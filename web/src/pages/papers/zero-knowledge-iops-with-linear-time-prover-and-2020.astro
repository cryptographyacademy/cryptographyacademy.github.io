---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1527';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Zero-Knowledge IOPs with Linear-Time Prover and Polylogarithmic-Time Verifier';
const AUTHORS_HTML = 'Jonathan Bootle, Alessandro Chiesa, Siqi Liu';

const CONTENT = `    <p class="text-gray-300">Jonathan Bootle jbt@zurich.ibm.com IBM Research – Zurich</p>

    <p class="text-gray-300">Alessandro Chiesa alexch@berkeley.edu UC Berkeley</p>

    <p class="text-gray-300">Siqi Liu sliu18@berkeley.edu UC Berkeley</p>

    <p class="text-gray-300">October 14, 2021</p>

    <h2 id="sec-2" class="text-2xl font-bold">Abstract</h2>

    <p class="text-gray-300">Interactive oracle proofs (IOPs) are a multi-round generalization of probabilistically checkable proofs that play a fundamental role in the construction of efficient cryptographic proofs.</p>

    <p class="text-gray-300">We present an IOP that simultaneously achieves the properties of zero knowledge, linear-time proving, and polylogarithmic-time verification. We construct a zero-knowledge IOP where, for the satisfiability of an <span class="math">N</span>-gate arithmetic circuit over any field of size <span class="math">\\Omega(N)</span>, the prover uses <span class="math">O(N)</span> field operations and the verifier uses <span class="math">\\mathsf{polylog}(N)</span> field operations (with proof length <span class="math">O(N)</span> and query complexity <span class="math">\\mathsf{polylog}(N)</span>). Polylogarithmic verification is achieved in the holographic setting for every circuit (the verifier has oracle access to a linear-time-computable encoding of the circuit whose satisfiability is being proved).</p>

    <p class="text-gray-300">Our result implies progress on a basic goal in the area of efficient zero knowledge. Via a known transformation, we obtain a zero knowledge argument system where the prover runs in linear time and the verifier runs in polylogarithmic time; the construction is plausibly post-quantum and only makes a black-box use of lightweight cryptography (collision-resistant hash functions).</p>

    <p class="text-gray-300"><strong>Keywords</strong>: interactive oracle proofs; zero knowledge; succinct arguments</p>

    <p class="text-gray-300">1 Introduction 1 1.1 Our results 2 1.2 Related work on probabilistic proofs 4 1.3 Related work on succinct arguments 4</p>

    <p class="text-gray-300">2 Techniques 6 2.1 Approach overview 6 2.2 Construction overview 7 2.3 From tensor-queries to point-queries in zero-knowledge 9 2.4 Tensor IOP for R1CS with semi-honest verifier zero knowledge 13 2.5 Hiding properties of linear codes 16 2.6 On bounded-query zero knowledge 17 2.7 Linear-time succinct arguments from linear-time IOPs 21</p>

    <p class="text-gray-300">3 Preliminaries 23 3.1 Interactive oracle proofs with special queries 23 3.2 Point queries and tensor queries 24 3.3 Robust proofs 24 3.4 Proximity proofs 25 3.5 Zero knowledge 25 3.6 Error-correcting codes 27 3.7 Zero knowledge codes 29</p>

    <p class="text-gray-300">4 Tensor IOP for R1CS with (semi)honest-verifier zero knowledge 31 4.1 Preliminaries 31 4.2 Our construction 33</p>

    <p class="text-gray-300">5 Algebraic reformulation of zero knowledge codes 38 5.1 Proof of Lemma 5.2 38 5.2 Proof of Lemma 5.1 39 5.3 Examples 40</p>

    <p class="text-gray-300">6 Tensor products of zero-knowledge codes 42</p>

    <p class="text-gray-300">7 Zero-knowledge codes with linear-time encoding 45 7.1 Preliminaries 45 7.2 Proof of Theorem 7.3 46 7.3 Setting parameters 47</p>

    <p class="text-gray-300">8 From tensor queries to point queries with zero knowledge 48 8.1 Construction 49 8.2 Proof of Lemma 8.2 50</p>

    <p class="text-gray-300">9 Main theorem 54 9.1 Step 1: robustification 55 9.2 Step 2: composition 56 9.3 Step 3: tensor queries to point queries 57</p>

    <p class="text-gray-300">A Robustification 58 B Proof composition 62 C Equivalence of zero-knowledge code definitions 66</p>

    <p class="text-gray-300">Acknowledgments 67</p>

    <p class="text-gray-300">References 67</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Zero knowledge proofs enable a prover to convince a verifier that a statement is true without revealing any further information about the statement <em>[x10]</em>. The main efficiency measures in a zero knowledge proof are the running time of the prover, the running time of the verifier, and the number of bits exchanged between them. A central goal in the study of zero knowledge proofs is to minimize the complexity of these measures.</p>

    <p class="text-gray-300">Motivated by real-world applications, researchers across multiple communities have invested significant effort, and made much progress, in designing efficient zero knowledge protocols.</p>

    <p class="text-gray-300">Several works (e.g., <em>[x15, x16, Cha+17, x21, x22, x23]</em>) focus on prover time. They construct zero-knowledge proofs for circuit satisfiability where the prover’s time complexity is linear in circuit size, which is asymptotically optimal. The drawback of these constructions is that communication complexity and verifier time also grow linearly with circuit size, which is undesirable for many applications.</p>

    <p class="text-gray-300">This drawback is inevitable because, even without zero knowledge, interactive proofs for hard languages with sublinear communication are unlikely <em>[x17, x18]</em>. Nevertheless, if instead of considering proofs we consider arguments <em>[x5]</em>, wherein soundness is required to hold only against efficient adversaries rather than all adversaries, then one can hope to avoid the drawback. For this, rather than studying proofs where zero knowledge holds computationally, one studies arguments where zero knowledge holds statistically.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Succinctness.</h4>

    <p class="text-gray-300">In a seminal work, Kilian <em>[x20]</em> constructed zero knowledge arguments that are succinct: communication complexity and verifier time are polylogarithmic in computation size. While these are essentially optimal, the prover in Kilian’s construction is a polynomial-time algorithm that fails to achieve the asymptotically-optimal linear time achieved via the aforementioned (non-succinct) zero knowledge proofs. Improving the prover time in succinct arguments has been a major goal in a subsequent line of work.</p>

    <p class="text-gray-300">Essentially all approaches for constructing succinct arguments follow the same high-level template: first construct a probabilistic proof in some proof model, and then make a black-box use of cryptography to compile the probabilistic proof into an argument system.</p>

    <p class="text-gray-300">A notable exception are zero-knowledge arguments with a linear-time prover and a polylogarithmic-time verifier. This goal is presently achieved as a consequence of the zero-knowledge argument in <em>[x4]</em> (see Section 1.3), but only via a non-black-box use of cryptography. This is unfortunate, as black-box results are a cryptographic “gold standard” that typically reflect a a deeper understanding, and over time lead to more efficient solutions (once each black-box is suitably optimized), when compared to non-black-box results.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Interactive oracle proofs.</h4>

    <p class="text-gray-300">The above status quo is due to inefficiencies in probabilistic proofs. Prior results on zero-knowledge argument systems with a linear-time prover and sublinear-time verifier rely on compiling interactive oracle proofs (IOPs) <em>[x3, x24]</em> into corresponding succinct arguments via a black-box use of suitable collision-resistant hash functions. The verifier time was sublinear rather than polylogarithmic due to the underlying IOP constructions. In particular, the following basic question has remained open:</p>

    <p class="text-gray-300">Do there exist zero-knowledge IOPs with a linear-time prover and a polylogarithmic-time verifier?</p>

    <p class="text-gray-300">In this paper we give a positive answer to this question for arithmetic computations over a large field, and obtain a corresponding black-box result about zero-knowledge succinct arguments. The question of whether an analogous result can be proved for boolean computations remains an exciting open problem.</p>

    <p class="text-gray-300">##</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">IOP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">encode circuit cost</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover cost</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier cost</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">query complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">zero-knowledge</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BCGGHJ17]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√n) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√n)</td>

            <td class="px-3 py-2 border-b border-gray-700">semi-honest zk</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BCG20]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(nε) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(nε)</td>

            <td class="px-3 py-2 border-b border-gray-700">not zk</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">this work</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">polylog(n) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">semi-honest zk</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 1: Comparison of known IOPs with a linear-time prover, for soundness error  <span class="math">1/2</span> . The parameters are for an  <span class="math">n</span> -gate arithmetic circuit defined over a field  <span class="math">\\mathbb{F}</span>  of size  <span class="math">\\Omega(n)</span> ; and  <span class="math">\\epsilon</span>  is any positive constant. Sublinear verification is achieved in the holographic setting (the verifier has oracle access to an encoding of the circuit).</p>

    <p class="text-gray-300">Our main result is an interactive oracle proof (IOP) [BCS16; RRR16] that simultaneously achieves zero knowledge, linear-time proving, and polylogarithmic-time verification (so also linear proof length and polylogarithmic query complexity). This implies the first zero-knowledge argument system with linear-time proving and polylogarithmic-time verification (and thus polylogarithmic communication complexity) that makes a black-box use of cryptography. Jumping ahead, our solution uses a lightweight cryptographic primitive (linear-time collision-resistant hash functions) for which there are plausibly post-quantum candidates.</p>

    <p class="text-gray-300">IOP for R1CS. Our IOP is for a standard generalization of arithmetic circuit satisfiability, known as rank-1 constraint satisfiability (R1CS), where the "circuit description" is given by coefficient matrices. This NP-complete problem is widely used in the probabilistic proof literature (and beyond) because it efficiently expresses arithmetic circuits <span class="math">^3</span>  and is convenient to use when designing a succinct argument.</p>

    <p class="text-gray-300">Definition 1 (informal). The R1CS problem asks: given a finite field  <span class="math">\\mathbb{F}</span> , coefficient matrices  <span class="math">A, B, C \\in \\mathbb{F}^{n \\times n}</span>  each containing at most  <span class="math">m = \\Omega(n)</span>  non-zero entries, <span class="math">^4</span>  and an instance vector  <span class="math">x \\in \\mathbb{F}^<em></span> , is there a witness vector  <span class="math">w \\in \\mathbb{F}^</em></span>  such that  <span class="math">z := (x, w) \\in \\mathbb{F}^n</span>  and  <span class="math">Az \\circ Bz = Cz</span> ? (Here “ <span class="math">\\circ</span> ” denotes the entry-wise product.)</p>

    <p class="text-gray-300">Merely checking the validity of a witness by directly checking the R1CS condition costs  <span class="math">O(m)</span>  field operations, so "linear time" for R1CS means computations that cost no more than  <span class="math">O(m)</span>  field operations.</p>

    <p class="text-gray-300">We construct an IOP for the R1CS problem with the parameters below. Our result significantly improves over prior linear-time IOPs, as summarized in Figure 1 and further discussed in Section 1.2.</p>

    <p class="text-gray-300">Theorem 1 (informal). There is a public-coin IOP for R1CS over any field  <span class="math">\\mathbb{F}</span>  of size  <span class="math">\\Omega(m)</span> , where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the prover uses  <span class="math">O(m)</span>  field operations;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- the verifier uses poly  $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\log m)$  field operations;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity is  <span class="math">O(\\log m)</span> ;</li>

      <li>proof length is  <span class="math">O(m)</span>  elements in  <span class="math">\\mathbb{F}</span> ;</li>

      <li>query complexity is  <span class="math">O(\\log m)</span> ;</li>

      <li>soundness error is  <span class="math">O(1)</span> .</li>

    </ul>

    <p class="text-gray-300">Moreover, the IOP is semi-honest-verifier zero-knowledge.</p>

    <p class="text-gray-300">Succinct argument for R1CS. The above theorem directly implies a zero-knowledge succinct argument with a linear-time prover and polylogarithmic-time verifier, obtained in a black-box way under standard</p>

    <p class="text-gray-300">cryptographic assumptions. The implication involves combining IOPs and linear-time collision resistant hashing <em>[x1]</em>, as reviewed in Section 2.7.</p>

    <p class="text-gray-300">In more detail, the result below relies on any linear-time collision-resistant hash function. Such hash functions are known to exist, e.g., under certain assumptions about finding short codewords in linear codes <em>[x2]</em>; moreover, these candidate hash functions are not known to be insecure against quantum adversaries, and so our succinct argument is plausibly post-quantum secure.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Theorem 2 (informal).</h6>

    <p class="text-gray-300">Using any linear-time collision-resistant hash function with security parameter <span class="math">\\lambda</span> as a black box, one can obtain an interactive argument for R1CS, over any field of size <span class="math">\\Omega(m)</span>, where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>time complexity of the prover is bounded by the cost of <span class="math">O(\\lambda+m)</span> field operations;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- time complexity of the verifier is bounded by the cost of $\\mathsf{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log m)$ field operations;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity is <span class="math">O(\\log m)</span>;</li>

      <li>communication complexity is <span class="math">\\mathsf{poly}(\\lambda,\\log m)</span> field elements;</li>

      <li>soundness error is <span class="math">O(1)</span>.</li>

    </ul>

    <p class="text-gray-300">Moreover, the argument is malicious-verifier zero-knowledge with private coins.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">On zero knowledge.</h4>

    <p class="text-gray-300">The notion of semi-honest-verifier zero-knowledge in Theorem 1 means that the IOP prover leaks no information to an honest IOP verifier for any choice of verifier randomness. This suffices for malicious-verifier zero-knowledge in Theorem 2, as explained in Section 2.7. We also present results (see Section 2.6) that allow us to prove a variant of Theorem 1 where the IOP satisfies the stronger property of bounded-query zero-knowledge, but at the cost of a sublinear verifier time rather than polylogarithmic. Bounded-query zero-knowledge is the hiding notion typically studied for PCPs <em>[x12]</em>, and often enables reductions in communication complexity when compiling the IOP into a succinct argument. The aforementioned loss in verifier time only comes from the fact that known constructions of “zero knowledge codes” with a linear-time encoder are probabilistic, and the loss could be avoided by derandomizing such families — overcoming this barrier remains an exciting open problem in coding theory.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">On sublinear verification.</h4>

    <p class="text-gray-300">The polylogarithmic verifier time in Theorem 1 is achieved in the holographic setting, which means that the verifier is given query access to a linear-length encoding of the coefficient matrices that is computable in linear time. Similarly, polylogarithmic verifier time in Theorem 2 is achieved in the preprocessing setting, which means that the verifier receives as input a short digest of the circuit that can be derived by anyone (in linear time). This follows a general paradigm wherein holographic proofs lead to preprocessing arguments <em>[x7, x8]</em>. Holography/preprocessing is necessary for sublinear verification in the general case because just reading the R1CS instance takes linear time.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Open questions.</h4>

    <p class="text-gray-300">Our IOP works for satisfiability problems over fields of at least linear size, as is the case for all known linear-time IOPs (see Section 1.2); obtaining analogous results for all fields, or just the boolean field, is open. Moreover, our IOP achieves constant soundness error, and the question of additionally achieving a sub-constant soundness error (ideally, negligible in a security parameter) is open. Finally, while our focus is asymptotic efficiency, we are optimistic that the ideas in this paper will facilitate further research that may additionally achieve good concrete efficiency. (We point to specific ideas for this in Section 2.) Initial progress in this direction has been made in subsequent work discussed in Section 1.3.</p>

    <p class="text-gray-300">1.2 Related work on probabilistic proofs</p>

    <p class="text-gray-300">As our main result concerns IOPs, we summarize prior works on probabilistic proofs that study related questions. Further connections to prior work are given in Section 2 where we overview our techniques.</p>

    <p class="text-gray-300">First we discuss a line of work on probabilistic proofs with linear proof length, a necessary condition for a linear-time prover (our goal). The first result was <em>[x1]</em>, which provides a PCP for boolean circuit satisfiability with linear proof length and sublinear query complexity; this is the only known result for PCPs, and constructing PCPs with linear proof length and polylogarithmic query complexity remains a major open problem. Subsequently, <em>[x2]</em> obtained a 3-round IOP for boolean circuit satisfiability with linear proof length and constant query complexity; and <em>[x26]</em> showed how to reduce the multiplicative constant in the proof length to arbitrarily close to <span class="math">1</span> at the cost of a slightly larger constant round complexity. None of these works study linear-time proving or sublinear-time verification. Here we omit a discussion of numerous works that achieve IOPs with linear size, but not linear prover time, for many other models of computation.</p>

    <p class="text-gray-300">Next, <em>[x1]</em> obtained a zero-knowledge IOP for arithmetic circuit satisfiability with linear-time prover and square-root-time verifier. Then <em>[x2]</em> improved the verifier time to any sublinear polynomial, but without zero knowledge. We improve on this by simultaneously achieving the properties of zero knowledge and polylogarithmic-time verifier. All of these results require working over a finite field of linear size, and analogous results for boolean circuits are not known. See Figure 1 for a table comparing these latter works.</p>

    <p class="text-gray-300">Recurring tools across many of these works, as well as this paper, include: the sumcheck protocol for tensor codes <em>[x22]</em>, proof composition (for PCPs <em>[x1]</em> and for IOPs <em>[x2]</em>), the linear-time sumcheck <em>[x29]</em>, and the use of codes without the multiplication property. (The property states that coordinate-wise multiplication of codewords yields codewords in a code whose relative distance is still good.)</p>

    <p class="text-gray-300">The main challenge in designing IOPs with linear-time provers is that one cannot use “useful” codes like the Reed–Solomon code since the encoding time is quasilinear. Instead, prior works resorted to using linear-time encodable codes (e.g., of Spielman <em>[x30]</em> or Druk–Ishai <em>[x12]</em>) that, unfortunately, do not have the multiplication property, which makes designing IOPs more difficult. (See <em>[x23, x24]</em> for more on why the multiplication property is useful in constructing probabilistic proofs.)</p>

    <p class="text-gray-300">Our zero-knowledge IOPs with linear-time prover and polylogarithmic-time verifier achieve a central goal in the area of probabilistic proofs, and to construct them we contribute several novel pieces all towards zero knowledge: (i) constructions of linear-time-encodable codes that satisfy a zero-knowledge property; (ii) structural results on the tensor products of codes that satisfy the zero-knowledge property; (iii) a tensor-query zero-knowledge holographic IOP for R1CS with low randomness complexity; (iv) results on zero knowledge preservation under proof composition.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">1.3 Related work on succinct arguments</h3>

    <p class="text-gray-300">Our main result implies a result on succinct arguments, and below we summarize prior works relevant to that.</p>

    <p class="text-gray-300">A non-black-box construction. A relaxation of Theorem 2 that makes a non-black-box use of cryptography is a straightforward implication of <em>[x1]</em>. In more detail, <em>[x1]</em> obtained a zero-knowledge argument system for arithmetic circuit satisfiability over linear-size fields where the prover runs in linear time and the verifier runs in square-root time. The verifier time can be reduced to polylogarithmic, while preserving zero knowledge and a linear-time prover, by using any zero-knowledge succinct argument with subquadratic prover time to prove that the “outer” verifier would have accepted. A similar implication, however from the non-zero-knowledge succinct argument in <em>[x2]</em>, is described in subsequent work <em>[x20, x21]</em>, and thus we refer the reader to that work for more details on these non-black-box</p>

    <p class="text-gray-300">approaches. (We remark that <em>[x11, x10]</em> additionally contribute ideas and implementations to improve the concrete efficiency of argument systems with a linear-time prover and sublinear-time verifier.)</p>

    <p class="text-gray-300">Black-box constructions from probabilistic proofs. Essentially all approaches for constructing succinct arguments follow this high-level template: first construct a probabilistic proof in some proof model, and then make a black-box use of cryptography to compile the probabilistic proof into an argument system. The first step alone typically costs more than linear time because it involves (among other things) using the Fast Fourier Transform (FFT) to encode the computation as a polynomial.</p>

    <p class="text-gray-300">Several works <em>[x2, x1, x12, x13, x14, x15, x16, x17]</em> construct various forms of succinct arguments <em>without FFTs</em> by first constructing linear-time probabilistic proofs in certain “algebraic” models and then compiling these into arguments by using homomorphic commitments. However, the cryptography introduces quasilinear work for the prover, usually to perform a linear number of multi-exponentiations over a cryptographically-large group (which translates to a quasilinear number of group operations for the prover); we refer the reader to follow up work <em>[x11, x10]</em> for a detailed discussion of these quasilinear costs in terms of computation size and the security parameter. In sum, the above line of works has contributed among the best asymptotic prover times for succinct arguments (as well as excellent concrete efficiency), but the cryptography has precluded linear-time provers.</p>

    <p class="text-gray-300">Bootle et al. <em>[x3]</em> observe that Kilian’s approach to succinct arguments introduces only linear cryptographic costs, when the collision-resistant hash function used for the compilation is suitably instantiated. (We elaborate on this in Section 2.7.) Prior work leveraged this observation to construct argument systems with linear-time prover and sublinear-time verifier, given a collision-resistant hash function as a black box.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>[x3]</em> achieves an honest-verifier zero knowledge argument system for arithmetic circuit satisfiability with a communication complexity of <span class="math">O(\\sqrt{n})</span>, where the prover performs <span class="math">O(n)</span> field operations and hash computations while the verifier performs <span class="math">O(\\sqrt{n})</span> field operations and hash computations.</li>

      <li><em>[x2]</em> achieves, for every <span class="math">\\epsilon&gt;0</span>, an argument system for R1CS with a communication complexity of <span class="math">O(n^{\\epsilon})</span>, where the prover performs <span class="math">O(n)</span> field operations and hash computations while the verifier performs <span class="math">O(n^{\\epsilon})</span> field operations and hash computations. No zero knowledge property is achieved in this work.</li>

    </ul>

    <p class="text-gray-300">There are linear-time candidates for the hash function <em>[x1]</em>, leading to a linear-time prover.</p>

    <p class="text-gray-300">In both cases the technical core is the construction of IOPs with a linear-time prover, but, as discussed in Section 1.2, these prior works only achieved sublinear query complexity thereby, after compilation, falling short of the goal of polylogarithmic communication complexity. No prior work thus achieves Theorem 2.</p>

    <p class="text-gray-300">Our main result (Theorem 1) offers improved IOP constructions, and we are then able to improve the state of the art of succinct arguments that make a black-box use of cryptography (Theorem 2).</p>

    <p class="text-gray-300">2 Techniques</p>

    <p class="text-gray-300">We overview our approach towards Theorem 1 in Section 2.1 and the construction in Section 2.2. We provide additional details behind different aspects of the construction in Sections 2.3, 2.6, and 2.7. Finally, in Section 2.7 we explain how our result about zero-knowledge succinct arguments (Theorem 2) is a direct implication of our result about zero-knowledge IOPs (Theorem 1).</p>

    <p class="text-gray-300">Throughout, recall that an IOP is a proof model in which a prover and a verifier interact over multiple rounds, and in each round the prover sends a proof message and the verifier replies with a challenge message. The verifier has query access to all received proof messages, in the sense that it can query any of the proof messages at any desired location. The verifier decides to accept or reject depending on its input, its randomness, and answers to its queries. The main information-theoretic efficiency measures in an IOP are proof length (total size of all proof messages) and query complexity (number of read locations across all proof messages), while the main computational efficiency measures are prover time and verifier time.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.1 Approach overview</h3>

    <p class="text-gray-300">We provide an overview of our approach to Theorem 1.</p>

    <h5 id="sec-13" class="text-base font-semibold mt-4">Review: proof composition.</h5>

    <p class="text-gray-300">Many constructions of PCPs rely on proof composition <em>[x1]</em> to achieve the desired goal by combining an “outer” PCP and an “inner” PCP with suitable properties. The composed PCP (roughly) has the prover complexity of the outer PCP, and the verifier complexity of the inner PCP. Informally, the new PCP string consists of the outer PCP string and also, for every choice of randomness of the outer PCP verifier, an inner PCP string attesting that the outer PCP verifier would have accepted the local view of the outer PCP string induced by that choice of randomness. Soundness of the composed PCP requires the outer PCP to be robust and the inner PCP to be a proximity proof.</p>

    <p class="text-gray-300">Proof composition extends to the IOP model <em>[x2]</em>: the outer and inner proof systems can be IOPs instead of PCPs, and must satisfy corresponding notions of robustness and proximity; moreover, composition is more efficient because the inner IOP has only to be invoked once rather than for every choice of randomness of the outer IOP verifier (this is because, after running the outer IOP, the verifier can simply send the chosen randomness to the prover and then run the inner IOP on that randomness). Proof composition of IOPs also plays a central role in constructions of IOPs, and we also use it in our construction, as described next.</p>

    <h5 id="sec-14" class="text-base font-semibold mt-4">Our setting.</h5>

    <p class="text-gray-300">Using proof composition in our setting involves several considerations.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Zero knowledge. We want the composed IOP to be semi-honest-verifier zero-knowledge, and for this, one can prove that it suffices for the outer IOP to be semi-honest-verifier zero-knowledge, regardless of any zero knowledge properties of the inner IOP. We prove this and other properties about zero knowledge within proof composition in Appendix B.</li>

      <li>Prover time. We want the prover of the composed IOP to run in linear time. The composed prover time is the sum of the outer IOP prover time and the inner IOP prover time. This means that the outer IOP prover must run in time that is linear, e.g., in the R1CS instance. The requirement on the inner IOP prover is less straightforward: the inner IOP prover attests tp a computation related to the outer IOP verifier. For example, if the outer IOP verifier runs in cube-root time (relative to the R1CS instance) then we can afford an inner IOP prover that runs in up to cubic time (as the cubic blow up applied to a cube-root time gives linear time</li>

    </ul>

    <p class="text-gray-300">overall). In other words, we require the polynomial blow up of the inner IOP prover time to be made up by the savings offered by the outer IOP verifier time.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Verifier time.</em> We want the verifier of the composed IOP to run in polylogarithmic time. The composed verifier time equals the time of the inner IOP verifier when used to test that the outer IOP verifier would have accepted. At minimum, the inner IOP verifier needs to read the description of the outer IOP verifier computation, which consists of its input instance (e.g., the R1CS public input) and its randomness. This implies that the outer IOP verifier can have at most polylogarithmic randomness complexity, and also implies that the compound savings in running time of the outer IOP verifier and inner IOP verifier must lead to a polylogarithmic running time.</li>

    </ul>

    <p class="text-gray-300">The above considerations suggest that one approach that suffices is the following: (i) an inner IOP of proximity for general computations with polylogarithmic verifier time; and (ii) an outer IOP for R1CS that is semi-honest-verifier zero-knowledge, is robust, has a linear prover time, has polylogarithmic randomness complexity, and has a verifier time that is sufficiently small so that we can afford the blowup incurred by the inner IOP prover time. For the inner IOP of proximity we choose the state-of-the-art PCP of proximity for <span class="math">\\mathsf{NTIME}(T)</span> due to Mie <em>[x20]</em> (discussed later). Our technical contribution is constructing a suitable outer IOP. As the blowup incurred by the inner PCP prover time will be polynomial, we need the outer IOP verifier to run in time that is sufficiently sublinear. We now outline the challenges that arise given prior work.</p>

    <p class="text-gray-300">Challenges. There are two natural paths to explore in order to construct the outer IOP.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>One path would be to somehow construct the desired outer IOP by starting from the semi-honest-verifier zero-knowledge IOP for arithmetic circuit satisfiability in <em>[x1]</em>, which works over any field of linear size and has linear prover time and square-root verifier time. This would require addressing some challenges. First, we would need to robustify the IOP, but robustification techniques typically work for verifiers with constant query complexity (possibly over a large alphabet), and so one would have to adapt <em>[x1]</em> for this setting. Second, the IOP verifier in <em>[x1]</em> would have to be derandomized to achieve polylogarithmic randomness complexity. Third, we cannot afford more than a quadratic blow up in the inner IOP prover time because the verifier in <em>[x1]</em> runs in square-root time.</li>

      <li>An alternative path would be to somehow construct the desired outer IOP by starting from the IOP for R1CS in <em>[x2]</em>, which over any field of size <span class="math">O(m)</span> has prover time <span class="math">O(m)</span> and verifier time <span class="math">O(m^{\\epsilon})</span> for any a-priori fixed constant <span class="math">\\epsilon&gt;0</span>. This would require somehow additionally achieving zero knowledge (not a goal in <em>[x2]</em>), and moreover would still require addressing the robustification and derandomization challenges mentioned above. On the other hand, because we can choose <span class="math">\\epsilon</span> to be small enough, we can afford an inner proximity proof whose prover runs in any fixed polynomial time (in particular, the PCP of proximiy in <em>[x20]</em> would suffice).</li>

    </ol>

    <p class="text-gray-300">This paper. We believe that both paths are plausible. In this paper we use that an approach that (roughly) follows the second path, because we can use an off-the-shelf inner proximity proof and we can focus our attention solely on constructing an appropriate outer IOP. Moreover, we believe that building on <em>[x1]</em> will contribute new understanding of zero knowledge techniques that are likely to be useful elsewhere, and will lead to a simpler exposition due to the modular nature of that construction.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">2.2 Construction overview</h3>

    <p class="text-gray-300">We outline the steps in the construction of an IOP that satisfies Theorem 1. We elaborate on each of these steps in subsequent subsections.</p>

    <h5 id="sec-16" class="text-base font-semibold mt-4">Review: the tensor-to-point approach.</h5>

    <p class="text-gray-300">The IOP for R1CS in <em>[x1]</em> is obtained in two steps: first construct a <em>tensor IOP</em> for R1CS with linear prover time and constant query complexity; then apply a compiler that transforms any tensor IOP into a standard IOP. In a tensor IOP, the verifier may make multiple <em>tensor queries</em> directly to a proof message <span class="math">\\Pi</span>, each of the form <span class="math">q=(q_{1},\\ldots,q_{t})</span> and receiving the corresponding answer <span class="math">v:=\\langle\\otimes_{i}q_{i},\\Pi\\rangle</span>. This differs from a standard IOP, where the verifier makes <em>point queries</em>, that is, it queries single locations of proof messages. As mentioned in Section 2.1, the resulting (point-query) IOP in <em>[x1]</em> has prover time <span class="math">O(m)</span> and verifier time <span class="math">O(m^{\\epsilon})</span> for any a-priori fixed constant <span class="math">\\epsilon&gt;0</span>. (Here <span class="math">m</span> is the maximum number of non-zero entries in an R1CS coefficient matrix.)</p>

    <h5 id="sec-17" class="text-base font-semibold mt-4">Steps in our proof.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We take an analogous two-step approach as in <em>[x1]</em>, except that we additionally achieve semi-honest-verifier zero knowledge, while still achieving a prover time of <span class="math">O(m)</span> and reducing the verifier time from <span class="math">O(m^{\\epsilon})</span> to $\\poly(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log m)<span class="math">. (Here </span>x$ is the instance vector of the R1CS instance.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <em>Step 1: tensor IOP for R1CS with zero knowledge.</em> Given any finite field <span class="math">\\mathbb{F}</span>, we construct a tensor IOP for R1CS over <span class="math">\\mathbb{F}</span> that is semi-honest-verifier zero-knowledge, has soundness error $O(\\frac{m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">, has prover time </span>O(m)<span class="math">, and has verifier time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log m)<span class="math">; moreover, the verifier makes </span>O(1)<span class="math"> tensor queries (and also interacts with the prover in a </span>O(\\log m)$-round interactive proof). In Section 2.4 we outline the main ideas that we use to additionally achieve zero knowledge compared to the tensor IOP for R1CS in <em>[x1]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Step 2: from tensor IOPs to standard IOPs while preserving zero knowledge.</em> Given any finite field <span class="math">\\mathbb{F}</span>, we construct a compiler that maps a tensor IOP over the field <span class="math">\\mathbb{F}</span> into a standard IOP <em>while preserving the zero knowledge property</em>; moreover, efficiency measures are preserved up to overheads in the dimension of the tensor and the query complexity of the input tensor IOP. In Section 2.3 we outline the main ideas that we use compared to the tensor-query to point-query compiler in <em>[x1]</em> (which does not preserve zero knowledge and leads to a large verifier time).</li>

    </ul>

    <p class="text-gray-300">Theorem 1 follows by applying the compiler in the second step to the tensor IOP for R1CS in the first step, as shown diagrammatically in Figure 2. Below we highlight two aspects of our construction of the compiler.</p>

    <h5 id="sec-18" class="text-base font-semibold mt-4">(a) Proof composition.</h5>

    <p class="text-gray-300">Differing from the approach overview in Section 2.1, the proof composition step actually happens within the tensor-query to point-query compiler rather than as a final step. This choice leads to a compiler that preserves efficiency measures of the tensor IOP up to constants (of independent interest), and moreover invokes the inner proximity proof on a linear computation rather than an arbitrary computation.</p>

    <h5 id="sec-19" class="text-base font-semibold mt-4">(b) Linear codes that are linear-time encodable and zero knowledge.</h5>

    <p class="text-gray-300">A key ingredient in the construction of our compiler is <em>tensor codes that simultaneously are linear-time encodable and satisfy a zero-knowledge property</em> (informally, codewords do not reveal any information about the underlying message when queried in a restricted way). For this, we establish structural properties of zero-knowledge codes and prove that they are preserved under tensor products, which reduces the problem to constructing a linear-time encodable zero-knowledge code to act as the base of the tensor product code. We obtain a suitable base code via an explicit (deterministic) construction of zero-knowledge code based on <em>[x23]</em> codes, which protect against a single malicious query. This is enough to prove zero-knowledge against semi-honest verifiers in Theorem 1, which suffices for our main theorem. We also give a probabilistic construction of zero-knowledge codes based on <em>[x10]</em> codes which do not reveal information on the underlying message even when the verifier makes queries to a constant fraction of codeword entries. This allows us to prove a variation of Theorem 1 with the stronger property of <em>bounded-query zero-knowledge</em>. We review notions of zero knowledge for linear codes in Section 2.5, and then describe our results about zero-knowledge codes in Section 2.6.</p>

    <h5 id="sec-20" class="text-base font-semibold mt-4">Concrete efficiency.</h5>

    <p class="text-gray-300">We do not make any claims regarding the concrete efficiency of our construction. That said, we are optimistic that the ideas introduced in this work can lead to improved constructions with the</p>

    <p class="text-gray-300">same asymptotic efficiency but better concrete efficiency. In particular, we believe that further research into zero-knowledge linear-time-encodable codes and further research in specializing the proof composition step to the specific outer statement (a certain linear computation) may significantly improve efficiency. Subsequent work has made progress in this direction [GLSTW21].</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 2: Diagram of our construction of the IOP for Theorem 1.</p>

    <p class="text-gray-300">We generically transform any tensor-query IOP into a corresponding point-query IOP, while preserving zero knowledge. The transformation is parametrized by a zero-knowledge linear code (a notion explained in more detail in Section 2.5) and outputs a point-query IOP that is bounded-query zero knowledge, meaning that malicious queries up to a fixed query bound do not leak any information. In contrast, the tensor-query IOP being transformed is only required to satisfy a weaker notion of zero knowledge, called semi-honest-verifier zero knowledge, that we describe further below. Here, “ <span class="math">(\\mathbb{F}, k, t)</span> -tensor IOP” means that each tensor-IOP query  <span class="math">q = (q_1, \\ldots, q_t)</span>  lies in  <span class="math">(\\mathbb{F}^k)^t</span> .</p>

    <p class="text-gray-300">Theorem 3 (informal). There is an efficient transformation that takes as input a tensor-query IOP and a linear code, and outputs a point-query IOP that has related complexity parameters, as summarized below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input IOP: an  <span class="math">(\\mathbb{F}, k, t)</span> -tensor IOP for a relation  <span class="math">R</span>  with soundness error  <span class="math">\\epsilon</span> , round complexity  <span class="math">\\mathsf{rc}</span> , proof length  <span class="math">l</span> , query complexity  <span class="math">\\mathfrak{q}</span> , prover arithmetic complexity  <span class="math">\\mathsf{tp}</span> , and verifier arithmetic complexity  <span class="math">\\mathsf{tv}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Input code: a linear code  <span class="math">\\mathcal{C}</span>  over  <span class="math">\\mathbb{F}</span>  with rate  <span class="math">\\rho = \\frac{k}{n}</span> , relative distance  <span class="math">\\delta = \\frac{d}{n}</span> , encoding time  <span class="math">\\theta(k) \\cdot k</span> , and description size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ . (The description of a linear code consists of a specification of the circuit used to compute the encoding function, including any random coins used to generate the circuit.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, when the tensor-query IOP is semi-honest-verifier zero knowledge the following also holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if the code  <span class="math">\\mathcal{C}</span>  is 1-query zero-knowledge, then the point-query IOP is semi-honest-verifier zero knowledge;</li>

      <li>if the code  <span class="math">\\mathcal{C}</span>  is  <span class="math">b</span> -query zero-knowledge, then the point-query IOP is  <span class="math">b</span> -query zero knowledge.</li>

    </ul>

    <p class="text-gray-300">Finally, the transformation preserves holography up to the multiplicative encoding overhead  <span class="math">\\theta</span>  of  <span class="math">\\mathcal{C}</span>  and terms that depend on  <span class="math">\\rho</span>  and  <span class="math">t</span> : if the indexer for the input tensor-query IOP runs in time  <span class="math">\\mathfrak{t}\\mathfrak{i}</span>  and produces an index of length  <span class="math">\\mathfrak{l}\\mathfrak{i}</span> , then the indexer for the output point-query IOP runs in time  <span class="math">\\mathfrak{t}\\mathfrak{i} + O_{\\rho ,t}(\\mathfrak{q}\\cdot \\mathfrak{l}\\mathfrak{i})\\cdot \\theta (k)</span> .</p>

    <p class="text-gray-300">The formal statement and its proof are in Section 8. We now explain the main ideas behind our compiler.</p>

    <p class="text-gray-300">Starting point: an inefficient compiler that breaks zero knowledge. Our starting point is the code-based compiler of [BCG20], which takes as input a tensor-query IOP  <span class="math">(\\mathbf{P},\\mathbf{V})</span>  and a linear error-correcting code  <span class="math">\\mathcal{C}</span>  and produces a corresponding point-query IOP  <span class="math">(\\hat{\\mathbf{P}},\\hat{\\mathbf{V}})</span> . We briefly summarize how the compiler works.</p>

    <p class="text-gray-300">First, the point-query IOP simulates the tensor-query IOP with the modification that: (i) each proof oracle  <span class="math">\\Pi \\in \\mathbb{F}^{k^t}</span>  is replaced by its encoding  <span class="math">\\hat{\\Pi} \\in \\mathbb{F}^{n^t}</span>  using the tensor product code  <span class="math">\\mathcal{C}^{\\otimes t}</span> ; (ii) instead of making tensor queries to the proof oracles directly, the new verifier  <span class="math">\\hat{\\mathbf{V}}</span>  sends tensor queries  <span class="math">q^{(s)}</span>  to the prover, who replies with the answers  <span class="math">v^{(s)}</span> . Second, the new prover  <span class="math">\\hat{\\mathbf{P}}</span>  and new verifier  <span class="math">\\hat{\\mathbf{V}}</span>  engage in a consistency test subprotocol to ensure that the answers  <span class="math">v^{(s)}</span>  (which may have been computed dishonestly) are consistent with the proofs  <span class="math">\\Pi</span> . The consistency test incorporates a proximity test to make sure that each proof message  <span class="math">\\hat{\\Pi}</span>  is close to a valid encoding of some proof message  <span class="math">\\Pi</span>  (as a malicious prover may send messages which are far from  <span class="math">\\mathcal{C}^{\\otimes t}</span> ). As part of the consistency check, the prover sends the verifier "folded" proof messages  <span class="math">c_{j}^{(s)} = \\langle \\otimes_{i \\leq j} q_{i}^{(s)}, \\Pi \\rangle</span>  encoded under lower-dimensional tensor codes  <span class="math">\\mathcal{C}^{\\otimes t - j}</span> . The proximity test works similarly, using random linear combinations of length  <span class="math">k</span>  sampled by the verifier instead of structured tensor queries. In both cases, the verifier checks linear relations between successive encodings  <span class="math">c_{j}^{(s)}</span>  and  <span class="math">c_{j + 1}^{(s)}</span>  by making  <span class="math">O(k)</span>  point queries.</p>

    <p class="text-gray-300">This compiler preserves prover time up to the encoding overhead  <span class="math">\\theta(k)</span>  as in our Theorem 3, but has two shortcomings. The compiler does not preserve zero-knowledge, even if the tensor IOP to be compiled is zero knowledge. Moreover, the output IOP has query complexity  <span class="math">\\Omega(k)</span>  and verifier complexity  <span class="math">\\Omega(k)</span> , which does not suffice for Theorem 3 (we can at most afford a polylogarithmic dependence in  <span class="math">k</span> ). Below we elaborate on how we overcome these shortcomings for zero-knowledge (Section 2.3.1) and for efficiency (Section 2.3.2).</p>

    <p class="text-gray-300">We explain semi-honest verifier zero knowledge (the property of the tensor IOP used to achieve zero knowledge for the output IOP) and then how we preserve zero knowledge in the compiler.</p>

    <p class="text-gray-300">Semi-honest-verifier zero knowledge. Here, "semi-honest" means that there exists a simulator that (perfectly) simulates the honest verifier's view for any fixed choice of the honest verifier's randomness.[12] This requirement is stronger than honest-verifier zero-knowledge, where the simulator must simulate the honest verifier's view for a random choice of its randomness; also, this requirement is weaker than the standard definition of zero-knowledge for IOPs, in which the verifier may deviate from the protocol and make arbitrary queries to the received oracles up to some query bound. Nevertheless, this notion suffices for our compilation procedure, which will produce point-query IOPs with zero-knowledge against semi-honest verifiers or against verifiers making a bounded number of point queries (depending on the zero-knowledge property of the code).</p>

    <p class="text-gray-300">Approach for zero knowledge. We need to ensure that, in our compiler, if the tensor-query IOP given as input is semi-honest-verifier zero knowledge then, depending on the zero knowledge property of the code  <span class="math">\\mathcal{C}</span> , the output point-query IOP is either semi-honest verifier zero knowledge or bounded-query zero knowledge. This implication does not hold for the compiler of [BCG20] because, when using a (non-zero-knowledge) linear code  <span class="math">\\mathcal{C}</span> , a point query to any encoded proof message  <span class="math">\\hat{\\Pi}</span>  or folded proof message  <span class="math">c_{j}^{(s)}</span>  leaks information about  <span class="math">\\Pi</span> . We address the information leaked by  <span class="math">\\hat{\\Pi}</span>  and  <span class="math">c_{j}^{(s)}</span>  in two ways.</p>

    <p class="text-gray-300">We ensure that the folded proof messages <span class="math">c_{j}^{(s)}</span> do not leak any information by leveraging the fact that the consistency test of <em>[x1]</em> is about a linear relation, and thus can be invoked on a random shift of the instance of interest. In more detail, the usual approach to making the messages in such a subprotocol zero-knowledge is to mask the input message as <span class="math">f=\\gamma\\Pi+\\Xi</span>, where <span class="math">\\Xi</span> is a random message sent by the prover and <span class="math">\\gamma</span> is a random challenge sent by the verifier after that, and then run the consistency test on the encoding <span class="math">c=\\gamma\\hat{\\Pi}+\\hat{\\Xi}</span> <em>[x2]</em>. (The claimed tensor-query answers <span class="math">v^{(s)}</span> need to be adjusted accordingly too to account for the contribution of <span class="math">\\Xi</span>.) Informally, this enables the simulator to randomly sample <span class="math">c</span> and honestly run the <em>[x1]</em> consistency test protocol. Queries on the resulting messages <span class="math">c_{j}^{(s)}</span> do not reveal any information, since they are derived from <span class="math">c</span>, which is a random tensor codeword. Further, we do not require any zero-knowledge properties from the consistency test.</p>

    <p class="text-gray-300">The simulator must still simulate the answers to point queries on <span class="math">\\Xi</span> by querying <span class="math">\\hat{\\Pi}</span> instead. To avoid information leakage from the encoded proofs <span class="math">\\hat{\\Pi}</span>, we use a linear code <span class="math">\\mathcal{C}</span> with bounded-query zero-knowledge. This is similar to the notion for IOPs, and means that queries to a codeword up to a fixed query bound do not leak any information. The <em>[x1]</em> compiler uses tensor products of codes, and to achieve semi-honest-verifier zero knowledge for the output IOP, it is important that the tensor product code <span class="math">\\mathcal{C}^{\\otimes t}</span> is <span class="math">1</span>-query zero-knowledge. Furthermore, to achieve <span class="math">b</span>-query zero knowledge for the output IOP, it is important that the tensor product code <span class="math">\\mathcal{C}^{\\otimes t}</span> is also zero-knowledge against <span class="math">b</span> queries. This leads to the problem of finding a zero-knowledge code which is encodable in linear time, which we discuss in Section 2.6.3, and showing that the zero-knowledge property of codes is preserved under tensor products, which we discuss in Section 2.6.2.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">2.3.2 Improving efficiency</h4>

    <p class="text-gray-300">Our modifications to the compiler of <em>[x1]</em> to preserve zero-knowledge do not affect its efficiency; in particular, if the zero-knowledge code <span class="math">\\mathcal{C}^{\\otimes t}</span> has a linear-time encoding, then the compiler preserves linear arithmetic complexity of the prover. However, when applied to our <span class="math">(\\mathbb{F},k,t)</span>-tensor IOP with <span class="math">n=\\Theta(k^{t})</span>, the improved consistency test has query complexity <span class="math">O(k)</span>, prover arithmetic complexity <span class="math">O(k^{t})</span>, and verifier arithmetic complexity <span class="math">O(k)</span>. Though the query complexity and verifier complexity can be improved by increasing <span class="math">t</span>, they remain sublinear in <span class="math">n</span>, which does not suffice for Theorem 3. To prove Theorem 3, we must reduce the query complexity from <span class="math">\\Omega(k)</span> to <span class="math">O(1)</span> and the verifier complexity from <span class="math">\\Omega(k)</span> to <span class="math">\\mathsf{poly}(\\log k)</span>.</p>

    <p class="text-gray-300">We achieve these goals using interactive proof composition and derandomization techniques. First, we strengthen the improved consistency test through robustification, and then use interactive proof composition for IOPs <em>[x1]</em>. This reduces the query complexity so that it is independent of <span class="math">k</span>, and makes the verifier complexity depend only on the randomness complexity of the consistency test verifier. Next, we show that linear prover complexity is preserved. Finally, we explain how to derandomize the consistency test to obtain the desired verifier complexity. (It remains an interesting question whether one can also achieve proof length that approaches witness length, the efficiency goal studied in <em>[x24]</em> via related techniques.)</p>

    <p class="text-gray-300">Interactive proof composition. Interactive proof composition involves an “outer” IOP that is robust and is for the desired relation, and an “inner” IOP of proximity that is for a relation about the outer IOP’s verifier. At a high level, we wish to apply this with the zero-knowledge consistency test from Section 2.3.1 as the outer IOP, and the PCP of proximity of <em>[x21]</em> as the inner IOP. This requires some care, in part because the consistency check is not robust, and also because our target parameters do not leave much wiggle room. Below, we elaborate on how we robustify the outer protocol, and how we perform proof composition.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Robustification. Any IOP can be generically robustified by encoding each proof symbol in every round</li>

    </ul>

    <p class="text-gray-300">via an appropriate error-correcting code: if the IOP has query complexity q then this transformation yields a robustness parameter <span class="math">\\alpha=O(1/\\mathsf{q})</span> (over the alphabet of the code). This is a straightforward generalization of robustifications for IPs (each prover message in each round is encoded) and for PCPs (each proof symbol of the PCP is encoded). This also extends to robustifying IOPPs, in which case each symbol of the witness whose proximity is being proved is also encoded (and this modifies the relation proved by the IOPP slightly). For convenience, we state and prove this generic robustification in Appendix A.</p>

    <p class="text-gray-300">Superficially, this robustification seems insufficient to prove Theorem 3 because zero-knowledge consistency test from Section 2.3.1 has sublinear query complexity <span class="math">\\mathsf{q}=O(k)=O(n^{1/t})</span>, which would lead to a robustness parameter that is sub-constant. However, fortunately, the queries are <em>bundled</em>: the verifier always queries entire sets of <span class="math">O(n^{1/t})</span> locations, so the IOPP can be restated as a <em>constant-query</em> IOPP over the large alphabet <span class="math">\\mathbb{F}^{O(n^{1/t})}</span>. To robustify an IOPP over such a large alphabet, we need to use a code with linear-time encoding such as <em>[x20]</em> (here zero-knowledge codes are not essential) in order to preserve the linear complexity of the prover. This gives us an IOPP for tensor queries with prover complexity <span class="math">O(n)</span>, verifier complexity <span class="math">O(n^{1/t})</span>, query complexity <span class="math">O(n^{1/t})</span> over the alphabet <span class="math">\\mathbb{F}</span>, constant soundness error, and, most importantly, a <em>constant robustness parameter</em> <span class="math">\\alpha</span>. We are now ready for the next step, proof composition.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Composition.</em> Interactive proof composition <em>[x1]</em> applies to any outer IOP that is robust and inner IOP that is a proof of proximity. If the outer IOP is a proof of proximity (as is the case when using the IOPP obtained above) then the composed IOP is also a proof of proximity; similarly, if the inner IOP is robust then the composed IOP is also robust. We state this generic proof composition in Appendix B.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We apply proof composition as follows: (i) the outer proof system is the robust zero-knowledge IOPP for tensor queries obtained above; (ii) the inner proof system is the PCP of proximity for <span class="math">\\mathsf{NTIME}(T)</span> due to Mie <em>[x18]</em> (which achieves any constant soundness error and constant proximity parameter, with proof length $\\tilde{O}(T(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbbm{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">, query complexity </span>O(1)<span class="math">, prover time </span>\\mathsf{poly}(T(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbbm{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">, and verifier time </span>\\mathsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbbm{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log T(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbbm{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Informally, the new verifier in the composed proof system runs the interactive phase of the IOPP for tensor queries and then, rather than running the query phase of the outer IOPP, runs the PCPP verifier of <em>[x18]</em> to check that the witness is close to a tensor encoding of a message that is consistent with all the answers to the tensor queries. This reduces the query complexity from <span class="math">O(n^{1/t})</span> to <span class="math">O(1)</span> queries.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">Preserving prover complexity.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We discuss prover complexity for the composed proof system. The cost of the prover in the composed IOP is <span class="math">O(n)</span> field operations to run the prover of the robust IOPP for tensor queries plus $\\mathsf{poly}(T(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbbm{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math"> bit operations to run the PCPP prover in <em>[x18]</em>. In our case, the </span>\\mathsf{NTIME}(T)<span class="math"> relation being checked is the decision predicate for the verifier in the robust IOPP, so that </span>T=O(n^{1/t})<span class="math"> (times smaller factors depending on </span>\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> since </span>T<span class="math"> refers to bit operations rather than field operations). If we take the tensor power </span>t\\in\\mathbb{N}<span class="math"> to be a sufficiently large constant, then we can ensure that the prover time in the PCPP of <em>[x18]</em>, which is polynomial in </span>O(n^{1/t})<span class="math">, is dominated by </span>O(n)$ field operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Reducing verifier complexity.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We discuss verifier complexity for the composed proof system. The cost of the verifier in the composed IOP is dominated by $\\mathsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbbm{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log T(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbbm{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math"> bit operations, the time to run the PCPP verifier in <em>[x18]</em>. From our discussion of prover complexity for the composed proof system, we know that </span>T=O(n^{1/t})<span class="math"> and so </span>\\log T(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbbm{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=O(\\log n)<span class="math">. We are thus left to discuss </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbbm{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Here </span>\\mathbbm{x}<span class="math"> is the state used to <em>describe</em> (not run) the computation of the decision predicate for the verifier in the robust IOPP. The description consists of: (a) the description of the code </span>\\mathcal{C}$ used for the tensor encoding; (b) the description of the tensor queries whose answers are being checked; and (c) the <em>verifier randomness</em> for the robust IOPP.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The second term depends on the tensor queries, but for simplicity here we will ignore it because in our application all the tensor queries can be described via <span class="math">O(t\\log n)</span> elements, again a low-order term. The first term depends on the choice of code <span class="math">\\mathcal{C}</span>, so we keep it as a parameter. As for the last term, the randomness complexity of the robust consistency check is <span class="math">O(\\mathsf{q}\\cdot k\\cdot t)</span>, due to the random linear combinations used in the proximity test of <em>[x1]</em>, whose randomness complexity is unchanged by robustification. In sum, the cost of the verifier in the composed system is $\\mathsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log n,\\mathsf{q}\\cdot k\\cdot t)$ bit operations. This leads to a sublinear verifier complexity and does not suffice for Theorem 3.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fortunately, these linear combinations can be derandomized so to reduce their description size to <span class="math">O(t)</span> (a low-order term), as we now explain. The linear combinations are used in the soundness analysis of the <em>[x1]</em> proximity test as part of a “distortion statement”: if any member of a collection of messages is far (in Hamming distance) from a linear code, then a random linear combination of those messages is also far from the code, except with some small, bounded, failure probability. Ben-Sasson et al. <em>[x3]</em> prove distortion statements for linear combinations of the form <span class="math">\\zeta=(\\alpha^{1},\\alpha^{2},\\alpha^{3},\\ldots,\\alpha^{k})</span> for a uniformly random <span class="math">\\alpha\\in\\mathbb{F}</span>, at the cost of a tolerable increase in failure probability, and thus, in the soundness error of the proximity test. This allows us to dramatically reduce the number of random field elements used in the proximity test from <span class="math">O(\\mathsf{q}\\cdot k\\cdot t)</span> to <span class="math">O(\\mathsf{q}\\cdot t)</span>. After some work, the result is a verifier complexity of $\\mathsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log n)$ bit operations in the composed system which suffices for Theorem 3.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-26" class="text-base font-medium mt-4">Remark 2.1.</h6>

    <p class="text-gray-300">We use the freedom to choose a large enough <span class="math">t</span> in our robust zero-knowledge IOPP based on <em>[x1]</em> to obtain query complexity (and verifier time) that is <span class="math">O(n^{1/t})</span>. It is plausible that <em>[x2]</em> similarly implies a robust zero-knowledge IOPP with query complexity (and verifier time) <span class="math">O(n^{1/2})</span>. We do not know how to leverage such a result because that would require an inner IOPP with subquadratic prover time and constant query complexity, and we do not know of such a result. While it is plausible that the prover of <em>[x22]</em> prover runs in subquadratic time, proving this seems an arduous task.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Remark 2.2 (zero knowledge).</h6>

    <p class="text-gray-300">We do not require the the IOPP for tensor queries used in Section 2.3.1 to be zero knowledge because we can invoke it on a random instance as explained in Section 2.3.1. Nevertheless, we believe that future improvements in zero knowledge IOPs (especially with a focus on concrete efficiency) will benefit from applying the transformations of robustification and proof composition to zero knowledge protocols. In such a case, it will be useful to understand how zero knowledge is affected by these transformations: If the robustified IOP is required to be zero knowledge, what should we require of the given IOP and code used to encode each symbol? Also, if the composed IOP is required to be zero knowledge, what should we require of the outer IOP and inner IOP? We took the opportunity to investigate this in our appendices, taking advantage of the fact that we already had to specify the relevant transformations.</p>

    <p class="text-gray-300">We consider two target notions of zero knowledge: against semi-honest verifiers and against (malicious) bounded-query verifiers. Then we deduce natural conditions on the ingredients to robustification and proof composition that suffice to achieve the target notion of zero knowledge. See Lemma A.4 for the zero knowledge properties of robustification, and Lemma B.6 for the zero knowledge properties of proof composition. We view these results as an independent contribution to foundational transformations of IOPs.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">2.4 Tensor IOP for R1CS with semi-honest verifier zero knowledge</h3>

    <p class="text-gray-300">The input to the compiler in Section 2.3 is a tensor IOP for R1CS that is semi-honest-verifier zero knowledge.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Theorem 4 (informal).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For every finite field <span class="math">\\mathbb{F}</span> and positive integers <span class="math">k,t\\in\\mathbb{N}</span>, there is a <span class="math">(\\mathbb{F},k,t)</span>-tensor holographic IOP for the indexed relation <span class="math">R_{\\mathrm{R1CS}}</span>, which is semi-honest-verifier zero-knowledge, that supports instances over <span class="math">\\mathbb{F}</span> with <span class="math">m=O(k^{t})</span>, that has the following parameters: (1) soundness error is $O(\\frac{m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$; (2) round</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">complexity is <span class="math">O(\\log m)</span>; (3) proof length is <span class="math">O(m)</span> elements in <span class="math">\\mathbb{F}</span>; (4) query complexity is <span class="math">O(1)</span>; (5) the indexer and prover use <span class="math">O(m)</span> field operations; (6) the verifier uses $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\log m)$ field operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We prove this theorem in Section 4, and summarize the proof below.</p>

    <p class="text-gray-300">Our starting point is the holographic tensor IOP for R1CS in [BCG20], which achieves the same parameters as in the above theorem except that it is not zero knowledge. We use re-randomization techniques to additionally achieve zero knowledge against semi-honest verifiers, while preserving all efficiency parameters. We now elaborate on this: first we review the structure of the tensor IOP in [BCG20], and then explain our ideas for how to additionally achieve zero knowledge.</p>

    <p class="text-gray-300"><strong>The holographic tensor IOP of BCG.</strong> The holographic tensor IOP for R1CS in [BCG20] follows a standard blueprint for constructing protocols for R1CS [BCRSVW19], adapted to the case of tensor queries. The prover first sends oracles containing the full assignment <span class="math">z = (x, w)</span> and its linear combinations <span class="math">z_A := Az</span>, <span class="math">z_B := Bz</span>, and <span class="math">z_C := Cz</span>. The verifier wishes to check that <span class="math">z_A \\circ z_B = z_C</span> and that <span class="math">z_A, z_B, z_C</span> are the correct linear combinations of <span class="math">z</span>. To facilitate this, the verifier sends some randomness to the prover, which enables reducing the first condition (a Hadamard product) to a scalar-product condition. The verifier then engages with the prover in scalar-product subprotocols for checking the scalar products, and holographic "lincheck" subprotocols for checking the linear relations (given tensor-query access to suitable linear-time encodings of the matrices <span class="math">A, B, C</span>). The verifier makes a constant number of tensor queries to each of <span class="math">z, z_A, z_B, z_C</span> for concluding the subprotocols and performing other consistency checks (e.g., consistency of <span class="math">z</span> with <span class="math">x</span>).</p>

    <p class="text-gray-300">This protocol is not zero knowledge even for an honest verifier because: (1) the answer to each tensor query to <span class="math">z, z_A, z_B, z_C</span> reveals information about the secret input <span class="math">w</span> (part of the full assignment <span class="math">z</span>); (2) messages sent by the prover during the scalar-product and lincheck protocols reveal further information about <span class="math">z, z_A, z_B, z_C</span>.</p>

    <p class="text-gray-300"><strong>Approach for zero knowledge.</strong> We need to ensure that every prover message and the answer to every tensor query is simulatable. The fact that queries are linear combinations with a tensor structure would make this rather difficult if we had to deal with malicious verifiers.[16] Fortunately, we seek zero knowledge against semi-honest verifiers only, which means that it suffices to consider any valid execution of an honest verifier, and in particular we have the freedom to assume that the verifier's queries have a certain structure. While there are generic techniques for related settings (e.g., a transformation for linear PCPs with degree-2 verifiers in [BCIOP13]), they do not seem to be useful for our setting (tensor IOPs with linear-time proving). So our approach here will be to modify the protocol in [BCG20] by adapting ideas used in prior works.</p>

    <p class="text-gray-300">We incorporate random values into the protocol in two different ways to address the two types of leakage above. This will enable us to make every prover message and query answer either uniformly random (independent of the witness) or uniquely determined by other prover messages or query answers. The simulator that we construct will then simply sample all the random values and derive the rest from them. We elaborate on this strategy in the paragraphs below.</p>

    <p class="text-gray-300"><strong>(1) ZK against verifier queries.</strong> The answer to each verifier query is a linear combination (with tensor structure) of elements in the prover's oracle message. Intuitively, if we pad each oracle message with as many random values as the number of queries it receives, and also "force" the linear combination to have non-zero coefficients in the padded region, then all the query answers will be uniformly random and reveal no information. Padding each of <span class="math">z, z_A, z_B, z_C</span> with independent randomness, however, does not preserve completeness because the padded vectors would not satisfy the R1CS condition.</p>

    <p class="text-gray-300">14</p>

    <p class="text-gray-300">This naive strategy, however, can be fixed as follows. We rely on a small R1CS gadget, whose solutions can be efficiently sampled, for which we can control the amount of independent randomness. Then we augment the original R1CS instance with this gadget. <span class="math">^{17}</span>  In the first step of the protocol, the prover samples a random solution to the R1CS gadget and appends it to the witness to obtain an augmented witness. <span class="math">^{18}</span>  In the rest of the protocol, the random solution acts as padding as described above, while preserving completeness. The choice of how much to pad depends on how many independent queries each oracle receives.</p>

    <p class="text-gray-300">Though conceptually simple, this approach requires careful design and analysis. Intuitively, this is because the solutions to the R1CS gadget, which act as random padding, satisfy some non-linear relations, and therefore cannot consist entirely of uniformly random field elements. For example, since  <span class="math">z_{C} = z_{A} \\circ z_{B}</span> , if the padding for  <span class="math">z_{A}</span>  and  <span class="math">z_{B}</span>  was uniformly random, then the padding for  <span class="math">z_{C}</span>  would be a sum of products of uniformly random field elements, which would not lead to uniformly random answers to queries on  <span class="math">z_{C}</span> . However, introducing uniformly random padding into  <span class="math">z_{C}</span>  requires setting some elements of  <span class="math">z_{A}</span>  (or  <span class="math">z_{B}</span> ) to fixed non-zero elements, which cannot then be used to make queries on  <span class="math">z_{A}</span>  uniformly random. In sum, the solutions to the R1CS gadgets must hide not only the results to queries on the vectors  <span class="math">z_{A}, z_{B}, z_{C}</span> , but also the dependencies in the solutions themselves.</p>

    <p class="text-gray-300">(2) ZK for the subprotocols. Each lincheck subprotocol checks a linear relation  <span class="math">Uz = z_U</span> , and as with the point-query compiler, the usual approach to making the messages in such a subprotocol zero-knowledge is to run the subprotocol on the input vector  <span class="math">e = \\gamma z + y</span> , where  <span class="math">y</span>  is a random vector sent by the prover and  <span class="math">\\gamma</span>  is a random challenge sent by the verifier after that. (The claimed output vector  <span class="math">z_U</span>  needs to be adjusted accordingly too.) This enables the simulator to randomly sample  <span class="math">e</span>  and honestly run the lincheck protocol, which reveals no information, since the honest verifier only queries  <span class="math">e = \\gamma z + y</span> , and never  <span class="math">z</span>  and  <span class="math">y</span>  separately. As the lincheck subprotocol is used as a black-box, the holographic properties of our protocol are unaffected by our modifications for zero-knowledge, and are inherited from the lincheck protocol of [BCG20].</p>

    <p class="text-gray-300">The scalar-product subprotocol is a sumcheck protocol on a certain polynomial  <span class="math">p</span> . Sumcheck protocols are usually made zero knowledge by following a similar pattern and running the sumcheck protocol on the polynomial  <span class="math">u := \\gamma p + q</span> , where  <span class="math">q</span>  is a random polynomial [BCFGRS17]. The simulator can randomly sample  <span class="math">u</span>  and honestly run the sumcheck protocol, while simulating answers to  <span class="math">q</span>  by querying  <span class="math">p</span>  instead.</p>

    <p class="text-gray-300">We cannot apply this idea in our setting of linear-time provers without change. In the protocol of [BCG20], the polynomial  <span class="math">p</span>  is the product of two multilinear polynomials  <span class="math">f</span>  and  <span class="math">g</span> , each with  <span class="math">\\log n</span>  variables (and thus  <span class="math">O(n)</span>  coefficients). To achieve linear arithmetic complexity for the prover, it is crucial that the prover does not compute the sumcheck directly on  <span class="math">p</span> , which could have up to  <span class="math">O(n^2)</span>  coefficients, and works only with  <span class="math">f</span>  and  <span class="math">g</span>  following a certain linear-time algorithm [Tha13]. Thus the prover cannot simply sample a random  <span class="math">q</span> .</p>

    <p class="text-gray-300">The solution is to re-randomize the multiplicands  <span class="math">f</span>  and  <span class="math">g</span>  separately to  <span class="math">\\gamma f + r</span>  and  <span class="math">\\gamma g + s</span> , and run the sumcheck protocol on their product  <span class="math">(\\gamma f + r) \\cdot (\\gamma g + s)</span> . (If  <span class="math">p = f \\cdot g</span>  sums to  <span class="math">\\alpha</span>  then  <span class="math">(\\gamma f + r) \\cdot (\\gamma g + s)</span>  sums to  <span class="math">\\alpha \\gamma^2 + \\rho \\gamma + \\sigma</span>  for some  <span class="math">\\rho</span>  and  <span class="math">\\sigma</span>  derived from  <span class="math">r</span>  and  <span class="math">s</span>  alone.) The prover can then compute on polynomials with  <span class="math">O(n)</span>  coefficients, and the simulator can sample each factor of  <span class="math">p</span>  at random and proceed similarly.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency. The resulting tensor IOP inherits all efficiency parameters of the non-ZK tensor IOP of [BCG20]: soundness error  $O(m /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ ; logarithmic round complexity; linear proof length; constant query complexity; linear-time indexer; linear-time prover; and logarithmic-time verifier.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">2.5 Hiding properties of linear codes</p>

    <p class="text-gray-300">Linear codes have been used to achieve hiding properties in many applications, including secret sharing, multi-party computation, and probabilistic proofs. Below we introduce useful notation and then review the properties of linear codes that we use, along with other ingredients, to achieve zero knowledge IOPs. Informally, we consider probabilistic encodings for linear codes with the property that a small number of locations of a codeword reveal no information about the underlying encoded message.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Randomized linear codes. Let <span class="math">\\mathcal{C}</span> be a linear code over a field <span class="math">\\mathbb{F}</span> with message length <span class="math">k</span> and block length <span class="math">n</span>, and let <span class="math">\\mathrm{Enc}\\colon\\mathbb{F}^{k}\\to\\mathbb{F}^{n}</span> be an encoding function for <span class="math">\\mathcal{C}</span> (that is, <span class="math">\\mathrm{Enc}(\\mathbb{F}^{k})=\\mathcal{C}</span>). For a fixed choice of <span class="math">k_{m}</span> and <span class="math">k_{r}</span> such that <span class="math">k_{m}+k_{r}=k</span>, we can derive from <span class="math">\\mathrm{Enc}</span> the bivariate function <span class="math">\\widetilde{\\mathrm{Enc}}\\colon\\mathbb{F}^{k_{m}}\\times\\mathbb{F}^{k_{r}}\\to\\mathbb{F}^{n}</span> defined as $\\widetilde{\\mathrm{Enc}}(m;r):=\\mathrm{Enc}(m\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r)<span class="math">. In turn, this function naturally induces a probabilistic encoding: we define </span>\\widetilde{\\mathrm{Enc}}(m)<span class="math"> to be the random variable </span>\\{\\widetilde{\\mathrm{Enc}}(m;r)\\}_{r\\leftarrow\\mathbb{F}^{k_{r}}}<span class="math">. In other words, we have designated the first </span>k_{m}<span class="math"> inputs of </span>\\mathrm{Enc}<span class="math"> for the message and the remaining </span>k_{r}<span class="math"> inputs for encoding randomness. We shall refer to a code </span>\\mathcal{C}<span class="math"> specified via a bivariate function </span>\\widetilde{\\mathrm{Enc}}$ as a <em>randomized linear code</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bounded-query zero knowledge. A randomized linear code is <em><span class="math">b</span>-query zero knowledge</em> if reading any <span class="math">b</span> locations of a random encoding of a message does not reveal any information about the message. The locations may be chosen arbitrarily and adaptively. In more detail, we denote by <span class="math">\\mathrm{View}(\\widetilde{\\mathrm{Enc}}(m;r),A)</span> the view of an oracle algorithm <span class="math">A</span> that is given query access to the codeword <span class="math">\\widetilde{\\mathrm{Enc}}(m;r)</span>. We say that <span class="math">\\mathcal{C}</span> is <span class="math">b</span>-query zero knowledge if there exists a $\\mathsf{poly}(n,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">-time simulator algorithm </span>\\mathcal{S}<span class="math"> such that, for every message </span>m\\in\\mathbb{F}^{k_{m}}<span class="math"> and </span>b<span class="math">-query algorithm </span>A$, the following random variables are identically distributed:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\left\\{\\mathrm{View}\\big{(}\\widetilde{\\mathrm{Enc}}(m;r),A\\big{)}\\right\\}_{r\\leftarrow\\mathbb{F}^{k_{r}}}\\quad\\text{and}\\quad\\mathcal{S}^{A}\\enspace.</span></p>

    <p class="text-gray-300">To achieve even <span class="math">1</span>-query zero knowledge the random encoding cannot be systematic (as otherwise the algorithm <span class="math">A</span> could learn any location of the message by querying the corresponding location in the codeword).</p>

    <p class="text-gray-300">The above notion mirrors the standard notion of bounded-query zero knowledge for several models of probabilistic proofs (PCPs <em>[x21, x13, x14]</em>, IPCPs <em>[x12]</em>, and IOPs <em>[x5, x4]</em>). Moreover, it is equivalent, in the special case of codes with a polynomial-time encoding, to the message-indistinguishability definition of zero knowledge of <em>[x17]</em> (which requires that the encodings of any two messages are equidistributed when restricted to any small-enough subset of coordinates); see Appendix C.</p>

    <p class="text-gray-300">Bounded-query uniformity. In intermediate steps we also consider a stronger notion of zero knowledge: we say that <span class="math">\\mathcal{C}</span> is <em><span class="math">b</span>-query uniform</em> if any <span class="math">b</span> locations of <span class="math">\\{\\widetilde{\\mathrm{Enc}}(m;r)\\}_{r\\leftarrow\\mathbb{F}^{k_{r}}}</span> are uniformly random and independent symbols. This is a strengthening over the prior notion because the simulator for this case is a simple fixed strategy: answer each query with a freshly sampled random symbol. We refer the reader to Example 1 for more intuition on the difference between the two notions; there we explain how code concatenation, a standard operation on codes, naturally leads to codes that are bounded-query zero knowledge but not bounded-query uniform, and in particular the simulator cannot employ the foregoing simple strategy.</p>

    <p class="text-gray-300">Example: Reed–Solomon code. The Reed–Solomon code is a well-known code whose hiding properties are well understood. Namely, one can achieve <span class="math">b</span>-query uniformity (and thus also <span class="math">b</span>-query zero knowledge) by interpolating the given message padded with <span class="math">b</span> random elements and then evaluating the resulting polynomial on a domain disjoint from the interpolation domain. We explore this example further in Section 5.3.1 to build intuition about algebraic statements proved in this paper (and discussed in Section 2.6.1). The Reed–Solomon code also happens to be a versatile tool for constructing efficient IOPs, and indeed many IOPs rely on the Reed–Solomon code to additionally achieve bounded-query zero knowledge <em>[x5, x4, x3, x1, x11, x3]</em>. In this paper, however, we will not use the Reed–Solomon code in our constructions because its encoding function costs more than linear time.</p>

    <p class="text-gray-300">2.6 On bounded-query zero knowledge</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 1 guarantees zero-knowledge against <em>semi-honest</em> verifiers. However, we can achieve <em>bounded-query</em> zero-knowledge against a malicious verifier who makes at most <span class="math">O(m^{\\epsilon})</span> queries, if we relax the verifier time in our construction to $\\poly(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)+O(m^{\\epsilon})$ field operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The reason behind this is as follows. By Theorem 3, the zero-knowledge property in Theorem 1 relies (among other things) on a family of <em>explicit</em> linear-time encodable error-correcting codes which themselves have a zero-knowledge property, whereby a single query to a codeword leaks no information about the encoded message. These codes suffice for semi-honest-verifier zero-knowledge because the honest verifier never learns more than one query of each codeword. By contrast, in the setting of bounded-query zero-knowledge, we require codes with a zero-knowledge property against a sublinear number of queries. The above codes do not satisfy this property. Instead, we show how to obtain suitable codes from a <em>probabilistic</em> construction of Druk and Ishai <em>[x10]</em>, leading to an IOP verifier whose randomness complexity is sublinear.</p>

    <p class="text-gray-300">Obtaining an explicit construction of linear-time encodable zero-knowledge codes remains an interesting open problem, which would allow us to prove Theorem 1 with <em>both</em> polylogarithmic verifier complexity and bounded-query zero-knowledge.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">2.6.1 Algebraic reformulation of zero knowledge</h4>

    <p class="text-gray-300">We provide algebraic reformulations for the properties of bounded-query zero knowledge and bounded-query uniformity. We use these throughout this work, and deem them to be of independent interest.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}</span> be a randomized linear code with encoding function <span class="math">\\widetilde{\\operatorname{Enc}}\\colon\\mathbb{F}^{k_{m}}\\times\\mathbb{F}^{k_{r}}\\to\\mathbb{F}^{n}</span>. We can split the generator matrix <span class="math">G\\in\\mathbb{F}^{n\\times k}</span> associated with <span class="math">\\widetilde{\\operatorname{Enc}}</span> into two parts <span class="math">G=\\begin{bmatrix}G_{m}&amp;G_{r}\\end{bmatrix}</span> so that <span class="math">\\widetilde{\\operatorname{Enc}}(m;r)=G_{m}m+G_{r}r</span> is the sum of a <em>message part</em> <span class="math">G_{m}m</span> and a <em>randomness part</em> <span class="math">G_{r}r</span>, which acts as “mask”.</p>

    <p class="text-gray-300">The lemma below involves two codes associated to <span class="math">\\mathcal{C}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{C}^{\\perp}:=\\{z\\in\\mathbb{F}^{n}\\mid z^{\\intercal}G=0\\}</span> is the dual code of <span class="math">\\mathcal{C}</span>, which consists of all linear combinations <span class="math">z</span> that “eliminate” the message part and the randomness part of a codeword, regardless of the choice of message and randomness. I.e., if <span class="math">z\\in\\mathcal{C}^{\\perp}</span> then <span class="math">z^{\\intercal}(G_{m}m+G_{r}r)=0</span> for every <span class="math">m\\in\\mathbb{F}^{k_{m}}</span> and <span class="math">r\\in\\mathbb{F}^{k_{r}}</span>.</li>

      <li><span class="math">\\mathcal{D}(\\mathcal{C}):=\\{z\\in\\mathbb{F}^{n}\\mid z^{\\intercal}G_{r}=0\\}</span> is the code consisting of all linear combinations that eliminate the randomness part. I.e., if <span class="math">z\\in\\mathcal{D}(\\mathcal{C})</span> then <span class="math">z^{\\intercal}(G_{m}m+G_{r}r)=z^{\\intercal}G_{m}m</span> for every <span class="math">m\\in\\mathbb{F}^{k_{m}}</span> and <span class="math">r\\in\\mathbb{F}^{k_{r}}</span>. In particular, the linear combination <span class="math">z</span> “leaks” information about the encoded message if <span class="math">z^{\\intercal}G_{m}m</span> is non-zero.</li>

    </ul>

    <p class="text-gray-300">Note that <span class="math">\\mathcal{C}^{\\perp}\\subseteq\\mathcal{D}(\\mathcal{C})</span>.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Lemma 2.3.</h6>

    <p class="text-gray-300">For every <span class="math">b\\in\\mathbb{N}</span> the following equivalences hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{C}</span> is <span class="math">b</span>-query zero-knowledge if and only if the minimum weight of codewords in <span class="math">\\mathcal{D}(\\mathcal{C})\\setminus\\mathcal{C}^{\\perp}</span> is at least <span class="math">b+1</span>;</li>

      <li><span class="math">\\mathcal{C}</span> is <span class="math">b</span>-query uniform if and only if <span class="math">\\mathcal{D}(\\mathcal{C})</span>’s minimum absolute distance is at least <span class="math">b+1</span>.</li>

    </ol>

    <p class="text-gray-300">The difference between the two equivalences is that for the weaker condition (bounded-query zero knowledge) the minimum-weight requirement is imposed only on codewords in <span class="math">\\mathcal{D}(\\mathcal{C})\\setminus\\mathcal{C}^{\\perp}</span>, rather than on all non-zero codewords in <span class="math">\\mathcal{D}(\\mathcal{C})</span>.</p>

    <p class="text-gray-300">The characterizations in Lemma 2.3 strengthen weaker statements in prior works such as <em>[x11, x14]</em>. Below we provide intuition about the equivalences, first discussing bounded-query uniformity and then bounded-query zero knowledge. Technical details can be found in Section 5, and Remark 5.3 explains how the characterizations are related statements in prior works.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Intuition for Equivalence 2.</h6>

    <p class="text-gray-300">Consider the random variable <span class="math">c:=\\left\\{G_{m}m+G_{r}r\\right\\}_{r\\leftarrow\\mathbb{F}^{k_{r}}}</span>, which is a random encoding of the message <span class="math">m\\in\\mathbb{F}^{k_{m}}</span>. If <span class="math">\\mathcal{D}(\\mathcal{C})</span> has minimum absolute distance <span class="math">b+1</span>, then there is a linear combination <span class="math">z\\in\\mathbb{F}^{n}</span> of weight <span class="math">b+1</span> that eliminates the randomness part <span class="math">G_{r}r</span>. The support of <span class="math">z</span> gives <span class="math">b+1</span> entries of <span class="math">c</span> that are correlated (via the non-zero coefficients of <span class="math">z</span>), showing that <span class="math">\\mathcal{C}</span> cannot be <span class="math">(b+1)</span>-query uniform. On the other hand, if no linear combination <span class="math">z\\in\\mathbb{F}^{n}</span> of weight at most <span class="math">b</span> eliminates the randomness part <span class="math">G_{r}r</span>, then every linear combination of <span class="math">b</span> entries of <span class="math">c</span> is uniformly random. By an XOR Lemma (Lemma 5.4) this can only happen if each set of <span class="math">b</span> entries of <span class="math">c</span> is uniformly distributed.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Intuition for Equivalence 1.</h6>

    <p class="text-gray-300">Again consider the random variable <span class="math">c:=\\left\\{G_{m}m+G_{r}r\\right\\}_{r\\leftarrow\\mathbb{F}^{k_{r}}}</span>. If the minimum weight of codewords in the set <span class="math">\\mathcal{D}(\\mathcal{C})\\setminus\\mathcal{C}^{\\perp}</span> is <span class="math">b+1</span>, then there is a linear combination <span class="math">z</span> of weight <span class="math">b+1</span> that eliminates the randomness part <span class="math">G_{r}r</span> (<span class="math">z^{\\intercal}G_{r}=0</span>) but does not eliminate the message part <span class="math">G_{m}m</span> (<span class="math">z^{\\intercal}G_{m}\\neq 0</span>). The support of <span class="math">z</span> gives <span class="math">b+1</span> entries of <span class="math">c</span> that can be used to distinguish between different messages <span class="math">m</span> according to the value of <span class="math">z^{\\intercal}G_{m}m</span> (using the non-zero coefficients of <span class="math">z</span>). Therefore, <span class="math">\\mathcal{C}</span> cannot be <span class="math">(b+1)</span>-query zero-knowledge. On the other hand, suppose that no linear combination <span class="math">z</span> of weight at most <span class="math">b</span> can be used to distinguish between encodings of different messages. Then every low-weight linear combination of entries of <span class="math">c</span> is either random (if <span class="math">z</span> does not eliminate <span class="math">G_{r}r</span>) or zero (if <span class="math">z</span> eliminates both <span class="math">G_{r}r</span> and <span class="math">G_{m}m</span>). Thus, no such low-weight <span class="math">z</span> belongs to the set <span class="math">\\mathcal{D}(\\mathcal{C})\\setminus\\mathcal{C}^{\\perp}</span>.</p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">2.6.2 Tensor products of zero knowledge codes</h4>

    <p class="text-gray-300">As part of the tensor-query to point-query compiler (see Section 2.4), the prover sends to the verifier proof messages <span class="math">\\hat{\\Pi}</span> consisting of tensor-IOP proof messages <span class="math">\\Pi</span> encoded under a tensor code <span class="math">\\mathcal{C}^{\\otimes t}</span>. The verifier has point-query access to the encoded messages <span class="math">\\hat{\\Pi}</span>. To ensure that these queries do not leak information (up to a certain number of queries), we require the tensor code <span class="math">\\mathcal{C}^{\\otimes t}</span> to be zero-knowledge. To this end, we prove that the tensor product operation preserves the property of bounded-query zero-knowledge (and bounded-query uniformity). In particular, for <span class="math">\\mathcal{C}^{\\otimes t}</span> to be zero knowledge it will suffice for <span class="math">\\mathcal{C}</span> to be zero knowledge. (We discuss how to obtain a zero-knowledge code that is linear-time encodable after this, in Section 2.6.3.)</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{C}^{\\prime}</span> be randomized linear codes.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathcal{C}</span> is <span class="math">b</span>-query zero-knowledge and <span class="math">\\mathcal{C}^{\\prime}</span> is <span class="math">b^{\\prime}</span>-query zero-knowledge, then <span class="math">\\mathcal{C}\\otimes\\mathcal{C}^{\\prime}</span> is <span class="math">\\min(b,b^{\\prime})</span>-query zero-knowledge.</li>

      <li>If <span class="math">\\mathcal{C}</span> is <span class="math">b</span>-query uniform and <span class="math">\\mathcal{C}^{\\prime}</span> is <span class="math">b^{\\prime}</span>-query uniform, then <span class="math">\\mathcal{C}\\otimes\\mathcal{C}^{\\prime}</span> is <span class="math">\\min(b,b^{\\prime})</span>-query uniform.</li>

    </ol>

    <p class="text-gray-300">The formal statement and proof are provided in Section 6. Below we describe the main ideas behind the two items in Theorem 5.</p>

    <p class="text-gray-300">For Item 2 (the simpler case), using the algebraic reformulation given in Lemma 2.3, it suffices to show that the minimum distance of <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})</span> is at least <span class="math">\\min(b,b^{\\prime})</span>. Unfortunately, it is difficult to directly analyze <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})</span>. Although <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})</span> can be expressed as a sum of linear-spaces each of which has a known minimum distance (see Figure 3), this cannot be used to prove any useful bounds. Instead, we analyze the space <span class="math">R:=\\mathcal{D}(\\mathcal{C})\\otimes\\mathcal{D}(\\mathcal{C}^{\\prime})^{\\perp}\\oplus\\mathbb{F}^{n}\\otimes\\mathcal{D}(\\mathcal{C}^{\\prime})</span> (also shown in Figure 3). Since <span class="math">R</span> contains <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})</span>, the minimum distance of <span class="math">R</span> is a lower bound for the minimum distance of <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})</span>. Further, <span class="math">R</span> is defined by a direct sum of two tensor-product spaces (whereas <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})</span> seems to require three). This gives a decomposition of any element of <span class="math">R</span> into two elements with strong restrictions on their rows and columns (when we view tensors of rank two as matrices), which belong to different spaces and yet must be equal in almost all of their entries for a low-weight element of <span class="math">R</span>. This allows us to bound the minimum distance of <span class="math">R</span>.</p>

    <p class="text-gray-300">Item 1 (which is the harder case) follows in a similar fashion, using a different definition of <span class="math">R</span> and accounting for the fact that the algebraic characterization of zero-knowledge in Lemma 2.3 uses the set <span class="math">\\mathcal{D}(\\mathcal{C})\\setminus\\mathcal{C}^{\\perp}</span>, rather than the linear space <span class="math">\\mathcal{D}(\\mathcal{C})</span>.</p>

    <p class="text-gray-300">Note that one cannot hope to improve Item 2 to prove that  <span class="math">\\mathcal{C} \\otimes \\mathcal{C}&#x27;</span>  is even  <span class="math">\\max(b, b&#x27;)</span> -query uniform in general. We know that the rows of any codeword of  <span class="math">\\mathcal{C} \\otimes \\mathcal{C}&#x27;</span>  belong to  <span class="math">\\mathcal{C}</span> , and must therefore satisfy various parity checks. Therefore, if  <span class="math">b&#x27;</span>  is greater than the block length  <span class="math">n</span>  of  <span class="math">\\mathcal{C}</span> , then  <span class="math">\\mathcal{C} \\otimes \\mathcal{C}&#x27;</span>  cannot be  <span class="math">\\max(b, b&#x27;)</span> -query uniform. However, one might hope that Item 1 could be improved to  <span class="math">O(bb&#x27;)</span> -query zero knowledge, which would imply zero-knowledge against a verifier making a linear number of queries in Theorem 1.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 3: The linear spaces  <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes \\mathcal{C}^{\\prime})</span>  and  <span class="math">R</span>  as subspaces of  <span class="math">\\mathbb{F}^n\\otimes \\mathbb{F}^{n&#x27;}</span></p>

    <p class="text-gray-300">To prove our main theorem, Theorem 1, we require an explicit construction of a randomized linear code, that must be both linear-time encodable and 1-query zero-knowledge. Prior works such as [BCGGHJ17; Cer19] achieve this by applying a 1-out-of-2 secret sharing scheme to every element of the output of an explicit (non zero-knowledge) linear-time encodable code, such as [Spi96]. Given the encoding function Enc for a linear-time encodable code, the new code is defined by  <span class="math">\\widetilde{\\mathrm{Enc}}(m; r) \\coloneqq (\\mathrm{Enc}(m) + r, r)</span> .</p>

    <p class="text-gray-300">Investigating bounded-query zero-knowledge. To prove the variation on our main theorem, Theorem 1, with bounded-query zero-knowledge, we require randomized linear codes which are linear-time encodable as above, but with a stronger zero-knowledge property. In this case, the code must be  <span class="math">b</span> -query zero-knowledge where  <span class="math">b</span>  is not only greater than 1, but may even be a constant fraction of the block length.</p>

    <p class="text-gray-300">Prior works achieved these properties separately. For example, it is well-known that the Reed-Solomon code can be made  <span class="math">b</span> -query zero-knowledge by using  <span class="math">b</span>  elements of encoding randomness, but their encoding functions incur costs quasilinear in the message length. On the other hand, the zero-knowledge properties of linear-time encodable codes, such as the explicit family by Spielman [Spi96] or the probabilistic family by Druk and Ishai [DI14], have not been investigated.</p>

    <p class="text-gray-300">We prove the existence of codes satisfying both requirements, via a probabilistic construction. In the statement below,  <span class="math">H_{q} \\colon [0,1] \\to [0,1]</span>  denotes the  <span class="math">q</span> -ary entropy function (see Definition 7.2).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 6. For every finite field  <span class="math">\\mathbb{F}</span> , every  <span class="math">\\epsilon \\in (0,1)</span> , and every function  <span class="math">\\beta \\colon \\mathbb{N} \\to (0,1)</span>  bounded away from 1, letting  $q \\coloneqq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , there is a circuit family  </span>\\{E_{k_m} \\colon \\mathbb{F}^{k_m} \\times \\mathbb{F}^{(H_q(\\beta(k_m)) + \\epsilon) \\cdot O(k_m)} \\times \\mathbb{F}^{O(k_m)} \\to \\mathbb{F}^{O(k_m)}\\}_{k_m \\in \\mathbb{N}}<span class="math">  such that: (1)  </span>E_{k_m}<span class="math">  has size  </span>O(k_m)<span class="math"> ; (2) with probability at least  </span>1 - q^{-\\Omega_\\epsilon(k_m)}<span class="math">  over  </span>R \\in \\mathbb{F}^{O(k)}$ , the randomized</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">linear code <span class="math">\\mathcal{C}_{k_{m}}</span> whose encoding function is <span class="math">\\operatorname{\\mathrm{Einc}}_{k_{m}}(m;r):=E_{k_{m}}(m,r,R)</span> has constant relative distance and is <span class="math">O(\\beta(k_{m})\\cdot k_{m})</span>-query uniform.</p>

    <p class="text-gray-300">The precise statement of the theorem and its proof are provided in Section 7.</p>

    <p class="text-gray-300">Below we provide intuition about the theorem statement by comparing the parameters to those achievable by the Reed–Solomon code; then provide an overview of the proof; and finally discuss related constructions and analyses. Derandomizing Theorem 6, namely the goal of obtaining an explicit family of codes that are both zero knowledge and linear-time encodable, remains an open problem.</p>

    <p class="text-gray-300">Comparison with RS code. The relation between encoding randomness and bounded-query uniformity is simple for the Reed–Solomon code: <span class="math">b</span> elements of encoding randomness ensure <span class="math">b</span>-query uniformity. This relation is more complex for the code in Theorem 6, but we can understand its qualitative behavior by considering two regimes, depending on whether the desired <span class="math">b</span> is small or large.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b</span> is small. If <span class="math">\\beta=O(q^{-\\sigma})</span> for <span class="math">\\sigma\\in(0,1)</span>, then <span class="math">H_{q}(\\beta)\\cdot k_{m}</span> is bounded by <span class="math">O(-\\frac{\\beta}{\\sigma}\\cdot\\log\\beta)\\cdot k_{m}</span>, which itself is bounded by <span class="math">O(\\frac{\\log k_{m}}{\\sigma})\\cdot b</span>. This tells us that <span class="math">O(\\frac{\\log k_{m}}{\\sigma})\\cdot b</span> elements of encoding randomness suffice for <span class="math">b</span>-query uniformity, which in this regime is a factor of <span class="math">O(\\frac{\\log k_{m}}{\\sigma})</span> more than for the Reed–Solomon code.</li>

      <li><span class="math">b</span> is large. If <span class="math">b</span> is linear in the block length of the code (which is linear in <span class="math">k_{m}</span>), then <span class="math">\\beta</span> is constant and so <span class="math">H_{q}(\\beta)\\cdot k_{m}=O(b)</span>. This tells us that <span class="math">O(b)</span> elements of encoding randomness suffice for <span class="math">b</span>-query uniformity, which in this regime is within a constant factor of the Reed–Solomon code.</li>

    </ul>

    <p class="text-gray-300">The regime that we use in this paper is when <span class="math">b</span> is large (linear in <span class="math">k_{m}</span>).</p>

    <p class="text-gray-300">Overview of proof of Theorem 6. We use the same code as in <em>[x10]</em>, which is a probabilistic construction (which we inherit). Our contribution is to show that their construction additionally satisfies the strong requirement of <span class="math">b</span>-query uniformity, by using Lemma 2.3 and ideas from the analysis of <em>[x10]</em>.</p>

    <p class="text-gray-300">Informally, Druk and Ishai <em>[x10]</em> construct a family of distributions <span class="math">\\mathcal{G}=\\{\\mathcal{G}_{k}\\}_{k\\in\\mathbb{N}}</span> such that, for every <span class="math">k\\in\\mathbb{N}</span>, <span class="math">\\mathcal{G}_{k}=\\{G_{R}\\in\\mathbb{F}^{O(k)\\times k}\\}_{R\\in\\mathbb{F}^{O(k)}}</span> is a distribution over generator matrices such that: (1) matrix-vector multiplication is computable in linear time; (2) for any fixed non-zero vector <span class="math">x</span>, when <span class="math">G_{R}</span> is sampled at random from the distribution, <span class="math">G_{R}x</span> is uniformly distributed. This latter property is known as linear uniform output, and implies that, with high probability over <span class="math">R</span>, <span class="math">G_{R}</span> has constant relative distance and dual distance.</p>

    <p class="text-gray-300">We are interested in analyzing what happens if we split the message space of a generator matrix <span class="math">G\\in\\mathcal{G}_{k}</span> into two parts, one of length <span class="math">k_{m}</span> for the actual message and another of length <span class="math">k_{r}</span> for the encoding randomness, for <span class="math">k_{m}+k_{r}=k</span>. As in Section 2.5, this induces a corresponding split in the generator matrix: <span class="math">G=\\begin{bmatrix}G_{m}&amp;G_{r}\\end{bmatrix}</span>. By Lemma 2.3, the probability that this code is <span class="math">b</span>-query uniform is bounded from below by the probability that <span class="math">(G_{r})^{\\perp}</span>, the dual of <span class="math">G_{r}</span>, has minimum (absolute) distance at least <span class="math">b+1</span>.</p>

    <p class="text-gray-300">Druk and Ishai <em>[x10]</em> show that <span class="math">G^{\\perp}</span> has constant relative distance with high probability. We observe that <span class="math">G_{r}</span> inherits the linear-uniform output property from <span class="math">G</span>, and then adapt their analysis to <span class="math">(G_{r})^{\\perp}</span>. We now summarize the main ideas of their analysis when it is applied to our setting of <span class="math">b</span>-query uniformity. Similarly, to the standard probabilistic proof of the Gilbert–Varshamov bound, requiring that <span class="math">(G_{r})^{\\perp}</span> has distance at least <span class="math">b+1</span> is equivalent to showing that each non-zero vector <span class="math">z\\in\\mathbb{F}^{n}</span> with Hamming weight at most <span class="math">b</span> is not in <span class="math">(G_{r})^{\\perp}</span>, i.e., <span class="math">zG_{r}\\neq 0</span>. The linear-uniform output property of <span class="math">G</span> implies that <span class="math">zG_{r}</span> is uniformly distributed, over a random choice of <span class="math">G_{r}</span>; therefore the probability that <span class="math">z\\in\\mathbb{F}^{n}</span> is in <span class="math">(G_{r})^{\\perp}</span> is at most <span class="math">q^{-k_{r}}</span>. Taking a union bound over all vectors of weight at most <span class="math">b</span>, of which there are at most <span class="math">q^{H_{q}(b/n)\\cdot n}</span>, gives an upper bound on the probability that the distance of <span class="math">(G_{r})^{\\perp}</span> is at most <span class="math">b</span>.</p>

    <p class="text-gray-300">We can choose parameters so that <span class="math">n=O(k_{m})</span> and <span class="math">k_{r}=O(H_{q}(b/n)\\cdot n)</span> with suitable constants so that <span class="math">q^{-k_{r}}\\cdot q^{H_{q}(b/n)\\cdot n}=q^{-\\Omega(k_{m})}</span>. In combination with results on the distance of <span class="math">G</span>, this yields Theorem 6.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">In sum, we obtain a trade-off between the fraction of the message space allocated to the encoding randomness and the <span class="math">b</span>-query uniformity of the code. For example, if (as we use in this paper) <span class="math">b</span> is linear in <span class="math">n</span> then <span class="math">H_{q}(b/n)</span> is constant and the encoding randomness is a constant fraction of the input.</p>

    <p class="text-gray-300">Comparison with related work. Chen et al. <em>[x1]</em> show a result analogous to Theorem 6 for random codes: with high probability over a choice of random code with block length <span class="math">O(k_{m})</span>, using <span class="math">H_{q}(\\beta(k_{m}))\\cdot O(k_{m})</span> elements of encoding randomness ensures <span class="math">O(\\beta(k_{m})\\cdot k_{m})</span>-query zero-knowledge. Random codes, however, are not linear-time encodable. Theorem 6 can be viewed as strengthening the result for random codes in <em>[x1, Theorem 11]</em> to apply to the linear-time codes of <em>[x11]</em> (and to proving the stronger property of bounded-query uniformity). The proofs of both results follow the standard template of the existence proof of codes meeting the Gilbert–Varshamov bound, except that the analyzed code family changes.</p>

    <p class="text-gray-300">Druk and Ishai <em>[x11]</em> give a linear-time secret sharing scheme for message vectors of constant length, based on the same code family used to prove Theorem 6. Their construction generalizes to a randomized encoding scheme with <span class="math">b</span>-query zero-knowledge (and most likely <span class="math">b</span>-query uniformity), where <span class="math">b</span> is determined by the distance of the dual code. For this code family, the dual distance is linear in <span class="math">k_{m}</span>, giving <span class="math">b</span>-query zero-knowledge for <span class="math">b=\\Theta(k_{m})</span>. However, encoding requires solving a system of linear equations whose dimension is the same length as the message, and so fails to be linear-time.</p>

    <p class="text-gray-300">Ishai et al. <em>[x21, x34]</em> give a generic construction of zero-knowledge codes from any linear code, which works by randomizing a generator matrix for the code, but this does not preserve linear-time encoding.</p>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">2.7 Linear-time succinct arguments from linear-time IOPs</h3>

    <p class="text-gray-300">Known approaches for constructing succinct arguments rely on cryptography to “compile” various forms of probabilistic proofs into argument systems. However, the cryptography used typically introduces super-linear overheads, ruling out a linear-time argument system even when compiling a linear-time probabilistic proof. Bootle et al. <em>[x1]</em> observe that Kilian’s approach <em>[x27]</em> is a notable exception. We review this below because Theorem 1 implies Theorem 2 via this approach; our technical contribution is Theorem 1.</p>

    <p class="text-gray-300">Linear-time arguments via Kilian’s approach. The cryptography used in Kilian’s approach is collision-resistant hash functions, for which there are linear-time candidates under standard assumptions (e.g., based on the hardness of finding short codewords in linear codes <em>[x1]</em>). If we use a linear-time hash function in Kilian’s approach to compile a linear-time PCP (over a large-enough alphabet) then we obtain a linear-time argument system. While constructions of linear-time PCPs are not known (and seem far beyond current techniques), the foregoing implication equally holds for IOPs <em>[x6, x30]</em>. This route was used in <em>[x1, x2]</em> to obtain interactive arguments with linear-time prover and sublinear-time verifier from IOPs with linear-time prover and sublinear-time verifier.</p>

    <p class="text-gray-300">Zero knowledge. Kilian’s approach to additionally achieve zero knowledge makes a non-black-box use of the collision-resistant hash function and the probabilistic proof’s verifier. Ishai et al. <em>[x22]</em> then proved that if the underlying probabilistic proof satisfies a mild notion of zero knowledge then Kilian’s approach can be significantly simplified to yield a zero-knowledge succinct argument where <em>the collision-resistant hash function and the probabilistic proof are used as black boxes</em>. This implication, too, preserves linear time of both building blocks to yield a zero-knowledge succinct argument with a linear-time prover.</p>

    <p class="text-gray-300">The notion of zero-knowledge required of the underlying probabilistic proof depends on the desired notion of zero knowledge for the argument system. If the argument system is desired to be honest-verifier zero knowledge (this suffices, e.g., to subsequently apply the Fiat–Shamir heuristic) then the probabilistic proof must be honest-verifier zero knowledge. If instead the argument system is desired to be malicious-verifier zero-knowledge then the probabilistic proof must be <em>semi</em>-honest-verifier zero knowledge (the simulator works for any possible fixed execution of the honest verifier). A further strengthening known as bounded-query zero knowledge, the hiding notion typically studied for PCPs <em>[x13]</em>, enables reductions in communication.</p>

    <p class="text-gray-300">In sum. The interactive argument in Theorem 2 is constructed via the above approach from the IOP in Theorem 1 (with sublinear verification in the holographic setting mapping to sublinear verification in the preprocessing setting). The semi-honest-verifier zero-knowledge property of the IOP implies the malicious-verifier zero-knowledge property of the interactive argument. The linear prover time and polylogarithmic verifier time of the IOP imply the corresponding running times of the interactive argument, as the given collision-resistant hash function runs in linear time.</p>

    <p class="text-gray-300">3 Preliminaries</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">3.1 Interactive oracle proofs with special queries</h3>

    <h6 id="sec-39" class="text-base font-medium mt-4">Definition 3.1.</h6>

    <p class="text-gray-300">An indexed relation <span class="math">R</span> is a set of triples <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})</span> where <span class="math">\\mathfrak{i}</span> is the index, <span class="math">\\mathtt{x}</span> the instance, and <span class="math">\\mathtt{w}</span> the witness. The corresponding indexed language <span class="math">L(R)</span> is the set of pairs <span class="math">(\\mathfrak{i},\\mathtt{x})</span> for which there exists a witness <span class="math">\\mathtt{w}</span> such that <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})\\in R</span>.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Definition 3.2.</h6>

    <p class="text-gray-300">A holographic IOP with query class <span class="math">\\mathcal{Q}</span> (some set of functions) is a tuple <span class="math">\\mathsf{IOP}=(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span>, where <span class="math">\\mathbf{I}</span> is the <em>indexer</em>, <span class="math">\\mathbf{P}</span> the <em>prover</em>, and <span class="math">\\mathbf{V}</span> the <em>verifier</em>. The indexer is a deterministic polynomial-time algorithm, while the prover and verifier are probabilistic polynomial-time interactive algorithms.</p>

    <p class="text-gray-300">In an offline phase, the indexer <span class="math">\\mathbf{I}</span> is given an index <span class="math">\\mathfrak{i}</span> and outputs an encoding <span class="math">\\Pi_{0}</span> of <span class="math">\\mathfrak{i}</span>.</p>

    <p class="text-gray-300">In an online phase, the prover <span class="math">\\mathbf{P}</span> receives as input an index-instance-witness tuple <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})</span> and the verifier <span class="math">\\mathbf{V}</span> receives as input the instance <span class="math">\\mathtt{x}</span>; in addition, the verifier <span class="math">\\mathbf{V}</span> has query access to <span class="math">\\Pi_{0}</span> (in a precise sense specified below), which we denote as <span class="math">\\mathbf{V}^{\\Pi_{0}}(\\mathtt{x})</span>. The online phase consists of multiple rounds, and in each round the prover <span class="math">\\mathbf{P}</span> sends a proof message <span class="math">\\Pi_{i}</span> and the verifier <span class="math">\\mathbf{V}</span> replies with a challenge message <span class="math">\\rho_{i}</span>.</p>

    <p class="text-gray-300">The prover <span class="math">\\mathbf{P}</span> may compute its proof message <span class="math">\\Pi_{i}</span> based on its input <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})</span> and all the verifier challenges received thus far (none if <span class="math">i=1</span> or <span class="math">\\rho_{1},\\ldots,\\rho_{i-1}</span> if <span class="math">i&gt;1</span>). In contrast, the verifier <span class="math">\\mathbf{V}</span> may compute its challenge message <span class="math">\\rho_{i}</span> based on its input <span class="math">\\mathtt{x}</span> and on answers obtained by querying <span class="math">(\\Pi_{0},\\Pi_{1},\\ldots,\\Pi_{i})</span> via queries in <span class="math">\\mathcal{Q}</span>. In more detail, the answer of a query <span class="math">q\\in\\mathcal{Q}</span> to <span class="math">(\\Pi_{0},\\Pi_{1},\\ldots,\\Pi_{i})</span> is <span class="math">v:=q(\\mathtt{x},\\Pi_{0},\\Pi_{1},\\ldots,\\Pi_{i})</span> (this answer could also be a special error value in case the proof messages are not according to an expected format).</p>

    <p class="text-gray-300">After the interaction and all queries are concluded, the verifier <span class="math">\\mathbf{V}</span> accepts or rejects.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Remark 3.3 (non-oracle messages).</h6>

    <p class="text-gray-300">We allow the prover in an IOP to also send, at any point in the interaction, arbitrary messages that the verifier will simply read in full (without making any queries) as in a usual interactive proof. We refer to such messages as <em>non-oracle messages</em>, to differentiate them from the <em>oracle messages</em> to which the verifier has query access. These non-oracle messages can typically be viewed as degenerate cases of oracle messages, and we use them in protocol descriptions for convenience of exposition.</p>

    <p class="text-gray-300">A holographic interactive oracle proof <span class="math">\\mathsf{IOP}=(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> for an indexed relation <span class="math">R</span> has completeness <span class="math">1</span> and soundness error <span class="math">\\epsilon</span> if the following holds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>Completeness. For every index-instance-witness tuple <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})\\in R</span>, the probability that <span class="math">\\mathbf{P}(\\mathfrak{i},\\mathtt{x},\\mathtt{w})</span> convinces <span class="math">\\mathbf{V}^{\\mathbf{I}(\\mathfrak{i})}(\\mathtt{x})</span> to accept is <span class="math">1</span>.</li>

      <li>Soundness. For every index-instance tuple <span class="math">(\\mathfrak{i},\\mathtt{x})\\notin L(R)</span> and malicious prover <span class="math">\\tilde{\\mathbf{P}}</span>, the probability that <span class="math">\\tilde{\\mathbf{P}}</span> convinces <span class="math">\\mathbf{V}^{\\mathbf{I}(\\mathfrak{i})}(\\mathtt{x})</span> to accept is at most <span class="math">\\epsilon</span>.</li>

    </ul>

    <h5 id="sec-42" class="text-base font-semibold mt-4">Public coins.</h5>

    <p class="text-gray-300">A holographic IOP is <em>public-coin</em> if each verifier message to the prover is a random string. This means that the verifier’s randomness is its challenge messages <span class="math">\\rho_{1},\\ldots,\\rho_{\\mathsf{rc}}</span>. All verifier queries can be postponed, without loss of generality, to a query phase that occurs after the interactive phase with the prover.</p>

    <h5 id="sec-43" class="text-base font-semibold mt-4">Non-adaptive queries.</h5>

    <p class="text-gray-300">A holographic IOP is <em>non-adaptive</em> if all verifier queries depend solely on the input instance <span class="math">\\mathtt{x}</span> and the verifier’s randomness, as opposed to some queries depending on answers to prior queries. For non-adaptive IOPs, the verifier <span class="math">\\mathbf{V}</span> can be written as a pair of algorithms <span class="math">(\\mathbf{V}_{\\mathrm{q}},\\mathbf{V}_{\\mathrm{d}})</span> where: (a) <span class="math">\\mathbf{V}_{\\mathrm{q}}</span> is probabilistic, takes as input the instance <span class="math">\\mathtt{x}</span>, interacts with the prover <span class="math">\\mathbf{P}</span>, and outputs a decision state <span class="math">\\sigma</span> and a query set <span class="math">I</span> (for the index oracle and proof oracles); and (b) <span class="math">\\mathbf{V}_{\\mathrm{d}}</span> is deterministic, takes as input the decision state <span class="math">\\sigma</span> and query answers <span class="math">\\mathbf{v}\\in\\Sigma^{I}</span>, and outputs a decision bit. For this case, we define the relation <span class="math">R(\\mathbf{V})</span> to be all pairs <span class="math">(\\sigma,\\mathbf{v})</span> such that there exist <span class="math">\\mathtt{x}</span> and <span class="math">I</span> with <span class="math">(\\sigma,I)</span> in the support of <span class="math">\\mathbf{V}_{\\mathrm{q}}(\\mathtt{x})</span> and <span class="math">\\mathbf{V}_{\\mathrm{d}}(\\sigma,\\mathbf{v})=1</span>.</p>

    <h5 id="sec-44" class="text-base font-semibold mt-4">Complexity measures.</h5>

    <p class="text-gray-300">We consider several complexity measures:</p>

    <p class="text-gray-300">round complexity rc is the number of back-and-forth message exchanges between the prover and verifier;</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>answer alphabet <span class="math">\\Sigma</span> is the alphabet over which oracle messages are defined;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- proof length <span class="math">l=li+lp+lc</span> where $li:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the number of alphabet symbols output by the indexer, </span>lp:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\cdots+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi_{rc}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the total number of alphabet symbols sent in oracle messages by the prover, and </span>lc$ is the total number of alphabet symbols sent in non-oracle messages by the prover;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>randomness r is the number of random bits used by the verifier;</li>

      <li>query complexity q is the total number of queries made by the verifier (to any oracle);</li>

      <li>running time ti is the running time of <span class="math">\\mathbf{I}</span>, tp is the running time of <span class="math">\\mathbf{P}</span>, and tv is the running time of <span class="math">\\mathbf{V}</span>. In the non-adaptive case, tq and td are the running times of the query and decision components of <span class="math">\\mathbf{V}</span> respectively.</li>

    </ul>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">3.2 Point queries and tensor queries</h3>

    <p class="text-gray-300">We define the two query classes that we use in this paper, point queries and tensor queries.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Definition 3.4.</h6>

    <p class="text-gray-300">A holographic IOP with point queries is an IOP with the query class <span class="math">\\mathcal{Q}_{\\mathrm{point}}</span> defined as follows: <span class="math">\\mathcal{Q}_{\\mathrm{point}}</span> is all functions of the form <span class="math">q(\\mathtt{x},\\Pi_{0},\\Pi_{1},\\ldots,\\Pi_{i})=\\Pi_{j}[k]</span> for some <span class="math">j\\in\\{0,1,\\ldots,i\\}</span> and location <span class="math">k</span>. (If the location <span class="math">k</span> does not exist, the answer is an error.) Namely, each query in the class <span class="math">\\mathcal{Q}_{\\mathrm{point}}</span> returns the symbol at a location of the encoded index (<span class="math">j=0</span>) or of a specified prover message (<span class="math">j&gt;0</span>).</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Definition 3.5.</h6>

    <p class="text-gray-300">Given a finite field <span class="math">\\mathbb{F}</span> and positive integers <span class="math">k,t</span>, a holographic IOP with <span class="math">(\\mathbb{F},k,t)</span>-tensor queries is an IOP with the query class <span class="math">\\mathcal{Q}_{\\mathrm{tensor}}(\\mathbb{F},k,t)</span> defined as follows: <span class="math">\\mathcal{Q}_{\\mathrm{tensor}}(\\mathbb{F},k,t)</span> contains all functions of the form <span class="math">q(\\mathtt{x},\\Pi_{0},\\Pi_{1},\\ldots,\\Pi_{i})=\\langle q_{0}\\otimes q_{1}\\otimes\\cdots\\otimes q_{t},\\Pi_{j}\\rangle</span> for some <span class="math">j\\in\\{0,1,\\ldots,i\\}</span> and vectors <span class="math">q_{0}\\in\\mathbb{F}^{*}</span> and <span class="math">q_{1},\\ldots,q_{t}\\in\\mathbb{F}^{k}</span>. (If the lengths of the linear combination <span class="math">q_{0}\\otimes q_{1}\\otimes\\cdots\\otimes q_{t}</span> and proof string <span class="math">\\Pi_{j}</span> do not match, the answer is an error.) Namely, each query in the class <span class="math">\\mathcal{Q}_{\\mathrm{tensor}}</span> returns the scalar product of a certain tensor vector and the encoded index (<span class="math">j=0</span>) or of a specified prover message (<span class="math">j&gt;0</span>).</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Remark 3.6.</h6>

    <p class="text-gray-300">In the context of tensor IOPs, we often view a proof message <span class="math">\\Pi\\in\\mathbb{F}^{\\ell\\cdot k^{t}}</span> as consisting of <span class="math">\\ell</span> “sub-messages” <span class="math">\\pi_{1},\\ldots,\\pi_{\\ell}</span> each in <span class="math">\\mathbb{F}^{k^{t}}</span>. In this case, when describing a protocol, we may make a tensor query <span class="math">q_{1}\\otimes\\cdots\\otimes q_{t}</span> to one of the sub-messages <span class="math">\\pi</span>, with the understanding that one can specify an indicator vector <span class="math">q_{0}\\in\\mathbb{F}^{\\ell}</span> so that <span class="math">\\langle q_{0}\\otimes q_{1}\\otimes\\cdots\\otimes q_{t},\\Pi\\rangle=\\langle q_{1}\\otimes\\cdots\\otimes q_{t},\\pi\\rangle</span>.</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">3.3 Robust proofs</h3>

    <p class="text-gray-300">We sometimes require, for the case of non-adaptive verifiers, a stronger notion of soundness, robust soundness. Informally this means that, up to a soundness error <span class="math">\\epsilon</span>, the information read by the verifier is not only rejecting but also cannot be modified in few locations to make the verifier accept.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Definition 3.7.</h6>

    <p class="text-gray-300">A holographic interactive oracle proof <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> for an indexed relation <span class="math">R</span> has soundness error <span class="math">\\epsilon</span> with robustness parameter <span class="math">\\alpha</span> relative to distance <span class="math">\\Delta</span> if <span class="math">\\mathbf{V}</span>’s queries are non-adaptive and, for every index-instance tuple <span class="math">(\\dot{\\mathtt{i}},\\mathtt{x})\\notin L(R)</span> and malicious prover <span class="math">\\tilde{\\mathbf{P}}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\Pr\\left[\\Delta\\left(\\mathbf{v},R(\\mathbf{V})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma}\\right)\\leq\\alpha\\ \\right]\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\begin{array}[]{c}\\left[\\tilde{\\Pi},(\\sigma,I)\\right]\\leftarrow\\langle\\tilde{\\mathbf{P}},\\mathbf{V}_{\\mathrm{q}}(\\mathtt{x})\\rangle\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{v}:=(\\mathbf{I}(\\dot{\\mathtt{i}}),\\tilde{\\Pi})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I}\\end{array}\\bigg{]}\\leq\\epsilon\\enspace. \\]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Above, <span class="math">(\\sigma,I)</span> is the output of the query sampler algorithm <span class="math">\\mathbf{V}_{\\mathrm{q}}(\\mathtt{x})</span> when interacting with <span class="math">\\tilde{\\mathbf{P}}</span> and <span class="math">\\tilde{\\Pi}</span> consists of all proof oracles sent by <span class="math">\\tilde{\\mathbf{P}}</span> during this interaction; and $R(\\mathbf{V})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma}<span class="math"> is the set of all query answers </span>\\mathbf{v}^{\\prime}<span class="math"> such that </span>(\\sigma,\\mathbf{v}^{\\prime})\\in R(\\mathbf{V})<span class="math">. The probability is taken over </span>\\mathbf{V}_{\\mathrm{q}}$’s randomness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">3.4 Proximity proofs</p>

    <p class="text-gray-300">A holographic interactive oracle proof of proximity <span class="math">\\mathsf{IOPP}=(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> for an indexed relation <span class="math">R</span> has completeness <span class="math">1</span> and soundness error <span class="math">\\epsilon</span> with distance function <span class="math">\\Delta</span> if the following holds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For every index-instance-witness tuple <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})\\in R</span>, the probability that <span class="math">\\mathbf{P}(\\mathfrak{i},\\mathtt{x},\\mathtt{w})</span> convinces <span class="math">\\mathbf{V}^{\\mathbf{I}(\\mathfrak{i}),\\mathtt{w}}(\\mathtt{x})</span> to accept is <span class="math">1</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Proximity soundness. For every index-instance tuple <span class="math">(\\mathfrak{i},\\mathtt{x})</span> and malicious prover <span class="math">\\tilde{\\mathbf{P}}</span>, the probability that <span class="math">\\tilde{\\mathbf{P}}</span> convinces <span class="math">\\mathbf{V}^{\\mathbf{I}(\\mathfrak{i}),\\mathtt{w}}(\\mathtt{x})</span> to accept is at most $\\epsilon(\\Delta(\\mathtt{w},R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{(\\mathfrak{i},\\mathtt{x})}))<span class="math">. Here the soundness error </span>\\epsilon<span class="math"> is a function of the </span>\\Delta<span class="math">-distance of </span>\\mathtt{w}<span class="math"> to the set of valid witnesses </span>R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{(\\mathfrak{i},\\mathtt{x})}:=\\{\\mathtt{w}^{\\prime}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,(\\mathfrak{i},\\mathtt{x},\\mathtt{w}^{\\prime})\\in R\\}<span class="math">. (Intuitively, one expects the soundness error to go down as the distance of </span>\\mathtt{w}<span class="math"> to valid witnesses increases.) If the set of valid witnesses </span>R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{(\\mathfrak{i},\\mathtt{x})}<span class="math"> is empty (this happens when </span>(\\mathfrak{i},\\mathtt{x})\\not\\in L(R)<span class="math">) then we use the convention </span>\\Delta(\\mathtt{w},\\emptyset):=1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We remark that, while not explicit above, each verifier’s query <span class="math">q\\in\\mathcal{Q}</span> is to <span class="math">(\\mathbf{I}(\\mathfrak{i}),\\mathtt{w},\\Pi_{1},\\ldots,\\Pi_{i})</span> and its answer is <span class="math">q(\\mathtt{x},\\mathbf{I}(\\mathfrak{i}),\\mathtt{w},\\Pi_{1},\\ldots,\\Pi_{i})</span>; namely, the candidate witness <span class="math">\\mathtt{w}</span> is also an input to the query function <span class="math">q</span>. The definition of IOPs with particular query classes (e.g., point-query IOPs) extend naturally to this case.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Exact proximity proofs. We are sometimes in the position where if $\\Delta(\\mathtt{w},R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{(\\mathfrak{i},\\mathtt{x})})>0<span class="math"> then </span>\\epsilon(\\Delta(\\mathtt{w},R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{(\\mathfrak{i},\\mathtt{x})}))=\\epsilon<span class="math"> where </span>\\epsilon\\in(0,1)<span class="math"> does not depend on the distance. In other words, whenever </span>(\\mathfrak{i},\\mathtt{x})\\notin L(R)<span class="math">, then for any malicious prover </span>\\tilde{\\mathbf{P}}<span class="math">, the probability that </span>\\tilde{\\mathbf{P}}<span class="math"> convinces </span>\\mathbf{V}^{\\mathbf{I}(\\mathfrak{i})}(\\mathtt{x})<span class="math"> to accept is at most </span>\\epsilon<span class="math">. In such cases, we do not mention the distance function </span>\\Delta$, and use the terminology exact interactive oracle proof of proximity (exact IOPP), analogous to that used in <em>[x13]</em> for probabilistically-checkable proofs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-51" class="text-xl font-semibold mt-8">3.5 Zero knowledge</h3>

    <p class="text-gray-300">The main notion of zero-knowledge that we achieve in this paper is (perfect) zero-knowledge against semi-honest verifiers. This means that for any choice of verifier randomness, an honest verifier’s queries do not leak any information about the prover’s witness. We also investigate (perfect) zero knowledge against malicious verifiers that make a bounded number of queries to the proof oracles. This means that the malicious verifier can send to the honest prover arbitrary messages and also query any proof oracle sent by the prover in arbitrary, possibly adaptive, ways as long as the number of queried locations does not exceed a given query bound, which we usually denote by <span class="math">b</span>; the query bound can be a function of other parameters, e.g., input size.</p>

    <p class="text-gray-300">Below we define the notion of view and then the notions of zero knowledge that we use.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Definition 3.8.</h6>

    <p class="text-gray-300">We denote by <span class="math">\\mathrm{View}(\\mathbf{B},\\mathbf{A}(a))</span> the view of <span class="math">\\mathbf{A}</span>, on input <span class="math">a</span>, in an interactive protocol with <span class="math">\\mathbf{B}</span>. Namely, it is the random variable <span class="math">(r,b_{1},\\ldots,b_{n},v_{1},\\ldots,v_{m})</span> where <span class="math">r</span> is <span class="math">\\mathbf{A}</span>’s randomness, <span class="math">b_{1},\\ldots,b_{n}</span> are non-oracle messages sent from <span class="math">\\mathbf{B}</span> to <span class="math">\\mathbf{A}</span>, and <span class="math">v_{1},\\ldots,v_{m}</span> are the answers to <span class="math">\\mathbf{A}</span>’s queries to <span class="math">\\mathbf{B}</span>’s oracle messages. (There is no need to include any messages from <span class="math">\\mathbf{A}</span> to <span class="math">\\mathbf{B}</span> as these are implied by the other information in the view.)</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Definition 3.9.</h6>

    <p class="text-gray-300">Let <span class="math">A</span> be an algorithm with adaptive query access to oracles <span class="math">\\mathcal{O}_{1},\\ldots,\\mathcal{O}_{n}</span>. Let <span class="math">\\mathbf{Q}</span> be a stateful query-checker algorithm which receives the adaptive queries of <span class="math">A</span> and may output <span class="math">\\bot</span> at any point. We say that <span class="math">A</span> is a <span class="math">\\mathbf{Q}</span>-query algorithm if <span class="math">\\mathbf{Q}</span> never outputs <span class="math">\\bot</span>.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Definition 3.10.</h6>

    <p class="text-gray-300">A holographic IOP <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> for an indexed relation <span class="math">R</span> is (perfect) zero-knowledge with query-checker <span class="math">\\mathbf{Q}</span> if there exists a polynomial-time simulator algorithm <span class="math">\\mathbf{S}</span> such that, for every <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})\\in R</span> and <span class="math">\\mathbf{Q}</span>-query algorithm <span class="math">\\tilde{\\mathbf{V}}</span>, the random variables <span class="math">\\mathbf{S}^{\\tilde{\\mathbf{V}}}(\\mathfrak{i},\\mathtt{x})</span> and <span class="math">\\mathrm{View}(\\mathbf{P}(\\mathfrak{i},\\mathtt{x},\\mathtt{w}),\\tilde{\\mathbf{V}})</span> are identically distributed.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Definition 3.11.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{Q}_{b}</span> be a query-checker algorithm which outputs <span class="math">\\bot</span> if more than <span class="math">b</span> queries are made. For the query-checker <span class="math">\\mathbf{Q}_{b}</span>, we refer to <span class="math">A</span> from Definition 3.9 as a <span class="math">b</span>-query algorithm, and say that <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> from Definition 3.10 has (perfect) zero-knowledge with query bound <span class="math">b</span>.</p>

    <p class="text-gray-300">All results in this paper achieve the definition above via <em>straightline</em> simulators, which means that the simulator samples the view of the verifier by running through a single execution of the malicious verifier, simulating any (non-oracle) messages from the prover or the answers to any of the malicious verifier’s queries.</p>

    <p class="text-gray-300">For intermediate building blocks we will also consider a relaxation of the above definition where we require zero knowledge to hold only against <em>semi-honest</em> verifiers, which are malicious verifiers whose messages and queries are consistent with some execution of an honest verifier though they may be distributed differently than those of an honest verifier.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Definition 3.12.</h6>

    <p class="text-gray-300">A holographic interactive oracle proof <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> for an indexed relation <span class="math">R</span> is (perfect) zero knowledge against semi-honest verifiers if there exists a polynomial-time simulator algorithm <span class="math">\\mathbf{S}</span> such that, for every <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})\\in R</span> and choice of verifier randomness <span class="math">\\rho</span>, the random variables <span class="math">\\mathbf{S}^{\\mathbf{V}(\\mathfrak{i},\\mathtt{x};\\rho)}(\\mathfrak{i},\\mathtt{x})</span> and <span class="math">\\mathrm{View}(\\mathbf{P}(\\mathfrak{i},\\mathtt{x},\\mathtt{w}),\\mathbf{V}(\\mathfrak{i},\\mathtt{x};\\rho))</span> are identically distributed.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Remark 3.13.</h6>

    <p class="text-gray-300">If a holographic IOP <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> is zero-knowledge with query-checker <span class="math">\\mathbf{Q}</span>, and for choice of verifier randomness <span class="math">\\rho</span>, the verifier <span class="math">\\mathbf{V}</span> is a <span class="math">\\mathbf{Q}</span>-query algorithm, then <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> is zero knowledge against semi-honest verifiers.</p>

    <p class="text-gray-300">Finally, we also consider zero knowledge for proximity proofs, which we use towards our main result. The notion of (perfect) zero knowledge in the definition below is closely related to prior ones used for proximity proofs, such as for PCPPs in <em>[x11]</em> and for IOPPs in <em>[x3]</em>. The main technical difference is that we consider a query function <span class="math">f</span> that determines how many queries the simulator makes to the witness as a function of the number of queries made to the witness <em>and any proof oracles sent by the prover</em>.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Definition 3.14.</h6>

    <p class="text-gray-300">A holographic interactive oracle proof of proximity <span class="math">\\mathsf{IOPP}=(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> for an indexed relation <span class="math">R</span> is (perfect) zero knowledge with query function <span class="math">f</span> if there exists a polynomial-time simulator algorithm <span class="math">\\mathbf{S}</span> such that, for every <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})\\in R</span>, query checker <span class="math">\\mathbf{Q}</span>, and <span class="math">\\mathbf{Q}</span>-query algorithm <span class="math">\\tilde{\\mathbf{V}}</span>, the random variables <span class="math">\\mathbf{S}^{\\tilde{\\mathbf{V}},\\mathtt{w}}(\\mathfrak{i},\\mathtt{x})</span> and <span class="math">\\mathrm{View}(\\mathbf{P}(\\mathfrak{i},\\mathtt{x},\\mathtt{w}),\\tilde{\\mathbf{V}})</span> are identically distributed, and <span class="math">\\mathbf{S}</span> is <span class="math">f(\\mathbf{Q})</span>-query with respect to <span class="math">\\mathtt{w}</span>.</p>

    <p class="text-gray-300">We conclude by remarking that all of the zero knowledge definitions above are sensitive to the choice of alphabet for the proof oracles because they all refer to the query complexity of certain verifiers (and a query to a proof oracle returns an entire alphabet symbol). In particular, when we establish that a certain construction achieves zero knowledge, this is proved for a specific choice of alphabet and there are guarantees for, e.g., if the alphabet is changed a smaller one and the query bound is increased correspondingly.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Remark 3.15.</h6>

    <p class="text-gray-300">In the above definitions we required the simulator to output a verifier view, which in particular includes the verifier’s randomness. However, as we do not restrict the efficiency of verifiers, the verifier’s randomness could have super-polynomial size, in which case the (polynomial-time) simulator cannot sample it on the verifier’s behalf. This is a minor technicality that is resolved, as in prior work, as follows: we assume that the verifier is initialized with its own randomness and the simulator is only required to produce the rest of the view (simulated messages and query answers) by having access to the verifier but not to its randomness.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">3.6 Error-correcting codes</p>

    <p class="text-gray-300">We introduce preliminaries on error-correcting codes.</p>

    <p class="text-gray-300">We consider functions <span class="math">c\\colon[n]\\to\\mathbb{F}</span> for a given domain <span class="math">[n]</span> and finite field <span class="math">\\mathbb{F}</span>. The (absolute) distance <span class="math">d(c,c^{\\prime})</span> between two functions <span class="math">c,c^{\\prime}\\colon[n]\\to\\mathbb{F}</span> is the number of inputs for which <span class="math">c</span> and <span class="math">c^{\\prime}</span> differ; the relative distance is <span class="math">\\delta(c,c^{\\prime}):=d(c,c^{\\prime})/n</span>. The weight of <span class="math">c</span> is the number of inputs for which <span class="math">c</span> is non-zero.</p>

    <p class="text-gray-300">A linear error-correcting code <span class="math">\\mathcal{C}</span> over <span class="math">\\mathbb{F}</span> is a set of functions <span class="math">c\\colon[n]\\to\\mathbb{F}</span> that form an <span class="math">\\mathbb{F}</span>-linear space. The block length is <span class="math">n</span> and the message length is the rank <span class="math">k</span> of the linear space <span class="math">\\mathcal{C}</span>; the rate is <span class="math">\\rho:=k/n</span>. The minimum (absolute) distance <span class="math">d:=d(\\mathcal{C})</span> is the minimal (absolute) distance between any two distinct codewords <span class="math">c</span> and <span class="math">c^{\\prime}</span> in <span class="math">\\mathcal{C}</span>. The minimum relative distance <span class="math">\\delta:=\\delta(\\mathcal{C})</span> of the code is defined similarly.</p>

    <p class="text-gray-300">For a given function <span class="math">c\\colon[n]\\to\\mathbb{F}</span>, if <span class="math">d(c,\\mathcal{C})</span> is smaller than the unique decoding radius of <span class="math">\\mathcal{C}</span> (which is <span class="math">d(\\mathcal{C})/2</span>), there is a unique codeword <span class="math">\\bar{c}\\in\\mathcal{C}</span> closest to <span class="math">c</span>; otherwise we default to setting <span class="math">\\bar{c}:=0</span>.</p>

    <p class="text-gray-300">Codewords can also be viewed as vectors in <span class="math">\\mathbb{F}^{n}</span>, and we can associate to them messages in <span class="math">\\mathbb{F}^{k}</span>. This leads to two fundamental notions associated to a linear codes.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generator matrix. A generator matrix for <span class="math">\\mathcal{C}</span> is a matrix <span class="math">G\\in\\mathbb{F}^{n\\times k}</span> whose rows generate <span class="math">\\mathcal{C}</span> as a linear subspace of <span class="math">\\mathbb{F}^{n}</span>. In particular, <span class="math">G</span> is an injective map from <span class="math">\\mathbb{F}^{k}</span> to <span class="math">\\mathcal{C}</span>, and thus associates to each vector <span class="math">f\\in\\mathbb{F}^{k}</span> the corresponding codeword <span class="math">c:=Gf\\in\\mathcal{C}</span>. The cost of encoding a message this way is <span class="math">O(k\\cdot n)</span> operations (or, more generally, is linear in the number of non-zero entries in <span class="math">G</span>). There are multiple generator matrices for the same code (they are in one-to-one correspondence with ordered bases of <span class="math">\\mathcal{C}</span>).</li>

      <li>Parity-check matrix. A parity-check matrix for <span class="math">\\mathcal{C}</span> is a generator matrix <span class="math">H\\in\\mathbb{F}^{n\\times(n-k)}</span> for the dual code <span class="math">\\mathcal{C}^{\\perp}</span> or equivalently, a matrix <span class="math">H</span> such that, for every <span class="math">c\\in\\mathbb{F}^{n}</span>, it holds that <span class="math">c\\in\\mathcal{C}</span> if and only if <span class="math">H^{\\intercal}c=0</span>. The cost of checking whether a function <span class="math">c</span> is a codeword in this way is <span class="math">O(n\\cdot(n-k))</span> operations (or, more generally, is linear in the number of non-zero entries in <span class="math">H</span>). If <span class="math">G</span> is any generator matrix for <span class="math">\\mathcal{C}</span>, then it holds that <span class="math">H^{\\intercal}G=O_{(n-k)\\times k}</span>, where <span class="math">O_{(n-k)\\times k}</span> is the <span class="math">(n-k)\\times k</span> matrix of all zeros.</li>

    </ul>

    <p class="text-gray-300">A parity-check matrix can be efficiently derived from <span class="math">G</span> in <span class="math">O(n\\cdot k^{2})</span> operations by writing <span class="math">G</span> in column-echelon form \\[ \\begin{bmatrix}I_{k}\\\\ A\\end{bmatrix} \\] for some <span class="math">A\\in\\mathbb{F}^{(n-k)\\times k}</span> and setting <span class="math">H:=\\begin{bmatrix}-A^{\\intercal}\\\\ I_{n-k}\\end{bmatrix}</span>. That <span class="math">H</span> is a parity-check matrix follows from the fact that <span class="math">H\\cdot G^{\\intercal}=0</span>, which shows that <span class="math">H</span> generates a sub-code of <span class="math">\\mathcal{C}^{\\perp}</span>, and that <span class="math">\\mathcal{C}^{\\perp}</span> has the same rank <span class="math">n-k</span> as <span class="math">H</span>, which then shows that <span class="math">H</span> generates all of <span class="math">\\mathcal{C}^{\\perp}</span>.</p>

    <p class="text-gray-300">The mapping from a message to its codeword need not be performed as a matrix-vector product (a generator matrix times the message), and so we will use the notation <span class="math">\\mathrm{Enc}\\colon\\mathbb{F}^{k}\\to\\mathcal{C}</span> to denote an injective function that performs this encoding possibly some other way (e.g., via an arithmetic circuit) for the sake of efficiency. Given the encoding function, one can always recover a generator matrix <span class="math">G</span> by evaluating <span class="math">\\mathrm{Enc}</span> at each unit vector of <span class="math">\\mathbb{F}^{k}</span> in some canonical order and using the evaluations as the columns of <span class="math">G</span>. We say that this is the generator matrix <span class="math">G</span> associated with <span class="math">\\mathrm{Enc}</span>.</p>

    <p class="text-gray-300">Another common operation is error-free decoding, which is the task of computing the (unique) message that corresponds to a given codeword. This can be done via a left inverse <span class="math">G^{+}</span> of <span class="math">G</span> (a matrix such that <span class="math">G^{+}G=I_{k}</span>); as <span class="math">G</span> has full rank, the left-inverse <span class="math">G^{+}</span> can be computed as <span class="math">(G^{\\intercal}G)^{-1}G^{\\intercal}</span> in <span class="math">O(n\\cdot k^{2})</span> operations.</p>

    <p class="text-gray-300">We will represent a linear code via (some representation of) all of these quantities, as follows.</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Definition 3.16.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}</span> be a linear code over a field <span class="math">\\mathbb{F}</span>. The public parameters <span class="math">(\\mathrm{Enc},G,H,G^{+})</span> of <span class="math">\\mathcal{C}</span> consist of an injective encoding function <span class="math">\\mathrm{Enc}\\colon\\mathbb{F}^{k}\\to\\mathbb{F}^{n}</span> such that <span class="math">\\mathcal{C}=\\mathrm{Enc}(\\mathbb{F}^{k})</span>, a generator matrix <span class="math">G\\in\\mathbb{F}^{n\\times k}</span>, a parity-check matrix <span class="math">H\\in\\mathbb{F}^{n\\times(n-k)}</span>, and a left-inverse <span class="math">G^{+}\\in\\mathbb{F}^{k\\times n}</span> of <span class="math">G</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Interleaved codes. We say that <span class="math">c</span> is an <em>interleaved codeword</em> if, for some <span class="math">\\ell\\in\\mathbb{N}</span>, we have <span class="math">c\\in\\mathcal{C}^{\\ell}</span>. We equivalently view <span class="math">c</span> as a function from <span class="math">[\\ell]\\times[n]</span> to <span class="math">\\mathbb{F}</span> or as a matrix in <span class="math">\\mathbb{F}^{\\ell\\times n}</span>.</p>

    <p class="text-gray-300">We consider a single symbol of a function <span class="math">c\\colon[\\ell]\\times[n]\\to\\mathbb{F}</span> to be a column of the <span class="math">\\ell\\times n</span> matrix that represents <span class="math">c</span> (the column thus contains <span class="math">\\ell</span> elements of <span class="math">\\mathbb{F}</span>). Accordingly, we define the block-wise (absolute) distance between two functions <span class="math">c,c^{\\prime}\\colon[\\ell]\\times[n]\\to\\mathbb{F}</span> to be the number of columns in which <span class="math">c</span> and <span class="math">c^{\\prime}</span> differ. If <span class="math">c</span> is within the unique decoding radius of <span class="math">\\mathcal{C}^{\\ell}</span>, we denote by <span class="math">\\overline{c}</span> the unique codeword in <span class="math">\\mathcal{C}^{\\ell}</span> that is closest to <span class="math">c</span> (and otherwise we default to setting <span class="math">\\overline{c}:=0</span>); note that <span class="math">\\overline{c}</span> is obtained by replacing each row of <span class="math">c</span> with the corresponding closest codeword in <span class="math">\\mathcal{C}</span>.</p>

    <p class="text-gray-300">Moreover, we define the block-wise relative distance of a set of functions <span class="math">\\{c^{(s)}\\colon[\\ell]\\times[n]\\to\\mathbb{F}\\}_{s}</span> to <span class="math">\\mathcal{C}</span> to be the fraction of columns where at least one of the functions deviates from a codeword, as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Delta(\\{c^{(s)}\\}_{s},\\mathcal{C}):=\\frac{\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\big{\\{}j\\in[n]\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\ \\ \\exists\\,(s,i)\\text{ s.t. }c^{(s)}(i,j)\\neq\\overline{c}^{(s)}(i,j)\\ \\ \\big{\\}}\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}{n}\\ \\ .$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-61" class="text-base font-semibold mt-4">Tensor-product codes.</h5>

    <p class="text-gray-300">The tensor product code <span class="math">\\mathcal{C}^{\\otimes t}</span> is the linear code in <span class="math">\\mathbb{F}^{n^{t}}</span> with message length <span class="math">k^{t}</span>, block length <span class="math">n^{t}</span>, and distance <span class="math">d^{t}</span> that comprises all functions <span class="math">c\\colon[n]^{t}\\to\\mathbb{F}</span> whose restriction to any axis-parallel line is in <span class="math">\\mathcal{C}</span>. Namely, for every <span class="math">j\\in[t]</span> and <span class="math">a_{1},\\ldots,a_{j-1},a_{j+1},\\ldots,a_{t}\\in[n]</span>, the function <span class="math">c^{\\prime}\\colon[n]\\to\\mathbb{F}</span> defined by <span class="math">c^{\\prime}(i):=c(a_{1},\\ldots,a_{j-1},i,a_{j+1},\\ldots,a_{t})</span> is in <span class="math">\\mathcal{C}</span>. The encoding function associated to <span class="math">\\mathcal{C}^{\\otimes t}</span> is defined below.</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Definition 3.17.</h6>

    <p class="text-gray-300">Let <span class="math">G\\colon[n]\\times[k]\\to\\mathbb{F}</span> be the generator matrix associated with the encoding function <span class="math">\\mathrm{Enc}</span> of a linear code <span class="math">\\mathcal{C}</span> in <span class="math">\\mathbb{F}^{n}</span>, and <span class="math">f\\colon[k]^{t}\\to\\mathbb{F}</span> a message function with inputs indexed by <span class="math">(i_{1},\\ldots,i_{t})</span>. The <span class="math">\\mathcal{C}^{\\otimes t}</span>-encoding of <span class="math">f</span> is the function <span class="math">\\mathrm{Enc}_{1,\\ldots,t}(f)\\colon[n]^{t}\\to\\mathbb{F}</span>, with inputs indexed by <span class="math">(j_{1},\\ldots,j_{t})</span>, defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Enc}_{1,\\ldots,t}(f)(j_{1},\\ldots,j_{t}):=\\sum_{i_{1},\\ldots,i_{t}\\in[k]}G(j_{1},i_{1})\\cdots G(j_{t},i_{t})f(i_{1},\\ldots,i_{t})\\ \\ .</span></p>

    <p class="text-gray-300">While the encoding function of <span class="math">\\mathcal{C}^{\\otimes t}</span> is most conveniently defined in terms of the generator matrix <span class="math">G</span> of <span class="math">\\mathrm{Enc}</span>, it may be significantly cheaper to compute it using <span class="math">\\mathrm{Enc}_{\\mathcal{C}}</span>.</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Lemma 3.18.</h6>

    <p class="text-gray-300">If the encoding function <span class="math">\\mathrm{Enc}\\colon\\mathbb{F}^{k}\\to\\mathcal{C}</span> of a code <span class="math">\\mathcal{C}</span> has arithmetic complexity <span class="math">\\theta(k)\\cdot k</span>, then the encoding function <span class="math">\\mathrm{Enc}_{1,\\ldots,t}\\colon\\mathbb{F}^{k}\\to\\mathcal{C}^{\\otimes t}</span> of the tensor code <span class="math">\\mathcal{C}^{\\otimes t}</span> has arithmetic complexity <span class="math">\\frac{\\rho^{-t}-1}{\\rho^{-t}-1}\\theta(k)\\cdot k^{t}</span>. (In particular, if <span class="math">\\mathcal{C}</span> is linear-time encodable then so is the tensor code <span class="math">\\mathcal{C}^{\\otimes t}</span>.)</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Proof sketch.</h6>

    <p class="text-gray-300">View a message in <span class="math">\\mathbb{F}^{k^{t}}</span> as <span class="math">k^{t-1}</span> vectors in <span class="math">\\mathbb{F}^{k}</span>. Encode each of the vectors to get a partial encoding with <span class="math">k^{t-1}n</span> elements. View it as <span class="math">k^{t-2}n</span> vectors in <span class="math">\\mathbb{F}^{k}</span> and encode each of them to obtain a partial encoding with <span class="math">k^{t-2}n^{2}</span> elements. Compute <span class="math">t</span> partial encodings to obtain the full encoding.</p>

    <p class="text-gray-300">After performing <span class="math">r</span> partial encodings, there are <span class="math">k^{t-r}n^{r}=k^{t}\\rho^{-r}</span> elements of <span class="math">\\mathbb{F}</span>, which are then viewed as <span class="math">k^{t-1}\\rho^{-r}</span> vectors of <span class="math">\\mathbb{F}^{k}</span> before computing the next partial encoding. In this way, the final encoding can be obtained via <span class="math">\\theta(k)k^{t}+\\theta(k)k^{t}\\rho^{-1}+\\cdots+\\theta(k)k^{t}\\rho^{-t+1}=(1+\\rho^{-1}+\\cdots+\\rho^{-t+1})\\theta(k)k^{t}</span> operations. Summing the geometric series yields the claimed arithmetic complexity. ∎</p>

    <p class="text-gray-300">In later sections we will also need more general notions of encodings, which consider <em>partial encodings</em> of a high-dimensional array along different axis-parallel lines. We provide these definitions below.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Definition 3.19.</h6>

    <p class="text-gray-300">Let <span class="math">G\\colon[n]\\times[k]\\to\\mathbb{F}</span> be the generator matrix of a linear code <span class="math">\\mathcal{C}</span> in <span class="math">\\mathbb{F}^{n}</span>. The encoding of a function <span class="math">c\\colon[k]\\times[a_{1}]\\times\\cdots\\times[a_{h}]\\to\\mathbb{F}</span> is the function <span class="math">\\mathrm{Enc}(c)\\colon[n]\\times[a_{1}]\\times\\cdots\\times[a_{h}]\\to\\mathbb{F}</span> defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Enc}(c)(j,\\cdot,\\ldots,\\cdot):=\\sum_{i\\in[k]}G(j,i)c(i,\\cdot,\\ldots,\\cdot)\\ \\ .</span></p>

    <p class="text-gray-300">More generally, we write <span class="math">\\mathrm{Enc}_{r}</span> to indicate an encoding operation that is applied to the <span class="math">r</span>-th coordinate.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">3.7 Zero knowledge codes</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{C}</span> be a linear code over a field <span class="math">\\mathbb{F}</span> with message length <span class="math">k</span> and block length <span class="math">n</span>, and let <span class="math">(\\mathrm{Enc},G,H,G^{+})</span> be public parameters associated to the code. For any choice of <span class="math">k_{m},k_{r}\\in\\mathbb{N}</span> such that <span class="math">k=k_{m}+k_{r}</span>, we can split the domain of <span class="math">\\mathcal{C}</span>’s encoding function <span class="math">\\mathrm{Enc}</span> into two parts, by considering the bivariate function <span class="math">\\tilde{\\mathrm{Enc}}\\colon\\mathbb{F}^{k_{m}}\\times\\mathbb{F}^{k_{r}}\\to\\mathbb{F}^{n}</span> defined as $\\tilde{\\mathrm{Enc}}(m;r):=\\mathrm{Enc}(m\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r)<span class="math">. This split naturally induces a <em>probabilistic encoding</em>: </span>\\tilde{\\mathrm{Enc}}(m)<span class="math"> is defined to be the random variable </span>\\{\\mathrm{Enc}(m;r)\\}_{r\\leftarrow\\mathbb{F}^{k_{r}}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We are interested in <em>hiding properties</em> of the foregoing encoding, for given values of <span class="math">k_{m}</span> and <span class="math">k_{r}</span>. In light of this, we use the term <em>randomized linear code</em> to refer to a code <span class="math">\\mathcal{C}</span> specified via the tuple <span class="math">(\\tilde{\\mathrm{Enc}},G,G^{+},H)</span>, where the bivariate function <span class="math">\\tilde{\\mathrm{Enc}}</span> is given explicitly as part of the code description. Observe that, since <span class="math">\\tilde{\\mathrm{Enc}}</span> is linear in both the message and the randomness, we can uniquely split the generator matrix <span class="math">G</span> in two parts: <span class="math">G=\\begin{bmatrix}G_{m}&amp;G_{r}\\end{bmatrix}</span>, where <span class="math">G_{m}\\in\\mathbb{F}^{n\\times k_{m}}</span> corresponds to the message space of <span class="math">\\mathrm{Enc}</span>, and <span class="math">G_{r}\\in\\mathbb{F}^{n\\times k_{r}}</span> corresponds to the randomness space of <span class="math">\\mathrm{Enc}</span>. We will rely on this notation throughout this paper.</p>

    <p class="text-gray-300">Common notions associated to a code change accordingly. For example, the message space is now <span class="math">\\mathbb{F}^{k_{m}}</span>, and so the message length is <span class="math">k_{m}</span> and the rate is <span class="math">\\rho_{m}=k_{m}/n</span>. We similarly refer to <span class="math">\\mathbb{F}^{k_{r}}</span> as the randomness space, and call <span class="math">k_{r}</span> the randomness length and <span class="math">\\rho_{r}=k_{r}/n</span> the randomness rate. The distance of the code is now the worst-case distance across all possible randomness choices of two encodings.</p>

    <p class="text-gray-300">Below we define the hiding properties that we consider for randomized linear codes, (i) Q-<em>query zero knowledge</em>, which requires that certain sets of coordinates leak no information about the encoded message; (ii) Q-<em>query uniformity</em>, which strengthens the prior notion to require that any such set of coordinates is uniformly random. The following definition uses the same definition of a Q-query algorithm is as in Definition 3.9.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Definition 3.20.</h6>

    <p class="text-gray-300">A randomized linear code <span class="math">\\mathcal{C}</span> is <em>Q-query zero-knowledge</em> for a query-checker <span class="math">\\mathbf{Q}</span> if there exists a probabilistic polynomial-time simulator <span class="math">\\mathcal{S}</span> such that, for every message <span class="math">m\\in\\mathbb{F}^{k_{m}}</span> and <span class="math">\\mathbf{Q}</span>-query algorithm <span class="math">A</span>, the following two random variables are equidistributed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\{\\mathrm{View}(\\tilde{\\mathrm{Enc}}(m;r),A)\\}_{r\\leftarrow\\mathbb{F}^{k_{r}}}</span>, which is the view of <span class="math">A</span> when making adaptive queries to <span class="math">\\tilde{\\mathrm{Enc}}(m;r)</span>;</li>

      <li><span class="math">\\mathcal{S}^{A}</span>, which is the output of the simulator <span class="math">\\mathcal{S}</span> given black-box access to <span class="math">A</span>.</li>

    </ul>

    <p class="text-gray-300">Moreover, if the answer to each query made by <span class="math">A</span> is simply uniformly distributed, then we say that <span class="math">\\mathcal{C}</span> is <em>Q-query uniform</em>.</p>

    <p class="text-gray-300">As a special case of Definition 3.20, we also consider: (i) <em>bounded-query zero knowledge</em>, which mirrors the corresponding standard notion for PCPs and IOPs (and, as shown in Appendix C, is essentially equivalent to the zero knowledge notion considered in <em>[x21, x33]</em>); (ii) <em>bounded-query uniformity</em>, which strengthens the prior notion to require that any sufficiently small set of coordinates is uniformly random.</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Definition 3.21.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{Q}_{b}</span> be a query-checker algorithm which outputs <span class="math">\\bot</span> if more than <span class="math">b</span> queries are made, as in Definition 3.11. For the query-checker <span class="math">\\mathbf{Q}_{b}</span>, we refer to <span class="math">A</span> from Definition 3.9 as a <span class="math">b</span>-query algorithm, and <span class="math">\\mathcal{C}</span> from Definition 3.20 as a <span class="math">b</span>-query zero-knowledge or <span class="math">b</span>-query uniform code.</p>

    <p class="text-gray-300">Next, we define some simple randomized linear codes, starting with an encoding scheme used in <em>[x1]</em>.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Definition 3.22 (split encodings).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}</span> be a linear code with encoding function <span class="math">\\mathrm{Enc}\\colon\\mathbb{F}^{k_{m}}\\to\\mathbb{F}^{n}</span>. Then, the randomized linear code <span class="math">\\tilde{\\mathcal{C}}</span> has encoding function <span class="math">\\tilde{\\mathrm{Enc}}\\colon\\mathbb{F}^{k_{m}}\\times\\mathbb{F}^{n}\\to\\mathbb{F}^{2n}</span> defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\tilde{\\mathrm{Enc}}(m;r):=\\left(\\mathrm{Enc}(m)+r,r\\right)\\ .</span></p>

    <p class="text-gray-300">Let <span class="math">\\mathbf{Q}</span> be a query-checker for <span class="math">\\tilde{\\mathrm{Enc}}(m, r)</span> which outputs <span class="math">0</span> if queries are made to both the <span class="math">j</span>-th symbol of <span class="math">\\mathrm{Enc}(m) + r</span> and <span class="math">r</span>. It is easy to see that <span class="math">\\tilde{\\mathcal{C}}</span> is <span class="math">\\mathbf{Q}</span>-query uniform, and in particular, is <span class="math">1</span>-query uniform.</p>

    <p class="text-gray-300">If <span class="math">\\mathcal{C}</span> has rate <span class="math">\\rho</span>, relative distance <span class="math">\\delta</span>, and encoding time <span class="math">\\theta(k_m) \\cdot k_m</span>, then <span class="math">\\tilde{\\mathcal{C}}</span> has rate <span class="math">\\rho/2</span>, relative distance <span class="math">\\delta/2</span>, and encoding time <span class="math">\\theta(k_m) \\cdot k_m + n</span>.</p>

    <p class="text-gray-300">Example 1 (hiding in code concatenation). We illustrate the differences between the notions of bounded-query zero knowledge and bounded-query uniformity via a natural code operation: code concatenation.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}_{\\mathrm{in}}</span> be a <span class="math">b_{\\mathrm{in}}</span>-query zero knowledge code with encoding function <span class="math">\\tilde{\\mathrm{Enc}}_{\\mathrm{in}}: \\mathbb{F}^{k_m} \\times \\mathbb{F}^{k_r} \\to \\mathbb{F}^n</span>, and let <span class="math">\\mathcal{C}_{\\mathrm{out}}</span> be a <span class="math">b_{\\mathrm{out}}</span>-query zero knowledge code with encoding function <span class="math">\\tilde{\\mathrm{Enc}}_{\\mathrm{out}}: \\mathbb{F} \\times \\mathbb{F}^{k_r&#x27;} \\to \\{0,1\\}^{n&#x27;}</span>. The concatenated code <span class="math">\\mathcal{C}</span> has encoding function <span class="math">\\tilde{\\mathrm{Enc}}: \\mathbb{F}^{k_m} \\times \\mathbb{F}^{k_r + k_r&#x27; \\cdot n} \\to \\{0,1\\}^{n&#x27; \\cdot n}</span> defined as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde{\\mathrm{Enc}}\\big(m; (r, r_1, \\dots, r_n)\\big) := \\Big(\\tilde{\\mathrm{Enc}}_{\\mathrm{out}}\\big(\\tilde{\\mathrm{Enc}}_{\\mathrm{in}}(m; r)_1; r_1\\big), \\dots, \\tilde{\\mathrm{Enc}}_{\\mathrm{out}}\\big(\\tilde{\\mathrm{Enc}}_{\\mathrm{in}}(m; r)_n; r_n\\big) \\Big).</span></div>

    <p class="text-gray-300">Note that the encoding functions use independent encoding randomness each time they are used: first for encoding the message (via the inner code), and then for each symbol of the resulting encoding (via the outer code).</p>

    <p class="text-gray-300">The concatenated code <span class="math">\\mathcal{C}</span> is <span class="math">b</span>-query zero knowledge for <span class="math">b := b_{\\mathrm{in}}b_{\\mathrm{out}} + b_{\\mathrm{in}} + b_{\\mathrm{out}}</span>. Indeed, reading any <span class="math">b</span> symbols of <span class="math">\\tilde{\\mathrm{Enc}}(m)</span> reveals at most <span class="math">\\left\\lfloor \\frac{b}{b_{\\mathrm{out}} + 1} \\right\\rfloor = \\left\\lfloor \\frac{b_{\\mathrm{in}}b_{\\mathrm{out}} + b_{\\mathrm{in}} + b_{\\mathrm{out}}}{b_{\\mathrm{out}} + 1} \\right\\rfloor = b_{\\mathrm{in}}</span> symbols of <span class="math">\\tilde{\\mathrm{Enc}}_{\\mathrm{in}}(m)</span>, and thus reveals no information of <span class="math">m</span>. (As we shall see in Section 2.3.2 and Appendix A, the same computation tells us how zero knowledge is preserved when robustifying an IOP.)</p>

    <p class="text-gray-300">However, if we assume that <span class="math">\\mathcal{C}_{\\mathrm{in}}</span> is <span class="math">b_{\\mathrm{in}}</span>-query uniform and <span class="math">\\mathcal{C}_{\\mathrm{out}}</span> is <span class="math">b_{\\mathrm{out}}</span>-query uniform then we cannot conclude that <span class="math">\\mathcal{C}</span> is <span class="math">b</span>-query uniform. (Naturally, we can still conclude that <span class="math">\\mathcal{C}</span> is <span class="math">b</span>-query zero knowledge as we have only strengthened the assumptions on <span class="math">\\mathcal{C}_{\\mathrm{in}}</span> and <span class="math">\\mathcal{C}_{\\mathrm{out}}</span>.) Indeed, <span class="math">\\tilde{\\mathrm{Enc}}(m)</span> is always the concatenation of codewords in <span class="math">\\mathcal{C}_{\\mathrm{out}}</span>, and therefore many substrings of the codeword are not independent.</p>

    <p class="text-gray-300">In sum, code concatenation amplifies bounded-query zero knowledge but not bounded-query uniformity, and in particular a simulator for a zero knowledge concatenated code may have to do more than "sample a random symbol and return it".</p>

    <p class="text-gray-300">4 Tensor IOP for R1CS with (semi)honest-verifier zero knowledge</p>

    <p class="text-gray-300">In this section, we give a holographic tensor IOP for the relation <span class="math">R_{\\mathrm{R1CS}}</span> that is zero knowledge against (semi-)honest verifiers.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Definition 4.1 (R1CS).</h6>

    <p class="text-gray-300">The indexed relation <span class="math">R_{\\mathrm{R1CS}}</span> is the set of all triples</p>

    <p class="text-gray-300"><span class="math">(\\mathbb{i},\\mathbb{x},\\mathbb{w})=\\big{(}(\\mathbb{F},m,n,A,B,C),(\\ell,x),w\\big{)}</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">A,B,C</span> are matrices in <span class="math">\\mathbb{F}^{m\\times n}</span>, each with at most <span class="math">M</span> non-zero entries, <span class="math">x\\in\\mathbb{F}^{\\ell}</span>, <span class="math">w\\in\\mathbb{F}^{n-\\ell}</span>, and <span class="math">z:=(x,w)\\in\\mathbb{F}^{n}</span> is a vector such that <span class="math">Az\\circ Bz=Cz</span>. (Here “<span class="math">\\circ</span>” denotes the entry-wise product between two vectors.)</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Theorem 4.2.</h6>

    <p class="text-gray-300">For every finite field <span class="math">\\mathbb{F}</span> and positive integers <span class="math">k,t</span>, there is a <span class="math">(\\mathbb{F},k,t)</span>-tensor holographic IOP, with non-adaptive queries, for the indexed relation <span class="math">R_{\\mathrm{R1CS}}</span> that supports instances over <span class="math">\\mathbb{F}</span> with <span class="math">M=\\ell\\cdot k^{t}</span>, <span class="math">m=k^{t}-2</span>,<span class="math">n=k^{t}-6</span> and <span class="math">n_{\\mathrm{in}}=\\ell_{\\mathrm{in}}\\cdot k^{t_{\\mathrm{in}}}</span>, where <span class="math">\\ell_{\\mathrm{in}}\\in[k-1]</span>, and has the following parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error is $O((M+k^{t})/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity is <span class="math">O(\\log(M+k^{t}))</span>;</li>

      <li>proof length is <span class="math">O(M+k^{t})</span> elements in <span class="math">\\mathbb{F}</span>;</li>

      <li>query complexity is <span class="math">O(1)</span>;</li>

      <li>the prover sends <span class="math">O(\\log\\ell+t\\log k)</span> non-oracle messages;</li>

      <li>the indexer uses <span class="math">O(M)</span> field operations;</li>

      <li>the prover uses <span class="math">O(k^{t}+M)</span> field operations;</li>

      <li>the verifier uses <span class="math">O(\\ell_{\\mathrm{in}}\\cdot k^{t_{\\mathrm{in}}}+\\log\\ell+t\\log k)</span> field operations;</li>

      <li>the verifier has randomness complexity <span class="math">O(t\\log k)</span>.</li>

    </ul>

    <p class="text-gray-300">Moreover, the tensor IOP is semi-honest-verifier zero-knowledge.</p>

    <h3 id="sec-71" class="text-xl font-semibold mt-8">4.1 Preliminaries</h3>

    <h4 id="sec-72" class="text-lg font-semibold mt-6">Zero-knowledge gadgets.</h4>

    <p class="text-gray-300">To help achieve zero-knowledge in our construction, we will augment the R1CS instance with the following matrix gadgets.</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Claim 4.3.</h6>

    <p class="text-gray-300">Let <span class="math">I_{s}</span> denote the <span class="math">s\\times s</span> identity matrix. Define the following vectors and matrices:</p>

    <p class="text-gray-300"><span class="math">\\vec{e}_{1}:=\\begin{bmatrix}1&amp;0&amp;0\\end{bmatrix},</span> <span class="math">\\vec{e}_{2}:=\\begin{bmatrix}0&amp;1&amp;0\\end{bmatrix},</span> <span class="math">\\vec{e}_{3}:=\\begin{bmatrix}0&amp;0&amp;1\\end{bmatrix}</span> <span class="math">\\in\\mathbb{F}^{3}\\enspace,</span> <span class="math">A_{s}:=\\vec{e}_{1}\\otimes I_{s}\\enspace,</span> <span class="math">B_{s}:=\\vec{e}_{2}\\otimes I_{s},</span> <span class="math">C_{s}:=\\vec{e}_{3}\\otimes I_{s}</span> <span class="math">\\in\\mathbb{F}^{s\\times 3s}\\enspace.</span></p>

    <p class="text-gray-300">The solutions to the equation <span class="math">A_{s}z\\circ B_{s}z=C_{s}z</span> are all vectors <span class="math">z\\in\\mathbb{F}^{3s}</span> of the form <span class="math">\\begin{pmatrix}\\vec{p}&amp;\\vec{q}&amp;\\vec{p}\\circ\\vec{q}\\end{pmatrix}</span> where <span class="math">\\vec{p},\\vec{q}\\in\\mathbb{F}^{s}</span>.</p>

    <p class="text-gray-300">During the R1CS protocol, the prover and verifier engage in a twisted scalar-product sub-protocol and three executions of a holographic lincheck sub-protocol which are specified in <em>[x1]</em>. We note that their results can be generalized using the notion of <span class="math">\\epsilon</span>-biased generators, which allows the verifier’s randomness complexity to be improved. First, we define <span class="math">\\epsilon</span>-biased generators. Then, we define the scalar-product and holographic lincheck relations, along with theorems specifying tensor IOPs for both relations.</p>

    <p class="text-gray-300"><span class="math">\\epsilon</span>-biased generators. We define <span class="math">\\epsilon</span>-biased generators over arbitrary fields, using a notion of absolute bias instead of using the deviation from uniform probabilities.</p>

    <p class="text-gray-300">Definition 4.4 (<span class="math">\\epsilon</span>-biased generators). Let <span class="math">G\\colon(\\mathbb{F}\\setminus\\{0\\})^{s}\\to(\\mathbb{F}\\setminus\\{0\\})^{n}</span> be a function. We say that <span class="math">G</span> is <span class="math">\\epsilon</span>-biased if</p>

    <p class="text-gray-300"><span class="math">\\max_{w\\in\\mathbb{F}^{n}\\setminus\\{0\\}}\\Pr_{x\\in\\mathbb{F}^{s}}[\\langle w,G(x)\\rangle=0]\\leq\\epsilon\\enspace.</span></p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Lemma 4.5.</h6>

    <p class="text-gray-300">Let <span class="math">G\\colon(\\mathbb{F}\\setminus\\{0\\})^{s}\\to(\\mathbb{F}\\setminus\\{0\\})^{n}</span> be an <span class="math">\\epsilon</span>-biased generator and let <span class="math">G^{\\prime}\\colon(\\mathbb{F}\\setminus\\{0\\})^{s^{\\prime}}\\to(\\mathbb{F}\\setminus\\{0\\})^{n^{\\prime}}</span> be an <span class="math">\\epsilon^{\\prime}</span>-biased generator. Then, the function <span class="math">G\\otimes G^{\\prime}\\colon(x,x^{\\prime})\\mapsto G(x)\\otimes G^{\\prime}(x^{\\prime})</span> is an <span class="math">(\\epsilon+\\epsilon^{\\prime})</span>-biased generator.</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">w</span> be a non-zero vector in <span class="math">\\mathbb{F}^{n\\cdot n^{\\prime}}</span>. Choose <span class="math">x\\leftarrow(\\mathbb{F}\\setminus\\{0\\})^{s}</span> and <span class="math">x^{\\prime}\\leftarrow(\\mathbb{F}\\setminus\\{0\\})^{s^{\\prime}}</span> uniformly at random. Writing</p>

    <p class="text-gray-300"><span class="math">\\langle w,G(x)\\otimes G^{\\prime}(x^{\\prime})\\rangle=w^{\\intercal}\\cdot(G(x)\\otimes I_{n^{\\prime}})\\cdot(I_{n}\\otimes G^{\\prime}(x^{\\prime}))\\enspace,</span></p>

    <p class="text-gray-300">it is easy to see that <span class="math">w^{\\intercal}\\cdot(G(x)\\otimes I_{n^{\\prime}})</span> is zero with probability at most <span class="math">\\epsilon</span> over the choice of <span class="math">x</span>, in which case <span class="math">\\langle w,G(x)\\otimes G^{\\prime}(x^{\\prime})\\rangle</span> is also zero. If <span class="math">w^{\\intercal}\\cdot(G(x)\\otimes I_{n^{\\prime}})</span> is not zero, then <span class="math">w^{\\intercal}\\cdot(G(x)\\otimes I_{n^{\\prime}})\\cdot(I_{n}\\otimes G^{\\prime}(x^{\\prime}))</span> is zero with probability at most <span class="math">\\epsilon^{\\prime}</span> over the choice of <span class="math">x^{\\prime}</span>. ∎</p>

    <p class="text-gray-300">To achieve the parameters stated in Theorem 4.13, we use the following generator.</p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Definition 4.6.</h6>

    <p class="text-gray-300">Let <span class="math">G\\colon(\\mathbb{F}\\setminus\\{0\\})^{\\log k}\\to(\\mathbb{F}\\setminus\\{0\\})^{k}</span> be defined by <span class="math">G(x_{1},\\ldots,x_{\\log k})=\\left(\\prod_{i\\in S}x_{i}\\right)_{S\\subseteq[\\log k]}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the Schwarz–Zippel lemma, Definition 4.6 gives a $\\frac{\\log k}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}<span class="math">-biased generator with arithmetic complexity </span>O(k)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Relations and subprotocols. The twisted scalar-product sub-protocol and the holographic lincheck sub-protocol are specified by the following definitions and theorems. (Note that if we set <span class="math">y:=1^{n}</span> in the definition below then we recover “standard” scalar products.)</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Definition 4.7.</h6>

    <p class="text-gray-300">The twisted scalar product relation <span class="math">R_{\\text{\\tiny TSP}}</span> is the set of tuples <span class="math">(\\mathfrak{i},\\mathbb{x},\\mathbb{w})=(\\bot,(\\mathbb{F},n,y,\\tau),(a,b))</span> where <span class="math">a,b,y\\in\\mathbb{F}^{n}</span>, <span class="math">\\tau\\in\\mathbb{F}</span>, and <span class="math">\\langle a\\circ y,b\\rangle=\\tau</span>.</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Theorem 4.8 (<em>[x1]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For every finite field <span class="math">\\mathbb{F}</span> and positive integers <span class="math">k,t</span>, there is a <span class="math">(\\mathbb{F},k,t)</span>-tensor exact IOPP for the relation <span class="math">R_{\\text{\\tiny TSP}}</span> that supports instances over <span class="math">\\mathbb{F}</span> with <span class="math">n=\\ell\\cdot k^{t}</span> and <span class="math">y=y_{0}\\otimes y_{1}\\otimes\\ldots\\otimes y_{t}</span> for <span class="math">y_{0}\\in\\mathbb{F}^{\\ell}</span>, <span class="math">y_{1},\\ldots,y_{t}\\in\\mathbb{F}^{k}</span> and has the following parameters: soundness error is $O(\\frac{\\log n}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">; round complexity is </span>O(\\log n)<span class="math">; proof length is </span>O(n)<span class="math"> elements in </span>\\mathbb{F}<span class="math">; query complexity is </span>O(1)<span class="math">; the prover uses </span>O(n)<span class="math"> field operations; the verifier uses </span>O(\\log\\ell+t\\log k)<span class="math"> field operations; and the verifier has randomness complexity </span>O(t\\log k)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-79" class="text-base font-medium mt-4">Definition 4.9.</h6>

    <p class="text-gray-300">Let <span class="math">U\\in\\mathbb{F}^{m\\times n}</span> be a matrix with <span class="math">M</span> non-zero entries. The sparse representation of <span class="math">U</span> consists of <span class="math">\\operatorname{val}_{U}\\in\\mathbb{F}^{M}</span>, <span class="math">\\operatorname{row}_{U}\\in[m]^{M}</span> and <span class="math">\\operatorname{col}_{U}\\in[n]^{M}</span> such that <span class="math">\\operatorname{val}_{U}</span> contains the <span class="math">M</span> non-zero entries of <span class="math">U\\in\\mathbb{F}^{m\\times n}</span> and, for all <span class="math">\\kappa\\in[M]</span>, <span class="math">\\operatorname{val}_{U}(\\kappa)=U(\\operatorname{row}_{U}(\\kappa),\\operatorname{col}_{U}(\\kappa))</span>.</p>

    <h6 id="sec-80" class="text-base font-medium mt-4">Definition 4.10.</h6>

    <p class="text-gray-300">The lincheck indexed relation <span class="math">R_{\\text{\\tiny LC}}</span> is the set of all triples</p>

    <p class="text-gray-300"><span class="math">(\\mathfrak{i},\\mathbb{x},\\mathbb{w})=\\left(U,(\\mathbb{F},M,m,n),(v,v_{\\text{\\tiny U}})\\right)</span></p>

    <p class="text-gray-300">where <span class="math">U\\in\\mathbb{F}^{m\\times n}</span> is a matrix with <span class="math">M</span> non-zero entries given in sparse representation, <span class="math">v\\in\\mathbb{F}^{n},v_{\\text{\\tiny U}}\\in\\mathbb{F}^{m},\\operatorname{val}_{U}\\in\\mathbb{F}^{M},\\operatorname{row}_{U}\\in[m]^{M},\\operatorname{col}_{U}\\in[n]^{M}</span> and <span class="math">Uv=v_{\\text{\\tiny U}}</span>.</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Lemma 4.11 (<em>[x1]</em>).</h6>

    <p class="text-gray-300">For every finite field <span class="math">\\mathbb{F}</span> and positive integers <span class="math">k,t</span>, given an <span class="math">\\epsilon</span>-biased generator <span class="math">G\\colon\\mathbb{F}^{s}\\to\\mathbb{F}^{k}</span> with circuit complexity <span class="math">O(k)</span>, there is an exact <span class="math">(\\mathbb{F},k,t)</span>-tensor holographic IOPP for the indexed relation <span class="math">R_{\\text{\\tiny LC}}</span> that supports instances over <span class="math">\\mathbb{F}</span> with <span class="math">M=\\ell\\cdot k^{t}</span>, <span class="math">m,n=k^{t}</span> and has the following parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">soundness error is $O((M+k^{t})/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+t\\epsilon)<span class="math">; round complexity is </span>O(\\log(M+k^{t}))<span class="math">; proof length is </span>O(M+k^{t})<span class="math"> elements in </span>\\mathbb{F}<span class="math">; query complexity is </span>O(1)<span class="math">; the prover uses </span>O(M+k^{t})<span class="math"> field operations; the verifier uses </span>O(\\log(M/k^{t})+t\\log k)<span class="math"> field operations; and the verifier has randomness complexity </span>O(t(s+\\log k))<span class="math">. The index </span>\\mathbb{i}<span class="math"> consists of </span>(A,B,C,[m],[n])<span class="math">, where </span>A<span class="math">, </span>B<span class="math"> and </span>C<span class="math"> are given in their sparse representations. Moreover, the indexer algorithm is degenerate: the encoding of an index </span>\\mathbb{i}$ is the index itself.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-82" class="text-base font-medium mt-4">Remark 4.12.</h6>

    <p class="text-gray-300">The queries used in our tensor IOP construction and those <em>[x1]</em> may be highly structured. For example, a query <span class="math">q\\in(\\mathbb{F}^{k})^{t}</span> in which each component is produced by the generator from Definition 4.6 can be described using only <span class="math">t\\log k</span> field elements. As such, we allow the verifier to produce a description of each tensor query rather than computing the entire query explicitly, which gives the stated verification time.</p>

    <h3 id="sec-83" class="text-xl font-semibold mt-8">4.2 Our construction</h3>

    <p class="text-gray-300">The holographic tensor IOP is given in Construction 4.14. In the following theorem, the performance parameters of the tensor IOP are described in terms of the soundness error, communication complexity, and round complexity of the sub-protocols. Later, in Section 9, this allows us to demonstrate how our final result depends critically on these two subprotocols.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Write $k_{\\textsc{sp}}(N)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for the soundness error of the twisted scalar-product protocol, </span>c_{\\textsc{sp}}(N)<span class="math"> for its communication complexity and </span>r_{\\textsc{sp}}(N)<span class="math"> for its round complexity. Write </span>k_{\\textsc{lc}}(N)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for the soundness error of the holographic lincheck protocol, </span>c_{\\textsc{lc}}(N)<span class="math"> for its communication complexity and </span>r_{\\textsc{lc}}(N)$ for its round complexity.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-84" class="text-base font-medium mt-4">Theorem 4.13.</h6>

    <p class="text-gray-300">For every finite field <span class="math">\\mathbb{F}</span> and positive integers <span class="math">k,t</span>, given an <span class="math">\\epsilon</span>-biased generator <span class="math">G\\colon(\\mathbb{F}\\setminus\\{0\\})^{s}\\to(\\mathbb{F}\\setminus\\{0\\})^{k}</span> with arithmetic complexity <span class="math">O(k)</span>, there is a <span class="math">(\\mathbb{F},k,t)</span>-tensor holographic IOP for the indexed relation <span class="math">R_{\\textsc{R1CS}}</span> that supports instances over <span class="math">\\mathbb{F}</span> with <span class="math">M=\\ell\\cdot k^{t}</span>, <span class="math">m=k^{t}-2</span>,<span class="math">n=k^{t}-6</span> and <span class="math">n_{\\textsc{in}}=\\ell_{\\textsc{in}}\\cdot k^{t_{\\textsc{in}}}</span>, where <span class="math">\\ell_{\\textsc{in}}\\in[k-1]</span>, and has the following parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error is $O((k_{\\textsc{lc}}+k_{\\textsc{sp}})/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+t\\epsilon)$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity is <span class="math">O(r_{\\textsc{lc}}+r_{\\textsc{sp}})</span>;</li>

      <li>proof length is <span class="math">O(M+k^{t})</span> elements in <span class="math">\\mathbb{F}</span>;</li>

      <li>query complexity is <span class="math">O(1)</span>;</li>

      <li>the prover sends <span class="math">O(c_{\\textsc{lc}}+c_{\\textsc{sp}})</span> non-oracle messages;</li>

      <li>the indexer uses <span class="math">O(M)</span> field operations;</li>

      <li>the prover uses <span class="math">O(k^{t}+M)</span> field operations;</li>

      <li>the verifier uses <span class="math">O(\\ell_{\\textsc{in}}\\cdot k^{t_{\\textsc{in}}}+\\log\\ell+t\\log k)</span> field operations;</li>

      <li>the verifier has randomness complexity <span class="math">O(t(s+\\log k))</span>.</li>

    </ul>

    <p class="text-gray-300">Moreover, the tensor IOP is semi-honest-verifier zero-knowledge.</p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Construction 4.14 (tensor IOP for R1CS).</h6>

    <p class="text-gray-300">We construct a holographic interactive oracle proof <span class="math">\\mathsf{IOP}=(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> with tensor queries for the indexed relation <span class="math">R_{\\textsc{R1CS}}</span>. Given as input an index <span class="math">\\mathbb{i}=(\\mathbb{F},m,n,A,B,C)</span>, the indexer <span class="math">\\mathbf{I}</span> runs the indexer for the lincheck protocol (implied by Lemma 4.11) on input <span class="math">U</span> to obtain <span class="math">(\\mathrm{row}_{U},\\mathrm{col}_{U},[m],[n])</span> for each <span class="math">U\\in\\left\\{\\begin{bmatrix}A&amp;0\\cr 0&amp;A_{2}\\end{bmatrix},\\begin{bmatrix}B&amp;0\\cr 0&amp;B_{2}\\end{bmatrix},\\begin{bmatrix}C&amp;0\\cr 0&amp;C_{2}\\end{bmatrix}\\right\\}</span>, and outputs the oracle message</p>

    <p class="text-gray-300"><span class="math">\\Pi_{0}:=\\left(\\left\\{\\begin{bmatrix}A&amp;0\\cr 0&amp;A_{2}\\end{bmatrix},\\begin{bmatrix}B&amp;0\\cr 0&amp;B_{2}\\end{bmatrix},\\begin{bmatrix}C&amp;0\\cr 0&amp;C_{2}\\end{bmatrix}\\right\\},[m],[n]\\right)\\enspace.</span></p>

    <p class="text-gray-300">The prover <span class="math">\\mathbf{P}</span> takes as input the index <span class="math">\\mathbb{i}</span>, instance <span class="math">\\mathbb{x}=(\\ell,x)</span>, and witness <span class="math">\\mathbb{w}=w</span>, while the verifier <span class="math">\\mathbf{V}</span> has query access to the index <span class="math">\\mathbb{i}</span> and takes as input the instance <span class="math">\\mathbb{x}</span>. Let <span class="math">G\\colon(\\mathbb{F}\\setminus\\{0\\})^{s}\\to(\\mathbb{F}\\setminus\\{0\\})^{k}</span> be an <span class="math">\\epsilon</span>-biased generator with arithmetic complexity <span class="math">O(k)</span>.</p>

    <p class="text-gray-300">###</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover <span class="math">\\mathbf{P}</span> relies on Claim 4.3 to sample a random solution <span class="math">u \\in \\mathbb{F}^6</span> to the equation <span class="math">A_2u \\circ B_2u = C_2u</span> such that the first two entries of <span class="math">u</span> are equal to <span class="math">(1,0)</span>.</li>

      <li>The prover <span class="math">\\mathbf{P}</span> constructs the full assignment <span class="math">z := (x, w, u) \\in \\mathbb{F}^{k^t}</span>. The prover samples vectors <span class="math">y, y_A</span> and <span class="math">y_B \\in \\mathbb{F}^{k^t}</span> uniformly at random, subject to the condition that the final 2 entries of <span class="math">y_A</span> are <span class="math">(0,1)</span>. The prover computes the vectors</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">z_A := \\begin{bmatrix} A &amp;amp; 0 \\\\ 0 &amp;amp; A_2 \\end{bmatrix} z, \\qquad z_B := \\begin{bmatrix} B &amp;amp; 0 \\\\ 0 &amp;amp; B_2 \\end{bmatrix} z, \\qquad \\qquad z_C := \\begin{bmatrix} C &amp;amp; 0 \\\\ 0 &amp;amp; C_2 \\end{bmatrix} z,</span></div>

    <div class="my-4 text-center"><span class="math-block">w_A := \\begin{bmatrix} A &amp;amp; 0 \\\\ 0 &amp;amp; A_2 \\end{bmatrix} y, \\qquad w_B := \\begin{bmatrix} B &amp;amp; 0 \\\\ 0 &amp;amp; B_2 \\end{bmatrix} y, \\qquad \\qquad w_C := \\begin{bmatrix} C &amp;amp; 0 \\\\ 0 &amp;amp; C_2 \\end{bmatrix} y \\quad \\in \\mathbb{F}^{k^t}.</span></div>

    <p class="text-gray-300">The prover sends the oracle message <span class="math">\\Pi_1 := (z, z_A, z_B, z_C, y, y_A, y_B, w_A, w_B, w_C) \\in \\mathbb{F}^{10 \\cdot k^t}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier <span class="math">\\mathbf{V}</span> sends uniformly random seeds <span class="math">\\rho_1, \\ldots, \\rho_t \\in (\\mathbb{F} \\setminus \\{0\\})^s</span> and the uniformly random challenge <span class="math">\\alpha \\in \\mathbb{F} \\setminus \\{0\\}</span>.</li>

      <li>The prover <span class="math">\\mathbf{P}</span> computes the query vector <span class="math">r := G(\\rho_1) \\otimes \\cdots \\otimes G(\\rho_t)</span>, and the field elements</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\nu_C := \\langle r, z_C \\rangle, \\mu_1 := \\langle z_A \\circ r, y_B \\rangle + \\langle y_A \\circ r, z_B \\rangle, \\text{ and } \\mu_0 := \\langle y_A \\circ r, y_B \\rangle.</span></div>

    <p class="text-gray-300">The prover <span class="math">\\mathbf{P}</span> sends the non-oracle message <span class="math">(\\nu_C, \\mu_1, \\mu_0) \\in \\mathbb{F}^3</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier <span class="math">\\mathbf{V}</span> performs consistency checks. First, <span class="math">\\mathbf{V}</span> queries <span class="math">z_C</span> in <span class="math">\\Pi_1</span> at <span class="math">r = G(\\rho_1) \\otimes \\cdots \\otimes G(\\rho_t)</span> in order to obtain the answer <span class="math">\\langle r, z_C \\rangle</span>. Then, <span class="math">\\mathbf{V}</span> checks that <span class="math">\\nu_C = \\langle r, z_C \\rangle</span>, which shows that <span class="math">\\nu_C</span> is the correct answer to the query on <span class="math">z_C</span>.</li>

    </ul>

    <p class="text-gray-300">Moreover, <span class="math">\\mathbf{V}</span> checks that the (claimed) satisfying assignment <span class="math">z</span> is consistent with the partial assignment <span class="math">x</span> as follows: sample uniformly random seeds <span class="math">\\sigma_1, \\ldots, \\sigma_{t_{\\mathrm{in}} + 1} \\in \\mathbb{F}^s</span>; compute vectors <span class="math">s_i = G(\\sigma_i)</span> for <span class="math">i \\in [t_{\\mathrm{in}}]</span>, and compute <span class="math">s_{t_{\\mathrm{in}} + 1}</span> by computing <span class="math">G(\\sigma_{t_{\\mathrm{in}} + 1})</span> and changing all but the first <span class="math">\\ell_{\\mathrm{in}}</span> entries to zero. Set <span class="math">s_{t_{\\mathrm{in}} + 1}&#x27;</span> to be the first <span class="math">\\ell_{\\mathrm{in}}</span> entries. Then set each of the vectors <span class="math">s_{t_{\\mathrm{in}} + 2}, \\ldots, s_t \\in \\mathbb{F}^k</span> to equal <span class="math">(1, 0, \\ldots, 0) \\in \\mathbb{F}^k</span>; query <span class="math">z</span> in <span class="math">\\Pi_1</span> at the tensor <span class="math">s := s_1 \\otimes \\cdots \\otimes s_t</span> in order to obtain the answer <span class="math">\\langle s, z \\rangle</span>; and check that <span class="math">\\langle s, z \\rangle = \\langle s_1 \\otimes \\cdots \\otimes s_{t_{\\mathrm{in}}} \\otimes s_{t_{\\mathrm{in}} + 1}&#x27;, x \\rangle</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover <span class="math">\\mathbf{P}</span> and verifier <span class="math">\\mathbf{V}</span> engage in several sub-protocols, which make use of the masking vectors <span class="math">y</span>, <span class="math">y_A</span> and <span class="math">y_B</span>, and the images <span class="math">w_A</span>, <span class="math">w_B</span>, <span class="math">w_C</span> of <span class="math">y</span> under <span class="math">A</span>, <span class="math">B</span> and <span class="math">C</span>, to check that <span class="math">z_A \\circ z_B = z_C</span>, <span class="math">Az = z_A</span>, <span class="math">Bz = z_B</span> and <span class="math">Cz = z_C</span> while ensuring zero-knowledge. Note that <span class="math">\\mathbf{V}</span> can query, for example, <span class="math">\\alpha z_A + y_A</span> with query <span class="math">q</span> by applying the query <span class="math">(\\alpha, 1) \\otimes q</span> to <span class="math">(z_A, y_A)</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A twisted scalar-product protocol with instance <span class="math">\\mathbb{x} = (\\mathbb{F}, m, r, \\alpha^2 \\nu_C + \\alpha \\mu_1 + \\mu_0)</span> and witness <span class="math">\\mathbb{w} = (\\alpha z_A + y_A, \\alpha z_B + y_B)</span> to show that <span class="math">\\langle (\\alpha z_A + y_A) \\circ r, \\alpha z_B + y_B \\rangle = \\alpha^2 \\nu_C + \\alpha \\mu_1 + \\mu_0</span>.</li>

      <li>A lincheck protocol with <span class="math">\\mathbb{i} = A</span>, <span class="math">\\mathbb{x} = (\\mathbb{F}, M, m, n)</span>, and <span class="math">\\mathbb{w} = (\\alpha z + y, \\alpha z_A + w_A)</span> to show that <span class="math">\\alpha z_A + w_A = A(\\alpha z + y)</span>.</li>

      <li>A lincheck protocol with <span class="math">\\mathbb{i} = B</span>, <span class="math">\\mathbb{x} = (\\mathbb{F}, M, m, n)</span>, and <span class="math">\\mathbb{w} = (\\alpha z + y, \\alpha z_B + w_B)</span> to show that <span class="math">\\alpha z_B + w_B = B(\\alpha z + y)</span>.</li>

      <li>A lincheck protocol with <span class="math">\\mathbb{i} = C</span>, <span class="math">\\mathbb{x} = (\\mathbb{F}, M, m, n)</span>, and <span class="math">\\mathbb{w} = (\\alpha z + y, \\alpha z_C + w_C)</span> to show that <span class="math">\\alpha z_C + w_C = C(\\alpha z + y)</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Lemma 4.15 (completeness).</strong> Construction 4.14 has perfect completeness.</p>

    <p class="text-gray-300">Sketch of proof. Let <span class="math">(x, w)</span> be a solution to the R1CS instance. Since <span class="math">A_2 u \\circ B_2 u = C_2 u</span>, we know that <span class="math">z := (x, w, u)</span> satisfies the augmented R1CS instance in which <span class="math">A, B, C</span> are combined with <span class="math">A_2, B_2, C_2</span>. The prover <span class="math">\\mathbf{P}</span> computes <span class="math">z_A = \\begin{bmatrix} A &amp;amp; 0 \\\\ 0 &amp;amp; A_2 \\end{bmatrix} z</span> and similarly for <span class="math">z_B</span> and <span class="math">z_C</span>, so the equation <span class="math">z_A \\circ z_B = z_C</span> holds.</p>

    <p class="text-gray-300">This means that, for every choice of <span class="math">r = G(\\rho_1) \\otimes \\dots \\otimes G(\\rho_t)</span>, we have <span class="math">\\langle z_A \\circ r, z_B \\rangle = \\langle r, z_C \\rangle</span>. Expanding the expression <span class="math">\\langle (\\alpha z_A + y_A) \\circ r, \\alpha z_B + y_B \\rangle</span>, we see that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\langle (\\alpha z_A + y_A) \\circ r, \\alpha z_B + y_B \\rangle = \\alpha^2 \\langle z_A \\circ r, z_B \\rangle + \\alpha (\\langle z_A \\circ r, y_B \\rangle + \\langle y_A \\circ r, z_B \\rangle) + \\langle y_A \\circ r, y_B \\rangle \\\\ = \\alpha^2 \\langle r, z_C \\rangle + \\alpha \\mu_1 + \\alpha \\mu_0 \\\\ = \\alpha^2 \\nu_C + \\alpha \\mu_1 + \\mu_0. \\end{array}</span></div>

    <p class="text-gray-300">This means that the twisted scalar-product protocol succeeds.</p>

    <p class="text-gray-300">Moreover, for every choice of <span class="math">\\alpha</span>, we have <span class="math">A(\\alpha z + y) = \\alpha Az + Ay = \\alpha z_A + w_A</span>, which means that the lincheck protocol with <span class="math">A</span> succeeds. Similar reasoning holds for <span class="math">B</span> and <span class="math">C</span>. So the three scalar product sub-protocols succeed.</p>

    <p class="text-gray-300">Finally, for every choice of <span class="math">s_1, \\ldots, s_{t_{\\mathrm{in}} + 1}</span> and setting <span class="math">s_{t_{\\mathrm{in}} + 2} = \\dots = s_t = (1,0,\\ldots,0) \\in \\mathbb{F}^k</span> it holds that <span class="math">\\langle s_1 \\otimes \\dots \\otimes s_t, z \\rangle = \\langle s_1 \\otimes \\dots \\otimes s_{t_{\\mathrm{in}}} \\otimes s_{t_{\\mathrm{in}} + 1}&#x27;, x \\rangle</span>, which is the equation checked by the verifier.</p>

    <p class="text-gray-300">Lemma 4.16 (soundness). Let <span class="math">\\epsilon_{\\mathrm{TSP}}</span> and <span class="math">\\epsilon_{\\mathrm{LC}}</span> be the soundness errors of the (twisted) scalar-product and lincheck protocols. Construction 4.14 has soundness error</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\epsilon := \\max \\left\\{ \\epsilon_{\\mathrm{TSP}} + t\\epsilon + \\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}, \\epsilon_{\\mathrm{LC}} + \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}, (t_{\\mathrm{in}} + 1)\\epsilon \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. Let <span class="math">(\\dot{\\mathfrak{s}}, \\mathfrak{x}) = \\big((\\mathbb{F}, m, n, A, B, C), (\\ell, x)\\big) \\notin L(R)</span> and fix a malicious prover. Let</p>

    <div class="my-4 text-center"><span class="math-block">\\Pi_1 = (z, z_A, z_B, z_C, y, y_A, y_B, w_A, w_B, w_C)</span></div>

    <p class="text-gray-300">be the first message sent by the malicious prover. At least one of the following cases must hold.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The Hadamard product is incorrect: <span class="math">z_A \\circ z_B \\neq z_C</span>. By Lemma 4.5, the vector <span class="math">r = G(\\rho_1) \\otimes \\ldots \\otimes G(\\rho_t)</span> is the output of a <span class="math">t\\epsilon</span>-biased generator. Since <span class="math">\\langle z_A \\circ z_B - z_C, r \\rangle = 0</span> if and only if <span class="math">\\langle z_A \\circ r, z_B \\rangle = \\langle z_C, r \\rangle</span>, we have <span class="math">\\operatorname{Pr}_r[\\langle z_A \\circ r, z_B \\rangle = \\langle z_C, r \\rangle] \\leq t\\epsilon</span>. Suppose that <span class="math">\\langle z_A \\circ r, z_B \\rangle \\neq \\langle z_C, r \\rangle</span> and let <span class="math">\\nu_C \\in \\mathbb{F}</span> be the claimed value of the inner product sent by the malicious prover in the second message. Either <span class="math">\\langle z_C, r \\rangle \\neq \\nu_C</span> or <span class="math">\\langle z_A \\circ r, z_B \\rangle \\neq \\nu_C</span> (or both). In the former case, the verifier will reject due to the check that <span class="math">\\nu_C = \\langle z_C, r \\rangle</span>. In the latter case, we apply the Schwartz-Zippel lemma to the non-zero polynomial <span class="math">h(\\alpha) := \\langle (\\alpha z_A + y_A) \\circ r, \\alpha z_B + y_B \\rangle - \\alpha^2 \\nu_C - \\alpha \\mu_1 - \\mu_0</span> of degree 2, concluding that $\\operatorname{Pr}_\\alpha[\\langle (\\alpha z_A + y_A) \\circ r, \\alpha z_B + y_B \\rangle = \\alpha^2 \\nu_C + \\alpha \\mu_1 + \\mu_0] \\leq \\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}<span class="math">. By the soundness of the twisted scalar-product protocol, the verifier accepts with probability at most </span>\\epsilon_{\\mathrm{TSP}}<span class="math">. By a union bound, the probability of accepting is at most </span>\\epsilon_{\\mathrm{TSP}} + t\\epsilon + \\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- A linear combination is incorrect: <span class="math">z_A \\neq Az</span> or <span class="math">z_B \\neq Bz</span> or <span class="math">z_C \\neq Cz</span>. Suppose that <span class="math">z_A \\neq Az</span>, without loss of generality. Then, there exists some <span class="math">i \\in [k^t]</span> such that <span class="math">(z_A)_i \\neq (Az)_i</span>. We apply the Schwartz-Zippel lemma to the non-zero polynomial <span class="math">P(\\alpha) := \\alpha[(z_A)_i - (Az)_i] + [(w_A)_i - (Ay)_i]</span> of degree 1, concluding that <span class="math">P(\\alpha) = 0</span> with probability at most $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}<span class="math">, and hence </span>\\operatorname{Pr}_\\alpha[A(\\alpha z + e) = \\alpha z_A + w_A] \\leq \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}<span class="math">. If </span>A(\\alpha z + e) \\neq \\alpha z_A + w_A<span class="math">, then by the soundness of the lincheck protocol, the verifier accepts with probability at most </span>\\epsilon_{\\mathrm{LC}}<span class="math">. By a union bound, the acceptance probability is at most </span>\\epsilon_{\\mathrm{LC}} + \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">35</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Inconsistency with the partial assignment:  <span class="math">z \\neq (x, w)</span>  for some  <span class="math">w</span> . Note that after setting the final entries of  <span class="math">s_{t_{\\mathrm{in}} + 1}</span>  to zero, it is still the output of an  <span class="math">\\epsilon</span> -biased generator. By Lemma 4.5, the vector  <span class="math">s_1 \\otimes \\dots \\otimes s_{t_{\\mathrm{in}}} \\otimes s_{t_{\\mathrm{in}} + 1}&#x27;</span>  is the output of a  <span class="math">(t_{\\mathrm{in}} + 1)\\epsilon</span> -biased generator. This implies that  <span class="math">\\operatorname{Pr}_{s_1, \\ldots, s_{t_{\\mathrm{in}} + 1}}[\\langle s_1 \\otimes \\dots \\otimes s_t, z \\rangle = \\langle s_1 \\otimes \\dots \\otimes s_{t_{\\mathrm{in}} + 1}, x \\rangle] \\leq (t_{\\mathrm{in}} + 1)\\epsilon</span> . The acceptance probability is at most  <span class="math">(t_{\\mathrm{in}} + 1)\\epsilon</span> .</li>

    </ul>

    <p class="text-gray-300">Proof. We give an efficient simulator  <span class="math">\\mathbf{S}</span>  for Construction 4.14, such that for every index-instance tuple  <span class="math">(\\mathfrak{i},\\mathfrak{x})\\in L(R)</span>  and verifier randomness  <span class="math">r</span> , the random variables  <span class="math">\\mathbf{S}^{\\mathbf{V}}(\\mathfrak{i},\\mathfrak{x},r)</span>  and  <span class="math">\\mathrm{View}(\\mathbf{P}(\\mathfrak{i},\\mathfrak{x},\\mathfrak{w}),\\mathbf{V}(\\mathfrak{i},\\mathfrak{x},r))</span>  are identically distributed.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Start simulating  <span class="math">\\mathbf{V}</span> .</li>

      <li>Sample  <span class="math">(\\nu_{C},\\mu_{1},\\mu_{0})</span>  uniformly at random from  <span class="math">\\mathbb{F}^3</span> , and send to  <span class="math">\\mathbf{V}</span>  as non-oracle messages.</li>

      <li>Receive the challenge  <span class="math">\\alpha</span>  from  <span class="math">\\mathbf{V}</span> . Receive the seeds  <span class="math">\\rho_1, \\ldots, \\rho_t</span>  from  <span class="math">\\mathbf{V}</span>  and compute  <span class="math">r = G(\\rho_1) \\otimes \\dots \\otimes G(\\rho_t)</span> .</li>

      <li>Sample uniformly random  <span class="math">e, e_A, e_B \\in \\mathbb{F}^{k^t}</span>  conditioned on  <span class="math">\\langle e_A \\circ r, e_B \\rangle = \\alpha^2 \\nu_C + \\alpha \\mu_1 + \\mu_0</span> , and such that the entries of  <span class="math">e_A</span>  corresponding to the  <span class="math">(1, 0)</span>  in  <span class="math">z_A</span>  are equal to  <span class="math">(\\alpha, 1)</span> . Compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">f _ {A} := \\left[ \\begin{array}{c c} A &amp;amp; 0 \\\\ 0 &amp;amp; A _ {2} \\end{array} \\right] e, \\qquad f _ {B} := \\left[ \\begin{array}{c c} B &amp;amp; 0 \\\\ 0 &amp;amp; B _ {2} \\end{array} \\right] e, \\qquad f _ {C} := \\left[ \\begin{array}{c c} C &amp;amp; 0 \\\\ 0 &amp;amp; C _ {2} \\end{array} \\right] e \\quad \\in \\mathbb {F} ^ {k ^ {t}}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Engage in a twisted scalar-product subprotocol with  <span class="math">\\mathbf{V}</span>  to prove that  <span class="math">\\langle e_A\\circ r,e_B\\rangle = \\alpha^2\\nu_C + \\alpha \\mu_1 + \\mu_0</span>  and lincheck subprotocols to prove that  <span class="math">Ae = f_{A}</span> ,  <span class="math">Be = f_{B}</span>  and  <span class="math">Ce = f_{C}</span> .</li>

      <li>Answer the verifier's tensor query  <span class="math">\\langle r, z_C \\rangle</span>  with  <span class="math">\\nu_C</span> . Receive the seeds  <span class="math">\\sigma_1, \\ldots, \\sigma_{t_{\\mathrm{in}} + 1}</span> , compute  <span class="math">s_1, \\ldots, s_{t_{\\mathrm{in}} + 1}</span> , and answer the verifier's tensor query  <span class="math">\\langle s_1 \\otimes \\dots \\otimes s_t, z \\rangle</span>  with  <span class="math">\\langle s_1 \\otimes \\dots \\otimes s_{t_{\\mathrm{in}}}, x \\rangle</span> .</li>

    </ol>

    <p class="text-gray-300">Efficiency. We show that  <span class="math">\\mathbf{S}</span>  runs in polynomial time. This is clear apart from Item 4. To see that Item 4 is also efficient, note that the condition  <span class="math">\\langle e_A\\circ r,e_B\\rangle = \\alpha^2\\nu_C + \\alpha \\mu_1 + \\mu_0</span>  from Item 4 imposes a quadratic constraint on  <span class="math">e_{A},e_{B}</span> . The simulator samples  <span class="math">e_{A}</span>  first uniformly at random. Now,  <span class="math">e_{A}</span>  enforces a linear constraint on  <span class="math">e_{B}</span> . Since one entry of  <span class="math">e_{A}</span>  is  <span class="math">\\alpha</span>  which is non-zero,  <span class="math">e_{B}</span>  is sampled by sampling all entries except the entry corresponding to  <span class="math">\\alpha</span>  uniformly at random, and then choosing the entry corresponding to  <span class="math">\\alpha</span>  to satisfy the linear constraint.</p>

    <p class="text-gray-300">Finally, we argue that  <span class="math">\\mathbf{S}</span>  simulates the verifier's view perfectly. In a simulated view, all of the values  <span class="math">(e_A,e_B,e,\\nu_C,\\mu_1,\\mu_0)</span>  are uniformly random (except for three entries of  <span class="math">e_{A}</span>  being fixed to  <span class="math">(\\alpha ,1)</span> ) conditioned on satisfying the relation checked by the twisted scalar-product sub-protocol. The vectors  <span class="math">f_{A},f_{B}</span>  and  <span class="math">f_{C}</span>  are then fully determined by  <span class="math">e</span> . The values of any queries made as part of the sub-protocols are determined by  <span class="math">e</span> ,  <span class="math">f_{A}f_{B}</span>  and  <span class="math">f_{C}</span> .</p>

    <p class="text-gray-300">Correctness. To see that  <span class="math">\\mathbf{S}</span>  simulates the view of  <span class="math">\\mathbf{V}</span>  perfectly, we will display all of the randomisers used by the prover in a real proof, and then examine the distribution of oracle and non-oracle messages and queries.</p>

    <p class="text-gray-300">First, we display the randomizers in the last 2 entries of  <span class="math">z_A, z_B, z_C, y_A, y_B</span> , and the last 6 entries of  <span class="math">z, y</span> . All values denoted by letters and asterisks are sampled uniformly at random in a real execution by the honest prover:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">zA[-2 :]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">yA[-2 :]</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">zB[-2 :]</td>

            <td class="px-3 py-2 border-b border-gray-700">a1</td>

            <td class="px-3 py-2 border-b border-gray-700">a2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">yB[-2 :]</td>

            <td class="px-3 py-2 border-b border-gray-700">b1</td>

            <td class="px-3 py-2 border-b border-gray-700">b2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">zC[-2 :]</td>

            <td class="px-3 py-2 border-b border-gray-700">a1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z[-6 :]</td>

            <td class="px-3 py-2 border-b border-gray-700">zA[-2 :]</td>

            <td class="px-3 py-2 border-b border-gray-700">zB[-2 :]</td>

            <td class="px-3 py-2 border-b border-gray-700">zC[-2 :]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y[-6 :]</td>

            <td class="px-3 py-2 border-b border-gray-700">*</td>

            <td class="px-3 py-2 border-b border-gray-700">*</td>

            <td class="px-3 py-2 border-b border-gray-700">*</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now examine the distribution of oracle and non-oracle messages and queries.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Claim: The vector  <span class="math">\\alpha z + y</span>  is uniformly random. This is obvious due to the values of  <span class="math">z</span>  and  <span class="math">y</span>  as displayed above.</li>

      <li>Claim: the distribution of  <span class="math">\\alpha z_A + y_A</span>  is uniformly random, except for the first three entries which are  <span class="math">(\\alpha, 1)</span> . This is obvious due to the values of  <span class="math">z_A</span>  and  <span class="math">y_A</span>  as displayed above.</li>

      <li>Claim: The messages  <span class="math">\\mu_1 = \\langle z_A \\circ r, y_B \\rangle + \\langle y_A \\circ r, z_B \\rangle</span>  and  <span class="math">\\mu_0 = \\langle y_A \\circ r, y_B \\rangle</span> , and the vector  <span class="math">\\alpha z_B + y_B</span>  are uniformly random. These values can be written</li>

    </ul>

    <p class="text-gray-300">|  μ1  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  μ0  |</p>

    <p class="text-gray-300">|  αzB+yB  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(yA○r)T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(zA○r)T</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0k^t</td>

            <td class="px-3 py-2 border-b border-gray-700">(yA○r)T</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">αIk^t</td>

            <td class="px-3 py-2 border-b border-gray-700">Ik^t</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  zB  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  yB  |</p>

    <p class="text-gray-300">Consider the sub-matrix obtained by dropping the columns corresponding to all but the final 2 entries of  <span class="math">z_B</span>  and  <span class="math">y_B</span> . By choice of  <span class="math">z_A</span>  and  <span class="math">y_A</span> , and since all entries of  <span class="math">r</span>  are non-zero, this sub-matrix has full row-rank. The matrix equation above can be rewritten as the sum of a vector which depends on the witness, and the aforementioned sub-matrix multiplied by the random input vector  <span class="math">(a_1, a_2, b_1, b_2)</span> . The claim follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Claim: The query answer  <span class="math">\\nu_{C} = \\langle r, z_{C} \\rangle</span>  is uniformly distributed. This follows from the fact that the following equation holds, in which every term except  <span class="math">\\nu_{C}</span>  is known to be uniformly distributed.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left\\langle \\left(\\alpha z _ {A} + y _ {A}\\right) \\circ r, \\alpha z _ {B} + y _ {B} \\right\\rangle = \\alpha^ {2} \\nu_ {C} + \\alpha \\mu_ {1} + \\mu_ {0}.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Claim: The answers to the queries made as part of the three lincheck protocols are fully determined by  <span class="math">\\alpha z + y</span> . As described in Construction 4.14, the verifier makes, for example, query  <span class="math">(\\alpha, 1) \\otimes q</span>  to  <span class="math">(z, y)</span>  which is the same as query  <span class="math">q</span>  to  <span class="math">\\alpha z + y</span> , and queries  <span class="math">(\\alpha, 1) \\otimes q&#x27;</span>  to  <span class="math">(z_A, w_A)</span>  which is the same as query  <span class="math">q&#x27;</span>  to  <span class="math">\\alpha z_A + w_A</span> , and similarly for  <span class="math">B</span>  and  <span class="math">C</span> . This means that these query answers are determined by the vectors  <span class="math">\\alpha z + y</span> ,  <span class="math">\\alpha z_A + w_A</span> ,  <span class="math">\\alpha z_B + w_B</span>  and  <span class="math">\\alpha z_C + w_C</span> , and hence all by determined by  <span class="math">\\alpha z + y</span> , which is a random vector.</li>

      <li>The answer to the query  <span class="math">\\langle s_1 \\otimes \\dots \\otimes s_t, z \\rangle</span>  is always equal to  <span class="math">\\langle s_1 \\otimes \\dots \\otimes s_{t_{\\mathrm{in}}}, x \\rangle</span>  which is independent of the witness.</li>

    </ul>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">5 Algebraic reformulation of zero knowledge codes</p>

    <p class="text-gray-300">We provide algebraic reformulations of the conditions in Definition 3.21 that we use in this work. Throughout this section we fix a randomized linear code <span class="math">\\mathcal{C}=(\\mathrm{Enc},G,H,G^{+})</span> over a field <span class="math">\\mathbb{F}</span>, and state results that involve the following vector space: <span class="math">\\mathcal{D}(\\mathcal{C}):=\\{z\\in\\mathbb{F}^{n}\\mid z^{\\intercal}G_{r}=0\\}</span>.</p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Lemma 5.1.</h6>

    <p class="text-gray-300">The following are equivalent:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{C}</span> is <span class="math">b</span>-query zero-knowledge for exactly the integers <span class="math">b\\in[B]</span>.</li>

      <li>The minimum weight of codewords in <span class="math">\\mathcal{D}(\\mathcal{C})\\setminus\\mathcal{C}^{\\perp}</span> is <span class="math">B+1</span>.</li>

    </ol>

    <h6 id="sec-88" class="text-base font-medium mt-4">Lemma 5.2.</h6>

    <p class="text-gray-300">The following conditions are equivalent:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{C}</span> is <span class="math">b</span>-query uniform for exactly the integers <span class="math">b\\in[B]</span>.</li>

      <li><span class="math">\\mathcal{D}(\\mathcal{C})</span> has minimum (absolute) distance <span class="math">B+1</span>.</li>

    </ol>

    <p class="text-gray-300">We first prove Lemma 5.2 in Section 5.1 as it is simpler, and then prove Lemma 5.1 in Section 5.2.</p>

    <h6 id="sec-89" class="text-base font-medium mt-4">Remark 5.3.</h6>

    <p class="text-gray-300">Lemma 5.1 and Lemma 5.2 strengthen weaker statements in prior works, as summarized below.</p>

    <p class="text-gray-300">Cramer et al. <em>[x1, Theorem 11.77]</em> give a weight-characterization like Lemma 5.1 for <span class="math">b</span>-query zero-knowledge for Massey’s scheme. Then, <em>[x1, Remark 11.92]</em> states that this can be generalized to <span class="math">k_{m}&gt;1</span> and points to <em>[x2, Theorem 10]</em> for characterizations in terms of two codes. However, <em>[x1, Theorem 10]</em> involves projection maps and not a weight characterisation, which we do not know how to use to prove our results in Section 6. Lemma 5.1 proves the weight-characterisation in terms of the two codes <span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{D}(\\mathcal{C})</span>.</p>

    <p class="text-gray-300">Lemma 5.2 is related to <em>[x2, Corollary 4]</em> and <em>[x26, Lemma 6.4.1]</em>, which essentially use the condition that <span class="math">\\mathcal{D}(\\mathcal{C})</span> has no codeword of weight less than <span class="math">B+1</span> and prove that this condition implies <span class="math">B</span>-query zero-knowledge. Here, we strengthen that result to an <em>equivalence</em> by making two modifications:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>we consider the stronger notion of <span class="math">b</span>-query uniformity rather than <span class="math">b</span>-query zero-knowledge;</li>

      <li>we consider a condition on <span class="math">\\mathcal{D}(\\mathcal{C})</span>, namely, its minimum distance (there is no codeword of weight less than <span class="math">B+1</span> but there does exist a codeword of weight <span class="math">B+1</span>).</li>

    </ul>

    <p class="text-gray-300">Lemma 5.2 is also related to statements in <em>[x1]</em>. Specifically, for the special case of Massey’s secret-sharing scheme (which corresponds to a randomized linear code with <span class="math">k_{m}=1</span>), <em>[x1, Theorem 11.78]</em> shows that <span class="math">\\mathcal{C}</span> is <span class="math">b</span>-wise uniform for <span class="math">b\\leq d(\\mathcal{C}^{\\perp})-2</span>. Lemma 5.2, which uses a condition on <span class="math">d(\\mathcal{D}(\\mathcal{C}))</span>, strengthens this to an equivalence, and for all codes.</p>

    <p class="text-gray-300">In this section we use the following version of the XOR Lemma several times.</p>

    <h6 id="sec-90" class="text-base font-medium mt-4">Lemma 5.4 (XOR Lemma).</h6>

    <p class="text-gray-300">Two random variables <span class="math">X=(X_{1},\\ldots,X_{n})</span> and <span class="math">Y=(Y_{1},\\ldots,Y_{n})</span> over <span class="math">\\mathbb{F}^{n}</span> are equidistributed if and only if, for every <span class="math">z\\in\\mathbb{F}^{n}</span>, the random variables <span class="math">z^{\\intercal}X</span> and <span class="math">z^{\\intercal}Y</span> over <span class="math">\\mathbb{F}</span> are equidistributed. In particular, a random variable <span class="math">X=(X_{1},\\ldots,X_{n})\\in\\mathbb{F}^{n}</span> is uniformly distributed if and only if, for every non-zero <span class="math">z\\in\\mathbb{F}^{n}</span>, the random variable <span class="math">z^{\\intercal}X\\in\\mathbb{F}</span> is uniformly distributed.</p>

    <h3 id="sec-91" class="text-xl font-semibold mt-8">5.1 Proof of Lemma 5.2</h3>

    <p class="text-gray-300">We prove each of the two implications in turn.</p>

    <h6 id="sec-92" class="text-base font-medium mt-4"><span class="math">\\mathbf{1\\Rightarrow 2}</span>.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By hypothesis, <span class="math">\\mathcal{C}</span> is <span class="math">B</span>-query uniform but not <span class="math">(B+1)</span>-query uniform. This implies that there exists a message <span class="math">m^{<em>}\\in\\mathbb{F}^{k_{m}}</span> and a subset <span class="math">J^{</em>}\\subseteq[n]</span> with <span class="math">B+1</span> entries such that <span class="math">\\mathrm{Enc}(m^{<em>},r)_{J^{</em>}}</span> is not uniformly distributed. By Lemma 5.4, there exists non-zero <span class="math">z^{*}\\in\\mathbb{F}^{J}</span> such that $\\langle e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J^{<em>}},z^{</em>}\\rangle$ is not uniformly distributed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">w^{<em>}:=(w_{m}^{</em>},w_{r}^{<em>})</span>, where <span class="math">((w_{m}^{</em>})^{\\intercal})_{i}:=\\sum_{j\\in J}(z^{<em>})^{\\intercal}_{j}(G_{m})_{i,j}</span> for each <span class="math">i\\in[k_{m}]</span>, and <span class="math">((w_{r}^{</em>})^{\\intercal})_{i}:=\\sum_{j\\in J}(z^{<em>})^{\\intercal}_{j}(G_{r})_{i,j}</span> for each <span class="math">i\\in[k_{r}]</span>. Then, <span class="math">w_{r}^{</em>}</span> must be the zero vector, otherwise $\\langle e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J^{<em>}},z^{</em>}\\rangle<span class="math"> would be uniformly distributed. Therefore, </span>z^{*}<span class="math"> can be padded with zeroes to obtain a codeword in </span>\\mathcal{D}(\\mathcal{C})<span class="math"> of weight </span>B+1<span class="math">. Further, any codeword in </span>\\mathcal{D}(\\mathcal{C})<span class="math"> with weight at most </span>B<span class="math"> contradicts the </span>B<span class="math">-query uniformity of </span>\\mathcal{C}<span class="math"> via Lemma 5.4. Therefore, the minimum distance of </span>\\mathcal{D}(\\mathcal{C})<span class="math"> is exactly </span>B+1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2 <span class="math">\\Rightarrow</span> 1. Fix a message <span class="math">m\\in\\mathbb{F}^{k_{m}}</span> and a subset <span class="math">J\\subseteq[n]</span> of at most <span class="math">B</span> locations. We argue that, for a random <span class="math">r\\in\\mathbb{F}^{k_{r}}</span>, the entries in <span class="math">J</span> of <span class="math">e:=\\mathrm{Enc}(m,r)</span> are uniformly distributed. By Lemma 5.4, it suffices to check that for every non-zero vector <span class="math">z\\in\\mathbb{F}^{J}</span> the random variable $\\langle z,e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}\\rangle<span class="math"> is uniformly distributed. Let </span>G=\\begin{bmatrix}G_{m}&G_{r}\\end{bmatrix}<span class="math"> be the generator matrix of </span>\\mathcal{C}<span class="math">, so that </span>e=G_{m}m+G_{r}r<span class="math">. Setting </span>w:=(w_{m},w_{r})<span class="math"> defined similarly to </span>w_{m}^{<em>}<span class="math"> and </span>w_{r}^{</em>}<span class="math"> above. Then, writing </span>e<span class="math"> in terms of </span>m<span class="math">, </span>r<span class="math"> and </span>G$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\langle z,e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}\\rangle=\\sum_{j\\in J}z_{j}e_{j}=\\sum_{j\\in J}z_{j}(G_{m}m+G_{r}r)_{j}=\\langle w_{m},m\\rangle+\\langle w_{r},r\\rangle\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By our hypothesis, <span class="math">w_{r}</span> cannot be the zero vector, otherwise, <span class="math">z</span> can be padded with zeroes to obtain a codeword in <span class="math">\\mathcal{D}(\\mathcal{C})</span> of weight <span class="math">B</span>, which is less than the minimum distance of <span class="math">\\mathcal{D}(\\mathcal{C})</span>. Hence <span class="math">w_{r}</span> is non-zero, so <span class="math">\\langle r,w_{r}\\rangle</span> is uniformly distributed since <span class="math">r</span> is uniformly distributed over <span class="math">\\mathbb{F}^{k_{r}}</span>, and so $\\langle z,e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}\\rangle<span class="math"> is also uniformly distributed. The non-zero vector </span>z\\in\\mathbb{F}^{J}<span class="math"> was arbitrary, and by Lemma 5.4 we conclude that </span>e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}<span class="math"> is uniformly distributed. Further, </span>m<span class="math"> and </span>J<span class="math"> were also arbitrary, which proves that </span>\\mathcal{C}<span class="math"> is </span>b<span class="math">-query uniform. Finally, it is clear that </span>\\mathcal{C}<span class="math"> is not </span>(B+1)<span class="math">-query uniform because the codeword in </span>\\mathcal{D}(\\mathcal{C})<span class="math"> of weight </span>B+1<span class="math"> that exists by hypothesis gives a linear relation between </span>B+1<span class="math"> entries of </span>e<span class="math">. This shows that if </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=b+1<span class="math"> then </span>e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}$ is not uniformly distributed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-93" class="text-xl font-semibold mt-8">5.2 Proof of Lemma 5.1</h3>

    <p class="text-gray-300">We prove each of the two implications in turn, using the definition of <span class="math">b</span>-query zero-knowledge given by Definition C.1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 <span class="math">\\Rightarrow</span> 2. By hypothesis, <span class="math">\\mathcal{C}</span> is <span class="math">B</span>-query zero-knowledge but not <span class="math">(B+1)</span>-query zero-knowledge. This implies that there exist distinct messages <span class="math">m,m^{\\prime}\\in\\mathbb{F}^{k_{m}}</span> and a subset <span class="math">J\\subseteq[n]</span> of at most <span class="math">B+1</span> locations such that the distributions $\\{e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}\\mid e=\\mathrm{Enc}(m;r),r\\leftarrow\\mathbb{F}^{k_{r}}\\}<span class="math"> and </span>\\{e^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}\\mid e^{\\prime}=\\mathrm{Enc}(m^{\\prime};r^{\\prime}),r^{\\prime}\\leftarrow\\mathbb{F}^{k_{r}}\\}$ are not identical.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By Lemma 5.4, there exists a vector <span class="math">z\\in\\mathbb{F}^{J}</span> such that the distributions of $\\langle z,e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}\\rangle<span class="math"> and </span>\\langle z,e^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}\\rangle<span class="math"> are not identical. Let </span>G=\\begin{bmatrix}G_{m}&G_{r}\\end{bmatrix}<span class="math"> be the generator matrix of </span>\\mathcal{C}<span class="math">, so that </span>e=G_{m}m+G_{r}r<span class="math"> and similarly for </span>e^{\\prime}<span class="math">. Let </span>w_{m}\\in\\mathbb{F}^{k_{m}}<span class="math"> and </span>w_{r}\\in\\mathbb{F}^{k_{r}}<span class="math"> be defined by </span>(w_{m}^{\\intercal})_{i}:=\\sum_{j\\in J}z_{j}^{\\intercal}(G_{m})_{i,j}<span class="math"> for each </span>i\\in[k_{m}]<span class="math">, and </span>(w_{r}^{\\intercal})_{i}:=\\sum_{j\\in J}z_{j}^{\\intercal}(G_{r})_{i,j}<span class="math"> for each </span>i\\in[k_{r}]$. Then, as in the proof of Lemma 5.2, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\langle z,e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}\\rangle=\\langle w_{m},m\\rangle+\\langle w_{r},r\\rangle\\enspace,<span class="math"> </span>\\langle z,e^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}\\rangle=\\langle w_{m},m^{\\prime}\\rangle+\\langle w_{r},r^{\\prime}\\rangle\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By our hypothesis, <span class="math">w_{r}</span> must be the zero vector, otherwise $\\langle z,e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}\\rangle<span class="math"> and </span>\\langle z,e^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}\\rangle<span class="math"> are both uniformly random over </span>\\mathbb{F}<span class="math">. Therefore, </span>z<span class="math"> can be padded with zeroes to obtain a codeword </span>z^{*}\\in\\mathcal{D}(\\mathcal{C})<span class="math"> with at most </span>B+1<span class="math"> entries. Further, </span>w_{m}<span class="math"> must be non-zero, otherwise both </span>\\langle z,e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}\\rangle<span class="math"> and </span>\\langle z,e^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}\\rangle<span class="math"> would be equal to zero. Hence </span>z^{<em>}G_{m}\\neq 0<span class="math"> and </span>z^{</em>}<span class="math"> is not an element of </span>\\mathcal{C}^{\\perp}<span class="math">, which can be written </span>\\{x\\mid xG_{m}=0\\wedge xG_{r}=0\\}<span class="math">. Finally, note that </span>z^{<em>}<span class="math"> must have exactly </span>B+1<span class="math"> non-zero entries; a </span>z^{</em>}<span class="math"> with weight at most </span>B<span class="math"> would give a linear distinguisher for some set of </span>B<span class="math"> entries of </span>e<span class="math"> and </span>e^{\\prime}<span class="math"> and contradicts the </span>B<span class="math">-query zero-knowledge property of </span>\\mathcal{C}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2 <span class="math">\\Rightarrow</span> 1. We show that for every set <span class="math">J\\subseteq[n]</span> of size at most <span class="math">B</span>, and every message pair <span class="math">m,m^{\\prime}\\in\\mathbb{F}^{k_{m}}</span>, the distributions $\\{e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}\\mid e=\\mathrm{Enc}(m;r),r\\leftarrow\\mathbb{F}^{k_{r}}\\}<span class="math"> and </span>\\{e^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}\\mid e^{\\prime}=\\mathrm{Enc}(m^{\\prime};r^{\\prime}),r^{\\prime}\\leftarrow\\mathbb{F}^{k_{r}}\\}<span class="math"> are identical. By Lemma 5.4, it suffices to show that for all vectors </span>z\\in\\mathbb{F}^{J}<span class="math">, the random variables </span>\\langle z,e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}\\rangle<span class="math"> and </span>\\langle z,e^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}\\rangle<span class="math"> are identically distributed. We may pad </span>z\\in\\mathbb{F}^{J}<span class="math"> with zeroes to obtain </span>z^{*}\\in\\mathbb{F}^{n}<span class="math"> of weight at most </span>B$. By our</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">hypothesis, the minimum weight codeword of  <span class="math">\\mathcal{D}(\\mathcal{C})\\setminus \\mathcal{C}^{\\perp}</span>  is  <span class="math">B + 1</span> . Hence, any such  <span class="math">z^{<em>}</span> , which has weight at most  <span class="math">B</span> , is either not an element of  <span class="math">\\mathcal{D}(\\mathcal{C})</span> , or is an element of  <span class="math">\\mathcal{C}^{\\perp}</span> . In the first case,  <span class="math">z^{</em>}G_{r}\\neq 0</span> . Setting  <span class="math">w^{<em>} = (w_{m}^{</em>},w_{r}^{<em>})</span> , defined similarly to  <span class="math">w_{m}</span>  and  <span class="math">w_{r}</span>  above, we see that  <span class="math">w_{r}^{</em>}\\neq 0</span>  and that  $\\langle z,e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_J\\rangle<span class="math">  and  </span>\\langle z,e'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_J\\rangle<span class="math">  are both uniformly distributed over  </span>\\mathbb{F}<span class="math"> . In the second case,  </span>w_{r}^{<em>} = z^{</em>}G_{r} = 0<span class="math">  and  </span>w_{m}^{<em>} = z^{</em>}G_{m} = 0<span class="math"> . We see that  </span>w_{r}^{*}\\langle z,e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}\\rangle<span class="math">  and  </span>\\langle z,e'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_J\\rangle<span class="math">  are both equal to zero. Since  </span>m,m^{\\prime}<span class="math">  and  </span>J<span class="math">  were arbitrary, we conclude that  </span>\\mathcal{C}<span class="math">  has  </span>B$ -query zero-knowledge.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, it is clear that  <span class="math">\\mathcal{C}</span>  is not  <span class="math">(B + 1)</span> -query zero-knowledge because the weight  <span class="math">B + 1</span>  codeword  <span class="math">z^{*}</span>  of  <span class="math">\\mathcal{D}(\\mathcal{C}) \\setminus \\mathcal{C}^{\\perp}</span>  that exists by hypothesis yields a relation  $\\langle z, e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_J \\rangle = \\langle w_m, m \\rangle<span class="math">  for  </span>J<span class="math">  of size  </span>B + 1<span class="math">  and non-zero  </span>w_m<span class="math"> . This shows that one can distinguish between messages that have different values of  </span>\\langle w_m, m \\rangle$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We illustrate how the algebraic reformulations in this section relate to two well-known codes: the Reed-Solomon code (Section 5.3.1) and the Reed-Muller code (Section 5.3.2).</p>

    <p class="text-gray-300">Let  <span class="math">k_{m}, k_{r}, k</span>  and  <span class="math">n</span>  be positive integers such that  <span class="math">k = k_{m} + k_{r}</span> . Consider the randomized linear code  <span class="math">\\mathcal{C}</span>  derived from the Reed-Solomon code  <span class="math">\\mathcal{C} = \\mathrm{RS}[n, k, n - k + 1]</span> , whose encoding function  <span class="math">\\operatorname{Enc} \\colon \\mathbb{F}^{k_m} \\times \\mathbb{F}^{k_r} \\to \\mathbb{F}^n</span>  is defined by generator matrix</p>

    <div class="my-4 text-center"><span class="math-block">G = \\left[ \\begin{array}{l l} G _ {r} &amp;amp; G _ {m} \\end{array} \\right] = \\left[ \\begin{array}{l l l l l l l} 1 &amp;amp; \\omega_ {1} &amp;amp; \\omega_ {1} ^ {2} &amp;amp; \\dots &amp;amp; \\omega_ {1} ^ {k _ {r} - 1} &amp;amp; \\omega_ {1} ^ {k _ {r}} &amp;amp; \\dots &amp;amp; \\omega_ {1} ^ {k - 1} \\\\ 1 &amp;amp; \\omega_ {2} &amp;amp; \\omega_ {2} ^ {2} &amp;amp; \\dots &amp;amp; \\omega_ {2} ^ {k _ {r} - 1} &amp;amp; \\omega_ {2} ^ {k _ {r}} &amp;amp; \\dots &amp;amp; \\omega_ {2} ^ {k - 1} \\\\ \\vdots &amp;amp; \\vdots &amp;amp; \\vdots &amp;amp; \\ddots &amp;amp; \\vdots &amp;amp; \\vdots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ 1 &amp;amp; \\omega_ {n} &amp;amp; \\omega_ {n} ^ {2} &amp;amp; \\dots &amp;amp; \\omega_ {n} ^ {k _ {r} - 1} &amp;amp; \\omega_ {n} ^ {k _ {r}} &amp;amp; \\dots &amp;amp; \\omega_ {n} ^ {k - 1} \\end{array} \\right]</span></div>

    <p class="text-gray-300">for (pre-determined) distinct points  <span class="math">\\omega_{1},\\ldots ,\\omega_{n}\\in \\mathbb{F}</span> . Here, we have split the input to the encoding function into a  <span class="math">k_{r}</span> -element randomizer followed by a  <span class="math">k_{m}</span> -element message (for any desired  <span class="math">k_{m}</span>  and  <span class="math">k_{r}</span>  such that  <span class="math">k_{m} + k_{r} = k</span> ). One can verify that, for every message  <span class="math">m\\in \\mathbb{F}^{k_m}</span> , if  <span class="math">r\\in \\mathbb{F}^{k_r}</span>  is random then any subset of  <span class="math">k_{r}</span>  entries of  <span class="math">\\operatorname {Enc}(m,r)</span>  are uniformly distributed. We now explain how to alternatively understand this through the lens of Lemma 5.2 and the code  <span class="math">\\mathcal{D}(\\mathcal{C})</span> .</p>

    <p class="text-gray-300">Observe that  <span class="math">G_{r}</span>  generates the Reed-Solomon code  <span class="math">\\mathrm{RS}[n, k_{r}, n - k_{r} + 1]</span> . Next observe that  <span class="math">\\mathcal{D}(\\mathcal{C})</span>  is its dual code and is straightforward to understand: the dual of an MDS code is also an MDS code (and so the distance of the dual is easy to compute) and, in particular, the dual of a Reed-Solomon code is also a Reed-Solomon code. One can thus verify that  <span class="math">\\mathcal{D}(\\mathcal{C}) = \\mathrm{RS}[n, n - k_{r}, k_{r} + 1]</span> . Since  <span class="math">\\mathcal{D}(\\mathcal{C})</span>  has minimum distance  <span class="math">k_{r} + 1</span> , Lemma 5.2 shows that  <span class="math">\\mathcal{C}</span>  is  <span class="math">k_{r}</span> -query uniform. This agrees with our prior conclusion.</p>

    <p class="text-gray-300">Furthermore, any subset of  <span class="math">k_r + 1</span>  entries of  <span class="math">\\operatorname{Enc}(m, r)</span>  leak information about  <span class="math">m</span> . One can understand this via Lemma 5.1 and the set  <span class="math">\\mathcal{D}(\\mathcal{C}) \\setminus \\mathcal{C}^\\perp</span> . Observe that  <span class="math">\\mathcal{C}^\\perp</span>  is the Reed-Solomon code  <span class="math">\\mathrm{RS}[n, n - k, k + 1]</span>  which has minimum distance greater than  <span class="math">k_r + 1</span> . This means that removing  <span class="math">\\mathcal{C}^\\perp</span>  from  <span class="math">\\mathcal{D}(\\mathcal{C})</span>  does not change the weight  <span class="math">k_r + 1</span>  of the minimum weight codeword, and so  <span class="math">\\mathcal{C}</span>  is zero-knowledge for at most  <span class="math">k_r</span>  queries.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">\\ell, \\ell&#x27;, m</span>  be positive integers such that  <span class="math">\\ell &amp;lt; \\ell&#x27; \\leq m</span> . Let  <span class="math">H</span>  be a subgroup of the multiplicative group of  <span class="math">\\mathbb{F}_q</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= h<span class="math"> . Consider the Reed-Muller code  </span>\\mathrm{RM}[H, m, \\ell']<span class="math">  over  </span>\\mathbb{F}_q<span class="math"> . That is,  </span>\\mathrm{RM}[H, m, \\ell']$  is defined to be</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathrm{RM}[H,m,\\ell^{\\prime}] = \\{(f(\\vec{\\omega}))_{\\vec{\\omega}\\in H^{m}}\\mid f\\in \\mathbb{F}_{q}[Z_{1},\\ldots ,Z_{m}]</span>  with  <span class="math">\\deg (f)\\leq \\ell &#x27;</span>  and  <span class="math">\\forall i\\in [m],\\deg_{Z_i}(f)\\leq h - 1\\}</span></p>

    <p class="text-gray-300">which has block length <span class="math">n = h^m</span>. The code <span class="math">\\mathrm{RM}[H, m, \\ell&#x27;]</span> has a generator matrix <span class="math">G</span> where column corresponds to a distinct monomial in <span class="math">Z_1, \\ldots, Z_m</span>, evaluated at all points in <span class="math">H^m</span>, and the columns are ordered by graded lexicographic order of monomials. We may derive a randomized linear code <span class="math">\\mathcal{C}</span> by assigning the random part of the input to the monomials of degree at most <span class="math">\\ell</span>. This means that the matrix <span class="math">G_r</span> is a submatrix of <span class="math">G</span> which generates <span class="math">\\mathrm{RM}[H, m, \\ell]</span>.</p>

    <p class="text-gray-300">Let <span class="math">s, t</span> be the unique non-negative integers such that <span class="math">t &amp;lt; h - 1</span> and <span class="math">\\ell = s(h - 1) + t</span>. The code <span class="math">\\mathrm{RM}[H, m, \\ell]</span> has minimum distance <span class="math">(h - t) \\cdot h^{m - s - 1}</span>. The dual of the Reed-Muller code <span class="math">\\mathrm{RM}[H, m, \\ell]</span> is <span class="math">\\mathrm{RM}[H, m, m(h - 1) - \\ell - 1]</span>, which is <span class="math">\\mathcal{D}(\\mathcal{C})</span>. Further, <span class="math">\\mathcal{D}(\\mathcal{C})</span> has minimum distance <span class="math">(t + 2) \\cdot h^s</span>. By Lemma 5.2, <span class="math">\\mathcal{C}</span> is <span class="math">b</span>-query uniform for <span class="math">b &amp;lt; (t + 2) \\cdot h^s</span>.</p>

    <p class="text-gray-300">Now we analyze the zero-knowledge property of <span class="math">\\mathcal{C}</span> via Lemma 5.1 and the set <span class="math">\\mathcal{D}(\\mathcal{C}) \\setminus \\mathcal{C}^{\\perp}</span>. Let <span class="math">s&#x27;, t&#x27;</span> be the unique non-negative integers such that <span class="math">t&#x27; &amp;lt; h - 1</span> and <span class="math">\\ell&#x27; = s&#x27;(h - 1) + t&#x27;</span>. Observe that <span class="math">\\mathcal{C}^{\\perp}</span> is the Reed-Muller code <span class="math">\\mathrm{RM}[H, m, m(h - 1) - \\ell&#x27; - 1]</span> which has minimum distance <span class="math">(t&#x27; + 2) \\cdot h^{s&#x27;}</span>. This is always strictly greater than the minimum distance <span class="math">(t + 2) \\cdot h^s</span> of <span class="math">\\mathcal{D}(\\mathcal{C})</span>. Thus, removing <span class="math">\\mathcal{C}^{\\perp}</span> from <span class="math">\\mathcal{D}(\\mathcal{C})</span> does not change the weight of the minimum weight codeword, and so <span class="math">\\mathcal{C}</span> is <span class="math">b</span>-query zero-knowledge for <span class="math">b &amp;lt; (t + 2) \\cdot h^s</span> queries.</p>

    <p class="text-gray-300">41</p>

    <p class="text-gray-300">6 Tensor products of zero-knowledge codes</p>

    <p class="text-gray-300">We define the tensor product <span class="math">\\mathcal{C}\\otimes\\mathcal{C}^{\\prime}</span> of two randomized linear codes <span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{C}^{\\prime}</span>. The definition matches the standard notion of tensor products in that the vector space <span class="math">\\mathcal{C}\\otimes\\mathcal{C}^{\\prime}</span> is the tensor product of the vector spaces <span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{C}^{\\prime}</span>. However, we additionally need to specify how the randomized encoding function of <span class="math">\\mathcal{C}\\otimes\\mathcal{C}^{\\prime}</span> uses encoding randomness.</p>

    <h6 id="sec-97" class="text-base font-medium mt-4">Definition 6.1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}</span> be a <span class="math">[n,k_{m},k_{r},d]</span> randomized linear code with encoding function <span class="math">\\mathrm{Enc}_{\\mathcal{C}}\\colon\\mathbb{F}^{k_{m}}\\times\\mathbb{F}^{k_{r}}\\to\\mathbb{F}^{n}</span>. Let <span class="math">\\mathcal{C}^{\\prime}</span> be a <span class="math">[n^{\\prime},k_{m}^{\\prime},k_{r}^{\\prime},d^{\\prime}]</span> randomized linear code with encoding function <span class="math">\\mathrm{Enc}_{\\mathcal{C}^{\\prime}}\\colon\\mathbb{F}^{k_{m}^{\\prime}}\\times\\mathbb{F}^{k_{r}^{\\prime}}\\to\\mathbb{F}^{n^{\\prime}}</span>. The encoding function <span class="math">\\mathrm{Enc}_{\\mathcal{C}\\otimes\\mathcal{C}^{\\prime}}</span> for the <span class="math">[nn^{\\prime},k_{m}k_{m}^{\\prime},k_{m}k_{r}^{\\prime}+k_{r}k_{m}^{\\prime}+k_{r}k_{r}^{\\prime},dd^{\\prime}]</span> randomized linear code <span class="math">\\mathcal{C}\\otimes\\mathcal{C}^{\\prime}</span> is defined by the following procedure:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>Extend the input message <span class="math">m\\in\\mathbb{F}^{k_{m}\\times k_{m}^{\\prime}}</span> to the matrix <span class="math">\\tilde{m}\\in\\mathbb{F}^{(k_{m}+k_{r})\\times(k_{m}^{\\prime}+k_{r}^{\\prime})}</span> by padding with entries sampled independently and uniformly at random from <span class="math">\\mathbb{F}</span>.</li>

      <li>Output the codeword <span class="math">c\\in\\mathbb{F}^{n\\times n^{\\prime}}</span> obtained by applying <span class="math">\\widetilde{\\mathrm{Enc}}_{\\mathcal{C}}</span> to each row of <span class="math">\\tilde{m}</span> and then applying <span class="math">\\widetilde{\\mathrm{Enc}}_{\\mathcal{C}^{\\prime}}</span> to each column of the result.</li>

    </ul>

    <p class="text-gray-300">If <span class="math">\\mathcal{C}</span> has generator matrix <span class="math">\\begin{bmatrix}G_{m}&amp;G_{r}\\end{bmatrix}</span> and <span class="math">\\mathcal{C}^{\\prime}</span> has generator matrix <span class="math">\\begin{bmatrix}G_{m}^{\\prime}&amp;G_{r}^{\\prime}\\end{bmatrix}</span>, then <span class="math">\\mathcal{C}\\otimes\\mathcal{C}^{\\prime}</span> has generator matrix <span class="math">\\begin{bmatrix}G_{m}\\otimes G_{m}^{\\prime}\\end{bmatrix}G_{m}\\otimes G_{r}^{\\prime}\\quad G_{r}\\otimes G_{m}^{\\prime}\\quad G_{r}\\otimes G_{r}^{\\prime}</span> , where the first part corresponds to the message and the last three parts correspond to the encoding randomness.</p>

    <p class="text-gray-300">In this section we prove that the properties of bounded-query zero knowledge and bounded-query uniformity are preserved under the tensor operation.</p>

    <h6 id="sec-98" class="text-base font-medium mt-4">Theorem 6.2.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{C}^{\\prime}</span> be randomized linear codes.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>If <span class="math">\\mathcal{C}</span> is <span class="math">b</span>-query zero-knowledge and <span class="math">\\mathcal{C}^{\\prime}</span> is <span class="math">b^{\\prime}</span>-query zero-knowledge, then <span class="math">\\mathcal{C}\\otimes\\mathcal{C}^{\\prime}</span> is <span class="math">\\min(b,b^{\\prime})</span>-query zero-knowledge.</li>

      <li>If <span class="math">\\mathcal{C}</span> is <span class="math">b</span>-query uniform and <span class="math">\\mathcal{C}^{\\prime}</span> is <span class="math">b^{\\prime}</span>-query uniform, then <span class="math">\\mathcal{C}\\otimes\\mathcal{C}^{\\prime}</span> is <span class="math">\\min(b,b^{\\prime})</span>-query uniform.</li>

    </ol>

    <p class="text-gray-300">If we iteratively apply the above result to <span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{C}^{\\prime}=\\mathcal{C}^{\\otimes i}</span> for each <span class="math">i\\in[t-1]</span> then we obtain this corollary:</p>

    <h6 id="sec-99" class="text-base font-medium mt-4">Corollary 6.3.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}</span> be a randomized linear code.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>If <span class="math">\\mathcal{C}</span> is <span class="math">b</span>-query zero-knowledge, then, for any <span class="math">t\\in\\mathbb{N}</span>, <span class="math">\\mathcal{C}^{\\otimes t}</span> is <span class="math">b</span>-query zero-knowledge.</li>

      <li>If <span class="math">\\mathcal{C}</span> is <span class="math">b</span>-query uniform, then, for any <span class="math">t\\in\\mathbb{N}</span>, <span class="math">\\mathcal{C}^{\\otimes t}</span> is <span class="math">b</span>-query uniform.</li>

    </ol>

    <p class="text-gray-300">We now proceed to the proof of Theorem 6.2. We start with some preliminaries and a structural result (Proposition 6.7), and then prove each item of the theorem.</p>

    <h6 id="sec-100" class="text-base font-medium mt-4">Definition 6.4.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a field and <span class="math">M\\in\\mathbb{F}^{m\\times n}</span> a matrix. We define <span class="math">\\text{Null}(M)</span> to be the left null-space of <span class="math">M</span>:</p>

    <p class="text-gray-300"><span class="math">\\text{Null}(M):=\\{x\\in\\mathbb{F}^{m}:x^{\\intercal}M=0\\}\\ \\ .</span></p>

    <h6 id="sec-101" class="text-base font-medium mt-4">Lemma 6.5.</h6>

    <p class="text-gray-300">Let <span class="math">f\\colon V\\to W</span> and <span class="math">f^{\\prime}\\colon V^{\\prime}\\to W^{\\prime}</span> be surjective linear maps. Then</p>

    <p class="text-gray-300"><span class="math">\\ker(f\\otimes f^{\\prime})=\\ker(f)\\otimes V^{\\prime}+V\\otimes\\ker(f^{\\prime})</span></p>

    <h6 id="sec-102" class="text-base font-medium mt-4">Proof sketch.</h6>

    <p class="text-gray-300">We have <span class="math">V=I\\oplus K</span>, where <span class="math">I\\simeq W</span> and <span class="math">K=\\ker f</span>, and similarly for <span class="math">V^{\\prime}</span>. Thus, <span class="math">f\\otimes f^{\\prime}</span> is a linear mapping from <span class="math">V\\otimes V^{\\prime}</span> to <span class="math">W\\otimes W^{\\prime}</span>, where <span class="math">V\\otimes V^{\\prime}</span> is equal to <span class="math">(I\\otimes I^{\\prime})\\otimes(I\\otimes K^{\\prime})\\otimes(K\\otimes I^{\\prime})\\otimes(K\\otimes K^{\\prime})</span>. Now, <span class="math">f\\otimes f^{\\prime}</span> maps <span class="math">I\\otimes I^{\\prime}</span> to <span class="math">W\\otimes W^{\\prime}</span>, and has kernel <span class="math">(I\\otimes K^{\\prime})\\otimes(K\\otimes I^{\\prime})\\otimes(K\\otimes K^{\\prime})</span>, which can be rewritten as <span class="math">(K\\otimes V^{\\prime})+(V\\otimes K^{\\prime})</span>. ∎</p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-103" class="text-base font-medium mt-4">Corollary 6.6.</h6>

    <p class="text-gray-300">For randomized linear codes <span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{C}^{\\prime}</span>, <span class="math">(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})^{\\perp}=\\mathcal{C}\\otimes\\mathbb{F}^{n^{\\prime}}+\\mathbb{F}^{n}\\otimes\\mathcal{C}^{\\prime}</span>.</p>

    <h6 id="sec-104" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Setting <span class="math">f(x)=x^{\\intercal}G</span> and <span class="math">f^{\\prime}(x)=x^{\\intercal}G^{\\prime}</span> gives the result. The surjectivity of <span class="math">f</span> and <span class="math">f^{\\prime}</span> are guaranteed by the full rank of <span class="math">G</span> and <span class="math">G^{\\prime}</span>. ∎</p>

    <h6 id="sec-105" class="text-base font-medium mt-4">Proposition 6.7.</h6>

    <p class="text-gray-300">For randomized linear codes <span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{C}^{\\prime}</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})=(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})^{\\perp}+\\mathcal{D}(\\mathcal{C})\\otimes\\mathcal{D}(\\mathcal{C}^{\\prime})=\\mathcal{C}\\otimes\\mathbb{F}^{n^{\\prime}}+\\mathbb{F}^{n}\\otimes\\mathcal{C}^{\\prime}+\\mathcal{D}(\\mathcal{C})\\otimes\\mathcal{D}(\\mathcal{C}^{\\prime})</span></p>

    <h6 id="sec-106" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The spaces <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})</span> and <span class="math">(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})^{\\perp}</span> are characterized explicitly as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})=\\left\\{z\\in\\mathbb{F}^{n\\cdot n^{\\prime}}:z^{\\intercal}\\cdot(G_{r}\\otimes G_{m}^{\\prime})=0\\ \\wedge\\ z^{\\intercal}\\cdot(G_{m}\\otimes G_{r}^{\\prime})=0\\ \\wedge\\ z^{\\intercal}\\cdot(G_{r}\\otimes G_{r}^{\\prime})=0\\right\\},</span> <span class="math">(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})^{\\perp}=\\left\\{z\\in\\mathbb{F}^{n\\cdot n^{\\prime}}:z^{\\intercal}\\cdot(G\\otimes G^{\\prime})=0\\right\\}\\enspace.</span></p>

    <p class="text-gray-300">It is clear that <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})</span> contains both <span class="math">(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})^{\\perp}</span> and <span class="math">\\mathcal{D}(\\mathcal{C})\\otimes\\mathcal{D}(\\mathcal{C}^{\\prime})</span>, and so <span class="math">(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})^{\\perp}+\\mathcal{D}(\\mathcal{C})\\otimes\\mathcal{D}(\\mathcal{C}^{\\prime})\\subseteq\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})</span>.</p>

    <p class="text-gray-300">Now we show that <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})\\subseteq(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})^{\\perp}+\\mathcal{D}(\\mathcal{C})\\otimes\\mathcal{D}(\\mathcal{C}^{\\prime})</span>.</p>

    <p class="text-gray-300">By definition, <span class="math">\\mathcal{C}^{\\perp}\\subseteq\\mathcal{D}(\\mathcal{C})\\subseteq\\mathbb{F}^{n}</span>. Given a basis <span class="math">A=\\{a_{i}\\}_{i\\in I}</span> for <span class="math">\\mathcal{C}^{\\perp}</span>, we may extend it to a basis <span class="math">A\\cup B</span> for <span class="math">\\mathcal{D}(\\mathcal{C})</span> by adding <span class="math">B=\\{b_{j}\\}_{j\\in J}</span> such that no element <span class="math">b_{j}</span> is contained in <span class="math">\\mathcal{C}^{\\perp}</span>, and then again to a basis <span class="math">A\\cup B\\cup C</span> for <span class="math">\\mathbb{F}^{n}</span> by adding <span class="math">C=\\{c_{k}\\}_{k\\in K}</span> such that no element <span class="math">c_{k}</span> is contained in <span class="math">\\mathcal{D}(\\mathcal{C})</span>. The same applies to <span class="math">(\\mathcal{C}^{\\prime})^{\\perp}\\subseteq\\mathcal{D}(\\mathcal{C}^{\\prime})\\subseteq\\mathbb{F}^{n^{\\prime}}</span>. Considering the pairwise tensor products of basis elements for <span class="math">\\mathbb{F}^{n}</span> and <span class="math">\\mathbb{F}^{n^{\\prime}}</span> gives a basis of rank-2 tensors for <span class="math">\\mathbb{F}^{n\\cdot n^{\\prime}}</span>.</p>

    <p class="text-gray-300">It suffices to show that any rank-2 basis element <span class="math">z\\otimes z^{\\prime}\\in\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})</span> is in <span class="math">(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})^{\\perp}+\\mathcal{D}(\\mathcal{C})\\otimes\\mathcal{D}(\\mathcal{C}^{\\prime})</span>. If <span class="math">z\\otimes z^{\\prime}\\in\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})</span>, then by definition of <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})</span>, we have <span class="math">(z^{\\intercal}G_{r})\\otimes(z^{\\prime\\intercal}G_{m}^{\\prime})=0</span>, <span class="math">(z^{\\intercal}G_{m})\\otimes(z^{\\prime\\intercal}G_{r}^{\\prime})=0</span> and <span class="math">(z^{\\intercal}G_{r})\\otimes(z^{\\prime\\intercal}G_{r}^{\\prime})=0</span>. Thus, at least one of <span class="math">z^{\\intercal}G_{r}</span> and <span class="math">z^{\\prime\\intercal}G_{r}^{\\prime}</span> must be equal to zero. If both are zero, then <span class="math">z\\otimes z^{\\prime}\\in\\mathcal{D}(\\mathcal{C})\\otimes\\mathcal{D}(\\mathcal{C}^{\\prime})</span>.</p>

    <p class="text-gray-300">On the other hand, if, without loss of generality, <span class="math">z^{\\intercal}G_{r}=0</span> and <span class="math">z^{\\prime\\intercal}G_{r}^{\\prime}\\neq 0</span>, then since <span class="math">(z^{\\intercal}G_{m})\\otimes(z^{\\prime\\intercal}G_{r}^{\\prime})=0</span>, we must have <span class="math">z^{\\intercal}G_{m}=0</span>. Then, as <span class="math">z^{\\intercal}G_{m}=0</span> and <span class="math">z^{\\intercal}G_{r}=0</span>, we have <span class="math">z\\in\\mathcal{C}^{\\perp}</span>, and so <span class="math">z\\otimes z^{\\prime}\\in\\mathcal{C}^{\\perp}\\otimes\\mathbb{F}^{n^{\\prime}}</span>. By Corollary 6.6, we have <span class="math">(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})^{\\perp}=\\mathcal{C}^{\\perp}\\otimes\\mathbb{F}^{n^{\\prime}}+\\mathbb{F}^{n}\\otimes(\\mathcal{C}^{\\prime})^{\\perp}</span>, and so <span class="math">z\\otimes z^{\\prime}\\in(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})^{\\perp}</span>.</p>

    <p class="text-gray-300">Therefore, <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})\\subseteq(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})^{\\perp}+\\mathcal{D}(\\mathcal{C})\\otimes\\mathcal{D}(\\mathcal{C}^{\\prime})</span>, which completes the proof. ∎</p>

    <h6 id="sec-107" class="text-base font-medium mt-4">Proof of Item 2 in Theorem 6.2.</h6>

    <p class="text-gray-300">Using the algebraic characterisation of <span class="math">b</span>-query uniformity from Lemma 5.2, it suffices to prove that if <span class="math">\\mathcal{D}(\\mathcal{C})</span> has minimum distance at least <span class="math">b+1</span>, and <span class="math">\\mathcal{D}(\\mathcal{C}^{\\prime})</span> has minimum distance at least <span class="math">b^{\\prime}+1</span>, then <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})</span> has minimum distance at least <span class="math">\\min(b,b^{\\prime})+1</span>. Without loss of generality, suppose that <span class="math">b\\leq b^{\\prime}</span>. We show that <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})</span> has minimum distance at least <span class="math">b+1</span>.</p>

    <p class="text-gray-300">Let <span class="math">R:=\\mathcal{D}(\\mathcal{C})\\otimes\\mathbb{F}^{n^{\\prime}}+\\mathbb{F}^{n}\\otimes\\mathcal{D}(\\mathcal{C}^{\\prime})</span>. By Proposition 6.7, we have <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})=(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})^{\\perp}+\\mathcal{D}(\\mathcal{C})\\otimes\\mathcal{D}(\\mathcal{C}^{\\prime})</span>. Since <span class="math">\\mathcal{C}^{\\perp}\\subseteq\\mathcal{D}(\\mathcal{C})</span> and <span class="math">\\mathcal{C}^{\\prime\\perp}\\subseteq\\mathcal{D}(\\mathcal{C}^{\\prime})</span>, we have <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})\\subseteq R</span>. This means that the minimum distance of <span class="math">R</span> is a lower bound for the minimum distance of <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})</span>, so it suffices to show that the minimum distance of <span class="math">R</span> is at least <span class="math">b+1</span>. We will demonstrate this by showing that each element of <span class="math">R</span> with at most <span class="math">b</span> non-zero entries must be equal to zero. This implies that each non-zero element <span class="math">z\\in R</span> has weight at least <span class="math">b+1</span>.</p>

    <p class="text-gray-300">Writing <span class="math">\\mathbb{F}^{n^{\\prime}}</span> as a direct sum <span class="math">\\mathbb{F}^{n^{\\prime}}=\\mathcal{D}(\\mathcal{C}^{\\prime})\\oplus I(\\mathcal{C}^{\\prime})</span>, we have <span class="math">R=\\mathcal{D}(\\mathcal{C})\\otimes I(\\mathcal{C}^{\\prime})+\\mathbb{F}^{n}\\otimes\\mathcal{D}(\\mathcal{C}^{\\prime})</span>. We may therefore express any <span class="math">z\\in R</span> as the difference <span class="math">z=z_{1}-z_{2}</span>, for some <span class="math">z_{1}\\in\\mathcal{D}(\\mathcal{C})\\otimes I(\\mathcal{C}^{\\prime})</span> and <span class="math">z_{2}\\in\\mathbb{F}^{n}\\otimes\\mathcal{D}(\\mathcal{C}^{\\prime})</span>. Note that each row of <span class="math">z_{1}</span> lies in <span class="math">\\mathcal{D}(\\mathcal{C})</span>, each column of <span class="math">z_{1}</span> lies in <span class="math">I(\\mathcal{C}^{\\prime})</span>, and each column of <span class="math">z_{2}</span> lies in <span class="math">\\mathcal{D}(\\mathcal{C}^{\\prime})</span>.</p>

    <p class="text-gray-300">Suppose that <span class="math">z\\in R</span> has at most <span class="math">b</span> non-zero elements. Write <span class="math">z=z_{1}-z_{2}</span> as above. At least <span class="math">n-b</span> columns of <span class="math">z</span> are equal to zero. Hence, <span class="math">z_{1}</span> and <span class="math">z_{2}</span> are equal on these <span class="math">n-b</span> columns. Since each column of <span class="math">z_{2}</span> lies in <span class="math">\\mathcal{D}(\\mathcal{C}^{\\prime})</span> then these <span class="math">n-b</span> columns of <span class="math">z_{1}</span> lie in <span class="math">\\mathcal{D}(\\mathcal{C}^{\\prime})</span>, and hence in <span class="math">\\mathcal{D}(\\mathcal{C}^{\\prime})\\cap I(\\mathcal{C}^{\\prime})</span>, which is <span class="math">\\{0\\}</span>. This means that</p>

    <p class="text-gray-300"><span class="math">n-b</span> columns of <span class="math">z_{1}</span> are equal to zero, and that each row of <span class="math">z_{1}</span> contains at most <span class="math">b</span> non-zero entries. Since the minimum distance of <span class="math">\\mathcal{D}(\\mathcal{C})</span> is at least <span class="math">b+1</span>, each row of <span class="math">z_{1}</span> is zero, so <span class="math">z_{1}</span> is zero. Thus, <span class="math">z=z_{2}\\in\\mathbb{F}^{n}\\otimes\\mathcal{D}(\\mathcal{C}^{\\prime})</span>. But since the minimum distance of <span class="math">\\mathbb{F}^{n}\\otimes\\mathcal{D}(\\mathcal{C}^{\\prime})</span> is at least <span class="math">b^{\\prime}+1</span>, which is at least <span class="math">b+1</span>, we see that <span class="math">z=0</span>.</p>

    <p class="text-gray-300">This implies that each non-zero element <span class="math">z\\in R</span> has weight at least <span class="math">b+1</span>, completing the proof. ∎</p>

    <h6 id="sec-108" class="text-base font-medium mt-4">Proof of Item 1 in Theorem 6.2.</h6>

    <p class="text-gray-300">Using the algebraic characterisation of <span class="math">b</span>-query zero-knowledge from Lemma 5.1, it suffices to prove that if <span class="math">\\mathcal{D}(\\mathcal{C})\\setminus\\mathcal{C}^{\\perp}</span> has minimum weight at least <span class="math">b+1</span>, and <span class="math">\\mathcal{D}(\\mathcal{C}^{\\prime})\\setminus(\\mathcal{C}^{\\prime})^{\\perp}</span> has minimum weight at least <span class="math">b^{\\prime}+1</span>, then <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})\\setminus(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})^{\\perp}</span> has minimum weight at least <span class="math">\\min(b,b^{\\prime})+1</span>. Without loss of generality, suppose that <span class="math">b\\leq b^{\\prime}</span>. We show that <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})\\setminus(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})^{\\perp}</span> has minimum weight at least <span class="math">b+1</span>.</p>

    <p class="text-gray-300">Use <span class="math">N(\\mathcal{C})</span> to denote the linear subspace orthogonal to <span class="math">\\mathcal{C}^{\\perp}</span> such that <span class="math">\\mathcal{D}(\\mathcal{C})=\\mathcal{C}^{\\perp}\\oplus N(\\mathcal{C})</span>. We observe that since <span class="math">\\mathbb{F}^{n}=\\mathcal{C}^{\\perp}\\oplus\\mathcal{C}</span> and <span class="math">\\mathcal{D}(\\mathcal{C})\\subset\\mathbb{F}^{n}</span>, so <span class="math">N(\\mathcal{C})\\subset\\mathcal{C}</span>. Define a new linear space</p>

    <p class="text-gray-300"><span class="math">R:=\\left(\\mathcal{C}^{\\perp}\\otimes\\mathbb{F}^{n^{\\prime}}+\\mathcal{C}\\otimes(\\mathcal{C}^{\\prime})^{\\perp}\\right)+\\mathcal{C}\\otimes N(\\mathcal{C}^{\\prime})\\setminus\\left(\\mathcal{C}^{\\perp}\\otimes\\mathbb{F}^{n^{\\prime}}+\\mathcal{C}\\otimes(\\mathcal{C}^{\\prime})^{\\perp}\\right)\\enspace.</span></p>

    <p class="text-gray-300">By Proposition 6.7, we have <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})=(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})^{\\perp}+\\mathcal{D}(\\mathcal{C})\\otimes\\mathcal{D}(\\mathcal{C}^{\\prime})</span>. Since <span class="math">\\mathcal{D}(\\mathcal{C})=\\mathcal{C}^{\\perp}\\oplus N(\\mathcal{C})</span> and <span class="math">\\mathcal{D}(\\mathcal{C}^{\\prime})=\\mathcal{C}^{\\prime\\perp}\\oplus N(\\mathcal{C}^{\\prime})</span>, we have <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})=\\mathcal{C}^{\\perp}\\otimes\\mathbb{F}^{n^{\\prime}}+\\mathcal{C}\\otimes\\mathcal{C}^{\\prime\\perp}+N(\\mathcal{C})\\otimes N(\\mathcal{C}^{\\prime})</span>. Additionally since <span class="math">N(\\mathcal{C})\\subset\\mathcal{C}</span>, <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})\\setminus(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})^{\\perp}\\subset R</span>.</p>

    <p class="text-gray-300">This means that the minimum weight of <span class="math">R</span> is a lower bound for the minimum weight of <span class="math">\\mathcal{D}(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})\\setminus(\\mathcal{C}\\otimes\\mathcal{C}^{\\prime})^{\\perp}</span>, so it suffices to show that the minimum weight of <span class="math">R</span> is at least <span class="math">b+1</span>.</p>

    <p class="text-gray-300">We may therefore express any <span class="math">z\\in R</span> as the difference <span class="math">z=z_{1}-z_{2}</span>, for some <span class="math">z_{1}\\in\\mathcal{C}^{\\perp}\\otimes\\mathbb{F}^{n^{\\prime}}</span> and <span class="math">z_{2}\\in\\mathcal{C}\\otimes\\mathcal{D}(\\mathcal{C}^{\\prime})\\setminus\\mathcal{C}\\otimes(\\mathcal{C}^{\\prime})^{\\perp}</span>. Note that each row of <span class="math">z_{1}</span> lies in <span class="math">\\mathcal{C}^{\\perp}</span>, each row of <span class="math">z_{2}</span> lies in <span class="math">\\mathcal{C}</span>, and there exists a column of <span class="math">z_{2}</span> that lies in <span class="math">\\mathcal{D}(\\mathcal{C}^{\\prime})\\setminus(\\mathcal{C}^{\\prime})^{\\perp}</span>.</p>

    <p class="text-gray-300">Suppose that <span class="math">z\\in R</span> has at most <span class="math">b</span> non-zero elements. Write <span class="math">z=z_{1}-z_{2}</span> as above. At least <span class="math">n-b</span> rows of <span class="math">z</span> are equal to zero. Hence, <span class="math">z_{1}</span> and <span class="math">z_{2}</span> are equal on these <span class="math">n-b</span> rows. Since each row of <span class="math">z_{1}</span> lies in <span class="math">\\mathcal{C}^{\\perp}</span> then these <span class="math">n-b</span> rows of <span class="math">z_{2}</span> lie in <span class="math">\\mathcal{C}^{\\perp}</span>, and hence in <span class="math">\\mathcal{C}^{\\perp}\\cap\\mathcal{C}</span>, which is <span class="math">\\{0\\}</span>. This means that <span class="math">n-b</span> rows of <span class="math">z_{2}</span> are equal to zero, and that each column of <span class="math">z_{2}</span> contains at most <span class="math">b</span> non-zero entries. Since the minimum distance of <span class="math">\\mathcal{D}(\\mathcal{C}^{\\prime})\\setminus\\mathcal{C}^{\\prime\\perp}</span> is at least <span class="math">b+1</span>, no column of <span class="math">z_{2}</span> lies in <span class="math">\\mathcal{D}(\\mathcal{C}^{\\prime})\\setminus\\mathcal{C}^{\\prime\\perp}</span>, so <span class="math">z=z_{1}-z_{2}</span> cannot be in <span class="math">R</span>. We derive a contradiction.</p>

    <p class="text-gray-300">This implies that each element <span class="math">z\\in R</span> has weight at least <span class="math">b+1</span>, completing the proof. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">7 Zero-knowledge codes with linear-time encoding</p>

    <p class="text-gray-300">We state and prove our result about the existence of linear codes that are both linear-time encodable and <span class="math">b</span>-query zero knowledge (in fact, <span class="math">b</span>-query uniform).</p>

    <p class="text-gray-300"><strong>Definition 7.1.</strong> A field-agnostic circuit over variables <span class="math">x_1, \\ldots, x_n</span> is a directed acyclic graph such that (i) every node with in-degree 0 is labeled by a variable <span class="math">x_i</span>; (ii) every other gate is labelled by either <span class="math">+</span> or <span class="math">\\times</span>.²¹</p>

    <p class="text-gray-300"><strong>Definition 7.2.</strong> <span class="math">H_q(x) := x \\log_q(q - 1) - x \\log_q(x) - (1 - x) \\log_q(1 - x)</span> is the <span class="math">q</span>-ary entropy function.</p>

    <p class="text-gray-300"><strong>Theorem 7.3.</strong> For every choice of rate parameters <span class="math">\\rho, \\rho_m, \\rho_r \\in (0,1)</span> with <span class="math">\\rho = \\rho_m + \\rho_r</span>, there is a polynomial-time constructible field-agnostic circuit family <span class="math">\\{E_k\\}_{k \\in \\mathbb{N}}</span> where <span class="math">E_k</span> has size <span class="math">O(k)</span>, <span class="math">k + \\nu(k)</span> inputs and <span class="math">n</span> outputs, with <span class="math">\\nu(k) = O(k)</span> and <span class="math">k = \\lfloor \\rho n \\rfloor</span> such that for any finite field <span class="math">\\mathbb{F}</span> (of size <span class="math">q</span>) the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for every <span class="math">R \\in \\mathbb{F}^{\\nu(k)}</span>, <span class="math">E_k(\\cdot, R)</span> is an injective linear encoding function with message length <span class="math">k</span> and block length <span class="math">n</span>, which defines a randomized linear code <span class="math">\\mathcal{C}_k</span> with <span class="math">k_r = \\lceil \\rho_r n \\rceil</span> and <span class="math">k_m = k - k_r</span>;</li>

      <li>for every <span class="math">\\epsilon &amp;gt; 0</span>,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{R \\leftarrow \\mathbb{F}^{\\nu(k)}} \\left[ \\text{the relative distance of } \\mathcal{C}_k \\text{ is greater than } H_q^{-1}(1 - \\rho - \\epsilon) \\right] \\geq 1 - q^{1 - \\epsilon n}.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for every <span class="math">\\epsilon &amp;gt; 0</span>,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{R \\leftarrow \\mathbb{F}^{\\nu(k)}} \\left[ \\mathcal{C}_k \\text{ is $b$-query uniform with } (b + 1)/n &amp;gt; H_q^{-1}(\\rho_r - \\epsilon) \\right] \\geq 1 - q^{-\\epsilon n}.</span></div>

    <p class="text-gray-300">In Section 7.1 we introduce preliminaries and then in Section 7.2 we prove the theorem.</p>

    <p class="text-gray-300">7.1 Preliminaries</p>

    <p class="text-gray-300">We recall several definitions and results about linear uniform output families (LUO families) from Druk and Ishai [DI14]. Let <span class="math">\\mathbb{F}</span> be a finite field with <span class="math">q</span> elements.</p>

    <p class="text-gray-300"><strong>Definition 7.4.</strong> A <span class="math">(\\mathbb{F}, k, n)</span>-LUO family is a distribution <span class="math">\\mathcal{A}</span> over linear functions <span class="math">A \\colon \\mathbb{F}^k \\to \\mathbb{F}^n</span> such that for every non-zero <span class="math">x \\in \\mathbb{F}^k</span> and every <span class="math">y \\in \\mathbb{F}^n</span> it holds that <span class="math">\\operatorname{Pr}_{A \\leftarrow \\mathcal{A}}[Ax = y] = q^{-n}</span>. Equivalently, for every fixed non-zero <span class="math">x \\in \\mathbb{F}^k</span>, the distribution of <span class="math">Ax</span> induced by a choice of <span class="math">A</span> according to <span class="math">\\mathcal{A}</span> is uniform over <span class="math">\\mathbb{F}^n</span>.</p>

    <p class="text-gray-300"><strong>Lemma 7.5 (transposition).</strong> If <span class="math">\\mathcal{A}</span> is a <span class="math">(\\mathbb{F}, k, n)</span>-LUO family then <span class="math">\\mathcal{A}^{\\intercal} := \\{A^{\\intercal} \\mid A \\leftarrow \\mathcal{A}\\}</span> is a <span class="math">(\\mathbb{F}, n, k)</span>-LUO family. Namely, for every non-zero <span class="math">y \\in \\mathbb{F}^n</span> and every <span class="math">x \\in \\mathbb{F}^k</span> it holds that <span class="math">\\operatorname{Pr}_{A \\leftarrow \\mathcal{A}}[A^{\\intercal}y = x] = q^{-k}</span>.</p>

    <p class="text-gray-300"><strong>Theorem 7.6.</strong> For every parameter <span class="math">c \\in \\mathbb{N}</span> there is a polynomial-time constructible family <span class="math">\\{E_k\\}_{k \\in \\mathbb{N}}</span> of field-agnostic circuits where <span class="math">E_k</span> has size <span class="math">O(k)</span>, <span class="math">k + \\nu(k)</span> inputs and <span class="math">ck</span> outputs, such that for any field <span class="math">\\mathbb{F}</span>, viewing <span class="math">E_k</span> as a function <span class="math">E_k \\colon \\mathbb{F}^k \\times \\mathbb{F}^{\\nu(k)} \\to \\mathbb{F}^{ck}</span>, the function family <span class="math">\\{A_R(x) := E_k(x, R)\\}_{R \\in \\mathbb{F}^{\\nu(k)}}</span> is a <span class="math">(\\mathbb{F}, k, ck)</span>-LUO family when <span class="math">R</span> is chosen uniformly in <span class="math">\\mathbb{F}^{\\nu(k)}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> The circuit family <span class="math">E_k \\colon \\mathbb{F}^k \\times \\mathbb{F}^{\\nu(k)} \\to \\mathbb{F}^{ck}</span> of [DI14] provides a suitable LUO family. It remains to prove that the circuits <span class="math">E_k</span> are field-agnostic. The <span class="math">E_k</span> are given by a composition of circuits as <span class="math">E_k(x, R) = f_k \\circ M_R \\circ g_k</span>. The circuit <span class="math">g_k</span> is the encoding function for a recursive construction of a variant of Spielman codes, and for a suitable choice of base code, <span class="math">g_k</span> uses only addition and fan-out gates. The circuit <span class="math">f_k</span> is the</p>

    <p class="text-gray-300">²¹ A standard arithmetic circuit is defined over a field <span class="math">\\mathbb{F}</span>, and nodes with in-degree 0 can be labelled by elements of <span class="math">\\mathbb{F}</span> as well as variables. A field-agnostic circuit can be viewed as a circuit over any field <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">45</p>

    <p class="text-gray-300">transpose (see e.g. <em>[x14]</em>) of <span class="math">g_{k}</span> obtained by reversing the direction of the circuit for <span class="math">g_{k}</span> and thus also consists only of addition and fan-out gates. Finally, <span class="math">M_{R}</span> is left-multiplication by a block-diagonal matrix with entries specified by <span class="math">R</span>, and it is clear that this circuit can be implemented as stated since <span class="math">R</span> is an input to the circuit. ∎</p>

    <h6 id="sec-109" class="text-base font-medium mt-4">Theorem 7.7 (good codes from LUO).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">\\delta\\in[0,1-1/q)</span> a distance parameter, <span class="math">\\epsilon&gt;0</span> an error parameter, and <span class="math">n\\in\\mathbb{N}</span> a block length; define the message length <span class="math">k:=\\lceil(1-H_{q}(\\delta)-\\epsilon)\\cdot n\\rceil</span>. If <span class="math">\\mathcal{A}</span> is a <span class="math">(\\mathbb{F},k,n)</span>-LUO family then the image of <span class="math">A\\colon\\mathbb{F}^{k}\\to\\mathbb{F}^{n}</span> sampled from <span class="math">\\mathcal{A}</span> is a linear code with rate <span class="math">k/n</span> and relative distance strictly greater than <span class="math">\\delta</span>, except with probability at most <span class="math">q^{1-\\epsilon n}</span> over the choice of <span class="math">A</span>.</p>

    <h6 id="sec-110" class="text-base font-medium mt-4">Theorem 7.8 (good dual codes from LUO).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">\\epsilon&gt;0</span> an error parameter, <span class="math">k</span> a message length and <span class="math">n\\in\\mathbb{N}</span> a block length. Let <span class="math">\\mathcal{A}</span> be a <span class="math">(\\mathbb{F},k,n)</span>-LUO family. If <span class="math">A\\colon\\mathbb{F}^{k}\\to\\mathbb{F}^{n}</span> sampled from <span class="math">\\mathcal{A}</span> defines a code <span class="math">\\mathcal{C}</span>, then the kernel of <span class="math">A</span> is the dual code <span class="math">\\mathcal{C}^{\\perp}</span> with rate <span class="math">1-k/n</span> and relative distance strictly greater than <span class="math">H_{q}^{-1}(k/n-\\epsilon)</span>, except with probability at most <span class="math">q^{-\\epsilon n}</span> over the choice of <span class="math">A</span>.</p>

    <h3 id="sec-111" class="text-xl font-semibold mt-8">7.2 Proof of Theorem 7.3</h3>

    <h6 id="sec-112" class="text-base font-medium mt-4">Lemma 7.9.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field with <span class="math">q</span> elements. Let <span class="math">\\mathcal{A}</span> be a <span class="math">(\\mathbb{F},k,n)</span>-LUO family. Let <span class="math">\\epsilon&gt;0</span> be an error parameter, <span class="math">\\rho_{r}\\in(0,1)</span> be a randomness rate and <span class="math">b\\in\\mathbb{N}</span> be a bound such that <span class="math">\\rho_{r}\\leq k/n</span> and <span class="math">\\rho_{r}\\geq H_{q}((b+1)/n)+\\epsilon</span>. Then, for <span class="math">A\\leftarrow\\mathcal{A}</span>, the associated randomized linear code <span class="math">\\mathcal{C}=(A,G,G^{+},H)</span> with <span class="math">k_{r}=\\lceil\\rho_{r}n\\rceil</span> is <span class="math">b</span>-query uniform, except with probability at most <span class="math">q^{-\\epsilon n}</span> over the choice of <span class="math">A</span>.</p>

    <h6 id="sec-113" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The code <span class="math">\\mathcal{C}</span> has generator matrix <span class="math">G=\\begin{bmatrix}G_{m}&amp;G_{r}\\end{bmatrix}</span>. We give a lower bound on the minimum distance of <span class="math">\\mathcal{D}(\\mathcal{C})</span> that holds with high probability over the random choice of <span class="math">A\\in\\mathcal{A}</span>. Recall that <span class="math">\\mathcal{D}(\\mathcal{C})=\\{z\\in\\mathbb{F}^{n}\\mid z^{\\intercal}G_{r}=0\\}</span>, so if <span class="math">\\mathcal{C}</span> is induced by the LUO family <span class="math">\\mathcal{A}</span> then <span class="math">\\mathcal{D}(\\mathcal{C})</span> is induced by the LUO family $\\mathcal{A}^{\\intercal}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{[k]\\setminus[k_{m}]}:=\\{A^{\\intercal}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{[k]\\setminus[k_{m}]}\\mid A\\leftarrow\\mathcal{A}\\}<span class="math">. This is indeed a LUO family by Lemma 7.5 and the fact that truncating the output preserves the LUO property. By Theorem 7.8, </span>\\mathcal{D}(\\mathcal{C})<span class="math"> has relative distance strictly greater than </span>(b+1)/n=H_{q}^{-1}(\\rho_{r}-\\epsilon)<span class="math"> except with probability at most </span>1-q^{-\\epsilon n}<span class="math">. Hence, by Lemma 5.2, </span>\\mathcal{C}<span class="math"> is </span>b$-query uniform. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-114" class="text-base font-medium mt-4">Remark 7.10.</h6>

    <p class="text-gray-300">Lemma 7.9 gives a lower bound on the amount of randomness needed for a randomized linear code to achieve <span class="math">b</span>-query uniformity. This lower bound is essentially the same as the bound appearing in the probabilistic construction of zero-knowledge codes from <em>[x21, Theorem 6.3]</em>, rewritten using the <span class="math">q</span>-ary entropy function rather than the binary entropy function. This is because both results make use of the same condition on <span class="math">\\mathcal{D}(\\mathcal{C})</span> appearing in Lemma 5.2.</p>

    <p class="text-gray-300">Our code construction is, however, different. The construction of <em>[x21]</em> takes any fixed code <span class="math">\\mathcal{C}</span> with generator matrix <span class="math">G</span>, and constructs a new generator matrix <span class="math">G</span> by sampling a matrix <span class="math">M</span> which satisfies certain constraints, and setting <span class="math">G^{\\prime}:=GM^{-1}</span>. When encoding is performed using the generator matrix <span class="math">G^{\\prime}</span>, then the result is a randomized linear code that is <span class="math">b</span>-query uniform. This does not guarantee any linear-time encoding properties. For this reason, our construction in Lemma 7.9 shows that the condition of Lemma 5.2 is satisfied with high probability over a random code induced by a LUO family <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">More concretely, the construction of <em>[x21]</em> analyzes <span class="math">\\mathcal{D}(\\mathcal{C})</span> defined by the kernel of <span class="math">G_{r}^{<em>}</span> for <span class="math">GM^{-1}=\\begin{bmatrix}G_{m}^{</em>}&amp;G_{r}^{*}\\end{bmatrix}</span> for a randomly generated <span class="math">M</span>, and <span class="math">G</span> fixed, whereas we analyze the kernel of <span class="math">G_{r}</span> over the choice of <span class="math">G</span> induced by a random choice of function from a LUO family.</p>

    <h6 id="sec-115" class="text-base font-medium mt-4">Remark 7.11.</h6>

    <p class="text-gray-300">Besides a probabilistic construction, <em>[x21]</em> also gives a fully explicit construction of zero-knowledge codes. It is an interesting open problem to give a fully explicit construction of linear-time encodable codes with comparable <span class="math">b</span>-query uniformity.</p>

    <p class="text-gray-300">Proof of Theorem 7.3. We discuss each of the items in the theorem in turn.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By Theorem 7.6, there exists a polynomial-time constructible <span class="math">(q,k,n)</span>-LUO family with <span class="math">k=\\lfloor\\rho n\\rfloor</span> (after truncating and padding the input and output if necessary) given by <span class="math">E_{k}\\colon\\mathbb{F}^{k}\\times\\mathbb{F}^{\\nu(k)}\\to\\mathbb{F}^{n}</span> (so that each member of the family is given by <span class="math">E(\\cdot;R)</span> for some <span class="math">R\\in\\mathbb{F}^{\\nu(k)}</span>).</li>

      <li>By Theorem 7.7, we know that setting <span class="math">\\mathcal{C}=E_{k}(\\cdot,R)</span> for random <span class="math">R</span> gives a linear code with relative distance at least <span class="math">H_{q}^{-1}(1-\\rho)-\\epsilon</span>, except with probability at most <span class="math">q^{1-\\epsilon n}</span>. Given <span class="math">E_{k}</span>, one can efficiently compute the public parameters for <span class="math">\\mathcal{C}</span>.</li>

      <li>By Lemma 5.2 and Lemma 7.9, <span class="math">\\mathcal{C}</span> is <span class="math">b</span>-query uniform with <span class="math">b</span> at least <span class="math">H_{q}^{-1}(\\rho_{r}-\\epsilon)</span> except with probability at most <span class="math">q^{-\\epsilon n}</span>.</li>

    </ul>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-116" class="text-xl font-semibold mt-8">7.3 Setting parameters</h3>

    <h4 id="sec-117" class="text-lg font-semibold mt-6">Performance parameters.</h4>

    <p class="text-gray-300">We now explain how to choose parameters in Theorem 7.3 to prove Theorem 6.</p>

    <p class="text-gray-300">Fix a field <span class="math">\\mathbb{F}</span> of size <span class="math">q</span>, a constant <span class="math">\\epsilon\\in(0,1)</span> and a constant <span class="math">K</span> bounded away from <span class="math">1</span>, and consider the problem of constructing a family of random encoding circuits whose input size is denoted by <span class="math">k_{m}</span>. Find constants <span class="math">\\delta,\\epsilon_{r}\\in(0,1)</span> that satisfy</p>

    <p class="text-gray-300"><span class="math">1-H_{q}(\\delta)-H_{q}(K)-\\epsilon_{r}-\\epsilon&gt;0\\;\\;.</span> (1)</p>

    <p class="text-gray-300">Set the randomness rate <span class="math">\\rho_{r}\\coloneqq H_{q}(K)+\\epsilon_{r}</span> and the total rate <span class="math">\\rho\\coloneqq 1-H_{q}(\\delta)-\\epsilon</span>. By definition this ensures that the message rate <span class="math">\\rho_{m}=\\rho-\\rho_{r}&gt;0</span>. Then set the query bound <span class="math">b\\leq K\\cdot k_{m}/(\\rho-\\rho_{r})</span>. Finally set the code length <span class="math">n=k_{m}/\\rho_{m}</span> and the total message length <span class="math">k=\\rho n</span>.</p>

    <p class="text-gray-300">Now we apply Theorem 7.3 to the parameters <span class="math">\\mathbb{F},k,\\rho,\\rho_{m},\\rho_{r},\\epsilon_{r},b,</span> to obtain a family of random encoding circuits with input randomness length</p>

    <p class="text-gray-300"><span class="math">k_{r}=\\frac{H_{q}(K)+\\epsilon_{r}}{1-H_{q}(\\delta)-H_{q}(K)-\\epsilon_{r}-\\epsilon}k_{m}\\;\\;,</span> (2)</p>

    <p class="text-gray-300">and output length,</p>

    <p class="text-gray-300"><span class="math">n=\\frac{1}{1-H_{q}(\\delta)-H_{q}(K)-\\epsilon_{r}-\\epsilon}k_{m}\\;\\;.</span> (3)</p>

    <p class="text-gray-300">The failure to achieve relative distance at least <span class="math">\\delta</span> occurs with probability at most <span class="math">q^{1-\\epsilon n}</span>.</p>

    <p class="text-gray-300">The failure to achieve <span class="math">b</span>-query uniformity occurs with probability at most <span class="math">q^{-\\epsilon_{r}n}</span>.</p>

    <h4 id="sec-118" class="text-lg font-semibold mt-6">Obtaining Theorem 6.</h4>

    <p class="text-gray-300">Suppose that <span class="math">\\beta\\colon\\mathbb{N}\\to(0,1)</span> is bounded away from <span class="math">1</span>, so that there exists some constant <span class="math">K&lt;1</span> with <span class="math">\\beta(k_{m})\\leq K</span> for all <span class="math">k_{m}</span>. This means that <span class="math">H_{q}(\\beta(k_{m}))</span> is bounded away from <span class="math">1</span>. Thus, it is possible to choose <span class="math">\\epsilon_{r}</span> and <span class="math">\\delta</span> in <span class="math">(0,1)</span> satisfying Equation (1) for any value of <span class="math">k_{m}</span>.</p>

    <p class="text-gray-300">Consider Equation (2) and Equation (3). Since <span class="math">\\beta</span> is bounded away from <span class="math">1</span>, we see that <span class="math">1-H_{q}(\\delta)-H_{q}(\\beta)-\\epsilon_{r}-\\epsilon</span> is bounded below by a constant, and so <span class="math">k_{r}=(H_{q}(\\beta)+\\epsilon_{r})\\cdot O(k_{m})</span> and <span class="math">n=O(k_{m})</span>.</p>

    <p class="text-gray-300">Continuing this reasoning implies that the randomness used to generate the code and the code length are both linear in <span class="math">k_{m}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">48</p>

    <p class="text-gray-300">Definition 8.1. The indexed relation <span class="math">R_{\\mathrm{cons}}</span> is the set of tuples</p>

    <div class="my-4 text-center"><span class="math-block">(\\dot{\\mathbf{i}}, \\mathbf{x}, \\mathbf{w}) = \\left(\\bot, (\\mathbb{F}, \\mathcal{C}, \\ell, \\mathfrak{q}, t, \\{q^{(s)}\\}_{s}, \\{v_{s}\\}_{s}), c\\right)</span></div>

    <p class="text-gray-300">such that <span class="math">c = \\operatorname{Enc}_{\\mathcal{C}^{\\otimes t}}(f) \\in \\mathbb{F}^{\\ell \\cdot n^t}</span> for some <span class="math">f \\in \\mathbb{F}^{\\ell \\cdot k^t}</span>, for each <span class="math">s \\in [\\mathfrak{q}]</span>, <span class="math">q^{(s)} = (q_0^{(s)}, \\ldots, q_t^{(s)}) \\in \\mathbb{F}^\\ell \\times (\\mathbb{F}^k)^t</span>, and for all <span class="math">s \\in [\\mathfrak{q}]</span>, <span class="math">\\langle \\otimes_i q_i^{(s)}, f \\rangle = v^{(s)}</span>.</p>

    <p class="text-gray-300">Lemma 8.2. There exists an explicit polynomial-time transformation <span class="math">T</span> that satisfies the following. The inputs to the transformation are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A randomized <span class="math">t</span>-linear tensor code <span class="math">\\mathcal{C}^{\\otimes t}</span> over <span class="math">\\mathbb{F}</span> with encoding function <span class="math">\\widetilde{\\mathrm{Enc}}_{\\mathcal{C}^{\\otimes t}}</span>, which has rate <span class="math">\\rho_{m} = \\frac{k_{m}^{t}}{n^{t}}</span>, randomness rate <span class="math">\\rho_{r} = \\frac{k^{t} - k_{m}^{t}}{n^{t}}</span>, relative distance <span class="math">\\delta = \\frac{d^{t}}{n^{t}}</span>, and encoding arithmetic complexity <span class="math">\\theta(k_{m}) \\cdot k_{m}^{t}</span>.</li>

      <li>A holographic interactive oracle proof <span class="math">\\mathsf{IOP} = (\\mathbf{I}, \\mathbf{P}, \\mathbf{V})</span> with queries in <span class="math">\\mathcal{Q}_{\\mathrm{tensor}}(\\mathbb{F}, k_m, t)</span> for an indexed relation <span class="math">R</span> with: soundness error <span class="math">\\epsilon</span>; round complexity <span class="math">\\mathsf{rc}</span>; proof length <span class="math">l = l_i + l_p = \\ell k_m^t</span>; query complexity <span class="math">\\mathfrak{q}</span>; arithmetic complexity <span class="math">\\mathfrak{t}</span> for the indexer; arithmetic complexity <span class="math">\\mathfrak{tp}</span> for the prover; and arithmetic complexity <span class="math">\\mathfrak{tv}</span> for the verifier; semi-honest-verifier zero-knowledge.</li>

      <li>An interactive oracle proof of proximity <span class="math">\\mathsf{IOPP} = (\\mathbf{P}&#x27;, \\mathbf{V}&#x27;)</span> with queries in <span class="math">\\mathcal{Q}_{\\mathrm{point}}</span> for the indexed relation <span class="math">R_{\\mathrm{cons}}(\\mathbb{F}, \\mathcal{C}, \\ell, \\mathfrak{q}, t)</span> with soundness error <span class="math">\\epsilon&#x27;</span>; round complexity <span class="math">\\mathsf{rc}&#x27;</span>; proof length <span class="math">l&#x27;</span>; input query complexity <span class="math">\\mathfrak{q}_{\\mathbb{x}}&#x27;</span>, the number of verifier queries to the input oracle; proof query complexity <span class="math">\\mathfrak{q}_{\\pi}&#x27;</span>, the number of verifier queries to the IOPP proof oracles; arithmetic complexity <span class="math">\\mathfrak{tp}&#x27;</span> for the prover; arithmetic complexity <span class="math">\\mathfrak{tv}&#x27;</span> for the verifier.</li>

    </ul>

    <p class="text-gray-300">The output of the transformation <span class="math">(\\hat{\\mathbf{I}},\\hat{\\mathbf{P}},\\hat{\\mathbf{V}})\\coloneqq T(\\mathcal{C},\\mathsf{IOP},\\mathsf{IOPP})</span> is an interactive oracle proof with queries in <span class="math">\\mathcal{Q}_{\\mathrm{point}}</span> for the indexed relation <span class="math">R</span> with the following parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error $\\max (\\epsilon ,(1 - 1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\epsilon '(1 / 4) + 1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity <span class="math">\\mathsf{rc} + \\mathsf{rc}&#x27; + 1</span>;</li>

      <li>proof length <span class="math">O\\left(\\frac{n^t}{k_m^t} \\cdot l\\right) + l&#x27;</span>;</li>

      <li>query complexity <span class="math">2\\mathfrak{q}_{\\mathbb{X}}&#x27; + \\mathfrak{q}_{\\pi}&#x27;</span>, where <span class="math">2\\mathfrak{q}_{\\mathbb{X}}&#x27;</span> queries are to the IOP proof oracles, and <span class="math">\\mathfrak{q}_{\\pi}&#x27;</span> queries are to the IOPP proof oracles;</li>

      <li>indexer time <span class="math">\\mathsf{t_i} + \\mathsf{t_i}&#x27;</span>;</li>

      <li>prover time <span class="math">\\mathfrak{tp} + \\mathfrak{tp}&#x27;</span>; and</li>

      <li>verifier time <span class="math">\\mathfrak{tv} + \\mathfrak{tv}&#x27;</span>.</li>

    </ul>

    <p class="text-gray-300">Moreover,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if the interleaved code <span class="math">\\left(\\mathcal{C}^{\\otimes t}\\right)^{\\ell}</span> is <span class="math">\\mathbf{Q}</span>-query zero knowledge and the honest IOPP verifier <span class="math">\\mathbf{V}&#x27;</span>' witness queries are compatible with <span class="math">\\mathbf{Q}</span>, then <span class="math">(\\hat{\\mathbf{I}},\\hat{\\mathbf{P}},\\hat{\\mathbf{V}})</span> is zero knowledge against semi-honest verifiers;</li>

      <li>if <span class="math">\\left(\\mathcal{C}^{\\otimes t}\\right)^{\\ell}</span> is <span class="math">b</span>-query zero knowledge, <span class="math">(\\hat{\\mathbf{I}},\\hat{\\mathbf{P}},\\hat{\\mathbf{V}})</span> is zero knowledge against all verifiers making at most <span class="math">b</span> queries to the IOP oracles.</li>

    </ol>

    <p class="text-gray-300">Finally, if inputs are public-coin protocols then the output of the transformation is also a public-coin protocol.</p>

    <p class="text-gray-300">Remark 8.3. The round complexity is <span class="math">rc + rc&#x27; + 1</span> in the case that the verifier <span class="math">\\mathbf{V}</span> makes non-adaptive queries, because then <span class="math">\\hat{\\mathbf{V}}</span> can handle all of the queries in a single round. In the case where the <span class="math">\\mathfrak{q}</span> queries are made as adaptively as possible, the round complexity would be <span class="math">rc + rc&#x27; + \\mathfrak{q}</span>. If <span class="math">\\mathbf{V}</span> is public-coin, then <span class="math">\\hat{\\mathbf{P}}</span> already knows all of the queries and the round complexity would be <span class="math">rc + rc&#x27;</span>.</p>

    <p class="text-gray-300">Remark 8.4. The stated time for the (honest) prover <span class="math">\\hat{\\mathbf{P}}</span> assumes that <span class="math">\\hat{\\mathbf{P}}</span> has access to the output of the indexer <span class="math">\\mathbf{I}</span>, since <span class="math">\\hat{\\mathbf{P}}</span> must compute and send the answers to tensor queries involving the output of <span class="math">\\mathbf{I}</span>.</p>

    <h2 id="sec-120" class="text-2xl font-bold">8.1 Construction</h2>

    <p class="text-gray-300">Though Definition 3.5 specifies that tensor queries are of the form <span class="math">q(\\mathbb{x}, \\Pi_0, \\ldots, \\Pi_i) = \\langle q_0 \\otimes q_1 \\otimes \\dots \\otimes q_t, \\Pi_j \\rangle</span>, our transformation below handles tensor queries of the form <span class="math">\\langle q_0 \\otimes q_1 \\otimes \\dots \\otimes q_t, \\mathrm{stack}(\\Pi_0, \\ldots, \\Pi_{\\mathrm{rc}}) \\rangle</span>, which are more general.</p>

    <p class="text-gray-300"><strong>Construction 8.5.</strong> We describe the construction of <span class="math">(\\hat{\\mathbf{I}},\\hat{\\mathbf{P}},\\hat{\\mathbf{V}})</span>. The new indexer <span class="math">\\hat{\\mathbf{I}}</span>, given an index <span class="math">\\mathbb{i}</span>, runs <span class="math">\\mathbf{I}</span> on <span class="math">\\mathbb{i}</span> to produce <span class="math">\\Pi_0\\in \\mathbb{F}^{\\ell_0\\cdot k_m^t}</span>, pads <span class="math">\\Pi_0</span> with zeroes for encoding randomness to get <span class="math">\\tilde{\\Pi}_0\\in \\mathbb{F}^{\\ell_0\\cdot k^t}</span>, computes <span class="math">\\tilde{\\Pi}_0\\coloneqq \\widetilde{\\mathrm{Enc}}_{\\mathcal{C}^{\\otimes t}}(\\tilde{\\Pi}_0)\\in \\mathbb{F}^{\\ell_0\\cdot n^t}</span>, and outputs <span class="math">\\tilde{\\Pi}_0</span>. The new prover <span class="math">\\hat{\\mathbf{P}}</span> receives as input the index <span class="math">\\mathbb{i}</span>, an instance <span class="math">\\mathbb{x}</span>, and a witness <span class="math">\\mathbb{w}</span>, while the new verifier <span class="math">\\hat{\\mathbf{V}}</span> receives as oracle the encoded proof <span class="math">\\tilde{\\Pi}_0</span> and as input the instance <span class="math">\\mathbb{x}</span>. The new prover <span class="math">\\hat{\\mathbf{P}}</span> and the new verifier <span class="math">\\hat{\\mathbf{V}}</span> interact in two phases, a simulation phase and a consistency phase. We describe each in turn.</p>

    <p class="text-gray-300"><strong>(1) Simulation phase.</strong> For each <span class="math">i \\in [\\mathsf{rc}]</span>, <span class="math">\\hat{\\mathbf{P}}</span> and <span class="math">\\hat{\\mathbf{V}}</span> simulate the <span class="math">i</span>-th round of the interaction between <span class="math">\\mathbf{P}(\\mathbb{i}, \\mathbb{x}, \\mathbb{w})</span> and <span class="math">\\mathbf{V}^{\\mathbf{I}(\\mathbb{i})}(\\mathbb{x})</span>, as well as any tensor queries by <span class="math">\\mathbf{V}</span> to the received proof strings.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Prover messages.</strong> For any proof message <span class="math">\\Pi_i \\in \\mathbb{F}^{\\ell_i \\cdot k_m^t}</span> that it receives from <span class="math">\\mathbf{P}</span>, <span class="math">\\hat{\\mathbf{P}}</span> pads <span class="math">\\Pi_i</span> with uniformly-sampled encoding randomness to get <span class="math">\\tilde{\\Pi}_i \\in \\mathbb{F}^{\\ell_i \\cdot k^t}</span>, computes a new proof message <span class="math">\\tilde{\\Pi}_i := \\widetilde{\\mathrm{Enc}}_{\\mathcal{C}^{\\otimes t}}(\\tilde{\\Pi}_i) \\in \\mathbb{F}^{\\ell_i \\cdot n^t}</span>, and sends <span class="math">\\tilde{\\Pi}_i</span> to <span class="math">\\hat{\\mathbf{V}}</span>. Also, <span class="math">\\hat{\\mathbf{P}}</span> forwards any non-oracle messages from <span class="math">\\mathbf{P}</span> to <span class="math">\\mathbf{V}</span> via <span class="math">\\hat{\\mathbf{V}}</span>.</li>

      <li><strong>Verifier messages.</strong> <span class="math">\\hat{\\mathbf{V}}</span> receives challenge message <span class="math">\\rho_{i}</span> from <span class="math">\\mathbf{V}</span> and forwards it to <span class="math">\\hat{\\mathbf{P}}</span>, who forwards it to <span class="math">\\mathbf{P}</span>.</li>

      <li><strong>Tensor queries.</strong> If <span class="math">\\hat{\\mathbf{V}}</span> receives any tensor query (or queries) <span class="math">q \\in \\mathcal{Q}_{\\mathrm{tensor}}(\\mathbb{F}, k_m, t)</span> on <span class="math">(\\Pi_0, \\Pi_1, \\ldots, \\Pi_i)</span> from <span class="math">\\mathbf{V}</span>, it sends the query <span class="math">q</span> to <span class="math">\\hat{\\mathbf{P}}</span>, who checks whether the set of tensor queries <span class="math">\\hat{\\mathbf{V}}</span> sent so far could be made by the verifier <span class="math">\\mathbf{V}</span>. If not, <span class="math">\\hat{\\mathbf{P}}</span> terminates the interaction. If so, it responds by computing <span class="math">q(\\mathbb{x}, \\Pi_0, \\Pi_1, \\ldots, \\Pi_i)</span> and sending it to <span class="math">\\hat{\\mathbf{V}}</span> as a non-oracle message. Then <span class="math">\\hat{\\mathbf{V}}</span> forwards this (alleged) query answer to <span class="math">\\mathbf{V}</span>.</li>

    </ol>

    <p class="text-gray-300">This completes the simulation of the tensor IOP. If at this point the tensor IOP verifier <span class="math">\\mathbf{V}</span> rejects, then the new verifier <span class="math">\\hat{\\mathbf{V}}</span> rejects too. (There is no need to check if the IOP prover <span class="math">\\hat{\\mathbf{P}}</span> answered tensor queries honestly.)</p>

    <p class="text-gray-300"><strong>(2) Consistency phase.</strong> In this phase the IOP verifier <span class="math">\\hat{\\mathbf{V}}</span> checks that the IOP prover <span class="math">\\hat{\\mathbf{P}}</span> honestly answered the tensor queries of the tensor IOP verifier <span class="math">\\mathbf{V}</span> in the simulation phase. Suppose that the tensor queries of <span class="math">\\mathbf{V}</span> are <span class="math">\\{q^{(s)} = (q_0^{(s)},\\ldots ,q_t^{(s)})\\}_{s\\in [\\mathfrak{q}]}</span>, and the prover <span class="math">\\hat{\\mathbf{P}}</span> has sent alleged answers <span class="math">\\{v^{(s)}\\}_{s\\in [\\mathfrak{q}]}</span> to them; note that these are known to both parties. The IOP prover <span class="math">\\hat{\\mathbf{P}}</span> and IOP verifier <span class="math">\\hat{\\mathbf{V}}</span> interact as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Masking.</strong> The prover <span class="math">\\hat{\\mathbf{P}}</span> samples uniformly random mask <span class="math">\\Xi \\in \\mathbb{F}^{\\ell \\cdot k_m^t}</span>, pads <span class="math">\\Xi</span> with uniformly-sampled encoding randomness to get <span class="math">\\tilde{\\Xi} \\in \\mathbb{F}^{\\ell \\cdot k^t}</span>, computes an encoding <span class="math">\\tilde{\\Xi} \\gets \\widetilde{\\mathrm{Enc}}_{\\mathcal{C}^{\\otimes t}}(\\tilde{\\Xi}) \\in \\mathbb{F}^{\\ell \\cdot n^t}</span>, and sends <span class="math">\\tilde{\\Xi}</span> to <span class="math">\\hat{\\mathbf{V}}</span>. The prover computes <span class="math">w_s := q^{(s)}(\\mathbb{x}, \\Xi)</span> for each <span class="math">s \\in [\\mathfrak{q}]</span>, and sends <span class="math">(w_s)_{s \\in [\\mathfrak{q}]} \\in \\mathbb{F}^{\\mathfrak{q}}</span> to <span class="math">\\hat{\\mathbf{V}}</span> as a non-oracle message. The verifier <span class="math">\\hat{\\mathbf{V}}</span> responds with a challenge <span class="math">\\alpha</span> sampled uniformly from <span class="math">\\mathbb{F}</span>.</li>

    </ol>

    <p class="text-gray-300">Define the functions</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde{\\Pi} := \\mathrm{Stack}(\\tilde{\\Pi}_0, \\ldots, \\tilde{\\Pi}_{\\mathrm{rc}}) \\in \\mathbb{F}^{\\ell \\cdot k^t} \\ ,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\hat{\\Pi} := \\operatorname{Stack}(\\hat{\\Pi}_0, \\dots, \\hat{\\Pi}_{\\mathsf{rc}}) \\in \\mathbb{F}^{\\ell \\cdot n^t},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\tilde{f} := \\alpha \\cdot \\hat{\\Pi} + \\hat{\\Xi} \\in \\mathbb{F}^{\\ell \\cdot k^t}, \\text{ and}</span></div>

    <div class="my-4 text-center"><span class="math-block">c := \\alpha \\cdot \\hat{\\Pi} + \\hat{\\Xi} \\in \\mathbb{F}^{\\ell \\cdot n^t}.</span></div>

    <p class="text-gray-300">Note that <span class="math">c = \\operatorname{Enc}_{\\mathcal{C}^{\\otimes t}}(\\tilde{f})</span>. Moreover, <span class="math">\\hat{\\mathbf{P}}</span> already knows the value of <span class="math">\\tilde{f}</span> and of <span class="math">c</span> at every point, and <span class="math">\\hat{\\mathbf{V}}</span> can compute the value of any point in <span class="math">c</span> by querying the corresponding points in <span class="math">\\hat{\\Pi}</span> and <span class="math">\\hat{\\Xi}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consistency test. Let <span class="math">\\{q^{(s)}\\}_s</span> be the set of tensor queries. Let <span class="math">\\{q_{<em>}^{(s)}\\}_s</span> be the set of queries obtained by taking each query <span class="math">q^{(s)} \\in \\mathbb{F}^{\\ell} \\times (\\mathbb{F}^{k_m})^t</span> and appending zeroes to the end of each component to obtain an element of <span class="math">\\mathbb{F}^{\\ell} \\times (\\mathbb{F}^k)^t</span>. Note that <span class="math">\\langle \\otimes q_{</em>}^{(s)}, \\tilde{f} \\rangle = \\langle \\otimes q^{(s)}, f \\rangle</span> for each <span class="math">s \\in [\\mathfrak{q}]</span>.</li>

    </ol>

    <p class="text-gray-300">The prover <span class="math">\\hat{\\mathbf{P}}</span> and verifier <span class="math">\\hat{\\mathbf{V}}</span> engage in the IOP of proximity protocol <span class="math">\\mathsf{IOPP} = (\\mathbf{P}&#x27;, \\mathbf{V}&#x27;)</span> for <span class="math">R_{\\mathrm{cons}}</span> with index <span class="math">\\dot{\\mathfrak{s}} = \\bot</span>, instance <span class="math">\\mathbf{x} = (\\mathbb{F}, \\mathcal{C}, \\ell, \\mathfrak{q}, t, \\{q_{<em>}^{(s)}\\}_{s}, \\{\\alpha \\cdot v_{s} + w_{s}\\}_{s})</span>, and witness <span class="math">\\mathbf{w} = c</span> to ensure that <span class="math">c \\in (\\mathcal{C}^{\\otimes t})^{\\ell}</span> (or at least close) and that for all <span class="math">s \\in [\\mathfrak{q}]</span>, <span class="math">\\langle \\otimes q_{</em>}^{(s)}, \\tilde{f} \\rangle = \\alpha \\cdot v_{s} + w_{s}</span>. If <span class="math">\\mathbf{V}&#x27;</span> rejects in this sub-protocol, then <span class="math">\\hat{\\mathbf{V}}</span> rejects.</p>

    <h2 id="sec-121" class="text-2xl font-bold">8.2 Proof of Lemma 8.2</h2>

    <p class="text-gray-300">Proof. The round complexity, proof length, query complexity, indexer time, prover time, and verifier time follow directly from the construction. The completeness follows from the completeness of the original tensor IOP protocol <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> and the completeness of the IOPP protocol <span class="math">(\\mathbf{P}&#x27;,\\mathbf{V}&#x27;)</span>.</p>

    <p class="text-gray-300">Soundness. Suppose <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x}) \\notin L(R)</span>, fix a malicious prover <span class="math">\\tilde{\\mathbf{P}}</span>. Let <span class="math">\\hat{\\Pi}</span> be the oracle messages sent to <span class="math">\\hat{\\mathbf{V}}</span> during the simulation phase and <span class="math">\\hat{\\Xi}</span> be the mask sent at the start of the consistency phase. At least one of the following cases would hold:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\hat{\\Pi}</span> or <span class="math">\\hat{\\Xi}</span> is <span class="math">1/2</span>-far from <span class="math">(\\mathcal{C}^{\\otimes t})^{\\ell}</span> (here we consider blockwise distance). Let <span class="math">\\hat{\\Pi}_{\\perp}</span> and <span class="math">\\hat{\\Xi}_{\\perp}</span> denote the components of the oracles that are orthogonal to <span class="math">(\\mathcal{C}^{\\otimes t})^{\\ell}</span>. Let <span class="math">T_{e} := \\{j \\in [n^{t}] \\mid \\exists i \\in [\\ell] \\text{ s.t. } \\hat{\\Pi}_{\\perp}[i,j] \\neq 0 \\lor \\hat{\\Xi}_{\\perp}[i,j] \\neq 0\\}</span>. Define a collection of disjoint sets of coordinates <span class="math">\\{S_{\\beta}\\}_{\\beta \\in \\mathbb{F}}</span> where <span class="math">S_{\\beta} := \\{j \\in T_{e} \\mid \\forall i \\in [\\ell k], \\beta \\hat{\\Pi}_{\\perp}[i,j] + \\hat{\\Xi}_{\\perp}[i,j] = 0\\}</span>. Note that $\\sum_{\\beta \\in \\mathbb{F}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{e}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{e}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; n^{t}/2$. Then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{aligned} \\Pr_{\\alpha \\sim \\mathbb{F}} \\left[ \\alpha \\hat{\\Pi} + \\hat{\\Xi} \\text{ is } 1/4\\text{-close to } (\\mathcal{C}^{\\otimes t})^{\\ell} \\right] &amp;= \\Pr_{\\alpha \\sim \\mathbb{F}} \\left[ \\alpha \\hat{\\Pi}_{\\perp} + \\hat{\\Xi}_{\\perp} \\text{ is } 1/4\\text{-close to } 0^{\\ell \\cdot n^{t}} \\right] \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&amp;= \\Pr_{\\alpha \\sim \\mathbb{F}} \\left[ \\delta_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{e}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- n^{t}/4} \\right] \\quad (\\delta_{E} \\text{ is the indicator variable of event } E) \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">&amp;&lt; \\frac{2}{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\, .</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{aligned} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since the probability can only be multiples of $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, we obtain an upper bound of </span>1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. In this case </span>\\hat{\\mathbf{V}}<span class="math"> accepts with probability at most </span>1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ (1 - 1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\epsilon'(1/4)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\hat{\\Pi}</span> and <span class="math">\\hat{\\Xi}</span> are <span class="math">1/2</span>-close to <span class="math">(\\mathcal{C}^{\\otimes t})^{\\ell}</span>. In this case <span class="math">\\hat{\\mathbf{V}}</span> accepts with probability at most <span class="math">\\epsilon</span> by the soundness of the original IOP protocol.</li>

    </ul>

    <p class="text-gray-300">Zero knowledge. By construction, if the honest IOPP verifier <span class="math">\\mathbf{V}&#x27;</span>'s witness queries are compatible with some query checker <span class="math">\\mathbf{Q}</span>, then the resulting honest IOP verifier <span class="math">\\hat{\\mathbf{V}}</span>'s queries to <span class="math">\\hat{\\Pi}</span> and <span class="math">\\hat{\\Xi}</span> are also compatible</p>

    <p class="text-gray-300">with <span class="math">\\mathbf{Q}</span>. Thus, to show the two zero knowledge properties of the compiler, it suffices to prove that when <span class="math">\\left(\\mathcal{C}^{\\otimes t}\\right)^{\\ell}</span> is <span class="math">\\mathbf{Q}</span>-query zero knowledge, the new protocol is zero knowledge for every verifier whose queries to <span class="math">\\hat{\\Pi}</span> and <span class="math">\\hat{\\Xi}</span> are compatible with <span class="math">\\mathbf{Q}</span>.</p>

    <p class="text-gray-300">We define a simulator <span class="math">\\hat{\\mathbf{S}}</span> that when given access to such a verifier <span class="math">\\tilde{\\mathbf{V}}</span>, the original IOP simulator <span class="math">\\mathbf{S}</span>, 2 identical simulators <span class="math">\\mathcal{S}_1</span> and <span class="math">\\mathcal{S}_2</span> for the code <span class="math">\\left(\\mathcal{C}^{\\otimes t}\\right)^{\\ell}</span>, and input <span class="math">(\\mathbb{i},\\mathbb{x})</span> simulates the view of <span class="math">\\tilde{\\mathbf{V}}</span> in the real protocol.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Start simulating <span class="math">\\tilde{\\mathbf{V}}</span>.</li>

      <li>Answer any tensor query <span class="math">q^{(s)} \\in \\mathcal{Q}_{\\mathrm{tensor}}(\\mathbb{F}, k, t)</span> on <span class="math">\\Pi</span> by first checking whether the set of tensor queries <span class="math">\\tilde{\\mathbf{V}}</span> sent so far could be made by the honest IOP verifier <span class="math">\\mathbf{V}</span>. If not, return "stop". If so, send <span class="math">q^{(s)}</span> to <span class="math">\\mathbf{S}</span> and reply with <span class="math">\\mathbf{S}</span>'s answer <span class="math">v_s</span>.</li>

      <li>Forward any point query to <span class="math">\\hat{\\Pi}</span> to <span class="math">\\mathcal{S}_1</span> and answer with the simulator's output. Denote the set of queries by <span class="math">Q_{\\hat{\\Pi},0}</span>.</li>

      <li>For each tensor query <span class="math">q^{(s)} \\in \\mathcal{Q}_{\\mathrm{tensor}}(\\mathbb{F}, k, t)</span> to the encoded mask, sample a uniformly random element in <span class="math">\\mathbb{F}</span> as the answer <span class="math">w_s</span> and send it to <span class="math">\\tilde{\\mathbf{V}}</span>. In the consistency phase, forward any query to <span class="math">\\hat{\\Xi}</span> to <span class="math">\\mathcal{S}_2</span> and answer with the simulator's output. Let <span class="math">Q_{\\hat{\\Xi}}</span> be <span class="math">\\tilde{\\mathbf{V}}</span>'s point queries to <span class="math">\\hat{\\Xi}</span> before the simulation of the next step. Let <span class="math">A_{\\hat{\\Xi}}</span> be <span class="math">\\hat{\\mathbf{S}}</span>'s answers to these queries.</li>

      <li>Receive the challenge <span class="math">\\alpha</span> from <span class="math">\\tilde{\\mathbf{V}}</span>.</li>

      <li>For any <span class="math">q \\in Q_{\\hat{\\Xi}} \\setminus Q_{\\hat{\\Pi},0}</span>, sample <span class="math">\\hat{\\Pi}(q)</span> uniformly at random in <span class="math">\\mathbb{F}</span>. Sample <span class="math">X \\in \\mathbb{F}^{\\ell \\cdot k^t}</span> uniformly at random conditioned on that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\forall q ^ {(s)} \\in \\mathcal {Q} _ {\\text {t e n s o r}} (\\mathbb {F}, k, t), \\quad q ^ {(s)} (\\mathbf {x}, X) = \\alpha v _ {s} + w _ {s}, \\tag {4}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall \\left(j _ {0}, \\dots , j _ {t}\\right) \\in Q _ {\\hat {\\Xi}}, \\quad \\hat {X} \\left(j _ {0}, \\dots , j _ {t}\\right) = \\alpha \\hat {\\Pi} \\left(j _ {0}, \\dots , j _ {t}\\right) + A _ {\\hat {\\Xi}} \\left(j _ {0}, \\dots , j _ {t}\\right). \\tag {5}</span></div>

    <p class="text-gray-300">Let <span class="math">\\tilde{f} \\coloneqq X</span>. In the rest of the consistency phase, run the IOPP prover <span class="math">\\mathbf{P}&#x27;</span> on instance <span class="math">\\mathbb{x}_{\\mathrm{IOPP}} = (\\mathbb{F}, \\mathcal{C}, \\ell, \\mathfrak{q}, t, \\{q_{<em>}^{(s)}\\}_{s}, \\{q_{</em>}^{(s)}(\\mathbf{x}, X)\\}_{s})</span> using witness <span class="math">\\hat{X}</span> to generate messages and oracles for the IOPP protocol.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Answer any query <span class="math">q</span> to <span class="math">\\hat{\\Xi}</span> (resp. <span class="math">\\hat{\\Pi}</span>) by first checking if <span class="math">q</span> has been made to <span class="math">\\hat{\\Pi}</span> (resp. <span class="math">\\hat{\\Xi}</span>). If not, forward it to <span class="math">S_{2}</span> (resp. <span class="math">S_{1}</span>) and answer with the simulator's output. If so, answer with <span class="math">\\hat{X}(q) - \\alpha \\hat{\\Pi}(q)</span> (resp. <span class="math">\\alpha^{-1}(\\hat{X}(q) - \\hat{\\Xi}(q))</span>).</li>

    </ol>

    <p class="text-gray-300">Note that <span class="math">\\hat{\\mathbf{S}}</span> runs in polynomial time. In particular, in Item 2 checking whether the set of tensor queries is in the support of the honest verifier's query sets requires solving a system of linear equations of constant dimensions. Additionally since an honest verifier makes only constant number of tensor queries, this step only takes constant time. In Item 6, we conditionally sample <span class="math">X</span>. Let <span class="math">R</span> denote the randomness used in encoding <span class="math">X</span>. Equation (4) imposes linear constraint on <span class="math">X</span>, while Equation (5) imposes linear constraint on <span class="math">X</span> and <span class="math">R</span>. These constraints can be efficiently generated from the queries <span class="math">q^{(s)}</span> and the generator matrix of the code</p>

    <p class="text-gray-300">51</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathcal{C}</span>. Since <span class="math">\\mathcal{Q}_{\\mathrm{tensor}}(\\mathbb{F},k,t)</span>'s size is bounded by a constant and <span class="math">Q_{\\hat{\\Xi}}</span>'s size is bounded by $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, the set of linear equations on </span>X<span class="math"> and </span>R<span class="math"> can be solved in </span>\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\ell k^t,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> time. Other steps of </span>\\hat{\\mathbf{S}}$ are clearly efficient.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To see that <span class="math">\\hat{\\mathbf{S}}</span> simulates the view of <span class="math">\\hat{\\mathbf{V}}</span> perfectly, we consider a hybrid experiment in which the "hybrid prover" reads all of the witness <span class="math">z</span> (like the honest prover in the real world) but can modify messages after they are sent (like the simulator in the ideal world).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Start simulating <span class="math">\\hat{\\mathbf{V}}</span>.</li>

      <li>Answer any tensor query <span class="math">q^{(s)}</span> to <span class="math">\\hat{\\Pi}</span> by first checking whether the set of tensor queries <span class="math">\\hat{\\mathbf{V}}</span> sent so far could be made by the honest IOP verifier <span class="math">\\mathbf{V}</span>. If not, return "stop". If so, send <span class="math">q^{(s)}</span> to <span class="math">\\mathbf{S}</span> and reply with <span class="math">\\mathbf{S}</span>'s answer <span class="math">v_{s}</span>.</li>

      <li>Forward any point query to <span class="math">\\hat{\\Pi}</span> to <span class="math">S_{1}</span> and answer with the simulator's output. Denote the set of queries by <span class="math">Q_{\\hat{\\Pi},0}</span> and the answers by <span class="math">A_{\\hat{\\Pi},0}</span>.</li>

      <li>Construct a uniformly random <span class="math">\\Pi \\in \\mathbb{F}^{\\ell \\cdot k_m^t}</span> such that for each <span class="math">s \\in [\\mathfrak{q}]</span>, the answer to the tensor query <span class="math">q^{(s)}</span> on <span class="math">\\Pi</span> is <span class="math">v_{s}</span>. Find the encoding of <span class="math">\\Pi</span> such that for all <span class="math">q \\in Q_{\\hat{\\Pi},0}</span>, <span class="math">\\hat{\\Pi}(q) = A_{\\hat{\\Pi},0}(q)</span>.</li>

      <li>Sample a random mask <span class="math">\\Xi \\in \\mathbb{F}^{\\ell \\cdot k_m^t}</span>, pad it with randomness to get <span class="math">\\hat{\\Xi} \\in \\mathbb{F}^{\\ell \\cdot k^t}</span>, and then encode the padded mask to obtain <span class="math">\\hat{\\Xi} \\in \\mathbb{F}^{\\ell \\cdot n^t}</span>. Compute <span class="math">w_{s} = q^{(s)}(\\Xi, \\Xi)</span> and send the answers to <span class="math">\\hat{\\mathbf{V}}</span>.</li>

      <li>Answer any query to <span class="math">\\hat{\\Pi}</span> by <span class="math">\\hat{\\Pi}</span>, and any query to <span class="math">\\hat{\\Xi}</span> by <span class="math">\\hat{\\Xi}</span>. Let <span class="math">Q_{\\hat{\\Xi}}</span> be <span class="math">\\hat{\\mathbf{V}}</span>'s queries to <span class="math">\\hat{\\Xi}</span> before the simulation of the next step. Let <span class="math">A_{\\hat{\\Xi}}</span> be <span class="math">\\hat{\\mathbf{S}}</span>'s answers to these queries.</li>

      <li>Receive the challenge <span class="math">\\alpha</span> from <span class="math">\\hat{\\mathbf{V}}</span>.</li>

      <li>Query <span class="math">\\hat{\\Pi}</span> at all locations in <span class="math">Q_{\\hat{\\Xi}}</span>. Sample <span class="math">X \\in \\mathbb{F}^{\\ell \\cdot k^t}</span> uniformly at random conditioned on that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\forall q^{(s)} \\in \\mathcal{Q}_{\\text{tensor}}(\\mathbb{F}, k, t) \\quad q_{*}^{(s)}(\\Xi, X) = \\alpha v_{s} + w_{s}, \\\\ \\forall (j_{0}, \\dots, j_{t}) \\in Q_{\\hat{\\Xi}}, \\quad \\hat{X}(j_{0}, \\dots, j_{t}) = \\alpha \\hat{\\Pi}(j_{0}, \\dots, j_{t}) + A_{\\hat{\\Xi}}(j_{0}, \\dots, j_{t}) \\quad . \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Replace <span class="math">\\hat{\\Xi}</span> with <span class="math">\\hat{X} - \\alpha \\hat{\\Pi}</span>.</li>

      <li>Simulate the rest of the interaction with the oracles <span class="math">\\hat{\\Xi}, \\hat{\\Pi}</span>, and <span class="math">\\hat{X}</span>.</li>

    </ol>

    <p class="text-gray-300">By the zero-knowledge property of the original IOP protocol, in this experiment <span class="math">(\\{q^{(s)}, v_s\\}_s, \\Pi)</span> are identically distributed as in the real protocol. Also since <span class="math">\\hat{\\mathbf{V}}</span>'s queries to <span class="math">\\hat{\\Pi}</span> and <span class="math">\\hat{\\Xi}</span> are compatible with <span class="math">\\mathbf{Q}</span> and the interleaved code <span class="math">\\left(\\mathcal{C}^{\\otimes t}\\right)^{\\ell}</span> is <span class="math">\\mathbf{Q}</span>-query zero knowledge, the distribution <span class="math">(\\{q_{<em>}^{(s)}, v_s\\}_s, (Q_{\\hat{\\Pi},0}, A_{\\hat{\\Pi},0}))</span> is identical to the distribution produced by the prover. So the joint distribution of <span class="math">(\\{q_{</em>}^{(s)}, v_s\\}_s, (Q_{\\hat{\\Pi},0}, A_{\\hat{\\Pi},0}), \\hat{\\Pi})</span> is also identical to that in the real protocol. Moreover all queries to <span class="math">\\hat{\\Xi}</span> after Item 9 have the correct distribution as in the actual protocol. Finally, the view of <span class="math">\\hat{\\mathbf{V}}</span> in the above experiment follows the same distribution as the output of the simulator <span class="math">\\hat{\\mathbf{S}}</span>. Therefore <span class="math">(\\hat{\\mathbf{I}}, \\hat{\\mathbf{P}}, \\hat{\\mathbf{V}})</span> is zero-knowledge for any <span class="math">\\hat{\\mathbf{V}}</span> whose queries to <span class="math">\\hat{\\Pi}</span> and <span class="math">\\hat{\\Xi}</span> are compatible with <span class="math">\\mathbf{Q}</span>.</p>

    <p class="text-gray-300">52</p>

    <p class="text-gray-300">53</p>

    <p class="text-gray-300">9 Main theorem</p>

    <p class="text-gray-300">Below we state our main theorem, Theorem 9.1, which is an IOP with point queries for rank-1 constraint satisfiability, and the formal analogue of Theorem 1. Theorem 9.1 differs from Theorem 1 in that we expose several parameters of interest, described below. See Remark 9.2 and Remark 9.3 for an explanation of how these parameters lead to Theorem 1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the following theorem, we denote by <span class="math">M</span> the number of non-zero entries in the <span class="math">N\\times N</span> matrices <span class="math">A,B</span> and <span class="math">C</span> in an instance of <span class="math">R_{\\mathrm{R1CS}}</span>. Write $k_{\\mathrm{\\scriptscriptstyle SP}}(N)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for the soundness error of the twisted scalar-product protocol, </span>c_{\\mathrm{\\scriptscriptstyle SP}}(N)<span class="math"> for its communication complexity and </span>r_{\\mathrm{\\scriptscriptstyle SP}}(N)<span class="math"> for its round complexity. Write </span>k_{\\mathrm{\\scriptscriptstyle LC}}(N,M)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span>c_{\\mathrm{\\scriptscriptstyle LC}}(N,M)<span class="math">, and </span>r_{\\mathrm{\\scriptscriptstyle LC}}(N,M)$ for the corresponding parameters of the lincheck protocol.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-122" class="text-base font-medium mt-4">Theorem 9.1 (main).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be a finite field. Let <span class="math">t\\in\\mathbb{N}</span> be a constant. Let <span class="math">\\mathcal{C}\\colon\\mathbb{F}^{N^{1/t}}\\to\\mathbb{F}^{O(N^{1/t})}</span> be a code with constant rate and distance, which is linear-time encodable, with description size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. There is a public-coin holographic IOP (with point queries) for </span>R_{\\mathrm{R1CS}}<span class="math"> instances with size </span>M=O(N)<span class="math"> and fields </span>\\mathbb{F}<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\Omega(N)$ that has the following efficiency:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>answer alphabet <span class="math">\\mathbb{F}</span>;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error is $O((M+k_{\\mathrm{\\scriptscriptstyle SP}}(N)+k_{\\mathrm{\\scriptscriptstyle LC}}(N,M))/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity is <span class="math">O(r_{\\mathrm{\\scriptscriptstyle SP}}(N)+r_{\\mathrm{\\scriptscriptstyle LC}}(N,M))</span>;</li>

      <li>proof length is <span class="math">O(M+N)</span>;</li>

      <li>query complexity is <span class="math">O(c_{\\mathrm{\\scriptscriptstyle SP}}(N)+c_{\\mathrm{\\scriptscriptstyle LC}}(N,M))</span>;</li>

      <li>the indexer uses <span class="math">O(M)</span> field operations</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- the prover uses $O(M+N)+\\mathsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,N^{1/t})$ field operations;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, the protocol is semi-honest-verifier zero knowledge. Let <span class="math">\\beta\\colon\\mathbb{N}\\to(0,1)</span> be a function bounded away from <span class="math">1</span>. If the code <span class="math">\\mathcal{C}</span> is also <span class="math">\\beta N^{1/t}</span>-query zero knowledge, the protocol is zero knowledge for all verifiers making at most <span class="math">\\beta N^{1/t}</span> queries.</p>

    <h6 id="sec-123" class="text-base font-medium mt-4">Remark 9.2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If we just want a semi-honest-verifier zero-knowledge protocol, we can use explicit codes <span class="math">\\mathcal{C}</span>. In this case $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(1)<span class="math">. Thus the second component of verifier time is </span>\\mathsf{poly}\\left(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log N\\right)\\in\\mathsf{polylog}(M)<span class="math">. So the total verifier time is polylogarithmic in </span>M<span class="math">. We can pick </span>t<span class="math"> that exceeds the polynomial degree in the expression for prover time, so that the total prover time is linear in </span>M$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If we want the stronger notion of bounded-query zero-knowledge, we can use the zero-knowledge codes given by Theorem 7.3. In this case $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(N^{1/t})<span class="math">. Then we can pick </span>t<span class="math"> that exceeds the polynomial degrees in the expressions for prover time and verifier time, so that </span>\\mathsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,N^{1/t})<span class="math"> and </span>\\mathsf{poly}\\left(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log N\\right)<span class="math"> are both in </span>o(M)<span class="math">. So the prover time is linear in </span>M<span class="math"> and the verifier time is sublinear in </span>M$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-124" class="text-base font-medium mt-4">Remark 9.3.</h6>

    <p class="text-gray-300">When <span class="math">M=O(N)</span>, the best known efficiency parameters for the scalar-product and lincheck protocols satisfy <span class="math">c_{\\mathrm{\\scriptscriptstyle SP}}(N),r_{\\mathrm{\\scriptscriptstyle SP}}(N),k_{\\mathrm{\\scriptscriptstyle SP}}=O(\\log N)</span>, <span class="math">c_{\\mathrm{\\scriptscriptstyle LC}}(N,M),r_{\\mathrm{\\scriptscriptstyle LC}}(N,M)=O(\\log M)</span>, <span class="math">k_{\\mathrm{\\scriptscriptstyle LC}}(N,M)=O(M)</span>. These arise from Theorem 4.8, and Lemma 4.11 instantiated with the bias-biased generator of Definition 4.6.</p>

    <p class="text-gray-300">We obtain this <span class="math">\\mathsf{IOP}</span> for <span class="math">R_{\\mathrm{R1CS}}</span> in three steps. First, we construct a robust <span class="math">\\mathsf{IOPP}</span> for the relation <span class="math">R_{\\mathrm{\\scriptscriptstyle cons}}</span>. Then we use proof composition to improve the round complexity and query complexity of the <span class="math">\\mathsf{IOPP}</span>. Finally, we apply the compiler in Lemma 8.2 to this efficient <span class="math">\\mathsf{IOPP}</span> for <span class="math">R_{\\mathrm{\\scriptscriptstyle cons}}</span> and to the tensor-query <span class="math">\\mathsf{IOP}</span> for <span class="math">R_{\\mathrm{R1CS}}</span> in Theorem 4.13 to obtain the protocol in the theorem statement. In the rest of the section, we explain each of the steps.</p>

    <p class="text-gray-300">9.1 Step 1: robustification</p>

    <p class="text-gray-300">We start with the following <span class="math">\\mathsf{IOPP}</span> for the relation <span class="math">R_{\\text{cons}}</span>.</p>

    <h6 id="sec-125" class="text-base font-medium mt-4">Definition 9.4.</h6>

    <p class="text-gray-300">The indexed relation <span class="math">R^{\\prime}_{\\text{cons}}</span> is the set of tuples</p>

    <p class="text-gray-300"><span class="math">(\\mathfrak{i},\\mathbb{x},\\mathbb{w})=\\left(\\bot,(\\mathbb{F},\\mathcal{C},\\ell,\\mathfrak{q},t,\\{q^{(s)}\\}_{s},\\{v_{s}\\}_{s}),c\\right)</span></p>

    <p class="text-gray-300">such that <span class="math">c=\\operatorname{Enc}_{\\mathcal{C}^{\\otimes(t-1)}}(f)\\in\\mathbb{F}^{\\ell k\\cdot n^{t-1}}</span> for some <span class="math">f\\in\\mathbb{F}^{\\ell\\cdot k^{t}}</span>, for each <span class="math">s\\in[\\mathfrak{q}]</span>, <span class="math">q^{(s)}=(q_{0}^{(s)},\\ldots,q_{t}^{(s)})\\in\\mathbb{F}^{\\ell}\\times\\left(\\mathbb{F}^{k}\\right)^{t}</span>, and for all <span class="math">s\\in[\\mathfrak{q}]</span>, <span class="math">\\langle q^{(s)},f\\rangle=v^{(s)}</span>.</p>

    <h6 id="sec-126" class="text-base font-medium mt-4">Lemma 9.5.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">b\\in\\Theta(k)</span>. Let <span class="math">\\mathcal{C}\\colon\\mathbb{F}^{k}\\to\\mathbb{F}^{n}</span> be a linear code with constant rate <span class="math">\\rho=k/n</span>, constant relative distance <span class="math">\\delta=d/n</span>, linear encoding arithmetic complexity <span class="math">\\theta(k)\\cdot k</span>, and description size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. There exists an non-adaptive interactive oracle proof of proximity </span>\\mathsf{IOPP}=(\\mathbf{P},(\\mathbf{V}_{\\mathrm{q}},\\mathbf{V}_{\\mathrm{d}}))<span class="math"> with point queries for the relation </span>R^{\\prime}_{\\text{cons}}(\\mathbb{F},\\mathcal{C},\\ell,\\mathfrak{q},t,\\{q^{(s)}\\}_{s},\\{v_{s}\\}_{s})$ with the following parameters:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>answer alphabet <span class="math">\\mathbb{F}^{\\ell k}</span> for the witness, and <span class="math">\\mathbb{F}^{k}</span> for the proof;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error $\\epsilon(\\Delta)=\\ell kn^{t-1}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1-\\min\\{\\delta^{t-1}/4,\\Delta/2^{t-1}\\}$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity <span class="math">O(t)</span>;</li>

      <li>proof length <span class="math">O(\\mathfrak{q}\\cdot n^{t-2})</span> symbols in <span class="math">\\mathbb{F}^{k}</span>;</li>

      <li>query complexity <span class="math">1</span> to the witness and <span class="math">O(t\\cdot\\mathfrak{q})</span> to the proof;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- prover time $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathfrak{q}\\cdot t\\ell k^{t})$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>verifier randomness complexity <span class="math">O(t\\cdot\\mathfrak{q})</span> elements in <span class="math">\\mathbb{F}</span>;</li>

      <li><span class="math">\\mathbf{V}_{\\mathrm{d}}</span>’s decision state <span class="math">\\sigma=(\\mathbb{x},r)</span> where <span class="math">r</span> is the verifier randomness;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathbf{V}_{\\mathrm{d}}</span> time $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathfrak{q}k\\cdot(\\ell+t))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, the verifier’s witness queries are compatible with a query checker <span class="math">\\mathbf{Q}</span> which allows revealing at most <span class="math">1</span> column (in <span class="math">\\mathbb{F}^{\\ell k}</span>) from the interleaved codeword in <span class="math">\\left(\\mathcal{C}^{\\otimes(t-1)}\\right)^{\\ell k}</span>.</p>

    <h6 id="sec-127" class="text-base font-medium mt-4">Proof sketch.</h6>

    <p class="text-gray-300">This <span class="math">\\mathsf{IOPP}</span> is obtained by modifying the ‘consistency phase’ of <em>[x1, Construction 9.4]</em> which uses a proximity test <em>[x1, Lemma 10.1]</em> as a subroutine.</p>

    <p class="text-gray-300">To obtain an IOPP for <span class="math">R_{\\text{cons}}</span>, we run the consistency phase of <em>[x1, Construction 9.4]</em>, but parse the message <span class="math">f_{0}^{(0)}</span> as a <span class="math">t</span>-dimensional array of size <span class="math">\\ell k\\cdot k^{t-1}</span> rather than a <span class="math">(t+1)</span>-dimensional array of size <span class="math">\\ell\\cdot k^{t}</span>. The first components <span class="math">q_{0}^{(s)}\\in\\mathbb{F}^{\\ell}</span> and <span class="math">q_{1}^{(s)}\\in\\mathbb{F}^{k}</span> of each tensor query are then grouped together as a single component <span class="math">q_{0}^{(s)}\\otimes q_{1}^{(s)}\\in\\mathbb{F}^{\\ell k}</span>, and the first ‘folding’ step applies <span class="math">q_{0}^{(s)}\\otimes q_{1}^{(s)}</span> of <span class="math">f_{0}^{(0)}</span>.</p>

    <p class="text-gray-300">We also derandomize the proximity test <em>[x1, Lemma 10.1]</em> to reduce the verifier randomness complexity from <span class="math">O((\\ell+t)\\cdot k\\cdot\\mathfrak{q})</span> field elements to <span class="math">O(t\\cdot\\mathfrak{q})</span> field elements. Although this change increases the soundness error, it will help us to improve the final <span class="math">\\mathsf{IOP}</span> verifier’s running time after applying proof composition.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The proximity test checks whether, for a set of messages <span class="math">\\{\\tilde{c}_{0},\\ldots,\\tilde{c}_{t}\\}</span>, we have that <span class="math">\\tilde{c}_{i}</span> is close to an interleaved <span class="math">\\mathcal{C}^{\\otimes(t-i)}</span>-codeword. This is achieved by recursively “folding” the higher dimensional messages to reduce their dimension, by taking a random linear combination of their coefficients at each stage. Executing the protocol with the array sizes described above would require the verifier to sample uniformly random vectors <span class="math">\\zeta_{1}\\in\\mathbb{F}^{\\ell k}</span> and <span class="math">\\zeta_{2},\\ldots,\\zeta_{t}\\in\\mathbb{F}^{k}</span>. However, in this case, the verifier’s randomness complexity would be <span class="math">O(k)</span>, which prevents polylogarithmic verification after proof composition. However, we can replace each <span class="math">\\zeta_{i}</span> with a random vector of the form $(\\alpha_{i}^{1},\\alpha_{i}^{2},\\alpha_{i}^{3},\\ldots,\\alpha_{i}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\zeta_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> for a uniformly random </span>\\alpha_{i}\\leftarrow\\mathbb{F}$, and replace</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">[BCG20, Lemma 10.10] with [BKS18, Theorem 4.1] in the soundness proof of the proximity test. This modification increases the soundness error, but we can tolerate the increase for sufficiently large fields. <span class="math">\\square</span></p>

    <h6 id="sec-128" class="text-base font-medium mt-4">Remark 9.6.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As it is, [BKS18, Theorem 4.1] states that if <span class="math">\\zeta_{i}</span> is a random vector of the form <span class="math">(\\alpha_{i}^{1},\\alpha_{i}^{2})</span>, and if any component of a message <span class="math">\\tilde{c}_{i}\\in(\\mathbb{F}^{n^{t-i}})^{2}</span> is far from the codespace <span class="math">\\mathcal{C}^{\\otimes(t-i)}</span>, then the random folding of <span class="math">\\tilde{c}_{i}</span> by <span class="math">\\zeta_{i}</span> is also far from <span class="math">\\mathcal{C}^{\\otimes(t-i)}</span> with probability at least $1-\\frac{n^{t-i}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. The the same proof can be used to show that when the random vector is </span>\\zeta_{i}=(\\alpha_{i}^{1},\\alpha_{i}^{2},\\alpha_{i}^{3},\\ldots,\\alpha_{i}^{k})<span class="math"> and the message </span>\\tilde{c}_{i}\\in(\\mathbb{F}^{n^{t-i}})^{k}<span class="math">, the same probability is at least </span>1-\\frac{(k-1)n^{t-i}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. We also note that the analysis in [BKS18] could potentially be adapted to show that if random Reed-Muller vectors are used to fold the messages, the first term in the soundness error could be improved from </span>\\ell kn^{t-1}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to </span>\\mathsf{polylog}(k,n)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, with verifier randomness complexity changing to </span>O(t\\cdot\\mathsf{q}\\log\\ell k)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the construction above, we use a <span class="math">b</span>-query zero-knowledge code <span class="math">\\mathcal{C}</span> with for <span class="math">b\\leq k</span>.</p>

    <p class="text-gray-300">Next, we reduce the verifier query complexity through proof composition. We first robustify the current <span class="math">\\mathsf{IOPP}</span> for <span class="math">R^{\\prime}_{\\mathsf{cons}}</span> to obtain a robust <span class="math">\\mathsf{IOPP}</span> for <span class="math">R_{\\mathsf{cons}}</span>.</p>

    <h6 id="sec-129" class="text-base font-medium mt-4">Corollary 9.7.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{C}\\colon\\mathbb{F}^{k}\\to\\mathbb{F}^{O(k)}</span> be a randomized linear code with constant rate and relative distance, linear-time encoding, membership-deciding, and decoding time, and description size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The relation </span>R_{\\mathsf{cons}}<span class="math"> has a non-adaptive point-query </span>\\mathsf{IOPP}<span class="math"> </span>(\\mathbf{P}_{\\mathsf{r}},(\\mathbf{V}_{\\mathsf{q}_{\\mathsf{r}}},\\mathbf{V}_{\\mathsf{d}_{\\mathsf{r}}}))$ with:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>answer alphabet <span class="math">\\mathbb{F}</span>;</li>

      <li>round complexity <span class="math">O(t)</span>;</li>

      <li>proof length <span class="math">O(\\mathsf{q}\\cdot\\ell k^{t})</span>;</li>

      <li>query complexity <span class="math">O(\\mathsf{q}k\\cdot(\\ell+t))</span>;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error $O(k^{t}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)+O(1)<span class="math"> with robustness </span>\\Theta(1/(\\ell+t))$;</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- verifier time $O(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathcal{C}</td>

            <td class="px-3 py-2 border-b border-gray-700">+\\mathsf{q}k\\cdot(\\ell+t))$;</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>verifier randomness complexity <span class="math">O(t\\mathsf{q})</span>;</li>

      <li><span class="math">\\mathbf{V}_{\\mathsf{d}_{\\mathsf{r}}}</span>’s decision state <span class="math">\\sigma=(\\Xi,r)</span> where <span class="math">r</span> is the verifier randomness;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathbf{V}_{\\mathsf{d}_{\\mathsf{r}}}</span> time $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{q}k\\cdot(\\ell+t))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, the verifier’s witness queries are compatible with a query checker <span class="math">\\mathbf{Q}_{\\mathsf{r}}</span> which allows revealing at most <span class="math">1</span> column (in <span class="math">\\mathbb{F}^{O(\\ell k)}</span>) from the interleaved codeword in <span class="math">\\left(\\mathcal{C}^{\\otimes(t-1)}\\right)^{O(\\ell k)}</span>.</p>

    <h6 id="sec-130" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Apply Lemma A.1 to the point-query <span class="math">\\mathsf{IOPP}</span> for <span class="math">R^{\\prime}_{\\mathsf{cons}}</span> in Lemma 9.5. In Lemma 9.5, the witness has alphabet <span class="math">\\mathbb{F}^{\\ell k}</span>, and will be encoded in <span class="math">\\ell</span> parts by applying <span class="math">\\mathcal{C}</span> to blocks of length <span class="math">k</span>. This converts a witness for the relation <span class="math">R^{\\prime}_{\\mathsf{cons}}</span> into a witness for the relation <span class="math">R_{\\mathsf{cons}}</span>. Thus the new witness can be viewed as <span class="math">\\ell</span> codewords in <span class="math">\\mathcal{C}^{\\otimes t}</span>, or equivalently <span class="math">O(\\ell k)</span> codewords in <span class="math">\\mathcal{C}^{\\otimes(t-1)}</span>. Proof elements have alphabet <span class="math">\\mathbb{F}^{k}</span> and will be encoded using <span class="math">\\mathcal{C}</span>. ∎</p>

    <h3 id="sec-131" class="text-xl font-semibold mt-8">9.2 Step 2: composition</h3>

    <h6 id="sec-132" class="text-base font-medium mt-4">Lemma 9.8 (<em>[x16]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix any <span class="math">T(n)=\\Omega(n)</span>, <span class="math">\\delta=\\delta(n)&gt;0</span>, and <span class="math">\\epsilon=\\epsilon(n)&gt;0</span>. Every relation <span class="math">R</span> in <span class="math">\\mathsf{NTIME}(T)</span> has a PCPP for <span class="math">R</span> with (1) answer alphabet <span class="math">\\{0,1\\}</span>; (2) proof length $T(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\cdot\\mathsf{polylog}(T(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">; (3) query complexity </span>O(\\log(1/\\epsilon)\\cdot\\log(1/\\delta)/\\delta)<span class="math">; (4) soundness error </span>\\epsilon<span class="math"> with proximity parameter </span>\\delta<span class="math">; (5) prover time </span>\\mathsf{poly}(T(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">; (6) verifier time </span>\\mathsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log T(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">######</p>

    <h6 id="sec-133" class="text-base font-medium mt-4">Corollary 9.9.</h6>

    <p class="text-gray-300">Let <span class="math">\\epsilon\\in(0,1)</span> be a constant. For instances of <span class="math">R_{\\textsc{cons}}</span> in which each query <span class="math">q^{(s)}</span> is described using a short seed of length <span class="math">O(t\\log k)</span>, there is a point-query IOPP <span class="math">(\\mathbf{P},\\mathbf{V})</span> with:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>answer alphabet <span class="math">\\mathbb{F}</span>;</li>

      <li>round complexity <span class="math">O(t)</span>;</li>

      <li>proof length <span class="math">O(\\mathfrak{q}\\cdot\\ell k^{t})</span>;</li>

      <li>query complexity <span class="math">O_{\\epsilon}(t\\log t)</span>;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error $O(k^{t}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)+O(1)+\\epsilon<span class="math"> with proximity parameter </span>\\Theta(1/t)$;</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- verifier time $\\mathsf{poly}(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathcal{C}</td>

            <td class="px-3 py-2 border-b border-gray-700">+O(\\mathfrak{q}\\cdot t\\log k),\\log(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathcal{C}</td>

            <td class="px-3 py-2 border-b border-gray-700">+\\mathfrak{q}k\\cdot(\\ell+t)))$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, the verifier’s witness queries are still compatible with a query checker <span class="math">\\mathbf{Q}_{\\text{r}}</span> which allows revealing at most <span class="math">1</span> column (in <span class="math">\\mathbb{F}^{O(\\ell k)}</span>) from the interleaved codeword in <span class="math">\\left(\\mathcal{C}^{\\otimes(t-1)}\\right)^{O(\\ell k)}</span>.</p>

    <h6 id="sec-134" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Apply Lemma B.1 to the robust outer IOP provided by Corollary 9.7 and the inner IOP of proximity provided by Lemma 9.8.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The inner relation <span class="math">R(\\mathbf{V}_{\\mathrm{dr}})</span> has instance <span class="math">(\\mathtt{x},r):=(\\mathbb{F},\\mathcal{C},\\ell,\\mathfrak{q},t,\\{q^{(s)}\\}_{s},\\{v_{s}\\}_{s},r)</span>, where <span class="math">\\mathcal{C}</span> has description size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span>r<span class="math"> has size </span>O(\\mathfrak{q}\\cdot t)<span class="math">, and by assumption, the query set has a description of size </span>O(\\mathfrak{q}\\cdot t\\log k)<span class="math">. This means that the instance size is </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+O(\\mathfrak{q}\\cdot t\\log k)<span class="math">. The witness size of </span>R(\\mathbf{V}_{\\mathrm{dr}})<span class="math"> is equal to the query complexity of the robust outer IOP. Thus it has size </span>O(\\mathfrak{q}k\\cdot(\\ell+t))<span class="math">. The verifier’s decision time is </span>T(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathtt{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathfrak{q}k\\cdot(\\ell+t))<span class="math">. Substituting these values into Lemma 9.8, the final </span>\\mathsf{IOPP}$’s proof length, prover time and verifier time are as written in the statement.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The round complexity <span class="math">O(t)</span> is inherited from the robust outer <span class="math">\\mathsf{IOPP}</span>, while the query complexity <span class="math">O_{\\epsilon}(t\\log t)</span> is obtained from the applying Lemma 9.8 with the proximity parameter <span class="math">\\delta=\\Theta(1/t)</span>. ∎</p>

    <h3 id="sec-135" class="text-xl font-semibold mt-8">9.3 Step 3: tensor queries to point queries</h3>

    <p class="text-gray-300">Finally, we apply the transformation given in Lemma 8.2 to the tensor-query <span class="math">R_{\\mathrm{R1CS}}</span> IOP of Theorem 4.13, the <span class="math">R_{\\textsc{cons}}</span> IOPP in Corollary 9.9, and two different zero knowledge codes to produce two point-query <span class="math">\\mathsf{IOP}</span>s for <span class="math">R_{\\mathrm{R1CS}}</span> and complete the proof of Theorem 9.1. Set <span class="math">N=k_{m}^{t}</span> and <span class="math">M=\\ell\\cdot k_{m}^{t}</span> for some <span class="math">k_{m},t\\in\\mathbb{N}</span>. Theorem 4.13 gives a <span class="math">(\\mathbb{F},k_{m},t)</span>-tensor IOP for <span class="math">R_{\\mathrm{R1CS}}</span>, which has query complexity <span class="math">\\mathfrak{q}=O(1)</span>, and for which each query can be described by a short seed of size <span class="math">O(t\\log k_{m})</span>.</p>

    <p class="text-gray-300">By Definition 3.22, there exists a randomized linear code <span class="math">\\mathcal{C}:\\mathbb{F}^{k_{m}}\\times\\mathbb{F}^{O(k_{m})}\\to\\mathbb{F}^{O(k_{m})}</span> which has constant message rate, randomness rate, and relative distance, and is linear-time encodable and <span class="math">1</span>-query zero-knowledge. Therefore the tensor code <span class="math">\\mathcal{C}^{\\otimes(t-1)}</span> is also <span class="math">1</span>-query zero-knowledge. If we encode the interleaved code <span class="math">\\left(\\mathcal{C}^{\\otimes(t-1)}\\right)^{\\ell k}</span> as in the proof of Corollary 9.7, the resulting interleaved code is <span class="math">\\mathbf{Q}_{\\text{r}}</span>-query zero knowledge. Moreover, by Corollary 9.9, the <span class="math">R_{\\textsc{cons}}</span> IOPP verifier <span class="math">\\mathbf{V}^{\\prime}</span> for code <span class="math">\\mathcal{C}</span> is compatible with <span class="math">\\mathbf{Q}_{\\text{r}}</span>. As a result, applying Lemma 8.2 to the tensor-query <span class="math">R_{\\mathrm{R1CS}}</span> IOP, the <span class="math">R_{\\textsc{cons}}</span> IOPP, and <span class="math">\\mathcal{C}</span> gives a point-query <span class="math">R_{\\mathrm{R1CS}}</span> IOP with the stated parameters. Moreover, the IOP is zero knowledge against semi-honest verifier zero-knowledge.</p>

    <p class="text-gray-300">By Theorem 7.3, there also exists a randomized linear code <span class="math">\\mathcal{C}^{\\prime}:\\mathbb{F}^{k_{m}}\\times\\mathbb{F}^{O(k_{m})}\\to\\mathbb{F}^{O(k_{m})}</span> which has constant message rate, randomness rate, and relative distance, is linear-time encodable, and is <span class="math">\\beta k_{m}</span>-query zero-knowledge. Thus the interleaved code <span class="math">\\left(\\mathcal{C}^{\\prime\\otimes(t-1)}\\right)^{O(\\ell k_{m})}</span> is <span class="math">\\beta k_{m}</span>-query zero knowledge. Apply Lemma 8.2 to the tensor-query <span class="math">R_{\\mathrm{R1CS}}</span> IOP, the <span class="math">R_{\\textsc{cons}}</span> IOPP, and the code <span class="math">\\mathcal{C}^{\\prime}</span>. The resulting point-query IOP has the stated parameters, and it is zero knowledge against all verifiers making at most <span class="math">\\beta k_{m}</span> queries to the <span class="math">\\mathsf{IOP}</span> orac</p>

    <p class="text-gray-300">A Robustification</p>

    <p class="text-gray-300">We state a generic lemma about robustification for IOPs (Lemma A.1); it extends corresponding generic robustifications for PCPs and IPs. We include the construction for convenience (Construction A.3) and sketch its proof. We also prove properties about how zero knowledge is affected by proof composition (Lemma A.4).</p>

    <h6 id="sec-136" class="text-base font-medium mt-4">Lemma A.1.</h6>

    <p class="text-gray-300">Suppose that we are given the following two ingredients.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>IOP. A holographic IOP <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> for <span class="math">R</span> with queries in <span class="math">\\mathcal{Q}_{\\mathrm{point}}</span> with the following parameters: round complexity rc; answer alphabet <span class="math">\\Sigma</span>; oracle length <span class="math">\\mathsf{l}=\\mathsf{li}+\\mathsf{lp}</span>; query complexity q; soundness error <span class="math">\\epsilon</span>; indexer time ti; prover time tp; verifier time tv; verifier randomness r.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Code. A randomized code <span class="math">\\mathcal{C}\\colon\\Sigma\\to\\Lambda^{n}</span> with public parameters <span class="math">(\\mathrm{Enc},G,H,G^{+})</span>, relative distance <span class="math">\\delta</span> (over alphabet <span class="math">\\Lambda</span>), encoding time <span class="math">\\theta</span>, membership-deciding time <span class="math">\\psi</span>, and error-free decoding time <span class="math">\\eta</span>. (In particular, the rate of <span class="math">\\mathcal{C}</span> is $\\rho:=\\frac{\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{n\\cdot\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Lambda</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then the protocol in Construction A.3 (see below) is a holographic IOP <span class="math">(\\mathbf{I}_{\\mathrm{r}},\\mathbf{P}_{\\mathrm{r}},\\mathbf{V}_{\\mathrm{r}})</span> with queries in <span class="math">\\mathcal{Q}_{\\mathrm{point}}</span> for the indexed relation <span class="math">R</span> with the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity rc;</li>

      <li>answer alphabet <span class="math">\\Lambda</span>;</li>

      <li>index oracle length <span class="math">n\\cdot\\mathsf{li}</span> and proof oracle length <span class="math">n\\cdot\\mathsf{lp}</span>;</li>

      <li>query complexity <span class="math">n\\cdot\\mathsf{q}</span>;</li>

      <li>soundness error <span class="math">\\epsilon</span> with robustness <span class="math">\\frac{\\delta}{2\\mathsf{q}}</span>;</li>

      <li>indexer time <span class="math">\\mathsf{ti}+\\mathsf{li}\\cdot\\theta</span>;</li>

      <li>prover time <span class="math">\\mathsf{tp}+\\mathsf{lp}\\cdot\\theta</span>;</li>

      <li>verifier time <span class="math">\\mathsf{tv}+\\mathsf{q}\\cdot(\\psi+\\eta)</span>;</li>

      <li>verifier randomness r.</li>

    </ul>

    <p class="text-gray-300">If <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> is public coin (resp., has non-adaptive queries) then <span class="math">(\\mathbf{I}_{\\mathrm{r}},\\mathbf{P}_{\\mathrm{r}},\\mathbf{V}_{\\mathrm{r}})</span> is public coin (resp., has non-adaptive queries).</p>

    <h6 id="sec-137" class="text-base font-medium mt-4">Remark A.2 (multiple alphabets).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma A.1 and Lemma A.4 extend to holographic IOPs with multiple alphabets <span class="math">\\Lambda_{1},\\ldots,\\Lambda_{s}</span> provided that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Lambda_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\Theta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Lambda_{1})<span class="math"> for each </span>i\\in[2,\\ldots,s]<span class="math">, and error-correcting codes </span>\\mathcal{C}_{1},\\ldots,\\mathcal{C}_{s}<span class="math"> with respect to these alphabets. The parameters of </span>(\\mathbf{I}_{\\mathrm{r}},\\mathbf{P}_{\\mathrm{r}},\\mathbf{V}_{\\mathrm{r}})$ are then modified to use the minimum of the relative distances and the maximum of the block lengths, relative distances, encoding, checking, and error-free decoding times.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-138" class="text-base font-medium mt-4">Construction A.3.</h6>

    <p class="text-gray-300">The new indexer <span class="math">\\mathbf{I}_{\\mathrm{r}}</span> runs the old indexer <span class="math">\\mathbf{I}</span> on the given index to obtain an index oracle <span class="math">\\Pi_{0}=(a_{0,1},\\ldots,a_{0,\\mathsf{li}})\\in\\Sigma^{\\mathsf{li}}</span>, encodes each symbol <span class="math">a_{0,j}\\in\\Sigma</span> using the given code to obtain a string of symbols <span class="math">\\mathcal{C}(a_{0,j})\\in\\Lambda^{n}</span>, and then outputs the new index oracle <span class="math">\\mathcal{C}(\\Pi_{0}):=(\\mathcal{C}(a_{0,1}),\\ldots,\\mathcal{C}(a_{0,\\mathsf{li}}))\\in\\Lambda^{n\\cdot\\mathsf{li}}</span>.</p>

    <p class="text-gray-300">The new prover <span class="math">\\mathbf{P}_{\\mathrm{r}}</span> and new verifier <span class="math">\\mathbf{V}_{\\mathrm{r}}</span> respectively simulate the old prover <span class="math">\\mathbf{P}</span> and old verifier <span class="math">\\mathbf{V}</span>, with modifications depending on the code <span class="math">\\mathcal{C}</span> as described below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The new prover encodes each symbol in each proof. For each round <span class="math">i\\in[\\mathsf{rc}]</span>, when the old prover <span class="math">\\mathbf{P}</span> outputs a proof oracle <span class="math">\\Pi_{i}=(a_{i,1},\\ldots,a_{i,\\mathsf{lp}_{i}})\\in\\Sigma^{\\mathsf{lp}_{i}}</span>, <span class="math">\\mathbf{P}_{\\mathrm{r}}</span> encodes each symbol <span class="math">a_{i,j}\\in\\Sigma</span> using the given code to obtain a string of symbols <span class="math">\\mathcal{C}(a_{i,j})\\in\\Lambda^{n}</span> and sends the encoded proof <span class="math">\\mathcal{C}(\\Pi_{i}):=(\\mathcal{C}(a_{i,1}),\\ldots,\\mathcal{C}(a_{i,\\mathsf{lp}_{i}}))\\in\\Lambda^{n\\cdot\\mathsf{lp}_{i}}</span>.</li>

      <li>The new verifier checks membership in the code. Whenever the old verifier <span class="math">\\mathbf{V}</span> wishes to read the <span class="math">j</span>-th symbol of the <span class="math">i</span>-th oracle <span class="math">\\Pi_{i}</span>, the new verifier <span class="math">\\mathbf{V}_{\\mathrm{r}}</span> does the following:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Use <span class="math">n</span> queries queries to read <span class="math">\\tilde{c}_{i,j}\\in\\Lambda^{n}</span>, the <span class="math">j</span>-th string in the <span class="math">i</span>-th oracle.</li>

      <li>If <span class="math">i=0</span> (V’s query was to the index oracle <span class="math">\\Pi_{0}</span>) then decode <span class="math">\\tilde{c}_{i,j}</span> to the symbol <span class="math">a_{i,j}\\in\\Sigma</span>. (Note that we already know that <span class="math">\\tilde{c}_{i,j}</span> is in the code <span class="math">\\mathcal{C}</span> because it is an output of the new indexer <span class="math">\\mathbf{I}_{\\mathrm{r}}</span>.)</li>

      <li>If <span class="math">i\\in[\\mathsf{rc}]</span> (V’s query was to one of the proof oracles <span class="math">\\Pi_{1},\\ldots,\\Pi_{\\mathsf{rc}}</span>) check that <span class="math">\\tilde{c}_{i,j}</span> is in the code <span class="math">\\mathcal{C}</span> (e.g. using the parity-check matrix <span class="math">H</span> of <span class="math">\\mathcal{C}</span> or a more efficient algorithm if known) and, if so, decode <span class="math">\\tilde{c}_{i,j}</span> to the symbol <span class="math">a_{i,j}\\in\\Sigma</span> (e.g. using the matrix <span class="math">G^{+}</span> or otherwise).</li>

      <li>Give <span class="math">a_{i,j}</span> as the query answer to the old verifier V.</li>

    </ul>

    <p class="text-gray-300">In sum, the new verifier <span class="math">\\mathbf{V}_{\\mathrm{r}}</span> accepts if and only if all read strings are in the code <span class="math">\\mathcal{C}</span> and the old verifier V accepts the corresponding decodings.</p>

    <h6 id="sec-139" class="text-base font-medium mt-4">Proof of Lemma A.1.</h6>

    <p class="text-gray-300">Completeness and the efficiency parameters of <span class="math">(\\mathbf{I}_{\\mathrm{r}},\\mathbf{P}_{\\mathrm{r}},\\mathbf{V}_{\\mathrm{r}})</span> claimed in the lemma (round complexity, answer alphabet, proof length, query complexity, prover time, and verifier time) directly follow from the construction. Below we prove robustness and preservation of zero knowledge.</p>

    <p class="text-gray-300">We show that <span class="math">(\\mathbf{I}_{\\mathrm{r}},\\mathbf{P}_{\\mathrm{r}},\\mathbf{V}_{\\mathrm{r}})</span> is <span class="math">(\\frac{\\delta}{2\\mathfrak{q}},\\epsilon)</span>-robust. Namely, we show that, for any cheating prover <span class="math">\\tilde{\\mathbf{P}}_{\\mathrm{r}}</span>, with probability at most <span class="math">\\epsilon</span>, the view of <span class="math">\\mathbf{V}_{\\mathrm{r}}</span> is <span class="math">\\frac{\\delta}{2\\mathfrak{q}}</span>-close to some accepting view.</p>

    <p class="text-gray-300">Fix an arbitrary malicious prover <span class="math">\\tilde{\\mathbf{P}}_{\\mathrm{r}}</span> and, for each round <span class="math">i\\in[\\mathsf{rc}]</span>, denote by <span class="math">\\tilde{c}_{i,j}\\in\\Lambda^{n}</span> the <span class="math">j</span>-th string in the <span class="math">i</span>-th proof string sent by <span class="math">\\tilde{\\mathbf{P}}_{\\mathrm{r}}</span>; note that each <span class="math">\\tilde{c}_{i,j}</span> is a random variable that depends on the transcript so far. Denote by <span class="math">\\mathbf{v}_{\\rho}</span> the view of the new verifier <span class="math">\\mathbf{V}_{\\mathrm{r}}</span>, when using randomness <span class="math">\\rho</span>, and interacting with the malicious prover <span class="math">\\tilde{\\mathbf{P}}_{\\mathrm{r}}</span>. Note that <span class="math">\\mathbf{v}_{\\rho}</span> consists of <span class="math">\\mathfrak{q}</span> strings in <span class="math">\\Lambda^{n}</span>. Let <span class="math">\\overline{c}_{i,j}</span> be any codeword in <span class="math">\\mathcal{C}</span> that is closest to <span class="math">\\tilde{c}_{i,j}</span> (which need not be in <span class="math">\\mathcal{C}</span>), and let <span class="math">\\overline{\\mathbf{v}}_{\\rho}</span> be the view of <span class="math">\\mathbf{V}_{\\mathrm{r}}</span> when each <span class="math">\\tilde{c}_{i,j}</span> is replaced with its “correction” <span class="math">\\overline{c}_{i,j}</span>.</p>

    <p class="text-gray-300">Let <span class="math">E</span> be the event that the “corrected” view <span class="math">\\overline{\\mathbf{v}}_{\\rho}</span> makes the new verifier <span class="math">\\mathbf{V}_{\\mathrm{r}}</span> accept. The event <span class="math">E</span> occurs with probability at most <span class="math">\\epsilon</span> because, if not, then the malicious prover <span class="math">\\tilde{\\mathbf{P}}</span> whose proofs are decodings of proofs output by <span class="math">\\tilde{\\mathbf{P}}_{\\mathrm{r}}</span> would make the old verifier V accept with probability greater than <span class="math">\\epsilon</span>, a contradiction to the soundness of V. We now argue that if <span class="math">E</span> does <em>not</em> occur (<span class="math">\\overline{\\mathbf{v}}_{\\rho}</span> is rejecting) then it holds that the view of <span class="math">\\mathbf{V}_{\\mathrm{r}}</span> is <span class="math">\\frac{\\delta}{2\\mathfrak{q}}</span>-far from accepting, which will conclude the proof.</p>

    <p class="text-gray-300">We distinguish between two cases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>There exists a string <span class="math">\\tilde{c}_{i,j}</span> in the view <span class="math">\\mathbf{v}_{\\rho}</span> that is <span class="math">\\delta/2</span>-far from <span class="math">\\mathcal{C}</span>. Then we directly conclude that <span class="math">\\mathbf{v}_{\\rho}</span> is <span class="math">\\frac{\\delta}{2\\mathfrak{q}}</span>-far from being accepted (regardless of <span class="math">E</span> in fact), because all accepting views consist of strings in the code. Note that the loss in distance in the denominator is because the string <span class="math">\\tilde{c}_{i,j}</span> contains <span class="math">n</span> symbols out of the <span class="math">n\\cdot\\mathfrak{q}</span> symbols in the view <span class="math">\\mathbf{v}_{\\rho}</span>, and in the worst case all other strings are in the code and contribute no distance.</li>

      <li>Every string <span class="math">\\tilde{c}_{i,j}</span> in the view <span class="math">\\mathbf{v}_{\\rho}</span> is <span class="math">\\delta/2</span>-close to <span class="math">\\mathcal{C}</span>. Fix any view <span class="math">\\mathbf{v}^{\\prime}</span> that is <span class="math">\\frac{\\delta}{2\\mathfrak{q}}</span>-close to <span class="math">\\mathbf{v}_{\\rho}</span>. We need to argue that <span class="math">\\mathbf{v}^{\\prime}</span> is a rejecting view. If <span class="math">\\mathbf{v}^{\\prime}</span> contains any string that is not in <span class="math">\\mathcal{C}</span> then, by construction of the new verifier <span class="math">\\mathbf{V}_{\\mathrm{r}}</span>, <span class="math">\\mathbf{v}^{\\prime}</span> is rejecting. So suppose that every string in <span class="math">\\mathbf{v}^{\\prime}</span> is in <span class="math">\\mathcal{C}</span>. In this case we argue that <span class="math">\\mathbf{v}^{\\prime}</span> equals the corrected view <span class="math">\\overline{\\mathbf{v}}_{\\rho}</span>, which is rejecting because we assumed that <span class="math">E</span> does not hold.</li>

    </ul>

    <p class="text-gray-300">Consider any string <span class="math">c^{\\prime}</span> in <span class="math">\\mathbf{v}^{\\prime}</span>. Let <span class="math">c</span> and <span class="math">\\overline{c}</span> be the corresponding strings in <span class="math">\\mathbf{v}_{\\rho}</span> and <span class="math">\\overline{\\mathbf{v}}_{\\rho}</span> respectively. Via the triangle inequality:</p>

    <p class="text-gray-300"><span class="math">0\\leq\\Delta_{\\Lambda}(c^{\\prime},\\overline{c})\\leq\\Delta_{\\Lambda}(c^{\\prime},c)+\\Delta_{\\Lambda}(c,\\overline{c})&lt;\\mathfrak{q}\\cdot\\frac{\\delta}{2\\mathfrak{q}}+\\frac{\\delta}{2}=\\delta\\enspace.</span></p>

    <p class="text-gray-300">Since <span class="math">\\mathcal{C}</span> has relative distance <span class="math">\\delta</span>, we conclude that <span class="math">c^{\\prime}=\\overline{c}</span>. And since the chosen string was arbitrary, we deduce that, as claimed, <span class="math">\\mathbf{v}^{\\prime}</span> equals the corrected view <span class="math">\\overline{\\mathbf{v}}_{\\rho}</span>.</p>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-140" class="text-2xl font-bold">Appendix</h2>

    <h6 id="sec-141" class="text-base font-medium mt-4">Lemma A.4.</h6>

    <p class="text-gray-300">The implications below hold for the robustification in Lemma A.1.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Semi-honest-verifier zero knowledge. If <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> is zero knowledge again semi-honest verifiers, then so is <span class="math">(\\mathbf{I}_{\\mathrm{r}},\\mathbf{P}_{\\mathrm{r}},\\mathbf{V}_{\\mathrm{r}})</span>.</li>

      <li>Bounded-query zero knowledge. If <span class="math">\\mathcal{C}</span> is <span class="math">b^{\\prime}</span>-query zero knowledge and <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> is <span class="math">b</span>-query zero knowledge, then <span class="math">(\\mathbf{I}_{\\mathrm{r}},\\mathbf{P}_{\\mathrm{r}},\\mathbf{V}_{\\mathrm{r}})</span> is <span class="math">(b^{\\prime}b+b^{\\prime}+b)</span>-query zero knowledge.</li>

    </ol>

    <h6 id="sec-142" class="text-base font-medium mt-4">Proof of Item 2 in Lemma A.4.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{S}</span> be the simulator for the old IOP <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> and let <span class="math">\\mathcal{S}</span> be the simulator for the code <span class="math">\\mathcal{C}</span>. Below we construct the new simulator <span class="math">\\mathbf{S}_{\\mathrm{r}}</span> for the new IOP <span class="math">(\\mathbf{I}_{\\mathrm{r}},\\mathbf{P}_{\\mathrm{r}},\\mathbf{V}_{\\mathrm{r}})</span>.</p>

    <p class="text-gray-300">Fix an index <span class="math">\\dot{\\mathfrak{s}}</span>, instance <span class="math">\\mathfrak{x}</span>, and witness <span class="math">\\mathfrak{w}</span> such that <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w})\\in R</span> and fix a <span class="math">(b^{\\prime}b+b^{\\prime}+b)</span>-query malicious verifier <span class="math">\\tilde{\\mathbf{V}}_{\\mathrm{r}}</span>. We need the random variables <span class="math">\\mathbf{S}_{\\mathrm{r}}^{\\tilde{\\mathbf{V}}_{\\mathrm{r}}}(\\dot{\\mathfrak{s}},\\mathfrak{x})</span> and <span class="math">\\mathrm{View}(\\mathbf{P}_{\\mathrm{r}}(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w}),\\tilde{\\mathbf{V}}_{\\mathrm{r}})</span> to be identically distributed.</p>

    <p class="text-gray-300">The new simulator <span class="math">\\mathbf{S}_{\\mathrm{r}}</span> receives as input an index <span class="math">\\dot{\\mathfrak{s}}</span> and instance <span class="math">\\mathfrak{x}</span>, and computes the encoded index <span class="math">\\mathbf{I}_{\\mathrm{r}}(\\dot{\\mathfrak{s}})</span> for later use. Then <span class="math">\\mathbf{S}</span> starts running <span class="math">\\tilde{\\mathbf{V}}_{\\mathrm{r}}</span> and simulates its view by taking different actions depending on <span class="math">\\tilde{\\mathbf{V}}_{\\mathrm{r}}</span>. Whenever <span class="math">\\tilde{\\mathbf{V}}_{\\mathrm{r}}</span> outputs a message for the new prover <span class="math">\\mathbf{P}_{\\mathrm{r}}</span>, the new simulator <span class="math">\\mathbf{S}_{\\mathrm{r}}</span> forwards this message to the old simulator <span class="math">\\mathbf{S}</span> (as if it were a message for the old prover <span class="math">\\mathbf{P}</span>). Whenever <span class="math">\\tilde{\\mathbf{V}}_{\\mathrm{r}}</span> makes a query to the index oracle <span class="math">\\mathbf{I}_{\\mathrm{r}}(\\dot{\\mathfrak{s}})</span>, the new simulator <span class="math">\\mathbf{S}_{\\mathrm{r}}</span> directly answers the query (as it knows the index and has computed the encoded index so that it knows the answer to all such queries). Whenever <span class="math">\\tilde{\\mathbf{V}}_{\\mathrm{r}}</span> makes a query to a proof oracle, <span class="math">\\mathbf{S}_{\\mathrm{r}}</span> proceeds as follows. Suppose that <span class="math">\\tilde{\\mathbf{V}}_{\\mathrm{r}}</span>’s query is to the <span class="math">j</span>-th string in the <span class="math">i</span>-th proof oracle (for <span class="math">i\\in[\\mathsf{rc}]</span>).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{S}_{\\mathrm{r}}</span> answers the first <span class="math">b^{\\prime}</span> distinct queries to this string by using an (independent) execution of the code simulator <span class="math">\\mathcal{S}</span> for this string. Any subsequent queries (beyond the first <span class="math">b^{\\prime}</span>) exceed the ZK bound of the code <span class="math">\\mathcal{C}</span>, which means that we cannot rely on <span class="math">\\mathcal{S}</span> to simulate answers to them. This brings us to the next option.</li>

      <li><span class="math">\\mathbf{S}_{\\mathrm{r}}</span> answers subsequent queries by relying on the old simulator <span class="math">\\mathbf{S}</span>. Specifically, <span class="math">\\mathbf{S}_{\\mathrm{r}}</span> asks <span class="math">\\mathbf{S}</span> to simulate the <span class="math">j</span>-th symbol in the <span class="math">i</span>-th proof oracle, which leads to an answer <span class="math">a_{i,j}\\in\\Sigma</span>; then <span class="math">\\mathbf{S}_{\\mathrm{r}}</span> samples a codeword <span class="math">\\mathcal{C}(a_{i,j})\\in\\Lambda^{n}</span> that agrees with the previous <span class="math">b^{\\prime}</span> answers, and answers all future queries to this string via this sampled codeword.</li>

    </ul>

    <p class="text-gray-300">Observe that <span class="math">\\mathbf{S}_{\\mathrm{r}}</span> asks <span class="math">\\mathbf{S}</span> to simulate at most <span class="math">\\lfloor\\frac{b^{\\prime}b+b^{\\prime}+b}{b^{\\prime}+\\mathrm{i}}\\rfloor=b</span> queries, which <span class="math">\\mathbf{S}</span> can do by assumption.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Also observe that the codeword in the second step can be found efficiently. Let <span class="math">R</span> denote the randomness used in encoding <span class="math">a_{i,j}</span>. The answers to the previous <span class="math">b^{\\prime}</span> queries each imposes a linear constraint on <span class="math">R</span>. These constraints can be efficiently generated from the previous queries and the generator matrix of the code <span class="math">\\mathcal{C}</span>. The set of linear equations on <span class="math">R</span> can be solved in $\\text{poly}(b^{\\prime},\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Lambda</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ time. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-143" class="text-base font-medium mt-4">Proof of Item 1 in Lemma A.4.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{S}</span> be the simulator for the old IOP <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span>. Below we construct the new simulator <span class="math">\\mathbf{S}_{\\mathrm{r}}</span> for the new IOP <span class="math">(\\mathbf{I}_{\\mathrm{r}},\\mathbf{P}_{\\mathrm{r}},\\mathbf{V}_{\\mathrm{r}})</span>.</p>

    <p class="text-gray-300">Fix an index <span class="math">\\dot{\\mathfrak{s}}</span>, instance <span class="math">\\mathfrak{x}</span>, and witness <span class="math">\\mathfrak{w}</span> such that <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w})\\in R</span> and fix the randomness <span class="math">\\rho</span> for the old verifier <span class="math">\\mathbf{V}</span>. Note that <span class="math">\\mathbf{V}_{\\mathrm{r}}</span> does not use any additional randomness beyond the randomness used by <span class="math">\\mathbf{V}</span>. We need the random variables <span class="math">\\mathbf{S}_{\\mathrm{r}}^{\\mathbf{V}_{\\mathrm{r}}(\\dot{\\mathfrak{s}},\\mathfrak{x};\\rho)}(\\dot{\\mathfrak{s}},\\mathfrak{x})</span> and <span class="math">\\mathrm{View}(\\mathbf{P}_{\\mathrm{r}}(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w}),\\mathbf{V}_{\\mathrm{r}}(\\dot{\\mathfrak{s}},\\mathfrak{x};\\rho))</span> to be identically distributed.</p>

    <p class="text-gray-300">The new simulator <span class="math">\\mathbf{S}_{\\mathrm{r}}</span> receives as input an index <span class="math">\\dot{\\mathfrak{s}}</span> and instance <span class="math">\\mathfrak{x}</span>, and computes the encoded index <span class="math">\\mathbf{I}_{\\mathrm{r}}(\\dot{\\mathfrak{s}})</span> for later use. Then <span class="math">\\mathbf{S}_{\\mathrm{r}}</span> starts running <span class="math">\\mathbf{V}_{\\mathrm{r}}</span> and simulates its view by taking different actions depending on <span class="math">\\mathbf{V}_{\\mathrm{r}}</span>. Whenever <span class="math">\\mathbf{V}_{\\mathrm{r}}</span> outputs a message for the new prover <span class="math">\\mathbf{P}_{\\mathrm{r}}</span>, the new simulator <span class="math">\\mathbf{S}_{\\mathrm{r}}</span> forwards this message to the old simulator <span class="math">\\mathbf{S}</span> (as if it were a message for the old prover <span class="math">\\mathbf{P}</span>). Whenever <span class="math">\\mathbf{V}_{\\mathrm{r}}</span> makes a query to the index oracle <span class="math">\\mathbf{I}_{\\mathrm{r}}(\\dot{\\mathfrak{s}})</span>, the new simulator <span class="math">\\mathbf{S}_{\\mathrm{r}}</span> directly answers the query (as it knows the index and has computed the encoded index so that it knows the answer to all such queries). Whenever <span class="math">\\mathbf{V}_{\\mathrm{r}}</span> makes a query to a proof oracle, <span class="math">\\mathbf{S}_{\\mathrm{r}}</span> proceeds as follows. If <span class="math">\\mathbf{V}_{\\mathrm{r}}</span>’s query is to the <span class="math">j</span>-th string in the <span class="math">i</span>-th proof oracle (for <span class="math">i\\in[\\mathsf{rc}]</span>), then since <span class="math">\\mathbf{V}_{\\mathrm{r}}</span> is semi-honest, it queries the entire <span class="math">j</span>-th string. To simulate the <span class="math">j</span>-th string, <span class="math">\\mathbf{S}_{\\mathrm{r}}</span> asks <span class="math">\\mathbf{S}</span> to simulate the <span class="math">j</span>-th symbol in the <span class="math">i</span>-th proof oracle, which leads to an answer <span class="math">a_{i,j}\\in\\Sigma</span>; then <span class="math">\\mathbf{S}_{\\mathrm{r}}</span> samples a codeword</p>

    <p class="text-gray-300"><span class="math">\\mathcal{C}(a_{i,j})\\in\\Lambda^{n}</span> that agrees with the previous <span class="math">b^{\\prime}</span> answers, and answers all future queries to this string via this sampled codeword. This procedure is efficient because the encoding algorithm for the code <span class="math">\\mathcal{C}</span> is efficient.</p>

    <p class="text-gray-300">Since, by assumption, <span class="math">\\mathbf{S}</span> simulates the view of <span class="math">\\mathbf{V}</span> perfectly, the encoded view is a perfect simulation of the view of <span class="math">\\mathbf{V}_{\\mathrm{r}}</span>. ∎</p>

    <p class="text-gray-300">B Proof composition</p>

    <p class="text-gray-300">We state a generic lemma about proof composition for IOPs (Lemma B.1). We include the construction for convenience (Construction B.5) but omit the proof; see <em>[x1]</em> for more details on interactive proof composition for IOPs (which extends the classical notion of non-interactive proof composition for PCPs <em>[x1]</em>). We also prove properties about how zero knowledge is affected by proof composition (Lemma B.6).</p>

    <h6 id="sec-144" class="text-base font-medium mt-4">Lemma B.1.</h6>

    <p class="text-gray-300">Suppose that the conditions below hold with parameters such that <span class="math">\\delta_{\\text{\\tiny in}}(\\sigma_{\\text{\\tiny out}}(n))\\leq\\alpha_{\\text{\\tiny out}}(n)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Outer IOP with robustness. There is a holographic IOP <span class="math">(\\mathbf{I}_{\\text{\\tiny out}},\\mathbf{P}_{\\text{\\tiny out}},\\mathbf{V}_{\\text{\\tiny out}})</span> with non-adaptive queries in <span class="math">\\mathcal{Q}_{\\text{\\tiny point}}</span> for an indexed relation <span class="math">R</span> with the following parameters: round complexity <span class="math">\\mathsf{rc}_{\\text{\\tiny out}}</span>; answer alphabet <span class="math">\\Sigma</span>; oracle length <span class="math">\\mathsf{l}_{\\text{\\tiny out}}=\\mathsf{li}_{\\text{\\tiny out}}+\\mathsf{lp}_{\\text{\\tiny out}}</span>; randomness <span class="math">\\mathsf{r}_{\\text{\\tiny out}}</span>; query complexity <span class="math">\\mathsf{q}_{\\text{\\tiny out}}</span>; decision state size <span class="math">\\sigma_{\\text{\\tiny out}}</span>; soundness error <span class="math">\\epsilon_{\\text{\\tiny out}}</span>; robustness <span class="math">\\alpha_{\\text{\\tiny out}}</span>; indexer time <span class="math">\\mathsf{ti}_{\\text{\\tiny out}}</span>; prover time <span class="math">\\mathsf{tp}_{\\text{\\tiny out}}</span>; verifier time <span class="math">\\mathsf{tv}_{\\text{\\tiny out}}=\\mathsf{tq}_{\\text{\\tiny out}}+\\mathsf{td}_{\\text{\\tiny out}}</span>.</li>

      <li>Inner IOP with proximity. There is an IOPP <span class="math">(\\mathbf{P}_{\\text{\\tiny in}},\\mathbf{V}_{\\text{\\tiny in}})</span> with queries in <span class="math">\\mathcal{Q}_{\\text{\\tiny point}}</span> for the relation <span class="math">R(\\mathbf{V}_{\\text{\\tiny out}})</span> with round complexity <span class="math">\\mathsf{rc}_{\\text{\\tiny in}}</span>; answer alphabet <span class="math">\\Sigma</span>; proof length <span class="math">\\mathsf{l}_{\\text{\\tiny in}}</span>; randomness <span class="math">\\mathsf{r}_{\\text{\\tiny in}}</span>; query complexity <span class="math">\\mathsf{q}_{\\text{\\tiny in}}</span>; soundness error <span class="math">\\epsilon_{\\text{\\tiny in}}</span>; proximity <span class="math">\\delta_{\\text{\\tiny in}}</span>; prover time <span class="math">\\mathsf{tp}_{\\text{\\tiny in}}</span>; verifier time <span class="math">\\mathsf{tv}_{\\text{\\tiny in}}</span>.</li>

    </ul>

    <p class="text-gray-300">Then the protocol in Construction B.5 (see below) is a holographic IOP <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> with queries in <span class="math">\\mathcal{Q}_{\\text{\\tiny point}}</span> for the indexed relation <span class="math">R</span> with the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity <span class="math">\\mathsf{rc}(n)=\\mathsf{rc}_{\\text{\\tiny out}}(n)+\\mathsf{rc}_{\\text{\\tiny in}}(\\sigma_{\\text{\\tiny out}}(n))</span>;</li>

      <li>answer alphabet <span class="math">\\Sigma</span>;</li>

      <li>index oracle length <span class="math">\\mathsf{li}(n)=\\mathsf{li}_{\\text{\\tiny out}}(n)</span>;</li>

      <li>proof oracle length <span class="math">\\mathsf{lp}(n)=\\mathsf{lp}_{\\text{\\tiny out}}(n)+\\mathsf{l}_{\\text{\\tiny in}}(\\sigma_{\\text{\\tiny out}}(n))</span>;</li>

      <li>randomness <span class="math">\\mathsf{r}(n)=\\mathsf{r}_{\\text{\\tiny out}}(n)+\\mathsf{r}_{\\text{\\tiny in}}(\\sigma_{\\text{\\tiny out}}(n))</span>;</li>

      <li>query complexity <span class="math">\\mathsf{q}(n)=\\mathsf{q}_{\\text{\\tiny in}}(\\sigma_{\\text{\\tiny out}}(n))</span>;</li>

      <li>soundness error <span class="math">\\epsilon(n)=\\epsilon_{\\text{\\tiny out}}(n)+\\epsilon_{\\text{\\tiny in}}(\\sigma_{\\text{\\tiny out}}(n))</span>;</li>

      <li>indexer time <span class="math">\\mathsf{ti}(n)=\\mathsf{ti}_{\\text{\\tiny out}}(n)</span>;</li>

      <li>prover time <span class="math">\\mathsf{tp}(n)=\\mathsf{tp}_{\\text{\\tiny out}}(n)+\\mathsf{tq}_{\\text{\\tiny out}}(n)+\\mathsf{tp}_{\\text{\\tiny in}}(\\sigma_{\\text{\\tiny out}}(n))</span>;</li>

      <li>verifier time <span class="math">\\mathsf{tv}(n)=\\mathsf{tq}_{\\text{\\tiny out}}(n)+\\mathsf{tv}_{\\text{\\tiny in}}(\\sigma_{\\text{\\tiny out}}(n))</span>.</li>

    </ul>

    <p class="text-gray-300">If the two proof systems are public coin then so is <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span>.</p>

    <p class="text-gray-300">We provide some remarks, then state the construction for proof composition (see Construction B.5), and finally prove how zero-knowledge properties are preserved in the construction.</p>

    <h6 id="sec-145" class="text-base font-medium mt-4">Remark B.2 (outer proximity or inner robustness).</h6>

    <p class="text-gray-300">If the outer IOP has proximity parameter <span class="math">\\delta_{\\text{\\tiny out}}</span>, then the composed proof system is an IOP with proximity parameter <span class="math">\\delta(n)=\\delta_{\\text{\\tiny out}}(n)</span>. If the inner IOP has robustness parameter <span class="math">\\alpha_{\\text{\\tiny in}}</span> then the composed proof system is an IOP with robustness parameter <span class="math">\\alpha(n)=\\alpha_{\\text{\\tiny in}}(\\sigma_{\\text{\\tiny out}}(n))</span>.</p>

    <h6 id="sec-146" class="text-base font-medium mt-4">Remark B.3 (different alphabets).</h6>

    <p class="text-gray-300">Lemma B.1 asserts that the outer and inner proof systems use the same alphabet for the prover messages. This is not essential: if the two alphabets differ, the same argument as above goes through, and the composed proof system will have some messages over one alphabet and other messages over the other alphabet. In particular, in Section 9 the outer proof system will be over a given field <span class="math">\\mathbb{F}</span> and the inner proof system will be over the boolean field <span class="math">\\mathbb{F}_{2}</span>.</p>

    <h6 id="sec-147" class="text-base font-medium mt-4">Remark B.4 (on the ZK query bound).</h6>

    <p class="text-gray-300">The expression for <span class="math">b</span> in Equation (6) may look odd, but it can be intuitively explained. First, if the outer proof system does not satisfy any zero knowledge property (<span class="math">b_{\\text{\\tiny out}}=0</span>)</p>

    <p class="text-gray-300">then the composed proof system also will not (<span class="math">b=0</span>), regardless of the inner proof system. This makes sense since the verifier in the composed proof system does have access to the proof transcript of the outer proof system. So suppose that the outer proof system has a non-trivial zero knowledge property (<span class="math">b_{\\text{out}}&gt;0</span>); this property may degrade a little or not at all in the composed proof system, depending on the inner proof system, because it is used to argue that a local view is satisfied. For illustrative purposes, let us consider two cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose that the inner proximity proof satisfies no zero knowledge property, which means that the condition holds with the constant function <span class="math">f_{\\text{in}}(\\cdot):=\\mathfrak{q}_{\\text{out}}</span>, because a witness for the relation <span class="math">R(\\mathbf{V}_{\\text{out}})</span> consists of <span class="math">\\mathfrak{q}_{\\text{out}}</span> symbols. (All proximity proofs satisfy the “trivial” zero knowledge property where the simulator queries all locations of the witness, which means that <span class="math">f</span> returns the size of the witness.) In this case, it could be that the inner proof system reveals all <span class="math">\\mathfrak{q}_{\\text{in}}</span> locations of the local view and in addition the verifier can make <span class="math">b</span> queries to the outer proof transcript. We need that <span class="math">b+\\mathfrak{q}_{\\text{out}}\\leq b_{\\text{out}}</span> which gives <span class="math">b\\leq b_{\\text{out}}-\\mathfrak{q}_{\\text{out}}</span>, i.e., we “lost” <span class="math">\\mathfrak{q}_{\\text{out}}</span> queries.</li>

      <li>Suppose that the inner proximity proof satisfies zero knowledge with <span class="math">f_{\\text{in}}(i):=i</span>, i.e., the simulator only has to query the witness at <span class="math">i</span> locations whenever a malicious verifier makes <span class="math">i</span> queries across the witness and proof transcript. In this case the expression <span class="math">\\max_{j=0,1,\\ldots,i}\\{j+f_{\\text{in}}(i-j)\\}</span> equals <span class="math">i</span>, which means that we get the better bound <span class="math">b\\leq b_{\\text{out}}</span>, which means no degradation in the query bound.</li>

    </ul>

    <h6 id="sec-148" class="text-base font-medium mt-4">Construction B.5.</h6>

    <p class="text-gray-300">The new indexer <span class="math">\\mathbf{I}</span> takes as input an index <span class="math">\\mathbbm{i}</span> and outputs the encoded index <span class="math">\\Pi_{0}:=\\mathbf{I}_{\\text{out}}(\\mathbbm{i})</span>. The new prover <span class="math">\\mathbf{P}</span> receives as input the index <span class="math">\\mathbbm{i}</span>, an instance <span class="math">\\mathbbm{x}</span>, and witness <span class="math">\\mathbbm{w}</span>. The new verifier <span class="math">\\mathbf{V}</span> receives as oracle the encoded index <span class="math">\\Pi_{0}</span> and as input the instance <span class="math">\\mathbbm{x}</span>. The protocol between <span class="math">\\mathbf{P}</span> and <span class="math">\\mathbf{V}</span> proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Outer. The new prover <span class="math">\\mathbf{P}</span> and new verifier <span class="math">\\mathbf{V}</span> engage in the interactive phase of <span class="math">(\\mathbf{P}_{\\text{out}}(\\mathbbm{i},\\mathbbm{x},\\mathbbm{w}),\\mathbf{V}_{\\text{out}}^{\\mathbf{I}_{\\text{out}}(\\mathbbm{i})}(\\mathbbm{x}))</span> for the indexed relation <span class="math">R</span>, leading to the outer proof transcript <span class="math">\\Pi_{\\text{out}}</span> (which is in addition to the encoded index <span class="math">\\mathbf{I}_{\\text{out}}(\\mathbbm{i})</span>). Note that the interactive phase does not include the (non-adaptive) query phase of <span class="math">\\mathbf{V}_{\\text{out}}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Sample local view. The new verifier <span class="math">\\mathbf{V}</span> sends the (whole) randomness string <span class="math">\\mathsf{r}_{\\text{out}}</span> of the outer verifier <span class="math">\\mathbf{V}_{\\text{out}}</span> to the new prover <span class="math">\\mathbf{P}</span>. Both <span class="math">\\mathbf{P}</span> and <span class="math">\\mathbf{V}</span> compute <span class="math">(\\sigma,I):=\\mathbf{V}_{\\mathfrak{q}_{\\text{out}}}(\\mathbbm{x},\\mathsf{r}_{\\text{out}})</span>. These define an inner instance <span class="math">\\mathbbm{x}_{\\text{in}}:=\\sigma</span> and inner witness $\\mathbbm{w}_{\\text{in}}:=(\\mathbf{I}_{\\text{out}}(\\mathbbm{i}),\\Pi_{\\text{out}})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I}<span class="math"> for the relation </span>R(\\mathbf{V}_{\\text{out}})<span class="math"> of accepting local views for the outer verifier </span>\\mathbf{V}_{\\text{out}}<span class="math">. Note that the new verifier </span>\\mathbf{V}<span class="math"> has oracle access to the encoded index </span>\\mathbf{I}_{\\text{out}}(\\mathbbm{i})<span class="math"> and outer proof transcript </span>\\Pi_{\\text{out}}<span class="math">, and in particular also to the inner witness </span>\\mathbbm{w}_{\\text{in}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Inner. The new prover <span class="math">\\mathbf{P}</span> and the new verifier <span class="math">\\mathbf{V}</span> engage in an execution of <span class="math">(\\mathbf{P}_{\\text{in}}(\\mathbbm{x}_{\\text{in}},\\mathbbm{w}_{\\text{in}}),\\mathbf{V}_{\\text{in}}^{\\mathbb{m}_{\\text{in}}}(\\mathbbm{x}_{\\text{in}}))</span> for the relation <span class="math">R(\\mathbf{V}_{\\text{out}})</span>. The new verifier <span class="math">\\mathbf{V}</span> accepts if and only if the inner verifier <span class="math">\\mathbf{V}_{\\text{in}}</span> does.</li>

    </ul>

    <h6 id="sec-149" class="text-base font-medium mt-4">Lemma B.6.</h6>

    <p class="text-gray-300">The implications below hold for the proof composition in Lemma B.1.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Semi-honest-verifier zero knowledge. If <span class="math">(\\mathbf{I}_{\\text{out}},\\mathbf{P}_{\\text{out}},\\mathbf{V}_{\\text{out}})</span> is zero knowledge against semi-honest verifiers, then so is <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> (regardless of any zero-knowledge properties of <span class="math">(\\mathbf{P}_{\\text{in}},\\mathbf{V}_{\\text{in}})</span>).</li>

      <li>Bounded-query zero knowledge. If <span class="math">(\\mathbf{I}_{\\text{out}},\\mathbf{P}_{\\text{out}},\\mathbf{V}_{\\text{out}})</span> is zero knowledge with query bound <span class="math">b_{\\text{out}}</span> and <span class="math">(\\mathbf{P}_{\\text{in}},\\mathbf{V}_{\\text{in}})</span> is zero knowledge with query function <span class="math">f_{\\text{in}}</span> then <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> is zero knowledge with query bound</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$b:=\\max\\left\\{i\\in\\mathbb{N}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\max_{j=0,1,\\ldots,i}\\{j+f_{\\text{in}}(i-j)\\}\\leq b_{\\text{out}}\\right.\\right\\}~{}.$ (6)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-150" class="text-base font-medium mt-4">Proof of Item 2 in Lemma B.6.</h6>

    <p class="text-gray-300">Recall the zero knowledge properties of the outer and inner proof systems:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By the zero-knowledge property of <span class="math">(\\mathbf{P}_{\\mathrm{out}},\\mathbf{V}_{\\mathrm{out}})</span>, there is an efficient simulator <span class="math">\\mathbf{S}_{\\mathrm{out}}</span> such that, for every index-instance-witness triple <span class="math">(\\mathbf{i},\\mathbf{x},\\mathbf{w})\\in R</span> and <span class="math">b_{\\mathrm{out}}</span>-query malicious verifier <span class="math">\\tilde{\\mathbf{V}}_{\\mathrm{out}}</span>, the random variables <span class="math">\\mathbf{S}_{\\mathrm{out}}^{\\tilde{\\mathbf{V}}_{\\mathrm{out}}}(\\mathbf{i},\\mathbf{x})</span> and <span class="math">\\mathrm{View}(\\mathbf{P}_{\\mathrm{out}}(\\mathbf{i},\\mathbf{x},\\mathbf{w}),\\tilde{\\mathbf{V}}_{\\mathrm{out}})</span> are identically distributed.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By the zero-knowledge property of <span class="math">(\\mathbf{P}_{\\mathrm{in}},\\mathbf{V}_{\\mathrm{in}})</span>, there is an efficient simulator <span class="math">\\mathbf{S}_{\\mathrm{in}}</span> such that, for every instance-witness pair <span class="math">(\\mathbf{x}_{\\mathrm{in}},\\mathbf{w}_{\\mathrm{in}})\\in R(\\mathbf{V}_{\\mathrm{out}})</span> (the relation of accepting local views for <span class="math">\\mathbf{V}_{\\mathrm{out}}</span>), query bound <span class="math">b\\in \\mathbb{N}</span>, and <span class="math">b</span>-query malicious verifier <span class="math">\\tilde{\\mathbf{V}}_{\\mathrm{in}}</span>, the random variables <span class="math">\\mathbf{S}_{\\mathrm{in}}^{\\tilde{\\mathbf{V}}_{\\mathrm{in}},\\mathbf{w}_{\\mathrm{in}}}(\\mathbf{x}_{\\mathrm{in}})</span> and <span class="math">\\mathrm{View}(\\mathbf{P}_{\\mathrm{in}}(\\mathbf{x}_{\\mathrm{in}},\\mathbf{w}_{\\mathrm{in}}),\\tilde{\\mathbf{V}}_{\\mathrm{in}}^{\\mathbf{w}_{\\mathrm{in}}})</span> are identically distributed and <span class="math">\\mathbf{S}_{\\mathrm{in}}</span> makes at most <span class="math">f_{\\mathrm{in}}(b)</span> queries to <span class="math">\\mathbf{w}_{\\mathrm{in}}</span>.</li>

    </ul>

    <p class="text-gray-300">We use the above simulators to construct an efficient simulator <span class="math">\\mathbf{S}</span> for the composed proof system <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\tilde{\\mathbf{V}}</span> be a <span class="math">b</span>-query malicious verifier for <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> whose view <span class="math">\\mathbf{S}</span> must simulate. Unlike the honest verifier, <span class="math">\\tilde{\\mathbf{V}}</span> may arbitrarily query any of the proof strings sent by the new prover <span class="math">\\mathbf{P}</span>. Also, <span class="math">\\tilde{\\mathbf{V}}</span> does not make queries to the encoded index <span class="math">\\mathbf{I}(\\mathbf{i})</span>, as <span class="math">\\tilde{\\mathbf{V}}</span> can itself apply the (deterministic) indexer <span class="math">\\mathbf{I}</span> to the index <span class="math">\\mathbf{i}</span>.</p>

    <p class="text-gray-300">The new simulator <span class="math">\\mathbf{S}</span> receives as input an index <span class="math">\\mathbf{i}</span> and instance <span class="math">\\mathbf{x}</span>, and computes the encoded index <span class="math">\\mathbf{I}_{\\mathrm{out}}(\\mathbf{i})</span> for later use. Then <span class="math">\\mathbf{S}</span> starts running <span class="math">\\tilde{\\mathbf{V}}</span> and simulates its view by relying on executions of the outer simulator <span class="math">\\mathbf{S}_{\\mathrm{out}}^{\\tilde{\\mathbf{V}}_{\\mathrm{out}}}(\\mathbf{i},\\mathbf{x})</span> and the inner simulator <span class="math">\\mathbf{S}_{\\mathrm{in}}^{\\tilde{\\mathbf{V}}_{\\mathrm{in}},\\mathbf{w}_{\\mathrm{in}}}(\\mathbf{x}_{\\mathrm{in}})</span> as described below. Note that the inner instance <span class="math">\\mathbf{x}_{\\mathrm{in}}</span> is explicitly defined, while the outer verifier <span class="math">\\tilde{\\mathbf{V}}_{\\mathrm{out}}</span>, inner verifier <span class="math">\\tilde{\\mathbf{V}}_{\\mathrm{in}}</span>, and inner witness <span class="math">\\mathbf{w}_{\\mathrm{in}}</span> are implicitly defined.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Simulate outer proof system.</strong> Whenever <span class="math">\\tilde{\\mathbf{V}}</span> outputs a message for <span class="math">\\mathbf{P}_{\\mathrm{out}}</span>, <span class="math">\\mathbf{S}</span> forwards this message to <span class="math">\\mathbf{S}_{\\mathrm{out}}</span>. Whenever <span class="math">\\tilde{\\mathbf{V}}</span> makes a query to a proof string of the outer proof system (i.e., to a location in <span class="math">\\Pi_{\\mathrm{out}}</span>), <span class="math">\\mathbf{S}</span> forwards this query to <span class="math">\\mathbf{S}_{\\mathrm{out}}</span> and replies with the simulated answer provided by <span class="math">\\mathbf{S}_{\\mathrm{out}}</span>. (Note that <span class="math">\\tilde{\\mathbf{V}}</span> may make queries during this phase, even though the honest verifier <span class="math">\\mathbf{V}</span> does not.)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Determine malicious local view.</strong> After the interactive phase of the outer proof system, <span class="math">\\tilde{\\mathbf{V}}</span> outputs a malicious choice of randomness string <span class="math">\\hat{\\mathbf{r}}_{\\mathrm{out}}</span>. The simulator <span class="math">\\mathbf{S}</span> runs the outer query sampler <span class="math">\\mathbf{V}_{\\mathrm{qout}}(\\mathbf{x},\\hat{\\mathbf{r}}_{\\mathrm{out}})</span> to obtain the inner instance <span class="math">\\mathbf{x}_{\\mathrm{in}} := \\tilde{\\sigma}</span> and the positions of the local view <span class="math">\\hat{I}</span> (which are positions in <span class="math">\\mathbf{I}_{\\mathrm{out}}(\\mathbf{i})</span> and <span class="math">\\Pi_{\\mathrm{out}}</span>).</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Simulate inner proof system.</strong> Whenever <span class="math">\\tilde{\\mathbf{V}}</span> outputs a message for <span class="math">\\mathbf{P}_{\\mathrm{in}}</span>, <span class="math">\\mathbf{S}</span> forwards this message to <span class="math">\\mathbf{S}_{\\mathrm{in}}</span>. Whenever <span class="math">\\tilde{\\mathbf{V}}</span> makes a query to a proof string of the inner proof system, <span class="math">\\mathbf{S}</span> forwards this query to <span class="math">\\mathbf{S}_{\\mathrm{in}}</span> and replies with the simulated answer provided by <span class="math">\\mathbf{S}_{\\mathrm{in}}</span>. Note that this may in turn cause <span class="math">\\mathbf{S}_{\\mathrm{in}}</span> to query some locations in <span class="math">\\mathbf{w}_{\\mathrm{in}}</span> (which is the encoded index <span class="math">\\mathbf{I}_{\\mathrm{out}}(\\mathbf{i})</span> and outer proof transcript <span class="math">\\Pi_{\\mathrm{out}}</span> restricted to positions in <span class="math">\\hat{I}</span>). For all such queries, if the query is to <span class="math">\\mathbf{I}_{\\mathrm{out}}(\\mathbf{i})</span> then <span class="math">\\mathbf{S}</span> answers it directly (as it has the index and already has computed the encoded index); if instead the query is to <span class="math">\\Pi_{\\mathrm{out}}</span> then <span class="math">\\mathbf{S}</span> forwards the query to <span class="math">\\mathbf{S}_{\\mathrm{out}}</span> and replies with the resulting simulated answer. Moreover, in this phase <span class="math">\\tilde{\\mathbf{V}}</span> may still choose to directly query a location of the outer proof transcript <span class="math">\\Pi_{\\mathrm{out}}</span>, and again <span class="math">\\mathbf{S}</span> relies on <span class="math">\\mathbf{S}_{\\mathrm{out}}</span> to simulate the answer to such queries.</li>

    </ul>

    <p class="text-gray-300">Suppose that the <span class="math">b</span>-query verifier <span class="math">\\tilde{\\mathbf{V}}</span> makes <span class="math">j</span> queries to the outer proof transcript <span class="math">\\Pi_{\\mathrm{out}}</span> and <span class="math">b - j</span> queries to the inner proof transcript <span class="math">\\Pi_{\\mathrm{in}}</span>. The inner simulator <span class="math">\\mathbf{S}_{\\mathrm{in}}</span> will make <span class="math">f_{\\mathrm{in}}(b - j)</span> queries to the inner witness <span class="math">\\mathbf{w}_{\\mathrm{in}}</span>, and <span class="math">\\mathbf{S}</span> will forward up to <span class="math">f_{\\mathrm{in}}(b - j)</span> queries to the outer simulator <span class="math">\\mathbf{S}_{\\mathrm{out}}</span>. (Some queries to <span class="math">\\mathbf{w}_{\\mathrm{in}}</span> are to the encoded <span class="math">\\mathbf{I}_{\\mathrm{out}}(\\mathbf{i})</span>, and those are not forwarded to <span class="math">\\mathbf{S}_{\\mathrm{out}}</span>.) This means that in total <span class="math">\\mathbf{S}_{\\mathrm{out}}</span> will have to simulate up to <span class="math">j + f_{\\mathrm{in}}(b - j)</span> queries. Since <span class="math">\\tilde{\\mathbf{V}}</span> gets to choose the value of <span class="math">j</span>, <span class="math">\\mathbf{S}_{\\mathrm{out}}</span> will have to simulate, in the worst case, <span class="math">\\max_{j = 0,1,\\dots,b}\\{j + f_{\\mathrm{in}}(b - j)\\}</span> queries. As long as the outer query bound <span class="math">b_{\\mathrm{out}}</span> is at least this worst-case bound, the outer simulator <span class="math">\\mathbf{S}_{\\mathrm{out}}</span> will succeed in the simulation, and in turn so will the new simulator <span class="math">\\mathbf{S}</span>.</p>

    <p class="text-gray-300">Proof of Item 1 of Lemma B.6. The semi-honest-verifier zero-knowledge property of <span class="math">(\\mathbf{P}_{\\mathrm{out}},\\mathbf{V}_{\\mathrm{out}})</span> states that there is an efficient simulator <span class="math">\\mathbf{S}_{\\mathrm{out}}</span> such that, for every index-instance-witness triple <span class="math">(\\mathbf{i},\\mathbf{x},\\mathbf{w})\\in R</span> and every choice of randomness <span class="math">\\rho_{\\mathrm{out}}</span> for <span class="math">\\mathbf{V}_{\\mathrm{out}}</span>, the following random variables are identically distributed:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {S} _ {\\text {o u t}} ^ {\\mathbf {V} _ {\\text {o u t}} (\\mathbf {i}, \\mathbf {x}; \\rho_ {\\text {o u t}})} (\\mathbf {i}, \\mathbf {x}) \\quad \\text {a n d} \\quad \\operatorname {V i e w} \\left(\\mathbf {P} _ {\\text {o u t}} (\\mathbf {i}, \\mathbf {x}, \\mathbf {w}), \\mathbf {V} _ {\\text {o u t}} (\\mathbf {i}, \\mathbf {x}; \\rho_ {\\text {o u t}})\\right).</span></div>

    <p class="text-gray-300">We use the simulator <span class="math">\\mathbf{S}_{\\mathrm{out}}</span> to construct an efficient simulator <span class="math">\\mathbf{S}</span> for the composed proof system <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span>.</p>

    <p class="text-gray-300">The new simulator <span class="math">\\mathbf{S}</span> receives as input an index <span class="math">\\hat{\\mathbf{s}}</span> and instance <span class="math">\\mathbf{x}</span>, and computes the encoded index <span class="math">\\mathbf{I}_{\\mathrm{out}}(\\hat{\\mathbf{s}})</span> for later use. Then <span class="math">\\mathbf{S}</span> starts running <span class="math">\\mathbf{V}</span> and simulates its view by relying on executions of the outer simulator <span class="math">\\mathbf{S}_{\\mathrm{out}}^{\\mathbf{V}_{\\mathrm{out}}(\\hat{\\mathbf{s}},\\mathbf{x};p_{\\mathrm{out}})}(\\hat{\\mathbf{s}},\\mathbf{x})</span>. Note that the inner instance <span class="math">\\mathbf{x}_{\\mathrm{in}}</span> is explicitly defined, while the outer verifier <span class="math">\\mathbf{V}_{\\mathrm{out}}</span>, inner verifier <span class="math">\\mathbf{V}_{\\mathrm{in}}</span>, and inner witness <span class="math">\\mathbf{w}_{\\mathrm{in}}</span> are implicitly defined.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Simulate outer proof system.</em> Whenever <span class="math">\\mathbf{V}</span> outputs a message for <span class="math">\\mathbf{P}_{\\mathrm{out}}</span>, <span class="math">\\mathbf{S}</span> forwards this message to <span class="math">\\mathbf{S}_{\\mathrm{out}}</span>. Since <span class="math">\\mathbf{V}</span> is semi-honest, <span class="math">\\mathbf{V}</span> does not make any queries during this phase.</li>

      <li><em>Determine semi-honest local view.</em> After the interactive phase of the outer proof system, <span class="math">\\mathbf{V}</span> outputs a choice of randomness string <span class="math">r_{\\mathrm{out}}</span> (which can be distributed arbitrarily). The simulator <span class="math">\\mathbf{S}</span> runs the outer query sampler <span class="math">\\mathbf{V}_{\\mathrm{q}_{\\mathrm{out}}}(\\mathbf{x},r_{\\mathrm{out}})</span> to obtain the inner instance <span class="math">\\mathbf{x}_{\\mathrm{in}}:=\\sigma</span>, the positions of the local view <span class="math">I</span> (which are positions in <span class="math">\\mathbf{I}_{\\mathrm{out}}(\\hat{\\mathbf{s}})</span> and <span class="math">\\Pi_{\\mathrm{out}}</span>), and the view of <span class="math">\\mathbf{V}_{\\mathrm{out}}</span>, which forms the witness <span class="math">\\mathbf{w}_{\\mathrm{in}}</span> for the inner proof system.</li>

      <li><em>Simulate inner proof system.</em> The simulator <span class="math">\\mathbf{S}</span> runs the inner prover <span class="math">\\mathbf{P}_{\\mathrm{in}}</span>, and mediates an interaction between <span class="math">\\mathbf{V}</span> and <span class="math">\\mathbf{P}_{\\mathrm{in}}</span>. Whenever <span class="math">\\mathbf{V}</span> outputs a message for <span class="math">\\mathbf{P}_{\\mathrm{in}}</span>, <span class="math">\\mathbf{S}</span> forwards this message to <span class="math">\\mathbf{P}_{\\mathrm{in}}</span>. Whenever <span class="math">\\mathbf{V}</span> makes a query to a proof string of the inner proof system, <span class="math">\\mathbf{S}</span> answers this query using oracles output by <span class="math">\\mathbf{P}_{\\mathrm{in}}</span>. The verifier <span class="math">\\mathbf{V}</span> may also query some locations in the encoded index <span class="math">\\mathbf{I}_{\\mathrm{out}}(\\hat{\\mathbf{s}})</span> and outer proof transcript <span class="math">\\Pi_{\\mathrm{out}}</span> restricted to positions in <span class="math">I</span> (which forms <span class="math">\\mathbf{w}_{\\mathrm{in}}</span>). For all such queries, if the query is to <span class="math">\\mathbf{I}_{\\mathrm{out}}(\\hat{\\mathbf{s}})</span> then <span class="math">\\mathbf{S}</span> answers it directly (as it has the index and has already computed the encoded index); if instead the query is to <span class="math">\\Pi_{\\mathrm{out}}</span> then <span class="math">\\mathbf{S}</span> forwards the query to <span class="math">\\mathbf{S}_{\\mathrm{out}}</span> and replies with the resulting simulated answer. Note that since <span class="math">\\mathbf{V}</span> is semi-honest, no other locations of the outer proof transcript <span class="math">\\Pi_{\\mathrm{out}}</span> are queried.</li>

    </ul>

    <p class="text-gray-300">By assumption, <span class="math">\\mathbf{S}_{\\mathrm{out}}</span> simulates the view of <span class="math">\\mathbf{V}_{\\mathrm{out}}</span> perfectly. In either a simulated proof, or a real proof, the view of <span class="math">\\mathbf{V}</span> is obtained by running <span class="math">\\mathbf{P}_{\\mathrm{in}}</span> on the view of <span class="math">\\mathbf{V}_{\\mathrm{out}}</span>. Thus, <span class="math">\\mathbf{S}</span> provides a perfect simulation. Since <span class="math">\\mathbf{S}_{\\mathrm{out}}</span> and <span class="math">\\mathbf{P}_{\\mathrm{in}}</span> are efficient, so is <span class="math">\\mathbf{S}</span>.</p>

    <p class="text-gray-300">C Equivalence of zero-knowledge code definitions</p>

    <p class="text-gray-300">The following is a reformulation of <em>[x23, Definition 2.3.2]</em>.</p>

    <h6 id="sec-151" class="text-base font-medium mt-4">Definition C.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{C}</span> be a randomized linear code with randomized encoding function <span class="math">\\mathrm{Enc}</span>. Let <span class="math">b\\in\\mathbb{N}</span> be a query bound and <span class="math">\\epsilon&gt;0</span> a statistical distance parameter. We say that <span class="math">\\mathcal{C}</span> is <span class="math">(b,\\epsilon)</span>-ZK if for every set <span class="math">J\\subseteq[n]</span> of size at most <span class="math">b</span>, and every message pair <span class="math">m,m^{\\prime}\\in\\mathbb{F}^{k_{m}}</span>, the statistical distance between $\\mathrm{Enc}(m)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}<span class="math"> and </span>\\mathrm{Enc}(m^{\\prime})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}<span class="math"> is at most </span>\\epsilon$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lemma C.2 and Lemma C.3 show that Definition C.1 and Definition 3.21 are equivalent when <span class="math">\\mathcal{C}</span> has a polynomial-time encoding function. However, Definition 3.21 may be stronger, for example, for codes with an exponential-size block length for which a polynomial number of entries can be efficiently simulated.</p>

    <h6 id="sec-152" class="text-base font-medium mt-4">Lemma C.2.</h6>

    <p class="text-gray-300">If a randomized linear code <span class="math">\\mathcal{C}</span> is <span class="math">b</span>-query zero-knowledge then it is <span class="math">(b,0)</span>-ZK.</p>

    <h6 id="sec-153" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The distribution of <span class="math">\\mathcal{S}^{A}</span> equals <span class="math">\\{\\mathrm{View}(\\mathrm{Enc}(m;r),A)\\}_{r\\leftarrow\\mathbb{F}^{k_{r}}}</span> for any message <span class="math">m\\in\\mathbb{F}^{k_{m}}</span> and any <span class="math">b</span>-query verifier <span class="math">A</span>, so specializing to <span class="math">A</span> which queries a set <span class="math">J</span> demonstrates that $\\mathrm{Enc}(m)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}$ is identically distributed for any query set. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-154" class="text-base font-medium mt-4">Lemma C.3.</h6>

    <p class="text-gray-300">If a randomized linear code <span class="math">\\mathcal{C}</span> is <span class="math">(b,0)</span>-ZK, then it is <span class="math">b</span>-query zero-knowledge. Moreover, the running time of the simulator <span class="math">\\mathcal{S}</span> is the time taken to compute <span class="math">\\mathrm{Enc}(0)</span>.</p>

    <h6 id="sec-155" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The simulator <span class="math">\\mathcal{S}</span> simply computes the codeword <span class="math">\\mathrm{Enc}(0)</span> and answers the verifier’s queries with the entries of <span class="math">\\mathrm{Enc}(0)</span>. Since the distribution of <span class="math">\\mathrm{Enc}(0)</span> is identical to that of <span class="math">\\mathrm{Enc}(m)</span> for any message <span class="math">m</span>, the simulation is perfect. ∎</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">This research was supported in part by: the Berkeley Haas Blockchain Initiative and a donation from the Ethereum Foundation. Part of the work was conducted while the first author was employed by UC Berkeley.</p>

    <h2 id="sec-156" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AHIKV17] Benny Applebaum, Naama Haramaty, Yuval Ishai, Eyal Kushilevitz, and Vinod Vaikuntanathan. “Low-Complexity Cryptographic Hash Functions”. In: Proceedings of the 8th Innovations in Theoretical Computer Science Conference. ITCS ’17. 2017, 7:1–7:31.</li>

      <li>[AHIV17] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. “Ligero: Lightweight Sublinear Arguments Without a Trusted Setup”. In: Proceedings of the 24th ACM Conference on Computer and Communications Security. CCS ’17. 2017, pp. 2087–2104.</li>

      <li>[AS98] Sanjeev Arora and Shmuel Safra. “Probabilistic checking of proofs: a new characterization of NP”. In: Journal of the ACM 45.1 (1998). Preliminary version in FOCS ’92., pp. 70–122.</li>

      <li>[BBBPWM18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. “Bulletproofs: Short Proofs for Confidential Transactions and More”. In: Proceedings of the 39th IEEE Symposium on Security and Privacy. S&P ’18. 2018, pp. 315–334.</li>

      <li>[BBHR19] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. “Scalable Zero Knowledge with No Trusted Setup”. In: Proceedings of the 39th Annual International Cryptology Conference. CRYPTO ’19. 2019, pp. 733–764.</li>

      <li>[BCC88] Gilles Brassard, David Chaum, and Claude Crépeau. “Minimum disclosure proofs of knowledge”. In: Journal of Computer and System Sciences 37.2 (1988), pp. 156–189.</li>

      <li>[BCCGP16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. “Efficient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting”. In: Proceedings of the 35th Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’16. 2016, pp. 327–357.</li>

      <li>[BCFGRS17] Eli Ben-Sasson, Alessandro Chiesa, Michael A. Forbes, Ariel Gabizon, Michael Riabzev, and Nicholas Spooner. “Zero Knowledge Protocols from Succinct Constraint Detection”. In: Proceedings of the 15th Theory of Cryptography Conference. TCC ’17. 2017, pp. 172–206.</li>

      <li>[BCG20] Jonathan Bootle, Alessandro Chiesa, and Jens Groth. “Linear-Time Arguments with Sublinear Verification from Tensor Codes”. In: Proceedings of the 18th Theory of Cryptography Conference. TCC ’20. 2020, pp. 19–46.</li>

      <li>[BCGGHJ17] Jonathan Bootle, Andrea Cerulli, Essam Ghadafi, Jens Groth, Mohammad Hajiabadi, and Sune K. Jakobsen. “Linear-Time Zero-Knowledge Proofs for Arithmetic Circuit Satisfiability”. In: Proceedings of the 23rd International Conference on the Theory and Applications of Cryptology and Information Security. ASIACRYPT ’17. 2017, pp. 336–365.</li>

      <li>[BCGGRS19] Eli Ben-Sasson, Alessandro Chiesa, Lior Goldberg, Tom Gur, Michael Riabzev, and Nicholas Spooner. “Linear-Size Constant-Query IOPs for Delegating Computation”. In: Proceedings of the 17th Theory of Cryptography Conference. TCC ’19. 2019, pp. 494–521.</li>

      <li>[BCGRS17] Eli Ben-Sasson, Alessandro Chiesa, Ariel Gabizon, Michael Riabzev, and Nicholas Spooner. “Interactive Oracle Proofs with Constant Rate and Query Complexity”. In: Proceedings of the 44th International Colloquium on Automata, Languages and Programming. ICALP ’17. 2017, 40:1–40:15.</li>

      <li>[BCGV16] Eli Ben-Sasson, Alessandro Chiesa, Ariel Gabizon, and Madars Virza. “Quasilinear-Size Zero Knowledge from Linear-Algebraic PCPs”. In: Proceedings of the 13th Theory of Cryptography Conference. TCC ’16-A. 2016, pp. 33–64.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCIOP13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. “Succinct Non-Interactive Arguments via Linear Interactive Proofs”. In: Proceedings of the 10th Theory of Cryptography Conference. TCC ’13. 2013, pp. 315–333.</li>

      <li>[BCRSVW19] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. “Aurora: Transparent Succinct Arguments for R1CS”. In: Proceedings of the 38th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’19. 2019, pp. 103–128.</li>

      <li>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. “Interactive Oracle Proofs”. In: Proceedings of the 14th Theory of Cryptography Conference. TCC ’16-B. 2016, pp. 31–60.</li>

      <li>[BKKMS13] Eli Ben-Sasson, Yohay Kaplan, Swastik Kopparty, Or Meir, and Henning Stichtenoth. “Constant Rate PCPs for Circuit-SAT with Sublinear Query Complexity”. In: Proceedings of the 54th Annual IEEE Symposium on Foundations of Computer Science. FOCS ’13. 2013, pp. 320–329.</li>

      <li>[BKS18] Eli Ben-Sasson, Swastik Kopparty, and Shubhangi Saraf. “Worst-Case to Average Case Reductions for the Distance to a Code”. In: Proceedings of the 33rd ACM Conference on Computer and Communications Security. CCS ’18. 2018, 24:1–24:23.</li>

      <li>[CCGHV07] Hao Chen, Ronald Cramer, Shafi Goldwasser, Robbert de Haan, and Vinod Vaikuntanathan. “Secure Computation from Random Error Correcting Codes”. In: Proceedings of the 26th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT’ 07. 2007, pp. 291–310.</li>

      <li>[CDBN15] Ronald Cramer, Ivan Damgård, and Jesper Buus Nielsen. Secure Multiparty Computation and Secret Sharing. Cambridge University Press, 2015.</li>

      <li>[CHMMVW20] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. “Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS”. In: Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’20. 2020, pp. 738–768.</li>

      <li>[COS20] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. “Fractal: Post-Quantum and Transparent Recursive Proofs from Holography”. In: Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’20. 2020, pp. 769–793.</li>

      <li>[Cer19] Andrea Cerulli. “Efficient zero-knowledge proofs and their applications”. 2019.</li>

      <li>[Cha+17] Melissa Chase, David Derler, Steven Goldfeder, Claudio Orlandi, Sebastian Ramacher, Christian Rechberger, Daniel Slamanig, and Greg Zaverucha. “Post-Quantum Zero-Knowledge and Signatures from Symmetric-Key Primitives”. In: Proceedings of the 24th ACM Conference on Computer and Communications Security. CCS ’17. 2017, pp. 1825–1842.</li>

      <li>[DI14] Erez Druk and Yuval Ishai. “Linear-time encodable codes meeting the Gilbert–Varshamov bound and their cryptographic applications”. In: Proceedings of the 5th Innovations in Theoretical Computer Science Conference. ITCS ’14. 2014, pp. 169–182.</li>

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. “Quadratic Span Programs and Succinct NIZKs without PCPs”. In: Proceedings of the 32nd Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’13. 2013, pp. 626–645.</li>

      <li>[GH98] Oded Goldreich and Johan Håstad. “On the complexity of interactive proofs with bounded communication”. In: Information Processing Letters 67.4 (1998), pp. 205–214.</li>

      <li>[GIMS10] Vipul Goyal, Yuval Ishai, Mohammad Mahmoody, and Amit Sahai. “Interactive locking, zero-knowledge PCPs, and unconditional cryptography”. In: Proceedings of the 30th Annual Conference on Advances in Cryptology. CRYPTO’10. 2010, pp. 173–190.</li>

      <li>[GK96] Oded Goldreich and Ariel Kahan. “How to Construct Constant-Round Zero-Knowledge Proof Systems for NP”. In: Journal of Cryptology 9.3 (1996), pp. 167–190.</li>

    </ul>

    <p class="text-gray-300">[GLSTW21] Alexander Golovnev, Jonathan Lee, Srinath Setty, Justin Thaler, and Riad Wahby. <em>Brakedown: Linear-time and post-quantum SNARKs for RICS</em>. Cryptology ePrint Archive, Report 2021/1043. 2021.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GMO16] Irene Giacomelli, Jesper Madsen, and Claudio Orlandi. “ZKBoo: Faster Zero-Knowledge for Boolean Circuits”. In: <em>Proceedings of the 25th USENIX Security Symposium</em>. Security ’16. 2016, pp. 1069–1083.</li>

      <li>[GMR89] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. “The knowledge complexity of interactive proof systems”. In: <em>SIAM Journal on Computing</em> 18.1 (1989). Preliminary version appeared in STOC ’85., pp. 186–208.</li>

      <li>[GVW02] Oded Goldreich, Salil Vadhan, and Avi Wigderson. “On interactive proofs with a laconic prover”. In: <em>Computational Complexity</em> 11.1/2 (2002), pp. 1–53.</li>

      <li>[HK20] David Heath and Vladimir Kolesnikov. “Stacked Garbling for Disjunctive Zero-Knowledge Proofs”. In: <em>Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques</em>. EUROCRYPT ’20. 2020, pp. 569–598.</li>

      <li>[IKOS07] Yuval Ishai, Eyal Kushilevitz, Rafail Ostrovsky, and Amit Sahai. “Zero-knowledge from secure multiparty computation”. In: <em>Proceedings of the 39th Annual Symposium on Theory of Computing</em>. STOC’07. 2007, pp. 21–30.</li>

      <li>[IMS12] Yuval Ishai, Mohammad Mahmoody, and Amit Sahai. “On Efficient Zero-Knowledge PCPs”. In: <em>Proceedings of the 9th Theory of Cryptography Conference on Theory of Cryptography</em>. TCC ’12. 2012, pp. 151–168.</li>

      <li>[IMSX15] Yuval Ishai, Mohammad Mahmoody, Amit Sahai, and David Xiao. <em>On Zero-Knowledge PCPs: Limitations, Simplifications, and Applications</em>. Available at http://www.cs.virginia.edu/~mohammad/files/papers/ZKPCPs-Full.pdf. 2015.</li>

      <li>[ISVW13] Yuval Ishai, Amit Sahai, Michael Viderman, and Mor Weiss. “Zero Knowledge LTCs and Their Applications”. In: <em>Proceedings of the 16th International Workshop on Approximation Algorithms for Combinatorial Optimization Problems, and of the 17th International Workshop on Randomization and Computation</em>. APPROX-RANDOM ’13. 2013, pp. 607–622.</li>

      <li>[IW14] Yuval Ishai and Mor Weiss. “Probabilistically Checkable Proofs of Proximity with Zero-Knowledge”. In: <em>Proceedings of the 11th Theory of Cryptography Conference</em>. TCC ’14. 2014, pp. 121–145.</li>

      <li>[KKB88] Michael Kaminski, David Kirkpatrick, and Nader Bshouty. “Addition Requirements for Matrix and Transposed Matrix Products”. In: <em>Journal of Algorithms</em> 9.3 (1988), pp. 354–364.</li>

      <li>[KKW18] Jonathan Katz, Vladimir Kolesnikov, and Xiao Wang. “Improved Non-Interactive Zero Knowledge with Applications to Post-Quantum Signatures”. In: <em>Proceedings of the 25th ACM Conference on Computer and Communications Security</em>. CCS ’18. 2018, pp. 525–537.</li>

      <li>[KMP20] Abhiram Kothapalli, Elisaweta Masserova, and Bryan Parno. <em>A Direct Construction for Asymptotically Optimal zkSNARKs</em>. Cryptology ePrint Archive, Report 2020/1318. 2020.</li>

      <li>[KPT97] Joe Kilian, Erez Petrank, and Gábor Tardos. “Probabilistically checkable proofs with zero knowledge”. In: <em>Proceedings of the 29th Annual ACM Symposium on Theory of Computing</em>. STOC ’97. 1997, pp. 496–505.</li>

      <li>[Kil92] Joe Kilian. “A note on efficient zero-knowledge proofs and arguments”. In: <em>Proceedings of the 24th Annual ACM Symposium on Theory of Computing</em>. STOC ’92. 1992, pp. 723–732.</li>

      <li>[LSTW21] Jonathan Lee, Srinath Setty, Justin Thaler, and Riad Wahby. <em>Linear-time zero-knowledge SNARKs for RICS</em>. Cryptology ePrint Archive, Report 2021/030. 2021.</li>

      <li>[Mei12] Or Meir. “Combinatorial PCPs with Short Proofs”. In: <em>Proceedings of the 26th Annual IEEE Conference on Computational Complexity</em>. CCC ’12. 2012.</li>

    </ul>

    <p class="text-gray-300">[Mei13] Or Meir. "IP = PSPACE Using Error-Correcting Codes". In: SIAM Journal on Computing 42.1 (2013), pp. 380-403. [Mie09] Thilo Mie. "Short PCPPs verifiable in polylogarithmic time with O(1) queries". In: Annals of Mathematics and Artificial Intelligence 56 (3 2009), pp. 313-338. [RR20] Noga Ron-Zewi and Ron Rothblum. "Local Proofs Approaching the Witness Length". In: Proceedings of the 61st Annual IEEE Symposium on Foundations of Computer Science. FOCS '20. 2020, pp. 846-857. [RRR16] Omer Reingold, Ron Rothblum, and Guy Rothblum. "Constant-Round Interactive Proofs for Delegating Computation". In: Proceedings of the 48th ACM Symposium on the Theory of Computing. STOC '16. 2016, pp. 49-62. [SL20] Srinath Setty and Jonathan Lee. Quarks: Quadruple-efficient transparent zkSNARKs. Cryptology ePrint Archive, Report 2020/1275. 2020. [Set20] Srinath Setty. "Spartan: Efficient and general-purpose zkSNARKs without trusted setup". In: Proceedings of the 40th Annual International Cryptology Conference. CRYPTO '20. Referencing Cryptology ePrint Archive, Report 2019/550, revision from 2020.02.28. 2020, pp. 704-737. [Spi96] Daniel A. Spielman. "Linear-time encodable and decodable error-correcting codes". In: IEEE Transactions on Information Theory 42.6 (1996). Preliminary version appeared in STOC '95., pp. 1723-1731. [Tha13] Justin Thaler. "Time-Optimal Interactive Proofs for Circuit Evaluation". In: Proceedings of the 33rd Annual International Cryptology Conference. CRYPTO '13. 2013, pp. 71-89. [WTSTW18] Riad S. Wahby, Ioanna Tzialla, Abhi Shelat, Justin Thaler, and Michael Walfish. "Doubly-efficient zkSNARKs without trusted setup". In: Proceedings of the 39th IEEE Symposium on Security and Privacy. S&amp;P '18. 2018, pp. 926-943. [WYKW20] Chenkai Weng, Kang Yang, Jonathan Katz, and Xiao Wang. Wolverine: Fast, Scalable, and Communication-Efficient Zero-Knowledge Proofs for Boolean and Arithmetic Circuits. IACR Cryptology ePrint Archive, Report 2020/925. 2020. [Wei16] Mor Weiss. "Secure Computation and Probabilistic Checking". 2016. [XZZPS19] Tiancheng Xie, Jiaheng Zhang, Yupeng Zhang, Charalampos Papamanthou, and Dawn Song. "Libra: Succinct Zero-Knowledge Proofs with Optimal Prover Computation". In: Proceedings of the 39th Annual International Cryptology Conference. CRYPTO '19. 2019, pp. 733-764. [ZWZZ20] Jiaheng Zhang, Weijie Wang, Yinuo Zhang, and Yupeng Zhang. Doubly Efficient Interactive Proofs for General Arithmetic Circuits with Linear Prover Time. Cryptology ePrint Archive, Report 2020/1247. 2020. [ZXZS20] Jiaheng Zhang, Tiancheng Xie, Yupeng Zhang, and Dawn Song. "Transparent Polynomial Delegation and Its Applications to Zero Knowledge Proof". In: Proceedings of the 41st IEEE Symposium on Security and Privacy. S&amp;P '20. 2020, pp. 859-876.</p>`;
---

<BaseLayout title="Zero-Knowledge IOPs with Linear-Time Prover and Polylogarith... (2020/1527)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/1527
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
