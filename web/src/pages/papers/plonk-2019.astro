---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/953';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-13';
---

<BaseLayout title="PlonK (2019/953)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        PlonK: Permutations over Lagrange-bases for
        Oecumenical Noninteractive arguments of Knowledge
      </h1>
      <p class="text-gray-400 mb-2">
        Ariel Gabizon, Zachary J. Williamson, Oana Ciobotaru
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/953
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">Converted with: {CRAWLER} &middot; {CONVERTED_DATE}</p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-1.1"
                class="hover:text-white">
                Our Results</a>
            </li>
            <li>
              <a href="#sec-1.2"
                class="hover:text-white">
                Efficiency Analysis</a>
            </li>
            <li>
              <a href="#sec-1.3"
                class="hover:text-white">
                Performance and Benchmarks</a>
            </li>
            <li>
              <a href="#sec-1.4"
                class="hover:text-white">
                Comparison with Sumcheck Approach</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-2.1"
                class="hover:text-white">
                Terminology and Conventions</a>
            </li>
            <li>
              <a href="#sec-2.2"
                class="hover:text-white">
                Analysis in the AGM Model</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">
            A Batched Version of the KZG Scheme</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1"
                class="hover:text-white">
                The PCS</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">
            Idealised Low-Degree Protocols</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-4.1"
                class="hover:text-white">
                Polynomial Protocols on Ranges</a>
            </li>
            <li>
              <a href="#sec-4.2"
                class="hover:text-white">
                From Polynomial Protocols to Protocols
                against Algebraic Adversaries</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">
            Polynomial Protocols for Identifying
            Permutations</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-5.1"
                class="hover:text-white">
                Checking Extended Permutations</a>
            </li>
            <li>
              <a href="#sec-5.2"
                class="hover:text-white">
                Checking Extended Copy Constraints</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-6"
            class="hover:text-white">
            Constraint Systems</a>
        </li>
        <li>
          <a href="#sec-7"
            class="hover:text-white">
            Main Protocol</a>
        </li>
        <li>
          <a href="#sec-8"
            class="hover:text-white">
            The Final Protocol, Rolled Out</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-8.1"
                class="hover:text-white">
                Polynomials that Define a Specific Circuit</a>
            </li>
            <li>
              <a href="#sec-8.2"
                class="hover:text-white">
                The SNARK Proof Relation</a>
            </li>
            <li>
              <a href="#sec-8.3"
                class="hover:text-white">
                The Protocol</a>
            </li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#acknowledgements"
            class="hover:text-white">Acknowledgements</a>
        </li>
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
        <li>
          <a href="#app-a"
            class="hover:text-white">
            Appendix A: Claims for Permutation Argument</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">
        zk-SNARK constructions that utilize an updatable universal
        structured reference string remove one of the main obstacles
        in deploying zk-SNARKs. The important work of Maller et al.
        [MBKM] presented Sonic &mdash; the first potentially practical
        zk-SNARK with fully succinct verification for general
        arithmetic circuits with such an SRS. However, the version of
        Sonic enabling fully succinct verification still requires
        relatively high proof construction overheads.
      </p>
      <p class="text-gray-300">
        We present a universal SNARK construction with fully succinct
        verification, and significantly lower prover running time
        (roughly 7.5&ndash;20 times fewer group exponentiations than
        [MBKM] in the fully succinct verifier mode depending on
        circuit structure).
      </p>
      <p class="text-gray-300">
        Similarly to [MBKM] we rely on a permutation argument based
        on Bayer and Groth [BG12]. However, we focus on
        &ldquo;evaluations on a subgroup rather than coefficients of
        monomials&rdquo;; which enables simplifying both the
        permutation argument and the arithmetization step.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1. Introduction</h2>
      <p class="text-gray-300">
        Due to real-world deployments of zk-SNARKs, it has become of
        significant interest to have the structured reference string
        (SRS) be constructible in a &ldquo;universal and
        updatable&rdquo; fashion. Meaning that the same SRS can be
        used for statements about all circuits of a certain bounded
        size; and that at any point in time the SRS can be updated by
        a new party, such that the honesty of only one party from all
        updaters up to that point is required for soundness. For
        brevity, let us call a zk-SNARK with such a setup process
        universal.
      </p>
      <p class="text-gray-300">
        For the purpose of this introduction, let us say a zk-SNARK
        for circuit satisfiability is <em>fully succinct</em> if:
      </p>
      <ol class="list-decimal list-inside text-gray-300 ml-4
        space-y-1">
        <li>
          The preprocessing phase/SRS generation run time is
          quasilinear in circuit size.
        </li>
        <li>
          The prover run time is quasilinear in circuit size.
        </li>
        <li>
          The proof length is logarithmic in circuit size.
        </li>
        <li>
          The verifier run time is polylogarithmic in circuit size.
        </li>
      </ol>
      <p class="text-gray-300">
        Maller et al. [MBKM] constructed for the first time a
        universal fully succinct zk-SNARK for circuit satisfiability,
        called Sonic. [MBKM] also give a version of Sonic with
        dramatically improved prover run time, at the expense of
        efficient verification only in a certain amortized sense.
      </p>

      <!-- 1.1 Our results -->

      <h3 id="sec-1.1" class="text-xl font-semibold">
        1.1 Our Results
      </h3>
      <p class="text-gray-300">
        In this work we give a universal fully-succinct zk-SNARK with
        significantly improved prover run time compared to
        fully-succinct Sonic.
      </p>
      <p class="text-gray-300">
        At a high level our improvements stem from a more direct
        arithmetization of a circuit as compared to the
        [BCC+16]-inspired arithmetization of [MBKM]. This
        is combined with a permutation argument over univariate
        evaluations on a multiplicative subgroup rather than over
        coefficients of a bivariate polynomial as in [MBKM].
      </p>
      <p class="text-gray-300">
        In a nutshell, one reason multiplicative subgroups are useful
        is that several protocols, including Sonic, use a permutation
        argument based on Bayer and Groth [BG12]. Ultimately, in the
        &ldquo;grand product argument&rdquo;, this reduces to
        checking relations between coefficients of polynomials at
        &ldquo;neighbouring monomials&rdquo;.
      </p>
      <p class="text-gray-300">
        We observe that if we think of the points
        <span class="math">x, g \cdot x</span> as neighbours, where
        <span class="math">g</span> is a generator of a
        multiplicative subgroup of a field
        <span class="math">\mathbb&#123;F&#125;</span>, it is very
        convenient to check relations between different polynomials
        at such pairs of points.
      </p>
      <p class="text-gray-300">
        A related convenience is that multiplicative subgroups
        interact well with Lagrange bases. For example, suppose
        <span class="math">H \subset \mathbb&#123;F&#125;</span> is
        a multiplicative subgroup of order
        <span class="math">n</span>, and
        <span class="math">x \in H</span>. The polynomial
        <span class="math">L^x</span> of degree
        <span class="math">n - 1</span> that vanishes on
        <span class="math">H \setminus \&#123;x\&#125;</span> and
        has <span class="math">L^x(x) = 1</span>, has a very sparse
        representation of the form
      </p>
      <div class="math-block">
        L_x(X) = \frac&#123;c_x(X^n - 1)&#125;&#123;(X - x)&#125;,
      </div>
      <p class="text-gray-300">
        for a constant <span class="math">c_x</span>. This is
        beneficial when constructing an efficiently verifiable
        [BG12]-style permutation argument in terms of polynomial
        identities.
      </p>

      <!-- 1.2 Efficiency Analysis -->

      <h3 id="sec-1.2" class="text-xl font-semibold">
        1.2 Efficiency Analysis
      </h3>
      <p class="text-gray-300">
        We compare the performance of this work to the state of the
        art, both for non-universal SNARKs and universal SNARKs. At
        the time of publication, the only fully succinct universal
        SNARK construction is (the fully-succinct version of) the
        Sonic protocol [MBKM]. This protocol requires the prover
        compute
        <span class="math">273n</span>
        <span class="math">\mathbb&#123;G&#125;_1</span> group
        exponentiations, where
        <span class="math">n</span> is the number of multiplication
        gates.
      </p>
      <p class="text-gray-300">
        Our universal SNARK requires the prover to compute 5
        polynomial commitments, combined with two opening proofs to
        evaluate the polynomial commitments at a random challenge
        point. There are two &ldquo;flavours&rdquo; of PlonK to suit
        the tastes of the user. By increasing the proof size by two
        group elements, the total prover computations can be reduced
        by approximately 10%. The combined degree of the polynomials
        is either
        <span class="math">9(n + a)</span> (larger proofs) or
        <span class="math">11(n + a)</span> (smaller proofs, reduced
        verifier work), where
        <span class="math">n</span> is the number of multiplication
        gates and <span class="math">a</span> is the number of
        addition gates.
      </p>
      <p class="text-gray-300">
        Currently, the most efficient fully-succinct SNARK
        construction available is Groth's 2016 construction [Gro16],
        which requires a unique, non-updateable CRS per circuit.
        Proof construction times are dominated by
        <span class="math">3n + m</span>
        <span class="math">\mathbb&#123;G&#125;_1</span> and
        <span class="math">n</span>
        <span class="math">\mathbb&#123;G&#125;_2</span> group
        exponentiations, where
        <span class="math">m</span> is formally the number of R1CS
        variables, and is typically bounded by
        <span class="math">n</span>. If we assume that one
        <span class="math">\mathbb&#123;G&#125;_2</span>
        exponentiation is equivalent to three
        <span class="math">\mathbb&#123;G&#125;_1</span>
        exponentiations, this yields
        <span class="math">6n + m</span> equivalent
        <span class="math">\mathbb&#123;G&#125;_1</span> group
        exponentiations.
      </p>
      <p class="text-gray-300">
        We also note that the degree of PlonK&rsquo;s structured
        reference string is equal to the number of gates in a circuit
        (if one uses the &ldquo;fast&rdquo; flavour of PlonK). This
        is a significant reduction in the SRS size compared to the
        state of the art.
      </p>

      <!-- Table 1: Prover comparison -->

      <div id="table-1" class="overflow-x-auto my-6">
        <p class="text-sm text-gray-400 mb-2">
          <strong>Table 1.</strong> Prover comparison.
          <span class="math">m</span> = number of wires,
          <span class="math">n</span> = number of multiplication
          gates,
          <span class="math">a</span> = number of addition gates.
        </p>
        <table class="w-full text-sm">
          <thead>
            <tr class="border-b border-gray-700">
              <th class="text-left py-2 pr-4">Scheme</th>
              <th class="text-left py-2 pr-4">Prover work</th>
              <th class="text-left py-2 pr-4">Proof length</th>
              <th class="text-left py-2 pr-4">Succinct</th>
              <th class="text-left py-2 pr-4">Universal</th>
            </tr>
          </thead>
          <tbody class="text-gray-300">
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Groth&rsquo;16</td>
              <td class="py-2 pr-4">
                <span class="math">3n + m - \ell</span>
                <span class="math">\mathbb&#123;G&#125;_1</span>
                exp,
                <span class="math">n</span>
                <span class="math">\mathbb&#123;G&#125;_2</span>
                exp
              </td>
              <td class="py-2 pr-4">
                <span class="math">2\mathbb&#123;G&#125;_1,
                  1\mathbb&#123;G&#125;_2</span>
              </td>
              <td class="py-2 pr-4">Yes</td>
              <td class="py-2 pr-4">No</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Sonic (helped)</td>
              <td class="py-2 pr-4">
                <span class="math">18n</span>
                <span class="math">\mathbb&#123;G&#125;_1</span>
                exp
              </td>
              <td class="py-2 pr-4">
                <span class="math">4\mathbb&#123;G&#125;_1,
                  2\mathbb&#123;F&#125;</span>
              </td>
              <td class="py-2 pr-4">No</td>
              <td class="py-2 pr-4">Yes</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Sonic (succinct)</td>
              <td class="py-2 pr-4">
                <span class="math">273n</span>
                <span class="math">\mathbb&#123;G&#125;_1</span>
                exp
              </td>
              <td class="py-2 pr-4">
                <span class="math">20\mathbb&#123;G&#125;_1,
                  16\mathbb&#123;F&#125;</span>
              </td>
              <td class="py-2 pr-4">Yes</td>
              <td class="py-2 pr-4">Yes</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">This work (small)</td>
              <td class="py-2 pr-4">
                <span class="math">11(n+a)</span>
                <span class="math">\mathbb&#123;G&#125;_1</span>
                exp,
                <span class="math">\approx 54(n+a)\log(n+a)
                  </span>
                <span class="math">\mathbb&#123;F&#125;</span>
                mul
              </td>
              <td class="py-2 pr-4">
                <span class="math">7\mathbb&#123;G&#125;_1,
                  6\mathbb&#123;F&#125;</span>
              </td>
              <td class="py-2 pr-4">Yes</td>
              <td class="py-2 pr-4">Yes</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">This work (fast prover)</td>
              <td class="py-2 pr-4">
                <span class="math">9(n+a)</span>
                <span class="math">\mathbb&#123;G&#125;_1</span>
                exp,
                <span class="math">\approx 54(n+a)\log(n+a)
                  </span>
                <span class="math">\mathbb&#123;F&#125;</span>
                mul
              </td>
              <td class="py-2 pr-4">
                <span class="math">9\mathbb&#123;G&#125;_1,
                  6\mathbb&#123;F&#125;</span>
              </td>
              <td class="py-2 pr-4">Yes</td>
              <td class="py-2 pr-4">Yes</td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- Table 2: Verifier comparison -->

      <div id="table-2" class="overflow-x-auto my-6">
        <p class="text-sm text-gray-400 mb-2">
          <strong>Table 2.</strong> Verifier comparison per proof.
          <span class="math">P</span> = pairing,
          <span class="math">\ell</span> = number of public inputs.
        </p>
        <table class="w-full text-sm">
          <thead>
            <tr class="border-b border-gray-700">
              <th class="text-left py-2 pr-4">Scheme</th>
              <th class="text-left py-2 pr-4">Verifier work</th>
            </tr>
          </thead>
          <tbody class="text-gray-300">
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Groth&rsquo;16</td>
              <td class="py-2 pr-4">
                <span class="math">3P, \ell</span>
                <span class="math">\mathbb&#123;G&#125;_1</span>
                exp
              </td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Sonic (succinct)</td>
              <td class="py-2 pr-4">
                <span class="math">13P</span>
              </td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">This work (small)</td>
              <td class="py-2 pr-4">
                <span class="math">2P, 16</span>
                <span class="math">\mathbb&#123;G&#125;_1</span>
                exp
              </td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">This work (fast prover)</td>
              <td class="py-2 pr-4">
                <span class="math">2P, 18</span>
                <span class="math">\mathbb&#123;G&#125;_1</span>
                exp
              </td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- 1.3 Performance and Benchmarks -->

      <h3 id="sec-1.3" class="text-xl font-semibold">
        1.3 Performance and Benchmarks
      </h3>
      <p class="text-gray-300">
        [Figure 1 describes benchmarks for test PlonK circuits using
        the BN254 curve. Does not include witness generation. Tests
        performed on a Surface Pro 6 with 16GB RAM and a core
        i7-8650U CPU, utilizing all 8 logical/4 physical cores.]
      </p>
      <p class="text-gray-300">
        Even for circuits with over a million gates, PlonK proofs are
        capable of being constructed on consumer-grade hardware in
        under 23 seconds. This marks a significant advancement in the
        efficiency of universal SNARKs, which are now practical for a
        wide range of real-world use-cases.
      </p>
      <p class="text-gray-300">
        Circuit preprocessing is a one-off computation, required for
        each program codified into a PlonK circuit. This step
        generates the polynomial commitments to the
        &lsquo;selector&rsquo; polynomials required to verify proofs.
      </p>
      <p class="text-gray-300">
        When constructing proofs, the time taken to perform the
        required fast fourier transforms is comparable to the time
        taken for elliptic curve scalar multiplications. The number of
        field multiplications in Table 1 is obtained from 8 FFTs of
        size <span class="math">4n</span>, 5 FFTs of size
        <span class="math">2n</span> and 12 FFTs of size
        <span class="math">n</span>.
      </p>

      <!-- 1.4 Comparison with the randomized sumcheck approach -->

      <h3 id="sec-1.4" class="text-xl font-semibold">
        1.4 Comparison with the Randomized Sumcheck Approach,
        and Fractal/Marlin
      </h3>
      <p class="text-gray-300">
        Roughly speaking, all succinct proving systems work by using
        randomness to compress many constraint checks into one. The
        general way to obtain such compression is by taking a random
        linear combination of the constraints. In the case of R1CS
        and similar systems, the more difficult constraints to be
        compressed are linear relations between the system variables,
        i.e. constraints of the form
        <span class="math">\langle a_i, x \rangle = 0</span> where
        <span class="math">x \in \mathbb&#123;F&#125;^m</span> are
        the system variables, and
        <span class="math">a_i \in \mathbb&#123;F&#125;^m</span>
        represents one of the constraints.
      </p>
      <p class="text-gray-300">
        These are analogous to the less general &ldquo;wiring
        constraints&rdquo; in a circuit satisfiability statement,
        which have the form
        <span class="math">x_i = x_j</span> (e.g. when
        <span class="math">x_i</span> represents the output wire of
        a gate <span class="math">G</span>, and
        <span class="math">x_j</span> an input wire from
        <span class="math">G</span> into another gate
        <span class="math">G'</span>).
      </p>
      <p class="text-gray-300">
        A random linear combination of linear constraints might have
        the form
      </p>
      <div class="math-block">
        \sum_&#123;i \in [n]&#125; r^i \langle a_i, x \rangle = 0
      </div>
      <p class="text-gray-300">
        for a uniform
        <span class="math">r \in \mathbb&#123;F&#125;</span>.
      </p>
      <p class="text-gray-300">
        Coming back to PlonK, the reason we don&rsquo;t require the
        &ldquo;bi-variate evaluation breakthrough&rdquo; is that we
        focus on constant fan-in circuits rather than
        R1CS/unlimited addition fan-in; and thus our linear
        constraints are just wiring constraints that can be reduced
        to a permutation check. One way to interpret the [BG12]
        technique is that &ldquo;linear constraints that correspond
        to a permutation can be more simply combined than general
        linear constraints&rdquo;.
      </p>
      <p class="text-gray-300">
        <strong>Concrete comparison to Marlin:</strong> While Fractal
        leverages the sparse bi-variate evaluation technique in the
        context of transparent recursive SNARKs, Marlin focuses on
        constructing a fully succinct (universal) SNARK as in this
        paper. For the same value of
        <span class="math">n</span>, PlonK outperforms Marlin by
        roughly a 2x factor in prover group operations and proof
        size.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2. PRELIMINARIES                                             -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2. Preliminaries</h2>

      <!-- 2.1 Terminology and Conventions -->

      <h3 id="sec-2.1" class="text-xl font-semibold">
        2.1 Terminology and Conventions
      </h3>
      <p class="text-gray-300">
        We assume our field
        <span class="math">\mathbb&#123;F&#125;</span> is of prime
        order. We denote by
        <span class="math">\mathbb&#123;F&#125;_&#123;&lt;
          d&#125;[X]</span>
        the set of univariate polynomials over
        <span class="math">\mathbb&#123;F&#125;</span> of degree
        smaller than <span class="math">d</span>. We assume all
        algorithms described receive as an implicit parameter the
        security parameter
        <span class="math">\lambda</span>.
      </p>
      <p class="text-gray-300">
        Whenever we use the term &ldquo;efficient&rdquo;, we mean an
        algorithm running in time
        <span class="math">\text&#123;poly&#125;(\lambda)</span>.
        Furthermore, we assume an &ldquo;object generator&rdquo;
        <span class="math">\mathcal&#123;O&#125;</span> that is run
        with input <span class="math">\lambda</span> before all
        protocols, and returns all fields and groups used.
        Specifically, in our protocol
        <span class="math">\mathcal&#123;O&#125;(\lambda) =
          (\mathbb&#123;F&#125;, \mathbb&#123;G&#125;_1,
          \mathbb&#123;G&#125;_2, \mathbb&#123;G&#125;_t, e, g_1,
          g_2, g_t)</span>
        where:
      </p>
      <ul class="list-disc list-inside text-gray-300 ml-4
        space-y-1">
        <li>
          <span class="math">\mathbb&#123;F&#125;</span> is a prime
          field of super-polynomial size
          <span class="math">r =
            \lambda^&#123;\omega(1)&#125;</span>.
        </li>
        <li>
          <span class="math">\mathbb&#123;G&#125;_1,
            \mathbb&#123;G&#125;_2,
            \mathbb&#123;G&#125;_t</span>
          are all groups of size
          <span class="math">r</span>, and
          <span class="math">e</span> is an efficiently computable
          non-degenerate pairing
          <span class="math">e : \mathbb&#123;G&#125;_1 \times
            \mathbb&#123;G&#125;_2 \to
            \mathbb&#123;G&#125;_t</span>.
        </li>
        <li>
          <span class="math">g_1, g_2</span> are uniformly chosen
          generators such that
          <span class="math">e(g_1, g_2) = g_t</span>.
        </li>
      </ul>
      <p class="text-gray-300">
        We write
        <span class="math">\mathbb&#123;G&#125;_1</span> and
        <span class="math">\mathbb&#123;G&#125;_2</span> additively.
        We use the notations
        <span class="math">[x]_1 := x \cdot g_1</span> and
        <span class="math">[x]_2 := x \cdot g_2</span>.
        We often denote by
        <span class="math">[n]</span> the integers
        <span class="math">\&#123;1, \ldots, n\&#125;</span>.
      </p>

      <!-- 2.2 Analysis in the AGM model -->

      <h3 id="sec-2.2" class="text-xl font-semibold">
        2.2 Analysis in the AGM Model
      </h3>
      <p class="text-gray-300">
        For security analysis we will use the Algebraic Group Model
        of Fuchsbauer, Kiltz and Loss [FKL18]. In our protocols, by
        an <em>algebraic adversary</em>
        <span class="math">\mathcal&#123;A&#125;</span> in an
        SRS-based protocol we mean a
        <span class="math">\text&#123;poly&#125;(\lambda)</span>-time
        algorithm which satisfies the following: for
        <span class="math">i \in \&#123;1, 2\&#125;</span>,
        whenever
        <span class="math">\mathcal&#123;A&#125;</span> outputs an
        element
        <span class="math">A \in
          \mathbb&#123;G&#125;_i</span>,
        it also outputs a vector
        <span class="math">v</span> over
        <span class="math">\mathbb&#123;F&#125;</span> such that
        <span class="math">A = \langle v, \text&#123;srs&#125;_i
          \rangle</span>.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2.1 (Q-DLOG Assumption)
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            Fix integer <span class="math">Q</span>. The
            <span class="math">Q</span>-DLOG assumption for
            <span class="math">(\mathbb&#123;G&#125;_1,
              \mathbb&#123;G&#125;_2)</span>
            states that given
          </p>
          <div class="math-block">
            [Bootle16]_1, [x]_1, \dots, [x^Q]_1, [Bootle16]_2, [x]_2, \dots,
            [x^Q]_2
          </div>
          <p class="text-sm text-gray-300">
            for uniformly chosen
            <span class="math">x \in
              \mathbb&#123;F&#125;</span>,
            the probability of an efficient
            <span class="math">\mathcal&#123;A&#125;</span>
            outputting <span class="math">x</span> is
            <span class="math">\text&#123;negl&#125;(\lambda)</span>.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 2.2
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            Assume the <span class="math">Q</span>-DLOG for
            <span class="math">(\mathbb&#123;G&#125;_1,
              \mathbb&#123;G&#125;_2)</span>.
            Given an algebraic adversary
            <span class="math">\mathcal&#123;A&#125;</span>
            participating in a protocol with a degree
            <span class="math">Q</span> SRS, the probability of any
            real pairing check passing is larger by at most an
            additive
            <span class="math">\text&#123;negl&#125;(\lambda)</span>
            factor than the probability the corresponding ideal check
            holds.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <strong>Knowledge soundness in the Algebraic Group
          Model:</strong>
        We say a protocol
        <span class="math">\mathcal&#123;P&#125;</span> between a
        prover <span class="math">P</span> and verifier
        <span class="math">V</span> for a relation
        <span class="math">\mathcal&#123;R&#125;</span> has
        <em>knowledge soundness in the Algebraic Group Model</em> if
        there exists an efficient
        <span class="math">E</span> such that the probability of any
        algebraic adversary
        <span class="math">\mathcal&#123;A&#125;</span> winning the
        following game is
        <span class="math">\text&#123;negl&#125;(\lambda)</span>:
      </p>
      <ol class="list-decimal list-inside text-gray-300 ml-4
        space-y-1">
        <li>
          <span class="math">\mathcal&#123;A&#125;</span> chooses
          input <span class="math">x</span> and plays the role of
          <span class="math">P</span> in
          <span class="math">\mathcal&#123;P&#125;</span> with input
          <span class="math">x</span>.
        </li>
        <li>
          <span class="math">E</span>, given access to all of
          <span class="math">\mathcal&#123;A&#125;</span>&rsquo;s
          messages during the protocol (including the coefficients of
          the linear combinations), outputs
          <span class="math">\omega</span>.
        </li>
        <li>
          <span class="math">\mathcal&#123;A&#125;</span> wins if
          <span class="math">V</span> outputs
          <span class="math">\text&#123;acc&#125;</span> at the end
          of the protocol, and
          <span class="math">(x, \omega) \notin
            \mathcal&#123;R&#125;</span>.
        </li>
      </ol>
    </section>

    <!-- ============================================================ -->
    <!-- 3. A BATCHED VERSION OF THE KZG SCHEME                       -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">
        3. A Batched Version of the [KZG10] Scheme
      </h2>
      <p class="text-gray-300">
        Crucial to the efficiency of our protocol is a batched
        version of the [KZG10] polynomial commitment scheme (PCS)
        similar to Appendix C of [MBKM], allowing to query multiple
        committed polynomials at multiple points. We begin by
        defining polynomial commitment schemes in a manner conducive
        to our protocol.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 3.1 (d-polynomial commitment scheme)
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            A <span class="math">d</span>-polynomial commitment
            scheme consists of:
          </p>
          <ul class="list-disc list-inside text-sm text-gray-300
            ml-4 space-y-1">
            <li>
              <span class="math">\text&#123;gen&#125;(d)</span>: a
              randomized algorithm that outputs an SRS
              <span class="math">\text&#123;srs&#125;</span>.
            </li>
            <li>
              <span class="math">\text&#123;com&#125;(f,
                \text&#123;srs&#125;)</span>: given a polynomial
              <span class="math">f \in
                \mathbb&#123;F&#125;_&#123;&lt;
                d&#125;[X]</span>,
              returns a commitment
              <span class="math">\text&#123;cm&#125;</span> to
              <span class="math">f</span>.
            </li>
            <li>
              A public coin protocol
              <span class="math">\text&#123;open&#125;</span>
              between parties
              <span class="math">P_&#123;\text&#123;PC&#125;&#125;</span>
              and
              <span class="math">V_&#123;\text&#123;PC&#125;&#125;</span>.
            </li>
          </ul>
          <p class="text-sm text-gray-300 mt-2">
            Such that:
          </p>
          <ul class="list-disc list-inside text-sm text-gray-300
            ml-4 space-y-1">
            <li>
              <strong>Completeness:</strong> If
              <span class="math">\text&#123;open&#125;</span> is run
              correctly,
              <span class="math">V_&#123;\text&#123;PC&#125;&#125;</span>
              outputs
              <span class="math">\text&#123;acc&#125;</span> with
              probability one.
            </li>
            <li>
              <strong>Knowledge soundness in the algebraic group
                model:</strong> There exists an efficient
              <span class="math">E</span> such that for any
              algebraic adversary the probability of winning the
              knowledge soundness game is
              <span class="math">\text&#123;negl&#125;(\lambda)</span>.
            </li>
          </ul>
        </div>
      </div>

      <!-- 3.1 The PCS -->

      <h3 id="sec-3.1" class="text-xl font-semibold">
        3.1 The PCS
      </h3>
      <p class="text-gray-300">
        We describe the following scheme based on [KZG10, MBKM].
      </p>
      <ol class="list-decimal list-inside text-gray-300 ml-4
        space-y-2">
        <li>
          <span class="math">\text&#123;gen&#125;(d)</span>: choose
          uniform
          <span class="math">x \in
            \mathbb&#123;F&#125;</span>.
          Output
          <span class="math">\text&#123;srs&#125; = ([Bootle16]_1, [x]_1,
            \dots, [x^&#123;d-1&#125;]_1, [Bootle16]_2,
            [x]_2)</span>.
        </li>
        <li>
          <span class="math">\text&#123;com&#125;(f,
            \text&#123;srs&#125;) := [f(x)]_1</span>.
        </li>
        <li>
          The
          <span class="math">\text&#123;open&#125;</span> protocol
          for a single evaluation point
          <span class="math">z</span>:
          <span class="math">V_&#123;\text&#123;PC&#125;&#125;</span>
          sends random
          <span class="math">\gamma \in
            \mathbb&#123;F&#125;</span>.
          <span class="math">P_&#123;\text&#123;PC&#125;&#125;</span>
          computes the polynomial
          <div class="math-block">
            h(X) := \sum_&#123;i=1&#125;^&#123;t&#125;
            \gamma^&#123;i-1&#125; \cdot
            \frac&#123;f_i(X) -
            f_i(z)&#125;&#123;X - z&#125;
          </div>
          and sends
          <span class="math">W := [h(x)]_1</span>.
          <span class="math">V_&#123;\text&#123;PC&#125;&#125;</span>
          outputs
          <span class="math">\text&#123;acc&#125;</span> iff
          <div class="math-block">
            e(F - v, [Bootle16]_2) \cdot e(-W, [x - z]_2) = 1.
          </div>
        </li>
      </ol>
      <p class="text-gray-300">
        The open protocol for multiple evaluation points consists of
        running in parallel the open protocol for each evaluation
        point and applying a generic method for batch randomized
        evaluation of pairing equations.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 3.3
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            Fix positive integer <span class="math">d</span>. There
            is a <span class="math">d</span>-polynomial commitment
            scheme <span class="math">\mathscr&#123;S&#125;</span>
            such that:
          </p>
          <ul class="list-disc list-inside text-sm text-gray-300
            ml-4 space-y-1">
            <li>
              (a) For <span class="math">n \leq d</span> and
              <span class="math">f \in
                \mathbb&#123;F&#125;_&#123;&lt;
                n&#125;[X]</span>,
              computing
              <span class="math">\text&#123;com&#125;(f)</span>
              requires <span class="math">n</span>
              <span class="math">\mathbb&#123;G&#125;_1</span>-exponentiations.
            </li>
            <li>
              (b) The open protocol requires
              <span class="math">\sum_&#123;i \in [t^*]&#125;
                d_i</span>
              <span class="math">\mathbb&#123;G&#125;_1</span>-exponentiations
              of
              <span class="math">P_&#123;\text&#123;PC&#125;&#125;</span>
              and
              <span class="math">t + 2t^* - 2</span>
              <span class="math">\mathbb&#123;G&#125;_1</span>-exponentiations
              and 2 pairings of
              <span class="math">V_&#123;\text&#123;PC&#125;&#125;</span>.
            </li>
          </ul>
        </div>
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 4. IDEALISED LOW-DEGREE PROTOCOLS                            -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">
        4. Idealised Low-Degree Protocols
      </h2>
      <p class="text-gray-300">
        We define a limited type of protocol between a prover and a
        verifier to cleanly capture and abstract the use of a
        polynomial commitment scheme such as [KZG10]. In this
        protocol, the prover sends low-degree polynomials to a third
        trusted party
        <span class="math">\mathcal&#123;I&#125;</span>. The
        verifier may then ask
        <span class="math">\mathcal&#123;I&#125;</span> whether
        certain identities hold between the prover&rsquo;s
        polynomials, and additional predefined polynomials known to
        the verifier.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 4.1 (Polynomial Protocol)
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            Fix positive integers
            <span class="math">d, D, t, \ell</span>. A
            <span class="math">(d, D, t,
              \ell)</span>-polynomial protocol is a multiround
            protocol between a prover
            <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>,
            verifier
            <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>
            and trusted party
            <span class="math">\mathcal&#123;I&#125;</span> that
            proceeds as follows:
          </p>
          <ol class="list-decimal list-inside text-sm text-gray-300
            ml-4 space-y-1 mt-2">
            <li>
              The protocol includes a set of preprocessed polynomials
              <span class="math">g_1, \ldots, g_\ell \in
                \mathbb&#123;F&#125;_&#123;&lt;
                d&#125;[X]</span>.
            </li>
            <li>
              The messages of
              <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>
              are sent to
              <span class="math">\mathcal&#123;I&#125;</span> and
              are of the form
              <span class="math">f \in
                \mathbb&#123;F&#125;_&#123;&lt;
                d&#125;[X]</span>.
            </li>
            <li>
              The messages of
              <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>
              to
              <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>
              are arbitrary.
            </li>
            <li>
              At the end,
              <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>
              asks
              <span class="math">\mathcal&#123;I&#125;</span> if
              certain polynomial identities hold of the form
              <div class="math-block">
                F(X) := G(X, h_1(v_1(X)), \dots,
                h_M(v_M(X))) \equiv 0.
              </div>
            </li>
            <li>
              <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>
              outputs
              <span class="math">\text&#123;acc&#125;</span> if all
              identities hold.
            </li>
          </ol>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 4.3 (Polynomial Protocol for a Relation)
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            Given a relation
            <span class="math">\mathcal&#123;R&#125;</span>, a
            polynomial protocol for
            <span class="math">\mathcal&#123;R&#125;</span> is a
            polynomial protocol with completeness and knowledge
            soundness: there exists an efficient
            <span class="math">E</span> that, given access to the
            messages of
            <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>
            to
            <span class="math">\mathcal&#123;I&#125;</span>, outputs
            <span class="math">\omega</span> such that, for any
            strategy of
            <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>,
            the probability of
            <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>
            accepting while
            <span class="math">(x, \omega) \notin
              \mathcal&#123;R&#125;</span>
            is
            <span class="math">\text&#123;negl&#125;(\lambda)</span>.
          </p>
        </div>
      </div>

      <!-- 4.1 Polynomial protocols on ranges -->

      <h3 id="sec-4.1" class="text-xl font-semibold">
        4.1 Polynomial Protocols on Ranges
      </h3>
      <p class="text-gray-300">
        In our protocol
        <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>
        actually needs to check if certain polynomial equations hold
        on a certain range of input values, rather than as a
        polynomial identity. Motivated by this, for a subset
        <span class="math">S \subset
          \mathbb&#123;F&#125;</span>,
        we define an
        <span class="math">S</span>-ranged polynomial protocol
        identically to a polynomial protocol, except that the
        verifier asks if his identities hold on all points of
        <span class="math">S</span>, rather than identically.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 4.5
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            Let
            <span class="math">\mathcal&#123;P&#125;</span> be an
            <span class="math">S</span>-ranged
            <span class="math">(d, D, t,
              \ell)</span>-polynomial protocol for
            <span class="math">\mathcal&#123;R&#125;</span>. Then we
            can construct a
            <span class="math">(\max\&#123;d, |S|,
              D - |S|\&#125;, D, t + 1,
              \ell + 1)</span>-polynomial protocol
            <span class="math">\mathcal&#123;P&#125;^*</span> for
            <span class="math">\mathcal&#123;R&#125;</span>.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-claim">
        <div class="formal-block-title text-cyan-400">
          Claim 4.6
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            Fix
            <span class="math">F_1, \ldots, F_k \in
              \mathbb&#123;F&#125;_&#123;&lt;
              n&#125;[X]</span>.
            Fix
            <span class="math">Z \in
              \mathbb&#123;F&#125;_&#123;&lt;
              n&#125;[X]</span>.
            Suppose that for some
            <span class="math">i \in [k]</span>,
            <span class="math">Z \nmid F_i</span>. Then:
          </p>
          <ol class="list-decimal list-inside text-sm text-gray-300
            ml-4 space-y-1 mt-2">
            <li>
              e.w.p
              <span class="math">1/|\mathbb&#123;F&#125;|</span>
              over uniform
              <span class="math">a_1, \ldots, a_k \in
                \mathbb&#123;F&#125;</span>,
              <span class="math">Z</span> doesn&rsquo;t divide
              <span class="math">F := \sum_&#123;j=1&#125;^k a_j
                \cdot F_j</span>.
            </li>
            <li>
              Assuming <span class="math">Z</span> decomposes to
              distinct linear factors, e.w.p
              <span class="math">k/|\mathbb&#123;F&#125;|</span>
              over uniform
              <span class="math">a \in
                \mathbb&#123;F&#125;</span>,
              <span class="math">Z</span> doesn&rsquo;t divide
              <span class="math">G := \sum_&#123;j=1&#125;^k
                a^&#123;j-1&#125; \cdot F_j</span>.
            </li>
          </ol>
        </div>
      </div>

      <!-- 4.2 From polynomial protocols to protocols against
           algebraic adversaries -->

      <h3 id="sec-4.2" class="text-xl font-semibold">
        4.2 From Polynomial Protocols to Protocols against
        Algebraic Adversaries
      </h3>
      <p class="text-gray-300">
        We wish to use the polynomial commitment scheme of Section 3
        to compile a polynomial protocol into one with knowledge
        soundness in the algebraic group model. When
        <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>
        sends a polynomial
        <span class="math">f_i</span> to
        <span class="math">\mathcal&#123;I&#125;</span> in
        <span class="math">\mathscr&#123;P&#125;</span>,
        <span class="math">\mathbf&#123;P&#125;</span> sends
        <span class="math">\text&#123;cm&#125;_i =
          \text&#123;com&#125;(f_i)</span>
        to <span class="math">\mathbf&#123;V&#125;</span>.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 4.7
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            Let
            <span class="math">\mathscr&#123;P&#125;</span> be a
            public coin
            <span class="math">(d, D, t,
              \ell)</span>-polynomial protocol for a relation
            <span class="math">\mathscr&#123;R&#125;</span> where
            only one identity is checked by
            <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>.
            Then we can construct a protocol
            <span class="math">\mathscr&#123;P&#125;^*</span> for
            <span class="math">\mathscr&#123;R&#125;</span> with
            knowledge soundness in the Algebraic Group Model under
            <span class="math">2d</span>-DLOG such that:
          </p>
          <ol class="list-decimal list-inside text-sm text-gray-300
            ml-4 space-y-1 mt-2">
            <li>
              The prover
              <span class="math">\mathbf&#123;P&#125;</span> in
              <span class="math">\mathscr&#123;P&#125;^*</span>
              requires
              <span class="math">e(\mathscr&#123;P&#125;)</span>
              <span class="math">\mathbb&#123;G&#125;_1</span>-exponentiations.
            </li>
            <li>
              The total prover communication consists of
              <span class="math">t +
                t^*(\mathscr&#123;P&#125;)</span>
              <span class="math">\mathbb&#123;G&#125;_1</span>
              elements and <span class="math">M</span>
              <span class="math">\mathbb&#123;F&#125;</span>-elements.
            </li>
            <li>
              The verifier
              <span class="math">\mathbf&#123;V&#125;</span>
              requires
              <span class="math">t +
                t^*(\mathscr&#123;P&#125;)</span>
              <span class="math">\mathbb&#123;G&#125;_1</span>-exponentiations,
              two pairings and one evaluation of
              <span class="math">G</span>.
            </li>
          </ol>
        </div>
      </div>

      <p class="text-gray-300">
        <strong>Reducing the number of field elements:</strong>
        An optimization by Mary Maller reduces the number of
        <span class="math">\mathbb&#123;F&#125;</span>-elements in
        the proof from <span class="math">M</span>. The idea is to
        use the <em>linearisation polynomial</em>: instead of sending
        all evaluation values, the prover sends only a subset
        <span class="math">S \subset [M]</span>, and the verifier
        computes the commitment to the linearised polynomial
        <span class="math">F_L</span> using the linearity of
        <span class="math">\text&#123;com&#125;</span>.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 5. POLYNOMIAL PROTOCOLS FOR IDENTIFYING PERMUTATIONS         -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">
        5. Polynomial Protocols for Identifying Permutations
      </h2>
      <p class="text-gray-300">
        At the heart of our universal SNARK is a &ldquo;permutation
        check&rdquo; inspired by the permutation argument originally
        presented by Bayer and Groth [BG12] and its variants in
        [BCC+16, MBKM]. Our main advantage over [MBKM]
        is getting a simpler protocol by working with
        <em>univariate</em> polynomials and multiplicative subgroups.
      </p>
      <p class="text-gray-300">
        We use two integer parameters
        <span class="math">n \leq d</span>. Intuitively,
        <span class="math">n</span> is the degree of the honest
        prover&rsquo;s polynomials, and
        <span class="math">d</span> is the bound we actually enforce
        on malicious provers.
      </p>
      <p class="text-gray-300">
        We assume the existence of a multiplicative subgroup
        <span class="math">H \subset
          \mathbb&#123;F&#125;</span>
        of order <span class="math">n</span> with generator
        <span class="math">\mathbf&#123;g&#125;</span>. For
        <span class="math">i \in [n]</span>, we denote by
        <span class="math">L_i(X)</span> the element of
        <span class="math">\mathbb&#123;F&#125;_&#123;&lt;
          n&#125;[X]</span>
        with
        <span class="math">L_i(\mathbf&#123;g&#125;^i) = 1</span>
        and
        <span class="math">L_i(a) = 0</span> for
        <span class="math">a \in H</span> different from
        <span class="math">\mathbf&#123;g&#125;^i</span>, i.e.
        <span class="math">\&#123;L_i\&#125;_&#123;i \in
          [n]&#125;</span>
        is a Lagrange basis for <span class="math">H</span>.
      </p>

      <div class="formal-block formal-block-claim">
        <div class="formal-block-title text-cyan-400">
          Claim 5.1
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            Fix <span class="math">i \in [n]</span>, and
            <span class="math">Z, Z^* \in
              \mathbb&#123;F&#125;[X]</span>.
            Then
            <span class="math">L_i(a)(Z(a) - Z^*(a)) = 0</span>
            for each <span class="math">a \in H</span> if and only
            if
            <span class="math">Z(\mathbf&#123;g&#125;^i) =
              Z^*(\mathbf&#123;g&#125;^i)</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        For
        <span class="math">f, g \in
          \mathbb&#123;F&#125;_&#123;&lt;
          d&#125;[X]</span>
        and a permutation
        <span class="math">\sigma : [n] \to [n]</span>, we write
        <span class="math">g = \sigma(f)</span> if for each
        <span class="math">i \in [n]</span>,
        <span class="math">g(\mathbf&#123;g&#125;^i) =
          f(\mathbf&#123;g&#125;^&#123;\sigma(i)&#125;)</span>.
        We present a ranged polynomial protocol enabling
        <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>
        to prove that
        <span class="math">g = \sigma(f)</span>.
      </p>
      <p class="text-gray-300">
        <strong>Preprocessed polynomials:</strong>
        <span class="math">S_&#123;\text&#123;ID&#125;&#125; \in
          \mathbb&#123;F&#125;_&#123;&lt;
          n&#125;[X]</span>
        defined by
        <span class="math">S_&#123;\text&#123;ID&#125;&#125;(\mathbf&#123;g&#125;^i)
          = i</span>
        and
        <span class="math">S_\sigma \in
          \mathbb&#123;F&#125;_&#123;&lt;
          n&#125;[X]</span>
        defined by
        <span class="math">S_\sigma(\mathbf&#123;g&#125;^i) =
          \sigma(i)</span>.
      </p>
      <p class="text-gray-300">
        <strong>Protocol:</strong>
      </p>
      <ol class="list-decimal list-inside text-gray-300 ml-4
        space-y-2">
        <li>
          <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>
          chooses random
          <span class="math">\beta, \gamma \in
            \mathbb&#123;F&#125;</span>
          and sends them to
          <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>.
        </li>
        <li>
          Let
          <span class="math">f' := f + \beta \cdot
            S_&#123;\text&#123;ID&#125;&#125; + \gamma</span>,
          <span class="math">g' := g + \beta \cdot S_\sigma +
            \gamma</span>.
        </li>
        <li>
          <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>
          computes
          <span class="math">Z \in
            \mathbb&#123;F&#125;_&#123;&lt;
            n&#125;[X]</span>
          such that
          <span class="math">Z(\mathbf&#123;g&#125;) = 1</span>;
          and for
          <span class="math">i \in \&#123;2, \dots,
            n\&#125;</span>:
          <div class="math-block">
            Z(\mathbf&#123;g&#125;^i) = \prod_&#123;1 \leq j
            &lt; i&#125;
            f'(\mathbf&#123;g&#125;^j) /
            g'(\mathbf&#123;g&#125;^j).
          </div>
        </li>
        <li>
          <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>
          sends <span class="math">Z</span> to
          <span class="math">\mathcal&#123;I&#125;</span>.
        </li>
        <li>
          <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>
          checks if for all
          <span class="math">a \in H</span>:
          (a)
          <span class="math">L_1(a)(Z(a) - 1) = 0</span>,
          and (b)
          <span class="math">Z(a)f'(a) = g'(a)Z(a \cdot
            \mathbf&#123;g&#125;)</span>.
        </li>
      </ol>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 5.2
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            Fix
            <span class="math">f, g \in
              \mathbb&#123;F&#125;_&#123;&lt;
              d&#125;[X]</span>.
            For any strategy of
            <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>,
            the probability of
            <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>
            outputting
            <span class="math">\text&#123;acc&#125;</span> in the
            above protocol when
            <span class="math">g \neq \sigma(f)</span> is
            <span class="math">\text&#123;negl&#125;(\lambda)</span>.
          </p>
        </div>
      </div>

      <!-- 5.1 Checking extended permutations -->

      <h3 id="sec-5.1" class="text-xl font-semibold">
        5.1 Checking &ldquo;Extended&rdquo; Permutations
      </h3>
      <p class="text-gray-300">
        In our protocol, we in fact need to check a permutation
        &ldquo;across&rdquo; the values of several polynomials.
        Suppose we now have multiple polynomials
        <span class="math">f_1, \ldots, f_k \in
          \mathbb&#123;F&#125;_&#123;&lt;
          d&#125;[X]</span>
        and a permutation
        <span class="math">\sigma : [kn] \to [kn]</span>.
        For
        <span class="math">(g_1, \ldots, g_k) \in
          (\mathbb&#123;F&#125;_&#123;&lt;
          d&#125;[X])^k</span>,
        we say that
        <span class="math">(g_1, \ldots, g_k) = \sigma(f_1,
          \ldots, f_k)</span>
        if the corresponding sequences satisfy
        <span class="math">g_&#123;(\ell)&#125; =
          f_&#123;(\sigma(\ell))&#125;</span>
        for each
        <span class="math">\ell \in [kn]</span>.
      </p>
      <p class="text-gray-300">
        The protocol for extended permutations uses the same
        structure as the basic protocol, but with products across all
        <span class="math">k</span> polynomials:
      </p>
      <div class="math-block">
        f'(X) := \prod_&#123;j \in [k]&#125; f'_j(X), \quad
        g'(X) := \prod_&#123;j \in [k]&#125; g'_j(X).
      </div>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 5.3
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            Fix any
            <span class="math">f_1, \ldots, f_k, g_1, \ldots,
              g_k \in \mathbb&#123;F&#125;_&#123;&lt;
              d&#125;[X]</span>
            and permutation <span class="math">\sigma</span> on
            <span class="math">[kn]</span> as inputs to the above
            protocol
            <span class="math">\mathscr&#123;P&#125;_k</span>.
            Suppose that
            <span class="math">(g_1, \ldots, g_k) \neq
              \sigma(f_1, \ldots, f_k)</span>.
            Then, for any strategy of
            <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>,
            the probability of
            <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>
            outputting
            <span class="math">\text&#123;acc&#125;</span> is
            <span class="math">\text&#123;negl&#125;(\lambda)</span>.
          </p>
        </div>
      </div>

      <!-- 5.2 Checking extended copy constraints -->

      <h3 id="sec-5.2" class="text-xl font-semibold">
        5.2 Checking &ldquo;Extended Copy Constraints&rdquo;
        Using a Permutation
      </h3>
      <p class="text-gray-300">
        Let
        <span class="math">\mathcal&#123;T&#125; = \&#123;T_1,
          \ldots, T_s\&#125;</span>
        be a partition of <span class="math">[kn]</span> into
        disjoint blocks. Fix
        <span class="math">f_1, \ldots, f_k \in
          \mathbb&#123;F&#125;_&#123;&lt;
          n&#125;[X]</span>.
        We say that
        <span class="math">f_1, \ldots, f_k</span>
        <em>copy-satisfy</em>
        <span class="math">\mathcal&#123;T&#125;</span> if
        <span class="math">f_&#123;(\ell)&#125; =
          f_&#123;(\ell')&#125;</span>
        whenever
        <span class="math">\ell, \ell'</span> belong to the same
        block of
        <span class="math">\mathcal&#123;T&#125;</span>.
      </p>
      <p class="text-gray-300">
        The above protocol for extended permutations can be directly
        used for checking whether
        <span class="math">f_1, \ldots, f_k</span> satisfy
        <span class="math">\mathcal&#123;T&#125;</span>: define a
        permutation
        <span class="math">\sigma(\mathcal&#123;T&#125;)</span> on
        <span class="math">[kn]</span> such that for each block
        <span class="math">T_i</span>,
        <span class="math">\sigma(\mathcal&#123;T&#125;)</span>
        contains a cycle going over all elements of
        <span class="math">T_i</span>. Then,
        <span class="math">(f_1, \ldots, f_k)</span> copy-satisfy
        <span class="math">\mathcal&#123;T&#125;</span> if and only
        if
        <span class="math">(f_1, \ldots, f_k) = \sigma(f_1,
          \ldots, f_k)</span>.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 6. CONSTRAINT SYSTEMS                                        -->
    <!-- ============================================================ -->

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6. Constraint Systems</h2>
      <p class="text-gray-300">
        Fix positive integers <span class="math">m</span> and
        <span class="math">n</span>. We present a type of constraint
        system that captures fan-in two arithmetic circuits of
        unlimited fan-out with <span class="math">n</span> gates and
        <span class="math">m</span> wires, but is more general.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition (Constraint System)
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            The constraint system
            <span class="math">\mathscr&#123;C&#125; = (V,
              Q)</span>
            is defined as follows:
          </p>
          <ul class="list-disc list-inside text-sm text-gray-300
            ml-4 space-y-1 mt-2">
            <li>
              <span class="math">V = (a, b, c)</span>, where
              <span class="math">a, b, c \in [m]^n</span>. We think
              of
              <span class="math">a, b, c</span> as the left, right
              and output sequence.
            </li>
            <li>
              <span class="math">Q = (q_L, q_R, q_O, q_M,
                q_C) \in
                (\mathbb&#123;F&#125;^n)^5</span>
              where we think of these as &ldquo;selector
              vectors&rdquo;.
            </li>
          </ul>
          <p class="text-sm text-gray-300 mt-2">
            We say
            <span class="math">x \in
              \mathbb&#123;F&#125;^m</span>
            satisfies
            <span class="math">\mathscr&#123;C&#125;</span> if for
            each <span class="math">i \in [n]</span>:
          </p>
          <div class="math-block">
            (q_L)_i \cdot x_&#123;a_i&#125; + (q_R)_i \cdot
            x_&#123;b_i&#125; + (q_O)_i \cdot x_&#123;c_i&#125;
            + (q_M)_i \cdot (x_&#123;a_i&#125; x_&#123;b_i&#125;)
            + (q_C)_i = 0.
          </div>
        </div>
      </div>

      <p class="text-gray-300">
        <strong>Arithmetic circuits:</strong> A fan-in 2 circuit of
        <span class="math">n</span> gates can be captured: set
        <span class="math">a_i, b_i, c_i</span> to be the indices
        of left/right/output wires of the
        <span class="math">i</span>&rsquo;th gate. For
        multiplication gates, set
        <span class="math">(q_M)_i = 1, (q_O)_i = -1</span>,
        others zero. For addition gates, set
        <span class="math">(q_L)_i = 1, (q_R)_i = 1,
          (q_O)_i = -1</span>,
        others zero.
      </p>
      <p class="text-gray-300">
        <strong>Booleanity constraints:</strong> To enforce
        <span class="math">x_j \in \&#123;0, 1\&#125;</span>, set
        <span class="math">a_i = b_i = j, (q_L)_i = -1,
          (q_M)_i = 1</span>,
        others zero.
      </p>
      <p class="text-gray-300">
        <strong>Enforcing constants:</strong> To enforce
        <span class="math">x_j = a</span>, set
        <span class="math">(q_L)_i = 1, (q_C)_i = -a</span>,
        others zero.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 7. MAIN PROTOCOL                                             -->
    <!-- ============================================================ -->

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">7. Main Protocol</h2>
      <p class="text-gray-300">
        Let
        <span class="math">\mathscr&#123;C&#125; = (V, Q)</span> be
        a constraint system of the form described in Section 6. We
        present our main protocol for the relation
        <span class="math">\mathcal&#123;R&#125;_&#123;\mathscr&#123;C&#125;&#125;</span>.
        Define the <em>partition of
        <span class="math">\mathscr&#123;C&#125;</span></em>,
        denoted
        <span class="math">\mathcal&#123;T&#125;_&#123;\mathscr&#123;C&#125;&#125;</span>,
        as follows: suppose
        <span class="math">V = (a, b, c)</span>; think of
        <span class="math">V</span> as a vector in
        <span class="math">[m]^&#123;3n&#125;</span>. For
        <span class="math">i \in [m]</span>, let
        <span class="math">T_i \subset [3n]</span> be the set of
        indices <span class="math">j</span> with
        <span class="math">V_j = i</span>. Now define
        <span class="math">\mathcal&#123;T&#125;_&#123;\mathscr&#123;C&#125;&#125;
          := \&#123;T_i\&#125;_&#123;i \in [m]&#125;</span>.
      </p>
      <p class="text-gray-300">
        <strong>Preprocessing:</strong> Let
        <span class="math">\sigma =
          \sigma(\mathcal&#123;T&#125;_&#123;\mathscr&#123;C&#125;&#125;)</span>.
        The polynomials
        <span class="math">S_&#123;\text&#123;ID&#125;1&#125;,
          S_&#123;\text&#123;ID&#125;2&#125;,
          S_&#123;\text&#123;ID&#125;3&#125;,
          S_&#123;\sigma 1&#125;,
          S_&#123;\sigma 2&#125;,
          S_&#123;\sigma 3&#125;</span>
        as defined in subsection 5.1. Also, the selector polynomials
        <span class="math">q_L, q_R, q_O, q_M, q_C \in
          \mathbb&#123;F&#125;_&#123;&lt;
          n&#125;[X]</span>.
      </p>
      <p class="text-gray-300">
        <strong>Protocol:</strong>
      </p>
      <ol class="list-decimal list-inside text-gray-300 ml-4
        space-y-2">
        <li>
          <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>
          computes the three polynomials
          <span class="math">f_L, f_R, f_O \in
            \mathbb&#123;F&#125;_&#123;&lt;
            n&#125;[X]</span>,
          where for <span class="math">i \in [n]</span>:
          <span class="math">f_L(\mathbf&#123;g&#125;^i) =
            x_&#123;a_i&#125;</span>,
          <span class="math">f_R(\mathbf&#123;g&#125;^i) =
            x_&#123;b_i&#125;</span>,
          <span class="math">f_O(\mathbf&#123;g&#125;^i) =
            x_&#123;c_i&#125;</span>.
          Sends
          <span class="math">f_L, f_R, f_O</span> to
          <span class="math">\mathcal&#123;I&#125;</span>.
        </li>
        <li>
          Run the extended permutation check between
          <span class="math">(f_L, f_R, f_O)</span> and itself using
          <span class="math">\sigma</span>. This checks whether
          <span class="math">(f_L, f_R, f_O)</span> copy-satisfies
          <span class="math">\mathcal&#123;T&#125;_&#123;\mathscr&#123;C&#125;&#125;</span>.
        </li>
        <li>
          <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>
          computes the public input polynomial
          <span class="math">\text&#123;PI&#125;(X) :=
            \sum_&#123;i \in [\ell]&#125; -x_i \cdot
            L_i(X)</span>.
        </li>
        <li>
          <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>
          checks the identity on
          <span class="math">H</span>:
          <div class="math-block">
            q_L \cdot f_L + q_R \cdot f_R + q_O \cdot f_O + q_M
            \cdot f_L \cdot f_R + (q_C +
            \text&#123;PI&#125;) = 0.
          </div>
        </li>
      </ol>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Theorem 7.1
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            The above protocol is an
            <span class="math">H</span>-ranged polynomial protocol
            for the relation
            <span class="math">\mathcal&#123;R&#125;_&#123;\mathscr&#123;C&#125;&#125;</span>.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Corollary 7.2
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            Let
            <span class="math">\mathscr&#123;C&#125;</span> be a
            constraint system with parameter
            <span class="math">n</span>. There is a protocol for
            <span class="math">\mathcal&#123;R&#125;_&#123;\mathscr&#123;C&#125;&#125;</span>
            with Knowledge Soundness in the Algebraic Group Model
            such that:
          </p>
          <ol class="list-decimal list-inside text-sm text-gray-300
            ml-4 space-y-1 mt-2">
            <li>
              The prover
              <span class="math">\mathbf&#123;P&#125;</span>
              requires
              <span class="math">11n + 1</span>
              <span class="math">\mathbb&#123;G&#125;_1</span>-exponentiations.
            </li>
            <li>
              The total prover communication consists of 7
              <span class="math">\mathbb&#123;G&#125;_1</span>-elements
              and 7
              <span class="math">\mathbb&#123;F&#125;</span>-elements.
            </li>
          </ol>
        </div>
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 8. THE FINAL PROTOCOL, ROLLED OUT                            -->
    <!-- ============================================================ -->

    <section id="sec-8" class="mb-10">
      <h2 class="text-2xl font-bold">
        8. The Final Protocol, Rolled Out
      </h2>
      <p class="text-gray-300">
        For the reader&rsquo;s convenience we present the full final
        protocol. A few preliminary notes:
      </p>
      <ul class="list-disc list-inside text-gray-300 ml-4
        space-y-2">
        <li>
          <strong>Zero-knowledge:</strong> Adding zero-knowledge is
          implemented by adding random multiples of
          <span class="math">Z_H</span> to the prover polynomials,
          and requiring the verifier to send challenges in
          <span class="math">\mathbb&#123;F&#125; \setminus
            H</span>.
        </li>
        <li>
          <strong>Multiplicative subgroup:</strong> We explicitly
          define <span class="math">H</span> as containing the
          <span class="math">n</span>&rsquo;th roots of unity in
          <span class="math">\mathbb&#123;F&#125;</span>, where
          <span class="math">\omega</span> is a primitive
          <span class="math">n</span>&rsquo;th root of unity and
          generator of <span class="math">H</span>, i.e.
          <span class="math">H = \&#123;1, \omega, \dots,
            \omega^&#123;n-1&#125;\&#125;</span>.
        </li>
        <li>
          <strong>Identity permutation optimization:</strong> An
          optimization by Vitalik Buterin represents the identity
          permutation via degree-1 polynomials, reducing proof size
          by one field element.
        </li>
        <li>
          <strong>Non-interactive via Fiat-Shamir:</strong> We use
          <span class="math">\mathcal&#123;H&#125;</span> to refer
          to an efficiently computable hash function for obtaining a
          non-interactive version of our protocol.
        </li>
      </ul>

      <!-- 8.1 Polynomials that define a specific circuit -->

      <h3 id="sec-8.1" class="text-xl font-semibold">
        8.1 Polynomials that Define a Specific Circuit
      </h3>
      <p class="text-gray-300">
        The following polynomials, along with integer
        <span class="math">n</span>, uniquely define our circuit:
      </p>
      <ul class="list-disc list-inside text-gray-300 ml-4
        space-y-1">
        <li>
          <span class="math">q_M(X), q_L(X), q_R(X), q_O(X),
            q_C(X)</span>: the selector polynomials that define the
          circuit&rsquo;s arithmetisation.
        </li>
        <li>
          <span class="math">S_&#123;\text&#123;ID&#125;1&#125;(X) =
            X</span>,
          <span class="math">S_&#123;\text&#123;ID&#125;2&#125;(X) =
            k_1 X</span>,
          <span class="math">S_&#123;\text&#123;ID&#125;3&#125;(X) =
            k_2 X</span>:
          the identity permutation applied to
          <span class="math">a, b, c</span>.
          <span class="math">k_1, k_2 \in
            \mathbb&#123;F&#125;</span>
          are chosen such that
          <span class="math">H, k_1 \cdot H, k_2 \cdot H</span>
          are distinct cosets of <span class="math">H</span>.
        </li>
        <li>
          <span class="math">S_&#123;\sigma 1&#125;(X),
            S_&#123;\sigma 2&#125;(X),
            S_&#123;\sigma 3&#125;(X)</span>:
          the three permutation polynomials encoding
          <span class="math">\sigma^*</span>.
        </li>
      </ul>

      <!-- 8.2 The SNARK proof relation -->

      <h3 id="sec-8.2" class="text-xl font-semibold">
        8.2 The SNARK Proof Relation
      </h3>
      <p class="text-gray-300">
        Given
        <span class="math">\ell \leq n</span> and fixed values for
        the above polynomials, we wish to prove statements of
        knowledge for the relation
        <span class="math">\mathcal&#123;R&#125; \subset
          \mathbb&#123;F&#125;^\ell \times
          \mathbb&#123;F&#125;^&#123;3n - \ell&#125;</span>
        containing all pairs
        <span class="math">x = (w_i)_&#123;i \in [\ell]&#125;,
          w = (w_i)_&#123;i = \ell+1&#125;^&#123;3n&#125;</span>
        such that:
      </p>
      <ol class="list-decimal list-inside text-gray-300 ml-4
        space-y-2">
        <li>
          For all <span class="math">i \in [n]</span>:
          <div class="math-block">
            q_&#123;Mi&#125; w_i w_&#123;n+i&#125; +
            q_&#123;Li&#125; w_i + q_&#123;Ri&#125;
            w_&#123;n+i&#125; + q_&#123;Oi&#125;
            w_&#123;2n+i&#125; + q_&#123;Ci&#125; = 0.
          </div>
        </li>
        <li>
          For all
          <span class="math">i \in [3n]</span>:
          <span class="math">w_i = w_&#123;\sigma(i)&#125;</span>.
        </li>
      </ol>

      <!-- 8.3 The protocol -->

      <h3 id="sec-8.3" class="text-xl font-semibold">
        8.3 The Protocol
      </h3>
      <p class="text-gray-300">
        The protocol is described as a non-interactive protocol using
        the Fiat-Shamir heuristic. We always denote by
        <span class="math">\text&#123;transcript&#125;</span> the
        concatenation of the common preprocessed input, public input,
        and proof elements written by the prover up to a certain
        point.
      </p>

      <h4 class="text-lg font-semibold mt-4 text-gray-200">
        Round 1
      </h4>
      <p class="text-gray-300">
        Generate random blinding scalars
        <span class="math">(b_1, \ldots, b_9) \in
          \mathbb&#123;F&#125;</span>.
        Compute wire polynomials:
      </p>
      <div class="math-block">
        a(X) = (b_1 X + b_2) Z_H(X) + \sum_&#123;i=1&#125;^n w_i
        L_i(X)
      </div>
      <div class="math-block">
        b(X) = (b_3 X + b_4) Z_H(X) + \sum_&#123;i=1&#125;^n
        w_&#123;n+i&#125; L_i(X)
      </div>
      <div class="math-block">
        c(X) = (b_5 X + b_6) Z_H(X) + \sum_&#123;i=1&#125;^n
        w_&#123;2n+i&#125; L_i(X)
      </div>
      <p class="text-gray-300">
        Compute
        <span class="math">[a]_1 := [a(x)]_1</span>,
        <span class="math">[b]_1 := [b(x)]_1</span>,
        <span class="math">[c]_1 := [c(x)]_1</span>.
        First output of
        <span class="math">P</span> is
        <span class="math">([a]_1, [b]_1, [c]_1)</span>.
      </p>

      <h4 class="text-lg font-semibold mt-4 text-gray-200">
        Round 2
      </h4>
      <p class="text-gray-300">
        Compute permutation challenges
        <span class="math">\beta =
          \mathcal&#123;H&#125;(\text&#123;transcript&#125;,
          0)</span>,
        <span class="math">\gamma =
          \mathcal&#123;H&#125;(\text&#123;transcript&#125;,
          1)</span>.
        Compute the permutation polynomial
        <span class="math">z(X)</span> using blinding scalars
        <span class="math">(b_7, b_8, b_9)</span> and the
        accumulated product of the ratios of the wire values shifted
        by the permutation challenges.
        Second output of
        <span class="math">P</span> is
        <span class="math">([z]_1)</span>.
      </p>

      <h4 class="text-lg font-semibold mt-4 text-gray-200">
        Round 3
      </h4>
      <p class="text-gray-300">
        Compute quotient challenge
        <span class="math">\alpha =
          \mathcal&#123;H&#125;(\text&#123;transcript&#125;)</span>.
        Compute quotient polynomial
        <span class="math">t(X)</span> which encodes all
        constraints divided by
        <span class="math">Z_H(X)</span>:
      </p>
      <div class="math-block">
        t(X) = \frac&#123;1&#125;&#123;Z_H(X)&#125; \Big[
        a(X)b(X)q_M(X) + a(X)q_L(X) + b(X)q_R(X) + c(X)q_O(X)
        + \text&#123;PI&#125;(X) + q_C(X) \Big]
      </div>
      <div class="math-block">
        + \frac&#123;\alpha&#125;&#123;Z_H(X)&#125; \Big[
        (a(X) + \beta X + \gamma)(b(X) + \beta k_1 X +
        \gamma)(c(X) + \beta k_2 X + \gamma) z(X)
      </div>
      <div class="math-block">
        - (a(X) + \beta S_&#123;\sigma 1&#125;(X) + \gamma)(b(X)
        + \beta S_&#123;\sigma 2&#125;(X) + \gamma)(c(X) + \beta
        S_&#123;\sigma 3&#125;(X) + \gamma) z(X\omega) \Big]
      </div>
      <div class="math-block">
        + \frac&#123;\alpha^2&#125;&#123;Z_H(X)&#125;
        (z(X) - 1) L_1(X)
      </div>
      <p class="text-gray-300">
        Split <span class="math">t(X)</span> into degree
        <span class="math">&lt; n</span> polynomials
        <span class="math">t_&#123;\text&#123;lo&#125;&#125;(X),
          t_&#123;\text&#123;mid&#125;&#125;(X),
          t_&#123;\text&#123;hi&#125;&#125;(X)</span>
        such that
        <span class="math">t(X) =
          t_&#123;\text&#123;lo&#125;&#125;(X) + X^n
          t_&#123;\text&#123;mid&#125;&#125;(X) + X^&#123;2n&#125;
          t_&#123;\text&#123;hi&#125;&#125;(X)</span>.
        Third output of
        <span class="math">P</span> is
        <span class="math">([t_&#123;\text&#123;lo&#125;&#125;]_1,
          [t_&#123;\text&#123;mid&#125;&#125;]_1,
          [t_&#123;\text&#123;hi&#125;&#125;]_1)</span>.
      </p>

      <h4 class="text-lg font-semibold mt-4 text-gray-200">
        Round 4
      </h4>
      <p class="text-gray-300">
        Compute evaluation challenge
        <span class="math">\mathfrak&#123;z&#125; =
          \mathcal&#123;H&#125;(\text&#123;transcript&#125;)</span>.
        Compute opening evaluations:
      </p>
      <div class="math-block">
        \bar&#123;a&#125; = a(\mathfrak&#123;z&#125;), \quad
        \bar&#123;b&#125; = b(\mathfrak&#123;z&#125;), \quad
        \bar&#123;c&#125; = c(\mathfrak&#123;z&#125;), \quad
        \bar&#123;s&#125;_&#123;\sigma 1&#125; =
        S_&#123;\sigma 1&#125;(\mathfrak&#123;z&#125;), \quad
        \bar&#123;s&#125;_&#123;\sigma 2&#125; =
        S_&#123;\sigma 2&#125;(\mathfrak&#123;z&#125;), \quad
        \bar&#123;z&#125;_\omega =
        z(\mathfrak&#123;z&#125;\omega)
      </div>
      <p class="text-gray-300">
        Fourth output of
        <span class="math">P</span> is
        <span class="math">(\bar&#123;a&#125;, \bar&#123;b&#125;,
          \bar&#123;c&#125;,
          \bar&#123;s&#125;_&#123;\sigma 1&#125;,
          \bar&#123;s&#125;_&#123;\sigma 2&#125;,
          \bar&#123;z&#125;_\omega)</span>.
      </p>

      <h4 class="text-lg font-semibold mt-4 text-gray-200">
        Round 5
      </h4>
      <p class="text-gray-300">
        Compute opening challenge
        <span class="math">v =
          \mathcal&#123;H&#125;(\text&#123;transcript&#125;)</span>.
        Compute linearisation polynomial
        <span class="math">r(X)</span> and opening proof
        polynomials
        <span class="math">W_&#123;\mathfrak&#123;z&#125;&#125;(X)</span>
        and
        <span class="math">W_&#123;\mathfrak&#123;z&#125;\omega&#125;(X)</span>.
      </p>
      <p class="text-gray-300">
        The final output is:
      </p>
      <div class="math-block">
        \pi_&#123;\text&#123;SNARK&#125;&#125; = \Big(
        [a]_1, [b]_1, [c]_1, [z]_1,
        [t_&#123;\text&#123;lo&#125;&#125;]_1,
        [t_&#123;\text&#123;mid&#125;&#125;]_1,
        [t_&#123;\text&#123;hi&#125;&#125;]_1,
        [W_&#123;\mathfrak&#123;z&#125;&#125;]_1,
        [W_&#123;\mathfrak&#123;z&#125;\omega&#125;]_1,
        \bar&#123;a&#125;, \bar&#123;b&#125;, \bar&#123;c&#125;,
        \bar&#123;s&#125;_&#123;\sigma 1&#125;,
        \bar&#123;s&#125;_&#123;\sigma 2&#125;,
        \bar&#123;z&#125;_\omega \Big)
      </div>
      <p class="text-gray-300">
        Compute multipoint evaluation challenge
        <span class="math">u =
          \mathcal&#123;H&#125;(\text&#123;transcript&#125;)</span>.
      </p>

      <h4 class="text-lg font-semibold mt-4 text-gray-200">
        Verifier Algorithm
      </h4>
      <p class="text-gray-300">
        The verifier algorithm proceeds as follows:
      </p>
      <ol class="list-decimal list-inside text-gray-300 ml-4
        space-y-2">
        <li>
          Validate all
          <span class="math">\mathbb&#123;G&#125;_1</span> elements
          and field elements.
        </li>
        <li>
          Compute challenges
          <span class="math">\beta, \gamma, \alpha,
            \mathfrak&#123;z&#125;, v, u \in
            \mathbb&#123;F&#125;</span>.
        </li>
        <li>
          Compute zero polynomial evaluation
          <span class="math">Z_H(\mathfrak&#123;z&#125;) =
            \mathfrak&#123;z&#125;^n - 1</span>.
        </li>
        <li>
          Compute Lagrange polynomial evaluation
          <span class="math">L_1(\mathfrak&#123;z&#125;) =
            \frac&#123;\omega(\mathfrak&#123;z&#125;^n - 1)&#125;&#123;n(\mathfrak&#123;z&#125; - \omega)&#125;</span>.
        </li>
        <li>
          Compute public input polynomial evaluation
          <span class="math">\text&#123;PI&#125;(\mathfrak&#123;z&#125;)</span>.
        </li>
        <li>
          Compute <span class="math">r</span>&rsquo;s constant
          term <span class="math">r_0</span> and the non-constant
          part <span class="math">r'(X) := r(X) - r_0</span>.
        </li>
        <li>
          Compute first part of batched polynomial commitment
          <span class="math">[D]_1</span> incorporating the
          linearisation.
        </li>
        <li>
          Compute full batched polynomial commitment
          <span class="math">[F]_1</span>:
          <div class="math-block">
            [F]_1 := [D]_1 + v \cdot [a]_1 + v^2 \cdot [b]_1
            + v^3 \cdot [c]_1 + v^4 \cdot
            [s_&#123;\sigma 1&#125;]_1 + v^5 \cdot
            [s_&#123;\sigma 2&#125;]_1
          </div>
        </li>
        <li>
          Compute group-encoded batch evaluation
          <span class="math">[E]_1</span>.
        </li>
        <li>
          Batch validate all evaluations via a single pairing check:
          <div class="math-block">
            e([W_&#123;\mathfrak&#123;z&#125;&#125;]_1 + u \cdot
            [W_&#123;\mathfrak&#123;z&#125;\omega&#125;]_1,
            [x]_2) \stackrel&#123;?&#125;&#123;=&#125;
            e(\mathfrak&#123;z&#125; \cdot
            [W_&#123;\mathfrak&#123;z&#125;&#125;]_1 +
            u\mathfrak&#123;z&#125;\omega \cdot
            [W_&#123;\mathfrak&#123;z&#125;\omega&#125;]_1 +
            [F]_1 - [E]_1, [Bootle16]_2)
          </div>
        </li>
      </ol>
    </section>

    <!-- ============================================================ -->
    <!-- ACKNOWLEDGEMENTS                                             -->
    <!-- ============================================================ -->

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgements</h2>
      <p class="text-gray-300">
        The authors thank Mary Maller for the field element reduction
        method (end of Section 4), Vitalik Buterin for suggesting the
        identity permutation be defined using degree-1 polynomials,
        Swastik Kopparty for pointing out an error in the permutation
        argument whose correction led to improved performance, and
        Justin Drake and Konstantin Panarin for discussions leading
        to corrections and simplifications. They also thank Sean Bowe
        for noticing the public inputs were not being hashed in the
        original Fiat-Shamir description, along with many other
        contributors for comments and corrections.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ul class="text-sm text-gray-400 space-y-2">
        <li>
          [BCC+16] Bootle, Cerulli, Chaidos, Groth,
          Petit.
          <em>Efficient zero-knowledge arguments for arithmetic
            circuits in the discrete log setting</em>.
          pp. 327&ndash;357, 2016.
        </li>
        <li>
          [BCR+19] Ben-Sasson, Chiesa, Riabzev, Spooner,
          Virza, Ward.
          <em>Aurora: Transparent succinct arguments for
            R1CS</em>.
          EUROCRYPT 2019, Part I, pp. 103&ndash;128.
        </li>
        <li>
          [BDFG20] Boneh, Drake, Fisch, Gabizon.
          <em>Halo infinite: Recursive zksnarks from any additive
            polynomial commitment scheme</em>.
          IACR Cryptol. ePrint Arch., 2020/1536.
        </li>
        <li>
          [BG12] Bayer, Groth.
          <em>Efficient zero-knowledge argument for correctness of
            a shuffle</em>.
          EUROCRYPT 2012, pp. 263&ndash;280.
        </li>
        <li>
          [BGM17] Bowe, Gabizon, Miers.
          <em>Scalable multi-party computation for zksnark
            parameters in the random beacon model</em>.
          <a
            href="https://eprint.iacr.org/2017/1050"
            target="_blank"
            rel="noopener noreferrer"
          >eprint 2017/1050</a>.
          <a href="/papers/scalable-mpc-zksnark-2017"
            class="text-blue-400 hover:text-blue-300">
            [page on this site]</a>
        </li>
        <li>
          [CHM+19] Chiesa, Hu, Maller, Mishra, Vesely,
          Ward.
          <em>Marlin: Preprocessing zksnarks with universal and
            updatable SRS</em>.
          IACR ePrint 2019:1047.
        </li>
        <li>
          [COS19] Chiesa, Ojha, Spooner.
          <em>Fractal: Post-quantum and transparent recursive
            proofs from holography</em>.
          IACR ePrint 2019:1076.
        </li>
        <li>
          [CS10] Costello, Stebila.
          <em>Fixed argument pairings</em>.
          LATINCRYPT 2010, pp. 92&ndash;108.
        </li>
        <li>
          [FKL18] Fuchsbauer, Kiltz, Loss.
          <em>The algebraic group model and its
            applications</em>.
          CRYPTO 2018, Part II, pp. 33&ndash;62.
        </li>
        <li>
          [Gab19] Gabizon.
          <em>Auroralight: improved prover efficiency and SRS size
            in a sonic-like system</em>.
          IACR ePrint 2019:601.
          <a href="/papers/auroralight-2019"
            class="text-blue-400 hover:text-blue-300">
            [page on this site]</a>
        </li>
        <li>
          [GGPR13] Gennaro, Gentry, Parno, Raykova.
          <em>Quadratic span programs and succinct nizks without
            pcps</em>.
          EUROCRYPT 2013, pp. 626&ndash;645.
        </li>
        <li>
          [GKM+] Groth, Kohlweiss, Maller, Meiklejohn,
          Miers.
          <em>Updatable and universal common reference strings with
            applications to zk-snarks</em>.
          IACR ePrint 2018.
        </li>
        <li>
          [Gro16] Groth.
          <em>On the size of pairing-based non-interactive
            arguments</em>.
          EUROCRYPT 2016, Part II, pp. 305&ndash;326.
        </li>
        <li>
          [KZG10] Kate, Zaverucha, Goldberg.
          <em>Constant-size commitments to polynomials and their
            applications</em>.
          pp. 177&ndash;194, 2010.
        </li>
        <li>
          [MBKM] Maller, Bowe, Kohlweiss, Meiklejohn.
          <em>Sonic: Zero-knowledge snarks from linear-size
            universal and updateable structured reference
            strings</em>.
          <a
            href="https://eprint.iacr.org/2019/099"
            target="_blank"
            rel="noopener noreferrer"
          >eprint 2019/099</a>.
        </li>
        <li>
          [Set] Setty.
          <em>Spartan: Efficient and general-purpose zkSNARKs
            without trusted setup</em>.
          <a
            href="https://eprint.iacr.org/2019/550"
            target="_blank"
            rel="noopener noreferrer"
          >eprint 2019/550</a>.
          <a href="/papers/spartan-2019"
            class="text-blue-400 hover:text-blue-300">
            [page on this site]</a>
        </li>
      </ul>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX A: CLAIMS FOR PERMUTATION ARGUMENT                  -->
    <!-- ============================================================ -->

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix A: Claims for Permutation Argument
      </h2>
      <p class="text-gray-300">
        The following claim is crucial for the correctness of the
        protocols in Section 5.
      </p>

      <div class="formal-block formal-block-claim">
        <div class="formal-block-title text-cyan-400">
          Claim A.1
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            Fix any permutation
            <span class="math">\sigma</span> of
            <span class="math">[n]</span>, and any
            <span class="math">a_1, \ldots, a_n, b_1, \ldots,
              b_n \in \mathbb&#123;F&#125;</span>.
            If
          </p>
          <div class="math-block">
            \prod_&#123;i \in [n]&#125; (a_i + \beta \cdot i +
            \gamma) = \prod_&#123;i \in [n]&#125; (b_i + \beta
            \cdot \sigma(i) + \gamma)
          </div>
          <p class="text-sm text-gray-300">
            with probability larger than
            <span class="math">n / |\mathbb&#123;F&#125;|</span>
            over uniform
            <span class="math">\beta, \gamma \in
              \mathbb&#123;F&#125;</span>;
            then
            <span class="math">b_i =
              a_&#123;\sigma(i)&#125;</span>
            for all <span class="math">i \in [n]</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof</em> (by Tohru Kohrita). By Schwartz-Zippel and
        the assumption of the claim, the following equality of
        polynomials holds in
        <span class="math">\mathbb&#123;F&#125;[X, Y]</span>:
      </p>
      <div class="math-block">
        \prod_&#123;i=1&#125;^&#123;n&#125; (a_i + iX + Y) \equiv
        \prod_&#123;i=1&#125;^&#123;n&#125; (b_i + \sigma(i)X + Y).
      </div>
      <p class="text-gray-300">
        Since
        <span class="math">\mathbb&#123;F&#125;[X, Y]</span> is a
        unique factorization domain where the invertible elements are
        exactly
        <span class="math">\mathbb&#123;F&#125;^*</span>, and the
        linear factors are irreducible, there must be a one-to-one
        map between the factors of each side that maps a factor on
        the LHS to one on the RHS with the same coefficient for
        <span class="math">X</span>. Since the coefficient of
        <span class="math">Y</span> in all terms is one, the
        constant must be 1. Thus, for all
        <span class="math">i \in [n]</span>:
      </p>
      <div class="math-block">
        a_&#123;\sigma(i)&#125; + \sigma(i)X + Y \equiv b_i +
        \sigma(i)X + Y.
      </div>
      <p class="text-gray-300">
        Therefore
        <span class="math">b_i =
          a_&#123;\sigma(i)&#125;</span>
        for all <span class="math">i \in [n]</span>.
      </p>
    </section>

  </article>
</BaseLayout>
