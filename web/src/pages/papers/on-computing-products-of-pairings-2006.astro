---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2006/172';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
---

<BaseLayout title="On Computing Products of Pairings (2006/172)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        On Computing Products of Pairings
      </h1>
      <p class="text-gray-400 mb-2">
        R Granger, N. P.  Smart
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2006 &middot; Full Version &middot; eprint 2006/172
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
        &middot; 99s on modal (Tesla T4)
        &middot; sha256:2f5e1ddf7dca5e7c...
      </p>
    </header>

    <section class="paper-content">
      <p class="text-gray-300">R. Granger and N.P. Smart</p>
      <p class="text-gray-300">Dept. Computer Science, Merchant Venturers Building, Woodland Road, Bristol, BS8 1UB, United Kingdom. &#123;granger,nigel&#125;@cs.bris.ac.uk</p>
      <p class="text-gray-300">Abstract. In many pairing-based protocols often the evaluation of the product of many pairing evaluations is required. In this paper we consider methods to compute such products efficiently. Focusing on pairingfriendly fields in particular, we evaluate methods for the Weil, Tate and Ate pairing algorithms for ordinary elliptic curves at various security levels. Our operation counts indicate that the minimal cost of each additional pairing relative to the cost of one is ≈ 0.61, 0.45, and 0.43, for each of these pairings respectively at the 128-bit security level. For larger security levels the Ate pairing can have a relative additional cost of as low as 0.13 for each additional pairing.</p>
      <p class="text-gray-300">These estimates allow implementors to make optimal algorithm choices for given scenarios, in which the number of pairings in the product, the security level, and the embedding degree are factors under consideration.</p>
      <p class="text-gray-300">Let tˆ : G<sup>1</sup> × G<sup>2</sup> −→ G<sup>T</sup> be a non-degenerate bilinear map (or simply pairing) from additive groups G<sup>1</sup> and G<sup>2</sup> to a multiplicative group G<sup>T</sup> , all of prime order r. In some protocols the evaluation of products of the form</p>
      <div class="math-block">e = \prod_&#123;i=1&#125;^&#123;n&#125; \hat&#123;t&#125;(P_i, Q_i) \tag&#123;1&#125;</div>
      <p class="text-gray-300">is required. For example, in the BBG HIBE scheme [7] ones needs to compute a ratio of two pairings (such a ratio can be computed via a product of two pairings in a trivial manner), in the BBS short group signature scheme [8] one needs at one point to compute a product of three pairings, in the Water's [21] IBE scheme extended to an l-level HIBE or WIBE [1] requires an evaluation of a product of l + 1 pairing values, in a number of ID-based key distribution protocols one needs to compute a product of two pairing values [9]. A common question asked amongst protocol designers therefore is how efficiently can such a product be computed?</p>
      <p class="text-gray-300">A naive way to compute e is to evaluate each tˆ(P<sup>i</sup> , Qi) independently, and then multiply the results. However, since only the entire product is required, and not each individual pairing evaluation, one is free to apply more efficient methods.</p>
      <p class="text-gray-300">All pairing evaluation algorithms currently employed in cryptography are based on elliptic curves, and so make use of Miller's algorithm [18], which can be used to compute both the Weil and Tate pairings and their variants [5, 13, 4]. The algorithm consists of a sequence of elementary operations, or 'Miller operations', which are function-evaluation steps very similar to a point doubling or addition on the Jacobian under consideration. Depending on the pairing being computed, after either one or two such Miller operations are performed, and possibly a final powering depending on the type of pairing computed.</p>
      <p class="text-gray-300">For example, to compute the reduced Tate pairing of points P and Q on an ordinary elliptic curve with even embedding degree, the function-evaluation step for doubling is simply</p>
      <div class="math-block">f \leftarrow f^2 \cdot l(Q),</div>
      <p class="text-gray-300">where l is the tangent line to the curve at a point, depending on P and the loop iteration in Miller's algorithm. In (1) there are n such terms f<sup>i</sup> , and by using a single accumulator f for their product, initialised to 1, each doubling function-evaluation step becomes</p>
      <div class="math-block">f \leftarrow f^2 \cdot \prod_&#123;i=1&#125;^n l_i(Q_i). \tag&#123;2&#125;</div>
      <p class="text-gray-300">Therefore one needs only compute a single squaring in the extension field per doubling, rather than n squarings as with the naive method. By the same argument, in this example one can also trivially combine the final powerings required in each pairing evaluation in (1). Thus the basic idea to improve efficiency is to compute only once those operations common to each pairing evaluation.</p>
      <p class="text-gray-300">In the general scenario, the main question to consider in computing products of a particular pairing is to what extent can one improve upon the naive method? In this note we make some simple observations, previously made by Scott [19], that attempt to answer this question, for the Weil and Tate pairings, and also the recently defined Tate pairing variant, the Ate [15] pairing. The methods we use are contained in [19], our aim is however to quantify the efficiency gain one achieves for different security levels and different types of pairings.</p>
      <p class="text-gray-300">Following their introduction by Koblitz and Menezes [16], we focus throughout on pairing-friendly fields, since these allow for many optimisations, and have various practical benefits [14]. Furthermore, in order to gain a real idea of how these improvements perform, we also consider several practical security levels.</p>
      <p class="text-gray-300">The paper is organised as follows. In Section 2 we provide a brief description of pairing-friendly fields and their arithmetic. In Section 3 we detail the methods and operation counts for computing products of pairings for our selection of pairing algorithms. Lastly, in Section 4 we give some efficiency comparisons for our choice of finite fields for various security levels.</p>
      <h4 id="1-1-acknowledgements" class="text-lg font-semibold mt-6 mb-2">1.1 Acknowledgements</h4>
      <p class="text-gray-300">The authors would like to thank Eike Kiltz for bringing the issue of products of multiple pairings in various applications to our attention, and Frederik Vercauteren and Mike Scott who provided comments on an earlier version of this paper.</p>
      <h3 id="2-pairing-friendly-fields" class="text-xl font-semibold mt-8 mb-3">2 Pairing-Friendly Fields</h3>
      <p class="text-gray-300">Koblitz and Menezes [16] introduced the concept of pairing-friendly fields which are particularly well suited to pairing implementations (see also [14]). They are Kummer extensions of  <span class="math">\mathbb&#123;F&#125;_p</span>  defined by the polynomial</p>
      <div class="math-block">f(X) = X^k + f_0 \tag&#123;3&#125;</div>
      <p class="text-gray-300">for values of  <span class="math">p \equiv 1 \pmod&#123;12&#125;</span>  and  <span class="math">k = 2^i 3^j</span> . Generally one assumes that k is even, which aids in efficiency due to the well-known denominator elimination trick in pairing computations. Following [14, 16], we focus in particular on the cases k = 6, 12 and 24. We give here a brief description of the various operations together with their arithmetic costs, and refer the reader to [14] for further details.</p>
      <p class="text-gray-300">Define  <span class="math">\mathbb&#123;F&#125;_&#123;p^k&#125; = \mathbb&#123;F&#125;_p[\theta]/(f(\theta))</span> , where  <span class="math">f(\theta) = 0</span> , and for any  <span class="math">k = 2^i 3^j</span> , let  <span class="math">M_k</span> ,  <span class="math">S_k</span>  and  <span class="math">I_k</span>  denote the time for a multiplication, squaring and inversion respectively in the field  <span class="math">\mathbb&#123;F&#125;_&#123;p^k&#125;</span> . Here we assume that addition operations take a negligible amount of time.</p>
      <p class="text-gray-300">Using the Karatsuba and Toom-Cook methods for multiplication and squaring, to compute products (resp. squares) of polynomials of degree  <span class="math">2^i 3^j - 1</span>  over  <span class="math">\mathbb&#123;F&#125;_p</span>  requires v(k) multiplications (resp. squarings) in the field  <span class="math">\mathbb&#123;F&#125;_p</span> , where  <span class="math">v(k) = 3^i 5^j</span> , i.e.,  <span class="math">M_k = v(k) M_1</span> .</p>
      <p class="text-gray-300">Furthermore, we can assume that  <span class="math">f_0</span>  in (3) has been chosen so that multiplication by  <span class="math">f_0</span>  can be performed quickly by simple additions rather than a full multiplication. With this representation, the Frobenius automorphism can be computed with just a few additions, and inversions can be reduced to a single inversion in  <span class="math">\mathbb&#123;F&#125;_p</span> , together with a few multiplications in  <span class="math">\mathbb&#123;F&#125;_&#123;p^k&#125;</span> , see [14] for more details. We also refer to [14] for a discussion of the relative costs of inversion in the fields under consideration.</p>
      <p class="text-gray-300">In the Tate and Ate pairings, one must perform an exponentiation, also known as 'the final powering'. Essentially this need only be performed (see Section 3) in the cyclotomic subgroup of  <span class="math">\mathbb&#123;F&#125;_&#123;p^k&#125;^&#123;\times&#125;</span>  of order  <span class="math">\Phi_k(p)</span> , which we denote by  <span class="math">G_&#123;\Phi_k(p)&#125;</span> . Inversion and the Frobenius operation in  <span class="math">G_&#123;\Phi_k(p)&#125;</span>  are essentially free, and using special properties of this subgroup, one can improve upon the squaring cost in  <span class="math">\mathbb&#123;F&#125;_&#123;p^k&#125;</span> , again see [14] for details of this.</p>
      <p class="text-gray-300">For the exponentiation step, using Lucas sequences [20] one can exponentiate in  <span class="math">G_&#123;\Phi_k(p)&#125;</span>  by an exponent l for a cost of</p>
      <div class="math-block">C_&#123;\text&#123;Luc&#125;&#125;(l) = (M_&#123;k/2&#125; + S_&#123;k/2&#125;) \log_2 l.</div>
      <p class="text-gray-300">Also, using well known methods (see [14]), one can perform exponentiation via standard signed sliding window methods [6] since inversion is cheap in  <span class="math">G_&#123;\Phi_k(p)&#125;</span> . If  <span class="math">l \leq p</span>  then the best way to perform the exponentiation, using windows of width at least i, will take time</p>
      <div class="math-block">C_&#123;\text&#123;SSW&#125;&#125;(l) = \overline&#123;S&#125;(1 + \log_2 l) + M_k \left(\frac&#123;\log_2 l&#125;&#123;i+2&#125; + (2^&#123;i-2&#125; - 1)\right)</div>
      <p class="text-gray-300">where  <span class="math">\overline&#123;S&#125;</span>  denotes the time needed to perform a squaring operation in  <span class="math">G_&#123;\Phi_k(p)&#125;</span> . We also need to store  <span class="math">2^&#123;i-2&#125;</span>  elements during the exponentiation algorithm.</p>
      <p class="text-gray-300">When  <span class="math">l \geq p</span> , as is the case in the final powering of the algorithm to compute the Tate pairing, one uses the fact that we can perform the Frobenius operation on  <span class="math">G_&#123;\Phi_k(p)&#125;</span>  for free. Thus we write l in base p, and perform a simultaneous exponentiation. Using the techniques of Avanzi [2], we can estimate the time needed to perform such a multi-exponentiation by</p>
      <div class="math-block">C_&#123;\text&#123;bigSSW&#125;&#125;(l) = (d + \log_2 p)\overline&#123;S&#125; + \left(d(2^&#123;i-1&#125; - 1) + \frac&#123;\log_2 l&#125;&#123;i+2&#125; - 1\right)M_k</div>
      <p class="text-gray-300">using windows of width i, where  <span class="math">d = \lceil \log_2 l / \log_2 p \rceil</span> . The precomputation and storage can be reduced using techniques described in [3].</p>
      <h3 id="3-methods-for-computing-products-of-pairings" class="text-xl font-semibold mt-8 mb-3">3 Methods for Computing Products of Pairings</h3>
      <p class="text-gray-300">In this section we extend the best known algorithms for the computation of the Weil, Tate, and Ate pairings for ordinary elliptic curves defined over pairing-friendly fields, to consider the efficient computation of a product of n pairings in each case. As mentioned earlier we use the obvious optimizations, which were mentioned in passing by Scott [19].</p>
      <p class="text-gray-300">Let E be an ordinary elliptic curve described by the equation  <span class="math">y^2 = x^3 + ax + b</span>  over  <span class="math">\mathbb&#123;F&#125;_p</span> , for  <span class="math">p \equiv 1 \mod 12</span> , and let P be a basepoint of prime order r dividing  <span class="math">\#E(\mathbb&#123;F&#125;_p)</span> . Assuming E is not anomalous, let k be the multiplicative order of q modulo r, i.e., the embedding degree of E under the MOV attack [17]. For the purposes of this paper we assume k is 6, 12 or 24.</p>
      <p class="text-gray-300">The main ingredient in Miller's algorithm for computing a pairing is the evaluation of certain line functions at certain divisors. For each pairing we consider, the basic step is the evaluation of  <span class="math">F_P(Q)</span> , where  <span class="math">F_P</span>  is a function whose divisor is equivalent to  <span class="math">r(P)-r(\infty)</span> , for points P and Q defined over either  <span class="math">\mathbb&#123;F&#125;_&#123;p^k&#125;</span>  or a proper subfield. It is usual to assume that  <span class="math">P \in E(\mathbb&#123;F&#125;_p)</span>  and Q is the image of a point in  <span class="math">\overline&#123;E&#125;(\mathbb&#123;F&#125;_&#123;p^e&#125;)</span> , where  <span class="math">\overline&#123;E&#125;</span>  is either the quadratic or sextic twist of E. In particular it is common to take either the curve  <span class="math">y^2 = x^3 - 3x + b</span> , or the curve  <span class="math">y^2 = x^3 + b</span>  which admit twists of degree d = 2 and d = 6 respectively. Thus we define e via e = k/d, since we have assumed that k is a multiple of six.</p>
      <p class="text-gray-300">We follow Koblitz and Menezes' analysis [16] but we do not assume the group order to be a Solinas prime, i.e., one of negligible Hamming weight. Hence in addition to the line computations that arise from a doubling for the functionevaluation step in each loop iteration, we must also consider the line computation arising from an addition, for every set bit in the binary expansion of r. We extended the analysis in this way as we are interested in the cost per addition pairing in the product, which will depend on the heavily on the Hamming weight of r. We now treat each pairing in turn.</p>
      <h4 id="3-1-the-weil-pairing" class="text-lg font-semibold mt-6 mb-2">3.1 The Weil Pairing</h4>
      <p class="text-gray-300">Let  <span class="math">F_P</span>  and  <span class="math">F_Q</span>  be functions whose divisors are  <span class="math">r(P) - r(\infty)</span>  and  <span class="math">r(Q) - r(\infty)</span>  respectively, which are normalised so that  <span class="math">F_P(\infty)/F_Q(\infty) = 1</span> . The Weil pairing  <span class="math">\hat&#123;t&#125;</span>  (see [18]) of  <span class="math">P \neq Q</span>  is given by</p>
      <div class="math-block">(-1)^r \frac&#123;F_P(Q)&#125;&#123;F_Q(P)&#125;. (4)</div>
      <p class="text-gray-300">As pointed out by Koblitz and Menezes [16], for even k one can replace  <span class="math">\hat&#123;t&#125;</span>  by its  <span class="math">(1-p^&#123;k/2&#125;)</span> -th power to eliminate all subfield terms, as with the Tate pairing. This can be accomplised with just one squaring in  <span class="math">\mathbb&#123;F&#125;_&#123;p^k&#125;</span> . The function-evaluation steps - also known as 'Miller operations' - for a single pairing are then</p>
      <div class="math-block">f \leftarrow f^2 \cdot l(Q)</div>
      <p class="text-gray-300">and  <span class="math">f \leftarrow f \cdot l'(Q)</span> , (5)</p>
      <p class="text-gray-300">for lines l, l' corresponding to point doubling and addition respectively. Clearly, if one of the points being paired lies in  <span class="math">E(\mathbb&#123;F&#125;_p)</span> , then the Miller operations become more efficient. In particular, if  <span class="math">P \in E(\mathbb&#123;F&#125;_p)</span>  and  <span class="math">Q \in E(\mathbb&#123;F&#125;_&#123;p^k&#125;)</span> , then the computation of  <span class="math">F_P(Q)</span>  is cheaper than that of computing  <span class="math">F_Q(P)</span> . The computation of the former has thus been dubbed 'Miller-Lite' by Solinas, while the latter we refer to as Miller-Full. By (4), the total cost of a single Weil pairing computation is</p>
      <div class="math-block">C_&#123;\text&#123;Weil&#125;&#125; = C_&#123;\text&#123;Lite&#125;&#125; + C_&#123;\text&#123;Full&#125;&#125;</div>
      <p class="text-gray-300">where  <span class="math">C_&#123;\text&#123;Lite&#125;&#125;</span>  and  <span class="math">C_&#123;\text&#123;Full&#125;&#125;</span>  represent the respective costs of a Miller-Lite and a Miller-Full operation. Note we have dropped the final squaring and division costs since these are negligible.</p>
      <p class="text-gray-300">To compute the product of n terms  <span class="math">F_&#123;P_i&#125;(Q_i)</span> , for each bit of r we simply combine the squarings in  <span class="math">\mathbb&#123;F&#125;_&#123;p^k&#125;</span>  as in (2), and if the bit is set also, multiply in n extra terms arising from the addition line function-evaluation.</p>
      <p class="text-gray-300">It turns out that in computing products of pairings one can achieve extra advantages by assuming that the points P and Q, and all intermediate points within Miller's algorithm, are held in affine coordinates. At first sight this seems to require n inversions in  <span class="math">\mathbb&#123;F&#125;_p</span> , for the Miller-Lite algorithm, and n inversions in  <span class="math">\mathbb&#123;F&#125;_&#123;p^e&#125;</span>  for the Miller-Full algorithm. However, using Montgomery's trick [11, Algorithm 10.3.4], one can trade the n inversions in  <span class="math">\mathbb&#123;F&#125;_p</span>  (resp.  <span class="math">\mathbb&#123;F&#125;_&#123;p^e&#125;</span> ) for 3n-3 multiplications in  <span class="math">\mathbb&#123;F&#125;_p</span>  (resp.  <span class="math">\mathbb&#123;F&#125;_&#123;p^e&#125;</span> ) plus one inversion in  <span class="math">\mathbb&#123;F&#125;_p</span>  (resp.  <span class="math">\mathbb&#123;F&#125;_&#123;p^e&#125;</span> ). For products of a larger number of pairings using affine coordinates will always be more efficient, however for smaller values the exact cross over point depends on the ratio between the cost of an inversion in  <span class="math">\mathbb&#123;F&#125;_p</span>  to that of a multiplication.</p>
      <p class="text-gray-300">In Table 1, we list the cost of all relevant operations in all cases.</p>
      <p class="text-gray-300">Table 1. Cost of Miller operations per bit in product of n pairings</p>
      <div class="overflow-x-auto my-4"><table class="text-sm text-gray-300 border-collapse w-full"><tbody>
        <tr><td class="border border-gray-700 px-3 py-1">Operation</td><td class="border border-gray-700 px-3 py-1">d</td><td class="border border-gray-700 px-3 py-1">Cost</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Jacobian Projective Coordinates</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Miller-Lite double</td><td class="border border-gray-700 px-3 py-1">2</td><td class="border border-gray-700 px-3 py-1">(4S1 + (2e + 7)M1 + Mk)n + Sk</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">6</td><td class="border border-gray-700 px-3 py-1">(5S1 + (2e + 6)M1 + Mk)n + Sk</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Miller-Lite add</td><td class="border border-gray-700 px-3 py-1">2/6</td><td class="border border-gray-700 px-3 py-1">(3S1 + (2e + 10)M1 + Mk)n</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Miller-Full double</td><td class="border border-gray-700 px-3 py-1">2</td><td class="border border-gray-700 px-3 py-1">(2eM1 + 4Se + 6Me + Mk)n + Sk</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">6</td><td class="border border-gray-700 px-3 py-1">(2eM1 + 5Se + 6Me + Mk)n + Sk</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Miller-Full add</td><td class="border border-gray-700 px-3 py-1">2/6</td><td class="border border-gray-700 px-3 py-1">(2eM1 + 3Se + 10Me + Mk)n</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Affine Coordinates</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Miller-Lite double 2/6 (2S1 + (e + 6)M1 + Mk)n − 3M1 + I1 + Sk</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Miller-Lite add</td><td class="border border-gray-700 px-3 py-1">2/6</td><td class="border border-gray-700 px-3 py-1">(S1 + (e + 5)M1 + Mk)n − 3M1 + I1</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Miller-Full double 2/6 (2Se + 6Me + eM1 + Mk)n − 3Me + IeSk</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Miller-Full add</td><td class="border border-gray-700 px-3 py-1">2/6</td><td class="border border-gray-700 px-3 py-1">(Se + 5Me + eM1 + Mk)n − 3Me + Ie</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
      </tbody></table></div>
      <p class="text-gray-300">For sake of a comparison we assume that the signed Hamming weight for the relevant loops is on average 1/3 the length of the loop, using the non-adjacent form [10] of a binary expansion to reduce the number of addition line function evaluations in the loop. Therefore, the total cost for computing the product of n Weil pairings, for group order r, using affine coordinates and d = 2, is,</p>
      <div class="math-block">((2S_1 + 2S_e + (2e + 6)M_1 + 6M_e + 2M_k)n - 3M_1 - 3M_e + I_1 + I_e + 2S_k)\log_2 r + ((S_1 + S_e + (4e + 5)M_1 + 6M_e + 2M_k)n - 3M_1 - 3M_e + I_1 + I_e)(\log_2 r)/3.</div>
      <h3 id="3-2-the-tate-pairing" class="text-xl font-semibold mt-8 mb-3">3.2 The Tate Pairing</h3>
      <p class="text-gray-300">In computing the Tate pairing one executes one Miller-Lite operation and then performs an exponentiation by (p <sup>k</sup> − 1)/r in order to eliminate r-th powers and obtain an r-th root of unity. As observed by Koblitz and Menezes, the exponentiation can be sped up by first exponentiating by (p <sup>k</sup> − 1)/Φk(p), which is very cheap since the Frobenius is also, and then exponentiating by Φk(p)/r. Once raised to the power (p <sup>k</sup> − 1)/Φk(p), the pairing output is an element of G<sup>Φ</sup>k(p) and so the available techniques for fast arithmetic can be utilised. Hence, we can make use of the fast squaring described in Section 2.</p>
      <p class="text-gray-300">By the same argument as for the Weil pairing, the computation of the line functions reduces to (5), and so we can use the same arithmetic for computing the Miller-Lite part of the algorithm.</p>
      <p class="text-gray-300">For the exponentiation we ignore the small cost to power by (p <sup>k</sup> − 1)/Φk(p), as this is negligible. Thus a Tate pairing computation requires time</p>
      <div class="math-block">C_&#123;\mathrm&#123;Tate&#125;&#125; = C_&#123;\mathrm&#123;Luc&#125;&#125;(\Phi_k(p)/r) + C_&#123;\mathrm&#123;Lite&#125;&#125;</div>
      <p class="text-gray-300">or</p>
      <div class="math-block">C_&#123;\text&#123;Tate&#125;&#125; = C_&#123;\text&#123;bigSSW&#125;&#125;(\Phi_k(p)/r) + C_&#123;\text&#123;Lite&#125;&#125;,</div>
      <p class="text-gray-300">whichever is the fastest. Therefore the total cost for computing the product of n Tate pairings, in affine coordinates, is</p>
      <div class="math-block">((2S_1 + (e+6)M_1 + M_k)n - 3M_1 + I_1 + S_k) \log_2 r + ((S_1 + (e+5)M_1 + M_k)n - 3M_1 + I_1) (\log_2 r)/3 + \min\&#123;C_&#123;\text&#123;Luc&#125;&#125;(\Phi_k(p)/r), C_&#123;\text&#123;bigSSW&#125;&#125;(\Phi_k(p)/r)\&#125;.</div>
      <h4 id="3-3-the-ate-pairing" class="text-lg font-semibold mt-6 mb-2">3.3 The Ate Pairing</h4>
      <p class="text-gray-300">The Ate <sup>1</sup> pairing was introduced by Hess, Smart and Vercauteren [15] as an extension of the Eta pairing [4] from supersingular, to ordinary elliptic curves. It is particularly suited to the case where d = 6, and hence e is smaller than for other curves.</p>
      <p class="text-gray-300">The central idea behind the Ate pairing is rather than compute a function with divisor r(P) − r(∞) at Q, with P ∈ E(Fp) and Q ∈ E(Fp<sup>k</sup> ), one instead computes a function with divisor</p>
      <div class="math-block">(t-1)(Q) - ((t-1)Q) - (t-2)(\infty)</div>
      <p class="text-gray-300">evaluated at P, where t is the trace of frobenius of E over Fp. Since the trace of E is O( <sup>√</sup>p), the computational overheads can be smaller than the Tate pairing depending on the security level and embedding degree. The computational overhead is more pronounced when <sup>t</sup> is small compared to <sup>√</sup>p. For convenience we let T = t − 1.</p>
      <p class="text-gray-300">For the standard Ate pairing one computes</p>
      <div class="math-block">f_&#123;T,Q&#125;(P)^&#123;(p^k-1)/r&#125;,</div>
      <p class="text-gray-300">whilst for the twisted Ate pairing one computes</p>
      <div class="math-block">f_&#123;T^e,P&#125;(Q)^&#123;(p^k-1)/r&#125;.</div>
      <p class="text-gray-300">Note that the length of the loop in computing the Miller function depends on the size of the trace. Hence, one can exploit techniques that allow the construction of curves with trace as small as log<sup>2</sup> (r)/φ(k) bits, for k ≥ 12 [12]. We refer the interested reader to [15] for further details regarding the derivation of the Ate pairing.</p>
      <p class="text-gray-300">For this note, we consider both the standard and the twisted Ate pairing, the degree of the relevant twist, and the size of the trace. We assume the signed Hamming weight of T is around log<sup>2</sup> (t)/3, and that of T e is around e log<sup>2</sup> (t)/3. Then the cost for computing the product of n Ate pairings can be easily read from Table 1. For example, the cost of computing the product of n Standard Ate pairings with average trace, in affine coordinates, is</p>
      <div class="math-block">((2S_e + 6M_e + eM_1 + M_k)n - 3M_e + I_eS_k) \log_2 t + ((S_e + 5M_e + eM_1 + M_k)n - 3M_e + I_e) (\log_2 t)/3 + \min\&#123;C_&#123;\text&#123;Luc&#125;&#125;(\Phi_k(p)/r), C_&#123;\text&#123;bigSSW&#125;&#125;(\Phi_k(p)/r)\&#125;,</div>
      <sup>1</sup> Pronounced in the natural way, the Ate pairing is called as such because it is effectively the Eta pairing but with the roles of G<sup>1</sup> and G<sup>2</sup> reversed.
      <p class="text-gray-300">whilst, the cost of computing the product of n twisted Ate pairings with small trace, i.e. log<sup>2</sup> t ≈ log<sup>2</sup> r/φ(k), in affine coordinates, is</p>
      <div class="math-block">((2S_1 + (e+6)M_1 + M_k)n - 3M_1 + I_1 + S_k) (e \log_2 r)/\phi(k) + ((S_1 + (e+5)M_1 + M_k)n - 3M_1 + I_1) (e \log_2 r)/(3\phi(k)) + \min\&#123;C_&#123;\text&#123;Luc&#125;&#125;(\Phi_k(p)/r), C_&#123;\text&#123;bigSSW&#125;&#125;(\Phi_k(p)/r)\&#125;,</div>
      <h3 id="4-results" class="text-xl font-semibold mt-8 mb-3">4 Results</h3>
      <p class="text-gray-300">Assuming that S<sup>1</sup> ≈ M<sup>1</sup> and that I1/M<sup>1</sup> ≈ 10, in Tables 2 and 3 we list the number of multiplications/squarings in F<sup>p</sup> required to compute the product of n pairings, for each of the AES security levels; that is 80-bits, 128-bits, 192-bits and 256-bits, for embedding degrees 6, 12 and 24. We also list the ratio of the cost per additional pairing compared to the cost of a single pairing. The table present the affine coordinate versions of the algorithms only. With a ratio of I1/M<sup>1</sup> ≈ 10 the affine coordinate versions are always faster as long as n ≥ 2.</p>
      <p class="text-gray-300">For the parameter sizes we follow the work of [14, 16]. The first set of parameters in each table corresponds to the 80-bit security level, the next two sets of parameters refer to the 128-bit security level, whilst the next two correspond to the 192-bit level, the final three are related to the 256-bit level.</p>
      <p class="text-gray-300">As an example consider the 128-bit security level and the parameter set k = 12, p ≈ r ≈ 2 <sup>256</sup> and d = 6. This parameter choice is generally considered to be the most efficient choice at this security level. We see that each extra pairing costs ranges roughly between 32 percent and 61 percent of the cost of one pairing.</p>
      <p class="text-gray-300">At the highest security level and most efficient implementation choice of k = 24, p ≈ 2 640 , r ≈ 2 <sup>512</sup> and d = 6, we find that the cost per extra pairing ranges from 13 percent to 63 percent. For protocols in which one needs to compute the product of three pairing values one finds that the Ate pairing with a small value of t can be over three times faster than using the Tate pairing. It is also over five times faster than naively computing the three Tate pairings independently and then multplying the result.</p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>1. M. Abdalla, D. Catalano, A.W. Dent, J. Malone-Lee, G. Neven and N.P. Smart. Identity-based encryption gone wild. In ICALP 2006, Springer-Verlag LNCS XXXX, XXXX–XXXX, 2006.</li>
        <li>2. R.M. Avanzi. On Multi-exponentiation in cryptography. Preprint, Cryptology ePrint Archive, Report 2002/154, 2002.</li>
        <li>3. R. M. Avanzi and P. Mihailescu. Generic efficient arithmetic algorithms for PAFFs (Processor Adequate Finite Fields) and related algebraic structures. In Selected Areas in Cryptology – SAC 2003, Springer-Verlag LNCS 3006, 320–334, 2004.</li>
        <li>4. P. Barreto, S. Galbraith, C. O h ´ Eigearaigh, and M. Scott. Efficient pairing com- ´ putation on supersingular abelian varieties. Preprint, Cryptology ePrint Archive, Report 2004/375.</li>
      </ul>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>5. P. Barreto, H. Kim, B. Lynn and M. Scott. Efficient Algorithms for Pairing-Based Cryptosystems. In Advances in Cryptology – CRYPTO 2002, Springer-Verlag LNCS 2442, 354–368, 2002.</li>
        <li>6. I.F. Blake, G. Seroussi and N.P. Smart. Elliptic Curves in Cryptography. Cambridge University Press, 1999.</li>
        <li>7. D. Boneh, X. Boyen and E.-G. Goh. Hierarchichical identity based encryption with constant size ciphertext. In Advances in Cryptology – EUROCRYPT 2005, Springer-Verlag LNCS 3494, 440–456, 2005.</li>
        <li>8. D. Boneh, X. Boyen and H. Shacham. Short group signatures. In Advances in Cryptology – CRYPTO 2004, Springer-Verlag LNCS 3152, 41–55, 2004.</li>
        <li>9. M.Z. Cheng, L. Chen and N.P. Smart. A built-in decisional function and security proof of ID-based key agreement protocols from pairings. Preprint, 2006.</li>
        <li>10. W. Clark and J. Liang. On arithmetic weight for a general radix representation. IEEE Trans. Info. Theory, 19, 823–826, 1973.</li>
        <li>11. H. Cohen. A course in computational algebraic number theory. Springer-Verlag, GTM 139, 1993.</li>
        <li>12. P. Duan, S. Cui and C.W. Chan. Special polynomial families for generating more suitable elliptic curves for pairing-based cryptosystems. Preprint, Cryptology ePrint Archive, Report 2005/342, 2005.</li>
        <li>13. S. Galbraith, K. Harrison and D. Soldera. Implementing the Tate pairing. In Algorithmic Number Theory Symposium – ANTS V, Springer-Verlag LNCS 2369, 324–337, 2002.</li>
        <li>14. R. Granger, D. Page and N.P. Smart. High security pairing-based cryptography revisited. In Algorithmic Number Theory Symposium – ANTS VII, Springer-Verlag LNCS XXXX, XXXX–XXXX, 2006.</li>
        <li>15. F. Hess, N.P. Smart and F. Vercauteren. The Eta pairing revisited. Preprint, Cryptology ePrint Archive, Report 2006/110, 2005</li>
        <li>16. N. Koblitz and A. Menezes. Pairing-based cryptography at high security levels. In Cryptography and Coding, Springer-Verlag LNCS 3796, 13–36, 2005.</li>
        <li>17. A. J. Menezes, T. Okamoto and S. A. Vanstone. Reducing elliptic curve logarithms to logarithms in a finite field. IEEE Trans. Info. Theory, 39, 1639–1646, 1993.</li>
        <li>18. V.S. Miller The Weil Pairing, and its efficient calculation. Journal of Cryptology, 17, 235–261, 2004.</li>
        <li>19. M. Scott. Computing the Tate Pairing. In Topics in Cryptology CT-RSA 2005, Springer-Verlag LNCS 3376, 293–304, 2005.</li>
        <li>20. M. Scott and P.S.L.M. Barreto. Compressed pairings. In Advances in Cryptology – CRYPTO 2004, Springer-Verlag LNCS 3152, 140–156, 2004.</li>
        <li>21. B. Waters. Efficient identity-based encryption without random oracles. In Advances in Cryptology – EUROCRYPT 2005, Springer-Verlag LNCS 3494, 114–127, 2005.</li>
      </ul>
      <p class="text-gray-300">Table 2. Cost of the various algorithms for a product of n pairings, d = 2</p>
      <div class="overflow-x-auto my-4"><table class="text-sm text-gray-300 border-collapse w-full"><tbody>
        <tr><td class="border border-gray-700 px-3 py-1">k = 6<br>Weil<br>17256 n+ 8208<br>0.678<br>160<br>r ≈ 2<br>Tate<br>5432 n+ 5491<br>0.497<br>160<br>p ≈ 2<br>Ate (Average t)<br>5920 n+ 3760<br>0.612<br>Ate (Small t)<br>5920 n+ 3760<br>0.612<br>Twisted Ate (Average t)<br>8160 n+ 7440<br>0.523<br>Twisted Ate (Small t)<br>8160 n+ 7440<br>0.523<br>k = 6<br>Weil<br>27624 n+ 13136<br>0.678<br>256<br>r ≈ 2<br>Tate<br>8696 n+ 12817<br>0.404<br>512<br>p ≈ 2<br>Ate (Average t)<br>18944 n+ 13502<br>0.584<br>Ate (Small t)<br>9472 n+ 10046<br>0.485<br>Twisted Ate (Average t)<br>26112 n+ 25278<br>0.508<br>Twisted Ate (Small t)<br>13056 n+ 15934<br>0.450<br>k = 12<br>Weil<br>75710 n+ 25086<br>0.751<br>256<br>r ≈ 2<br>Tate<br>19949 n+ 22899<br>0.466<br>256<br>p ≈ 2<br>Ate (Average t)<br>27904 n+ 14582<br>0.657<br>Ate (Small t)<br>13952 n+ 11787<br>0.542<br>Twisted Ate (Average t)<br>59904 n+ 50720<br>0.542<br>Twisted Ate (Small t)<br>29952 n+ 29856<br>0.501<br>k = 6<br>Weil<br>41472 n+ 19712<br>0.678<br>384<br>r ≈ 2<br>Tate<br>13056 n+ 26827<br>0.327<br>1365<br>p ≈ 2<br>Ate (Average t)<br>50468 n+ 35897<br>0.584<br>Ate (Small t)<br>14208 n+ 22667<br>0.385<br>Twisted Ate (Average t)<br>69598 n+ 67293<br>0.508<br>Twisted Ate (Small t)<br>19584 n+ 31499<br>0.383<br>k = 12<br>Weil<br>113664 n+ 37632<br>0.751<br>384<br>r ≈ 2<br>Tate<br>29952 n+ 44412<br>0.403<br>683<br>p ≈ 2<br>Ate (Average t)<br>74338 n+ 38439<br>0.659<br>Ate (Small t)<br>20928 n+ 27740<br>0.430<br>Twisted Ate (Average t) 159822 n+ 134877<br>0.542<br>Twisted Ate (Small t)<br>44928 n+ 54844<br>0.450<br>k = 6<br>Weil<br>55248 n+ 26272<br>0.678<br>512<br>r ≈ 2<br>Tate<br>17392 n+ 44876<br>0.279<br>2560<br>p ≈ 2<br>Ate (Average t)<br>94720 n+ 66982<br>0.586<br>Ate (Small t)<br>18944 n+ 39334<br>0.325<br>Twisted Ate (Average t) 130560 n+ 125862<br>0.509<br>Twisted Ate (Small t)<br>26112 n+ 51110<br>0.338<br>k = 12<br>Weil<br>151420 n+ 50172<br>0.751<br>512<br>r ≈ 2<br>Tate<br>39898 n+ 70264<br>0.362<br>1280<br>p ≈ 2<br>Ate (Average t)<br>139520 n+ 70397<br>0.665<br>Ate (Small t)<br>27904 n+ 48040<br>0.367<br>Twisted Ate (Average t) 299520 n+ 251090<br>0.544<br>Twisted Ate (Small t)<br>59904 n+ 84178<br>0.416<br>k = 24<br>Weil<br>435844 n+ 121872<br>0.781<br>512<br>r ≈ 2<br>Tate<br>105370 n+ 183035<br>0.365<br>640<br>p ≈ 2<br>Ate (Average t)<br>206720 n+ 139115<br>0.598<br>Ate (Small t)<br>41344 n+ 115136<br>0.264<br>Twisted Ate (Average t) 791040 n+ 663381<br>0.544</td><td class="border border-gray-700 px-3 py-1">Security level</td><td class="border border-gray-700 px-3 py-1">Algorithm</td><td class="border border-gray-700 px-3 py-1">Cost for n pairings Cost per extra pairing</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Twisted Ate (Small t)<br>158208 n+ 219989<br>0.418</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
      </tbody></table></div>
      <p class="text-gray-300">Table 3. Cost of the various algorithms for a product of n pairings, d = 6</p>
      <div class="overflow-x-auto my-4"><table class="text-sm text-gray-300 border-collapse w-full"><tbody>
        <tr><td class="border border-gray-700 px-3 py-1">Security level</td><td class="border border-gray-700 px-3 py-1">Algorithm</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Cost for n pairings Cost per extra pairing</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">k = 6</td><td class="border border-gray-700 px-3 py-1">Weil</td><td class="border border-gray-700 px-3 py-1">10012 n+ 7782</td><td class="border border-gray-700 px-3 py-1">0.563</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">160<br>r ≈ 2</td><td class="border border-gray-700 px-3 py-1">Tate</td><td class="border border-gray-700 px-3 py-1">5006 n+ 5491</td><td class="border border-gray-700 px-3 py-1">0.477</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">160<br>p ≈ 2</td><td class="border border-gray-700 px-3 py-1">Ate (Average t)</td><td class="border border-gray-700 px-3 py-1">2506 n+ 3546</td><td class="border border-gray-700 px-3 py-1">0.414</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Ate (Small t)</td><td class="border border-gray-700 px-3 py-1">2506 n+ 3546</td><td class="border border-gray-700 px-3 py-1">0.414</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Twisted Ate (Average t)</td><td class="border border-gray-700 px-3 py-1">2506 n+ 3546</td><td class="border border-gray-700 px-3 py-1">0.414</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Twisted Ate (Small t)</td><td class="border border-gray-700 px-3 py-1">2506 n+ 3546</td><td class="border border-gray-700 px-3 py-1">0.414</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">k = 6</td><td class="border border-gray-700 px-3 py-1">Weil</td><td class="border border-gray-700 px-3 py-1">16028 n+ 12454</td><td class="border border-gray-700 px-3 py-1">0.563</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">256<br>r ≈ 2</td><td class="border border-gray-700 px-3 py-1">Tate</td><td class="border border-gray-700 px-3 py-1">8014 n+ 12817</td><td class="border border-gray-700 px-3 py-1">0.385</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">512<br>p ≈ 2</td><td class="border border-gray-700 px-3 py-1">Ate (Average t)</td><td class="border border-gray-700 px-3 py-1">8021 n+ 12819</td><td class="border border-gray-700 px-3 py-1">0.385</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Ate (Small t)</td><td class="border border-gray-700 px-3 py-1">4010 n+ 9704</td><td class="border border-gray-700 px-3 py-1">0.292</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Twisted Ate (Average t)</td><td class="border border-gray-700 px-3 py-1">8021 n+ 12819</td><td class="border border-gray-700 px-3 py-1">0.385</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Twisted Ate (Small t)</td><td class="border border-gray-700 px-3 py-1">4010 n+ 9704</td><td class="border border-gray-700 px-3 py-1">0.292</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">k = 12</td><td class="border border-gray-700 px-3 py-1">Weil</td><td class="border border-gray-700 px-3 py-1">42286 n+ 27132</td><td class="border border-gray-700 px-3 py-1">0.609</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">256<br>r ≈ 2</td><td class="border border-gray-700 px-3 py-1">Tate</td><td class="border border-gray-700 px-3 py-1">18585 n+ 22899</td><td class="border border-gray-700 px-3 py-1">0.448</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">256<br>p ≈ 2</td><td class="border border-gray-700 px-3 py-1">Ate (Average t)</td><td class="border border-gray-700 px-3 py-1">11861 n+ 15605</td><td class="border border-gray-700 px-3 py-1">0.432</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Ate (Small t)</td><td class="border border-gray-700 px-3 py-1">5930 n+ 12298</td><td class="border border-gray-700 px-3 py-1">0.325</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Twisted Ate (Average t)</td><td class="border border-gray-700 px-3 py-1">18602 n+ 22901</td><td class="border border-gray-700 px-3 py-1">0.448</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Twisted Ate (Small t)</td><td class="border border-gray-700 px-3 py-1">9301 n+ 15946</td><td class="border border-gray-700 px-3 py-1">0.368</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">k = 6</td><td class="border border-gray-700 px-3 py-1">Weil</td><td class="border border-gray-700 px-3 py-1">24064 n+ 18688</td><td class="border border-gray-700 px-3 py-1">0.563</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">384<br>r ≈ 2</td><td class="border border-gray-700 px-3 py-1">Tate</td><td class="border border-gray-700 px-3 py-1">12032 n+ 26827</td><td class="border border-gray-700 px-3 py-1">0.310</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">1365<br>p ≈ 2</td><td class="border border-gray-700 px-3 py-1">Ate (Average t)</td><td class="border border-gray-700 px-3 py-1">21369 n+ 34078</td><td class="border border-gray-700 px-3 py-1">0.385</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Ate (Small t)</td><td class="border border-gray-700 px-3 py-1">6016 n+ 22155</td><td class="border border-gray-700 px-3 py-1">0.214</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Twisted Ate (Average t)</td><td class="border border-gray-700 px-3 py-1">21369 n+ 34078</td><td class="border border-gray-700 px-3 py-1">0.385</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Twisted Ate (Small t)</td><td class="border border-gray-700 px-3 py-1">6016 n+ 22155</td><td class="border border-gray-700 px-3 py-1">0.214</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">k = 12</td><td class="border border-gray-700 px-3 py-1">Weil</td><td class="border border-gray-700 px-3 py-1">63488 n+ 40704</td><td class="border border-gray-700 px-3 py-1">0.609</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">384<br>r ≈ 2</td><td class="border border-gray-700 px-3 py-1">Tate</td><td class="border border-gray-700 px-3 py-1">27904 n+ 44412</td><td class="border border-gray-700 px-3 py-1">0.386</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">683<br>p ≈ 2</td><td class="border border-gray-700 px-3 py-1">Ate (Average t)</td><td class="border border-gray-700 px-3 py-1">31599 n+ 41166</td><td class="border border-gray-700 px-3 py-1">0.434</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Ate (Small t)</td><td class="border border-gray-700 px-3 py-1">8896 n+ 28508</td><td class="border border-gray-700 px-3 py-1">0.238</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Twisted Ate (Average t)</td><td class="border border-gray-700 px-3 py-1">49631 n+ 60657</td><td class="border border-gray-700 px-3 py-1">0.450</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Twisted Ate (Small t)</td><td class="border border-gray-700 px-3 py-1">13952 n+ 33980</td><td class="border border-gray-700 px-3 py-1">0.291</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">k = 6</td><td class="border border-gray-700 px-3 py-1">Weil</td><td class="border border-gray-700 px-3 py-1">32056 n+ 24908</td><td class="border border-gray-700 px-3 py-1">0.563</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">512<br>r ≈ 2</td><td class="border border-gray-700 px-3 py-1">Tate</td><td class="border border-gray-700 px-3 py-1">16028 n+ 44876</td><td class="border border-gray-700 px-3 py-1">0.263</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">2560<br>p ≈ 2</td><td class="border border-gray-700 px-3 py-1">Ate (Average t)</td><td class="border border-gray-700 px-3 py-1">40106 n+ 63568</td><td class="border border-gray-700 px-3 py-1">0.387</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Ate (Small t)</td><td class="border border-gray-700 px-3 py-1">8021 n+ 38651</td><td class="border border-gray-700 px-3 py-1">0.172</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Twisted Ate (Average t)</td><td class="border border-gray-700 px-3 py-1">40106 n+ 63568</td><td class="border border-gray-700 px-3 py-1">0.387</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Twisted Ate (Small t)</td><td class="border border-gray-700 px-3 py-1">8021 n+ 38651</td><td class="border border-gray-700 px-3 py-1">0.172</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">k = 12</td><td class="border border-gray-700 px-3 py-1">Weil</td><td class="border border-gray-700 px-3 py-1">84572 n+ 54264</td><td class="border border-gray-700 px-3 py-1">0.609</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">512<br>r ≈ 2</td><td class="border border-gray-700 px-3 py-1">Tate</td><td class="border border-gray-700 px-3 py-1">37170 n+ 70264</td><td class="border border-gray-700 px-3 py-1">0.346</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">1280<br>p ≈ 2</td><td class="border border-gray-700 px-3 py-1">Ate (Average t)</td><td class="border border-gray-700 px-3 py-1">59306 n+ 75516</td><td class="border border-gray-700 px-3 py-1">0.440</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Ate (Small t)</td><td class="border border-gray-700 px-3 py-1">11861 n+ 49063</td><td class="border border-gray-700 px-3 py-1">0.195</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Twisted Ate (Average t)</td><td class="border border-gray-700 px-3 py-1">93013 n+ 111996</td><td class="border border-gray-700 px-3 py-1">0.454</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Twisted Ate (Small t)</td><td class="border border-gray-700 px-3 py-1">18602 n+ 56359</td><td class="border border-gray-700 px-3 py-1">0.248</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">k = 24</td><td class="border border-gray-700 px-3 py-1">Weil</td><td class="border border-gray-700 px-3 py-1">240756 n+ 142332</td><td class="border border-gray-700 px-3 py-1">0.628</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">512<br>r ≈ 2</td><td class="border border-gray-700 px-3 py-1">Tate</td><td class="border border-gray-700 px-3 py-1">99914 n+ 183035</td><td class="border border-gray-700 px-3 py-1">0.353</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">640<br>p ≈ 2</td><td class="border border-gray-700 px-3 py-1">Ate (Average t)</td><td class="border border-gray-700 px-3 py-1">88106 n+ 151915</td><td class="border border-gray-700 px-3 py-1">0.367</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Ate (Small t)</td><td class="border border-gray-700 px-3 py-1">17621 n+ 117696</td><td class="border border-gray-700 px-3 py-1">0.130</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Twisted Ate (Average t) 250026 n+ 293887</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">0.460</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Twisted Ate (Small t)</td><td class="border border-gray-700 px-3 py-1">50005 n+ 146090</td><td class="border border-gray-700 px-3 py-1">0.255</td></tr>
      </tbody></table></div>
    </section>
  </article>
</BaseLayout>
