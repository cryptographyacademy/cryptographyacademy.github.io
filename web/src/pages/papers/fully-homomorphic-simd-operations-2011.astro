---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2011/133';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Fully Homomorphic SIMD Operations';
const AUTHORS_HTML = 'N.P. Smart&lt;sup&gt;1&lt;/sup&gt; and F. Vercauteren&lt;sup&gt;2&lt;/sup&gt;';

const CONTENT = `    <p class="text-gray-300">N.P. Smart&lt;sup&gt;1&lt;/sup&gt; and F. Vercauteren&lt;sup&gt;2&lt;/sup&gt;</p>

    <p class="text-gray-300">&lt;sup&gt;1&lt;/sup&gt; Dept. Computer Science, University of Bristol, Merchant Venturers Building, Woodland Road, Bristol, BS8 1UB, United Kingdom. nigel@cs.bris.ac.uk &lt;sup&gt;2&lt;/sup&gt; COSIC - Electrical Engineering, Katholieke Universiteit Leuven, Kasteelpark Arenberg 10, B-3001 Heverlee, Belgium. fvercaut@esat.kuleuven.ac.be</p>

    <p class="text-gray-300">Abstract. At PKC 2010 Smart and Vercauteren presented a variant of Gentry's fully homomorphic public key encryption scheme and mentioned that the scheme could support SIMD style operations. The slow key generation process of the Smart–Vercauteren system was then addressed in a paper by Gentry and Halevi, but their key generation method appears to exclude the SIMD style operation alluded to by Smart and Vercauteren. In this paper, we show how to select parameters to enable such SIMD operations, whilst still maintaining practicality of the key generation technique of Gentry and Halevi. As such, we obtain a somewhat homomorphic scheme supporting both SIMD operations and operations on large finite fields of characteristic two. This somewhat homomorphic scheme can be made fully homomorphic in a naive way by recrypting all data elements seperately. However, we show that the SIMD operations can be used to perform the recrypt procedure in parallel, resulting in a substantial speed-up. Finally, we demonstrate how such SIMD operations can be used to perform various tasks by studying two use cases: implementing AES homomorphically and encrypted database lookup.</p>

    <p class="text-gray-300">For many years a long standing open problem in cryptography has been the construction of a fully homomorphic encryption (FHE) scheme. The practical realisation of such a scheme would have a number of consequences, such as computation on encrypted data held on an untrusted server. In 2009 Gentry [8, 9] came up with the first construction of such a scheme based on ideal lattices. Soon after Gentry's initial paper appeared, two other variants were presented [5, 16]; the method of van Dijk et al. [5] is a true variant of Gentry's scheme and relies purely on the arithmetic of the integers; on the other hand the scheme of Smart and Vercauteren [16] is a specialisation of Gentry's scheme to a particular set of parameters.</p>

    <p class="text-gray-300">All schemes make use of Gentry's idea of first producing a somewhat homomorphic encryption scheme and then applying a bootstrapping process to obtain a complete FHE scheme. This bootstrapping process requires a &quot;dirty&quot; ciphertext to be publicly reencrypted into a &quot;cleaner&quot; ciphertext. This requires that the somewhat homomorphic scheme can homomorphically implement its own decryption circuit, and so must be able to execute a circuit of a given depth.</p>

    <p class="text-gray-300">Recently, Gentry and Halevi [10] presented an optimized version of the Smart–Vercauteren variant. In particular, the optimized version has an efficient key generation procedure based on the Fast Fourier Transform and a simpler decryption circuit. These two major optimizations, along with some other minor ones, allow Gentry and Halevi to actually implement a &quot;toy&quot; FHE scheme, including the ciphertext cleaning operation.</p>

    <p class="text-gray-300">Smart and Vercauteren mentioned in [16] that their scheme can be adapted to support SIMD (Single-Instruction Multiple-Data) style operations on non-trivial finite fields of characteristic two, as opposed to operations on single bits, as long as the parameters are chosen appropriately. However, the parameters proposed in both [10] and [16] do not allow such SIMD operations, nor direct operation on elements of finite fields of characteristic two of degree greater than one. In particular, the efficient key generation method of [10] precludes the use of parameters which would support SIMD style operations. Using fully homomorphic SIMD operations would be an advantage in any practical system since FHE schemes usually embed relatively small plaintexts within large ciphertexts. Allowing each ciphertext to represent a number of independent plaintexts would therefore enable more efficient use of both space and computational resources.</p>

    <p class="text-gray-300">In this paper we investigate the use of SIMD operations in FHE systems in more depth. In particular we show how by adapting the parameter settings of [10, 16] one can obtain the benefits of SIMD operations, whilst still maintaining many of the important efficiency improvements obtained by Gentry and Halevi. We thus obtain a somewhat homomorphic scheme supporting SIMD operations, and operations on large finite fields of characteristic two. We then discuss how one can use the SIMD operations to perform the recrypt procedure in parallel. In addition we explain how such SIMD operations could be utilized to perform a number of interesting higher level operations, such as performing AES encryption homomorphically and searching an encrypted database on a remote server.</p>

    <p class="text-gray-300">The paper is structured as follows. Section 2 presents some basic facts about finite fields and algebras defined as quotients of polynomial rings. Section 3 explains how these algebras allow us to create a somewhat homomorphic encryption scheme whose message space consists of multiple parallel copies of a given finite field of characteristic two. Section 4 describes a recryption procedure for the somewhat homomorphic scheme that preserves the underlying message space structure. Section 5 contains our main contribution, namely, a recryption procedure that makes use of the SIMD operations. This new procedure significantly reduces the cost of recryption. To justify our claims, Section 6 presents implementation timings for a toy example. Finally, Section 7 gives possible applications of the SIMD structure of our FHE scheme, including bit-sliced implementations of algorithms, such as performing AES encryption using an encrypted key, and database search.</p>

    <p class="text-gray-300"><strong>Notations</strong> We end this introduction by presenting the notations that will be used throughout this paper. Assignment to variables will be denoted by  <span class="math">x \\leftarrow y</span> . If A is a set then  <span class="math">x \\leftarrow A</span>  implies that x is selected from A using the uniform distribution. If A is an algorithm then  <span class="math">x \\leftarrow A</span>  implies that x is obtained from running A, with the resulting probability distribution being induced by the random coins of A. For integers x, d, we denote  <span class="math">[x]_d</span>  the reduction of x modulo x into the interval  <span class="math">[x]_d</span>  is a vector then we let x denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote the x-denote th</p>

    <p class="text-gray-300">Polynomials over an indeterminate X will (usually) be denoted by uppercase roman letters, e.g. F(X). We make an exception for the cyclotomic polynomials which are as usual denoted by  <span class="math">\\Phi_m(X)</span> . Elements of finite fields and number fields defined by a polynomial F(X), i.e. elements of  <span class="math">\\mathbb{F}_2[X]/F(X)</span>  and  <span class="math">\\mathbb{Q}[X]/F(X)</span> , can also be represented as polynomials in some fixed root of F(X) in the algebraic closure of the base field. We shall denote such polynomials by lower case greek letters, with the fixed root (being an element of the field) also being denoted by a lower case greek letter; for instance  <span class="math">\\gamma(\\theta)</span>  where  <span class="math">F(\\theta)=0</span> . When the underlying root of F(X) is clear we shall simply write  <span class="math">\\gamma</span> .</p>

    <p class="text-gray-300">For a polynomial  <span class="math">F(X) \\in \\mathbb{Q}[X]</span>  we let  <span class="math">\\|F(X)\\|_{\\infty}</span>  denote the  <span class="math">\\infty</span> -norm of the coefficient vector, i.e. the maximum coefficient in absolute value. Similarly, for an element  <span class="math">\\gamma \\in \\mathbb{Q}[X]/F(X)</span>  we write  <span class="math">\\|\\gamma\\|_{\\infty}</span>  for  <span class="math">\\|\\gamma(X)\\|_{\\infty}</span>  where  <span class="math">\\gamma(X)</span>  is the corresponding unique polynomial of degree  <span class="math">&lt; \\deg(F)</span> . If  <span class="math">F(X) \\in \\mathbb{Q}[X]</span>  then we let [F(X)] denote the polynomial in  <span class="math">\\mathbb{Z}[X]</span>  obtained by rounding the coefficients of F(X) to the nearest integer. Similarly, for an element  <span class="math">\\gamma \\in \\mathbb{Q}[X]/F(X)</span>  we write  <span class="math">[\\gamma]</span>  for  <span class="math">[\\gamma(X)]</span> .</p>

    <p class="text-gray-300">To present the SIMD operations in full generality and to understand how they can be utilized we first set up a number of finite fields and homomorphisms between them. We let  <span class="math">F(X) \\in \\mathbb{F}_2[X]</span>  denote a monic polynomial of degree N that we assume to split into exactly r distinct irreducible factors of degree d = N/r</p>

    <p class="text-gray-300"><span class="math">$F(X) := \\prod_{i=1}^{r} F_i(X).</span>$</p>

    <p class="text-gray-300">In practice F(X) will be the reduction modulo two of a specially chosen monic <em>irreducible</em> polynomial over  <span class="math">\\mathbb{Z}</span> . This polynomial F(X) defines a number field  <span class="math">\\mathbb{K} = \\mathbb{Q}(\\theta) = \\mathbb{Q}[X]/(F)</span> , where  <span class="math">\\theta</span>  is some fixed root in the algebraic closure of  <span class="math">\\mathbb{Q}</span> .</p>

    <p class="text-gray-300">Let A denote the algebra  <span class="math">A := \\mathbb{F}_2[X]/(F)</span> , then by the Chinese Remainder Theorem we have the natural isomorphisms</p>

    <p class="text-gray-300"><span class="math">$A \\cong \\mathbb{F}_2[X]/(F_1) \\otimes \\cdots \\otimes \\mathbb{F}_2[X]/(F_r),</span>$</p>

    <p class="text-gray-300"><span class="math">$\\cong \\mathbb{F}_{2^d} \\otimes \\cdots \\otimes \\mathbb{F}_{2^d},</span>$</p>

    <p class="text-gray-300">i.e. A is isomorphic to r copies of the finite field  <span class="math">\\mathbb{F}_{2^d}</span> . Arithmetic in A will be defined by polynomial arithmetic in the indeterminate X modulo the polynomial F(X). Our goal in this section is to relate arithmetic in A explicitly with the elements in subfields of the  <span class="math">\\mathbb{F}_{2^d}</span> .</p>

    <p class="text-gray-300">We let  <span class="math">\\theta_i</span>  denote a fixed root of  <span class="math">F_i(X)</span>  in the algebraic closure of  <span class="math">\\mathbb{F}_2</span> . To aid notation we define  <span class="math">\\mathbb{L}_i := \\mathbb{F}_2[X]/(F_i)</span>  and note that all the  <span class="math">\\mathbb{L}_i</span>  are isomorphic as fields, where the isomorphisms are explicitly given by</p>

    <p class="text-gray-300"><span class="math">$\\Lambda_{i,j}: \\left\\{ \\begin{array}{c} \\mathbb{L}_i \\longrightarrow \\mathbb{L}_j \\\\ \\alpha(\\theta_i) \\longmapsto \\alpha(\\rho_{i,j}(\\theta_j)), \\end{array} \\right.</span>$</p>

    <p class="text-gray-300">with  <span class="math">\\rho_{i,j}(\\theta_j)</span>  a fixed root of  <span class="math">F_i</span>  in  <span class="math">\\mathbb{L}_j</span> , i.e. we have  <span class="math">F_i(\\rho_{i,j}(X)) \\equiv 0 \\pmod{F_j(X)}</span> .</p>

    <p class="text-gray-300">For each divisor n of d, the finite field  <span class="math">\\mathbb{K}_n := \\mathbb{F}_{2^n}</span>  is contained in  <span class="math">\\mathbb{F}_{2^d}</span> . We assume a fixed canonical representation for  <span class="math">\\mathbb{K}_n</span>  as  <span class="math">\\mathbb{F}_2[X]/K_n(X)</span>  for some irreducible polynomial  <span class="math">K_n(X) \\in \\mathbb{F}_2[X]</span>  of degree n, which is often fixed by the application. We let  <span class="math">\\psi</span>  denote a fixed root of  <span class="math">K_n(X)</span>  in the algebraic closure of  <span class="math">\\mathbb{F}_2</span> . Since  <span class="math">\\mathbb{K}_n</span>  is contained in each of  <span class="math">\\mathbb{L}_i</span>  defined above, we have explicit homomorphic embeddings given by</p>

    <p class="text-gray-300"><span class="math">$\\Psi_{n,i}: \\left\\{ \\begin{array}{l} \\mathbb{K}_n \\longrightarrow \\mathbb{L}_i \\\\ \\alpha(\\psi) \\longmapsto \\alpha(\\sigma_{n,i}(\\theta_i)) \\,, \\end{array} \\right.</span>$</p>

    <p class="text-gray-300">with  <span class="math">\\sigma_{n,i}(\\theta_i)</span>  a fixed root of  <span class="math">K_n(X)</span>  in  <span class="math">\\mathbb{L}_i</span> , i.e.  <span class="math">K_n(\\sigma_{n,i}(X)) \\equiv 0 \\pmod{F_i(X)}</span> . Note that the above mapping is linear in the coefficients of  <span class="math">\\alpha(\\psi)</span> .</p>

    <p class="text-gray-300">Combining the above homomorphic embedding with the Chinese Remainder Theorem, we obtain a homomorphic embedding of  <span class="math">l \\le r</span>  copies of  <span class="math">\\mathbb{K}_n</span>  into the algebra A via</p>

    <p class="text-gray-300"><span class="math">$\\Gamma_{n,l}: \\left\\{ \\begin{matrix} \\mathbb{K}_n^l &amp; \\longrightarrow &amp; A \\\\ (\\kappa_1(\\psi), \\dots, \\kappa_l(\\psi)) &amp; \\longmapsto \\sum_{i=1}^l \\kappa_i(\\sigma_{n,i}(X)) \\cdot H_i(X) \\cdot G_i(X), \\end{matrix} \\right.</span>$</p>

    <p class="text-gray-300">The polynomials  <span class="math">H_i(X)</span>  and  <span class="math">G_i(X)</span>  are given by the Chinese Remainder Theorem and are defined as</p>

    <p class="text-gray-300"><span class="math">$H_i(X) \\leftarrow F(X)/F_i(X)</span>$
and  <span class="math">G_i(X) \\leftarrow 1/H_i(X) \\pmod{F_i(X)}</span> .</p>

    <p class="text-gray-300">We shall denote component wise addition and multiplication of elements in  <span class="math">\\mathbb{K}_n^l</span>  by  <span class="math">\\mathbf{k}_1 + \\mathbf{k}_2</span>  and  <span class="math">\\mathbf{k}_1 \\times \\mathbf{k}_2</span> . As such we have constructed two equivalent methods of computing with elements in  <span class="math">\\mathbb{K}_n^l</span> : the first method simply computes component wise on vectors of l elements in  <span class="math">\\mathbb{K}_n</span> , whereas the second method first maps all inputs to the algebra A using  <span class="math">\\Gamma_{n,l}</span> , performs computations in A and finally maps back to  <span class="math">\\mathbb{K}_n^l</span>  via  <span class="math">\\Gamma_{n,l}^{-1}</span> . Note that by construction  <span class="math">\\mathbb{K}_n^l</span>  and  <span class="math">\\Gamma_{n,l}(\\mathbb{K}_n^l)</span>  are isomorphic, so that  <span class="math">\\Gamma_n^{-1}</span>  is always well defined on the result of the computation.</p>

    <p class="text-gray-300">The goal of this paper is to produce a fully homomorphic encryption scheme that allows us to work via SIMD operations on l copies of  <span class="math">\\mathbb{K}_n</span>  at a time, for all n dividing d, by computing in the algebra A. In particular, this enables us to support SIMD operations both in  <span class="math">\\mathbb{F}_2</span>  and  <span class="math">\\mathbb{F}_{2^d}</span> . To make things concrete the reader should consider the example of F(X) being the 3485-th cyclotomic polynomial. In this situation the polynomial F(X) has degree  <span class="math">N=\\varphi(3485)=2560</span> , and modulo two it factors into 64 polynomials each of degree 40. This polynomial therefore allows us to compute in parallel with up to 64 elements of any subfield of  <span class="math">\\mathbb{F}_{2^{40}}</span> . For instance, by selecting n=1 and l=64 we perform 64 operations in  <span class="math">\\mathbb{F}_2</span>  in parallel; selecting n=40 and l=1 we perform operations in a single copy of the finite field  <span class="math">\\mathbb{F}_{2^{40}}</span> ; whereas selecting n=8 and l=16 we perform SIMD operations on what is essentially the AES state matrix, namely 16 elements of  <span class="math">\\mathbb{F}_{2^8}</span> .</p>

    <p class="text-gray-300">In this section, we recall the Smart–Vercauteren variant of Gentry's somewhat homomorphic scheme and show that it can support SIMD operations in r copies of the finite field  <span class="math">\\mathbb{K}_n</span>  by modifying key generation. Note that the recent FHE schemes based on ring-LWE [2] also support such style operations, and may be preferable in practice due to their improved key generation procedures, we leave it to the reader to extend our work to these new schemes. However, whilst our SIMD style operations extend to the ring-LWE based somewhat homomorphic schemes, our parallel recryption step does not carry over. We will return to this point later on.</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">3.1 Smart-Vercauteren somewhat homomorphic scheme</h4>

    <p class="text-gray-300">Let  <span class="math">F \\in \\mathbb{Z}[X]</span>  be a monic irreducible polynomial of degree N and let  <span class="math">\\mathbb{K} = \\mathbb{Q}(\\theta) = \\mathbb{Q}[X]/(F)</span>  denote the number field defined by F. Gentry's original scheme uses two co-prime ideals I and J in the number ring  <span class="math">\\mathbb{Z}[\\theta]</span> . The ideal I is chosen to have small norm  <span class="math">\\mathcal{N}(I) = \\sharp(\\mathbb{Z}[\\theta]/I)</span>  and determines the plaintext space, namely  <span class="math">\\mathbb{Z}[\\theta]/I</span> . For this reason, I = (2) is chosen in practice. Note that in the case of a general F the quotient ring  <span class="math">\\mathbb{Z}[\\theta]/(2)</span>  is an algebra of a somewhat more general type than discussed in Section 2. We shall choose F later on such that one obtains precisely the type of algebra considered in Section 2. The ideal J determines the private/public key pair: the private key consists of a &quot;good&quot; representation of J, whereas the public key consists of a &quot;bad&quot; representation of J.</p>

    <p class="text-gray-300">To clarify the notions of &quot;good&quot; and &quot;bad&quot;, we first describe the Smart-Vercauteren instantiation. The ideal J is chosen to be principal, i.e. generated by one element  <span class="math">\\gamma \\in \\mathbb{Z}[\\theta]</span> , and has the following additional property: let  <span class="math">d = \\mathcal{N}(J) = \\sharp(\\mathbb{Z}[\\theta]/J) = |N_{\\mathbb{K}/\\mathbb{Q}}(\\gamma)|</span> , where  <span class="math">N_{\\mathbb{K}/\\mathbb{Q}}(\\cdot)</span>  denotes the number field norm of  <span class="math">\\mathbb{K}</span>  to  <span class="math">\\mathbb{Q}</span> , then there must exist a unique  <span class="math">\\alpha \\in \\mathbb{Z}_d</span>  such that</p>

    <p class="text-gray-300"><span class="math">$J = (\\gamma) = (d, \\theta - \\alpha)</span>$
.</p>

    <p class="text-gray-300">The &quot;good&quot; representation of J (i.e. the private key) corresponds to the small generator  <span class="math">\\gamma</span> , whereas the &quot;bad&quot; representation (i.e. public key) is  <span class="math">(d, \\theta - \\alpha)</span> . The additional property of J is equivalent with the requirement that the Hermite Normal Form representation of J has the following specific form</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} d &amp; 0 &amp; 0 \\dots 0 \\\\ -\\alpha &amp; 1 &amp; 0 &amp; 0 \\\\ -\\alpha^2 &amp; 0 &amp; 1 &amp; 0 \\\\ \\vdots &amp; &amp; \\ddots \\\\ -\\alpha^{N-1} &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix},</span>$</p>

    <p class="text-gray-300">where the entries below d in the first column are taken modulo d. Another characterisation of this property is that the ideal J simply contains an element of the form  <span class="math">\\theta - \\alpha</span> . This is clearly necessary since J can be generated by  <span class="math">(d, \\theta - \\alpha)</span> , but it is also sufficient. Indeed, since  <span class="math">\\gamma \\in J</span> , this implies that  <span class="math">d \\in J</span> , so  <span class="math">(d, \\theta - \\alpha) \\subset J</span>  and since both ideals have the same norm, we must have  <span class="math">J = (d, \\theta - \\alpha)</span> . As such, there exists an element  <span class="math">\\nu \\in \\mathbb{Z}[\\theta]</span>  with  <span class="math">\\nu \\cdot \\gamma = \\theta - \\alpha</span> . To derive an easy verifiable condition on  <span class="math">\\gamma</span> , we define the algebraic number  <span class="math">\\zeta \\in \\mathbb{Z}[\\theta]</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\zeta \\cdot \\gamma = d. \\tag{1}</span>$</p>

    <p class="text-gray-300">Multiplying  <span class="math">\\nu \\cdot \\gamma = \\theta - \\alpha</span>  on both sides with  <span class="math">\\zeta</span>  gives the condition  <span class="math">d \\cdot \\nu = \\theta \\cdot \\zeta - \\alpha \\cdot \\zeta</span> . Write  <span class="math">\\zeta = \\sum_{i=0}^{N-1} \\zeta_i \\cdot \\theta^i</span>  and  <span class="math">F(X) = \\sum_{i=0}^{N} F_i \\cdot X^i</span> , then computing the product  <span class="math">\\theta \\cdot \\zeta</span>  explicitly and reducing modulo d finally leads to:</p>

    <p class="text-gray-300"><span class="math">$\\alpha \\cdot \\zeta_i = \\zeta_{i-1} - \\zeta_{N-1} F_i \\bmod d, \\tag{2}</span>$</p>

    <p class="text-gray-300">for all i = 0, ..., N - 1 where  <span class="math">\\zeta_{-1} = 0</span> .</p>

    <p class="text-gray-300">Note that the two element representation  <span class="math">(d, \\theta - \\alpha)</span>  defines an easily computable homomorphism</p>

    <p class="text-gray-300"><span class="math">$H: \\mathbb{Z}[\\theta] \\to \\mathbb{Z}_d: \\eta = \\sum_{i=0}^{N-1} \\eta_i \\cdot \\theta^i \\mapsto H(\\eta) = \\sum_{i=0}^{N-1} \\eta_i \\cdot \\alpha^i \\mod d.</span>$
(3)</p>

    <p class="text-gray-300">The homomorphism H also makes it very easy to test if an element  <span class="math">\\eta \\in \\mathbb{Z}[\\theta]</span>  is contained in the ideal J, namely  <span class="math">\\eta \\in J</span>  if and only if  <span class="math">H(\\eta) = 0</span> . Furthermore, given the &quot;good&quot; representation  <span class="math">\\gamma</span> , it is possible to invert H on a small subset of  <span class="math">\\mathbb{Z}[\\theta]</span>  as shown by the following lemma.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Let  <span class="math">J = (\\gamma) = (d, \\theta - \\alpha)</span>  and  <span class="math">\\zeta \\cdot \\gamma = d</span>  and let H be defined as in (3). Let  <span class="math">\\eta \\in \\mathbb{Z}[\\theta]</span>  with  <span class="math">\\|\\eta\\|_{\\infty} &lt; U</span> , then we have</p>

    <p class="text-gray-300"><span class="math">$\\eta = H(\\eta) - \\left\\lceil \\frac{H(\\eta) \\cdot \\zeta}{d} \\right\\rfloor \\cdot \\gamma \\qquad \\textit{for} \\qquad U = \\frac{d}{2 \\cdot \\delta_\\infty \\cdot \\|\\zeta\\|_\\infty} \\,,</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\delta_{\\infty} = \\sup\\left\\{\\frac{\\|\\mu\\cdot\\nu\\|_{\\infty}}{\\|\\mu\\|_{\\infty}\\cdot\\|\\nu\\|_{\\infty}}: \\mu,\\nu\\in\\mathbb{Z}[\\theta]\\right\\}</span> . Furthermore, for  <span class="math">\\|\\eta\\|_{\\infty} &lt; U</span>  we have</p>

    <p class="text-gray-300"><span class="math">$[H(\\eta) \\cdot \\zeta]_d = [\\eta \\cdot \\zeta]_d = \\eta \\cdot \\zeta. \\tag{4}</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> It is easy to see that  <span class="math">H(\\eta) - \\eta</span>  is contained in the principal ideal generated by  <span class="math">\\gamma</span> . As such, there exists a  <span class="math">\\beta \\in \\mathbb{Z}[\\theta]</span>  such that  <span class="math">H(\\eta) - \\eta = \\beta \\cdot \\gamma</span> . Using  <span class="math">\\zeta = d/\\gamma</span> , we can write</p>

    <p class="text-gray-300"><span class="math">$\\beta = \\frac{H(\\eta) \\cdot \\zeta}{d} - \\frac{\\eta \\cdot \\zeta}{d} \\,. \\tag{5}</span>$</p>

    <p class="text-gray-300">Since  <span class="math">\\beta</span>  has integer coefficients, we can recover it by rounding the coefficients of the first term if the coefficients of the second term are strictly bounded by 1/2. This shows that  <span class="math">\\eta</span>  can be recovered from  <span class="math">H(\\eta)</span>  for  <span class="math">\\|\\eta\\|_{\\infty} &lt; d/(2 \\cdot \\delta_{\\infty} \\cdot \\|\\zeta\\|_{\\infty})</span> . Furthermore, equation (5) shows that  <span class="math">[H(\\eta) \\cdot \\zeta]_d = [\\eta \\cdot \\zeta]_d</span>  and since  <span class="math">\\|\\eta\\|_{\\infty} &lt; U</span> , we have  <span class="math">[\\eta \\cdot \\zeta]_d = \\eta \\cdot \\zeta</span> .</p>

    <p class="text-gray-300"><strong>Corollary 1.</strong> Using the notation of Lemma 1, assume that  <span class="math">\\|\\eta\\|_{\\infty} &lt; U/L</span> , then for i = 0, ..., N-1 we have</p>

    <p class="text-gray-300"><span class="math">$-\\frac{1}{2L} &lt; \\frac{H(\\eta) \\cdot \\zeta_i}{d} - \\left\\lceil \\frac{H(\\eta) \\cdot \\zeta_i}{d} \\right\\rceil &lt; \\frac{1}{2L},</span>$</p>

    <p class="text-gray-300">i.e.  <span class="math">H(\\eta) \\cdot \\zeta_i/d</span>  is within distance 1/2L of an integer.</p>

    <p class="text-gray-300"><em>Proof.</em> Follows directly from equation (5) and the assumption on  <span class="math">\\eta</span> .</p>

    <p class="text-gray-300">The above lemma shows that we can recover an element  <span class="math">\\eta</span>  from its image under H, when its norm is not too large. As such we obtain a trapdoor one way function that can be used as the basis for encryption. Using these preliminaries we are now ready to define key generation, encryption and decryption.</p>

    <p class="text-gray-300">KEY GENERATION: Input parameters: N, t</p>

    <p class="text-gray-300">Generate a monic irreducible polynomial  <span class="math">F \\in \\mathbb{Z}[X]</span>  of degree N with small coefficients, defining the number field  <span class="math">\\mathbb{K} = \\mathbb{Q}(\\theta) = \\mathbb{Q}[X]/(F)</span> . Choose an element  <span class="math">\\gamma \\in \\mathbb{Z}[\\theta]</span>  with  <span class="math">\\gamma = 1 \\mod 2</span>  such that the coefficients of  <span class="math">\\gamma</span>  are smaller in absolute value than  <span class="math">2^t</span>  (at least one coefficient should be a t-bit integer). Compute the norm  <span class="math">d = |N_{\\mathbb{K}/\\mathbb{Q}}(\\gamma)|</span>  as well as the element  <span class="math">\\zeta \\in \\mathbb{Z}[\\theta]</span>  with  <span class="math">\\zeta \\cdot \\gamma = d</span> . If d is even, choose a new  <span class="math">\\gamma</span> . If d is odd, compute  <span class="math">\\alpha = -\\zeta_{N-1} \\cdot F_0/\\zeta_0</span>  and verify whether (2) holds for all  <span class="math">i = 1, \\ldots, N-1</span> . If not, generate a new  <span class="math">\\gamma</span> . Otherwise, the public key is the pair  <span class="math">\\mathsf{pk} := (d, \\alpha)</span>  whereas the private key is the element  <span class="math">\\mathsf{sk} := \\zeta</span> .</p>

    <p class="text-gray-300">In practice, N will be of the order a few thousand and t a few hundred. The size of d can be approximated roughly by  <span class="math">N^N \\cdot 2^{Nt}</span> ; this therefore results in a d of several million bits.</p>

    <p class="text-gray-300">ENCRYPTION: Input parameters:  <span class="math">\\mu</span> , pk :=  <span class="math">(d, \\alpha)</span> , message  <span class="math">M \\in A := \\mathbb{F}_2[X]/(F(X))</span></p>

    <p class="text-gray-300">The plaintext space consists of (a subalgebra of) the algebra  <span class="math">A := \\mathbb{F}_2[X]/(F(X))</span> . Represent the message M as a polynomial  <span class="math">M(X) \\in \\mathbb{Z}[X]</span>  with coefficients in  <span class="math">\\{0,1\\}</span> . Generate a &quot;noise&quot; polynomial  <span class="math">R(X) \\in \\mathbb{Z}[X]</span>  of degree &lt; N with  <span class="math">\\|R(X)\\|_{\\infty} \\le \\mu</span>  and compute the ciphertext as</p>

    <p class="text-gray-300"><span class="math">$c \\leftarrow [M(\\alpha) + 2 \\cdot R(\\alpha)]_d</span>$
.</p>

    <p class="text-gray-300">Note that the ciphertext is an element in  <span class="math">\\mathbb{Z}_d</span>  and that encryption simply corresponds to applying the homomorphism H to the algebraic integer  <span class="math">C(\\theta) := M(\\theta) + 2 \\cdot R(\\theta)</span> . Furthermore, it should be clear that if we can recover  <span class="math">C(\\theta)</span> , then we can decrypt simply by computing  <span class="math">C(X) \\mod 2</span> . The encryption function is denoted as  <span class="math">c \\leftarrow \\operatorname{Encrypt}(M(X), \\operatorname{pk})</span> . If  <span class="math">M(X) \\in A</span>  then we say  <span class="math">M \\big|_{\\alpha} = M(\\alpha) \\pmod{d}</span>  is a &quot;trivial&quot; encryption of M(X), i.e. it is an encryption with no randomness.</p>

    <p class="text-gray-300">&lt;u&gt;DECRYPTION&lt;/u&gt;: Input parameters: ciphertext  <span class="math">c \\in \\mathbb{Z}_d</span> , sk :=  <span class="math">\\zeta</span>  Given the ciphertext  <span class="math">c \\in \\mathbb{Z}_d</span> , compute the element  <span class="math">C(\\theta)</span>  as</p>

    <p class="text-gray-300"><span class="math">$C(\\theta) = c - \\left\\lceil \\frac{c \\cdot \\zeta}{d} \\right\\rceil</span>$
,</p>

    <p class="text-gray-300">and then set  <span class="math">M(X) = C(X) \\mod 2</span> . Note that here we used the fact that  <span class="math">\\gamma \\equiv 1 \\mod 2</span> . We can obtain a simpler decryption procedure using the last statement in Lemma 1. Indeed, if c is a decryptable ciphertext, we know that  <span class="math">\\|C(\\theta)\\|_{\\infty} &lt; U</span>  and thus that</p>

    <p class="text-gray-300"><span class="math">$[c \\cdot \\zeta]_d = C(\\theta) \\cdot \\zeta</span>$
.</p>

    <p class="text-gray-300">Since  <span class="math">\\gamma \\equiv 1 \\mod 2</span>  and d is odd with  <span class="math">d = \\gamma \\cdot \\zeta</span> , we see that also  <span class="math">\\zeta \\equiv 1 \\mod 2</span> . Furthermore,  <span class="math">C(\\theta) = M(\\theta) + 2R(\\theta)</span> , so we obtain</p>

    <p class="text-gray-300"><span class="math">$[c \\cdot \\zeta]_d \\mod 2 = M(\\theta) \\mod 2 = M(X)</span>$
.</p>

    <p class="text-gray-300">This shows that for  <span class="math">\\zeta = \\sum_{i=0}^{N-1} \\zeta_i \\theta^i</span>  we can recover the coefficients of  <span class="math">M(X) = m_0 + m_1 \\cdot X + \\dots + m_{N-1} \\cdot X^{N-1}</span>  one by one, by computing</p>

    <p class="text-gray-300"><span class="math">$m_i = [c \\cdot \\zeta_i]_d \\pmod{2}</span>$
.</p>

    <p class="text-gray-300">We write  <span class="math">M(X) \\leftarrow \\mathsf{Decrypt}(c, \\mathsf{sk})</span> . Note that to save space for key storage, it suffices to store  <span class="math">\\zeta_0</span> , since the other  <span class="math">\\zeta_i</span>  follow from equation (2). In particular, we obtain the closed expression  <span class="math">\\zeta_i = w_i \\cdot \\zeta_0</span>  with</p>

    <p class="text-gray-300"><span class="math">$w_i = -\\frac{1}{F_0} \\left( \\sum_{j=i+1}^N F_j \\cdot \\alpha^{j-i} \\right) \\pmod{d}. \\tag{6}</span>$</p>

    <p class="text-gray-300">Since the  <span class="math">w_i</span>  can be publicly computed, we can decrypt  <span class="math">m_i = [c \\cdot w_i \\cdot \\zeta_0]_d \\pmod{2}</span> . We pause to note that it is this linear relationship between the distinct decryption keys  <span class="math">\\zeta_i</span>  which enables the parallel recryption procedure we describe later. For ring-LWE based somewhat homomorphic schemes supporting SIMD operations, where such a simple linear relation does not hold, it seems much harder to produce a parallel recryption procedure using the squashing paradigm of Gentry.</p>

    <p class="text-gray-300">&lt;u&gt;HOMOMORPHIC OPERATIONS&lt;/u&gt;: It is easy to see that the scheme is somewhat homomorphic, where the operations being performed are addition and multiplication of ciphertexts modulo d. Indeed, let  <span class="math">c_i = H(C_i(\\theta)) = H(M_i(\\theta) + 2R_1(\\theta))</span>  for i = 1, 2, then we have that</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} c_1 + c_2 &amp;= H(M_1(\\theta) + M_2(\\theta) + 2(R_1(\\theta) + R_2(\\theta))) \\\\ c_1 \\cdot c_2 &amp;= H(M_1(\\theta) \\cdot M_2(\\theta) + 2(M_1(\\theta)R_2(\\theta) + M_2(\\theta)R_1(\\theta) + 2R_1(\\theta)R_2(\\theta))) \\,. \\end{split}</span>$</p>

    <p class="text-gray-300">This shows that operations on the ciphertext space induce corresponding operations on the plaintext space, i.e. the algebra A. Thus it is clear that the somewhat homomorphic scheme supports SIMD operations and operations on elements in possibly large degree (i.e. degree n) finite fields. To make a distinction when we are performing homomorphic operations we will use the notation  <span class="math">\\oplus</span>  and  <span class="math">\\odot</span>  to denote the homomorphic addition and multiplication of ciphertexts.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">3.2 Efficient key generation and SIMD operations</h4>

    <p class="text-gray-300">Whilst the FHE scheme works for any polynomial F with small coefficients, the common case, as in [10] and [16], is to use the polynomial  <span class="math">F(X) := X^{2^n} + 1</span> . As pointed out by Gentry and Halevi [10] this leads to a major improvement in the key generation procedure over that proposed by Smart and Vercauteren [16]. If we let  <span class="math">\\eta_i</span>  denote the roots of the polynomial F over the complex numbers, or over a sufficiently large finite field, then we can compute  <span class="math">\\zeta</span>  and d as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">\\omega_i \\leftarrow \\gamma(\\eta_i) \\in \\mathbb{C}</span>  for all i.</li>
      <li>Compute  <span class="math">d \\leftarrow \\prod \\omega_i</span> .</li>
      <li>Compute  <span class="math">\\omega_i^* \\leftarrow 1/\\omega_i</span> .</li>
      <li>Interpolate the polynomial  <span class="math">\\zeta/d</span>  from the data values  <span class="math">\\omega_i^*</span> .</li>
    </ul>

    <p class="text-gray-300">The key observation is that since F(X) is of the form  <span class="math">X^{2^n} + 1</span> , the  <span class="math">\\eta_i</span>  are  <span class="math">2^{n+1}</span> -th roots of unity and so to perform the polynomial evaluation and interpolation above we can apply the Fast Fourier Transform (FFT). Indeed, Gentry and Halevi present an even more optimized scheme to compute d and  <span class="math">\\zeta</span>  which requires only polynomial arithmetic, but this makes significant use of the fact that the trace of 2-power roots of unity is always zero.</p>

    <p class="text-gray-300">The problem with selecting  <span class="math">F(X) = X^{2^n} + 1</span>  is that it has only one irreducible factor modulo two. In particular if we select  <span class="math">F(X) = X^{2^n} + 1</span>  then the underlying plaintext algebra is given by</p>

    <p class="text-gray-300"><span class="math">$A := \\mathbb{F}_2[X]/(F) \\cong \\mathbb{F}_2[X]/(X-1)^{2^n}.</span>$</p>

    <p class="text-gray-300">In other words, F does not split into a set of <em>distinct</em> irreducible factors modulo two as we required to enable SIMD operations.</p>

    <p class="text-gray-300">We now present a possible replacement for F(X). The key observation is that we need an F(X) which enables fast key generation via FFT like algorithms, which has small coefficients, and which splits into distinct irreducible factors modulo two of the same degree. In addition we need a relatively large supply of such polynomials to cope with increasing security levels (i.e. N), different numbers of parallel operations (i.e. N) and different degree two finite fields</p>

    <p class="text-gray-300">in which operations occur (i.e. n). In particular need to pick an F(X) which generates a Galois extension of degree n. In addition we need to select a polynomial F(X) such that 2 is neither ramified, nor an index divisor, in the associated number field generated by a root of F(X). These conditions ensure that the algebra mod two splits into distinct finite fields of the same degree.</p>

    <p class="text-gray-300">One is then led to consider other cyclotomic polynomials as follows. We select an odd integer m and recall that the m-th cyclotomic polynomial is defined by</p>

    <p class="text-gray-300"><span class="math">$\\Phi_m(X) := \\prod_{\\eta} (X - \\eta)</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\eta</span>  ranges over all m-th primitive roots of unity. We have  <span class="math">\\deg(\\Phi_m(X)) = \\phi(m)</span> , and that  <span class="math">\\Phi_m(X)</span>  is an irreducible polynomial with integer coefficients. In the practical range for m, the coefficients of  <span class="math">\\Phi_m</span>  are very small, e.g. for all  <span class="math">m \\leq 40000</span>  the coefficients are bounded by 59 and are in most cases much smaller than this upper bound.</p>

    <p class="text-gray-300">The field  <span class="math">\\mathbb{Q}(\\theta)</span>  is a Galois extension and hence each prime ideal splits in  <span class="math">\\mathbb{Q}(\\theta)</span>  into a product of prime ideals of the same degree and ramification index. If m is odd then the prime two does not ramify in the field  <span class="math">\\mathbb{Q}(\\theta)</span> , nor is it an index divisor. In particular, by Dedekind's criterion, this means that the polynomial  <span class="math">\\Phi_m(X)</span> , of degree  <span class="math">N = \\phi(m)</span> , factors modulo two into a product of r = N/d distinct irreducible polynomials of degree equal to the unique degree d of the prime ideals lying above the ideal (2). This degree d is the smallest integer such that  <span class="math">2^d \\equiv 1 \\pmod{m}</span> .</p>

    <p class="text-gray-300">Hence, by selecting  <span class="math">F(X) := \\Phi_m(X)</span>  in our construction of the algebra A over  <span class="math">\\mathbb{F}_2</span> , we find that A is isomorphic to a product of r finite fields of degree d = N/r. The only issue is whether one can perform the key generation efficiently. To do this we use Fourier Transforms with respect to the m-th roots of unity. In particular given the polynomial  <span class="math">\\gamma</span>  in the key generation procedure we compute the evaluation at the m-th roots of unity via a Fourier Transform, and produce the norm d by selecting the N required values to multiply together (consisting of the evaluations of the primitive roots of unity). One can then compute  <span class="math">1/\\gamma</span>  by inverting the Fourier coefficients and then interpolating via the inverse Fourier Transform.</p>

    <p class="text-gray-300">In other words the same optimization as mentioned earlier can be applied: Instead of taking the standard Cooley-Tukey [6] FFT method for powers of two, we apply the Good-Thomas method [11, 18] for when m is a product of two coprime integers, or Cooley-Tukey when m is a prime power. Either method reduces the problem to computing FFTs for prime power values of m, for which we can use the Rader FFT algorithm [15]. This in itself reduces the problem to computing a convolution of two sequences, which is then performed by extension of the sequences to length a power of two followed by the application of the Cooley-Tukey algorithm to the extended sequence. Overall the FFT then takes  <span class="math">O(m \\cdot \\log m)</span>  operations on elements of size  <span class="math">O(\\log_2 d)</span>  bits. In practice  <span class="math">m \\approx 2 \\cdot N</span>  and so this gives the same complexity for key generation as using  <span class="math">F(X) = X^{2^n} + 1</span> , however the implied constants are slightly greater. This means we can achieve almost the same complexity for key generation as in the 2-power root of unity case.</p>

    <p class="text-gray-300">To turn the somewhat homomorphic scheme of the previous section into a fully homomorphic scheme, we follow Gentry's bootstrapping approach, i.e. we squash the decryption circuit so much that it can be evaluated by the somewhat homomorphic scheme. In particular, we use the optimized procedure described by Gentry and Halevi in [10].</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">4.1 Recryption Method</h4>

    <p class="text-gray-300">Recall that each message bit  <span class="math">m_i</span>  can be recovered as  <span class="math">m_i = [c \\cdot w_i \\cdot \\zeta_0]_d \\pmod 2</span>  with the  <span class="math">w_i</span>  being publicly computable constants defined in (6). Since  <span class="math">[c \\cdot w_i]_d</span>  can be computed without knowledge of  <span class="math">\\zeta_0</span>  it suffices to show how  <span class="math">[c \\cdot \\zeta_0]_d \\pmod 2</span>  can be computed with a low complexity circuit.</p>

    <p class="text-gray-300">The idea is to write the private key  <span class="math">\\zeta_0</span>  as the solution to a sparse-subset-sum problem. In particular, we will define s sets of S elements as follows (a discussion on the sizes of s and S will be given later): choose s elements  <span class="math">x_i \\in [0, \\ldots, d)</span> , a random integer  <span class="math">R \\in [1, \\ldots, d)</span>  and define the i-th set  <span class="math">\\mathcal{B}_i = \\{x_i \\cdot R^j \\pmod{d} \\mid j \\in [0, \\ldots, S)\\}</span>  such that the private key  <span class="math">\\zeta_0</span>  can be written as the sum</p>

    <p class="text-gray-300"><span class="math">$\\zeta_0 = \\sum_{i=1}^{s} \\sum_{j=0}^{S-1} b_{i,j} \\cdot x_i \\cdot R^j \\pmod{d},</span>$</p>

    <p class="text-gray-300">where for each i only one  <span class="math">b_{i,j}=1</span>  and all other  <span class="math">b_{i,j}</span>  are zero. The index j for which  <span class="math">b_{i,j}=1</span>  will be denoted by  <span class="math">e_i</span>  and so we can write  <span class="math">\\zeta_0=\\sum_{i=1}^s x_i\\cdot R^{e_i}\\pmod d</span> . The result is that we have written  <span class="math">\\zeta_0</span>  as the sum of s elements, where one element is taken from each  <span class="math">\\mathcal{B}_i</span> . To enable recryption or ciphertext cleaning, we will augment the public key with additional information: compute the ciphertexts  <span class="math">c_{i,j}\\leftarrow \\mathsf{Encrypt}(b_{i,j},\\mathsf{pk})</span>  for  <span class="math">1\\leq i\\leq s,\\ 0\\leq j&lt; S</span> , then the public key now consists of the data</p>

    <p class="text-gray-300"><span class="math">$\\left(d, \\alpha, s, S, R, \\left\\{x_i, \\left\\{c_{i,j}\\right\\}_{j=0}^{S-1}\\right\\}_{i=1}^{s}\\right).</span>$</p>

    <p class="text-gray-300">Denote  <span class="math">y_{i,j} = c \\cdot x_i \\cdot R^j \\pmod{d}</span>  for  <span class="math">i = 1, \\dots, s</span>  and  <span class="math">j = 0, \\dots, S-1</span>  such that  <span class="math">0 \\le y_{i,j} &lt; d</span> , then the decryption function  <span class="math">[c \\cdot \\zeta_0]_d \\pmod{2}</span>  can be rewritten as</p>

    <p class="text-gray-300"><span class="math">$[c \\cdot \\zeta_0]_d \\pmod{2} = \\left[ \\sum_{i=1}^s \\sum_{j=0}^{S-1} b_{i,j} \\cdot y_{i,j} \\right]_d \\pmod{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\left( \\sum_{i=1}^s \\sum_{j=0}^{S-1} b_{i,j} \\cdot y_{i,j} \\right) - d \\cdot \\left[ \\sum_{i=1}^s \\sum_{j=0}^{S-1} b_{i,j} \\cdot \\frac{y_{i,j}}{d} \\right] \\pmod{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\bigoplus_{i=1}^s \\bigoplus_{j=0}^{S-1} b_{i,j} \\cdot y_{i,j} \\pmod{2} \\oplus \\left[ \\sum_{i=1}^s \\sum_{j=0}^{S-1} b_{i,j} \\cdot \\frac{y_{i,j}}{d} \\right] \\pmod{2}.</span>$</p>

    <p class="text-gray-300">Note that the latter double sum  <span class="math">\\mathcal{T} = \\sum_{i=1}^s \\sum_{j=0}^{S-1} b_{i,j} \\cdot \\frac{y_{i,j}}{d}</span>  is equal to  <span class="math">c \\cdot \\zeta_0/d</span>  and if we assume that c is the image of  <span class="math">C(\\theta)</span>  under H, where  <span class="math">\\|C(\\theta)\\|_{\\infty} &lt; U/(s+1)</span> , then we know by Corollary 1 that  <span class="math">\\mathcal{T}</span>  is within distance 1/2(s+1) of an integer. If we now replace each  <span class="math">\\frac{y_{i,j}}{d}</span>  with an approximation  <span class="math">z_{i,j}</span>  up to p bits after the binary point, i.e.  <span class="math">|z_{i,j} - y_{i,j}/d| &lt; 2^{-(p+1)}</span> , then since there are only s non-zero terms, we have that  <span class="math">|\\mathcal{T} - \\sum_{i=1}^s \\sum_{j=0}^{S-1} b_{i,j} \\cdot z_{i,j}| &lt; s \\cdot 2^{-(p+1)}</span> . Rounding the double sum over the  <span class="math">z_{i,j}</span>  will thus give the same result as rounding  <span class="math">\\mathcal{T}</span>  as long as</p>

    <p class="text-gray-300"><span class="math">$\\frac{1}{2(s+1)} + s \\cdot 2^{-(p+1)} &lt; 1/2 \\,,</span>$</p>

    <p class="text-gray-300">which implies that  <span class="math">p \\ge \\lceil \\log_2(s+1) \\rceil</span> . Furthermore, in the inner sum we are adding S numbers of which only one is non-zero. As such, we can compute the k-th bit of this sum by simply XOR-ing the k-th bits of the  <span class="math">b_{i,j} \\cdot z_{i,j}</span>  for  <span class="math">j = 1, \\ldots, S</span> . We are then left with an addition of s numbers, each which consists of p bits after the binary point.</p>

    <p class="text-gray-300">We are now ready to formulate the recrypt algorithm by mapping these equations into the encrypted domain. To this end, we require two helper functions. The first function  <span class="math">\\mathbf{b} \\leftarrow \\mathsf{compute\\_bits}(y)</span>  takes as input an integer  <span class="math">0 \\le y &lt; d</span>  and outputs the vector of bits  <span class="math">\\mathbf{b} = (b_0, b_1, \\dots, b_p)</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\left| \\frac{y}{d} - (b_0 + \\frac{b_1}{2} + \\frac{b_2}{2^2} + \\dots + \\frac{b_p}{2^p}) \\right| &lt; \\frac{1}{2^{p+1}}.</span>$</p>

    <p class="text-gray-300">This is easily computed by determining  <span class="math">u \\leftarrow \\lceil (2^p \\cdot y)/d \\rceil</span> , and then reading the bits from the (small) integer u.</p>

    <p class="text-gray-300">The second function school_book_add(A) takes as input an  <span class="math">s \\times (p+1)</span>  array A of ciphertexts, where each row contains the encryptions of the (p+1) bits of an integer. The result of the function is a (p+1) vector containing the encryptions of the (p+1) bits of the sum of these s integers modulo  <span class="math">2^{p+1}</span> . The school book method is discussed in more detail in [10] where it is shown that it requires</p>

    <p class="text-gray-300"><span class="math">$T_{\\mathsf{school\\_book\\_add}} := \\left(s \\cdot 2^{p-1} + \\sum_{k=1}^{p-1} (s+k) \\cdot 2^{p-k}\\right) \\cdot T_{\\mathsf{mod},d}</span>$</p>

    <p class="text-gray-300">where  <span class="math">T_{\\text{mod},d}</span>  denotes the cost of one multiplication modulo d.</p>

    <p class="text-gray-300">In Algorithm 1 we present the algorithm for recrypting the first bit of the message underlying a ciphertext c, i.e. the algorithm computes  <span class="math">[c \\cdot \\zeta_0]_d \\pmod 2</span>  in the encrypted domain using the augmented public key. This is essentially the recryption algorithm used by Gentry and Halevi, where the message space is one bit only. To obtain the recyption of the i-th coefficient we simly input  <span class="math">[c \\cdot w_i]_d</span>  instead of c, since decrypting the i-th bit is given by  <span class="math">[c \\cdot w_i \\cdot \\zeta_0]_d \\pmod 2</span> .</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6"><strong>Algorithm 1:</strong> BitRecrypt(c, pk): Recrypting the First Bit of the Plaintext Associated With Ciphertext c</h4>

    <pre><code class="language-text">A \\leftarrow 0, \\text{ where } A \\in M_{s \\times (p+1)}(\\mathbb{Z}_d).
\\text{sum} \\leftarrow 0.
\\text{for } i \\text{ from } 1 \\text{ upto } s \\text{ do}
y \\leftarrow c \\cdot x_i \\pmod{d}.
\\text{for } j \\text{ from } 0 \\text{ upto } S - 1 \\text{ do}
\\text{if } y \\text{ is odd then}
\\text{sum} \\leftarrow \\text{sum} \\oplus c_{i,j}.
\\text{b} \\leftarrow \\text{compute\\_bits}(y).
\\text{for } u \\text{ from } 0 \\text{ upto } p \\text{ do}
A_{i,u} \\leftarrow A_{i,u} \\oplus (\\mathbf{b}_u \\cdot c_{i,j}).
y \\leftarrow y \\cdot R \\pmod{d}.
\\text{a} \\leftarrow \\text{school\\_book\\_add}(A).
\\overline{c} \\leftarrow \\text{sum} \\oplus \\mathbf{a}_0.
\\text{return } (\\overline{c}).
</code></pre>

    <p class="text-gray-300">We denote the cost of executing this algorithm for a one bit ciphertext as  <span class="math">T_{\\text{bits}}</span> . Ignoring the modular additions, we see that  <span class="math">T_{\\text{bits}} = \\left( (S+1) \\cdot s \\cdot + s \\cdot 2^{p-1} + \\sum_{k=1}^{p-1} (s+k) \\cdot 2^{p-k} \\right) \\cdot T_{\\text{mod},d}</span> .</p>

    <p class="text-gray-300">To recrypt a whole ciphertext c, we first form ciphertexts  <span class="math">\\overline{c}_i = \\text{BitRecrypt}([c \\cdot w_i]_d, \\text{pk})</span>  for  <span class="math">i = 0, \\dots, N-1</span> , which are recryptions of the coefficients of the underlying polynomial M(X) by submitting  <span class="math">[c \\cdot w_i]_d</span>  to Algorithm 1. Then given  <span class="math">\\overline{c}_i</span>  we form the ciphertext</p>

    <p class="text-gray-300"><span class="math">$\\overline{c} \\leftarrow \\sum_{i=0}^{N-1} \\overline{c}_i \\odot \\alpha^i</span>$</p>

    <p class="text-gray-300">which will be a recryption of the original ciphertext. Note, to control the noise this last sum is computed naively, and not via Horner's rule, i.e. we multiply each coefficient ciphertext  <span class="math">\\bar{c}_i</span>  by  <span class="math">\\alpha^i \\pmod{d}</span>  and then sum. The resulting algorithm is summarized in Algorithm 2. Assuming the  <span class="math">\\alpha^i \\pmod{d}</span>  and  <span class="math">w_i</span>  are precomputed, the total cost of recrypting a</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8"><strong>Algorithm 2:</strong> Recrypting Ciphertext c version 1</h3>

    <pre><code class="language-text">\\bar{c} \\leftarrow 0.

for i from 0 upto N-1 do
\\bar{c}_i \\leftarrow \\mathsf{BitRecrypt}([c \\cdot w_i]_d, \\mathsf{pk}).
\\bar{c} \\leftarrow \\bar{c} \\oplus \\bar{c}_i \\odot \\alpha^i.

return (\\bar{c}).
</code></pre>

    <p class="text-gray-300">ciphertext corresponding to an arbitrary element in A (using our naive method) is essentially  <span class="math">N \\cdot T_{\\text{bits}} + 2 \\cdot N \\cdot T_{\\text{mod},d}</span> . If SIMD style operations, and operations on larger datatypes, are to be supported we therefore need a more efficient method to perform recryption.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">4.2 Security Analysis and Parameters</h4>

    <p class="text-gray-300">The analysis of Gentry of the above scheme and bootstrapping operation applies in our situation. The security of the underlying somewhat homomorphic scheme is based on the hardness of a variant of the bounded distance decoding (BDDP) problem; whereas the security of the bootstrapping procedure is based on the sparse subset sum problem (SSSP). Indeed the minor modifications we make in future sections to the public key result in exactly the same security reductions. Thus an adversary against the scheme can either be turned into an algorithm to solve a decision variant of the BDDP, or a SSSP.</p>

    <p class="text-gray-300">When selecting key sizes for cryptographic schemes, in practice one almost always selects key sizes based on the best known attacks and not on the hard problems to which a security problem reduces. We have various parameters we need to select s, S, N, t and  <span class="math">\\mu</span> . The sizes of N, t and  <span class="math">\\mu</span>  determine whether one can break the scheme by distinguishing ciphertexts, or (more seriously) by message or key recovery. Parameter selection is here based on the hardness of</p>

    <p class="text-gray-300">solving explicit closest vector problems (CVPs), in lattices of dimension N, involving basis matrices with coefficients bounded by d (a function of t and N), and for close vectors whose distance to the lattice is related to the size of  <span class="math">\\mu</span> . An algorithm to solve the CVP/BDDP can be directly used to recover plaintexts as explained in [16]. The larger the ratio of t to  <span class="math">\\mu</span>  the easier it is to recover plaintexts, but the ratio of t to  <span class="math">\\mu</span>  also determines how complicated a circuit the basic somewhat homomorphic scheme can evaluate. Indeed the smaller the ratio of t to  <span class="math">\\mu</span>  the less expressive our somewhat homomorphic scheme is. In selecting N, t and  <span class="math">\\mu</span>  one needs to make a careful analysis of the current state of the art in lattice basis reduction; a topic which is beyond the scope of this paper.</p>

    <p class="text-gray-300">On the other hand, it is not the case that an algorithm to solve the sparse subset sum problem can be used to break the scheme. The security proof in [9] uses the FHE adversary to solve the following SSSP</p>

    <p class="text-gray-300"><span class="math">$\\zeta_0 = \\sum_{i=1}^s \\sum_{j=0}^{S-1} b_{i,j} \\cdot (x_i \\cdot R^j) \\pmod{d}.</span>$</p>

    <p class="text-gray-300">The simulator (solving SSSP) is given  <span class="math">\\zeta_0</span>  and the weights  <span class="math">x_i \\cdot R^j \\pmod{d}</span> , and uses random ciphertexts  <span class="math">c_{i,j}</span>  to represent the encryption of the  <span class="math">b_{i,j}</span> . Since the proof has already shown that ciphertexts of specific values are indistinguishable from encryptions of random values, the adversary does not know it is in a simulation. The proof in [9] shows how the simulator can then solve the SSSP. Whilst this easily establishes the fact that the recrypt procedure does not reduce the security of the scheme, assuming of course the scheme is KDM secure and the SSSP is hard, it actually tells us very little in practice. In particular it says: &quot;If the adversary knows the secret key, then recovering another representation of the secret key is equivalent to solving the SSSP&quot;.</p>

    <p class="text-gray-300">Thus the parameters s and S determine (in practice) a hidden sparse subset sum problem rather than a standard SSSP. Namely, the adversary needs to solve the above subset sum problem where he is not given access to the value  <span class="math">\\zeta_0</span> . Taking the pragmatic view of parameter selection based on the best known attack, it is clear that neither the lattice attacks on the SSSP nor the time-memory trade off methods to solve the SSSP apply in the hidden case. This has important direct implications for parameter size selection. If a time-memory trade off is possible then we need to select S and S such that  <span class="math">S^{\\lfloor s/2 \\rfloor} &gt; 2^{\\lambda}</span> , where we do not believe the adversary can perform S</p>

    <p class="text-gray-300">A more pragmatic view of parameter selection would imply that, since the time-memory trade off against the hidden SSSP appears impossible, that we select  <span class="math">S^s &gt; 2^{\\lambda}</span> . This has a number of direct consequences: Firstly we can select S to be much smaller than Gentry-Halevi do, secondly this means we do not need to complicate the recryption procedure with the index encoding method they use to save space, since S is now small enough to not require it. Thirdly this halves the degree of the resulting recryption circuit which makes the scheme more efficient, and fourthly it saves on the computational cost of recryption, since we need to do less work.</p>

    <p class="text-gray-300">In summary: in practice one should select N, t and  <span class="math">\\mu</span>  according to best practice from lattice basis reduction. For real systems this means that parameters need to be chosen that are significantly larger than the toy examples presented in Gentry–Halevi. However, when selecting s and S one can be less conservative than Gentry–Halevi.</p>

    <p class="text-gray-300">In Section 5 we detail a parallel recryption procedure which has the same multiplicative depth as the one above; but which requires more addition operations, where the number of extra additions depends on the level of SIMD operations required. Thus the value of t may need to be larger than that required in non SIMD based schemes. Asymptotically the constant increase will make no difference, but for &quot;practical&quot; parameters one may have a noticeable difference. Thus in Section 5 we present experimental results for &quot;toy&quot; security levels. This is done purely to show that our algorithms make a difference even for choices of N,  <span class="math">\\mu</span>  and t corresponding to low security levels.</p>

    <p class="text-gray-300">Whilst Algorithm 1 will recrypt a ciphertext that encodes an element of the algebra A, it can be made significantly more efficient. Firstly, the procedure recrypts a general element in A, yet in practice we will only have that c contains  <span class="math">l \\cdot n \\leq N</span>  encrypted bits. Secondly, since the recrypt procedure is a binary circuit we can run it on the r embedded copies of  <span class="math">\\mathbb{F}_2</span> , i.e. we can use the SIMD style operations to recrypt r bits in parallel.</p>

    <p class="text-gray-300">The first optimization is easy to obtain: recall that  <span class="math">\\Gamma_{n,l}</span>  maps a vector of l binary polynomials  <span class="math">(\\kappa_1(\\psi), \\ldots, \\kappa_l(\\psi))</span>  each of of degree less than n, into a polynomial a(X) of degree less than N. The map  <span class="math">\\Gamma_{n,l}</span>  thus defines an isomorphism between  <span class="math">\\mathbb{K}^l_n</span>  and  <span class="math">\\Gamma_{n,l}(\\mathbb{K}^l_n)</span>  so  <span class="math">\\Gamma_{n,l}^{-1}</span>  is well defined on the result of the computation. We can represent  <span class="math">\\Gamma_{n,l}^{-1}</span>  explicitly</p>

    <p class="text-gray-300">by an  <span class="math">(n \\cdot l) \\times N</span>  binary matrix B over  <span class="math">\\mathbb{F}_2</span>  which is defined as follows:</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{coeff}(\\kappa_i, j) = \\sum_{k=0}^{N-1} B_{j+i \\cdot n+1, k+1} \\cdot \\operatorname{coeff}(a(X), k).</span>$</p>

    <p class="text-gray-300">Using B we can therefore first obtain encryptions of all the coefficients of the  <span class="math">\\kappa_i</span> , recrypt these using Algorithm 1 and then reconstruct the recrypted ciphertext using  <span class="math">\\Gamma_{n,l}</span> . In particular, denote with  <span class="math">\\bar{c}_{i_1,i_2}</span>  a recryption of the  <span class="math">i_1</span> th coefficient of the  <span class="math">i_2</span> th component in  <span class="math">\\mathbb{K}_n^l</span> , then we can obtain a full recryption of an element in  <span class="math">\\mathbb{K}_n^l</span>  by computing</p>

    <p class="text-gray-300"><span class="math">$\\bar{c} \\leftarrow \\sum_{i_1=0}^{n-1} \\sum_{i_2=1}^{l} \\bar{c}_{i_1,i_2} \\odot ((\\Gamma_{n,l}(0,\\ldots,0,\\psi^{i_1},0,\\ldots,0))|_{\\alpha}),</span>$</p>

    <p class="text-gray-300">where  <span class="math">(0, \\ldots, 0, \\psi^{i_1}, 0, \\ldots, 0) \\in \\mathbb{K}_n^l</span>  is the element whose  <span class="math">i_2</span> th component is equal to  <span class="math">\\psi^{i_1}</span> , and  <span class="math">M(X)|_{\\alpha}</span>  is the trivial encryption of the element M(X) in the algebra A.</p>

    <p class="text-gray-300">Recall that given a ciphertext c, the value  <span class="math">[c \\cdot w_i]_d</span>  is an encryption of the ith coefficient of a(X). Since the scheme is homomorphic and using the matrix B we conclude that</p>

    <p class="text-gray-300"><span class="math">$c_{i_1,i_2} = \\left[ \\sum_{k=0}^{N-1} B_{i_1+i_2\\cdot n+1,k+1} [c \\cdot w_k]_d \\right]_d = \\left[ c \\cdot \\left( \\sum_{k=0}^{N-1} B_{i_1+i_2\\cdot n+1,k+1} \\cdot w_k \\right) \\right]_d</span>$</p>

    <p class="text-gray-300">is a valid encryption of  <span class="math">\\operatorname{coeff}(\\kappa_{i_2},i_1)</span> . Note that these quantities are obtained as the sum of maximum N ciphertexts, which implies that the original c has to be an encryption of  <span class="math">C(\\theta)</span>  with  <span class="math">\\|C(\\theta)\\|_{\\infty} &lt; U/((s+1) \\cdot N)</span>  for Algorithm 1 to recrypt correctly. The second algorithm thus first computes the  <span class="math">n \\cdot l</span>  constants (the  <span class="math">w_i</span>  are no longer required)</p>

    <p class="text-gray-300"><span class="math">$v_{i_1,i_2} = \\sum_{k=0}^{N-1} B_{i_1+i_2\\cdot n+1,k+1} \\cdot w_k \\pmod{d},</span>$</p>

    <p class="text-gray-300">and then computes the recryptions  <span class="math">\\overline{c}_{i_1,i_2} = \\mathsf{BitRecrypt}([c \\cdot v_{i_1,i_2}]_d, \\mathsf{pk})</span> . Notice how we have reduced the number of calls to recrypt from N down to  <span class="math">n \\cdot l</span>  and that we require only  <span class="math">n \\cdot l</span>  constants  <span class="math">v_{i_1,i_2}</span>  instead of the N constants  <span class="math">w_i</span> . The result is summarized in Algorithm 3. Assuming the  <span class="math">\\left(\\Gamma_{n,l}(0,\\ldots,0,\\psi^{i_1},0,\\ldots,0)\\right)\\big|_{\\alpha}</span>  and  <span class="math">v_{i_1,i_2}</span>  are precomputed, the total cost of recrypting a ciphertext is essentially  <span class="math">n \\cdot l \\cdot T_{\\mathsf{bits}} + 2 \\cdot n \\cdot l \\cdot T_{\\mathsf{mod},d}</span> .</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6"><strong>Algorithm 3:</strong> Recrypting Ciphertext c version 2</h4>

    <pre><code class="language-text">\\begin{array}{l} \\overline{c} \\leftarrow 0. \\\\ \\text{for } i_1 \\text{ from } 0 \\text{ upto } n-1 \\text{ do} \\\\ \\text{ for } i_2 \\text{ from } 0 \\text{ upto } l-1 \\text{ do} \\\\ \\overline{c}_{i_1,i_2} \\leftarrow \\text{BitRecrypt}([c \\cdot v_{i_1,i_2}]_d, \\text{pk}). \\\\ \\overline{c} \\leftarrow \\overline{c} \\oplus \\overline{c}_{i_1,i_2} \\odot \\left( \\varGamma_{n,l}(0,\\ldots,0,\\psi^{i_1},0,\\ldots,0) \\right) \\big|_{\\alpha}. \\\\ \\text{return } (\\overline{c}). \\end{array}
</code></pre>

    <p class="text-gray-300">So far we have not exploited the SIMD capabilities of the somewhat homomorphic scheme. Therefore our next goal is to produce the recryptions  <span class="math">\\bar{c}_{i_1,i_2}</span>  in parallel for  <span class="math">i_2=1,\\ldots,l</span> . Thus we aim to compute a ciphertext  <span class="math">\\hat{c}_{i_1}</span>  from c such that  <span class="math">\\hat{c}_{i_1}</span>  represents a recryption of the message</p>

    <p class="text-gray-300"><span class="math">$(\\mathsf{coeff}(\\kappa_1, i_1), \\ldots, \\mathsf{coeff}(\\kappa_l, i_1))</span>$
,</p>

    <p class="text-gray-300">where c represents an encryption of  <span class="math">(\\kappa_1, \\ldots, \\kappa_l)</span> . We use the notation  <span class="math">\\hat{c}_i</span>  to distinguish it from the recryption  <span class="math">\\bar{c}_i</span>  above. The key observation is that the recrypt procedure is the evaluation of a binary circuit, and that this binary circuit is identical (bar the constants) no matter which component we are recrypting. In addition the algebra splits into (at least) l finite fields of characteristic two, thus we can embed the binary circuit into each of these l components and perform the associated recryption in parallel. For a fixed  <span class="math">i_1</span>  we therefore want to execute the computation of the vector</p>

    <p class="text-gray-300"><span class="math">$([c \\cdot v_{i_1,1} \\cdot \\zeta_0]_d \\pmod{2}, \\dots, [c \\cdot v_{i_1,l} \\cdot \\zeta_0]_d \\pmod{2})</span>$</p>

    <p class="text-gray-300">in the encrypted domain in parallel. Recall that each component of this vector is computed as</p>

    <p class="text-gray-300"><span class="math">$[c \\cdot v_{i_1,k} \\cdot \\zeta_0]_d \\pmod{2} = \\bigoplus_{i=1}^s \\bigoplus_{j=0}^{S-1} b_{i,j} \\cdot y_{i,j}^{(k)} \\pmod{2} \\oplus \\left[ \\sum_{i=1}^s \\sum_{j=0}^{S-1} b_{i,j} \\cdot z_{i,j}^{(k)} \\right] \\pmod{2},</span>$</p>

    <p class="text-gray-300">where  <span class="math">y_{i,j}^{(k)} = c \\cdot v_{i_1,k} \\cdot x_i \\cdot R^j</span>  and  <span class="math">z_{i,j}^{(k)}</span>  an approximation of  <span class="math">y_{i,j}^{(k)}/d</span>  up to p bits after the binary point. Recall that to obtain the bit  <span class="math">\\mathcal{B}_k = \\left[\\sum_{i=1}^s \\sum_{j=0}^{S-1} b_{i,j} \\cdot z_{i,j}^{(k)}\\right] \\pmod{2}</span>  we used the function school_book_add(M) with input an  <span class="math">s \\times (p+1)</span>  array M where the ith row contained  <span class="math">\\bigoplus_{j=0}^{S-1} b_{i,j} \\cdot \\text{compute\\_bits}(y_{i,j}^{(k)})</span> . In fact,  <span class="math">\\mathcal{B}_k</span>  was simply the first bit in the bit vector returned by school_book_add(M).</p>

    <p class="text-gray-300">If we now want to execute the above computation in the kth component (instead of the first), we basically have to multiply everything by  <span class="math">\\Gamma_{n,l}(0,\\ldots,0,1,0,\\ldots,0)</span> , where  <span class="math">(0,\\ldots,0,1,0,\\ldots,0)</span>  is the vector of l elements of  <span class="math">\\mathbb{K}_n</span>  whose kth element is equal to one, with all other elements being zero. To avoid costly modular multiplications by  <span class="math">\\Gamma_{n,l}(0,\\ldots,0,1,0,\\ldots,0)\\big|_{\\alpha}</span> , we will use l different encryptions of  <span class="math">b_{i,j}</span> , depending on which of the l components of the algebra we are using. In particular, we no longer augment the public key with the data</p>

    <p class="text-gray-300"><span class="math">$\\left(p, s, S, R, \\left\\{x_i, \\left\\{c_{i,j}\\right\\}_{j=0}^{S-1}\\right\\}_{i=1}^{s}\\right),</span>$</p>

    <p class="text-gray-300">where  <span class="math">c_{i,j} \\leftarrow \\mathsf{Encrypt}(b_{i,j},\\mathsf{pk})</span> , but instead replace the  <span class="math">c_{i,j}</span>  components with elements  <span class="math">e_{i,j,k}</span>  where</p>

    <p class="text-gray-300"><span class="math">$e_{i,i,k} \\leftarrow \\text{Encrypt}(b_{i,i} \\cdot \\Gamma_{n,l}(0,\\ldots,0,1,0,\\ldots,0), \\text{pk}) \\text{ for } 1 \\le i \\le s, \\ 0 \\le j &lt; S, \\ 0 \\le k &lt; l.</span>$</p>

    <p class="text-gray-300">This means we need to increase the size of the augmented public key by essentially a factor of l. Once we have computed all the  <span class="math">\\hat{c}_{i_1}</span> 's we can simply recover  <span class="math">\\overline{c}</span>  by computing</p>

    <p class="text-gray-300"><span class="math">$\\overline{c} \\leftarrow \\sum_{i_1=0}^{n-1} \\hat{c}_{i_1} \\odot \\left( \\left( \\Gamma_{n,l}(\\psi^{i_1}, \\dots, \\psi^{i_1}) \\right) \\Big|_{\\alpha} \\right).</span>$</p>

    <p class="text-gray-300">The resulting algorithm is given in Algorithm 4. Note that to compute each  <span class="math">\\hat{c}_{i_1}</span>  we only require one call to school_book_add(A) compared to l calls in Algorithm 3.</p>

    <p class="text-gray-300"><strong>Algorithm 4:</strong> Recrypting Ciphertext c version 3: parallel recryption of all  <span class="math">i_1</span> th coefficients of the n elements embedded in a ciphertext c</p>

    <pre><code class="language-text">\\overline{c} \\leftarrow 0.
for i_1 from 0 upto n-1 do
       sum \\leftarrow 0.
        A \\leftarrow 0, where A \\in M_{s \\times (p+1)}(\\mathbb{Z}/d\\mathbb{Z}).
       for i_2 from 0 upto l-1 do
               c_{i_1,i_2} \\leftarrow c \\cdot v_{i_1,i_2} \\pmod{d}.
               for j from 1 upto s do
                      y \\leftarrow c_{i_1,i_2} \\cdot x_j \\pmod{d}.
                      for k from 0 upto S-1 do
                             if y is odd then
                                     \\operatorname{sum} \\leftarrow \\operatorname{sum} \\oplus e_{j,k,i_2}.
                              \\mathbf{b} \\leftarrow \\mathsf{compute\\_bits}(y).
                              for u from 0 upto p do
                                     A_{j,u} \\leftarrow A_{j,u} \\oplus (\\mathbf{b}_u \\cdot e_{j,k,i_2}).
                              y \\leftarrow y \\cdot R \\pmod{d}.
       \\mathbf{a} \\leftarrow \\mathsf{school\\_book\\_add}(A).
       \\hat{c}_{i_1} \\leftarrow \\text{sum} \\oplus \\mathbf{a}_0.
       \\overline{c} \\leftarrow \\overline{c} \\oplus \\hat{c}_{i_1} \\odot ((\\Gamma_{n,l}(\\psi^{i_1}, \\dots, \\psi^{i_1})))_{\\alpha}).
return (\\overline{c}).
</code></pre>

    <p class="text-gray-300">We let  <span class="math">T_{\\mathsf{par}}(n,l)</span>  denote the cost of performing this recryption operation on a message consisting of l field elements from  <span class="math">\\mathbb{K}_n</span>  held in parallel. Assuming the  <span class="math">\\left(\\Gamma_{n,l}(\\psi^{i_1},\\ldots,\\psi^{i_1})\\right)\\big|_{\\alpha}</span>  and the  <span class="math">v_{i_1,i_2}</span>  are precomputed we obtain that</p>

    <p class="text-gray-300"><span class="math">$T_{\\mathsf{par}}(n,l) = n\\left(S \\cdot s \\cdot l + s \\cdot l + l + 1\\right) \\cdot T_{\\mathsf{mod},d} + n \\cdot T_{\\mathsf{school\\_book\\_add}}.</span>$</p>

    <p class="text-gray-300">The main cost advantage therefore stems from the fewer calls to the function school_book_add.</p>

    <p class="text-gray-300">Naively it would appear that our parallel version of recrypt, using Algorithm 4, is more efficient than the naive version using Algorithm 2. However, one may need larger public keys to actually implement the parallel recryption (as it is a more complex circuit). We also need to compare whether doing operations in parallel and with large data entries (via the algebra A) is more efficient than doing the same operations but with bits using the standard bit-wise FHE scheme but with more complex circuits. It is to this topic we now turn by examining some &quot;toy&quot; examples.</p>

    <p class="text-gray-300">So the question arises as to whether it is simpler to perform FHE on bits, or to perform FHE via the algebra A. In this section we concentrate on estimating the performance in terms of the run time and the sizes of the resulting ciphertexts which need to be stored. First recall key generation; we choose N and a polynomial F(X) with small coefficients, we then choose an element  <span class="math">\\gamma \\in \\mathbb{Z}[\\theta]</span>  which has coefficients of order  <span class="math">2^t</span> . This results in a value for d of size approximately  <span class="math">N^N \\cdot 2^{t \\cdot N}</span> ; thus we require roughly  <span class="math">t \\cdot N</span>  bits to represent a single ciphertext.</p>

    <p class="text-gray-300">We first let T(n) denote the function which returns the number of  <span class="math">\\mathbb{F}_2</span>  multiplications needed to perform a multiplication in the field  <span class="math">\\mathbb{K}_n = \\mathbb{F}_{2^n}</span> . Using Karatsuba multiplication (for example) we find, for n a power of two, that</p>

    <p class="text-gray-300"><span class="math">$T(n) := \\begin{cases} 1 &amp; \\text{if } n = 1, \\\\ 3 \\cdot T(n/2) &amp; \\text{otherwise.} \\end{cases}</span>$</p>

    <p class="text-gray-300">This is clearly only an estimate of the overall cost, as we are ignoring the required additions and management of the</p>

    <p class="text-gray-300">There are various different options one has for implementing operations on l' finite fields each of size  <span class="math">2^{n&#x27;}</span> . In the following discussion we concentrate on the following four options; clearly other options are available but we select these as a way of demonstrating the different ways how our techniques could be used.</p>

    <p class="text-gray-300">&lt;u&gt;OPTION 1:&lt;/u&gt;: We operate on bits using the standard bit-wise FHE schemes, i.e. we take n=l=1 in our FHE scheme. We will then require  <span class="math">l&#x27; \\cdot n&#x27; \\cdot t \\cdot N</span>  bits to store our l' finite field elements, and the cost of performing a single SIMD style multiplication on the l' finite fields will cost around  <span class="math">l&#x27; \\cdot T(n&#x27;) \\cdot T_{\\text{bits}}</span>  multiplications.</p>

    <p class="text-gray-300">&lt;u&gt;OPTION 2:&lt;/u&gt;: We operate on the l' finite field elements where each element uses a single ciphertext, i.e. we take n=n' and l=1 in our FHE scheme. This option has the benefit that we can work with the finite field, but we are not forced to operate in a SIMD manner all the time. With such an option we will require  <span class="math">l&#x27; \\cdot t \\cdot N</span>  bits to store our l' finite field elements, and performing a single SIMD style multiplication on the l' finite fields will cost around  <span class="math">l&#x27; \\cdot T_{par}(n&#x27;, 1)</span>  multiplications.</p>

    <p class="text-gray-300">&lt;u&gt;OPTION 3:&lt;/u&gt;: We operate on all l' finite fields in a SIMD fashion using only a single ciphertext, i.e. we take n=n' and l=l' in our FHE scheme. Thus we will require  <span class="math">t \\cdot N</span>  to store our l' finite field elements, and performing a single SIMD style multiplication on the l' finite fields will cost around  <span class="math">T_{par}(n&#x27;, l&#x27;)</span>  multiplications.</p>

    <p class="text-gray-300">&lt;u&gt;OPTION 4:&lt;/u&gt;: Here we operate on bits, but we operate on them in a SIMD fashion by having a ciphertext represent l' bits, i.e. we take n=1 and l=l' in our FHE scheme. With this option we require  <span class="math">n&#x27; \\cdot t \\cdot N</span>  bits to store the l' finite field elements, and SIMD style multiplication will require  <span class="math">T(n&#x27;) \\cdot T_{par}(1, l&#x27;)</span>  multiplications.</p>

    <p class="text-gray-300">We summarize the above choices, for the concrete parameters of n'=8 and l'=16, in the following table. We select a value for N around the size of 2000, purely to enable comparison with the work of [10]. We iterate this value is purely for illustrative purposes to show the difference between the various options; it should not be taken to indicate the  <span class="math">N\\approx 2000</span>  is a secure security level. Fixing n',l' and N rather than leaving them variable is done as the overhead of the SIMD operations crucially depends on the specific combination of finite field and cyclotomic field chosen, and has no nice asymptotic meaning. We select a single parameter instance simply not to overwhelm the reader with data, since our goal is purely to show feasibility of our algorithms even at low security levels.</p>

    <p class="text-gray-300">Note, that for Option 1 we select N=2048 since if we are only encrypting bits then using the polynomial  <span class="math">F(X)=X^{2^n}+1</span>  will always be more efficient than using  <span class="math">F(X)=\\Phi_{3485}(X)</span> . In addition we keep the parameter t as an indeterminate, as we will be returning to that later.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Ciphertext</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Runtime</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Space (≈ bits)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Approx Cost</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Option 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2048</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">262144 · t</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">432 · Tbits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Option 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2560</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">40960 · t</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16 · Tpar(8, 1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Option 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2560</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2560 · t</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tpar(8, 16)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Option 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2560</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20480 · t</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27 · Tpar(1, 16)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Thus if one is soley interested in reducing the memory of the calculation one would select Option 3. To determine which one is most efficient one needs to actually implement the schemes, since the actual costs of each operation depend on the value of t needed. So we implemented the above algorithms for the four cases (N, n, l) = (2048, 1, 1),(2560, 8, 1),(2560, 8, 16) and (2560, 1, 16), so as to comparre the four options in the above analysis.</p>

    <p class="text-gray-300">In all cases we found that taking t = 400 resulted in a scheme in which we were able to recrypt clean ciphertexts; however to enable fully homomorphic encryptions we need to recrypt dirty ciphertexts, and be able to perform some additional operations. For the first two of our four cases we found that t = 600 was sufficient, whilst for the second two we found that t = 800 was sufficient; note, we increased t in multiples of 100, thus smaller values could have been sufficient.</p>

    <p class="text-gray-300">In the four cases we found the following recrypt times. We also present, assuming we wished in all cases to implement operations on l &lt;sup&gt;0&lt;/sup&gt; = 16 values in &lt;sup&gt;F&lt;/sup&gt;2n&lt;sup&gt;0&lt;/sup&gt; , where &lt;sup&gt;n&lt;/sup&gt; &lt;sup&gt;0&lt;/sup&gt; = 8, the actual time needed to perform the recrypt on such data and the total size of all ciphertexts needed to represent such data. In our implementation of the field algorithms for Option 1 and Option 4 we used the Karatsuba method mentioned above, and only performed recryption when implementing a multiplication using the FHE scheme; i.e. recryption was not performed upon additions. The algorithms were implemented in C++ using the NTL library and were run on a machine with six Intel Xeon 2.4 GHz processors and 47 GB of RAM.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Basic FHE Scheme</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">0&lt;br&gt;, l0&lt;br&gt;Performing Ops For (n&lt;br&gt;) = (8, 16)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Recrypt</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Recrypt</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ciphertext</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(N, n, l)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">t</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(p, S) Time (sec) Method Time (sec)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Size</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(2048, 1, 1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">600 (4, 32)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15 Option 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7148</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18.00MB</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(2560, 8, 1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">600 (4, 32)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">187 Option 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2983</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.00MB</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(2560, 8, 16)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">800 (4, 32)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">735 Option 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">723</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.25MB</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(2560, 1, 16)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">800 (4, 32)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">89 Option 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2406</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.00MB</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">We end by noting the following: In our toy example we see that SIMD operations and parallel recryption offer some performance advantages. The exact benefit depends on a number of factors. Firstly the size of n 0 and l 0 ; these are determined by an application and are often small. In turn n 0 and l 0 affect the choice of N, which also depends on the desired security level. The precise values of t and µ allowed are then determined by security analysis of lattice problems. Our toy experiments show that our ability to perform SIMD operations do not affect the size of t very much and that the parallel recryption operation is as practical as standard recryption.</p>

    <p class="text-gray-300">The exact choice of which Option is best however depends on an application. Just as in standard SIMD vs non-SIMD operations on a standard processor, whether one utilizes the SIMD instructions in a program depends on the program being run.</p>

    <p class="text-gray-300">Before discussing two possible applications we note that one issue with SIMD operations on data is that sometimes we wish to move data between various elements in the l values on which we are operating. This is often a problem, since the hardware/mathematics/software which supports the SIMD operations precludes such operations. However, in our FHE scheme such operations can be performed at no additional cost.</p>

    <p class="text-gray-300">Indeed given a SIMD word consisting of l elements in a finite field F2&lt;sup&gt;n&lt;/sup&gt; one can produce a new SIMD word which consists of any linear function of the bits creating the original SIMD word. To see this we notice that it simply requires multiplying the matrix B used in the parallel recrypt procedure by the matrix defining the linear map. Thus, we can perform this linear function as part of the recryption performed for the previous operation.</p>

    <p class="text-gray-300">In particular this means we can shuffle the elements in our SIMD word, or extract specific elements, or extract specific bits, etc. Indeed extracting specific bits in parallel was the core of our parallel recrypt procedure explained above.</p>

    <p class="text-gray-300">We now turn to our two examples: The first example, namely homomorphic evaluation of AES under some homomorphic key, is used to demonstrate how SIMD operations in high level ( <span class="math">\\mathbb{F}_{2^8}</span> ) algebraic structures, allow us to evaluate complex operations relatively easily. Evaluation of AES circuits using FHE operations has been mentioned as a possible usage scenario in [13]. The second example, one of database lookup, provides an example of how data can be searched using SIMD style operations more efficiently than using the bit-wise homomorphic operations envisaged in [9].</p>

    <p class="text-gray-300">In this section we assume that all operations are performed with post-processing by the recryption operation. Thus we are no longer interested in the size of the circuit which implements a functionality but simply the cost of the operations involved. As explained above we have essentially three key operations; the two algebraic operations Mult and Add, plus the linear operations on bits mentioned above. We shall denote the cost of these three operations by  <span class="math">C_M</span> ,  <span class="math">C_A</span>  and  <span class="math">C_L</span> , and we note that  <span class="math">C_L</span>  essentially comes for free as part of recryption. For example, if an operation requires two multiplications, one addition and three linear operations we shall denote this cost (for simplicity) by  <span class="math">2 \\cdot C_M + C_A + 3 \\cdot C_L</span> .</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">7.1 Bit-Slicing</h4>

    <p class="text-gray-300">Any algorithm which is run on a circuit using bit operations can be run multiple times at once, by executing the algorithm on a set of parameters which supports operations on multiple bits in parallel. Such a technique is often called bit-slicing when applied to a single algorithm; however the technique is essentially also a bit-wise form of SIMD operation. Hence, <em>any</em> application performed using an FHE algorithm which supports the parallel recrypt procedure in this paper could be potentially sped-up by at least an order of magnitude by operating on multiple versions of the same algorithm in parallel.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">7.2 Application to AES</h4>

    <p class="text-gray-300">As an example of the benefits of using FH-SIMD over the bitwise FHE we examine the case of how one would implement an AES functionality using FHE. Namely, we want a server to encrypt a message using a key which is only available via an FHE encryption. Using AES as a relatively complex example application of secure computation has also been recently suggested for a number of other related technologies; namely two and multi-party MPC [7, 14]. It is also particularly well suited to SIMD execution due to its overall design.</p>

    <p class="text-gray-300">The method we propose is to encode the entire AES state matrix in a single ciphertext. Recall that the state matrix is a 4-by-4 matrix of elements in  <span class="math">\\mathbb{F}_{2^8}</span> . We therefore first need to select an m so that the ideal (2) splits into at least 16 prime ideals of degree divisible by eight in the field defined by  <span class="math">\\Phi_m(X)</span> . There are a large number of such examples, including the example we have used in this paper of taking m=3485. Note that since  <span class="math">\\phi(m)</span>  is equal to  <span class="math">4\\times 16</span>  we could also perform 4 AES computations in parallel as well, although we will restrict ourselves to one for ease of exposition. In terms of our previous section we let  <span class="math">K_8 = \\mathbb{F}_{2^8}</span>  denote the standard representation of  <span class="math">\\mathbb{F}_{2^8}</span> , i.e.</p>

    <p class="text-gray-300"><span class="math">$K_8 := \\mathbb{F}_2[X]/(X^8 + X^4 + X^3 + X + 1),</span>$</p>

    <p class="text-gray-300">and we let A denote the algebra consisting of 64 copies of  <span class="math">\\mathbb{F}_{2^{40}}</span> , each with the representation induced by the given factor of  <span class="math">\\Phi_m(X) \\pmod{2}</span> .</p>

    <p class="text-gray-300">We assume the AES state matrix is given by</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} s_{0,0} \\ s_{0,1} \\ s_{0,2} \\ s_{0,3} \\\\ s_{1,0} \\ s_{1,1} \\ s_{1,2} \\ s_{1,3} \\\\ s_{2,0} \\ s_{2,1} \\ s_{2,2} \\ s_{2,3} \\\\ s_{3,0} \\ s_{3,1} \\ s_{3,2} \\ s_{3,3} \\end{pmatrix} \\ ,</span>$</p>

    <p class="text-gray-300">which we encode as an element of  <span class="math">K_8^{16}</span>  as  <span class="math">(s_{0,0}, s_{0,1}, \\dots, s_{3,3})</span> . Using the map  <span class="math">\\Gamma_{8,16}</span>  we obtain an element of A, which can then be evaluated at  <span class="math">\\alpha</span>  modulo p to obtain a trivial encryption of the message state (before the first round).</p>

    <p class="text-gray-300">To implement AES we assume that the round keys  <span class="math">k_i</span>  have been presented in encrypted form, using the above embedding via  <span class="math">\\Gamma_{8,16}</span> . Computing the round keys from a given key can be done using the same operations needed to execute the rounds. Thus if we can implement the rounds using efficient FH-SIMD operations, then we can also compute the encryptions of the round keys given the initial key.</p>

    <p class="text-gray-300">The round structure of AES is made up of four basic operations, which we now discuss in turn.</p>

    <p class="text-gray-300"><strong>AddRoundKey</strong> This is the simplest operation and is clearly performed for all sixteen bytes in parallel by doing a single  <span class="math">\\oplus</span>  operation of the FHE scheme. This step can be done at the cost of  <span class="math">C_A</span> .</p>

    <p class="text-gray-300"><strong>ShiftRows</strong> In this operation row i is shifted left by i-1 positions. This is clearly an example of a <em>linear</em> operation from earlier, in that we map the ciphertext corresponding to</p>

    <p class="text-gray-300"><span class="math">$(s_{0.0}, s_{0.1}, s_{0.2}, s_{0.3}, s_{1.0}, s_{1.1}, s_{1.2}, s_{1.3}, s_{2.0}, s_{2.1}, s_{2.2}, s_{2.3}, s_{3.0}, s_{3.1}, s_{3.2}, s_{3.3})</span>$</p>

    <p class="text-gray-300">into a ciphertext corresponding to</p>

    <p class="text-gray-300"><span class="math">$(s_{0.0}, s_{0.1}, s_{0.2}, s_{0.3}, s_{1.1}, s_{1.2}, s_{1.3}, s_{1.0}, s_{2.2}, s_{2.3}, s_{2.0}, s_{2.1}, s_{3.3}, s_{3.0}, s_{3.1}, s_{3.2}).</span>$</p>

    <p class="text-gray-300">Since this is a reordering the cost is given by  <span class="math">C_L</span> .</p>

    <p class="text-gray-300">MixColumns In this step we perform a matrix multiplication on the left of the state matrix by a fixed matrix given by</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} X &amp; X+1 &amp; 1 &amp; 1 \\\\ 1 &amp; X &amp; X+1 &amp; 1 \\\\ 1 &amp; 1 &amp; X &amp; X+1 \\\\ X+1 &amp; 1 &amp; 1 &amp; X \\end{pmatrix}.</span>$</p>

    <p class="text-gray-300">This is accomplished in four stages</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute the trivial encryption  <span class="math">c_1</span>  of  <span class="math">\\Gamma_{8,16}((X,X,\\ldots,X))</span> , clearly this can be precomputed.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">c_2 \\leftarrow c \\otimes c_1</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>By application of three <em>linear</em> operations we can create ciphertexts  <span class="math">c_3</span> ,  <span class="math">c_4</span> ,  <span class="math">c_5</span>  and  <span class="math">c_6</span>  corresponding to  <span class="math">c_2</span>  shifted up by one row,  <span class="math">c_3</span>  shifted up by two rows, and  <span class="math">c_4</span>  shifted up by four rows (where shift rows is performed with rotation).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">c_2 \\oplus c_3 \\oplus c_4 \\oplus c_5 \\oplus c_6</span>  and output the result.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Notice that our FH-SIMD scheme allows us to perform the 16 multiplications in parallel in the second step. The cost of the MixColumns operation is then  <span class="math">C_M + 4 \\cdot C_A + 4 \\cdot C_L</span> .</p>

    <p class="text-gray-300"><strong>SubBytes</strong> This is the most complex of all the AES operations, however there is much existing literature on straight line (i.e. no branching) executions of the AES S-Boxes at byte level. For example the approach in [3] transforms the polynomial bases into a &quot;nice&quot; normal basis and then decomposes the arithmetic for inversion into  <span class="math">\\mathbb{F}_{2^4}</span>  and then  <span class="math">\\mathbb{F}_{2^2}</span>  operations. At which point all the arithmetic is just logical operations, and hence amenable to FH-SIMD operations. However, this approach is more suited to real hardware, or to FH-SIMD operations where the basic data type is a bit (e.g. when using say (n, l) = (1, 16) in our main scheme).</p>

    <p class="text-gray-300">As we are restricted to operations which can be performed efficiently in our FH-SIMD scheme a more naive approach is probably to be preferred. Recall that the AES S-Box consists of inverting each state byte in  <span class="math">K_8</span>  (where we define  <span class="math">0^{-1}=0</span> ), followed by an  <span class="math">\\mathbb{F}_2</span> -linear operation. Also recall that  <span class="math">x^{-1}=x^{254}</span>  in the field  <span class="math">K_8</span> . We can therefore apply the S-Box operation to our encrypted state using the following method:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">t \\leftarrow c</span> .</li>
      <li>For i = 1 to 6 do    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">t \\leftarrow t \\otimes t</span> .</li>
      <li><span class="math">t \\leftarrow t \\otimes c</span> .</li>
    </ul></li>
      <li><span class="math">t \\leftarrow t \\otimes t</span> .</li>
      <li>Extract eight ciphertexts  <span class="math">t_0, \\ldots, t_7</span>  such that  <span class="math">t_i</span>  is the (parallel) encryption of the <em>i</em>-th bit of all 16 values in t.</li>
      <li>Perform the linear operation on  <span class="math">t_0, \\ldots, t_7</span>  in parallel to produce ciphertexts  <span class="math">s_0, \\ldots, s_7</span> .</li>
      <li>Map these ciphertexts back to an encryption of an element in A.</li>
    </ul>

    <p class="text-gray-300">The first step, that of producing an encryption t of  <span class="math">x^{254}</span>  where c is an encryption of x, requires at most 13 fully homomorphic multiplications. The second step of extracting the ciphertexts  <span class="math">t_0, \\ldots, t_7</span>  is essentially a single linear operation. The third step of adding the elements  <span class="math">t_0, \\ldots, t_7</span>  together to produce  <span class="math">s_0, \\ldots, s_7</span> , requires  <span class="math">4 \\cdot 8 = 32</span>  homomorphic additions, due to the nature of the linear operation in AES. The final step of obtaining a single ciphertext from  <span class="math">s_0, \\ldots, s_7</span>  is also an application of a linear operation. Thus the total cost of SubBytes is given by  <span class="math">13 \\cdot C_M + 32 \\cdot C_A + 2 \\cdot C_L</span> .</p>

    <p class="text-gray-300">We note that our SIMD evaluation of the AES round function not only benefits in our system from being able to execute 16 operations in parallel. We also have the benefit of being able to deal directly with  <span class="math">\\mathbb{F}_{2^8}</span>  arithmetic operations, as well as decompose into bits where necessary in the linear transformation in the S-Box operation. The total cost of a round function being given by</p>

    <p class="text-gray-300"><span class="math">$14 \\cdot C_M + 37 \\cdot C_A + 7 \\cdot C_L</span>$</p>

    <p class="text-gray-300">although by interleaving operations a lower cost could probably be obtained</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">7.3 Data Base Lookup</h4>

    <p class="text-gray-300">We end by examining a more realistic application scenario, namely one of searching an encrypted database on a remote server. Suppose a user has previously encrypted a database and stored it on a cloud service provider, and now she wishes to retrieve some of the data. We first note that the usual atomic database operation of search actually consists of two operations. The first operation is one of search, whereas the second is one of retrieval. The following method performs the search using FHE and the retrieval using Private Information Retrieval (PIR).</p>

    <p class="text-gray-300">We assume the database is such that one can determine beforehand which fields will be searched on. In some sense this is akin to the basic premise of public key encryption with keyword search [1], however we have a more complicated data retrieval operation to perform. To simplify the discussion we assume that there is only one database field which is searchable, and another field which contains the information. Each database entry (in the clear) is then given by a tuple (i, s, d), where s is the search term, d is the data and i is some index which is going to enable retrieval. The number of such items we denote by r. We assume that i and s are n bits in length, and thus can be encoded as an element of the finite field  <span class="math">K_n = \\mathbb{F}_{2^n}</span> .</p>

    <p class="text-gray-300">To encrypt the database the user picks a public/private key pair (pk, sk) for our FH-SIMD scheme, as well as a symmetric key K for a symmetric encryption scheme  <span class="math">(E_K, D_K)</span> . Let us assume that the encryption scheme can support l operations in  <span class="math">\\mathbb{F}_{2^n}</span>  in parallel. When placing the database on the cloud service provider the user divides the database into  <span class="math">\\lceil r/l \\rceil</span>  blocks of l items. Then to actually send the server the jth encrypted data block, for  <span class="math">j=0,1,2,\\ldots,\\lceil r/l \\rceil-1</span>  we send</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} (\\mathbf{i}_j, c_j, \\mathbf{E}_j) = &amp; \\left(i_{l \\cdot j+1}, \\dots, i_{l \\cdot (j+1)}, \\right. \\\\ &amp; \\quad \\quad \\mathsf{Encrypt}(\\Gamma_{n,l}(s_{l \\cdot j+1}, \\dots, s_{l \\cdot (j+1)}), \\mathsf{pk}), \\\\ &amp; \\quad \\quad \\left. E_K(d_{l \\cdot j+1}), \\dots, E_K(d_{l \\cdot (j+1)}) \\right). \\end{split}</span>$</p>

    <p class="text-gray-300">We now discuss how the user retrieves all data items which correspond to the search term s. We first recover an encryption of an encoding of the index terms which contain this search term. This is done by sending the server one ciphertext, and receiving one in return. The sent &quot;query&quot; ciphertext is equal to</p>

    <p class="text-gray-300"><span class="math">$q = \\mathsf{Encrypt}(\\Gamma_{n,l}(s,\\ldots,s),\\mathsf{pk}),</span>$</p>

    <p class="text-gray-300">i.e. an encryption of l copies of the query term s.</p>

    <p class="text-gray-300">The server then takes each data block  <span class="math">(\\mathbf{i}_j, c_j, \\mathbf{E}_j)</span>  and computes  <span class="math">c_j^{(1)} = q \\oplus_{\\mathsf{pk}} c_j</span> . The value  <span class="math">c_j^{(1)}</span>  is then homomorphically raised to the power  <span class="math">2^n - 1</span> , by performing 2n applications of Mult. This results in a ciphertext  <span class="math">c_j^{(2)}</span>  which is an encryption of a vector of zero and ones, with a one only occurring in position k when k is not equal to the kth component of the vector underlying the ciphertext  <span class="math">c_j</span> .</p>

    <p class="text-gray-300">The server then computes  <span class="math">c_j^{(3)} = (c_j^{(2)} \\oplus_{\\mathsf{pk}} \\mathsf{Encrypt}(\\Gamma_{n,l}(1,1,\\ldots,1),\\mathsf{pk})) \\otimes_{\\mathsf{pk}} \\mathsf{Encrypt}(\\Gamma_{n,l}(\\mathbf{i}_j),\\mathsf{pk})</span> , and the set of ciphertexts  <span class="math">c_j^{(3)}</span>  are then added together using Add to obtain a final ciphertext c', which is returned to the user. Note, that this &quot;search&quot; query has a cost of  <span class="math">(2 \\cdot n + 1) \\cdot C_M + 2 \\cdot C_A</span>  per data block.</p>

    <p class="text-gray-300">The plaintext underlying the returned ciphertext c' consists of l components, where the kth component is given by</p>

    <p class="text-gray-300"><span class="math">$\\bigoplus_{s=s_{l\\cdot j+k}} i_{l\\cdot j+k}.</span>$</p>

    <p class="text-gray-300">If there is only one match per component then we have recovered the matching indices and hence can recover the actual data by engaging in a PIR protocol [4, 12]. The problem arises when we have the possibility of more than one match per component per query. In this situation we need an encoding algorithm to enable us to recover the exact PIR inputs we need to recover the data.</p>

    <p class="text-gray-300">In the extreme case we have a possibility of every component containing  <span class="math">\\lceil r/l \\rceil</span>  matches, i.e. the search term s matches with every item in the database. In which case we obtain, via a trivial encoding, that we must have  <span class="math">\\lceil r/l \\rceil \\le n</span> . This essentially implies that the length of the database is bounded by the number of bits we can encrypt, i.e.  <span class="math">r &lt; l \\cdot n</span> .</p>

    <p class="text-gray-300">However, if we can ensure that a maximum of t matches can occur per SIMD component then we can produce a more effective encoding as follows: Firstly we assume the encoding used for data retrieval in the PIR is such that we recover the data item corresponding to an index/component position pair. This simplifies our discussion as we only have to concentrate on decoding a single component.</p>

    <p class="text-gray-300">We set  <span class="math">m = \\lceil r/l \\rceil</span> , and to each of the m blocks we associate an n-bit index i. We want to therefore be able, given an xor of the indices  <span class="math">z = i_{j_1} \\oplus \\ldots \\oplus i_{j_s}</span> , with  <span class="math">s \\leq t</span> , to recover the set  <span class="math">\\{i_{j_1}, \\ldots, i_{j_s}\\}</span> . To construct the encoding we take the parity matrix of an [N, K, D] linear code over  <span class="math">\\mathbb{F}_2</span>  of length N, rank K and minimum distance D, which we assume is greater  <span class="math">2 \\cdot t</span> . This is a matrix of dimension  <span class="math">(N - K) \\times N</span> . We then take as our indices the columns of this matrix, which implies that these indices must fit in n bits, hence  <span class="math">N - K \\leq n</span> . Given an xor of at most t indices we can recover which indices were xor-ed together by decoding the [N, K, D] linear code. To see this notice that the sum of indices z is a syndrome of a codeword in the linear code. Thus by recovering the error positions in the code from the syndrome we know which indices, i.e. which columns of the parity check matrix, were xor-ed together. Thus the total number of distinct indices we can cope with is bounded by the column size of the parity check matrix, i.e. N. Hence, we obtain  <span class="math">m = \\lceil r/l \\rceil \\leq N</span> .</p>

    <p class="text-gray-300">As an example of a possible encoding scheme we take a primitive BCH code which exists for any pair of values of (s,t) such that  <span class="math">s \\geq 3</span>  and  <span class="math">t &lt; 2^{s-1}</span> . The primitive BCH code over  <span class="math">\\mathbb{F}_2</span>  then has parameters given by  <span class="math">N = 2^s - 1</span> ,  <span class="math">N - K \\leq s \\cdot t</span>  and  <span class="math">D \\geq 2 \\cdot t + 1</span> . If we take our FHE scheme of the previous section using the mth cyclotomic polynomial with m = 3485, then we have l = 64,  <span class="math">n \\leq d = 40</span>  and  <span class="math">\\phi(m) = 2560</span> . Given the bounds</p>

    <p class="text-gray-300"><span class="math">$\\lceil r/l \\rceil \\le N = 2^s - 1</span>$
and  <span class="math">s \\cdot t \\le n</span> ,</p>

    <p class="text-gray-300">and supposing we take t=3, so we can recover at most three collisions on search terms within each component, then by setting n=d=40 and (s,t)=(13,3) we obtain a valid encoding. This implies that the total number of items within the database is bounded by  <span class="math">l\\cdot N=524224</span> . Clearly using more optimal codes, or different cyclotomic polynomials one can obtain larger values of the whole database, or one can deal with more collisions within a component.</p>

    <p class="text-gray-300">The above methodology using our FH-SIMD scheme to search on l components at once in an efficient manner, results in a linear speed up in the search of the encrypted database. However, there is another advantage of our splitting the database into l components; we can deal with (albeit having a probability of invalid indices being returned) having more collisions between the search terms. In the above example we could deal with up to three collisions in each component, this meant that our method would be guaranteed to be correct if there were at most three items in the database corresponding to each search item. However, if we assume that the search items are randomly distributed between the l components, then in practice we can deal with more collisions, since our results will be correct as long as there are at most t collisions per component. The generalised birthday bound [17] says that we can have</p>

    <p class="text-gray-300"><span class="math">$(t!)^{1/t} \\cdot l^{(t-1)/t}</span>$</p>

    <p class="text-gray-300">collisions before the probability of obtaining more than t collisions in one of the l components is greater than 1/2. In our above numerical example, with t=3 and l=64, this equates to just over 29 matches in our database.</p>

    <p class="text-gray-300">This material is based on research sponsored by the European Commission through the ICT Programme under Contract ICT-2007-216676 ECRYPT II. The first author was also supported by the Defense Advanced Research Projects</p>

    <p class="text-gray-300">Agency (DARPA) and Air Force Research Laboratory (AFRL) under agreement number FA8750-11-2-0079, by the Royal Society via a Royal Society Wolfson Merit Award, by the ERC via an Advanced Grant, and the EPSRC via grant EP/I03126X. The second author was supported by a Postdoctoral Fellowship of the Research Foundation - Flanders (FWO).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>D. Boneh, G. Di Crescenzo, R. Ostrovsky, and G. Persiano. Public key encryption with keyword search. <em>Advances in Cryptology – Eurocrypt 2004</em>, Lecture Notes in Comput. Sci. 3027, 506–522, 2004.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Z. Brakerski and V. Vaikuntanathan. Fully homomorphic encryption from Ring-LWE and security for key dependent messages. To appear <em>Advances in Cryptology – Crypto 2011</em>, Lecture Notes in Comput. Sci. XXXX, XXXX–XXXX, 2011.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>D. Canright. A very compact S-Box for AES. <em>Cryptographic Hardware and Embedded Systems CHES 2005</em>, Lecture Notes in Comput. Sci. 3659, 441–455, 2005.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>B. Chor, E. Kushilevitz, O. Goldreich and M. Sudan. Private information retrieval. <em>J. ACM</em>, 45, 965–981, 1998.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>M. van Dijk, C. Gentry, S. Halevi, and V. Vaikuntanathan. Fully homomorphic encryption over the integers. <em>Advances in Cryptology – Eurocrypt 2010</em>, Lecture Notes in Comput. Sci. 6110, 24–43, 2010.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>J.W. Cooley and J.W. Tukey. An algorithm for the machine calculation of complex Fourier series. <em>Math. Comp.</em>, 19, 297–301, 1965.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>I. Damgard and M. Keller. Secure multiparty AES. ˚ <em>Financial Cryptography FC 2010</em>, Lecture Notes in Comput. Sci. 6052, 367–374, 2010.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>C. Gentry. Fully homomorphic encryption using ideal lattices. <em>Symposium on Theory of Computing STOC 2009</em>, ACM, 169–178, 2009.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>C. Gentry. A fully homomorphic encryption scheme. <em>Manuscript</em>, 2009.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>C. Gentry and S. Halevi. Implementing Gentry's fully-homomorphic encryption scheme. <em>Advances in Cryptology Eurocrypt 2011</em>, Lecture Notes in Comput. Sci. 6632, 129–148, 2011.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>I.J. Good. The interaction algorithm and practical Fourier analysis. <em>J.R. Stat. Soc.</em>, 20, 361–372, 1958.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>E. Kushilevitz and R. Ostrovsky. Replication is not needed: Single database, computationally-private information retrieval. <em>Foundations of Computer Science – FoCS '97</em>, 364–373, 1997.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>K. Lauter, M. Naehrig, V. Vaikuntanathan. Can homomorphic encryption be practical. Preprint, 2011.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>B. Pinkas, T. Schneider, N.P. Smart, S.C. Williams. Secure two-party computation is practical. <em>Advances in Cryptology – Asiacrypt 2009</em>, Lecture Notes in Comput. Sci. 5912, 250-267, 2009.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>C.M. Rader. Discrete Fourier transforms when the number of data samples is prime. <em>Proc. IEEE</em>, 56, 1107–1108, 1968.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>N.P. Smart and F. Vercauteren. Fully homomorphic encryption with relatively small key and ciphertext sizes. <em>Public Key Cryptography – PKC 2010</em>, Lecture Notes in Comput. Sci. 6056, 420–443, 2010.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>K. Suzuki, D. Tonien, K. Kurosawa and K. Toyota. Birthday paradox for multi-collisions. <em>Information Security and Cryptology – ICISC 2006</em>, Lecture Notes in Comput. Sci. 4296, 29–40, 2006.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>L.H. Thomas. Using a computer to solve problems in physics. <em>Application of Digital Computers</em>, 1963.</li>
    </ol></li>
    </ul>

`;
---

<BaseLayout title="Fully Homomorphic SIMD Operations (2011/133)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2011 &middot; eprint 2011/133
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="fully-homomorphic-simd-operations-2011" />
  </article>
</BaseLayout>
