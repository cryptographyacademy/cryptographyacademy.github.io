---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/916';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'FruitChains: A Fair Blockchain';
const AUTHORS_HTML = 'Rafael Pass, Elaine Shi';

const CONTENT = `    <p class="text-gray-300">Rafael Pass Cornell Tech rafael@cs.cornell.edu Elaine Shi Cornell University elaine@cs.cornell.edu</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Nakamoto’s famous <em>blockchain</em> protocol enables achieving consensus in a so-called <em>permissionless setting</em>—anyone can join (or leave) the protocol execution, and the protocol instructions do not depend on the identities of the players. His ingenious protocol prevents “sybil attacks” (where an adversary spawns any number of new players) by relying on <em>computational puzzles</em> (a.k.a. “moderately hard functions”) introduced by Dwork and Naor (Crypto’92). Recent work by Garay et al (EuroCrypt’15) and Pass et al (manuscript, 2016) demonstrate that this protocol provably achieves <em>consistency</em> and <em>liveness</em> assuming a) honest players control a majority of the computational power in the network, b) the puzzle-hardness is appropriately set as a function of the maximum network delay and the total computational power of the network, and c) the computational puzzle is modeled as a random oracle. Assuming honest participation, however, is a strong assumption, especially in a setting where honest players are expected to perform a lot of work (to solve the computational puzzles). In Nakamoto’s Bitcoin application of the blockchain protocol, players are <em>incentivized</em> to solve these puzzles by receiving rewards for every “block” (of transactions) they contribute to the blockchain. An elegant work by Eyal and Sirer (FinancialCrypt’14), strengthening and formalizing an earlier attack discussed on the Bitcoin forum, demonstrates that a <em>coalition</em> controlling even a minority fraction of the computational power in the network can gain (close to) 2 times its “fair share” of the rewards (and transaction fees) by deviating from the protocol instructions. In contrast, in a <em>fair</em> protocol, one would expect that players controlling a <span class="math">\\phi</span> fraction of the computational resources to reap a <span class="math">\\phi</span> fraction of the rewards.</p>

    <p class="text-gray-300">In this work, we present a new blockchain protocol—the FruitChain protocol—which satisfies the same consistency and liveness properties as Nakamoto’s protocol (assuming an honest majority of the computing power), and additionally is <em><span class="math">\\delta</span>-approximately fair</em>: with overwhelming probability, any honest set of players controlling a <span class="math">\\phi</span> fraction of computational power is guaranteed to get at least a fraction <span class="math">(1-\\delta)\\phi</span> of the blocks (and thus rewards) in <em>any</em> <span class="math">\\Omega(\\frac{\\kappa}{\\delta})</span> length segment of the chain (where <span class="math">\\kappa</span> is the security parameter). As a consequence, if this blockchain protocol is used as the ledger underlying a cryptocurrency system, where rewards and transaction fees are <em>evenly distributed</em> among the miners of blocks in a length <span class="math">\\kappa</span> segment of the chain, no coalition controlling less than a majority of the computing power can gain more than a factor <span class="math">(1+3\\delta)</span> by deviating from the protocol (i.e., honest participation is an <em><span class="math">\\frac{n}{2}</span>-coalition-safe <span class="math">3\\delta</span>-Nash equilibrium</em>). Finally, the FruitChain protocol enables decreasing the <em>variance</em> of mining rewards and as such significantly lessens (or even obliterates) the need for mining pools.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Distributed systems have been historically analyzed in a <em>closed</em> setting—a.k.a. the <em>permissioned setting</em>—in which the number of participants in the system, as well as their identities, are common knowledge. In 2008, Nakamoto <em>[nakamoto]</em> proposed his celebrated “blockchain protocol” which attempts to achieve consensus in a <em>permissionless</em> setting: anyone can join (or leave) the protocol execution (without getting permission from a centralized or distributed authority), and the protocol instructions do not depend on the identities of the players. The core blockchain protocol (a.k.a. “Nakamoto consensus”, or the “Bare-bones blockchain protocol”), roughly speaking, is a method for maintaining a <em>public</em>, <em>immutable</em> and <em>ordered</em> ledger of records (for instance, in the Bitcoin application, these records are simply transactions); that is, records can be added to the <em>end</em> of the ledger at any time (but only to the end of it); additionally, we are guaranteed that records previously added cannot be removed or reordered and that all honest users have a <em>consistent view</em> of the ledger—we refer to this as <em>consistency</em>. Additionally, the protocol should satify a <em>liveness</em> property: transactions submitted by an honest user get incorporated into the ledger sufficiently fast.</p>

    <p class="text-gray-300">The key challenge with the permissionless setting is that an attacker can trivially mount a so-called “sybil attack”—it simply spawns lots of players (that it controls) and can thus easily ensure that it controls a majority of all the players. Indeed, Barak et al <em>[barak]</em> proved that this is a fundamental problem with the permissionless model. Nakamoto blockchain protocol overcomes this issue by relying on “computational puzzles”—a.k.a. <em>moderately hard functions</em> or <em>proofs of work</em>—put forth by Dwork and Naor <em>[dwork]</em>: roughly speaking, the participants are required to solve the computational puzzle of some well-defined diffulty in order to confirm transactions—this is referred to as <em>mining</em>. Next, rather than attempting to provide robustness whenever the majority of the participants are honest (since participants can be easily spawned in the permissionless setting), Nakamoto’s goal was to provide robustness of the protocol under the assumption that a <em>majority of the computing power</em> is held by honest participants. Indeed, recent works by Garay et al. <em>[garay]</em> and Pass et al. <em>[pass]</em> formally proved that Nakamoto’s blockchain protocol satisfies the above-mentioned consistency and liveness under different network assumptions, as long as the puzzle difficulty (referred to as the <em>mining hardness</em>) is apporpriately set as a function of the maxiumum delay in the network.</p>

    <p class="text-gray-300">Nakamoto’s blockchain represents an exciting breakthrough: it demonstrated that distributed consensus is possible on an Internet scale. The above analyses, however, assume that a majority of the computing power is controlled by honest players, and that honest players correctly execute the protocol. Assuming such honest participation is a strong assumption, especially in a setting where honest players are expected to perform a lot of work (to solve the computational puzzles)—why would we expect players to want to participate if it is costly! (This can be formalized in the GameTheory with Costly computation framework of Halpern and Pass <em>[halpern]</em>). In Nakamoto’s ingenious Bitcoin application of the blockchain protocol, players are thus <em>incentivized</em> to solve these puzzles by receiving, so-called, <em>block rewards</em> for every “blocks” (of transactions) they contribute to the blockchain; additionally, the miners also receive <em>transaction fees</em> for all the transactions that are confirmed in the block. The hope is that these reward mechanism (block rewards and transaction fees) properly incentivize honest participation. Unfortunately, as shown by several recent work, this is not the case:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Selfish mining undermines incentive compatibility</em>. Nakamoto’s blockchain suffers from a so-called <em>selfish-mining</em> attack, where even a minority coalition that controls network delivery can manage to reap close to twice its fair share of block rewards <em>[mckinney, mckinney, nkans]</em>—in particular, if the adversary wields close to a half of the computational power, it can reap almost all of the rewards, thus denying honest players of (almost) any reward! (More specifically, whenever the adversary mines a new block, it simply <em>withholds it</em> (not sharing it with the honest</li>

    </ul>

    <p class="text-gray-300">players), and only releases it when some honest player mines a new block—if the adversary controls the network it can ensure that all honest players receive the adversarial block before the block mined by the honest players, and as such, it effectively “erases” the honest player’s block replacing it with its own block.) This selfish mining attack was first observed in discussions on the Bitcoin forum <em>[x18]</em>; the first analytical study provided by Eyal and Sirer <em>[x11]</em>, and subsequently improved by Sapirshtein et al. <em>[x25]</em> and Nayak et al. <em>[x20]</em>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Transaction fees exacerbate instability. Due to Bitcoin’s particular coin minting schedule, the block reward is scheduled to decrease over time and miners are expected to obtain rewards increasingly more from transaction fees. A recent work by Carlsten et al. <em>[x5]</em> (concurrent to ours) demonstrates that the situation gets even worse once we take into account the transaction fees: as a simplest example, if a block contains transactions with large fees, miners will be incentivized to create a “fork” and attempt to confirm the transaction themselves.</li>

      <li>Mining pools harm decentralization. Finally, to maintain consistency of the blockchain, the puzzle difficulty is (and by the analysis of <em>[x22]</em> need to be set) so that the whole world combined mines a block (i.e., solves a computational puzzle) roughly every 10 minutes. As a consequence, an individual “solo miner” with state-of-the-art equiment needs to wait on average, roughly, 2 years before it gets any rewards <em>[x21]</em>. This has led to the formation of “mining pools” where miners are coordinated by a pool operator and share the rewards to reduce the variance of their gains. In essence, the decentralized nature of the blockchain is lost.</li>

    </ul>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Our Results</h3>

    <p class="text-gray-300">In this work, we introduce a notion of fairness for blockchain protocols: Roughly speaking, we say that a blockchain protocol that is <em>fair</em> if honest players that wield <span class="math">\\phi</span> fraction of the computational resources will reap at least <span class="math">\\phi</span> fraction of the blocks in any sufficiently long window of the chain. (This notion of fairness can be viewed as a strengthen form of the notion of “ideal chain quality” considered, but not acheived, in <em>[x13, x22]</em>) More precisely, we say that a blockchain protocol is <em><span class="math">\\delta</span>-approximately fair</em> w.r.t. <span class="math">\\rho</span> attackers if, with overwhelming probability, any <span class="math">\\phi</span> fraction coalition of <em>honest</em> users is guaranteed to get at least a <span class="math">(1-\\delta)\\phi</span> fraction of the blocks in every sufficiently long window of the chain, even in the presence of an adversary controlling up to a <span class="math">\\rho</span> fraction of the computing power. Our main theorem shows how to acheive a blockchain which satisfies the same consistency and liveness properties as Nakamoto’s one, as well as fairness:</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Theorem 1.1 (Informally stated).</h6>

    <p class="text-gray-300">Let <span class="math">\\rho&lt;\\frac{1}{2}</span> be a constant. Then, for every constant <span class="math">\\delta&gt;0</span>, there exists a blockchain protocol that satisfies consistency, liveness and <span class="math">\\delta</span>-approximate fairness.</p>

    <p class="text-gray-300">Note that approximate fairness directly implies that an attacker cannot get “much” more than its fair share of the block rewards (and thus it disincentivizes selfish mining). But the instability issue with transaction fees still remains, and so does the mining pool issue. We finally demonstrate that our protocol provides a solution to both these issues as well:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Regarding transaction fees: we suggest a method for spreading out the transaction fees of a block over the miners of a <em>sequence</em> of blocks preceeding it. As we show, any fair blockchain protocol can be used to disincentivize deviation even in the presence of transaction fee under this new reward rule. More precisely, we show that no coalition controlling less than a majority of the computing power can gain more than a factor <span class="math">(1+3\\delta)</span> of the block rewards and transaction fees by deviating from the protocol—that is, honest participation is an <span class="math">\\frac{n}{2}</span>-coalition-safe <span class="math">3\\delta</span>-Nash equilibrium.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Regarding mining pools, we demonstrate that the block (i.e., fruit) mining difficulty in our protocol can be made almost arbitrarily small, and as a consequence, miners can get paid much more often. Indeed, experimental results implenting our new blockchain <em>[BHP^{+}]</em> show that with Bitcoin current block size of 1MB, by sacrificing 8% to 10% of the block to new meta data, we can ensure that miners get paid 1000x more often (and thus on average, roughly, twice per day). Consequently, there is no longer a need for pooled mining.</li>

    </ul>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Protocol Overview</h3>

    <p class="text-gray-300">To explain our protocol, let us first recall Nakamoto’s blockchain protocol as we will make use of it.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Nakamoto’s protocol in a nutshell.</h4>

    <p class="text-gray-300">Roughly speaking, players “confirm” records/transactions by “mining blocks of transactions” through solving some computational puzzle that is a function of the transactions and the history so far. More precisely, each participant maintains its own local “chain” of “blocks” of records —called the <em>blockchain</em>. Each block consists of a triple <span class="math">(h_{-1},\\eta,\\mathsf{m})</span> where <span class="math">h_{-1}</span> is a pointer to the previous block in chain, <span class="math">\\mathsf{m}</span> is the record component of the block, and <span class="math">\\eta</span> is a “proof-of-work”—a solution to a computational puzzle that is derived from the pair <span class="math">(h_{-1},\\mathsf{m})</span>. The proof of work can be thought of as a “key-less digital signature” on the whole blockchain up until this point.</p>

    <p class="text-gray-300">Concretely, Nakamoto’s protocol is parametrized by a parameter <span class="math">p</span>—which we refer to as the <em>mining hardness parameter</em>, and a proof-of-work is deemed valid if <span class="math">\\eta</span> is a string such that <span class="math">\\mathsf{H}(h_{-1},\\eta,\\mathsf{m})&lt;D_{p}</span>, where <span class="math">\\mathsf{H}</span> is a hash function (modeled as a random oracle) and <span class="math">D_{p}</span> is set so that the probability that an input satisfies the relation is less than <span class="math">p</span>. At any point of the protocol execution, each participant attempts to increase the length of its own chain by “mining” for a new block: upon receiving some record <span class="math">\\mathsf{m}</span>, it picks a random <span class="math">\\eta</span> and checks whether <span class="math">\\eta</span> is a valid proof of work w.r.t. <span class="math">\\mathsf{m}</span> and <span class="math">h_{-1}</span>, where <span class="math">h_{-1}</span> is a pointer to the last block of its current chain; if so, it extends is own local chain and broadcast it to the all the other participants. Whenever a participant receives a chain that is longer than its own local chain, it replaces its own chain with the longer one.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">The FruitChain protocol.</h4>

    <p class="text-gray-300">Roughly speaking, our protocol, which we refer to as the FruitChain protocol, will be running an instance of Nakamoto’s blockchain protocol, but instead of directly storing the records <span class="math">\\mathsf{m}</span> inside the blockchain, the records are put inside “fruits” denoted <span class="math">f</span>; these fruits themselves require solving some proof of work, with a <em>different hardness parameter</em> <span class="math">p_{f}</span>; additionally, we require the fruits to “hang” from a block in the chain which is not too “far” from the block which records the fruit—more specifically, the fruit needs to “point” to an earlier block in the chain which is not too far from the block containing it (and thus, the fruit could not have been mined “too” long ago)—we refer to such a fruit as being <em>recent</em>. In this new protocol, the fruits play the roles of “blocks”—i.e., <em>“orange is the new block”</em>—and chain quality is thus defined in terms of fruits.</p>

    <p class="text-gray-300">In each round, honest players simultaneously mine for a fruit and a block (for Nakamoto’s blockchain) by making one invocation of the hash function—this follows the 2-for-1 trick of <em>[x13]</em> where, say, the prefix of the output of <span class="math">H</span> determines whether fruit mining is successful, and the suffix is used to determine whether block mining is successful. Whenever a player successfully mines a fruit it broadcasts it to all other players; fruits that have not yet been recorded in the blockchain (and that are still recent) are stored in a buffer and all honest players next attempt to add them to the blockchain.</p>

    <p class="text-gray-300">Intuitively, the reason why “selfish mining” fails is that even if an adversary tries to “erase” some block mined by an honest player (which contains some honest fruits), by the chain growth and chain quality properties of the underlying blockchain, eventually an honest player will mine a new block which is stable and this honest player will include the fruits in it—in fact, the time before such an “honest block” arrives is short enough for the fruit to still be “recent” at the time of the honest block arriving.</p>

    <p class="text-gray-300">Intuitively, the reason why we require fruits to be recent is to prevent a different kind of attack: without it, an attacker could <em>withhold fruits</em>, and suddenly release lots of them at the same time, thereby creating an very high fraction of adversarial fruits in some segment of the (fruit) chain. By requiring the fruits to be recent, we prevent the adversary from squirreling away (too many of) its fruits: since the underlying blockchain has a guaranteed liveness, we can upperbound the extra amount of time the attacker can withhold fruits and thus upperbound the number of extra fruits it can release in any window.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">1.3 Related Work</h3>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Comparison with GHOST, the Inclusive Blockchain, and <em>[x12]</em></h4>

    <p class="text-gray-300">Although our approach of including fruits in a main blockchain take inspiration from to the earlier elegant works on GHOST <em>[x24]</em> and inclusive blockchains <em>[x16]</em>, we stress that these earlier works do not attain our goals of providing a provably secure, fair blockchain. GHOST <em>[x24]</em> is a mechanism such that forking blocks not on the main chain will affect the chain selection rule— however, as the subsequent work by Kiayias and Panagiotakos <em>[x19]</em> shows, GHOST actually worsens “chain quality” (i.e., the fraction of honest blocks in the chain) whereas our goal is to improve chain quality and fairness. The inclusive blockchain work proposes to maintain a direct acyclic graph rather than a chain, such that forking subtrees may be included in the linearized transaction log — despite the superficial resemblance at first sight, the mechanisms employed by the inclusive blockchain is actually quit different from how we include fruits in the main blockchain.</p>

    <p class="text-gray-300">As mentionned above, our protocol borrows the 2-for-1 trick from the work Garay et al <em>[x12]</em> which also relied on a separate “mining process” to acheive a different goal (namely, to implement a broadcast channel from a blockchain).</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Subsequent works.</h4>

    <p class="text-gray-300">In both Nakamoto’s blockchain protocol and ours, the time needed to confirm transactions grows with the <em>worst-case upper-bound</em> on the network delay <em>[x20, x21]</em>. In contrast, in a <em>responsive</em> protocol, we require the confirmation time to only be a function of the <em>actual</em> network delay, which may be a lot smaller than the worst-case one. In a companion paper called <em>hybrid consensus</em> <em>[x20]</em>, we show how to combine any blockchain protocol with classical asynchronous consensus to improve the latency of the blockchain protocol and achieve a responsive protocol. Roughly speaking, hybrid consensus makes use of a blockchain to elect a committee—more specifically, the miners of blocks in a sufficiently long segment of the chain are elected as the committee—and then this committee executes the classical consensus protocol. The chain quality of the blockchain determines the fraction of honest players in the committee: if we employ Nakamoto’s blockchain, we would need to require that <span class="math">\\frac{3}{4}</span> of the computing power is controlled by honest player to ensure a chain quality of <span class="math">\\frac{2}{3}</span> and thus a fraction <span class="math">\\frac{2}{3}</span> honest committee members (which is required by the consensus protocol). In contrast, by relying on our new FruitChain protocol, it suffices to assume that <span class="math">\\frac{2}{3}</span> of the computing power is controlled by honest players. We highlight that, as shown in <em>[x20]</em>, achieving a responsive protocol also <em>requires</em> assuming that <span class="math">\\frac{2}{3}</span> of the computing is held by honest parties, and as such relying on our FruitChain protocol enables achieving an <em>optimal resilience</em> for low-latency blockchains.</p>

    <p class="text-gray-300">Besides hybrid consensus, other subsequent works have also employed ideas from FruitChain to achieve incentive compatibility in blockchain style protocols. Notably, recent provably secure</p>

    <p class="text-gray-300">proof-of-stake protocols, including Snow White <em>[x1]</em> and Ouroboros <em>[x11]</em>, argue that the idea from FruitChain is applicable to non-proof-of-work blockchains as well.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Other related works.</h4>

    <p class="text-gray-300">Kiayias et al. <em>[x11]</em> model Bitcoin mining as a game, where nodes decide on which blocks to extend and whether to release a mined block. They show that for small players controlling less than <span class="math">\\frac{1}{3}</span> of the resources, following Bitcoin’s protocol specification is a Nash equilibrium. Their results, however, only apply to a rather constrained idealistic model where all honest miners can communicate with 0 latency, and the adversary cannot perform form any network level attacks (such as rushing). As we mentionned in the introduction, in our model where the adversary can control the delivery of messages, the bitcoin protocol is not incentive compatible even for players controlling less than a <span class="math">\\frac{1}{3}</span> of the computational resources—there is a selfish mining attack which enables an attacker to gain <span class="math">\\frac{1}{2}</span> of the block rewards.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">1.4 Roadmap</h3>

    <p class="text-gray-300">In Section 2, we define the protocol execution model and the formal abstraction of a blockchain protocol. In Section 3, we present our new fairness definition for a blockchain protocol. In Section 4, we formally present our FruitChain protocol. In Section 5, we provide formal proofs for our main theorem. In Section 6, we describe how, given any (approximately) fair blockchain, we can design payout mechanisms to achieve incentive compatibility and <span class="math">\\epsilon</span>-Nash equilibrium. Finally, in Section 7, we describe how FruitChain can also be used to disincentivize mining pools and ensure the decentralized nature of a blockchain.</p>

    <h2 id="sec-13" class="text-2xl font-bold">2 Preliminaries and Definitions</h2>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">2.1 Protocol Execution Model and Notations</h3>

    <p class="text-gray-300">A protocol refers to an algorithm for a set of interactive Turing Machines (also called nodes) to interact with each other. The execution of a protocol <span class="math">\\Pi</span> that is directed by an environment <span class="math">Z(1^{\\kappa})</span> (where <span class="math">\\kappa</span> is a security parameter), which activates a number of parties <span class="math">1,2,\\ldots,n</span> as either “honest” or corrupted parties. Honest parties would faithfully follow the protocol’s prescription, whereas corrupt parties are controlled by an adversary <span class="math">A</span> which reads all their inputs/message and sets their outputs/messages to be sent.</p>

    <p class="text-gray-300">The environment <span class="math">Z</span> is a terminology often used in protocol composition in the cryptography literature — one can regard the environment <span class="math">Z</span> a catch-all term that encompasses everything that lives outside the “box” defined by the protocol. For example, as mentioned later, part of the environment <span class="math">Z</span>’s job is to provide inputs to honest nodes and receive outputs from them. This models the fact that the inputs to the protocol may originate from external applications and the protocol’s outputs can be consumed by external applications where any external application or other protocols running in the system are viewed as part of <span class="math">Z</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A protocol’s execution proceeds in <em>rounds</em> that model atomic time steps. At the beginning of every round, honest nodes receive inputs from an environment <span class="math">Z</span>; at the end of every round, honest nodes send outputs to the environment <span class="math">Z</span>.</li>

      <li><span class="math">A</span> is responsible for delivering all messages sent by parties (honest or corrupted) to <em>all</em> other parties. <span class="math">A</span> cannot modify the content of messages broadcast by honest players, <em>but it may delay or reorder the delivery of a message</em> as long as it eventually delivers all messages. (Later, we</li>

    </ul>

    <p class="text-gray-300">shall consider restrictions on the delivery time.) The identity of the sender is not known to the recipient.²</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At any point, <span class="math">Z</span> can corrupt an honest party <span class="math">j</span> which means that <span class="math">A</span> gets access to its local state and subsequently, <span class="math">A</span> controls party <span class="math">j</span>. (In particular, this means we consider a model with “erasures”; random coin tosses that are no longer stored in the local state of <span class="math">j</span> are not visible to <span class="math">A</span>.)³</li>

      <li>At any point, <span class="math">Z</span> can uncorrupt a corrupted player <span class="math">j</span>, which means that <span class="math">A</span> no longer controls <span class="math">j</span>. A player that becomes uncorrupt is treated in the same way as a newly spawning player, i.e., the player’s internal state is re-initialized and then the player starts executing the honest protocol no longer controlled by <span class="math">A</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notations for randomized execution. A protocol’s execution is randomized, where the randomness comes from honest players as well as the adversary denoted <span class="math">A</span> that controls all corrupt nodes, and the environment <span class="math">Z</span> that sends inputs to honest nodes during the protocol execution. We use the notation view<span class="math">\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}</span>EXEC™<span class="math">(A,Z,\\kappa)</span> to denote a randomly sampled execution trace, and</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">view</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">denotes the number of rounds in the execution trace view. More specifically, view is a random variable denoting the joint view of all parties (i.e., all their inputs, random coins and messages received, including those from the random oracle) in the above execution; note that this joint view fully determines the execution.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Constraints on <span class="math">(A,Z)</span>. The environment <span class="math">Z</span> and the adversary <span class="math">A</span> must respect certain constraints. We say that a p.p.t. pair <span class="math">(A,Z)</span> is <span class="math">(n,\\rho,\\Delta)</span>-respecting w.r.t. <span class="math">\\Pi</span>, iff for every <span class="math">\\kappa\\in N</span>, every view view in the support of EXEC™<span class="math">(A,Z,\\kappa)</span>, the following holds:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Z</span> activates <span class="math">n</span> parties in view;</li>

      <li>For any message broadcast by an honest player at any time <span class="math">t</span> in view, any player that is honest at time <span class="math">t+\\Delta</span> or later must have received the message. This means that in the case of newly spawned players, instantly delivers messages that were sent more than <span class="math">\\Delta</span> rounds ago. As long as this <span class="math">\\Delta</span> constraint is respected, <span class="math">A</span> is allowed to delay or reorder honest players’ messages arbitrarily.</li>

      <li>at any round <span class="math">r</span> in view, <span class="math">A</span> controls at most <span class="math">\\rho\\cdot n</span> parties; and</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">\\Gamma(\\cdot,\\cdot,\\cdot)</span> be a boolean predicate. We say that a p.p.t. pair <span class="math">(A,Z)</span> is <span class="math">\\Gamma</span>-compliant w.r.t. protocol <span class="math">\\pi</span> iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(A,Z)</span> is <span class="math">(n,\\rho,\\Delta)</span>-respecting w.r.t. <span class="math">\\pi</span>; and</li>

      <li><span class="math">\\Gamma(n,\\rho,\\Delta)=1</span>.</li>

    </ul>

    <p class="text-gray-300">In other words <span class="math">\\Gamma</span> is a predicate that places constraints on additional constraints on the parameter <span class="math">(n,\\rho,\\Delta)</span> that <span class="math">(A,Z)</span> must respect. When the context is clear, we often say that <span class="math">(A,Z)</span> is <span class="math">\\Gamma</span>-compliant while omitting to specify w.r.t. which protocol.</p>

    <p class="text-gray-300">²We could also consider a seemingly weaker model where messages sent by corrupted parties need not be delivered to all honest players. We can easily convert the weaker model to the stronger model by having honest parties “gossip” all messages they receive.</p>

    <p class="text-gray-300">³Our proof actually extends also to the model “without erasures”.</p>

    <p class="text-gray-300">6</p>

    <p class="text-gray-300">2.2 Conventions</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Variables that are functions of the security parameter.</h4>

    <p class="text-gray-300">Unless otherwise noted, by default we assume that all variables are a function of the security parameter <span class="math">\\kappa</span>. If any variable is not a function of <span class="math">\\kappa</span>, we shall explicitly note that the variable is a <em>constant</em>. Variables may also be functions of each other as defined later by relations that <span class="math">(A,Z)</span> must additionally satisfy for our blockchain protocol to be secure.</p>

    <p class="text-gray-300">For two variables that by default are functions of <span class="math">\\kappa</span>, we say that <span class="math">\\mathsf{var}_{1}&lt;\\mathsf{var}_{2}</span> iff for every <span class="math">\\kappa\\in\\mathbb{N}</span>, <span class="math">\\mathsf{var}_{1}(\\kappa)&lt;\\mathsf{var}_{2}(\\kappa)</span>. Similarly, if we say that <span class="math">\\mathsf{var}</span> is positive, we mean that <span class="math">\\mathsf{var}(\\kappa)</span> is positive for any <span class="math">\\kappa\\in\\mathbb{N}</span>.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Other conventions.</h4>

    <p class="text-gray-300">Throughout this paper, whenever we refer to p.p.t. machines, we mean that the machine is <em>non-uniform</em> probabilistic polynomial-time.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">2.3 Blockchain Protocols</h3>

    <p class="text-gray-300">In this section, we recall the abstract model for blockchain protocols from <em>[x20]</em> and a provide a description of Nakamoto’s original blockchain protocol which we will heavily make use of.</p>

    <p class="text-gray-300">In a blockchain protocol <span class="math">\\Pi</span>, nodes receive input records from an environment <span class="math">Z</span>, and nodes interact with each other to agree on a linearly ordered log of transactions in a way that achieves consistency and liveness.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Inputs and outputs of a blockchain protocol.</h4>

    <p class="text-gray-300">At the beginning of each time step, the environment <span class="math">Z</span> inputs a record <span class="math">\\mathsf{m}</span> to each honest player. At the end of each time step, each honest player outputs a <span class="math">\\mathsf{chain}</span> to the environment <span class="math">Z</span>, where <span class="math">\\mathsf{chain}</span> denotes an ordered sequence of records (also referred to as blocks). Each record (or block) may in turn contain an ordered sequence of transactions. Henceforth we use the notation</p>

    <p class="text-gray-300"><span class="math">\\text{output of node }i\\text{ in round }t:\\ \\ \\mathsf{chain}_{i}^{t}(\\mathsf{view})</span></p>

    <p class="text-gray-300">to denote the output of node <span class="math">i</span> in round <span class="math">t</span> to <span class="math">Z</span> in a given execution trace <span class="math">\\mathsf{view}</span>.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Modeling proofs-of-work.</h4>

    <p class="text-gray-300">To model Nakamoto’s blockchain protocol, we need to extend the protocol execution model with a random oracle. In an execution with security parameter <span class="math">\\kappa</span>, we assume all parties have access to a random function <span class="math">H:\\{0,1\\}^{<em>}\\to\\{0,1\\}^{\\kappa}</span> which they can access through two oracles: <span class="math">\\mathsf{H}(x)</span> simply outputs <span class="math">H(x)</span> and <span class="math">\\mathsf{H.ver}(x,y)</span> output <span class="math">1</span> iff <span class="math">H(x)=y</span> and <span class="math">0</span> otherwise. In any round <span class="math">r</span>, the players (as well as <span class="math">A</span>) may make </em>any<em> number of queries to <span class="math">\\mathsf{H.ver}</span>. On the other hand, in each round <span class="math">r</span>, honest players can make only a </em>single<em> query to <span class="math">\\mathsf{H}</span>, and an adversary <span class="math">A</span> controlling <span class="math">q</span> parties, can make <span class="math">q</span> </em>sequential<em> queries to <span class="math">\\mathsf{H}</span>. (This modeling is meant to capture the assumption that we only “charge” for the effort of finding a solution to a “proof of work” </em>[x10]*, but checking the validity of a solution is cheap. We discuss this further after introducing Nakamoto’s protocol.) We emphasize that the environment <span class="math">Z</span> does not get direct access to the random oracle (but can instruct <span class="math">A</span> to make queries).</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">2.4 Nakamoto’s Blockchain Protocol</h3>

    <p class="text-gray-300">We turn to describing Nakamoto’s protocol <em>[x18]</em>, which we refer to as <span class="math">\\Pi_{\\text{nak}}(p)</span>. <span class="math">\\Pi_{\\text{nak}}(p)</span> takes in a puzzle difficulty parameter <span class="math">p</span> that denotes the probability that each player mines a block in a single round.</p>

    <p class="text-gray-300">Protocol overview.</p>

    <p class="text-gray-300">In <span class="math">\\Pi_{\\mathrm{nak}}</span>, each honest node maintains an internal state <span class="math">chain</span> at any point of time. Each <span class="math">chain[i]</span> is referred to as a (mined) block and is of the format <span class="math">chain[i]:=(h_{-1},\\eta,\\mathsf{m},h)</span>, containing the hash of the previous block denoted <span class="math">h_{-1}</span>, a nonce <span class="math">\\eta</span>, a record <span class="math">\\mathsf{m}</span>, and a hash <span class="math">h</span> Let chain := extract(<span class="math">chain</span>) be the sequence of records contained in the sequence of blocks <span class="math">chain</span>. chain is the version that honest nodes output to the environment.</p>

    <p class="text-gray-300">The <span class="math">\\Pi_{\\mathrm{nak}}</span> works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Nodes that are newly spawned or that have been become uncorrupt start with initial chain containing only a special genesis block: <span class="math">chain := (0, 0, \\bot, \\mathsf{H}(0, 0, \\bot))</span>.</li>

      <li>In every round: a node reads all incoming messages (delivered by <span class="math">A</span>). If any incoming message <span class="math">chain&#x27;</span> is a valid sequence of blocks that is longer than its local state <span class="math">chain</span>, replace <span class="math">chain</span> by <span class="math">chain&#x27;</span>. We define what it means for a chain to be valid later. Note that checking the validity of <span class="math">chain&#x27;</span> can be done using only H.ver queries.</li>

      <li>Read an input record <span class="math">\\mathsf{m}</span> from the environment <span class="math">Z</span>. Now parse chain[-1] := <span class="math">(\\neg, \\neg, \\neg, h_{-1})</span>, pick a random nonce <span class="math">\\eta \\in \\{0,1\\}^{\\kappa}</span>, and issue query <span class="math">h = \\mathsf{H}(h_{-1}, \\eta, \\mathsf{m})</span>. If <span class="math">h &amp;lt; D_p</span>, then append the newly mined block <span class="math">(h_{-1}, \\eta, b, h)</span> to chain and broadcasts the updated chain.</li>

    </ul>

    <p class="text-gray-300">More specifically, <span class="math">D_p = p(\\kappa) \\cdot 2^\\kappa</span> such that for all <span class="math">(h, \\mathfrak{m})</span>, <span class="math">\\operatorname{Pr}_n[\\mathsf{H}(h, \\eta, \\mathfrak{m}) &amp;lt; D_p] = p</span>. In other words, <span class="math">D_p</span> is appropriately parameterized such that the probability that any player mines a block in a round is <span class="math">p</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output chain := extract(<span class="math">chain</span>) to the environment <span class="math">Z</span>. Note that the notation chain extracts only the sequence of records from chain removing all other metadata that are not needed by external applications.</li>

    </ul>

    <p class="text-gray-300">Valid chain.</p>

    <p class="text-gray-300">We say a block <span class="math">chain[i] = (h_{-1}, \\eta, \\mathsf{m}, h)</span> is valid with respect to (a predecessor block) <span class="math">chain[i - 1] = (h_{-1}&#x27;, n&#x27;, \\mathfrak{m}&#x27;, h&#x27;)</span> if two conditions hold: <span class="math">h_{-1} = h&#x27;</span>, <span class="math">h = \\mathsf{H}(h_{-1}, \\eta, \\mathsf{m})</span>, and <span class="math">h &amp;lt; D_p</span>. A chain of blocks <span class="math">chain</span> is valid if a) <span class="math">chain[0] = (0, 0, \\bot, \\mathsf{H}(0, 0, \\bot))</span> is the genesis block, and b) for all <span class="math">i \\in [\\ell]</span>, <span class="math">chain[i]</span> is valid with respect to <span class="math">chain[i - 1]</span>.</p>

    <p class="text-gray-300">Remark: on our use of the random oracle.</p>

    <p class="text-gray-300">Recall that in our model, we restrict players to a single evaluation query <span class="math">\\mathsf{H}</span> per round, but allow them any number of verification queries <span class="math">\\mathsf{H.ver}</span> in the same round. We do this to model the fact that checking the validity of mined blocks is "cheap" whereas the mining process is expensive. (To enable this, we have included a pointer <span class="math">h</span> to the current record in every mined block in the description of Nakamoto; thus a player need not spend an <span class="math">\\mathsf{H}</span> query to compute the pointer to the previous record.)</p>

    <p class="text-gray-300">In practice, the cost of evaluating a hash function (which is used to instantiate the random oracle) is the same as verifying its outputs, but our modeling attempts to capture the phenomena that a miner typically use various heuristics (such as black lists of IP addresses that have sent invalid blocks) and different hardware to check the validity of a mined block versus to mine a new block.</p>

    <h2 id="sec-21" class="text-2xl font-bold">2.5 Security of Blockchain Protocols</h2>

    <p class="text-gray-300">In this section, we recall the security properties of blockchains from [PSS17], which in turn are based on earlier definitions from [GKL15, KP15] For our purposes, we slightly generalize the properties</p>

    <p class="text-gray-300">4In reality (as well as in the description in the introduction), <span class="math">h</span> is not included in the block (as it can be easily determined from the remaining elements); we include it to ensure that we can verify validity of a block using only H.ver.</p>

    <p class="text-gray-300">from <em>[x13]</em> (see below for a discussion of this generalization), but point out that our generalized definitions suffice for all known applications of them; see <em>[x13]</em> for more discussion (and historical remarks) on these definitions.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">Negligible functions.</h4>

    <p class="text-gray-300">A function <span class="math">\\epsilon(\\cdot)</span> is said to be <em>negligible</em> if for every polynomial <span class="math">p(\\cdot)</span>, there exists some <span class="math">\\kappa_{0}</span> such that <span class="math">\\epsilon(\\kappa)\\leq\\frac{1}{p(\\kappa)}</span> for all <span class="math">\\kappa\\geq\\kappa_{0}</span>.</p>

    <p class="text-gray-300">We now define three useful properties, referred to as chain growth, chain quality, and consistency respectively. Note that all properties are defined over honest nodes’ outputs to the environment that are visible at the abstraction level (rather than over nodes’ internal states <span class="math">chain</span>).</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">2.5.1 Chain Growth</h4>

    <p class="text-gray-300">The first desideratum is that the chain grows proportionally with the number of time steps. Let,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{min\\text{-}chain\\text{-}increase}_{t,t^{\\prime}}(\\mathsf{view})</span> $=\\min_{i,j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}_{j}^{t+t^{\\prime}}(\\mathsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}_{i}^{t}(\\mathsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where we quantify over nodes <span class="math">i,j</span> such that <span class="math">i</span> is honest at round <span class="math">t</span> and <span class="math">j</span> is honest at round <span class="math">t+t^{\\prime}</span> in <span class="math">\\mathsf{view}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{growth}^{t_{0},t_{1}}(\\mathsf{view},\\Delta,T)=1</span> iff the following two properties hold:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (consistent length) for all time steps $t\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\Delta<span class="math">, </span>t+\\Delta\\leq t^{\\prime}\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, for every two players </span>i,j<span class="math"> such that in </span>\\mathsf{view}<span class="math"> </span>i<span class="math"> is honest at </span>t<span class="math"> and </span>j<span class="math"> is honest at </span>t^{\\prime}<span class="math">, we have that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}_{j}^{t^{\\prime}}(\\mathsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}_{i}^{t}(\\mathsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{min\\text{-}chain\\text{-}increase}_{t,t_{0}}(\\mathsf{view})\\geq T.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (chain growth upper bound) for every time step $t\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-t_{1}$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{max\\text{-}chain\\text{-}increase}_{t,t_{1}}(\\mathsf{view})\\leq T.</span></p>

    <p class="text-gray-300">In other words, <span class="math">\\mathsf{growth}^{t_{0},t_{1}}</span> is a predicate which tests that a) honest parties have chains of roughly the same length, and b) during any <span class="math">t_{0}</span> time steps in the execution, all honest parties’ chains increase by at least <span class="math">T</span>, and c) during any <span class="math">t_{1}</span> time steps in the execution, honest parties’ chains increase by at most <span class="math">T</span>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Definition 2.1 (Chain growth).</h6>

    <p class="text-gray-300">A blockchain protocol <span class="math">\\Pi</span> satisfies <span class="math">(T_{0},g_{0},g_{1})</span>-chain growth in <span class="math">\\Gamma</span>-environments, if for all <span class="math">\\Gamma</span>-compliant p.p.t. pair <span class="math">(A,Z)</span>, there exists some negligible function <span class="math">\\mathsf{negl}</span> such that for every <span class="math">\\kappa\\in\\mathbb{N}</span>, <span class="math">T\\geq T_{0}</span>, <span class="math">t_{0}\\geq\\frac{T}{g_{0}}</span> and <span class="math">t_{1}\\leq\\frac{T}{g_{1}}</span> the following holds:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow\\mathsf{EXEC}^{\\Pi}(A,Z,\\kappa):\\mathsf{growth}^{t_{0},t_{1}}(\\mathsf{view},\\Delta,\\kappa)=1\\right]\\geq 1-\\mathsf{negl}(\\kappa)</span></p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">2.5.2 Chain Quality</h4>

    <p class="text-gray-300">The second desideratum is that the number of blocks contributed by the adversary is not too large.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a <span class="math">\\mathsf{chain}</span>, we say that a block <span class="math">B:=\\mathsf{chain}[j]</span> is honest w.r.t. <span class="math">\\mathsf{view}</span> and prefix <span class="math">\\mathsf{chain}[:j^{\\prime}]</span> where <span class="math">j^{\\prime}&lt;j</span> if in <span class="math">\\mathsf{view}</span> there exists some node <span class="math">i</span> honest at some time $t\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, such that 1) </span>\\mathsf{chain}[:j^{\\prime}]\\prec\\mathsf{chain}_{i}^{t}(\\mathsf{view})<span class="math"> where </span>\\prec<span class="math"> denotes “is a prefix of” and 2) </span>Z<span class="math"> input </span>B<span class="math"> to node </span>i<span class="math"> at time </span>t<span class="math">. Informally, for an honest node’s chain denoted </span>\\mathsf{chain}<span class="math">, a block </span>B:=\\mathsf{chain}[j]$ is honest w.r.t. a prefix</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{chain}[:j^{\\prime}]</span> where <span class="math">j^{\\prime}&lt;j</span>, if earlier there is some honest node who received <span class="math">B</span> as input when its local chain contains the prefix <span class="math">\\mathsf{chain}[:j^{\\prime}]</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{quality}^{T}(\\mathsf{view},\\mu)=1</span> iff for every time <span class="math">t</span> and every player <span class="math">i</span> such that <span class="math">i</span> is honest at <span class="math">t</span> in <span class="math">\\mathsf{view}</span>, among any consecutive sequence of <span class="math">T</span> blocks <span class="math">\\mathsf{chain}[j+1..j+T]\\subseteq\\mathsf{chain}_{i}^{t}(\\mathsf{view})</span>, the fraction of blocks that are honest w.r.t. <span class="math">\\mathsf{view}</span> and <span class="math">\\mathsf{chain}[:j]</span> is at least <span class="math">\\mu</span>.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Definition 2.2 (Chain quality).</h6>

    <p class="text-gray-300">A blockchain protocol <span class="math">\\Pi</span> has <span class="math">(T_{0},\\mu)-</span>chain quality, in <span class="math">\\Gamma</span>-environments if for all <span class="math">\\Gamma</span>-compliant p.p.t. pair <span class="math">(A,Z)</span>, there exists some negligible function <span class="math">\\mathsf{negl}</span> such that for every <span class="math">\\kappa\\in\\mathbb{N}</span> and every <span class="math">T\\geq T_{0}</span> the following holds:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow\\mathsf{EXEC}^{\\Pi}(A,Z,\\kappa):\\mathsf{quality}^{T}(\\mathsf{view},\\mu)=1\\right]\\geq 1-\\mathsf{negl}(\\kappa)</span></p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">2.5.3 Consistency</h4>

    <p class="text-gray-300">Roughly speaking, consistency stipulates common prefix and future self-consistency. Common prefix requires that all honest nodes’ chains, except for roughly <span class="math">O(\\kappa)</span> number of trailing blocks that have not stabilized, must all agree. Future self-consistency requires that an honest node’s present chain, except for roughly <span class="math">O(\\kappa)</span> number of trailing blocks that have not stabilized, should persist into its own future. These properties can be unified in the following formal definition (which additionally requires that at any time, two honest nodes’ chains must be of similar length).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathsf{consistent}^{T}(\\mathsf{view})=1</span> iff for all times <span class="math">t\\leq t^{\\prime}</span>, and all players <span class="math">i,j</span> (potentially the same) such that <span class="math">i</span> is honest at <span class="math">t</span> and <span class="math">j</span> is honest at <span class="math">t^{\\prime}</span> in <span class="math">\\mathsf{view}</span>, we have that the prefixes of <span class="math">\\mathsf{chain}_{i}^{t}(\\mathsf{view})</span> and <span class="math">\\mathsf{chain}_{j}^{t^{\\prime}}(\\mathsf{view})</span> consisting of the first $\\ell=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}_{i}^{t}(\\mathsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-T<span class="math"> records are identical — this also implies that the following must be true: </span>\\mathsf{chain}_{j}^{t^{\\prime}}(\\mathsf{view})>\\ell<span class="math">, i.e., </span>\\mathsf{chain}_{j}^{t^{\\prime}}(\\mathsf{view})<span class="math"> cannot be too much shorter than </span>\\mathsf{chain}_{i}^{t}(\\mathsf{view})<span class="math"> given that </span>t^{\\prime}\\geq t$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-28" class="text-base font-medium mt-4">Definition 2.3 (Consistency).</h6>

    <p class="text-gray-300">A blockchain protocol <span class="math">\\Pi</span> satisfies <span class="math">T_{0}</span>-consistency, in <span class="math">\\Gamma</span>-environments if for all <span class="math">\\Gamma</span>-compliant p.p.t. pair <span class="math">(A,Z)</span>, there exists some negligible function <span class="math">\\mathsf{negl}</span> such that for every <span class="math">\\kappa\\in\\mathbb{N}</span> and every <span class="math">T\\geq T_{0}</span> the following holds:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow\\mathsf{EXEC}^{\\Pi}(A,Z,\\kappa):\\mathsf{consistent}^{T}(\\mathsf{view})=1\\right]\\geq 1-\\mathsf{negl}(\\kappa)</span></p>

    <p class="text-gray-300">Note that a direct consequence of consistency is that at any time, the chain <em>lengths</em> of any two honest players can differ by at most <span class="math">T</span> (except with negligible probability).</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">2.6 Preliminaries from <em>[x13]</em>: Security of Nakamoto’s Blockchain</h3>

    <p class="text-gray-300">The results from <em>[x13]</em> (and as we shall shortly see, also ours) are parametrized by the following quantities (which are defined for some fixed mining hardness function <span class="math">p(\\cdot)</span>; recall that Nakamoto’s protocol is parametrized a <em>single</em> hardness parameter <span class="math">p</span>):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>let <span class="math">\\alpha:=1-(1-p)^{(1-\\rho)n}</span>. That is, <span class="math">\\alpha</span> is the probability that <em>some</em> honest player succeeds in mining a block in a round;</li>

      <li>let <span class="math">\\beta:=\\rho np</span>. That is <span class="math">\\beta</span> is the expected number blocks that an attacker can mine in a round.</li>

      <li>let <span class="math">\\gamma:=\\frac{\\alpha}{1+\\Delta\\alpha}</span>. <span class="math">\\gamma</span> is a “discounted” version of <span class="math">\\alpha</span> which takes into account the fact that messages sent by honest parties can be delayed by <span class="math">\\Delta</span> rounds and this may lead to honest players “redoing work”; <span class="math">\\gamma</span> corresponds to their “effective” mining power.</li>

    </ul>

    <p class="text-gray-300">In essence, the quantities capture the per round expected “chain length increase” by the honest parties and the adversary; the reason that <span class="math">\\alpha,\\beta</span> are defined differently is that we assume that the</p>

    <p class="text-gray-300">adversary can sequentialize its queries in a round, whereas honest players make a single parallel query (they each act independently), and thus even if they manage to mine several blocks, the longest chain held by honest players can increase by at most <span class="math">1</span>. Note, however, that when <span class="math">p</span> is small (in comparison to <span class="math">1/n</span>), which is case for the Bitcoin protocol, <span class="math">\\alpha</span> is well approximated by <span class="math">(1-\\rho)np</span> and thus <span class="math">\\frac{\\alpha}{\\beta}\\approx\\frac{1-\\rho}{\\rho}</span>, so this difference is minor; additionally, when <span class="math">p</span> is small, <span class="math">\\gamma\\approx\\alpha</span> and thus <span class="math">\\frac{\\gamma}{\\beta}\\approx\\frac{1-\\rho}{\\rho}</span>.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">Compliant executions for Nakamoto’s blockchain.</h4>

    <p class="text-gray-300">We now specify the compliance predicate <span class="math">\\Gamma^{p}_{\\text{nak}}(\\cdot,\\cdot,\\cdot)</span> for the Nakamoto blockchain. We say that <span class="math">\\Gamma^{p}_{\\text{nak}}(\\cdot,\\cdot,\\cdot)=1</span> iff there is a constant <span class="math">\\lambda&gt;1</span> such that</p>

    <p class="text-gray-300"><span class="math">\\alpha(1-2(\\Delta+1)\\alpha)\\geq\\lambda\\beta</span></p>

    <p class="text-gray-300">where <span class="math">\\alpha</span> and <span class="math">\\beta</span> are functions of the parameters <span class="math">n,\\rho,\\Delta</span> and <span class="math">\\kappa</span> as defined above.</p>

    <p class="text-gray-300">As shown in Pass et al. <em>[x13]</em>, this condition also implies the following:</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Fact 2.4.</h6>

    <p class="text-gray-300">If <span class="math">(A,Z)</span> is <span class="math">\\Gamma^{p}_{\\text{nak}}</span>-compliant, then <span class="math">np\\Delta&lt;1</span>.</p>

    <p class="text-gray-300">We directly get the following corollary that will be useful to us.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Fact 2.5.</h6>

    <p class="text-gray-300">If <span class="math">(A,Z)</span> is <span class="math">\\Gamma^{p}_{\\text{nak}}</span>-compliant, then <span class="math">\\gamma\\geq\\frac{np}{8}</span> and</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Recall that <span class="math">\\gamma=\\frac{\\alpha}{1+\\Delta\\alpha}.</span> Since <span class="math">\\alpha\\leq np</span>, by Fact 2.4, we directly get that</p>

    <p class="text-gray-300"><span class="math">\\gamma\\geq\\frac{\\alpha}{2}\\beta</span></p>

    <p class="text-gray-300">Recall that, <span class="math">\\alpha=1-(1-p)^{(1-\\rho)n}.</span> Since by Fact 2.4, <span class="math">n&lt;1/p</span>, by the binomial expansion we have that</p>

    <p class="text-gray-300"><span class="math">(1-p)^{(1-\\rho)n}&lt;1-\\frac{(1-\\rho)np}{2}</span></p>

    <p class="text-gray-300">Thus, <span class="math">\\gamma&gt;\\frac{(1-\\rho)np}{4}\\geq\\frac{np}{8}</span> since under our restrictions, we have that <span class="math">\\rho&lt;\\frac{1}{2}</span>. ∎</p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">Formal guarantees of Nakamoto’s blockchain.</h4>

    <p class="text-gray-300">The following theorem was proven in <em>[x13]</em>.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Theorem 2.6 (Security of Nakamoto <em>[x13]</em>).</h6>

    <p class="text-gray-300">For any constant <span class="math">\\delta&gt;0</span>, any <span class="math">0&lt;p&lt;1</span>, any super-logarithmic function <span class="math">T_{0}=\\omega(\\log\\kappa)</span> Nakamoto’s blockchain protocol <span class="math">\\Pi_{\\text{nak}}(p)</span> satisfies the following properties in <span class="math">\\Gamma^{p}_{\\text{nak}}</span>-environments:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">T_{0}</span>-consistency;</li>

      <li>chain growth rate <span class="math">(T_{0},g_{0},g_{1})</span> where</li>

    </ul>

    <p class="text-gray-300"><span class="math">g_{0}=(1-\\delta)\\gamma</span> <span class="math">g_{1}=(1+\\delta)np</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>chain quality <span class="math">(T_{0},\\mu)</span> where</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mu=1-(1+\\delta)\\frac{\\beta}{\\gamma}</span></p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Remark 2.7 (Blockchain quality and consistency).</h6>

    <p class="text-gray-300">The consistency property proven in <em>[x13]</em> is actually a bit stronger than stated. Not only it shows that players agree on the <em>records</em> contained in their blockchains, but also that the actual <em>blockchains</em> agree except for potentially the last <span class="math">\\kappa</span> blocks. We refer to this property as <em>blockchain consistency</em>, and will rely on it in the sequel.</p>

    <p class="text-gray-300">Additionally, the chain quality property is also stronger in that not only the records of honest blocks are contributed by honest players, but also the actual blocks are mined by honest players. We refer to this property as <em>blockchain quality</em>, and will rely on it in the sequel.</p>

    <p class="text-gray-300">12</p>

    <h2 id="sec-37" class="text-2xl font-bold">2.6.1 Liveness</h2>

    <p class="text-gray-300">The liveness property from [PSS17] (which generalized the one from [GKL15]), stipulates that from any given round <span class="math">r</span>, if a sufficiently long period of time <span class="math">t</span> elapses—we refer to this time as the wait-time of the blockchain—every honest player will have a record <span class="math">\\mathfrak{m}</span> sufficiently “deep” in their chain (technically, <span class="math">\\kappa</span> blocks from the end of the chain), where <span class="math">\\mathfrak{m}</span> was provided as an input to some honest player between rounds <span class="math">r</span> and <span class="math">r + t^5</span>. More precisely, let <span class="math">\\text{live}(\\text{view}, t) = 1</span> iff for any <span class="math">t</span> consecutive rounds <span class="math">r, \\ldots, r + t</span> in view there exists some round <span class="math">r&#x27;</span> s.t. <span class="math">r \\leq r&#x27; \\leq r + t</span> and player <span class="math">i</span> such that in view, 1) <span class="math">i</span> is honest at <span class="math">r&#x27;</span>, 2) <span class="math">i</span> received a record <span class="math">\\mathfrak{m}</span> as input at round <span class="math">r&#x27;</span>, and 3) for every player <span class="math">j</span> that is honest at <span class="math">r + t</span> in view, <span class="math">\\mathfrak{m} \\in \\text{chain}_j^{r + t}(\\text{view})[: -\\kappa]</span>.</p>

    <p class="text-gray-300"><strong>Definition 2.8.</strong> We say that blockchain <span class="math">(\\Pi, \\text{chain})</span> satisfies liveness with wait-time <span class="math">w</span> in <span class="math">\\Gamma</span>-environments if for all <span class="math">\\Gamma</span>-compliant p.p.t. pair <span class="math">(A, Z)</span>, there exists a negligible function <span class="math">\\epsilon</span> in the security parameter <span class="math">\\kappa \\in \\mathbb{N}</span>, such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\text{view} \\leftarrow \\text{EXEC}^{\\Pi}(A, Z, \\kappa): \\text{live}(\\text{view}, w) = 1 \\right] \\geq 1 - \\epsilon(\\kappa)</span></div>

    <p class="text-gray-300">The following theorem was shown in the prior work [PSS17].</p>

    <p class="text-gray-300"><strong>Theorem 2.9</strong> ([PSS17]). For any boolean predicate <span class="math">\\Gamma(\\cdot, \\cdot, \\cdot)</span>, let <span class="math">\\Pi</span> be a blockchain protocol satisfying chain growth <span class="math">(T_0, g_0, g_1)</span>, chain quality <span class="math">(T_0, \\mu)</span> and <span class="math">T_0</span>-chain consistency in <span class="math">\\Gamma</span>-environments where <span class="math">\\mu</span> and <span class="math">g_0</span> are strictly positive, and <span class="math">T_0</span> is sublinear.<span class="math">^6</span> Then, <span class="math">\\Pi</span> satisfies liveness with wait-time</p>

    <div class="my-4 text-center"><span class="math-block">w = (1 + \\delta) \\frac{\\kappa}{g_0}</span></div>

    <p class="text-gray-300">against in <span class="math">\\Gamma</span>-environments</p>

    <p class="text-gray-300">As a direct corollary of 2.9 and 2.6, we get:</p>

    <p class="text-gray-300"><strong>Corollary 2.10</strong> ([PSS17]). For any constant <span class="math">\\delta &amp;gt; 0</span>, and any <span class="math">0 &amp;lt; p &amp;lt; 1</span>, <span class="math">\\Pi_{\\mathrm{nak}}(p)</span> satisfies liveness with wait-time</p>

    <div class="my-4 text-center"><span class="math-block">w = (1 + \\delta) \\frac{\\kappa}{\\gamma}</span></div>

    <p class="text-gray-300">in <span class="math">\\Gamma_{\\mathrm{nak}}^p</span>-environments.</p>

    <h2 id="sec-38" class="text-2xl font-bold">3 Defining Fairness</h2>

    <p class="text-gray-300">We turn to defining our notion of fairness. Roughly speaking, a blockchain protocol is <span class="math">\\delta</span>-approximately fair w.r.t. <span class="math">\\rho</span> attackers if, with overwhelming probability, any honest subset controlling <span class="math">\\phi</span> fraction of the compute power is guaranteed to get at least a</p>

    <div class="my-4 text-center"><span class="math-block">(1 - \\delta) \\phi</span></div>

    <p class="text-gray-300">fraction of the blocks in every sufficiently long window, even in the presence of an adversary controlling a <span class="math">\\rho</span> fraction of the computation power. Note that this condition trivially implies <span class="math">(1 - \\delta)(1 - \\rho)</span> chain quality (by considering <span class="math">\\phi = 1 - \\rho</span>, that is, the full set of honest players). Consequently, to formally define this notion, we first generalize the definition of quality (used in the definition of chain quality, see Definition 2.2) to consider “quality” w.r.t. to any subset <span class="math">S</span> of the honest players.</p>

    <p class="text-gray-300"><span class="math">^5</span>The weaker liveness property from [GKL15] only requires this is all honest players have <span class="math">\\mathfrak{m}</span> as their input; this weaker property is not enough for our purposes.</p>

    <p class="text-gray-300"><span class="math">^6</span> [PSS17] only explicitly considered the case when <span class="math">T_0</span> is some slightly super-logarithmic function, but their proof actually only assumes that <span class="math">T_0</span> is sublinear. We also remark that any blockchain protocol which satisfies the security properties w.r.t. to a polynomial <span class="math">T_0</span> which potentially is super-linear can always be modified to satisfy security w.r.t. a sublinear <span class="math">T_0</span> by redefining the security parameter.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">Warmup: fairness definition for static corruption.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As a warmup, let us consider how to define (approximate) fairness in a static corruption model where the adversary must declare corrupt nodes upfront — once we show how to do this, we then discuss how to extend the definition to an adaptive corruption model. Under a static corruption model, we say that a blockchain protocol satisfies <span class="math">(T,\\delta)</span>-approximate fairness, iff the following holds except with negligible probability over the protocol’s execution: for any honest node’s chain during the protocol execution, for any constant <span class="math">\\phi&gt;0</span>, for any subset <span class="math">S</span> of honest users such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\phi\\cdot n<span class="math"> where </span>n<span class="math"> denotes the total number of users, for any </span>T<span class="math"> consecutive blocks </span>\\mathsf{chain}[j+1..j+T]<span class="math"> in </span>\\mathsf{chain}<span class="math">, it holds that the fraction of blocks in </span>\\mathsf{chain}[j+1..j+T]<span class="math"> contributed by nodes in </span>S<span class="math"> is at least </span>(1-\\delta)\\phi$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">Fairness definition for adaptive corruption.</h4>

    <p class="text-gray-300">In general, the corruptions can be declared in an adaptive fashion, therefore nodes in any subset <span class="math">S</span> may become corrupt during the course of the window we care about. To define (approximate) fairness with adaptive corruptions, we need to allow the subset <span class="math">S</span> to change over time. We formalize the definition below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let a <em>player subset selection</em>, <span class="math">S(\\mathsf{view},r)</span>, be a function that given <span class="math">(\\mathsf{view},r)</span> outputs a subset of the players that are honest at round <span class="math">r</span> in <span class="math">\\mathsf{view}</span>.</li>

      <li>We say that <span class="math">S</span> is a <em><span class="math">\\phi</span>-fraction player subset selection</em> if <span class="math">S(\\mathsf{view},r)</span> always outputs a set of size <span class="math">\\phi n</span> (rounded upwards) where <span class="math">n</span> is the number of players in <span class="math">\\mathsf{view}</span>.</li>

      <li>Given a player subset selection <span class="math">S</span>, we say that a <em>record <span class="math">\\mathsf{m}</span> is <span class="math">S</span>-compatible w.r.t. <span class="math">\\mathsf{view}</span> and prefix</em> chain if there exists a player <span class="math">j</span> and round <span class="math">r^{\\prime}</span> such that <span class="math">j</span> is in <span class="math">S(\\mathsf{view},r^{\\prime})</span>, the environment provided <span class="math">\\mathsf{m}</span> as an input to <span class="math">j</span> at round <span class="math">r^{\\prime}</span>, and <span class="math">\\mathsf{chain}\\prec\\mathsf{chain}_{i}^{r^{\\prime}}(\\mathsf{view})</span> where <span class="math">\\prec</span> denotes “is a prefix of”;</li>

      <li>Let <span class="math">\\mathsf{quality}^{T,S}(\\mathsf{view},\\mu)=1</span> iff for every round <span class="math">r</span> and every player <span class="math">i</span> such that <span class="math">i</span> is honest in round <span class="math">r</span> of <span class="math">\\mathsf{view}</span>, we have that among any consecutive sequence of <span class="math">T</span> records <span class="math">\\mathsf{chain}_{i}^{r}(\\mathsf{view})[j+1:j+T]</span>, the fraction of records that are <span class="math">S</span>-compatible w.r.t. <span class="math">\\mathsf{view}</span> and prefix <span class="math">\\mathsf{chain}_{i}^{r}(\\mathsf{view})[:j]</span> is at least <span class="math">\\mu</span>.</li>

    </ul>

    <p class="text-gray-300">We now define fairness analogously to chain quality.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Definition 3.1.</h6>

    <p class="text-gray-300">A blockchain protocol <span class="math">\\Pi</span> has (approximate) <em>fairness</em> <span class="math">(T_{0},\\delta)</span> in <span class="math">\\Gamma</span>-environments, if for all <span class="math">\\Gamma</span>-compliant p.p.t. <span class="math">(A,Z)</span>, every positive constant <span class="math">\\phi\\leq 1-\\rho</span>, every <span class="math">\\phi</span>-fraction subset selection <span class="math">S</span>, there exists some negligible function <span class="math">\\epsilon</span> such that for every <span class="math">\\kappa\\in\\mathbb{N}</span> and every <span class="math">T\\geq T_{0}</span> the following holds:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow\\mathsf{EXEC}^{\\Pi}(A,Z,\\kappa):\\mathsf{quality}^{T,S}(\\mathsf{view},(1-\\delta)\\phi)\\right)=1\\right]\\geq 1-\\epsilon(\\kappa)</span></p>

    <p class="text-gray-300">As a sanity check, note that the definition of <span class="math">\\mathsf{quality}^{T,S}(\\mathsf{view},\\mu)</span> collapses down to <span class="math">\\mathsf{quality}^{T}(\\mathsf{view},\\mu)</span> if <span class="math">S</span> is the full set of the honest players. As a consequence, <span class="math">(T_{0},\\delta)</span>-fairness trivially implies <span class="math">(T_{0},(1-\\delta)(1-\\rho))</span>-chain quality (by considering <span class="math">\\phi=1-\\rho</span>). Additionally, when <span class="math">\\rho\\leq\\frac{1}{2}</span> which is the case we consider in this paper,</p>

    <p class="text-gray-300"><span class="math">(1-\\delta)(1-\\rho)=1-\\delta-\\rho+\\delta\\rho=1-[\\delta+(1-\\delta)\\rho]\\geq 1-[2\\delta\\rho+(1-\\delta)\\rho]=1-(1+\\delta)\\rho</span></p>

    <p class="text-gray-300">Thus, no <span class="math">\\rho</span>-size coalition can get more than a factor <span class="math">(1+\\delta)</span> more than its “fair” share of blocks.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Fact 3.2.</h6>

    <p class="text-gray-300">If a blockchain protocol <span class="math">\\Pi</span> satisfies <span class="math">(T_{0},\\delta)</span>-fairness in <span class="math">\\Gamma</span>-environments, then it satisfies <span class="math">(T_{0},\\mu)</span>-chain quality where <span class="math">\\mu=(1-\\delta)(1-\\rho)\\geq 1-(1+\\delta)\\rho</span> in <span class="math">\\Gamma</span>-environments.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">4 The FruitChain Protocol</p>

    <p class="text-gray-300">We now turn to formally defining our FruitChain protocol. Roughly speaking, the FruitChain protocol will be running an instance of <span class="math">\\Pi_{\\text{nak}}(p)</span> but instead of directly putting the records m inside the blockchain, the records are put inside “fruits” denoted <span class="math">f</span>; these fruits themselves requires solving some proof of work—with a different hardness parameter <span class="math">p_{f}</span>; additionally, we require a fruit to “hang” from a block which isn’t too far from from the block which records the fruit—more specifically, the fruit needs to “point” to an earlier block in the chain which is not too far from the block containing it (and thus, the fruit could not have been mined “too” long ago); the recency parameter <span class="math">R</span> will be used to specify how far back a fruit is allowed to hang.</p>

    <h3 id="sec-43" class="text-xl font-semibold mt-8">4.1 Valid Blocks, Fruits, and Blockchain</h3>

    <p class="text-gray-300">Towards formalizing the protocol, we start by introducing some notation:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We assume that the random oracle <span class="math">H</span> outputs strings of length at least <span class="math">2\\kappa</span>. Let d be a collision-resistant hash-function (technically, it is a family of functions, and the instance from the family is selected as a public-parameter; in the sequel we ignore this selection and simply treat it as a single function (for instance, selected using randomness <span class="math">H(0)</span>.)</li>

      <li>Our protocol is parametrized by two “hardness” parameters <span class="math">p=p,p_{f}=p_{f}</span>, and a recency parameter <span class="math">R</span>. (<span class="math">p</span> is the mining hardness parameter for the underlying Nakamoto blockchain, and <span class="math">p_{f}</span> is the “fruit mining” hardness parameter, as mentioned above, the recency parameter will specify how far back a fruit is allowed to “hang”); the quantity <span class="math">q=\\frac{p_{f}}{p}</span> will be useful in our analysis.</li>

    </ul>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">Valid fruits.</h4>

    <p class="text-gray-300">A fruit is of the format <span class="math">f=(h_{-1};h^{\\prime};\\eta,\\textsf{digest};\\textsf{m};h)</span> where each entry means the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">h_{-1}</span> points to the previous block’s reference — this entry is an artifact of the fruit mining and block mining piggybacked on top of each other; a fruit actually does not care about this entry (but a block does). However the value still needs to be included for the fruit to be verified;</li>

      <li><span class="math">h^{\\prime}</span> points to a (recently stablized) block that the fruit is hanging from — we call <span class="math">h^{\\prime}</span> the pointer of the fruit <span class="math">f</span>;</li>

      <li><span class="math">\\eta</span> is a random nonce denoting the puzzle solution;</li>

      <li>digest is the digest of some fruit-set <span class="math">F</span> — this is an artifact since the fruit mining and block mining are piggybacked on top of each other. The block must contain a set of fruits denoted <span class="math">F</span>, but the fruit does not care about the fruit-set, and therefore we include only its d that is necessary for checking that the fruit is correct;</li>

      <li>m is the record to be contained in the fruit; and</li>

      <li><span class="math">h</span> is the hash or reference of the fruit.</li>

    </ul>

    <p class="text-gray-300">We say that a fruit denoted <span class="math">f=(h_{-1};h^{\\prime};\\eta,\\textsf{digest};\\textsf{m};h)</span> is valid iff</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">H(h_{-1};h^{\\prime};\\eta;\\textsf{digest};\\textsf{m})=h</span>;</li>

      <li><span class="math">[h]_{-\\kappa:}&lt;D_{p_{f}}</span> where <span class="math">[h]_{-\\kappa:}</span> denotes the last <span class="math">\\kappa</span> bits of <span class="math">h</span>.</li>

    </ol>

    <p class="text-gray-300">We say that <span class="math">F</span> is a valid fruit-set if either <span class="math">F=\\emptyset</span> or <span class="math">F</span> is a set of valid fruits.</p>

    <p class="text-gray-300">###</p>

    <h4 id="sec-45" class="text-lg font-semibold mt-6">Valid blocks.</h4>

    <p class="text-gray-300">Since the block mining and the fruit mining are piggybacked on top of each other, a block looks very much like a fruit, except that a block must additionally include the actual fruit-set <span class="math">F</span>. More specifically, a block is of the following format <span class="math">\\mathsf{b}=((h_{-1};h^{\\prime};\\eta;\\mathsf{digest};\\mathsf{m};h),F)</span> where each entry means the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">h_{-1}</span> points to the previous block’s reference, this represents the chain that the block extends from;</li>

      <li><span class="math">h^{\\prime}</span> is an artifact of the fruit mining and block mining piggybacked atop each other; a block actually does not care about this field (but a fruit does), but it still needs to be included for block verification;</li>

      <li><span class="math">\\eta</span> is a random nonce denoting the puzzle solution;</li>

      <li>digest is the digest of some fruit-set <span class="math">F</span> to be included in the block later;</li>

      <li><span class="math">\\mathsf{m}</span> is a record — the block also does not care about this field, and this is an artifact of the two piggybacked mining processes;</li>

      <li><span class="math">h</span> is called the reference of the block, which is a hash of the previous fields; and</li>

      <li><span class="math">F</span> is a fruit-set to be included in the block.</li>

    </ul>

    <p class="text-gray-300">We say that a block denoted <span class="math">\\mathsf{b}=((h_{-1};h^{\\prime};\\eta;\\mathsf{digest};\\mathsf{m};h),F)</span>, is valid iff</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{digest}=\\mathsf{d}(F)</span> where <span class="math">\\mathsf{d}</span> is a collision-resistant hash function as mentioned earlier;</li>

      <li><span class="math">F</span> is a valid fruit-set;</li>

      <li><span class="math">H(h_{-1};h^{\\prime};\\eta,\\mathsf{d}(F);\\mathsf{m})=h;</span></li>

      <li><span class="math">[h]_{:\\kappa}&lt;D_{p_{1}}</span> where <span class="math">[h]_{:\\kappa}</span> denotes the first <span class="math">\\kappa</span> bits of <span class="math">h</span>.</li>

    </ol>

    <h4 id="sec-46" class="text-lg font-semibold mt-6">Valid blockchain.</h4>

    <p class="text-gray-300">We say that a <span class="math">chain</span> is valid iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">chain[0]=genesis</span> where <span class="math">genesis:=((0;0;0;0;\\bot;\\mathsf{H}(0;0;0;0,\\bot)),\\emptyset)</span> is the “genesis” block;</li>

      <li>for all <span class="math">i\\in[\\ell]</span>, <span class="math">chain[i].h_{-1}=chain[i-1].h</span>, i.e., each block refers to the previous block’s reference;</li>

      <li>for all <span class="math">i\\in[\\ell]</span>, all <span class="math">f\\in chain[i].F</span>, there exists some <span class="math">j\\geq i-R\\kappa</span> such that the pointer of <span class="math">f</span> is <span class="math">chain[j].h</span>.</li>

    </ul>

    <h4 id="sec-47" class="text-lg font-semibold mt-6">Recency of fruits.</h4>

    <p class="text-gray-300">Finally, we say that the fruit <span class="math">f</span> is recent w.r.t. <span class="math">chain</span> if the pointer of <span class="math">f</span> is the reference of a block in <span class="math">chain[-R\\kappa:]</span> (i.e., one of the last <span class="math">R\\kappa</span> blocks in <span class="math">chain</span>).</p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">4.2 The FruitChain Protocol and our Main Theorem</h3>

    <p class="text-gray-300">The FruitChain protocol denoted <span class="math">\\Pi_{\\text{fruit}}</span> is described in Figure 1. Henceforth, we say that</p>

    <p class="text-gray-300"><span class="math">\\Gamma_{\\text{fruit}}^{p,p_{f},R}(n,\\rho,\\Delta)=1\\text{ iff }\\Gamma_{\\text{nak}}^{p}(n,\\rho,\\Delta)=1</span></p>

    <p class="text-gray-300">Moreover, we assume the following quantities are constants throughout this paper:</p>

    <p class="text-gray-300"><span class="math">q:=\\frac{p_{f}}{p}=\\Theta(1),\\qquad R=\\Theta(1)</span></p>

    <p class="text-gray-300">We are now ready to state our main theorem.</p>

    <p class="text-gray-300">|  Πfruit(p, pf, R): FruitChain protocol  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  Initialize: chain := genesis, F = ∅  |</p>

    <p class="text-gray-300">|  Upon receiving a valid fruit, · let F := F ∪ {fruit}  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Upon receiving a valid chain', if</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">chain'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">chain</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">: · let chain := chain'</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  extractfruit(chain):  |</p>

    <p class="text-gray-300">|  On input a valid chain, · first extract a sequence of distinct fruits from chain, where if the same fruit is included multiple times, only the first occurrence is included. The extracted fruits are ordered by the first block that contains the fruit; and for fruits in the same block, follow the order in which the fruits are serialized within the block. · then, output the sequence of records m contained in the extracted sequence of fruits, where records contained in earlier fruits are extracted earlier.  |</p>

    <p class="text-gray-300">Figure 1: The FruitChain protocol. Nodes not only mine for blocks, but also fruits. Blocks confirm "recent" fruits; whereas fruits confirm transactions.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Theorem 4.1 (Security of FruitChain).</h6>

    <p class="text-gray-300">For any constant <span class="math">0&lt;\\delta&lt;1</span>, and any <span class="math">p,p_{f}</span>, let <span class="math">R=17</span>, <span class="math">\\kappa_{f}=2qR\\kappa</span>, and <span class="math">T_{0}=5\\frac{\\kappa_{f}}{\\delta}</span>. Then the FruitChain protocol denoted <span class="math">\\Pi_{\\mathrm{fruit}}(p,p_{f},R)</span> satisfies</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\kappa_{f}</span>-consistency;</li>

      <li>chain growth rate <span class="math">(T_{0},g_{0},g_{1})</span> where</li>

    </ul>

    <p class="text-gray-300"><span class="math">g_{0}=(1-\\delta)(1-\\rho)np_{f},</span> <span class="math">g_{1}=(1+\\delta)np_{f}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>fairness <span class="math">(T_{0},\\delta)</span>.</li>

    </ul>

    <p class="text-gray-300">in <span class="math">\\Gamma_{\\mathrm{fruit}}^{p,p_{f},R}</span>-environments.</p>

    <h2 id="sec-50" class="text-2xl font-bold">5 Proof of the Main Theorem</h2>

    <p class="text-gray-300">We start by introducing some additional notation and useful lemmas, and then turn to proving each of the three security properties.</p>

    <h3 id="sec-51" class="text-xl font-semibold mt-8">5.1 Additional Notations</h3>

    <p class="text-gray-300">Let us introduce some additional notation that will be useful in the analysis of the protocol:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We say that a fruit <span class="math">f=(h_{-1};h^{\\prime};\\eta,\\mathsf{digest};\\mathsf{m};h)</span> was <em>mined</em> at round <span class="math">r</span> if <span class="math">r</span> is the first time <span class="math">H</span> outputs <span class="math">h</span>.</li>

      <li>We say that a block, <span class="math">\\mathsf{b}=((h_{-1};h^{\\prime};\\eta;\\mathsf{digest};\\mathsf{m};h),F)</span> was <em>mined</em> at round <span class="math">r</span> if <span class="math">r</span> is the first time <span class="math">H</span> outputs <span class="math">h</span>.</li>

      <li>We say that a block/fruit was mined by an honest player if there it was an honest players that first mined it.</li>

    </ul>

    <p class="text-gray-300">To simplify notation, in addition to the parameters <span class="math">\\alpha,\\beta,\\gamma</span> previously defined, we also define analogs of <span class="math">\\alpha</span> and <span class="math">\\beta</span> with respect to the “fruit mining” process:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>let <span class="math">\\alpha_{f}=(1-\\rho)np_{f}</span> (that is, the expected number of fruits mined by honest players in one round);</li>

      <li>let <span class="math">\\beta_{f}=\\rho np_{f}</span> (that is, the expected number of fruits mined by corrupt players in one round).</li>

    </ul>

    <h3 id="sec-52" class="text-xl font-semibold mt-8">5.2 The Fruit Freshness Lemma</h3>

    <p class="text-gray-300">In this section, we present a lemma demonstrating the key property of the FruitChain protocol: any fruit mined by an honest player will be incorporated sufficiently deep in the chain (and thus never lost). We refer to this as the <em>Fruit Freshness Lemma</em>—fruits stay “fresh” (i.e., recent) sufficiently long to be incorporated.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathsf{fruitfreshness}(\\mathsf{view},w,\\kappa)=1</span> iff for every honest player <span class="math">i</span> and every round $r<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-w<span class="math">, if </span>i<span class="math"> mines a fruit at round </span>r<span class="math"> in </span>\\mathsf{view}<span class="math">, then for every honest player </span>j<span class="math">, there exists some index </span>pos<span class="math"> such that </span>f<span class="math"> is at position </span>pos<span class="math"> in the record chain (w.r.t. Nakamoto’s protocol) of </span>j<span class="math"> at every round </span>r^{\\prime}\\geq r+w<span class="math"> (i.e., </span>f\\in chain_{j}^{r^{\\prime}}(\\mathsf{view})[pos]<span class="math">) and additionally </span>pos<span class="math"> is at least </span>\\kappa$ positions from the end of the chain.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let</p>

    <p class="text-gray-300"><span class="math">wait=2\\Delta+\\frac{2\\kappa}{\\gamma}</span></p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Lemma 5.1.</h6>

    <p class="text-gray-300">Let <span class="math">R=17</span>. For any <span class="math">p</span>, <span class="math">p_{f}</span>, for any <span class="math">\\Gamma^{p,p_{f},R}_{\\text{fruit}}</span>-compliant <span class="math">(A,Z)</span>, there exists a negligible function <span class="math">\\epsilon</span> such that for any <span class="math">\\kappa\\in\\mathbb{N}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\textsf{view}\\leftarrow\\textsf{EXEC}^{\\Pi_{\\text{fruit}}(p,p_{f},R)}(A,Z,\\kappa):\\textsf{fruitfreshness}(\\textsf{view},wait,\\kappa)=1\\right]\\geq 1-\\epsilon(\\kappa)</span></p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Disregard the blockchain consistency (see Remark 2.7), liveness and chain growth failure events—they only happen with negligible probability. Let <span class="math">wait=wait(\\kappa,n,\\rho,\\Delta)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By <em>blockchain consistency</em>, at any point in the execution, whenever an honest player mines a fruit <span class="math">f</span>, the block pointed to by the fruit is at some <em>fixed</em> position <span class="math">pos</span> on the blockchain of every honest player, now and at every time in the future. (Recall that honest players try to mine fruit that point back to a block that is <span class="math">\\kappa</span> steps back in the chain, and thus the consistency condition kicks in.) Let <span class="math">\\ell</span> denote the length of the chain of the player that mines <span class="math">f</span>; by definition <span class="math">pos=\\ell-\\kappa</span>.</li>

      <li>By the description of the protocol, if the fruit <span class="math">f</span> is mined at a round <span class="math">r^{\\prime}</span>, it gets seen by all honest players by round <span class="math">r^{\\prime}+\\Delta</span>; additionally, when this happens all honest players attempt to add <span class="math">f</span> to their chain as long as it remains recent (w.r.t. all honest players).</li>

      <li>By <em>liveness</em>, it thus follows that <span class="math">f</span> gets incorporated into the record chain of all honest players at some position <span class="math">pos</span> that is at least <span class="math">\\kappa</span> records from the end of their chain by round</li>

    </ul>

    <p class="text-gray-300"><span class="math">r^{\\prime}+\\Delta+(1+\\delta)\\frac{\\kappa}{\\gamma}\\leq r^{\\prime}+wait-\\Delta</span></p>

    <p class="text-gray-300">as long as <span class="math">f</span> is recent by then (w.r.t. all honest players).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By the upperbound on chain growth, at most</li>

    </ul>

    <p class="text-gray-300"><span class="math">(1+\\delta)np\\left(\\Delta+\\frac{2\\kappa}{\\gamma}\\right)</span></p>

    <p class="text-gray-300">blocks are “added” in time <span class="math">wait-\\Delta</span>; more precisely, by round <span class="math">r^{\\prime}+wait-\\Delta</span>, no honest player has ever had a chain of length <span class="math">\\ell^{\\prime}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\ell^{\\prime}&gt;\\ell+(1+\\delta)np\\left(\\Delta+\\frac{2\\kappa}{\\gamma}\\right)</span></p>

    <p class="text-gray-300">Thus, by round <span class="math">r^{\\prime}+wait-\\Delta</span>, for every such honest player’s chain length <span class="math">\\ell^{\\prime}</span> we have</p>

    <p class="text-gray-300"><span class="math">pos=\\ell-\\kappa\\geq\\ell^{\\prime}-\\kappa-(1+\\delta)np\\left(\\Delta+\\frac{2\\kappa}{\\gamma}\\right)</span></p>

    <p class="text-gray-300">By our compliance assumption and by Fact 2.4 and Fact 2.5, we have that <span class="math">\\gamma\\geq\\frac{np}{8}</span> and <span class="math">np\\Delta&lt;1</span>, thus</p>

    <p class="text-gray-300"><span class="math">pos\\geq\\ell^{\\prime}-\\kappa-(1+\\delta)-(1+\\delta)16\\kappa\\leq 17\\kappa=\\ell^{\\prime}-R\\kappa</span></p>

    <p class="text-gray-300">which means that <span class="math">f</span> remains recent until round <span class="math">r^{\\prime}+wait-\\Delta</span> w.r.t. all honest players.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally, by <em>consistency</em>, all honest players agree that <span class="math">f</span> is found at position <span class="math">pos</span> in their blockchain at any point after <span class="math">r^{\\prime}+wait-\\Delta</span>; additionally, by the <em>consistent length property</em> all honest players agree that position <span class="math">pos</span> is at least <span class="math">\\kappa</span> from the end of the chain by <span class="math">r^{\\prime}+wait-\\Delta+\\Delta=r^{\\prime}+wait</span>.</li>

    </ul>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">We also observe the following fact about <span class="math">wait</span>, which says that the expected number of fruits mined by all players during <span class="math">wait+2</span> steps is upper bounded by <span class="math">k_{f}</span>.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Fact 5.2.</h6>

    <p class="text-gray-300">For any <span class="math">p,p_{f}</span>, any <span class="math">\\Gamma^{p,p_{f},R}_{\\text{fruit}}</span>-compliant <span class="math">(A,Z)</span>,</p>

    <p class="text-gray-300"><span class="math">(wait+2)\\cdot np_{f}\\leq\\kappa_{f}</span></p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Note that by Fact 2.4 and Fact 2.5, we have that <span class="math">\\gamma\\geq\\frac{np}{8}</span> and <span class="math">np\\Delta&lt;1</span>, thus</p>

    <p class="text-gray-300"><span class="math">(wait+2)\\cdot np_{f}=(2\\Delta+2\\frac{\\kappa}{\\gamma}+2)\\cdot qpn\\leq 2q+2\\kappa\\cdot 8q+2\\leq 2qR\\kappa=\\kappa_{f}</span></p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-57" class="text-xl font-semibold mt-8">5.3 Some Simplifying Assumptions</h3>

    <p class="text-gray-300">Towards proving our main theorem we state some simplifying assumptions that can be made without loss of generality. These assumptions (which all follow from properties of the random oracle H) will prove helpful in our subsequent analysis.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>WLOG1: We may without loss of generality assume that honest players never query the RO on the same input—more precisely, we analyze an experiment where if some honest player wants to query it on an “old” input, it resamples nonce until the input is “new”; since nonce is selected from <span class="math">\\{0,1\\}^{\\kappa}</span>, this “resampling” experiment is identical to the real one with except with negligible probability, thus we can WLOG analyze it.</li>

      <li>WLOG2: We may without loss of generality assume that any fruit that points to a block b which was first mined at time <span class="math">t</span>, has been mined after <span class="math">t</span>. Additionally, any fruit that points to a block that comes after b in a valid chain must have been mined after <span class="math">t</span>. (If not, we can predict the outcome of the random oracle <span class="math">H</span> on some input before having queries H which is a contradiction. We omit the standard details.)</li>

      <li>WLOG3: We may assume without loss of generality that all fruit mined by honest players are “new” (i.e., different from all valid fruit previously seen by honest players); this follows by WLOG1 and the fact that the probability of seeing a collision in the random oracle is negligible (by a simple union bound over the number of random oracle queries).</li>

      <li>WLOG4: We may assume without loss of generality that any valid fruit which appears in some honest players chain at round <span class="math">r</span> was mined before <span class="math">r</span>; this follows from the unpredictability of the random oracle (and a simple union bound over the number of random oracle queries).</li>

      <li>WLOG5: We may assume without loss of generality that there are no “blockchain collisions”—namely, there are no two different valid sequences of blocks which end with the same block.</li>

    </ul>

    <p class="text-gray-300">We now turn to proving the three security properties.</p>

    <h3 id="sec-58" class="text-xl font-semibold mt-8">5.4 Proof of Fruit Consistency</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Disregard the chain growth and consistency, and blockchain quality (see Remark 2.7) failure events—they happen with negligible probability. Consider some view view in the support of <span class="math">\\textsf{EXEC}^{\\Pi_{\\text{fruit}}(p,p_{f},R)}(A,Z,\\kappa)</span>, rounds <span class="math">r,r^{\\prime}</span> s.t. <span class="math">r^{\\prime}\\geq r</span>, and players <span class="math">i,j</span> that are honest respectively at <span class="math">r,r^{\\prime}</span> in view. By consistency, the chains of <span class="math">i,j</span> at <span class="math">r,r^{\\prime}</span> agree except for potentially the last <span class="math">\\kappa</span> blocks in the chain of <span class="math">i</span>—let $C=\\mathsf{b}_{0},\\ldots,\\mathsf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> denote those initial blocks on which they agree, and let </span>\\mathsf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1},\\ldots<span class="math"> denote the (max </span>\\kappa<span class="math">) blocks in the chain of </span>i<span class="math"> at </span>r<span class="math"> which are not in the chain of </span>j<span class="math"> at </span>r^{\\prime}<span class="math">; we now bound the number of fruits that can be contained in these remaining (max </span>\\kappa$) “inconsistent” blocks.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- By the “recency condition” of valid fruit, any valid fruit in the chain of <span class="math">i</span> at <span class="math">r</span> which is after <span class="math">C</span> must point to a block <span class="math">\\mathsf{b}_{j^{\\prime}}</span> such that $j^{\\prime}></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-R\\kappa$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Note that at <span class="math">r_{0}^{\\prime}</span>, <span class="math">\\mathsf{b}_{j^{\\prime\\prime}}</span> was mined by an honest player holding a chain of length $j^{\\prime\\prime}\\geq</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">-R\\kappa-\\kappa<span class="math">; additionally, at </span>r<span class="math">, </span>i<span class="math"> is honest, holding a chain of length at most </span></td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">+\\kappa<span class="math"> (recall that </span></td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math"> contains the blocks on which </span>i<span class="math"> and </span>j<span class="math"> agree, and by consistency, all but the last </span>\\kappa<span class="math"> blocks in the chain of </span>i<span class="math"> must be in the chain of </span>j$). Thus, by the <em>chain growth upperbound</em>, at most</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mu=(1+\\delta)\\frac{2\\kappa+R\\kappa}{np}</span></p>

    <p class="text-gray-300">rounds could thus have elapsed between <span class="math">r_{0}^{\\prime}</span> and <span class="math">r</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By WLOG2, any fruit which gets added after <span class="math">C</span> must have been mined after <span class="math">r_{0}^{\\prime}</span>. By WLOG4, any such fruit that is part of the chain of <span class="math">i</span> by <span class="math">r</span> was mined before <span class="math">r</span>.</li>

      <li>We thus conclude by the Chernoff bound (see Lemma A.1) that for every sufficiently small <span class="math">\\delta^{\\prime}</span>, except with probability <span class="math">e^{-\\Omega(np_{f}\\cdot\\frac{\\kappa(R+2)}{np})}=e^{-\\Omega(q(R+2)\\kappa)}</span>, there were at most</li>

    </ul>

    <p class="text-gray-300"><span class="math">(1+\\delta^{\\prime})^{2}\\cdot np_{f}\\cdot\\frac{\\kappa(R+2)}{np}=(1+\\delta^{\\prime})^{2}q(R+2)\\kappa&lt;2qR\\kappa=\\kappa_{f}</span></p>

    <p class="text-gray-300">“inconsistent” fruits in the chain of <span class="math">i</span> at <span class="math">r</span>.</p>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">5.5 Proof of Fruit Growth</h3>

    <h4 id="sec-60" class="text-lg font-semibold mt-6">Consistent length.</h4>

    <p class="text-gray-300">The consistent length property follows directly from the consistent length property of the underlying blockchain.</p>

    <h4 id="sec-61" class="text-lg font-semibold mt-6">Lowerbound.</h4>

    <p class="text-gray-300">Disregard the fruit freshness failure event (Lemma 5.1)—it happens with negligible probability. Consider any <span class="math">r,t</span> and players <span class="math">i,j</span> that are honest respectively at round <span class="math">r</span> and <span class="math">r+t</span>. Consider the <span class="math">t</span> rounds starting from round <span class="math">r</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By the <em>fruit freshness</em> condition, every fruit that is mined by some honest party by round <span class="math">r+t-wait</span> gets incorporated into (and remains in) the chain of player <span class="math">j</span> by <span class="math">r+t</span>.</li>

      <li>By the Chernoff bound, in the <span class="math">t-wait</span> rounds from <span class="math">r</span> to <span class="math">r+t-wait</span>, except with probability <span class="math">e^{-\\Omega((t-wait)\\alpha_{f})}</span>, the honest parties mine at least</li>

    </ul>

    <p class="text-gray-300"><span class="math">(1-\\delta^{\\prime})(t-wait)\\alpha_{f}</span></p>

    <p class="text-gray-300">fruits (where <span class="math">\\delta^{\\prime}</span> is some arbitrarily small constant), which are all included in the chain of <span class="math">j</span> at <span class="math">r+t</span>. Additionally, by WLOG3 they are all “new” (i.e., not included in the chains of <span class="math">i</span> at <span class="math">r</span>) and different.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally, by <em>fruit consistency</em> (proved in Section 5.4), we have that all but potentially <span class="math">\\kappa_{f}</span> of the fruits in the chain of <span class="math">i</span> at <span class="math">r</span> are still in the chain of <span class="math">j</span> at <span class="math">r+t</span>.</li>

    </ul>

    <p class="text-gray-300">##</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We conclude that, except with probability <span class="math">e^{-\\Omega((t-wait)\\alpha_{f})}</span>, the chain of <span class="math">j</span> at <span class="math">r+t</span> contains at least</li>

    </ul>

    <p class="text-gray-300"><span class="math">(1-\\delta^{\\prime})(t-wait)\\alpha_{f}-\\kappa_{f}</span></p>

    <p class="text-gray-300">more fruits than the chain of <span class="math">j</span> at <span class="math">r</span>. By Fact 5.2, <span class="math">wait\\cdot\\alpha_{f}=wait\\cdot(1-\\rho)np_{f}\\leq(1-\\rho)\\kappa_{f}\\leq\\kappa_{f}</span>; thus, have at least</p>

    <p class="text-gray-300"><span class="math">(1-\\delta)(t-wait)\\alpha_{f}-\\kappa_{f}\\geq(1-\\delta)\\alpha_{f}t-2\\kappa_{f}</span> (1)</p>

    <p class="text-gray-300">new fruit.</p>

    <p class="text-gray-300">We conclude by noting that this implies that a fruit growth lowerbound of <span class="math">g_{0}=\\frac{1}{1+\\delta}\\alpha_{f}\\geq(1-\\delta)\\alpha_{f}</span> in the desired regime: Consider any <span class="math">T\\geq\\frac{5\\kappa_{f}}{\\delta}</span> and any</p>

    <p class="text-gray-300"><span class="math">t\\geq\\frac{T}{g_{0}}=\\frac{T}{\\frac{\\alpha_{f}}{1+\\delta}}</span></p>

    <p class="text-gray-300">As shown above (see Equation 1), during this time <span class="math">t</span>, except with probability, <span class="math">e^{-\\Omega((t-wait)\\alpha_{f})}</span> the chain must grown by at least</p>

    <p class="text-gray-300"><span class="math">T(1+\\delta)(1-\\delta^{\\prime})-2\\kappa_{f}=T(1+\\frac{\\delta}{2})(1-\\delta^{\\prime})+T\\frac{\\delta}{2}(1-\\delta^{\\prime})-2\\kappa_{f}</span></p>

    <p class="text-gray-300">For a sufficiently small <span class="math">\\delta^{\\prime}</span> the first term is greater than <span class="math">T</span>, and the second term greater than <span class="math">2\\kappa_{f}</span>, and thus the chain must have grown by at least <span class="math">T</span>. Finally note that by Equation 1</p>

    <p class="text-gray-300"><span class="math">e^{-\\Omega((t-wait)\\alpha_{f})}=e^{-\\Omega((t\\alpha_{f}-\\kappa_{f})}=e^{-\\Omega((T-\\kappa_{f})}=e^{-\\Omega((5\\kappa_{f}-\\kappa_{f})}=e^{-\\Omega((5\\kappa_{f}-\\kappa_{f})}=e^{-\\Omega(\\kappa)}</span></p>

    <p class="text-gray-300">Thus the chain growth is guaranteed except with negligible probability.</p>

    <h4 id="sec-62" class="text-lg font-semibold mt-6">Upperbound.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Disregard the chain growth, consistency and blockchain quality (see Remark 2.7) failure events—they happen with negligible probability. Consider some view view in the support of <span class="math">\\mathsf{EXEC}^{\\Pi_{\\text{fruit}}(p,p_{f},R)}(A,Z,\\kappa)</span>, rounds <span class="math">r,r^{\\prime}=r+t</span> and players <span class="math">i,j</span> that are honest respectively at <span class="math">r</span> and <span class="math">r^{\\prime}</span> in view. By <em>consistency</em>, the chains of <span class="math">i,j</span> at <span class="math">r,r^{\\prime}</span> agree except for potentially the last <span class="math">\\kappa</span> blocks of the chain of <span class="math">i</span>—let $C=\\mathsf{b}_{0},\\ldots,\\mathsf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> denote those initial blocks on which they agree, and let </span>\\mathsf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1},\\ldots<span class="math"> denote the blocks in the chain of </span>j<span class="math"> at </span>r^{\\prime}<span class="math"> which are not in the chain of </span>i<span class="math"> at </span>r<span class="math"> (there may be more than </span>\\kappa<span class="math"> such blocks since we are looking at the chain of </span>j<span class="math"> at a later time </span>r^{\\prime}<span class="math">); We now upper bound the number of fruits in the new blocks in the chain of </span>j<span class="math"> which come after </span>C<span class="math">, similarly to the fruit consistency proof (they main difference is that we now consider the chain of </span>j<span class="math"> as opposed to the chain of </span>i$). The details follow:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- By the “recency condition” of valid fruit, any valid fruit in the chain of <span class="math">j</span> at <span class="math">r^{\\prime}</span> which is after <span class="math">C</span> must point to a block <span class="math">\\mathsf{b}_{j^{\\prime}}</span> such that $j^{\\prime}></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-R\\kappa$,</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Note that at <span class="math">r_{0}^{\\prime}</span>, <span class="math">\\mathsf{b}_{j^{\\prime\\prime}}</span> was mined by an honest player holding a chain of length $j^{\\prime\\prime}\\geq</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">-R\\kappa-\\kappa<span class="math">; additionally, at </span>r<span class="math">, </span>i<span class="math"> is honest, holding a chain of length at most </span></td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">+\\kappa<span class="math"> (recall that </span></td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math"> contains the blocks on which </span>i<span class="math"> and </span>j<span class="math"> agree, and by consistency, all but the last </span>\\kappa<span class="math"> block in the chain of </span>i<span class="math"> must be in the chain of </span>j<span class="math">). Thus, by the <em>chain growth upperbound</em>, for any arbitrarily small </span>\\delta^{\\prime}$ at most</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mu=(1+\\delta^{\\prime})\\frac{2\\kappa+R\\kappa}{np}</span></p>

    <p class="text-gray-300">rounds could thus have elapsed between <span class="math">r_{0}^{\\prime}</span> and <span class="math">r</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By WLOG2, any fruit which gets added after <span class="math">C</span> must have been mined after <span class="math">r_0&#x27;</span>. By WLOG4, any such fruit that is part of the chain of <span class="math">j</span> by <span class="math">r&#x27;</span> was mined before <span class="math">r&#x27;</span>.</li>

      <li>We thus conclude by the Chernoff bound that except with probability <span class="math">e^{-\\Omega(np_f \\cdot \\frac{\\kappa(R + 2)}{np})} = e^{-\\Omega(q(R + 2)\\kappa)}</span>, there were at most</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">(1 + \\delta^ {\\prime}) ^ {2} \\cdot n p _ {f} \\cdot \\left(\\frac {\\kappa (R + 2)}{n p} + t\\right) = (1 + \\delta^ {\\prime}) ^ {2} (q (R + 2) \\kappa + n p _ {f} t) \\leq \\kappa_ {f} + (1 + \\delta^ {\\prime}) ^ {2} n p _ {f} t \\tag {2}</span></div>

    <p class="text-gray-300">"new" fruits in the chain of <span class="math">j</span> at <span class="math">r&#x27;</span>.</p>

    <p class="text-gray-300">We conclude by noting that this implies a fruit growth upperbound of <span class="math">g_{1} = (1 + \\delta)np_{f}</span> in the desired regime: Consider any <span class="math">T\\geq \\frac{5\\kappa_f}{\\delta}</span> and any</p>

    <div class="my-4 text-center"><span class="math-block">t = \\frac {T}{g _ {1}} = \\frac {T (1 + \\delta)}{n p _ {f}}.</span></div>

    <p class="text-gray-300">As shown above (see Equation 2), during this time <span class="math">t</span>, except with negligible probability, the chain must have grown by at most</p>

    <div class="my-4 text-center"><span class="math-block">\\kappa_ {f} + (1 + \\delta^ {\\prime}) ^ {2} T (1 - \\delta) \\leq T \\delta / 5 + (1 + \\delta^ {\\prime}) ^ {2} T / (1 + \\delta)</span></div>

    <p class="text-gray-300">For any <span class="math">0 &amp;lt; \\delta &amp;lt; 1</span> and <span class="math">\\delta&#x27; = 0.1\\delta</span>, the above expression is upper bounded by <span class="math">T</span>.</p>

    <h2 id="sec-63" class="text-2xl font-bold">5.6 Proof of Fruit Fairness</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Disregard the chain growth, blockchain quality (see Remark 2.7), fruit freshness, and the fruit growth failure events—they happen with negligible probability. Consider some <span class="math">\\phi</span>-fraction player subset selection <span class="math">S</span>, some view view in the support of <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathrm{fruit}}(p,p_f,R)}(A,Z,\\kappa)</span>, some round <span class="math">r</span> and player <span class="math">i</span> that is honest in round <span class="math">r</span> of view. Let $C = \\mathsf{b}_0,\\ldots ,\\mathsf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> be the blocks in the view of </span>i<span class="math"> at view, let </span>f_0,\\dots ,f_\\ell<span class="math"> be the fruits contained in them, and let </span>\\mathfrak{m}_0,\\ldots ,\\mathfrak{m}_\\ell<span class="math"> be the records contained in the fruits; let </span>f_{j},\\ldots ,f_{j + T}<span class="math"> be </span>T<span class="math"> consecutive fruits for some </span>j<span class="math">, where </span>T\\geq \\frac{5\\kappa_f}{\\delta}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">r_0</span> be the round when the block in the view of <span class="math">i</span> at <span class="math">r</span> containing <span class="math">f_{j + \\kappa_f}</span> was first added to some honest player <span class="math">j_0</span>'s chain; let <span class="math">r_1</span> be the round when the block (again in the view of <span class="math">i</span> at <span class="math">r</span>) containing <span class="math">f_{j + T}</span> was first added to some honest player <span class="math">j_1</span>'s chain, and let <span class="math">t = r_1 - r_0 - 2</span> be the number of rounds from <span class="math">r_0 + 1</span> to <span class="math">r_1 - 1</span>. We lower bound the number of <span class="math">S</span>-compatible (honest) fruits in the sequence, following similar lines (but slightly more complicated) to the proof of fruit growth lowerbound:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By the fruit freshness condition, every fruit mined by some honest player between <span class="math">(r_0 + 1)</span> and <span class="math">(r_1 - 1) - wait</span> will be in the chain of <span class="math">j_1</span> at some position pos that is at least <span class="math">\\kappa</span> positions from the end of the chain, before the beginning of round <span class="math">r_1</span> and will remain so.</li>

      <li>By the Chernoff bound, in the <span class="math">t - wait</span> rounds from <span class="math">r_0 + 1</span> to <span class="math">(r_1 - 1) - wait</span>, except with probability <span class="math">e^{-\\Omega((t - wait)\\phi np_f)}</span>, the honest parties in <span class="math">S</span> mine at least</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">(1 - \\delta^ {\\prime}) (t - w a i t) \\phi n p _ {f}</span></div>

    <p class="text-gray-300">fruits (where <span class="math">\\delta&#x27;</span> is some arbitrarily small constant), which thus are all included in the chain of <span class="math">j_1</span> by <span class="math">r_1 - 1</span>.</p>

    <p class="text-gray-300">7Note that we cannot consider the time when it was added to <span class="math">i</span>'s chain as <span class="math">i</span> may potentially be corrupted up until <span class="math">r</span>.</p>

    <p class="text-gray-300">Since fruits are ordered by the block containing them, and since in round <span class="math">r_{1}</span> a <em>new</em> block is added which contains <span class="math">f_{j+T}</span>, it follows from <em>blockchain consistency</em> that all these fruits are contained in the sequence <span class="math">f_{1},\\ldots,f_{j+T}</span> (recall that all these fruits are found in blocks that are at least <span class="math">\\kappa</span> positions from the end of the chain, so by consistency, those block cannot change and thus were not added in round <span class="math">r_{1}</span> and consequently must come before the block containing <span class="math">f_{j+T}</span>).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By WLOG3, these fruits are also all “new” (i.e., not included in the chains of <span class="math">j_{0}</span> at <span class="math">r_{0}</span>) and different. Since in round <span class="math">r_{0}</span>, the block containing <span class="math">f_{j+\\kappa_{f}}</span> was added to the chain of <span class="math">j_{0}</span>, and since by WLOG5, the chain of <span class="math">j_{0}</span> at <span class="math">r_{0}</span> up until (and including) the block which contains <span class="math">f_{j+\\kappa_{f}}</span> is a prefix of <span class="math">C</span>, all these fruits must in fact be contained in the sequence <span class="math">f_{j+\\kappa_{f}},\\ldots,f_{j+T}</span>.</li>

      <li>Finally, by fruit consistency, at <span class="math">r_{0}</span> all honest players’ fruit chains contain <span class="math">f_{1},\\ldots f_{j}</span> (since recall that some player added <span class="math">f_{j+\\kappa_{f}}</span> at <span class="math">r_{0}</span>). Thus all these fruits are <span class="math">S</span>-compatible w.r.t the prefix <span class="math">f_{1},\\ldots f_{j-1}</span> before the <span class="math">T</span> segment we are considering.</li>

    </ul>

    <p class="text-gray-300">We proceed to show that <span class="math">t</span> is sufficiently large. Recall that <span class="math">j_{0}</span> is honest at <span class="math">r_{0}</span> and <span class="math">j_{1}</span> is honest at <span class="math">r_{1}</span>. We know that at <span class="math">r_{1}</span>, the fruit chain contains at least <span class="math">f_{j+T}</span> fruits. Additionally, at <span class="math">r_{0}</span> the fruit <span class="math">f_{j+\\kappa_{f}}</span> is added for the first time, so by fruit chain consistency, at most <span class="math">j+2\\kappa_{f}</span> fruits could have been in the chain of <span class="math">i</span> at this point (since a fruit at position <span class="math">j+\\kappa_{f}</span> is modified). Thus, the fruit chain must have grown by at least <span class="math">T-2\\kappa_{f}</span> from <span class="math">r_{0}</span> to <span class="math">r_{1}</span>. By the <em>upperbound on fruit growth</em> (see Equation 2) we thus have that</p>

    <p class="text-gray-300"><span class="math">T-2\\kappa_{f}\\leq\\kappa_{f}+(1-\\delta^{\\prime})^{2}np_{f}(t+2)</span></p>

    <p class="text-gray-300">Thus,</p>

    <p class="text-gray-300"><span class="math">t\\geq\\frac{1}{(1+\\delta^{\\prime})^{2}np_{f}}\\left(T-3\\kappa_{f}\\right)-2</span></p>

    <p class="text-gray-300">We conclude that (except with negligible probability) the number of fruits in the sequence is at least:</p>

    <p class="text-gray-300"><span class="math">(1-\\delta^{\\prime})\\phi np_{f}\\left(\\frac{1}{(1+\\delta^{\\prime})^{2}np_{f}}\\left(T-3\\kappa_{f}\\right)-2-wait\\right)=</span> <span class="math">(1-\\delta^{\\prime})\\phi\\left(\\frac{1}{(1+\\delta^{\\prime})^{2}}\\left(T-3\\kappa_{f}\\right)-np_{f}(wait+2)\\right)\\geq</span> <span class="math">(1-\\delta^{\\prime})\\phi\\left(\\frac{1}{(1+\\delta^{\\prime})^{2}}\\left(T-3\\kappa_{f}\\right)-\\kappa_{f}\\right)\\geq</span> <span class="math">(1-\\delta^{\\prime})\\phi\\left(\\frac{1}{(1+\\delta^{\\prime})^{2}}\\left(T-4.5\\kappa_{f}\\right)\\right)\\geq</span> <span class="math">\\phi(T-5\\kappa_{f})</span></p>

    <p class="text-gray-300">where the first inequality follows by Fact 5.2, and the second and third by the taking a sufficiently small <span class="math">\\delta^{\\prime}</span>. Since <span class="math">T\\geq\\frac{5\\kappa_{f}}{\\delta}</span>, we have that <span class="math">(1-\\delta)T\\geq T-5\\kappa_{f}</span>, thus the number of fruits in the sequence is at least</p>

    <p class="text-gray-300"><span class="math">(1-\\delta)\\phi T</span></p>

    <h2 id="sec-64" class="text-2xl font-bold">6 From Fairness to Incentive Compatibility</h2>

    <p class="text-gray-300">We remark that any secure blockchain protocol that satisfies <span class="math">\\delta</span>-approximate fairness (where <span class="math">\\delta&lt;0.3</span>) w.r.t <span class="math">T(\\kappa)</span> length windows can be used as the ledger underlying a cryptocurrency system while ensuring <em><span class="math">3\\delta</span>-incentive compatibility</em> if players (i.e. miners) only care about how much money</p>

    <p class="text-gray-300">they receive—that is, a miner's utility is the sum of the rewards and transaction fees it receives (potentially times some constant).⁸</p>

    <p class="text-gray-300">Consider a crypto-currency which uses a blockchain protocol as the underlying ledger; we omit a formalization of what this means, but have in mind a system such as Bitcoin where rewards and transaction fees are somehow distributed among the miners of blocks—for instance, recall that in Bitcoin, the miner of a block receives a mining reward as well as all the transaction fees contained in the block it mined.</p>

    <p class="text-gray-300">We say that honest mining is a <span class="math">\\rho</span>-coalition-safe <span class="math">\\epsilon</span>-Nash equilibrium if, with overwhelming probability, no <span class="math">\\rho&#x27; &amp;lt; \\rho</span> fraction coalition can gain more than a multiplicative factor <span class="math">(1 + \\epsilon)</span> in utility, no matter what transactions are being processed—formally, consider some environment providing transactions into the system. We restrict to a setting where the total rewards and transaction fees during the run of the system is some fixed constant <span class="math">V^9</span>.</p>

    <p class="text-gray-300">We now remark that if rewards and transaction fees are evenly distributed among the (miners of the) blocks in the <span class="math">T(\\kappa)</span>-length segment of the chain preceding the block (and in the initial phase, before the chain is of length <span class="math">T(\\kappa)</span>, simply the first <span class="math">T(\\kappa)</span> blocks) then it follows that honest mining is a <span class="math">\\rho</span>-coalition-safe <span class="math">3\\delta</span>-Nash equilibrium as long as the underlying blockchain satisfies <span class="math">\\delta</span>-approximate fairness w.r.t. <span class="math">\\rho</span> attackers: as noted above, fairness implies that no matter what deviation the coalition performs, with overwhelming probability, the fraction of adversarial blocks in any <span class="math">T(\\kappa)</span>-length window of the chain is upperbounded by <span class="math">(1 + \\delta)\\rho</span> and thus the total amount of compensation received by the attacker is bounded by <span class="math">(1 + \\delta)\\rho \\cdot V</span>; in contrast, by fairness, if the coalition had been following the honest protocol, they are guaranteed to receive at least <span class="math">(1 - \\delta)\\rho \\cdot V</span>; thus, the multiplicative increase in utility is</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{1 + \\delta}{1 - \\delta} \\leq 1 + 3\\delta</span></div>

    <p class="text-gray-300">when <span class="math">\\delta &amp;lt; 0.3</span>.¹⁰</p>

    <p class="text-gray-300">To see why the "standard" bitcoin approach of giving all rewards and fees to the miner of the block does not work, consider an freshly mined (honest) block containing a transaction with a very high transaction fee. A coalition controlling a constant fraction of the computing power would have a huge incentive to "drop" this block and instead try to mine a new block which contains it. Fairness does not prevent such an attack, and indeed, even in our protocol such an attack will be successful with constant probability. (Indeed, it has been informally conjectured in the bitcoin community that <span class="math">\\epsilon</span>-incentive compatibility is impossible to achieve in the presence of transaction fees, due to exactly this reason. Our method of distributing the fees over a segment overcomes this "barrier".)</p>

    <p class="text-gray-300">⁸This may not always be a realistic assumption. For instance, a miner can care about what transactions get added into the blockchain etc, but following earlier approaches to modeling incentives in blockchains (e.g., [ES14]), we focus only on miners' monetary rewards.</p>

    <p class="text-gray-300">⁹The analysis directly extends to a setting where the total rewards and fees are only guaranteed to be withing some multiplicative factor <span class="math">(1 + \\delta&#x27;)</span> of <span class="math">V</span> at the cost of a degradation of the quality of the Nash equilibrium (i.e., increasing the <span class="math">\\epsilon</span>).</p>

    <p class="text-gray-300">¹⁰Let us remark that an alternative approach would be to give the whole mining reward to the miner of a block (as in Bitcoin) but still distribute the transaction fees among the group of miners in a <span class="math">T(\\kappa)</span>-segment of the chain. This approach works by the same analysis as long as mining rewards are fixed throughout the experiment (which is not the case for e.g., Bitcoin where mining rewards decrease over time).</p>

    <p class="text-gray-300">24</p>

    <p class="text-gray-300">above), but also leads to the issue that it may take a very long time for an individual miner to be successful in mining a block and consequently reap a reward for its work. In other words, the payments received by miners has a very <em>high variance</em>. This has lead to the creation of mining pools, where miners come together and pool their work and then share the reward once someone in the pool mines a block—such pooling decreases the variance. To prevent free-riding, miners submit “partial proofs of work” (that is, “near” solutions to the mining puzzles) that are significantly easier to find, and rewards are distributed (according to some distribution rule) among the contributors of the partial proofs-of-work.</p>

    <p class="text-gray-300">An undesirable effect of such pools is that the pool operator effectively controls a large number of participants and potentially could get them to deviate; in a sense, the decentralized nature of the system gets lost.</p>

    <p class="text-gray-300">We note that since the FruitChain protocol is parametrized by <em>two</em> mining hardnesses—the block hardness <span class="math">p</span>, and the fruit hardness <span class="math">p_{f}</span>—which are independent of each other, we can set <span class="math">p</span> appropriately to ensure consistency, but <span class="math">p_{f}</span> can be set to be much larger—for instance, as large as the probability of find a partial proof-of-work in mining pools—and consequently, we would reduce the variance of the rewards received by miners in exactly the same way as in mining pool, but now in a <em>fully decentralized</em> way.</p>

    <p class="text-gray-300">Today, a solo miner (assuming one unit of typical commodity mining ASIC) would take 2 to 5 years to obtain its first reward [sol]. With FruitChain, suppose we allocate space for 1000 fruits per block where each fruit is 80 bytes (same size as a Bitcoin puzzle solution), this would occupy roughly 8% of a 1MB block — however, this would allow a solo miner to get its first rewards 1000x faster, roughly on the order of a day (or days) rather than years.</p>

    <h2 id="sec-65" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[sol] http://www.coinwarz.com/calculators/bitcoin-mining-calculator.</li>

      <li>[BCL^{+}05] Boaz Barak, Ran Canetti, Yehuda Lindell, Rafael Pass, and Tal Rabin. Secure computation without authentication. In CRYPTO’05, 2005.</li>

      <li>[BHP^{+}] Iddo Bentov, Yuncong Hu, Rafael Pass, Elaine Shi, and Siqiu Yao. Decentralized pooled mining: An implementation of fruitchain. Manuscript.</li>

      <li>[BPS16] Iddo Bentov, Rafael Pass, and Elaine Shi. Snow white: Provably secure proofs of stake. Cryptology ePrint Archive, Report 2016/919, 2016. http://eprint.iacr.org/2016/919.</li>

      <li>[CKWN16] Miles Carlsten, Harry A. Kalodner, S. Matthew Weinberg, and Arvind Narayanan. On the instability of bitcoin without the block reward. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, Vienna, Austria, October 24-28, 2016, pages 154–167, 2016.</li>

      <li>[DN92] Cynthia Dwork and Moni Naor. Pricing via processing or combatting junk mail. In CRYPTO’92, pages 139–147, 1992.</li>

      <li>[ES14] Ittay Eyal and Emin Gün Sirer. Majority is not enough: Bitcoin mining is vulnerable. In Financial Cryptography and Data Security, pages 436–454. Springer, 2014.</li>

      <li>[GKL15] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol: Analysis and applications. In Advances in Cryptology-EUROCRYPT 2015, pages 281–310. Springer, 2015.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[HP15] Joseph Y. Halpern and Rafael Pass. Algorithmic rationality: Game theory with costly computation. J. Economic Theory, 156:246–268, 2015.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[KKKT16] Aggelos Kiayias, Elias Koutsoupias, Maria Kyropoulou, and Yiannis Tselekounis. Blockchain mining games. In Proceedings of the 2016 ACM Conference on Economics and Computation, EC ’16, pages 365–382, 2016.</li>

      <li>[KP15] Aggelos Kiayias and Giorgos Panagiotakos. Speed-security tradeoffs in blockchain protocols, 2015.</li>

      <li>[KP16] Aggelos Kiayias and Giorgos Panagiotakos. On trees, chains and fast transactions in the blockchain. IACR Cryptology ePrint Archive, 2016:545, 2016.</li>

      <li>[KRDO16] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain protocol. Cryptology ePrint Archive, Report 2016/889, 2016. http://eprint.iacr.org/2016/889.</li>

      <li>[LSZ15] Yoad Lewenberg, Yonatan Sompolinsky, and Aviv Zohar. Inclusive block chain protocols. In Financial Crypto’15, 2015.</li>

      <li>[mtg10] mtgox. https://bitcointalk.org/index.php?topic=2227.msg29606#msg29606, 2010.</li>

      <li>[Nak08] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2008.</li>

      <li>[NKMS16] Kartik Nayak, Srijan Kumar, Andrew Miller, and Elaine Shi. Stubborn mining: Generalizing selfish mining and combining with an eclipse attack. In IEEE European Symposium on Security and Privacy, EuroS&P 2016, Saarbrücken, Germany, March 21-24, 2016, pages 305–320, 2016.</li>

      <li>[PSS17] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol in asynchronous networks. In Eurocrypt, 2017.</li>

      <li>[PS16] Rafael Pass and Elaine Shi. Hybrid consensus. http://eprint.iacr.org/2016/917, 2016.</li>

      <li>[SSZ16] Ayelet Sapirshtein, Yonatan Sompolinsky, and Aviv Zohar. Optimal selfish mining strategies in bitcoin. In Financial Crypto’16, 2016.</li>

      <li>[SZ15] Yonatan Sompolinsky and Aviv Zohar. Secure high-rate transaction processing in bitcoin. In Financial Cryptography and Data Security - 19th International Conference, FC 2015, San Juan, Puerto Rico, January 26-30, 2015, Revised Selected Papers, pages 507–527, 2015.</li>

    </ul>

    <h2 id="sec-66" class="text-2xl font-bold">Appendix A Appendix</h2>

    <p class="text-gray-300">We recall the standard Chernoff bound.</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Lemma A.1 (Multiplicative Chernoff Bound).</h6>

    <p class="text-gray-300">Let <span class="math">X_{1},\\ldots X_{n}</span> be independent Boolean random variables, such that for all <span class="math">i</span>, <span class="math">\\Pr[X_{i}=1]=p</span>; let <span class="math">X</span> be the sum of these variables, and <span class="math">\\mu</span> be the expectation of the sum. Then for any <span class="math">\\delta\\in(0,1]</span>, we have</p>

    <p class="text-gray-300"><span class="math">Pr\\left[X&amp;gt;(1+\\delta)\\,\\mu\\right]&amp;lt;e^{-\\Omega\\left(\\delta^{2}\\mu\\right)}</span> <span class="math">Pr\\left[X&amp;lt;(1-\\delta)\\,\\mu\\right]&amp;lt;e^{-\\Omega\\left(\\delta^{2}\\mu\\right)}</span></p>`;
---

<BaseLayout title="FruitChains: A Fair Blockchain (2016/916)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/916
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
