---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2009/191';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'New logic minimization techniques with applications to cryptology.';
const AUTHORS_HTML = 'Joan Boyar, Rene Peralta';

const CONTENT = `    <p class="text-gray-300">A new combinational logic minimization technique with applications to cryptology.</p>

    <p class="text-gray-300">Joan Boyar <span class="math">^{1}</span> and René Peralta<span class="math">^{2}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> Department of Mathematics and Computer Science University of Southern Denmark, joan@imada.sdu.dk <span class="math">^{2}</span> Information Technology Laboratory, NIST, peralta@nist.gov</p>

    <p class="text-gray-300">Abstract. A new technique for combinational logic optimization is described. The technique is a two-step process. In the first step, the nonlinearity of a circuit – as measured by the number of non-linear gates it contains – is reduced. The second step reduces the number of gates in the linear components of the already reduced circuit. The technique can be applied to arbitrary combinational logic problems, and often yields improvements even after optimization by standard methods has been performed. In this paper we show the results of our technique when applied to the S-box of the Advanced Encryption Standard (AES [5]). This is an experimental proof of concept, as opposed to a full-fledged circuit optimization effort. Nevertheless the result is, as far as we know, the circuit with the smallest gate count yet constructed for this function. We have also used the technique to improve the performance (in software) of several candidates to the Cryptographic Hash Algorithm Competition. Finally, we have experimentally verified that the second step of our technique yields significant improvements over conventional methods when applied to randomly chosen linear transformations.</p>

    <p class="text-gray-300">Keywords: AES; S-box; finite field inversion; circuit complexity; multiplicative complexity.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Constructing optimal combinational circuits is an intractable problem under almost any meaningful metric (gate count, depth, energy consumption, etc.). In practice, no known techniques can reliably find optimal circuits for functions with as few as eight Boolean inputs and one Boolean output (there are <span class="math">2^{256}</span> such functions).</p>

    <p class="text-gray-300">For example, the multiplicative complexity<span class="math">^{3}</span> of the Boolean function <span class="math">E_{4}^{8}</span>, which is true if and only if exactly four of its eight input bits are true, is unknown [2]. In practice, we build circuit implementations of functions using a variety of heuristics. Many of these heuristics have exponential time complexity and thus can only be applied to small components of a circuit being built. This works reasonably well for functions that naturally decompose into repeated use of small components. Such functions include</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Partially supported by the Danish Natural Science Research Council (SNF). Some of this work was done while visiting the University of California, Irvine.</li>

    </ul>

    <p class="text-gray-300">3 The multiplicative complexity of a function is the number of GF(2) multiplications necessary and sufficient to compute it.</p>

    <p class="text-gray-300">arithmetic functions (which we often build using full adders), matrix multiplication (which decomposes into multiplication of small submatrices), and more complex functions such as cryptographic functions (which are commonly based on multiple iterations of an algorithm containing linear steps and one non-linear step).</p>

    <p class="text-gray-300">This work presents a new technique for logic synthesis and circuit optimization. The technique can be applied to arbitrary functions, and yields improvements even on programs/circuits that have already been optimized by standard methods. We apply our technique to the S-box of AES, which, in addition to being used in AES, has been used in several proposals for a new hash function standard. The result is, as far as we know, the smallest circuit yet constructed for this function. The circuit contains 32 AND gates and 83 XOR/XNOR gates for a total of 115 gates. We have also applied these techniques to the logic embedded in the non-linear components of several candidates to the SHA-3 competition. The improvements in software performance were significant.</p>

    <p class="text-gray-300">Our circuits are over the basis <span class="math">\\{\\oplus,\\wedge,1\\}</span>. This basis is logically complete: any Boolean circuit can be transformed into this form using only local replacements. The circuit operations can be viewed either as performing Boolean logic or arithmetic modulo 2. The number of <span class="math">\\wedge</span> gates is called the multiplicative complexity of the circuit. Connected components of the circuit containing <span class="math">\\wedge</span> gates are called non-linear. Components free of <span class="math">\\wedge</span> gates are called linear.</p>

    <h2 id="sec-1" class="text-2xl font-bold">2 Combinational circuit optimization</h2>

    <p class="text-gray-300">The techniques described here would generally be applied to subcircuits of a larger circuit, such as an S-box in a cryptographic application, which have relatively few inputs and outputs connecting them to the remainder of the circuit. The key observation that led us to our techniques is that circuits with low multiplicative complexity will naturally have large sections which are purely linear (i.e. contain only <span class="math">\\oplus</span> gates). Thus</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>it is plausible that a two-step process, which first reduces multiplicative complexity and then optimizes linear components, leads to small circuits.</p>
    </blockquote>

    <p class="text-gray-300">We have, of course, no way of proving this hypothesis. But the experiments reported here support it.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">First step</h3>

    <p class="text-gray-300">The first step of our technique consists of identifying non-linear components of the subcircuit to be optimized and reducing the number of <span class="math">\\wedge</span> gates. This reduction is not easy to do. For example, the two circuits</p>

    <p class="text-gray-300">below compute the same function. But it is not obvious how to algorithmically transform one into the other.</p>

    <p class="text-gray-300">Finding circuits with minimum multiplicative complexity is, in all likelihood, a highly intractable problem. However, recent work on multiplicative complexity contains an arsenal of reduction techniques that in practice yield circuits with small, and often optimal, multiplicative complexity <em>[2]</em>. That work focuses exclusively on symmetric functions (those whose value depends only on the Hamming weight of the input). In this paper we use ad-hoc heuristics to construct a circuit with low multiplicative complexity for inversion in <span class="math">GF(2^{4})</span>. The technique is partially described in Section 3.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">Second step</h3>

    <p class="text-gray-300">The second step of our technique consists of finding maximal linear components of the circuit and then minimizing the number of XOR gates needed to compute the target functions computed in these linear components. A new heuristic for this computationally intractable problem is described in Section 4.</p>

    <h2 id="sec-4" class="text-2xl font-bold">3 AES’s S-box</h2>

    <p class="text-gray-300">The non-linear operation in AES’s S-box is to compute an inverse in the field <span class="math">GF(2^{8})</span>. A recursive method for building a circuit for inverses in <span class="math">GF(2^{mn})</span>, given a circuit for inverses in <span class="math">GF(2^{m})</span>, is due to Itoh and Tsujii <em>[6]</em>. The circuits produced by this method are said to have a tower fields architecture. Since there are multiple possible representations for Galois fields, several authors have concentrated on finding representations that yield efficient circuits under the tower fields architecture. We use the same general technique for the reduction from inversion in <span class="math">GF(2^{8})</span> to <span class="math">GF(2^{4})</span> inversion, but we use a completely different technique for computing the inversion in <span class="math">GF(2^{4})</span>. We then place the optimized circuit for <span class="math">GF(2^{4})</span> inversion in its appropriate place in AES’s S-box and apply a novel optimization technique on the linear parts of the resulting circuit.</p>

    <p class="text-gray-300"><span class="math">GF(2^{4})</span> inversion – A non-linear component</p>

    <p class="text-gray-300">The tower fields architecture for inversion in <span class="math">GF(2^{8})</span> has (non-trivial) easily identifiable non-linear components corresponding to inversion in subfields. The first step in our method is to focus on one of these components and derive a circuit that uses few <span class="math">\\wedge</span> gates. The component for inversion in <span class="math">GF(2^{2})</span> is too small for us to benefit significantly from optimizing it. Instead we focus on inversion in <span class="math">GF(2^{4})</span>.</p>

    <p class="text-gray-300">There are many representations of <span class="math">GF(2^{4})</span>. We construct</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">GF(2^{2})</span> by adjoining a root <span class="math">W</span> of <span class="math">x^{2}+x+1</span> over <span class="math">GF(2)</span>;</li>

      <li><span class="math">GF(2^{4})</span> by adjoining a root <span class="math">Z</span> of <span class="math">x^{2}+x+W^{2}</span> over <span class="math">GF(2^{2})</span>.</li>

    </ul>

    <p class="text-gray-300">Following Canright <em>[4]</em>, we represent <span class="math">GF(2^{2})</span> using the basis <span class="math">(W,W^{2})</span> and <span class="math">GF(2^{4})</span> using the basis <span class="math">(Z^{2},Z^{8})</span>. Thus, an element <span class="math">\\delta\\in GF(2^{4})</span> is written as <span class="math">\\delta_{1}Z^{2}+\\delta_{2}Z^{8}</span>, where <span class="math">\\delta_{1},\\delta_{2}\\in GF(2^{2})</span>. Similarly, an element <span class="math">\\gamma</span> in <span class="math">GF(2^{2})</span> is written as <span class="math">\\gamma_{1}W+\\gamma_{2}W^{2}</span>, where <span class="math">\\gamma_{1},\\gamma_{2}\\in GF(2)</span>. Since <span class="math">Z</span> satisfies <span class="math">x^{2}+x+W^{2}=0</span> and <span class="math">W</span> satisfies <span class="math">x^{2}+x+1=0</span>, one can calculate that <span class="math">Z^{4}=Z^{2}+W</span>, <span class="math">Z^{8}=Z^{2}+1</span>, <span class="math">Z^{10}=Z^{4}+Z^{2}=W</span>, <span class="math">Z^{16}=Z^{8}+W</span>, <span class="math">W^{3}=W^{2}+W</span>, <span class="math">W^{4}=W</span>, and <span class="math">W^{5}=W^{2}</span>. These equations can be used to reduce expressions to check equalities.</p>

    <p class="text-gray-300">Using this representation, an element of <span class="math">GF(2^{4})</span> can be written as <span class="math">\\Delta=(x_{1}W+x_{2}W^{2})Z^{2}+(x_{3}W+x_{4}W^{2})Z^{8}</span>, where <span class="math">x_{1},x_{2},x_{3},x_{4}\\in GF(2)</span>. The inverse of this element, <span class="math">\\Delta^{\\prime}=(y_{1}W+y_{2}W^{2})Z^{2}+(y_{3}W+y_{4}W^{2})Z^{8}</span>, can then be calculated using the following polynomials over <span class="math">GF(2)</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">y_{1}=x_{2}x_{3}x_{4}+x_{1}x_{3}+x_{2}x_{3}+x_{3}+x_{4}</span></li>

      <li><span class="math">y_{2}=x_{1}x_{3}x_{4}+x_{1}x_{3}+x_{2}x_{3}+x_{2}x_{4}+x_{4}</span></li>

      <li><span class="math">y_{3}=x_{1}x_{2}x_{4}+x_{1}x_{3}+x_{1}x_{4}+x_{1}+x_{2}</span></li>

      <li><span class="math">y_{4}=x_{1}x_{2}x_{3}+x_{1}x_{3}+x_{1}x_{4}+x_{2}x_{4}+x_{2}</span></li>

    </ul>

    <p class="text-gray-300">The fact that <span class="math">\\Delta^{\\prime}</span> is the inverse of <span class="math">\\Delta</span> can be verified by multiplying the two elements together and reducing using the equations mentioned above (along with <span class="math">x^{2}=x</span> and <span class="math">x+x=0</span>). The symbolic result is <span class="math">(QW+QW^{2})Z^{2}+(QW+QW^{2})Z^{8}</span>, where <span class="math">Q=x_{1}x_{2}x_{3}x_{4}+x_{1}x_{2}x_{3}+x_{1}x_{2}x_{4}+x_{1}x_{3}x_{4}+x_{2}x_{3}x_{4}+x_{1}x_{2}+x_{1}x_{3}+x_{1}x_{4}+x_{2}x_{3}+x_{2}x_{4}+x_{3}x_{4}+x_{1}+x_{2}+x_{3}+x_{4}</span>. The fact that the value of <span class="math">Q</span> is 1 unless all four variables have the value 0, when it is 0, can be seen by observing that it is the symmetric function <span class="math">\\Sigma_{4}^{4}+\\Sigma_{3}^{4}+\\Sigma_{2}^{4}+\\Sigma_{1}^{4}</span>. If exactly four variables are set, then the first term gives the value 1 (and the others 0); if three are set, then the second, third and fourth terms give the value 1; if exactly two are set, then only the third gives the value 1; and if only one is set, then only the last gives the value 1. Hence, the result is 1, except for the zero input.</p>

    <p class="text-gray-300">Thus the task at hand is to construct a circuit with four inputs and four outputs that calculates the above system of equations using as few</p>

    <p class="text-gray-300"><span class="math">\\wedge</span>  gates as possible. Currently, our heuristic search programs can handle functions with one output and up to eight inputs. This means that we can directly construct optimal circuits for each of the four equations individually, but not for the system itself. For the full system we took the following approach:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>pick an equation and construct an efficient circuit for it;</li>

      <li>store intermediate functions computed in the previous steps for possible use in constructing a circuit for the next equation to be tackled;</li>

      <li>iterate until all equations have been computed.</li>

    </ul>

    <p class="text-gray-300">The first step is non-trivial even for predicates on few inputs. The heuristic we used is inspired by methods from automatic theorem proving. We omit its description here due to space constraints <span class="math">^6</span> . We can report, however, that we succeeded in determining the multiplicative complexity of all  <span class="math">2^{16}</span>  predicates on four bits. It turns out that 3 multiplications are enough to compute any predicate on four variables. <span class="math">^7</span>  This is of interest to designers of cryptographic functions since many constructions have been proposed which use 4x4 S-boxes. We have not yet been able to do the same for all predicates on 5 bits.</p>

    <p class="text-gray-300">We performed the three steps above for each of the 24 orderings of  <span class="math">\\{y_1, y_2, y_3, y_4\\}</span> . The ordering  <span class="math">(y_4, y_2, y_1, y_3)</span>  gave the best results. The resulting circuit, expressed as a straight-line program over  <span class="math">\\mathrm{GF}(2)</span> , is shown in Figure 1 (outputs are indicated by an  <span class="math">(^{*})</span> ).</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig.1. Inversion in  <span class="math">GF(2^4)</span> .</p>

    <p class="text-gray-300">This circuit contains  <span class="math">5 \\wedge</span>  gates and  <span class="math">11 \\oplus</span>  gates. It is a significant improvement over previous constructions, e.g. Paar's construction [8] has a gate count of  <span class="math">10 \\wedge</span>  gates and  <span class="math">15 \\oplus</span>  gates for the same function. It is harder to compare to Canright's construction [4]. In his original, he had  <span class="math">9 \\wedge</span>  gates (and NAND gates) and  <span class="math">14 \\oplus</span>  gates (and XNOR gates), but he optimized, allowing NOR gates. After this, he had 8 NAND gates, 2 NOR gates, and 9 XOR/XNOR gates.</p>

    <p class="text-gray-300">The multiplicative complexity of a function is the number of GF(2) multiplications necessary and sufficient to compute it. Under the given representation for <span class="math">GF(2^{4})</span>, the multiplicative complexity of inversion is 5. This can be argued as follows: the upper bound is given by the construction. The four outputs that have to be computed all have degree 3. One <span class="math">\\wedge</span> is needed to compute a polynomial of degree 2. Then, an additional <span class="math">\\wedge</span> is necessary to produce each of the four linearly independent polynomials, since each is of degree 3.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">A view of the structure of AES’s S-box</h4>

    <p class="text-gray-300">In the previous section, using the tower fields architecture, we identified and optimized (with respect to multiplicative complexity) a major non-linear component in an implementation of the AES S-box. That completes the first step of our technique for circuit optimization, but in other circuits, one may be able to identify more non-linear components with few enough inputs that they can also be optimized before continuing. In the case of AES, after the non-linear portions of the circuit are optimized, as expected, a bird’s-eye view of the resulting circuit reveals large linear connected components. In fact, from a cryptanalyst’s point of view, the topology of the resulting circuit is potentially of interest: the S-box of AES consists of an initial linear expansion <span class="math">U</span> from 8 to 22 bits, followed by a non-linear contraction <span class="math">F</span> from 22 to 18 bits, and ending with a linear contraction <span class="math">B</span> from 18 to 8 bits. The <span class="math">U</span> and <span class="math">B</span> matrices are given in Appendix A. AES’s S-box is <span class="math">S(\\mathbf{x})=B\\cdot F(U\\cdot\\mathbf{x})+[11000110]^{T}</span>, where <span class="math">\\cdot</span> is matrix multiplication and <span class="math">\\mathbf{x}</span> is the 8-bit S-box input. We do not know if there are any cryptanalytic implications to the structure of these matrices. The first row and last columns of <span class="math">U</span> should raise an eyebrow, as should the <span class="math">12^{th}</span> and the last three columns of <span class="math">B</span>. Note that the initial linear expansion and the linear contraction were defined to contain as much of the circuit as possible while still being linear. Thus, the portion of the circuit defined by <span class="math">U</span>, for example, overlaps with the <span class="math">GF(2^{8})</span> inversion. The next step was to minimize the circuits for computing <span class="math">U</span> and <span class="math">B</span>.</p>

    <h2 id="sec-6" class="text-2xl font-bold">4 Minimizing linear components</h2>

    <p class="text-gray-300">Gate optimization of circuits for linear functions has been extensively studied. It has been shown that the problem of linear-circuit optimization is NP-hard <em>[1]</em>. That paper further shows that unless P=NP, this problem does not even have efficient <span class="math">\\epsilon</span>-approximation schemes. Thus, our goal in this research is restricted to improving on known heuristics. As far as we know, the most successful heuristics are variations on a greedy algorithm due to Paar <em>[9]</em>. We report significant improvements over the latter methods.</p>

    <p class="text-gray-300">A linear straight-line program over a field <span class="math">F</span> is a variation on a straight-line program which does not allow multiplication of variables.</p>

    <p class="text-gray-300">That is, every line of the program is of the form <span class="math">u:=\\lambda v+\\mu w</span> where <span class="math">\\lambda,\\mu</span> are in <span class="math">F</span> and <span class="math">v,w</span> are variables. Constructing a linear circuit for a given function <span class="math">f</span> is equivalent to constructing a linear straight-line program over GF(2) which computes <span class="math">f</span>. (Note that, over GF(2) <span class="math">\\lambda</span>, and <span class="math">\\mu</span> are always 1 and thus are never written explicitly.)</p>

    <p class="text-gray-300">A linear straight-line program over GF(2) is said to be cancellation-free if, for every line of the program <span class="math">u:=v+w</span>, none of the variables in the expression for <span class="math">v</span> are also present in the expression for <span class="math">w</span>, i.e., there is no cancellation of variables in the computation.</p>

    <p class="text-gray-300">Previous work on circuit minimization for AES S-boxes (e.g. <em>[8, 10, 4]</em>) only consider cancellation-free straight-line programs for producing a set of linear forms over GF(2). Some authors appear to make the incorrect assumption that there always exists a cancellation-free optimal linear program over GF(2). A small counter-example showing this is not the case is the following:</p>

    <p class="text-gray-300"><span class="math">x_{1}+x_{2};x_{1}+x_{2}+x_{3};x_{1}+x_{2}+x_{3}+x_{4};x_{2}+x_{3}+x_{4}.</span></p>

    <p class="text-gray-300">It is not hard (although somewhat tedious) to see that the optimum cancellation-free straight-line program has length 5. A solution of length 4 which allows cancellations is</p>

    <p class="text-gray-300"><span class="math">v_{1}=x_{1}+x_{2};v_{2}=v_{1}+x_{3};v_{3}=v_{2}+x_{4};v_{4}=v_{3}+x_{1}.</span></p>

    <p class="text-gray-300">In <em>[1]</em>, we show that any algorithm for computing linear programs that is restricted to cancellation-free programs is at most <span class="math">\\frac{3}{2}</span>-approximating. Thus, even optimal cancellation-free circuits can be far from optimal in the unrestricted model. The heuristic we present below is not restricted to producing cancellation-free circuits. Furthermore, there appears to be little reason for restricting the search to cancellation-free circuits, as we have shown that finding an optimal cancellation-free circuit is NP-hard (<em>[1]</em>).</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">A new heuristic</h4>

    <p class="text-gray-300">Let <span class="math">S</span> be a set of linear functions. For any linear predicate <span class="math">f</span>, we define the distance <span class="math">\\delta(S,f)</span> as the minimum number of additions of elements from <span class="math">S</span> necessary to obtain <span class="math">f</span>.</p>

    <p class="text-gray-300">The problem is to find a short linear program that computes <span class="math">f(\\mathbf{x})=M\\mathbf{x}</span> where <span class="math">M</span> is an <span class="math">m\\times n</span> matrix over GF(2). The heuristic is as follows. We keep a “base” <span class="math">S</span> of “known” functions. Initially <span class="math">S</span> is just the set of variables <span class="math">x_{1},\\ldots,x_{n}</span>. We maintain the vector <span class="math">Dist[]</span> of distances from <span class="math">S</span> to the linear functions given by the rows of <span class="math">M</span>. That is, <span class="math">Dist[i]=\\delta(S,f_{i})</span> where <span class="math">f_{i}</span> is the <span class="math">i^{th}</span> row of <span class="math">M</span> multiplied by the input vector <span class="math">\\mathbf{x}</span>. Initially, <span class="math">Dist[i]</span> is just one less than the Hamming weight of row <span class="math">i</span>. We then perform the following loop</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>pick a new base element by adding two existing base elements;</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>update <span class="math">Dist[]</span>;</li>

    </ul>

    <p class="text-gray-300">until <span class="math">Dist[i]=0</span> for all <span class="math">i</span>.</p>

    <p class="text-gray-300">The current criterion for picking the new base element is</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>pick one that minimizes the sum of new distances;</li>

      <li>resolve ties by maximizing the Euclidean norm of the vector of new distances.</li>

    </ul>

    <p class="text-gray-300">This tie resolution criterion, which we term “Norm”, may seem counter-intuitive. The basic idea is that we prefer a distance vector like 0,0,3,1 to one like 1,1,1,1. In the latter case, we would need 4 more gates to finish. In the former, 3 might do it.</p>

    <p class="text-gray-300">The bulk of the time of the heuristic is spent on picking the new base element. Our experiments show that the following “pre-emptive” choice usually improves running time without increasing the size of the output circuit:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if any two bases <span class="math">S[i],S[j]</span> are such that <span class="math">S[i]\\oplus S[j]</span> is a row in <span class="math">M</span>, then pick this sum as the new base element.</li>

    </ul>

    <p class="text-gray-300">The tie resolution criterion is a critical part of the heuristic. It does well on most matrices we have tried, but we have found specific matrices for which other decision rules do better. Intuitively, no one simple rule should work for all matrices. The effectiveness of the heuristic most likely depends on the topology of the digraph represented by the input matrix. We have not pursued this line of inquiry. We have, however tested our heuristic with various tie resolution methods against Paar’s algorithm <em>[9]</em>. On random matrices, our heuristic gives significant improvements under Norm as well as under three other tie-breaking rules (see Section 6 and Appendix B).</p>

    <p class="text-gray-300">The distance vector in our heuristics is computed by exhaustive search. The reason the heuristic is practical for moderate-size matrices is that the distance can only decrease. In fact, it can only decrease by 1. So when a new base is being considered, if a distance is <span class="math">d</span>, then only combinations of exactly <span class="math">d-1</span> old base elements and the new base element need to be considered.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">A small example using the heuristic</h4>

    <p class="text-gray-300">Suppose we need a circuit that computes the following system of equations.</p>

    <p class="text-gray-300"><span class="math">y_{0}=x_{0}+x_{1}+x_{2}</span> <span class="math">y_{1}=x_{1}+x_{3}+x_{4}</span> <span class="math">y_{2}=x_{0}+x_{2}+x_{3}+x_{4}</span> <span class="math">y_{3}=x_{1}+x_{2}+x_{3}</span> <span class="math">y_{4}=x_{0}+x_{1}+x_{3}</span> <span class="math">y_{5}=x_{1}+x_{2}+x_{3}+x_{4}</span></p>

    <p class="text-gray-300">Equivalently, we need a circuit for multiplication by the following <span class="math">6\\times 5</span> matrix</p>

    <p class="text-gray-300">\\[ M=\\begin{bmatrix}1\\ 1\\ 1\\ 0\\ 0\\\\ 0\\ 1\\ 0\\ 1\\ 1\\\\ 1\\ 0\\ 1\\ 1\\ 1\\\\ 0\\ 1\\ 1\\ 1\\ 0\\\\ 1\\ 1\\ 0\\ 1\\ 0\\\\ 0\\ 1\\ 1\\ 1\\ 1\\end{bmatrix} \\]</p>

    <p class="text-gray-300">The target signals to be computed are simply the rows of <span class="math">M</span>. The initial base is <span class="math">\\{x_{0},x_{1},x_{2},x_{3},x_{4}\\}</span>, which corresponds to</p>

    <p class="text-gray-300"><span class="math">S=\\{\\left[\\left.1\\ 0\\ 0\\ 0\\ 0\\right.\\right],\\left[\\left.0\\ 1\\ 0\\ 0\\ 0\\right.\\right],\\left[\\left.0\\ 0\\ 1\\ 0\\ 0\\right.\\right],</span> <span class="math">\\left[\\left.0\\ 0\\ 0\\ 1\\ 0\\right.\\right],\\left[\\left.0\\ 0\\ 0\\ 0\\ 1\\right.\\right]\\}</span></p>

    <p class="text-gray-300">The initial distance vector is</p>

    <p class="text-gray-300"><span class="math">D=\\left[\\left.2\\ 2\\ 3\\ 2\\ 2\\ 3\\right.\\right]</span></p>

    <p class="text-gray-300">The heuristic must find two base vectors whose sum, when added to the base, minimizes the sum of the new distances. It turns out the right choice is to calculate <span class="math">x_{1}+x_{3}</span>. So the new base <span class="math">S</span> is expanded to contain the signal</p>

    <p class="text-gray-300"><span class="math">\\left[\\left.0\\ 1\\ 0\\ 1\\ 0\\right.\\right]\\quad=\\quad\\left[\\left.0\\ 1\\ 0\\ 0\\ 0\\right.\\right]\\quad+\\quad\\left[\\left.0\\ 0\\ 0\\ 1\\ 0\\right.\\right]</span></p>

    <p class="text-gray-300">The new distance vector is</p>

    <p class="text-gray-300"><span class="math">D=\\left[\\left.2\\ 1\\ 3\\ 1\\ 1\\ 2\\right.\\right]</span></p>

    <p class="text-gray-300">The full run of the program is below. The tie breaking criteria is used in Step 2. If one had chosen <span class="math">x_{1}+x_{2}</span> instead of <span class="math">x_{0}+t_{5}</span>, the new distance vector would be <span class="math">\\left[\\left.1\\ \\ 1\\ \\ 3\\ \\ 1\\ \\ 1\\ \\ 2\\right.\\right]</span>, which has norm <span class="math">\\sqrt{17}</span>, while the one found has norm <span class="math">\\sqrt{19}</span>. Note that there is cancellation in the last step.</p>

    <p class="text-gray-300">Step 1 : <span class="math">t_{5}=x_{1}+x_{3}</span>. New D : <span class="math">\\left[\\left.2\\ 1\\ 3\\ 1\\ 1\\ 2\\right.\\right]</span>. Step 2 : <span class="math">t_{6}=x_{0}+t_{5}</span> (found target signal <span class="math">y_{4}=\\left[\\left.1\\ 1\\ 0\\ 1\\ 0\\right.\\right]</span>). New D : <span class="math">\\left[\\left.2\\ 1\\ 3\\ 1\\ 0\\ 2\\right.\\right]</span>. Step 3 : <span class="math">t_{7}=x_{2}+t_{5}</span> (found target signal <span class="math">y_{3}=\\left[\\left.0\\ 1\\ 1\\ 1\\ 0\\right.\\right]</span>). New D : <span class="math">\\left[\\left.2\\ 1\\ 3\\ 0\\ 0\\ 1\\right.\\right]</span>. Step 4 : <span class="math">t_{8}=x_{4}+t_{5}</span> (found target signal <span class="math">y_{1}=\\left[\\left.0\\ 1\\ 0\\ 1\\ 1\\right.\\right]</span>). New D : <span class="math">\\left[\\left.2\\ 0\\ 3\\ 0\\ 0\\ 1\\right.\\right]</span>. Step 5 : <span class="math">t_{9}=x_{2}+t_{8}</span> (found target signal <span class="math">y_{5}=\\left[\\left.0\\ 1\\ 1\\ 1\\ 1\\right.\\right]</span>). New D : <span class="math">\\left[\\left.2\\ 0\\ 2\\ 0\\ 0\\ 0\\right.\\right]</span>. Step 6 : <span class="math">t_{10}=x_{0}+x_{1}</span>. New D : <span class="math">\\left[\\left.1\\ 0\\ 1\\ 0\\ 0\\ 0\\right.\\right]</span>. Step 7 : <span class="math">t_{11}=x_{2}+t_{10}</span> (found target signal <span class="math">y_{0}=\\left[\\left.1\\ 1\\ 1\\ 0\\ 0\\right.\\right]</span>) . New D : <span class="math">\\left[\\left.0\\ 0\\ 1\\ 0\\ 0\\ 0\\right.\\right]</span>. Step 8 : <span class="math">t_{12}=t_{8}+t_{11}</span> (found target signal <span class="math">y_{2}=\\left[\\left.1\\ 0\\ 1\\ 1\\ 1\\right.\\right]</span>). New D : <span class="math">\\left[\\left.0\\ 0\\ 0\\ 0\\ 0\\ 0\\right.\\right]</span>. (DONE!)</p>

    <p class="text-gray-300">5 A circuit for the S-box of AES</p>

    <p class="text-gray-300">Our techniques yield a circuit for the AES S-box composed of three parts: a “top” linear transformation; a middle non-linear part; and a “bottom” linear transformation. The linear transformations are defined by the matrices U and B of Appendix A.</p>

    <p class="text-gray-300">For matrix <span class="math">U</span>, the smallest circuits we found had 23 <span class="math">\\oplus</span> gates. Among the many such circuits, the shortest ones have depth 7. It is worthwhile to note that if 24 <span class="math">\\oplus</span> gates are allowed, circuits with depth 4 exist for <span class="math">U</span>. Figure 2 in Appendix C shows a circuit of size 23 and depth 7. The circuit maps inputs <span class="math">x_{0}\\ldots x_{7}</span> to outputs <span class="math">x_{7},y_{1}\\ldots y_{21}</span>.</p>

    <p class="text-gray-300">Figure 3 in Appendix C shows the non-linear middle part of the S-box circuit. It is a function from 22 to 18 bits. The circuit contains 32 <span class="math">\\wedge</span> gates and 32 <span class="math">\\oplus</span> gates. It maps inputs <span class="math">x_{7},y_{1}\\ldots y_{21}</span> to outputs <span class="math">z_{0}\\ldots z_{17}</span>.</p>

    <p class="text-gray-300">For matrix <span class="math">B</span>, the randomized version of our heuristic yields many circuits with 30 <span class="math">\\oplus</span> gates. The heuristic is fast enough that we are able to pick a circuit which is both small and short. Figure 4 in Appendix C shows a circuit of depth 6. The circuit maps inputs <span class="math">z_{0}\\ldots z_{17}</span> to outputs <span class="math">s_{0}\\ldots s_{7}</span>.</p>

    <h2 id="sec-9" class="text-2xl font-bold">6 Experiments with different tie-breaking methods</h2>

    <p class="text-gray-300">In order to compare the effects of using different tie-breakers, we tested our heuristics on matrices generated as follows</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We first chose a size (for example, <span class="math">10\\times 20</span> matrices, which represent 10 linear forms on 20 distinct variables);</li>

      <li>We then picked a bias <span class="math">\\rho</span> between 0 and 1;</li>

      <li>For each entry of the matrix, we set the bit to 1 with probability <span class="math">\\rho</span> and to 0 with probability <span class="math">1-\\rho</span>. Thus <span class="math">\\rho</span> is the expected fraction of variables that appears in each linear form.</li>

      <li>Matrices with rows which are all zeros were discarded, as were matrices containing duplicate rows.</li>

    </ul>

    <p class="text-gray-300">The testing was performed with a C++ program, compiled with g++ -O3, on a quadcore x86_64, running Ubuntu 9.10, with Intel Xenon 5150 processors running at 2.66 GHz, with 8 GB memory. There were no other users on the machine. We compared the different heuristics on sets of one hundred random matrices with different sizes and densities. The experiment showed that the heuristics were slower when the bias was larger. This was expected, since the initial “distances” (number of operations on the base vectors to obtain the target vectors) were then larger on average when there were more ones in the matrices.</p>

    <p class="text-gray-300">The tie-breakers we compared were the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Norm: maximizing the Euclidean norm</li>

      <li>Norm-largest: maximizing the square of the Euclidean norm minus the largest distance</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Norm-diff: maximizing the square of the Euclidean norm minus the difference of the largest two distances</li>

      <li>Random: In processing the possible new base vectors, if the current possible new base vector has the same sum of distances as the previous best (current choice), then flip an unbiased coin. If heads, then keep the current choice. If tails, then apply the Norm criterion. This heuristic may end up choosing a pair with non-maximum Euclidean norm. On the other hand, it allows substitution of one optimum (by sum-of-distances and Euclidean norm) pair by another found later in the search.</li>

    </ul>

    <p class="text-gray-300">In all cases, except the “Random” one, when there were still ties after applying the “tie-breaker”, the first pair with both the minimum sum of distances and the optimal value for the tie-breaker was chosen. This was the base pair with lexicographically minimum indices <span class="math">(i,j)</span>. Randomized tie-breaking allows running the heuristic several times and picking the best result. In our tests we ran the heuristic with “Random” tie-breaking three times.</p>

    <p class="text-gray-300">We also compared these heuristics to Paar’s heuristic <em>[9]</em> on the same matrices. Paar’s heuristic repeatedly finds the most frequently occurring base pair and adds that as the next base pair. It is significantly faster than our heuristic, but it produces only cancellation-free circuits. Its performance, relative to the heuristics proposed here, decreases as the bias increases, using more than 30% extra gates when the bias is 3/4 (when the number of rows is at least 15) and 40% extra when the bias is 9/10.</p>

    <p class="text-gray-300">Among the biases tried, the number of gates in the circuits found by our heuristics is similar with biases 1/2 and 3/4. It is not a strictly increasing function of the bias, since when nearly all of the variables are used in nearly all of the forms, the outputs from many of the gates can be reused for many targets. Thus, circuits with fewer gates were found when the bias was 9/10 than when it was 1/2 or 3/4. This was also true for Paar’s heuristic, but less dramatically so.</p>

    <p class="text-gray-300">All the tie resolution criteria performed fairly similarly, producing circuits of nearly the same size, with Random apparently doing slightly better (more often producing smaller circuits), presumably because it tries three different circuits and uses the best. Random also runs for about three times as long as the others. The results of these tests are presented in tables in Appendix B. In the tables, the column headings specify the matrix size and the bias. For each heuristic, and all matrix sizes and biases, 100 randomly chosen matrices were tested.</p>

    <p class="text-gray-300">For each tie-breaker rule and Paar’s heuristic, for each matrix size and bias, the average number of gates in the circuits found and the number of matrices where that heuristic did not obtain the minimum value of all of the heuristics is given, along with the running time in seconds. Note that this means the Paar heuristic was beaten by at least one of the other heuristics on all 700 matrices except for 17 of the 100 with bias 1/4 (and</p>

    <p class="text-gray-300">there was only one matrix on which Paar’s heuristic beat any of the other heuristics). In fact, for the tests with bias larger than 1/4, Paar’s heuristic did worse than any of the other heuristic on every one of the matrices; usually the values obtained for the newer heuristics were similar, with Random possibly being marginally better, but with the value for Paar’s heuristic being significantly larger.</p>

    <p class="text-gray-300">Paar’s heuristic (and, for matrices between size 4 and 10, a variant which does at most one gate better on average in the data presented) was tested <em>[9]</em> on square matrices of sizes <span class="math">4\\times 4</span> through <span class="math">16\\times 16</span> and the average number of XOR gates is presented, along with the relative improvement over the straightforward implementation. These square matrices came from applying Mastrovito’s <em>[7]</em> matrix description of multiplication in <span class="math">GF(2^{n})</span> to constant multiplication. Paar tries all possible constants in <span class="math">GF(2^{n})</span> for <span class="math">n</span> between 4 and 16, giving these square matrices. Since our heuristics are so much slower and the matrices in the cryptographic applications we are interested in do not necessarily have this form, we have not tested on all of these restriced matrices of those sizes, but rather on random matrices with different biases. For <span class="math">15\\times 15</span> matrices, Paar gets an average of 52.9 gates. This is similar to our results for Paar’s algorithm with <span class="math">15\\times 15</span> matrices with biases 1/2 and 3/4, where the Paar heuristic gets averages of 51.7 and 53.3 gates, respectively. For bias 1/2, our deterministic heuristics get average gate counts between 44.21 and 44.28, while Random gets 43.81. For bias 3/4, our deterministic heuristics all get average count 40.82, while Random gets 40.38. Thus, our relative improvement over the Paar heuristic is between 17% and 32% for these types of matrices. Paar’s result of 52.9 gates for <span class="math">15\\times 15</span> matrices is a relative improvement of 45.5% over the straightforward approach.</p>

    <p class="text-gray-300">The last row in each table in Appendix B shows the sums of the values which are the minimum of those calculated by the different heuristics for each matrix. This shows that for each of the tie-breakers, there are cases where it gets a worse result than at least one of the others.</p>

    <h2 id="sec-10" class="text-2xl font-bold">7 Conclusions and work in progress</h2>

    <p class="text-gray-300">We tested new techniques for decreasing circuit size. The techniques were applied to the extensively studied AES S-box. We obtained the smallest circuit yet constructed for this function. The circuit contains 32 AND gates and 83 XOR/XNOR gates for a total of 115 gates. As by-products of the experiment we obtained very small circuits for inversion in <span class="math">GF(2^{4})</span> and <span class="math">GF(2^{8})</span>.</p>

    <p class="text-gray-300">The experiments with linear circuit optimization indicate that our techniques are likely to be superior to previous techniques which produced only cancellation-free circuits. We expect this to be particularly useful for cryptographic applications where many XOR operations are used, along with some AND operations to introduce nonlinearity.</p>

    <p class="text-gray-300">Along with the many implications of our experiments, our results lead us to question the common wisdom that multiplication in <span class="math">GF(2^{n})</span> using Mastrovito Multipliers requires about <span class="math">n^{2}</span> additions and <span class="math">n^{2}</span> multiplications (see, for example, <em>[11]</em>). In future work we intend to re-examine this body of work.</p>

    <p class="text-gray-300">It would be interesting to determine how close to optimal the circuits found by these techniques usually are and how much better they are than the optimal cancellation-free circuits. Finding even better techniques which are not restricted to finding cancellation-free circuits would also be very interesting.</p>

    <h2 id="sec-11" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] J. Boyar, P. Matthews, and R. Peralta. On the shortest linear straight-line program for computing linear forms. In Mathematical Foundations of Computer Science, volume 5162 of Lecture Notes in Computer Science, pages 168–179, 2008.</li>

      <li>[2] J. Boyar and R. Peralta. Tight bounds for the multiplicative complexity of symmetric functions. Theoretical Computer Science, 396(1-3):223–246, 2008.</li>

      <li>[3] J. Boyar and R. Peralta. Patent application number 61089998 filed with the U.S. Patent and Trademark Office. A new technique for combinational circuit optimization and a new circuit for the S-Box for AES, 2009.</li>

      <li>[4] D. Canright. A very compact Rijndael S-box. Technical Report NPS-MA-05-001, Naval Postgraduate School, 2005.</li>

      <li>[5] FIPS. Advanced Encryption Standard (AES). National Institute of Standards and Technology, 2001.</li>

      <li>[6] T. Itoh and S. Tsujii. A fast algorithm for computing multiplicative inverses in <span class="math">GF(2^{m})</span> using normal bases. Inf. Comput., 78(3):171–177, 1988.</li>

      <li>[7] E. Mastrovito. VLSI architectures for computation in Galois fields. PhD thesis, Linköping University, Dept. Electr. Eng., Sweden, 1991.</li>

      <li>[8] C. Paar. Some remarks on efficient inversion in finite fields, 1995. In 1995 IEEE International Symposium on Information Theory, page 58, Whistler, B.C. Canada.</li>

      <li>[9] C. Paar. Optimized arithmetic for Reed-Solomon encoders. In IEEE International Symposium on Information Theory, page 250, 1997.</li>

      <li>[10] A. Satoh, S. Morioka, K. Takano, and S. Munetoh. A compact Rijndael hardware architecture with S-Box optimization. In Advances in Cryptology - Proceedings of ASIACRYPT 01, volume 2248 of Lecture Notes in Computer Science, pages 239–254. Springer-Verlag, 2001.</li>

      <li>[11] B. Sunar and Ç. K. Koç. Mastrovito multiplier for all trinomials. IEEE Trans. Comput., 48(5):522–527, 1999.</li>

    </ul>

    <p class="text-gray-300">Appendix A: The matrices  <span class="math">U</span>  and  <span class="math">B</span>  for the top and bottom linear parts of the AES S-box</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 0 0 0 0 0 0 1</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  0 1 1 0 0 0 0 1  |</p>

    <p class="text-gray-300">|   |  1 1 1 0 0 0 0 1  |</p>

    <p class="text-gray-300">|   |  1 1 1 0 0 1 1 1  |</p>

    <p class="text-gray-300">|   |  0 1 1 1 0 0 0 1  |</p>

    <p class="text-gray-300">|   |  0 1 1 0 0 0 1 1  |</p>

    <p class="text-gray-300">|   |  1 0 0 1 1 0 1 1  |</p>

    <p class="text-gray-300">|   |  0 1 0 0 1 1 1 1  |</p>

    <p class="text-gray-300">|   |  1 0 0 0 0 1 0 0  |</p>

    <p class="text-gray-300">|   |  1 0 0 1 0 0 0 0  |</p>

    <p class="text-gray-300">|   |  1 1 1 1 1 0 1 0  |</p>

    <p class="text-gray-300">|   |  0 1 0 0 1 1 1 0  |</p>

    <p class="text-gray-300">|   |  1 0 0 1 0 1 1 0  |</p>

    <p class="text-gray-300">|   |  1 0 0 0 0 0 1 0  |</p>

    <p class="text-gray-300">|   |  0 0 0 1 0 1 0 0  |</p>

    <p class="text-gray-300">|   |  1 0 0 1 1 0 1 0  |</p>

    <p class="text-gray-300">|   |  0 0 1 0 1 1 1 0  |</p>

    <p class="text-gray-300">|   |  1 0 1 1 0 1 0 0  |</p>

    <p class="text-gray-300">|   |  1 0 1 0 1 1 1 0  |</p>

    <p class="text-gray-300">|   |  0 1 1 1 1 1 1 0  |</p>

    <p class="text-gray-300">|  1 1 0 1 1 1 1 0  |   |</p>

    <div class="my-4 text-center"><span class="math-block">B = \\left[ \\begin{array}{l l l l l l l l l} 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 \\\\ 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 \\\\ 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 \\\\ 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 \\\\ 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 \\\\ 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\end{array} \\right]</span></div>

    <p class="text-gray-300">Appendix B: Experimental results on samples of 100 random matrices</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">15 × 15 matrices, Bias=1/4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">15 × 15 matrices, Bias=1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Heuristic</td>

            <td class="px-3 py-2 border-b border-gray-700">Average</td>

            <td class="px-3 py-2 border-b border-gray-700">Not min</td>

            <td class="px-3 py-2 border-b border-gray-700">Seconds</td>

            <td class="px-3 py-2 border-b border-gray-700">Average</td>

            <td class="px-3 py-2 border-b border-gray-700">Not min</td>

            <td class="px-3 py-2 border-b border-gray-700">Seconds</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Norm</td>

            <td class="px-3 py-2 border-b border-gray-700">29.65</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">44.21</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">125</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Norm-largest</td>

            <td class="px-3 py-2 border-b border-gray-700">29.63</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">44.23</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">121</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Norm-diff</td>

            <td class="px-3 py-2 border-b border-gray-700">29.65</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">44.28</td>

            <td class="px-3 py-2 border-b border-gray-700">51</td>

            <td class="px-3 py-2 border-b border-gray-700">119</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Random</td>

            <td class="px-3 py-2 border-b border-gray-700">29.59</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">43.81</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">322</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Paar</td>

            <td class="px-3 py-2 border-b border-gray-700">31.07</td>

            <td class="px-3 py-2 border-b border-gray-700">83</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">51.70</td>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Minimum</td>

            <td class="px-3 py-2 border-b border-gray-700">29.48</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">43.50</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">15 × 15 matrices, Bias=3/4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">15 × 15 matrices, Bias=9/10</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Heuristic</td>

            <td class="px-3 py-2 border-b border-gray-700">Average</td>

            <td class="px-3 py-2 border-b border-gray-700">Not min</td>

            <td class="px-3 py-2 border-b border-gray-700">Seconds</td>

            <td class="px-3 py-2 border-b border-gray-700">Average</td>

            <td class="px-3 py-2 border-b border-gray-700">Not min</td>

            <td class="px-3 py-2 border-b border-gray-700">Seconds</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Norm</td>

            <td class="px-3 py-2 border-b border-gray-700">40.82</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">291</td>

            <td class="px-3 py-2 border-b border-gray-700">30.28</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">388</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Norm-largest</td>

            <td class="px-3 py-2 border-b border-gray-700">40.82</td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

            <td class="px-3 py-2 border-b border-gray-700">290</td>

            <td class="px-3 py-2 border-b border-gray-700">30.28</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">428</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Norm-diff</td>

            <td class="px-3 py-2 border-b border-gray-700">40.82</td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

            <td class="px-3 py-2 border-b border-gray-700">292</td>

            <td class="px-3 py-2 border-b border-gray-700">30.29</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">388</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Random</td>

            <td class="px-3 py-2 border-b border-gray-700">40.39</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">838</td>

            <td class="px-3 py-2 border-b border-gray-700">30.01</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">1145</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Paar</td>

            <td class="px-3 py-2 border-b border-gray-700">53.27</td>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">0.03</td>

            <td class="px-3 py-2 border-b border-gray-700">43.11</td>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Minimum</td>

            <td class="px-3 py-2 border-b border-gray-700">40.11</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">29.86</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | 20 × 20 matrices, Bias=3/4  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Norm</td>

            <td class="px-3 py-2 border-b border-gray-700">67.47</td>

            <td class="px-3 py-2 border-b border-gray-700">62</td>

            <td class="px-3 py-2 border-b border-gray-700">86,465</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Norm-largest</td>

            <td class="px-3 py-2 border-b border-gray-700">67.43</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">82,597</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Norm-diff</td>

            <td class="px-3 py-2 border-b border-gray-700">67.40</td>

            <td class="px-3 py-2 border-b border-gray-700">58</td>

            <td class="px-3 py-2 border-b border-gray-700">82,780</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Random</td>

            <td class="px-3 py-2 border-b border-gray-700">66.87</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">234,815</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Paar</td>

            <td class="px-3 py-2 border-b border-gray-700">90.86</td>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">0.11</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Minimum</td>

            <td class="px-3 py-2 border-b border-gray-700">66.43</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20 × 10 matrices, Bias=3/4</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">10 × 20 matrices, Bias=3/4</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Heuristic</td>

            <td class="px-3 py-2 border-b border-gray-700">Average</td>

            <td class="px-3 py-2 border-b border-gray-700">Not min</td>

            <td class="px-3 py-2 border-b border-gray-700">Seconds</td>

            <td class="px-3 py-2 border-b border-gray-700">Average</td>

            <td class="px-3 py-2 border-b border-gray-700">Not min</td>

            <td class="px-3 py-2 border-b border-gray-700">Seconds</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Norm</td>

            <td class="px-3 py-2 border-b border-gray-700">31.44</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">1.35</td>

            <td class="px-3 py-2 border-b border-gray-700">42.04</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">30,626</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Norm-largest</td>

            <td class="px-3 py-2 border-b border-gray-700">31.43</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">1.38</td>

            <td class="px-3 py-2 border-b border-gray-700">42.08</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">30,490</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Norm-diff</td>

            <td class="px-3 py-2 border-b border-gray-700">31.44</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">1.34</td>

            <td class="px-3 py-2 border-b border-gray-700">42.12</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">30,740</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Random</td>

            <td class="px-3 py-2 border-b border-gray-700">31.23</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">4.08</td>

            <td class="px-3 py-2 border-b border-gray-700">41.76</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">84,540</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Paar</td>

            <td class="px-3 py-2 border-b border-gray-700">43.32</td>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02</td>

            <td class="px-3 py-2 border-b border-gray-700">50.02</td>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Minimum</td>

            <td class="px-3 py-2 border-b border-gray-700">31.12</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">41.50</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y14 = x3 + x5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y13 = x0 + x6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y9 = x0 + x3</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y8 = x0 + x5</td>

            <td class="px-3 py-2 border-b border-gray-700">t0 = x1 + x2</td>

            <td class="px-3 py-2 border-b border-gray-700">y1 = t0 + x7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y4 = y1 + x3</td>

            <td class="px-3 py-2 border-b border-gray-700">y12 = y13 + y14</td>

            <td class="px-3 py-2 border-b border-gray-700">y2 = y1 + x0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y5 = y1 + x6</td>

            <td class="px-3 py-2 border-b border-gray-700">y3 = y5 + y8</td>

            <td class="px-3 py-2 border-b border-gray-700">t1 = x4 + y12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y15 = t1 + x5</td>

            <td class="px-3 py-2 border-b border-gray-700">y20 = t1 + x1</td>

            <td class="px-3 py-2 border-b border-gray-700">y6 = y15 + x7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y10 = y15 + t0</td>

            <td class="px-3 py-2 border-b border-gray-700">y11 = y20 + y9</td>

            <td class="px-3 py-2 border-b border-gray-700">y7 = x7 + y11</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y17 = y10 + y11</td>

            <td class="px-3 py-2 border-b border-gray-700">y19 = y10 + y8</td>

            <td class="px-3 py-2 border-b border-gray-700">y16 = t0 + y11</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y21 = y13 + y16</td>

            <td class="px-3 py-2 border-b border-gray-700">y18 = x0 + y16</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 2. Top linear transformation: Inputs are  <span class="math">x_0, x_1, \\ldots, x_7</span> . Outputs to the next level are  <span class="math">x_7, y_1, y_2, \\ldots, y_{21}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t2 = y12 × y15</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t3 = y3 × y6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t4 = t3 + t2</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t5 = y4 × x7</td>

            <td class="px-3 py-2 border-b border-gray-700">t6 = t5 + t2</td>

            <td class="px-3 py-2 border-b border-gray-700">t7 = y13 × y16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t8 = y5 × y1</td>

            <td class="px-3 py-2 border-b border-gray-700">t9 = t8 + t7</td>

            <td class="px-3 py-2 border-b border-gray-700">t10 = y2 × y7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t11 = t10 + t7</td>

            <td class="px-3 py-2 border-b border-gray-700">t12 = y9 × y11</td>

            <td class="px-3 py-2 border-b border-gray-700">t13 = y14 × y17</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t14 = t13 + t12</td>

            <td class="px-3 py-2 border-b border-gray-700">t15 = y8 × y10</td>

            <td class="px-3 py-2 border-b border-gray-700">t16 = t15 + t12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t17 = t4 + t14</td>

            <td class="px-3 py-2 border-b border-gray-700">t18 = t6 + t16</td>

            <td class="px-3 py-2 border-b border-gray-700">t19 = t9 + t14</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t20 = t11 + t16</td>

            <td class="px-3 py-2 border-b border-gray-700">t21 = t17 + y20</td>

            <td class="px-3 py-2 border-b border-gray-700">t22 = t18 + y19</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t23 = t19 + y21</td>

            <td class="px-3 py-2 border-b border-gray-700">t24 = t20 + y18</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t25 = t21 + t22</td>

            <td class="px-3 py-2 border-b border-gray-700">t26 = t21 × t23</td>

            <td class="px-3 py-2 border-b border-gray-700">t27 = t24 + t26</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t28 = t25 × t27</td>

            <td class="px-3 py-2 border-b border-gray-700">t29 = t28 + t22</td>

            <td class="px-3 py-2 border-b border-gray-700">t30 = t23 + t24</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t31 = t22 + t26</td>

            <td class="px-3 py-2 border-b border-gray-700">t32 = t31 × t30</td>

            <td class="px-3 py-2 border-b border-gray-700">t33 = t32 + t24</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t34 = t23 + t33</td>

            <td class="px-3 py-2 border-b border-gray-700">t35 = t27 + t33</td>

            <td class="px-3 py-2 border-b border-gray-700">t36 = t24 × t35</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t37 = t36 + t34</td>

            <td class="px-3 py-2 border-b border-gray-700">t38 = t27 + t36</td>

            <td class="px-3 py-2 border-b border-gray-700">t39 = t29 × t38</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  t40 = t25 + t39 |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t41 = t40 + t37</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t42 = t29 + t33</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t43 = t29 + t40</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z1 = t37 × y6</td>

            <td class="px-3 py-2 border-b border-gray-700">z2 = t33 × x7</td>

            <td class="px-3 py-2 border-b border-gray-700">z3 = t43 × y16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z4 = t40 × y1</td>

            <td class="px-3 py-2 border-b border-gray-700">z5 = t29 × y7</td>

            <td class="px-3 py-2 border-b border-gray-700">z6 = t42 × y11</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z7 = t45 × y17</td>

            <td class="px-3 py-2 border-b border-gray-700">z8 = t41 × y10</td>

            <td class="px-3 py-2 border-b border-gray-700">z9 = t44 × y12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z10 = t37 × y3</td>

            <td class="px-3 py-2 border-b border-gray-700">z11 = t33 × y4</td>

            <td class="px-3 py-2 border-b border-gray-700">z12 = t43 × y13</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z13 = t40 × y5</td>

            <td class="px-3 py-2 border-b border-gray-700">z14 = t29 × y2</td>

            <td class="px-3 py-2 border-b border-gray-700">z15 = t42 × y9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z16 = t45 × y14</td>

            <td class="px-3 py-2 border-b border-gray-700">z17 = t41 × y8</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 3. The middle non-linear section: Inputs are  <span class="math">x_7, y_1, y_2, \\ldots, y_{21}</span> . Outputs to the next level are  <span class="math">z_0, z_1, \\ldots, z_{17}</span> . Note that the computation of  <span class="math">t_{25}</span>  through  <span class="math">t_{40}</span>  is the inversion in  <span class="math">GF(2^4)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t46 = z15 + z16</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t47 = z10 + z11</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t48 = z5 + z13</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t49 = z9 + z10</td>

            <td class="px-3 py-2 border-b border-gray-700">t50 = z2 + z12</td>

            <td class="px-3 py-2 border-b border-gray-700">t51 = z2 + z5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t52 = z7 + z8</td>

            <td class="px-3 py-2 border-b border-gray-700">t53 = z0 + z3</td>

            <td class="px-3 py-2 border-b border-gray-700">t54 = z6 + z7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t55 = z16 + z17</td>

            <td class="px-3 py-2 border-b border-gray-700">t56 = z12 + t48</td>

            <td class="px-3 py-2 border-b border-gray-700">t57 = t50 + t53</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t58 = z4 + t46</td>

            <td class="px-3 py-2 border-b border-gray-700">t59 = z3 + t54</td>

            <td class="px-3 py-2 border-b border-gray-700">t60 = t46 + t57</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t61 = z14 + t57</td>

            <td class="px-3 py-2 border-b border-gray-700">t62 = t52 + t58</td>

            <td class="px-3 py-2 border-b border-gray-700">t63 = t49 + t58</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t64 = z4 + t59</td>

            <td class="px-3 py-2 border-b border-gray-700">t65 = t61 + t62</td>

            <td class="px-3 py-2 border-b border-gray-700">t66 = z1 + t63</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s0 = t59 + t63</td>

            <td class="px-3 py-2 border-b border-gray-700">s6 = t56 XNOR t62</td>

            <td class="px-3 py-2 border-b border-gray-700">s7 = t48 XNOR t60</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t67 = t64 + t65</td>

            <td class="px-3 py-2 border-b border-gray-700">s3 = t53 + t66</td>

            <td class="px-3 py-2 border-b border-gray-700">s4 = t51 + t66</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s5 = t47 + t65</td>

            <td class="px-3 py-2 border-b border-gray-700">s1 = t64 XNOR s3</td>

            <td class="px-3 py-2 border-b border-gray-700">s2 = t55 XNOR t67</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 4. Bottom linear transformation: Inputs are  <span class="math">z_0, z_1, \\ldots, z_{17}</span> . Outputs are  <span class="math">s_0, s_1, \\ldots, s_7</span> .</p>`;
---

<BaseLayout title="New logic minimization techniques with applications to crypt... (2009/191)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2009 &middot; eprint 2009/191
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
