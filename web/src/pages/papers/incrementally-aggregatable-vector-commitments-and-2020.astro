---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/149';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Incrementally Aggregatable Vector Commitments and Applications to Verifiable Decentralized Storage';
const AUTHORS_HTML = 'Matteo Campanelli, Dario Fiore, Nicola Greco, Dimitris Kolonelos, Luca Nizzardo';

const CONTENT = `    <p class="text-gray-300">Matteo Campanelli^{1}, Dario Fiore^{1}, Nicola Greco^{3}, Dimitris Kolonelos^{1,2}, and Luca Nizzardo^{3}</p>

    <p class="text-gray-300">^{1} IMDEA Software Institute, Madrid, Spain {matteo.campanelli,dario.fiore,dimitris.kolonelos}@imdea.org ^{2} Universidad Politecnica de Madrid, Spain ^{3} Protocol Labs {nicola,luca}@protocol.ai</p>

    <p class="text-gray-300">Abstract. Vector commitments with subvector openings (SVC) [Lai-Malavolta, Boneh-Bunz-Fisch; CRYPTO’19] allow one to open a committed vector at a set of positions with an opening of size independent of both the vector’s length and the number of opened positions.</p>

    <p class="text-gray-300">We continue the study of SVC with two goals in mind: improving their efficiency and making them more suitable to decentralized settings. We address both problems by proposing a new notion for VC that we call <em>incremental aggregation</em> and that allows one to merge openings in a succinct way an unbounded number of times. We show two applications of this property. The first one is immediate and is a method to generate openings in a distributed way. For the second one, we use incremental aggregation to design an algorithm for faster generation of openings via preprocessing.</p>

    <p class="text-gray-300">We then proceed to realize SVC with incremental aggregation. We provide two constructions in groups of unknown order that, similarly to that of Boneh et al. (which supports only one-hop aggregation), have constant-size public parameters, commitments and openings. As an additional feature, for the first construction we propose efficient arguments of knowledge of subvector openings which immediately yields a keyless proof of storage with compact proofs.</p>

    <p class="text-gray-300">Finally, we address a problem closely related to that of SVC: storing a file efficiently in completely decentralized networks. We introduce and construct <em>verifiable decentralized storage</em> (VDS), a cryptographic primitive that allows to check the integrity of a file stored by a network of nodes in a distributed and decentralized way. Our VDS constructions rely on our new vector commitment techniques.</p>

    <p class="text-gray-300">#</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>This article is the full version of the paper that appears in the proceedings of ASIACRPT 2020, © IACR 2020.</li>

    </ul>

    <p class="text-gray-300">1 Introduction 4 1.1 A new notion for SVCs: incremental aggregation 4 1.2 Verifiable Decentralized Storage 7 1.3 Concurrent Work 10</p>

    <p class="text-gray-300">2 Preliminaries 10 2.1 Groups of Unknown Order and Computational Assumptions 11 2.2 Arguments of Knowledge 12</p>

    <p class="text-gray-300">3 Vector Commitments with Incremental Aggregation 13 3.1 Vector Commitments with Subvector Openings 13 3.2 Incrementally Aggregatable Subvector Openings 15</p>

    <p class="text-gray-300">4 Applications of Incremental Aggregation 17 4.1 Divide-and-Conquer Extensions of Aggregation and Disaggregation 17 4.2 Committing and Opening with Precomputation 18</p>

    <p class="text-gray-300">5 Our Realizations of Incrementally Aggregatable Vector Commitments 20 5.1 Our First SVC Construction 20 5.2 Our Second SVC Construction 31 5.3 Comparison with Related Work 36</p>

    <p class="text-gray-300">6 Arguments of Knowledge for Our First SVC 38 6.1 Building block: A Stronger Proof of Product 38 6.2 A Succinct AoK of Opening for our VC Construction 39 6.3 An AoK for commitments with common subvector 42 6.4 A Succinct AoK for Commitment on Subvector 42</p>

    <p class="text-gray-300">7 Verifiable Decentralized Storage 43 7.1 Syntax 44 7.2 Correctness and Efficiency of VDS 46 7.3 Security of VDS 48</p>

    <p class="text-gray-300">8 Our Realizations of VDS in Hidden-Order Groups 49 8.1 Our First VDS Construction 49 8.2 Our Second VDS Construction 56 8.3 Efficiency and Comparison 59</p>

    <p class="text-gray-300">9 Experimental Evaluation 60</p>

    <p class="text-gray-300">A PoProd protocol for Union of RSA Accumulators 64 B Committing and Opening with Precomputation for the [BBF19] SVC 65 C Succinct Arguments of Knowledge for VDS 66 D VDS Proof of Storage 67 D.1 Proof of Retrievability for any VDS 69 D.2 Proof of Data Possession for our first VDS scheme 70</p>

    <p class="text-gray-300">E A Variant VDS Construction with Strong Security 71 E.1 Strong Security 71</p>

    <p class="text-gray-300">3 E.2 A VDS Construction with Strong Security ... 71 F Experimental Results ... 72</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Commitment schemes are one of the most fundamental cryptographic primitives. They can be seen as the digital equivalent of a sealed envelop: committing to a message <span class="math">m</span> is akin to putting <span class="math">m</span> in the envelop; opening the commitment is like opening the envelop and revealing the value inside. They have two basic properties. Hiding guarantees that a commitment reveals no information about the underlying message. Binding instead ensures that one cannot change its mind about the committed message; namely, it is not possible to open a commitment to two distinct values <span class="math">m\\neq m^{\\prime}</span>.</p>

    <p class="text-gray-300">Vector commitments (VC) <em>[x19, x7]</em> are a special class of commitment schemes in which one can commit to a vector <span class="math">\\vec{v}</span> of length <span class="math">n</span> and to later open the commitment at any position <span class="math">i\\in[n]</span>. The distinguishing feature of VCs is that both the commitment and an opening for a position <span class="math">i</span> have size independent of <span class="math">n</span>. In terms of security, VCs should be position binding, i.e., one cannot open a commitment at position <span class="math">i</span> to two distinct values <span class="math">v_{i}\\neq v_{i}^{\\prime}</span>.</p>

    <p class="text-gray-300">VCs were formalized by Catalano and Fiore <em>[x7]</em> who also proposed two constructions based on the CDH assumption in bilinear groups and the RSA assumption respectively. Both schemes have constant-size commitments and openings but suffer from large public parameters that are <span class="math">O(n^{2})</span> and <span class="math">O(n)</span> for the CDH- and RSA-based scheme respectively. Noteworthy is that Merkle trees <em>[x14]</em> are VCs with <span class="math">O(\\log n)</span>-size openings.</p>

    <p class="text-gray-300">Two recent works <em>[x1, x16]</em> proposed new constructions of vector commitments that enjoy a new property called subvector openings (also called batch openings in <em>[x1]</em>). A VC with subvector openings (called SVC, for short) allows one to open a commitment at a collection of positions <span class="math">I=\\{i_{1},\\ldots,i_{m}\\}</span> with a constant-size proof, namely of size independent of the vector’s length <span class="math">n</span> and the subvector length <span class="math">m</span>. This property has been shown useful for reducing communication complexity in several applications, such as PCP/IOP-based succinct arguments <em>[x16, x1]</em> and keyless Proofs of Retrievability (PoR) <em>[x10]</em>.</p>

    <p class="text-gray-300">In this work we continue the study of VCs with subvector openings with two main goals: (1) improving their efficiency, and (2) enabling their use in decentralized systems.</p>

    <p class="text-gray-300">With respect to efficiency, although the most attractive feature of SVCs is the constant size of their opening proofs, a drawback of all constructions is that generating each opening takes at least time <span class="math">O(n)</span> (i.e., as much as committing). This is costly and may harm the use of SVCs in applications such as the ones mentioned above.</p>

    <p class="text-gray-300">When it comes to decentralization, VCs have been proposed as a solution for integrity of a distributed ledger (e.g., blockchains in the account model <em>[x1]</em>): the commitment is a succinct representation of the ledger, and a user responsible for the <span class="math">i</span>-th entry can hold the corresponding opening and use it to prove validity of <span class="math">v_{i}</span>. In this case, though, it is not obvious how to create a succinct subvector opening for, say, <span class="math">m</span> positions held by different users each responsible only of its own position/s in the vector. We elaborate more on the motivation around this problem in Section 1.2.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 A new notion for SVCs: incremental aggregation</h3>

    <p class="text-gray-300">To address these concerns, we define and investigate a new property of vector commitments with subvector openings called incremental aggregation. In a nutshell, aggregation means that different subvector openings (say, for sets of positions <span class="math">I</span> and <span class="math">J</span>) can be merged together into a single concise (i.e., constant-size) opening (for positions <span class="math">I\\cup J</span>). This operation must be doable without knowing the</p>

    <p class="text-gray-300">entire committed vector. Moreover, aggregation is incremental if aggregated proofs can be further aggregated (e.g., two openings for <span class="math">I\\cup J</span> and <span class="math">K</span> can be merged into one for <span class="math">I\\cup J\\cup K</span>, and so on an unbounded number of times) and disaggregated (i.e., given an opening for set <span class="math">I</span> one can create one for any <span class="math">K\\subset I</span>).</p>

    <p class="text-gray-300">While a form of aggregation is already present in the VC of Boneh et al. <em>[x1]</em>, in <em>[x2]</em> this can be performed only once. In contrast, <em>we define (and construct) the first VC schemes where openings can be aggregated an unbounded number of times</em>. This incremental property is key to address efficiency and decentralized applications of SVCs, as we detail below.</p>

    <p class="text-gray-300">Incremental aggregation for efficiency. To overcome the barrier of generating each opening in linear time <span class="math">O_{\\lambda}(n)</span>, we propose an alternative preprocessing-based method. The idea is to precompute at commitment time an auxiliary information consisting of <span class="math">n/B</span> openings, one for each batch of <span class="math">B</span> positions of the vector. Next, to generate an opening for an arbitrary subset of <span class="math">m</span> positions, one uses the incremental aggregation property in order to disaggregate the relevant subsets of precomputed openings, and then further aggregate for the <span class="math">m</span> positions. Concretely, with this method, in our construction we can do the preprocessing in time <span class="math">O_{\\lambda}(n\\log n)</span> and generate an opening for <span class="math">m</span> positions in time roughly <span class="math">O_{\\lambda}(mB\\log n)</span>.</p>

    <p class="text-gray-300">With the VC of <em>[x1]</em>, a limited version of this approach is also viable: one precomputes an opening for each bit of the vector in <span class="math">O_{\\lambda}(n\\log n)</span> time; and then, at opening time, one uses their one-hop aggregation to aggregate relevant openings in time roughly <span class="math">O_{\\lambda}(m\\log n)</span>. This however comes with a huge drawback: one must store one opening (of size <span class="math">p(\\lambda)=\\mathsf{poly}(\\lambda)</span> where <span class="math">\\lambda</span> is the security parameter) for every bit of the vector, which causes a prohibitive storage overhead, i.e., <span class="math">p(\\lambda)\\cdot n</span> bits in addition to storing the vector <span class="math">\\vec{v}</span> itself.</p>

    <p class="text-gray-300">With incremental aggregation, we can instead tune the chunk size <span class="math">B</span> to obtain flexible time-memory tradeoffs. For example, with <span class="math">B=\\sqrt{n}</span> one can use <span class="math">p(\\lambda)\\sqrt{n}</span> bits of storage to get <span class="math">O_{\\lambda}(m\\sqrt{n}\\log n)</span> opening time. Or, by setting <span class="math">B=p(\\lambda)</span> as the size of one opening, we can obtain a storage overhead of exactly <span class="math">n</span> bits and opening time <span class="math">O_{\\lambda}(m\\log n)</span>.</p>

    <p class="text-gray-300">Incremental aggregation for decentralization. Essentially, by its definition, incremental aggregation enables generating subvector openings in a distributed fashion. Namely, consider a scenario where different parties each hold an opening of some subvector; using aggregation they can create an opening for the union of their subvectors, moreover the incremental property allows them to perform this operation in a non-coordinated and asynchronous manner, i.e. without the need of a central aggregator. We found this application of incrementally aggregatable SVCs to decentralized systems worth exploring in more detail. To fully address this application, we propose a new cryptographic primitive called verifiable decentralized storage which we discuss in Section 1.2.</p>

    <p class="text-gray-300">Constructing VCs with incremental aggregation. Turning to realizing SVC schemes with our new incremental aggregation property, we propose two SVC constructions that work in hidden-order groups <em>[x10]</em> (instantiatable using classical RSA groups, class groups <em>[x4]</em> or the recently proposed groups from Hyperelliptic Curves <em>[x11]</em>).</p>

    <p class="text-gray-300">Our first SVC has constant-size public parameters and constant-size subvector openings, and its security relies on the Strong RSA assumption and an argument of knowledge in the generic group model. Asymptotically, its efficiency is similar to the SVC of Boneh et al. <em>[x1]</em>, but concretel</p>

    <p class="text-gray-300">we outperform <em>[x1]</em>. We implement our new SVC and show it can obtain very fast opening times thanks to the preprocessing method described earlier: opening time reduces by several orders of magnitude for various choices of vector and opening sizes, allowing us to obtain practical opening times—of the order of seconds—that would be impossible without preprocessing—of the order of hundred of seconds. In a file of 1 Mibit (<span class="math">2^{20}</span> bits), preprocessing reduces the time to open 2048 bits from one hour to less than 5 seconds!</p>

    <p class="text-gray-300">For the second construction, we show how to modify the RSA-based SVC of <em>[x12]</em> (which in turn extends the one of <em>[x2]</em> to support subvector openings) in order to make it with constant-size parameters and to achieve incremental aggregation. Compared to the first construction, it is more efficient and based on more standard assumptions, in the standard model.</p>

    <p class="text-gray-300">Efficient Arguments of Knowledge of Subvector Opening. As an additional result, we propose efficient arguments of knowledge (AoK) with constant-size proofs for our first VC. The first AoK can prove knowledge of the subvector that opens a commitment at a public set of positions, and it extends to proving that two commitments share a common subvector. The second AoK is similar except that the subvector one proves knowledge of is also committed; essentially one can create two vector commitments <span class="math">C</span> and <span class="math">C^{\\prime}</span> together with a short proof that <span class="math">C^{\\prime}</span> is a commitment to a subvector of the vector committed in <span class="math">C</span>.</p>

    <p class="text-gray-300">An immediate application of our first AoK is a keyless proof of storage (PoS) protocol with compact proofs. PoS allows a client to verify that a server is storing intactly a file via a short-communication challenge-response protocol. A PoS is said keyless if no secret key is needed by clients, a property useful in open systems where the client is a set of distrustful parties (e.g., verifiers in a blockchain) and the server may even be one of these clients. A classical keyless PoS is based on Merkle trees and random spot-checks <em>[x6]</em>, recently generalized to work with vector commitments <em>[x3]</em>. A drawback of this construction is that proofs grow with the number of spot-checks (and the size of the tree) and become undesirably large in some applications, e.g., if need to be stored in a blockchain. With our AoK we can obtain openings of fixed size, as short as 2KB, which is 40x shorter than those based on Merkle trees in a representative setting without relying on SNARKs (that would be unfeasible in terms of time and memory).</p>

    <p class="text-gray-300">From Updatable VCs to Verifiable Decentralized Storage. In their seminal work on VCs, Catalano and Fiore <em>[x2]</em> also defined updatable VCs. This means that if one changes the <span class="math">i</span>-th value of a vector from <span class="math">v_{i}</span> to <span class="math">v_{i}^{\\prime}</span> it is possible to update: a commitment <span class="math">C</span> to <span class="math">\\vec{v}</span> into a commitment <span class="math">C^{\\prime}</span> to <span class="math">\\vec{v}^{\\prime}</span>, a valid opening for <span class="math">C</span> (at any position) into a valid opening for <span class="math">C^{\\prime}</span>. And importantly, these updates can be done without knowing the entire vector and in time that depends only on the number of modified positions. As an application, in <em>[x2]</em> it is shown how updatable VCs can be used to realize verifiable databases (VDB) <em>[x1]</em>, a primitive that enables a client to outsource a database to an untrusted server in such a way that the client can retrieve (and update) a DB record and be assured that it has not been tampered with by the server.</p>

    <p class="text-gray-300">In this work we study how to extend this model to a scenario where storage is distributed across different nodes of a decentralized network. This problem is motivated by the emerging trend of decentralized storage networks (DSNs), a decentralized and open alternative to traditional cloud</p>

    <p class="text-gray-300">storage and hosting services. Filecoin (which is built on top of IPFS), Storj, Dat, Freenet and general-purpose blockchains like Ethereum are some emerging projects in this space.</p>

    <p class="text-gray-300">Our contribution is to put forward a new cryptographic primitive called verifiable decentralized storage (VDS) that can be used to obtain data integrity guarantees in DSNs. We propose a definition of VDS and a construction obtained by extending the techniques of our VC scheme; in particular, both incremental aggregation and the arguments of knowledge are key ingredients for building a cost-effective VDS solution.</p>

    <p class="text-gray-300">In the following section we elaborate on the VDS problem: we begin by discussing the requirements imposed by DSNs, and then give a description of our VDS primitive and realization.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.2 Verifiable Decentralized Storage</h3>

    <p class="text-gray-300">Decentralized Storage Networks. Openness and decentralization are the main characteristics of DSNs: anyone can enter the system (and participate as either a service provider or a consumer) and the system works without any central management or trusted parties. Abstracting from the details of each system, a DSN consists of participants called nodes that can be either a storage provider (aka storage node) or a client node. Akin to centralized cloud storage, a client can outsource the storage of large data; the key difference of DSN however is that storage is provided by, and distributed across, a collection of nodes that can enter and leave the system at their wish. Also, DSNs can have some reward mechanism to economically incentivize storage nodes.</p>

    <p class="text-gray-300">The openness and the presence of economic incentives raise a number of security questions that need to be solved in order to make these systems viable. In this work, we focus on the basic problem of ensuring that the storage nodes of the DSN are doing their job properly, namely:</p>

    <p class="text-gray-300">How can any client node check that the whole DSN is storing correctly its data (in a distributed fashion)?</p>

    <p class="text-gray-300">While this question is well studied in the centralized setting where the storage provider is a single server, for decentralized systems the situation is less satisfactory. In what follows we elaborate on the problem and the desired requirements, and then on our solution.</p>

    <p class="text-gray-300">The Problem of Verifiable Decentralized Storage in DSNs. Consider a client who outsources the storage of a large file <span class="math">F</span>, consisting of blocks <span class="math">(F_{1},\\ldots,F_{N})</span>, to a collection of storage nodes. A storage node can store a portion of <span class="math">F</span> and the network is assumed to be designed in order to self-coordinate so that the whole <span class="math">F</span> is stored, and to be fault-resistant (e.g., by having the same data block stored on multiple nodes). Once the file is stored, clients can request to the network to retrieve or modify a data block <span class="math">F_{i}</span> (or more), as well as to append (resp. delete) blocks to (resp. from) the file.</p>

    <p class="text-gray-300">In this scenario, our goal is to formalize a cryptographic primitive that can provide clients with the guarantee of integrity of the outsourced data and its modifications. The basic idea of VDS is that: (i) the client retains a short digest <span class="math">\\delta_{F}</span> that “uniquely” points to the file <span class="math">F</span>; (ii) any operation performed by the network, be it a retrieval or a file modification, can be proven by generating a short certificate that is publicly verifiable given <span class="math">\\delta_{F}</span>.</p>

    <p class="text-gray-300">This problem is similar in scope to the one addressed by authenticated data structures (ADS) <em>[x29]</em>. But while ADS is centralized, VDS is not. In VDS nodes act as storage in a distributed</p>

    <p class="text-gray-300">and uncoordinated fashion. This is more challenging as VDS needs to preserve some basic properties of the DSN:</p>

    <p class="text-gray-300">Highly Local. The file is stored across multiple nodes and no node is required to hold the entire <span class="math">F</span>: in VDS every node should function with only its own local view of the system, which should be much smaller than the whole <span class="math">F</span>, e.g., logarithmic or constant in the size of <span class="math">F</span>. Another challenge is dynamic files: in VDS both the digest and the local view must be locally updatable, possibly with the help of a short and publicly verifiable update advice that can be generated by the node who holds the modified data blocks.</p>

    <p class="text-gray-300">Decentralized Keyless Clients. In a decentralized system the notion of a client who outsources the storage of a file is blurry. It may for example be a set of mutually distrustful parties (even the entire DSN in the most extreme case, e.g., the file is a blockchain), or a collection of storage nodes themselves that decide to make some data available to the network. This comes with two implications:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>VDS must work without any secret key on the clients side, so that everyone in the network can delegate and verify storage. This keyless setting captures not only clients requiring no coordination, but also a stronger security model. Here the attacker may control both the storage node and the client, yet it must not be able to cheat when proving correctness of its storage. The latter is crucial in DSNs with economic rewards to well-behaving storage nodes⁸.</li>

      <li>In VDS a file <span class="math">F</span> exists as long as some storage nodes provide its storage and a pointer to the file is known to the network through its digest. When a file <span class="math">F</span> is modified into <span class="math">F&#x27;</span> and its digest <span class="math">\\delta_F</span> is updated into <span class="math">\\delta_{F&#x27;}</span>, both versions of the file may coexist. Forks are possible and it is left to each client (or the application) to choose which digest to track: the old one, the new one, or both.</li>

    </ol>

    <p class="text-gray-300">Non-Coordinated Certificates Generation. There are multiple ways in which data retrieval queries can be answered in a DSN. In some cases, e.g., IPFS, after executing a P2P protocol to discover the storage nodes holding the desired data blocks, one gets such blocks from these nodes. In other cases (e.g., Freenet [CSWH01] or the original Gnutella protocol), data retrieval is also answered in a peer-to-peer non-coordinated fashion. When a query for blocks <span class="math">i_1, \\ldots, i_m</span> propagates through the network, every storage node replies with the blocks that it owns and these answers are aggregated and propagated in the network until they reach the client who asked for them. Notably, data aggregation and propagation may follow different strategies.⁹ To accommodate flexible aggregation strategies, in VDS we consider the incremental aggregation of query certificates in an arbitrary and bandwidth-efficient fashion. For example, short certificates for file blocks <span class="math">F_i</span> and <span class="math">F_j</span> should be mergeable into a short certificate for <span class="math">(F_i, F_j)</span> and this aggregation process should be carried on and on. Noteworthy that having certificates that stay short after each aggregation keeps the communication overhead of the VDS integrity mechanism at a minimum.¹⁰</p>

    <p class="text-gray-300">Defining VDS. We define VDS as a collection of algorithms that capture all the properties above; these are the algorithms that can be executed by clients and storage nodes to maintain the system. A client for a file <span class="math">F</span> is anyone who holds a digest <span class="math">\\delta_F</span> with which it can: verify retrieval queries, verify and apply updates of <span class="math">F</span> (that result in forks of <span class="math">\\delta_F</span> into some other <span class="math">\\delta_{F&#x27;}</span>). A storage node for</p>

    <p class="text-gray-300">⁸ Since in a decentralized system a storage node may also be a client, an attacker could “delegate storage to itself” and use the client’s secret key to cheat in the proof in order to steal rewards (akin to the so-called “generation attack” in Filecoin [Lab17]).</p>

    <p class="text-gray-300">⁹ E.g., in Freenet data is sent back along the same route the query came through, with the goal of providing anonymity between who requests and who delivers data.</p>

    <p class="text-gray-300">¹⁰ The motivation of this property is similar to that of sequential aggregate signatures, see e.g., [LMRS04, BGR12].</p>

    <p class="text-gray-300">some blocks <span class="math">F_I = \\{F_i\\}_{i \\in I}</span> of a file <span class="math">F</span> is anyone that in addition to <span class="math">F_I</span> stores the digest <span class="math">\\delta_F</span> and a local state <span class="math">\\mathsf{st}_{F_I}</span> with which it can: answer and certify retrieval queries for any subset of <span class="math">F_I</span>; push and certify updates of <span class="math">F</span> that involve blocks in <span class="math">F_I</span>; verify and apply updates of <span class="math">F</span> from other nodes. Finally, any node can aggregate retrieval certificates for different blocks of the same file.</p>

    <p class="text-gray-300">In our VDS notion, an update of <span class="math">F</span> can be: (i) a modification of some blocks, (ii) appending new blocks, or (iii) deleting some blocks (from the end). In all cases, an update of <span class="math">F</span> results into a file <span class="math">F&#x27;</span> and a new digest <span class="math">\\delta_{F&#x27;}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In terms of efficiency, in VDS the digests and every certificate (for both retrieval queries or modifications) are required to be of size at most $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">; similarly, the storage node&#x27;s local state </span>\\mathsf{st}_{F_I}<span class="math"> has size at most </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. In a nutshell, no node should run linearly in the size of the file (unless it is explicitly storing it in full).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The main security property of a VDS scheme intuitively requires that no efficient adversary can create a certificate for falsified data blocks (or updates) that passes verification. As an extra security property, we also consider the possibility that anyone holding a digest <span class="math">\\delta_F</span> can check if the DSN is storing correctly <span class="math">F</span> without having to retrieve it. Namely, we let VDS provide a Proof of Storage mechanism, which we define similarly to Proof of Retrievability [JK07] and Proof of Data Possession [ABC+07]. Similarly to the case of data retrieval queries, the creation of these proofs of storage must be possible while preserving the aforementioned properties of locality and no-central-coordination.</p>

    <p class="text-gray-300"><strong>Constructing VDS.</strong> We propose two constructions of VDS in hidden-order groups. Both our VDS schemes are obtained by extending our first and second SVC scheme respectively, in order to handle updates and to ensure that all such update operations can be performed locally. In particular we show crucial use of the new properties of our construction: subvector openings, incremental aggregation and disaggregation, and arguments of knowledge for sub-vector commitments (the latter for the first scheme only).</p>

    <p class="text-gray-300">Our two VDS schemes are based on the Strong RSA [BP97] and Strong distinct-prime-product root [LM19], and Low Order [BBF18] assumptions and have similar performances. The second scheme has the interesting property that the storage node can perform and propagate updates by running in time that is independent of even its total local storage. Our first scheme instead supports an additional type of update that we call "CreateFrom". In it, a storage node holding a prefix <span class="math">F&#x27;</span> of a file <span class="math">F</span> can publish a new digest <span class="math">\\delta_{F&#x27;}</span> corresponding to <span class="math">F&#x27;</span> as a new file and convince any client about its correctness without the need for the client to know neither <span class="math">F</span> nor <span class="math">F&#x27;</span>. As a potential use case for this feature, consider a network that is supposed to store the entire editing history of some data (e.g., one or more files of a Git project); namely the <span class="math">i</span>-th block of the VDS file contains the data value after the <span class="math">i</span>-th edit (e.g., the <span class="math">i</span>-th Git commit). Then "CreateFrom" can be used to verifiably create a digest of any past version of the data (e.g., of a fork at any point in the past). Finally, our approach is not limited to a prefix of the file but to whatever subset of indices we want to create the new file from.</p>

    <p class="text-gray-300">It is worth noting that by abstracting the ideas of our constructions, other VDS schemes can be obtained using Merkle trees or RSA accumulators.¹² Compared to a Merkle-tree based solution, we can achieve constant-size certificates for every operation as well as to (efficiently) support compact</p>

    <p class="text-gray-300">¹¹ This can be seen as a deletion that can be performed without holding the blocks to be deleted and is more efficient to verify when the prefix <span class="math">F&#x27;</span> is much smaller than <span class="math">F</span>.</p>

    <p class="text-gray-300">¹² In fact, a similar idea from RSA accumulators was discussed in [BBF19].</p>

    <p class="text-gray-300">9</p>

    <p class="text-gray-300">roofs of storage without expensive SNARKs. Compared to RSA Accumulators, our first VDS scheme takes advantage of our AoK thanks to which it supports CreateFrom updates and compact proofs of storage.</p>

    <p class="text-gray-300">Finally, we note that VDS shares similarities with the notion of updatable VCs <em>[x10]</em> extended with incrementally aggregatable subvector openings. There are two main differences. First, in VDS updates can be applied with the help of a short advice created by the party who created the update, whereas in updatable VC this is possible having only the update’s description. The second difference is that in VDS the public parameters must be short, otherwise nodes could not afford storing them. This is not necessarily the case in VCs and in fact, to the best of our knowledge, there exists no VC construction with short parameters that is updatable (according to the updatability notion of <em>[x10]</em>) and has incrementally aggregatable subvector openings. We believe this is an interesting open problem.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.3 Concurrent Work</h3>

    <p class="text-gray-300">In very recent concurrent works, Gorbunov et al. <em>[x22]</em> and Tomescu et al. <em>[TAB^{+}20]</em> study similar problems related to aggregation properties of vector commitments. In <em>[TAB^{+}20]</em>, Tomescu et al. study a vector commitment scheme based on the Kate et al. polynomial commitment <em>[x27]</em>: they show how it can be made both updatable and aggregatable, and propose an efficient Stateless Cryptocurrency based on it. In Pointproofs <em>[x22]</em> they propose the notion of Cross-Commitment Aggregation, which enables aggregating opening proofs for different commitments, and show how this notion is relevant to blockchain applications. The VC schemes in both <em>[TAB^{+}20]</em> and <em>[x22]</em> work in bilinear groups and have linear-size public parameters. Also, these constructions do not support incremental aggregation or disaggregation. In contrast, our VCs work in hidden-order groups, which likely makes them concretely less efficient, but they have constant-size parameters, and they support incremental aggregation and disaggregation. Finally, we note that by using techniques similar to <em>[x22]</em> we can extend our constructions to support cross-commitment aggregation; we leave formalizing this extension for future work.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">In this section we describe notation and definitions used throughout the paper.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notation. We denote the security parameter by <span class="math">\\lambda</span> and the set of all polynomial functions by <span class="math">\\mathsf{poly}(\\lambda)</span>. A function <span class="math">\\epsilon(\\lambda)</span> is said negligible – denoted <span class="math">\\epsilon(\\lambda)\\in\\mathsf{negl}(\\lambda)</span> – if it vanishes faster than the inverse of any polynomial. An algorithm <span class="math">\\mathcal{A}</span> is said PPT if it is modeled as a probabilistic Turing machine that runs in time <span class="math">\\mathsf{poly}(\\lambda)</span>. We denote by <span class="math">y\\leftarrow\\mathcal{A}(x)</span> the process of running <span class="math">\\mathcal{A}</span> on input <span class="math">x</span> and assigning the output to <span class="math">y</span>. For a set <span class="math">S</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes its cardinality, and </span>x\\leftarrow\\vdash S<span class="math"> denotes selecting </span>x<span class="math"> uniformly at random over </span>S<span class="math">. For a positive integer </span>n\\in\\mathbb{N}<span class="math"> we let </span>[n]:=\\{1,\\ldots,n\\}<span class="math">. We denote vectors </span>\\vec{v}<span class="math"> in bold, and for </span>\\vec{v}\\in\\mathcal{M}^{n}<span class="math"> </span>v_{i}<span class="math"> is its entry at position </span>i<span class="math">. We let </span>\\mathsf{Primes}(\\lambda)<span class="math"> be the set of all prime integers less than </span>2^{\\lambda}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">11</p>

    <p class="text-gray-300">Our constructions use a group <span class="math">\\mathbb{G}</span> of unknown (aka hidden) order, in which the Low Order assumption [BBF18] and the Strong RSA assumption [BP97] or the Strong Distinct-Prime-Product Root assumption [LM19] (defined below) hold.</p>

    <p class="text-gray-300">We let <span class="math">\\mathsf{Ggen}(1^{\\lambda})</span> be a probabilistic algorithm that generates such a group <span class="math">\\mathbb{G}</span> with order in a specific range <span class="math">[\\mathsf{ord}_{min},\\mathsf{ord}_{max}]</span> such that <span class="math">\\frac{1}{\\mathsf{ord}_{min}},\\frac{1}{\\mathsf{ord}_{max}},\\frac{1}{\\mathsf{ord}_{max} - \\mathsf{ord}_{min}}\\in \\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300"><strong>Definition 2.1 (Low Order Assumption [BBF18]).</strong> We say that the low order assumption holds for <span class="math">\\mathsf{Ggen}</span> if for any PPT adversary <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{l l} u ^ {\\ell} = 1 &amp;amp; \\\\ \\wedge u \\neq 1 &amp;amp; : \\mathbb{G} \\leftarrow \\mathsf{Ggen}(\\lambda) \\\\ \\wedge 1 &amp;lt; \\ell &amp;lt; 2 ^ {\\mathsf{poly}(\\lambda)} &amp;amp; : (u, \\ell) \\leftarrow \\mathcal{A}(\\mathbb{G}) \\end{array} \\right] = \\mathsf{negl}(\\lambda)</span></div>

    <p class="text-gray-300"><strong>Remark 2.1.</strong> The Low Order Assumption is implied by the more commonly known Adaptive Root assumption, which is defined below. For the reduction we refer to [BBF18]. We also notice that the definition of the Low Order assumption given in [BBF18] is for smaller <span class="math">\\ell</span>, <span class="math">1 &amp;lt; \\ell &amp;lt; 2^{\\lambda}</span>, which was sufficient for the application in the paper, whereas ours is for any polynomial-size <span class="math">\\ell</span>. We note that the same reduction to the Adaptive Root assumption described in [BBF18] also holds for our definition of the problem.</p>

    <p class="text-gray-300"><strong>Definition 2.2 (Adaptive Root Assumption [Wes18]).</strong> We say that the adaptive root assumption holds for <span class="math">\\mathsf{Ggen}</span> if for any PPT adversary <span class="math">(\\mathcal{A}_1, \\mathcal{A}_2)</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{l l} &amp;amp; \\mathbb{G} \\leftarrow \\mathsf{Ggen}(\\lambda) \\\\ u ^ {\\ell} = w &amp;amp; (w, \\mathsf{state}) \\leftarrow \\mathcal{A}_{1}(\\mathbb{G}) \\\\ \\wedge w \\neq 1 &amp;amp; \\ell \\leftarrow \\S \\mathsf{Primes}(\\lambda) \\\\ &amp;amp; u \\leftarrow \\mathcal{A}_{2}(\\ell, \\mathsf{state}) \\end{array} \\right] = \\mathsf{negl}(\\lambda)</span></div>

    <p class="text-gray-300"><strong>Definition 2.3 (Strong-RSA Assumption [BP97]).</strong> We say that the strong RSA assumption holds for <span class="math">\\mathsf{Ggen}</span> if for any PPT adversary <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{l l} u ^ {e} = g &amp;amp; \\mathbb{G} \\leftarrow \\mathsf{Ggen}(\\lambda) \\\\ \\wedge e \\text{ is prime} &amp;amp; : g \\leftarrow \\S \\mathbb{G} \\\\ &amp;amp; (u, e) \\leftarrow \\mathcal{A}(\\mathbb{G}, g) \\end{array} \\right] = \\mathsf{negl}(\\lambda)</span></div>

    <p class="text-gray-300"><strong>Definition 2.4 (Strong Distinct-Prime-Product Root assumption [LM19]).</strong> We say that the Strong Distinct-Prime-Product Root assumption holds for <span class="math">\\mathsf{Ggen}</span> if for any PPT adversary <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{l l} u ^ {\\Pi_ {i \\in S} e _ {i}} = g &amp;amp; \\mathbb{G} \\leftarrow \\mathsf{Ggen}(\\lambda) \\\\ \\wedge \\forall i \\ e _ {i} \\in \\mathsf{Primes}(\\lambda) &amp;amp; : g \\leftarrow \\S \\mathbb{G} \\\\ \\wedge \\forall i \\neq j, e _ {i} \\neq e _ {j} &amp;amp; (u, \\{e _ {i} \\} _ {i \\in S}) \\leftarrow \\mathcal{A}(\\mathbb{G}, g) \\end{array} \\right] = \\mathsf{negl}(\\lambda)</span></div>

    <p class="text-gray-300">The assumption is implied by the strong RSA assumption over RSA groups.</p>

    <p class="text-gray-300">As discussed in [BBF18, BBF19, LM19], two concrete instantiations of <span class="math">\\mathbb{G}</span> are class groups [BH01] and the quotient group <span class="math">\\mathbb{Z}_N^* / \\{1, -1\\}</span> of an RSA group [Wes18]. The reason why we cannot directly</p>

    <p class="text-gray-300">use the RSA group is that the order of <span class="math">-1 \\in \\mathbb{Z}_N^*</span>  is known, and thus the adaptive root assumption does not hold. In the quotient group, <span class="math">\\{-1, 1\\}</span> is the identity element; hence, knowing the order of <span class="math">-1</span> does not help in finding a root for a non-identity element and thus solving the adaptive root assumption.</p>

    <p class="text-gray-300">Shamir's Trick. Informally speaking, Shamir's trick [Sha83] is a way to compute an <span class="math">xy</span>-root of a group element <span class="math">g</span> given an <span class="math">x</span>-root and a <span class="math">y</span>-root of it in groups of unknown order, when <span class="math">x</span> and <span class="math">y</span> are co-prime. That is, given <span class="math">\\rho_x = g^{\\frac{1}{x}}</span>, <span class="math">\\rho_y = g^{\\frac{1}{y}}</span>, <span class="math">x</span> and <span class="math">y</span>, one can compute <span class="math">a, b</span> st <span class="math">ax + by = 1</span> using the extended gcd algorithm. Then <span class="math">g^{\\frac{1}{xy}} = g^{\\frac{ax + by}{xy}} = g^{\\frac{a}{y} + \\frac{b}{x}} = \\rho_y^a \\cdot \\rho_x^b</span>. More formally, we recall the following algorithm:</p>

    <p class="text-gray-300">ShamirTrick<span class="math">(\\rho_x, \\rho_y, x, y)</span> if <span class="math">\\rho_x^x \\neq \\rho_y^y</span> then return <span class="math">\\perp</span> Use the extended Euclidean Algorithm to compute <span class="math">a, b, d</span> s.t. <span class="math">ax + by = d = \\gcd(x, y)</span> if <span class="math">d \\neq 1</span> then return <span class="math">\\perp</span> return <span class="math">\\rho_x^b \\rho_y^a</span></p>

    <h2 id="sec-8" class="text-2xl font-bold">2.2 Arguments of Knowledge</h2>

    <p class="text-gray-300">Let <span class="math">R: \\mathcal{X} \\times \\mathcal{W} \\to \\{0,1\\}</span> be an NP relation for a language <span class="math">\\mathcal{L} = \\{x : \\exists w \\text{ s.t. } R(x,w) = 1\\}</span>. An argument system for <span class="math">R</span> is a triple of algorithms <span class="math">(\\text{Setup}, \\mathsf{P}, \\mathsf{V})</span> such that: <span class="math">\\text{Setup}(1^{\\lambda})</span> takes as input a security parameter <span class="math">\\lambda</span> and outputs a common reference string <span class="math">\\text{crs}</span>; the prover <span class="math">\\mathsf{P}(\\text{crs}, x, w)</span> takes as input the crs, the statement <span class="math">x</span> and witness <span class="math">w</span>; the verifier <span class="math">\\mathsf{V}(\\text{crs}, x)</span> takes in the crs, the statement <span class="math">x</span>, and after interacting with the prover outputs 0 (reject) or 1 (accept). An execution between the prover and verifier is denoted with <span class="math">\\langle \\mathsf{P}(\\text{crs}, x, w), \\mathsf{V}(\\text{crs}, x) \\rangle = b</span>, where <span class="math">b \\in \\{0,1\\}</span> is the output of the verifier. If <span class="math">\\mathsf{V}</span> uses only public randomness, we say that the protocol is public coin.</p>

    <p class="text-gray-300"><strong>Definition 2.5 (Completeness).</strong> We say that an argument system <span class="math">(\\text{Setup}, \\mathsf{P}, \\mathsf{V})</span> for a relation <span class="math">R: \\mathcal{X} \\times \\mathcal{W} \\to \\{0,1\\}</span> is complete if, for all <span class="math">(x,w) \\in \\mathcal{X} \\times \\mathcal{W}</span> such that <span class="math">R(x,w) = 1</span> we have</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\langle \\mathsf {P} (\\mathsf {c r s}, x, w), \\mathsf {V} (\\mathsf {c r s}, x) \\rangle = 1: \\mathsf {c r s} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\right] = 1.</span></div>

    <p class="text-gray-300">Consider an adversary <span class="math">\\mathcal{A} = (\\mathcal{A}_0, \\mathcal{A}_1)</span> modeled as a pair of algorithms such that <span class="math">\\mathcal{A}_0(\\mathrm{crs}) \\to (x, \\mathrm{state})</span> (i.e. outputs an instance <span class="math">x \\in \\mathcal{X}</span> after <span class="math">\\mathrm{crs} \\gets \\mathrm{Setup}(\\lambda)</span> is run) and <span class="math">\\mathcal{A}_1(\\mathrm{crs}, x, \\mathrm{state})</span> interacts with a honest verifier. We want an argument of knowledge to satisfy the following properties:</p>

    <p class="text-gray-300"><strong>Soundness.</strong> We say that an argument <span class="math">(\\text{Setup}, \\mathsf{P}, \\mathsf{V})</span> is sound if for all PPT adversaries <span class="math">\\mathcal{A} = (\\mathcal{A}_0, \\mathcal{A}_1)</span> we have</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\langle \\mathcal {A} _ {1} (\\mathsf {c r s}, x, \\mathsf {s t a t e}), \\mathsf {V} (\\mathsf {c r s}, x) \\rangle = 1 &amp;amp; \\mathsf {c r s} \\leftarrow \\mathsf {S e t u p} (\\lambda) \\\\ \\text {a n d} \\nexists w: R (x, w) = 1 &amp;amp; (x, \\mathsf {s t a t e}) \\leftarrow \\mathcal {A} _ {0} (\\mathsf {c r s}) \\end{array} \\right] \\in \\mathsf {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300"><strong>Knowledge Extractability.</strong> We say that <span class="math">(\\text{Setup}, \\mathsf{P}, \\mathsf{V})</span> is an argument of knowledge if for all polynomial time adversaries <span class="math">\\mathcal{A}_1</span> there exists an extractor <span class="math">\\mathcal{E}</span> running in polynomial time such that, for all adversaries <span class="math">\\mathcal{A}_0</span> it holds</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\langle \\mathcal {A} _ {1} (\\mathsf {c r s}, x, \\mathsf {s t a t e}), \\mathsf {V} (\\mathsf {c r s}, x) \\rangle = 1 &amp;amp; \\mathsf {c r s} \\leftarrow \\mathsf {S e t u p} (\\lambda) \\\\ \\text {a n d} (x, w ^ {\\prime}) \\notin \\mathcal {R} &amp;amp; (x, \\mathsf {s t a t e}) \\leftarrow \\mathcal {A} _ {0} (\\mathsf {c r s}) \\\\ &amp;amp; w ^ {\\prime} \\leftarrow \\mathcal {E} (\\mathsf {c r s}, x, \\mathsf {s t a t e}) \\end{array} \\right] \\in \\mathsf {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">Succinctness. Finally we informally recall the notion of succinct arguments, which requires the communication and verifier’s running time in a protocol execution to be independent of the witness length.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Succinct Arguments of Knowledge for Hidden Order Groups.</h4>

    <p class="text-gray-300">We recall two succinct AoK protocols for the exponentiation relation in groups of unknown order that have been recently proposed by Boneh et. al. <em>[x1]</em>. Both protocols work for a hidden order group <span class="math">\\mathbb{G}</span> generated by Ggen in which the adaptive root assumption holds. Also, they are public-coin protocols that can be made non-interactive in the random oracle model using the Fiat-Shamir <em>[x10]</em> heuristic and its generalization to multi-round protocols <em>[x3]</em>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Protocol PoE: is an argument system for the following relation:</li>

    </ol>

    <p class="text-gray-300"><span class="math">R_{\\mathsf{PoE}}=\\left\\{((u,w,x)\\in\\mathbb{G}^{2}\\times\\mathbb{Z},\\varnothing)\\ :\\ u^{x}=w\\in\\mathbb{G}\\quad\\right\\}</span></p>

    <p class="text-gray-300">PoE is a sound argument system under the adaptive root assumption for Ggen. It is neither zero-knowledge nor knowledge sound. Its main feature is succinctness, as the verifier can get convinced about <span class="math">u^{x}=w</span> without having to execute the exponentiation herself. Moreover the information sent by the prover is only 1 group element.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Protocol PoKE^{∗}: is an argument of knowledge for the following relation, parametrized by a generator <span class="math">g\\in\\mathbb{G}</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">R_{\\mathsf{PoKE}^{*}}=\\left\\{(w,x)\\in\\mathbb{G}\\times\\mathbb{Z}\\ :\\ g^{x}=w\\in\\mathbb{G}\\quad\\right\\}</span></p>

    <p class="text-gray-300">PoKE^{∗} is an argument of knowledge that in <em>[x1]</em> is proven secure in the generic group model for hidden order groups <em>[x12]</em>. This protocol is also succinct consisting of only 1 group element and 1 field element in <span class="math">\\mathbb{Z}_{2^{\\lambda}}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Protocol PoKE2: is an argument of knowledge for the following relation, parametrized by a generator <span class="math">g\\in\\mathbb{G}</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">R_{\\mathsf{PoKE2}}=\\left\\{((w,u)\\in\\mathbb{G}^{2},x\\in\\mathbb{Z})\\ :\\ u^{x}=w\\in\\mathbb{G}\\quad\\right\\}</span></p>

    <p class="text-gray-300">PoKE2 is similar to PoKE^{∗} but it is secure for arbitrary bases <span class="math">u</span> chosen by the adversary, instead of bases randomly sampled a priori as in PoKE^{∗}. Similarly, it is an argument of knowledge in the generic group model for hidden order groups and is also succinct, with a proof consisting of 2 group elements and 1 element of <span class="math">\\mathbb{Z}_{2^{\\lambda}}</span>.</p>

    <h2 id="sec-10" class="text-2xl font-bold">3 Vector Commitments with Incremental Aggregation</h2>

    <p class="text-gray-300">In this section, we recall the notion of vector commitment with subvector openings <em>[x7, x20, x1]</em> and then we formally define our new incremental aggregation property.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">3.1 Vector Commitments with Subvector Openings</h3>

    <p class="text-gray-300">A vector commitment (VC) <em>[x22, x7]</em> is a primitive that allows one to commit to a vector <span class="math">\\vec{v}</span> of length <span class="math">n</span> in such a way that it can later open the commitment at any position <span class="math">i\\in[n]</span>. For</p>

    <p class="text-gray-300">security, a VC should be position binding in the sense that it is not possible to open a commitment to two different values at the same position. Also, what makes VC interesting is conciseness, which requires commitment and openings to be of fixed size, independent of the vector's length.</p>

    <p class="text-gray-300">In our work we consider a generalization of vector commitments proposed by Lai and Malavolta [LM19] that is called  <span class="math">VCs</span>  with subvector openings, <span class="math">^{15}</span>  which is in turn a specialization of the notion of functional vector commitments by Libert et al. [LRY16]. In a nutshell, a functional VC is like a VC with the additional possibility of opening the commitment to a function of the committed vector, i.e.,  <span class="math">f(\\vec{v})</span> . Subvector openings are a specific class of functions in which one can open the commitment to an ordered collection of positions (with a short proof).</p>

    <p class="text-gray-300">In this section we recall this generalization of vector commitments with subvector openings (that for brevity we call SVC). It is easy to see that the original notion of Catalano and Fiore [CF13] is a special case when the opened subvector includes one position only.</p>

    <p class="text-gray-300">We begin by recalling the notion of subvectors from [LM19].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 3.1 (Subvectors [LM19]). Let  <span class="math">\\mathcal{M}</span>  be a set,  <span class="math">n\\in \\mathbb{N}</span>  be a positive integer and  $I = \\{i_1,\\ldots ,i_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\} \\subseteq [n]<span class="math">  be an ordered index set. For a vector  </span>\\vec{v}\\in \\mathcal{M}^n<span class="math"> , the  </span>I<span class="math"> -subvector of  </span>\\vec{v}<span class="math">  is  </span>\\vec{v}_I\\coloneqq (v_{i_1},\\dots,v_{i_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let  <span class="math">I, J \\subseteq [n]</span>  be two sets, and let  <span class="math">\\vec{v}_I, \\vec{v}_J</span>  be two subvectors of some vector  <span class="math">\\vec{v} \\in \\mathcal{M}^n</span> . The ordered union of  <span class="math">\\vec{v}_I</span>  and  <span class="math">\\vec{v}_J</span>  is the subvector  <span class="math">\\vec{v}_{I \\cup J} := (v_{k_1}, \\ldots, v_{k_m})</span> , where  <span class="math">I \\cup J = \\{k_1, \\ldots, k_m\\}</span>  is the ordered sets union of  <span class="math">I</span>  and  <span class="math">J</span> .</p>

    <p class="text-gray-300">Definition 3.2 (Vector Commitments with Subvector Openings). A vector commitment scheme with subvector openings (SVC) is a tuple of algorithms  <span class="math">\\mathsf{VC} = (\\mathsf{VC}. \\mathsf{Setup}, \\mathsf{VC}. \\mathsf{Com}, \\mathsf{VC}. \\mathsf{Open}, \\mathsf{VC}. \\mathsf{Ver})</span>  that work as follows and satisfy correctness, position binding and conciseness defined below.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{VC}. \\mathsf{Setup}(1^{\\lambda}, \\mathcal{M}) \\to \\mathsf{crs}</span>  Given the security parameter  <span class="math">\\lambda</span> , and description of a message space  <span class="math">\\mathcal{M}</span>  for the vector components, the probabilistic setup algorithm outputs a common reference string  <span class="math">\\mathsf{crs}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathsf{VC}. \\mathsf{Com}(\\mathsf{crs}, \\vec{v}) \\to (C, \\mathsf{aux})</span>  On input  <span class="math">\\mathsf{crs}</span>  and a vector  <span class="math">\\vec{v} \\in \\mathcal{M}^n</span> , the committing algorithm outputs a commitment  <span class="math">C</span>  and an auxiliary information  <span class="math">\\mathsf{aux}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathsf{VC}. \\mathsf{Open}(\\mathsf{crs}, I, \\vec{y}, \\mathsf{aux}) \\to \\pi_I</span>  On input the CRS  <span class="math">\\mathsf{crs}</span> , a vector  <span class="math">\\vec{y} \\in \\mathcal{M}^m</span> , an ordered index set  <span class="math">I \\subset \\mathbb{N}</span>  and auxiliary information  <span class="math">\\mathsf{aux}</span> , the opening algorithm outputs a proof  <span class="math">\\pi_I</span>  that  <span class="math">\\vec{y}</span>  is the  <span class="math">I</span> -subvector of the committed message.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{VC}. \\mathsf{Ver}(\\mathsf{crs}, C, I, \\vec{y}, \\pi_I) \\to b \\in \\{0, 1\\}</span>  On input the CRS  <span class="math">\\mathsf{crs}</span> , a commitment  <span class="math">C</span> , an ordered set of indices  <span class="math">I \\subset \\mathbb{N}</span> , a vector  <span class="math">\\vec{y} \\in \\mathcal{M}^m</span>  and a proof  <span class="math">\\pi_I</span> , the verification algorithm accepts (i.e., it outputs 1) only if  <span class="math">\\pi_I</span>  is a valid proof that  <span class="math">C</span>  was created to a vector  <span class="math">\\vec{v} = (v_1, \\ldots, v_n)</span>  such that  <span class="math">\\vec{y} = \\vec{v}_I</span> .</p>

    <p class="text-gray-300">Correctness. A SVC scheme VC is (perfectly) correct if for all  <span class="math">\\lambda \\in \\mathbb{N}</span> , any vector length  <span class="math">n</span>  any ordered set of indices  <span class="math">I \\subseteq [n]</span> , and any  <span class="math">\\vec{v} \\in \\mathcal{M}^n</span> , we have:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c c} &amp;amp; \\mathsf {c r s} \\leftarrow \\mathsf {V C . S e t u p} (1 ^ {\\lambda}, \\mathcal {M}) \\\\ \\mathsf {V C . V e r} (\\mathsf {c r s}, C, I, \\vec {v} _ {I}, \\pi_ {I}) = 1 &amp;amp; : \\quad (C, \\mathsf {a u x}) \\leftarrow \\mathsf {V C . C o m} (\\mathsf {c r s}, \\vec {v}) \\\\ &amp;amp; \\pi_ {I} \\leftarrow \\mathsf {V C . O p e n} (\\mathsf {c r s}, I, \\vec {v} _ {I}, \\mathsf {a u x}) \\end{array} \\right] = 1</span></div>

    <p class="text-gray-300">This is also called VCs with batchable openings in an independent work by Boneh et al. [BBF19].</p>

    <p class="text-gray-300">Position Binding. A SVC scheme VC satisfies position binding if for all PPT adversaries <span class="math">\\mathcal{A}</span> we have:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{c c} \\mathsf{VC.Ver}(\\mathsf{crs}, C, I, \\vec{y}, \\pi) = 1 &amp;amp; \\\\ \\wedge \\vec{y} \\neq \\vec{y}&#x27; \\wedge &amp;amp; : \\quad \\mathsf{crs} \\leftarrow \\mathsf{VC.Setup}(1^{\\lambda}, \\mathcal{M}) \\\\ \\mathsf{VC.Ver}(\\mathsf{crs}, C, I, \\vec{y}&#x27;, \\pi&#x27;) = 1 &amp;amp; (C, I, \\vec{y}, \\pi, \\vec{y}&#x27;, \\pi&#x27;) \\leftarrow \\mathcal{A}(\\mathsf{crs}) \\end{array} \\right] \\in \\mathsf{negl}(\\lambda)</span></div>

    <p class="text-gray-300">Conciseness. A vector commitment is concise if there is a fixed polynomial <span class="math">p(\\lambda)</span> in the security parameter such that the size of the commitment <span class="math">C</span> and the outputs of VC.Open are both bounded by <span class="math">p(\\lambda)</span>, i.e., they are independent of <span class="math">n</span>.</p>

    <p class="text-gray-300">Vector Commitments with Specializable Universal CRS. The notion of VCs defined above slightly generalizes the previous ones in which the generation of public parameters (aka common reference string) depends on a bound <span class="math">n</span> on the length of the committed vectors. In contrast, in our notion VC.Setup is length-independent. To highlight this property, we also call this primitive vector commitments with universal CRS.</p>

    <p class="text-gray-300">Here we formalize a class of VC schemes that lies in between VCs with universal CRS (as defined above) and VCs with length-specific CRS (as defined in [CF13]). Inspired by the recent work of Groth et al. [GKM⁺18], we call these schemes VCs with Specializable (Universal) CRS. In a nutshell, these are schemes in which the algorithms VC.Com, VC.Open and VC.Ver work on input a length-specific CRS <span class="math">\\mathsf{crs}_n</span>. However, this <span class="math">\\mathsf{crs}_n</span> is generated in two steps: (i) a length-independent, probabilistic setup <span class="math">\\mathsf{crs} \\gets \\mathsf{VC.Setup}(1^{\\lambda}, \\mathcal{M})</span>, and (ii) a length-dependent, deterministic specialization <span class="math">\\mathsf{crs}_n \\gets \\mathsf{VC.Specialize}(\\mathsf{crs}, n)</span>. The advantage of this model is that, being VC.Specialize deterministic, it can be executed by anyone, and it allows to re-use the same <span class="math">\\mathsf{crs}</span> for multiple vectors lengths.</p>

    <p class="text-gray-300">Definition 3.3 (VCs with Specializable CRS). A VC scheme VC has a specializable CRS if there exists a DPT algorithm VC.Specialize(crs, n) that, on input a (universal) CRS crs generated by VC.Setup(1^λ, M) and an integer <span class="math">n = \\text{poly}(\\lambda)</span>, produces a specialized CRS <span class="math">\\mathsf{crs}_n</span> such that the algorithms VC.Com, VC.Open and VC.Ver can be defined in terms of algorithms VC.Com<em>, VC.Open</em> and VC.Ver* as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- VC.Com(crs, <span class="math">\\vec{v}</span>) sets $n :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, runs </span>\\mathsf{crs}_n \\gets \\mathsf{VC.Specialize}(\\mathsf{crs}, n)<span class="math"> and </span>(C^<em>, \\mathsf{aux}^</em>) \\gets \\mathsf{VC.Com}^<em>(\\mathsf{crs}_n, \\vec{v})<span class="math">, and returns </span>C := (C^</em>, n)<span class="math"> and </span>\\mathsf{aux} := (\\mathsf{aux}^*, n)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>VC.Open(crs, <span class="math">I, \\vec{y}, \\mathsf{aux}</span>) parses <span class="math">\\mathsf{aux} := (\\mathsf{aux}^<em>, n)</span>, runs <span class="math">\\mathsf{crs}_n \\gets \\mathsf{VC.Specialize}(\\mathsf{crs}, n)</span> and returns <span class="math">\\pi_I \\gets \\mathsf{VC.Open}^</em>(\\mathsf{crs}_n, I, \\vec{y}, \\mathsf{aux}^*)</span>.</li>

      <li>VC.Ver(crs, <span class="math">C, I, \\vec{y}, \\pi_I</span>) parses <span class="math">C := (C^<em>, n)</span>, runs <span class="math">\\mathsf{crs}_n \\gets \\mathsf{VC.Specialize}(\\mathsf{crs}, n)</span> and returns VC.Ver<span class="math">^</em>(\\mathsf{crs}_n, C^*, I, \\vec{y}, \\pi_I)</span>.</li>

    </ul>

    <p class="text-gray-300">Basically, for a VC with specializable CRS it is sufficient to describe the algorithms VC.Setup, VC.Specialize, VC.Com<em>, VC.Open</em> and VC.Ver*. Furthermore, a concrete advantage is that when working on multiple commitments, openings and verifications that involve the same length <span class="math">n</span>, one can execute <span class="math">\\mathsf{crs}_n \\gets \\mathsf{VC.Specialize}(\\mathsf{crs}, n)</span> only once.</p>

    <h2 id="sec-12" class="text-2xl font-bold">3.2 Incrementally Aggregatable Subvector Openings</h2>

    <p class="text-gray-300">In a nutshell, aggregation means that different proofs of different subvector openings can be merged together into a single short proof which can be created without knowing the entire committed vector.</p>

    <p class="text-gray-300">15</p>

    <p class="text-gray-300">Moreover, this aggregation is composable, namely aggregated proofs can be further aggregated. Following a terminology similar to that of aggregate signatures, we call this property incremental aggregation (but can also be called multi-hop aggregation). In addition to aggregating openings, we also consider the possibility to “disaggregate” them, namely from an opening of positions in the set <span class="math">I</span> one can create an opening for positions in a set <span class="math">K\\subset I</span>.</p>

    <p class="text-gray-300">We stress on the two main requirements that make aggregation and disaggregation non-trivial: all openings must remain short (independently of the number of positions that are being opened), and aggregation (resp. disaggregation) must be computable locally, i.e., without knowing the whole committed vector. Without such requirements, one could achieve this property by simply concatenating openings of single positions.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 3.4 (Aggregatable Subvector Openings).</h6>

    <p class="text-gray-300">A vector commitment scheme <span class="math">\\mathsf{VC}</span> with subvector openings is called <em>aggregatable</em> if there exists algorithms <span class="math">\\mathsf{VC.Agg}</span>, <span class="math">\\mathsf{VC.Disagg}</span> working as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{VC.Agg}(\\mathsf{crs},(I,\\vec{v}_{I},\\pi_{I}),(J,\\vec{v}_{J},\\pi_{J}))\\rightarrow\\pi_{K}</span> takes as input two triples <span class="math">(I,\\vec{v}_{I},\\pi_{I}),(J,\\vec{v}_{J},\\pi_{J})</span> where <span class="math">I</span> and <span class="math">J</span> are sets of indices, $\\vec{v}_{I}\\in\\mathcal{M}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and </span>\\vec{v}_{J}\\in\\mathcal{M}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> are subvectors, and </span>\\pi_{I}<span class="math"> and </span>\\pi_{J}<span class="math"> are opening proofs. It outputs a proof </span>\\pi_{K}<span class="math"> that is supposed to prove opening of values in positions </span>K=I\\cup J$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{VC.Disagg}(\\mathsf{crs},I,\\vec{v}_{I},\\pi_{I},K)\\rightarrow\\pi_{K}</span> takes as input a triple <span class="math">(I,\\vec{v}_{I},\\pi_{I})</span> and a set of indices <span class="math">K\\subset I</span>, and it outputs a proof <span class="math">\\pi_{K}</span> that is supposed to prove opening of values in positions <span class="math">K</span>.</p>

    <p class="text-gray-300">The aggregation algorithm <span class="math">\\mathsf{VC.Agg}</span> must guarantee the following two properties:</p>

    <p class="text-gray-300">Aggregation Correctness. Aggregation is (perfectly) correct if for all <span class="math">\\lambda\\in\\mathbb{N}</span>, all honestly generated <span class="math">\\mathsf{crs}\\leftarrow\\mathsf{VC.Setup}(1^{\\lambda},\\mathcal{M})</span>, any commitment <span class="math">C</span> and triple <span class="math">(I,\\vec{v}_{I},\\pi_{I})</span> s.t. <span class="math">\\mathsf{VC.Ver}(\\mathsf{crs},C,I,\\vec{v}_{I},\\pi_{I})=1</span>, the following two properties hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for any triple <span class="math">(J,\\vec{v}_{J},\\pi_{J})</span> such that <span class="math">\\mathsf{VC.Ver}(\\mathsf{crs},C,J,\\vec{v}_{J},\\pi_{J})=1</span>,</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{VC.Ver}(\\mathsf{crs},C,K,\\vec{v}_{K},\\pi_{K})=1\\ :\\ \\pi_{K}\\leftarrow\\mathsf{VC.Agg}(\\mathsf{crs},(I,\\vec{v}_{I},\\pi_{I}),(J,\\vec{v}_{J},\\pi_{J}))\\right]=1</span></p>

    <p class="text-gray-300">where <span class="math">K=I\\cup J</span> and <span class="math">\\vec{v}_{K}</span> is the ordered union <span class="math">\\vec{v}_{I\\cup J}</span> of <span class="math">\\vec{v}_{I}</span> and <span class="math">\\vec{v}_{J}</span>;</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for any subset of indices <span class="math">K\\subset I</span>,</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{VC.Ver}(\\mathsf{crs},C,K,\\vec{v}_{K},\\pi_{K})=1\\ :\\ \\pi_{K}\\leftarrow\\mathsf{VC.Disagg}(\\mathsf{crs},I,\\vec{v}_{I},\\pi_{I},K)\\right]=1</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\vec{v}_{K}=(v_{i_{l}})_{i_{l}\\in K}</span>, for $\\vec{v}_{I}=(v_{i_{1}},\\ldots,v_{i_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Aggregation Conciseness. There exists a fixed polynomial <span class="math">p(\\cdot)</span> in the security parameter such that all openings produced by <span class="math">\\mathsf{VC.Agg}</span> and <span class="math">\\mathsf{VC.Disagg}</span> have length bounded by <span class="math">p(\\lambda)</span>.</p>

    <p class="text-gray-300">We remark that the notion of specializable CRS can apply to aggregatable VCs as well. In this case, we let <span class="math">\\mathsf{VC.Agg}^{\\star}</span> (resp. <span class="math">\\mathsf{VC.Disagg}^{\\star}</span>) be the algorithm that works on input the specialized <span class="math">\\mathsf{crs}_{n}</span> instead of <span class="math">\\mathsf{crs}</span></p>

    <p class="text-gray-300">4 Applications of Incremental Aggregation</p>

    <p class="text-gray-300">We discuss two general applications of the incremental aggregation property of vector commitments.</p>

    <p class="text-gray-300">One application is generating subvector openings in a distributed and decentralized way. Namely, assume a set of parties hold each an opening of some subvector. Then it is possible to create a (concise) opening for the union of their subvectors by using the VC.Agg algorithm. Moreover, the incremental (aka multi-hop) aggregation allows these users to perform this operation in an arbitrary order, hence no coordination or a central aggregator party are needed. This application is particularly useful in our extension to verifiable decentralized storage.</p>

    <p class="text-gray-300">The second application is to generate openings in a faster way via preprocessing. As we mentioned in the introduction, this technique is useful in the scenario where a user commits to a vector and then must generate openings for various subvectors, which is for example the use case when the VC is used for proofs of retrievability and IOPs <em>[x1]</em>.</p>

    <p class="text-gray-300">So, here the goal is to achieve a method for computing subvector openings in time sub-linear in the total size of the vector, which is the barrier in all existing constructions. To obtain this speedup, the basic idea is to (A) compute and store openings for all the position at commitment time, and then (B) use the aggregation property to create an opening for a specific set of positions. In order to obtain efficiency using this approach it is important that both steps (A) and (B) can be computed efficiently. In particular, step (A) is challenging since typically computing one opening takes linear time, hence computing all of them would take quadratic time.</p>

    <p class="text-gray-300">In this section, we show how steps (A) and (B) can benefit from disaggregation and aggregation respectively. As a preliminary for this technique, we begin by describing two generic extensions of (incremental) aggregation (resp. disaggregation) that support many inputs (resp. outputs). Then we show how these extended algorithms can be used for committing and opening with preprocessing.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">4.1 Divide-and-Conquer Extensions of Aggregation and Disaggregation</h3>

    <p class="text-gray-300">We discuss how the incremental property of our aggregation and disaggregation can be used to define two extended versions of these algorithms. The first one is an algorithm that can aggregate many openings for different sets of positions into a single opening for their union. The second one does the opposite, namely it disaggregates one opening for a set <span class="math">I</span> into many openings for partitions of <span class="math">I</span>.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Aggregating Many Openings</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We consider the problem of aggregating several openings for sets of positions <span class="math">I_{1},\\ldots,I_{m}</span> into a single opening for <span class="math">\\bigcup_{j=1}^{m}I_{j}</span>. Our syntax in Definition 3.4 only considers pairwise aggregation. This can be used to handle many aggregations by executing the pairwise aggregation in a sequential (or arbitrary order) fashion. Sequential aggregation might however be costly since it would require executing VC.Agg on increasingly growing sets. If <span class="math">f_{a}(k)</span> is the complexity of VC.Agg on two sets of total size <span class="math">k</span>, then the total complexity of the sequential method is $\\sum_{j=2}^{m}f(\\sum_{l=1}^{j-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_{l}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, which for example is quadratic in </span>m<span class="math">, for </span>f_{a}(k)=\\Theta(k)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Fig. 1, we show an algorithm, VC.AggManyToOne, that is a nearly optimal solution for aggregating <span class="math">m</span> openings based on a divide-and-conquer methodology. Assuming for simplicity that all <span class="math">I_{j}</span>’s have size bounded by some <span class="math">s</span>, then the complexity of VC.AggManyToOne is given by the following recurrence relation:</p>

    <p class="text-gray-300"><span class="math">T(m)=2T\\left(\\frac{m}{2}\\right)+f_{a}(s\\cdot m)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VC.AggManyToOne(crs, (Ij, vIj, πj)j∈[m])</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VC.DisaggOneToMany(crs, B, I, vI, πI)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1: if m = 1 return π1</td>

            <td class="px-3 py-2 border-b border-gray-700">1: if n =</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">= B return πI</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2: m' ← m/2</td>

            <td class="px-3 py-2 border-b border-gray-700">2: n' ← n/2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3: L ← ∪m' j=1 Ij, R ← ∪m' j=m'+1 Ij,</td>

            <td class="px-3 py-2 border-b border-gray-700">3: L ← ∪n' j=1 ij, R ← ∪m' j=n'+1 ij,</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4: πL ← VC.AggManyToOne(crs, (Ij, vIj, πj)j=1,...,m')</td>

            <td class="px-3 py-2 border-b border-gray-700">4: πL' ← VC.Disagg(crs, I, vI, πI, L)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5: πR ← VC.AggManyToOne(crs, (Ij, vIj, πj)j=m'+1,...,m)</td>

            <td class="px-3 py-2 border-b border-gray-700">5: πR' ← VC.Disagg(crs, I, vI, πI, R)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6: πL∪R ← VC.Agg(crs, (L, vL, πL), (R, vR, πR))</td>

            <td class="px-3 py-2 border-b border-gray-700">6: πL' ← VC.DisaggOneToMany(crs, B, L, vL, πL')</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7: return πL∪R</td>

            <td class="px-3 py-2 border-b border-gray-700">7: πR' ← VC.DisaggOneToMany(crs, B, R, vR, πR')</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8: return πL</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">πR</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 1. Extensions of Aggregation and Disaggregation</p>

    <p class="text-gray-300">which for example solves to  <span class="math">\\Theta(s \\cdot m \\log m)</span>  if  <span class="math">f_a(n) \\in \\Theta(n)</span> , or to  <span class="math">\\Theta(s \\cdot m \\log (sm) \\log m)</span>  if  <span class="math">f_a(n) \\in \\Theta(n \\log n)</span> .</p>

    <p class="text-gray-300">Disaggregating from One to Many Openings We consider the problem that is dual to the one above, namely how to disaggregate an opening for a set  <span class="math">I</span>  into several openings for sets  <span class="math">I_1, \\ldots, I_m</span>  that form a partition of  <span class="math">I</span> . Our syntax in Definition 3.4 only considers disaggregation from one set  <span class="math">I</span>  to one subset  <span class="math">K</span>  of  <span class="math">I</span> . Similarly to the aggregation case, disaggregating from one set to many subsets can be trivially obtained via a sequential application of VC.Disagg on all pairs  <span class="math">(I, I_j)</span> . This however can be costly if the number of partitions approaches the size of  <span class="math">I</span> , e.g., if we want to disaggregate to all the elements of  <span class="math">I</span> .</p>

    <p class="text-gray-300">In Fig. 1, we show an algorithm, VC.DisaggOneToMany, we show a divide-and-conquer algorithm for disaggregating an opening for a set  <span class="math">I</span>  of size  <span class="math">m</span>  into  <span class="math">m&#x27; = m / B</span>  openings, each for a partition of size  <span class="math">B</span> . For simplicity, we assume that  <span class="math">m</span>  is a power of 2, and  <span class="math">B \\mid m</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  $f_{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  be the complexity of VC.Disagg. Then the complexity of VC.DisaggOneToMany is given by the following recurrence relation:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">T (m) = 2 T \\left(\\frac {m}{2}\\right) + 2 f _ {d} (m / 2)</span></div>

    <p class="text-gray-300">which for example solves to  <span class="math">\\Theta(m\\log(m/B))</span>  if  <span class="math">f_d(n) \\in \\Theta(n)</span> , or to  <span class="math">\\Theta(m\\log m\\log(m/B))</span>  if  <span class="math">f_d(n) \\in \\Theta(n\\log n)</span> .</p>

    <p class="text-gray-300">We present a construction of committing and opening algorithms (denoted VC.PPCom and VC.FastOpen respectively) that works generically for any SVC with incremental aggregation and that, by relying on preprocessing, can achieve fast opening time.</p>

    <p class="text-gray-300">Our preprocessing method works with a flexible choice of a parameter  <span class="math">B</span>  that allows for different time-memory tradeoffs. In a nutshell, ranging from 1 to  <span class="math">n</span> , a larger  <span class="math">B</span>  reduces memory but increases opening time while a smaller  <span class="math">B</span>  (e.g.,  <span class="math">B = 1</span> ) requires larger storage overhead but gives the fastest opening time.</p>

    <p class="text-gray-300">Let  <span class="math">B</span>  be an integer that divides  <span class="math">n</span> , and let  <span class="math">n&#x27; = n / B</span> . The core of our idea is that, during the commitment stage, one can create openings for  <span class="math">n&#x27; = n / B</span>  subvectors of  <span class="math">\\vec{v}</span>  that cover the all</p>

    <p class="text-gray-300">vector (e.g.,  <span class="math">B</span>  contiguous positions). Let  <span class="math">\\pi_{P_1},\\ldots ,\\pi_{P_{n&#x27;}}</span>  be such openings; these elements are stored as advice information.</p>

    <p class="text-gray-300">Next, in the opening phase, in order to compute the opening for a subvector  <span class="math">\\vec{v}_I</span>  of  <span class="math">m</span>  positions, one should: (i) fetch the subset of openings  <span class="math">\\pi_{P_j}</span>  such that, for some  <span class="math">S</span> ,  <span class="math">I \\subseteq \\cup_{j \\in S} P_j</span> , (ii) possibly disaggregate some of them and then aggregate in order to compute  <span class="math">\\pi_I</span> .</p>

    <p class="text-gray-300">To give a very general example of the above process, assume one has stored  <span class="math">\\pi_{\\{1,2\\}}</span>  and  <span class="math">\\pi_{\\{3,4,5\\}}</span>  and is asked for  <span class="math">\\pi_{\\{2,3\\}}</span> , then she has to compute first  <span class="math">\\pi_2</span>  and  <span class="math">\\pi_3</span>  by disaggregating  <span class="math">\\pi_{\\{1,2\\}}</span>  and  <span class="math">\\pi_{\\{3,4,5\\}}</span>  respectively, and then aggregate them to  <span class="math">\\pi_{\\{2,3\\}}</span> . Below are two more examples in picture:</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> <span class="math">\\approx p(\\lambda)\\cdot n / 2</span>  bits in opening advice</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> <span class="math">p(\\lambda)</span>  bits in opening advice</p>

    <p class="text-gray-300">The two algorithms VC.PPCom and VC.FastOpen are described in detail in Fig. 2.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 2. Generic algorithms for committing and opening with precomputation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In terms of auxiliary storage, in addition to the vector  <span class="math">\\vec{v}</span>  itself, one needs at most  <span class="math">(n / B)p(\\lambda)</span>  bits, where  <span class="math">p(\\lambda)</span>  is the polynomial bounding the conciseness of the SVC scheme. In terms of time complexity, VC.PPCom requires one execution of VC.Com, one execution of VC.Open, and one execution of VC.DisaggOneToMany, which in turn depends on the complexity of VC.Disagg; VC.FastOpen requires to perform (at most)  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  disaggregations (each with a set  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  such that their sum is  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{16}<span class="math"> , and one execution of VC.AggManyToOne on  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  openings. Note that VC.FastOpen's running time</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">depends only on the size <span class="math">m</span> of the set <span class="math">I</span> and size <span class="math">B</span> of the buckets <span class="math">P_{j}</span>, and thus offers various tradeoffs by adjusting <span class="math">B</span>.</p>

    <p class="text-gray-300">More specific running times depend on the complexity of VC.Com, VC.Open, VC.Agg, and VC.Disagg of the given SVC scheme. See Appendix B for these results for our construction.</p>

    <h2 id="sec-17" class="text-2xl font-bold">5 Our Realizations of Incrementally Aggregatable Vector Commitments</h2>

    <p class="text-gray-300">In this section we describe our new SVC realizations.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">5.1 Our First SVC Construction</h3>

    <p class="text-gray-300">An overview of our techniques. The basic idea underlying our VC can be described as a generic construction from any accumulator with union proofs. Consider a vector of bits <span class="math">\\vec{v}=(v_{1},\\ldots,v_{n})\\in\\{0,1\\}^{n}</span>. In order to commit to this vector we produce two accumulator, Acc_{0} and Acc_{1}, on two partitions of the set <span class="math">S=\\{1,\\ldots,n\\}</span>. Each accumulator Acc_{b} compresses the set of positions <span class="math">i</span> such that <span class="math">v_{i}=b</span>. In other words, Acc_{b} compresses the set <span class="math">S_{=b}:=\\{i\\in S:v_{i}=b\\}</span> with <span class="math">b\\in\\{0,1\\}</span>. In order to open to bit <span class="math">b</span> at position <span class="math">i</span>, one can create an accumulator membership proof for the statement <span class="math">i\\in\\tilde{S}_{b}</span> where we denote by <span class="math">\\tilde{S}_{b}</span> the alleged set of positions that have value <span class="math">b</span>.</p>

    <p class="text-gray-300">However, if the commitment to <span class="math">\\vec{v}</span> is simply the pair of accumulators (Acc_{0}, Acc_{1}) we do not achieve position binding as an adversary could for example include the same element <span class="math">i</span> in both accumulators. To solve this issue we set the commitment to be the pair of accumulators plus a succinct non-interactive proof <span class="math">\\pi_{S}</span> that the two sets <span class="math">\\tilde{S}_{0},\\tilde{S}_{1}</span> they compress constitute together a partition of <span class="math">S</span>. Notably, this proof <span class="math">\\pi_{S}</span> guarantees that each index <span class="math">i</span> is in either <span class="math">\\tilde{S}_{0}</span> or <span class="math">\\tilde{S}_{1}</span>, and thus prevents an adversary from also opening the position <span class="math">i</span> to the complement bit <span class="math">1-b</span>.</p>

    <p class="text-gray-300">The construction described above could be instantiated with any accumulator scheme that admits an efficient and succinct proof of union. We, though, directly present an efficient construction based on RSA accumulators <em>[x1, x3, x10, x12, x2]</em> as this is efficient and has some nice extra properties like aggregation and constant-size parameters. Also, part of our technical contribution to construct this VC scheme is the construction of efficient and succinct protocols for proving the union of two RSA accumulators built with different generators.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Succinct AoK Protocols for Union of RSA Accumulators</h4>

    <p class="text-gray-300">Let <span class="math">\\mathbb{G}</span> be a hidden order group as generated by Ggen, and let <span class="math">g_{1},g_{2},g_{3}\\in\\mathbb{G}</span> be three honestly sampled random generators. We propose a succinct argument of knowledge for the following relation</p>

    <p class="text-gray-300"><span class="math">R_{\\mathsf{PoProd}_{2}}=\\left\\{((Y,C),(a,b))\\in\\mathbb{G}^{2}\\times\\mathbb{Z}^{2}\\ :\\ Y=g_{1}^{a}g_{2}^{b}\\wedge C=g_{3}^{a\\cdot b}\\quad\\right\\}</span></p>

    <p class="text-gray-300">Our protocol (described in Fig. 3) is inspired by a similar protocol of Boneh et al. <em>[x2]</em>, PoDDH, for a similar relation in which there is only one generator (i.e., <span class="math">g_{1}=g_{2}=g_{3}</span>, namely for DDH tuples <span class="math">(g^{a},g^{b},g^{ab})</span>). Their protocol has a proof consisting of 3 groups elements and 2 integers of <span class="math">\\lambda</span> bits.</p>

    <p class="text-gray-300">As we argue later <span class="math">\\mathsf{PoProd}_{2}</span> is still sufficient for our construction, i.e., for the goal of proving that <span class="math">C=g_{3}^{c}</span> is an accumulator to a set that is the union of sets represented by two accumulators <span class="math">A=g_{1}^{a}</span> and <span class="math">B=g_{2}^{b}</span> respectively. The idea is to invoke <span class="math">\\mathsf{PoProd}_{2}</span> on <span class="math">(Y,C)</span> with <span class="math">Y=A\\cdot B</span>.</p>

    <p class="text-gray-300">To prove the security of our protocol we rely on the adaptive root assumption and, in a non-black-box way, on the knowledge extractability of the PoKRep and PoKE^{∗} protocols from <em>[x2]</em>. The latter is proven in the generic group model for hidden order groups (where also the adaptive root assumption holds), therefore we state the following theorem.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 3. PoProd2 protocol</p>

    <p class="text-gray-300">Theorem 5.1. The  <span class="math">\\mathsf{PoProd}_2</span>  protocol is an argument of knowledge for  <span class="math">R_{\\mathsf{PoProd}_2}</span>  in the generic group model.</p>

    <p class="text-gray-300">Proof For ease of exposition we show a security proof for a slight variant of the protocol  <span class="math">\\mathsf{PoProd}_2</span> . Then, towards the end of this proof we show that security of this variant implies security for our protocol. We let  <span class="math">\\mathsf{PoProd}_2&#x27;</span>  be the same protocol as  <span class="math">\\mathsf{PoProd}_2</span>  with only difference that the prover computes also  <span class="math">r_c \\gets r_a \\cdot r_b \\pmod{\\ell}</span>  and sends  <span class="math">r_c</span>  in the proof, and the verifier  <span class="math">\\mathsf{V}</span>  checks in the verification if  <span class="math">r_c = r_a \\cdot r_b \\pmod{\\ell}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{A}&#x27; = (\\mathcal{A}_0&#x27;, \\mathcal{A}_1&#x27;)</span>  be an adversary of the Knowledge Extractability of  <span class="math">\\mathsf{PoProd}_2&#x27;</span>  such that:  <span class="math">((Y, C), \\text{state}) \\gets \\mathcal{A}_0&#x27;(\\text{crs})</span> ,  <span class="math">\\mathcal{A}_1&#x27;(\\text{crs}, (Y, C), \\text{state})</span>  executes with  <span class="math">\\mathsf{V}(\\text{crs}, (Y, C))</span>  the protocol  <span class="math">\\mathsf{PoProd}_2&#x27;</span>  and the verifier accepts with a non-negligible probability  <span class="math">\\epsilon</span> . We will construct an extractor  <span class="math">\\mathcal{E}&#x27;</span>  that having access to the internal state of  <span class="math">\\mathcal{A}_1&#x27;</span>  and on input  <span class="math">(\\text{crs}, (Y, C), \\text{state})</span> , outputs a witness  <span class="math">(a, b)</span>  of  <span class="math">R_{\\mathsf{PoProd}_2&#x27;}</span>  with overwhelming probability and runs in (expected) polynomial time.</p>

    <p class="text-gray-300">To prove knowledge extractability of  <span class="math">\\mathsf{PoProd}_2&#x27;</span>  we rely on the knowledge extractability of the protocol PoKRep from [BBF19], which is indeed implicit in our protocol. More precisely, given a  <span class="math">\\mathsf{PoProd}_2&#x27;</span>  execution between  <span class="math">\\mathcal{A}&#x27;</span>  and  <span class="math">\\mathsf{V}</span> ,  <span class="math">(\\ell, Q_Y, Q_C, r_a, r_b, r_c)</span> ,  <span class="math">\\mathcal{E}&#x27;</span>  constructs an adversary  <span class="math">\\mathcal{A}_Y = (\\mathcal{A}_{Y,0}, \\mathcal{A}_{Y,1})</span>  of PoKRep Knowledge Extractability and, by using the input and internal state of  <span class="math">\\mathcal{A}_1&#x27;</span> , simulates an execution between  <span class="math">\\mathcal{A}_Y</span>  and  <span class="math">\\mathsf{V}</span> :  <span class="math">\\mathcal{A}_{Y,0}</span>  outputs  <span class="math">(\\mathsf{crs}_Y, Y, \\mathsf{state}) := ((\\mathbb{G}, g_1, g_2), Y, \\mathsf{state})</span> ,  <span class="math">\\mathcal{A}_{Y,1}</span>  outputs  <span class="math">(Q_Y, r_a, r_b)</span> . It is obvious that if the initial execution is accepted by  <span class="math">\\mathsf{V}</span>  so is the PoKRep execution. From Knowledge Extractability of PoKRep we know that there exists an extractor  <span class="math">\\mathcal{E}_Y</span>  corresponding to  <span class="math">\\mathcal{A}_{Y,1}</span>  that outputs  <span class="math">(a, b)</span>  such that  <span class="math">g_1^a g_2^b = Y</span> . Additionally, it is implicit from the extraction that  <span class="math">a = r_a</span>  (mod  <span class="math">\\ell</span> ) and  <span class="math">b = r_b</span>  (mod  <span class="math">\\ell</span> ) (for more details we refer to the Knowledge Extractability proof of PoKRep in [BBF19]). So,  <span class="math">\\mathcal{E}&#x27;</span>  uses  <span class="math">\\mathcal{E}_Y</span>  and gets  <span class="math">(a, b)</span> . Similarly, it simulates  <span class="math">\\mathsf{PoKE}^*</span>  for  <span class="math">g_3^c = C</span> , uses the extractor  <span class="math">\\mathcal{E}_c</span>  and gets  <span class="math">c</span> .</p>

    <p class="text-gray-300">As one can see, the expected running time of  <span class="math">\\mathcal{E}&#x27;</span>  is the (expected) time to obtain a successful execution of the protocol plus the running time of the 2 extractors:  <span class="math">\\frac{1}{\\epsilon} + t_{\\mathcal{E}_Y} + t_{\\mathcal{E}_c} = \\mathrm{poly}(\\lambda)</span> .</p>

    <p class="text-gray-300">Now what is left to prove to conclude our theorem is to show that the extracted  <span class="math">a, b, c</span>  are such that  <span class="math">a \\cdot b = c</span>  with all but negligible probability. To this end, we observe that we could run  <span class="math">\\mathcal{E}&#x27;</span>  a second time using a different random challenge  <span class="math">\\ell&#x27;</span> ; by using again  <span class="math">\\mathcal{E}_Y, \\mathcal{E}_c</span>  (after simulating the corresponding PoKRep and PoKE* executions) we would get  <span class="math">a&#x27;, b&#x27;, c&#x27;</span>  such that  <span class="math">g_1^{a&#x27;} g_2^{b&#x27;} = Y = g_1^a g_2^b</span> ,  <span class="math">g_3^{c&#x27;} = C = g_3^c</span> . We argue that  <span class="math">a = a&#x27;</span> ,  <span class="math">b = b&#x27;</span>  and  <span class="math">c = c&#x27;</span>  holds over the integers with overwhelming probability under the assumption that computing a multiple of the order of the group  <span class="math">\\mathbb{G}</span>  is hard (such assumption is in turn implied by the adaptive root assumption). If such event does not hold</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">one can make a straightforward reduction to this problem. Therefore, we proceed by assuming that from the two executions we have <span class="math">a = a&#x27;</span>, <span class="math">b = b&#x27;</span>, and <span class="math">c = c&#x27;</span> over the integers. Moreover, since both executions are accepted we have <span class="math">r_c&#x27; = r_a&#x27; \\cdot r_b&#x27;</span> (mod <span class="math">\\ell&#x27;</span>) <span class="math">\\Rightarrow c&#x27; = a&#x27; \\cdot b&#x27;</span> (mod <span class="math">\\ell&#x27;</span>) <span class="math">\\Rightarrow c = a \\cdot b</span> (mod <span class="math">\\ell&#x27;</span>), but <span class="math">\\ell&#x27;</span> was sampled uniformly at random from <span class="math">\\mathsf{Primes}(\\lambda)</span> after <span class="math">a, b, c</span> were determined. So <span class="math">a \\cdot b = c</span> over the integers, unless with a negligible probability $\\leq \\frac{\\#\\{\\text{factors of } ab - c\\}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Primes}(\\lambda)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\leq \\frac{\\mathsf{poly}(\\lambda)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Primes}(\\lambda)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\mathsf{negl}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, it is trivial to reduce the Knowledge Extractability of <span class="math">\\mathsf{PoProd}_2</span> to Knowledge Extractability of <span class="math">\\mathsf{PoProd}_2&#x27;</span>. Let a generic adversary <span class="math">\\mathcal{A}</span> against the Knowledge Extractability of protocol <span class="math">\\mathsf{PoProd}_2</span> such that the verifier accepts with a non-negligible probability <span class="math">\\epsilon</span>, we can construct a generic adversary <span class="math">\\mathcal{A}&#x27;</span> against Knowledge Extractability of <span class="math">\\mathsf{PoProd}_2&#x27;</span>, so that the verifier accepts with the same probability. <span class="math">\\mathcal{A}&#x27;</span> runs the <span class="math">\\mathsf{crs} \\gets \\mathsf{Setup}(1^{\\lambda})</span> algorithm and sends <span class="math">\\mathsf{crs}</span> to <span class="math">\\mathcal{A}</span>. The adversary <span class="math">\\mathcal{A}</span> outputs <span class="math">((Y, C), \\mathsf{state}) \\gets \\mathcal{A}_0(\\mathsf{crs})</span> and sends it to <span class="math">\\mathcal{A}_0&#x27;</span>, which outputs as it is. Then <span class="math">\\mathcal{A}_1&#x27;</span> interacts with <span class="math">\\mathsf{V}</span> in the protocol <span class="math">\\mathsf{PoProd}_2&#x27;</span> (as a prover) and at the same time with <span class="math">\\mathcal{A}_1</span> in <span class="math">\\mathsf{PoProd}_2</span> (as a verifier). After receiving <span class="math">\\ell</span> from <span class="math">\\mathsf{V}</span> it forwards it to <span class="math">\\mathcal{A}_1</span>. <span class="math">\\mathcal{A}_1</span> answers with <span class="math">\\pi := ((Q_Y, Q_C), r_a, r_b)</span>. <span class="math">\\mathcal{A}_1&#x27;</span> computes <span class="math">r_c \\gets r_a r_b \\mod \\ell</span> and sends <span class="math">\\pi&#x27; := ((Q_Y, Q_C), r_a, r_b, r_c)</span> to <span class="math">\\mathsf{V}</span>. The verifier <span class="math">\\mathsf{V}</span> accepts <span class="math">\\pi&#x27;</span> with the same probability that a verifier of <span class="math">\\mathsf{PoProd}_2</span> would accept <span class="math">\\pi</span> since <span class="math">r_c = r_a r_b \\mod \\ell</span> in both cases. From Knowledge Extractability of <span class="math">\\mathsf{PoProd}_2&#x27;</span> we know that there is an extractor <span class="math">\\mathcal{E}&#x27;</span> that outputs a witness <span class="math">(a, b)</span>. Then <span class="math">\\mathcal{E} = \\mathcal{E}&#x27;</span> is a valid extractor for <span class="math">\\mathsf{PoProd}_2</span>.</p>

    <p class="text-gray-300">In Appendix A we give a protocol <span class="math">\\mathsf{PoProd}</span> that proves <span class="math">g_1^a = A \\wedge g_2^b = B</span> instead of <span class="math">g_1^a g_2^b = Y</span> (i.e., a version of <span class="math">\\mathsf{PoDDH}</span> with different generators). Despite being conceptually simpler, it is slightly less efficient than <span class="math">\\mathsf{PoProd}_2</span>, and thus use the latter in our VC construction.</p>

    <p class="text-gray-300">HASH TO PRIME FUNCTION AND NON-INTERACTIVE <span class="math">\\mathsf{PoProd}_2</span>. Our protocols can be made non-interactive by applying the Fiat-Shamir transform. For this we need an hash function that can be modeled as a random oracle and that maps arbitrary strings to prime numbers, i.e., <span class="math">\\mathsf{H}_{\\mathsf{prime}}: \\{0,1\\}^<em> \\to \\mathsf{Primes}(2\\lambda)^17</span>. A simple way to achieve such a function is to apply a standard hash function <span class="math">\\mathsf{H}: \\{0,1\\}^</em> \\to \\{0,1\\}^{2\\lambda}</span> to an input <span class="math">\\vec{y}</span> together with a counter <span class="math">i</span>, and if <span class="math">p_{y,i} = \\mathsf{H}(\\vec{y},i)</span> is prime then output <span class="math">p_{y,i}</span>, otherwise continue to <span class="math">\\mathsf{H}(\\vec{y},i + 1)</span> and so on, until a prime is found. Due to the distribution of primes, the expected running time of this method is <span class="math">O(\\lambda)</span>, assuming that <span class="math">\\mathsf{H}</span>'s outputs are uniformly distributed. We do not insist, though, in the previous or any other specific instantiation of <span class="math">\\mathsf{H}_{\\mathsf{prime}}</span> in this work. For more discussion on hash-to-prime functions we refer to [GHR99, CMS99, CS99, BBF19, OWB19].</p>

    <p class="text-gray-300">Our First SVC Construction Now we are ready to describe our SVC scheme. For an intuition we refer the reader to the beginning of this section. Also, we note that while the intuition was given for the case of committing to a vector of bits, our actual VC construction generalizes this idea to vectors where each item is a block of <span class="math">k</span> bits. This is done by creating <span class="math">2k</span> accumulators, each of them holding sets of indices <span class="math">i</span> for specific positions inside each block <span class="math">v_{j}</span>.</p>

    <p class="text-gray-300">Notation and Building Blocks. To describe our scheme we use the notation below:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Our message space is <span class="math">\\mathcal{M} = \\{0,1\\}^k</span>. Then for a vector <span class="math">\\vec{v} \\in \\mathcal{M}^n</span>, we denote with <span class="math">i \\in [n]</span> the vector's position, i.e., <span class="math">v_i \\in \\mathcal{M}</span>, and with <span class="math">j \\in [k]</span> the position of its <span class="math">j</span>'th bit. So <span class="math">v_{ij}</span> denotes the <span class="math">j</span>-th bit in position <span class="math">i</span>.</li>

    </ul>

    <p class="text-gray-300">17 As pointed out in [BBF18], although for the interactive version of such protocols the prime can be of size <span class="math">\\lambda</span>, the non-interactive version requires at least a double-sized prime <span class="math">2\\lambda</span>, as an explicit square root attack was presented. Notably, even in the interactive version a <span class="math">2^{\\lambda/2}</span>-attacker would still be able to succeed in breaking knowledge-soundness with <span class="math">2^{-\\lambda/2}</span> probability, with a <span class="math">\\lambda</span>-sized prime.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We make use of a deterministic collision resistant function PrimeGen that maps integers to primes. In our construction we do not need its outputs to be random (see e.g., [BBF19] for possible instantiations).</li>

      <li>As a building block, we use the <span class="math">\\mathsf{PoProd}_2</span> AoK from the previous section.</li>

      <li><span class="math">\\mathsf{PartndPrimeProd}(I,\\vec{y})\\to ((a_{I,1},b_{I,1}),\\ldots ,(a_{I,k},b_{I,k}))</span>: given a set of indices <span class="math">I = \\{i_1,\\dots ,i_m\\} \\subseteq [n]</span> and a vector <span class="math">\\vec{y}\\in \\mathcal{M}^m</span>, this function computes</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">(a _ {I, j}, b _ {I, j}) := \\left(\\prod_ {l = 1: y _ {l j} = 0} ^ {m} p _ {i _ {l}}, \\prod_ {l = 1: y _ {l j} = 1} ^ {m} p _ {i _ {l}}\\right) \\quad \\text{for } j = 1, \\dots , k</span></div>

    <p class="text-gray-300">where <span class="math">p_i \\gets \\mathsf{PrimeGen}(i)</span> for all <span class="math">i</span>.</p>

    <p class="text-gray-300">Basically, for every bit position <span class="math">j \\in [k]</span>, the function computes the products of primes that correspond to, respectively, 0-bits and 1-bits.</p>

    <p class="text-gray-300">In the special case where <span class="math">I = [n]</span>, we omit the set of indices from the notation of the outputs, i.e., <span class="math">\\mathsf{PartndPrimeProd}([n],\\vec{v})</span> outputs <span class="math">a_{j}</span> and <span class="math">b_{j}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{PrimeProd}(I) \\to u_I</span>: given a set of indices <span class="math">I</span>, this function outputs the product of all primes corresponding to indices in <span class="math">I</span>. Namely, it returns <span class="math">u_I \\coloneqq \\prod_{i \\in I} p_i</span>. In the special case <span class="math">I = [n]</span>, we denote the output of <span class="math">\\mathsf{PrimeProd}([n])</span> as <span class="math">u_n</span>.</li>

    </ul>

    <p class="text-gray-300">Notice that by construction, for any <span class="math">I</span> and <span class="math">\\vec{y}</span>, it always holds <span class="math">a_{I,j} \\cdot b_{I,j} = u_I</span>.</p>

    <p class="text-gray-300">SVC Scheme. Below we describe our SVC scheme and then we show its incremental aggregation.</p>

    <p class="text-gray-300">VC.Setup(1^λ, {0, 1}^k) → crs generates a hidden order group G ← Ggen(1^λ) and samples three generators g, g0, g1 ← G. It also determines a deterministic collision resistant function PrimeGen that maps integers to primes.</p>

    <p class="text-gray-300">Returns <span class="math">\\mathsf{crs} = (\\mathbb{G},g,g_0,g_1,\\mathsf{PrimeGen})</span></p>

    <p class="text-gray-300">VC.Specialize(crs, n) → crs_n computes <span class="math">u_n \\gets \\mathsf{PrimeProd}([n])</span> and <span class="math">U_n = g^{u_n}</span>, and returns <span class="math">\\mathsf{crs}_n \\gets (\\mathsf{crs}, U_n)</span>. One can think of <span class="math">U_n</span> as an accumulator to the set <span class="math">[n]</span>.</p>

    <p class="text-gray-300">VC.Com\\<em> (crs_n, v) → (C\\</em>, aux\\*) does the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">((a_{1},b_{1}),\\ldots ,(a_{k},b_{k}))\\gets \\mathsf{PartndPrimeProd}([n],\\vec{v})</span>; next,</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\text{for all } j \\in [ k ] \\text{ compute } A _ {j} = g _ {0} ^ {a _ {j}} \\text{ and } B _ {j} = g _ {1} ^ {b _ {j}}</span></div>

    <p class="text-gray-300">One can think of each <span class="math">(A_j, B_j)</span> as a pair of RSA accumulators for two sets that constitute a partition of <span class="math">[n]</span> done according to the bits of <span class="math">v_{1j}, \\ldots, v_{nj}</span>. Namely <span class="math">A_j</span> and <span class="math">B_j</span> accumulate the sets <span class="math">\\{i \\in [n] : v_{ij} = 0\\}</span> and <span class="math">\\{i \\in [n] : v_{ij} = 1\\}</span> respectively.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all <span class="math">j \\in [k]</span>, compute <span class="math">C_j = A_j \\cdot B_j \\in \\mathbb{G}</span> and a proof <span class="math">\\pi_{\\mathsf{prod}}^{(j)} \\gets \\mathsf{PoProd}_2 \\cdot \\mathsf{P}(\\mathsf{crs}, (C_j, U_n), (a_j, b_j))</span>. Such proof ensures that the sets represented by <span class="math">A_j</span> and <span class="math">B_j</span> are a partition of the set represented by <span class="math">U_n</span>. Since <span class="math">U_n</span> is part of the CRS (i.e., it is trusted), this ensures the well-formedness of <span class="math">A_j</span> and <span class="math">B_j</span>.</li>

    </ol>

    <p class="text-gray-300">Return <span class="math">C^{\\star} \\coloneqq \\left(\\{A_1, B_1, \\ldots, A_k, B_k\\}, \\left\\{\\pi_{\\mathsf{prod}}^{(1)}, \\ldots, \\pi_{\\mathsf{prod}}^{(k)}\\right\\}\\right)</span> and <span class="math">\\mathsf{aux}^{\\star} \\coloneqq \\vec{v}</span>.</p>

    <p class="text-gray-300">VC.Open\\<em> (crs_n, I, y, aux\\</em>) → π_I proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>let <span class="math">J = [n] \\setminus I</span> and compute <span class="math">((a_{J,1}, b_{J,1}), \\ldots, (a_{J,k}, b_{J,k})) \\gets \\mathsf{PartndPrimeProd}(J, \\vec{v}_J)</span>;</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for all <span class="math">j \\in [k]</span> compute</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Gamma_{I,j} := g_0^{a_{J,j}} \\quad \\text{and} \\quad \\Delta_{I,j} = g_1^{b_{J,j}}</span></div>

    <p class="text-gray-300">Notice that <span class="math">a_{J,j} = a_j / a_{I,j}</span> and <span class="math">b_{J,j} = b_j / b_{I,j}</span>. Also <span class="math">\\Gamma_{I,j}</span> is a membership witness for the set <span class="math">\\{i_l \\in I : y_{lj} = 0\\}</span> in the accumulator <span class="math">A_j</span>, and similarly for <span class="math">\\Delta_{I,j}</span>.</p>

    <p class="text-gray-300">Return <span class="math">\\pi_I \\coloneqq \\{\\pi_{I,1}, \\dots, \\pi_{I,k}\\} \\gets \\{(\\Gamma_{I,1}, \\Delta_{I,1}), \\dots, (\\Gamma_{I,k}, \\Delta_{I,k})\\}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{VC.Ver}^{\\star}(\\mathsf{crs}_n, C^{\\star}, I, \\vec{y}, \\pi_I) \\to b</span> computes <span class="math">((a_{I,1}, b_{I,1}), \\dots, (a_{I,k}, b_{I,k}))</span> using</p>

    <p class="text-gray-300"><span class="math">\\mathsf{PartndPrimeProd}(I, \\vec{y})</span>, and then returns <span class="math">b \\gets b_{acc} \\wedge b_{prod}</span> where:</p>

    <div class="my-4 text-center"><span class="math-block">b_{acc} \\leftarrow \\bigwedge_{j=1}^{k} \\left(\\Gamma_{I,j}^{a_{I,j}} = A_j \\wedge \\Delta_{I,j}^{b_{I,j}} = B_j\\right) \\tag{1}</span></div>

    <div class="my-4 text-center"><span class="math-block">b_{prod} \\leftarrow \\bigwedge_{j=1}^{k} \\left(\\mathsf{PoProd}_2.\\mathsf{V}(\\mathsf{crs}, (A_j \\cdot B_j, U_n), \\pi_{\\mathsf{prod}}^{(j)})\\right) \\tag{2}</span></div>

    <p class="text-gray-300">Remark 5.1. For more efficient verification, <span class="math">\\mathsf{VC.Open}^{\\star}</span> can be changed to include <span class="math">2k</span> (non-interactive) proofs of exponentiation <span class="math">\\mathsf{PoE}</span> (which using the PoKCR aggregation from [BBF19] add only <span class="math">k</span> elements of <span class="math">\\mathbb{G}</span>). This reduces the exponentiations cost in <span class="math">\\mathsf{VC.Ver}^{\\star}</span>. As noted in [BBF19], although the asymptotic complexity is the same, the operations are in <span class="math">\\mathbb{Z}_{2^{2\\lambda}}</span> instead of <span class="math">\\mathbb{G}</span>, which concretely makes up an improvement.</p>

    <p class="text-gray-300">The correctness of the vector commitment scheme described above is obvious by inspection (assuming correctness of <span class="math">\\mathsf{PoProd}_2</span>).</p>

    <p class="text-gray-300">Incremental Aggregation. Here we show that our SVC scheme is incrementally aggregatable.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{VC.Disagg}(\\mathsf{crs}, I, \\vec{v}_I, \\pi_I, K) \\to \\pi_K</span>. Let <span class="math">L := I \\setminus K</span>, and <span class="math">\\vec{v}_L</span> be the subvector of <span class="math">\\vec{v}_I</span> at positions in <span class="math">L</span>.</p>

    <p class="text-gray-300">Then compute <span class="math">\\{a_{L,j}, b_{L,j}\\}_{j \\in [k]} \\gets \\mathsf{PartndPrimeProd}(L, \\vec{v}_L)</span>, and for each <span class="math">j \\in [k]</span> set:</p>

    <div class="my-4 text-center"><span class="math-block">\\Gamma_{K,j} \\leftarrow \\Gamma_{I,j}^{a_{L,j}}, \\quad \\Delta_{K,j} \\leftarrow \\Delta_{I,j}^{b_{L,j}}</span></div>

    <p class="text-gray-300">and return <span class="math">\\pi_K := \\{\\pi_{K,1}, \\dots, \\pi_{K,k}\\} := \\{(\\Gamma_{K,1}, \\Delta_{K,1}), \\dots, (\\Gamma_{K,k}, \\Delta_{K,k})\\}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{VC.Agg}(\\mathsf{crs}, (I, \\vec{v}_I, \\pi_I), (J, \\vec{v}_J, \\pi_J)) \\to \\pi_K := \\{(\\Gamma_{K,1}, \\Delta_{K,1}), \\dots, (\\Gamma_{K,k}, \\Delta_{K,k})\\}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">L \\coloneqq I \\cap J</span>. If <span class="math">L \\neq \\emptyset</span>, set <span class="math">I&#x27; \\coloneqq I \\setminus L</span> and compute <span class="math">\\pi_{I&#x27;} \\gets \\mathsf{VC.Disagg}(\\mathsf{crs}, I, \\vec{v}_I, \\pi_I, I&#x27;)</span>; otherwise let <span class="math">\\pi_{I&#x27;} = \\pi_I</span>.</li>

      <li>Compute <span class="math">\\{a_{I&#x27;,j}, b_{I&#x27;,j}\\}_{j \\in [k]} \\gets \\mathsf{PartndPrimeProd}(I&#x27;, \\vec{v}_{I&#x27;})</span> and <span class="math">\\{a_{J,j}, b_{J,j}\\}_{j \\in [k]} \\gets \\mathsf{PartndPrimeProd}(J, \\vec{v}_J)</span>.</li>

      <li>Parse <span class="math">\\pi_{I&#x27;} := \\left\\{(\\Gamma_{I&#x27;,j}, \\Delta_{I&#x27;,j})\\right\\}_{j=1}^{k}</span>, <span class="math">\\pi_J := \\{(\\Gamma_{J,j}, \\Delta_{J,j})\\}_{j=1}^{k}</span>, and for all <span class="math">j \\in [k]</span>, compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\Gamma_{K,j} \\leftarrow \\mathbf{ShamirTrick}(\\Gamma_{I&#x27;,j}, \\Gamma_{J,j}, a_{I&#x27;,j}, a_{J,j}), \\quad \\Delta_{Kj} \\leftarrow \\mathbf{ShamirTrick}(\\Delta_{I&#x27;,j}, \\Delta_{J,j}, b_{I&#x27;,j}, b_{J,j}).</span></div>

    <p class="text-gray-300">Note that our algorithms above can work directly with the universal CRS <span class="math">\\mathsf{crs}</span>, and do not need the specialized one <span class="math">\\mathsf{crs}_n</span>.</p>

    <p class="text-gray-300">Aggregation Correctness. The second property of aggregation correctness (the one about VC.Disagg) is straightforward by construction:</p>

    <p class="text-gray-300">if we let <span class="math">\\{a_{K,j}, b_{K,j}\\}_{j \\in [k]} \\gets \\mathsf{PartndPrimeProd}(K, \\vec{v}_K)</span>, then <span class="math">a_{I,j} = a_{L,j} \\cdot a_{K,j}</span>, and thus <span class="math">A_j = \\Gamma_{I,j}^{a_{I,j}} = \\Gamma_{I,j}^{a_{L,j} \\cdot a_{K,j}} = \\Gamma_{K,j}^{a_{K,j}}</span> (and similarly for <span class="math">\\Delta_{K,j}</span>).</p>

    <p class="text-gray-300">The first property instead follows from the correctness of Shamir’s trick if the integer values provided as input are coprime; however since <span class="math">I^{\\prime}\\cap J=\\emptyset</span>, <span class="math">a_{I^{\\prime},j}</span> and <span class="math">a_{J,j}</span> (resp. <span class="math">b_{I^{\\prime},j}</span> and <span class="math">b_{J,j}</span>) are coprime unless a collision occurs in PrimeGen.</p>

    <p class="text-gray-300">Efficiency. We summarize the efficiency of our construction in terms of both the computational cost of the algorithms and the communication (CRS, commitment and openings size). For this analysis we consider an instantiation of PrimeGen with a deterministic function that maps every integer in <span class="math">[n]</span> into a unique prime number, which can be of <span class="math">\\alpha=\\log n</span> bits.</p>

    <p class="text-gray-300">Our scheme is presented in order to support vectors of length <span class="math">n</span> of <span class="math">k</span>-bits-long strings. We summarize efficiency in terms of <span class="math">k</span> and <span class="math">n</span>. However, we note that <span class="math">k</span> is actually only a parameter and our scheme can work with any setting of vectors <span class="math">\\vec{v}</span> of length <span class="math">N</span> of <span class="math">\\ell</span>-bits long strings. In this case, it is sufficient to fix an arbitrary <span class="math">k</span> that divides <span class="math">\\ell</span> and to spread each <span class="math">v_{i}\\in\\{0,1\\}^{\\ell}</span> over <span class="math">\\ell/k</span> positions. For example, for <span class="math">k=1</span> with have <span class="math">n=N\\ell</span> and thus the prime size is <span class="math">\\alpha=\\log(N\\ell)</span>.</p>

    <p class="text-gray-300">Setup. In terms of computation, VC.Setup generates the group description and samples <span class="math">3</span> generators, while VC.Specialize computes one exponentiation in <span class="math">\\mathbb{G}</span> with an <span class="math">(n\\alpha)</span>-long integer. The CRS consists of <span class="math">3</span> elements of <span class="math">\\mathbb{G}</span>, and the specialized CRS (for any <span class="math">n</span>) is one group element.</p>

    <p class="text-gray-300">Committing. Committing to a vector <span class="math">\\vec{v}\\in(\\{0,1\\}^{k})^{n}</span> requires about <span class="math">k</span> exponentiations with an <span class="math">(n\\alpha)</span>-long integer each. A commitment consists of <span class="math">4k</span> elements of <span class="math">\\mathbb{G}</span> and <span class="math">2k</span> integers in <span class="math">\\mathbb{Z}_{2^{2\\lambda}}</span>.</p>

    <p class="text-gray-300">Opening. Creating an opening for a set <span class="math">I</span> of <span class="math">m</span> positions has about the same cost of committing, and the opening consists of <span class="math">2k</span> group elements. Using the PoE to make verification more efficient (see Remark 5.1) would (naively) result to <span class="math">4k</span> elements. However, as described in <em>[x1]</em>, many PoE’s for coprime exponents can be aggregated into a single group element. In our case, applying this optimization would result to <span class="math">k</span> group elements for all the PoE’s, which totally gives <span class="math">3k</span> group elements for an opening.</p>

    <p class="text-gray-300">Verification. Verifying an opening for set <span class="math">I</span> requires about <span class="math">k</span> exponentiations with <span class="math">(m\\cdot\\alpha)</span>-bit integers (resp. <span class="math">4k</span> exponentiations with <span class="math">\\lambda</span>-bit integers, <span class="math">2k</span> multiplications in <span class="math">\\mathbb{G}</span> and <span class="math">O(km\\alpha)</span> multiplications in <span class="math">\\mathbb{Z}_{2^{2\\lambda}}</span>, when using PoE) to check equation (1), plus <span class="math">5k</span> exponentiations with <span class="math">2\\lambda</span>-bit integers and <span class="math">3k</span> multiplications in <span class="math">\\mathbb{G}</span> to verify PoProd_{2} proofs in equation (2).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Aggregation and Disaggregation. Disaggregation requires <span class="math">2k</span> exponentiations with $((</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\alpha)<span class="math">-bit integers, while aggregation requires </span>2k<span class="math"> computations of ShamirTrick that amount to </span>O(k(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\alpha)<span class="math"> operations in </span>\\mathbb{G}<span class="math">. From this, we obtain that VC.AggManyToOne and VC.DisaggOneToMany take time </span>O(ksm\\log m\\alpha)<span class="math"> </span>\\mathbb{G}<span class="math"> and </span>O(km\\log(m/B)\\alpha)<span class="math"> </span>\\mathbb{G}$, respectively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Commitment and Opening with Precomputation. Finally, let us summarize the costs of committing and opening with preprocessing obtained by instantiating our method of Section 4.2. The preprocessing VC.PPCom takes time <span class="math">O(kn\\alpha\\log(n/B))</span>. The opening requires computing at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq m<span class="math"> disaggregation, each taking time </span>O(k\\alpha(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">, for a total of </span>O(k\\alpha(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">, followed by the aggregation step that counts </span>O(k\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. So, in the worst case VC.FastOpen takes </span>O(k\\cdot m\\cdot\\alpha(\\log(m)+B-1))<span class="math"> operations of </span>\\mathbb{G}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Security. The security of our SVC scheme, i.e., position binding, can be reduced to the Strong RSA and Adaptive root assumptions in the hidden order group <span class="math">\\mathbb{G}</span> used in the construction and to the knowledge extractability of PoProd_{2}.</p>

    <p class="text-gray-300">A bit more in detail the steps of the proof are as follows. Let an adversary to the position binding output <span class="math">(C,I,\\vec{y},\\pi,\\vec{y}^{\\prime},\\pi^{\\prime})</span>. First from knowledge extractability of PoProd_{2} it comes that</p>

    <p class="text-gray-300"><span class="math">A_{j}B_{j}=g_{1}^{a_{j}}g_{2}^{b_{j}}</span> and <span class="math">g^{a_{j}b_{j}}=U_{n}=g^{u_{n}}</span>. However, this does not necessarily means that <span class="math">a_{j}b_{j}=u_{n}</span> over the integers and to prove it we need the Low Order assumptions, under which it holds. Afterwards we prove that since <span class="math">A_{j}B_{j}=g_{1}^{a_{j}}g_{2}^{b_{j}}</span> no different proofs <span class="math">\\pi,\\pi^{\\prime}</span> for the same positions can pass the verification under the strong RSA assumption, which is the core of our proof. The main caveat of the proof is that instead of knowing that <span class="math">A_{j}=g_{1}^{a_{j}}</span> and <span class="math">B_{j}=g_{2}^{b_{j}}</span> we know only that <span class="math">A_{j}B_{j}=g_{1}^{a_{j}}g_{2}^{b_{j}}</span>. The former case would directly reduce to RSA Accumulator’s security (strong RSA assumption). For this we first need to prove an intermediate lemma (lemma 5.5) which shows that specifically for our case <span class="math">A_{j}B_{j}=g_{1}^{a_{j}}g_{2}^{b_{j}}</span> is enough, since the choice of the primes <span class="math">p_{i}</span> in the exponent is restricted to a polynomially bounded set.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Theorem 5.2 (Position-Binding).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{Ggen}</span> be the generator of hidden order groups where the Strong RSA and Low Order assumptions hold, and let <span class="math">\\mathsf{PoProd}_{2}</span> be an argument of knowledge for <span class="math">R_{\\mathsf{PoProd}_{2}}</span>. Then the subVector Commitment scheme defined above is position binding.</p>

    <p class="text-gray-300">Proof To prove the theorem we use a hybrid argument. We start by defining the game <span class="math">G_{0}</span> as the actual position binding game of Definition 3.2, and our goal is to prove that for any PPT <span class="math">\\mathcal{A}</span>, <span class="math">\\Pr[G_{0}=1]\\in\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Game <span class="math">G_{0}</span>:</p>

    <p class="text-gray-300"><span class="math">G_{0}=\\mathsf{PosBind}_{\\mathsf{VC}}^{\\mathcal{A}}(\\lambda)</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{crs}\\leftarrow\\mathsf{VC.Setup}(1^{\\lambda},\\mathcal{M})</span></p>

    <p class="text-gray-300"><span class="math">(C,I,\\vec{y},\\pi,\\vec{y}^{\\prime},\\pi^{\\prime})\\leftarrow\\mathcal{A}(\\mathsf{crs})</span></p>

    <p class="text-gray-300"><span class="math">b\\leftarrow\\mathsf{VC.Ver}(\\mathsf{crs},C,I,\\vec{y},\\pi)=1\\wedge\\vec{y}\\neq\\vec{y}^{\\prime}\\wedge\\mathsf{VC.Ver}(\\mathsf{crs},C,I,\\vec{y}^{\\prime},\\pi^{\\prime})=1</span></p>

    <p class="text-gray-300">return <span class="math">b</span></p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Lemma 5.1.</h6>

    <p class="text-gray-300">For any PPT <span class="math">\\mathcal{A}</span> in game <span class="math">G_{0}</span> there exists an algorithm <span class="math">\\mathcal{E}</span> and an experiment <span class="math">G_{1}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\Pr[G_{0}=1]\\leq\\Pr[G_{1}=1]+\\mathsf{negl}(\\lambda)</span></p>

    <p class="text-gray-300">Proof By construction of <span class="math">\\mathsf{VC.Com}</span>, the commitment <span class="math">C</span> returned by the adversary <span class="math">\\mathcal{A}</span> in game <span class="math">G_{0}</span> contains <span class="math">k</span> proofs of <span class="math">\\mathsf{PoProd}_{2}</span>, and by construction of <span class="math">\\mathsf{VC.Ver}</span> if <span class="math">G_{0}</span> returns <span class="math">1</span> all these proofs verify. It is not hard to argue that for any adversary <span class="math">\\mathcal{A}</span> playing in game <span class="math">G_{0}</span> there is an extractor <span class="math">\\mathcal{E}</span> that outputs the <span class="math">k</span> witnesses <span class="math">\\{a_{j},b_{j}\\}_{j\\in[k]}</span>.</p>

    <p class="text-gray-300">Game <span class="math">G_{1}</span>: is the same as <span class="math">G_{0}</span> except that we also execute <span class="math">\\mathcal{E}</span>, which outputs <span class="math">\\{a_{j},b_{j}\\}_{j\\in[k]}</span>, and we additionally check that <span class="math">U_{n}=g^{a_{j}b_{j}}</span> for all <span class="math">j\\in[k]</span>. Below is a detailed description of <span class="math">G_{1}</span> in which we “open the box” of the VC algorithms.</p>

    <p class="text-gray-300"><span class="math">G_{1}</span></p>

    <p class="text-gray-300">crs  <span class="math">\\leftarrow</span>  VC.Setup(1, M); bad1  <span class="math">\\leftarrow</span>  false</p>

    <p class="text-gray-300"><span class="math">(\\{A_{j},B_{j},\\pi_{\\mathsf{prod}}^{(j)}\\}_{j\\in [k]},n),I,\\vec{y},\\{\\Gamma_{I,j},\\Delta_{I,j}\\}_{j\\in [k]},\\vec{y}^{\\prime},\\{\\Gamma_{I,j}^{\\prime},\\Delta_{I,j}^{\\prime}\\}_{j\\in [k]})\\gets \\mathcal{A}(\\mathsf{crs})</span></p>

    <p class="text-gray-300"><span class="math">\\{a_j,b_j\\}_{j\\in [k]}\\gets \\mathcal{E}(\\mathsf{crs})</span></p>

    <p class="text-gray-300"><span class="math">u_{n}\\gets \\mathsf{PrimeProd}(n);U_{n}\\gets g^{u_{n}}</span></p>

    <p class="text-gray-300"><span class="math">b_{prod}\\gets \\bigwedge_{j = 1}^{k}\\left(\\mathsf{PoProd}_2.\\mathsf{V}(\\mathsf{crs},(A_j\\cdot B_j,U_n),\\pi_{\\mathsf{prod}}^{(j)})\\right)</span></p>

    <p class="text-gray-300"><span class="math">b_{wit}\\gets \\bigwedge_{j = 1}^{k}A_{j}\\cdot B_{j} = g_{0}^{a_{j}}g_{j}^{b_{j}}\\wedge U_{n} = g^{a_{j}\\cdot b_{j}}</span></p>

    <p class="text-gray-300">if  <span class="math">b_{prod} = 1 \\wedge b_{wit} = 0</span>  then  <span class="math">\\mathsf{bad}_1 \\gets \\mathsf{true}</span></p>

    <p class="text-gray-300"><span class="math">\\{a_{I,j},b_{I,j}\\}_{j\\in [k]}\\gets \\mathsf{PartndPrimeProd}(I,\\vec{y});\\{a_{I,j}^{\\prime},b_{I,j}^{\\prime}\\}_{j\\in [k]}\\gets \\mathsf{PartndPrimeProd}(I,\\vec{y}^{\\prime})</span></p>

    <p class="text-gray-300"><span class="math">b\\gets b_{prod}\\wedge \\bigwedge_{j = 1}^{k}\\left(\\Gamma_{I,j}{}^{a_{I,j}} = A_j\\wedge \\Delta_{I,j}{}^{b_{I,j}} = B_j\\right)\\wedge \\vec{y}\\neq \\vec{y}^{\\prime}\\wedge</span></p>

    <div class="my-4 text-center"><span class="math-block">\\bigwedge_ {j = 1} ^ {k} \\left(\\Gamma_ {I, j} ^ {\\prime} ^ {a _ {I, j} ^ {\\prime}} = A _ {j} \\wedge \\Delta_ {I, j} ^ {\\prime} ^ {b _ {I, j} ^ {\\prime}} = B _ {j}\\right)</span></div>

    <p class="text-gray-300">if  <span class="math">\\mathsf{bad}_1 = \\mathsf{true}</span>  then  <span class="math">b\\gets 0</span></p>

    <p class="text-gray-300">return  <span class="math">b</span></p>

    <p class="text-gray-300">Clearly, the games  <span class="math">G_0</span>  and  <span class="math">G_1</span>  are identical except if the flag  <span class="math">\\mathsf{bad}_1</span>  is raised true, i.e.,  <span class="math">\\operatorname<em>{Pr}[G_0 = 1] - \\operatorname</em>{Pr}[G_1 = 1] \\leq \\operatorname<em>{Pr}[\\mathsf{bad}_1 = \\mathsf{true}]</span> . However, the event in which  <span class="math">\\mathsf{bad}_1</span>  is set true is the event in which one of the witnesses returned by the extractor is not correct. By the knowledge extractability of  <span class="math">\\mathsf{PoProd}_2</span>  we immediately get that  <span class="math">\\operatorname</em>{Pr}[\\mathsf{bad}_1 = \\mathsf{true}] \\in \\mathsf{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Game  <span class="math">G_{2}</span> : is the same as  <span class="math">G_{1}</span>  except that  <span class="math">G_{2}</span>  outputs 0 if there is an index  <span class="math">j</span>  such that  <span class="math">U_{n} = g^{a_{j}\\cdot b_{j}}</span>  but  <span class="math">u_{n}\\neq a_{j}\\cdot b_{j}</span> . Precisely, if this happens a flag  <span class="math">\\mathsf{bad}_2</span>  is set true and the outcome of the experiment is 0. See below for the detailed description of  <span class="math">G_{2}</span> .</p>

    <p class="text-gray-300"><span class="math">G_{2}</span></p>

    <p class="text-gray-300">crs  <span class="math">\\leftarrow</span>  VC.Setup(1, M); bad1, bad2  <span class="math">\\leftarrow</span>  false</p>

    <p class="text-gray-300"><span class="math">(\\{A_j,B_j,\\pi_{\\mathsf{prod}}^{(j)}\\}_{j\\in [k]},n),I,\\vec{y},\\{\\Gamma_{I,j},\\Delta_{I,j}\\}_{j\\in [k]},\\vec{y}^{\\prime},\\{\\Gamma_{I,j}^{\\prime},\\Delta_{I,j}^{\\prime}\\}_{j\\in [k]})\\gets \\mathcal{A}(\\mathsf{crs})</span></p>

    <p class="text-gray-300"><span class="math">\\{a_j,b_j\\}_{j\\in [k]}\\gets \\mathcal{E}(\\mathsf{crs})</span></p>

    <p class="text-gray-300"><span class="math">u_{n}\\gets \\mathsf{PrimeProd}(n);U_{n}\\gets g^{u_{n}}</span></p>

    <p class="text-gray-300"><span class="math">b_{prod}\\gets \\bigwedge_{j = 1}^{k}\\left(\\mathsf{PoProd}_2.\\mathsf{V}(\\mathsf{crs},(A_j\\cdot B_j,U_n),\\pi_{\\mathsf{prod}}^{(j)})\\right)</span></p>

    <p class="text-gray-300"><span class="math">b_{wit}\\gets \\bigwedge_{j = 1}^{k}A_{j}\\cdot B_{j} = g_{0}^{a_{j}}g_{j}^{b_{j}}\\wedge U_{n} = g^{a_{j}\\cdot b_{j}}</span></p>

    <p class="text-gray-300">if  <span class="math">b_{prod} = 1 \\wedge b_{wit} = 0</span>  then  <span class="math">\\mathsf{bad}_1 \\gets \\mathsf{true}</span></p>

    <p class="text-gray-300"><span class="math">b_{col}\\gets \\bigwedge_{j = 1}^{k}u_{n} = a_{j}\\cdot b_{j}</span></p>

    <p class="text-gray-300">if  <span class="math">b_{prod} = 1 \\wedge b_{col} = 0</span>  then  <span class="math">\\mathsf{bad}_2 \\gets \\mathsf{true}</span></p>

    <p class="text-gray-300"><span class="math">\\{a_{I,j},b_{I,j}\\}_{j\\in [k]}\\gets \\mathsf{PartndPrimeProd}(I,\\vec{y});\\left\\{a_{I,j}^{\\prime},b_{I,j}^{\\prime}\\right\\}_{j\\in [k]}\\gets \\mathsf{PartndPrimeProd}(I,\\vec{y}^{\\prime})</span></p>

    <p class="text-gray-300"><span class="math">b\\gets b_{prod}\\wedge \\bigwedge_{j = 1}^{k}\\left(\\Gamma_{I,j}{}^{a_{I,j}} = A_j\\wedge \\Delta_{I,j}{}^{b_{I,j}} = B_j\\right)\\wedge \\vec{y}\\neq \\vec{y}^{\\prime}\\wedge</span></p>

    <div class="my-4 text-center"><span class="math-block">\\bigwedge_ {j = 1} ^ {k} \\left(\\Gamma_ {I, j} ^ {\\prime a _ {I, j} ^ {\\prime}} = A _ {j} \\wedge \\Delta_ {I j} ^ {\\prime b _ {I, j} ^ {\\prime}} = B _ {j}\\right)</span></div>

    <p class="text-gray-300">if  <span class="math">\\mathsf{bad}_1 = \\mathsf{true} \\vee \\mathsf{bad}_2 = \\mathsf{true}</span>  then  <span class="math">b \\gets 0</span></p>

    <p class="text-gray-300">return  <span class="math">b</span></p>

    <p class="text-gray-300">Lemma 5.2. If the Low Order assumption holds for  <span class="math">\\mathsf{G}</span>  gen, then  <span class="math">\\operatorname<em>{Pr}[G_1 = 1] - \\operatorname</em>{Pr}[G_2 = 1] \\leq \\mathsf{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Proof Clearly,  <span class="math">G_{1}</span>  and  <span class="math">G_{2}</span>  proceed identically except if  <span class="math">\\mathsf{bad}_2</span>  is set true. We claim that  <span class="math">\\operatorname*{Pr}[\\mathsf{bad}_2 = \\mathsf{true}]</span>  is negligible for any  <span class="math">\\mathcal{A}, \\mathcal{E}</span>  running in  <span class="math">G_{2}</span> . If this event happens, one indeed obtains an integer  <span class="math">v = u_{n} - a_{j} \\cdot b_{j}</span>  such that  <span class="math">g^{v} = 1 \\in \\mathbb{G}</span> , where  <span class="math">g \\neq 1</span>  and  <span class="math">1 &amp;lt; v &amp;lt; 2^{\\mathsf{poly}(\\lambda)}</span> , and solves the Low Order problem.</p>

    <p class="text-gray-300">Game  <span class="math">G_{3}</span> : is an experiment that can be seen as a simplification of  <span class="math">G_{2}</span> .</p>

    <p class="text-gray-300"><span class="math">G_{3}</span></p>

    <p class="text-gray-300">crs  <span class="math">\\leftarrow</span>  VC.Setup(1, M)</p>

    <p class="text-gray-300"><span class="math">(\\vec{v},\\{A_j,B_j\\}_{j\\in [k]},I,\\vec{y},\\{\\Gamma_{I,j},\\Delta_{I,j}\\}_{j\\in [k]},\\vec{y}^{\\prime},\\{\\Gamma_{I,j}^{\\prime},\\Delta_{I,j}^{\\prime}\\}_{j\\in [k]})\\gets \\mathcal{A}^{\\prime}(\\mathsf{crs})</span></p>

    <p class="text-gray-300"><span class="math">\\{a_j,b_j\\}_{j\\in [k]}\\gets \\mathsf{PartndPrimeProd}([n],\\vec{v})</span></p>

    <p class="text-gray-300"><span class="math">\\{a_{I,j},b_{I,j}\\}_{j\\in [k]}\\gets \\mathsf{PartndPrimeProd}(I,\\vec{y});\\left\\{a_{I,j}^{\\prime},b_{I,j}^{\\prime}\\right\\}_{j\\in [k]}\\gets \\mathsf{PartndPrimeProd}(I,\\vec{y}^{\\prime})</span></p>

    <p class="text-gray-300"><span class="math">b\\gets \\bigwedge_{j = 1}^{k}(A_{j}\\cdot B_{j} = g_{0}^{a_{j}}\\cdot g_{1}^{b_{j}})\\bigwedge_{j = 1}^{k}\\left(\\Gamma_{I,j}{}^{a_{I,j}} = A_{j}\\wedge \\Delta_{I,j}{}^{b_{I,j}} = B_{j}\\right)\\wedge \\vec{y}\\neq \\vec{y}^{\\prime}\\wedge</span></p>

    <div class="my-4 text-center"><span class="math-block">\\bigwedge_ {j = 1} ^ {k} \\left(\\Gamma_ {I, j} ^ {\\prime a _ {I, j} ^ {\\prime}} = A _ {j} \\wedge \\Delta_ {I, j} ^ {\\prime b _ {I, j} ^ {\\prime}} = B _ {j}\\right)</span></div>

    <p class="text-gray-300">return  <span class="math">b</span></p>

    <p class="text-gray-300">First, we show the following lemma that relates the probability of winning in  <span class="math">G_{3}</span>  with that of winning in  <span class="math">G_{2}</span> .</p>

    <p class="text-gray-300">Lemma 5.3. For any  <span class="math">(\\mathcal{A},\\mathcal{E})</span>  running in  <span class="math">G_{2}</span>  there is an  <span class="math">\\mathcal{A}&#x27;</span>  running in  <span class="math">G_{3}</span>  such that  <span class="math">\\operatorname<em>{Pr}[G_2 = 1] = \\operatorname</em>{Pr}[G_3 = 1]</span> .</p>

    <p class="text-gray-300">Proof We build  <span class="math">\\mathcal{A}&#x27;</span>  from  <span class="math">(\\mathcal{A},\\mathcal{E})</span>  as follows. On input crs,  <span class="math">\\mathcal{A}&#x27;</span>  executes</p>

    <p class="text-gray-300"><span class="math">(\\{A_j,B_j,\\pi_{\\mathsf{prod}}^{(j)}\\}_{j\\in [k]},n),I,\\vec{y},\\{\\Gamma_{I,j},\\Delta_{I,j}\\}_{j\\in [k]},\\vec{y}^{\\prime},\\{\\Gamma_{I,j}^{\\prime},\\Delta_{I,j}^{\\prime}\\}_{j\\in [k]})\\gets \\mathcal{A}(\\mathsf{crs})</span>  and  <span class="math">\\{a_j,b_j\\}_{j\\in [k]}\\gets \\mathcal{E}(\\mathsf{crs})</span>  Next,  <span class="math">\\mathcal{A}&#x27;</span>  reconstructs a vector  <span class="math">\\vec{v}\\in (\\{0,1\\} ^k)^n</span>  from the set  <span class="math">\\{a_j,b_j\\}_{j\\in [k]}</span>  . This can be done by setting  <span class="math">v_{ij} = 0</span>  if  <span class="math">p_i\\mid a_j</span>  and  <span class="math">v_{ij} = 1</span>  if  <span class="math">p_i\\mid b_j</span>  , where  <span class="math">p_i\\gets \\mathsf{PrimeGen}(i)</span>  (in case both or neither cases occur, abort). Finally,  <span class="math">\\mathcal{A}&#x27;</span>  runs all the checks as in game  <span class="math">G_{2}</span>  , and if  <span class="math">G_{2}</span>  would output 1, then  <span class="math">\\mathcal{A}&#x27;</span>  outputs  <span class="math">(\\vec{v},\\{A_j,B_j\\}_{j\\in [k]},I,\\vec{y},\\{\\Gamma_{I,j},\\Delta_{I,j}\\}_{j\\in [k]},\\vec{y}^{\\prime},\\{\\Gamma_{I,j}^{\\prime},\\Delta_{I,j}^{\\prime}\\}_{j\\in [k]})</span>  , otherwise  <span class="math">\\mathcal{A}&#x27;</span>  aborts.</p>

    <p class="text-gray-300">To claim that  <span class="math">\\operatorname<em>{Pr}[G_2 = 1] = \\operatorname</em>{Pr}[G_3 = 1]</span> , we observe that whenever  <span class="math">G_{2}</span>  returns 1 it is the case that  <span class="math">a_{j} \\cdot b_{j} = u_{n} = \\prod_{i=1}^{n} p_{i}</span>  for all  <span class="math">j \\in [k]</span> ; therefore  <span class="math">\\mathcal{A}&#x27;</span>  never aborts.</p>

    <p class="text-gray-300">Game  <span class="math">G_{4}</span> : this is the same as game  <span class="math">G_{3}</span>  except that the game outputs 0 if during any computation of lines 3 and 4 it happens that  <span class="math">\\text{PrimeGen}(i) = \\text{PrimeGen}(i&#x27;)</span>  for distinct  <span class="math">i \\neq i&#x27;</span> . It is straightforward to show that the probability of this event is bounded by the probability of finding collisions in  <span class="math">\\text{PrimeGen}</span> , i.e., that under the collision resistance of  <span class="math">\\text{PrimeGen}</span>  it holds  <span class="math">\\operatorname<em>{Pr}[G_{3} = 1] - \\operatorname</em>{Pr}[G_{4} = 1] \\in \\text{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">To conclude the proof of our Theorem, we prove that any PPT adversary can win in  <span class="math">G_{4}</span>  with only negligible probability assuming that the strong RSA assumption holds in  <span class="math">\\mathbb{G}</span> .</p>

    <p class="text-gray-300">Lemma 5.4. If the strong RSA assumption holds for Ggen, then for every PPT adversary  <span class="math">\\mathcal{A}&#x27;</span>  running in game  <span class="math">G_4</span>  we have that  <span class="math">Pr[G_4 = 1] \\in \\mathrm{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Proof For the proof, we rely on the following lemma that defines a computational problem that we prove it is implied by the Strong RSA assumption.</p>

    <p class="text-gray-300">Lemma 5.5. Let  <span class="math">\\mathsf{G}</span>  be a hidden order group generation algorithm where the strong RSA assumption holds and PrimeGen a deterministic collision resistant function that maps integers to primes. Then for any PPT adversary  <span class="math">\\mathcal{A}</span>  and any  <span class="math">n = \\mathsf{poly}(\\lambda)</span> , the probability below is negligible:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} u ^ {p} = g _ {0} ^ {a} \\cdot g _ {1} ^ {b} &amp;amp; \\mathbb {G} \\leftarrow \\mathsf {G g e n} (\\lambda) \\\\ \\wedge (p \\nmid a \\lor p \\nmid b) &amp;amp; g _ {0}, g _ {1} \\leftarrow \\mathbb {G} \\\\ \\wedge u \\in \\mathbb {G} \\wedge (a, b) \\in \\mathbb {Z} ^ {2} \\wedge p \\in S &amp;amp; S = \\{p _ {i} \\leftarrow \\mathsf {P r i m e G e n} (i) \\} _ {i = 1} ^ {n} \\\\ &amp;amp; (u, p, a, b) \\leftarrow \\mathcal {A} (\\mathbb {G}, g _ {0}, g _ {1}, S) \\end{array} \\right] \\in \\mathsf {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">We proceed assuming that the lemma holds; its proof is deferred to the end.</p>

    <p class="text-gray-300">Suppose by contradiction the existence of a PPT adversary  <span class="math">\\mathcal{A}&#x27;</span>  such that  <span class="math">\\operatorname*{Pr}[G_4 = 1] = \\epsilon</span>  with  <span class="math">\\epsilon</span>  non-negligible. Below we show how to construct an adversary  <span class="math">\\mathcal{B}</span>  that uses  <span class="math">\\mathcal{A}&#x27;</span>  in order to solve the problem of Lemma 5.5 with probability  <span class="math">\\epsilon</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{B}(\\mathbb{G}, g_0, g_1)</span>  samples a random  <span class="math">g \\gets \\mathbb{S}\\mathbb{G}</span> , determines a PrimeGen as in VC.Setup, sets  <span class="math">\\operatorname{crs} \\gets (\\mathbb{G}, g, g_0, g_1, \\text{PrimeGen})</span> , and runs  <span class="math">\\mathcal{A}</span>  on input crs.</li>

      <li><span class="math">\\mathcal{A}(\\mathrm{crs})</span>  responds with a tuple  <span class="math">(\\vec{v},\\{A_j,B_j\\}_{j\\in [k]},I,\\vec{y},\\pi ,\\vec{y} &#x27;,\\pi &#x27;)</span></li>

      <li><span class="math">\\mathcal{B}</span>  computes  <span class="math">\\{a_j, b_j\\}_{j \\in [k]} \\gets \\text{PartndPrimeProd}([n], \\vec{v})</span> ,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\{a_{I,j},b_{I,j}\\}_{j\\in [k]}\\gets \\mathsf{PartndPrimeProd}(I,\\vec{y})</span>  and</p>

    <p class="text-gray-300"><span class="math">\\{a_{I,j}^{\\prime},b_{I,j}^{\\prime}\\}_{j\\in [k]}\\gets \\mathsf{PartndPrimeProd}(I,\\vec{y}^{\\prime})</span>  as in game  <span class="math">G_{3}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathcal{A}&#x27;</span> wins the game then we have that all the following conditions holds:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\vec{y} \\neq \\vec{y}&#x27;, \\quad \\bigwedge_{j=1}^{k} \\left( \\Gamma_{I,j}^{a_{I,j}} = A_j \\wedge \\Delta_{I,j}^{b_{I,j}} = B_j \\right) = 1, \\quad \\bigwedge_{j=1}^{k} \\left( \\Gamma_{I,j}&#x27;^{a_{I,j}&#x27;} = A_j \\wedge \\Delta_{I,j}&#x27;^{b_{I,j}&#x27;} = B_j \\right) = 1</span></div>

    <p class="text-gray-300">,</p>

    <div class="my-4 text-center"><span class="math-block">\\bigwedge_{j=1}^{k} (A_j \\cdot B_j = g_0^{a_j} \\cdot g_1^{b_j}).</span></div>

    <p class="text-gray-300">From <span class="math">\\vec{y} \\neq \\vec{y}&#x27;</span> we get that there is at least one pair of indices <span class="math">l \\in [m]</span> and <span class="math">j \\in [k]</span> such that <span class="math">y_{lj} \\neq y_{lj}&#x27;</span>. Say wlog that <span class="math">y_{lj} = 0</span> and <span class="math">y_{lj}&#x27; = 1</span>. Also, if we parse <span class="math">I = \\{i_1, \\dots, i_m\\}</span>, we let <span class="math">i = i_l \\in [m]</span>. So we fix these indices <span class="math">i</span> and <span class="math">j</span>, and let <span class="math">p_i = \\mathsf{PrimeGen}(i)</span> be the corresponding prime.</p>

    <p class="text-gray-300">Notice that by construction of <span class="math">\\mathsf{PartndPrimeProd}</span> (and since we assumed no collision occurs in <span class="math">\\mathsf{PrimeGen}</span>) we have that either <span class="math">p_i \\nmid a_j</span> or <span class="math">p_i \\nmid b_j</span> holds. Additionally, by our assumption that <span class="math">y_{lj} = 0</span> and <span class="math">y_{lj}&#x27; = 1</span>, the following holds: <span class="math">p_i \\mid a_{I,j}</span>, <span class="math">p_i \\nmid b_{I,j}</span>, <span class="math">p_i \\nmid a_{I,j}&#x27;</span>, <span class="math">p_i \\mid b_{I,j}&#x27;</span>.</p>

    <p class="text-gray-300">From the other condition on the validity of the proofs, <span class="math">\\mathcal{B}</span> can compute two group elements <span class="math">\\hat{\\Gamma}, \\hat{\\Delta}</span> such that <span class="math">\\hat{\\Gamma}^{p_i} = A_j</span> and <span class="math">\\hat{\\Delta}^{p_i} = B_j</span>.</p>

    <p class="text-gray-300">Combining this with the condition <span class="math">A_j \\cdot B_j = g_0^{a_j} \\cdot g_1^{b_j}</span>, we have that <span class="math">(\\hat{\\Gamma} \\cdot \\hat{\\Delta})^{p_i} = g_0^{a_j} \\cdot g_1^{b_j}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{B}</span> sets <span class="math">w = \\hat{\\Gamma} \\cdot \\hat{\\Delta}</span> and outputs the tuple <span class="math">(w, p_i, a_j, b_j)</span>.</li>

    </ul>

    <p class="text-gray-300">From all the above observations, if <span class="math">\\mathcal{A}&#x27;</span> makes game <span class="math">G_4</span> return 1, then the tuple returned by <span class="math">\\mathcal{B}</span> is a suitable solution for the problem of Lemma 5.5, which in turn reduces to the Strong RSA assumption.</p>

    <p class="text-gray-300">By combining all the lemmas we have that any PPT adversary has at most negligible probability of breaking the position binding of our SVC scheme.</p>

    <p class="text-gray-300">Proof [Proof of Lemma 5.5] Suppose that for a PPT adversary <span class="math">\\mathcal{A}</span> the above probability is a non-negligible value <span class="math">\\epsilon</span>. We will construct an adversary <span class="math">\\mathcal{B}</span> that breaks strong RSA assumption with a non-negligible probability. <span class="math">\\mathcal{B}</span> takes as input <span class="math">(\\mathbb{G}, g)</span>. We denote as <span class="math">G_{\\mathcal{A}}</span> the game defined in lemma (parametrized by an adversary <span class="math">\\mathcal{A}</span>). We define two different reductions:</p>

    <p class="text-gray-300">REDUCTION 1. In reduction 1 the adversary <span class="math">\\mathcal{B}</span> breaks strong RSA assumption only in case where the adversary <span class="math">\\mathcal{A}</span> outputs a tuple <span class="math">(u, p, a, b)</span> such that <span class="math">p \\mid a</span> (and thus from assumption <span class="math">p \\nmid b</span>) and fails otherwise. <span class="math">\\mathcal{B}</span> proceeds as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}(\\mathbb{G}, g)</span> samples <span class="math">\\gamma \\gets [1, 2^{\\lambda} \\text{ord}_{max}]</span>, where <span class="math">\\text{ord}_{max}</span> is the upper bound of the order of <span class="math">\\mathbb{G}</span> outputted by <span class="math">\\mathsf{Ggen}(1^{\\lambda})</span> (see section 2.1), and sets <span class="math">g_0 \\gets g^\\gamma, g_1 \\gets g</span>. <span class="math">\\mathcal{B}</span> runs <span class="math">\\mathcal{A}</span> on input <span class="math">(\\mathbb{G}, g_0, g_1)</span>. <span class="math">\\gamma</span> is sampled from a large enough domain so that <span class="math">g^\\gamma</span> is statistically close to a uniformly distributed <span class="math">g_0</span> from <span class="math">\\mathbb{G}</span> hence <span class="math">g_0, g_1</span> are indistinguishable to two uniformly random elements of <span class="math">\\mathbb{G}</span>. <span class="math">\\mathcal{A}(\\mathbb{G}, g_0, g_1, S)</span> responds with a tuple <span class="math">(u, p, a, b)</span> and sends it to <span class="math">\\mathcal{B}</span>. We condition our analysis on the event <span class="math">p \\mid a</span>, meaning that <span class="math">\\mathcal{B}</span> stops in case <span class="math">p \\nmid a</span>.</p>

    <p class="text-gray-300">Assume that <span class="math">u^p = g_0^a \\cdot g_1^b \\wedge (p \\mid a \\wedge p \\nmid b) \\wedge u \\in \\mathbb{G} \\wedge (a, b) \\in \\mathbb{Z}^2 \\wedge p \\in S</span> then we will show that <span class="math">\\mathcal{B}</span> can break the strong RSA assumption. We argue that <span class="math">p \\mid a</span> leads to <span class="math">\\gcd(p, \\gamma a + b) = 1</span>. Let <span class="math">\\gcd(p, \\gamma a + b) \\neq 1</span>, meaning that <span class="math">\\gcd(p, \\gamma a + b) = p</span>, then <span class="math">p \\mid \\gamma a + b \\Rightarrow \\gamma a + b = 0 \\pmod{p}</span>. However, <span class="math">p \\mid a \\Rightarrow a = 0 \\pmod{p}</span>. From the two previous facts we infer that <span class="math">b = 0 \\pmod{p} \\Rightarrow p \\mid b</span>, hence <span class="math">p \\mid a \\wedge p \\mid b</span>, which is a contradiction. Therefore, assuming that <span class="math">\\gcd(p, \\gamma a + b) = 1</span>, <span class="math">\\mathcal{B}</span> uses</p>

    <p class="text-gray-300">the extended Euclidean algorithm to compute <span class="math">(\\alpha, \\beta)</span> such that <span class="math">\\alpha p + \\beta (a\\gamma + b) = 1</span>. We know that <span class="math">u^p = g_0^a g_1^b = g^{a\\gamma + b} \\Rightarrow u = g^{\\frac{a\\gamma + b}{p}}</span> hence it follows that <span class="math">g^{1/p} = g^{\\frac{\\alpha p + \\beta (a\\gamma + b) = 1}{p}} = g^{\\alpha + \\beta \\frac{a\\gamma + b}{p}} = g^{\\alpha} \\cdot u^{\\beta}</span>. Finally, <span class="math">\\mathcal{B}</span> outputs <span class="math">(g^{\\alpha} \\cdot u^{\\beta}, p)</span> which is a valid strong-RSA solution.</p>

    <p class="text-gray-300">REDUCTION 2. In reduction 2 the adversary <span class="math">\\mathcal{B}</span> breaks strong RSA assumption only in case where the adversary <span class="math">\\mathcal{A}</span> outputs a tuple <span class="math">(u,p,a,b)</span> such that <span class="math">p\\nmid a</span> and fails otherwise.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}(\\mathbb{G},g)</span> samples <span class="math">\\gamma \\leftrightarrows [1,2^{\\lambda}\\mathrm{ord}_{max}]</span>, where <span class="math">\\mathrm{ord}_{max}</span> is the upper bound of the order of <span class="math">\\mathbb{G}</span> outputted by <span class="math">\\mathsf{Ggen}(1^{\\lambda})</span> (see section 2.1), defines <span class="math">S\\coloneqq \\{p_i\\gets \\mathsf{PrimeGen}(i)\\}_{i = 1}^n</span> and <span class="math">\\mathsf{prod}\\gets \\prod_{i = 1}^{n}p_{i}</span> and sets <span class="math">g_0\\gets g,g_1\\gets g^{\\gamma \\cdot \\mathsf{prod}}</span>. <span class="math">\\mathcal{B}</span> sends <span class="math">(\\mathbb{G},g_0,g_1)</span> to <span class="math">\\mathcal{A}</span>. <span class="math">\\gamma</span> is sampled from a large enough domain so that <span class="math">g^{\\gamma}</span> is statistically close to a uniformly distributed <span class="math">g_{1}</span> from <span class="math">\\mathbb{G}</span> hence <span class="math">g_0,g_1</span> are indistinguishable to two uniformly random elements of <span class="math">\\mathbb{G}</span>. <span class="math">\\mathcal{A}(\\mathbb{G},g_0,g_1,S)</span> responds with a tuple <span class="math">(u,p,a,b)</span> and sends it to <span class="math">\\mathcal{B}</span>. We condition our analysis on the event <span class="math">p\\nmid a</span>, meaning that <span class="math">\\mathcal{B}</span> stops in case <span class="math">p\\mid a</span>.</p>

    <p class="text-gray-300">Assume that <span class="math">u^{p} = g_{0}^{a}\\cdot g_{1}^{b}\\wedge p\\nmid a\\wedge u\\in \\mathbb{G}\\wedge (a,b)\\in \\mathbb{Z}^{2}\\wedge p\\in S</span> then we will show that <span class="math">\\mathcal{B}</span> can break the strong RSA assumption. We argue that <span class="math">\\gcd (p,a + b\\gamma \\mathsf{prod}) = 1</span>. Let <span class="math">\\gcd (p,a + b\\gamma \\mathsf{prod})\\neq 1</span>, meaning that <span class="math">\\gcd (p,a + b\\gamma \\mathsf{prod}) = p</span>, then <span class="math">p\\mid a + b\\gamma \\mathsf{prod}\\Rightarrow a + b\\gamma \\mathsf{prod} = 0\\pmod{p}</span>. However, <span class="math">\\mathsf{prod}</span> includes <span class="math">p</span> <span class="math">(p\\in S)</span> we know that <span class="math">p\\mid b\\gamma \\mathsf{prod}\\Rightarrow b\\gamma \\mathsf{prod} = 0\\pmod{p}</span>. From the two previous facts we infer that <span class="math">a = 0\\pmod{p}\\Rightarrow p\\mid a</span> which is a contradiction. <span class="math">\\mathcal{B}</span> uses the extended Euclidean algorithm to compute <span class="math">(\\alpha ,\\beta)</span> such that <span class="math">\\alpha p + \\beta (a + b\\gamma \\mathsf{prod}) = 1</span>. We know that <span class="math">u^{p} = g_{0}^{a}g_{1}^{b} = g^{a + b\\gamma \\mathsf{prod}}\\Rightarrow u = g^{\\frac{a + b\\gamma\\mathsf{prod}}{p}}</span> hence it follows that <span class="math">g^{1 / p} = g^{\\frac{\\alpha p + \\beta(a + b\\gamma\\mathsf{prod}) = 1}{p}} = g^{\\alpha +\\beta \\frac{a + b\\gamma\\mathsf{prod}}{p}} = g^{\\alpha}\\cdot u^{\\beta}</span>. Finally, <span class="math">\\mathcal{B}</span> outputs <span class="math">(g^{\\alpha}\\cdot u^{\\beta},p)</span> which is a valid strong-RSA solution.</p>

    <p class="text-gray-300">To conclude the proof, notice that:</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr [ G _ {\\mathcal {A}} = 1 ] = \\Pr [ G _ {\\mathcal {A}} = 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p \\mid a ] \\Pr [ p \\mid a ] + \\Pr [ G _ {\\mathcal {A}} = 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p \\nmid a ] \\Pr [ p \\nmid a ] \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The reductions 1 and 2 described above show that under the strong RSA assumption $\\operatorname*{Pr}[G_{\\mathcal{A}} = 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p\\mid a]<span class="math"> and </span>\\operatorname*{Pr}[G_{\\mathcal{A}} = 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p\\nmid a]<span class="math"> respectively are negligible. Hence, we have that </span>\\operatorname*{Pr}[G_{\\mathcal{A}} = 1]\\in \\mathsf{negl}(\\lambda)$, which concludes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">On concrete instantiation. Our SVC construction is described generically from a hidden order group <span class="math">\\mathbb{G}</span>, an AoK <span class="math">\\mathsf{PoProd}_2</span>, and a mapping to primes <span class="math">\\mathsf{PrimeGen}</span>. The concrete scheme we analyze is the one where <span class="math">\\mathsf{PoProd}_2</span> is instantiated with the non-interactive version of the <span class="math">\\mathsf{PoProd}_2</span> protocol described in Sec. 5.1. The non-interactive version needs a hash-to-prime function <span class="math">\\mathsf{H}_{\\mathsf{prime}}</span>. We note that the same function can be used to instantiate <span class="math">\\mathsf{PrimeGen}</span>, though for the sake of <span class="math">\\mathsf{PrimeGen}</span> we do not need its randomness properties. One can choose a different mapping to primes for <span class="math">\\mathsf{PrimeGen}</span> and even just a bijective mapping (which is inherently collision resistant) would be enough: this is actually the instantiation we consider in our efficiency analysis. Finally, see Section 2.1 for a discussion on possible instantiations of <span class="math">\\mathbb{G}</span>.</p>

    <p class="text-gray-300">We note that by using the specific <span class="math">\\mathsf{PoProd}_2</span> protocol given in Sec. 5.1 we are assuming adversaries that are generic with respect to the group <span class="math">\\mathbb{G}</span>. Therefore, our SVC is ultimately position binding in the generic group model.</p>

    <h2 id="sec-22" class="text-2xl font-bold">5.2 Our Second SVC Construction</h2>

    <p class="text-gray-300">In this section we propose another SVC scheme with constant-size parameters and incremental aggregation. This scheme builds on the SVC of [LM19] based on the RSA assumption, which in</p>

    <p class="text-gray-300">turn extends the VC of [CF13] to support subvector openings. Our technical contribution is twofold. First, we show that the SVC of [CF13, LM19] can be modified in order to have public parameters and verification time independent of the vector's length. Second, we propose new algorithms for (incremental) aggregation and disaggregation for this SVC.</p>

    <p class="text-gray-300">Our second SVC Construction. Let us start by giving a brief overview of the [CF13] VC scheme and of the basic idea to turn it into one with succinct parameters and verification time. In brief, in [CF13] a commitment to a vector  <span class="math">\\vec{v}</span>  is  <span class="math">C = S_1^{v_1} \\cdots S_n^{v_n}</span> , where each  <span class="math">S_i := g^{\\prod_{j \\in [n] \\setminus \\{i\\}} e_j}</span>  with  <span class="math">g \\in \\mathbb{G}</span>  a random generator and  <span class="math">e_j</span>  being distinct prime numbers (which can be deterministically generated using a suitable map-to-primes). The opening for position  <span class="math">i</span>  is an element  <span class="math">\\Lambda_i</span>  such that  <span class="math">\\Lambda_i^{e_i} \\cdot S_i^{v_i} = C</span>  and the key idea is that such  <span class="math">\\Lambda_i</span>  is an  <span class="math">e_i</span> -th root that can be publicly computed as long as one does it for the correct position  <span class="math">i</span>  and value  <span class="math">v_i</span> . Also, as it can be seen, the element  <span class="math">S_i</span>  is necessary to verify an opening of position  <span class="math">i</span> , and thus  <span class="math">(S_1, \\ldots, S_n)</span>  were included in the public parameters. Catalano and Fiore observed that it might be possible to remove the  <span class="math">S_i</span> -s from  <span class="math">\\mathbf{crs}</span>  if the verifier opts for recomputing  <span class="math">S_i</span>  at verification time at the price of linear-time verification.</p>

    <p class="text-gray-300">Our goal is to obtain constant-size parameters and constant-time verification. To do that we let the prover compute  <span class="math">S_{i}</span>  and include it in the opening for position  <span class="math">i</span> . To prevent adversaries from providing false  <span class="math">S_{i}</span> 's, we store in the public parameters  <span class="math">U_{n} = g^{\\prod_{i\\in [n]}e_{i}}</span>  (i.e., an accumulator to all positions) so that the verifier can verify the correctness of  <span class="math">S_{i}</span>  in constant-time by checking  <span class="math">S_{i}^{e_{i}} = U_{n}</span> . This technique easily generalizes to subvector openings.</p>

    <p class="text-gray-300">In the following, we describe the scheme in details and then propose our incremental aggregation algorithms. To simplify our exposition, we use the following notation: for a set of indices  <span class="math">I \\subseteq [n]</span> ,  <span class="math">e_I := \\prod_{i \\in I} e_i</span>  denotes the product of all primes corresponding to the elements of  <span class="math">I</span> , and  <span class="math">S_I := g^{\\prod_{i \\in [n] \\setminus I} e_i} = g^{e_{[n] \\setminus I}} = U_n^{1 / e_I}</span>  (which is a generalization of the former  <span class="math">S_i</span> ), where, we recall, the  <span class="math">e_i</span> 's are defined from the crs.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{VC.Setup}(1^{\\lambda},\\ell ,n)\\to \\mathsf{crs}</span>  generates a hidden order group  <span class="math">\\mathbb{G}\\gets \\mathsf{Ggen}(1^{\\lambda})</span>  and samples a generator  <span class="math">g\\gets \\mathbb{G}</span> . It also determines a deterministic collision resistant function PrimeGen that maps integers to primes.</p>

    <p class="text-gray-300">Returns  <span class="math">\\mathsf{crs} = (\\mathbb{G},g,\\mathsf{PrimeGen})</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{VC.Specialize}(\\mathsf{crs},n)\\to \\mathsf{crs}_n</span>  computes  <span class="math">n</span> <span class="math">(\\ell +1)</span>  -bit primes  <span class="math">e_1,\\ldots ,e_n</span> <span class="math">e_i\\gets \\mathsf{PrimeGen}(i)</span>  for each  <span class="math">i\\in [n]</span> , and  <span class="math">U_{n} = g^{e_{[n]}}</span>  and returns  <span class="math">\\mathsf{crs}_n\\gets (\\mathsf{crs},U_n)</span> . One can think of  <span class="math">U_{n}</span>  as an accumulator to the set  <span class="math">[n]</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathsf{VC.Com}(\\mathsf{crs},\\vec{v})\\to (C,\\mathsf{aux})</span>  Computes for each  <span class="math">i\\in [n]</span> <span class="math">S_{i}\\gets g^{e_{[n]\\setminus \\{i\\}}}</span>  and then  <span class="math">C\\gets S_1^{v_1}\\ldots S_n^{v_n}</span>  and  <span class="math">\\mathsf{aux}\\gets (v_{1},\\ldots ,v_{n})</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{VC.Open}(\\mathsf{crs},I,\\vec{y},\\mathsf{aux})\\to \\pi_I</span>  Computes for each  <span class="math">j\\in [n]\\setminus I</span> <span class="math">S_{j}^{1 / e_{I}}\\gets g^{e_{[n]\\setminus (I\\cup \\{j\\})}}</span>  and  <span class="math">S_{I}\\gets g^{e_{[n]\\setminus I}}</span>  and then</p>

    <div class="my-4 text-center"><span class="math-block">\\Lambda_ {I} \\leftarrow \\prod_ {j = 1, j \\notin I} ^ {n} \\left(S _ {j} ^ {1 / e _ {I}}\\right) ^ {y _ {j}} = \\left(\\prod_ {j = 1, j \\notin I} ^ {n} S _ {j} ^ {y _ {j}}\\right) ^ {1 / e _ {I}}</span></div>

    <p class="text-gray-300">Returns  <span class="math">\\pi_I\\coloneqq (S_I,\\Lambda_I)</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{VC.Ver}(\\mathsf{crs},C,I,\\vec{y},\\pi_I)\\to b</span>  Parse  <span class="math">\\pi_I\\coloneqq (S_I,\\Lambda_I)</span>  , and compute  <span class="math">S_{i} = S_{I}^{e_{I}\\backslash \\{i\\}} = U_{n}^{1 / e_{i}}</span>  for every  <span class="math">i\\in I</span>  Return 1 (accept) if both the following checks hold, and 0 (reject) otherwise:</p>

    <div class="my-4 text-center"><span class="math-block">S _ {I} ^ {e _ {I}} = U _ {n} \\wedge C = \\Lambda_ {I} ^ {e _ {I}} \\prod_ {i \\in I} S _ {i} ^ {y _ {i}}</span></div>

    <p class="text-gray-300">The correctness of the above construction holds essentially the same as the one of the SVC of [CF13, LM19] with the addition of the <span class="math">S_I</span> elements of the openings, whose correctness can be seen by inspection (and is the same as for RSA accumulators).</p>

    <p class="text-gray-300"><strong>Incremental Aggregation.</strong> Let us now show that the SVC above has incremental aggregation. Note that our algorithms also implicitly show that the RSA-based SVC of [LM19] is incrementally aggregatable.</p>

    <p class="text-gray-300"><strong>VC. Disagg(crs, <span class="math">I, \\vec{v}_I, \\pi_I, K</span>) <span class="math">\\rightarrow</span> <span class="math">\\pi_K</span></strong> Parse <span class="math">\\pi_I := (S_I, \\Lambda_I)</span>. First compute <span class="math">S_K</span> from <span class="math">S_I</span>, <span class="math">S_K \\gets S_I^{e_{I \\setminus K}}</span>, and then, for every <span class="math">j \\in I \\setminus K</span>, <span class="math">\\chi_j = S_K^{1/e_j}</span>, e.g., by computing <span class="math">\\chi_j \\gets S_I^{e_{I \\setminus (K \\cup \\{j\\})}}</span>.</p>

    <p class="text-gray-300">Return <span class="math">\\pi_K := (S_K, \\Lambda_K)</span> where</p>

    <div class="my-4 text-center"><span class="math-block">\\Lambda_K \\leftarrow \\Lambda_I^{e_{I \\setminus K}} \\cdot \\prod_{j \\in I \\setminus K} \\chi_j^{v_j}</span></div>

    <p class="text-gray-300"><strong>VC. Agg(crs, <span class="math">(I, \\vec{v}_I, \\pi_I), (J, \\vec{v}_J, \\pi_J))</span> <span class="math">\\rightarrow</span> <span class="math">\\pi_K</span></strong> Parse <span class="math">\\pi_I := (S_I, \\Lambda_I)</span> and similarly <span class="math">\\pi_J</span>. Also, let <span class="math">K = I \\cup J</span>, and assume for simplicity that <span class="math">I \\cap J = \\emptyset</span> (if this is not the case, one could simply disaggregate <span class="math">\\pi_I</span> (or <span class="math">\\pi_J</span>) to <span class="math">\\pi_{I \\setminus J}</span> (or <span class="math">\\pi_{J \\setminus I}</span>)).</p>

    <p class="text-gray-300">First, compute <span class="math">S_K \\gets \\mathbf{ShamirTrick}(S_I, S_J, e_I, e_J)</span>. Next, compute <span class="math">\\phi_j \\gets S_K^{e_{J \\setminus \\{j\\}}} = S_I^{1/e_j}</span> for every <span class="math">j \\in J</span>, and similarly <span class="math">\\psi_i \\gets S_K^{e_{I \\setminus \\{i\\}}} = S_J^{1/e_i}</span> for every <span class="math">i \\in I</span>. Then compute</p>

    <div class="my-4 text-center"><span class="math-block">\\rho_I \\leftarrow \\frac{\\Lambda_I}{\\prod_{j \\in J} \\phi_j^{v_j}} \\qquad \\text{and} \\qquad \\sigma_J \\leftarrow \\frac{\\Lambda_J}{\\prod_{i \\in I} \\psi_i^{v_i}}</span></div>

    <p class="text-gray-300">Return <span class="math">\\pi_K := (S_K, \\Lambda_K)</span> where <span class="math">\\Lambda_K \\gets \\mathbf{ShamirTrick}(\\rho_I, \\sigma_J, e_I, e_J)</span>.</p>

    <p class="text-gray-300"><strong>Aggregation Correctness.</strong> It follows from the correctness of Shamir's trick and by construction. In Aggregation and disaggregation <span class="math">S_K</span>'s correctness is straightforward, so we emphasize on <span class="math">\\Lambda_K</span>. For the disaggregation algorithm:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\Lambda_K := \\Lambda_I^{e_{I \\setminus K}} \\cdot \\prod_{j \\in I \\setminus K} \\chi_j^{v_j} &amp;amp;= \\left(\\prod_{j=1, j \\notin I}^n S_j^{v_j}\\right)^{\\frac{1}{e_I} e_{I \\setminus K}} \\cdot \\prod_{j \\in I \\setminus K} \\left(S_j^{1/e_K}\\right)^{v_j} \\\\ &amp;amp;= \\left(\\prod_{j=1, j \\notin I}^n S_j^{v_j}\\right)^{\\frac{1}{e_K}} \\cdot \\left(\\prod_{j \\in I \\setminus K} S_j^{v_j}\\right)^{1/e_K} \\\\ &amp;amp;= \\left(\\prod_{j=1, j \\notin K}^n S_j^{v_j}\\right)^{1/e_K} \\end{aligned}</span></div>

    <p class="text-gray-300">which is a valid opening for the <span class="math">K</span>-subvector. And for the aggregation algorithm:</p>

    <div class="my-4 text-center"><span class="math-block">\\rho_I := \\frac{\\Lambda_I}{\\prod_{j \\in J} \\phi_j^{v_j}} = \\left(\\prod_{j=1, j \\notin I \\cup J}^n S_j^{v_j}\\right)^{1/e_I} \\quad \\text{and} \\quad \\sigma_J := \\frac{\\Lambda_J}{\\prod_{j \\in I} \\psi_j^{v_j}} = \\left(\\prod_{j=1, j \\notin J \\cup I}^n S_j^{v_j}\\right)^{1/e_J}</span></div>

    <p class="text-gray-300">SO</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Lambda_{K} := \\mathbf{ShamirTrick}(\\rho_{I}, \\sigma_{J}, e_{I}, e_{J}) \\\\ = \\mathbf{ShamirTrick}\\left(\\left(\\prod_{j=1,j \\notin I \\cup J}^{n} S_{j}^{v_{j}}\\right)^{1/e_{I}}, \\left(\\prod_{j=1,j \\notin J \\cup I}^{n} S_{j}^{v_{j}}\\right)^{1/e_{J}}, e_{I}, e_{J}\\right) \\\\ = \\left(\\prod_{j=1,j \\notin I \\cup J}^{n} S_{j}^{v_{j}}\\right)^{\\frac{1}{e_{I} \\cdot e_{J}}} = \\left(\\prod_{j=1,j \\notin I \\cup J}^{n} S_{j}^{v_{j}}\\right)^{\\frac{1}{e_{I \\cup J}}} \\end{array}</span></div>

    <p class="text-gray-300">which is a valid opening for the <span class="math">(I \\cup J)</span>-subvector.</p>

    <p class="text-gray-300"><strong>Efficiency.</strong> We summarize the efficiency of this construction in terms of both the computational cost of each algorithm and the communication. For the analysis we consider an instantiation of PrimeGen with a deterministic function that maps every integer in <span class="math">[n]</span> into an <span class="math">\\ell</span>-bit prime number. Also, we observe that the algorithms described above may have different implementations: while straightforward instantiations may lead to a complexity quadratic in the (sub)vector's length, in what follows we discuss more efficient ways that keeps the complexity quasilinear. For this, we often rely on the MultiExp algorithm described in [BBF19]. On input an integer <span class="math">n</span>, and two vectors <span class="math">\\vec{\\alpha} \\in \\mathbb{G}^n</span> and <span class="math">\\vec{x} \\in \\mathbb{Z}^n</span>, MultiExp<span class="math">(n, \\vec{\\alpha}, \\vec{x})</span> is a divide-and-conquer algorithm that computes <span class="math">\\prod_{i=1}^{n} \\alpha_i^{x^<em> / x_i}</span> where <span class="math">x^</em> = \\prod_{i=1}^{n} x_i</span>, and it does it in time <span class="math">O(n \\log n)</span>, instead of a naive <span class="math">O(n^2)</span>.</p>

    <p class="text-gray-300"><strong>SETUP.</strong> VC.Setup generates a group description and samples one random group element, while VC.Specialize computes one exponentiation with an <span class="math">(\\ell \\cdot n)</span>-bits integer. Both the universal and the specialized CRS consist each of 1 element of <span class="math">\\mathbb{G}</span>.</p>

    <p class="text-gray-300"><strong>COMMITTING.</strong> Committing to a vector <span class="math">\\vec{v} \\in (\\{0,1\\}^{\\ell})^{n}</span> can be done in time <span class="math">O(\\ell \\cdot n \\log n)</span> by using the MultiExp algorithm from [BBF19], i.e., <span class="math">C \\gets \\mathbf{MultiExp}(n, \\vec{\\alpha}, \\vec{e})</span> where <span class="math">\\alpha_{i} = g^{v_{i}}</span> and <span class="math">e_{i} = \\mathsf{PrimeGen}(i)</span>. The commitment is a single element of <span class="math">\\mathbb{G}</span>.</p>

    <p class="text-gray-300"><strong>OPENING.</strong> An opening for a set <span class="math">I</span> of <span class="math">m</span> positions consists of two group elements, and it can be computed as follows. First, compute <span class="math">S_{I}</span> through the exponentiation <span class="math">g^{e_{[n] \\setminus I}}</span> which requires <span class="math">O(\\ell(n - m))</span> group operations, and then compute <span class="math">\\Lambda_{I}</span> in a way similar to committing, i.e., <span class="math">\\Lambda_{I} \\gets \\mathbf{MultiExp}(n&#x27;, \\vec{\\alpha}, \\vec{x})</span>, where <span class="math">n&#x27; = n - m</span>, <span class="math">\\vec{\\alpha} = (g^{v_{j}})_{j \\in [n] \\setminus I}</span>, <span class="math">\\vec{x} = (e_{j})_{j \\in [n] \\setminus I}</span>, which takes time <span class="math">O(\\ell(n - m) \\log(n - m))</span>.</p>

    <p class="text-gray-300"><strong>VERIFICATION.</strong> Verifying an opening for <span class="math">I</span> of size <span class="math">m</span> requires two exponentiations with an <span class="math">(\\ell m)</span>-bits long integer <span class="math">(S_I^{e_I}</span> and <span class="math">\\Lambda_I^{e_I})</span>, and the computation of <span class="math">\\prod_{i\\in I}S_i^{y_i}</span> can be done in time <span class="math">O(\\ell m\\log m)</span> by running MultiExp<span class="math">(m,\\vec{\\alpha},\\vec{x})</span> with <span class="math">\\vec{\\alpha} = (S_I^{y_1},\\dots,S_I^{y_m})</span> and <span class="math">\\vec{x} = (e_i)_{i\\in I}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>AGGREGATION AND DISAGGREGATION.</strong> Disaggregation can be computed in time $O(\\ell(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\log (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math"> in a way similar to verification: two exponentiations with an </span>\\ell(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">-bits long integer each, and an invocation of MultiExp</span>((</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">), \\vec{\\alpha}, \\vec{x})<span class="math">, with </span>\\vec{\\alpha} = (S_I^{v_j})_{j \\in I \\setminus K}<span class="math"> and </span>\\vec{x} = (e_j)_{j \\in I \\setminus K}<span class="math">, to compute </span>\\prod_{j \\in I \\setminus K} S_I^{e_{I \\setminus (K \\cup \\{j\\})} \\cdot v_j}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Aggregation can be computed in time <span class="math">O(\\ell m \\log m)</span> where $m = \\max(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> as follows. Two invocations of ShamirTrick, each requiring two exponentiations with </span>(\\ell m)<span class="math">-bits long integers, to compute </span>S_K<span class="math"> and </span>\\Lambda_K<span class="math">, and two invocations of MultiExp to compute </span>\\prod_{j \\in J} \\phi_j^{v_j}<span class="math"> and </span>\\prod_{i \\in I} \\psi_i^{v_i}<span class="math"> respectively. From this, we obtain that VC.AggManyToOne and VC.DisaggOneToMany take time </span>O(\\ell m \\log^2 m) \\mathbb{G}<span class="math"> and </span>O(\\ell m \\log m \\log (m / B)) \\mathbb{G}$, respectively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>COMMITMENT AND OPENING WITH PRECOMPUTATION.</strong> Finally, let us summarize the costs of committing and opening with preprocessing obtained by instantiating our method of Section 4.2.</p>

    <p class="text-gray-300">34</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The preprocessing VC.PPCom, with parameter <span class="math">B</span>, requires <span class="math">O(\\ell n \\log n \\log (n / B))</span> operations of <span class="math">\\mathbb{G}</span> and produces a storage advice of <span class="math">2n / B</span> group elements. The opening requires computing at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq m<span class="math"> disaggregation, each taking time </span>O(\\ell (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\log ((</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)))<span class="math">, for a total of </span>O(\\ell (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\log (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">, followed by the aggregation step that counts </span>O(\\ell</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. So, in the worst case VC.FastOpen takes </span>O(\\ell \\cdot m \\cdot (\\log^2(m) + B - 1))<span class="math"> operations of </span>\\mathbb{G}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Security.</strong> For the security of the above SVC scheme we observe that the difference with the corresponding [LM19] lies in the generation of <span class="math">S_{i}</span>'s. In [LM19] they are generated in the trusted setup phase, thus they are considered "well-formed" in the security proof. In our case, the <span class="math">S_{i}</span>'s are reconstructed during verification time from the <span class="math">S_{I}</span> that comes in the opening <span class="math">\\pi_{I}</span> which can (possibly) be generated in an adversarial way. However, in the verification it is checked that <span class="math">S_{I}^{e_{I}} = U</span>, where <span class="math">U = g^{e_{[n]}}</span> is computed in the trusted setup. So under the Low Order assumption we get that <span class="math">S_{I}</span> has the correct form, <span class="math">S_{I} = g^{e_{[n]} / e_{I}} = g^{e_{[n] \\setminus I}}</span>, with overwhelming probability. Except for this change, the rest reduces to the position binding of the [LM19] SVC.</p>

    <p class="text-gray-300"><strong>Theorem 5.3 (Position-Binding).</strong> Let <span class="math">\\mathsf{Ggen}</span> be the generator of hidden order groups where the Low Order assumption holds and the [LM19] SVC is position binding. Then the SVC scheme defined above is position binding.</p>

    <p class="text-gray-300"><strong>Proof</strong> We start by defining the game <span class="math">G_{0}</span> as the actual position binding game of Definition 3.2, and our goal is to prove that for any PPT <span class="math">\\mathcal{A}</span>, <span class="math">\\operatorname*{Pr}[G_0 = 1] \\in \\mathrm{negl}(\\lambda)</span>:</p>

    <p class="text-gray-300"><strong>Game <span class="math">G_0</span>:</strong></p>

    <p class="text-gray-300"><span class="math">G_0 = \\mathrm{PosBind}_{\\mathsf{VC}}^A (\\lambda)</span></p>

    <p class="text-gray-300">crs <span class="math">\\leftarrow</span> VC.Setup <span class="math">(1^{\\lambda},\\mathcal{M})</span></p>

    <p class="text-gray-300"><span class="math">(C,I,\\vec{y},\\pi ,\\vec{y}^{\\prime},\\pi^{\\prime})\\gets \\mathcal{A}(\\mathsf{crs})</span></p>

    <p class="text-gray-300"><span class="math">b\\gets \\mathsf{VC.Ver}(\\mathsf{crs},C,I,\\vec{y},\\pi) = 1\\wedge \\vec{y}\\neq \\vec{y}^{\\prime}\\wedge \\mathsf{VC.Ver}(\\mathsf{crs},C,I,\\vec{y}^{\\prime},\\pi^{\\prime}) = 1</span></p>

    <p class="text-gray-300">return <span class="math">b</span></p>

    <p class="text-gray-300">More specifically <span class="math">\\mathsf{crs} := (\\mathbb{G}, g, \\mathsf{PrimeGen})</span>, <span class="math">\\pi := (S_I, \\Lambda_I)</span>, <span class="math">\\pi&#x27; := (S_I&#x27;, \\Lambda_I&#x27;)</span> and</p>

    <div class="my-4 text-center"><span class="math-block">b = S _ {I} ^ {e _ {I}} = U _ {n} \\wedge C = \\Lambda_ {I} ^ {e _ {I}} \\prod_ {i \\in I} S _ {i} ^ {y _ {i}} \\wedge \\vec {y} = \\vec {y} ^ {\\prime} \\wedge S _ {I} ^ {\\prime e _ {I}} = U _ {n} \\wedge C = \\Lambda_ {I} ^ {\\prime e _ {I}} \\prod_ {i \\in I} S _ {i} ^ {\\prime y _ {i} ^ {\\prime}}</span></div>

    <p class="text-gray-300">where <span class="math">S_{i} = S_{I}^{e_{I}\\setminus \\{i\\}}</span> and <span class="math">S_{i}^{\\prime} = S_{I}^{\\prime e_{I}\\setminus \\{i\\}}</span> for each <span class="math">i\\in I</span>.</p>

    <p class="text-gray-300">Now let <span class="math">G_{1}</span> be the same as above except for the outputted by the adversary <span class="math">S_{I}</span> and <span class="math">S_{I}^{\\prime}</span> it holds that <span class="math">S_{I} = g^{e_{[n] \\setminus I}} = S_{I}^{\\prime}</span>. The <span class="math">S_{I}^{e_{I}} = U_{n} = S_{I}^{\\prime e_{I}}</span> checks are not done in the verification (as they are redundant):</p>

    <p class="text-gray-300"><strong>Game <span class="math">G_1</span>:</strong></p>

    <p class="text-gray-300"><span class="math">G_{1}</span></p>

    <p class="text-gray-300">crs <span class="math">\\leftarrow</span> VC.Setup <span class="math">(1^{\\lambda},\\mathcal{M})</span></p>

    <p class="text-gray-300"><span class="math">(C,I,\\vec{y},(S_I,\\Lambda_I),\\vec{y}^{\\prime},(S_I^{\\prime},\\Lambda_I^{\\prime}))\\gets \\mathcal{A}(\\mathsf{crs})</span></p>

    <p class="text-gray-300">if <span class="math">S_{I} \\neq g^{e_{[n] \\setminus I}}</span> or <span class="math">S_{I}^{\\prime} \\neq g^{e_{[n] \\setminus I}}</span> then abort</p>

    <div class="my-4 text-center"><span class="math-block">b \\leftarrow C = \\Lambda_ {I} ^ {e _ {I}} \\prod_ {i \\in I} \\left(S _ {I} ^ {e _ {I} \\backslash \\{i \\}}\\right) ^ {y _ {i}} \\wedge \\vec {y} = \\vec {y} ^ {\\prime} \\wedge C = \\Lambda_ {I} ^ {\\prime e _ {I}} \\prod_ {i \\in I} \\left(S _ {I} ^ {\\prime e _ {I} \\backslash \\{i \\}}\\right) ^ {y _ {i} ^ {\\prime}}</span></div>

    <p class="text-gray-300">return <span class="math">b</span></p>

    <p class="text-gray-300">Then <span class="math">\\operatorname<em>{Pr}[G_0 = 1] \\leq \\operatorname</em>{Pr}[G_1 = 1] + \\mathrm{negl}(\\lambda)</span>. In <span class="math">G_0</span>, <span class="math">S_I^{e_I} = U_n = g^{e_{[n]}}</span>. Assume that <span class="math">S_I \\neq g^{e_{[n] \\setminus I}}</span> then <span class="math">g^{e_{[n] \\setminus I}} = S_I^<em></span>, hence <span class="math">S_I^{e_I} = S_I^{</em>e_I} \\Rightarrow (S_I^{-1}S_I^<em>)^{e_I} = 1</span>. Since <span class="math">S_I^</em></span> is efficiently computable and</p>

    <p class="text-gray-300">35</p>

    <p class="text-gray-300"><span class="math">e_{I}&lt;2^{\\mathsf{poly}(\\lambda)}</span> this constitutes a solution to the Low Order problem for the hidden order group. The previous happens only with negligible probability under the Low Order assumption. The same holds for <span class="math">S^{\\prime}_{I}</span>. Notice that it follows that <span class="math">S_{i}=S^{\\prime}_{i}=g^{e_{[n]\\setminus\\{i\\}}}</span>.</p>

    <p class="text-gray-300">Let <span class="math">G_{2}</span> be the same as above except the adversary receives <span class="math">e_{i}\\leftarrow\\mathsf{PrimeGen}(i)</span> and <span class="math">S_{i}=g^{e_{[n]\\setminus\\{i\\}}}</span> for each <span class="math">i\\in[n]</span>, together with the parameters:</p>

    <p class="text-gray-300">Game <span class="math">G_{2}</span>:</p>

    <p class="text-gray-300"><span class="math">G_{2}</span></p>

    <p class="text-gray-300"><span class="math">(\\mathbb{G},g,\\mathsf{PrimeGen})\\leftarrow\\mathsf{VC.Setup}(1^{\\lambda},\\mathcal{M})</span></p>

    <p class="text-gray-300"><span class="math">e_{i}\\leftarrow\\mathsf{PrimeGen}(i);S_{i}=g^{\\prod_{i\\in[n]\\setminus\\{i\\}}e_{i}}</span> for each <span class="math">i\\in[n]</span></p>

    <p class="text-gray-300"><span class="math">(C,I,\\vec{y},\\Lambda_{I},\\vec{y}^{\\prime},\\Lambda_{I}^{\\prime})\\leftarrow\\mathcal{A}\\left(\\mathbb{G},g,\\mathsf{PrimeGen},\\{S_{i}\\}_{i\\in[n]}\\right)</span></p>

    <p class="text-gray-300"><span class="math">b\\leftarrow C=\\Lambda_{I}^{e_{I}}\\prod_{i\\in I}S_{i}^{y_{i}}\\wedge\\vec{y}=\\vec{y}^{\\prime}\\wedge C=\\Lambda_{I}^{i_{e_{I}}}\\prod_{i\\in I}S_{i}^{y_{i}^{\\prime}}</span></p>

    <p class="text-gray-300">return <span class="math">b</span></p>

    <p class="text-gray-300">It is straightforward that <span class="math">\\Pr[G_{1}=1]=\\Pr[G_{2}=1]</span> and furthermore <span class="math">G_{2}</span> is identical to the position binding game of the <em>[x12]</em> SVC scheme and according to the hypothesis <span class="math">\\Pr[G_{2}=1]=\\mathsf{negl}(\\lambda)</span>. <span class="math">\\square</span></p>

    <p class="text-gray-300">As showed in <em>[x12]</em>, their SVC is position binding under the strong Distinct-Prime-Product Root assumption in the standard model. We conclude that the above SVC is position binding in hidden order groups where the Low Order and the Strong Distinct-Prime-Product Root assumptions hold.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">5.3 Comparison with Related Work</h3>

    <p class="text-gray-300">We compare our two SVC schemes with the recent scheme proposed by Boneh et al. <em>[x1]</em> and the one by Lai and Malavolta <em>[x12]</em>, which extends <em>[x4]</em> to support subvector openings. We present a detailed comparison in Table 1, considering to work with vectors of length <span class="math">N</span> of <span class="math">\\ell</span>-bit elements and security parameter <span class="math">\\lambda</span>. In particular we consider an instantiation of our first SVC with <span class="math">k=1</span> (and thus <span class="math">n=N\\cdot\\ell</span>).</p>

    <p class="text-gray-300">Setup Model. <em>[x1]</em> works with a fully universal CRS, whereas our schemes have both a universal CRS with deterministic specialization, which however, in comparison to <em>[x4, x12]</em>, outputs constant-size parameters instead of linear.</p>

    <p class="text-gray-300">Aggregation. The VC of <em>[x1]</em> supports aggregation only on openings created by VC.Open (i.e., it is one-hop) and does not have disaggregatable proofs (unless in a different model where one works linearly in the length of the vector or knows the full vector). In contrast, we show the first schemes that satisfy incremental aggregation (also, our second one immediately yields a method for the incremental aggregation of <em>[x12]</em>). As we mention later, incremental aggregation can be very useful to precompute openings for a certain number of vector blocks allowing for interesting time-space tradeoffs that can speedup the running time of VC.Open.</p>

    <p class="text-gray-300">Efficiency. From the table, one can see that our first SVC has: slightly worse commitments size than all the other schemes, computational asymptotic performances similar to <em>[x1]</em>, and opening size slightly better than <em>[x1]</em>. Our second SVC is the most efficient among the schemes with constant-size parameters; in particular, it has faster asymptotics than our first SVC and <em>[x1]</em></p>

    <p class="text-gray-300">for having a smaller logarithmic factor (e.g.,  <span class="math">\\log(N - m)</span>  vs.  <span class="math">\\log(\\ell N)</span> ), which is due to the avoidance of using one prime per bit of the vector. In some cases, [CF13, LM19] is slightly better, but this is essentially a benefit of the linear-size parameters, namely the improvement is due to having the  <span class="math">S_{i}</span> 's elements already precomputed.</p>

    <p class="text-gray-300">When considering applications in which a user creates the commitment to a vector and (at some later points in time) is requested to produce openings for various subvectors, our incremental aggregation property leads to use preprocessing to achieve more favorable time and memory costs. In a nutshell, The idea of preprocessing is that one can precompute and store information that allows to speedup the generation of openings, in particular by making opening time less dependent on the total length of the vector. Our method in Section 4.2 works generically for any SVC that has incremental aggregation. A similar preprocessing solution can also be designed for the SVC of [BBF19] by using its one-hop aggregation; we provide a detailed description of the method in Appendix B. The preprocessing for [BBF19] however has no flexibility in choosing how much auxiliary storage can be used, and one must store (a portion of) a non-membership witness for every bit of the vector.</p>

    <p class="text-gray-300">Even in the simplest case of  <span class="math">B = 1</span>  (shown in Table 1) both our SVCs save a factor  <span class="math">\\ell</span>  in storage, which concretely turns into  <span class="math">3 \\times</span>  less storage.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Furthermore we support flexible choices of  <span class="math">B</span>  thus allowing to tune the amount of auxiliary storage. For instance, we can choose  <span class="math">B = \\sqrt{N}</span>  so as to get  $2\\sqrt{N}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  bits of storage, and opening time about  </span>O(\\ell m\\log n(\\sqrt{n} + \\log m))<span class="math">  and  </span>O(m(\\sqrt{n} + \\log^2 m))<span class="math">  in the first and second scheme respectively. Our flexibility may also allow one to choose the buckets size  </span>B$  and their distribution according to applications-dependent heuristics; investigating its benefit may be an interesting direction for future work.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Metric</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our First SVC</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our Second SVC</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[BBF19]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[CF13, LM19]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Setup  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VC.Setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(1)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VC.Specialize</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·N·log(ℓN)) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·N) G</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·N·log N) G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">crsN</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">N</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Commit a vector v ∈ {0,1}ℓN  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VC.Com</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(ℓ·N·log(ℓN)) G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(ℓ·N·log N) G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(ℓ·N·log(ℓN)) G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(ℓ·N) G</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Opening and Verification for vI with</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">= m</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VC.Open</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·(N-m)·log(ℓN)) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·(N-m)·log(N-m)) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·(N-m)·log(ℓN)) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·(N-m)·m log m) G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">πI</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">+ 1</td>

            <td class="px-3 py-2 border-b border-gray-700">Zgik</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VC.Ver</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·m·log(ℓN)) Zgik + O(λ) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(m·ℓ·log(ℓN)) Zgik + O(λ) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·m) G</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Commitment and Opening with Precomputation  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VC.Com</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(ℓ·N·log(ℓ·N)·log(N)) G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(ℓ·N log2(N)) G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(ℓ·N·log(ℓ·N)·log(N)) G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(ℓ·N log2(N))</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VC.Open</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m·ℓ·log(m) log(ℓN)) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·m log2m) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m·ℓ·log(m) log(ℓN)) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m·ℓ·log2(m)) G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Aggregation</td>

            <td class="px-3 py-2 border-b border-gray-700">Incremental</td>

            <td class="px-3 py-2 border-b border-gray-700">Incremental</td>

            <td class="px-3 py-2 border-b border-gray-700">One-hop</td>

            <td class="px-3 py-2 border-b border-gray-700">Incremental</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Disaggregation</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 1. Comparison between the SVC's of [BBF19], [LM19] and this work; our contributions are highlighted in gray. We consider committing to a vector  <span class="math">\\vec{v} \\in (\\{0,1\\}^{\\ell})^{N}</span>  of length  <span class="math">N</span> , and opening and verifying for a set  <span class="math">I</span>  of  <span class="math">m</span>  positions. By '  <span class="math">O(x)</span> <span class="math">\\mathbb{G}</span>  ' we mean  <span class="math">O(x)</span>  group operations in  <span class="math">\\mathbb{G}</span> ;  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  denotes the bit length of an element of  </span>\\mathbb{G}<span class="math"> . An alternative algorithm for VC.Open in [LM19] costs  </span>O(\\ell \\cdot (N - m) \\cdot \\log (N - m))<span class="math"> . Our precomputation is for  </span>B = 1$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 4. PoProd* protocol</p>

    <p class="text-gray-300">We propose three Arguments of Knowledge (AoK) related to our vector commitment scheme presented in section 5.1. More specifically, the first AoK allows one to prove knowledge of an opening of a subvector. The second AoK, is a direct outcome of the first and allows one to prove that two given commitments share a common subvector. Finally, the third protocol allows one to commit to a prefix-subvector of a vector and prove the knowledge of it succinctly.</p>

    <p class="text-gray-300">Similarly to section 5.1, our protocols build on the techniques for succinct proofs in groups of unknown order from [BBF19]. Furthermore, these arguments of knowledge are not zero knowledge and they serve efficiency purposes. Interestingly, one can prove knowledge of a portion of a vector committed without having to send the actual vector values. The proofs are constant-size which leads to an improvement of communication complexity linear in the size of the opening.</p>

    <p class="text-gray-300">Before proceeding to describing the main protocols, we introduce another one that is used as building block. This is an argument of knowledge, called  <span class="math">\\mathsf{PoProd}^<em></span> , for the relation  <span class="math">R_{\\mathsf{PoProd}^</em>}</span>  described below, which uses a common reference string consisting of a hidden order group  <span class="math">\\mathbb{G} \\gets \\mathsf{Ggen}(1^\\lambda)</span>  and a random generator  <span class="math">g \\in \\mathbb{G}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">R _ {\\mathsf {P o P r o d} ^ {*}} = \\left\\{\\left(\\left(A, B, C, \\Gamma , \\varDelta\\right), (a, b)\\right) \\in \\mathbb {G} ^ {5} \\times \\mathbb {Z} ^ {2}: A = \\Gamma^ {a} \\wedge B = \\varDelta^ {b} \\wedge C = g ^ {a \\cdot b} \\right\\}</span></div>

    <p class="text-gray-300">The relation  <span class="math">R_{\\mathsf{PoProd}^<em>}</span>  is similar to  <span class="math">R_{\\mathsf{PoProd}}</span>  defined in Section 5.1 with the difference that now the first two bases  <span class="math">\\Gamma</span>  and  <span class="math">\\varDelta</span>  are not part of the common reference string, but part of the statement instead. As argued in [BBF19] the PoKE</em> protocol is not secure anymore for adversarially chosen bases, therefore we cannot use PoProd protocol which assumes knowledge extractability of PoKE<em>. To deal with this problem, we thus modify the protocol by using the protocol PoKE2, which is secure for arbitrary bases. This comes with some cost: in our PoProd</em> a proof consists of 5 group elements and 2 field elements, that is 2 group elements more comparing to proofs of PoProd. The protocol is in Fig. 6.1.</p>

    <p class="text-gray-300">Theorem 6.1. The PoProd<em> protocol in Fig. 6.1 is an argument of knowledge for  <span class="math">R_{\\mathsf{PoProd}^</em>}</span>  in the generic group model.</p>

    <p class="text-gray-300">The proof of the theorem above is similar to the proof of Theorem 5.1, except that we use the extractor <span class="math">\\mathcal{E}_{\\mathsf{PoKE2}}</span> of the protocol <span class="math">\\mathsf{PoKE2}</span> from <em>[x1]</em> in order to extract integers <span class="math">a</span> and <span class="math">b</span> and <span class="math">\\mathcal{E}_{\\mathsf{PoKE^{*}}}</span> in order to extract the exponent of <span class="math">C</span>.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">6.2 A Succinct AoK of Opening for our VC Construction</h3>

    <p class="text-gray-300">We show an argument of knowledge of an <span class="math">I</span>-opening with respect to a commitment <span class="math">C</span> to a vector, where <span class="math">I</span> is a set of positions. We emphasize that the goal of this protocol is not to keep the opening secret (i.e., the protocol is not zero knowledge, also our vector commitment scheme is not hiding). The goal is to reduce the communication complexity of an opening by proving knowledge of the subvector at positions <span class="math">I</span> without having to actually send the values <span class="math">\\vec{v}_{I}</span>. Even though the argument of knowledge itself adds an overhead it is independent of the number of the positions. Hence, the protocol makes more sense for large sets of positions <span class="math">I</span> as for a small number of positions the overhead of the AoK would exceed the size of the opening values.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{VC}=(\\mathsf{VC.Setup},\\mathsf{VC.Specialize},\\mathsf{VC.Com},\\mathsf{VC.Open},\\mathsf{VC.Ver})</span> be our SVC scheme from Section 5.1, and let us define the following relation</p>

    <p class="text-gray-300"><span class="math">R_{\\mathsf{PoKOpen}}=\\{(\\,(C,I),(\\vec{y},\\pi_{I})\\,):\\mathsf{VC.Ver(crs},C,I,\\vec{y},\\pi_{I})=1\\}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">that is parametrized by a CRS <span class="math">\\mathsf{crs}\\leftarrow\\mathsf{VC.Setup}(1^{\\lambda},\\mathcal{M})</span>, and where the statement consists of a commitment <span class="math">C</span> and a set of indices <span class="math">I\\subseteq[n]</span>, and the witness consists of a vector $\\vec{y}\\in\\mathcal{M}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and an opening </span>\\pi_{I}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For simplicity we present a protocol <span class="math">\\mathsf{PoKOpen}</span> for the case when <span class="math">k=1</span> in our <span class="math">\\mathsf{VC}</span> (see section 5.1); extension to larger <span class="math">k</span> is immediate. The idea of our protocol is that, given a commitment <span class="math">C:=((A,B),\\pi_{\\mathsf{prod}})</span> and a set of indices <span class="math">I</span>, the prover, holding <span class="math">\\pi_{I}:=(\\Gamma_{I},\\Delta_{I})</span>, first sends <span class="math">\\pi_{I}</span> to the verifier and then provides an AoK of <span class="math">(a_{I},b_{I})</span> such that <span class="math">\\Gamma_{I}^{a_{I}}=A\\wedge\\Delta_{I}^{b_{I}}=B\\wedge g^{a_{I}\\cdot b_{I}}=U_{I}</span>, where <span class="math">U_{I}\\leftarrow g^{u_{I}}</span> with <span class="math">u_{I}\\leftarrow\\mathsf{PrimeProd}(I)</span>. This can be proven by using the <span class="math">\\mathsf{PoProd^{*}}</span> protocol presented above. Finally the verifier should also verify the <span class="math">\\pi_{\\mathsf{prod}}</span> proof as in the normal verification of an opening algorithm.</p>

    <p class="text-gray-300">We state the following theorem.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Theorem 6.2.</h6>

    <p class="text-gray-300">If <span class="math">\\mathsf{PoProd^{<em>}}</span> is a succinct argument of knowledge for <span class="math">R_{\\mathsf{PoProd^{</em>}}}</span>, then protocol <span class="math">\\mathsf{PoKOpen}</span> is a succinct argument of knowledge for relation <span class="math">R_{\\mathsf{PoKOpen}}</span> with respect to algorithm <span class="math">\\mathsf{VC.Ver}</span> of our construction of Section 5.1.</p>

    <p class="text-gray-300">Proof Let <span class="math">\\mathcal{A}</span> be an adversary of the Knowledge Extractability of <span class="math">\\mathsf{PoKOpen}</span> such that: <span class="math">((C,I),\\mathsf{state})\\leftarrow\\mathcal{A}_{0}(\\mathsf{pp}),</span> <span class="math">\\mathcal{A}_{1}(\\mathsf{pp},(C,I),\\mathsf{state})</span> executes with <span class="math">\\mathsf{V}(\\mathsf{pp},(C,I))</span> the protocol <span class="math">\\mathsf{PoKOpen}</span> and the verifier accepts with a non-negligible probability <span class="math">\\epsilon</span>. We will construct an extractor <span class="math">\\mathcal{E}</span> that having access to the internal state of <span class="math">\\mathcal{A}_{1}</span> and on input <span class="math">(\\mathsf{pp},(C,I),\\mathsf{state})</span>, outputs a witness <span class="math">(\\vec{y},\\pi_{I})</span> of <span class="math">R_{\\mathsf{PoKOpen}}</span> with overwhelming probability and runs in (expected) polynomial time.</p>

    <p class="text-gray-300">To prove knowledge extractability of <span class="math">\\mathsf{PoKOpen}</span> we rely on the knowledge extractability of <span class="math">\\mathsf{PoProd^{<em>}}</span>. More precisely, given a <span class="math">\\mathsf{PoKOpen}</span> execution between <span class="math">\\mathcal{A}</span> and <span class="math">\\mathsf{V}</span>, <span class="math">(\\Gamma_{I},\\Delta_{I},\\pi_{\\mathsf{PoProd^{\\prime}}})</span>, <span class="math">\\mathcal{E}</span> constructs an adversary <span class="math">\\mathcal{A^{\\prime}}=(\\mathcal{A}^{\\prime}_{0},\\mathcal{A}^{\\prime}_{1})</span> of <span class="math">\\mathsf{PoProd^{</em>}}</span> Knowledge Extractability and, by using the input and internal state of <span class="math">\\mathcal{A}_{1}</span>, simulates an execution between <span class="math">\\mathcal{A^{\\prime}}</span> and <span class="math">\\mathsf{V}</span>: <span class="math">\\mathcal{A}^{\\prime}_{0}</span> outputs <span class="math">(((\\mathbb{G},g),(A,B,U_{I},</span> <span class="math">\\Gamma_{I},\\Delta_{I})),\\mathsf{state})</span>, <span class="math">\\mathcal{A}^{\\prime}_{1}</span> outputs tuple <span class="math">(z_{a},z_{b},(Q_{A},Q_{B},Q_{C}),r_{a},r_{b})</span>. It is obvious that if the initial execution is accepted by <span class="math">\\mathsf{V}</span> so is the <span class="math">\\mathsf{PoProd^{*}}</span> execution. From Knowledge Extractability of <span class="math">\\mathsf{PoProd}</span> we know that there exists an extractor <span class="math">\\mathcal{E^{\\prime}}</span> corresponding to <span class="math">\\mathcal{A}^{\\prime}_{1}</span> that outputs <span class="math">(a_{I},b_{I})</span> such that <span class="math">A=\\Gamma_{I}^{a_{I}}\\wedge B=\\Delta_{I}^{b_{I}}\\wedge U_{I}=g^{a_{I}\\cdot b_{I}}</span>. Since</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 5. PoKOpen protocol</p>

    <p class="text-gray-300"><span class="math">U_{I}</span>  is also computed from  <span class="math">\\mathsf{V}</span>  it holds that  <span class="math">U_{I} = g^{u_{I}}</span> , unless with a negligible probability that  <span class="math">\\mathcal{A}&#x27;</span>  can find an  <span class="math">x \\neq u_{I}</span>  such that  <span class="math">g^{x} = U_{I} = g^{u_{I}}</span>  (which implies finding a multiple of the order of  <span class="math">\\mathbb{G}</span> ). Therefore  <span class="math">g^{u_{I}} = U_{I} = g^{a_{I} \\cdot b_{I}}</span>  and using the same argument we know that  <span class="math">u_{I} = a_{I} \\cdot b_{I}</span>  (unless with negligible probability).</p>

    <p class="text-gray-300">So,  <span class="math">\\mathcal{E}</span>  uses  <span class="math">\\mathcal{E}&#x27;</span>  and gets a  <span class="math">(a_I, b_I)</span>  such that  <span class="math">A = \\Gamma_I^{a_I} \\wedge B = \\Delta_I^{b_I} \\wedge U_I = g^{a_I \\cdot b_I}</span> . Then computes  <span class="math">u_I \\gets \\text{PrimeProd}(I)</span>  and works as follows: for each  <span class="math">i \\in I</span>  computes  <span class="math">p_i \\gets \\text{PrimeGen}(i)</span>  and if  <span class="math">p_i \\mid a_I</span>  then sets  <span class="math">y_i = 0</span> , otherwise if  <span class="math">p_i \\mid a_I</span>  then sets  <span class="math">y_i = 1</span> . It is clear that  <span class="math">p_i</span>  divides exactly one of  <span class="math">a_I, b_I</span>  since  <span class="math">a_I \\cdot b_I = u_I = \\prod_{i \\in I} p_i := \\prod_{i \\in I} \\text{PrimeGen}(i)</span>  (unless with a negligible probability that a collision happened in  <span class="math">\\text{PrimeGen}</span> ). Finally sets the subvector  <span class="math">\\vec{y} = (y_i)_{i \\in I}</span>  and  <span class="math">\\pi_I = (\\Gamma_I, \\Delta_I)</span> . As stated above  <span class="math">\\Gamma_I^{a_I} = A \\wedge \\Delta_I^{b_I} = B</span>  and also since  <span class="math">\\mathsf{V}</span>  verifies the PoKOpen protocol it holds that  <span class="math">\\text{PoProd}_2 \\cdot \\mathsf{V}(\\mathsf{pp}, (A \\cdot B, U_n), \\pi_{\\mathsf{prod}})</span>  which means that VC.Ver(pp, C, I,  <span class="math">\\vec{y}, \\pi_I) = 1</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As one can see, the expected running time of  <span class="math">\\mathcal{E}</span>  is the (expected) time to obtain a successful execution of the protocol plus the running time to obtain  <span class="math">\\vec{y}</span>  plus the running time of  <span class="math">\\mathcal{E}&#x27;</span> . To obtain  <span class="math">\\vec{y}</span>  it will need to make  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  divisibility checks which takes time  </span>\\tilde{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  plus  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  calls of PrimeGen, which takes  </span>\\mathrm{poly}(\\lambda)<span class="math">  time. So overall the expected time is  </span>\\frac{1}{\\epsilon} + t_{\\mathcal{E}'} + \\tilde{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + \\mathrm{poly}(\\lambda) = \\mathrm{poly}(\\lambda)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Non-interactive PoKOpen. A non-interactive version of the protocol PoKOpen after applying the generalized Fiat-Shamir transform [BCS16] is shortly presented below:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{PoKOpen.P}(\\mathsf{crs},(C,I),(\\vec{y},\\pi_I))\\to \\pi</span>  : Parse  <span class="math">\\mathsf{crs}\\coloneqq (\\mathbb{G},g,g_0,g_1,\\mathsf{PrimeGen},U_n)</span> <span class="math">C\\coloneqq (\\{A,B\\} ,\\pi_{\\mathsf{prod}})</span> <span class="math">\\pi_I\\coloneqq (\\Gamma_I,\\Delta_I)</span>  . Compute  <span class="math">(a_{I},b_{I})\\gets \\mathsf{PartndPrimeProd}(I,\\vec{y})</span>  and then  <span class="math">u_{I}\\gets \\mathsf{PrimeProd}(I)</span>  and  <span class="math">U_{I}\\gets g^{u_{I}}</span>  . Finally compute a proof  <span class="math">\\pi_{\\mathsf{PoProd}^<em>}\\gets \\mathsf{PoProd}^</em>.\\mathsf{P}((\\mathbb{G},g),(A,B,U_I,\\Gamma_I,\\Delta_I),(a_I,b_I))</span></p>

    <p class="text-gray-300">Return <span class="math">\\pi \\gets (\\Gamma_I, \\Delta_I, \\pi_{\\mathsf{PoProd}^*})</span></p>

    <p class="text-gray-300">PoKOpen.V(crs, <span class="math">(C, I), \\pi_{\\mathsf{PoProd}^<em>}) \\to b</span> : Parse crs := <span class="math">(\\mathbb{G}, g, g_0, g_1, \\mathsf{PrimeGen}, U_n)</span>, <span class="math">C := (\\{A, B\\}, \\pi_{\\mathsf{prod}})</span> and <span class="math">\\pi := (\\Gamma_I, \\Delta_I, \\pi_{\\mathsf{PoProd}^</em>})</span>. Compute <span class="math">u_I \\gets \\mathsf{PrimeProd}(I)</span> and then <span class="math">U_I \\gets g^{u_I}</span>.</p>

    <p class="text-gray-300">Return 1 if both <span class="math">\\mathsf{PoProd}_2.\\mathsf{V}(\\mathsf{crs},(A\\cdot B,U_n),\\pi_{\\mathsf{prod}})</span> and</p>

    <p class="text-gray-300"><span class="math">\\mathsf{PoProd}^<em>.\\mathsf{V}((\\mathbb{G},g),(A,B,\\Gamma_I,\\Delta_I,U_I),\\pi_{\\mathsf{PoProd}^</em>})</span> output 1, and 0 otherwise.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Remark 6.1 (Achieving sub-linear verification time).</strong> For ease of exposition we presented the case of <span class="math">k = 1</span> in the above. For the case of arbitrary <span class="math">k</span> one should prove knowledge of <span class="math">(a_{Ij}, b_{Ij})</span> such that <span class="math">\\bigwedge_{j=1}^{k} \\Gamma_{Ij}^{a_{Ij}} = A_j \\bigwedge_{j=1}^{k} \\Delta_{Ij}^{b_{Ij}} = B \\wedge g^{a_{Ij} \\cdot b_{Ij}} = U_I</span>, where <span class="math">U_I \\gets g^{u_I}</span> and <span class="math">u_I \\gets \\mathsf{PrimeProd}(I)</span>. Using the same technique as above the size of the AoK is <span class="math">O(k)</span> (as is the commitment and the opening proof). However, since the <span class="math">U_I</span> is the same for each <span class="math">j</span>, the verification is done in $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ k + \\lambda \\cdot k)<span class="math"> time. Interestingly, if </span>k = \\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> the verification time gets </span>O(\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">, which is sublinear in the size of the opening. Essentially, in cases where the opening queries are (approximately) fixed, one can trade a larger commitment size </span>O(\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> in order to achieve an argument of knowledge of subvectors that has sublinear size and sublinear verification time </span>O(\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Applications to Compact Proofs of Storage.</strong> We observe that the protocol PoKOpen for our VC immediately implies a keyless proof of storage, or more precisely a proof of retrievable commitment (PoRC) [Fis18] with non-black-box extraction. In a nutshell, a PoRC is a proof of retrievability [JK07] of a committed file. In [Fis18] Fisch defines PoRC and proposes a construction based on vector commitments – called VC-PoRC – which abstracts away a classical proof of retrievability based on Merkle trees. A bit more in detail, in the VC-PoRC scheme the prover uses a VC to commit to a file (seen as a vector of blocks); then at every audit the verifier chooses a challenge by picking a set of <span class="math">\\lambda_{\\mathsf{pos}}</span> randomly chosen positions <span class="math">I = \\{i \\leftarrow \\mathbb{S}[n]\\}</span>, and the prover responds by sending the subvector <span class="math">\\vec{v}_I</span> and an opening <span class="math">\\pi_I</span>. Here <span class="math">\\lambda_{\\mathsf{pos}}</span> is a statistical parameter that governs the probability of catching an adversary that deletes (or corrupts) a fraction of the file. For example, if the file is first encoded using an erasure code with constant rate <span class="math">\\mu</span> (i.e., one where a <span class="math">\\mu</span>-fraction of blocks suffices to decode and such that the encoded file has size roughly $\\mu^{-1} \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">), then an erasing adversary has probability at most </span>\\mu^{\\lambda_{\\mathsf{pos}}}$ of passing an audit.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our PoRC scheme is obtained by modifying the VC-PoRC of [Fis18] in such a way that the VC opening is replaced by a PoKOpen AoK. This change saves the cost of sending the <span class="math">\\lambda_{\\mathsf{pos}}</span> vector values, which gives us proofs of fixed size, 7 elements of <span class="math">\\mathbb{G}</span> and 2 values of <span class="math">\\mathbb{Z}_{2^{2\\lambda}}</span>. As drawback, our scheme is not black-box extractable; strictly speaking, this means it is not a PoR in the sense of [JK07] since the extractor does not exist in the real world.¹⁹</p>

    <p class="text-gray-300">We note that another solution with fixed-size proofs can be achieved by using a SNARK to prove knowledge of the VC openings so that the VC-PoRC verifier would accept. For the Merkle tree VC, this means proving knowledge of <span class="math">\\lambda_{\\mathsf{pos}}</span> Merkle tree openings, which amounts to proving correctness of about <span class="math">\\lambda_{\\mathsf{pos}}\\log n</span> hash computations. On a file of <span class="math">2^{20}</span> bits with 128 spot-checks, this solution would reduce proof size from 80KB to less than 1KB. But its concrete proving costs are high (more than 20 minutes and hundreds of GB of RAM).</p>

    <p class="text-gray-300">In contrast we can estimate our AoK to be generated in less than 20 seconds and of size roughly 2KB.</p>

    <p class="text-gray-300">¹⁹ The notion of PoR with non-black-box extractability is close to that of robust proof of data possession [ABC⁺⁰⁷, ABC⁺¹¹].</p>

    <p class="text-gray-300">41</p>

    <p class="text-gray-300">Since our PoRC scheme is a straightforward modification of Fisch’s VC-PoRC construction, a complete description is omitted. We stress that our technical contribution here is the design of the AoK.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, we note that we can apply the observation of the previous remark in order to also achieve verification time sub-linear in the size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> of the challenged subvector at the expense of slightly larger commitments (of size </span>\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">6.3 An AoK for commitments with common subvector</h3>

    <p class="text-gray-300">We note that a simple AND composition of two PoKOpen arguments of knowledge on two different vector commitments can serve as a protocol proving knowledge of a common subvector of the two vectors committed. More specifically given two vector commitments, <span class="math">C_{1},C_{2}</span> on two different vector <span class="math">\\vec{v}_{1},\\vec{v}_{2}</span> respectively, one can prove knowledge of a common subvector <span class="math">\\vec{v}_{I}</span> with a succinct (constant sized) argument without having to send the actual subvector. The two commitments should share the same CRS <span class="math">\\mathsf{crs}\\leftarrow\\mathsf{VC.Setup}(1^{\\lambda},\\mathcal{M})</span> though they can have distinct specialized CRSs <span class="math">\\mathsf{crs}_{n_{1}}</span> and <span class="math">\\mathsf{crs}_{n_{2}}</span> respectively (i.e., <span class="math">\\vec{v}_{1}</span> and <span class="math">\\vec{v}_{2}</span> may have different length). The underlying relation is:</p>

    <p class="text-gray-300"><span class="math">R_{\\mathsf{PoKComSub}}=\\left\\{(\\left(C_{1},C_{2},I\\right),\\left(\\vec{v}_{I},\\pi_{I,1},\\pi_{I,2}\\right)\\right):\\mathsf{VC.Ver}^{\\star}(\\mathsf{crs}_{n_{1}},C_{1},I,\\vec{v}_{I},\\pi_{I,1})=1</span> <span class="math">\\quad\\wedge\\mathsf{VC.Ver}^{\\star}(\\mathsf{crs}_{n_{2}},C_{2},I,\\vec{v}_{I},\\pi_{I,2})=1\\right\\}</span></p>

    <p class="text-gray-300">As mentioned above, it is straightforward to show that an AND composition of PoKOpen on different vector commitments <span class="math">C_{1}</span> and <span class="math">C_{2}</span> is a protocol for the above relation. That is the prover, holding <span class="math">\\pi_{I,1}:=(\\Gamma_{I,1},\\Delta_{I,1})</span> and <span class="math">\\pi_{I,2}:=(\\Gamma_{I,2},\\Delta_{I,2})</span>, first sends <span class="math">\\pi_{I,1},\\pi_{I,2}</span> to the verifier and then provides an argument of knowledge of <span class="math">(a_{I},b_{I})</span> such that <span class="math">\\Gamma_{I,1}^{a_{I}}=A_{1}\\wedge\\Delta_{I,1}^{b_{I}}=B_{1}\\wedge g^{a_{I}\\cdot b_{I}}=U_{I}\\wedge\\Gamma_{I,2}^{a_{I}}=A_{2}\\wedge\\Delta_{I,2}^{b_{I}}=B_{2}</span>, where <span class="math">U_{I}\\leftarrow g^{u_{I}}</span> and <span class="math">u_{I}\\leftarrow\\mathsf{PrimeProd}(I)</span>.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">6.4 A Succinct AoK for Commitment on Subvector</h3>

    <p class="text-gray-300">Here we present a protocol which succinctly proves that a commitment <span class="math">C^{\\prime}</span> opens to an <span class="math">I</span>-subvector <span class="math">\\vec{v}_{I}</span> of the opening <span class="math">\\vec{v}</span> of another commitment <span class="math">C</span>. Since <span class="math">C^{\\prime}</span> is a vector commitment <span class="math">\\vec{v}_{I}</span> should be a normal vector instead of a general subvector, i.e. <span class="math">I</span> should be a set of consecutive positions starting from <span class="math">1</span>, <span class="math">I=\\{1,\\ldots,n^{\\prime}\\}</span> for some <span class="math">n^{\\prime}\\in\\mathbb{N}</span>. We note though that both commitments should share the same <span class="math">\\mathsf{crs}</span> (but not the same specialized CRS). Below is the relation of the AoK that is parametrized by the two specialized CRSs <span class="math">\\mathsf{crs}_{n}\\leftarrow\\mathsf{VC.Specialize}(\\mathsf{crs},n)</span> and <span class="math">\\mathsf{crs}_{n^{\\prime}}\\leftarrow\\mathsf{VC.Specialize}(\\mathsf{crs},n^{\\prime})</span> where <span class="math">\\mathsf{crs}\\leftarrow\\mathsf{VC.Setup}(1^{\\lambda},\\mathcal{M})</span> is common.</p>

    <p class="text-gray-300"><span class="math">R_{\\mathsf{PoKSubV}}=\\left\\{(\\left(C,C^{\\prime},I\\right),\\left(\\vec{v}_{I},\\pi_{I},\\pi_{I}^{\\prime}\\right)\\right):\\mathsf{VC.Ver}^{\\star}(\\mathsf{crs}_{n},C,I,\\vec{v}_{I},\\pi_{I})=1</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\quad\\wedge\\mathsf{VC.Ver}^{\\star}(\\mathsf{crs}_{n^{\\prime}},C^{\\prime},I,\\vec{v}_{I},\\pi_{I}^{\\prime})=1\\wedge</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{v}_{I}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n^{\\prime}\\right\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The idea of our protocol is that since the opening <span class="math">\\vec{v}_{I}</span> is the <span class="math">I</span>-subvector of <span class="math">\\vec{v}</span> one can provide a succinct proof of knowledge of the opening at these positions using the PoKOpen protocol presented above. However this is not enough as one should bind the opening proof with <span class="math">C^{\\prime}</span>. This concretely can happen if one embeds a proof of product for the two components, <span class="math">A^{\\prime}</span> and <span class="math">B^{\\prime}</span>, of <span class="math">C^{\\prime}</span> inside the proof of opening. More specifically the prover provides an opening proof <span class="math">\\pi_{I}:=(\\Gamma_{I},\\Delta_{I})</span> then computes <span class="math">(a_{I},b_{I})\\leftarrow\\mathsf{PartndPrimeProd}(I,\\vec{v}_{I})</span> and proves that <span class="math">g_{0}^{a_{I}}=A^{\\prime}\\wedge g_{1}^{b_{I}}=B^{\\prime}\\wedge U_{n^{\\prime}}=g^{a_{I}\\cdot b_{I}}\\wedge\\Gamma_{I}^{a_{I}}=A\\wedge\\Delta_{I}^{b_{I}}=B</span>. Notice that the last three equalities correspond to the proof of opening protocol</p>

    <p class="text-gray-300">and the first three to the proof of product. So a conjunction of PoKOpen and PoProd protocol is sufficient. Lastly  <span class="math">g, g_0, g_1</span>  and  <span class="math">U_{n&#x27;}</span>  are part of  <span class="math">\\mathsf{crs}_{n&#x27;}</span>  and  <span class="math">(A, B)</span> ,  <span class="math">(A&#x27;, B&#x27;)</span>  part of the  <span class="math">C</span>  and  <span class="math">C&#x27;</span>  commitments respectively.</p>

    <p class="text-gray-300">Fig. 6. PoKSubV protocol</p>

    <p class="text-gray-300">|  Prover input: ((crsn, crsn'), (C, C', I), (vI, πI). Verifier input: ((crsn, crsn'), (C, C', I)).  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  P → V: πI := (ΓI, ΔI)  |</p>

    <p class="text-gray-300">|  A conjunction of PoProd* and PoKOpen protocols between P(crsn, crsn', (C, C', I), (vI, πI)) and V(crsn, crsn', (C, C', I)) is executed:  |</p>

    <p class="text-gray-300">|  V → P: h ←$ G  |</p>

    <p class="text-gray-300">|  P → V: z := (za, zb) computed as za ← hαI, zb ← hbI  |</p>

    <p class="text-gray-300">|  V → P: ℓ ←<span class="math"> Primes(λ) and α ←</span> [0, 2λ)  |</p>

    <p class="text-gray-300">|  P → V: π := ((QA, QB, Q'A', Q'B', QC), ra, rb) computed as follows  |</p>

    <p class="text-gray-300">|  -(qa, qb, qab) ← ([aI/ℓ], [bI/ℓ], [aIbI/ℓ])  |</p>

    <p class="text-gray-300">|  -(ra, rb) ← (aI mod ℓ, bI mod ℓ)  |</p>

    <p class="text-gray-300">|  -(QA', QB', QA, QB, QC) := (g0qa, g1qb, Γ1qa hαqa, Δ1qb hαqb, gqab)  |</p>

    <p class="text-gray-300">|  V: Parse crsn := (G, g, g0, g1, PrimeGen, Un), crsn' := (G, g, g0, g1, PrimeGen, Un') and C := {A, B}, πprod).  |</p>

    <p class="text-gray-300">|  Compute rc ← ra · rb mod ℓ  |</p>

    <p class="text-gray-300">|  Output 1 iff ra, rb ∈ [ℓ] ∧ Q'A', g0ra = A' ∧ Q'B', g1rb = B' ∧ Q'A', Γ1ra hαra = Azαa ∧ Q'B', Δ1rb hαrb = Bzbα ∧ Q'Cgrc = Un' ∧ PoProd2. V(pp, (A · B, Un), πprod)  |</p>

    <p class="text-gray-300">We state the following theorem for the security of the protocol above.</p>

    <p class="text-gray-300">Theorem 6.3. If  <span class="math">\\mathsf{PoProd}^<em></span>  and  <span class="math">\\mathsf{PoKOpen}</span>  are succinct arguments of knowledge for  <span class="math">R_{\\mathsf{PoProd}^</em>}</span>  and  <span class="math">R_{\\mathsf{PoKOpen}}</span> , then protocol  <span class="math">\\mathsf{PoKSubV}</span>  in Fig. 6 is a succinct argument of knowledge for relation  <span class="math">R_{\\mathsf{PoKSubV}}</span>  with respect to algorithm VC.Ver of our construction of Section 5.1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The intuition of the proof is that one proves knowledge of an opening  <span class="math">I</span>  for  <span class="math">C</span> , namely that  <span class="math">\\vec{v}_I</span>  is an  <span class="math">I</span> -subvector of  <span class="math">C</span> , where  <span class="math">(a_I, b_I) \\gets \\text{PartndPrimeProd}(I, \\vec{v}_I)</span> , with a normal proof of subvector opening. This is equivalent to VC.Ver\\<em>(crsn, C, I,  <span class="math">\\vec{v}_I, \\pi_I</span> ) = 1. Then in the same proof proves that the accumulators of  <span class="math">C&#x27;</span>  are composed by the same  <span class="math">(a_I, b_I)</span>  which results in proving that  <span class="math">C&#x27;</span>  commits to  <span class="math">\\vec{v}_I</span> . The last point is equivalent to VC.Ver\\</em>(crsn', C', I,  <span class="math">\\vec{v}_I, \\pi_I&#x27;</span> ) = 1 ∧  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{v}_I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n'$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this section we introduce verifiable decentralized storage (VDS). We recall that in VDS there are two types of parties (called nodes): the generic client nodes and the more specialized storage nodes (a storage node can also act as a client node). The main goal of client nodes is to retrieve some blocks (i.e., a portion) of a given file. The role of a storage node is instead to store a portion of a file (or more files) and to answer to the retrieval queries of clients that are relevant to the portion it stores. In terms of security, VDS guarantees that malicious storage nodes cannot send to the clients blocks of the file that have been tampered with.</p>

    <p class="text-gray-300">We refer the reader to Section 1.2 for a discussion on the motivation and requirements of VDS.</p>

    <p class="text-gray-300">In Table 2 we summarize the main roles/capabilities of VDS nodes.</p>

    <p class="text-gray-300">|  ALL PARTICIPATING NODES  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2. Roles in a decentralized verifiable database.</p>

    <p class="text-gray-300">Here we introduce the syntax of VDS. A VDS scheme is defined by a collection of algorithms that are to be executed by either storage nodes or client nodes. The only exception is the Bootstrap algorithm that is used to bootstrap the entire system and is assumed to be executed by a trusted party, or to be implemented in a distributed fashion (which is easy if it is public coin).</p>

    <p class="text-gray-300">The syntax of VDS reflects its goal: guaranteeing data integrity in a highly dynamic and decentralized setting (the file can change and expend/shrink often and no single node stores it all). In VDS we create both parameters and an initial commitment for an empty file at the beginning (through the probabilistic Bootstrap algorithm, which requires a trusted execution). From then on this commitment is changed through incremental updates (of arbitrary size). Updating is divided in two parts. A node can carry out an update it and "push" it to all the other nodes, i.e. providing auxiliary information (that we call "update hint") other nodes can use to update their local certificates (if affected by the change) and a new digest <span class="math">^{20}</span> . These operations are done respectively trough StrgNode.PushUpdate and StrgNode.ApplyUpdate. Opening and verifying are where VC (with incremental aggregation) and VDS share the same mechanism. To respond to a query, a storage node can produce (possibly partial) proofs of opening via the StrgNode.Retrieve algorithm.. If these proofs need to be aggregated, any node can use algorithm AggregateCertificates. Anyone can verify a proof through ClntNode.VerRetrieve.</p>

    <p class="text-gray-300">In VDS we model the files to be stored as vectors in some message space  <span class="math">\\mathcal{M}</span>  (e.g.,  <span class="math">\\mathcal{M} = \\{0,1\\}</span>  or  <span class="math">\\{0,1\\}^{\\ell}</span> ), i.e.,  <span class="math">\\mathsf{F} = (\\mathsf{F}_1,\\dots ,\\mathsf{F}_N)</span> . Given a file  <span class="math">\\mathsf{F}</span> , we define a portion of it as a pair  <span class="math">(I,\\mathsf{F}_I)</span>  where  <span class="math">\\mathsf{F}_I</span>  is essentially the  <span class="math">I</span> -subvector of  <span class="math">\\mathsf{F}</span> .</p>

    <p class="text-gray-300">Algorithm to bootstrap the system:</p>

    <p class="text-gray-300">Bootstrap  <span class="math">(1^{\\lambda})\\to (\\mathsf{pp},\\delta_{0},\\mathsf{st}_{0})</span>  Given the security parameter  <span class="math">\\lambda</span> , the probabilistic bootstrap algorithm outputs public parameters pp, initial digest  <span class="math">\\delta_0</span>  and state  <span class="math">\\mathsf{st}_0</span> .  <span class="math">\\delta_0</span>  and  <span class="math">\\mathsf{st}_0</span>  correspond to the digest and storage node's local state respectively for an empty file.</p>

    <p class="text-gray-300">All the algorithms below implicitly take as input the public parameters pp.</p>

    <p class="text-gray-300">The algorithms for storage nodes are:</p>

    <p class="text-gray-300">StrgNode.AddStorage  <span class="math">(\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, Q, \\mathsf{F}_Q, \\pi_Q) \\to (\\mathsf{st}&#x27;, J, \\mathsf{F}_J)</span>  This algorithm allows a storage node to add more blocks of a given file  <span class="math">\\mathsf{F}</span>  to its local storage. Its first inputs are the local view of the storage node that is defined by a digest  <span class="math">\\delta</span> , a length  <span class="math">n</span> , a state  <span class="math">\\mathsf{st}</span> , and a file portion  <span class="math">(I, \\mathsf{F}_I)</span> . Then it takes</p>

    <p class="text-gray-300">as input a file subportion <span class="math">(Q,\\mathsf{F}_{Q})</span> together with a valid retrieval certificate <span class="math">\\pi_{Q}</span>. The output is an updated view of the storage node, that is a new state <span class="math">\\mathsf{st}&#x27;</span> and file portion <span class="math">(J,\\mathsf{F}_{J}):=(I,\\mathsf{F}_{I})\\cup(Q,\\mathsf{F}_{Q})</span>. Note that this algorithm can be used to enable anyone who holds a valid retrieval certificate for a file portion <span class="math">\\mathsf{F}_{Q}</span> to become a storage node of such portion.</p>

    <p class="text-gray-300">StrgNode.RmvStorage<span class="math">(\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, K) \\to (\\mathsf{st}&#x27;, J, \\mathsf{F}_J)</span> This algorithm allows a storage node to remove blocks of a given file <span class="math">\\mathsf{F}</span> from its local storage. Its first inputs are the local view of the storage node that is defined by a digest <span class="math">\\delta</span>, a length <span class="math">n</span>, a state <span class="math">\\mathsf{st}</span>, and a file portion <span class="math">(I, \\mathsf{F}_I)</span>. Then it takes as input a set of positions <span class="math">K \\subseteq I</span>, and the output is an updated view of the storage node, that is a new state <span class="math">\\mathsf{st}&#x27;</span> and file portion <span class="math">(J, \\mathsf{F}_J) := (I, \\mathsf{F}_I) \\setminus (K, \\cdot)</span>.</p>

    <p class="text-gray-300">StrgNode.CreateFrom<span class="math">(\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, J) \\to (\\delta&#x27;, n&#x27;, \\mathsf{st}&#x27;, J, \\mathsf{F}_J, \\Upsilon_J)</span> This algorithm allows a storage node for a file subportion <span class="math">\\mathsf{F}_I</span> to create a new file containing only a subset <span class="math">\\mathsf{F}_J</span> of <span class="math">\\mathsf{F}_I</span> along with the corresponding digest <span class="math">\\delta&#x27;</span> and length <span class="math">n&#x27;</span> and a hint to help other nodes generate their own digest. The algorithm takes as input the local view of the storage node, i.e., digest <span class="math">\\delta</span>, length <span class="math">n</span>, local state <span class="math">\\mathsf{st}</span> and file portion <span class="math">(I, \\mathsf{F}_I)</span>, and a set of indices <span class="math">J \\subseteq I</span>. The algorithm returns a new digest <span class="math">\\delta&#x27;</span>, length <span class="math">n&#x27;</span>, a local state <span class="math">\\mathsf{st}&#x27;</span>, a file portion <span class="math">(J, \\mathsf{F}_J)</span> and an advice <span class="math">\\Upsilon</span>. This advice can be used by a client holding only the former digest <span class="math">\\delta</span> to obtain the new digest <span class="math">\\delta&#x27;</span>, by using the ClntNode.GetCreate algorithm described below.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">StrgNode.PushUpdate<span class="math">(\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, \\mathsf{op}, \\Delta) \\to (\\delta&#x27;, n&#x27;, \\mathsf{st}&#x27;, J, \\mathsf{F}_J&#x27;, \\Upsilon_{\\Delta})</span> This algorithm allows a storage node of a file subportion <span class="math">\\mathsf{F}_I</span> to perform an update on the file and to generate a corresponding digest, length and local view, along with a hint other nodes can use to accordingly update their digests and local views. The inputs include the local view of the storage node, i.e., digest <span class="math">\\delta</span>, length <span class="math">n</span>, local state <span class="math">\\mathsf{st}</span> and file portion <span class="math">(I, \\mathsf{F}_I)</span>, an update operation <span class="math">\\mathsf{op} \\in \\{\\mathsf{mod}, \\mathsf{add}, \\mathsf{del}\\}</span> and an update description <span class="math">\\Delta</span>. The outputs are a new digest <span class="math">\\delta&#x27;</span> and length <span class="math">n&#x27;</span>, a new local state <span class="math">\\mathsf{st}&#x27;</span>, an updated file portion <span class="math">(J, \\mathsf{F}_J&#x27;)</span> and an update hint <span class="math">\\Upsilon_{\\Delta}</span>. If <span class="math">\\mathsf{op} = \\mathsf{mod}</span>, then <span class="math">\\Delta</span> contains a file portion <span class="math">(K, \\mathsf{F}_K&#x27;)</span> such that <span class="math">K \\subseteq I</span> and <span class="math">\\mathsf{F}_K&#x27;</span> represents the new content to be written in positions <span class="math">K</span>. If <span class="math">\\mathsf{op} = \\mathsf{add}</span>, it is also <span class="math">\\Delta = (K, \\mathsf{F}_K&#x27;)</span> except that <span class="math">K</span> is a set of new (sequential) positions <span class="math">K \\cap I = \\emptyset</span> that start from <span class="math">n + 1</span> (and end to $n +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">). If </span>\\mathsf{op} = \\mathsf{del}<span class="math">, then </span>\\Delta<span class="math"> only contains a set of positions </span>K \\subseteq I<span class="math">, which are the ones to be deleted (and are ought to be the </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> last sequential positions). The proof </span>\\Upsilon_{\\Delta}<span class="math"> can be used by client nodes holding </span>\\delta<span class="math"> in order to check the validity of the new digest </span>\\delta'<span class="math">, and by other storage nodes, holding additionally the length </span>n$, in order to check the validity of the changes and to update their local views accordingly.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">StrgNode.ApplyUpdate<span class="math">(\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, \\mathsf{op}, \\Delta, \\Upsilon_{\\Delta}) \\to (b, \\delta&#x27;, n&#x27;, \\mathsf{st}&#x27;, J, \\mathsf{F}_J&#x27;)</span> This algorithm allows a storage node to incorporate changes in a file pushed by another node. The inputs include the local view of the storage node, i.e., digest <span class="math">\\delta</span>, length <span class="math">n</span>, local state <span class="math">\\mathsf{st}</span> and file portion <span class="math">(I, \\mathsf{F}_I)</span>, an update operation <span class="math">\\mathsf{op} \\in \\{\\mathsf{mod}, \\mathsf{add}, \\mathsf{del}\\}</span>, an update description <span class="math">\\Delta</span> and an update hint <span class="math">\\Upsilon_{\\Delta}</span>. The algorithm returns a bit <span class="math">b</span> (to accept/reject the update) and (if <span class="math">b = 1</span>) a new digest <span class="math">\\delta&#x27;</span>, a new length <span class="math">n&#x27;</span>, a new (local) state <span class="math">\\mathsf{st}&#x27;</span> and an updated file subportion <span class="math">(J, \\mathsf{F}_J&#x27;)</span>. If <span class="math">\\mathsf{op} \\in \\{\\mathsf{mod}, \\mathsf{add}\\}</span> we have that <span class="math">J = I</span>, i.e., the node keeps storing the same indices; if <span class="math">\\mathsf{op} = \\mathsf{del}</span> then <span class="math">J</span> is <span class="math">I</span> minus the deleted indices.</p>

    <p class="text-gray-300">StrgNode.Retrieve<span class="math">(\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, Q) \\to (\\mathsf{F}_Q, \\pi_Q)</span> This algorithm allows a storage node to answer a retrieval query for blocks with indices in <span class="math">Q</span> and to create a certificate vouching for the correctness of the returned blocks. The inputs include the local view of the storage node, i.e., digest <span class="math">\\delta</span>, length <span class="math">n</span> local state <span class="math">\\mathsf{st}</span> and file portion <span class="math">(I, \\mathsf{F}_I)</span>, and a set of indices <span class="math">Q</span>. The output is a file portion <span class="math">\\mathsf{F}_Q</span> and a retrieval certificate <span class="math">\\pi_Q</span>.</p>

    <p class="text-gray-300">The algorithms for clients nodes are:</p>

    <p class="text-gray-300">45</p>

    <p class="text-gray-300">On input a digest <span class="math">\\delta</span>, a set of indices <span class="math">J</span> and a creation advice <span class="math">\\Upsilon_{J}</span>, this algorithm returns a bit <span class="math">b</span> (to accept/reject) and (if <span class="math">b=1</span>) a new digest <span class="math">\\delta^{\\prime}</span> that corresponds to a file <span class="math">\\mathsf{F}^{\\prime}</span> that is the prefix with indices <span class="math">J</span> of the file represented by digest <span class="math">\\delta</span>. On input a digest <span class="math">\\delta</span>, an update operation <span class="math">\\mathsf{op}\\in\\{\\mathsf{mod},\\mathsf{add},\\mathsf{del}\\}</span>, an update description <span class="math">\\Delta</span> and an update hint <span class="math">\\Upsilon_{\\Delta}</span>, it returns a bit <span class="math">b</span> (to accept/reject update) and (if <span class="math">b=1</span>) a new digest <span class="math">\\delta^{\\prime}</span>. On input a digest <span class="math">\\delta</span>, a file portion <span class="math">(Q,\\mathsf{F}_{Q})</span> and a certificate <span class="math">\\pi_{Q}</span>, this algorithm accepts (i.e. it outputs 1) only if <span class="math">\\pi_{Q}</span> is a valid proof that <span class="math">\\delta</span> corresponds to a file <span class="math">\\mathsf{F}</span> with length <span class="math">n</span> of which <span class="math">\\mathsf{F}_{Q}</span> is the portion corresponding to indices <span class="math">Q</span>. On input a digest <span class="math">\\delta</span> and two certificated retrieval outputs <span class="math">(I,\\mathsf{F}_{I},\\pi_{I})</span> and <span class="math">(J,\\mathsf{F}_{J},\\pi_{J})</span>, this algorithm aggregates their certificates into a single certificate <span class="math">\\pi_{K}</span> (with <span class="math">K:=I\\cup J</span>). In a running VDS system, this algorithm can be used by any node to aggregate two (or more) incoming certified data blocks into a single certified data block.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Remark 7.1 (On CreateFrom)</h6>

    <p class="text-gray-300">For completeness, our VDS syntax also includes the functionalitis (StrgNode.CreateFrom, ClntNode.GetCreate) that allow a storage node to initialize storage (and corresponding digest) for a new file that is a subset of an existing one, and a client node to verify such resulting digest. Although this feature can be interesting in some application scenarios (see the Introduction), we still see it as an extra feature that may or may not be satisfied by a VDS construction.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">7.2 Correctness and Efficiency of VDS</h3>

    <p class="text-gray-300">Intuitively, we say that a VDS scheme is efficient if running VDS has a “small” overhead in terms of the storage required by all the nodes and the bandwidth to transmit certificates. More formally, a VDS scheme is said efficient if there is a fixed polynomial <span class="math">p(\\cdot)</span> such that <span class="math">p(\\lambda,\\log n)</span> (with <span class="math">\\lambda</span> the security parameter and <span class="math">n</span> the length of the file) is a bound for all certificates and advices generated by the VDS algorithms as well as for digests <span class="math">\\delta</span> and the local state <span class="math">\\mathsf{st}</span> of storage nodes. Note that combining this bound with the requirement that all algorithms are polynomial time in their input, we also get that no VDS algorithm can run linearly in the size of the file (except in the trivial case that the file is processed in one shot, e.g., in the first StrgNode.AddStorage).</p>

    <p class="text-gray-300">Efficiency essentially models that running VDS is cost-effective for all the nodes in the sense that it does not require them to store significantly more data then they would have to store without. Notice that by requiring certificates to have a fixed size implies that they do not grow with aggregation.</p>

    <p class="text-gray-300">For correctness, intuitively speaking, we want that for any (valid) evolution of the system in which the VDS algorithms are honestly executed we get that any storage node storing a portion of a file <span class="math">\\mathsf{F}</span> can successfully convince a client holding a digest of <span class="math">\\mathsf{F}</span> about retrieval of any portion of <span class="math">\\mathsf{F}</span>. And such (intuitive notion of) correctness is also preserved when updates, aggregations, or creations of new files are done.</p>

    <p class="text-gray-300">Turning this intuition into a formal correctness definition turned out to be nontrivial. This is due to the distributed nature of this primitive and the fact that there could be many possible ways in which, at the time of answering a retrieval query, a storage node may have reached its state starting from the empty node state. The basic idea of our definition is that an empty node is “valid”, and then any “valid” storage node that runs StrgNode.PushUpdate “transfers” such validity to both itself and to other nodes that apply such update. A bit more precisely, we model “validity”</p>

    <p class="text-gray-300">as the ability to correctly certify retrievals of any subsets of the stored portion. A formal definition correctness follows. To begin with, we define the notion of validity for the view of a storage node.</p>

    <p class="text-gray-300"><strong>Definition 7.2 (Validity of storage node's view).</strong> Let <span class="math">\\mathsf{pp}</span> be public parameters as generated by Bootstrap. We say that a local view <span class="math">(\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I)</span> of a storage node is valid if <span class="math">\\forall Q \\subseteq I</span>:</p>

    <div class="my-4 text-center"><span class="math-block">CIntNode.VerRetrieve(\\delta, Q, \\mathsf{F}_Q, \\pi_Q) = 1</span></div>

    <p class="text-gray-300">where <span class="math">(\\mathsf{F}_Q,\\pi_Q)\\gets \\mathsf{StrgNode.Retrieve}(\\delta ,n,\\mathsf{st},I,\\mathsf{F}_I,Q)</span></p>

    <p class="text-gray-300"><strong>Remark 7.2.</strong> By Definition 7.2 the output of a bootstrapping algorithm <span class="math">(\\mathsf{pp}, \\delta_0, \\mathsf{st}_0) \\gets \\mathsf{Bootstrap}(1^\\lambda)</span> is always such that <span class="math">(\\mathsf{pp}, \\delta_0, 0, \\mathsf{st}_0, \\emptyset, \\emptyset)</span> is valid. This provides a "base case" for Definition 7.4.</p>

    <p class="text-gray-300">Second, we define the notion of admissible update, which intuitively models when a given update can be meaningfully processed, locally, by a storage node.</p>

    <p class="text-gray-300"><strong>Definition 7.3 (Admissible Update).</strong> An update <span class="math">(\\mathsf{op},\\varDelta)</span> is admissible for <span class="math">(n,I,\\mathsf{F}_I)</span> if:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- for <span class="math">\\mathsf{op} = \\mathsf{mod}</span>, <span class="math">K \\subseteq I</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{F}_K'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span>\\varDelta := (K, \\mathsf{F}_K')$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- for <span class="math">\\mathsf{op} = \\mathsf{del}</span>, <span class="math">K \\subseteq I</span> and $K = \\{n -</td>

            <td class="px-3 py-2 border-b border-gray-700">K</td>

            <td class="px-3 py-2 border-b border-gray-700">+ 1, \\ldots, n\\}<span class="math">, where </span>\\varDelta := K$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In words, the above definition formalizes that: to push a modification at positions <span class="math">K</span>, the storage node must store those positions; to push an addition, the new positions <span class="math">K</span> must extend the currently stored length of the file; to push a deletion of position <span class="math">K</span>, the storage node must store data of the positions to be deleted and those positions must also be the last $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ positions of the currently stored file (i.e., the file length is reduced).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Definition 7.4 (Correctness of VDS).</strong> A VDS scheme VDS is correct if for all honestly generated parameters <span class="math">(\\mathsf{pp}, \\delta_0, \\mathsf{st}_0) \\gets \\mathsf{Bootstrap}(1^\\lambda)</span> and any storage node's local view <span class="math">(\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I)</span> that is valid, the following conditions hold.</p>

    <p class="text-gray-300"><strong>UPDATE CORRECTNESS.</strong> For any update <span class="math">(\\mathsf{op},\\varDelta)</span> that is admissible for <span class="math">(n,I,\\mathsf{F}_I)</span> and for any <span class="math">(\\delta&#x27;,n&#x27;,\\mathsf{st}&#x27;,J,\\mathsf{F}_J&#x27;,\\Upsilon_{\\varDelta})\\gets \\mathsf{StrgNode.PushUpdate}(\\delta ,n,\\mathsf{st},I,\\mathsf{F}_I,\\mathsf{op},\\varDelta)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{pp}, \\delta&#x27;, n&#x27;, \\mathsf{st}&#x27;, J, \\mathsf{F}_J&#x27;)</span> is valid;</li>

      <li>for any valid <span class="math">(\\delta, n, \\mathsf{st}_s, I_s, \\mathsf{F}_{I_s})</span>, if <span class="math">(b_s, \\delta_s&#x27;, n&#x27;, \\mathsf{st}_s&#x27;, I_s&#x27;, \\mathsf{F}_s&#x27;) \\gets \\mathsf{StrgNode.ApplyUpdate}(\\delta, n, \\mathsf{st}_s, I_s, \\mathsf{F}_{I_s}, \\mathsf{op}, \\varDelta, \\Upsilon_{\\varDelta})</span> then we have: <span class="math">b_s = 1</span>, <span class="math">\\delta_s&#x27; = \\delta&#x27;</span>, <span class="math">n_s&#x27; = n&#x27;</span>, and <span class="math">(\\delta_s&#x27;, n_s&#x27;, \\mathsf{st}_s&#x27;, I_s&#x27;, \\mathsf{F}_s&#x27;)</span> is valid;</li>

      <li>if <span class="math">(b_c, \\delta_c&#x27;) \\gets CIntNode.ApplyUpdate(\\delta, \\mathsf{op}, \\varDelta, \\Upsilon_{\\varDelta})</span>, then <span class="math">\\delta_c&#x27; = \\delta&#x27;</span> and <span class="math">b_c = 1</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>ADD-STORAGE CORRECTNESS.</strong> For any <span class="math">(Q, \\mathsf{F}_Q, \\pi_Q)</span> such that</p>

    <p class="text-gray-300">CIntNode.VerRetrieve<span class="math">(\\delta, Q, \\mathsf{F}_Q, \\pi_Q) = 1</span>, if <span class="math">(\\mathsf{st}&#x27;, J, \\mathsf{F}_J) \\gets \\mathsf{StrgNode.AddStorage}(\\delta, \\mathsf{st}, I, \\mathsf{F}, Q, \\mathsf{F}_Q, \\pi_Q)</span> then <span class="math">(\\delta, n, \\mathsf{st}&#x27;, J, \\mathsf{F}_J)</span> is valid.</p>

    <p class="text-gray-300"><strong>REMOVE-STORAGE CORRECTNESS.</strong> For any <span class="math">K \\subseteq I</span>,</p>

    <p class="text-gray-300">if <span class="math">(\\mathsf{st}&#x27;, J, \\mathsf{F}_J) \\gets \\mathsf{StrgNode.RmvStorage}(\\delta, \\mathsf{st}, I, \\mathsf{F}, K)</span> then <span class="math">(\\delta, n, \\mathsf{st}&#x27;, J, \\mathsf{F}_J)</span> is valid.</p>

    <p class="text-gray-300"><strong>CREATE CORRECTNESS.</strong> For any <span class="math">J \\subseteq I</span>, if <span class="math">(\\delta&#x27;, n&#x27;, \\mathsf{st}&#x27;, J, \\mathsf{F}_J, \\Upsilon_J)</span> is output of</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">StrgNode.CreateFrom<span class="math">(\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, J)</span> and <span class="math">(b, \\delta&#x27;&#x27;) \\gets CIntNode.GetCreate(\\delta, J, \\Upsilon_J)</span>, then <span class="math">b = 1</span>, $n' =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span>\\delta'' = \\delta'<span class="math"> and </span>(\\mathsf{pp}, \\delta', n', \\mathsf{st}', J, \\mathsf{F}_J)$ is valid.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>AGGREGATE CORRECTNESS.</strong> For any pair of triples <span class="math">(I, \\mathsf{F}_I, \\pi_I)</span> and <span class="math">(J, \\mathsf{F}_J, \\pi_J)</span> such that</p>

    <p class="text-gray-300">CIntNode.VerRetrieve<span class="math">(\\delta, I, \\mathsf{F}_I, \\pi_I) = 1</span> and CIntNode.VerRetrieve<span class="math">(\\delta, J, \\mathsf{F}_J, \\pi_J) = 1</span>,</p>

    <p class="text-gray-300">if <span class="math">\\pi_K \\gets \\text{AggregateCertificates}((I, \\mathsf{F}_I, \\pi_I), (J, \\mathsf{F}_J, \\pi_J))</span> and <span class="math">(K, \\mathsf{F}_K) := (I, \\mathsf{F}_I) \\cup (J, \\mathsf{F}_J)</span>, then</p>

    <p class="text-gray-300">CIntNode.VerRetrieve<span class="math">(\\delta, K, \\mathsf{F}_K, \\pi_K) = 1</span>.</p>

    <p class="text-gray-300">47</p>

    <p class="text-gray-300">Remark 7.3 (Relation with Updatable VCs). Our notion of VDS is very close to the notion of updatable VCs [CF13] extended to support subvector openings and incremental aggregation. On a syntactical level, in comparison to updatable VCs, our VDS notion makes more evident the decentralized nature of the primitive, which is reflected in the definition of our algorithms where for example it is clear that no one ever needs to store/know the entire file. One major difference is that in VDS the public parameters must necessarily be short since no node can run linearly in the size of the file (nor it can afford such storage), whereas in VCs this may not be necessarily the case. Another difference is that in updatable VCs [CF13] updates can be received without any hint, which is instead the case in VDS. Finally, it is interesting to note that, as of today, there exists no VC scheme that is updatable, incrementally aggregatable and with subvector openings, that enjoys short parameters and has the required short verification time. So, in a way, our two VDS realizations show how to bypass this barrier of updatable VC by moving to a slightly different (and practically motivated) model.</p>

    <h2 id="sec-35" class="text-2xl font-bold">7.3 Security of VDS</h2>

    <p class="text-gray-300">In this section we define the security of VDS schemes. Intuitively speaking, we require that a malicious storage node (or a coalition of them) cannot convince a client of a false data block in a retrieval query. To formalize this, we let the adversary fully choose a history of the VDS system that starts from the empty state and consists of a sequence of steps, where each step is either an update (addition, deletion, modification) or a creation (from an existing file) and is accompanied by an advice. A client's digest  <span class="math">\\delta</span>  is updated following such history and using the adversarial advices, and similarly one gets a file  <span class="math">\\mathsf{F}</span>  corresponding to such digest. At this point, the adversary's goal is to provide a tuple  <span class="math">(Q,\\pi_{Q},\\mathsf{F}_{Q}^{<em>})</span>  that is accepted by a client with digest  <span class="math">\\delta</span>  but where  <span class="math">\\mathsf{F}_Q^</em>\\neq \\mathsf{F}_Q</span> .</p>

    <p class="text-gray-300"><strong>Definition 7.5 (History for Decentralized Storage).</strong> Let VDS be a verifiable decentralized storage scheme. A history for VDS is a sequence  <span class="math">\\mathcal{H} = (\\mathrm{op}^i, \\Delta^i, \\Upsilon_{\\Delta}^i)_{i \\in [\\ell]}</span>  of tuples, where  <span class="math">\\mathrm{op}^i</span>  is either in  <span class="math">\\{\\mathrm{mod}, \\mathrm{add}, \\mathrm{del}\\}</span>  (i.e., it is an update of the file), or  <span class="math">\\mathrm{op}^i = \\mathrm{cfrom}</span>  (i.e., it is the creation of a new file related to the current one), in which case  <span class="math">\\Delta^i</span>  is a set of indices. In order to define valid histories we define the function  <span class="math">\\mathrm{EvalHistory}(\\mathrm{pp}, \\delta_0, \\mathrm{st}_0, \\mathcal{H})</span>  as follows</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">EvalHistory(pp, δ0, st0, H)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FileChange(F, op, Δ)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F0 ← ∅; b ← 1</td>

            <td class="px-3 py-2 border-b border-gray-700">if op ∈ {mod, add} parse Δ = (K, F′K)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">for i ∈ [ℓ]</td>

            <td class="px-3 py-2 border-b border-gray-700">∀i ∈ K : F′i ← F′i; ∀i ∈ [</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">] \\ K : F′i ← F_i,</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fi ← FileChange(Fi-1, op^i, Δ^i)</td>

            <td class="px-3 py-2 border-b border-gray-700">elseif op = del parse Δ = K</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">if op^i ∈ {mod, add, del} then</td>

            <td class="px-3 py-2 border-b border-gray-700">∀i ∈ [</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">] \\ K : F′i ← F_i,</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(bi, δi) ← ClntNode.ApplyUpdate(δi-1, op^i, Δ^i, T′Δ)</td>

            <td class="px-3 py-2 border-b border-gray-700">elseif op = cfrom parse Δ = K</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">elseif op^i = cfrom then</td>

            <td class="px-3 py-2 border-b border-gray-700">∀i ∈ K : F′i ← F_i,</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(bi, δi) ← ClntNode.GetCreate(δi-1, Δ^i, T′Δ)</td>

            <td class="px-3 py-2 border-b border-gray-700">endif return F*</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  endif |   |</p>

    <p class="text-gray-300">|  b ← b ∧ bi |   |</p>

    <p class="text-gray-300">|  endfor |   |</p>

    <p class="text-gray-300">|  return (b, δℓ, Fℓ) |   |</p>

    <p class="text-gray-300">We say that a history  <span class="math">\\mathcal{H}</span>  is valid w.r.t. public parameters  <span class="math">\\mathsf{pp}</span>  and initial digest  <span class="math">\\delta_0</span>  and state  <span class="math">\\mathsf{st}_0</span>  if  <span class="math">\\mathsf{EvalHistory}(\\mathsf{pp},\\delta_0,\\mathsf{st}_0,\\mathcal{H})</span>  returns bit  <span class="math">b = 1</span> .</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Definition 7.6 (Security for Verifiable Decentralized Storage).</h6>

    <p class="text-gray-300">Consider the experiment <span class="math">\\mathsf{VDS\\text{-}Security}_{\\mathsf{VDS}}^{A}(\\lambda)</span> below. Then we say that a VDS scheme <span class="math">\\mathsf{VDS}</span> is secure if for all PPT <span class="math">\\mathcal{A}</span> we have <span class="math">\\Pr[\\mathsf{VDS\\text{-}Security}_{\\mathsf{VDS}}^{A}(\\lambda)=1]\\in\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{VDS\\text{-}Security}_{\\mathsf{VDS}}^{A}(\\lambda)</span></p>

    <p class="text-gray-300"><span class="math">(\\mathsf{pp},\\delta_{0},\\mathsf{st}_{0})\\leftarrow\\mathsf{Bootstrap}(1^{\\lambda})</span> <span class="math">(\\mathcal{H},Q,\\mathsf{F}_{Q}^{<em>},\\pi^{</em>})\\leftarrow\\mathcal{A}(\\mathsf{pp},\\delta_{0},\\mathsf{st}_{0})</span> <span class="math">(b,\\delta,\\mathsf{F})\\leftarrow\\mathsf{EvalHistory}(\\mathsf{pp},\\delta_{0},\\mathsf{st}_{0},\\mathcal{H})</span> <span class="math">b\\leftarrow b\\wedge\\mathsf{F}_{Q}^{<em>}\\neq\\mathsf{F}_{Q}\\wedge</span> <span class="math">\\mathsf{ClntNode.VerRetrieve}(\\mathsf{pp},\\delta,Q,\\mathsf{F}_{Q}^{</em>},\\pi^{*})</span> return <span class="math">b</span></p>

    <p class="text-gray-300">VDS Proof of Storage. As an additional security mechanism we consider the possibility to ensure a client that a given file is stored by the network at a certain point of time without having to retrieve it. To this end, we extend the VDS notion to provide a <em>proof of storage</em> mechanism in the form of a proof of retrievability (PoR) <em>[x10]</em> or a proof of data possession (PDP) <em>[ABC^{+}07]</em>. Our proof of storage model for VDS is such that proofs are publicly verifiable given the file’s digest. Also, in order to support the decentralized and open nature of DSNs, the entire proof mechanism should not use any secret, and proofs should be generatable in a distributed fashion (this is a main distinguishing feature compared to existing PoRs/PDPs) while staying compact. The formalization of this property is in Appendix D.</p>

    <h2 id="sec-37" class="text-2xl font-bold">8 Our Realizations of VDS in Hidden-Order Groups</h2>

    <p class="text-gray-300">In this section, we present two constructions of VDS that work in hidden-order groups. The two schemes are presented in Sections 8.1 and 8.2 respectively, and we discuss a comparison in Section 8.3.</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">8.1 Our First VDS Construction</h3>

    <p class="text-gray-300">We build our first scheme by extending the techniques used to construct our first SVC scheme from Section 5.1. In particular, we start from a modified version of our SVC that achieves a weaker position binding property (in which the adversary reveals the full vector, yet its goal is to find two distinct openings for the same position) and then show how to make this scheme dynamic (i.e., to change vector values or its length) and fully distributed (i.e., updates can be performed without knowing the entire vector).</p>

    <p class="text-gray-300">Preliminaries. We begin by describing the simplified version of our SVC, considering the case of <span class="math">k=1</span>, which fits best our VDS construction, regarding efficiency and communication complexity. For convenience of the reader we describe again shortly the algorithms and functions (and variations of them) from section 5.1 that are used in the scheme (for more details we refer to the corresponding section):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{PrimeGen}</span>, a deterministic collision resistant function that maps integers to primes.</li>

      <li><span class="math">\\mathsf{PartndPrimeProd}(I,\\vec{y})\\rightarrow(a_{I},b_{I})</span>: given a set of indices <span class="math">I=\\{i_{1},\\ldots,i_{m}\\}\\subseteq[n]</span> and a vector <span class="math">\\vec{y}\\in\\mathcal{M}^{m}</span>, the function computes <span class="math">(a_{I},b_{I})\\coloneqq\\Big{(}\\prod_{l=1:y_{l}=0}^{m}p_{i_{l}},\\prod_{l=1:y_{l}=1}^{m}p_{i_{l}}\\Big{)}</span>, where <span class="math">p_{i}\\leftarrow\\mathsf{PrimeGen}(i)</span> for all <span class="math">i\\in\\mathbb{N}</span>.</li>

    </ul>

    <p class="text-gray-300">VC.Setup(1^λ, {0,1}^k) → crs := (G, g, g0, g1, PrimeGen).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VC.Com'(crs, <span class="math">\\vec{v}</span>) → C compute <span class="math">(a,b) \\leftarrow \\text{PartndPrimeProd}([n], \\vec{v})</span>, where $n \\leftarrow</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; next compute </span>A = g_0^a<span class="math"> and </span>B = g_1^b<span class="math">. Return </span>C := (C^\\star, n) := ((A,B),</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">VC.Ver'(crs, C, I, <span class="math">\\vec{y}</span>, <span class="math">\\pi_I</span>) → b compute <span class="math">(a_I, b_I) \\leftarrow \\text{PartndPrimeProd}(I, \\vec{y})</span>, and then parse <span class="math">\\pi_I := (\\Gamma_I, \\Delta_I)</span> and return <span class="math">b \\leftarrow (\\Gamma_I^{a_I} = A) \\wedge (\\Delta_I^{b_I} = B)</span>.</p>

    <p class="text-gray-300">VC.Disagg'(crs, I, <span class="math">\\vec{v}_I</span>, <span class="math">\\pi_I</span>, K) → <span class="math">\\pi_K</span> let <span class="math">L := I \\setminus K</span>, and <span class="math">\\vec{v}_L</span> be the subvector of <span class="math">\\vec{v}_I</span> at positions in <span class="math">L</span>. Then compute <span class="math">a_L, b_L \\leftarrow \\text{PartndPrimeProd}(L, \\vec{v}_L)</span> parse <span class="math">\\pi_I := (\\Gamma_I, \\Delta_I)</span> and set <span class="math">(\\Gamma_K, \\Delta_K) \\leftarrow (\\Gamma_I^{a_L}, \\Delta_I^{b_L})</span>. Return <span class="math">\\pi_K \\leftarrow (\\Gamma_K, \\Delta_K)</span>.</p>

    <p class="text-gray-300">VC.Agg'(crs, (I, <span class="math">\\vec{v}_I</span>, <span class="math">\\pi_I</span>), (J, <span class="math">\\vec{v}_J</span>, <span class="math">\\pi_J</span>)) → <span class="math">\\pi_K</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">L := I \\cap J</span>. If <span class="math">L \\neq \\emptyset</span>, set <span class="math">I&#x27; := I \\setminus L</span> and compute <span class="math">\\pi_{I&#x27;} \\leftarrow \\text{VC.Disagg}(\\text{crs}, I, \\vec{v}_I, \\pi_I, I&#x27;)</span>; otherwise let <span class="math">\\pi_{I&#x27;} = \\pi_I</span>.</li>

      <li>Compute <span class="math">(a_{I&#x27;}, b_{I&#x27;}) \\leftarrow \\text{PartndPrimeProd}(I, \\vec{v}_{I&#x27;})</span> and <span class="math">\\{a_J, b_J\\} \\leftarrow \\text{PartndPrimeProd}(J, \\vec{v}_J)</span>.</li>

      <li>Parse <span class="math">\\pi_{I&#x27;} := (\\Gamma_{I&#x27;}, \\Delta_{I&#x27;})</span>, <span class="math">\\pi_J := (\\Gamma_J, \\Delta_J)</span> and compute <span class="math">\\Gamma_K \\leftarrow \\text{ShamirTrick}(\\Gamma_{I&#x27;}, \\Gamma_J, a_{I&#x27;}, a_J)</span> and <span class="math">\\Delta_K \\leftarrow \\text{ShamirTrick}(\\Delta_{I&#x27;}, \\Delta_J, b_{I&#x27;}, b_J)</span>.</li>

      <li>Return <span class="math">\\pi_K \\leftarrow (\\Gamma_K, \\Delta_K)</span></li>

    </ol>

    <p class="text-gray-300">Finally, let <span class="math">\\text{PoKSubV}&#x27;</span> be the same protocol as in section 6 but adjusted according to the above algorithms. That is the CRS of is simply crs instead of the two specialized CRSs. Furthermore, since <span class="math">C</span> is not accompanied with <span class="math">\\text{PoProd}_2</span> the verifier does not have to check the validity of it. The rest of the protocol remains the same and the underlying relation is:</p>

    <p class="text-gray-300">$$ \\begin{array}{l} R_{\\text{PoKSubV}'} = \\left\\{ \\left( (C, C', I), (\\vec{v}_I, \\pi_I, \\pi_I') \\right) : \\text{VC.Ver}'(\\text{crs}, C, I, \\vec{v}_I, \\pi_I) = 1 \\right. \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left. \\wedge \\text{VC.Ver}'(\\text{crs}, C', I, \\vec{v}_I, \\pi_I') = 1 \\wedge</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{v}_I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n' \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Finally, we note that for simplicity in the following we abuse the notation for Shamir's trick by writing e.g. <span class="math">(\\Gamma_I&#x27;, \\Delta_I&#x27;) \\leftarrow (\\text{ShamirTrick}(\\Gamma_I, \\Gamma_K, \\mathsf{F}_I, \\mathsf{F}_K)^{a_K&#x27;}</span>, ShamirTrick}(\\Delta_I, \\Delta_K, \\mathsf{F}_I, \\mathsf{F}_K)^{b_K'})$ instead of writing, more precisely,</p>

    <div class="my-4 text-center"><span class="math-block">(\\Gamma_I&#x27;, \\Delta_I&#x27;) \\leftarrow (\\text{ShamirTrick}(\\Gamma_I, \\Gamma_K, a_I, a_K)^{a_K&#x27;}, \\text{ShamirTrick}(\\Delta_I, \\Delta_K, b_I, b_K)^{b_K&#x27;})).</span></div>

    <p class="text-gray-300">Our scheme <span class="math">\\text{VDS}_1</span>. The algorithms of the VDS scheme <span class="math">\\text{VDS}_1</span> are the following:</p>

    <p class="text-gray-300">Bootstrap(1^λ) → (pp, δ0, n0, st0) Execute VC.Setup(1^λ, {0,1}^k) and get pp := (G, g, g0, g1, PrimeGen). Set <span class="math">n_0 \\leftarrow 0</span>, δ0 ← ((g0, g1), n0) and st0 ← (g0, g1).</p>

    <p class="text-gray-300">The algorithms for storage nodes are:</p>

    <p class="text-gray-300">StrgNode.AddStorage(δ, n, st, I, F_I, Q, F_Q, π_Q) → (st', J, F_J) If I = ∅ then set st' ← π_Q, otherwise st := π_I. Then compute st' ← VC.Agg'(pp, (I, F_I, π_I), (Q, F_Q, π_Q)). The computation of J and F_J is straightforward: (J, F_J) ← (I ∪ Q, F_I ∪ F_Q).</p>

    <p class="text-gray-300">StrgNode.RmvStorage(δ, n, st, I, F_I, K) → (st', J, F_J) Compute J ← I \\ K and the corresponding F_J. Then π_J ← VC.Disagg'(pp, I, F_I, π_I, J) and set st' ← π_J.</p>

    <p class="text-gray-300">50</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">StrgNode.CreateFrom(δ,n,st,I,F_I,J) → (δ',n',st',J,F_J,Y_J) The new digest δ' of F_J is computed with the commitment algorithm δ' ← VC.Com'(pp,F_J). The new length gets n' ←</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. The previous local state is st = π_I and the new local state gets st' ← VC.Disagg(pp,I,F_I,π_I,J). Finally, for Y_J it computes an argument of knowledge of subvector (see section 6), π_PoKSubV' ← PoKSubV'.P(pp,(δ,δ',J),(v_J,π_I)) and sets Y_J ← (δ',π_PoKSubV').</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">StrgNode.PushUpdate(δ,n,st,I,F_I,op,Δ) → (δ',n',st',J,F'_J,Y_Δ) The algorithm works according to the type of update operation op:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>op = mod: parse Δ := (K, F'_K) and st := π_I. Execute π_K ← VC.Disagg'(pp, I, F_I, π_I, K) and parse π_K := (Γ_K, Δ_K). Then compute (a'_K, b'_K) ← PartndPrimeProd(K, F'_K) and set δ' ← ((Γ'_K^{a'_K}, Δ'_K^{b'_K}), n) (i.e., n' = n remains the same). st' is the new opening of I, π'_I ← π_I, which is the same so the local state does not change st' ← st. Since it is a modification operation (J, F'_J) ← (I, F'_I), where F'_I is simply the modified file F'_I = (F_I \\ F_K) ∪ F'_K. Finally, set Y_Δ ← (F_K, π_K).</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- op = add: parse Δ := (K, F'_K), st := π_I, and the old digest δ := ((A, B), n). Then compute (a'_K, b'_K) ← PartndPrimeProd(K, F'_K) and the new digest gets δ' ← ((A^{a'_K}, B^{b'_K}), n') where n' ← n +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. The new state refers to the new file subportion (J, F'_J) ← (I ∪ K, F_I ∪ F_K), st' := π'_J, and is the same as the old one st' ← st since π_I = π'_J. Finally, set Y_Δ ← ∅.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- op = del: parse Δ := K and st := π_I. Execute π_K ← VC.Disagg'(pp, I, F_I, π_I, K) and parse π_K := (Γ_K, Δ_K). Then the new digest is δ' ← ((Γ_K, Δ_K), n') where n' ← n -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. The new state refers to the new file subportion (J, F'_J) ← (I \\ K, F_I \\ F_K)) and is the same as the old one st' ← st since π_I = π'_J. Finally set Y_Δ ← (F_K, π_K).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">StrgNode.ApplyUpdate(δ,n,st,I,F_I,op,Δ,Y_Δ) → (b,δ',n',st',J,F'_J) Again, it works according to the type of update operation op:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>op = mod: parse Δ := (K, F'_K), st := π_I and Y_Δ := (F_K, π_K). Compute acceptance bit b ← VC.Ver'(pp, δ, K, F_K, π_K). Then, if b = 1 parse π_K := (Γ_K, Δ_K), compute (a'_K, b'_K) ← PartndPrimeProd(K, F'_K) and set δ' ← ((Γ'_K^{a'_K}, Δ'_K^{b'_K}), n') where n' ← n. It is clear that in the case of a modify operation (J, F'_J) ← (I, F'_I), where F'_I is simply the modified file F'_I = (F_I \\ F_K) ∪ F'_K. For the new local state st' that we discern three cases:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>I ∩ K = ∅: then compute (Γ'_I, Δ'_I) ← (ShamirTrick(Γ_I, Γ_K, F_I, F_K)^{a'_K}, ShamirTrick(Δ_I, Δ_K, F_I, F_K)^{b'_K}) and set st' ← π'_I := (Γ'_I, Δ'_I).</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>I ∩ K = K: compute (Γ'_I, Δ'_I) ← (Γ_I, Δ_I) and set st' ← π'_I := (Γ'_I, Δ'_I).</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the case where neither I ∩ K = ∅ nor I ∩ K = K, i.e. I ∩ K = L ∉ {K, ∅} we partition K as K = L ∪ L and apply two sequential updates to π_I, one with L' (s.t. I ∩ L = ∅) and one with L (s.t. I ∩ L = L). That is, compute (a'_L, b'_L) ← PartndPrimeProd(L, F'_L) and then (Γ'_I, Δ'_I) ← (ShamirTrick(Γ_I, Γ_L, F_I, F_L)^{a'_L}, ShamirTrick(Δ_I, Δ_L, F_I, F_L)^{b'_L}). Then (Γ''_I, Δ''_I) ← (Γ'_I, Δ'_I). Finally, set st' ← (Γ''_I, Δ''_I). Essentially, since the case of I ∩ L = L doesn't cause any change to the state, computationally it is as a single update.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- op = add: parse Δ := (K, F'_K), st := π_I and the old digest as δ := ((A, B), n). Set b = 1 iff K = {n + 1, ..., n +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}. Then if b = 1 compute (a'_K, b'_K) ← PartndPrimeProd(K, F'_K) and the new digest becomes δ' ← ((A^{a'_K}, B^{b'_K}), n') where n' ← n +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. For the new local state, first parse the old one st := π_I := (Γ_I, Δ_I) and the new one gets st' ← π'_I where π'_I ← (Γ''_I^{a'_K}, Δ''_I^{b'_K}). Finally set (J, F'_J) ← (I, F_I), i.e., the file remains unchanged.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">51</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- op = del: parse <span class="math">\\Delta := K</span>, st := <span class="math">\\pi_I</span>, and <span class="math">\\Upsilon_{\\Delta} := (\\mathsf{F}_K, \\pi_K)</span>. Set <span class="math">b = 1</span> iff $K = \\{n -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1, \\ldots, n\\} \\wedge \\mathsf{VC.Ver}'(\\mathsf{pp}, \\delta, K, \\mathsf{F}_K, \\pi_K) = 1<span class="math">. Then if </span>b = 1<span class="math"> sets </span>\\delta' \\gets ((\\Gamma_K, \\Delta_K), n')<span class="math"> where </span>n' \\gets n -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. For the new local state, similarly to the modify operation, we discern three cases. If </span>I \\cap K = \\emptyset<span class="math"> then </span>(\\Gamma_I', \\Delta_I') \\gets (\\mathsf{ShamirTrick}(\\Gamma_I, \\Gamma_K, \\mathsf{F}_I, \\mathsf{F}_K), \\mathsf{ShamirTrick}(\\Delta_I, \\Delta_K, \\mathsf{F}_I, \\mathsf{F}_K))<span class="math"> and set </span>\\mathsf{st}' \\gets \\pi_K := (\\Gamma_I', \\Delta_I')<span class="math">; else if </span>I \\cap K = K<span class="math"> </span>\\mathsf{st}' = \\mathsf{st}<span class="math">, else if </span>I \\cap K = L<span class="math"> then (let </span>\\bar{L} = K \\setminus L<span class="math">) </span>(\\Gamma_I', \\Delta_I') \\gets (\\mathsf{ShamirTrick}(\\Gamma_I, \\Gamma_{\\bar{L}}, \\mathsf{F}_I, \\mathsf{F}_{\\bar{L}}), \\mathsf{ShamirTrick}(\\Delta_I, \\Delta_{\\bar{L}}, \\mathsf{F}_I, \\mathsf{F}_{\\bar{L}}))<span class="math"> and set </span>\\mathsf{st}' \\gets \\pi_I := (\\Gamma_I', \\Delta_I')<span class="math"> (similarly to the op = mod case). Finally </span>(J, \\mathsf{F}_J') \\gets (I \\setminus L, \\mathsf{F}_I \\setminus \\mathsf{F}_L)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">StrgNode.Retrieve<span class="math">(\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, Q) \\to (\\mathsf{F}_Q, \\pi_Q)</span> Compute both portions <span class="math">\\mathsf{F}_Q \\subseteq \\mathsf{F}_I</span> as well as proof <span class="math">\\pi_Q \\gets \\mathsf{VC.Disagg}&#x27;(\\mathsf{pp}, I, \\mathsf{F}_I, \\mathsf{st}, Q)</span>.</p>

    <p class="text-gray-300">The algorithms for client nodes are:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ClntNode.GetCreate<span class="math">(\\delta, J, \\Upsilon_J) \\to (b, \\delta&#x27;)</span> Parse <span class="math">\\Upsilon_J := (\\delta&#x27;, \\pi_{\\mathsf{PoKSubV&#x27;}})</span>, set $n' =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and output </span>b \\gets \\mathsf{PoKSubV'}<span class="math">. </span>\\mathsf{V}(\\mathsf{pp}, (\\delta, \\delta', J), \\pi_J) \\wedge J = \\{1, \\ldots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math"> and </span>\\delta'$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">ClntNode.VerRetrieve<span class="math">(\\delta, Q, \\mathsf{F}_Q, \\pi_Q) \\to b</span> Output <span class="math">b \\gets \\mathsf{VC.Ver}&#x27;(\\mathsf{pp}, \\delta, Q, \\mathsf{F}_Q, \\pi_Q)</span></p>

    <p class="text-gray-300">ClntNode.ApplyUpdate<span class="math">(\\delta, \\mathsf{op}, \\Delta, \\Upsilon_{\\Delta}) \\to (b, \\delta&#x27;)</span> This algorithm is almost identical to the first part of the Storage Node algorithm StrgNode.ApplyUpdate<span class="math">(\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, \\mathsf{op}, \\Delta, \\Upsilon_{\\Delta})</span>. The difference is that it executes only the parts that are related to the output of <span class="math">b</span> and <span class="math">\\delta</span>.</p>

    <p class="text-gray-300">AggregateCertificates<span class="math">(\\delta, (I, \\mathsf{F}_I, \\pi_I), (J, \\mathsf{F}_J, \\pi_J)) \\to \\pi_K</span></p>

    <p class="text-gray-300">Return <span class="math">\\pi_K \\gets \\mathsf{VC.Agg}&#x27;(\\mathsf{pp}, (I, \\mathsf{F}_I, \\pi_I), (J, \\mathsf{F}_J, \\pi_J))</span>.</p>

    <p class="text-gray-300">Correctness. Here we state and prove the correctness of <span class="math">\\mathsf{VDS}_1</span>.</p>

    <p class="text-gray-300">Theorem 8.1. The scheme <span class="math">\\mathsf{VDS}_1</span> presented above is a correct verifiable decentralized storage scheme.</p>

    <p class="text-gray-300">Proof In the following we will always assume that <span class="math">\\mathsf{st} := (\\mathsf{st}_1, \\mathsf{st}_2)</span> and <span class="math">\\delta := (\\delta^*, n) := ((\\delta_1, \\delta_2), n)</span>. Furthermore, whenever <span class="math">(a_I, b_I)</span> appear, we assume that they are the outputs of <span class="math">\\mathsf{PartndPrimeProd}(I, \\mathsf{F}_I)</span>, for each set of indices <span class="math">I</span>. Finally for each set of indices <span class="math">I</span> we assume <span class="math">\\pi_I := (\\Gamma_I, \\Delta_I)</span>.</p>

    <p class="text-gray-300">First we note that in our construction it is sufficient for a local view <span class="math">(\\mathsf{pp}, \\delta, n, \\mathsf{st}, I, \\mathsf{F}_I)</span> of a storage node to be valid that</p>

    <p class="text-gray-300">ClntNode.VerRetrieve<span class="math">(\\delta, I, \\mathsf{StrgNode.Retrieve}(\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, I)) = 1</span> holds. More concretely this translates to <span class="math">\\mathsf{st}_1^{a_I} = \\delta_1 \\wedge \\mathsf{st}_2^{b_I} = \\delta_2</span> and due to the correctness of disaggregation property <span class="math">\\mathsf{st}_1&#x27;^{a_Q} = \\delta_1 \\wedge \\mathsf{st}_2&#x27;^{b_Q} = \\delta_2</span> holds where <span class="math">\\mathsf{st}&#x27; \\gets \\mathsf{StrgNode.Retrieve}(\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, Q)</span> for each <span class="math">Q \\subseteq I</span>. To put things clear, a local view of a storage node <span class="math">(\\mathsf{pp}, \\delta, n, \\mathsf{st}, I, \\mathsf{F}_I)</span> is valid if <span class="math">\\mathsf{st}_1^{a_I} = \\delta_1 \\wedge \\mathsf{st}_2^{b_I} = \\delta_2</span>.</p>

    <p class="text-gray-300">Let <span class="math">(\\mathsf{pp}, \\delta, n, \\mathsf{st}, I, \\mathsf{F}_I)</span> be a valid local view of a storage node:</p>

    <p class="text-gray-300">UPDATE CORRECTNESS. Let <span class="math">(\\mathsf{op}, \\Delta)</span> be an admissible update for <span class="math">(I, \\mathsf{F}_I, n)</span> and <span class="math">(\\delta&#x27;, n&#x27;, \\mathsf{st}&#x27;, J, \\mathsf{F}_J&#x27;, \\Upsilon_{\\Delta})</span> be the output of StrgNode.PushUpdate<span class="math">(\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, \\mathsf{op}, \\Delta)</span>. We discern three cases depending on the type of update:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>op = mod:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>According to our construction <span class="math">\\delta^{\\star&#x27;} = (\\Gamma_K^{a_K&#x27;}, \\Delta_K^{b_K&#x27;})</span>, where</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\Gamma_K, \\Delta_K) = (\\Gamma_I^{a_{I \\setminus K}}, \\Delta_I^{b_{I \\setminus K}}) = (\\mathsf{st}_1^{\\frac{a_I}{a_K}}, \\mathsf{st}_2^{\\frac{b_I}{b_K}})</span> (due to VC.Disagg'). So <span class="math">\\delta&#x27; = (\\mathsf{st}_1^{\\frac{a_I}{a_K} a_K&#x27;}, \\mathsf{st}_2^{\\frac{b_I}{b_K} b_K&#x27;})</span>. Furthermore <span class="math">\\mathsf{st}&#x27; = \\mathsf{st}</span> and <span class="math">J = I</span>, so</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf{st}_1&#x27;^{a_J&#x27;}, \\mathsf{st}_1&#x27;^{b_J&#x27;}) = (\\mathsf{st}_1^{\\frac{a_I}{a_K} a_K&#x27;}, \\mathsf{st}_2^{\\frac{b_I}{b_K} b_K&#x27;}) = (\\delta_1&#x27;, \\delta_2&#x27;)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">(\\delta, n, \\mathsf{st}_s, I_s, \\mathsf{F}_{I_s})</span> be valid and <span class="math">(b_s, \\delta_s&#x27;, n_s&#x27;, \\mathsf{st}_s&#x27;, J_s, \\mathsf{F}_{J_s}&#x27;)</span> be the output of <span class="math">\\mathsf{StrgNode.ApplyUpdate}(\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, \\mathsf{op}, \\Delta, \\Upsilon_\\Delta)</span>. <span class="math">b_s = 1</span>, <span class="math">\\delta_s&#x27; = \\delta&#x27;</span> and <span class="math">n_s&#x27; = n&#x27;</span> come from inspection. If <span class="math">I \\cap K = \\emptyset</span> then <span class="math">(\\mathsf{st}_{s,1}&#x27;, \\mathsf{st}_{s,2}&#x27;) \\gets \\left( \\mathbf{ShamirTrick}(\\mathsf{st}_{s,1}, \\Gamma_K, \\mathsf{F}_I, \\mathsf{F}_K)^{a_K&#x27;}, \\mathbf{ShamirTrick}(\\mathsf{st}_{s,2}, \\Delta_K, \\mathsf{F}_I, \\mathsf{F}_K)^{b_K&#x27;} \\right) = (\\mathsf{st}_{s,1}^{a_K&#x27;}, \\mathsf{st}_{s,2}^{b_K&#x27;}) = (\\mathsf{st}_{s,2}^{a_K&#x27;}, \\mathsf{st}_{s,2}^{b_K&#x27;}) = (\\mathsf{st}_{s,2}^{a_K&#x27;}, \\mathsf{st}_{s,2}^{b_K&#x27;}) = (\\delta_{s,1}, \\delta_{s,2})</span></li>

    </ol>

    <p class="text-gray-300">If <span class="math">I \\cap K = K</span> then <span class="math">\\mathsf{st}_s</span> doesn't change and <span class="math">(a_I&#x27;, b_I&#x27;) = (\\frac{a_I}{a_K} a_K&#x27;, \\frac{b_I}{b_K} b_K&#x27;)</span>, hence</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathsf {s t} _ {s, 1} ^ {\\prime a _ {I} ^ {\\prime}}, \\mathsf {s t} _ {s, 2} ^ {\\prime b _ {I} ^ {\\prime}}\\right) = \\left(\\mathsf {s t} _ {s, 1} ^ {\\frac {a _ {K} ^ {\\prime}}{a _ {K}} a _ {I}}, \\mathsf {s t} _ {s, 2} ^ {\\frac {b _ {K} ^ {\\prime}}{b _ {K}} b _ {I}}\\right) = \\left(\\delta_ {s, 1}, \\delta_ {s, 2}\\right)</span></div>

    <p class="text-gray-300">If <span class="math">I \\cap K = K</span> then <span class="math">\\mathsf{st}_s</span> doesn't change and <span class="math">(a_I&#x27;, b_I&#x27;) = (\\frac{a_I}{a_K} a_K&#x27;, \\frac{b_I}{b_K} b_K&#x27;)</span>, hence</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathsf {s t} _ {s, 1} ^ {\\prime a _ {I} ^ {\\prime}}, \\mathsf {s t} _ {s, 2} ^ {\\prime b _ {I} ^ {\\prime}}\\right) = \\left(\\delta_ {s, 1} ^ {\\prime}, \\delta_ {s, 2} ^ {\\prime}\\right)</span></div>

    <p class="text-gray-300">The validity of <span class="math">(\\mathsf{pp},\\delta_s&#x27;,n_s&#x27;,\\mathsf{st}_s&#x27;,J_s,\\mathsf{F}_{J_s}&#x27;)</span> in the case of <span class="math">I\\cap K = L\\notin \\{\\emptyset ,K\\}</span> is covered by the above two, since it essentially is a sequence of the two above cases.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">(b_c, \\delta_c)</span> be the output of ClntNode.ApplyUpdate <span class="math">(\\delta, \\mathsf{op}, \\Delta, \\Upsilon_{\\Delta})</span>. It follows directly from the definition of ClntNode.ApplyUpdate (and its similarity with StrgNode.ApplyUpdate) that <span class="math">b_c = b_s = 1</span> and <span class="math">\\delta_c&#x27; = \\delta_s&#x27; = \\delta&#x27;</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>op = add:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>According to our construction <span class="math">\\delta^{\\star&#x27;} = (\\delta_1^{a_K&#x27;}, \\delta_2^{b_K&#x27;})</span> and <span class="math">\\mathsf{st}&#x27; = \\mathsf{st}</span>. Also, <span class="math">J = I \\cup K</span> and <span class="math">(a_J&#x27;, b_J&#x27;) = (a_I a_K&#x27;, b_I b_K&#x27;)</span> and so</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathsf {s t} _ {1} ^ {\\prime a _ {J} ^ {\\prime}}, \\mathsf {s t} _ {1} ^ {\\prime b _ {J} ^ {\\prime}}\\right) = \\left(\\mathsf {s t} _ {1} ^ {a _ {I} a _ {K} ^ {\\prime}}, \\mathsf {s t} _ {2} ^ {b _ {I} b _ {K} ^ {\\prime}}\\right) = \\left(\\delta_ {1} ^ {a _ {K} ^ {\\prime}}, \\delta_ {2} ^ {b _ {K} ^ {\\prime}}\\right) = \\left(\\delta_ {1} ^ {\\prime}, \\delta_ {2} ^ {\\prime}\\right)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">(\\delta, n, \\mathsf{st}_s, I_s, \\mathsf{F}_{I_s})</span> be valid and <span class="math">(b_s, \\delta_s&#x27;, n_s&#x27;, \\mathsf{st}_s&#x27;, J_s, \\mathsf{F}_{J_s}&#x27;)</span> be the output of</li>

    </ol>

    <p class="text-gray-300">StrgNode.ApplyUpdate( <span class="math">\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, \\mathsf{op}, \\Delta, \\Upsilon_{\\Delta}</span> ). <span class="math">b_s = 1</span>, <span class="math">\\delta_s&#x27; = \\delta&#x27;</span> and <span class="math">n_s&#x27; = n&#x27;</span> come from inspection.</p>

    <p class="text-gray-300">Also <span class="math">J = I</span> so <span class="math">(a_J&#x27;, b_J&#x27;) = (a_I, b_I)</span>. <span class="math">\\mathsf{st}&#x27; = (\\mathsf{st}_1^{a_K&#x27;}, \\mathsf{st}_2^{b_K&#x27;})</span> and <span class="math">\\delta^{\\star&#x27;} = (\\delta_1^{a_K&#x27;}, \\delta_2^{b_K&#x27;})</span> so</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathsf {s t} _ {1} ^ {\\prime a _ {J} ^ {\\prime}}, \\mathsf {s t} _ {1} ^ {\\prime b _ {J} ^ {\\prime}}\\right) = \\left(\\mathsf {s t} _ {1} ^ {\\frac {a _ {I}}{a _ {K}} a _ {I}}, \\mathsf {s t} _ {2} ^ {\\frac {b _ {I}}{b _ {K}} b _ {I}}\\right) = \\left(\\delta_ {1} ^ {\\prime}, \\delta_ {1} ^ {\\prime}\\right)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">(b_c, \\delta_c)</span> be the output of ClntNode.ApplyUpdate( <span class="math">\\delta, \\mathsf{op}, \\Delta, \\Upsilon_{\\Delta}</span> ). Again correctness comes directly from the definition of ClntNode.ApplyUpdate.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>op = del:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>According to our construction <span class="math">(\\delta_1&#x27;, \\delta_2&#x27;) = (\\Gamma_K, \\Delta_K) = (\\delta_1^{\\frac{1}{a_K}}, \\delta_2^{\\frac{1}{b_K}})</span>, <span class="math">\\mathsf{st}&#x27; = \\mathsf{st}</span> and <span class="math">J = I \\setminus K</span>. Furthermore, <span class="math">(a_J&#x27;, b_J&#x27;) = (\\frac{a_I}{a_K}, \\frac{b_I}{b_K})</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathsf {s t} _ {1} ^ {\\prime a _ {J} ^ {\\prime}}, \\mathsf {s t} _ {1} ^ {\\prime b _ {J} ^ {\\prime}}\\right) = \\left(\\mathsf {s t} _ {1} ^ {\\frac {a _ {I}}{a _ {K}}}, \\mathsf {s t} _ {2} ^ {\\frac {b _ {I}}{b _ {K}}}\\right) = \\left(\\delta_ {1} ^ {\\frac {1}{a _ {K}}}, \\delta_ {2} ^ {\\frac {1}{b _ {K}}}\\right) = \\left(\\delta_ {1} ^ {\\prime}, \\delta_ {2} ^ {\\prime}\\right)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">(\\delta, n, \\mathsf{st}_s, I_s, \\mathsf{F}_{I_s})</span> be valid and <span class="math">(b_s, \\delta_s&#x27;, n_s&#x27;, \\mathsf{st}_s&#x27;, J_s, \\mathsf{F}_{J_s}&#x27;)</span> be the output of</li>

    </ol>

    <p class="text-gray-300">StrgNode.ApplyUpdate( <span class="math">\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, \\mathsf{op}, \\Delta, \\Upsilon_{\\Delta}</span> ). <span class="math">b_s = 1</span>, <span class="math">\\delta_s&#x27; = \\delta&#x27;</span> and <span class="math">n_s&#x27; = n&#x27;</span> come from inspection.</p>

    <p class="text-gray-300">Also let <span class="math">L = I \\cap K</span> then <span class="math">J = I \\setminus L</span> and if <span class="math">\\bar{L} = K \\setminus L</span> then</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\mathsf {s t} _ {1} ^ {\\prime}, \\mathsf {s t} _ {2} ^ {\\prime}\\right) \\leftarrow \\left(\\mathbf {S h a m i r T r i c k} \\left(\\mathsf {s t} _ {1}, \\Gamma_ {\\bar {L}}, \\mathsf {F} _ {I}, \\mathsf {F} _ {\\bar {L}}\\right), \\mathbf {S h a m i r T r i c k} \\left(\\mathsf {s t} _ {2}, \\Delta_ {\\bar {L}}, \\mathsf {F} _ {I}, \\mathsf {F} _ {\\bar {L}}\\right)\\right) = \\left(\\mathsf {s t} _ {1} ^ {\\frac {1}{a _ {L}}}, \\mathsf {s t} _ {2} ^ {\\frac {1}{b _ {L}}}\\right) \\\\ \\left(\\mathsf {s t} _ {1} ^ {\\prime a _ {J} ^ {\\prime}}, \\mathsf {s t} _ {1} ^ {\\prime b _ {J} ^ {\\prime}}\\right) = \\left(\\mathsf {s t} _ {1} ^ {\\frac {a _ {J}}{a _ {L}}}, \\mathsf {s t} _ {2} ^ {\\frac {b _ {J}}{b _ {L}}}\\right) = \\left(\\mathsf {s t} _ {1} ^ {\\frac {a _ {I} / a _ {L}}{a _ {K} / a _ {L}}}, \\mathsf {s t} _ {1} ^ {\\frac {b _ {I} / b _ {L}}{b _ {K} / b _ {L}}}\\right) = \\left(\\delta_ {1} ^ {\\frac {1}{a _ {K}}}, \\delta_ {2} ^ {\\frac {1}{b _ {K}}}\\right) = \\left(\\delta_ {1} ^ {\\prime}, \\delta_ {2} ^ {\\prime}\\right) \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">(b_{c},\\delta_{c})</span>  be the output of ClntNode.ApplyUpdate  <span class="math">(\\delta ,\\mathrm{op},\\varDelta,\\Upsilon_{\\varDelta})</span> <span class="math">b_{c} = b_{s} = 1</span>  and  <span class="math">\\delta_c^\\prime = \\delta_s^\\prime = \\delta^\\prime</span>  from inspection.</li>

    </ol>

    <p class="text-gray-300">ADD STORAGE CORRECTNESS. It comes directly from aggregation correctness of VC.Agg' (see section 5.1).</p>

    <p class="text-gray-300">REMOVE STORAGE CORRECTNESS. It comes directly from disaggregation correctness of VC.Disagg' (see section 5.1).</p>

    <p class="text-gray-300">CREATE CORRECTNESS. Let  <span class="math">J \\subseteq I</span>  and  <span class="math">(\\delta&#x27;, n&#x27;, \\mathsf{st}&#x27;, J, \\mathsf{F}_J, \\Upsilon_J)</span>  be the output of</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">StrgNode.CreateFrom  <span class="math">(\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, J)</span>  and  <span class="math">(b, \\delta&#x27;&#x27;)</span>  the output of ClntNode.GetCreate  <span class="math">(\\delta, J, \\Upsilon_J)</span> , then  $n' =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  comes from inspection of StrgNode.CreateFrom,  </span>\\delta'' = \\delta'<span class="math">  comes from inspection of ClntNode.GetCreate algorithm and validity of  </span>(\\mathsf{pp}, \\delta', n', \\mathsf{st}', J, \\mathsf{F}_J)<span class="math">  comes from correctness of VC.Com&#x27; and VC.Agg. Finally,  </span>b = 1$  comes from correctness of PoKSubV' protocol.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">AGGREGATE CORRECTNESS. It comes directly from aggregation correctness of VC.Agg' (see section 5.1).</p>

    <p class="text-gray-300">Security. Below we state and prove the security of our  <span class="math">\\mathrm{VDS}_1</span>  scheme.</p>

    <p class="text-gray-300">Theorem 8.2 (Security). Let  <span class="math">\\mathbb{G} \\gets \\mathsf{Ggen}(1^{\\lambda})</span>  be a hidden order group where the strong RSA assumption holds, then the scheme  <span class="math">\\mathrm{VDS}_1</span>  presented above is a secure Verifiable Decentralized Storage scheme in the generic group model.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof First we observe that in our scheme, for every valid history  <span class="math">\\mathcal{H}</span> , with  <span class="math">\\mathrm{Bootstrap}(1^{\\lambda}) \\to (\\mathsf{pp}, \\delta_0, \\mathsf{st}_0) := ((\\mathbb{G}, g, g_0, g_1, \\mathrm{PrimeGen}), ((g_0, g_1), 0), (g_0, g_1))</span> , the digest that arises is the same as a commitment of the file with VC.Com'. Concretely, let  <span class="math">(b, \\delta, \\mathsf{F}) \\gets \\mathrm{EvalHistory}(\\mathsf{pp}, \\delta_0, \\mathsf{st}_0, \\mathcal{H})</span>  then if  <span class="math">b = 1</span>  it holds that  <span class="math">\\delta = \\mathrm{VC.Com}&#x27;(\\mathsf{pp}, \\mathsf{F})</span>  or  <span class="math">\\delta^{\\star} = (\\delta_1, \\delta_2) = (g_0^a, g_1^b)</span> , where  $(a, b) \\gets \\mathrm{PartndPrimeProd}([</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">], \\mathsf{F})$ . Particularly this is central to our construction and one can validate that it holds by inspecting all the algorithms that alter the digest.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To prove the theorem we use a hybrid argument. We start by defining the game  <span class="math">G_0</span>  as the actual VDS security game of Definition 7.6, and our goal is to prove that for any PPT  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\operatorname*{Pr}[G_0 = 1] \\in \\mathrm{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Game  <span class="math">G_0</span> :</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G0 = VDS-SecurityVDS(λ)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">EvalHistory(pp, δ0, st0, H)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(pp, δ0, st0) ← Bootstrap(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">F0 ← ∅; b ← 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(H, Q, FQ<em>, π</em>) ← A(pp, δ0, st0)</td>

            <td class="px-3 py-2 border-b border-gray-700">for i ∈ [ℓ]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(b, δ, F) ← EvalHistory(pp, δ0, st0, H)</td>

            <td class="px-3 py-2 border-b border-gray-700">Fi ← FileChange(Fi-1, opi, Δi)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">b ← b ∧ FQ* ≠ FQ ∧</td>

            <td class="px-3 py-2 border-b border-gray-700">if opi ∈ {mod, add, del} then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ClntNode.VerRetrieve(pp, δ, Q, FQ<em>, π</em>)</td>

            <td class="px-3 py-2 border-b border-gray-700">(bi, δi) ← ClntNode.ApplyUpdate(δi-1, opi, Δi, YΔi)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return b</td>

            <td class="px-3 py-2 border-b border-gray-700">elseif opi = cfrom then</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | (bi, δi) ← ClntNode.GetCreate(δi-1, Δi, YΔi)  |</p>

    <p class="text-gray-300">|   | endif  |</p>

    <p class="text-gray-300">|   | b ← b ∧ bi  |</p>

    <p class="text-gray-300">|   | endfor  |</p>

    <p class="text-gray-300">|   | return (b, δl, Fℓ)  |</p>

    <p class="text-gray-300">Recall that  <span class="math">\\mathcal{H} = (\\mathrm{op}^i,\\varDelta^i,\\Upsilon_{\\varDelta}^i)_{i\\in [\\ell ]}</span>  where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for <span class="math">\\mathsf{op}^i = \\mathsf{mod}</span>: <span class="math">\\varDelta^i := (K^i, \\mathsf{F}_{K^i}^i)</span>, <span class="math">\\Upsilon_{\\Delta}^{i} := (\\mathsf{F}_{K^{i - 1}}^{i - 1}, \\pi_{K^{i}}^{i - 1})</span> and ClntNode.ApplyUpdate <span class="math">(\\delta^{i - 1}, \\mathsf{op}^i, \\varDelta^i, \\Upsilon_{\\Delta}^{i})</span> outputs <span class="math">b^{i} = 1</span> if VC.Ver'(pp, <span class="math">\\delta^{i - 1}, K^i, \\mathsf{F}_{K^i}^{i - 1}, \\pi_{K^i}^{i - 1}) = 1</span> or <span class="math">(\\Gamma_{K^i}^{a_{K^i}} = \\delta_1^{i - 1}) \\wedge (\\varDelta_{K^i}^{b_{K^i}} = \\delta_2^{i - 1})</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- for <span class="math">\\mathsf{op}^i = \\mathsf{add}</span>: <span class="math">\\varDelta^i := (K, \\mathsf{F}_{K^i}^i)</span>, <span class="math">\\Upsilon_{\\Delta}^{i} := \\varnothing</span> and ClntNode.ApplyUpdate <span class="math">(\\delta^{i - 1}, \\mathsf{op}^i, \\varDelta^i, \\Upsilon_{\\Delta}^{i})</span> outputs <span class="math">b^{i} = 1</span> if $K^{i} = \\{n^{i - 1} + 1, \\dots, n^{i - 1} +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K^{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- <span class="math">\\mathsf{op}^i = \\mathsf{cfrom}</span>: <span class="math">\\varDelta^i := K^i</span>, <span class="math">\\Upsilon_{\\Delta}^{i} := (\\delta^i, \\pi_{\\mathsf{PoKSubV&#x27;}}^i)</span> and ClntNode.GetCreate <span class="math">(\\delta^{i - 1}, \\varDelta^i, \\Upsilon_{\\Delta}^{i})</span> outputs <span class="math">b^{i} = 1</span> if <span class="math">\\mathsf{PoKSubV&#x27;}</span>. $\\mathsf{V}(\\mathsf{pp}, (\\delta^{i - 1}, \\delta^i,</td>

            <td class="px-3 py-2 border-b border-gray-700">K^i</td>

            <td class="px-3 py-2 border-b border-gray-700">, K^i), \\pi_{K^i}^i) = 1$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Game <span class="math">G_i</span></strong>: define <span class="math">G_i</span> be the same as <span class="math">G_{i-1}</span> except for the update <span class="math">i</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">\\mathsf{op}^i = \\mathsf{mod}</span>: <span class="math">\\varDelta^i := (K^i, \\mathsf{F}_{K^i}^i)</span>, <span class="math">\\Upsilon_{\\Delta}^{i} := (\\mathsf{F}_{K^i}^{i-1}, \\pi_{K^i}^{i-1})</span> but in the <span class="math">i</span>-th step of EvalHistory <span class="math">b^i</span> is instead output of:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b ^ {i} \\leftarrow \\left(a _ {K ^ {i}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\right) \\wedge \\left(b _ {K ^ {i}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\right)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $(a,b)\\gets \\mathsf{PartndPrimeProd}([</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{F}^{i - 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">],\\mathsf{F}^{i - 1})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In case <span class="math">b^{i} = 0</span> aborts <span class="math">(\\mathsf{abort}_i)</span>. Otherwise <span class="math">\\delta^i</span> is computed normally from</p>

    <p class="text-gray-300">ClntNode.ApplyUpdate <span class="math">(\\delta^{i - 1},\\mathsf{op}^i,\\varDelta^i,\\Upsilon_{\\varDelta}^i)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for <span class="math">\\mathsf{op}^i = \\mathsf{add}</span>: <span class="math">\\varDelta^i := (K, \\mathsf{F}_{K^i}^i)</span>, <span class="math">\\Upsilon_{\\varDelta}^{i} := \\varnothing</span> and everything is the same as in <span class="math">G_{i - 1}</span>. I.e. <span class="math">(b^{i},\\delta^{i})</span> is the output of ClntNode.ApplyUpdate <span class="math">(\\delta^{i - 1},\\mathsf{op}^i,\\varDelta^i,\\Upsilon_{\\varDelta}^i)</span>.</li>

      <li><span class="math">\\mathsf{op}^i = \\mathsf{del}</span>: <span class="math">\\varDelta^i:=K^i</span>, <span class="math">\\Upsilon_{\\Delta}^{i}:=(\\mathsf{F}_{K^{i}}^{i-1}, \\pi_{K^{i}}^{i-1})</span>. Similarly to the mod case <span class="math">b^{i}</span> is the output of:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b ^ {i} \\leftarrow \\left(a _ {K ^ {i}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\right) \\wedge \\left(b _ {K ^ {i}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\right) \\wedge \\left(K ^ {i} = \\left\\{n ^ {i - 1} -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K ^ {i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1, \\dots , n ^ {i - 1} \\right\\}\\right)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $(a,b)\\gets \\mathsf{PartndPrimeProd}([</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{F}^{i - 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">],\\mathsf{F}^{i - 1})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In case <span class="math">b^{i} = 0</span> aborts <span class="math">(\\mathsf{abort}_i)</span>. Otherwise <span class="math">\\delta^i</span> is computed normally from</p>

    <p class="text-gray-300">ClntNode.ApplyUpdate <span class="math">(\\delta^{i - 1},\\mathsf{op}^i,\\varDelta^i,\\Upsilon_{\\varDelta}^i)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{op}^i = \\mathsf{cfrom}</span>: <span class="math">\\varDelta^i:=K^i</span>, <span class="math">\\Upsilon_{\\Delta}^{i}:=(\\delta^{i},\\pi_{\\mathsf{PoKSubV&#x27;}}^i)</span> but in the <span class="math">i</span>-th step of EvalHistory <span class="math">b^{i}</span> is instead:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b ^ {i} \\leftarrow \\left(\\mathsf {F} _ {K ^ {i}} ^ {i - 1} \\subseteq \\mathsf {F} ^ {i - 1}\\right) \\wedge \\delta^ {i} = \\mathsf {V C . C o m} ^ {\\prime} (\\mathsf {p p}, \\mathsf {F} _ {K ^ {i}} ^ {i - 1}) \\wedge J = \\{1, \\ldots ,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">In case <span class="math">b^{i} = 0</span> aborts <span class="math">(\\mathsf{abort}_i)</span>.</p>

    <p class="text-gray-300"><strong>Lemma 8.1.</strong> Let <span class="math">\\mathsf{op}^i = \\mathsf{mod}</span> then if the strong RSA assumption holds for <span class="math">\\mathsf{Ggen}</span>, <span class="math">\\operatorname<em>{Pr}[G_{i - 1} = 1] \\leq \\operatorname</em>{Pr}[G_i = 1] + \\mathsf{negl}(\\lambda)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof</strong> It is straightforward that the only difference between <span class="math">G_{i-1}</span> and <span class="math">G_i</span> is in the computation of <span class="math">b^i</span> inside the EvalHistory. That is in <span class="math">G_{i-1}: b^i = (\\Gamma_{K^i}^{a_{K^i}} = \\delta_1^{i-1}) \\wedge (\\Delta_{K^i}^{b_{K^i}} = \\delta_2^{i-1})</span> and in $G_i: b^i = (a_{K^i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a) \\wedge (b_{K^i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b)<span class="math">. Since </span>\\mathsf{abort}_1, \\mathsf{abort}_2, \\ldots, \\mathsf{abort}_{i-2}<span class="math"> have not happen, from correctness of the VDS scheme it comes that </span>(\\delta_1^{i-1}, \\delta_2^{i-1}) = (g_0^a, g_1^b)<span class="math">, where </span>(a,b) \\gets \\mathsf{PartndPrimeProd}([</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{F}^{i-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">], \\mathsf{F}^{i-1})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname<em>{Pr}[G_{i-1}=1]-\\operatorname</em>{Pr}[G_i=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\operatorname<em>{Pr}[\\mathsf{abort}_i]=\\operatorname</em>{Pr}[b^i=0]=\\operatorname*{Pr}[(a_{K^i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a)\\wedge(b_{K^i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b)]<span class="math">. But since </span>\\mathsf{abort}_{i-1}<span class="math"> didn&#x27;t happen </span>(\\Gamma_{K^i}^{a_{K^i}}=g_0^a)\\wedge(\\varDelta_{K^i}^{b_{K^i}}=g_1^b)<span class="math">. Therefore it is straightforward to </span>\\mathsf{abort}_i<span class="math"> to the strong RSA assumption, i.e. </span>\\operatorname*{Pr}[\\mathsf{abort}_i]=\\mathsf{negl}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lemma 8.2. Let <span class="math">\\mathsf{op}^i = \\mathsf{del}</span> then if the strong RSA assumption holds for <span class="math">\\mathsf{Ggen}</span>, <span class="math">\\operatorname<em>{Pr}[G_{i-1} = 1] \\leq \\operatorname</em>{Pr}[G_i = 1] + \\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Proof The same as the above case of <span class="math">\\mathsf{op}^i = \\mathsf{mod}</span> holds.</p>

    <p class="text-gray-300">Lemma 8.3. Let <span class="math">\\mathsf{op}^i = \\mathsf{add}</span> then <span class="math">\\operatorname<em>{Pr}[G_{i-1} = 1] = \\operatorname</em>{Pr}[G_i = 1]</span>.</p>

    <p class="text-gray-300">Proof <span class="math">G_{i - 1}</span> and <span class="math">G_{i}</span> are identical.</p>

    <p class="text-gray-300">Lemma 8.4. Let <span class="math">\\mathsf{op}^i = \\mathsf{cfrom}</span> then for any PPT <span class="math">\\mathcal{A}</span> in <span class="math">G_{i}</span> there exists an algorithm <span class="math">\\mathcal{E}</span> such that <span class="math">\\operatorname<em>{Pr}[G_{i-1} = 1] \\leq \\operatorname</em>{Pr}[G_i = 1] + \\mathsf{negl}(\\lambda)</span> of the strong RSA assumption holds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Let <span class="math">\\mathcal{E}</span> be the extractor of <span class="math">\\mathsf{PoKSubV}&#x27;</span> protocol that corresponds to <span class="math">\\mathcal{A}</span>. Since <span class="math">\\mathsf{PoKSubV}&#x27;</span> is knowledge sound, <span class="math">\\mathcal{E}</span> outputs <span class="math">(\\vec{\\mathsf{F}}_{K^i}^{i-1}, \\pi_{K^i}, \\pi_{K^i}&#x27;)</span> such that $\\mathsf{VC.Ver}'(\\mathsf{pp}, \\delta^{i-1}, K^i, \\vec{\\mathsf{F}}_{K^i}^{i-1}, \\pi_{K^i}) = 1 \\wedge \\mathsf{VC.Ver}'(\\mathsf{pp}, \\delta^i, K^i, \\vec{\\mathsf{F}}_{K^i}^{i-1}, \\pi_{K^i}') = 1 \\wedge</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathsf{F}}_{K^i}^{i-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n'<span class="math">, where </span>\\delta^i = (\\delta^{*i}, n^i)<span class="math">. Since </span>\\mathsf{abort}_1, \\mathsf{abort}_2, \\ldots, \\mathsf{abort}_{i-2}<span class="math"> have not happen, from correctness of the VDS scheme it comes that </span>\\delta^{i-1} = \\mathsf{VC.Com}'(\\mathsf{pp}, \\mathsf{F}^{i-1})<span class="math">. From the first verification equation above we get that under strong RSA assumption </span>\\mathsf{F}_{K_i}^{i-1} \\subseteq \\mathsf{F}^{i-1}<span class="math">. From the second verification equation above we get that </span>\\mathsf{F}_{K_i}^{i-1}<span class="math"> is an opening of </span>\\delta^i<span class="math">. From the third equation above we get that </span>\\delta^i<span class="math"> is a digest for a file of size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{F}_{K_i}^{i-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. From the last two points we get that </span>\\delta^i = \\mathsf{VC.Com}'(\\mathsf{pp}, \\mathsf{F}_{K^i}^{i-1})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">So <span class="math">\\operatorname<em>{Pr}[G_{i - 1} = 1]\\leq \\operatorname</em>{Pr}[G_i = 1] + \\mathsf{negl}(\\lambda)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We conclude that in any case <span class="math">\\operatorname<em>{Pr}[G_{i-1} = 1] \\leq \\operatorname</em>{Pr}[G_i = 1] + \\mathsf{negl}(\\lambda)</span>. Since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\ell = \\mathsf{poly}(\\lambda)<span class="math"> with a hybrid argument we get that </span>\\operatorname<em>{Pr}[G_0 = 1] \\leq \\operatorname</em>{Pr}[G_\\ell = 1] + \\mathsf{negl}(\\lambda)<span class="math">. But clearly </span>G_\\ell = 0<span class="math"> always (since no abort has happened), and thus </span>\\operatorname*{Pr}[\\mathsf{VDS-Security}_{\\mathsf{VDS}}^A (\\lambda) = 1] = P[G_0 = 1] = \\mathsf{negl}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-39" class="text-2xl font-bold">8.2 Our Second VDS Construction</h2>

    <p class="text-gray-300">To construct our second VDS scheme, denoted <span class="math">\\mathsf{VDS}_2</span>, we build on our second SVC scheme from section 5.2. The main difficulty that we face in turning our SVC into a VDS is the specialization phase of the CRS, i.e. the trusted generation of <span class="math">U = g^{\\prod_{i\\in [n]}e_i}</span>. Although VDS schemes can support a trusted setup phase, it can only be done once by the Bootstrap algorithm. However, <span class="math">U</span> depends on the current size of the file (though not on its content), meaning that normally at each addition (or deletion) to the file it should be updated<span class="math">^{22}</span>. To solve this problem, we attach <span class="math">U</span> to the VDS's digest (together with <span class="math">n</span> for technical reasons), <span class="math">\\delta = ((U,C),n)</span>.</p>

    <p class="text-gray-300">Then, <span class="math">U</span> can be built progressively while the file is extended or reduced. Namely, when adding new positions from the set <span class="math">K</span> to the file, all <span class="math">e_i</span>'s in <span class="math">K</span> are added to the accumulator, i.e. <span class="math">U&#x27; \\gets U^{\\prod_{i \\in K} e_i}</span>. The definition of VDS security (def. 7.6) ensures that the digest is evaluated honestly which ensures that <span class="math">U</span> has the correct form <span class="math">U = g^{\\prod_{i \\in n} e_i}</span>.</p>

    <p class="text-gray-300">Finally, we make use of the dynamic properties of the [CF13, LM19] scheme (in which our SVC builds) and the RSA Accumulator, to construct the VDS scheme. The latter is important if</p>

    <p class="text-gray-300"><span class="math">^{22}</span> Another solution would be to recompute it at the verification time, but it would require linear work, which contradicts VDS requirements.</p>

    <p class="text-gray-300">one notice that <span class="math">U = g^{\\prod_{i\\in [n]}e_i}, S_I = g^{\\prod_{i\\in [n]\\setminus I}e_i}</span> resemble an RSA Accumulator value and witness respectively.</p>

    <p class="text-gray-300"><strong>Our scheme VDS₂.</strong> In the following <span class="math">\\delta := ((U, C), n)</span>, <span class="math">\\mathsf{st} := \\pi_I</span>, where <span class="math">\\pi_I := (S_I, \\Lambda_I)</span>. Also, each <span class="math">e_i</span> is computed as <span class="math">e_i \\gets \\mathsf{PrimeGen}(i)</span>; so <span class="math">\\mathsf{PrimeGen}(i)</span> is omitted for simplicity in the description. VC.Agg, VC.Disagg are the aggregation and disaggregation algorithms defined in section 5.2. We highlight that possession of <span class="math">S_I</span> allows anyone to compute <span class="math">S_J \\gets S_I^{\\prod_{j \\in I \\setminus J} e_j}</span> for each <span class="math">J \\subseteq I</span>, thus for simplicity we omit explicitly refer to the procedure of computing any such <span class="math">S_J</span>.</p>

    <p class="text-gray-300">Bootstrap <span class="math">(1^{\\lambda},\\ell)\\to (\\mathsf{pp},\\delta_0,n_0,\\mathsf{st}_0)</span> generates a hidden order group <span class="math">\\mathbb{G}\\gets \\mathsf{Ggen}(1^{\\lambda})</span> and samples a generator <span class="math">g\\gets \\mathbb{G}</span>. It also determines a deterministic collision resistant function PrimeGen that maps integers to primes of <span class="math">\\ell +1</span> bits. Set <span class="math">n_0\\gets 0</span>, <span class="math">\\delta_0\\gets ((1,g),n_0)</span> and <span class="math">\\mathsf{st}_0\\gets g</span>.</p>

    <p class="text-gray-300">StrgNode.AddStorage( <span class="math">\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, Q, \\mathsf{F}_Q, \\pi_Q) \\to (\\mathsf{st}&#x27;, J, \\mathsf{F}_J)</span> aggregates the parameters and the opening proofs</p>

    <div class="my-4 text-center"><span class="math-block">S_{I \\cup Q} \\leftarrow \\text{ShamirTrick}(S_I, S_Q, \\prod_{i \\in I} e_i, \\prod_{i \\in Q} e_i) \\text{ and } \\Lambda_{I \\cup Q} \\leftarrow \\text{VC.Agg}((S_I, S_J), (I, \\mathsf{F}_I, \\Lambda_I), (J, \\mathsf{F}_J, \\Lambda_J))</span></div>

    <p class="text-gray-300">StrgNode.RmvStorage( <span class="math">\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, K) \\to (\\mathsf{st}&#x27;, J, \\mathsf{F}_J)</span> disaggregates</p>

    <div class="my-4 text-center"><span class="math-block">S_J \\leftarrow S_I^{\\prod_{i \\in I \\cap K} e_i} \\text{ and } \\Lambda_J \\leftarrow \\text{VC.Disagg}(S_J, I, \\mathsf{F}_I, \\Lambda_I, J)</span></div>

    <p class="text-gray-300">StrgNode.PushUpdate( <span class="math">\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, \\mathsf{op}, \\Delta) \\to (\\delta&#x27;, n&#x27;, \\mathsf{st}&#x27;, J, \\mathsf{F}_J&#x27;, \\Upsilon_{\\Delta})</span> the algorithm works according to the type of update operation <span class="math">\\mathsf{op}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{op} = \\mathsf{mod}</span>: <span class="math">\\Delta := (K, \\mathsf{F}_K&#x27;)</span>.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">C&#x27; \\leftarrow C \\cdot \\prod_{i \\in K} S_i^{\\mathsf{F}_i&#x27; - \\mathsf{F}_i}, \\qquad U&#x27; \\leftarrow U, \\qquad \\Lambda_I&#x27; \\leftarrow \\Lambda_I, \\qquad S_I&#x27; \\leftarrow S_I, \\qquad \\Upsilon_{\\Delta} \\leftarrow (\\mathsf{F}_K, S_K)</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{op} = \\mathsf{add}</span>: <span class="math">\\Delta := (K, \\mathsf{F}_K&#x27;)</span>.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">C&#x27; \\leftarrow C \\cdot \\prod_{j \\in K} S_j^{\\mathsf{F}_j}, \\qquad U&#x27; \\leftarrow U^{\\prod_{i \\in K} e_i}, \\qquad \\Lambda_I&#x27; \\leftarrow \\Lambda_I, \\qquad S_I&#x27; \\leftarrow S_I, \\qquad \\Upsilon_{\\Delta} \\leftarrow S_K</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{op} = \\mathsf{del}</span>: <span class="math">\\Delta := K</span>.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">C&#x27; \\leftarrow \\frac{C}{\\prod_{j \\in K} S_j^{\\mathsf{F}_j}}, \\qquad U&#x27; \\leftarrow S_I^{\\prod_{i \\in I \\setminus K} e_i} = S_K, \\qquad \\Lambda_I&#x27; \\leftarrow \\Lambda_I^{\\prod_{j \\in K} e_j}, \\qquad S_I&#x27; \\leftarrow S_I, \\qquad \\Upsilon_{\\Delta} \\leftarrow (\\mathsf{F}_K, S_K)</span></div>

    <p class="text-gray-300">StrgNode.ApplyUpdate( <span class="math">\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, \\mathsf{op}, \\Delta, \\Upsilon_{\\Delta}) \\to (b, \\delta&#x27;, n&#x27;, \\mathsf{st}&#x27;, J, \\mathsf{F}_J&#x27;)</span> Again, it works according to the type of update operation <span class="math">\\mathsf{op}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{op} = \\mathsf{mod}</span>: <span class="math">\\Delta := (K, \\mathsf{F}_K&#x27;)</span> and <span class="math">\\Upsilon_{\\Delta} := S_K</span>. Compute <span class="math">b \\gets (S_K^{\\prod_{j \\in K} e_j} = U)</span> and if <span class="math">b = 1</span>:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">C&#x27; \\leftarrow C \\cdot \\prod_{i \\in K} S_i^{\\mathsf{F}_i&#x27; - \\mathsf{F}_i}, \\quad U&#x27; \\leftarrow U, \\quad \\Lambda_I&#x27; \\leftarrow \\Lambda_I \\cdot \\prod_{j \\in K \\setminus I} \\left(S_j^{1 / \\prod_{i \\in I} e_i}\\right)^{\\mathsf{F}_j&#x27; - \\mathsf{F}_j}, \\quad S_I&#x27; \\leftarrow S_I</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{op} = \\mathsf{add}</span>: <span class="math">\\Delta := (K, \\mathsf{F}_K&#x27;)</span> and <span class="math">\\Upsilon_{\\Delta} := S_K</span>. Compute <span class="math">b \\gets (S_K^{\\prod_{j \\in K} e_j} = U)</span> and if <span class="math">b = 1</span>:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">C&#x27; \\leftarrow C \\cdot \\prod_{j \\in K} S_j^{\\mathsf{F}_j}, \\quad U&#x27; \\leftarrow U^{\\prod_{i \\in K} e_i}, \\quad \\Lambda_I&#x27; \\leftarrow \\Lambda_I \\cdot \\prod_{j \\in K} \\left(S_j^{1 / \\prod_{i \\in I} e_i}\\right)^{\\mathsf{F}_j}, \\qquad S_I&#x27; \\leftarrow S_I^{\\prod_{i \\in K} e_i}</span></div>

    <p class="text-gray-300">where <span class="math">S_j^{1 / \\prod_{i\\in I}e_i} = \\mathbf{ShamirTrick}(S_I,S_j,\\prod_{i\\in I}e_i,e_j)</span> for each <span class="math">j\\in K</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{op} = \\mathsf{del}</span>: <span class="math">\\Delta := K</span> and <span class="math">\\Upsilon_{\\Delta} := (\\mathsf{F}_K, S_K)</span>. Compute <span class="math">b \\gets (S_K^{\\prod_{j \\in K} e_j} = U)</span> and if <span class="math">b = 1</span>:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">C&#x27; \\leftarrow \\frac{C}{\\prod_{j \\in K} S_j^{\\mathsf{F}_j}}, \\qquad U&#x27; \\leftarrow S_K,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Lambda_I&#x27; \\leftarrow \\frac{\\Lambda_I^{\\prod_{i \\in K \\cap I} e_i}}{\\prod_{j \\in K \\setminus I} \\left(S_j^{1 / \\prod_{i \\in K \\cap I} e_i}\\right)^{\\mathsf{F}_j}}, \\qquad S_I&#x27; \\leftarrow \\mathbf{ShamirTrick}(S_I, S_{K \\setminus I}, \\prod_{i \\in I} e_i, \\prod_{i \\in K \\setminus I} e_i)</span></div>

    <p class="text-gray-300">StrgNode.Retrieve<span class="math">(\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, Q) \\to (\\mathsf{F}_Q, \\pi_Q)</span> disaggregates</p>

    <div class="my-4 text-center"><span class="math-block">S_Q \\leftarrow S_I^{\\prod_{i \\in I \\setminus Q} e_i} \\text{ and } \\Lambda_Q \\leftarrow \\mathsf{VC.Disagg}(S_Q, I, \\mathsf{F}_I, \\Lambda_I, Q)</span></div>

    <p class="text-gray-300">The algorithms for client nodes are:</p>

    <p class="text-gray-300">ClntNode.VerRetrieve<span class="math">(\\delta, Q, \\mathsf{F}_Q, \\pi_Q) \\to b</span> output</p>

    <div class="my-4 text-center"><span class="math-block">b \\leftarrow \\mathsf{VC.Ver}(\\mathsf{pp}, C, Q, \\mathsf{F}_Q, \\Lambda_Q) \\wedge S_Q^{\\prod_{i \\in Q} e_i} = U</span></div>

    <p class="text-gray-300">ClntNode.ApplyUpdate<span class="math">(\\delta, \\mathsf{op}, \\Delta, \\Upsilon_{\\Delta}) \\to (b, \\delta&#x27;)</span> This algorithm is almost identical to the first part of the Storage Node algorithm StrgNode.ApplyUpdate<span class="math">(\\delta, n, \\mathsf{st}, I, \\mathsf{F}_I, \\mathsf{op}, \\Delta, \\Upsilon_{\\Delta})</span>. The difference is that it executes only the parts that are related to the output of <span class="math">b</span> and <span class="math">\\delta</span>.</p>

    <p class="text-gray-300">AggregateCertificates<span class="math">(\\delta, (I, \\mathsf{F}_I, \\pi_I), (J, \\mathsf{F}_J, \\pi_J)) \\to \\pi_K</span> return</p>

    <div class="my-4 text-center"><span class="math-block">S_{I \\cup J} \\leftarrow \\mathbf{ShamirTrick}(S_I, S_J, \\prod_{i \\in I} e_i, \\prod_{i \\in J} e_i) \\text{ and } \\Lambda_K \\leftarrow \\mathsf{VC.Agg}\\left((S_I, S_J), (I, \\vec{\\mathsf{F}}_I, \\Lambda_I), (J, \\vec{\\mathsf{F}}_J, \\Lambda_J)\\right)</span></div>

    <p class="text-gray-300">We note that we do not define an efficient StrgNode.CreateFrom operation for the <span class="math">\\mathsf{VDS}_2</span> construction. While general-purpose SNARKs would work to achieve this result, they would be extremely expensive. We leave it as an open problem to find an efficient argument of knowledge of subvector opening for this scheme.</p>

    <p class="text-gray-300">Theorem 8.3 (VDS₂). Let <span class="math">\\mathbb{G} \\gets \\mathsf{Ggen}(1^{\\lambda})</span> be a hidden order group where the strong Distinct-Prime-Product Root and the Low Order assumptions hold. Then the VDS scheme presented above is a correct and secure Verifiable Decentralized Storage scheme.</p>

    <p class="text-gray-300">The intuition of the above theorem is as follows: the VDS scheme can be seen as preserving and updating a vector commitment <span class="math">C</span> and an RSA Accumulator <span class="math">U</span>. So correctness of VDS comes from correctness of the updatable vector commitment SVC and correctness of updates of the RSA Accumulator (see [BBF19]). Similarly, security comes from security of SVC and the RSA accumulator's security, which in turn rely on the strong distinct-prime-product root assumption and the</p>

    <p class="text-gray-300">58</p>

    <p class="text-gray-300">strong RSA assumption respectively. Note that strong Distinct-Prime-Product Root implies strong RSA (the opposite also holds in RSA groups).</p>

    <p class="text-gray-300">Recall that <span class="math">U</span> is an RSA accumulator of all <span class="math">e_{i}</span>’s and is used to verify <span class="math">S_{I}</span>’s. The RSA accumulator’s security demands that the accumulated value <span class="math">U</span> is honestly computed, which is ensured in the VDS setting since we assume a valid history. So given a valid history one knows that <span class="math">U</span> is of correct form (i.e. <span class="math">U=g^{\\prod_{i\\in[n]}e_{i}}</span>) and then can securely check that <span class="math">S_{I}</span> is of correct form (by checking <span class="math">S_{I}^{\\prod_{i\\in I}e_{i}}=U</span>), which is ensured from RSA Accumulator’s security. After checking the validity of <span class="math">S_{I}</span> it all boils down to position binding of the vector commitment. To conclude, the gap between position binding of the original VC and security of our VDS construction is to ensure that <span class="math">S_{I}</span> is well formed, which in turn relies on the correct form of <span class="math">U</span>.</p>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">8.3 Efficiency and Comparison</h3>

    <p class="text-gray-300">In Table 3 we provide a detailed efficiency analysis and comparison of the two VDS schemes, <span class="math">\\mathsf{VDS}_{1}</span> and <span class="math">\\mathsf{VDS}_{2}</span>, proposed in the two earlier sections.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In terms of performances, the two schemes do similarly, though <span class="math">\\mathsf{VDS}_{2}</span> outperforms the first one by a logarithmic factor. Its efficiency advantage comes from the fact that operations are not bit-by-bit as in the first one. More in detail, in <span class="math">\\mathsf{VDS}_{1}</span> most of the operations require one exponentiation with an <span class="math">\\alpha</span>-bit prime for each bit and each position of the subfile, roughly $O(\\ell\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\alpha)<span class="math"> group operations. In </span>\\mathsf{VDS}_{2}<span class="math">, the main overhead is related to handling the distributed parameters </span>\\{S_{i}\\}<span class="math">. In fact, computing </span>S_{i}<span class="math"> for each </span>i\\in I<span class="math">, given </span>S_{I}<span class="math"> takes </span>O(I\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> exponentiations with </span>(\\ell+1)<span class="math">-bit primes, roughly </span>O(\\ell\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To compare the two methods, recall that <span class="math">\\alpha</span> is at least <span class="math">\\log(\\ell n)</span> (since we need at least <span class="math">\\ell n</span> distinct primes), which means that <span class="math">\\mathsf{VDS}_{1}</span> has a (logarithmic) dependence on the size of the file. On the other hand, <span class="math">\\mathsf{VDS}_{2}</span>’s cost depends only on the size of the subfile that is processed. Hence, since $\\alpha>\\log(\\ell n)>\\log(n)\\geq\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> the </span>\\mathsf{VDS}_{2}<span class="math"> always outperforms </span>\\mathsf{VDS}_{1}$ (see Table 3).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Another notable difference regards the StrgNode.PushUpdate algorithm for <span class="math">\\mathsf{op}=\\mathsf{mod}</span>. In <span class="math">\\mathsf{VDS}_{2}</span>, the running time depends solely on the size of the update, whereas in <span class="math">\\mathsf{VDS}_{1}</span> it depends on the size of the entire subfile stored locally. This can be a huge difference for nodes that decide to store large portions, and it constitutes a major theoretical (and practical) improvement of <span class="math">\\mathsf{VDS}_{2}</span> over <span class="math">\\mathsf{VDS}_{1}</span>.</p>

    <p class="text-gray-300">In terms of security, <span class="math">\\mathsf{VDS}_{1}</span> is based on a weaker assumption, over groups of unknown order, than <span class="math">\\mathsf{VDS}_{2}</span> (although for the specific case of RSA groups the two assumptions are equivalent). Finally, in terms of functionality, <span class="math">\\mathsf{VDS}_{1}</span> is the only scheme that can support efficiently the StrgNode.CreateFrom functionality and the (compact) Proofs of Data Possession; this is thanks to its compatibility with the efficient succinct arguments of knowledge that we propose in section 6.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Metric</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VDS1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VDS2</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bootstrap</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">pp</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Digest</td>

            <td class="px-3 py-2 border-b border-gray-700">δ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">+ log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">+ log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Storage Node storing (I, F1)  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">State</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">stI</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">StrgNode.RmvStorage (K)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·α·</td>

            <td class="px-3 py-2 border-b border-gray-700">K</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·</td>

            <td class="px-3 py-2 border-b border-gray-700">K</td>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">K</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">StrgNode.CreateFrom (J)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·α·</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">no1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">YJ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">+ 2</td>

            <td class="px-3 py-2 border-b border-gray-700">Z2λ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">StrgNode.PushUpdate (Δ)</td>

            <td class="px-3 py-2 border-b border-gray-700">mod</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·α·</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">add</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·α·</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">del</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·α·(</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">))</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·(</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">YΔ</td>

            <td class="px-3 py-2 border-b border-gray-700">mod, del</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">) + 2·</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">) + 1·</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">add</td>

            <td class="px-3 py-2 border-b border-gray-700">∅</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">StrgNode.ApplyUpdate (Δ)</td>

            <td class="px-3 py-2 border-b border-gray-700">mod</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·α·(</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">))</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·(</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">add</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·α·</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·(</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">del</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·α·(</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">))</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·(</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">StrgNode.Retrieve (Q)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·α·(</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Q</td>

            <td class="px-3 py-2 border-b border-gray-700">))</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·(</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Q</td>

            <td class="px-3 py-2 border-b border-gray-700">) log(</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Q</td>

            <td class="px-3 py-2 border-b border-gray-700">))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">πQ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Client Node  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ClntNode.GetCreate (J)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(ℓ·α·</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">no1</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ClntNode.ApplyUpdate (Δ) (mod, add, del)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·α·</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AggregateCertificates (I, J)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·α·(</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">J</td>

            <td class="px-3 py-2 border-b border-gray-700">))</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·(</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">J</td>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">J</td>

            <td class="px-3 py-2 border-b border-gray-700">))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PoR</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PDP</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">no1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3. Comparison between our two VDS schemes. The running time is expressed in number of  <span class="math">\\mathbb{G}</span> -group operations. Notation for the sets of positions:  <span class="math">I</span>  are the ones held by the storage node,  <span class="math">K</span>  the ones added or removed from local storage by the storage node,  <span class="math">J</span>  the ones used to create the file in StrgNode.CreateFrom,  <span class="math">\\Delta</span>  the updated ones, and  <span class="math">Q</span>  the ones of a retrieval query. In  <span class="math">\\mathrm{VDS}_1</span> ,  <span class="math">\\alpha</span>  denotes the size of the primes (returned by PrimeGen); so  <span class="math">\\alpha \\geq \\log(n\\ell)</span>  where  <span class="math">n</span>  is the size of the file and  <span class="math">\\ell</span>  the bit-size of each position (i.e.  <span class="math">\\mathsf{F} \\in (\\{0,1\\}^{\\ell})^n</span> ). 1 Such a protocol exists but it is either inefficient for the prover (SNARKs) or it has a large overhead in communication complexity ( <span class="math">\\Sigma</span> -protocols or PoKE*-based ones).</p>

    <p class="text-gray-300">We have implemented in Rust our new SVC scheme of section 5.1 (with and without preprocessing) and the recent SVC of [BBF19] (referred as BBF in what follows). Here we discuss an experiment</p>

    <p class="text-gray-300">tal evaluation of these three schemes. 24 Below is a summary of the comparison, details of the experiments are in Appendix F.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Our SVC construction is faster in opening and verification than BBF (up to <span class="math">2.5 \\times</span> and <span class="math">2.3 \\times</span> faster respectively), but at the cost of a slower commitment stage (up to <span class="math">6 \\times</span> slower). These differences tend to flatten for larger vectors and opening sizes.</li>

      <li>Our SVC construction with preprocessing allows for extremely fast opening times compared to non-preprocessing constructions. Namely, it can reduce the running time by several orders of magnitude for various choices of vector and opening sizes, allowing to obtain practical opening times—of the order of seconds—that would be impossible without preprocessing—of the order of hundred of seconds. In a file of 1 Mbit (<span class="math">2^{20}</span> bits), preprocessing reduces the time to open 2048 bits from one hour to less than 5 seconds! This efficient opening, however, comes at the cost of a one-time preprocessing (during commitment) and higher storage requirements. We discuss how to mitigate these space requirements by trading for opening time and/or communication complexity later in this section. We stress that it is thanks to the incremental aggregation property of our construction that allows these tradeoffs (they are not possible in BBF with preprocessing).</li>

      <li>Although our SVC construction with preprocessing has an expensive commitment stage, this tends to be amortized throughout very few openings <span class="math">^{25}</span>, as few as 30 (see Figure 9 in Appendix F). These effects are particularly significant over a higher number of openings: over 1000 openings our SVC construction with preprocessing has an amortized cost of less than 6 seconds, while our SVC construction and BBF have amortized openings above 90 seconds.</li>

    </ul>

    <h2 id="sec-42" class="text-2xl font-bold">Mitigating Space Requirements for Preprocessing Construction</h2>

    <p class="text-gray-300">Our experiments show that preprocessing improves opening time. This comes at the cost of storing an auxiliary information—<span class="math">N</span> openings—which, in spite of being much smaller than in BBF, can still be quite large. Here we discuss two general ways to mitigate this storage cost, which can be used either separately or together.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Hashing in blocks.</strong> Let us recall that by selecting a block size <span class="math">\\ell = 2\\lambda</span> (e.g., 256) one can combine our VC with a collision-resistant hash function and support larger vectors at virtually the same cost. Concretely, given a vector <span class="math">\\vec{v}</span> of <span class="math">N</span> blocks, each of <span class="math">\\ell_H</span> bits, one can obtain a vector <span class="math">\\vec{v}&#x27; \\in (\\{0,1\\}^\\ell)^N</span> by hashing each <span class="math">\\ell_H</span>-bits block into a <span class="math">\\ell</span>-bits one. The downside of this approach is that subvector openings with respect to the original vector <span class="math">\\vec{v}</span> are less fine grained. On the good side, though, one gets that the efficiency of a VC for a vector of size <span class="math">N \\cdot \\ell_H</span> is virtually the same <span class="math">^{26}</span> as the one for a VC for a vector of size <span class="math">N2\\lambda</span>. For example, by selecting <span class="math">\\ell_H = 2</span> Kibit our timings for a vector of 262144 bits would work for one of 1 Mbit. This would yield a committing/preprocessing time of roughly 10 minutes. These advantages also translate opening times: for example, if we expect openings of roughly <span class="math">M = 2^{11}</span> bits we can expect a virtually instantaneous opening time (as we just need to look up a cached precomputed proof). A larger opening size such as <span class="math">M = 2^{14}</span> (resp. <span class="math">M = 2^{17}</span>) bits, would yield a running time of roughly 4 seconds (resp. 70 seconds).</li>

    </ul>

    <p class="text-gray-300"><span class="math">^{24}</span> We did not include BBF with precomputation in our experimental evaluation because this scheme has worse performances than our preprocessing construction in terms of both required storage and running time. We elaborate on this in Appendix F.</p>

    <p class="text-gray-300"><span class="math">^{25}</span> Amortized opening time roughly represents how computationally expensive a scheme is “in total” throughout all its operations. Amortized opening time for <span class="math">m</span> openings is the cost of one commitment plus the cost of <span class="math">m</span> openings, all averaged over the <span class="math">m</span> openings.</p>

    <p class="text-gray-300"><span class="math">^{26}</span> This is because the cost of hashing is negligible compared to group operations.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Selecting larger precomputed chunks. Another possibility to reduce storage is to precompute less openings by storing more aggregated openings, namely instead of an opening for every chunk of <span class="math">\\ell</span> bits, store one opening for every chunk of <span class="math">B \\cdot \\ell</span> bits. This technique requires a bit more computation in order to compute disaggregations—about <span class="math">m(B - 1)</span> <span class="math">\\mathbb{G}</span> operations in the worst case for <span class="math">m</span> positions (cf. Section B)—but opens the way to various tradeoffs to be explored. For instance, one could use certain application-dependent heuristics to choose which positions to precompute aggregated. As an example in the VC application to proofs of space and replication [Fis19] one opens a set of randomly chosen positions, and for each of them, also a set of predetermined positions.²⁷</li>

    </ul>

    <h2 id="sec-43" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">We thank Ben Fisch for valuable clarifications about the notions of Proof of Retrievable Commitment and Proof of Replication, and Justin Drake for pointing out the need (due to the attack discussed in [BBF18]) of using a hash function mapping into <span class="math">\\mathsf{Primes}(2\\lambda)</span> in the Fiat-Shamir transformation when making our succinct arguments of knowledge non-interactive.</p>

    <p class="text-gray-300">Research leading to these results has been partially supported by the Spanish Government under projects SCUM (ref. RTI2018-102043-B-I00), CRYPTOEPIC (refs. ERC2018-092822, EUR2019-103816), and SECURITAS (ref. RED2018-102321-T), by the Madrid Regional Government under project BLOQUES (ref. S2018/TCS-4339), and by research gifts from Protocol Labs.</p>

    <h2 id="sec-44" class="text-2xl font-bold">References</h2>

    <p class="text-gray-300">ABC⁺⁰⁷. G. Ateniese, R. C. Burns, R. Curtmola, J. Herring, L. Kissner, Z. N. J. Peterson, and D. Song. Provable data possession at untrusted stores. In P. Ning, S. De Capitani di Vimercati, and P. F. Syverson, editors, ACM CCS 2007, pages 598–609. ACM Press, October 2007.</p>

    <p class="text-gray-300">ABC⁺¹¹. G. Ateniese, R. Burns, R. Curtmola, J. Herring, O. Khan, L. Kissner, Z. Peterson, and D. Song. Remote Data Checking Using Provable Data Possession. ACM Trans. Inf. Syst. Secur., 14(1):12:1–12:34, June 2011.</p>

    <p class="text-gray-300">BBF¹⁸. D. Boneh, B. Bünz, and B. Fisch. A Survey of Two Verifiable Delay Functions. Cryptology ePrint Archive, Report 2018/712, 2018. https://eprint.iacr.org/2018/712.</p>

    <p class="text-gray-300">BBF¹⁹. D. Boneh, B. Bünz, and B. Fisch. Batching Techniques for Accumulators with Applications to IOPs and Stateless Blockchains. In A. Boldyreva and D. Micciancio, editors, CRYPTO 2019, Part I, volume 11692 of LNCS, pages 561–586. Springer, Heidelberg, August 2019.</p>

    <p class="text-gray-300">BCS¹⁶. E. Ben-Sasson, A. Chiesa, and N. Spooner. Interactive Oracle Proofs. In M. Hirt and A. D. Smith, editors, TCC 2016-B, Part II, volume 9986 of LNCS, pages 31–60. Springer, Heidelberg, October / November 2016.</p>

    <p class="text-gray-300">Bd94. J. C. Benaloh and M. de Mare. One-Way Accumulators: A Decentralized Alternative to Digital Sinatures (Extended Abstract). In T. Helleseth, editor, EUROCRYPT'93, volume 765 of LNCS, pages 274–285. Springer, Heidelberg, May 1994.</p>

    <p class="text-gray-300">BGR¹². K. Brogle, S. Goldberg, and L. Reyzin. Sequential Aggregate Signatures with Lazy Verification from Trapdoor Permutations - (Extended Abstract). In X. Wang and K. Sako, editors, ASIACRYPT 2012, volume 7658 of LNCS, pages 644–662. Springer, Heidelberg, December 2012.</p>

    <p class="text-gray-300">BGV¹¹. S. Benabbas, R. Gennaro, and Y. Vahlis. Verifiable Delegation of Computation over Large Datasets. In P. Rogaway, editor, CRYPTO 2011, volume 6841 of LNCS, pages 111–131. Springer, Heidelberg, August 2011.</p>

    <p class="text-gray-300">BH01. J. Buchmann and S. Hamdy. A Survey on {IQ} Cryptography, 2001.</p>

    <p class="text-gray-300">BP97. N. Bari and B. Pfitzmann. Collision-Free Accumulators and Fail-Stop Signature Schemes Without Trees. In W. Fumy, editor, EUROCRYPT'97, volume 1233 of LNCS, pages 480–494. Springer, Heidelberg, May 1997.</p>

    <p class="text-gray-300">²⁷ There, each vector entry is the node of a DAG and one opens a set of randomly chosen nodes and for each of them a given number of parents.</p>

    <p class="text-gray-300">CF13. D. Catalano and D. Fiore. Vector Commitments and Their Applications. In K. Kurosawa and G. Hanaoka, editors, PKC 2013, volume 7778 of LNCS, pages 55–72. Springer, Heidelberg, February / March 2013.</p>

    <p class="text-gray-300">CL02. J. Camenisch and A. Lysyanskaya. Dynamic Accumulators and Application to Efficient Revocation of Anonymous Credentials. In M. Yung, editor, CRYPTO 2002, volume 2442 of LNCS, pages 61–76. Springer, Heidelberg, August 2002.</p>

    <p class="text-gray-300">CMS99. C. Cachin, S. Micali, and M. Stadler. Computationally Private Information Retrieval with Polylogarithmic Communication. In J. Stern, editor, EUROCRYPT’99, volume 1592 of LNCS, pages 402–414. Springer, Heidelberg, May 1999.</p>

    <p class="text-gray-300">CS99. R. Cramer and V. Shoup. Signature Schemes Based on the Strong RSA Assumption. In J. Motiwalla and G. Tsudik, editors, ACM CCS 99, pages 46–51. ACM Press, November 1999.</p>

    <p class="text-gray-300">CSWH01. I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong. Freenet: A Distributed Anonymous Information Storage and Retrieval System, pages 46–66. Springer Berlin Heidelberg, Berlin, Heidelberg, 2001.</p>

    <p class="text-gray-300">DG20. S. Dobson and S. D. Galbraith. Trustless Groups of Unknown Order with Hyperelliptic Curves. Cryptology ePrint Archive, Report 2020/196, 2020. https://eprint.iacr.org/2020/196.</p>

    <p class="text-gray-300">DK02. I. Damgård and M. Koprowski. Generic Lower Bounds for Root Extraction and Signature Schemes in General Groups. In L. R. Knudsen, editor, EUROCRYPT 2002, volume 2332 of LNCS, pages 256–271. Springer, Heidelberg, April / May 2002.</p>

    <p class="text-gray-300">Fis18. B. Fisch. PoReps: Proofs of Space on Useful Data. Cryptology ePrint Archive, Report 2018/678, 2018. https://eprint.iacr.org/2018/678.</p>

    <p class="text-gray-300">Fis19. B. Fisch. Tight Proofs of Space and Replication. In Y. Ishai and V. Rijmen, editors, EUROCRYPT 2019, Part II, volume 11477 of LNCS, pages 324–348. Springer, Heidelberg, May 2019.</p>

    <p class="text-gray-300">FS87. A. Fiat and A. Shamir. How to Prove Yourself: Practical Solutions to Identification and Signature Problems. In A. M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 186–194. Springer, Heidelberg, August 1987.</p>

    <p class="text-gray-300">GHR99. R. Gennaro, S. Halevi, and T. Rabin. Secure Hash-and-Sign Signatures Without the Random Oracle. In J. Stern, editor, EUROCRYPT’99, volume 1592 of LNCS, pages 123–139. Springer, Heidelberg, May 1999.</p>

    <p class="text-gray-300">GKM^{+}18. J. Groth, M. Kohlweiss, M. Maller, S. Meiklejohn, and I. Miers. Updatable and Universal Common Reference Strings with Applications to zk-SNARKs. In H. Shacham and A. Boldyreva, editors, CRYPTO 2018, Part III, volume 10993 of LNCS, pages 698–728. Springer, Heidelberg, August 2018.</p>

    <p class="text-gray-300">GRWZ20. S. Gorbunov, L. Reyzin, H. Wee, and Z. Zhang. Pointproofs: Aggregating Proofs for Multiple Vector Commitments. Cryptology ePrint Archive, Report 2020/419, 2020. https://eprint.iacr.org/2020/419.</p>

    <p class="text-gray-300">JK07. A. Juels and B. S. Kaliski Jr. Pors: proofs of retrievability for large files. In P. Ning, S. De Capitani di Vimercati, and P. F. Syverson, editors, ACM CCS 2007, pages 584–597. ACM Press, October 2007.</p>

    <p class="text-gray-300">KZG10. A. Kate, G. M. Zaverucha, and I. Goldberg. Constant-Size Commitments to Polynomials and Their Applications. In M. Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 177–194. Springer, Heidelberg, December 2010.</p>

    <p class="text-gray-300">Lab17. P. Labs. Filecoin: A Decentralized Storage Network, 2017. https://filecoin.io/filecoin.pdf.</p>

    <p class="text-gray-300">Lip12. H. Lipmaa. Secure Accumulators from Euclidean Rings without Trusted Setup. In F. Bao, P. Samarati, and J. Zhou, editors, ACNS 12, volume 7341 of LNCS, pages 224–240. Springer, Heidelberg, June 2012.</p>

    <p class="text-gray-300">LM19. R. W. F. Lai and G. Malavolta. Subvector Commitments with Application to Succinct Arguments. In A. Boldyreva and D. Micciancio, editors, CRYPTO 2019, Part I, volume 11692 of LNCS, pages 530–560. Springer, Heidelberg, August 2019.</p>

    <p class="text-gray-300">LMRS04. A. Lysyanskaya, S. Micali, L. Reyzin, and H. Shacham. Sequential Aggregate Signatures from Trapdoor Permutations. In C. Cachin and J. Camenisch, editors, EUROCRYPT 2004, volume 3027 of LNCS, pages 74–90. Springer, Heidelberg, May 2004.</p>

    <p class="text-gray-300">LRY16. B. Libert, S. C. Ramanna, and M. Yung. Functional Commitment Schemes: From Polynomial Commitments to Pairing-Based Accumulators from Simple Assumptions. In I. Chatzigiannakis, M. Mitzenmacher, Y. Rabani, and D. Sangiorgi, editors, ICALP 2016, volume 55 of LIPIcs, pages 30:1–30:14. Schloss Dagstuhl, July 2016.</p>

    <p class="text-gray-300">LY10. B. Libert and M. Yung. Concise Mercurial Vector Commitments and Independent Zero-Knowledge Sets with Short Proofs. In D. Micciancio, editor, TCC 2010, volume 5978 of LNCS, pages 499–517. Springer, Heidelberg, February 2010.</p>

    <p class="text-gray-300">Mer88. R. C. Merkle. A Digital Signature Based on a Conventional Encryption Function. In C. Pomerance, editor, CRYPTO’87, volume 293 of LNCS, pages 369–378. Springer, Heidelberg, August 1988.</p>

    <p class="text-gray-300">OWB19. A. Ozdemir, R. S. Wahby, and D. Boneh. Scaling Verifiable Computation Using Efficient Set Accumulators. Cryptology ePrint Archive, Report 2019/1494, 2019. https://eprint.iacr.org/2019/1494.</p>

    <p class="text-gray-300">Sha83. A. Shamir. On the Generation of Cryptographically Strong Pseudorandom Sequences. ACM Trans. Comput. Syst., 1(1):38-44, 1983. STY01. T. Sander, A. Ta-Shma, and M. Yung. Blind, Auditable Membership Proofs. In Y. Frankel, editor, FC 2000, volume 1962 of LNCS, pages 53-71. Springer, Heidelberg, February 2001. <span class="math">\\mathrm{TAB}^{+}20</span> . A. Tomescu, I. Abraham, V. Buterin, J. Drake, D. Feist, and D. Khovratovich. Aggregatable Subvector Commitments for Stateless Cryptocurrencies. Cryptology ePrint Archive, Report 2020/527, 2020. https://eprint.iacr.org/2020/527. Tam03. R. Tamassia. Authenticated Data Structures. In G. Di Battista and U. Zwick, editors, Algorithms - ESA 2003, pages 2-5, Berlin, Heidelberg, 2003. Springer Berlin Heidelberg. Wes18. B. Wesolowski. Efficient verifiable delay functions. Cryptology ePrint Archive, Report 2018/623, 2018. https://eprint.iacr.org/2018/623.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathbb{G}</span>  be a hidden order group as generated by  <span class="math">\\mathsf{G}</span>  gen, and let  <span class="math">g_{1}, g_{2}, g_{3} \\in \\mathbb{G}</span>  be three honestly sampled random generators. A more straightforward succinct argument of knowledge for the union of RSA Accumulators is for the following relation</p>

    <div class="my-4 text-center"><span class="math-block">R _ {\\mathsf {P o P r o d}} = \\left\\{\\left(\\left(A, B, C\\right), (a, b)\\right) \\in \\mathbb {G} ^ {3} \\times \\mathbb {Z} ^ {2}: A = g _ {1} ^ {a} \\wedge B = g _ {2} ^ {b} \\wedge C = g _ {3} ^ {a \\cdot b} \\right\\}</span></div>

    <p class="text-gray-300">Our protocol PoProd is described below.</p>

    <p class="text-gray-300">Setup  <span class="math">(1^{\\lambda}):</span>  run  <span class="math">\\mathbb{G}\\gets \\mathbb{G}\\mathrm{gen}(1^{\\lambda})</span> <span class="math">g_{1},g_{2},g_{3}\\gets \\mathbb{G}</span>  , set crs  <span class="math">\\coloneqq</span> <span class="math">(\\mathbb{G},g_1,g_2,g_3)</span>  Prover's input: (crs,  <span class="math">(A,B,C),(a,b))</span>  .Verifier's input: (crs,  <span class="math">(A,B,C))</span></p>

    <p class="text-gray-300"><span class="math">\\underline{\\mathsf{V}}\\to \\underline{\\mathsf{P}}</span>  ..  <span class="math">\\ell \\leftarrow \\mathbb{S}</span>  Primes(λ)</p>

    <p class="text-gray-300"><span class="math">\\underline{\\mathsf{P}}\\to \\underline{\\mathsf{V}}</span>  ..  <span class="math">\\pi \\coloneqq ((Q_A,Q_B,Q_C),r_a,r_b)</span>  computed as follows</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(q_{a}, q_{b}, q_{c}) \\gets (\\lfloor a / \\ell \\rfloor, \\lfloor b / \\ell \\rfloor, \\lfloor ab / \\ell \\rfloor)</span></li>

      <li><span class="math">(r_a, r_b) \\gets (a \\mod \\ell, b \\mod \\ell)</span></li>

      <li><span class="math">(Q_A, Q_B, Q_C) \\coloneqq (g_1^{q_a}, g_2^{q_b}, g_3^{q_c})</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{V}(\\mathsf{crs},(A,B,C),\\ell ,\\pi)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">r_c \\gets r_a \\cdot r_b \\mod \\ell</span></li>

      <li>Output 1 iff  <span class="math">r_a, r_b \\in [\\ell] \\land Q_A^\\ell g_1^{r_a} = A \\land Q_B^\\ell g_2^{r_b} = B \\land Q_C^\\ell g_3^{r_c} = C</span></li>

    </ul>

    <p class="text-gray-300">To prove the security of our protocol we rely on the adaptive root assumption and, in a nonblack-box way, on the knowledge extractability of the PoKE* protocol from [BBF19]. The latter is proven in the generic group model for hidden order groups (where also the adaptive root assumption holds).</p>

    <p class="text-gray-300">Theorem A.1. The PoProd protocol is an argument of knowledge for  <span class="math">R_{\\mathrm{PoProd}}</span>  in the generic group model.</p>

    <p class="text-gray-300">The proof is quite similar to the one of theorem 5.1 only instead of using the extractor if PoKRep protocol we use the extractors of two PoKE* protocols (one for  <span class="math">g_1^a = A</span>  and one for  <span class="math">g_2^b = B</span> ).</p>

    <p class="text-gray-300">B Committing and Opening with Precomputation for the [BBF19] SVC</p>

    <p class="text-gray-300">We discuss how the preprocessing technique can also be applied to the SVC scheme of [BBF19] (instantiated for binary vectors of length <span class="math">n=N\\ell</span>). In this case, however, we will not use the incremental disaggregation and aggregation but only one-hop aggregation.</p>

    <p class="text-gray-300">Let us recall that in [BBF19] a commitment to <span class="math">\\vec{v}\\in\\{0,1\\}^{n}</span> is <span class="math">Acc=g^{b}</span> with <span class="math">b=\\prod_{j\\in[n],v_{j}=1}p_{j}</span>. When asked for opening of some positions in the set <span class="math">I</span>, the vector owner has to provide a batched membership proof for all <span class="math">\\{p_{j}:j=(i-1)\\ell+l,i\\in I,l\\in[\\ell],v_{j}=1\\}</span> and a batched non-membership proof for all <span class="math">\\{p_{j}:j=(i-1)\\ell+l,i\\in I,l\\in[\\ell],v_{j}=0\\}</span>.</p>

    <p class="text-gray-300">For the membership proofs, we can use ideas similar to the ones discussed earlier. In the commitment phase one can precompute <span class="math">\\{W_{i}=g^{b/b_{i}}:i\\in[N]\\}</span> where <span class="math">b_{i}=\\prod_{l\\in[\\ell],v_{il}=1}p_{(i-1)\\ell+l}</span>, which can be done in time <span class="math">O(N\\log N\\cdot\\ell\\log(\\ell N))</span> using the RootFactor algorithm from <em>[x21, x1]</em>. This adds at most <span class="math">N</span> elements of <span class="math">\\mathbb{G}</span> to the advice information. Next, in the opening phase, in order to compute a membership witness for a set of positions <span class="math">I</span> one can use the aggregation property to compute a witness <span class="math">W_{I}</span> from all <span class="math">W_{i}</span> with <span class="math">i\\in I</span>, which is doable in time <span class="math">O(m\\log m)</span>.</p>

    <p class="text-gray-300">For the non-membership proof, there are instead two options:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the batch-nonmembership witness from scratch</li>

      <li>Precompute and store (unbatched) non-membership witnesses for all <span class="math">0</span>’s of the vector and then aggregate the necessary ones to provide the opening asked.</li>

    </ol>

    <p class="text-gray-300">We argue that an intermediate solution of precomputing a fraction of non-membership witnesses and computing the rest from scratch does not provide any benefit since even if a single non-membership witness needs to be computed, it requires the whole vector and computing the corresponding product of primes. So, in the end the intermediate solution will be more costly than both the above ones.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute non-membership witness from scratch. To compute a non-membership witness one needs the product <span class="math">b</span> of all the primes in the accumulator (i.e., all primes that correspond to <span class="math">1</span>’s in <span class="math">\\vec{v}</span>). There are in turn two possible ways to deal with this:</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Precompute and store <span class="math">b</span>, which requires <span class="math">O(\\log(N\\ell)\\cdot N\\cdot\\ell)</span> computation and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(N\\cdot\\ell\\cdot\\log(N\\ell))$ bits of storage.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">b</span> online from all <span class="math">p_{i}</span>’s, which requires <span class="math">O(\\log(N\\ell)\\cdot N\\cdot\\ell)</span> computing power.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The computations needed to obtain a single non-membership witness is proportional to the size of <span class="math">b</span>, which is <span class="math">O(\\ell\\cdot N\\cdot\\log(\\ell N))\\mathbb{G}</span>. Hence, virtually there is no big improvement in the opening time by precomputing <span class="math">b</span>, since the group exponentiations are more costly (although concretely it saves the online computation of it). Furthermore, keeping $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(N\\cdot\\ell\\cdot\\log(N\\ell))<span class="math"> bits of storage may get impractical for big </span>N$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Precompute non-membership witnesses and then aggregate. The idea is similar to the aggregation technique mentioned above for membership witnesses. However, a crucial difference is that, as stated in <em>[x1]</em>, for non-membership witnesses one has only one-hop aggregation. This means one must precompute and store non-membership witnesses for each block of the vector. However these non-membership witnesses have size proportional to the number of bits of each block (plus one group element).</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This technique requires storage of <span class="math">O(N)</span> group elements plus <span class="math">O(N \\cdot \\ell \\log (N\\ell))</span> field elements on average. Precisely, the size of a non-membership witness for each block is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\log (N\\ell) \\times \\# \\{0\\text{-bits in the block}\\}<span class="math">, hence the total size of non-membership witnesses is </span>N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ N\\ell \\log (N\\ell)<span class="math"> in the worst case and </span>N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ N\\ell \\log (N\\ell)/2<span class="math"> in an average case where half of the bits of the vector are 0. To conclude, with the VC of [BBF19], one would need, on average, to precompute and store </span>2N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ N\\ell \\log (N\\ell)/2$ bits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Comparison. To conclude, even if we consider the case <span class="math">B = 1</span>, both our solutions require much less storage than in [BBF19]: $2N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> vs. </span>2N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ N\\ell \\log (N\\ell) / 2<span class="math"> bits. In terms of computing time, the preprocessing has roughly the same complexity in all three solutions, although our second scheme is slightly less favorable due to the </span>\\log^2 m<span class="math"> factor in the opening. Comparing [BBF19] and our first scheme, in [BBF19] the computing time for an opening of </span>m<span class="math"> blocks requires at least </span>50\\%<span class="math"> more time than in our first scheme due to the handling of non-membership witnesses (which leads to </span>25\\%$ more time in the average case).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-47" class="text-2xl font-bold">C Succinct Arguments of Knowledge for VDS</h2>

    <p class="text-gray-300">All the protocols below are for simplicity presented for the case of <span class="math">k = 1</span>.</p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">AoK of correct change</h3>

    <div class="my-4 text-center"><span class="math-block">R_{\\mathrm{PoKChange}} = \\left\\{ \\begin{array}{c} \\big( (C, C&#x27;, I), (\\pi_I, \\vec{v}_I, \\vec{v}_I&#x27;) \\big) : \\mathsf{VC.VerUpdate}(\\mathsf{crs}, C, (I, \\pi_I, \\vec{v}_I, \\vec{v}_I&#x27;)) = 1 \\\\ \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\big) \\\\</span></div>

    <p class="text-gray-300">In case of an update the new commitment is normally <span class="math">C&#x27; := (A&#x27;, B&#x27;) = (\\Gamma_I^{b_I}, \\Delta_I^{a_I})</span>. Therefore the prover first sends the proof <span class="math">\\pi_I := (\\Gamma_I, \\Delta_I)</span> to the verifier. Then provides knowledge of the opening of positions <span class="math">I</span> with respect to <span class="math">C</span> and further that <span class="math">\\Gamma_I^{b_I} = A&#x27; \\wedge \\Delta_I^{a_I} = B&#x27;</span>. Putting all together the prover proves knowledge of <span class="math">(a_I, b_I)</span> such that <span class="math">\\Gamma_I^{a_I} = A \\wedge \\Delta_I^{b_I} = B \\wedge g^{a_I \\cdot b_I} = U_I \\wedge \\Gamma_I^{b_I} = A&#x27; \\wedge \\Delta_I^{a_I} = B&#x27;</span>, where <span class="math">U_I \\gets g^{u_I}</span> and <span class="math">u_I \\gets \\mathsf{PrimeProd}(I)</span>.</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">AoK of correct add</h3>

    <div class="my-4 text-center"><span class="math-block">R_{\\mathrm{PoKAdd}} = \\left\\{ \\begin{array}{c} \\big( (C, C&#x27;, I), \\vec{v}_I&#x27; \\big) : \\mathsf{VC.VerUpdate}(\\mathsf{crs}, C, (I, \\varnothing, \\varnothing, \\vec{v}_I&#x27;)) = 1 \\\\ \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\end{array} \\right.</span></div>

    <p class="text-gray-300">The prover provides an argument of knowledge of <span class="math">(a_I&#x27;, b_I&#x27;)</span> such that <span class="math">A^{a_I&#x27;} = A&#x27; \\wedge B^{b_I&#x27;} = B&#x27; \\wedge g^{a_I \\cdot b_I} = U_I</span>, where <span class="math">U_I \\gets g^{u_I}</span> and <span class="math">u_I \\gets \\mathsf{PrimeProd}(I)</span>. Also, <span class="math">C := (A, B)</span> and <span class="math">C&#x27; = (A&#x27;, B&#x27;)</span> are part of the statement.</p>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">AoK of correct delete</h3>

    <div class="my-4 text-center"><span class="math-block">R_{\\mathrm{PoKDelete}} = \\left\\{ \\begin{array}{c} \\big( (C, C&#x27;, I), (\\pi_I, \\vec{v}_I) \\big) : \\mathsf{VC.VerUpdate}(\\mathsf{crs}, C, (I, \\pi_I, \\vec{v}_I, \\varnothing)) = 1 \\\\ \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\end{array} \\right.</span></div>

    <p class="text-gray-300">Recall that in case of deletion the new commitment <span class="math">C&#x27;</span> is simply the proof <span class="math">\\pi_I</span> of the subvector deleted. So the prover has only to provide an argument of knowledge of opening in the deleted positions <span class="math">I</span>. That is <span class="math">(a_I, b_I)</span> such that <span class="math">A&#x27;^{a_I} = A \\wedge B&#x27;^{b_I} = B \\wedge g^{a_I \\cdot b_I} = U_I</span>, where <span class="math">U_I \\gets g^{u_I}</span> and <span class="math">u_I \\gets \\mathsf{PrimeProd}(I)</span>. Also, <span class="math">C := (A, B)</span> and <span class="math">C&#x27; = (A&#x27;, B&#x27;)</span> are part of the statement.</p>

    <p class="text-gray-300">D VDS Proof of Storage</p>

    <p class="text-gray-300">For a VDS scheme we additionally consider the possibility to ensure a client that a given file is stored by the network at a certain point of time without having to retrieve it. To this end, we extend the VDS notion to provide a <em>proof of storage</em> mechanism in the form of a proof of retrievability (PoR) <em>[x10]</em> or a proof of data possession (PDP) <em>[ABC^{+}07]</em>. Our proof of storage model for VDS is such that proofs are publicly verifiable given the file’s digest. Also, in order to support the decentralized and open nature of DSNs, the entire proof mechanism should not use any secret. Finally, a main distinguishing feature compared to existing PoRs/PDPs is that proofs are generated in a distributed fashion by a collection of storage nodes and remain compact regardless of the number of nodes involved in the their generation.</p>

    <p class="text-gray-300">Below we begin by defining the syntax and correctness of proof of storage for a VDS scheme; these are defined the same for modeling both retrievability and data possession. The difference between the two is only in the security notion.</p>

    <p class="text-gray-300">A VDS scheme <span class="math">\\mathsf{VDS}</span> as in Definition 7.1 admits proofs of storage if there exist algorithms (<span class="math">\\mathsf{ClntNode.PoS-Challenge},\\mathsf{StrgNode.PoS-Prove},\\mathsf{ClntNode.PoS-Ver}</span>) that work as follows.</p>

    <p class="text-gray-300">This is a probabilistic algorithm that, given a file’s digest <span class="math">\\delta</span>, outputs a challenge <span class="math">r</span>. This algorithm allows a storage node to (partially) answer a PoS challenge <span class="math">r</span>. The inputs include the local view of the storage node, i.e., digest <span class="math">\\delta</span>, length <span class="math">n</span> local state <span class="math">\\mathsf{st}</span> and file portion <span class="math">(I,\\mathsf{F}_{I})</span>, and a challenge <span class="math">r\\in\\mathcal{C}</span>. The output is a proof <span class="math">\\pi_{r}</span>. On input a digest <span class="math">\\delta</span>, a challenge <span class="math">r\\in\\mathcal{C}</span> and two partial proofs <span class="math">\\pi_{r,1},\\pi_{r,2}</span>, this algorithm outputs an aggregated proof <span class="math">\\pi_{r}</span> and a bit <span class="math">b</span> such that <span class="math">b=1</span> iff <span class="math">\\pi_{r}</span> is a “complete” proof for challenge <span class="math">r</span> (i.e., it can be verified). On input a digest <span class="math">\\delta</span>, a challenge <span class="math">r\\in\\mathcal{C}</span> and a “complete” proof <span class="math">\\pi_{r}</span>, this algorithm accepts (outputs 1) or rejects (outputs 0).</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Definition D.1 (Correctness of VDS PoS).</h6>

    <p class="text-gray-300">A VDS scheme <span class="math">\\mathsf{VDS}</span> has a correct PoS mechanism if <span class="math">\\mathsf{VDS}</span> is correct and if for all honestly generated parameters <span class="math">(\\mathsf{pp},\\delta_{0},\\mathsf{st}_{0})\\leftarrow\\mathsf{Bootstrap}(1^{\\lambda})</span>, any file <span class="math">\\mathsf{F}</span> of length <span class="math">n</span> and any set of <span class="math">\\ell</span> valid storage node’s local views <span class="math">(\\delta,n,\\mathsf{st}_{j},I_{j},\\mathsf{F}_{I_{j}})</span> such that <span class="math">\\bigcup_{j=1}^{\\ell}(I_{j},\\mathsf{F}_{I_{j}})=([n],\\mathsf{F})</span>, the following holds:</p>

    <p class="text-gray-300">if <span class="math">r\\leftarrow\\mathsf{slntNode.PoS-Challenge}(\\delta)</span>, <span class="math">\\pi_{r,j}\\leftarrow\\mathsf{StrgNode.PoS-Prove}(\\delta,n,\\mathsf{st}_{j},I_{j},\\mathsf{F}_{I_{j}},r)</span> for all <span class="math">j\\in[\\ell]</span>, and <span class="math">\\pi_{r}</span> is obtained by aggregating <span class="math">\\{\\pi_{r,j}\\}_{j\\in[\\ell]}</span> in an arbitrary order using repeated usage of <span class="math">\\mathsf{StrgNode.PoS-Aggregate}</span> until getting <span class="math">b=1</span>, then <span class="math">\\mathsf{ClntNode.PoS-Ver}(\\delta,r,\\pi_{r})=1</span>.</p>

    <h4 id="sec-52" class="text-lg font-semibold mt-6">PoS Security.</h4>

    <p class="text-gray-300">Here we define two security properties for the above PoS mechanism: retrievability and data possession. Similarly to <em>[x10, ABC^{+}07]</em>, the idea is to ask that from any adversary, controlling all storage nodes, who creates a proof <span class="math">\\pi_{r}</span> that is accepted with sufficiently high probability it is possible to extract the entire file. In the retrievability case, this is formalized through requiring the existence of an extractor that extracts the file by interacting multiple times with such prover (via rewinding). In the data possession case, it is the same except that the extractor is non-black-box, i.e., we assume that for any adversary there is an extractor; in other words, the extractor is a cryptographic one that does not exist in the real world, and for this reason the data possession notion is weaker than retrievability.</p>

    <p class="text-gray-300">We build our definitions inspired to the one of Proof of Retrievable commitment (PoRC) soundness in [Fis18]. To this end, we define the following two experiments.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VDSPoSAdmAVDS(λ)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VDSPoSExtrAVDS(λ)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(pp, δ0, st0) ← Bootstrap(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">(pp, δ0, st0) ← Bootstrap(1λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(H*, auxA) ← A1(pp, δ0, st0)</td>

            <td class="px-3 py-2 border-b border-gray-700">(H*, auxA) ← A1(pp, δ0, st0)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(b<em>, δ</em>, F<em>) ← EvalHistory(pp, δ0, st0, H</em>)</td>

            <td class="px-3 py-2 border-b border-gray-700">(b<em>, δ</em>, F<em>) ← EvalHistory(pp, δ0, st0, H</em>)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">if b* = 0 abort,</td>

            <td class="px-3 py-2 border-b border-gray-700">F ← E^A2(pp, δ0, st0, δ<em>, auxA,·) (pp, δ0, st0, δ</em>)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">else r ←$ ClntNode.PoS-Challenge(δ*);</td>

            <td class="px-3 py-2 border-b border-gray-700">return 1 iff F ≠ ⊥ ∧ F* ≠δ F</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  πr<em> ← A2(pp, δ0, st0, δ</em>, auxA, r) |   |</p>

    <p class="text-gray-300">|  return ClntNode.PoS-Ver(δ<em>, r, πr</em>) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Above, given two files  <span class="math">\\mathsf{F} \\in \\mathcal{M}^n</span>  and  <span class="math">\\mathsf{F}&#x27; \\in \\mathcal{M}^{n&#x27;}</span>  and a parameter  <span class="math">\\mu \\in [0,1]</span>  we say that  <span class="math">\\mathsf{F}</span>  agrees on a  <span class="math">\\mu</span> -fraction with  <span class="math">\\mathsf{F}&#x27;</span> , denoted  <span class="math">\\mathsf{F} \\equiv_{\\mu} \\mathsf{F}&#x27;</span> , if and only if  <span class="math">n = n&#x27;</span>  and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{i \\in [n] : \\mathsf{F}_i = \\mathsf{F}_i'\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\mu \\cdot n$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The experiment  <span class="math">\\mathsf{VDSPoSAdm}_{\\mathsf{VDS}}^{\\mathcal{A}}(\\lambda)</span>  is parametrized by a two-stage adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span>  and models the interaction between an adversarial prover that creates a (valid) VDS history which results into a digest  <span class="math">\\delta^<em></span>  and then replies to one honestly generated challenge. This experiment is used to formalize the notion of  <span class="math">\\epsilon</span> -admissible adversaries, which in brief are adversaries that in this game answer successfully to the challenge with probability at least  <span class="math">\\epsilon</span> . The second experiment  <span class="math">\\mathsf{VDSPoSExtr}_{\\mathsf{VDS}}^{\\mathcal{A},\\mathcal{E}}(\\lambda)</span>  is again parametrized by a two-stage adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span> , and additionally by an extractor  <span class="math">\\mathcal{E}</span>  having oracle access to  <span class="math">\\mathcal{A}_2</span> . The goal of the extractor is to return a file  <span class="math">\\tilde{\\mathsf{F}}</span>  which agrees on a  <span class="math">\\mu</span> -fraction of indices with the file  <span class="math">\\mathsf{F}^</em></span>  implicitly returned by  <span class="math">\\mathcal{A}_1</span> .</p>

    <p class="text-gray-300">Definition D.2 (Admissible VDS PoS Adversary). A VDS adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span>  is  <span class="math">\\epsilon</span> -admissible if and only if the experiment  <span class="math">\\mathrm{VDSPoRAdm}_{\\mathrm{VDS}}^{\\mathcal{A}}(\\lambda)</span>  does not abort with probability  <span class="math">1 - \\mathrm{negl}(\\lambda)</span>  and  <span class="math">\\operatorname*{Pr}[\\mathrm{VDSPoRAdm}_{\\mathrm{VDS}}^{\\mathcal{A}}(\\lambda, \\mathsf{F}) = 1] \\geq \\epsilon</span> .</p>

    <p class="text-gray-300">Definition D.3 (Retrievability for VDS). A VDS scheme VDS is  <span class="math">(\\mu, \\epsilon)</span> -retrievable if it is secure and for some  <span class="math">\\lambda_{\\epsilon, \\mu} \\in O(\\log \\epsilon / \\log \\mu)</span>  and every  <span class="math">\\lambda &amp;gt; \\lambda_{\\epsilon, \\mu}</span>  there exists an extractor  <span class="math">\\mathcal{E}</span>  that runs in time  <span class="math">\\mathrm{poly}(\\lambda, n, 1/\\epsilon)</span>  such that for any adversary  <span class="math">\\mathcal{A}</span>  which is  <span class="math">\\epsilon</span> -admissible we have  <span class="math">\\operatorname*{Pr}[\\mathrm{VDSPoSExtr}_{\\mathrm{VDS}}^{\\mathcal{A}, \\mathcal{E}}(\\lambda) = 1] \\in \\mathrm{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Definition D.4 (Data Possession for VDS). A VDS scheme VDS has  <span class="math">\\epsilon</span> -data-possession if it is secure and for some  <span class="math">\\lambda_{\\epsilon, \\mu} \\in O(\\log \\epsilon / \\log \\mu)</span>  and every  <span class="math">\\lambda &amp;gt; \\lambda_{\\epsilon, \\mu}</span>  and every adversary  <span class="math">\\mathcal{A}</span>  which is  <span class="math">\\epsilon</span> -admissible there is an extractor  <span class="math">\\mathcal{E}</span>  that runs in time  <span class="math">\\mathrm{poly}(\\lambda, n, 1/\\epsilon)</span>  such that  <span class="math">\\operatorname*{Pr}[\\mathrm{VDSPoSExtr}_{\\mathrm{VDS}}^{\\mathcal{A}, \\mathcal{E}}(\\lambda) = 1] \\in \\mathrm{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Parallel Proof of Storage. We extend our PoS notion for VDS to a setting where one can simultaneously check storage of  <span class="math">k</span>  different files of the same length with a single challenge. The syntactical change we do is to assume that one can generate a challenge by only knowing the length of the files. Informally, the parallel version of retrievability (resp. data possession) is a parallel repetition of the protocol, and then from any adversary that answers successfully for all files it is possible to extract files so that each is consistent with at least a  <span class="math">\\mu</span> -fraction of the original one.</p>

    <p class="text-gray-300">The parallel security experiments are as follows.</p>

    <p class="text-gray-300">VDSPoS-Par-AdmA VDS(λ)</p>

    <p class="text-gray-300"><span class="math">(pp,\\delta_0,st_0)\\gets \\mathrm{Bootstrap}(1^{\\lambda})</span></p>

    <p class="text-gray-300"><span class="math">\\{(\\mathcal{H}_i^*,\\mathsf{aux}_{\\mathcal{A},i})\\}_{i = 1}^k\\gets \\mathcal{A}_1(\\mathsf{pp},\\delta_0,\\mathsf{st}_0)</span></p>

    <p class="text-gray-300"><span class="math">\\{(b_i^<em>,\\delta_i^</em>,\\mathsf{F}_i^<em>)\\gets \\mathsf{EvalHistory}(\\mathsf{pp},\\delta_0,\\mathsf{st}_0,\\mathcal{H}_i^</em>)\\}_{i = 1}^k</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">if  $\\exists i\\in [k]:b_i^* = 0\\lor \\neg (\\wedge_{i\\in [k - 1]}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{F}_i^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{F}_{i + 1}^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  abort,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">else  <span class="math">r\\gets \\mathfrak{s}</span>  ClntNode.PoS-Challenge  $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{F}_i^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\{\\pi_{r,i}^{<em>}\\}_{i = 1}^{k}\\gets \\mathcal{A}_{2}(\\mathsf{pp},\\delta_{0},\\mathsf{st}_{0},\\{\\delta_{i}^{</em>},\\mathsf{aux}_{\\mathcal{A},i}\\}_{i = 1}^{k},r)</span></p>

    <p class="text-gray-300">return 1 iff ClntNode.PoS-Ver  <span class="math">(\\delta_i^<em>, r, \\pi_{r,i}^</em>) \\forall i \\in [k]</span></p>

    <p class="text-gray-300">VDSPoS-Par-ExtrA,  <span class="math">\\mathcal{A},\\mathcal{E}</span>  (λ)</p>

    <p class="text-gray-300"><span class="math">(pp,\\delta_0,st_0)\\gets \\mathrm{Bootstrap}(1^{\\lambda})</span></p>

    <p class="text-gray-300"><span class="math">\\{(\\mathcal{H}_i^*,\\mathsf{aux}_{\\mathcal{A},i})\\}_{i = 1}^k\\gets \\mathcal{A}_1(\\mathsf{pp},\\delta_0,\\mathsf{st}_0)</span></p>

    <p class="text-gray-300"><span class="math">\\{(b_i^<em>,\\delta_i^</em>,\\mathsf{F}_i^<em>)\\gets \\mathsf{EvalHistory}(\\mathsf{pp},\\delta_0,\\mathsf{st}_0,\\mathcal{H}_i^</em>)\\}_{i = 1}^k</span></p>

    <p class="text-gray-300"><span class="math">\\{\\widetilde{\\mathsf{F}}_i\\}_{i = 1}^k\\gets \\mathcal{E}^{\\mathcal{A}_2(\\mathsf{pp},\\delta_0,\\mathsf{st}_0,\\delta_i^<em>,\\mathsf{aux}_{\\mathcal{A},i},)}(\\mathsf{pp},\\delta_0,\\mathsf{st}_0,\\{\\delta_i^</em>\\}_{i = 1}^k)</span></p>

    <p class="text-gray-300">return 1 iff  <span class="math">\\forall i\\in [k]:\\widetilde{\\mathsf{F}}_i\\neq \\bot \\land \\exists j\\in [k]:\\mathsf{F}_j^*\\neq_{\\delta}\\widetilde{\\mathsf{F}}_j</span></p>

    <p class="text-gray-300">Definition D.5 (Admissible VDS PoS Parallel Adversary). A VDS adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span>  is parallel  <span class="math">\\epsilon</span> -admissible if and only if the experiment VDSPoS-Par-Adm <span class="math">_{\\mathrm{VDS}}^{\\mathcal{A}}(\\lambda)</span>  does not abort with probability  <span class="math">1 - \\mathrm{negl}(\\lambda)</span>  and</p>

    <p class="text-gray-300"><span class="math">\\operatorname{Pr}[\\mathsf{VDSPoS - Par - Adm}_{\\mathsf{VDS}}^{\\mathcal{A}}(\\lambda, \\mathsf{F}) = 1] \\geq \\epsilon.</span></p>

    <p class="text-gray-300">Definition D.6 (Parallel Retrievability for VDS). A VDS scheme VDS is parallel  <span class="math">(\\mu, \\epsilon)</span> -retrievable if it is secure and for some  <span class="math">\\lambda_{\\epsilon, \\mu} \\in O(\\log \\epsilon / \\log \\mu)</span>  and every  <span class="math">\\lambda &amp;gt; \\lambda_{\\epsilon, \\mu}</span>  there exists an extractor  <span class="math">\\mathcal{E}</span>  that runs in time  <span class="math">\\mathrm{poly}(\\lambda, n, 1/\\epsilon)</span>  such that for any adversary  <span class="math">\\mathcal{A}</span>  which is parallel  <span class="math">\\epsilon</span> -admissible we have</p>

    <p class="text-gray-300"><span class="math">\\operatorname{Pr}[\\mathsf{VDSPoS - Par - Extr}_{\\mathsf{VDS}}^{\\mathcal{A},\\mathcal{E}}(\\lambda) = 1]\\in \\mathsf{negl}(\\lambda).</span></p>

    <p class="text-gray-300">Definition D.7 (Parallel Data Possession for VDS). A VDS scheme VDS has parallel  <span class="math">\\epsilon</span> -data-possession if it is secure and for some  <span class="math">\\lambda_{\\epsilon, \\mu} \\in O(\\log \\epsilon / \\log \\mu)</span>  and every  <span class="math">\\lambda &amp;gt; \\lambda_{\\epsilon, \\mu}</span>  and every adversary  <span class="math">\\mathcal{A}</span>  which is  <span class="math">\\epsilon</span> -admissible there is an extractor  <span class="math">\\mathcal{E}</span>  that runs in time  <span class="math">\\mathrm{poly}(\\lambda, n, 1/\\epsilon)</span>  such that  <span class="math">\\operatorname{Pr}[\\mathsf{VDSPoS - Par - Extr}_{\\mathsf{VDS}}^{\\mathcal{A},\\mathcal{E}}(\\lambda) = 1] \\in \\mathrm{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">With the following theorem we show that it is enough to prove security in the nonparallel setting. The idea of the proof is that one can construct an extractor for the parallel game by running  <span class="math">k</span>  extractors of the nonparallel game. The analysis of this reduction is rather simple and is therefore omitted.</p>

    <p class="text-gray-300">Theorem D.1. A VDS scheme that has  <span class="math">(\\mu, \\epsilon)</span> -retrievability (resp. data possession) also achieves parallel  <span class="math">(\\mu, \\epsilon)</span> -retrievability (resp. data possession).</p>

    <p class="text-gray-300">In this section we show that any VDS scheme admits a PoR mechanism.</p>

    <p class="text-gray-300">We describe the algorithms generically from the VDS algorithms.</p>

    <p class="text-gray-300">ClntNode.PoS-Challenge  <span class="math">(n)\\to r</span>  samples  <span class="math">\\lambda_{\\mathrm{pos}}</span>  integers  <span class="math">r_1,\\ldots ,r_{\\lambda_{\\mathrm{pos}}}\\gets \\mathfrak{s}[n]</span>  and define  <span class="math">r = \\{r_1,\\dots ,r_{\\lambda_{\\mathrm{pos}}}\\}</span></p>

    <p class="text-gray-300">StrgNode.PoS-Prove  <span class="math">(\\delta ,n,\\mathsf{st},I,\\mathsf{F}_I,r)\\to \\pi_r</span>  Parse  <span class="math">r\\coloneqq \\{r_1,\\ldots ,r_{\\lambda_{\\mathrm{pos}}}\\}</span>  and let  <span class="math">Q\\coloneqq I\\cap r</span>  , compute</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{F}_Q,\\pi_Q)\\gets \\mathsf{StrgNode.Retrieve}(\\delta ,n,\\mathsf{st},I,\\mathsf{F}_I,Q)</span>  and return  <span class="math">\\pi_{r,Q}\\coloneqq (Q,\\mathsf{F}_Q,\\pi_Q,Q)</span></p>

    <p class="text-gray-300">StrgNode.PoS-Aggregate  <span class="math">(\\delta, r, \\pi_{r,1}, \\pi_{r,2}) \\to (b, \\pi_r)</span>  Parse  <span class="math">\\pi_{r,1} := (Q_1, \\mathsf{F}_{Q_1}, \\pi_{Q_1})</span>  and  <span class="math">\\pi_{r,2} := (Q_2, \\mathsf{F}_{Q_2}, \\pi_{Q_2})</span> .</p>

    <p class="text-gray-300">If  <span class="math">\\exists i\\in \\{1,2\\}</span>  such that  <span class="math">Q_{i} = r</span>  set  <span class="math">b\\coloneqq 1</span>  and  <span class="math">\\pi_r\\coloneqq \\pi_{r,i}</span></p>

    <p class="text-gray-300">Otherwise, compute  <span class="math">(Q,\\mathsf{F}_Q)\\coloneqq (Q_1,\\mathsf{F}_{Q_1})\\cup (Q_2,\\mathsf{F}_{Q_2})</span>  and</p>

    <p class="text-gray-300"><span class="math">\\pi_{Q}\\gets \\mathsf{AggregateCertificates}(\\delta ,(Q_{1},\\mathsf{F}_{Q_{1}},\\pi_{Q_{1}}),(Q_{2},\\mathsf{F}_{Q_{2}},\\pi_{Q_{2}}))</span>  , and set  <span class="math">\\pi_r\\coloneqq (Q,\\mathsf{F}_Q,\\pi_Q)</span>  . If  <span class="math">Q = r</span></p>

    <p class="text-gray-300">set  <span class="math">b\\coloneqq 1</span>  , otherwise set  <span class="math">b\\coloneqq 0</span></p>

    <p class="text-gray-300">Return  <span class="math">(b,\\pi_r)</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{CIntNode.PoS-Ver}(\\delta,r,\\pi_{r})\\to b</span> <span class="math">\\text{parse }\\pi_{r}:=(Q,\\mathsf{F}_{Q},\\pi_{Q})\\text{ and return }1\\text{ iff }Q=r\\text{ and }\\mathsf{CIntNode.VerRetrieve}(\\delta,\\text{ }Q,\\mathsf{F}_{Q},\\pi_{Q})=1.</span></p>

    <p class="text-gray-300">Correctness is easy by inspection and by the correctness of VDS.</p>

    <p class="text-gray-300">For security we state the following theorem. The proof is omitted since it is almost identical to the proof of the VC-PoRC construction in <em>[x10]</em>; the only difference is that instead of reducing to the position binding of the VC we reduce to the security of the VDS scheme.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Theorem D.2.</h6>

    <p class="text-gray-300">If <span class="math">\\mathsf{VDS}</span> is a secure VDS scheme then its extension with the PoS algorithms described above is a <span class="math">(\\mu,\\epsilon)</span>-retrievable VDS for any <span class="math">\\epsilon&gt;0</span> such that <span class="math">\\epsilon-\\mu^{\\lambda_{\\mathsf{pos}}}</span> is non-negligible in <span class="math">\\lambda</span>.</p>

    <h3 id="sec-55" class="text-xl font-semibold mt-8">D.2 Proof of Data Possession for our first VDS scheme</h3>

    <p class="text-gray-300">Here we show that our first VDS scheme from Section 8.1 admits a proof of storage mechanism that satisfies the PDP notion. This extension works the same as the PoR described above for any VDS, except that the last step of aggregation “compacts” the proof by generating an AoK of opening (see Section 6). More precisely, let <span class="math">\\mathsf{PoKOpen}^{\\prime}</span> be the same as protocol <span class="math">\\mathsf{PoKOpen}</span> but adjusted for the simpler version of our VC scheme given in Section 8.1. Namely, the one where the commitment is <span class="math">(A,B)</span> and the verification is the <span class="math">\\mathsf{VC.Ver}^{\\prime}</span> algorithm. So, the relation proven by <span class="math">\\mathsf{PoKOpen}^{\\prime}</span> is:</p>

    <p class="text-gray-300"><span class="math">R_{\\mathsf{PoKOpen}^{\\prime}}=\\{(\\,(C,I),(\\vec{y},\\pi_{I})\\,):\\mathsf{VC.Ver}^{\\prime}(\\mathsf{pp},C,I,\\vec{y},\\pi_{I})=1\\}.</span></p>

    <p class="text-gray-300">Then, the PDP aggregation algorithm works as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{StrgNode.PoS-Aggregate}(\\delta,r,\\pi_{r,1},\\pi_{r,2})\\to(b,\\pi_{r})</span> <span class="math">\\text{ Parse }\\pi_{r,1}:=(Q_{1},\\mathsf{F}_{Q_{1}},\\pi_{Q_{1}})\\text{ and }\\pi_{r,2}:=(Q_{2},\\mathsf{F}_{Q_{2}},\\pi_{Q_{2}}).</span></p>

    <p class="text-gray-300">If <span class="math">\\exists i\\in\\{1,2\\}</span> such that <span class="math">Q_{i}=r</span> set <span class="math">b:=1</span> and <span class="math">(Q,\\mathsf{F}_{Q},\\pi_{Q}):=\\pi_{r,i}</span>.</p>

    <p class="text-gray-300">Otherwise, compute <span class="math">(Q,\\mathsf{F}_{Q}):=(Q_{1},\\mathsf{F}_{Q_{1}})\\cup(Q_{2},\\mathsf{F}_{Q_{2}})</span> and</p>

    <p class="text-gray-300"><span class="math">\\pi_{Q}\\leftarrow\\mathsf{AggregateCertificates}(\\delta,(Q_{1},\\mathsf{F}_{Q_{1}},\\pi_{Q_{1}}),(Q_{2},\\mathsf{F}_{Q_{2}},\\pi_{Q_{2}})).</span></p>

    <p class="text-gray-300">If <span class="math">Q\\neq r</span>, set <span class="math">\\pi_{r}:=(Q,\\mathsf{F}_{Q},\\pi_{Q})</span> and return <span class="math">(0,\\pi_{r})</span>. Otherwise, proceed to compute an AoK of opening, i.e., compute <span class="math">\\pi_{r}\\leftarrow\\mathsf{PoKOpen}^{\\prime}.\\mathsf{P}((\\delta,Q),(\\mathsf{F}_{Q},\\pi_{Q}))</span>, and then return <span class="math">(1,\\pi_{r})</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{CIntNode.PoS-Ver}(\\delta,r,\\pi_{r})\\to b</span> <span class="math">\\text{ return }\\mathsf{PoKOpen}^{\\prime}.\\mathsf{V}((\\delta,r),\\pi_{r}).</span></p>

    <p class="text-gray-300">Correctness is easy by inspection and by the correctness of VDS.</p>

    <p class="text-gray-300">For security we state the following theorem. The proof is essentially the same as the one for retrievability except that in this case we define a non-black-box extractor which is build from the extractor for <span class="math">\\mathsf{PoKOpen}^{\\prime}</span>.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Theorem D.3.</h6>

    <p class="text-gray-300">If <span class="math">\\mathsf{PoKOpen}^{\\prime}</span> is a secure AoK for relation <span class="math">R_{\\mathsf{PoKOpen}^{\\prime}}</span> and the VDS scheme <span class="math">\\mathsf{VDS}</span> from Section 8.1 is secure, then its extension with the PoS algorithms described above satisfies <span class="math">(\\mu,\\epsilon)</span>-data possession for any <span class="math">\\epsilon&gt;0</span> such that <span class="math">\\epsilon-\\mu^{\\lambda_{\\mathsf{pos}}}</span> is non-negligible in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">Parallel PDP. We observe that in the case of executing the PDP protocol in parallel for <span class="math">k</span> different digests, our construction has an interesting efficiency property. While verifying one PDP takes time <span class="math">O(\\lambda_{\\mathsf{pos}})</span> due to the computation of the group element <span class="math">U_{r}:=g^{u_{r}}</span> with <span class="math">u_{r}:=\\mathsf{PrimeProd}(r)</span>, in the case of verifying <span class="math">k</span> PDPs with the same challenge the element <span class="math">U_{r}</span> can be reused. This yields a total verification time <span class="math">O(\\lambda_{\\mathsf{pos}}+k)</span> instead of <span class="math">O(k\\cdot\\lambda_{\\mathsf{pos}})</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">E A Variant VDS Construction with Strong Security</p>

    <p class="text-gray-300">We define a stronger notion of security for VDS schemes where the digest is chosen adversarially, namely without having the verifier need to check the corresponding history. Also, we show that a variant of our second VDS construction can be proven secure under this strong notion; this however comes at the price of dropping one of the efficiency requirements as now the verifier may sometimes run in time linear in the size of the file (still all proofs remain short).</p>

    <h3 id="sec-57" class="text-xl font-semibold mt-8">E.1 Strong Security</h3>

    <p class="text-gray-300">In this notion the digest can diverge from a valid history, meaning that the VDS scheme is secure independently of the corresponding history: an adversary cannot convince a client of a false data block in a retrieval query for any arbitrary digest <span class="math">\\delta</span> (that is possibly not an EvalHistory). This notion is analogous to the position binding of vector commitments. This allows a client that has not followed the complete history of the VDS to make certain that for the given digest no invalid retrieval answers can be given.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Definition E.1 (Strong Security for Verifiable Decentralized Storage).</h6>

    <p class="text-gray-300">Consider the experiment <span class="math">\\mathsf{VDS\\text{-}strongSecurity}_{\\mathsf{VDS}}^{\\mathcal{A}}(\\lambda)</span> below. Then we say that a VDS scheme <span class="math">\\mathsf{VDS}</span> is strongly-secure if for all PPT <span class="math">\\mathcal{A}</span> we have <span class="math">\\Pr[\\mathsf{VDS\\text{-}strongSecurity}_{\\mathsf{VDS}}^{\\mathcal{A}}(\\lambda)=1]\\in\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{VDS\\text{-}strongSecurity}_{\\mathsf{VDS}}^{\\mathcal{A}}(\\lambda)</span></p>

    <p class="text-gray-300"><span class="math">(\\mathsf{pp},\\delta_{0},\\mathsf{st}_{0})\\leftarrow\\mathsf{Bootstrap}(1^{\\lambda})</span></p>

    <p class="text-gray-300"><span class="math">(\\delta^{*},Q,\\mathsf{F}_{Q},\\pi,\\mathsf{F}_{Q}^{\\prime},\\pi^{\\prime})\\leftarrow\\mathcal{A}(\\mathsf{pp},\\delta_{0},\\mathsf{st}_{0})</span></p>

    <p class="text-gray-300"><span class="math">b\\leftarrow\\mathsf{ClntNode.VerRetrieve}(\\mathsf{pp},\\delta^{*},Q,\\mathsf{F}_{Q}^{\\prime},\\pi^{\\prime})\\wedge</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{ClntNode.VerRetrieve}(\\mathsf{pp},\\delta^{*},Q,\\mathsf{F}_{Q},\\pi)\\wedge\\mathsf{F}_{Q}^{\\prime}\\neq\\mathsf{F}_{Q}</span></p>

    <p class="text-gray-300">return <span class="math">b</span></p>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">E.2 A VDS Construction with Strong Security</h3>

    <p class="text-gray-300">Our second VDS scheme from Section 8.2 is built upon the <em>[x10, x24]</em> SVC. This scheme is not strongly secure although it inherits the standard position binding of VC (differently from our other construction). This property states that, even for adversarially chosen <span class="math">C</span>’s, which possibly do not come from a valid history, no PPT adversary can provide openings <span class="math">\\pi_{Q},\\pi_{Q}^{\\prime}</span> for different subfiles.</p>

    <p class="text-gray-300">What prevents our VDS scheme to be strongly secure is the <span class="math">U</span>-part of the digest. For <span class="math">U</span> it must be ensured that it has the correct form <span class="math">U\\leftarrow g^{\\prod_{i\\in[n]}e_{i}}</span>. There are two ways to ensure this, either one follows the history of the VDS or it computes it from scratch when necessary. The first case leads to the VDS scheme of Section 8.2, while the second one leads to a strongly-secure VDS scheme, let us call it <span class="math">\\mathsf{VDS}^{\\prime}</span>, that however has the drawback of having linear-time (in the size of the file) verification of a retrieval.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We note that in practice a client may not need to check <span class="math">U</span> at each retrieval. Observe that it only depends on the size of the file and not on its context, meaning that only addition and deletion updates affect it. So one may keep <span class="math">U_{n}=g^{\\prod_{i\\in[n]}e_{i}}</span> stored and at the time of the query verification update it with the new file length <span class="math">n^{\\prime}</span>. This gives an $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n-n^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> computational cost for verification at the cost of storing a single group element, </span>U$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let the alternative verification algorithm be:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CIntNode.VerRetrieve}^{\\prime}(\\delta,Q,\\mathsf{F}_{Q},\\pi_{Q})\\rightarrow b</span> compute <span class="math">U\\leftarrow g^{\\prod_{i\\in[n]}e_{i}}</span> and output acceptance bit</p>

    <p class="text-gray-300"><span class="math">b\\leftarrow\\mathsf{VC.Ver}(\\mathsf{pp},C,Q,\\mathsf{F}_{Q},\\pi_{Q})\\wedge S_{Q}^{\\prod_{i\\in Q}e_{i}}=U</span></p>

    <p class="text-gray-300">and the corresponding VDS scheme be the same as the one in Section 8.2 except for the verification of retrieval query algorithm, i.e.,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{VDS}^{\\prime}=(\\mathsf{Bootstrap},\\mathsf{StrgNode.AddStorage},\\mathsf{StrgNode.RmvStorage},\\mathsf{StrgNode.PushUpdate},</span> <span class="math">\\mathsf{StrgNode.ApplyUpdate},\\mathsf{StrgNode.Retrieve},\\mathsf{CIntNode.VerRetrieve}^{\\prime},\\mathsf{CIntNode.ApplyUpdate},</span> <span class="math">\\mathsf{AggregateCertificates})</span></p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Theorem E.1 (Security).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{G}\\leftarrow\\mathsf{Ggen}(1^{\\lambda})</span> be a hidden order group where the Strong Distinct-Prime-Product Root assumption, then the <span class="math">\\mathsf{VDS}^{\\prime}</span> scheme presented above is a strongly-secure Verifiable Decentralized Storage scheme in the standard model.</p>

    <p class="text-gray-300">The proof is almost the same to the one of Theorem 8.3 and is omitted.</p>

    <h2 id="sec-61" class="text-2xl font-bold">Appendix F Experimental Results</h2>

    <p class="text-gray-300">In this section we include complete tables and plots for our benchmarks of our first VDS construction.</p>

    <p class="text-gray-300">In some of the tables and plots we show only results for openings of size at most 25% of the vector size as this is often the case in practice. We remark that the timings for verification of our SVC construction and BBF do not use proofs of knowledge of exponent, thus both timings can in practice be reduced through the use of this technique. Finally, although we show amortized openings (Figure 9) for only openings of size 2048 bits, we stress that different choices of file and opening size show very similar patterns.</p>

    <p class="text-gray-300">We exclude BBF with precomputation from our experiments as its storage requirements and running times dominate those of our construction with preprocessing. In terms of storage it is linear in the number of the bits in the vector. For our choice of security parameters and block size, it would require <span class="math">3\\times</span> more memory independently of the size of the vector. In terms of time, the running times of BBF with preprocessing always dominate those of our preprocessing scheme. Concretely opening and verification of each zero bit requires one more group exponentiation. Finally, the lack of incremental aggregation makes this scheme less flexible than ours as it does not allow to choose different tradeoffs in terms of memory/running time.</p>

    <h4 id="sec-62" class="text-lg font-semibold mt-6">The Experimental Setting</h4>

    <p class="text-gray-300">We implemented our VC, its preprocessing variant and BBF in Rust. We executed our experiments on a virtual machine running Debian GNU/Linux with 8 Xeon Gold 6154 cores and 30 GB of RAM.</p>

    <p class="text-gray-300">We measured running times for the commitment stage (including or not a preprocessing), opening and verification for different choices of vector length (<span class="math">N</span>) and subvector openings (<span class="math">m</span>). Vectors have blocks of <span class="math">\\ell=256</span> bits (which is representative of vectors where blocks are hash outputs) and their total size <span class="math">n=N\\ell</span> range from 16 kibibit (Kibit) to 1 mebibit (Mibit). For preprocessing we considered the basic case in which we precompute one proof per block, i.e., a total of <span class="math">n/\\ell</span> proofs is</p>

    <p class="text-gray-300">precomputed. We chose  <span class="math">m</span> , the opening size to be of 1, 8 or 64 blocks (i.e. 256, 2048 or 16536 bits). On security parameters: our experiments always used an RSA modulus of 2048 bits and primes of 64 bits for accumulation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n (file size in bits)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Running Time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16384</td>

            <td class="px-3 py-2 border-b border-gray-700">52s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">1m 56s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64536</td>

            <td class="px-3 py-2 border-b border-gray-700">4m 23s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">131072</td>

            <td class="px-3 py-2 border-b border-gray-700">10m 7s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">262144</td>

            <td class="px-3 py-2 border-b border-gray-700">24m 5s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">524288</td>

            <td class="px-3 py-2 border-b border-gray-700">1h 1m</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1048576</td>

            <td class="px-3 py-2 border-b border-gray-700">2h 54m</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4. Commitment times for our preprocessing construction (block size  <span class="math">\\ell  = {256}</span>  ).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n (size in bits)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This work</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BBF</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16384</td>

            <td class="px-3 py-2 border-b border-gray-700">18s</td>

            <td class="px-3 py-2 border-b border-gray-700">3s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">37s</td>

            <td class="px-3 py-2 border-b border-gray-700">8s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64536</td>

            <td class="px-3 py-2 border-b border-gray-700">1m 19s</td>

            <td class="px-3 py-2 border-b border-gray-700">18s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">131072</td>

            <td class="px-3 py-2 border-b border-gray-700">3m 0s</td>

            <td class="px-3 py-2 border-b border-gray-700">45s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">262144</td>

            <td class="px-3 py-2 border-b border-gray-700">7m 22s</td>

            <td class="px-3 py-2 border-b border-gray-700">2m 29s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">524288</td>

            <td class="px-3 py-2 border-b border-gray-700">20m 12s</td>

            <td class="px-3 py-2 border-b border-gray-700">7m 8s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1048576</td>

            <td class="px-3 py-2 border-b border-gray-700">1h 10m</td>

            <td class="px-3 py-2 border-b border-gray-700">29m 54s</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5. Commitment Times (no preprocessing)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n (size in bits)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This work (precomp.)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This work</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BBF</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16384</td>

            <td class="px-3 py-2 border-b border-gray-700">2·10-4</td>

            <td class="px-3 py-2 border-b border-gray-700">5.56</td>

            <td class="px-3 py-2 border-b border-gray-700">5.86</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">2·10-4</td>

            <td class="px-3 py-2 border-b border-gray-700">11.17</td>

            <td class="px-3 py-2 border-b border-gray-700">11.69</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64536</td>

            <td class="px-3 py-2 border-b border-gray-700">2·10-4</td>

            <td class="px-3 py-2 border-b border-gray-700">22.44</td>

            <td class="px-3 py-2 border-b border-gray-700">23.26</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">131072</td>

            <td class="px-3 py-2 border-b border-gray-700">2·10-4</td>

            <td class="px-3 py-2 border-b border-gray-700">44.68</td>

            <td class="px-3 py-2 border-b border-gray-700">45.49</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">262144</td>

            <td class="px-3 py-2 border-b border-gray-700">2·10-4</td>

            <td class="px-3 py-2 border-b border-gray-700">88.98</td>

            <td class="px-3 py-2 border-b border-gray-700">90.72</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">524288</td>

            <td class="px-3 py-2 border-b border-gray-700">2·10-4</td>

            <td class="px-3 py-2 border-b border-gray-700">178.94</td>

            <td class="px-3 py-2 border-b border-gray-700">184.86</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1048576</td>

            <td class="px-3 py-2 border-b border-gray-700">2·10-4</td>

            <td class="px-3 py-2 border-b border-gray-700">357.50</td>

            <td class="px-3 py-2 border-b border-gray-700">370.82</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6. Opening Times (in s) for openings of 256 bits</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n (size in bits)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This work (precomp.)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This work</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BBF</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16384</td>

            <td class="px-3 py-2 border-b border-gray-700">4.27</td>

            <td class="px-3 py-2 border-b border-gray-700">5.70</td>

            <td class="px-3 py-2 border-b border-gray-700">7.96</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">4.27</td>

            <td class="px-3 py-2 border-b border-gray-700">11.34</td>

            <td class="px-3 py-2 border-b border-gray-700">14.75</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64536</td>

            <td class="px-3 py-2 border-b border-gray-700">4.27</td>

            <td class="px-3 py-2 border-b border-gray-700">22.84</td>

            <td class="px-3 py-2 border-b border-gray-700">28.10</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">131072</td>

            <td class="px-3 py-2 border-b border-gray-700">4.27</td>

            <td class="px-3 py-2 border-b border-gray-700">45.44</td>

            <td class="px-3 py-2 border-b border-gray-700">54.17</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">262144</td>

            <td class="px-3 py-2 border-b border-gray-700">4.27</td>

            <td class="px-3 py-2 border-b border-gray-700">91.45</td>

            <td class="px-3 py-2 border-b border-gray-700">108.69</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">524288</td>

            <td class="px-3 py-2 border-b border-gray-700">4.27</td>

            <td class="px-3 py-2 border-b border-gray-700">182.29</td>

            <td class="px-3 py-2 border-b border-gray-700">222.47</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1048576</td>

            <td class="px-3 py-2 border-b border-gray-700">4.27</td>

            <td class="px-3 py-2 border-b border-gray-700">362.50</td>

            <td class="px-3 py-2 border-b border-gray-700">453.28</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 7. Opening Times (in s) for openings of 2048 bits</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n (size in bits)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This work (precomp.)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This work</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BBF</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64536</td>

            <td class="px-3 py-2 border-b border-gray-700">73.57</td>

            <td class="px-3 py-2 border-b border-gray-700">25.96</td>

            <td class="px-3 py-2 border-b border-gray-700">66.16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">131072</td>

            <td class="px-3 py-2 border-b border-gray-700">73.57</td>

            <td class="px-3 py-2 border-b border-gray-700">52.42</td>

            <td class="px-3 py-2 border-b border-gray-700">122.68</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">262144</td>

            <td class="px-3 py-2 border-b border-gray-700">73.57</td>

            <td class="px-3 py-2 border-b border-gray-700">104.63</td>

            <td class="px-3 py-2 border-b border-gray-700">238.07</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">524288</td>

            <td class="px-3 py-2 border-b border-gray-700">73.57</td>

            <td class="px-3 py-2 border-b border-gray-700">210.40</td>

            <td class="px-3 py-2 border-b border-gray-700">521.89</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1048576</td>

            <td class="px-3 py-2 border-b border-gray-700">73.57</td>

            <td class="px-3 py-2 border-b border-gray-700">423.48</td>

            <td class="px-3 py-2 border-b border-gray-700">1100.10</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 8. Opening Times (in s) for openings of 16384 bits</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m·l (opening in bits)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This work</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BBF</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">3.31</td>

            <td class="px-3 py-2 border-b border-gray-700">7.72</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

            <td class="px-3 py-2 border-b border-gray-700">8.97</td>

            <td class="px-3 py-2 border-b border-gray-700">13.28</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16384</td>

            <td class="px-3 py-2 border-b border-gray-700">309.82</td>

            <td class="px-3 py-2 border-b border-gray-700">314.28</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 9. Verification Times (in ms)</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Fig. 7. Commitment Experiments</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> Fig. 8. Opening Experiments</p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Fig. 9. Amortized Opening Experiments for a file of size 128 Kibib.</p>`;
---

<BaseLayout title="Incrementally Aggregatable Vector Commitments and Applicatio... (2020/149)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/149
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
