---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2002/174';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A  Designer&#x27;s Guide to KEMs';
const AUTHORS_HTML = 'Alexander W.  Dent';

const CONTENT = `    <p class="text-gray-300">A Designer’s Guide to KEMs</p>

    <p class="text-gray-300">Alexander W. Dent</p>

    <p class="text-gray-300">Information Security Group, Royal Holloway, University of London, Egham Hill, Egham, Surrey, U.K. alex@fermat.ma.rhul.ac.uk http://www.isg.rhul.ac.uk/~alex/</p>

    <p class="text-gray-300">Errata List</p>

    <p class="text-gray-300">There have been several pieces of technical errata for this paper since it was first published. This copy of the paper contains corrected proofs, but earlier copies will contain the following errors:</p>

    <p class="text-gray-300">An issue was identified with the original construction given in Section 6. The original proposed construction makes the implicit assumption that because the encryption scheme <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> is deterministic there exists only ciphertext <span class="math">C\\in\\mathcal{C}</span> such that <span class="math">\\mathcal{D}(C,sk)=x</span> for every <span class="math">x</span>. This assumption is false. We solve this problem by adding an extra step to the decryption algorithm, between the original steps 2 and 3. This new step is defined as:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that <span class="math">C=\\mathcal{E}(x,pk)</span>. If not, output <span class="math">\\bot</span> and halt. Note that this step is unnecessary if there exists only one ciphertext that corresponds to each message or if it is computationally infeasible for an attacker to find two ciphertexts that decrypt to give the same value.</li>

    </ol>

    <p class="text-gray-300">It was pointed out (by Nigel Smart of the University of Bristol) that the proof of security for the generalised PSEC-KEM construction given in Section 5 requires a plaintext-ciphertext checking oracle. This was not originally stated in the theorem. This means that, in terms of assumptions, the original constructions of Sections 6 and 7 are optimal.</p>

    <p class="text-gray-300">It was pointed out (by James Birkett of Royal Holloway, University of London) that the proof of Theorem 2 given in Appendix A contains numerous small errors. In particular, the two simulated oracles do not give consistent responses to attacker queries, thereby allowing the attacker to distinguish between the cases where he is dealing with proper and simulated decryption oracles.</p>

    <p class="text-gray-300">Alexander W. Dent</p>

    <p class="text-gray-300">Information Security Group, Royal Holloway, University of London, Egham Hill, Egham, Surrey, U.K. alex@fermat.ma.rhul.ac.uk http://www.isg.rhul.ac.uk/~alex/</p>

    <p class="text-gray-300">Abstract. A generic or KEM-DEM hybrid construction is a formal method for combining asymmetric and symmetric encryption techniques to give an efficient, provably secure public-key encryption scheme. This method combines an asymmetric key encapsulation mechanism (KEM) with a symmetric data encapsulation mechanism (DEM). A KEM is a probabilistic algorithm that produces a random symmetric key and an asymmetric encryption of that key. A DEM is a deterministic algorithm that takes a message and a symmetric key and encrypts the message under that key. Each of these components must satisfy its own security conditions if the overall scheme is to be secure. In this paper we describe generic constructions for provably secure KEMs based on weak encryption algorithms. We analyse the two most popular techniques for constructing a KEM and note that they are either overly complex or based on needlessly strong assumptions about the security of the underlying trapdoor function. Hence we propose two new, simple methods for constructing a KEM where the security of the KEM is based on weak assumptions about the underlying function. Lastly we propose a new KEM based on the Rabin function that is both efficient and secure, and is the first KEM to be proposed whose security depends upon the intractability of factoring.</p>

    <p class="text-gray-300">Whilst most dedicated public-key encryption algorithms are fine for sending short messages, many schemes have problems sending long or arbitrary length messages. Most of the normal "modes of operation" which might allow a sender to send a long message using a public-key encryption algorithm directly are cripplingly inefficient.</p>

    <p class="text-gray-300">One particular way to solve these problems is to use symmetric encryption with a randomly generated key to encrypt a message, and then use asymmetric cryptography to encrypt that (short) random key. This method has been cryptographic folklore for years and, as such, was not formally studied. This led to papers such as [3] which can be used to attack</p>

    <p class="text-gray-300">schemes in which the set of symmetric keys is significantly smaller than the message space of the asymmetric scheme used to encrypt them. This folklore has recently been formalised in terms of a generic or KEM-DEM construction <em>[4]</em>. In this construction the encryption scheme is divided into two parts: an asymmetric KEM and a symmetric DEM. A KEM (or key encapsulation mechanism) is a probabilistic algorithm that produces a random symmetric key and an encryption of that key. A DEM (or data encapsulation mechanism) is a deterministic algorithm that encrypts a message of arbitrary length under the key given by the KEM.</p>

    <p class="text-gray-300">This approach to the construction of hybrid ciphers has quickly become popular. Not only have several KEM schemes been proposed in the research literature <em>[4, 7]</em> but this approach has been adopted by the ISO standardisation body <em>[12]</em>. However KEMs are still proposed in an ad hoc fashion. Currently, if one wishes to propose a KEM based on one particular trapdoor problem then it is necessary to design such a KEM from scratch.</p>

    <p class="text-gray-300">In this paper we examine generic methods for constructing KEMs from weak encryption schemes. We analyse the two methods for constructing a KEM based on existing schemes and show that either they require the underlying encryption scheme to have security properties which are stronger than they need to be or they are overly complex. We also provide two new generic construction methods which overcome these problems. Essentially this paper gives a toolbox to allow an algorithm designer to construct a KEM from almost any cryptographic problem. To demonstrate the power of the results we will also propose a new KEM, Rabin-KEM, that is as secure as factoring.</p>

    <p class="text-gray-300">It should be noted that most of the results contained in this paper can be easily adapted to simple, “one-pass” key-agreement protocols like the Diffie-Hellman key agreement scheme <em>[5]</em>.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 The Security of a KEM</h2>

    <p class="text-gray-300">A KEM is a triple of algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a key generation algorithm, KEM.Gen, which takes as input a security parameter <span class="math">1^{\\lambda}</span> and outputs a public/secret key-pair <span class="math">(pk,sk)</span>,</li>

      <li>a encapsulation algorithm, KEM.Encap, that takes as input a public-key <span class="math">pk</span> and outputs an encapsulated key-pair <span class="math">(K,C)</span> (<span class="math">C</span> is sometimes said to be an encapsulation of the key <span class="math">K</span>),</li>

      <li>a decapsulation algorithm, KEM.Decap, that takes as input an encapsulation of a key <span class="math">C</span> and a secret-key <span class="math">sk</span>, and outputs a key <span class="math">K</span>.</li>

    </ul>

    <p class="text-gray-300">Obviously if the scheme is to be useful we require that, with overwhelming probability, the scheme is sound, i.e. for almost all <span class="math">(pk,sk)=\\textit{KEM}.\\textit{Gen}(1^{\\lambda})</span> and almost all <span class="math">(K,C)=\\textit{KEM}.\\textit{Encap}(pk)</span> we have that <span class="math">K=\\textit{KEM}.\\textit{Decap}(C,sk)</span>. We also assume that the range of possible keys <span class="math">K</span> is some set of fixed length binary strings, <span class="math">\\{0,1\\}^{\\textit{KEM}.\\textit{KeyLen}(\\lambda)}</span>.</p>

    <p class="text-gray-300">We choose to approach provable security from an asymptotic/complexity theoretic point of view and suggest that a scheme is secure if the probability of breaking that scheme is negligible as a function of the security parameter.</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Definition 1</h6>

    <p class="text-gray-300">A function <span class="math">f</span> is said to be negligible if, for all polynomials <span class="math">p</span>, there exists a constant <span class="math">N_{p}</span> such that</p>

    <p class="text-gray-300"><span class="math">f(x)\\leq\\frac{1}{p(x)}\\text{ for all }x\\geq N_{p}\\,.</span></p>

    <p class="text-gray-300">A KEM is considered secure if there exists no attacker with a significant advantage in winning the following game played against a mythical challenger.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The challenger generates a public/secret key-pair <span class="math">(pk,sk)=\\textit{KEM}.\\textit{Gen}(1^{\\lambda})</span> and passes <span class="math">pk</span> to the attacker.</li>

      <li>The attacker runs until it is ready to receive a challenge encapsulation pair. During this time the attacker may repeatedly query a decapsulation oracle to find the key associated with any encapsulation.</li>

      <li>The challenger prepares a challenge encapsulated key-pair as follows:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The challenger generates a valid encapsulated key-pair <span class="math">(K_{0},C)=\\textit{KEM}.\\textit{Encap}(pk)</span>.</li>

      <li>The challenger selects an alternate key <span class="math">K_{1}</span> chosen uniformly at random from the set <span class="math">\\{0,1\\}^{\\textit{KEM}.\\textit{Gen}(\\lambda)}</span>.</li>

      <li>The challenger selects a bit <span class="math">\\sigma</span> uniformly at random from <span class="math">\\{0,1\\}</span>. The challenger then passes <span class="math">(K_{\\sigma},C)</span> to the attacker.</li>

      <li>The attacker is allowed to run until it outputs a guess <span class="math">\\sigma^{\\prime}</span> for <span class="math">\\sigma</span>. During this time the attacker may repeatedly query a decapsulation oracle to find the key associated with any encapsulation except the challenge encapsulation <span class="math">C</span>.</li>

    </ol>

    <p class="text-gray-300">The attacker is said to win this game if <span class="math">\\sigma^{\\prime}=\\sigma</span>. We define an attacker’s advantage <span class="math">Adv</span> to be</p>

    <p class="text-gray-300"><span class="math">Pr[\\sigma^{\\prime}=\\sigma]-1/2\\,.</span></p>

    <p class="text-gray-300">If the maximum advantage of any attacker against a KEM is negligible (as a function of <span class="math">\\lambda</span>) then the KEM is said to be IND-CCA2 secure.</p>

    <p class="text-gray-300">A KEM is only useful when coupled with a DEM (a <em>data encapsulation mechanism</em>) to form a hybrid public-key encryption scheme. A DEM is a symmetric algorithm that takes a message and a key, and encrypts the message under that key. In order for the overall hybrid encryption scheme to be secure, the KEM and the DEM must satisfy certain security properties. Happily these properties are independent (i.e. the security properties that a KEM must have are independent of the security properties of the DEM). For the overall encryption scheme to be IND-CCA2 secure (in the sense given below) the KEM, in particular, must be IND-CCA2 secure. For further details of hybrid constructions using KEMs and DEMs, and their security properties, the reader is referred to <em>[4]</em>.</p>

    <h2 id="sec-5" class="text-2xl font-bold">3 The Security of an Encryption Scheme</h2>

    <p class="text-gray-300">We will require formal definitions for an asymmetric encryption scheme. It will suit our purposes to draw a distinction between a deterministic and probabilistic encryption schemes as they present slightly different challenges to the KEM designer. We will start by considering deterministic encryption schemes.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">A deterministic encryption scheme is a triple <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}</span> is the key-generation algorithm which takes as input a security parameter <span class="math">1^{\\lambda}</span> and outputs a public/secret key-pair <span class="math">(pk,sk)</span>,</li>

      <li><span class="math">\\mathcal{E}</span> is the encryption algorithm which takes as input a message <span class="math">m\\in\\mathcal{M}</span> and the public-key <span class="math">pk</span> and outputs a ciphertext <span class="math">C\\in\\mathcal{C}</span>,</li>

      <li><span class="math">\\mathcal{D}</span> is the decryption algorithm which takes as input a ciphertext <span class="math">C\\in\\mathcal{C}</span> and the secret-key <span class="math">sk</span> and outputs either a message <span class="math">m\\in\\mathcal{M}</span> or the error symbol <span class="math">\\bot</span>.</li>

    </ul>

    <p class="text-gray-300">The weakest notion of security for a deterministic encryption scheme is one-way security.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Definition 3.</h6>

    <p class="text-gray-300">A deterministic encryption scheme <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> is said to be one-way if the probability that a polynomial time attacker <span class="math">\\mathcal{A}</span> can invert a randomly generated ciphertext <span class="math">C=\\mathcal{E}(m,pk)</span> (where <span class="math">m</span> is chosen at random from <span class="math">\\mathcal{M}</span>) is negligible as a function of <span class="math">\\lambda</span>. Such a cryptosystem is often said to be secure in the OW-CPA model.</p>

    <p class="text-gray-300">A deterministic encryption scheme <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> is said to be secure in the OW-CPA+ model if the scheme is one-way even when the attacker has access to an oracle that, when given a ciphertext <span class="math">C\\in\\mathcal{C}</span>, determines whether <span class="math">C</span> is a valid ciphertext or not, i.e. whether <span class="math">C</span> is the correct encryption of some message or not.</p>

    <p class="text-gray-300">The idea of allowing an attacker access to an oracle that correctly determines if a ciphertext is valid was first used in a paper by Joye, Quisquater and Yung <em>[6]</em>. The paper used such an oracle to attack an early version of the EPOC-2 cipher.</p>

    <p class="text-gray-300">For our purposes, a probabilistic encryption scheme will be viewed as a deterministic scheme whose encryption algorithm takes some random seed as an extra input.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 4.</h6>

    <p class="text-gray-300">A probabilistic encryption scheme is a triple <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}</span> is the key-generation algorithm which takes as input a security parameter <span class="math">1^{\\lambda}</span> and outputs a public/secret key-pair <span class="math">(pk,sk)</span>,</li>

      <li><span class="math">\\mathcal{E}</span> is the encryption algorithm which takes as input a message <span class="math">m\\in\\mathcal{M}</span>, a random seed <span class="math">r\\in\\mathcal{R}</span> and the public-key <span class="math">pk</span> and outputs a ciphertext <span class="math">C\\in\\mathcal{C}</span>,</li>

      <li><span class="math">\\mathcal{D}</span> is the decryption algorithm which takes as input a ciphertext <span class="math">C\\in\\mathcal{C}</span> and the secret-key <span class="math">sk</span> and outputs either a message <span class="math">m\\in\\mathcal{M}</span> or the error symbol <span class="math">\\bot</span>.</li>

    </ul>

    <p class="text-gray-300">To cement the idea that this is a probabilistic system we require that, for all public keys <span class="math">pk</span> that can be obtained from the key generation algorithm with an input <span class="math">1^{\\lambda}</span> and for all <span class="math">m\\in\\mathcal{M}</span> we have that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{r\\in\\mathcal{R}:\\mathcal{E}(m,r,pk)=C\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\gamma(\\lambda)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">C\\in\\mathcal{C}</span> and $\\gamma(\\lambda)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is negligible as a function of </span>\\lambda$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Analogous notions of OW-CPA and OW-CPA+ security can be defined for probabilistic encryption schemes. However, there is another issue that will affect our ability to design KEMs based on probabilistic encryption schemes - the need for a plaintext-ciphertext checking oracle.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 5.</h6>

    <p class="text-gray-300">For a asymmetric encryption scheme <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span>, a plaintext-ciphertext checking oracle is an oracle that, when given a pair <span class="math">(m,C)\\in\\mathcal{M}\\times\\mathcal{C}</span>, correctly determines whether <span class="math">C</span> is an encryption of <span class="math">m</span> or not.</p>

    <p class="text-gray-300">Obviously, if <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> is a deterministic algorithm then there exists an efficient plaintext-ciphertext checking oracle, however the situation is more complicated for a probabilistic encryption scheme. There are several ways in which a plaintext-ciphertext checking oracle for a probabilistic encryption scheme can be made be available to all parties in a security proof. In particular, it might be possible to construct such an oracle because of the nature of underlying intractability assumption (such as in the case of an encryption scheme based on the gap Diffie-Hellman problem, see <em>[9]</em>). Alternatively, it might be possible to simulate such an oracle using, say, knowledge of the hash queries an attacker has made in the random oracle model <em>[2]</em>.</p>

    <h2 id="sec-10" class="text-2xl font-bold">4 Analysing RSA-KEM</h2>

    <p class="text-gray-300">We present a method to construct a KEM from almost all one-way public-key encryption schemes; this generalises the ideas used in RSA-KEM <em>[12]</em>.</p>

    <p class="text-gray-300">The construction of a KEM from a deterministic encryption scheme <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> is given in Table 1. This construction uses a key derivation function <em>KDF</em>. This function is intended to do more than simply format the random number correctly as a key: it is meant to remove algebraic relations between inputs. It is usually constructed from a hash function and will be modelled as a random oracle.</p>

    <p class="text-gray-300">Table 1: A KEM derived from a deterministic encryption scheme</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key generation is given by the key generation algorithm of the public-key encryption scheme (i.e. <em>KEM</em>.<em>Gen</em> = <span class="math">\\mathcal{G}</span>).</li>

      <li>Encapsulation is given by:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate an element <span class="math">x\\in\\mathcal{M}</span> uniformly at random.</li>

      <li>Set <span class="math">C:=\\mathcal{E}(x,pk)</span>.</li>

      <li>Set <span class="math">K:=KDF(x)</span>.</li>

      <li>Output <span class="math">(K,C)</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Decapsulation of an encapsulation <span class="math">C</span> is given by:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">x:=\\mathcal{D}(C,sk)</span>. If <span class="math">x=\\perp</span> then output <span class="math">\\perp</span> and halt.</li>

      <li>Set <span class="math">K:=KDF(x)</span>.</li>

      <li>Output <span class="math">K</span>.</li>

    </ol>

    <h6 id="sec-11" class="text-base font-medium mt-4">Theorem 1</h6>

    <p class="text-gray-300">Suppose <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> is a deterministic asymmetric encryption scheme that is secure in the OW-CPA+ model. Then the KEM derived from <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> in Table 1 is, in the random oracle model, IND-CCA2 secure.</p>

    <p class="text-gray-300">The proof of this theorem is similar to the of Theorem 2.</p>

    <p class="text-gray-300">This style of KEM can be easily extended to the case where the underlying encryption scheme is probabilistic and not deterministic. The construction is given in Table 2. Note that the encapsulation is included in the input to the key derivation function to prevent the attacker from breaking the scheme by finding a second ciphertext <span class="math">C^{\\prime}</span> that decrypts to the same value as the challenge ciphertext <span class="math">C</span>.</p>

    <p class="text-gray-300">Table 2: A KEM derived from a probabilistic encryption scheme</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key generation is given by the key generation algorithm of the public-key encryption scheme (i.e. <em>KEM</em>.<em>Gen</em> = <span class="math">\\mathcal{G}</span>).</li>

      <li>Encapsulation is provided by the following algorithm.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate elements <span class="math">x\\in\\mathcal{M}</span> and <span class="math">r\\in\\mathcal{R}</span> uniformly at random.</li>

      <li>Set <span class="math">C:=\\mathcal{E}(x,r,pk)</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Set $K:=KDF(\\bar{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C)<span class="math">, where </span>\\bar{x}<span class="math"> is a fixed length representation of the element </span>x\\in\\mathcal{M}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">(K,C)</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Decapsulation of an encapsulation <span class="math">C</span> is given by the following algorithm.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">x:=\\mathcal{D}(C,sk)</span>. If <span class="math">x=\\perp</span> then output <span class="math">\\perp</span> and halt.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Set $K:=KDF(\\bar{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C)<span class="math"> where </span>\\bar{x}<span class="math"> is a fixed length representation of the element </span>x\\in\\mathcal{M}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">K</span>.</li>

    </ol>

    <h6 id="sec-12" class="text-base font-medium mt-4">Theorem 2</h6>

    <p class="text-gray-300">Suppose <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> is a probabilistic asymmetric encryption scheme</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>that is secure in the OW-CPA+ model, and</li>

      <li>for which there exists a plaintext-ciphertext checking oracle.</li>

    </ul>

    <p class="text-gray-300">Then the KEM derived from <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> in Table 2 is, in the random oracle model, IND-CCA2 secure.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">See Appendix A</p>

    <h2 id="sec-14" class="text-2xl font-bold">5 Analysing PSEC-KEM</h2>

    <p class="text-gray-300">Obviously it would be advantageous if we were able to remove the reliance on these non-optimal security criteria, i.e. produce a generic method for constructing a KEM from an OW-CPA encryption scheme rather</p>

    <p class="text-gray-300">than from an OW-CPA+ encryption scheme and requiring a plaintext-ciphertext checking oracle. In this section, we present a method to construct a KEM from a OW-CPA encryption scheme (for which there exists a plaintext-ciphertext checking oracle); this generalises the ideas used in PSEC-KEM <em>[12]</em>.</p>

    <p class="text-gray-300">Table 3 gives a construction for a KEM from a (deterministic or probabilistic) asymmetric encryption scheme <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span>. In the construction <em>Hash</em> is a hash function and <em>MGF</em> is a mask generating function. A mask generating function is similar to a key derivation function, in fact the same constructions are used for both, but a mask generating function is used to create a bit string that is used to mask a data value. We will model these function as random oracles, hence care must be taken to ensure that the outputs of the hash function and the mask generating function are suitably independent. We also use a “smoothing function” <span class="math">\\phi:\\{0,1\\}^{n_{2}}\\rightarrow\\mathcal{M}</span>, where <span class="math">\\mathcal{M}</span> is the message space of the encryption scheme <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span>. This function must have the property that for <span class="math">Y^{\\prime}</span> drawn uniformly at random from <span class="math">\\{0,1\\}^{n_{2}}</span> and <span class="math">X\\in\\mathcal{M}</span> we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$Pr[\\phi(Y^{\\prime})=X]-\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">is negligible.</p>

    <p class="text-gray-300">For security, it is necessary that <span class="math">n</span> is suitably large. Certainly <span class="math">n\\geq\\lambda</span> would be sufficient. Of the other lengths, <span class="math">n_{1}</span> should equal <span class="math">KEM.Keylen</span> and <span class="math">n_{2}</span> merely has to be large enough so that there exists a function <span class="math">\\phi</span> which is suitably smooth.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Theorem 3</h6>

    <p class="text-gray-300">Suppose <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> is an asymmetric encryption scheme that is secure in the OW-CPA model and for which there exists a plaintext-ciphertext checking oracle. Then the KEM derived from <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> in Table 3 is, in the random oracle model, IND-CCA2 secure.</p>

    <p class="text-gray-300">A sketch proof is given in Appendix D.</p>

    <h2 id="sec-16" class="text-2xl font-bold">6 A New Construction for a Deterministic Encryption Scheme</h2>

    <p class="text-gray-300">Although the construction given in Section 5 (the generalisation of PSEC-KEM) is based on weaker assumptions than the construction of Section 4, it is not optimal as it requires us to assume the existence of a plaintext-ciphertext checking oracle and is very complex. We now propose a simpler construction for designing a KEM based on a deterministic encryption scheme with similarly weak security assumptions. In other words,</p>

    <p class="text-gray-300">Table 3. A KEM derived from a OW-CPA secure encryption scheme</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key-generation is given by <span class="math">\\mathcal{G}</span>, i.e. <span class="math">KEM.Gen=\\mathcal{G}</span>.</li>

      <li>Encapsulation is given by:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate a suitably large bit-string <span class="math">y\\in\\{0,1\\}^{n}</span>.</li>

      <li>Set <span class="math">Y:=Hash(y)</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Split <span class="math">Y</span> into two strings <span class="math">K\\in\\{0,1\\}^{n_{1}}</span> and <span class="math">Y^{\\prime}\\in\\{0,1\\}^{n_{2}}</span> where $Y=K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y^{\\prime}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">X:=\\phi(Y^{\\prime})</span>.</li>

      <li>Set <span class="math">C_{1}:=\\mathcal{E}(X,pk)</span>. (If <span class="math">\\mathcal{E}</span> is probabilistic then generate a random seed <span class="math">r\\in\\mathcal{R}</span> and set <span class="math">C_{1}:=\\mathcal{E}(X,r,pk)</span>.)</li>

      <li>Set <span class="math">C_{2}:=y\\oplus MGF(X)</span>.</li>

      <li>Set <span class="math">C=(C_{1},C_{2})</span>.</li>

      <li>Output <span class="math">(K,C)</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Decapsulation of an encapsulation <span class="math">C</span> is given by:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">C</span> as <span class="math">(C_{1},C_{2})</span>.</li>

      <li>Set <span class="math">X:=\\mathcal{D}(C_{1},sk)</span>. If <span class="math">x=\\perp</span> then output <span class="math">\\perp</span> and halt.</li>

      <li>Set <span class="math">y=C_{2}\\oplus MGF(X)</span>.</li>

      <li>Set <span class="math">Y=Hash(y)</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5. Split <span class="math">Y</span> into two strings <span class="math">K\\in\\{0,1\\}^{n_{1}}</span> and <span class="math">Y^{\\prime}\\in\\{0,1\\}^{n_{2}}</span> where $Y=K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y^{\\prime}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that <span class="math">\\phi(Y^{\\prime})=X</span>. If not, output <span class="math">\\perp</span> and halt.</li>

      <li>Output <span class="math">K</span>.</li>

    </ol>

    <p class="text-gray-300">we build a secure KEM from a deterministic encryption scheme that is secure in the OW-CPA model, as opposed to the OW-CPA+ model as in Section 4. The construction can be viewed as a simpler version of the REACT construction <em>[10]</em>.</p>

    <p class="text-gray-300">Table 4 gives a construction of a KEM based on a deterministic asymmetric encryption scheme <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span>. The scheme makes use of a key derivation function <span class="math">KDF</span> and a hash function <span class="math">Hash</span>. These functions will be modelled as random oracles and so care must be taken that their outputs are suitably independent.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">Suppose that <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> is a deterministic encryption algorithm that is secure in the OW-CPA model. Then the KEM derived from <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> in Table 4 is, in the random oracle model, IND-CCA2 secure.</p>

    <p class="text-gray-300">Proof See Appendix B</p>

    <p class="text-gray-300">This construction also has the advantage that the decryption algorithm need not return a unique solution but need only return a small subset of the message space that includes the original message, as, with high probability, the original message will be the only message in the subset that hashes to give the correct value of <span class="math">C_{2}</span>. We will make heavy use of this fact in the specification of Rabin-KEM (see Sect. 8).</p>

    <p class="text-gray-300">Table 4: A KEM derived from an OW-CPA secure, deterministic encryption scheme</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key-generation is given by <span class="math">\\mathcal{G}</span>, i.e. <span class="math">\\mathit{KEM.Gen}=\\mathcal{G}</span>.</li>

      <li>Encapsulation is given by:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate a suitably large bit-string <span class="math">x\\in\\mathcal{M}</span>.</li>

      <li>Set <span class="math">C_{1}:=\\mathcal{E}(x,pk)</span>.</li>

      <li>Set <span class="math">C_{2}:=\\mathit{Hash}(x)</span>.</li>

      <li>Set <span class="math">C:=(C_{1},C_{2})</span>.</li>

      <li>Set <span class="math">K:=\\mathit{KDF}(x)</span>.</li>

      <li>Output <span class="math">(K,C)</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Decapsulation of an encapsulation <span class="math">C</span> is given by:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">C</span> as <span class="math">(C_{1},C_{2})</span>.</li>

      <li>Set <span class="math">x:=\\mathcal{D}(C_{1},sk)</span>. If <span class="math">x=\\bot</span> then output <span class="math">\\bot</span> and halt.</li>

      <li>Check that <span class="math">C_{1}=\\mathcal{E}(x,pk)</span>. If not, output <span class="math">\\bot</span> and halt. (Note, this step may be ignored if there exists only one ciphertext associated with each message or if it is computationally infeasible for an attacker to find two ciphertexts that decrypt to the same value.)</li>

      <li>Check that <span class="math">C_{2}=\\mathit{Hash}(x)</span>. If not, output <span class="math">\\bot</span> and halt.</li>

      <li>Set <span class="math">K:=\\mathit{KDF}(x)</span>.</li>

      <li>Output <span class="math">K</span>.</li>

    </ol>

    <h2 id="sec-18" class="text-2xl font-bold">7 A New Construction for a Probabilistic Encryption Scheme</h2>

    <p class="text-gray-300">Although the previous KEM construction can be generalised to be used with a probabilistic encryption scheme, the security proof still relies on the existence of a plaintext-ciphertext checking oracle (which is always easily constructed for a deterministic encryption algorithm). We now give a construction for a probabilistic encryption scheme, loosely based on the ideas of <em>[KL]</em>, that does not require a plaintext-ciphertext checking oracle. It is interesting to note, however, that this construction <em>cannot</em> be used for a deterministic scheme.</p>

    <p class="text-gray-300">Table 5 gives the construction of a KEM based on a OW-CPA secure, probabilistic encryption scheme. Furthermore the proof of security for this construction does not require there to exist a plaintext-ciphertext checking oracle. The scheme makes use of a key derivation function <span class="math">\\mathit{KDF}</span> and a hash function <span class="math">\\mathit{Hash}</span>. These functions will be modelled as random oracles and so care must be taken that their outputs are suitably independent.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Theorem 5.1</h6>

    <p class="text-gray-300">Suppose that <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> is a probabilistic encryption algorithm that is secure in the OW-CPA model. Then the KEM derived from <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> in Table 5 is, in the random oracle model, IND-CCA2 secure.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">See Appendix C</p>

    <p class="text-gray-300">Table 5: A KEM derived from an OW-CPA secure, probabilistic encryption scheme</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key-generation is given by <span class="math">\\mathcal{G}</span>, i.e. <span class="math">\\mathit{KEM.Gen}=\\mathcal{G}</span>.</li>

      <li>Encapsulation is given by:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate a suitably large bit-string <span class="math">x\\in\\mathcal{M}</span>.</li>

      <li>Set <span class="math">r:=\\mathit{Hash}(x)</span>.</li>

      <li>Set <span class="math">C:=\\mathcal{E}(x,r,pk)</span>.</li>

      <li>Set <span class="math">K:=\\mathit{KDF}(x)</span>.</li>

      <li>Output <span class="math">(K,C)</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Decapsulation is given by:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">x:=\\mathcal{D}(C,sk)</span>. If <span class="math">x=\\perp</span> then output <span class="math">\\perp</span> and halt.</li>

      <li>Set <span class="math">r:=\\mathit{Hash}(x)</span>.</li>

      <li>Check that <span class="math">\\mathcal{E}(x,r,pk)=C</span>. If not, output <span class="math">\\perp</span> and halt.</li>

      <li>Set <span class="math">K:=\\mathit{KDF}(x)</span>.</li>

      <li>Output <span class="math">K</span>.</li>

    </ol>

    <h2 id="sec-21" class="text-2xl font-bold">8 Case study: Rabin-KEM</h2>

    <p class="text-gray-300">We demonstrate the power of these results by proposing a new KEM whose security is equivalent to factoring: Rabin-KEM. The Rabin-KEM construction will be based on the generic construction given in Sect. 6 and the Rabin trapdoor permutation <em>[8, 11]</em>. The algorithm is described in Table 6.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Theorem 6</h6>

    <p class="text-gray-300">Providing the factoring problem is hard, Rabin-KEM is, in the random oracle model, IND-CCA2 secure.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">It is well known that the Rabin trapdoor function is one-way providing that the factoring assumption is hard <em>[11]</em>. Therefore, given that the factoring problem is intractable, the given KEM is IND-CCA2 secure in the random oracle model by Theorem 4. ∎</p>

    <p class="text-gray-300">This KEM is both and efficient and secure, being the first KEM ever proposed whose security depends on the assumption that factoring is intractable. Of course there is a chance that the decryption algorithm will fail, i.e. that <span class="math">\\mathit{KEM.Decap}(C,sk)=\\perp</span> even though <span class="math">C</span> is actually a valid encapsulation of a key <span class="math">K</span>. However this will only happen if there is a collision in the hash function, which, as we model the hash function as a random oracle, only happens with probability <span class="math">2^{-\\mathit{Hash.Len}}</span> (where <span class="math">\\mathit{Hash.Len}</span> is the length of the output of the hash function).</p>

    <p class="text-gray-300">Table 6. Rabin-KEM</p>

    <p class="text-gray-300">Key Generation On input of <span class="math">1^{\\lambda}</span> for some integer <span class="math">\\lambda &amp;gt; 0</span>,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Randomly generate two distinct primes <span class="math">p</span> and <span class="math">q</span> of bit length <span class="math">\\lambda</span>.</li>

      <li>Set <span class="math">n := pq</span>.</li>

      <li>Set <span class="math">pk := (n)</span> and <span class="math">sk := (p, q)</span>.</li>

      <li>Output <span class="math">(pk, sk)</span>.</li>

    </ol>

    <p class="text-gray-300">Encapsulation On input of a public key <span class="math">PK</span>,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Randomly generate an integer <span class="math">x \\in [0, n)</span>.</li>

      <li>Set <span class="math">C_1 := x^2 \\mod n</span>.</li>

      <li>Set <span class="math">C_2 := \\text{Hash}(x)</span>.</li>

      <li>Set <span class="math">C := (C_1, C_2)</span>.</li>

      <li>Set <span class="math">K := \\text{KDF}(x)</span>.</li>

      <li>Output <span class="math">(K, C)</span>.</li>

    </ol>

    <p class="text-gray-300">Decapsulation On input of an encapsulated key <span class="math">C</span> and a secret key <span class="math">sk</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">C</span> as <span class="math">(C_1, C_2)</span>.</li>

      <li>Check that <span class="math">C_1</span> is a square modulo <span class="math">n</span>. If not, output <span class="math">\\bot</span> and halt.</li>

      <li>Compute the four square roots <span class="math">x_1, x_2, x_3, x_4</span> of <span class="math">C_1</span> modulo <span class="math">n</span> using the secret key <span class="math">sk</span>.</li>

      <li>If there exists no value <span class="math">1 \\leq i \\leq 4</span> such that <span class="math">\\text{Hash}(x_i) = C_2</span> then output <span class="math">\\bot</span> and halt.</li>

      <li>If there exists more than one value <span class="math">1 \\leq i \\leq 4</span> such that <span class="math">\\text{Hash}(x_i) = C_2</span> then output <span class="math">\\bot</span> and halt.</li>

      <li>Let <span class="math">x</span> be the unique square root of <span class="math">C_1</span> modulo <span class="math">n</span> for which <span class="math">\\text{Hash}(x) = C_2</span>.</li>

      <li>Set <span class="math">K := \\text{KDF}(x)</span>.</li>

      <li>Output <span class="math">K</span></li>

    </ol>

    <p class="text-gray-300">9 Conclusion</p>

    <p class="text-gray-300">This paper has provided four generic constructions for key encapsulation mechanisms (KEMs): two generalisations of existing KEMs and two new KEMs. These results show that KEMs can be constructed from almost any trapdoor function. We also proposed a new KEM: Rabin-KEM. This is a new fast, secure KEM based on the intractability of factoring large numbers.</p>

    <p class="text-gray-300">Acknowledgements</p>

    <p class="text-gray-300">I would like to thank Victor Shoup, Louis Granboulan and Kenny Paterson for some very useful discussions in this area. Nigel Smart and James Birkett both deserve thanks for pointing out errors in some of the proofs. As always the help of Christine Swart has been invaluable.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway. Relations among notions of security for public-key encryption schemes. In H. Krawczyk, editor, Advances in Cryptology – Crypto ’98, volume 1462 of Lecture Notes in Computer Science, pages 26–45. Springer-Verlag, 1998.</li>

      <li>[2] M. Bellare and P. Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In Proc. of the First ACM Conference on Computer and Communications Security, pages 62–73, 1993.</li>

      <li>[3] D. Boneh, A. Joux, and A. Nguyen. Why textbook ElGamal and RSA encryption are insecure. In T. Okamoto, editor, Advances in Cryptology – Asiacrypt 2000, volume 1976 of Lecture Notes in Computer Science, pages 30–43. Springer-Verlag, 2000.</li>

      <li>[4] R. Cramer and V. Shoup. Design and analysis of practical public-key encryption schemes secure against adaptive chosen ciphertext attack. Available from http://shoup.net/, 2002.</li>

      <li>[5] W. Diffie and M. Hellman. New directions in cryptography. IEEE Transactions on Information Theory, 22:644–654, 1976.</li>

      <li>[6] M. Joye, J. Quisquater, and M. Yung. On the power of misbehaving adversaries and security analysis of the original EPOC. In D. Naccache, editor, Topics in Cryptography – CT-RSA 2001, volume 2020 of Lecture Notes in Computer Science, pages 208–222. Springer-Verlag, 2001.</li>

      <li>[7] S. Lucks. A variant of the Cramer-Shoup cryptosystem for groups of unknown order. In Y. Zheng, editor, Advances in Cryptology – Asiacrypt 2002, volume 2501 of Lecture Notes in Computer Science, pages 27–45. Springer-Verlag, 2002.</li>

      <li>[8] A. J. Menezes, P. van Oorschot, and S. Vanstone. Handbook of Applied Cryptography. CRC Press, 1997.</li>

      <li>[9] T. Okamoto and D. Pointcheval. The gap problems: A new class of problems for the security of cryptographic schemes. In K. Kim, editor, Public Key Cryptography, volume 1992 of Lecture Notes in Computer Science, pages 104–118. Springer-Verlag, 2001.</li>

      <li>[10] T. Okamoto and D. Pointcheval. REACT: Rapid enhanced-security asymmetric cryptosystem transform. In D. Naccache, editor, Proceedings of CT-RSA 2001, volume 2020 of Lecture Notes in Computer Science, pages 159–175. Springer-Verlag, 2001.</li>

      <li>[11] M. O. Rabin. Digitalized signatures and public-key functions as intractable as factorization. Technical Report MIT/LCS/TR-212, MIT Laboratory for Computer Science, 1979.</li>

      <li>[12] V. Shoup. A proposal for the ISO standard for public-key encryption (version 2.0). Available from http://shoup.net/, 2001.</li>

    </ul>

    <h2 id="sec-24" class="text-2xl font-bold">Appendix A Proof of Theorem 2</h2>

    <p class="text-gray-300">This is a simple result. We will use standard techniques to prove a more detailed result.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Theorem 7.</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> be an encryption scheme and let <span class="math">KEM</span> be the KEM derived from <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> using the construction described in Table 2.</p>

    <p class="text-gray-300">If there exist an attacker <span class="math">\\mathcal{A}</span> that, in the random oracle model, breaks KEM in the IND-CCA2 model</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>with advantage <span class="math">\\epsilon</span>,</li>

      <li>in time <span class="math">t</span>,</li>

      <li>makes at most <span class="math">q_{D}</span> queries to the decapsulation oracle,</li>

      <li>and at most <span class="math">q_{K}</span> queries to the random oracle that represents the key derivation function,</li>

    </ul>

    <p class="text-gray-300">then there exists an algorithm that inverts the underlying encryption function in the OW-CPA+ model (and makes use of a plaintext-ciphertext checking oracle) with probability <span class="math">\\epsilon^{\\prime}</span> and in time <span class="math">t^{\\prime}</span> where</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon^{\\prime}\\geq\\epsilon-q_{D}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,,$ (1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">t^{\\prime}=t\\,.</span> (2)</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We assume that there exists an attacker for the KEM and use this to construct an algorithm that can break the underlying encryption scheme. Suppose <span class="math">\\mathcal{A}</span> is an attacker that breaks the KEM with the properties stated above.</p>

    <p class="text-gray-300">Consider the following algorithm that takes as input a public-key <span class="math">pk</span> for the underlying encryption scheme and a challenge ciphertext <span class="math">C^{*}</span>. This algorithm makes use of two lists: <span class="math">KDFList</span> which stores the answers to queries made to the KDF oracle and <span class="math">DecList</span> which stores the answers to queries made to the decapsulation oracle.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prepare two empty lists <span class="math">KDFList</span> and <span class="math">DecList</span>.</li>

      <li>Randomly generate a bit-string <span class="math">K^{<em>}</span> of length </em>KEM.KeyLen*.</li>

      <li>Pass the public key to <span class="math">pk</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>Allow <span class="math">\\mathcal{A}</span> to run until it requests a challenge encapsulation. If the attacker requests the evaluation of the key derivation function <em>KDF</em> on an input <span class="math">z</span> then the following steps are performed:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check to see if <span class="math">(z,K)\\in KDFList</span> for some value of <span class="math">K</span>. If so, return <span class="math">K</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Check to see if <span class="math">z</span> can be parsed as $\\bar{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C<span class="math"> for some fixed length representation of a message </span>x\\in\\mathcal{M}<span class="math"> and a ciphertext </span>C\\in\\mathcal{C}<span class="math">. If not, randomly generate an appropriately sized </span>K<span class="math">, add </span>(z,K)<span class="math"> to </span>KDFList<span class="math"> and return </span>K$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check to see if <span class="math">C</span> is an encryption of <span class="math">x</span> using the plaintext-ciphertext checking oracle. If not, randomly generate an appropriately sized <span class="math">K</span>, add <span class="math">(z,K)</span> to <span class="math">KDFList</span> and return <span class="math">K</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check to see if there exists an entry <span class="math">(C,K)</span> on <span class="math">DecList</span>. If so, add <span class="math">(z,K)</span> to <span class="math">KDFList</span> and return <span class="math">K</span>.</li>

      <li>Randomly generate an appropriately sized <span class="math">K</span>, add <span class="math">(z,K)</span> to <span class="math">KDFList</span>, add <span class="math">(C,K)</span> to <span class="math">DecList</span> and return <span class="math">K</span>.</li>

    </ul>

    <p class="text-gray-300">If the attacker requests the decapsulation of an encapsulation <span class="math">C</span> then the following steps are performed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check to see if <span class="math">C=C^{*}</span>. If so, return <span class="math">\\bot</span>.</li>

      <li>Check to see if <span class="math">(C,K)\\in DecList</span> for some value <span class="math">K</span>. If so, return <span class="math">K</span>.</li>

      <li>Check to see if <span class="math">C</span> is a valid ciphertext or not (using the oracle provided by the CPA+ model). If not, add <span class="math">(C,\\bot)</span> to <span class="math">DecList</span> and return <span class="math">\\bot</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Check to see if there exists an entry $(\\bar{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C,K)<span class="math"> on </span>KDFList<span class="math"> such that </span>C<span class="math"> is an encryption of </span>x<span class="math"> (using the plaintext-ciphertext checking oracle). If so, add </span>(C,K)<span class="math"> to </span>DecList<span class="math"> and return </span>K$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Otherwise randomly generate an appropriately sized <span class="math">K</span>, add <span class="math">(C,K)</span> to <span class="math">DecList</span> and return <span class="math">K</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When the attacker requests a challenge encapsulation, return <span class="math">(K^{<em>},C^{</em>})</span></li>

      <li>Allow the attacker to run until it outputs a bit <span class="math">\\sigma^{\\prime}</span>. Answer all oracle queries as before.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7. Check to see if there exists a pair <span class="math">(z,K)\\in KDFList</span> such that <span class="math">z</span> can be decomposed as $\\bar{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C^{<em>}<span class="math"> where </span>\\bar{x}<span class="math"> is the fixed length representation of a message </span>x\\in\\mathcal{M}<span class="math"> and </span>C^{</em>}<span class="math"> is an encryption of </span>x<span class="math"> (using the plaintext-ciphertext checking oracle). If so, output </span>x$ and halt.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Otherwise randomly generate <span class="math">x\\in\\mathcal{M}</span>. Output <span class="math">x</span> and halt.</li>

    </ol>

    <p class="text-gray-300">This algorithm perfectly simulates the attack environment for <span class="math">\\mathcal{A}</span> up unless one of two events occur:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The attacker queries the decryption oracle with the challenge ciphertext <span class="math">C^{<em>}</span> </em>before<em> the challenge ciphertext has been issued to the attacker (i.e. in Step 4). In this case the simulation will return <span class="math">\\bot</span> when it should return the decryption of <span class="math">C^{</em>}</span>. We will denote the event that this happens as <span class="math">E_{1}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The attacker queries the KDF oracle on the $\\bar{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C^{<em>}<span class="math"> where </span>\\bar{x}<span class="math"> is the fixed length representative of </span>x^{</em>}=\\mathcal{D}(C,sk)<span class="math">. In this case the simulation will return always return a random value (where it should return </span>K^{*}<span class="math"> half the time). We will denote the event that this happens as </span>E_{2}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Therefore,</p>

    <p class="text-gray-300"><span class="math">1/2+\\epsilon=Pr[\\mathcal{A}\\text{ wins}]</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$=Pr[\\mathcal{A}\\text{ wins}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{1}]Pr[E_{1}]+Pr[\\mathcal{A}\\text{ wins}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\neg E_{1}]Pr[\\neg E_{1}]$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$\\leq q_{D}/</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathcal{M}</td>

            <td class="px-3 py-2 border-b border-gray-700">+Pr[\\mathcal{A}\\text{ wins}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\neg E_{1}]$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">as <span class="math">\\mathcal{A}</span> has no knowledge of <span class="math">C^{<em>}</span> before the challenge is issued and so will only submit <span class="math">C^{</em>}</span> to the decryption oracle by pure chance. Since <span class="math">\\mathcal{A}</span> makes at most <span class="math">q_{D}</span> oracle queries and the underlying message <span class="math">x^{<em>}=\\mathcal{D}(C^{</em>},sk)</span> is chosen at random, the probability that <span class="math">\\mathcal{A}</span> submits <span class="math">C^{*}</span> to the decryption oracle is bounded by $q_{D}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. We now have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">1/2+\\epsilon</span> $\\leq q_{D}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+Pr[\\mathcal{A}\\text{ wins}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\neg E_{1}]$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$\\leq q_{D}/</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathcal{M}</td>

            <td class="px-3 py-2 border-b border-gray-700">+Pr[\\mathcal{A}\\text{ wins}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\neg E_{1}\\wedge E_{2}]+Pr[\\mathcal{A}\\text{ wins}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\neg E_{1}\\wedge\\neg E_{2}]$</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$=q_{D}/</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathcal{M}</td>

            <td class="px-3 py-2 border-b border-gray-700">+\\epsilon^{\\prime}+1/2\\,.$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This is because if <span class="math">\\mathcal{A}</span> does not query the KDF oracle on $\\bar{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C^{<em>}<span class="math"> where </span>x=D(C^{</em>},sk)<span class="math"> then (as we are working in the random oracle model) </span>\\mathcal{A}<span class="math"> can have no advantage in winning the IND-CCA2 game; and if </span>\\mathcal{A}<span class="math"> wins the IND-CCA2 game and both </span>E_{2}<span class="math"> occurred and </span>E_{1}$ did not occur, then our solver wins the OW-CPA+ game. Hence,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon^{\\prime}\\geq\\epsilon-q_{D}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Box</span></p>

    <h2 id="sec-27" class="text-2xl font-bold">Appendix B Proof of Theorem 4</h2>

    <p class="text-gray-300">We use standard techniques to prove the following, slightly more detailed result.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Theorem 8</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> be a deterministic encryption scheme and let KEM be the KEM derived from <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> using the construction described in Table 4. If there exists an attacker <span class="math">\\mathcal{A}</span> that, in the random oracle model, breaks KEM in the IND-CCA2 model</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>with advantage <span class="math">\\epsilon</span>,</li>

      <li>in time <span class="math">t</span>,</li>

      <li>and makes at most <span class="math">q_{D}</span> decapsulation queries,</li>

      <li>at most <span class="math">q_{H}</span> queries to the random oracle that represents the hash function,</li>

      <li>and at most <span class="math">q_{K}</span> queries to the random oracle that represents the key derivation function,</li>

    </ul>

    <p class="text-gray-300">then there exists an algorithm that inverts the underlying encryption function with probability <span class="math">\\epsilon^{\\prime}</span> and in time <span class="math">t^{\\prime}</span> where</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon^{\\prime}\\geq\\epsilon-\\frac{q_{D}}{2^{Hash.Len}}-\\frac{q_{D}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\,,$ (3)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">t^{\\prime}\\leq t+(q_{H}+q_{K}+q_{D})T\\,,</span> (4)</p>

    <p class="text-gray-300">where <span class="math">Hash.Len</span> is the length of the output of the hash function <span class="math">Hash</span> and <span class="math">T</span> is the time taken to evaluate the encryption function <span class="math">\\mathcal{E}</span>.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We assume that there exists an attacker for the KEM and use this to construct an algorithm that can break the underlying encryption scheme. Suppose <span class="math">\\mathcal{A}</span> is an attacker that breaks the KEM with the properties stated above.</p>

    <p class="text-gray-300">First we slightly change the environment that <span class="math">\\mathcal{A}</span> operates in. Let game 1 be the game in which <span class="math">\\mathcal{A}</span> attacks the KEM as described in the IND-CCA2 environment described in Sect. 3. Let game 2 be similar to game 1 except that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the challenge encapsulation <span class="math">(K^{<em>},C^{</em>})</span> is chosen at the beginning of the algorithm and if the attacker ever requests the decapsulation of <span class="math">C^{<em>}=(C_{1}^{</em>},C_{2}^{*})</span> then the decapsulation algorithm returns <span class="math">\\bot</span>,</li>

      <li>instead of allowing the attacker <span class="math">\\mathcal{A}</span> access to the “real” decapsulation oracle, hash function oracle and KDF oracle we only allow <span class="math">\\mathcal{A}</span> to have access to the “partially simulated” versions of these oracles described below.</li>

    </ul>

    <p class="text-gray-300">The simulated oracles make use of two lists <span class="math">HashList</span> and <span class="math">KDFList</span>, both of which are initially empty. If the attacker requests the evaluation of the hash function <span class="math">Hash</span> on an input <span class="math">x</span> then the following steps are performed:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">(x,hash)\\in HashList</span> for some value of <span class="math">hash</span> then return <span class="math">hash</span>.</li>

      <li>If <span class="math">x=\\mathcal{D}(C_{1}^{*},sk)</span> then return <span class="math">Hash(x)</span>.</li>

      <li>Otherwise randomly generate an appropriately sized <span class="math">hash</span>, add <span class="math">(x,hash)</span> to <span class="math">HashList</span> and return <span class="math">hash</span>.</li>

    </ol>

    <p class="text-gray-300">Hence the hash function is changed to a random function with the proviso that it must agree with the original hash function on the input <span class="math">\\mathcal{D}(C_{1}^{*},sk)</span>. This simulation is equivalent to some random oracle and every random oracle can be represented by this simulation. Similarly, if the attacker requests the evaluation of the key derivation function <span class="math">KDF</span> on an input <span class="math">x</span> then the following steps are performed:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">(x,K)\\in KDFList</span> for some value of <span class="math">K</span> then return <span class="math">K</span>.</li>

      <li>If <span class="math">x=\\mathcal{D}(C_{1}^{*},sk)</span> then return <span class="math">KDF(x)</span>.</li>

      <li>Otherwise randomly generate an appropriately sized <span class="math">K</span>, add <span class="math">(x,K)</span> to <span class="math">KDFList</span> and return <span class="math">K</span>.</li>

    </ol>

    <p class="text-gray-300">If the attacker requests the evaluation of decapsulation function on the encapsulated key <span class="math">(C_{1},C_{2})</span> then the following steps are performed:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">C_{1}=C_{1}^{*}</span> then return <span class="math">\\bot</span>.</li>

      <li>Check that there exists a unique <span class="math">x\\in\\mathcal{M}</span> such that <span class="math">(x,C_{2})\\in HashList</span> and <span class="math">\\mathcal{E}(x,pk)=C_{1}</span>. If not, return <span class="math">\\bot</span>.</li>

      <li>Compute <span class="math">K:=KDF(x)</span> using the KDF algorithm described above.</li>

      <li>Return <span class="math">K</span>.</li>

    </ol>

    <p class="text-gray-300">To analyse the effects of only allowing <span class="math">\\mathcal{A}</span> to have access to the simulated oracles we require the following simple lemma <em>[1, 4]</em>.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Lemma 1</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">A</span>, <span class="math">B</span> and <span class="math">E</span> are events is some probability space and that $Pr[A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\neg E]=Pr[B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\neg E]<span class="math"> then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr[A]-Pr[B]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq Pr[E]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">A</span> be the event that <span class="math">\\mathcal{A}</span> succeeds in breaking the KEM with access to the real oracles and let <span class="math">B</span> be the event that <span class="math">\\mathcal{A}</span> succeeds in breaking the KEM with access to the simulated oracles. Let <span class="math">E</span> be the event that either</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> queries the decapsulation oracle on the challenge encapsulation before the challenge encapsulation is given to <span class="math">\\mathcal{A}</span>, or</li>

      <li><span class="math">\\mathcal{A}</span> queries the decapsulation oracle on some encapsulation <span class="math">(C_{1},C_{2})</span> where <span class="math">Hash(\\mathcal{D}(C_{1},sk))=C_{2}</span> but <span class="math">\\mathcal{A}</span> has not queried the hash function simulator on the input <span class="math">\\mathcal{D}(C_{1},sk)</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">E</span> does not occur then <span class="math">\\mathcal{A}</span> will receive the same responses to his queries regardless of whether it is querying the real oracles or the simulated oracles. Hence $Pr[A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\neg E]=Pr[B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\neg E]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since the challenge ciphertext has to be chosen completely at random, the probability that <span class="math">E</span> occurs because <span class="math">\\mathcal{A}</span> queries the decapsulation oracle on the challenge encapsulation before it has been issued is bounded above by $q_{D}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. (Since the message is drawn randomly from </span>\\mathcal{M}<span class="math"> we can bound the probability that </span>\\mathcal{A}<span class="math"> guesses </span>C_{1}^{*}<span class="math"> in a single oracle query by </span>1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. If this happens, then the attacker may know </span>\\mathcal{D}(C_{1}^{<em>},sk)<span class="math"> and so may also know </span>C_{2}^{</em>}=Hash(\\mathcal{D}(C_{1}^{*},sk))<span class="math">. Hence, we may only bound the probability that this occurs by </span>q_{D}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">.) Since the hash function is modelled as a random oracle, the probability that </span>\\mathcal{A}<span class="math"> queries the decapsulation oracle on some encapsulation </span>(C_{1},C_{2})<span class="math"> where </span>Hash(\\mathcal{D}(C_{1},sk))=C_{2}<span class="math"> but </span>\\mathcal{A}$ has</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">not queried the hash function <span class="math">Hash</span> on the input <span class="math">\\mathcal{D}(C_1, sk)</span> is at most <span class="math">q_D / 2^{Hash.Len}</span>. Hence the advantage of <span class="math">\\mathcal{A}</span> in game 2 is least</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\epsilon - \\frac {q _ {D}}{2 ^ {\\text {H a s h . L e n}}} - \\frac {q _ {D}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}. \\tag {5}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Let <span class="math">E&#x27;</span> be the event that, in game 2, the attacker queries either the hash function simulator or the key derivation function oracle with the input <span class="math">x^{<em>} = \\mathcal{D}(C_{1}^{</em>}, sk)</span>. Since the attacker can have no knowledge of the whether <span class="math">KDF(x^{<em>}) = K^{</em>}</span> or not unless <span class="math">E&#x27;</span> occurs we have that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P r \\left[ E ^ {\\prime} \\right] \\geq \\epsilon - \\frac {q _ {D}}{2 ^ {\\text {H a s h . L e n}}} - \\frac {q _ {D}}{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {M} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}. \\tag {6}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Consider the following algorithm that takes as input a public key <span class="math">pk</span> for the underlying encryption scheme and a challenge ciphertext <span class="math">C_1^*</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prepare two empty lists <span class="math">HashList</span> and <span class="math">KDFList</span>.</li>

      <li>Generate random bit strings <span class="math">C_2^<em></span> of length <span class="math">Hash.Len</span> and <span class="math">K^</em></span> of length <span class="math">KEM.KeyLen</span>. Set <span class="math">C^<em> := (C_1^</em>, C_2^*)</span>.</li>

      <li>Pass the public key <span class="math">pk</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>Allow the attacker <span class="math">\\mathcal{A}</span> to run until it requests a challenge encapsulation. If the attacker requests the evaluation of the hash function <span class="math">Hash</span> on an input <span class="math">x</span> then the following steps are performed:</li>

    </ol>

    <p class="text-gray-300">(a) If <span class="math">(x, hash) \\in HashList</span> for some value of <span class="math">hash</span> then return <span class="math">hash</span>. (b) Otherwise randomly generate an appropriately sized <span class="math">hash</span>, add <span class="math">(x, hash)</span> to <span class="math">HashList</span> and return <span class="math">hash</span>.</p>

    <p class="text-gray-300">If the attacker requests the evaluation of the KDF <span class="math">KDF</span> on an input <span class="math">x</span> then the following steps are performed:</p>

    <p class="text-gray-300">(a) If <span class="math">(x, K) \\in KDFList</span> for some value of <span class="math">K</span> then return <span class="math">K</span>. (b) Otherwise randomly generate an appropriately sized <span class="math">K</span>, add <span class="math">(x, K)</span> to <span class="math">KDFList</span> and return <span class="math">K</span>.</p>

    <p class="text-gray-300">If the attacker requests the evaluation of decapsulation function on the encapsulated key <span class="math">(C_1, C_2)</span> then the following steps are performed:</p>

    <p class="text-gray-300">(a) If <span class="math">C_1 = C_1^*</span> then return <span class="math">\\bot</span>. (b) Check that there exists a unique <span class="math">x \\in \\mathcal{M}</span> such that <span class="math">(x, C_2) \\in HashList</span> and <span class="math">\\mathcal{E}(x, pk) = C_1</span>. If not, return <span class="math">\\bot</span>. (c) Compute <span class="math">K \\coloneqq KDF(x)</span> using the simulator described above. (d) Return <span class="math">K</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When the attacker requests a challenge encapsulation pass the pair <span class="math">(K^{<em>}, C^{</em>})</span> to the attacker.</li>

      <li>Allow the attacker to run until it outputs a bit <span class="math">\\sigma&#x27;</span>. Answer all oracle queries with the simulators described above.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check to see if there exists some <span class="math">(x,hash)\\in HashLish</span> or <span class="math">(x,K)\\in KDFList</span> such that <span class="math">\\mathcal{E}(x,pk)=C_{1}^{*}</span>. If so, output <span class="math">x</span> and halt.</li>

      <li>Randomly generate <span class="math">x\\in\\mathcal{M}</span>. Output <span class="math">x</span> and halt.</li>

    </ol>

    <p class="text-gray-300">This algorithm perfectly simulates the attack environment for the attacker <span class="math">\\mathcal{A}</span> in game 2, up until the point where event <span class="math">E^{\\prime}</span> occurs. However, if <span class="math">E^{\\prime}</span> occurs then the above algorithm will correctly output <span class="math">x^{<em>}=\\mathcal{D}(C_{1}^{</em>},sk)</span>. Hence the above algorithm will correctly invert a randomly generated ciphertext with probability at least</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon-\\frac{q_{D}}{2^{Hash.Len}}-\\frac{q_{D}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\,.$ (7)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This value is negligible providing <span class="math">\\epsilon</span> is negligible, hence the KEM is secure in the IND-CCA2 model providing the underlying encryption scheme is secure in the OW-CPA model. ∎</p>

    <h2 id="sec-31" class="text-2xl font-bold">Appendix C Proof of Theorem 5</h2>

    <p class="text-gray-300">Again, we prove a slightly more detailed result.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Theorem 9.</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> be a probabilistic encryption scheme and let KEM be the KEM derived from <span class="math">(\\mathcal{G},\\mathcal{E},\\mathcal{D})</span> using the construction described in Table 5. If there exists an attacker <span class="math">\\mathcal{A}</span> that, in the random oracle model, breaks KEM in the IND-CCA2 model</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>with advantage <span class="math">\\epsilon</span>,</li>

      <li>in time <span class="math">t</span>,</li>

      <li>and makes at most <span class="math">q_{D}</span> decapsulation queries,</li>

      <li>at most <span class="math">q_{H}</span> queries to the random oracle that represents the hash function,</li>

      <li>and at most <span class="math">q_{K}</span> queries to the random oracle that represents the key derivation function.</li>

    </ul>

    <p class="text-gray-300">then there exists an algorithm that inverts the underlying encryption function with probability <span class="math">\\epsilon^{\\prime}</span> and in time <span class="math">t^{\\prime}</span> where</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon^{\\prime}\\geq\\frac{1}{q_{D}+q_{H}+q_{K}}(\\epsilon-\\frac{q_{D}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}-\\frac{\\gamma q_{D}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})\\,,$ (8)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">t^{\\prime}\\approx t\\,,</span> (9)</p>

    <p class="text-gray-300">where <span class="math">\\gamma</span> is defined in Definition 4.</p>

    <p class="text-gray-300">Proof</p>

    <p class="text-gray-300">The proof is similar to that given in Appendix B.</p>

    <p class="text-gray-300">Let game 1 be the game in which <span class="math">\\mathcal{A}</span> attacks the KEM as described in the IND-CCA2 environment described in Sect. 3. Let game 2 be similar to game 1 except that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the challenge encapsulation <span class="math">(K^{<em>},C^{</em>})</span> is chosen at the beginning of the algorithm and if the attacker ever requests the decapsulation of <span class="math">C^{*}</span> then the decapsulation algorithm returns <span class="math">\\bot</span>,</li>

      <li>instead of allowing the attacker <span class="math">\\mathcal{A}</span> access to the “real” decapsulation oracle, hash function oracle and KDF oracle we only allow <span class="math">\\mathcal{A}</span> to have access to the “partially simulated” versions of these oracles described below.</li>

    </ul>

    <p class="text-gray-300">We simulate the hash function oracle and the KDF oracle exactly as before, making use of two lists, <span class="math">HashList</span> and <span class="math">KDFList</span>, both of which are initially empty. If the attacker requests the evaluation of the hash function <em>Hash</em> on an input <span class="math">x</span> then the following steps are performed:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">(x,hash)\\in HashList</span> for some value of <span class="math">hash</span> then return <span class="math">hash</span>.</li>

      <li>If <span class="math">x=\\mathcal{D}(C^{<em>},sk)</span> then return </em>Hash<em>(</em>x*).</li>

      <li>Otherwise randomly generate an appropriately sized <span class="math">hash</span>, add <span class="math">(x,hash)</span> to <span class="math">HashList</span> and return <span class="math">hash</span>.</li>

    </ol>

    <p class="text-gray-300">If the attacker requests the evaluation of the key derivation function <em>KDF</em> on an input <span class="math">x</span> then the following steps are performed:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">(x,K)\\in KDFList</span> for some value of <span class="math">K</span> then return <span class="math">K</span>.</li>

      <li>If <span class="math">x=\\mathcal{D}(C^{<em>},sk)</span> then return </em>KDF<em>(</em>x*).</li>

      <li>Otherwise randomly generate an appropriately sized <span class="math">K</span>, add <span class="math">(x,K)</span> to <span class="math">KDFList</span> and return <span class="math">K</span>.</li>

    </ol>

    <p class="text-gray-300">If the attacker requests the evaluation of the decapsulation function on the encapsulated key <span class="math">C</span> then the following steps are performed:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">C=C^{*}</span> then return <span class="math">\\bot</span>.</li>

      <li>For each pair <span class="math">(x,hash)\\in HashList</span>, check whether <span class="math">\\mathcal{E}(x,hash,pk)=C</span>. If no such pair exists then return <span class="math">\\bot</span>.</li>

      <li>If there exists such a pair <span class="math">(x,hash)</span> then run the simulator for the key derivation function on the input <span class="math">x</span> to get a key <span class="math">K</span>.</li>

      <li>Return <span class="math">K</span>.</li>

    </ol>

    <p class="text-gray-300">As before, we note that game 1 and game 2 are identical except if either of the following events occur:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> queries the decapsulation oracle on the challenge encapsulation before the challenge encapsulation is given to <span class="math">\\mathcal{A}</span>, or</li>

      <li><span class="math">\\mathcal{A}</span> queries the decapsulation oracle on some encapsulation <span class="math">C</span> where <span class="math">x=\\mathcal{D}(C,sk)</span> and <span class="math">C=\\mathcal{E}(x,\\mathit{Hash}(x),pk)</span> but <span class="math">\\mathcal{A}</span> has not queried the hash function simulator on the input <span class="math">x</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The probability that the first event occurs is bounded above by $q_{D}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (as there exists </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> valid encapsulations). The probability that the second event occurs is bounded above by </span>q_{D}\\gamma/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (where </span>\\gamma<span class="math"> is defined in Definition 4). Hence the advantage of </span>\\mathcal{A}$ in game 2 is at least</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon-q_{D}(\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\frac{\\gamma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})\\,.$ (10)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">E^{\\prime}</span> be the event that, in game 2, the attacker queries either the hash function simulator or the key derivation function oracle with the input <span class="math">x^{<em>}=\\mathcal{D}(C^{</em>},sk)</span>. Again, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$Pr[E^{\\prime}]\\geq\\epsilon-q_{D}(\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\frac{\\gamma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})\\,.$ (11)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now, consider the following algorithm that takes as input a public key <span class="math">pk</span> for the underlying encryption scheme and a challenge ciphertext <span class="math">C^{<em>}</span> (which is the encryption of some randomly chosen message <span class="math">x^{</em>}\\in\\mathcal{M}</span>).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prepare two empty lists <span class="math">HashList</span> and <span class="math">KDFList</span>.</li>

      <li>Generate a random bit strings <span class="math">K^{<em>}</span> of length </em>KEM.KeyLen*.</li>

      <li>Pass the public key <span class="math">pk</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>Allow the attacker <span class="math">\\mathcal{A}</span> to run until it requests a challenge encapsulation. If the attacker requests the evaluation of the hash function <em>Hash</em> on an input <span class="math">x</span> then the following steps are performed:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">(x,hash)\\in HashList</span> for some value of <span class="math">hash</span> then return <span class="math">hash</span>.</li>

      <li>Otherwise randomly generate an appropriately sized <span class="math">hash</span>, add <span class="math">(x,hash)</span> to <span class="math">HashList</span> and return <span class="math">hash</span>.</li>

    </ol>

    <p class="text-gray-300">If the attacker requests the evaluation of the KDF <em>KDF</em> on an input <span class="math">x</span> then the following steps are performed:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">(x,K)\\in KDFList</span> for some value of <span class="math">K</span> then return <span class="math">K</span>.</li>

      <li>Otherwise randomly generate an appropriately sized <span class="math">K</span>, add <span class="math">(x,K)</span> to <span class="math">KDFList</span> and return <span class="math">K</span>.</li>

    </ol>

    <p class="text-gray-300">If the attacker requests the evaluation of decapsulation function on the encapsulated key <span class="math">C</span> then the following steps are performed:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">C=C^{*}</span> then return <span class="math">\\bot</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that there exists a unique <span class="math">x\\in\\mathcal{M}</span> such that <span class="math">(x,hash)\\in HashList</span> and <span class="math">\\mathcal{E}(x,hash,pk)=C</span> for some value of <span class="math">hash</span>. If not, return <span class="math">\\bot</span>.</li>

      <li>Run the simulator for the key derivation function on the input <span class="math">x</span> to get a key <span class="math">K</span>.</li>

      <li>Return <span class="math">K</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When the attacker requests a challenge encapsulation pass the pair <span class="math">(K^{<em>},C^{</em>})</span> to the attacker.</li>

      <li>Allow the attacker to run until it outputs a bit <span class="math">\\sigma^{\\prime}</span>. Answer all oracle queries with the simulators described above.</li>

      <li>Pick, uniformly at random, some value <span class="math">x</span> from the set of <span class="math">x</span> such that either <span class="math">(x,hash)\\in HashList</span> or <span class="math">(x,K)\\in KDFList</span>. Output <span class="math">x</span> as the inverse of <span class="math">C^{*}</span>.</li>

    </ol>

    <p class="text-gray-300">This algorithm perfectly simulates the environment for the attacker in game 2 up until the point in which <span class="math">E^{\\prime}</span> occurs. However if <span class="math">E^{\\prime}</span> occurs then the above correctly output <span class="math">x^{*}</span> with probability <span class="math">1/(q_{D}+q_{H}+q_{K})</span>. Hence the above algorithm will correctly invert the encryption of a randomly generated message with probability at least</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{1}{q_{D}+q_{H}+q_{K}}(\\epsilon-\\frac{q_{D}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}-\\frac{\\gamma q_{D}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})\\,.$ (12)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This value is negligible providing <span class="math">\\epsilon</span> is negligible, hence the KEM is secure in the IND-CCA2 model providing the underlying encryption scheme is secure in the OW-CPA model. ∎</p>

    <h2 id="sec-33" class="text-2xl font-bold">Appendix D Proof of Theorem 3</h2>

    <p class="text-gray-300">Again, we actually prove a slightly more detailed result. Suppose <span class="math">\\mathcal{A}</span> is an attacker which breaks the KEM in the IND-CCA2 model, and that this attacker</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>has advantage <span class="math">\\epsilon</span>,</li>

      <li>makes at most <span class="math">q_{D}</span> queries to the decapsulation oracle,</li>

      <li>makes at most <span class="math">q_{M}</span> queries to the mask generating function oracle,</li>

      <li>and at most <span class="math">q_{H}</span> queries to the hash function oracle.</li>

    </ul>

    <p class="text-gray-300">We will use this to construct an algorithm that breaks the underlying cryptosystem. In constructing the algorithm that inverts the underlying cryptosystem we will be challenged to invert a random ciphertext <span class="math">C_{1}^{*}</span> (we</p>

    <p class="text-gray-300">will use the superscript ^{∗} to denote variables associated with the challenge ciphertext). For convenience we set</p>

    <p class="text-gray-300"><span class="math">r^{<em>}=C_{2}^{</em>}\\oplus\\mathcal{D}(C_{1}^{*},sk)</span></p>

    <p class="text-gray-300">and note that this constrains the behaviour of <span class="math">Hash</span> on <span class="math">r^{*}</span>.</p>

    <p class="text-gray-300">We construct the challenge encapsulation pair <span class="math">(K^{<em>},C^{</em>})</span> by selecting a random KEM.Keylen-bit integer <span class="math">K^{<em>}</span> and a random <span class="math">n</span>-bit integer <span class="math">C_{2}^{</em>}</span> and setting <span class="math">C^{<em>}=(C_{1}^{</em>},C_{2}^{*})</span>.</p>

    <p class="text-gray-300">We need to tweak the environment that the attacker runs in, so that we may successfully simulate all the oracles that it has access to. Let Game 1 be the normal IND-CCA2 game. Let Game 2 be the game where the challenge encapsulation pair <span class="math">(K^{<em>},C^{</em>})</span> is generated at the start of the algorithm, and if the attacker queries the decapsulation oracle on the input <span class="math">C^{*}</span> then the decapsulation oracle responds with <span class="math">\\bot</span>. If <span class="math">A_{1}</span> is the event that the attacker wins in Game 1 and <span class="math">A_{2}</span> is the event that the attacker wins in Game 2 then, using Lemma 1, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr[A_{1}]-Pr[A_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\frac{q_{D}}{2^{n}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\,.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now, since we do not know <span class="math">\\mathcal{D}(C_{1}^{<em>},sk)</span>, we will find it hard to simulate the decapsulation of encapsulations of the form <span class="math">(C_{1}^{</em>},C_{2})</span>. We can avoid this problem by refusing to decapsulate any encapsulation of this form. Let Game 3 be similar to Game 2, but with the decapsulation oracle will outputting <span class="math">\\bot</span> whenever it is queried with an encapsulation of the form <span class="math">(C_{1}^{*},C_{2})</span>. Let <span class="math">A_{3}</span> be the event that the attacker wins in Game 3 and let <span class="math">E</span> be the event that an encapsulation is submitted to the decapsulation oracle which would have different decapsulations in Game 2 and Game 3. Since Game 2 and Game 3 are identical if <span class="math">E</span> does not occur we must have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr[A_{2}]-Pr[A_{3}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq Pr[E]\\,.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now <span class="math">E</span> will only occur if the attacker <span class="math">\\mathcal{A}</span> submits a ciphertext <span class="math">(C_{1}^{<em>},C_{2})</span>, with <span class="math">C_{2}\\neq C_{2}^{</em>}</span>, for which the last <span class="math">n_{2}</span>-bits of</p>

    <p class="text-gray-300"><span class="math">Hash(C_{2}\\oplus\\mathcal{D}(C_{1}^{*},sk))</span></p>

    <p class="text-gray-300">maps, under <span class="math">\\phi</span>, to <span class="math">\\mathcal{D}(C_{1}^{<em>},sk)</span>. Since <span class="math">C_{2}\\oplus\\mathcal{D}(C_{1}^{</em>},sk)\\neq r^{<em>}</span> and <span class="math">Hash</span> is a random oracle, <span class="math">Hash(C_{2}\\oplus\\mathcal{D}(C_{1}^{</em>},sk))</span> will be a random bit-string and so <span class="math">\\phi</span> will map the last <span class="math">n_{2}</span> bits of this onto a completely random element of <span class="math">\\mathcal{M}</span>. So</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr[A_{3}]-Pr[A_{4}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq Pr[E]\\leq\\frac{q_{D}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\,.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We are now in a position to describe the simulators. We start by initialising four empty lists: <span class="math">DecList</span>, <span class="math">MaskList</span>, <span class="math">MGFList</span> and <span class="math">HashList</span>. If the attacker requests the evaluation of the mask generating function <span class="math">MGF</span> on the input <span class="math">X</span> then the following steps are performed:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check to see if there exists a pair <span class="math">(X,Mask)\\in MGFList</span>, for some value <span class="math">Mask</span>. If so, output <span class="math">Mask</span> and halt.</li>

      <li>Check to see if <span class="math">X\\in\\mathcal{M}</span>. If not, generate <span class="math">Mask</span> uniformly at random from the set <span class="math">\\{0,1\\}^{n}</span>, add <span class="math">(X,Mask)</span> to <span class="math">MGFList</span> and output <span class="math">Mask</span>.</li>

      <li>Check to see if <span class="math">\\mathcal{E}(X,pk)=C_{1}^{<em>}</span>. If so, output <span class="math">X</span> as the inverse of <span class="math">C_{1}^{</em>}</span> and terminate the entire algorithm.</li>

      <li>Check to see if <span class="math">(\\mathcal{E}(X,pk),Mask)\\in MaskList</span> for some value of <span class="math">Mask</span>. If so, output <span class="math">Mask</span> and halt.</li>

      <li>Generate <span class="math">Mask</span> uniformly at random from the set <span class="math">\\{0,1\\}^{n}</span>, add <span class="math">(X,Mask)</span> to <span class="math">MGFList</span>, add <span class="math">(\\mathcal{E}(X,pk),Mask)</span> to <span class="math">MaskList</span> and output <span class="math">Mask</span>.</li>

    </ol>

    <p class="text-gray-300">If the attacker requests the decapsulation of the encapsulation <span class="math">(C_{1},C_{2})</span> then the following steps are performed:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check to see if <span class="math">(C_{1},C_{2},K)\\in DecList</span>. If so, output <span class="math">K</span> and halt.</li>

      <li>Check to see if <span class="math">C_{1}=C_{1}^{*}</span>. If so, output <span class="math">\\bot</span> and halt.</li>

      <li>Check to see if <span class="math">(C_{1},Mask)\\in MaskList</span> for some value of <span class="math">Mask</span>. If not, generate <span class="math">Mask</span> uniformly at random from the set <span class="math">\\{0,1\\}^{n}</span> and add <span class="math">(C_{1},Mask)</span> to <span class="math">MaskList</span>.</li>

      <li>Set <span class="math">r=C_{2}\\oplus Mask</span>.</li>

      <li>Set <span class="math">R=Hash(r)</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6. Split <span class="math">R</span> into two strings <span class="math">K\\in\\{0,1\\}^{n_{1}}</span> and <span class="math">R^{\\prime}\\in\\{0,1\\}^{n_{2}}</span> where $R=K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^{\\prime}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check to see if <span class="math">C_{1}=\\mathcal{E}(\\phi(R^{\\prime}),pk)</span>. If not, add <span class="math">(C_{1},C_{2},\\bot)</span> to <span class="math">DecList</span>, output <span class="math">\\bot</span> and halt.</li>

      <li>Add <span class="math">(C_{1},C_{2},K)</span> to <span class="math">DecList</span>, output <span class="math">K</span> and halt.</li>

    </ol>

    <p class="text-gray-300">If the attacker (or the decryption function) requests the evaluation of the hash function <span class="math">Hash</span> on the input <span class="math">r</span> then the following steps are performed:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check to see if <span class="math">(r,R)\\in HashList</span> for some value of <span class="math">R</span>. If so, output <span class="math">R</span> and halt.</li>

      <li>Otherwise, generate <span class="math">R</span> uniformly at random from the set <span class="math">\\{0,1\\}^{n_{1}+n_{2}}</span>, add <span class="math">(r,R)</span> to <span class="math">HashList</span> and output <span class="math">R</span>.</li>

    </ol>

    <p class="text-gray-300">We use these simulators in the standard way, as shown in Section D, to invert the ciphertext <span class="math">C_{1}^{<em>}</span>. We therefore require that the simulators perfectly simulate the attacker’s normal environment </em>up until the point where the</p>

    <p class="text-gray-300">inverse of <span class="math">C_1^<em></span> is found. It is with some regret that we note that this is not the case at the moment, because when the hash function is queried on the input <span class="math">r^</em></span> the simulators will output a random bit string instead of the "proper" answer <span class="math">R^*</span>. We must tweak the environment slightly to show that this does not make a significant difference.</p>

    <p class="text-gray-300">Let Game 4 be similar to Game 3 but, if the hash function is evaluated on the input <span class="math">r^<em></span> before the mask generating function is evaluated on the input <span class="math">\\mathcal{D}(C_1^</em>, sk)</span>, then the hash function outputs an appropriately sized bit-string that has been generated at random. The simulators certainly perfectly simulate this environment. Let <span class="math">A_4</span> be the event that the attacker wins in Game 4 and let <span class="math">E</span> be the event that the hash function is evaluated on the input <span class="math">r^<em></span> before the mask generating function is evaluated on the input <span class="math">\\mathcal{D}(C_1^</em>, sk)</span>. Since Game 3 and Game 4 are identical provided <span class="math">E</span> does not occur, so</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr[A_3] - Pr[A_4] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq Pr[E].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Now, since the mask generating function has not been evaluated on <span class="math">\\mathcal{D}(C_1^<em>, sk)</span>, the attacker can have no knowledge of <span class="math">MGF(\\mathcal{D}(C_1^</em>, sk)) = C_2^<em> \\oplus r^</em></span>. So, since <span class="math">C_2^<em></span> is known, the attacker can have no knowledge of <span class="math">r^</em></span> and so the only way that the hash function <span class="math">Hash</span> can be evaluated on <span class="math">r^*</span> is by chance. Therefore,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr[A_3] - Pr[A_4] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq Pr[E] \\leq \\frac{q_H + q_D}{2^n}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Now that we have now simulated the environment successfully, we can use standard techniques to show that the probability that we successfully invert the given ciphertext is at least the advantage of the attacker in Game 4. Hence the probability that we successfully invert the ciphertext in Game 1 is at least</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Adv - \\frac{q_H + q_D}{2^n} - \\frac{q_D}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - \\frac{q_D}{2^n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">So, if there exists an attacker for the KEM that has non-negligible advantage then there exists an algorithm that inverts the underlying encryption scheme with non-negligible advantage. Alternatively, if the underlying encryption scheme is one-way secure then the KEM will be IND-CCA2 secure.</p>`;
---

<BaseLayout title="A  Designer&#x27;s Guide to KEMs (2002/174)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2002 &middot; eprint 2002/174
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
