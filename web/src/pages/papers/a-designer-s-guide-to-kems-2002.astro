---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2002/174';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = 'A Designer&#x27;s Guide to KEMs';
const AUTHORS_HTML = 'Alexander W. Dent';

const CONTENT = `    <p class="text-gray-300">Alexander W. Dent</p>

    <p class="text-gray-300">Information Security Group, Royal Holloway, University of London, Egham Hill, Egham, Surrey, U.K. alex@fermat.ma.rhul.ac.uk http://www.isg.rhul.ac.uk/~alex/</p>

    <p class="text-gray-300">There have been several pieces of technical errata for this paper since it was first published. This copy of the paper contains corrected proofs, but earlier copies will contain the following errors:</p>

    <p class="text-gray-300">An issue was identified with the original construction given in Section 6. The original proposed construction makes the implicit assumption that because the encryption scheme (G, E, D) is deterministic there exists only ciphertext C ∈ C such that D(C, sk) = x for every x. This assumption is false. We solve this problem by adding an extra step to the decryption algorithm, between the original steps 2 and 3. This new step is defined as:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that C = E(x, pk). If not, output ⊥ and halt. Note that this step is unnecessary if there exists only one ciphertext that corresponds to each message or if it is computationally infeasible for an attacker to find two ciphertexts that decrypt to give the same value.</li>
    </ol>

    <p class="text-gray-300">It was pointed out (by Nigel Smart of the University of Bristol) that the proof of security for the generalised PSEC-KEM construction given in Section 5 requires a plaintext-ciphertext checking oracle. This was not originally stated in the theorem. This means that, in terms of assumptions, the original constructions of Sections 6 and 7 are optimal.</p>

    <p class="text-gray-300">It was pointed out (by James Birkett of Royal Holloway, University of London) that the proof of Theorem 2 given in Appendix A contains numerous small errors. In particular, the two simulated oracles do not give consistent responses to attacker queries, thereby allowing the attacker to distinguish between the cases where he is dealing with proper and simulated decryption oracles.</p>

    <p class="text-gray-300">Alexander W. Dent</p>

    <p class="text-gray-300">Information Security Group, Royal Holloway, University of London, Egham Hill, Egham, Surrey, U.K. alex@fermat.ma.rhul.ac.uk http://www.isg.rhul.ac.uk/~alex/</p>

    <p class="text-gray-300">Abstract. A generic or KEM-DEM hybrid construction is a formal method for combining asymmetric and symmetric encryption techniques to give an efficient, provably secure public-key encryption scheme. This method combines an asymmetric key encapsulation mechanism (KEM) with a symmetric data encapsulation mechanism (DEM). A KEM is a probabilistic algorithm that produces a random symmetric key and an asymmetric encryption of that key. A DEM is a deterministic algorithm that takes a message and a symmetric key and encrypts the message under that key. Each of these components must satisfy its own security conditions if the overall scheme is to be secure. In this paper we describe generic constructions for provably secure KEMs based on weak encryption algorithms. We analyse the two most popular techniques for constructing a KEM and note that they are either overly complex or based on needlessly strong assumptions about the security of the underlying trapdoor function. Hence we propose two new, simple methods for constructing a KEM where the security of the KEM is based on weak assumptions about the underlying function. Lastly we propose a new KEM based on the Rabin function that is both efficient and secure, and is the first KEM to be proposed whose security depends upon the intractability of factoring.</p>

    <h2 id="sec-1" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Whilst most dedicated public-key encryption algorithms are fine for sending short messages, many schemes have problems sending long or arbitrary length messages. Most of the normal &quot;modes of operation&quot; which might allow a sender to send a long message using a public-key encryption algorithm directly are cripplingly inefficient.</p>

    <p class="text-gray-300">One particular way to solve these problems is to use symmetric encryption with a randomly generated key to encrypt a message, and then use asymmetric cryptography to encrypt that (short) random key. This method has been cryptographic folklore for years and, as such, was not formally studied. This led to papers such as [3] which can be used to attack schemes in which the set of symmetric keys is significantly smaller than the message space of the asymmetric scheme used to encrypt them. This folklore has recently been formalised in terms of a generic or KEM-DEM construction [4]. In this construction the encryption scheme is divided into two parts: an asymmetric KEM and a symmetric DEM. A KEM (or key encapsulation mechanism) is a probabilistic algorithm that produces a random symmetric key and an encryption of that key. A DEM (or data encapsulation mechanism) is a deterministic algorithm that encrypts a message of arbitrary length under the key given by the KEM.</p>

    <p class="text-gray-300">This approach to the construction of hybrid ciphers has quickly become popular. Not only have several KEM schemes been proposed in the research literature [4, 7] but this approach has been adopted by the ISO standardisation body [12]. However KEMs are still proposed in an ad hoc fashion. Currently, if one wishes to propose a KEM based on one particular trapdoor problem then it is necessary to design such a KEM from scratch.</p>

    <p class="text-gray-300">In this paper we examine generic methods for constructing KEMs from weak encryption schemes. We analyse the two methods for constructing a KEM based on existing schemes and show that either they require the underlying encryption scheme to have security properties which are stronger than they need to be or they are overly complex. We also provide two new generic construction methods which overcome these problems. Essentially this paper gives a toolbox to allow an algorithm designer to construct a KEM from almost any cryptographic problem. To demonstrate the power of the results we will also propose a new KEM, Rabin-KEM, that is as secure as factoring.</p>

    <p class="text-gray-300">It should be noted that most of the results contained in this paper can be easily adapted to simple, &quot;one-pass&quot; key-agreement protocols like the Diffie-Hellman key agreement scheme [5].</p>

    <h2 id="sec-2" class="text-2xl font-bold">2 The Security of a KEM</h2>

    <p class="text-gray-300">A KEM is a triple of algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>a key generation algorithm, KEM .Gen, which takes as input a security parameter 1&lt;sup&gt;λ&lt;/sup&gt; and outputs a public/secret key-pair (pk, sk),</li>
      <li>a encapsulation algorithm, KEM .Encap, that takes as input a publickey pk and outputs an encapsulated key-pair (K, C) (C is sometimes said to be an encapsulation of the key K),</li>
      <li>a decapsulation algorithm, KEM .Decap, that takes as input an encapsulation of a key C and a secret-key sk, and outputs a key K.</li>
    </ul>

    <p class="text-gray-300">Obviously if the scheme is to be useful we require that, with overwhelming probability, the scheme is sound, i.e. for almost all (pk, sk) = KEM .Gen(1&lt;sup&gt;λ&lt;/sup&gt; ) and almost all (K, C) = KEM .Encap(pk) we have that K = KEM .Decap(C, sk). We also assume that the range of possible keys K is some set of fixed length binary strings, {0, 1} KEM.KeyLen(λ) .</p>

    <p class="text-gray-300">We choose to approach provable security from an asymptotic/complexity theoretic point of view and suggest that a scheme is secure if the probability of breaking that scheme is negligible as a function of the security parameter.</p>

    <p class="text-gray-300">Definition 1. A function f is said to be negligible if, for all polynomials p, there exists a constant N&lt;sup&gt;p&lt;/sup&gt; such that</p>

    <p class="text-gray-300"><span class="math">$f(x) \\le \\frac{1}{p(x)} \\text{ for all } x \\ge N_p.</span>$</p>

    <p class="text-gray-300">A KEM is considered secure if there exists no attacker with a significant advantage in winning the following game played against a mythical challenger.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The challenger generates a public/secret key-pair (pk, sk) = KEM .Gen(1&lt;sup&gt;λ&lt;/sup&gt; ) and passes pk to the attacker.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The attacker runs until it is ready to receive a challenge encapsulation pair. During this time the attacker may repeatedly query a decapsulation oracle to find the key associated with any encapsulation.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The challenger prepares a challenge encapsulated key-pair as follows:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) The challenger generates a valid encapsulated key-pair (K0, C) = KEM .Encap(pk).</li>
      <li>(b) The challenger selects an alternate key K&lt;sup&gt;1&lt;/sup&gt; chosen uniformly at random from the set {0, 1} KEM.Gen(λ) .</li>
      <li>(c) The challenger selects a bit σ uniformly at random from {0, 1}. The challenger then passes (Kσ, C) to the attacker.</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The attacker is allowed to run until it outputs a guess σ 0 for σ. During this time the attacker may repeatedly query a decapsulation oracle to find the key associated with any encapsulation except the challenge encapsulation C.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The attacker is said to win this game if σ &lt;sup&gt;0&lt;/sup&gt; = σ. We define an attacker's advantage Adv to be</p>

    <p class="text-gray-300"><span class="math">$Pr[\\sigma&#x27; = \\sigma] - 1/2.</span>$</p>

    <p class="text-gray-300">If the maximum advantage of any attacker against a KEM is negligible (as a function of λ) then the KEM is said to be IND-CCA2 secure.</p>

    <p class="text-gray-300">A KEM is only useful when coupled with a DEM (a data encapsulation mechanism) to form a hybrid public-key encryption scheme. A DEM is a symmetric algorithm that takes a message and a key, and encrypts the message under that key. In order for the overall hybrid encryption scheme to be secure, the KEM and the DEM must satisfy certain security properties. Happily these properties are independent (i.e. the security properties that a KEM must have are independent of the security properties of the DEM). For the overall encryption scheme to be IND-CCA2 secure (in the sense given below) the KEM, in particular, must be IND-CCA2 secure. For further details of hybrid constructions using KEMs and DEMs, and their security properties, the reader is referred to [4].</p>

    <h2 id="sec-3" class="text-2xl font-bold">3 The Security of an Encryption Scheme</h2>

    <p class="text-gray-300">We will require formal definitions for an asymmetric encryption scheme. It will suit our purposes to draw a distinction between a deterministic and probabilistic encryption schemes as they present slightly different challenges to the KEM designer. We will start by considering deterministic encryption schemes.</p>

    <p class="text-gray-300">Definition 2. A deterministic encryption scheme is a triple (G, E, D) where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>G is the key-generation algorithm which takes as input a security parameter 1 &lt;sup&gt;λ&lt;/sup&gt; and outputs a public/secret key-pair (pk, sk),</li>
      <li>E is the encryption algorithm which takes as input a message m ∈ M and the public-key pk and outputs a ciphertext C ∈ C,</li>
      <li>D is the decryption algorithm which takes as input a ciphertext C ∈ C and the secret-key sk and outputs either a message m ∈ M or the error symbol ⊥.</li>
    </ul>

    <p class="text-gray-300">The weakest notion of security for a deterministic encryption scheme is one-way security.</p>

    <p class="text-gray-300">Definition 3. A deterministic encryption scheme (G, E, D) is said to be one-way if the probability that a polynomial time attacker A can invert a randomly generated ciphertext C = E(m, pk) (where m is chosen at random from M) is negligible as a function of λ. Such a cryptosystem is often said to be secure in the OW-CPA model&lt;sup&gt;1&lt;/sup&gt; .</p>

    <p class="text-gray-300">&lt;sup&gt;1&lt;/sup&gt; OW for &quot;one-way&quot; and CPA for &quot;chosen plaintext attack&quot;. The term &quot;chosen plaintext attack&quot; is used because the attacker is not allowed to make decryption queries.</p>

    <p class="text-gray-300">A deterministic encryption scheme (G, E, D) is said to be secure in the OW-CPA+ model if the scheme is one-way even when the attacker has access to an oracle that, when given a ciphertext C ∈ C, determines whether C is a valid ciphertext or not, i.e. whether C is the correct encryption of some message or not.</p>

    <p class="text-gray-300">The idea of allowing an attacker access to an oracle that correctly determines if a ciphertext is valid was first used in a paper by Joye, Quisquater and Yung [6]. The paper used such an oracle to attack an early version of the EPOC-2 cipher.</p>

    <p class="text-gray-300">For our purposes, a probabilistic encryption scheme will be viewed as a deterministic scheme whose encryption algorithm takes some random seed as an extra input.</p>

    <p class="text-gray-300">Definition 4. A probabilistic encryption scheme is a triple (G, E, D) where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>G is the key-generation algorithm which takes as input a security parameter 1 &lt;sup&gt;λ&lt;/sup&gt; and outputs a public/secret key-pair (pk, sk),</li>
      <li>E is the encryption algorithm which takes as input a message m ∈ M, a random seed r ∈ R and the public-key pk and outputs a ciphertext C ∈ C,</li>
      <li>D is the decryption algorithm which takes as input a ciphertext C ∈ C and the secret-key sk and outputs either a message m ∈ M or the error symbol ⊥.</li>
    </ul>

    <p class="text-gray-300">To cement the idea that this is a probabilistic system we require that, for all public keys pk that can be obtained from the key generation algorithm with an input 1 &lt;sup&gt;λ&lt;/sup&gt; and for all m ∈ M we have that</p>

    <p class="text-gray-300"><span class="math">$|\\{r \\in \\mathcal{R} : \\mathcal{E}(m, r, pk) = C\\}| \\le \\gamma(\\lambda)/|\\mathcal{R}|</span>$</p>

    <p class="text-gray-300">where C ∈ C and γ(λ)/|R| is negligible as a function of λ. 2</p>

    <p class="text-gray-300">Analogous notions of OW-CPA and OW-CPA+ security can be defined for probabilistic encryption schemes. However, there is another issue that will affect our ability to design KEMs based on probabilistic encryption schemes - the need for a plaintext-ciphertext checking oracle.</p>

    <p class="text-gray-300">Definition 5. For a asymmetric encryption scheme (G, E, D), a plaintextciphertext checking oracle is an oracle that, when given a pair (m, C) ∈ M × C, correctly determines whether C is an encryption of m or not.</p>

    <p class="text-gray-300">&lt;sup&gt;2&lt;/sup&gt; This condition basically states that for any public key and ciphertext, there cannot be two many choices for r that encrypt a message to that ciphertext.</p>

    <p class="text-gray-300">Obviously, if (G, E, D) is a deterministic algorithm then there exists an efficient plaintext-ciphertext checking oracle, however the situation is more complicated for a probabilistic encryption scheme. There are several ways in which a plaintext-ciphertext checking oracle for a probabilistic encryption scheme can be made be available to all parties in a security proof. In particular, it might be possible to construct such an oracle because of the nature of underlying intractability assumption (such as in the case of an encryption scheme based on the gap Diffie-Hellman problem, see [9]). Alternatively, it might be possible to simulate such an oracle using, say, knowledge of the hash queries an attacker has made in the random oracle model [2].</p>

    <h2 id="sec-4" class="text-2xl font-bold">4 Analysing RSA-KEM</h2>

    <p class="text-gray-300">We present a method to construct a KEM from almost all one-way publickey encryption schemes; this generalises the ideas used in RSA-KEM [12].</p>

    <p class="text-gray-300">The construction of a KEM from a deterministic encryption scheme (G, E, D) is given in Table 1. This construction uses a key derivation function KDF. This function is intended to do more than simply format the random number correctly as a key: it is meant to remove algebraic relations between inputs. It is usually constructed from a hash function and will be modelled as a random oracle.</p>

    <p class="text-gray-300">Table 1. A KEM derived from a deterministic encryption scheme</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Key generation is given by the key generation algorithm of the public-key encryption scheme (i.e. KEM .Gen = G).</li>
      <li>Encapsulation is given by:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate an element x ∈ M uniformly at random.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set C := E(x, pk).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set K := KDF(x).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output (K, C).</li>
    </ol></li>
    </ul></li>
      <li>Decapsulation of an encapsulation C is given by:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set x := D(C, sk). If x =⊥ then output ⊥ and halt.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set K := KDF(x).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output K.</li>
    </ol></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Theorem 1. Suppose (G, E, D) is a deterministic asymmetric encryption scheme that is secure in the OW-CPA+ model. Then the KEM derived from (G, E, D) in Table 1 is, in the random oracle model, IND-CCA2 secure.</p>

    <p class="text-gray-300">The proof of this theorem is similar to the of Theorem 2.</p>

    <p class="text-gray-300">This style of KEM can be easily extended to the case where the underlying encryption scheme is probabilistic and not deterministic. The construction is given in Table 2. Note that the encapsulation is included in the input to the key derivation function to prevent the attacker from breaking the scheme by finding a second ciphertext C 0 that decrypts to the same value as the challenge ciphertext C.</p>

    <p class="text-gray-300">Table 2. A KEM derived from a probabilistic encryption scheme</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Key generation is given by the key generation algorithm of the public-key encryption scheme (i.e. KEM .Gen = G).</li>
      <li>Encapsulation is provided by the following algorithm.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate elements x ∈ M and r ∈ R uniformly at random.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set C := E(x, r, pk).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set K := KDF(¯x||C), where ¯x is a fixed length representation of the element x ∈ M.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output (K, C).</li>
    </ol></li>
    </ul></li>
      <li>Decapsulation of an encapsulation C is given by the following algorithm.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set x := D(C, sk). If x =⊥ then output ⊥ and halt.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set K := KDF(¯x||C) where ¯x is a fixed length representation of the element x ∈ M.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output K.</li>
    </ol></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Theorem 2. Suppose (G, E, D) is a probabilistic asymmetric encryption scheme</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>that is secure in the OW-CPA+ model, and</li>
      <li>for which there exists a plaintext-ciphertext checking oracle.</li>
    </ul>

    <p class="text-gray-300">Then the KEM derived from (G, E, D) in Table 2 is, in the random oracle model, IND-CCA2 secure.</p>

    <p class="text-gray-300">Proof See Appendix A</p>

    <h2 id="sec-5" class="text-2xl font-bold">5 Analysing PSEC-KEM</h2>

    <p class="text-gray-300">Obviously it would be advantageous if we were able to remove the reliance on these non-optimal security criteria, i.e. produce a generic method for constructing a KEM from an OW-CPA encryption scheme rather than from an OW-CPA+ encryption scheme and requiring a plaintextciphertext checking oracle. In this section, we present a method to construct a KEM from a OW-CPA encryption scheme (for which there exists a plaintext-ciphertext checking oracle); this generalises the ideas used in PSEC-KEM [12].</p>

    <p class="text-gray-300">Table 3 gives a construction for a KEM from a (deterministic or probabilistic) asymmetric encryption scheme (G, E, D). In the construction Hash is a hash function and MGF is a mask generating function. A mask generating function is similar to a key derivation function, in fact the same constructions are used for both, but a mask generating function is used to create a bit string that is used to mask a data value. We will model these function as random oracles, hence care must be taken to ensure that the outputs of the hash function and the mask generating function are suitably independent. We also use a &quot;smoothing function&quot; φ : {0, 1} &lt;sup&gt;n&lt;/sup&gt;&lt;sup&gt;2&lt;/sup&gt; → M, where M is the message space of the encryption scheme (G, E, D). This function must have the property that for Y &lt;sup&gt;0&lt;/sup&gt; drawn uniformly at random from {0, 1} &lt;sup&gt;n&lt;/sup&gt;&lt;sup&gt;2&lt;/sup&gt; and X ∈ M we have</p>

    <p class="text-gray-300"><span class="math">$Pr[\\phi(Y&#x27;) = X] - \\frac{1}{|\\mathcal{M}|}</span>$</p>

    <p class="text-gray-300">is negligible.</p>

    <p class="text-gray-300">For security, it is necessary that n is suitably large. Certainly n ≥ λ would be sufficient. Of the other lengths, n&lt;sup&gt;1&lt;/sup&gt; should equal KEM.Keylen and n&lt;sup&gt;2&lt;/sup&gt; merely has to be large enough so that there exists a function φ which is suitably smooth.</p>

    <p class="text-gray-300">Theorem 3. Suppose (G, E, D) is an asymmetric encryption scheme that is secure in the OW-CPA model and for which there exists a plaintextciphertext checking oracle. Then the KEM derived from (G, E, D) in Table 3 is, in the random oracle model, IND-CCA2 secure.</p>

    <p class="text-gray-300">A sketch proof is given in Appendix D.</p>

    <h2 id="sec-6" class="text-2xl font-bold">6 A New Construction for a Deterministic Encryption Scheme</h2>

    <p class="text-gray-300">Although the construction given in Section 5 (the generalisation of PSEC-KEM) is based on weaker assumptions than the construction of Section 4, it is not optimal as it requires us to assume the existence of a plaintextciphertext checking oracle and is very complex. We now propose a simpler construction for designing a KEM based on a deterministic encryption scheme with similarly weak security assumptions. In other words,</p>

    <p class="text-gray-300">Table 3. A KEM derived from a OW-CPA secure encryption scheme</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Key-generation is given by G, i.e. KEM .Gen = G.</li>
      <li>Encapsulation is given by:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate a suitably large bit-string y ∈ {0, 1} n .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set Y := Hash(y).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Split Y into two strings K ∈ {0, 1} &lt;sup&gt;n&lt;/sup&gt;&lt;sup&gt;1&lt;/sup&gt; and Y &lt;sup&gt;0&lt;/sup&gt; ∈ {0, 1} &lt;sup&gt;n&lt;/sup&gt;&lt;sup&gt;2&lt;/sup&gt; where Y = K||Y 0 .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set X := φ(Y 0 ).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set C&lt;sup&gt;1&lt;/sup&gt; := E(X, pk). (If E is probabilistic then generate a random seed r ∈ R and set C&lt;sup&gt;1&lt;/sup&gt; := E(X, r, pk).)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set C&lt;sup&gt;2&lt;/sup&gt; := y ⊕ MGF(X).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set C = (C1, C2).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output (K, C).</li>
    </ol></li>
    </ul></li>
      <li>Decapsulation of an encapsulation C is given by:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse C as (C1, C2).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set X := D(C1, sk). If x =⊥ then output ⊥ and halt.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set y = C&lt;sup&gt;2&lt;/sup&gt; ⊕ MGF(X).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set Y = Hash(y).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Split Y into two strings K ∈ {0, 1} &lt;sup&gt;n&lt;/sup&gt;&lt;sup&gt;1&lt;/sup&gt; and Y &lt;sup&gt;0&lt;/sup&gt; ∈ {0, 1} &lt;sup&gt;n&lt;/sup&gt;&lt;sup&gt;2&lt;/sup&gt; where Y = K||Y 0 .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that φ(Y 0 ) = X. If not, output ⊥ and halt.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output K.</li>
    </ol></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">we build a secure KEM from a deterministic encryption scheme that is secure in the OW-CPA model, as opposed to the OW-CPA+ model as in Section 4. The construction can be viewed as a simpler version of the REACT construction [10].</p>

    <p class="text-gray-300">Table 4 gives a construction of a KEM based on a deterministic asymmetric encryption scheme (G, E, D). The scheme makes use of a key derivation function KDF and a hash function Hash. These functions will be modelled as random oracles and so care must be taken that their outputs are suitably independent.</p>

    <p class="text-gray-300">Theorem 4. Suppose that (G, E, D) is a deterministic encryption algorithm that is secure in the OW-CPA model. Then the KEM derived from (G, E, D) in Table 4 is, in the random oracle model, IND-CCA2 secure.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Proof See Appendix B</h4>

    <p class="text-gray-300">This construction also has the advantage that the decryption algorithm need not return a unique solution but need only return a small subset of the message space that includes the original message, as, with high probability, the original message will be the only message in the subset that hashes to give the correct value of C2. We will make heavy use of this fact in the specification of Rabin-KEM (see Sect. 8).</p>

    <p class="text-gray-300">Table 4. A KEM derived from an OW-CPA secure, deterministic encryption scheme</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Key-generation is given by G, i.e. KEM .Gen = G.</li>
      <li>Encapsulation is given by:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate a suitably large bit-string x ∈ M.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set C&lt;sup&gt;1&lt;/sup&gt; := E(x, pk).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set C&lt;sup&gt;2&lt;/sup&gt; := Hash(x).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set C := (C1, C2).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set K := KDF(x).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output (K, C).</li>
    </ol></li>
    </ul></li>
      <li>Decapsulation of an encapsulation C is given by:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse C as (C1, C2).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set x := D(C1, sk). If x =⊥ then output ⊥ and halt.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that C&lt;sup&gt;1&lt;/sup&gt; = E(x, pk). If not, output ⊥ and halt. (Note, this step may be ignored if there exists only one ciphertext associated with each message or if it is computationally infeasible for an attacker to find two ciphertexts that decrypt to the same value.)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that C&lt;sup&gt;2&lt;/sup&gt; = Hash(x). If not, output ⊥ and halt.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set K := KDF(x).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output K.</li>
    </ol></li>
    </ul></li>
    </ul>

    <h2 id="sec-8" class="text-2xl font-bold">7 A New Construction for a Probabilistic Encryption Scheme</h2>

    <p class="text-gray-300">Although the previous KEM construction can be generalised to be used with a probabilistic encryption scheme, the security proof still relies on the existence of a plaintext-ciphertext checking oracle (which is always easily constructed for a deterministic encryption algorithm). We now give a construction for a probabilistic encryption scheme, loosely based on the ideas of [?], that does not require a plaintext-ciphertext checking oracle. It is interesting to note, however, that this construction cannot be used for a deterministic scheme.</p>

    <p class="text-gray-300">Table 5 gives the construction of a KEM based on a OW-CPA secure, probabilistic encryption scheme. Furthermore the proof of security for this construction does not require there to exist a plaintext-ciphertext checking oracle. The scheme makes use of a key derivation function KDF and a hash function Hash. These functions will be modelled as random oracles and so care must be taken that their outputs are suitably independent.</p>

    <p class="text-gray-300">Theorem 5. Suppose that (G, E, D) is a probabilistic encryption algorithm that is secure in the OW-CPA model. Then the KEM derived from (G, E, D) in Table 5 is, in the random oracle model, IND-CCA2 secure.</p>

    <p class="text-gray-300">Proof See Appendix C</p>

    <p class="text-gray-300">Table 5. A KEM derived from an OW-CPA secure, probabilistic encryption scheme</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Key-generation is given by G, i.e. KEM .Gen = G.</li>
      <li>Encapsulation is given by:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate a suitably large bit-string x ∈ M.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set r := Hash(x).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set C := E(x, r, pk).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set K := KDF(x).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output (K, C).</li>
    </ol></li>
    </ul></li>
      <li>Decapsulation is given by:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set x := D(C, sk). If x =⊥ then output ⊥ and halt.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set r := Hash(x).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that E(x, r, pk) = C. If not, output ⊥ and halt.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set K := KDF(x).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output K.</li>
    </ol></li>
    </ul></li>
    </ul>

    <h2 id="sec-9" class="text-2xl font-bold">8 Case study: Rabin-KEM</h2>

    <p class="text-gray-300">We demonstrate the power of these results by proposing a new KEM whose security is equivalent to factoring: Rabin-KEM. The Rabin-KEM construction will be based on the generic construction given in Sect. 6 and the Rabin trapdoor permutation [8, 11]. The algorithm is described in Table 6.</p>

    <p class="text-gray-300">Theorem 6. Providing the factoring problem is hard, Rabin-KEM is, in the random oracle model, IND-CCA2 secure.</p>

    <p class="text-gray-300">Proof It is well known that the Rabin trapdoor function is one-way providing that the factoring assumption is hard [11]. Therefore, given that the factoring problem is intractable, the given KEM is IND-CCA2 secure in the random oracle model by Theorem 4. ut</p>

    <p class="text-gray-300">This KEM is both and efficient and secure, being the first KEM ever proposed whose security depends on the assumption that factoring is intractable. Of course there is a chance that the decryption algorithm will fail, i.e. that KEM .Decap(C, sk) =⊥ even though C is actually a valid encapsulation of a key K. However this will only happen if there is a collision in the hash function, which, as we model the hash function as a random oracle, only happens with probability 2−Hash.Len (where Hash.Len is the length of the output of the hash function).</p>

    <p class="text-gray-300">Key Generation On input of 1&lt;sup&gt;λ&lt;/sup&gt; for some integer λ &gt; 0,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Randomly generate two distinct primes p and q of bit length λ.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set n := pq.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set pk := (n) and sk := (p, q).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output (pk, sk).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Encapsulation On input of a public key PK,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Randomly generate an integer x ∈ [0, n).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set C&lt;sup&gt;1&lt;/sup&gt; := x &lt;sup&gt;2&lt;/sup&gt; mod n.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set C&lt;sup&gt;2&lt;/sup&gt; := Hash(x).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set C := (C1, C2).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set K := KDF(x).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output (K, C).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Decapsulation On input of an encapsulated key C and a secret key sk.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse C as (C1, C2).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that C&lt;sup&gt;1&lt;/sup&gt; is a square modulo n. If not, output ⊥ and halt.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute the four square roots x1, x2, x3, x&lt;sup&gt;4&lt;/sup&gt; of C&lt;sup&gt;1&lt;/sup&gt; modulo n using the secret key sk.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If there exists no value 1 ≤ i ≤ 4 such that Hash(xi) = C&lt;sup&gt;2&lt;/sup&gt; then output ⊥ and halt.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If there exists more than one value 1 ≤ i ≤ 4 such that Hash(xi) = C&lt;sup&gt;2&lt;/sup&gt; then output ⊥ and halt.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let x be the unique square root of C&lt;sup&gt;1&lt;/sup&gt; modulo n for which Hash(x) = C2.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set K := KDF(x).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output K</li>
    </ol></li>
    </ul>

    <h2 id="sec-10" class="text-2xl font-bold">9 Conclusion</h2>

    <p class="text-gray-300">This paper has provided four generic constructions for key encapsulation mechanisms (KEMs): two generalisations of existing KEMs and two new KEMs. These results show that KEMs can be constructed from almost any trapdoor function. We also proposed a new KEM: Rabin-KEM. This is a new fast, secure KEM based on the intractability of factoring large numbers.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Acknowledgements</h4>

    <p class="text-gray-300">I would like to thank Victor Shoup, Louis Granboulan and Kenny Paterson for some very useful discussions in this area. Nigel Smart and James Birkett both deserve thanks for pointing out errors in some of the proofs. As always the help of Christine Swart has been invaluable.</p>

    <h2 id="sec-12" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway. Relations among notions of security for public-key encryption schemes. In H. Krawczyk, editor, Advances in Cryptology – Crypto '98, volume 1462 of Lecture Notes in Computer Science, pages 26–45. Springer-Verlag, 1998.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>M. Bellare and P. Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In Proc. of the First ACM Conference on Computer and Communications Security, pages 62–73, 1993.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>D. Boneh, A. Joux, and A. Nguyen. Why textbook ElGamal and RSA encryption are insecure. In T. Okamoto, editor, Advances in Cryptology – Asiacrypt 2000, volume 1976 of Lecture Notes in Computer Science, pages 30–43. Springer-Verlag, 2000.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>R. Cramer and V. Shoup. Design and analysis of practical public-key encryption schemes secure against adaptive chosen ciphertext attack. Available from http://shoup.net/, 2002.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>W. Diffie and M. Hellman. New directions in cryptography. IEEE Transactions on Information Theory, 22:644–654, 1976.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>M. Joye, J. Quisquater, and M. Yung. On the power of misbehaving adversaries and security analysis of the original EPOC. In D. Naccache, editor, Topics in Cryptography – CT-RSA 2001, volume 2020 of Lecture Notes in Computer Science, pages 208–222. Springer-Verlag, 2001.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>S. Lucks. A variant of the Cramer-Shoup cryptosystem for groups of unknown order. In Y. Zheng, editor, Advances in Cryptology – Asiacrypt 2002, volume 2501 of Lecture Notes in Computer Science, pages 27–45. Springer-Verlag, 2002.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A. J. Menezes, P. van Oorschot, and S. Vanstone. Handbook of Applied Cryptography. CRC Press, 1997.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>T. Okamoto and D. Pointcheval. The gap problems: A new class of problems for the security of cryptographic schemes. In K. Kim, editor, Public Key Cryptography, volume 1992 of Lecture Notes in Computer Science, pages 104–118. Springer-Verlag, 2001.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>T. Okamoto and D. Pointcheval. REACT: Rapid enhanced-security asymmetric cryptosystem transform. In D. Naccache, editor, Proceedings of CT-RSA 2001, volume 2020 of Lecture Notes in Computer Science, pages 159–175. Springer-Verlag, 2001.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>M. O. Rabin. Digitalized signatures and public-key functions as intractable as factorization. Technical Report MIT/LCS/TR-212, MIT Laboratory for Computer Science, 1979.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>V. Shoup. A proposal for the ISO standard for public-key encryption (version 2.0). Available from http://shoup.net/, 2001.</li>
    </ol></li>
    </ul>

    <h2 id="sec-13" class="text-2xl font-bold">A Proof of Theorem 2</h2>

    <p class="text-gray-300">This is a simple result. We will use standard techniques to prove a more detailed result.</p>

    <p class="text-gray-300">Theorem 7. Let (G, E, D) be an encryption scheme and let KEM be the KEM derived from (G, E, D) using the construction described in Table 2. If there exist an attacker A that, in the random oracle model, breaks KEM in the IND-CCA2 model</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>with advantage ²,</li>
      <li>in time t,</li>
      <li>makes at most q&lt;sup&gt;D&lt;/sup&gt; queries to the decapsulation oracle,</li>
      <li>and at most q&lt;sup&gt;K&lt;/sup&gt; queries to the random oracle that represents the key derivation function,</li>
    </ul>

    <p class="text-gray-300">then there exists an algorithm that inverts the underlying encryption function in the OW-CPA+ model (and makes use of a plaintext-ciphertext checking oracle) with probability ² &lt;sup&gt;0&lt;/sup&gt; and in time t &lt;sup&gt;0&lt;/sup&gt; where</p>

    <p class="text-gray-300"><span class="math">$\\epsilon&#x27; \\ge \\epsilon - q_D/|\\mathcal{M}|,</span>$
(1)</p>

    <p class="text-gray-300"><span class="math">$t&#x27; = t. (2)</span>$</p>

    <p class="text-gray-300">Proof We assume that there exists an attacker for the KEM and use this to construct an algorithm that can break the underlying encryption scheme. Suppose A is an attacker that breaks the KEM with the properties stated above.</p>

    <p class="text-gray-300">Consider the following algorithm that takes as input a public-key pk for the underlying encryption scheme and a challenge ciphertext C ∗ . This algorithm makes use of two lists: KDF List which stores the answers to queries made to the KDF oracle and DecList which stores the answers to queries made to the decapsulation oracle.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Prepare two empty lists KDF List and DecList.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Randomly generate a bit-string K&lt;sup&gt;∗&lt;/sup&gt; of length KEM .KeyLen.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pass the public key to pk to A.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Allow A to run until it requests a challenge encapsulation. If the attacker requests the evaluation of the key derivation function KDF on an input z then the following steps are performed:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Check to see if (z, K) ∈ KDF List for some value of K. If so, return K.</li>
      <li>(b) Check to see if z can be parsed as ¯x||C for some fixed length representation of a message x ∈ M and a ciphertext C ∈ C. If not, randomly generate an appropriately sized K, add (z, K) to KDF List and return K.</li>
      <li>(c) Check to see if C is an encryption of x using the plaintext-ciphertext checking oracle. If not, randomly generate an appropriately sized K, add (z, K) to KDF List and return K.</li>
    </ul></li>
      <li><p class="text-gray-300">(d) Check to see if there exists an entry (C, K) on DecList. If so, add (z, K) to KDF List and return K.</p></li>
      <li><p class="text-gray-300">(e) Randomly generate an appropriately sized K, add (z, K) to KDF List, add (C, K) to DecList and return K.</p></li>
    </ul>

    <p class="text-gray-300">If the attacker requests the decapsulation of an encapsulation C then the following steps are performed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Check to see if C = C ∗ . If so, return ⊥.</li>
      <li>(b) Check to see if (C, K) ∈ DecList for some value K. If so, return K.</li>
      <li>(c) Check to see if C is a valid ciphertext or not (using the oracle provided by the CPA+ model). If not, add (C, ⊥) to DecList and return ⊥.</li>
      <li>(d) Check to see if there exists an entry (¯x||C, K) on KDF List such that C is an encryption of x (using the plaintext-ciphertext checking oracle). If so, add (C, K) to DecList and return K.</li>
      <li>(e) Otherwise randomly generate an appropriately sized K, add (C, K) to DecList and return K.</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>When the attacker requests a challenge encapsulation, return (K&lt;sup&gt;∗&lt;/sup&gt; , C&lt;sup&gt;∗&lt;/sup&gt; )</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Allow the attacker to run until it outputs a bit σ 0 . Answer all oracle queries as before.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check to see if there exists a pair (z, K) ∈ KDF List such that z can be decomposed as ¯x||C &lt;sup&gt;∗&lt;/sup&gt; where ¯x is the fixed length representation of a message x ∈ M and C ∗ is an encryption of x (using the plaintextciphertext checking oracle). If so, output x and halt.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Otherwise randomly generate x ∈ M. Output x and halt.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">This algorithm perfectly simulates the attack environment for A up unless one of two events occur:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The attacker queries the decryption oracle with the challenge ciphertext C ∗ before the challenge ciphertext has been issued to the attacker (i.e. in Step 4). In this case the simulation will return ⊥ when it should return the decryption of C ∗ . We will denote the event that this happens as E1.</li>
      <li>The attacker queries the KDF oracle on the ¯x||C &lt;sup&gt;∗&lt;/sup&gt; where ¯x is the fixed length representative of x &lt;sup&gt;∗&lt;/sup&gt; = D(C, sk). In this case the simulation will return always return a random value (where it should return K&lt;sup&gt;∗&lt;/sup&gt; half the time). We will denote the event that this happens as E2.</li>
    </ul>

    <p class="text-gray-300">Therefore,</p>

    <p class="text-gray-300"><span class="math">$1/2 + \\epsilon = Pr[A \\text{ wins}]</span>$</p>

    <p class="text-gray-300"><span class="math">$= Pr[\\mathcal{A} \\text{ wins}|E_1]Pr[E_1] + Pr[\\mathcal{A} \\text{ wins}|\\neg E_1]Pr[\\neg E_1]</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq Pr[E_1] + Pr[\\mathcal{A} \\text{ wins}|\\neg E_1]</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq q_D/|\\mathcal{M}| + Pr[\\mathcal{A} \\text{ wins}|\\neg E_1]</span>$</p>

    <p class="text-gray-300">as A has no knowledge of C &lt;sup&gt;∗&lt;/sup&gt; before the challenge is issued and so will only submit C ∗ to the decryption oracle by pure chance. Since A makes at most q&lt;sup&gt;D&lt;/sup&gt; oracle queries and the underlying message x &lt;sup&gt;∗&lt;/sup&gt; = D(C ∗ , sk) is chosen at random, the probability that A submits C ∗ to the decryption oracle is bounded by qD/|M|. We now have that</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} 1/2 + \\epsilon &amp;\\leq q_D/|\\mathcal{M}| + Pr[\\mathcal{A} \\text{ wins}|\\neg E_1] \\\\ &amp;= q_D/|\\mathcal{M}| + Pr[\\mathcal{A} \\text{ wins}|\\neg E_1 \\wedge E_2] Pr[E_2|\\neg E_1] + Pr[\\mathcal{A} \\text{ wins}|\\neg E_1 \\wedge \\neg E_2] Pr[\\neg E_2|\\neg E_1] \\\\ &amp;\\leq q_D/|\\mathcal{M}| + Pr[\\mathcal{A} \\text{ wins}|\\neg E_1 \\wedge E_2] + Pr[\\mathcal{A} \\text{ wins}|\\neg E_1 \\wedge \\neg E_2] \\\\ &amp;= q_D/|\\mathcal{M}| + \\epsilon&#x27; + 1/2 \\,. \\end{split}</span>$</p>

    <p class="text-gray-300">This is because if A does not query the KDF oracle on ¯x||C &lt;sup&gt;∗&lt;/sup&gt; where x = D(C ∗ , sk) then (as we are working in the random oracle model) A can have no advantage in winning the IND-CCA2 game; and if A wins the IND-CCA2 game and both E&lt;sup&gt;2&lt;/sup&gt; occurred and E&lt;sup&gt;1&lt;/sup&gt; did not occur, then our solver wins the OW-CPA+ game. Hence,</p>

    <p class="text-gray-300"><span class="math">$\\epsilon&#x27; \\ge \\epsilon - q_D/|\\mathcal{M}|</span>$
.</p>

    <h2 id="sec-14" class="text-2xl font-bold">B Proof of Theorem 4</h2>

    <p class="text-gray-300">We use standard techniques to prove the following, slightly more detailed result.</p>

    <p class="text-gray-300">Theorem 8. Let (G, E, D) be a deterministic encryption scheme and let KEM be the KEM derived from (G, E, D) using the construction described in Table 4. If there exists an attacker A that, in the random oracle model, breaks KEM in the IND-CCA2 model</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>with advantage ²,</li>
      <li>in time t,</li>
      <li>and makes at most q&lt;sup&gt;D&lt;/sup&gt; decapsulation queries,</li>
      <li>at most q&lt;sup&gt;H&lt;/sup&gt; queries to the random oracle that represents the hash function,</li>
      <li>and at most q&lt;sup&gt;K&lt;/sup&gt; queries to the random oracle that represents the key derivation function,</li>
    </ul>

    <p class="text-gray-300">ut</p>

    <p class="text-gray-300">then there exists an algorithm that inverts the underlying encryption function with probability ² &lt;sup&gt;0&lt;/sup&gt; and in time t &lt;sup&gt;0&lt;/sup&gt; where</p>

    <p class="text-gray-300"><span class="math">$\\epsilon&#x27; \\ge \\epsilon - \\frac{q_D}{2^{Hash.Len}} - \\frac{q_D}{|\\mathcal{M}|},</span>$
(3)</p>

    <p class="text-gray-300"><span class="math">$t&#x27; \\le t + (q_H + q_K + q_D)T, \\tag{4}</span>$</p>

    <p class="text-gray-300">where Hash.Len is the length of the output of the hash function Hash and T is the time taken to evaluate the encryption function E.</p>

    <p class="text-gray-300">Proof We assume that there exists an attacker for the KEM and use this to construct an algorithm that can break the underlying encryption scheme. Suppose A is an attacker that breaks the KEM with the properties stated above.</p>

    <p class="text-gray-300">First we slightly change the environment that A operates in. Let game 1 be the game in which A attacks the KEM as described in the IND-CCA2 environment described in Sect. 3. Let game 2 be similar to game 1 except that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the challenge encapsulation (K&lt;sup&gt;∗&lt;/sup&gt; , C&lt;sup&gt;∗&lt;/sup&gt; ) is chosen at the beginning of the algorithm and if the attacker ever requests the decapsulation of C &lt;sup&gt;∗&lt;/sup&gt; = (C ∗ 1 , C&lt;sup&gt;∗&lt;/sup&gt; 2 ) then the decapsulation algorithm returns ⊥,</li>
      <li>instead of allowing the attacker A access to the &quot;real&quot; decapsulation oracle, hash function oracle and KDF oracle we only allow A to have access to the &quot;partially simulated&quot; versions of these oracles described below.</li>
    </ul>

    <p class="text-gray-300">The simulated oracles make use of two lists HashList and KDF List, both of which are initially empty. If the attacker requests the evaluation of the hash function Hash on an input x then the following steps are performed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If (x, hash) ∈ HashList for some value of hash then return hash.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If x = D(C ∗ 1 , sk) then return Hash(x).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Otherwise randomly generate an appropriately sized hash, add (x, hash) to HashList and return hash.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Hence the hash function is changed to a random function with the proviso that it must agree with the original hash function on the input D(C ∗ 1 , sk). This simulation is equivalent to some random oracle and every random oracle can be represented by this simulation. Similarly, if the attacker requests the evaluation of the key derivation function KDF on an input x then the following steps are performed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">(x, K) \\in KDFList</span>  for some value of K then return K.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">x = \\mathcal{D}(C_1^*, sk)</span>  then return KDF(x).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Otherwise randomly generate an appropriately sized K, add (x, K) to KDFList and return K.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">If the attacker requests the evaluation of decapsulation function on the encapsulated key  <span class="math">(C_1, C_2)</span>  then the following steps are performed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">C_1 = C_1^*</span>  then return  <span class="math">\\perp</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that there exists a unique  <span class="math">x \\in \\mathcal{M}</span>  such that  <span class="math">(x, C_2) \\in HashList</span>  and  <span class="math">\\mathcal{E}(x, pk) = C_1</span> . If not, return  <span class="math">\\perp</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute K := KDF(x) using the KDF algorithm described above.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Return K.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">To analyse the effects of only allowing  <span class="math">\\mathcal{A}</span>  to have access to the simulated oracles we require the following simple lemma [1,4].</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> If A, B and E are events is some probability space and that  <span class="math">Pr[A|\\neg E] = Pr[B|\\neg E]</span>  then  <span class="math">|Pr[A] - Pr[B]| \\le Pr[E]</span> .</p>

    <p class="text-gray-300">Let A be the event that  <span class="math">\\mathcal{A}</span>  succeeds in breaking the KEM with access to the real oracles and let B be the event that  <span class="math">\\mathcal{A}</span>  succeeds in breaking the KEM with access to the simulated oracles. Let E be the event that either</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathcal{A}</span>  queries the decapsulation oracle on the challenge encapsulation before the challenge encapsulation is given to  <span class="math">\\mathcal{A}</span> , or</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathcal{A}</span>  queries the decapsulation oracle on some encapsulation  <span class="math">(C_1, C_2)</span>  where  <span class="math">Hash(\\mathcal{D}(C_1, sk)) = C_2</span>  but  <span class="math">\\mathcal{A}</span>  has not queried the hash function simulator on the input  <span class="math">\\mathcal{D}(C_1, sk)</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">If E does not occur then A will receive the same responses to his queries regardless of whether it is querying the real oracles or the simulated oracles. Hence  <span class="math">Pr[A|\\neg E] = Pr[B|\\neg E]</span> .</p>

    <p class="text-gray-300">Since the challenge ciphertext has to be chosen completely at random, the probability that E occurs because  <span class="math">\\mathcal{A}</span>  queries the decapsulation oracle on the challenge encapsulation before it has been issued is bounded above by  <span class="math">q_D/|\\mathcal{M}|</span> . (Since the message is drawn randomly from  <span class="math">\\mathcal{M}</span>  we can bound the probability that  <span class="math">\\mathcal{A}</span>  guesses  <span class="math">C_1^*</span>  in a single oracle query by  <span class="math">1/|\\mathcal{M}|</span> . If this happens, then the attacker may know  <span class="math">\\mathcal{D}(C_1^*, sk)</span>  and so may also know  <span class="math">C_2^* = Hash(\\mathcal{D}(C_1^*, sk))</span> . Hence, we may only bound the probability that this occurs by  <span class="math">q_D/|\\mathcal{M}|</span> .) Since the hash function is modelled as a random oracle, the probability that  <span class="math">\\mathcal{A}</span>  queries the decapsulation oracle on some encapsulation  <span class="math">(C_1, C_2)</span>  where  <span class="math">Hash(\\mathcal{D}(C_1, sk)) = C_2</span>  but  <span class="math">\\mathcal{A}</span>  has</p>

    <p class="text-gray-300">not queried the hash function Hash on the input  <span class="math">\\mathcal{D}(C_1, sk)</span>  is at most  <span class="math">q_D/2^{Hash.Len}</span> . Hence the advantage of  <span class="math">\\mathcal{A}</span>  in game 2 is least</p>

    <p class="text-gray-300"><span class="math">$\\epsilon - \\frac{q_D}{2^{Hash.Len}} - \\frac{q_D}{|\\mathcal{M}|}. \\tag{5}</span>$</p>

    <p class="text-gray-300">Let E' be the event that, in game 2, the attacker queries either the hash function simulator or the key derivation function oracle with the input  <span class="math">x^* = \\mathcal{D}(C_1^*, sk)</span> . Since the attacker can have no knowledge of the whether  <span class="math">KDF(x^*) = K^*</span>  or not unless E' occurs we have that</p>

    <p class="text-gray-300"><span class="math">$Pr[E&#x27;] \\ge \\epsilon - \\frac{q_D}{2^{Hash.Len}} - \\frac{q_D}{|\\mathcal{M}|}.</span>$
(6)</p>

    <p class="text-gray-300">Consider the following algorithm that takes as input a public key pk for the underlying encryption scheme and a challenge ciphertext  <span class="math">C_1^*</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Prepare two empty lists HashList and KDFList.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate random bit strings  <span class="math">C_2^*</span>  of length Hash.Len and  <span class="math">K^*</span>  of length KEM.KeyLen. Set  <span class="math">C^* := (C_1^*, C_2^*)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pass the public key pk to A.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Allow the attacker  <span class="math">\\mathcal{A}</span>  to run until it requests a challenge encapsulation. If the attacker requests the evaluation of the hash function Hash on an input x then the following steps are performed:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">(x, hash) \\in HashList</span>  for some value of hash then return hash.</li>
      <li>(b) Otherwise randomly generate an appropriately sized hash, add (x, hash) to HashList and return hash.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">If the attacker requests the evaluation of the KDF KDF on an input x then the following steps are performed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">(x, K) \\in KDFList</span>  for some value of K then return K.</li>
      <li>(b) Otherwise randomly generate an appropriately sized K, add (x, K) to KDFList and return K.</li>
    </ul>

    <p class="text-gray-300">If the attacker requests the evaluation of decapsulation function on the encapsulated key  <span class="math">(C_1, C_2)</span>  then the following steps are performed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">(a) If  <span class="math">C_1 = C_1^*</span>  then return  <span class="math">\\perp</span> .</p></li>
      <li><p class="text-gray-300">(b) Check that there exists a unique  <span class="math">x \\in \\mathcal{M}</span>  such that  <span class="math">(x, C_2) \\in HashList</span>  and  <span class="math">\\mathcal{E}(x, pk) = C_1</span> . If not, return  <span class="math">\\perp</span> .</p></li>
      <li><p class="text-gray-300">(c) Compute K := KDF(x) using the simulator described above.</p></li>
      <li><p class="text-gray-300">(d) Return K.</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>When the attacker requests a challenge encapsulation pass the pair  <span class="math">(K^*, C^*)</span>  to the attacker.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Allow the attacker to run until it outputs a bit  <span class="math">\\sigma&#x27;</span> . Answer all oracle queries with the simulators described above.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check to see if there exists some (x, hash) ∈ HashLish or (x, K) ∈ KDF List such that E(x, pk) = C ∗ 1 . If so, output x and halt.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Randomly generate x ∈ M. Output x and halt.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">This algorithm perfectly simulates the attack environment for the attacker A in game 2, up until the point where event E&lt;sup&gt;0&lt;/sup&gt; occurs. However, if E&lt;sup&gt;0&lt;/sup&gt; occurs then the above algorithm will correctly output x &lt;sup&gt;∗&lt;/sup&gt; = D(C ∗ 1 , sk). Hence the above algorithm will correctly invert a randomly generated ciphertext with probability at least</p>

    <p class="text-gray-300"><span class="math">$\\epsilon - \\frac{q_D}{2^{Hash.Len}} - \\frac{q_D}{|\\mathcal{M}|} \\,. \\tag{7}</span>$</p>

    <p class="text-gray-300">This value is negligible providing ² is negligible, hence the KEM is secure in the IND-CCA2 model providing the underlying encryption scheme is secure in the OW-CPA model. ut</p>

    <h2 id="sec-15" class="text-2xl font-bold">C Proof of Theorem 5</h2>

    <p class="text-gray-300">Again, we prove a slightly more detailed result.</p>

    <p class="text-gray-300">Theorem 9. Let (G, E, D) be a probabilistic encryption scheme and let KEM be the KEM derived from (G, E, D) using the construction described in Table 5. If there exists an attacker A that, in the random oracle model, breaks KEM in the IND-CCA2 model</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>with advantage ²,</li>
      <li>in time t,</li>
      <li>and makes at most q&lt;sup&gt;D&lt;/sup&gt; decapsulation queries,</li>
      <li>at most q&lt;sup&gt;H&lt;/sup&gt; queries to the random oracle that represents the hash function,</li>
      <li>and at most q&lt;sup&gt;K&lt;/sup&gt; queries to the random oracle that represents the key derivation function.</li>
    </ul>

    <p class="text-gray-300">then there exists an algorithm that inverts the underlying encryption function with probability ² &lt;sup&gt;0&lt;/sup&gt; and in time t &lt;sup&gt;0&lt;/sup&gt; where</p>

    <p class="text-gray-300"><span class="math">$\\epsilon&#x27; \\ge \\frac{1}{q_D + q_H + q_K} \\left(\\epsilon - \\frac{q_D}{|\\mathcal{M}|} - \\frac{\\gamma q_D}{|\\mathcal{R}|}\\right),</span>$
(8)</p>

    <p class="text-gray-300"><span class="math">$t&#x27; \\approx t</span>$
, (9)</p>

    <p class="text-gray-300">where γ is defined in Definition 4.</p>

    <p class="text-gray-300">Proof The proof is similar to that given in Appendix B.</p>

    <p class="text-gray-300">Let game 1 be the game in which A attacks the KEM as described in the IND-CCA2 environment described in Sect. 3. Let game 2 be similar to game 1 except that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the challenge encapsulation (K&lt;sup&gt;∗&lt;/sup&gt; , C&lt;sup&gt;∗&lt;/sup&gt; ) is chosen at the beginning of the algorithm and if the attacker ever requests the decapsulation of C ∗ then the decapsulation algorithm returns ⊥,</li>
      <li>instead of allowing the attacker A access to the &quot;real&quot; decapsulation oracle, hash function oracle and KDF oracle we only allow A to have access to the &quot;partially simulated&quot; versions of these oracles described below.</li>
    </ul>

    <p class="text-gray-300">We simulate the hash function oracle and the KDF oracle exactly as before, making use of two lists, HashList and KDF List, both of which are initially empty. If the attacker requests the evaluation of the hash function Hash on an input x then the following steps are performed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If (x, hash) ∈ HashList for some value of hash then return hash.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If x = D(C ∗ , sk) then return Hash(x).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Otherwise randomly generate an appropriately sized hash, add (x, hash) to HashList and return hash.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">If the attacker requests the evaluation of the key derivation function KDF on an input x then the following steps are performed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If (x, K) ∈ KDF List for some value of K then return K.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If x = D(C ∗ , sk) then return KDF(x).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Otherwise randomly generate an appropriately sized K, add (x, K) to KDF List and return K.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">If the attacker requests the evaluation of the decapsulation function on the encapsulated key C then the following steps are performed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If C = C ∗ then return ⊥.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For each pair (x, hash) ∈ HashList, check whether E(x, hash, pk) = C. If no such pair exists then return ⊥.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If there exists such a pair (x, hash) then run the simulator for the key derivation function on the input x to get a key K.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Return K.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">As before, we note that game 1 and game 2 are identical except if either of the following events occur:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A queries the decapsulation oracle on the challenge encapsulation before the challenge encapsulation is given to A, or</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A queries the decapsulation oracle on some encapsulation C where x = D(C, sk) and C = E(x, Hash(x), pk) but A has not queried the hash function simulator on the input x.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The probability that the first event occurs is bounded above by qD/|M| (as there exists |M| valid encapsulations). The probability that the second event occurs is bounded above by qDγ/|R| (where γ is defined in Definition 4). Hence the advantage of A in game 2 is at least</p>

    <p class="text-gray-300"><span class="math">$\\epsilon - q_D \\left( \\frac{1}{|\\mathcal{M}|} + \\frac{\\gamma}{|\\mathcal{R}|} \\right). \\tag{10}</span>$</p>

    <p class="text-gray-300">Let E&lt;sup&gt;0&lt;/sup&gt; be the event that, in game 2, the attacker queries either the hash function simulator or the key derivation function oracle with the input x &lt;sup&gt;∗&lt;/sup&gt; = D(C ∗ , sk). Again, we have</p>

    <p class="text-gray-300"><span class="math">$Pr[E&#x27;] \\ge \\epsilon - q_D(\\frac{1}{|\\mathcal{M}|} + \\frac{\\gamma}{|\\mathcal{R}|}).</span>$
(11)</p>

    <p class="text-gray-300">Now, consider the following algorithm that takes as input a public key pk for the underlying encryption scheme and a challenge ciphertext C ∗ (which is the encryption of some randomly chosen message x &lt;sup&gt;∗&lt;/sup&gt; ∈ M).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Prepare two empty lists HashList and KDF List.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate a random bit strings K&lt;sup&gt;∗&lt;/sup&gt; of length KEM .KeyLen.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pass the public key pk to A.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Allow the attacker A to run until it requests a challenge encapsulation. If the attacker requests the evaluation of the hash function Hash on an input x then the following steps are performed:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If (x, hash) ∈ HashList for some value of hash then return hash.</li>
      <li>(b) Otherwise randomly generate an appropriately sized hash, add (x, hash) to HashList and return hash.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">If the attacker requests the evaluation of the KDF KDF on an input x then the following steps are performed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If (x, K) ∈ KDF List for some value of K then return K.</li>
      <li>(b) Otherwise randomly generate an appropriately sized K, add (x, K) to KDF List and return K.</li>
    </ul>

    <p class="text-gray-300">If the attacker requests the evaluation of decapsulation function on the encapsulated key C then the following steps are performed:</p>

    <p class="text-gray-300">(a) If C = C ∗ then return ⊥.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(b) Check that there exists a unique x ∈ M such that (x, hash) ∈ HashList and E(x, hash, pk) = C for some value of hash. If not, return ⊥.</li>
      <li>(c) Run the simulator for the key derivation function on the input x to get a key K.</li>
      <li>(d) Return K.</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>When the attacker requests a challenge encapsulation pass the pair (K&lt;sup&gt;∗&lt;/sup&gt; , C&lt;sup&gt;∗&lt;/sup&gt; ) to the attacker.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Allow the attacker to run until it outputs a bit σ 0 . Answer all oracle queries with the simulators described above.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pick, uniformly at random, some value x from the set of x such that either (x, hash) ∈ HashList or (x, K) ∈ KDF List. Output x as the inverse of C ∗ .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">This algorithm perfectly simulates the environment for the attacker in game 2 up until the point in which E&lt;sup&gt;0&lt;/sup&gt; occurs. However if E&lt;sup&gt;0&lt;/sup&gt; occurs then the above correctly output x &lt;sup&gt;∗&lt;/sup&gt; with probability 1/(q&lt;sup&gt;D&lt;/sup&gt; + q&lt;sup&gt;H&lt;/sup&gt; + qK). Hence the above algorithm will correctly invert the encryption of a randomly generated message with probability at least</p>

    <p class="text-gray-300"><span class="math">$\\frac{1}{q_D + q_H + q_K} \\left(\\epsilon - \\frac{q_D}{|\\mathcal{M}|} - \\frac{\\gamma q_D}{|\\mathcal{R}|}\\right). \\tag{12}</span>$</p>

    <p class="text-gray-300">This value is negligible providing ² is negligible, hence the KEM is secure in the IND-CCA2 model providing the underlying encryption scheme is secure in the OW-CPA model. ut</p>

    <h2 id="sec-16" class="text-2xl font-bold">D Proof of Theorem 3</h2>

    <p class="text-gray-300">Again, we actually prove a slightly more detailed result. Suppose A is an attacker which breaks the KEM in the IND-CCA2 model, and that this attacker</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>has advantage ²,</li>
      <li>makes at most q&lt;sup&gt;D&lt;/sup&gt; queries to the decapsulation oracle,</li>
      <li>makes at most q&lt;sup&gt;M&lt;/sup&gt; queries to the mask generating function oracle,</li>
      <li>and at most q&lt;sup&gt;H&lt;/sup&gt; queries to the hash function oracle.</li>
    </ul>

    <p class="text-gray-300">We will use this to construct an algorithm that breaks the underlying cryptosystem. In constructing the algorithm that inverts the underlying cryptosystem we will be challenged to invert a random ciphertext C ∗ 1 (we will use the superscript * to denote variables associated with the challenge ciphertext). For convenience we set</p>

    <p class="text-gray-300"><span class="math">$r^* = C_2^* \\oplus \\mathcal{D}(C_1^*, sk)</span>$</p>

    <p class="text-gray-300">and note that this constrains the behaviour of Hash on  <span class="math">r^*</span> .</p>

    <p class="text-gray-300">We construct the challenge encapsulation pair  <span class="math">(K^*, C^*)</span>  by selecting a random KEM.Keylen-bit integer  <span class="math">K^*</span>  and a random n-bit integer  <span class="math">C_2^*</span>  and setting  <span class="math">C^* = (C_1^*, C_2^*)</span> .</p>

    <p class="text-gray-300">We need to tweak the environment that the attacker runs in, so that we may successfully simulate all the oracles that it has access to. Let Game 1 be the normal IND-CCA2 game. Let Game 2 be the game where the challenge encapsulation pair  <span class="math">(K^*, C^*)</span>  is generated at the start of the algorithm, and if the attacker queries the decapsulation oracle on the input  <span class="math">C^*</span>  then the decapsulation oracle responds with  <span class="math">\\bot</span> . If  <span class="math">A_1</span>  is the event that the attacker wins in Game 1 and  <span class="math">A_2</span>  is the event that the attacker wins in Game 2 then, using Lemma 1, we have</p>

    <p class="text-gray-300"><span class="math">$|Pr[A_1] - Pr[A_2]| \\le \\frac{q_D}{2^n \\cdot |\\mathcal{C}|}.</span>$</p>

    <p class="text-gray-300">Now, since we do not know  <span class="math">\\mathcal{D}(C_1^*, sk)</span> , we will find it hard to simulate the decapsulation of encapsulations of the form  <span class="math">(C_1^*, C_2)</span> . We can avoid this problem by refusing to decapsulate any encapsulation of this form. Let Game 3 be similar to Game 2, but with the decapsulation oracle will outputting  <span class="math">\\bot</span>  whenever it is queried with an encapsulation of the form  <span class="math">(C_1^*, C_2)</span> . Let  <span class="math">A_3</span>  be the event that the attacker wins in Game 3 and let E be the event that an encapsulation is submitted to the decapsulation oracle which would have different decapsulations in Game 2 and Game 3. Since Game 2 and Game 3 are identical if E does not occur we must have</p>

    <p class="text-gray-300"><span class="math">$|Pr[A_2] - Pr[A_3]| \\le Pr[E].</span>$</p>

    <p class="text-gray-300">Now E will only occur if the attacker  <span class="math">\\mathcal{A}</span>  submits a ciphertext  <span class="math">(C_1^*, C_2)</span> , with  <span class="math">C_2 \\neq C_2^*</span> , for which the last  <span class="math">n_2</span> -bits of</p>

    <p class="text-gray-300"><span class="math">$Hash(C_2 \\oplus \\mathcal{D}(C_1^*, sk))</span>$</p>

    <p class="text-gray-300">maps, under  <span class="math">\\phi</span> , to  <span class="math">\\mathcal{D}(C_1^*, sk)</span> . Since  <span class="math">C_2 \\oplus \\mathcal{D}(C_1^*, sk) \\neq r^*</span>  and Hash is a random oracle,  <span class="math">Hash(C_2 \\oplus \\mathcal{D}(C_1^*, sk))</span>  will be a random bit-string and so  <span class="math">\\phi</span>  will map the last  <span class="math">n_2</span>  bits of this onto a completely random element of  <span class="math">\\mathcal{M}</span> . So</p>

    <p class="text-gray-300"><span class="math">$|Pr[A_3] - Pr[A_4]| \\le Pr[E] \\le \\frac{q_D}{|\\mathcal{M}|}.</span>$</p>

    <p class="text-gray-300">We are now in a position to describe the simulators. We start by initialising four empty lists: DecList, M askList, MGF List and HashList. If the attacker requests the evaluation of the mask generating function MGF on the input X then the following steps are performed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check to see if there exists a pair (X, M ask) ∈ MGF List, for some value M ask. If so, output M ask and halt.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check to see if X ∈ M. If not, generate M ask uniformly at random from the set {0, 1} n , add (X, M ask) to MGF List and output M ask.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check to see if E(X, pk) = C ∗ 1 . If so, output X as the inverse of C ∗ 1 and terminate the entire algorithm.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check to see if (E(X, pk), M ask) ∈ M askList for some value of M ask. If so, output M ask and halt.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate M ask uniformly at random from the set {0, 1} n , add (X, M ask) to MGF List, add (E(X, pk), M ask) to M askList and output M ask.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">If the attacker requests the decapsulation of the encapsulation (C1, C2) then the following steps are performed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check to see if (C1, C2, K) ∈ DecList. If so, output K and halt.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check to see if C&lt;sup&gt;1&lt;/sup&gt; = C ∗ 1 . If so, output ⊥ and halt.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check to see if (C1, M ask) ∈ M askList for some value of M ask. If not, generate M ask uniformly at random from the set {0, 1} &lt;sup&gt;n&lt;/sup&gt; and add (C1, M ask) to M askList.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set r = C&lt;sup&gt;2&lt;/sup&gt; ⊕ M ask.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set R = Hash(r).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Split R into two strings K ∈ {0, 1} &lt;sup&gt;n&lt;/sup&gt;&lt;sup&gt;1&lt;/sup&gt; and R&lt;sup&gt;0&lt;/sup&gt; ∈ {0, 1} &lt;sup&gt;n&lt;/sup&gt;&lt;sup&gt;2&lt;/sup&gt; where R = K||R&lt;sup&gt;0&lt;/sup&gt; .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check to see if C&lt;sup&gt;1&lt;/sup&gt; = E(φ(R&lt;sup&gt;0&lt;/sup&gt; ), pk). If not, add (C1, C2, ⊥) to DecList, output ⊥ and halt.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Add (C1, C2, K) to DecList, output K and halt.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">If the attacker (or the decryption function) requests the evaluation of the hash function Hash on the input r then the following steps are performed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check to see if (r, R) ∈ HashList for some value of R. If so, output R and halt.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Otherwise, generate R uniformly at random from the set {0, 1} n1+n&lt;sup&gt;2&lt;/sup&gt; , add (r, R) to HashList and output R.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">We use these simulators in the standard way, as shown in Section D, to invert the ciphertext C ∗ 1 . We therefore require that the simulators perfectly simulate the attacker's normal environment up until the point where the inverse of  <span class="math">C_1^*</span>  is found. It is with some regret that we note that this is not the case at the moment, because when the hash function is queried on the input  <span class="math">r^*</span>  the simulators will output a random bit string instead of the &quot;proper&quot; answer  <span class="math">R^*</span> . We must tweak the environment slightly to show that this does not make a significant difference.</p>

    <p class="text-gray-300">Let Game 4 be similar to Game 3 but, if the hash function is evaluated on the input  <span class="math">r^*</span>  before the mask generating function is evaluated on the input  <span class="math">\\mathcal{D}(C_1^*, sk)</span> , then the hash function outputs an appropriately sized bit-string that has been generated at random. The simulators certainly perfectly simulate this environment. Let  <span class="math">A_4</span>  be the event that the attacker wins in Game 4 and let E be the event that the hash function is evaluated on the input  <span class="math">r^*</span>  before the mask generating function is evaluated on the input  <span class="math">\\mathcal{D}(C_1^*, sk)</span> . Since Game 3 and Game 4 are identical provided E does not occur, so</p>

    <p class="text-gray-300"><span class="math">$|Pr[A_3] - Pr[A_4]| \\le Pr[E].</span>$</p>

    <p class="text-gray-300">Now, since the mask generating function has not been evaluated on  <span class="math">\\mathcal{D}(C_1^*, sk)</span> , the attacker can have no knowledge of  <span class="math">MGF(\\mathcal{D}(C_1^*, sk)) = C_2^* \\oplus r^*</span> . So, since  <span class="math">C_2^*</span>  is known, the attacker can have no knowledge of  <span class="math">r^*</span>  and so the only way that the hash function Hash can be evaluated on  <span class="math">r^*</span>  is by chance. Therefore,</p>

    <p class="text-gray-300"><span class="math">$|Pr[A_3] - Pr[A_4]| \\le Pr[E] \\le \\frac{q_H + q_D}{2^n}</span>$</p>

    <p class="text-gray-300">Now that we have now simulated the environment successfully, we can use standard techniques to show that the probability that we successfully invert the given ciphertext is at least the advantage of the attacker in Game 4. Hence the probability that we successfully invert the ciphertext in Game 1 is at least</p>

    <p class="text-gray-300"><span class="math">$Adv - \\frac{q_H + q_D}{2^n} - \\frac{q_D}{|\\mathcal{M}|} - \\frac{q_D}{2^n |\\mathcal{C}|}.</span>$</p>

    <p class="text-gray-300">So, if there exists an attacker for the KEM that has non-negligible advantage then there exists an algorithm that inverts the underlying encryption scheme with non-negligible advantage. Alternatively, if the underlying encryption scheme is one-way secure then the KEM will be IND-CCA2 secure.</p>

`;
---

<BaseLayout title="A Designer&#x27;s Guide to KEMs (2002/174)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2002 &middot; eprint 2002/174
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="a-designer-s-guide-to-kems-2002" />
  </article>
</BaseLayout>
