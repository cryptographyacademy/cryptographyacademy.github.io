---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/1102';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Challenges with Assessing the Impact of NFS Advances on the Security of Pairing-based Cryptography';
const AUTHORS_HTML = 'Alfred Menezes, Palash Sarkar, Shashank Singh';

const CONTENT = `    <p class="text-gray-300">Alfred Menezes<span class="math">^{1}</span>, Palash Sarkar<span class="math">^{2}</span>, and Shashank Singh<span class="math">^{3}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> Department of Combinatorics &amp; Optimization, University of Waterloo ajmeneze@uwaterloo.ca</p>

    <p class="text-gray-300"><span class="math">^{2}</span> Applied Statistics Unit, Indian Statistical Institute palash@isical.ac.in</p>

    <p class="text-gray-300"><span class="math">^{3}</span> INRIA sha2nk.singh@gmail.com</p>

    <p class="text-gray-300">Abstract. In the past two years there have been several advances in Number Field Sieve (NFS) algorithms for computing discrete logarithms in finite fields <span class="math">\\mathbb{F}_{p^n}</span> where <span class="math">p</span> is prime and <span class="math">n &amp;gt; 1</span> is a small integer. This article presents a concise overview of these algorithms and discusses some of the challenges with assessing their impact on keylengths for pairing-based cryptosystems.</p>

    <p class="text-gray-300">A cryptographic pairing is a non-degenerate bilinear map <span class="math">\\hat{e} : \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span>, where <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T</span> are groups of the same prime order <span class="math">r</span>. The pairing is symmetric if <span class="math">\\mathbb{G}_1 = \\mathbb{G}_2</span>; otherwise it is asymmetric. Such pairings are generally constructed from elliptic curves <span class="math">E</span> defined over a finite field <span class="math">\\mathbb{F}_q</span> and having low embedding degree <span class="math">n</span>. For symmetric pairings, <span class="math">\\mathbb{F}_q</span> is either a characteristic-two or characteristic-three field (with <span class="math">n = 4</span> or <span class="math">n = 6</span>) or a prime field (with <span class="math">n = 2</span>). For asymmetric pairings, <span class="math">\\mathbb{F}_p</span> is a prime field and <span class="math">n</span> is small, e.g., <span class="math">n \\in \\{2, 6, 12, 18, 24\\}</span>. Here, <span class="math">\\mathbb{G}_1</span> and <span class="math">\\mathbb{G}_2</span> are order-<span class="math">r</span> groups of <span class="math">\\mathbb{F}_{q^n}</span>-rational points on <span class="math">E</span>, <span class="math">\\mathbb{G}_T</span> is the order-<span class="math">r</span> subgroup of <span class="math">\\mathbb{F}_{q^n}^*</span>, and the map <span class="math">\\hat{e}</span> is derived from the Weil or Tate pairings.</p>

    <p class="text-gray-300">Beginning in 2001 when Boneh and Franklin proposed their identity-based encryption scheme [11], pairings have become an indispensable instrument in the cryptographer's toolbox. Hundreds (if not thousands) of research papers have been written that use pairings to design protocols that achieve certain cryptographic or efficiency objectives that do not seem attainable with conventional cryptosystems such as RSA and elliptic curve cryptography (ECC). Among these applications are aggregate signature schemes, non-interactive zero-knowledge proof systems, certificateless encryption, attribute-based encryption, and searchable encryption.</p>

    <p class="text-gray-300">A vast majority of research papers on pairing-based protocols treat the underlying pairing <span class="math">\\hat{e}</span> as a black box, and emphasize reductionist security proofs for the protocols with respect to some hardness assumption on <span class="math">\\hat{e}</span>. An unfortunate consequence of this predominant point of view is that issues with functionality, efficiency and security of the pairing-based protocols have not been given the attention they deserve sometimes leading to misleading or incorrect claims. For example, beginning with the BLS signature scheme [12], many papers described protocols using so-called Type-2 asymmetric pairings whereby <span class="math">\\mathbb{G}_1 \\neq \\mathbb{G}_2</span> and an efficiently-computable isomorphism <span class="math">\\psi</span> from <span class="math">\\mathbb{G}_2</span> to <span class="math">\\mathbb{G}_1</span> is known. However, a concrete analysis subsequently revealed that Type 2 pairings are inferior to their Type 3 counterparts with respect to functionality, efficiency and security, and therefore there is no reason to use them [14] (see also [15]). As a second example, consider the Boneh-Shacham group signature scheme with asymmetric pairings <span class="math">\\hat{e} : \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span> in which</p>

    <p class="text-gray-300">|  BN curves: n = 12, ρ ≈ 1 p(z) = 36z^4 + 36z^3 + 24z^2 + 6z + 1 r(z) = 36z^4 + 36z^3 + 18z^2 + 6z + 1, t(z) = 6z^2 + 1  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  BLS12 curves: n = 12, ρ ≈ 1.5 p(z) = (z - 1)^2(z^4 - z^2 + 1)/3 + z, r(z) = z^4 - z^2 + 1, t(z) = z + 1  |</p>

    <p class="text-gray-300">|  KSS curves: n = 18, ρ ≈ 4/3 p(z) = (z^8 + 5z^7 + 7z^6 + 37z^5 + 188z^4 + 259z^3 + 343z^2 + 1763z + 2401)/21 r(z) = (z^6 + 37z^3 + 343)/343, t(z) = (z^4 + 16z + 7)/7  |</p>

    <p class="text-gray-300">|  BLS24 curves: n = 24, ρ ≈ 1.25 p(z) = (z - 1)^2(z^8 - z^4 + 1)/3 + z, r(z) = z^8 - z^4 + 1, t(z) = z + 1  |</p>

    <p class="text-gray-300">Table 1. Important parameters for the BN, BLS12, KSS and BLS24 families of elliptic curves.</p>

    <p class="text-gray-300">one needs to hash onto  <span class="math">\\mathbb{G}_2</span>  and thereafter apply  <span class="math">\\psi</span>  to the resulting hash value [13]. This protocol, although 'provably secure', is not implementable since no construction of such a pairing is known. As a third example, we mention the bewildering array of contrived hardness assumptions that have been proposed in the literature in order to attain a reductionist security proof (see [32]). It is typically easy to prove that these assumptions are valid in the generic group model. However, their validity in practice is much more difficult to ascertain. Indeed, Cheon [16] showed that the so-called Strong Diffie-Hellman (SDH) problem that had been formulated by Boneh and Boyen [10] can be solved significantly faster than previous believed. Shortly after, Jao and Yoshida [24] showed that Cheon's SDH solver could be used to forge signatures for the Boneh-Boyen signature scheme.</p>

    <p class="text-gray-300">More recently, confidence in the security of pairing-based protocols has been shaken because of spectacular advances in algorithms for solving the discrete logarithm problem (DLP) in  <span class="math">\\mathbb{G}_T</span> , a problem whose intractability is necessary for the security of all pairing-based protocols. Most astonishingly, the DLP in small-characteristic finite fields can now be solved in quasi-polynomial time [3], thereby rendering insecure all protocols that use symmetric pairings derived from elliptic and hyperelliptic curves over small-characteristic finite fields. Moreover, numerous improvements to the Number Field Sieve for computing discrete logarithms in fields  <span class="math">\\mathbb{F}_{p^n}</span>  where  <span class="math">p</span>  is prime and  <span class="math">n &amp;gt; 1</span>  is small have been proposed [4, 31], thereby appearing to decrease the security of popular asymmetric pairings including those derived from Barreto-Naehrig (BN) elliptic curves [8].</p>

    <p class="text-gray-300">The purpose of this paper is to initiate an examination of the impact of the aforementioned NFS improvements on keylengths for protocols that employ asymmetric pairings. Of special interest are parameters for BN [8], BLS12 [7], KSS [30] and BLS24 [7] pairings that achieve the 128-bit and 192-bit security levels in light of the new DLP attacks. Table 1 lists the important parameters for these families of elliptic curves. All elliptic curves  <span class="math">E</span>  are defined over a prime field  <span class="math">\\mathbb{F}_p</span> . The group order  <span class="math">\\# E(\\mathbb{F}_p) = p + 1 - t</span>  is divisible by a prime  <span class="math">r</span> , and we set  <span class="math">\\rho = \\log p / \\log r</span> . In order to achieve the  <span class="math">\\ell</span> -bit security level, one must select the parameter  <span class="math">z</span>  so that the bitlength of  <span class="math">r</span>  is at least  <span class="math">2\\ell</span>  (in order to resist Pollard's rho attack [36] on the DLP in  <span class="math">\\mathbb{G}_1</span> ), and so that the bitlength of  <span class="math">p^n</span>  is sufficiently large to resist NFS attacks on the DLP in  <span class="math">\\mathbb{F}_{p^n}^*</span> .</p>

    <p class="text-gray-300">We find that the published analyses of the NFS algorithms are inherently asymptotic in nature, and that much more work remains to be done before the impact on keylengths can be determined with full confidence. In the meantime, implementers who wish to deploy pairing-based protocols are advised to make conservative parameter choices that ignore hidden constants in the running times of the NFS algorithms. Note that these hidden constants (most likely) have the effect of multiplying</p>

    <p class="text-gray-300">the running time by at least 1, so ignoring them results in an underestimation of the NFS running times.</p>

    <p class="text-gray-300">The remainder of this paper is organized as follows. In §2 we give some examples of the difficulties and limitations of interpreting asymptotic results in practice. Concise overviews of the NFS and the Tower Number Field Sieve (TNFS) and their derivatives are presented in §3 and §4. In §5, we identify some hidden constants in the asymptotic analysis of the TNFS. The combined effect of these hidden constants is difficult to ascertain but can have a significant impact on the concrete running time of the algorithm. In §6, we consider the effect of one such constant, namely the constant that arises in the expression for the upper bound of the norm. Translating the effect of this constant into concrete running times yields several interesting observations on the practical efficiency of the algorithms. We make some concluding remarks in §7.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 Pitfalls in Asymptotic Analysis</h2>

    <p class="text-gray-300">This section gives some examples of the difficulties and limitations of interpreting asymptotic results in practice.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">2.1 Integer Factorization</h3>

    <p class="text-gray-300">The NFS for factoring integers <span class="math">N</span> has running time <span class="math">L_{N}(\\frac{1}{3},1.923)</span> <em>[33]</em>. Here, <span class="math">L_{N}(a,c)</span> with <span class="math">0&lt;a&lt;1</span> and <span class="math">c&gt;0</span> denotes the expression</p>

    <p class="text-gray-300"><span class="math">O\\left(\\exp\\left((c+o(1))(\\log N)^{a}(\\log\\log N)^{1-a}\\right)\\right)</span> (1)</p>

    <p class="text-gray-300">that is <em>subexponential</em> in <span class="math">\\log N</span>. This running time expression hides a multiplicative constant. Moreover, an exact formula for the <span class="math">o(1)</span> term in the exponent is not known.</p>

    <p class="text-gray-300">In the 1990’s, there was considerable debate in standards forums about the RSA keylengths that were needed to ensure long-term security against NFS attacks. While experiments with factoring medium-sized <span class="math">N</span> were being conducted, there was no consensus on how to scale the experimental results to large-sized <span class="math">N</span>. In addition, the NFS has large storage needs and requires a large amount of RAM in order to perform sieving efficiently. Thus, since it is difficult to predict the cost and speed of hardware many years into the future, it was difficult to assess the true <em>cost</em> of running the NFS on large-sized <span class="math">N</span>. Nonetheless, consensus was reached that the conservative approach to determining security levels for RSA would be to use the running time of the NFS as the sole measure. RSA keylength estimates that were made 15 years ago have survived with no changes. In particular, it has become widely accepted that RSA with moduli of bitlengths 1024, 2048, 3072, 7680, 15360, offers security levels of 80, 112, 128, 192, 256 bits, respectively <em>[6]</em>.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.2 Elliptic Curve Discrete Logarithm Problem</h3>

    <p class="text-gray-300">For any fixed <span class="math">n\\geq 4</span>, the Gaudry-Hess-Smart (GHS) Weil descent attack <em>[21]</em> for solving the elliptic curve discrete logarithm problem (ECDLP) in elliptic curves over characteristic-two finite fields <span class="math">\\mathbb{F}_{q^{n}}</span> has running time</p>

    <p class="text-gray-300"><span class="math">O(q^{2+\\epsilon})\\text{ as }q\\to\\infty.</span> (2)</p>

    <p class="text-gray-300">Consider the case of elliptic curves <span class="math">E</span> over <span class="math">\\mathbb{F}_{2^{163}}</span> where <span class="math">\\#E(\\mathbb{F}_{2^{163}})</span> is twice a prime. Pollard’s rho attack takes time <span class="math">2^{81}</span> to compute logarithms in <span class="math">E(\\mathbb{F}_{2^{163}})</span>. One would expect that the GHS attack is not applicable since <span class="math">q=2</span> is small. On the other hand, if one ignores the hidden constant and the <span class="math">\\epsilon</span> term in (2) then one might conclude that by embedding <span class="math">\\mathbb{F}_{2^{163}}</span> in <span class="math">\\mathbb{F}_{2^{25\\cdot 163}}</span> (where we now have <span class="math">q=2^{25}</span> and <span class="math">n=163</span>), the GHS attack would take time approximately <span class="math">2^{50}</span> and thus would be significantly faster than Pollard’s rho method. However, the running time expression (2) hides a very bad dependency on <span class="math">n</span>, namely a multiplicative constant <span class="math">2^{n}!</span>. For <span class="math">n=163</span>, <span class="math">2^{n}!\\approx 2^{2^{170}}</span> which makes it clear that the GHS attack is completely impractical for computing logarithms in elliptic curves over <span class="math">\\mathbb{F}_{2^{163}}</span>.</p>

    <p class="text-gray-300">As another example, we mention Diem’s striking result <em>[18]</em> (see also <em>[19]</em>). Let <span class="math">a</span> and <span class="math">b</span> be fixed positive real numbers with <span class="math">a&lt;b</span>. Then Diem proved that discrete logarithms in the group of rational points on any elliptic curve defined over <span class="math">\\mathbb{F}_{q^{n}}</span> with <span class="math">a\\cdot\\sqrt{\\log q}\\leq n\\leq b\\cdot\\sqrt{\\log q}</span> can be solved in subexponential time</p>

    <p class="text-gray-300"><span class="math">e^{O((\\log q^{n})^{2/3})}.</span></p>

    <p class="text-gray-300">Now, a subexponential-time algorithm for solving the ECDLP could have devastating consequences for the security of conventional ECC whose <em>raison d’être</em> is the belief that the fastest algorithm for solving the ECDLP is Pollard’s rho method which takes fully exponential time. However, Diem’s algorithm is inherently asymptotic and it is generally accepted that it does not pose a threat to the security of ECC in practice where elliptic curves over prime fields or over prime-degree extensions of the field of two elements are employed.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.3 Indistinguishability Obfuscation</h3>

    <p class="text-gray-300">In 2013, Garg et al. <em>[20]</em> gave the first provably-secure construction for a polynomial-time indistinguishability obfuscator. The security proof was for all polynomial-time adversaries under certain assumptions on the underlying cryptographic primitives. However, a concrete analysis undertaken by Mayo <em>[34]</em> highlighted the asymptotic nature of the scheme and its impracticality. Mayo considered the obfuscation of a circuit of depth <span class="math">\\ell^{3}</span> and size <span class="math">\\ell^{5}</span>, where <span class="math">\\ell</span> denotes the security parameter. When the Coron-Lepoint-Tibouchi multilinear map <em>[17]</em> is employed in the Garg et al. obfuscator, the size of the obfuscated circuit for <span class="math">\\ell=128</span> was estimated to be at least <span class="math">2^{1357}</span> bits. Thus, even though the Garg et al. obfuscator was provably secure and efficient within the “polynomial-time” paradigm, it is hopelessly impractical.</p>

    <h2 id="sec-7" class="text-2xl font-bold">3 Overview of the Number Field Sieve</h2>

    <p class="text-gray-300">Let <span class="math">p</span> be a prime, <span class="math">n\\geq 1</span>, and <span class="math">Q=p^{n}</span>. Suppose that <span class="math">p</span> is written as <span class="math">p=L_{Q}(a,c_{p})</span> for real numbers <span class="math">a,c_{p}&gt;0</span>. Depending on the value of <span class="math">a</span>, finite fields <span class="math">\\mathbb{F}_{Q}</span> are classified into the following types: small characteristic if <span class="math">a\\leq 1/3</span>; medium characteristic if <span class="math">1/3&lt;a&lt;2/3</span>; boundary if <span class="math">a=2/3</span>; and large characteristic if <span class="math">a&gt;2/3</span>.</p>

    <p class="text-gray-300">For small-characteristic finite fields, there has been tremendous progress in the discrete logarithm computation. The approach has been based on the function field sieve algorithm and asymptotically the fastest known algorithm runs in quasi-polynomial time <em>[3]</em>.</p>

    <p class="text-gray-300">For the other classes of finite fields, i.e., those with medium to large characteristic, the Number Field Sieve is presently the state-of-the-art. The NFS was initially proposed for integer factorization <em>[33]</em>. Application of the NFS to DLP computation was first proposed by Gordon <em>[22]</em> who considered</p>

    <p class="text-gray-300">prime-order fields. Extensions to composite-order fields were made by Schirokauer [41]. For the case of prime-order fields, improvements were made by Joux and Lercier [27]. Joux, Lercier, Smart and Vercauteren [28] showed that the NFS is applicable to all finite fields. For fields where the prime  <span class="math">p</span>  is of a special form, Joux and Pierrot [29] applied the special NFS to obtain improved complexity.</p>

    <p class="text-gray-300">The NFS is an index-calculus algorithm having three main phases: (i) relation collection, (ii) linear algebra, and (iii) individual logarithm. Asymptotically, the times for the relation collection and the linear algebra phases dominate the time for the individual logarithm phase. The parameters are tuned so that the time for the relation collection phase is equal to the time for the linear algebra phase and this time is the asymptotic run time of the NFS.</p>

    <p class="text-gray-300">Two number fields  <span class="math">\\mathbb{K}_f = \\mathbb{Q}[x] / (f)</span>  and  <span class="math">\\mathbb{K}_g = \\mathbb{Q}[x] / (g)</span>  are defined by choosing irreducible polynomials  <span class="math">f(x)</span>  and  <span class="math">g(x)</span>  over the integers. The required condition on  <span class="math">f(x)</span>  and  <span class="math">g(x)</span>  is that modulo  <span class="math">p</span>  they have a common irreducible factor  <span class="math">\\varphi (x)</span>  of degree  <span class="math">n</span>  over  <span class="math">\\mathbb{F}_p</span> . The field  <span class="math">\\mathbb{F}_{p^n}</span>  is represented by  <span class="math">\\varphi (x)</span> . Let  <span class="math">\\gamma</span>  be a generator of the multiplicative group of  <span class="math">\\mathbb{F}_{p^n}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\alpha, \\beta \\in \\mathbb{C}</span>  and  <span class="math">m \\in \\mathbb{F}_{p^n}</span>  be roots of  <span class="math">f(x)</span> ,  <span class="math">g(x)</span>  and  <span class="math">\\varphi(x)</span>  respectively. The commutative diagram given in Figure 1 shows two homomorphisms  <span class="math">\\mathbb{K}_f \\to \\mathbb{F}_{p^n}</span>  and  <span class="math">\\mathbb{K}_g \\to \\mathbb{F}_{p^n}</span>  given by  <span class="math">\\alpha \\mapsto m</span>  and  <span class="math">\\beta \\mapsto m</span>  respectively. This diagram explains the basic working of the NFS.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. The basic principle of NFS.</p>

    <p class="text-gray-300">Instead of working over the whole number fields  <span class="math">\\mathbb{K}_f</span>  and  <span class="math">\\mathbb{K}_g</span> , one works over the corresponding rings of integers  <span class="math">\\mathcal{O}_f</span>  and  <span class="math">\\mathcal{O}_g</span> . The notion of norm of ideals allows one to define a suitable factor base, namely the prime ideals of  <span class="math">\\mathcal{O}_f</span>  and  <span class="math">\\mathcal{O}_g</span> , whose norms are at most some pre-specified smoothness bound  <span class="math">B</span> . The size of the factor base is  <span class="math">B^{1 + o(1)}</span> , where  <span class="math">B</span>  is chosen so as to balance the times for relation collection and linear algebra.</p>

    <p class="text-gray-300">To generate relations, polynomials  <span class="math">\\phi \\in \\mathbb{Z}[x]</span>  of degree at most  <span class="math">t - 1</span>  are considered. If the principal ideals  <span class="math">\\phi (\\alpha)\\mathcal{O}_f</span>  and  <span class="math">\\phi (\\beta)\\mathcal{O}_g</span>  are  <span class="math">B</span> -smooth, then such a  <span class="math">\\phi</span>  yields a relation among the factor base elements. Formally, a relation is actually a linear relation between the discrete logarithms of certain elements of the field  <span class="math">\\mathbb{F}_{p^n}</span> . Such discrete logarithms are called virtual logarithms <span class="math">^2</span> . The number of relations collected is a little more than  <span class="math">B</span> . This allows carrying out the linear algebra phase to compute the virtual logarithms of the factor base elements. The individual logarithm phase consists of finding the discrete logarithm of some element  <span class="math">h\\in \\mathbb{F}_{p^n}</span> . The task in this phase is to find an element of the form  <span class="math">h^i\\gamma^j</span>  such that the principal ideal generated by the preimage of  <span class="math">h^i\\gamma^j</span>  in  <span class="math">\\mathcal{O}_f</span>  factors into prime ideals of degrees at most  <span class="math">t - 1</span>  and bounded norms. Then the special- <span class="math">q</span>  technique is used to express the desired discrete logarithm in terms of the virtual discrete logarithms of factor</p>

    <p class="text-gray-300">base elements. Since these virtual discrete logarithms have already been computed, it is possible to finally obtain the desired discrete logarithm. We refer to <em>[2]</em> for more details on the relation collection phase and to <em>[23]</em> for the individual discrete logarithm phase.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">3.1 Polynomial Selection and Sizes of Norms</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The crucial step in relation collection is to obtain <span class="math">\\phi\\in\\mathbb{Z}[x]</span> such that the ideals <span class="math">\\phi(\\alpha)\\mathcal{O}_{f}</span> and <span class="math">\\phi(\\beta)\\mathcal{O}_{g}</span> are both smooth. For ensuring this smoothness, it is sufficient to ensure that their norms, i.e., <span class="math">\\mathrm{Res}(f,\\phi)</span> and <span class="math">\\mathrm{Res}(g,\\phi)</span>, are both <span class="math">B</span>-smooth, where <span class="math">\\mathrm{Res}</span> denotes the resultant. Let <span class="math">E</span> be such that the coefficients of <span class="math">\\phi</span> are in <span class="math">\\left[\\,-\\frac{1}{2}E^{2/t},\\frac{1}{2}E^{2/t}\\right],</span> whence $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx E^{2/t}<span class="math"> and the number of polynomials </span>\\phi<span class="math"> that are considered for sieving is </span>E^{2}<span class="math">. Here, the </span>\\ell_{\\infty}<span class="math"> norm </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> of the polynomial </span>\\phi<span class="math"> is the maximum of the absolute values of the coefficients of </span>\\phi<span class="math">. For </span>p=L_{Q}(a,c_{p})<span class="math"> with </span>a>\\frac{1}{3}$, the following can be shown (a more precise bound is provided later in the context of the TNFS):</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Res}(f,\\phi)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O\\left(\\left(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)^{t-1}E^{2(\\deg f)/t}\\right)\\quad\\text{and}\\quad</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Res}(g,\\phi)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O\\left(\\left(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)^{t-1}E^{2(\\deg g)/t}\\right),$ (3)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">yielding the norm bound</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Res}(f,\\phi)\\times\\mathrm{Res}(g,\\phi)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O\\left(\\left(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)^{t-1}E^{(\\deg f+\\deg g)2/t}\\right).$ (4)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The probability of <span class="math">B</span>-smoothness of the product of norms (4) determines the cost of obtaining a single relation and hence the cost of relation collection. A suitable choice of <span class="math">B</span> is made to balance this cost with the cost of the linear algebra step. Thus the value of the product of norms in (4) is crucial for determining the overall run time of the algorithm.</p>

    <p class="text-gray-300">Note that the norm bound is determined by the degrees of <span class="math">f</span> and <span class="math">g</span> and their <span class="math">\\ell_{\\infty}</span> norms. So, to ensure that the norm bound is small, it is required that the degrees and <span class="math">\\ell_{\\infty}</span> norms of <span class="math">f</span> and <span class="math">g</span> are small. Ensuring both of these is a very difficult problem. In the literature several methods for polynomial selection have been proposed which provide polynomials with different trade-offs between degrees and <span class="math">\\ell_{\\infty}</span> norms. We briefly describe some of the important ones next.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">JLSV1 <em>[28]</em>.</h4>

    <p class="text-gray-300">Choose random polynomials <span class="math">f_{0}(x)</span> and <span class="math">f_{1}(x)</span> having small coefficients with <span class="math">\\deg(f_{1})&lt;\\deg(f_{0})=n</span>. Choose a random positive integer <span class="math">\\delta</span> which is slightly greater than <span class="math">\\lceil\\sqrt{p}\\rceil</span> and let <span class="math">(u,v)</span> be a rational reconstruction of <span class="math">\\delta</span> modulo <span class="math">p</span>, i.e., <span class="math">\\delta\\equiv u/v\\pmod{p}</span>. More precisely, <span class="math">(u,v)</span> is obtained as the first row on applying the LLL-reduction algorithm to the matrix</p>

    <p class="text-gray-300">\\[ \\begin{bmatrix}p&0\\\\ \\delta&1\\end{bmatrix}. \\]</p>

    <p class="text-gray-300">Let <span class="math">f(x)=f_{0}(x)+\\delta f_{1}(x)</span> and <span class="math">g(x)=vf_{0}(x)+uf_{1}(x)</span> and <span class="math">\\varphi(x)=f(x)\\bmod p</span>. Repeat the above procedure until <span class="math">f</span> and <span class="math">g</span> are irreducible over <span class="math">\\mathbb{Z}</span> and <span class="math">\\varphi</span> is irreducible over <span class="math">\\mathbb{F}_{p}</span>. For this method, the bound (4) is <span class="math">O\\left(E^{4n/t}Q^{(t-1)/n}\\right)</span>.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">GJL <em>[2]</em>.</h4>

    <p class="text-gray-300">The basic Joux-Lercier method <em>[27]</em> works for prime fields. In <em>[2]</em>, it was generalized to work over composite-order fields. Let <span class="math">\\varphi(x)=x^{n}+\\varphi_{n-1}x^{n-1}+\\cdots+\\varphi_{1}x+\\varphi_{0}</span> and <span class="math">r\\geq n</span>. Define an <span class="math">(r+1)\\times(r+1)</span> matrix <span class="math">M_{\\varphi,r}</span> whose rows are obtained from the coefficients of the polynomials <span class="math">p</span>, <span class="math">px,\\ldots,px^{n-1}</span>, <span class="math">\\varphi(x)</span>, <span class="math">x\\varphi(x),\\ldots,x^{r-n}\\varphi(x)</span>. The LLL algorithm is applied to <span class="math">M_{\\varphi,r}</span>. Let the first row of the resulting LLL-reduced matrix be <span class="math">[g_{0},g_{1},\\ldots,g_{r-1},g_{r}]</span> and let <span class="math">g=\\mathrm{LLL}\\left(M_{\\varphi,r}\\right)</span> denote the</p>

    <p class="text-gray-300">corresponding polynomial <span class="math">g(x) = g_0 + g_1 x + \\cdots + g_{r-1} x^{r-1} + g_r x^r</span>. By construction, <span class="math">\\varphi(x)</span> is a factor of <span class="math">g(x)</span> modulo <span class="math">p</span>.</p>

    <p class="text-gray-300">The GJL procedure for polynomial selection is the following. Let <span class="math">r \\geq n</span> and randomly choose a degree-<span class="math">(r + 1)</span> polynomial <span class="math">f(x)</span> that is irreducible over <span class="math">\\mathbb{Z}</span>, has coefficients of size <span class="math">O(\\log p)</span>, and has a degree-<span class="math">n</span> factor <span class="math">\\varphi(x)</span> modulo <span class="math">p</span> which is both monic and irreducible. The procedure is repeated until <span class="math">g = \\mathrm{LLL}(M_{\\varphi, r})</span> is irreducible over <span class="math">\\mathbb{Z}</span>. In this case, the norm bound (4) is <span class="math">O\\left(E^{2(2r + 1)/t}Q^{(t - 1)/(r + 1)}\\right)</span>.</p>

    <p class="text-gray-300"><strong>Conjugation [2].</strong> Choose a random monic quadratic polynomial <span class="math">\\mu(x)</span> having coefficients of size <span class="math">O(\\log p)</span>, and which is irreducible over <span class="math">\\mathbb{Z}</span> but has a root <span class="math">t</span> modulo <span class="math">p</span>. Let <span class="math">(u, v)</span> be a rational reconstruction of <span class="math">t</span> modulo <span class="math">p</span>. Choose random polynomials <span class="math">g_0(x)</span> and <span class="math">g_1(x)</span> with small coefficients with <span class="math">\\deg g_1 &amp;lt; \\deg g_0 = n</span>. Let <span class="math">g(x) = vg_0(x) + ug_1(x)</span> and <span class="math">f(x) = \\operatorname{Res}_y\\big(\\mu(y), g_0(x) + y \\cdot g_1(x)\\big)</span>. Repeat this until <span class="math">f</span> and <span class="math">g</span> are irreducible over <span class="math">\\mathbb{Z}</span> and <span class="math">\\varphi</span> is irreducible over <span class="math">\\mathbb{F}_p</span>. In this case, the norm bound (4) is <span class="math">O\\left(E^{6n/t}Q^{(t-1)/(2n)}\\right)</span>.</p>

    <p class="text-gray-300"><strong>SS [37].</strong> A general method (called Algorithm-<span class="math">\\mathcal{A}</span>) for polynomial selection was given in [37]. This method has two parameters <span class="math">d</span> and <span class="math">r</span>, where <span class="math">d</span> is a divisor of <span class="math">n</span> and <span class="math">r \\geq n/d</span>. The method uses the LLL algorithm in a more general manner than the GJL method. The norm bound (4) is <span class="math">O\\left(E^{2d(2r+1)/t}Q^{(t-1)/(d(r+1))}\\right)</span>. Putting <span class="math">d = n</span> and <span class="math">r = 1</span> gives the Conjugation method, whereas putting <span class="math">d = 1</span> gives the GJL method. For <span class="math">1 &amp;lt; d &amp;lt; n</span> and also for <span class="math">d = n</span>, <span class="math">r &amp;gt; 1</span>, this method provides trade-offs which cannot be obtained using either the GJL or the Conjugation method.</p>

    <h2 id="sec-11" class="text-2xl font-bold">3.2 Asymptotic Complexity</h2>

    <p class="text-gray-300">For each polynomial selection method, the norm bound (4) can be used to obtain a rough estimate of the efficiency of the resulting DLP computation. It is also possible to convert the norm bound into an asymptotic estimate of the run time. The details of how this can be done are a bit messy and so we skip the details. Instead, we just mention the final results.</p>

    <p class="text-gray-300"><strong>Medium characteristic case:</strong> For <span class="math">p = L_{Q}(a, c_{p})</span> with <span class="math">a &amp;gt; 1/3</span>, the run time of the NFS with the Conjugation method is <span class="math">L_{Q}(1/3, (96/9)^{1/3})</span>.</p>

    <p class="text-gray-300"><strong>Boundary case:</strong> For <span class="math">p = L_{Q}(2/3, c_{p})</span>, the run time of the NFS with Algorithm-<span class="math">\\mathcal{A}</span> is <span class="math">L_{Q}(1/3, 2c_{b})</span>, where</p>

    <div class="my-4 text-center"><span class="math-block">c _ {b} = \\frac {2 r + 1}{3 c _ {p} k t} + \\sqrt {\\left(\\frac {2 r + 1}{3 c _ {p} k t}\\right) ^ {2} + \\frac {k c _ {p} (t - 1)}{3 (r + 1)}} \\tag {5}</span></div>

    <p class="text-gray-300">with <span class="math">k = n / d</span>. For <span class="math">d = n</span> and <span class="math">r = k = 1</span>, this reduces to the complexity obtained by the Conjugation method. The best complexity that is obtained is <span class="math">L_{Q}(1/3, (48/9)^{1/3})</span>. This complexity, however, is attained for only one particular value of <span class="math">c_{p}</span>, namely <span class="math">c_{p} = 12^{1/3} \\approx 2.3</span>. As <span class="math">c_{p} \\to \\infty</span>, the minimum complexity (taken over <span class="math">r, k</span> and <span class="math">t</span>) approaches <span class="math">L_{Q}(1/3, (64/9)^{1/3})</span> from below.</p>

    <p class="text-gray-300"><strong>Large characteristic case:</strong> For <span class="math">p = L_{Q}(a, c_{p})</span> with <span class="math">a &amp;gt; 2/3</span>, the run time of the NFS with the GJL method is <span class="math">L_{Q}(1/3, (64/9)^{1/3})</span>.</p>

    <p class="text-gray-300">Among the three cases, the best complexity is achieved in the boundary case for a specific <span class="math">c_p</span> value.</p>

    <p class="text-gray-300">3 For comparisons with other run times, it is useful to note that <span class="math">(96/9)^{1/3} \\approx 2.201</span>, <span class="math">(64/9)^{1/3} \\approx 1.923</span>, <span class="math">(48/9)^{1/3} \\approx 1.747</span>, and <span class="math">(32/9)^{1/3} \\approx 1.526</span>.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Remark 1</h6>

    <p class="text-gray-300">The sharp distinction between the run times for the medium characteristic, boundary (with <span class="math">c_{p}=12^{1/3}</span>), and large characteristic cases highlights the inherent asymptotic nature of the analysis and the difficulty in deriving concrete run time estimates. In particular, without the benefit of extensive experimentation, it is not clear whether a concrete problem instance, e.g., with <span class="math">p\\approx 2^{256}</span> and <span class="math">n=12</span>, falls within the medium characteristic, boundary, or large characteristic cases.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">3.3 Multiple Number Field Sieve Algorithm</h3>

    <p class="text-gray-300">Using multiple number fields to obtain faster asymptotic complexity was suggested in <em>[5, 35]</em>. Pierrot <em>[35]</em> provided a detailed analysis of the GJL and the Conjugation methods using multiple number fields. The MNFS variant of Algorithm-<span class="math">\\mathcal{A}</span> was analyzed in <em>[37]</em>. The complexities of the MNFS algorithms for the different cases of <span class="math">p=L_{Q}(a,c_{p})</span> are as follows: <span class="math">L_{Q}(1/3,2.156)</span> for the medium characteristic case, <span class="math">L_{Q}(1/3,1.71)</span> for the boundary case, and <span class="math">L_{Q}(1/3,1.90)</span> for the large characteristic case. The complexity for the boundary case is obtained for only one value of <span class="math">c_{p}</span>, namely <span class="math">c_{p}\\approx 2.12</span>.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.4 Special Number Field Sieve Algorithm</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that <span class="math">p</span> can be written as <span class="math">p=\\Gamma(u)</span> for some polynomial <span class="math">\\Gamma</span> of degree <span class="math">\\lambda</span> and having small coefficients so that <span class="math">u=O(p^{1/\\lambda})</span>. Note that the primes <span class="math">p</span> in Table 1 are in this special form. Joux and Pierrot <em>[29]</em> showed how to modify the polynomial selection algorithm from <em>[28]</em> to obtain improved complexity. Choose an irreducible polynomial <span class="math">f</span> of the form <span class="math">f(x)=x^{n}+R(x)-u</span> where <span class="math">R(x)</span> is a polynomial of small degree with coefficients from <span class="math">\\{0,\\pm 1\\}</span>. Let <span class="math">g=\\Gamma(x^{n}+R(x))</span>. Then <span class="math">g(x)=\\Gamma(f(x)+u)\\equiv\\Gamma(u)=p\\pmod{f(x)}</span> and so <span class="math">g(x)-p</span> is a multiple of <span class="math">f(x)</span> implying that <span class="math">g(x)</span> is a multiple of <span class="math">f(x)</span> modulo <span class="math">p</span>. This choice of <span class="math">f</span> and <span class="math">g</span> ensures that <span class="math">\\deg f=n</span>, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=O(p^{1/\\lambda})<span class="math">, </span>\\deg g=\\lambda n<span class="math">, and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=O((\\log n)^{\\lambda})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The asymptotic complexities reported in <em>[29]</em> are the following. As before, let <span class="math">p=L_{Q}(a,c_{p})</span>.</p>

    <p class="text-gray-300">Medium characteristic case: <span class="math">L_{Q}\\left(1/3,((64/9)\\cdot(\\lambda+1)/\\lambda)^{1/3}\\right)</span> for <span class="math">1/3\\leq a&lt;2/3</span>. Boundary case: <span class="math">L_{Q}\\left(1/3,((32/9)\\cdot(\\lambda+1)/\\lambda)^{1/3}\\right)</span> for <span class="math">a=2/3</span>; Large characteristic case: <span class="math">L_{Q}\\left(1/3,(32/9)^{1/3}\\right)</span> for <span class="math">2/3&lt;a&lt;1</span>.</p>

    <p class="text-gray-300">Unlike the NFS, for SNFS the best complexity is achieved for the large characteristic case.</p>

    <h2 id="sec-15" class="text-2xl font-bold">4 Overview of the Tower Number Field Sieve</h2>

    <p class="text-gray-300">The Tower Number Field Sieve (TNFS) algorithm was initially considered by Schirokauer <em>[41]</em> and was revisited by Barbulescu et al. <em>[4]</em>. The implications of this algorithm for improving the complexity of the medium prime case were pointed out by Kim and Barbulescu <em>[31]</em> which has led to several follow-up works <em>[38, 39]</em>. Following <em>[31]</em> we denote these algorithms by ‘extended TNFS’ (exTNFS).</p>

    <p class="text-gray-300">As we saw in §3.2, the Conjugation method from <em>[2]</em> resulted in the NFS complexity of the boundary case being smaller than the complexity of the medium prime case. Suppose that the extension degree <span class="math">n</span> is composite and <span class="math">n=\\eta\\kappa</span> is a non-trivial factorization of <span class="math">n</span>. Then <span class="math">\\mathbb{F}_{p^{n}}</span> has a tower field representation <span class="math">\\mathbb{F}_{q^{\\kappa}}</span>, where <span class="math">q=p^{\\eta}</span>. The main idea behind the complexity reduction for the medium prime case using a tower field representation is the following. If <span class="math">p</span> and <span class="math">Q=p^{n}</span> are such</p>

    <p class="text-gray-300">that <span class="math">p=L_{Q}(a,c_{p})</span> for <span class="math">1/3&lt;a&lt;2/3</span>, then one can translate the problem to that of computing DLP in <span class="math">\\mathbb{F}_{q^{\\kappa}}</span> where <span class="math">q=L_{Q}(2/3,c_{q})</span>. This corresponds to the boundary case and so one benefits from the lower complexity of the boundary case for the medium prime case.</p>

    <p class="text-gray-300">Here <span class="math">q</span> is not prime and the characteristic of the field <span class="math">\\mathbb{F}_{Q}</span> remains <span class="math">p</span> irrespective of how the field is represented. Hence, strictly speaking, it is not correct to say that the medium characteristic case transforms to the boundary case. On the other hand, from the complexity point of view what matters are the norms of the polynomials and in that sense it is possible to obtain smaller norm bounds with the tower field representation than what could be done directly.</p>

    <p class="text-gray-300">The basic idea of the exTNFS algorithm is the following. One starts with a monic polynomial <span class="math">h(z)</span> of degree <span class="math">\\eta</span> which is irreducible over <span class="math">\\mathbb{F}_{p}</span> and hence is also irreducible over <span class="math">\\mathbb{Z}</span>. Let <span class="math">\\mathbb{F}_{p^{\\eta}}=\\mathbb{F}_{p}[z]/(h(z))</span> and <span class="math">R=\\mathbb{Z}[z]/(h(z))</span>. Suppose <span class="math">f</span> and <span class="math">g</span> are polynomials in <span class="math">R[x]</span> whose leading coefficients are from <span class="math">\\mathbb{Z}</span>. It is required that both <span class="math">f</span> and <span class="math">g</span> are irreducible over <span class="math">R</span> (this can be verified by testing irreducibility over <span class="math">\\mathbb{Q}[z]/(h(z))</span>) and over <span class="math">\\mathbb{F}_{p^{\\eta}}</span>, and that <span class="math">f</span> and <span class="math">g</span> have a degree-<span class="math">\\kappa</span> common factor <span class="math">\\varphi(x)</span> that is irreducible over <span class="math">\\mathbb{F}_{p^{\\eta}}</span>. The field <span class="math">\\mathbb{F}_{p^{\\prime\\prime}}</span> is then realized as <span class="math">\\mathbb{F}_{p^{\\eta}}[x]/(\\varphi(x))=(R/pR)[x]/(\\varphi(x))</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathbb{K}_{f}</span> and <span class="math">\\mathbb{K}_{g}</span> be the number fields defined by <span class="math">f</span> and <span class="math">g</span> respectively. As in the case of the NFS (see Figure 1), the above set-up provides two different decompositions of a homomorphism from <span class="math">R[x]</span> to <span class="math">\\mathbb{F}_{p^{\\prime\\prime}}</span>. One of these goes through <span class="math">R[x]/(f(x))</span> and the other goes through <span class="math">R[x]/(g(x))</span>. Using this set-up it is possible to define a factor base and carry out the three main phases of NFS. Here also, the factor base consists of <span class="math">B^{1+o(1)}</span> elements for some smoothness bound <span class="math">B</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sieving for relation collection is done using polynomials <span class="math">\\phi\\in R[x]</span> of degrees at most <span class="math">t-1</span> with $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=E^{2/\\eta t}<span class="math"> so that the number of sieving polynomials is </span>E^{2}<span class="math">. A sieving polynomial </span>\\phi\\in R[x]$ generates a relation if both the norms</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">N(\\phi,f)=\\text{Res}_{z}(\\text{Res}_{x}(\\phi(x),f(x)),h(z))\\quad\\text{and}\\quad N(\\phi,g)=\\text{Res}_{z}(\\text{Res}_{x}(\\phi(x),g(x)),h(z))</span> (6)</p>

    <p class="text-gray-300">are <span class="math">B</span>-smooth. Note that in this case, <span class="math">f</span> and <span class="math">g</span> can be viewed as bivariate polynomials in <span class="math">x</span> and <span class="math">z</span> and hence the norm is obtained by taking resultants twice. Bounds on the norm are obtained from the bounds on resultants of bivariate polynomials <em>[9]</em>.</p>

    <p class="text-gray-300">The polynomial selection methods for NFS (see §3.1) translate to the exTNFS setting. Instead of providing the details of these methods, we provide a summary of recent work with a focus on the medium prime case.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Kim and Barbulescu <em>[31]</em>.</h4>

    <p class="text-gray-300">This work chooses <span class="math">f,g\\in\\mathbb{Z}[x]</span>, whence the degree-<span class="math">\\kappa</span> polynomial <span class="math">\\varphi(x)=\\gcd(f(x),g(x))</span> is over <span class="math">\\mathbb{F}_{p}</span>. The requirement that <span class="math">\\varphi(x)</span> is irreducible over <span class="math">\\mathbb{F}_{p^{\\eta}}</span> imposes the condition that <span class="math">\\gcd(\\eta,\\kappa)=1</span>. Hence, the Kim-Barbulescu method works only for composite non prime-power values of <span class="math">n</span>. The actual polynomial selection is done using a translated version of the Conjugation method, resulting in the best achievable complexity for <span class="math">p=L_{Q}(a,c_{p})</span>, <span class="math">1/3&lt;a&lt;2/3</span> to be <span class="math">L_{Q}(1/3,(48/9)^{1/3})</span>. This complexity, however, is not achieved for all values of <span class="math">p</span>.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Sarkar and Singh <em>[38]</em>.</h4>

    <p class="text-gray-300">This work described a polynomial selection method (called Algorithm-<span class="math">\\mathcal{C}</span>) in which the coefficients <span class="math">f</span> and <span class="math">g</span> are in <span class="math">R</span> (and not necessarily in <span class="math">\\mathbb{Z}</span>), with the restriction that <span class="math">f</span> is monic and the leading coefficient of <span class="math">g</span> is in <span class="math">\\mathbb{Z}</span>. As a result, the restriction that <span class="math">\\varphi(x)</span> has coefficients in <span class="math">\\mathbb{F}_{p}</span> is also removed resulting in the removal of the <span class="math">\\gcd(\\eta,\\kappa)=1</span> constraint. This leads to a variant of the TNFS algorithm for the medium characteristic case with improved complexity for all composite <span class="math">n</span>. For prime-power <span class="math">n</span>, however, the minimum complexity obtained in <em>[38]</em> is larger than <span class="math">L_{Q}(1/3,(48/9)^{1/3})</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Jeong and Kim <em>[25]</em>. The Conjugation method was extended to the TNFS setting where the condition <span class="math">\\gcd(\\eta,\\kappa)=1</span> was not required. The best achievable complexity for <span class="math">p=L_{Q}(a,c_{p})</span>, <span class="math">1/3&lt;a&lt;2/3</span> was shown to be <span class="math">L_{Q}(1/3,(48/9)^{1/3})</span>. For prime-power <span class="math">n</span>, this improves upon the complexity achieved in <em>[38]</em>.</p>

    <p class="text-gray-300">Sarkar and Singh <em>[39]</em>. A new polynomial selection algorithm, called Algorithm-<span class="math">\\mathcal{D}</span>, was described. This provides another translation of Algorithm-<span class="math">\\mathcal{A}</span> to the TNFS setting without requiring the condition <span class="math">\\gcd(\\eta,\\kappa)=1</span>. Special cases of Algorithm-<span class="math">\\mathcal{D}</span> lead to the GJL and the Conjugation methods in both classical NFS and TNFS. As a result, Algorithm-<span class="math">\\mathcal{D}</span> subsumes the Jeong-Kim polynomial selection method. The asymptotic complexity for the medium prime case can be described as follows. Let <span class="math">p=L_{Q}(a,c_{p})</span> with <span class="math">1/3\\leq a&lt;2/3</span> and suppose that <span class="math">q=p^{\\eta}</span> can be written as <span class="math">q=L_{Q}(2/3,c_{\\theta})</span>. Then the asymptotic complexity is <span class="math">L_{Q}(1/3,2c_{b})</span> where <span class="math">c_{b}</span> is given by (5) with <span class="math">c_{p}</span> replaced by <span class="math">c_{\\theta}</span>. The minimum complexity is still <span class="math">L_{Q}(1/3,(48/9)^{1/3})</span> which is the same as that of the Jeong-Kim method and this complexity is attained for <span class="math">c_{\\theta}=12^{1/3}</span>. However, improvements in asymptotic complexity are obtained for certain ranges of values of <span class="math">c_{\\theta}</span>.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">4.1 Multiple Number Field Sieve Algorithm</h3>

    <p class="text-gray-300">Multiple number fields can also be used with the TNFS <em>[31]</em>. As in the case of the NFS, this reduces the asymptotic complexity. The best achievable complexity for the medium prime case is <span class="math">L_{Q}(1/3,1.71)</span>.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">4.2 Special Number Field Sieve Algorithm</h3>

    <p class="text-gray-300">As explained above, the main advantage of the TNFS method is to transform the problem for the medium characteristic case to that of the boundary characteristic for which the complexity is lower. In fact, it is also possible to transform to the large characteristic case. Carrying out this exercise for the SNFS (yielding the SexTNFS algorithm) leads to an asymptotic complexity of <span class="math">L_{Q}(1/3,(32/9)^{1/3})</span> for the medium prime case; this complexity is achieved for all medium primes unlike the case of TNFS. This works for composite <span class="math">n</span>; in the case where <span class="math">n</span> has a non-trivial factorization as <span class="math">n=\\eta\\kappa</span> with <span class="math">\\gcd(\\eta,\\kappa)=1</span>, this complexity was reported in <em>[31]</em>, whereas the same complexity was reported in <em>[25]</em> without the restriction <span class="math">\\gcd(\\eta,\\kappa)=1</span>.</p>

    <h2 id="sec-20" class="text-2xl font-bold">5 Asymptotic Analysis</h2>

    <p class="text-gray-300">In summary, the asymptotic run times of the NFS variants for computing discrete logarithms in <span class="math">\\mathbb{F}_{Q}</span> in the medium characteristic case are <span class="math">L_{Q}(1/3,c)</span> where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">c=2.201</span> for the NFS (§3.2);</li>

      <li><span class="math">c=2.156</span> for the multiple NFS (§3.3);</li>

      <li><span class="math">c=2.072</span> for the special NFS with <span class="math">\\lambda=4</span> (§3.4);</li>

      <li><span class="math">c=1.747</span> for the exTNFS for some <span class="math">p</span> (§4);</li>

      <li><span class="math">c=1.71</span> for the multiple exTNFS for some <span class="math">p</span> (§4.1); and</li>

      <li><span class="math">c=1.526</span> for the SexTNFS (§4.2).</li>

    </ul>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Asymptotic complexity analysis proceeds by ignoring various factors that do not have significant effect on the run time as <span class="math">Q=p^{n}</span> goes to infinity. In this section, we take a look at the different steps of this analysis with a view towards assessing whether the ignored factors can have a noticeable effect on the run time for concrete values of <span class="math">Q</span>. At the same time, we consider issues of storage and observe that different operations which are assumed to asymptotically require <span class="math">O(1)</span> time, in practice have noticeable difference in their times.</p>

    <p class="text-gray-300">We consider the TNFS setting where <span class="math">Q=p^{n}</span> and <span class="math">n=\\eta\\kappa</span> is a non-trivial factorization of <span class="math">n</span>.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">5.1 Bounds on Norms of Polynomials</h3>

    <p class="text-gray-300">The number fields <span class="math">\\mathbb{K}_{f}</span> and <span class="math">\\mathbb{K}_{g}</span> are defined using two polynomials <span class="math">f(x)</span> and <span class="math">g(x)</span> over <span class="math">R=\\mathbb{Z}[z]/(h(z))</span> where <span class="math">h(z)</span> is a degree-<span class="math">\\eta</span> irreducible polynomial over <span class="math">\\mathbb{Z}</span>. The degrees and <span class="math">\\ell_{\\infty}</span> norms of <span class="math">f</span> and <span class="math">g</span> are the main factors that influence the running time. These quantities are determined based on the actual polynomial selection method that is employed. To make the ideas concrete, we work with a special case of Algorithm-<span class="math">\\mathcal{D}</span> <em>[37]</em>. This special case is important since it is the TNFS variant of the Conjugation method proposed by Kim and Barbulescu <em>[31]</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using random trials, one chooses a monic quadratic polynomial <span class="math">A_{1}\\in\\mathbb{Z}[y]</span> having <span class="math">O(\\log p)</span>-size coefficients such that <span class="math">A_{1}</span> is irreducible over <span class="math">\\mathbb{Z}</span> and has a factor <span class="math">A_{2}(y)=y+\\delta</span> over <span class="math">\\mathbb{F}_{p}</span>. Further, using random trials, one chooses monic polynomials <span class="math">C_{0}(x)</span> and <span class="math">C_{1}(x)</span> over <span class="math">R</span> with $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=O(1)<span class="math">, </span>\\deg C_{0}(x)=\\kappa<span class="math">, </span>\\deg C_{1}(x)<\\kappa<span class="math">, and such that </span>f(x)<span class="math"> and </span>g(x)<span class="math"> are irreducible over </span>R<span class="math"> and </span>\\varphi(x)<span class="math"> is irreducible over </span>\\mathbb{F}_{p^{0}}=\\mathbb{F}_{p}[z]/(h(z))<span class="math"> where </span>f(x)=\\text{Res}_{x}(A_{1}(y),C_{0}(x)+yC_{1}(x))<span class="math">, </span>\\varphi(x)=\\text{Res}_{y}(A_{2}(y),C_{0}(x)+yC_{1}(x))<span class="math"> mod </span>p<span class="math">, </span>\\psi(x)=\\psi_{1}x+\\psi_{0}<span class="math">, and </span>g(x)=\\text{Res}_{x}(\\psi(y),C_{0}(x)+yC_{1}(x))<span class="math">. The integer coefficients </span>\\psi_{1}<span class="math"> and </span>\\psi_{0}<span class="math"> of </span>\\psi(x)<span class="math"> are obtained by a rational reconstruction of </span>\\delta<span class="math"> modulo </span>p<span class="math">. From the bound on the first vector of an LLL-reduced basis and the bound on the shortest vector of a lattice, one obtains </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq 2p^{1/2}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Asymptotically, the above method for selecting <span class="math">f</span> and <span class="math">g</span> yields $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=O(\\log p)<span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=O(Q^{1/2n})<span class="math">. The contribution to </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> from the coefficients of </span>C_{0}(x)<span class="math"> and </span>C_{1}(x)$ arising from the resultant computation are absorbed in the big-O notation.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">5.2 Size of the Factor Base</h3>

    <p class="text-gray-300">The polynomials <span class="math">f</span> and <span class="math">g</span> define the two (tower) number fields <span class="math">\\mathbb{K}_{f}</span> and <span class="math">\\mathbb{K}_{g}</span> having ring of integers <span class="math">\\mathcal{O}_{f}</span> and <span class="math">\\mathcal{O}_{g}</span> respectively. The factor base consists of all prime ideals of <span class="math">\\mathcal{O}_{f}</span> and <span class="math">\\mathcal{O}_{g}</span> whose norms are at most <span class="math">B</span>. From this, the factor base size is asymptotically <span class="math">B^{1+o(1)}</span>. For concrete polynomials <span class="math">f</span> and <span class="math">g</span>, the actual number of prime ideals could have a small but noticeable difference from <span class="math">B</span>.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">5.3 Bounds on Norms of Ideals</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sieving is done using polynomials of degrees at most <span class="math">t-1</span>. Consider the simplest and the most important case of <span class="math">t=2</span>. Then the sieving polynomials are linear polynomials <span class="math">\\phi\\in R[x]</span> with $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=E^{1/\\eta}<span class="math">. There are a total of </span>E^{2}<span class="math"> sieving polynomials. A relation is obtained if the principal ideals generated by the images of </span>\\phi<span class="math"> in </span>\\mathcal{O}_{f}<span class="math"> and </span>\\mathcal{O}_{g}<span class="math"> are smooth over the factor base. This smoothness depends on the norms </span>N(f,\\phi)<span class="math"> and </span>N(g,\\phi)$ whose bounds are given by (6).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $H=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}$ and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathfrak{C}(\\eta,s,H)=((\\eta-1)(1+s)+1)^{\\eta/2}\\cdot(\\eta+1)^{(\\eta-1)(1+s)/2}\\cdot H^{(\\eta-1)(1+s)}\\cdot((s+1)!\\eta^{s})^{\\eta}\\,.</span></p>

    <p class="text-gray-300">The following bounds on the norms can be obtained:</p>

    <p class="text-gray-300"><span class="math">N(f,\\phi)\\leq\\mathfrak{C}(\\eta,2\\kappa,H)\\cdot E^{2\\kappa}\\cdot O\\left((\\log p)^{\\eta}\\right)\\quad\\text{and}\\quad N(g,\\phi)\\leq\\mathfrak{C}(\\eta,\\kappa,H)\\cdot E^{\\kappa}\\cdot O\\left(Q^{1/(2\\kappa)}\\right);</span> (7)</p>

    <p class="text-gray-300">see Appendix A for details of the resultant calculations. In the asymptotic analysis these are written as <span class="math">N(f,\\phi)=E^{2\\kappa}L_{Q}(2/3,o(1))</span> and <span class="math">N(g,\\phi)=E^{\\kappa}Q^{1/(2\\kappa)}L_{Q}(2/3,o(1))</span>. In other words, one takes <span class="math">\\mathfrak{C}(\\eta,2\\kappa,H)=L_{Q}(2/3,o(1))</span> and <span class="math">\\mathfrak{C}(\\eta,\\kappa,H)=L_{Q}(2/3,o(1))</span>, and consequently their contribution to the overall running time <span class="math">L_{Q}(1/3,c)</span> is absorbed by the <span class="math">o(1)</span> term in the latter.</p>

    <p class="text-gray-300">For concrete values, the factors that get absorbed in the <span class="math">L_{Q}(2/3,o(1))</span> expression can be very large. For <span class="math">n=12</span>, let <span class="math">\\eta=4</span> and <span class="math">\\kappa=3</span> and suppose that <span class="math">H=5</span>. Then <span class="math">\\mathfrak{C}(4,3,5)\\approx 2^{91.5}</span> and <span class="math">\\mathfrak{C}(4,6,5)\\approx 2^{179.3}</span>. On the other hand, suppose we choose <span class="math">\\eta=1</span> and <span class="math">\\kappa=12</span> and <span class="math">H=5</span> as before. These values of <span class="math">\\eta</span> and <span class="math">\\kappa</span> correspond to the usual NFS, i.e., we are not exploiting the tower structure. Then <span class="math">\\mathfrak{C}(1,12,5)\\approx 2^{32.5}</span> and <span class="math">\\mathfrak{C}(1,24,5)\\approx 2^{83.7}</span>. While these are still large numbers, they are significantly smaller than the numbers obtained in the case of the tower representation.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">5.4 Smoothness Probability from the Canfield-Erdös-Pomerance Theorem</h3>

    <p class="text-gray-300">The bounds obtained on the norms <span class="math">N(f,\\phi)</span> and <span class="math">N(g,\\phi)</span> are used to estimate the probability that a random sieving polynomial will provide a relation. The required condition is that the principal ideals generated by the images of <span class="math">\\phi</span> in the two integer rings are smooth over the factor base. Two <em>assumptions</em> are used, which means that the entire analysis is heuristic.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It is <em>assumed</em> that the probability that the principal ideal generated by the image of <span class="math">\\phi</span> in <span class="math">\\mathcal{O}_{f}</span> factors over the factor base is the same as the probability that a random integer of size <span class="math">N(f,\\phi)</span> is <span class="math">B</span>-smooth. Similarly for <span class="math">\\mathcal{O}_{g}</span>.</li>

      <li>The events that the two principal ideals generated by the images of <span class="math">\\phi</span> are smooth over the factor base are independent.</li>

    </ol>

    <p class="text-gray-300">The probability that a random integer of size <span class="math">N(f,\\phi)</span> is <span class="math">B</span>-smooth is obtained from the <span class="math">L</span>-notation version of a theorem due to Canfield, Erdös and Pomerance. (See Theorem 15.2 of <em>[26]</em> for the statement of the theorem.) The smoothness probability can also be expressed in concrete terms. Let <span class="math">\\Psi(N,B)</span> be the number of positive integers <span class="math">\\leq N</span> which are <span class="math">B</span>-smooth. Ignoring lower order terms, it can be shown that</p>

    <p class="text-gray-300"><span class="math">\\log\\left(\\frac{\\Psi(N,B)}{N}\\right)\\approx-\\frac{\\log N}{\\log B}\\log\\left(\\frac{\\log N}{\\log B}\\right).</span> (8)</p>

    <p class="text-gray-300">Let <span class="math">\\Pi(N,B)=\\Psi(N,B)/N</span> be the probability that a random integer <span class="math">\\leq N</span> is <span class="math">B</span>-smooth. We are interested in</p>

    <p class="text-gray-300"><span class="math">\\Pi(N(f,\\phi),B)\\cdot\\Pi(N(g,\\phi),B).</span> (9)</p>

    <p class="text-gray-300">The number of trials (i.e., the number of sieving polynomials to consider) to obtain a single relation is about</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{n}=\\left(\\Pi(N(f,\\phi),B)\\cdot\\Pi(N(g,\\phi),B)\\right)^{-1}.</span></p>

    <p class="text-gray-300">Since about <span class="math">B</span> relations are required, the total number of trials to obtain all the relations is about <span class="math">B\\mathfrak{n}</span>. This is how the bounds on the norms determine the run time of the relation collection phase.</p>

    <p class="text-gray-300">5.5 Balancing Costs</p>

    <p class="text-gray-300">For the asymptotic analysis, the costs of the relation collection and the linear algebra phases are balanced. This balancing proceeds by imposing two conditions. Recall that the number of sieving polynomials is <span class="math">E^{2}</span> and the size of the factor base is <span class="math">B^{1+o(1)}</span>. Sparse linear algebra requires time <span class="math">B^{2+o(1)}</span>. Hence, the costs of the relation collection and linear algebra phases are balanced by setting <span class="math">E=B</span>.</p>

    <p class="text-gray-300">Note that this assumes that the total time for sieving with <span class="math">E^{2}</span> polynomials is equal to the time required for completing the linear algebra phase. While this is true in an asymptotic sense, in concrete terms the two costs can be significantly different. We note the following differences between these two tasks.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For both sieving and linear algebra, the basic operations are field operations in <span class="math">\\mathbb{F}_{p}</span>. However, the number of such field operations are different for the two tasks.</li>

      <li>For linear algebra, it is required to perform read and write operations on a very large matrix. In practice, these read/write operations will incur a significant overhead.</li>

      <li>The sieving step is parallelizable up to any extent. This is not true for the linear algebra step. The block Wiedemann algorithm can be parallelized, but this comes at the cost of additional memory requirements.</li>

    </ol>

    <h2 id="sec-25" class="text-2xl font-bold">6 Concrete Analysis</h2>

    <p class="text-gray-300">We take some concrete values to get an idea of the effect of the constants in the norm bounds on the smoothness probability. Suppose <span class="math">Q\\approx 2^{3000}</span>, <span class="math">n=12</span>, <span class="math">\\eta=4</span>, <span class="math">\\kappa=3</span>, <span class="math">H=5</span>, whence <span class="math">p\\approx 2^{250}</span>. Assume that the factor base size is <span class="math">B=2^{64}</span> so that the linear algebra phase requires approximately <span class="math">2^{128}</span> operations. As discussed in §5.5, <span class="math">E</span> is taken to be equal to <span class="math">B</span> so that <span class="math">E</span> is also <span class="math">2^{64}</span>. Then taking the upper bounds in (7) to be the norm values and the hidden constants in the big-O notation to be 1, we obtain</p>

    <p class="text-gray-300"><span class="math">N(f,\\phi)</span> <span class="math">\\approx\\mathfrak{C}(4,6,5)E^{2\\kappa}(\\log p)^{\\eta}\\approx 2^{593},</span> <span class="math">N(g,\\phi)</span> <span class="math">\\approx\\mathfrak{C}(4,3,5)E^{\\kappa}Q^{1/(2\\kappa)}\\approx 2^{783},</span> <span class="math">\\Pi(N(f,\\phi),B)</span> <span class="math">\\approx\\Pi(2^{593},2^{64})\\approx 2^{-29.8},</span> <span class="math">\\Pi(N(g,\\phi),B)</span> <span class="math">\\approx\\Pi(2^{783},2^{64})\\approx 2^{-44.2},</span> <span class="math">\\mathfrak{n}=(\\Pi(N(f,\\phi),B)\\cdot\\Pi(N(g,\\phi),B))^{-1}\\approx 2^{74}.</span></p>

    <p class="text-gray-300">Hence a single relation will be obtained after trying about <span class="math">2^{74}</span> sieving polynomials. On the other hand, if we ignore the factors <span class="math">\\mathfrak{C}(4,6,5)</span> and <span class="math">\\mathfrak{C}(4,3,5)</span>, then <span class="math">\\mathfrak{n}\\approx 2^{54}</span>. So, in this case the effect of the constants in the norm bounds is to increase the number of iterations for finding a single relation by a factor of about <span class="math">2^{20}</span>.</p>

    <p class="text-gray-300">The number of iterations required to find a single relation affects the overall cost of the algorithm. The total number of iterations required to find the <span class="math">B</span> required relations determines the cost of the relation collection phase. If we take the constants into account, the relation collection phase will have cost about <span class="math">2^{74}B=2^{138}</span> for <span class="math">B=2^{64}</span>. On the other hand, if the constants are ignored, then the relation collection phase will have cost about <span class="math">2^{54}B=2^{118}</span>. In both cases, the linear algebra phase will have cost approximately <span class="math">B^{2}=2^{128}</span>.</p>

    <p class="text-gray-300">The above choice of <span class="math">B</span> does not balance the costs of the relation collection and linear algebra phases. We have redone the calculations with <span class="math">Q\\approx 2^{3000}</span> so as to balance these costs. The overall</p>

    <p class="text-gray-300">approximate costs of the algorithm are given by the values in the fourth column (if the constants are taken into consideration) and fifth column (if the constants are ignored) of the first row of Table 2. The size of the factor base is the square root of the overall cost.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">algorithm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(η,κ,λ)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">with constants</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">without constants</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">(4,3,-)</td>

            <td class="px-3 py-2 border-b border-gray-700">2138</td>

            <td class="px-3 py-2 border-b border-gray-700">2116</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">(6,2,4)</td>

            <td class="px-3 py-2 border-b border-gray-700">2155</td>

            <td class="px-3 py-2 border-b border-gray-700">2108</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">(6,3,-)</td>

            <td class="px-3 py-2 border-b border-gray-700">2154</td>

            <td class="px-3 py-2 border-b border-gray-700">2118</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">(9,2,8)</td>

            <td class="px-3 py-2 border-b border-gray-700">2279</td>

            <td class="px-3 py-2 border-b border-gray-700">2160</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">(8,3,-)</td>

            <td class="px-3 py-2 border-b border-gray-700">2169</td>

            <td class="px-3 py-2 border-b border-gray-700">2118</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">(12,2,10)</td>

            <td class="px-3 py-2 border-b border-gray-700">2369</td>

            <td class="px-3 py-2 border-b border-gray-700">2186</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2. Approximate run times of exTNFS and SexTNFS for  <span class="math">Q = p^n \\approx 2^{3000}</span>  for several different values of  <span class="math">n</span> , with and without the constants. These constants are  <span class="math">\\mathfrak{C}(\\eta, \\kappa, H)</span>  and  <span class="math">\\mathfrak{C}(\\eta, 2\\kappa, H)</span>  for exTNFS, and  <span class="math">\\mathfrak{C}(\\eta, \\kappa, H)</span>  and  <span class="math">\\mathfrak{C}(\\eta, \\kappa\\lambda, H)</span>  for SexTNFS.</p>

    <p class="text-gray-300">A similar calculation can be done for SexTNFS; cf. Remark 2. In this case, however, the minimum complexity is not achieved for  <span class="math">\\eta = 4</span>  and  <span class="math">\\kappa = 3</span> . Instead the minimum is achieved for  <span class="math">\\eta = 6</span>  and  <span class="math">\\kappa = 2</span> . Since in this case  <span class="math">\\eta</span>  and  <span class="math">\\kappa</span>  are not coprime, this choice would not be allowed by the Kim-Barculescu work [31], but would be permitted by [25]. The run times considering and ignoring constants are respectively given in the second row of Table 2.</p>

    <p class="text-gray-300">We have performed similar calculations for  <span class="math">n = 18</span>  and  <span class="math">n = 24</span> . It turns out that the factorization of  <span class="math">n</span>  that minimizes the exTNFS complexity is not the same as the factorization of  <span class="math">n</span>  that minimizes the SexTNFS complexity. Table 2 provides the run times of exTNFS and SexTNFS both when the constants in the norm bound are taken into consideration and also when they are ignored. We observe the following from the values in Table 2.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the constants are taken into consideration, then in each case the run time is significantly greater than if the constants are ignored. In particular, a 3000-bit  <span class="math">Q</span>  does seem to provide at least 128-bit security for  <span class="math">n = 12</span> .</li>

      <li>The concrete run time for exTNFS is smaller than that of SexTNFS. (The only exception to this is for  <span class="math">n = 12</span>  and when the constants in the norm bounds are ignored.) This is contrary to what one would expect from the asymptotic analysis in which the run time of SexTNFS is smaller than that of exTNFS; cf. Remark 2.</li>

      <li>The asymptotic expression for the run time does not have any dependence on  <span class="math">n</span>  and depends only on  <span class="math">Q</span> . This means that for a given  <span class="math">Q</span> , the run times will asymptotically be the same for all  <span class="math">n</span> . However, concrete values show a significant dependence on the value of  <span class="math">n</span> . For a fixed  <span class="math">Q</span> , as  <span class="math">n</span>  increases there is a significant increase in the run time. This is because the constants in the norm bound depend on  <span class="math">n</span>  and increase quite rapidly as  <span class="math">n</span>  increases.</li>

      <li>For exTNFS without constants, the run time does not vary much as  <span class="math">n</span>  increases. This behaviour is not observed for SexTNFS.</li>

    </ol>

    <p class="text-gray-300">Remark 2. For SexTNFS, the upper bounds on the norms are</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N (f, \\phi) \\leq \\mathfrak {C} (\\eta , \\kappa , H) \\cdot E ^ {\\kappa} \\cdot p ^ {\\eta / \\lambda} \\quad \\text {a n d} \\quad N (g, \\phi) \\leq \\mathfrak {C} (\\eta , \\kappa \\lambda , H) \\cdot E ^ {\\kappa \\lambda} \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Gamma \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} ^ {n}. \\tag {10}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">These values should be compared with the norm bounds for exTNFS-Conj given by (7). The values of <span class="math">\\lambda</span> are 4, 6, 8 and 10 respectively for BN, BLS12, KSS and BLS24 curves. In the asymptotic complexity analysis, <span class="math">\\lambda</span> is treated as a constant and does not have a noticeable influence on the run time. On the other hand, in the concrete analysis, the actual value of <span class="math">\\lambda</span> has a noticeable effect on the upper bound on <span class="math">N(g,\\phi)</span>. This effect is present even if the constants <span class="math">\\mathfrak{C}(\\eta,\\kappa,H)</span> and <span class="math">\\mathfrak{C}(\\eta,\\kappa\\lambda,H)</span> are ignored. Since a higher value of the norm bound implies a lower smoothness probability and hence a higher overall run time, the concrete run time for SexTNFS turns out to be greater than that of exTNFS.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Remark 3</h6>

    <p class="text-gray-300">Consider an asymmetric pairing derived from an ordinary elliptic curve over <span class="math">\\mathbb{F}_{p}</span> with embedding degree <span class="math">n</span>, whereby the target group is <span class="math">\\mathbb{G}_{T}=\\mathbb{F}_{Q}^{*}</span> with <span class="math">Q=p^{n}</span>. For a fixed <span class="math">Q</span>, as <span class="math">n</span> increases, <span class="math">p</span> decreases. Since the elliptic curve group is of size roughly <span class="math">p</span>, the size of the elliptic curve group also decreases. Considering the 128-bit security level, the size of <span class="math">p</span> going below 256 will violate Pollard-rho security. Hence, 128-bit security cannot be achieved by keeping <span class="math">Q</span> at the 3000-bit level and simply increasing <span class="math">n</span> beyond 12.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">6.1 On the Tightness of the Norm Bounds</h3>

    <p class="text-gray-300">The norms <span class="math">N(f,\\phi)</span> and <span class="math">N(g,\\phi)</span> are expressed in terms of resultants. Upper bounds on these norms are known bounds on resultants <em>[9]</em> and are given by (7); let <span class="math">U_{f}</span> and <span class="math">U_{g}</span> be the upper bounds on <span class="math">N(f,\\phi)</span> and <span class="math">N(g,\\phi)</span>. Let <span class="math">V_{f}=E^{2\\kappa}\\cdot O\\left((\\log p)^{\\eta}\\right)</span> and <span class="math">V_{g}=E^{\\kappa}\\cdot O\\left(Q^{1/(2\\kappa)}\\right)</span>. Note that <span class="math">V_{f}</span> and <span class="math">V_{g}</span> are not necessarily upper bounds on <span class="math">N(f,\\phi)</span> and <span class="math">N(g,\\phi)</span> because the constants <span class="math">\\mathfrak{C}(\\eta,2\\kappa,H)</span> and <span class="math">\\mathfrak{C}(\\eta,\\kappa,H)</span> are absent.</p>

    <p class="text-gray-300">Let <span class="math">\\mu=\\Pi(U_{f},B)\\cdot\\Pi(U_{g},B)</span> and <span class="math">\\nu=\\Pi(V_{f},B)\\cdot\\Pi(V_{g},B)</span> where <span class="math">B</span> is the factor base size. Then <span class="math">\\mu</span> is a lower bound on the probability of obtaining a single relation and <span class="math">\\mu^{-1}</span> is an upper bound on the number of iterations required to obtain a single relation. The quantity <span class="math">\\nu</span> is similar to that of <span class="math">\\mu</span> except that <span class="math">V_{f}</span> and <span class="math">V_{g}</span> are used instead of <span class="math">U_{f}</span> and <span class="math">U_{g}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In <em>[9]</em>, an example is provided to show that the resultant bounds are tight and in general cannot be improved. On the other hand, the question of whether the bounds are tight for the kinds of polynomials arising in the context of NFS algorithms deserves an answer. To determine this, we conducted some experiments. The generalized Conjugate method (gConj) <em>[25]</em> was implemented and the polynomials <span class="math">h(z)</span>, <span class="math">f(x)</span> and <span class="math">g(x)</span> computed. This determines $H=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">, </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">. Now choose a value for </span>B<span class="math"> and set </span>E=B<span class="math"> so that the number of sieving polynomials </span>\\phi(x)<span class="math"> is </span>B^{2}<span class="math">. We further set </span>t=2<span class="math">, i.e., only linear sieving polynomials were considered. Then the coefficients of a sieving polynomial </span>\\phi(x)<span class="math"> (considered as a bivariate polynomial in </span>z<span class="math"> and </span>x<span class="math">) can take </span>B^{1/\\eta}<span class="math"> values. We chose 1000 random sieving polynomials and in each case computed the actual values of </span>N(f,\\phi)<span class="math"> and </span>N(g,\\phi)<span class="math">. From these two values, the smoothness probability </span>\\pi=\\Pi(N(f,\\phi),B)\\cdot\\Pi(N(g,\\phi),B)<span class="math"> was computed. Let </span>\\overline{N}_{f}<span class="math">, </span>\\overline{N}_{g}<span class="math"> and </span>\\overline{\\pi}<span class="math"> be the average of </span>N(f,\\phi)<span class="math">, </span>N(g,\\phi)<span class="math"> and </span>\\pi<span class="math"> computed over the 1000 random </span>\\phi$’s. A summary of these values is given in Table 3. The table also shows the results of a similar experiment conducted for the SexTNFS algorithm where BN curves were used.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In each case considered in Table 3, it turned out that taking <span class="math">H=2</span> is sufficient. We have previously considered <span class="math">H=5</span> and the reduced value of <span class="math">H=2</span> results in slightly lower values for <span class="math">U_{f}</span> and <span class="math">U_{g}</span>. There are several points to note from the results in Table 3.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The average value <span class="math">\\lg\\overline{N}_{f}</span> is closer to <span class="math">\\lg V_{f}</span> than to the known upper bound <span class="math">\\lg U_{f}</span>. Similarly for <span class="math">\\lg\\overline{N}_{g}</span> and <span class="math">\\overline{\\pi}</span>.</li>

    </ol>

    <p class="text-gray-300">2.</p>

    <p class="text-gray-300">Table 3. Upper bound and average values of norms for the 128-bit security level.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">method</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">η</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">κ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">lg p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">lg B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">lg Vf</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">lg Nf</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">lg Uf</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">lg Vg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">lg Ng</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">lg Ug</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- lg ν</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- lg π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- lg μ</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-gConj</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">70</td>

            <td class="px-3 py-2 border-b border-gray-700">452</td>

            <td class="px-3 py-2 border-b border-gray-700">458</td>

            <td class="px-3 py-2 border-b border-gray-700">603</td>

            <td class="px-3 py-2 border-b border-gray-700">978</td>

            <td class="px-3 py-2 border-b border-gray-700">992</td>

            <td class="px-3 py-2 border-b border-gray-700">1053</td>

            <td class="px-3 py-2 border-b border-gray-700">70</td>

            <td class="px-3 py-2 border-b border-gray-700">70</td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-gConj</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">70</td>

            <td class="px-3 py-2 border-b border-gray-700">464</td>

            <td class="px-3 py-2 border-b border-gray-700">495</td>

            <td class="px-3 py-2 border-b border-gray-700">731</td>

            <td class="px-3 py-2 border-b border-gray-700">978</td>

            <td class="px-3 py-2 border-b border-gray-700">996</td>

            <td class="px-3 py-2 border-b border-gray-700">1113</td>

            <td class="px-3 py-2 border-b border-gray-700">71</td>

            <td class="px-3 py-2 border-b border-gray-700">72</td>

            <td class="px-3 py-2 border-b border-gray-700">98</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-gConj</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">81</td>

            <td class="px-3 py-2 border-b border-gray-700">545</td>

            <td class="px-3 py-2 border-b border-gray-700">617</td>

            <td class="px-3 py-2 border-b border-gray-700">937</td>

            <td class="px-3 py-2 border-b border-gray-700">1267</td>

            <td class="px-3 py-2 border-b border-gray-700">1302</td>

            <td class="px-3 py-2 border-b border-gray-700">1467</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">84</td>

            <td class="px-3 py-2 border-b border-gray-700">116</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">543</td>

            <td class="px-3 py-2 border-b border-gray-700">717</td>

            <td class="px-3 py-2 border-b border-gray-700">902</td>

            <td class="px-3 py-2 border-b border-gray-700">711</td>

            <td class="px-3 py-2 border-b border-gray-700">655</td>

            <td class="px-3 py-2 border-b border-gray-700">806</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">70</td>

            <td class="px-3 py-2 border-b border-gray-700">99</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consider  <span class="math">\\lg \\overline{N}_f</span> . The average has been computed over 1000 iterations. The value of  <span class="math">\\lg \\overline{N}_f</span>  being substantially less than  <span class="math">\\lg U_f</span>  indicates that polynomials  <span class="math">\\phi</span>  such that  <span class="math">N(f, \\phi)</span>  is close to  <span class="math">U_f</span>  are not very common. On the other hand, this does not indicate that such polynomials do not occur at all. A total of  <span class="math">B^2</span>  sieving polynomials  <span class="math">\\phi</span>  have to be considered. It is possible that a non-negligible fraction of these do have norms close to the upper bound. Our experiments only indicate that the fraction is less than 1/1000. Thus, in the absence of further experimental data, one cannot completely disregard the role of the constants in the analysis.</li>

      <li>In each case,  <span class="math">B</span>  has been chosen so that  <span class="math">\\lg B</span>  is roughly equal to  <span class="math">\\mu</span> . Further, in each case it turns out that  <span class="math">\\overline{\\pi}</span>  is at least  <span class="math">\\mu</span> . So, even if the actual norms behave like  <span class="math">\\overline{N}_f</span>  and  <span class="math">\\overline{N}_g</span> , choosing  <span class="math">\\lg p</span>  as given provides at least 128 bits of security.</li>

    </ol>

    <p class="text-gray-300">In this subsection, we consider the question of deriving concrete group sizes from the asymptotic run time expressions. Following the ECRYPT recommendation [42, Page 26], consider a constant  <span class="math">A</span>  and write the run time of an NFS algorithm as</p>

    <div class="my-4 text-center"><span class="math-block">A \\cdot \\exp \\left((c + o (1)) (\\log Q) ^ {1 / 3} (\\log \\log Q) ^ {2 / 3}\\right). \\tag {11}</span></div>

    <p class="text-gray-300">Again following [42], assume  <span class="math">o(1) = 0</span> . In [42], the constant  <span class="math">A</span>  is determined in the following manner. It is mentioned that experience from available data points suggests that the resistance of RSA-512 is about 4 to 6 bits lower than that of DES. Plugging in  <span class="math">Q = 2^{512}</span>  and  <span class="math">c = (64/9)^{1/3}</span>  into (11) and setting the resulting expression equal to  <span class="math">2^{50}</span> , one obtains  <span class="math">A \\approx 2^{-14}</span> .</p>

    <p class="text-gray-300">More generally, let  <span class="math">A = 2^{-d}</span>  and denote by  <span class="math">s(Q,c,d)</span>  the base-two logarithm of the expression in (11) with  <span class="math">o(1) = 0</span> . Then, we have</p>

    <div class="my-4 text-center"><span class="math-block">s (Q, c, d) = c (\\lg e) (\\log Q) ^ {1 / 3} (\\log \\log Q) ^ {2 / 3} - d. \\tag {12}</span></div>

    <p class="text-gray-300">Here  <span class="math">Q</span>  is  <span class="math">p^n</span>  and  <span class="math">c</span>  is the second argument in the  <span class="math">L</span> -notation. As described above, the ECRYPT recommendation takes  <span class="math">d = 14</span> .</p>

    <p class="text-gray-300">The task of deriving group sizes is the following. Given  <span class="math">c, d, n</span>  and a target security level  <span class="math">\\ell</span> , find the minimum  <span class="math">Q</span>  such that both  <span class="math">(\\lg Q) / n \\geq 2\\ell</span>  and  <span class="math">s(Q, c, d) \\geq \\ell</span>  hold. The first condition ensures Pollard-rho security while the second condition ensures security against (exT)NFS attack. In the case where  <span class="math">\\rho &amp;gt; 1</span>  (see Table 1), the Pollard-rho condition  <span class="math">(\\lg Q) / n \\geq 2\\ell</span>  should be replaced with the condition  <span class="math">(\\lg Q) / n \\geq 2\\ell \\rho</span> .</p>

    <p class="text-gray-300">Taking  <span class="math">c = (64 / 9)^{1 / 3}</span>  and  <span class="math">d = 14</span> , yields  <span class="math">\\lg Q</span>  values of 3247, 7958, 15447 for  <span class="math">\\ell = 128</span> , 192, 256, respectively. These values of  <span class="math">\\lg Q</span>  are close to the ECRYPT recommendations of 3248, 7936, 15424.</p>

    <p class="text-gray-300">We note that taking <span class="math">c=(64/9)^{1/3}</span> and <span class="math">d=10</span> yields <span class="math">\\lg Q</span> values of 3034, 7587, 14889 for <span class="math">\\ell=128</span>, 192, 256, respectively. Rounding up these <span class="math">\\lg Q</span> values to the nearest integer multiple of 512 yields 3072, 7680, 15360, which are the NIST recommendations for prime-order fields at the 128, 192, 256-bit security levels <em>[6]</em>.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Remark 4.</h6>

    <p class="text-gray-300">(on the choice of <span class="math">d</span>) As we have described earlier, the <span class="math">L_{Q}(1/3,c)</span> run time expression for exTNFS is obtained from the bounds <span class="math">\\mathfrak{C}(\\eta,2\\kappa,H)\\cdot E^{2\\kappa}\\cdot O((\\log p)^{\\eta})</span> and <span class="math">\\mathfrak{C}(\\eta,\\kappa,H)\\cdot E^{\\kappa}\\cdot O(Q^{1/(2\\kappa)})</span> respectively on the norms <span class="math">N(f,\\phi)</span> and <span class="math">N(g,\\phi)</span>. The asymptotic analysis considers <span class="math">\\mathfrak{C}(\\eta,2\\kappa,H)</span> and <span class="math">\\mathfrak{C}(\\eta,\\kappa,H)</span> to be <span class="math">L_{Q}(2/3,o(1))</span> and ultimately the effect of these constants get absorbed in the <span class="math">o(1)</span> term in (11). At a later point, when we set <span class="math">o(1)</span> to be 0, we are in effect replacing the constants by 1. The values in Table 3 show that replacing the constants by 1 actually results in underestimates of the run time compared to what would be obtained from the actual values of the norms.</p>

    <p class="text-gray-300">Choosing a positive value of <span class="math">d</span> amounts to considering the actual run time to be lower than the run time predicted by values obtained from the asymptotic expression <span class="math">L_{Q}(1/3,c)</span> (with <span class="math">o(1)</span> assumed to be 0). Since the values obtained from the asymptotic run time expression are already lower than what would be obtained from the actual value of the norms, reducing these values further by choosing a value of <span class="math">d</span> greater than 0 seems to be over-engineering. So, we suggest that the value of <span class="math">d</span> be taken as 0 which would mean choosing <span class="math">A=1</span> in (11).</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">6.3 The 128-bit and 192-bit Security Levels</h3>

    <p class="text-gray-300">In this section, we provide estimates of group sizes required to achieve a desired security level. These estimates depend on the values of the norms <span class="math">N(f,\\phi)</span> and <span class="math">N(g,\\phi)</span>. One can work with the upper bounds on these norms. The upper bounds involve the constant terms which can be quite large. The experiments reported in Section 6.1 show that the actual values of the norms appear to be closer to the expressions for the upper bounds without the constants. So, we report group size estimates both with and without the constants in the norm bounds. The estimates obtained without considering the constants can be considered to be conservative estimates. The actual methodology for obtaining the estimates is described below.</p>

    <p class="text-gray-300">For each choice of security level <span class="math">\\ell\\in\\{128,192\\}</span>, the value of <span class="math">n</span>, the choice of curve, the choice of the algorithm (exTNFS or SexTNFS), and the choice of whether or not to use constants in the bounds, the following was done. For each possible non-trivial factor <span class="math">\\eta</span> of <span class="math">n</span>, let <span class="math">\\lg p(\\eta)</span> denote the minimum value of <span class="math">\\lg p</span> required to achieve security level <span class="math">\\ell</span>. The maximum of <span class="math">\\lg p(\\eta)</span> over all possible non-trivial factors <span class="math">\\eta</span> of <span class="math">n</span> is reported.</p>

    <p class="text-gray-300">The values <span class="math">\\lg p(\\eta)</span> were determined as follows. The initial value of <span class="math">\\lg p</span> was taken to be <span class="math">2\\rho\\ell</span> and the size <span class="math">B</span> of the factor base was fixed to <span class="math">2^{\\ell/2}</span>. The joint smoothness probability (9) was computed and the value of <span class="math">\\lg p</span> was incremented until for the first time the joint smoothness probability became lower than <span class="math">2^{-\\ell/2}</span>. This value was returned as <span class="math">\\lg p(\\eta)</span>.</p>

    <p class="text-gray-300">Once <span class="math">\\lg p</span> was calculated, the complexity of each stage was determined as follows. With all other parameters fixed, the value of <span class="math">B</span> was incremented until the smoothness probability became approximately equal to <span class="math">1/B</span>. This balances the costs of the relation collection and the linear algebra stages.</p>

    <p class="text-gray-300">The final results are given in Tables 4 and 5. Note that all estimates were generated using <span class="math">H=2</span>.</p>

    <p class="text-gray-300">A reasonable conclusion is that BN curves with <span class="math">\\lg p=383</span> and <span class="math">\\lg Q=4596</span> offer (at least) 128 bits of security. With these parameters, there is a mismatch in security levels with BN curves</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BN curves: n = 12, ρ = 1, λ = 4,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Γ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∞ = 36</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">algorithm</td>

            <td class="px-3 py-2 border-b border-gray-700">constants</td>

            <td class="px-3 py-2 border-b border-gray-700">η</td>

            <td class="px-3 py-2 border-b border-gray-700">κ</td>

            <td class="px-3 py-2 border-b border-gray-700">lg p</td>

            <td class="px-3 py-2 border-b border-gray-700">lg Q</td>

            <td class="px-3 py-2 border-b border-gray-700">lg(run time)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">without</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">311</td>

            <td class="px-3 py-2 border-b border-gray-700">3732</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">with</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">3072</td>

            <td class="px-3 py-2 border-b border-gray-700">136</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">without</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">383</td>

            <td class="px-3 py-2 border-b border-gray-700">4596</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">with</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">3072</td>

            <td class="px-3 py-2 border-b border-gray-700">150</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BLS12 curves: n = 12, ρ ≈ 1.5, λ = 6,</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Γ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">∞ ≈ 1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">algorithm</td>

            <td class="px-3 py-2 border-b border-gray-700">constants</td>

            <td class="px-3 py-2 border-b border-gray-700">η</td>

            <td class="px-3 py-2 border-b border-gray-700">κ</td>

            <td class="px-3 py-2 border-b border-gray-700">lg p</td>

            <td class="px-3 py-2 border-b border-gray-700">lg Q</td>

            <td class="px-3 py-2 border-b border-gray-700">lg(run time)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">without</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">4608</td>

            <td class="px-3 py-2 border-b border-gray-700">140</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">with</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">4608</td>

            <td class="px-3 py-2 border-b border-gray-700">156</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">without</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">4608</td>

            <td class="px-3 py-2 border-b border-gray-700">132</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">with</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">4608</td>

            <td class="px-3 py-2 border-b border-gray-700">189</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KSS curves: n = 18, ρ ≈ 4/3, λ = 8,</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Γ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">∞ ≈ 2401/21</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">algorithm</td>

            <td class="px-3 py-2 border-b border-gray-700">constants</td>

            <td class="px-3 py-2 border-b border-gray-700">η</td>

            <td class="px-3 py-2 border-b border-gray-700">κ</td>

            <td class="px-3 py-2 border-b border-gray-700">lg p</td>

            <td class="px-3 py-2 border-b border-gray-700">lg Q</td>

            <td class="px-3 py-2 border-b border-gray-700">lg(run time)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">without</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">342</td>

            <td class="px-3 py-2 border-b border-gray-700">6156</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">with</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">342</td>

            <td class="px-3 py-2 border-b border-gray-700">6156</td>

            <td class="px-3 py-2 border-b border-gray-700">184</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">without</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">342</td>

            <td class="px-3 py-2 border-b border-gray-700">6156</td>

            <td class="px-3 py-2 border-b border-gray-700">170</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">with</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">342</td>

            <td class="px-3 py-2 border-b border-gray-700">6156</td>

            <td class="px-3 py-2 border-b border-gray-700">274</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BLS24 curves: n = 24, ρ ≈ 1.25, λ = 10,</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Γ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">∞ ≈ 1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">algorithm</td>

            <td class="px-3 py-2 border-b border-gray-700">constants</td>

            <td class="px-3 py-2 border-b border-gray-700">η</td>

            <td class="px-3 py-2 border-b border-gray-700">κ</td>

            <td class="px-3 py-2 border-b border-gray-700">lg p</td>

            <td class="px-3 py-2 border-b border-gray-700">lg Q</td>

            <td class="px-3 py-2 border-b border-gray-700">lg(run time)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">without</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">320</td>

            <td class="px-3 py-2 border-b border-gray-700">7680</td>

            <td class="px-3 py-2 border-b border-gray-700">172</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">with</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">320</td>

            <td class="px-3 py-2 border-b border-gray-700">7680</td>

            <td class="px-3 py-2 border-b border-gray-700">204</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">without</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">320</td>

            <td class="px-3 py-2 border-b border-gray-700">7680</td>

            <td class="px-3 py-2 border-b border-gray-700">202</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">with</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">320</td>

            <td class="px-3 py-2 border-b border-gray-700">7680</td>

            <td class="px-3 py-2 border-b border-gray-700">360</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4. Approximate run times of exTNFS and SexTNFS for values of  <span class="math">Q</span>  and  <span class="math">n</span>  that achieve the 128-bit security level. The constants are  <span class="math">\\mathfrak{C}(\\eta, \\kappa, H)</span>  and  <span class="math">\\mathfrak{C}(\\eta, 2\\kappa, H)</span>  for exTNFS, and  <span class="math">\\mathfrak{C}(\\eta, \\kappa, H)</span>  and  <span class="math">\\mathfrak{C}(\\eta, \\kappa\\lambda, H)</span>  for SexTNFS.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BN curves: n = 12, ρ = 1, λ = 4,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Γ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∞ = 36</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">algorithm</td>

            <td class="px-3 py-2 border-b border-gray-700">constants</td>

            <td class="px-3 py-2 border-b border-gray-700">η</td>

            <td class="px-3 py-2 border-b border-gray-700">κ</td>

            <td class="px-3 py-2 border-b border-gray-700">lg p</td>

            <td class="px-3 py-2 border-b border-gray-700">lg Q</td>

            <td class="px-3 py-2 border-b border-gray-700">lg(run time)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">without</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">847</td>

            <td class="px-3 py-2 border-b border-gray-700">10164</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">with</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">728</td>

            <td class="px-3 py-2 border-b border-gray-700">8736</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">without</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1031</td>

            <td class="px-3 py-2 border-b border-gray-700">12372</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">with</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">697</td>

            <td class="px-3 py-2 border-b border-gray-700">8364</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BLS12 curves: n = 12, ρ ≈ 1.5, λ = 6,</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Γ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">∞ ≈ 1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">algorithm</td>

            <td class="px-3 py-2 border-b border-gray-700">constants</td>

            <td class="px-3 py-2 border-b border-gray-700">η</td>

            <td class="px-3 py-2 border-b border-gray-700">κ</td>

            <td class="px-3 py-2 border-b border-gray-700">lg p</td>

            <td class="px-3 py-2 border-b border-gray-700">lg Q</td>

            <td class="px-3 py-2 border-b border-gray-700">lg(run time)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">without</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">847</td>

            <td class="px-3 py-2 border-b border-gray-700">10164</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">with</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">728</td>

            <td class="px-3 py-2 border-b border-gray-700">8736</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">without</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1147</td>

            <td class="px-3 py-2 border-b border-gray-700">13764</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">with</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">576</td>

            <td class="px-3 py-2 border-b border-gray-700">6912</td>

            <td class="px-3 py-2 border-b border-gray-700">200</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KSS curves: n = 18, ρ ≈ 4/3, λ = 8,</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Γ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">∞ ≈ 2401/21</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">algorithm</td>

            <td class="px-3 py-2 border-b border-gray-700">constants</td>

            <td class="px-3 py-2 border-b border-gray-700">η</td>

            <td class="px-3 py-2 border-b border-gray-700">κ</td>

            <td class="px-3 py-2 border-b border-gray-700">lg p</td>

            <td class="px-3 py-2 border-b border-gray-700">lg Q</td>

            <td class="px-3 py-2 border-b border-gray-700">lg(run time)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">without</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">9216</td>

            <td class="px-3 py-2 border-b border-gray-700">194</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">with</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">9216</td>

            <td class="px-3 py-2 border-b border-gray-700">214</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">without</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">597</td>

            <td class="px-3 py-2 border-b border-gray-700">10746</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">with</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">9216</td>

            <td class="px-3 py-2 border-b border-gray-700">281</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BLS24 curves: n = 24, ρ ≈ 1.25, λ = 10,</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Γ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">∞ ≈ 1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">algorithm</td>

            <td class="px-3 py-2 border-b border-gray-700">constants</td>

            <td class="px-3 py-2 border-b border-gray-700">η</td>

            <td class="px-3 py-2 border-b border-gray-700">κ</td>

            <td class="px-3 py-2 border-b border-gray-700">lg p</td>

            <td class="px-3 py-2 border-b border-gray-700">lg Q</td>

            <td class="px-3 py-2 border-b border-gray-700">lg(run time)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">without</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">11520</td>

            <td class="px-3 py-2 border-b border-gray-700">203</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">with</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">11520</td>

            <td class="px-3 py-2 border-b border-gray-700">231</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">without</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">11520</td>

            <td class="px-3 py-2 border-b border-gray-700">214</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS</td>

            <td class="px-3 py-2 border-b border-gray-700">with</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">11520</td>

            <td class="px-3 py-2 border-b border-gray-700">366</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5. Approximate run times of exTNFS and SexTNFS for values of  <span class="math">Q</span>  and  <span class="math">n</span>  that achieve the 192-bit security level. The constants are  <span class="math">\\mathfrak{C}(\\eta, \\kappa, H)</span>  and  <span class="math">\\mathfrak{C}(\\eta, 2\\kappa, H)</span>  for exTNFS, and  <span class="math">\\mathfrak{C}(\\eta, \\kappa, H)</span>  and  <span class="math">\\mathfrak{C}(\\eta, \\kappa\\lambda, H)</span>  for SexTNFS.</p>

    <p class="text-gray-300"><span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{T}</span> — the former offers 191 bits of security, whereas the latter offers 128 bits. On the other hand, BLS12 curves (<span class="math">\\lambda=6</span>) with <span class="math">\\lg p=384</span> and <span class="math">\\lg Q=4608</span> do not have this mismatch — <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{T}</span> both offer 128 bits of security (the former since the bitlength of <span class="math">r</span> is approximately 256). Since KSS curves have <span class="math">\\rho\\approx 4/3</span> and BLS24 curves have <span class="math">\\rho\\approx 1.25</span>, these curves with <span class="math">\\lg p=342</span> and <span class="math">\\lg p=320</span>, respectively, offer (at least) 128 bits of security. In summary, if one is aiming for the 128-bit security level, then the bitlength of <span class="math">p</span> should be at least 383, 384, 342 and 320 for BN, BLS12, KSS and BLS24 pairings.</p>

    <p class="text-gray-300">For the 192-bit security level, the bitlength of <span class="math">p</span> should be at least 1031, 1147, 597 and 480 for BLS, BLS12, KSS and BLS24 pairings. This should be contrasted with the pre-TNFS recommendations of 640, 640, 512 and 480 bits <em>[1]</em>.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Remark 5</h6>

    <p class="text-gray-300">We have reported group size estimates for several families of curves at the 128-bit and the 192-bit security levels. The methodology for obtaining these estimates is more general. It can be applied to other curve families and also to the 256-bit security level.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Remark 6</h6>

    <p class="text-gray-300">Prior to the recent developments of the TNFS algorithm, BN curves with a 256-bit <span class="math">p</span> (and consequently a 3072-bit <span class="math">Q</span>) were considered to provide 128-bit security. Applying our methodology to these curves, we find the runtime estimates of exTNFS are <span class="math">2^{136}</span> and <span class="math">2^{118}</span> with and without constants respectively; and the runtime estimates of SexTNFS are <span class="math">2^{150}</span> and <span class="math">2^{110}</span> with and without constants respectively. Thus, a conservative estimate of the security level of BN curves with a 256-bit prime <span class="math">p</span> is 110 bits.</p>

    <h2 id="sec-33" class="text-2xl font-bold">7 Concluding Remarks</h2>

    <p class="text-gray-300">Our examination of the run times of recently-proposed improvements to the TNFS highlights their asymptotic nature. Much work remains to be done before the impact of these new algorithms on concrete keylengths for pairing-based cryptography can be determined with full confidence. Before this concrete analysis is completed, a conservative choice for BN pairings would be to increase the bitlength of <span class="math">p</span> from 256 to 383 if one is aiming for the 128-bit security level. For BLS12, KSS and BLS24 pairings, there is no change in the pre-TNFS recommendations to use primes <span class="math">p</span> of bitlength 384, 342 and 320, respectively, at the 128-bit security level. At the 192-bit security level, conservative choices for the bitlength <span class="math">p</span> are 1031, 1147, 597 and 480 for BN, BLS12, KSS and BL24 pairings, respectively.</p>

    <h2 id="sec-34" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">We thank the referees for their comments which helped improve the presentation of the paper.</p>

    <h2 id="sec-35" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] D. Aranha, L. Fuentes-Castañeda, E. Knapp, A. Menezes and F. Rodríguez-Henríquez, “Implementing pairings at the 192-bit security level”, Pairing-Based Cryptography – Pairing 2012, LNCS 7708 (2013), 177–195.</li>

      <li>[2] R. Barbulescu, P. Gaudry, A. Guillevic, and F. Morain, “Improving NFS for the discrete logarithm problem in non-prime finite fields”, Advances in Cryptology – EUROCRYPT 2015, LNCS 9056 (2015), 129–155.</li>

      <li>[3] R. Barbulescu, P. Gaudry, A. Joux and E. Thomé, “A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic: Improvements over FFS in small to medium characteristic”, Advances in Cryptology – EUROCRYPT 2014, LNCS 8441 (2014), 1–16.</li>

      <li>[</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[4] R. Barbulescu, P. Gaudry and T. Kleinjung, “The tower number field sieve”, Advances in Cryptology – ASIACRYPT 2015, LNCS 9453 (2015), 31–55.</li>

      <li>[5] R. Barbulescu and C. Pierrot, “The multiple number field sieve for medium and high characteristic finite fields”, LMS Journal of Computation and Mathematics, 17 (2014), 230–246.</li>

      <li>[6] E. Barker, “Recommendation for key management, Part 1: General”, NIST Special Publication 800-57, Part 1, Revision 4, January 2016.</li>

      <li>[7] P. Barreto, B. Lynn and M. Scott, “Constructing elliptic curves with prescribed embedding degrees”, Security in Communication Networks – SCN 2002, LNCS 2576 (2003), 257–267.</li>

      <li>[8] P. Barreto and M. Naehrig, “Pairing-friendly elliptic curves of prime order”, Selected Areas in Cryptography – SAC 2005, LNCS 3897 (2006), 319–331.</li>

      <li>[9] Y. Bistritz and A. Lifshitz, “Bounds for resultants of univariate and bivariate polynomials”, Linear Algebra and its Applications, 432 (2010), 1995–2005.</li>

      <li>[10] D. Boneh and X. Boyen, “Strong signatures without random oracles and the SDH assumption in bilinear groups”, Journal of Cryptology, 21 (2008), 149–177.</li>

      <li>[11] D. Boneh and M. Franklin, “Identity-based encryption from the Weil pairing”, Advances in Cryptology – CRYPTO 2001, LNCS 2139 (2001), 213–229.</li>

      <li>[12] D. Boneh, B. Lynn, and H. Shacham, “Short signatures from the Weil pairing”, Journal of Cryptology, 17 (2004), 297–319.</li>

      <li>[13] D. Boneh and H. Shacham, “Group signatures with verifier-local revocation”, 11th ACM Conference on Computer and Communications Security – CCS 2004, 168–177, 2004.</li>

      <li>[14] S. Chatterjee and A. Menezes, “On cryptographic protocols employing asymmetric pairings – The role of <span class="math">\\psi</span> revisited”, Discrete Applied Mathematics, 159 (2011), 1311–1322.</li>

      <li>[15] S. Chatterjee and A. Menezes, “Type 2 structure-preserving signature schemes revisited”, Advances in Cryptology – ASIACRYPT 2015, LNCS 9452 (2015), 286–310.</li>

      <li>[16] J. Cheon, “Security analysis of the Strong Diffie–Hellman problem”, Advances in Cryptology – EUROCRYPT 2006, LNCS 4004 (2006), 1–11.</li>

      <li>[17] J. Coron, T. Lepoint and M. Tibouchi, “Practical multilinear maps over the integers”, Advances in Cryptology – CRYPTO 2013, LNCS 8042 (2013), 476–493.</li>

      <li>[18] C. Diem, “On the discrete logarithm problem in elliptic curves”, Compositio Mathematica, 147 (2011), 75–104.</li>

      <li>[19] C. Diem, “On the discrete logarithm problem in elliptic curves II”, Algebra and Number Theory, 7 (2013), 1281–1323.</li>

      <li>[20] S. Garg, C. Gentry, S. Halevi, M. Raykova, S. Sahai and B. Waters, “Candidate indistinguishability obfuscation and functional encryption for all circuits”, IEEE 54th Annual Symposium on Foundations of Computer Science (FOCS), 2013, 40–49.</li>

      <li>[21] P. Gaudry, F. Hess and N. Smart, “Constructive and destructive facets of Weil descent on elliptic curves”, Journal of Cryptology, 15 (2002), 19–34.</li>

      <li>[22] D. Gordon, “Discrete logarithms in <span class="math">GF(p)</span> using the number field sieve”, SIAM Journal on Discrete Mathematics, 6 (1993), 124–138.</li>

      <li>[23] A. Guillevic, “Computing individual discrete logarithms faster in <span class="math">GF(p^{n})</span> with the NFS-DL algorithm”, Advances in Cryptology – ASIACRYPT 2015, LNCS 9452 (2015), 149–173.</li>

      <li>[24] D. Jao and K. Yoshida, “Boneh–Boyen signatures and the strong Diffie-Hellman problem”, Pairing-Based Cryptography – Pairing 2009, LNCS 5671 (2009), 1–16.</li>

      <li>[25] J. Jeong and T. Kim, “Extended tower number field sieve with application to finite fields of arbitrary composite extension degree”, Cryptology ePrint Archive: Report 2016/526, 2016.</li>

      <li>[26] A. Joux, Algorithmic Cryptanalysis. Chapman &amp; Hall/CRC, 2009.</li>

      <li>[27] A. Joux and R. Lercier, “Improvements to the general number field sieve for discrete logarithms in prime fields. A comparison with the Gaussian integer method”, Mathematics of Computation, 72 (2003), 953–967.</li>

      <li>[28] A. Joux, R. Lercier, N. Smart and F. Vercauteren, “The number field sieve in the medium prime case”’, Advances in Cryptology – CRYPTO 2006, LNCS 4117 (2006), 326–344.</li>

      <li>[29] A. Joux and C. Pierrot, “The special number field sieve in <span class="math">\\mathbb{F}_{p^{n}}</span> – Application to pairing-friendly constructions”, Pairing-Based Cryptography – Pairing 2013, LNCS 8365 (2013), 45–61.</li>

      <li>[30] E. Kachisa, E. Schaefer and M. Scott, “Constructing Brezing-Weng pairing-friendly elliptic curves using elements in the cyclotomic field”, Pairing-Based Cryptography – Pairing 2008, LNCS 5209 (2008), 126–135.</li>

      <li>[31] T. Kim and R. Barbulescu, “Extended tower number field sieve: A new complexity for medium prime case”, Advances in Cryptology – CRYPTO 2016, LNCS 9814 (2016), 543–571.</li>

      <li>[32] N. Koblitz and A. Menezes, “The brave new world of bodacious assumptions in cryptography”, Notices of the AMS, 57 (2010), 357–365.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A. Lenstra, H. Lenstra, M. Manasse and J. Pollard, “The number field sieve”, <em>The Development of the Number Field Sieve</em>, Lecture Notes in Mathematics 1554 (1993), 11–42</li>

      <li>K. Mayo, “A primer on cryptographic multilinear maps and code obfuscation”, M.Math. thesis, University of Waterloo, 2015. Available at http://hdl.handle.net/10012/9698.</li>

      <li>C. Pierrot. “The multiple number field sieve with conjugation and generalized Joux-Lercier methods”, <em>Advances in Cryptology – EUROCRYPT 2015</em>, LNCS 9056 (2015), 156–170.</li>

      <li>J. Pollard, “Monte Carlo methods for index computation mod <span class="math">p</span>”, <em>Mathematics of Computation</em>, 32 (1978), 918–924.</li>

      <li>P. Sarkar and S. Singh, “New complexity trade-offs for the (multiple) number field sieve algorithm in non-prime fields”, <em>Advances in Cryptology – EUROCRYPT 2016</em>, LNCS 9665 (2016), 429–458.</li>

      <li>P. Sarkar and S. Singh, “A general polynomial selection method and new asymptotic complexities for the tower number field sieve algorithm”, <em>Advances in Cryptology – ASIACRYPT 2016</em>, LNCS 10031 (2016), 37–62.</li>

      <li>P. Sarkar and S. Singh, “A generalisation of the conjugation method for polynomial selection for the extended tower number field sieve algorithm”, IACR Cryptology ePrint Archive: Report 2016/537, 2016.</li>

      <li>O. Schirokauer, “Discrete logarithms and local units”, <em>Philosophical Transactions of the Royal Society London A</em>, 345 (1993), 409–423.</li>

      <li>O. Schirokauer, “Using number fields to compute logarithms in finite fields”, <em>Mathematics of Computation</em>, 69 (2000), 1267–1283.</li>

      <li>N. Smart (editor), “ECRYPT II yearly report on algorithms and keysizes (2011-2012)”, September 30, 2012.</li>

    </ol>

    <h2 id="sec-36" class="text-2xl font-bold">Appendix A Calculations of Bounds on Resultants</h2>

    <p class="text-gray-300">Consider the setting of the TNFS with <span class="math">Q = p^n</span>, <span class="math">n = \\eta \\kappa</span>, <span class="math">h</span> a degree-<span class="math">\\eta</span> irreducible polynomial in <span class="math">\\mathbb{Z}[z]</span>, <span class="math">R = \\mathbb{Z}[z] / (h(z))</span>, and <span class="math">f, \\phi \\in R[x]</span>. Note that <span class="math">\\deg_z f = \\deg_z \\phi = \\eta - 1</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathfrak{f}(z,x)</span> be a bivariate polynomial with integer coefficients where <span class="math">\\mathfrak{f}_{i,j}</span> is the coefficient of <span class="math">x^i z^j</span>. Then $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{f}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = \\max</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{f}_{i,j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. Bounds on resultants of univariate and bivariate polynomials have been given in [9]. We summarize these below.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">a(u)</span> and <span class="math">b(u)</span> be two polynomials with integer coefficients. From [9], we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {R e s} _ {u} (a (u), b (u)) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq (\\deg (a) + 1) ^ {\\deg (b) / 2} \\cdot (\\deg (b) + 1) ^ {\\deg (a) / 2} \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} ^ {\\deg (b)} \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} ^ {\\deg (a)}. \\tag {13}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Let <span class="math">a(u,v)</span> and <span class="math">b(u,v)</span> be two polynomials with integer coefficients. Let <span class="math">c(u) = \\operatorname{Res}_v(a(u,v),b(u,v))</span>. Then</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq \\left(\\deg_ {v} (a) + \\deg_ {v} (b)\\right)! \\cdot \\left(\\max  \\left(\\deg_ {u} (a), \\deg_ {u} (b)\\right) + 1\\right) ^ {\\deg_ {v} a + \\deg_ {v} b - 1} \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} ^ {\\deg_ {v} b} \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} ^ {\\deg_ {v} a}. \\tag {14}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The bounds given by (13) and (14) combine to provide bounds on <span class="math">\\mathrm{Res}_z(\\mathrm{Res}_x(\\phi(x),\\mathfrak{f}(x)),h(z))</span>. Let <span class="math">\\mathfrak{c}(z) = \\mathrm{Res}_x(\\phi(x),\\mathfrak{f}(x))</span>. The degree of <span class="math">\\mathfrak{c}(z)</span> is given in [9] and from (14) we obtain $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{c}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}$. These quantities are as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l} \\deg \\mathfrak {c} (z) = (\\deg_ {x} \\phi + \\deg_ {x} f) \\cdot \\max (\\deg_ {z} \\phi + \\deg_ {z} f) = (\\eta - 1) (\\deg_ {x} \\phi + \\deg_ {x} f), \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak {c} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq (\\deg_ {x} \\phi + \\deg_ {x} \\mathfrak {f})! \\cdot (\\max  (\\deg_ {z} \\phi , \\deg_ {z} \\mathfrak {f}) + 1) ^ {\\deg_ {x} \\phi + \\deg_ {x} \\mathfrak {f} - 1} \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} ^ {\\deg_ {x} \\mathfrak {f}} \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak {f} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} ^ {\\deg_ {x} \\phi} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Using these values we obtain</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {R e s} _ {z} \\left(\\operatorname {R e s} _ {x} (\\phi (x), \\mathfrak {f} (x)), h (z)\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {R e s} _ {z} (\\mathfrak {c} (z), h (z)) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\left((\\eta - 1) \\left(\\deg_ {x} \\phi + \\deg_ {x} \\mathfrak {f}\\right) + 1\\right) ^ {\\eta / 2} \\cdot (\\eta + 1) ^ {(\\eta - 1) \\left(\\deg_ {x} \\phi + \\deg_ {x} \\mathfrak {f}\\right) / 2} \\cdot \\</td>

            <td class="px-3 py-2 border-b border-gray-700">h \\</td>

            <td class="px-3 py-2 border-b border-gray-700">_ {\\infty} ^ {(\\eta - 1) \\left(\\deg_ {x} \\phi + \\deg_ {x} \\mathfrak {f}\\right)} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\cdot \\left(\\left(\\deg_ {x} \\phi + \\deg_ {x} \\mathfrak {f}\\right)! \\cdot \\eta^ {\\deg_ {x} \\phi + \\deg_ {x} \\mathfrak {f} - 1}\\right) ^ {\\eta} \\cdot \\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\phi \\</td>

            <td class="px-3 py-2 border-b border-gray-700">_ {\\infty} ^ {\\eta \\deg_ {x} \\mathfrak {f}} \\cdot \\times \\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathfrak {f} \\</td>

            <td class="px-3 py-2 border-b border-gray-700">_ {\\infty} ^ {\\eta \\deg_ {x} \\phi}. \\tag {15}</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>`;
---

<BaseLayout title="Challenges with Assessing the Impact of NFS Advances on the ... (2016/1102)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/1102
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
