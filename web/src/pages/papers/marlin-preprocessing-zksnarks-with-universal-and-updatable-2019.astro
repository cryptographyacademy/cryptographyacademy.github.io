---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/1047';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS';
const AUTHORS_HTML = 'Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Psi Vesely, Nicholas Ward';

const CONTENT = `    <p class="text-gray-300">1</p>

    <p class="text-gray-300">|  Alessandro Chiesa alexch@berkeley.edu</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">UC Berkeley</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Yuncong Hu</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">yuncong_hu@berkeley.edu</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">UC Berkeley</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Mary Maller</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">mary.maller.15@ucl.ac.uk</p>

    <p class="text-gray-300">UCL  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Pratyush Mishra pratyush@berkeley.edu</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">UC Berkeley</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Psi Vesely</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">psi@ucsd.edu</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">UCL</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Nicholas Ward</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">npward@berkeley.edu</p>

    <p class="text-gray-300">UC Berkeley  |</p>

    <p class="text-gray-300">May 27, 2020</p>

    <p class="text-gray-300">We present a methodology to construct preprocessing zkSNARKs where the structured reference string (SRS) is universal and updatable. This exploits a novel use of holography [Babai et al., STOC 1991], where fast verification is achieved provided the statement being checked is given in encoded form.</p>

    <p class="text-gray-300">We use our methodology to obtain a preprocessing zkSNARK where the SRS has linear size and arguments have constant size. Our construction improves on Sonic [Maller et al., CCS 2019], the prior state of the art in this setting, in all efficiency parameters: proving is an order of magnitude faster and verification is thrice as fast, even with smaller SRS size and argument size. Our construction is most efficient when instantiated in the algebraic group model (also used by Sonic), but we also demonstrate how to realize it under concrete knowledge assumptions. We implement and evaluate our construction.</p>

    <p class="text-gray-300">The core of our preprocessing zkSNARK is an efficient algebraic holographic proof (AHP) for rank-1 constraint satisfiability (R1CS) that achieves linear proof length and constant query complexity.</p>

    <p class="text-gray-300">Keywords: succinct arguments; universal SRS; algebraic holographic proofs; polynomial commitments</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 1.1 Our results  5 1.2 Related work  7</p>

    <p class="text-gray-300">2  Techniques  10 2.1 Building block: algebraic holographic proofs  10 2.2 Building block: polynomial commitments  11 2.3 Compiler: from AHPs to preprocessing arguments with universal SRS  12 2.4 Construction: an AHP for constraint systems  13 2.5 Construction: extractable polynomial commitments  16</p>

    <p class="text-gray-300">3  Preliminaries  18 3.1 Indexed relations  18</p>

    <p class="text-gray-300">4  Algebraic holographic proofs  19</p>

    <p class="text-gray-300">5  AHP for constraint systems  21 5.1 Algebraic preliminaries  21 5.2 AHP for the lincheck problem  22 5.3 AHP for R1CS  27</p>

    <p class="text-gray-300">6  Polynomial commitment schemes with extractability  33 6.1 Definition  33 6.2 Construction  35</p>

    <p class="text-gray-300">7  Preprocessing arguments with universal SRS  39</p>

    <p class="text-gray-300">8  From AHPs to preprocessing arguments with universal SRS  41 8.1 Construction  41 8.2 Proof of Theorem 8.1  43 8.3 Proof of Theorem 8.3  46 8.4 Proof of Theorem 8.4  47</p>

    <p class="text-gray-300">9  MARLIN: an efficient preprocessing zkSNARK with universal SRS  49 9.1 Optimizations for the AHP  49 9.2 Optimizations for the polynomial commitment scheme  50</p>

    <p class="text-gray-300">A  Cryptographic assumptions  53 A.1 Bilinear groups  53 A.2 Strong Diffie-Hellman  53 A.3 Power knowledge of exponent  53 A.4 Algebraic group model  55 A.5 The effect of powers on security  56</p>

    <p class="text-gray-300">B  Polynomial commitments for a single degree bound  57 B.1 Definition  57 B.2 In the plain model  58 B.3 In the algebraic group model  66</p>

    <p class="text-gray-300">C  Polynomial commitments for multiple degree bounds  69 C.1 Degree-efficient construction  69 C.2 Black-box construction  72</p>

    <p class="text-gray-300">D  Polynomial commitments that support different query locations  75 D.1 Construction  75 D.2 Extractability  75 D.3 Hiding  76</p>

    <p class="text-gray-300">E  An optimized AHP for R1CS  78</p>

    <p class="text-gray-300">Acknowledgments  79</p>

    <p class="text-gray-300">References  79</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Succinct non-interactive arguments (SNARGs) are efficient certificates of membership in non-deterministic languages. Recent years have seen a surge of interest in zero-knowledge SNARGs of knowledge (zkSNARKs), with researchers studying constructions under different cryptographic assumptions, improvements in asymptotic efficiency, concrete performance of implementations, and numerous applications. The focus of this paper is SNARGs in the preprocessing setting, a notion that we motivate next.</p>

    <p class="text-gray-300">When is fast verification possible? The size of a SNARG must be, as a minimum condition, sublinear in the size of the non-deterministic witness, and often is required to be even smaller (e.g., logarithmic in the size of the non-deterministic computation). The time to verify a SNARG would be, ideally, as fast as reading the SNARG. This is in general too much to hope for, however. The verification procedure must also read the description of the computation, in order know what statement is being verified. While there are natural computations that have succinct descriptions (e.g., machine computations), in general the description of a computation could be as large as the computation itself, which means that the time to verify the SNARG could be asymptotically comparable to the size of the computation. This is unfortunate because there is a very useful class of computations for which we cannot expect fast verification: general circuit computations.</p>

    <p class="text-gray-300">The preprocessing setting. An approach to avoid the above limitation is to design a verification procedure that has two phases: an offline phase that produces a short summary for a given circuit; and an online phase that uses this short summary to verify SNARGs that attest to the satisfiability of the circuit with different partial assignments to its input wires. Crucially, now the online phase could in principle be as fast as reading the SNARG (and the partial assignment), and thus sublinear in the circuit size. This goal was captured by preprocessing SNARGs <em>[x11, x14, x1, Bit+13]</em>, which have been studied in an influential line of works that has led to highly-efficient constructions that fulfill this goal (e.g., <em>[x11]</em>) and large-scale deployments in the real world that benefit from the online fast verification (e.g., <em>[x22]</em>).</p>

    <p class="text-gray-300">The problem: circuit-specific SRS. The offline phase in efficient constructions of preprocessing SNARGS consists of sampling a structured reference string (SRS) that depends on the circuit that is being preprocessed. This implies that producing/validating proofs with respect to different circuits requires different SRSs. In many applications of interest, there is no single party that can be entrusted with sampling the SRS, and so real-world deployments have had to rely on cryptographic “ceremonies” <em>[x22]</em> that use secure multi-party sampling protocols <em>[Ben+15, x1, x2, Abd+19]</em>. However, any modification in the circuit used in an application requires another cryptographic ceremony, which is unsustainable for many applications.</p>

    <p class="text-gray-300">A solution: universal SRS. The above motivates preprocessing SNARGs where the SRS is universal, which means that the SRS supports any circuit up to a given size bound by enabling anyone, in an offline phase after the SRS is sampled, to publicly derive a circuit-specific SRS. Known techniques to obtain a universal SRS from circuit-specific SRS introduce expensive overheads due to universal simulation <em>[Ben+14a, Ben+14b]</em>. Also, these techniques lead to universal SRSs that are not updatable, a property introduced in <em>[Gro+18]</em> that significantly simplifies cryptographic ceremonies. The recent work of Maller et al. <em>[x18]</em> overcomes these shortcomings, obtaining the first efficient construction of a preprocessing SNARG with universal (and updatable) SRS. Even so, the construction in <em>[x18]</em> is considerably more expensive than the state of the art for circuit-specific SRS <em>[x11]</em>. In this paper we ask: can the efficiency gap between universal SRS and circuit-specific SRS be closed, or at least significantly reduced?</p>

    <p class="text-gray-300">Concurrent work. A concurrent work [GWC19] studies the same question as this paper. See Section 1.2 for a brief discussion that compares the two works.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">construction</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">argument size over BN-256 (bytes)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">argument size over BLS12-381 (bytes)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Sonic [Mal+19]</td>

            <td class="px-3 py-2 border-b border-gray-700">1152</td>

            <td class="px-3 py-2 border-b border-gray-700">1472</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MARLIN [this work]</td>

            <td class="px-3 py-2 border-b border-gray-700">704</td>

            <td class="px-3 py-2 border-b border-gray-700">880</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Groth16 [Gro16]</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">zkSNARK construction</td>

            <td class="px-3 py-2 border-b border-gray-700">sizes</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">time complexity</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ipk</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ivk</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">generator</td>

            <td class="px-3 py-2 border-b border-gray-700">indexer</td>

            <td class="px-3 py-2 border-b border-gray-700">prover</td>

            <td class="px-3 py-2 border-b border-gray-700">verifier</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Sonic [Mal+19]</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">8m</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">8 f-MSM(M)</td>

            <td class="px-3 py-2 border-b border-gray-700">4 v-MSM(3m)</td>

            <td class="px-3 py-2 border-b border-gray-700">273 v-MSM(m)</td>

            <td class="px-3 py-2 border-b border-gray-700">7 pairings</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">8m</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">8 f-MSM(M)</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Fq</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">+ log m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MARLIN [this work]</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">4m</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">1 f-MSM(3M)</td>

            <td class="px-3 py-2 border-b border-gray-700">12 v-MSM(m)</td>

            <td class="px-3 py-2 border-b border-gray-700">22 v-MSM(m)</td>

            <td class="px-3 py-2 border-b border-gray-700">2 pairings</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Fq</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">+ log m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Groth16 [Gro16]</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">4n</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">4 f-MSM(n)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4 v-MSM(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">1 v-MSM(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 f-MSM(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">1 v-MSM(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">3 pairings</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Fq</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m+n log n)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(m+n log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">n</span> : number of multiplication gates in the circuit <span class="math">m</span> : total number of (addition or multiplication) gates in the circuit <span class="math">M</span> : maximum supported circuit size (maximum number of addition and multiplication gates)</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Comparison of two preprocessing zkSNARKs with universal (and updatable) SRS: the prior state of the art and our construction. We include the current state of the art for circuit-specific SRS (in gray), for reference. Here  <span class="math">\\mathbb{G}_1 / \\mathbb{G}_2 / \\mathbb{F}_q</span>  denote the number of elements or operations over the respective group/field; also, f-MSM(m) and v-MSM(m) denote fixed-base and variable-base multi-scalar multiplications (MSM) each of size  <span class="math">m</span> , respectively. The number of pairings that we report for Sonic's verifier is lower than that reported in [Mal+19] because we account for standard batching techniques for pairing equations.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: Measured performance of MARLIN and [Gro16] over the BLS12-381 curve. We could not include measurements for [Mal+19, Sonic] because at the time of writing there is no working implementation of its unhelped variant.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <p class="text-gray-300">In this paper we present MARLIN, a new preprocessing zkSNARK with universal (and updatable) SRS that improves on the prior state of the art [Mal+19, Sonic] in essentially all relevant efficiency parameters.² In addition to reducing argument size by several group and field elements and reducing time complexity of the verifier by over <span class="math">3 \\times</span>, our construction overcomes the main efficiency drawback of [Mal+19, Sonic]: the cost of producing proofs. Indeed, our construction improves time complexity of the prover by over <span class="math">10 \\times</span>, achieving prover efficiency comparable to the case of preprocessing zkSNARKs with circuit-specific SRS. In Fig. 1 we provide a comparison of our construction and [Mal+19, Sonic], including argument sizes for two popular elliptic curves; the table also includes the state of the art for circuit-specific SRS. We have implemented MARLIN in a Rust library,³ and report evaluation results in Fig. 2.</p>

    <p class="text-gray-300">Our zkSNARK is the result of several contributions that we deem of independent interest, summarized below.</p>

    <p class="text-gray-300">(1) A new methodology. We present a general methodology to construct preprocessing SNARGs (and also zkSNARKs) where the SRS is universal (and updatable). The methodology in fact produces succinct interactive arguments that can be made non-interactive via the Fiat-Shamir transformation [FS86]. Hence below we focus on preprocessing arguments with universal and updatable SRS (see Section 7 for the definition).</p>

    <p class="text-gray-300">Our key observation is that the ability to preprocess a circuit in an offline phase is closely related to constructing "holographic proofs" [Bab+91], which means that the verifier does not receive the circuit description as an input but, rather, makes a small number of queries to an encoding of it. These queries are in addition to queries that the verifier makes to proofs sent by the prover. Moreover, in this paper we focus on the setting where the encoding of the circuit description consists of low-degree polynomials and also where proofs are themselves low-degree polynomials — this can be viewed as a requirement that honest and malicious provers are "algebraic". We call these algebraic holographic proofs (AHPs); see Section 4 for definitions.</p>

    <p class="text-gray-300">We present a transformation that "compiles" any public-coin AHP into a corresponding preprocessing argument with universal (and updatable) SRS by using suitable polynomial commitments.</p>

    <p class="text-gray-300">Theorem 1 (informal version of Theorem 8.1). There is an efficient transformation that combines any public-coin AHP for a relation <span class="math">\\mathcal{R}</span> and an extractable polynomial commitment scheme to obtain a public-coin preprocessing argument with universal SRS for the relation <span class="math">\\mathcal{R}</span>. The transformation preserves zero knowledge and proof of knowledge of the underlying AHP. The SRS is updatable provided the SRS of the polynomial commitment scheme is.</p>

    <p class="text-gray-300">The above transformation provides us with a methodology to construct preprocessing zkSNARKs with universal SRS (see Fig. 3). Namely, to improve the efficiency of preprocessing zkSNARKs with universal SRS it suffices to improve the efficiency of simpler building blocks: AHPs (an information-theoretic primitive) and polynomial commitments (a cryptographic primitive).⁴</p>

    <p class="text-gray-300">The improvements achieved by our preprocessing zkSNARK (see Fig. 1) were obtained by following this methodology: we designed efficient constructions for each of these two building blocks (which we discuss shortly), combined them via Theorem 1, and then applied the Fiat-Shamir transformation [FS86].</p>

    <p class="text-gray-300">²Maller et al. [Mal+19] discuss two variants of their protocol, a cheaper one for the “helped setting” and a costlier one for the “unhelped setting”. The variant that is relevant to this paper is the latter one, because it is a preprocessing zkSNARK. (The former variant does not achieve succinct verification, and instead achieves a weaker guarantee that applies to proof batches.)</p>

    <p class="text-gray-300">³https://github.com/scipr-lab/marlin</p>

    <p class="text-gray-300">⁴The methodology also captures as a special case various folklore approaches used in prior works to construct non-preprocessing zkSNARKs via polynomial commitment schemes (see Section 1.2), thereby providing the first formal statement that clarifies what properties of algebraic proofs and polynomial commitment schemes are essential for these folklore approaches.</p>

    <p class="text-gray-300">Methodologies that combine information-theoretic probabilistic proofs and cryptographic tools have played a fundamental role in the construction of efficient argument systems. In the particular setting of preprocessing SNARGs, for example, the compiler introduced in [Bit+13] for circuit-specific SRS has paved the way towards current state-of-the-art constructions [Gro16], and also led to constructions that are plausibly post-quantum [Bon+17; Bon+18]. We believe that our methodology for universal SRS will also be useful in future work, and may lead to further efficiency improvements.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 3: Diagram of our methodology to construct preprocessing SNARGs with universal SRS.</p>

    <p class="text-gray-300">(2) An efficient AHP for R1CS. We design an algebraic holographic proof (AHP) that achieves linear proof length and constant query complexity, among other useful efficiency features. The protocol is for rank-1 constraint satisfiability (R1CS), a well-known generalization of arithmetic circuits where the "circuit description" is given by coefficient matrices (see definition below). Note that the relations that we consider consist of triples rather than pairs, because we need to split the verifier's input into a part for the offline phase and a part for the online phase. The offline input is called the index, and it consists of the coefficient matrices; the online input is called the instance, and it consists of a partial assignment to the variables. The algorithm that encodes the index (coefficient matrices) in the offline phase is called the indexer.</p>

    <p class="text-gray-300">Definition 1 (informal). The indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span>  is the set of triples  <span class="math">(\\dot{\\mathbf{i}},\\mathbf{x},\\mathbf{w}) = ((\\mathbb{F},n,m,A,B,C),x,w)</span>  where  <span class="math">\\mathbb{F}</span>  is a finite field,  <span class="math">A,B,C</span>  are  <span class="math">n\\times n</span>  matrices over  <span class="math">\\mathbb{F}</span> , each containing at most  <span class="math">m</span>  non-zero entries, and  <span class="math">z\\coloneqq (x,w)</span>  is a vector in  <span class="math">\\mathbb{F}^n</span>  such that  <span class="math">Az\\circ Bz = Cz</span> . (Here “ <span class="math">\\circ</span> ” denotes the entry-wise product.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 2 (informal). There exists a constant-round AHP for the indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span>  with linear proof length and constant query complexity. The soundness error is  $O(m /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> , and the construction is a zero knowledge proof of knowledge. The arithmetic complexity of the indexer is  </span>O(m\\log m)<span class="math"> , of the prover is  </span>O(m\\log m)<span class="math"> , and of the verifier is  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\log m)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The literature on probabilistic proofs contains algebraic protocols that are holographic (e.g., [Bab+91] and [GKR15]) but none achieve constant query complexity, and so applying our methodology (Theorem 1) to these would lead to large argument sizes (many tens of kilobytes). These prior algebraic protocols rely on the multivariate sumcheck protocol applied to certain multivariate polynomials, which means that they incur sizable communication costs due to (a) the many rounds of the sumcheck protocol, and (b) the fact that applying the methodology would involve using multivariate polynomial commitment schemes that (for known constructions) lead to communication costs that are linear in the number of variables.</p>

    <p class="text-gray-300">In contrast, our algebraic protocol relies on univariate polynomials and achieves constant query complexity, incurring small communication costs. Our algebraic protocol can be viewed as a "holographic variant" of the algebraic protocol for R1CS used in Aurora [Ben+19c], because it achieves an exponential improvement in verification time when the verifier is given a suitable encoding of the coefficient matrices; see Table 1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">construction</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">holographic?</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">indexer</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">messages</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">proof length</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">queries</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Ben+19c]</td>

            <td class="px-3 py-2 border-b border-gray-700">NO</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m+n log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">+ n)</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">this work</td>

            <td class="px-3 py-2 border-b border-gray-700">YES</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">+ log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Comparison of the non-holographic protocol for R1CS in [Ben+19c], and the AHP for R1CS that we construct. Here  <span class="math">n</span>  denotes the number of variables and  <span class="math">m</span>  the number of non-zero coefficients in the matrices.</p>

    <p class="text-gray-300">(3) Extractable polynomial commitments. Polynomial commitment schemes, introduced in [KZG10], are commitment schemes specialized to work with univariate polynomials. The security properties in [KZG10], while sufficient for the applications therein, do not appear sufficient for standalone use, or even just for the transformation in Theorem 1. We propose a definition for polynomial commitment schemes that incorporates the functionality and security that we believe to suffice for standalone use (and in particular suffices for Theorem 1). Moreover, we show how to extend the construction of [KZG10] to fulfill this definition in the plain model under non-falsifiable knowledge assumptions, or via a more efficient construction in the algebraic group model [FKL18] under falsifiable assumptions. These constructions are of independent interest, and when combined with our transformation, lead to the first efficient preprocessing arguments with universal SRS under concrete knowledge assumptions, and also to the efficiency reported in Fig. 1.</p>

    <p class="text-gray-300">We have implemented in a Rust library <span class="math">^5</span>  the polynomial commitment schemes, and our implementation of MARLIN relies on this library. We deem this library of independent interest for other projects.</p>

    <p class="text-gray-300">In this paper we study the goal of constructing preprocessing SNARGs with universal SRS, which achieve succinct verification regardless of the structure of the non-deterministic computation being checked. The most relevant prior work is Sonic [Mal+19], on which we improve as already discussed (see Fig. 1). The notion of updatable SRS was defined and achieved in [Gro+18], but with a less efficient construction.</p>

    <p class="text-gray-300">Concurrent work. A concurrent work [GWC19] studies the same question as this paper, and also obtains efficiency improvements over Sonic [Mal+19]. Below is a brief comparison.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Similarly to our work, [GWC19] extends the polynomial commitment in [KZG10] to support batching, and proves the extension secure in the algebraic group model. We additionally show how to prove security in the plain model under non-falsifiable knowledge assumptions, and consider the problem of enforcing different degrees for different polynomials (a feature that is not needed in [GWC19]).</li>

      <li>We show how to compile any algebraic holographic proof into a preprocessing argument with universal SRS, while [GWC19] focus on compiling a more restricted notion that they call "polynomial protocols".</li>

      <li>Our protocol natively supports R1CS, and can be viewed as a holographic variant of the algebraic protocol in [Ben+19c]. The protocol in [GWC19] natively supports a different constraint system, and involves a protocol that, similar to [Gro10], uses a permutation argument to attest that all variables in the same cycle of a permutation are equal (e.g., (1)(2,3)(4) would require that the second and third entries are equal).</li>

    </ul>

    <p class="text-gray-300">Preprocessing SNARGs with a URS. Setty [Set19] studies preprocessing SNARGs with a URS (uniform reference string), and describes a protocol that for  <span class="math">n</span> -gate arithmetic circuits and a chosen constant  <span class="math">c \\geq 2</span>  achieves proving time  <span class="math">O_{\\lambda}(n)</span> , argument size  <span class="math">O_{\\lambda}(n^{1/c})</span> , and verification time  <span class="math">O_{\\lambda}(n^{1-1/c})</span> . The protocol in</p>

    <p class="text-gray-300"><em>[x23]</em> offers a tradeoff compared to our work: preprocessing with a URS instead of a SRS, at the cost of asymptotically larger argument size and verification time. The question of achieving processing with a URS while also achieving asymptotically small argument size and verification time remains open.</p>

    <p class="text-gray-300">The protocol in <em>[x23]</em> is obtained by combining the multivariate polynomial commitments of <em>[x30]</em> and a modern rendition of the PCP in <em>[x1]</em> (which itself can be viewed as the “bare bones” protocol of <em>[x13]</em> for circuits of depth <span class="math">1</span>). <em>[x23]</em> lacks an analysis of concrete costs, and also does not discuss how to achieve zero knowledge beyond stating that techniques in other papers <em>[x27, x30, x31, x32]</em> can be applied. Nevertheless, argument sizes would at best be similar to these other papers (tens of kilobytes), which is much larger than our argument sizes (in the SRS model).</p>

    <p class="text-gray-300">We conclude by noting that the informal security proof in <em>[x23]</em> appears insufficient to show soundness of the argument system, because the polynomial commitment scheme is only assumed to be binding but not also extractable (there is no explanation of where the witness encoded in the committed polynomial comes from). Our definitions and security proofs, if ported over to the multivariate setting, would fill this gap.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Remark 1.1.</h6>

    <p class="text-gray-300"><em>Setty </em>[x23]<em> also suggests using multivariate polynomial commitments with an SRS </em>[x28]<em>, which could lead to asymptotically smaller argument size and faster verification time. Perhaps because this is not the focus of Spartan (which advocates the benefits of a URS) there are no analyses of security or concrete efficiency for this case. By analogy to arguments with an SRS that use such commitments </em>[x30]<em>, one may guess that Setty’s suggestion would lead to arguments with faster prover time and larger argument sizes (tens of kilobytes) in comparison to our work. Working out the details of this suggestion is left to future work.</em></p>

    <h5 id="sec-7" class="text-base font-semibold mt-4">Non-preprocessing SNARGs for arbitrary computations.</h5>

    <p class="text-gray-300">Checking arbitrary circuits without preprocessing them requires the verifier to read the circuit, so the main goal is to obtain small argument size. In this setting of non-preprocessing SNARGs for arbitrary circuits, constructions with a URS (uniform reference string) are based on discrete logarithms <em>[x7, x10]</em> or hash functions <em>[x1, x2, x1]</em>, while constructions with a universal SRS (structured reference string) combine polynomial commitments and non-holographic algebraic proofs <em>[x11]</em>; all use random oracles to obtain non-interactive arguments.</p>

    <p class="text-gray-300">We find it interesting to remark that our methodology from Theorem 1 generalizes protocols such as <em>[x11]</em> in two ways. First, it formalizes the folklore approach of combining polynomial commitments and algebraic proofs to obtain arguments, identifying the security properties required to make this approach work. Second, it demonstrates how for algebraic <em>holographic</em> proofs the resulting argument enables preprocessing.</p>

    <h5 id="sec-8" class="text-base font-semibold mt-4">Non-preprocessing SNARGs for structured computations.</h5>

    <p class="text-gray-300">Several works study SNARGs for structured computations. This structure enables fast verification <em>without</em> preprocessing. A line of works <em>[x2, x3, x4, x5]</em> combines hash functions and various interactive oracle proofs. Another line of works <em>[x27, x27, x28, x30, x31]</em> combines multivariate polynomial commitments <em>[x28]</em> and doubly-efficient interactive proofs <em>[x13]</em>.</p>

    <p class="text-gray-300">While in this paper we study a different setting (<em>preprocessing</em> SNARGs for <em>arbitrary</em> computations), there are similarities, and notable differences, in the polynomial commitments used in our work and prior works. We begin by noting that the notion of “multivariate polynomial commitments” varies considerably across prior works, despite the fact that most of those commitments are based on the protocol introduced in <em>[x28]</em>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The commitments used in <em>[x27, x27]</em> are required to satisfy extractability (a stronger notion than binding) because the security proof of the argument system involves extracting a polynomial encoding a</li>

    </ul>

    <p class="text-gray-300">witness. The commitment is a modification of <em>[x20]</em> that uses knowledge commitments, a standard ingredient to achieve extractability under non-falsifiable assumptions in the plain model. Neither of these works consider hiding commitments as zero knowledge is not a goal for them.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The commitments used in <em>[x27, x28]</em> must be compatible with the Cramer–Damgård transform <em>[x10]</em> used in constructing the argument system. They consider a <em>modified setting</em> where the sender does not reveal the value of the commitment polynomial at a desired point but, instead, reveals a commitment to this value, along with a proof attesting that the committed value is correct. For this modified setting, they consider commitments that satisfy natural notions of extractability <em>and hiding</em> (achieving zero knowledge arguments is a goal in both papers). The commitments constructed in the two papers offer different tradeoffs. The commitment in <em>[x27]</em> is based on <em>[x20]</em>: it relies on a SRS (structured reference string); it uses pairings; and for <span class="math">\\ell</span>-variate polynomials achieves <span class="math">O_{\\lambda}(\\ell)</span>-size arguments that can be checked in <span class="math">O_{\\lambda}(\\ell)</span> time. The commitment in <em>[x28]</em> is inspired from <em>[x3]</em> and <em>[x5]</em>: it relies on a URS (uniform reference string); it does not use pairings; and for <span class="math">\\ell</span>-variate <em>multilinear</em> polynomials and a given constant <span class="math">c\\geq 2</span> achieves <span class="math">O_{\\lambda}(2^{\\ell/c})</span>-size arguments that can be checked in <span class="math">O_{\\lambda}(2^{\\ell-\\ell/c})</span> time.</li>

      <li>The commitments used in <em>[x31]</em> are intended for the regular (unmodified) setting of commitment schemes where the sender reveals the value of the polynomial, because zero knowledge is later achieved by building on the algebraic techniques described in <em>[x7]</em>. The commitment definition in <em>[x31]</em> considers binding and hiding, but not extractability. However, the given security analysis for the argument system does not seem to go through for this definition (there is no explanation of where the witness encoded in the committed polynomial comes from). Also, no commitment construction is provided in <em>[x31]</em>, and instead the reader is referred to <em>[x27]</em>, which considers the modified setting described above.</li>

    </ul>

    <p class="text-gray-300">In sum there are multiple notions of commitment and one must be precise about the functionality and security needed to construct an argument system. We now compare prior notions of commitments to the one that we use.</p>

    <p class="text-gray-300">First, since in this paper we do not use the Cramer–Damgård transform for zero knowledge, commitments in the modified setting are not relevant. Instead, we achieve zero knowledge via <em>bounded independence</em> <em>[x1]</em>, and in particular we consider the familiar setting where the sender reveals evaluations to the committed polynomial. Second, prior works consider protocols where the sender commits to a polynomial in a single round, while we consider protocols where the sender commits to multiple polynomials of different degrees in each of several rounds. This multi-polynomial multi-round setting requires suitable extensions in terms of functionality (to enable batching techniques to save on argument size) and security (extractability and hiding need to be strengthened), which means that prior definitions do not suffice for us.</p>

    <p class="text-gray-300">The above discrepancies have led us to formulate new definitions of functionality and security for polynomial commitments (as summarized in Section 2.2). We conclude by noting that, since in this paper we construct arguments that use <em>univariate</em> polynomials, our definitions are specialized to commitments for univariate polynomials. Corresponding definitions for multivariate polynomials can be obtained with straightforward modifications, and would strengthen definitions appearing in some prior works. Similarly, we fulfill the required definitions via natural adaptations of the univariate scheme of <em>[x16]</em>, and analogous adaptations of the multivariate scheme of <em>[x20]</em> would fulfill the multivariate analogues of these definitions.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2 Techniques</p>

    <p class="text-gray-300">We discuss the main ideas behind our results. First we describe the two building blocks used in Theorem 1: AHPs and polynomial commitment schemes (described in Sections 2.1 and 2.2 respectively). We describe how to combine these to obtain preprocessing arguments with universal SRS in Section 2.3. Next, we discuss constructions for these building blocks: in Section 2.4 we describe our AHP (underlying Theorem 2), and in Section 2.5 we describe our construction of polynomial commitments.</p>

    <p class="text-gray-300">Throughout, instead of considering the usual notion of relations that consist of instance-witness pairs, we consider <em>indexed relations</em>, which consist of triples <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w})</span> where <span class="math">\\dot{\\mathfrak{s}}</span> is the index, <span class="math">\\mathfrak{x}</span> is the instance, and <span class="math">\\mathfrak{w}</span> is the witness. This is because <span class="math">\\dot{\\mathfrak{s}}</span> represents the part of the verifier input that is preprocessed in the offline phase (e.g., the circuit description) and <span class="math">\\mathfrak{x}</span> represents the part of the verifier input that comes in the online phase (e.g., a partial assignment to the circuit’s input wires). The <em>indexed language</em> corresponding to an indexed relation <span class="math">\\mathcal{R}</span>, denoted <span class="math">\\mathcal{L}(\\mathcal{R})</span>, is the set of pairs <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x})</span> for which there exists a witness <span class="math">\\mathfrak{w}</span> such that <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w})\\in\\mathcal{R}</span>.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.1 Building block: algebraic holographic proofs</h3>

    <p class="text-gray-300">Interactive oracle proofs (IOPs) <em>[x1, x21]</em> are multi-round protocols where in each round the verifier sends a challenge and the prover sends an oracle (which the verifier can query). IOPs combine features of interactive proofs <em>[x1, x10]</em>and probabilistically checkable proofs <em>[Bab+91, x1, Aro+98]</em>. <em>Algebraic holographic proofs</em> (AHPs) modify the notion of an IOP in two ways.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Holographic:</em> the verifier does not receive its input explicitly but, rather, has oracle access to a prescribed <em>encoding</em> of it. This potentially enables the verifier to run in time that is much faster than the time to read its input in full. (Our constructions will achieve this fast verification.)</li>

      <li><em>Algebraic:</em> the honest prover must produce oracles that are low-degree polynomials (this restricts the completeness property), and all malicious provers must produce oracles that are low-degree polynomials (this relaxes the soundness property). The encoded input to the verifier must also be a low-degree polynomial.</li>

    </ul>

    <p class="text-gray-300">Since in this paper we only work with <em>univariate</em> polynomials, our definitions focus on this case, but they can be modified in a straightforward way to be more general.</p>

    <p class="text-gray-300">Informally, a (public-coin) AHP over a field <span class="math">\\mathbb{F}</span> for an indexed relation <span class="math">\\mathcal{R}</span> is specified by an indexer <span class="math">\\mathbf{I}</span>, prover <span class="math">\\mathbf{P}</span>, and verifier <span class="math">\\mathbf{V}</span> that work as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Offline phase.</em> The indexer <span class="math">\\mathbf{I}</span> receives as input the index <span class="math">\\dot{\\mathfrak{s}}</span> to be preprocessed, and outputs one or more univariate polynomials over <span class="math">\\mathbb{F}</span> encoding <span class="math">\\dot{\\mathfrak{s}}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <em>Online phase.</em> For some instance <span class="math">\\mathfrak{x}</span> and witness <span class="math">\\mathfrak{w}</span>, the prover <span class="math">\\mathbf{P}</span> receives <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w})</span> and the verifier <span class="math">\\mathbf{V}</span> receives <span class="math">\\mathfrak{x}</span>; <span class="math">\\mathbf{P}</span> and <span class="math">\\mathbf{V}</span> interact over some (in this paper, constant) number of rounds, where in each round <span class="math">\\mathbf{V}</span> sends a challenge and <span class="math">\\mathbf{P}</span> sends one or more polynomials; after the interaction, <span class="math">\\mathbf{V}(\\mathfrak{x})</span> probabilistically queries the polynomials output by the indexer and the polynomials output by the prover, and then accepts or rejects. Crucially, <span class="math">\\mathbf{V}</span> does <em>not</em> receive <span class="math">\\dot{\\mathfrak{s}}</span> as input, but instead queries the polynomials output by <span class="math">\\mathbf{I}</span> that encode <span class="math">\\dot{\\mathfrak{s}}</span>. This enables the construction of verifiers <span class="math">\\mathbf{V}</span> that run in time that is sublinear in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathfrak{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The completeness property states that for every <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w})\\in\\mathcal{R}</span> the probability that <span class="math">\\mathbf{P}(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w})</span> convinces <span class="math">\\mathbf{V}^{\\mathbf{I}(\\dot{\\mathfrak{s}})}(\\mathfrak{x})</span> to accept is <span class="math">1</span>. The soundness property states that for every <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x})\\notin\\mathcal{L}(\\mathcal{R})</span> and <em>admissible</em> prover <span class="math">\\bar{\\mathbf{P}}</span> the probability that <span class="math">\\bar{\\mathbf{P}}</span> convinces <span class="math">\\mathbf{V}^{\\mathbf{I}(\\dot{\\mathfrak{s}})}(\\mathfrak{x})</span> to accept is at most a given soundness error <span class="math">\\epsilon</span>. A prover is “admissible” if the degrees of the polynomials it outputs fit within prescribed degree bounds of the protocol. See Section 4 for details on AHPs, including definitions of proof of knowledge and zero knowledge.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Remark 2.1 (prior holographic proofs). Various definitions of “holographic proofs” have been studied in the literature on probabilistic proofs, starting with the seminal work of Babai, Fortnow, Levin, and Szegedy [Bab+91]. Recent examples include the IPs in [GKR15], whose verifier runs in sublinear time when given (multivariate low-degree) encodings of the circuit’s wiring predicates and of the circuit’s input; and also the IOPs in [RRR16], where encoded provers and encoded inputs play a role in amortizing interactive proofs.</p>

    <h2 id="sec-10" class="text-2xl font-bold">2.2 Building block: polynomial commitments</h2>

    <p class="text-gray-300">Informally, a polynomial commitment scheme [KZG10] allows a prover to produce a commitment <span class="math">c</span> to a univariate polynomial <span class="math">p \\in \\mathbb{F}[X]</span>, and later “open” <span class="math">p(X)</span> at any point <span class="math">z \\in \\mathbb{F}</span>, producing an evaluation proof <span class="math">\\pi</span> showing that the opened value is consistent with the polynomial “inside” <span class="math">c</span> at <span class="math">z</span>. Turning this informal goal into a useful definition requires some care, however, as we explain below. In this paper we propose a set of definitions for polynomial commitment schemes that we believe are useful for standalone use, and in particular suffice as a building block for our compiler described in Sections 2.3 and 8.</p>

    <p class="text-gray-300">First, we consider constructions with strong efficiency requirements: the commitment <span class="math">c</span> is much smaller than the polynomial <span class="math">p</span> (e.g., <span class="math">c</span> consists of a constant number of group elements), and the proof <span class="math">\\pi</span> can be validated very fast (e.g., in a constant number of cryptographic operations). These requirements not only rule out natural constructions, but also imply that the usual binding property, which states that an efficient adversary cannot open the same commitment to two different values, does not capture the desired security. Indeed, even if the adversary were to be bound to opening values of some function <span class="math">f\\colon \\mathbb{F} \\to \\mathbb{F}</span>, it may be that the function <span class="math">f</span> is consistent with a polynomial whose degree is higher than what was claimed. This means that a security definition needs to incorporate guarantees about the degree of the committed function. <span class="math">^{8}</span></p>

    <p class="text-gray-300">Second, in many applications of polynomial commitments, an adversary produces multiple commitments to polynomials within a round of interaction and across rounds of interaction. After this interaction, the adversary reveals values of all of these polynomials at one or more locations. This setting motivates a number of considerations. First, it is desirable to rely on a single set of public parameters for committing to multiple polynomials, even if the polynomials differ in degree. A construction such as that of [KZG10] can be modified in a natural way to achieve this by committing both to the polynomial and its shift to the maximum degree, similarly to techniques used to bundle multiple low-degree tests into a single one [Ben+19c]. This modification needs to be addressed in any proof of security. Second, it would be desirable to batch evaluation proofs across different polynomials for the same location. Again the construction in [KZG10] can support this, but one must argue that security still holds in this more general case.</p>

    <p class="text-gray-300">The preceding considerations require an extension of previous definitions and motivate our re-formulation of the primitive. Informally, a polynomial commitment scheme PC is a tuple of algorithms PC = (Setup, Trim, Commit, Open, Check). The setup algorithm PC.Setup takes as input a security parameter and maximum supported degree bound <span class="math">D</span>, and outputs public parameters pp that contain the description of a finite field <span class="math">\\mathbb{F}</span>. The “trimming” algorithm PC.Trim then deterministically specializes these parameters for a given set of degree bounds and outputs a committer key ck and a receiver key rk. The sender can then invoke</p>

    <p class="text-gray-300"><span class="math">^{7}</span>A natural construction would be to use a standard commitment scheme to commit to each coefficient of <span class="math">p</span>, and then open to a value by revealing the committed coefficients. However, this construction is inefficient, because the commitment <span class="math">c</span> and evaluation proof <span class="math">\\pi</span> are “long” (linear in the degree of <span class="math">p</span>). An alternative construction would be to use a Merkle tree on the coefficients of <span class="math">p</span>. While <span class="math">c</span> now becomes short, the evaluation proof <span class="math">\\pi</span> remains long because the receiver would need to see all coefficients to validate a claimed evaluation. Crucially, both constructions enable the receiver to check the degree of the committed polynomial.</p>

    <p class="text-gray-300"><span class="math">^{8}</span>This consideration motivates the strong correctness property in [KZG10], which states that if the adversary knows a polynomial that leads to the claimed commitment <span class="math">c</span> then this polynomial has bounded degree. This notion, while sufficient for the application in [KZG10], does not seem to suffice for standalone use because there is no a priori guarantee that an adversary that can open values to a commitment knows a polynomial inside the commitment. In some sense, a knowledge assumption is hidden in this hypothesis.</p>

    <p class="text-gray-300">11</p>

    <p class="text-gray-300">PC.Commit with input ck and a list of polynomials <span class="math">\\boldsymbol{p}</span> with respective degree bounds <span class="math">\\boldsymbol{d}</span> to generate a set of commitments <span class="math">\\boldsymbol{c}</span>. Subsequently, the sender can use PC.Open to produce a proof <span class="math">\\pi</span> that convinces the receiver that the polynomials “inside” <span class="math">\\boldsymbol{c}</span> respect the degree bounds <span class="math">\\boldsymbol{d}</span> and, moreover, evaluate to the claimed set of values <span class="math">\\boldsymbol{v}</span> at a given query set <span class="math">Q</span> that specifies any number of evaluation points for each polynomial. The receiver can invoke PC.Check to check this proof.</p>

    <p class="text-gray-300">The scheme PC is required to satisfy <em>extractability</em> and <em>efficiency</em> properties, and also, optionally, a <em>hiding</em> property. We outline these properties below (see Section 6.1 for the details).</p>

    <p class="text-gray-300">Extractability. Consider an efficient sender adversary <span class="math">\\mathcal{A}</span> that can produce a commitment <span class="math">c</span> and degree bound <span class="math">d\\leq D</span> such that, when asked for an evaluation at some point <span class="math">z\\in\\mathbb{F}</span>, can produce a supposed evaluation <span class="math">v</span> and proof <span class="math">\\pi</span> such that PC.Check accepts. Then PC is <em>extractable</em> if for every maximum degree bound <span class="math">D</span> and every sender adversary <span class="math">\\mathcal{A}</span> who can produce such commitments, there exists a corresponding efficient extractor <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> that outputs a polynomial <span class="math">p</span> of degree at most <span class="math">d</span> that “explains” <span class="math">c</span> so that <span class="math">p(z)=v</span>. While for simplicity we have described the most basic case here, our definition considers adversaries and extractors who interact over multiple rounds, wherein the adversary may produce multiple commitments in each round and the extractor is required to output corresponding polynomials on a per-round basis (before seeing the query set, proof, or supposed evaluations).</p>

    <p class="text-gray-300">In this work we rely on extractability to prove the security of our compiler (see Section 2.3); we do not know if weaker security notions studied in prior works, such as evaluation binding, suffice. More generally, we believe that extractability is a useful property that may be required across a range of other applications.</p>

    <p class="text-gray-300">Efficiency. We require two notions of efficiency for PC. First, the time required to commit to a polynomial <span class="math">p</span> and then to create an evaluation proof must be proportional to the degree of <span class="math">p</span>, and not to the maximum degree <span class="math">D</span>. (This ensures that the argument prover runs in time proportional to the size of the index.)</p>

    <p class="text-gray-300">On the receiver’s side, the commitment size, proof size, and time to verify an opening must be independent of the claimed degrees for the polynomials. (This ensures that the argument produced by our compiler is succinct.)</p>

    <p class="text-gray-300">Hiding. The hiding property of PC states that commitments and proofs of evaluation reveal no information about the committed polynomial beyond the publicly stated degree bound and the evaluation itself. Namely, PC is <em>hiding</em> if there exists an efficient simulator that outputs simulated commitments and simulated evaluation proofs that cannot be distinguished from their real counterparts by any malicious distinguisher that only knows the degree bound and the evaluation.</p>

    <p class="text-gray-300">Analogously to the case of extractability, we actually consider a more general definition that considers commitments to multiple polynomials within and across multiple rounds; moreover, the definition considers the case where some polynomials are designated as not hidden (and thus given to the simulator) because in our application we sometimes prefer to commit to a polynomial in a non-hiding way (for efficiency reasons).</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.3 Compiler: from AHPs to preprocessing arguments with universal SRS</h3>

    <p class="text-gray-300">We describe the main ideas behind Theorem 1, which uses polynomial commitment schemes to compile any (public-coin) AHP into a corresponding (public-coin) preprocessing argument with universal SRS. In a subsequent step, the argument can be made non-interactive via the Fiat–Shamir transformation, and thereby obtain a preprocessing SNARG with universal SRS.</p>

    <p class="text-gray-300">The basic intuition of the compiler follows the well-known framework of “commit to oracles and then open query answers” pioneered by Kilian <em>[x10]</em>. However, the commitment scheme used in our compiler leverages and enforces the algebraic structure of these oracles. While several works in the literature already</p>

    <p class="text-gray-300">take advantage of algebraic commitment schemes applied to algebraic oracles, our contribution is to observe that if we apply this framework to a holographic proof then we obtain a preprocessing argument.</p>

    <p class="text-gray-300">Informally, first the argument indexer invokes the AHP indexer to generate polynomials, and then deterministically commits to these using the polynomial commitment scheme. Subsequently, the argument prover and argument verifier interact, each respectively simulating the AHP prover and AHP verifier. In each round, the argument prover sends succinct commitments to the polynomials output by the AHP prover in that round. After the interaction, the argument verifier declares its queries to the polynomials (of the prover and of the indexer). The argument prover replies with the desired evaluations along with an evaluation proof attesting to their correctness relative to the commitments.</p>

    <p class="text-gray-300">This approach, while intuitive, must be proven secure. In particular, in the proof of soundness, we need to show that if the argument prover convinces the argument verifier with a certain probability, then we can find an AHP prover that convinces the AHP verifier with similar probability. This step is non-trivial: the AHP prover outputs polynomials, while the argument prover merely outputs succinct commitments and a few evaluations, which is much less information. In order to deduce the former from the latter requires <em>extraction</em>. This motivates considering polynomial commitment schemes that are extractable, in the sense described in Section 2.2. We do not know whether weaker security properties, such as the evaluation binding property studied in some prior works, suffice for proving the compiler secure.</p>

    <p class="text-gray-300">The compiler outlined above is compatible with the properties of argument of knowledge and zero knowledge. Specifically, we prove that if the AHP is a proof of knowledge, then the compiler produces an argument of knowledge; also, if the AHP is (bounded-query) zero knowledge and the polynomial commitment scheme is hiding, then the compiler produces a zero knowledge argument.</p>

    <p class="text-gray-300">See Section 8 for more details on the compiler.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.4 Construction: an AHP for constraint systems</h3>

    <p class="text-gray-300">In prior sections we have described how we can use polynomial commitment schemes to compile AHPs into corresponding preprocessing SNARGs. In this section we discuss the main ideas behind Theorem 2, which provides an efficient AHP for the indexed relation corresponding to R1CS (see Definition 1). The preprocessing zkSNARK that we achieve in this paper (see Fig. 1) is based on this AHP.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our protocol can be viewed as a “holographic variant” of the <em>non</em>-holographic algebraic proof for R1CS constructed in <em>[x1]</em>. Achieving holography involves designing a new sub-protocol that enables the verifier to evaluate low-degree extensions of the coefficient matrices at a random location. While in <em>[x1]</em> the verifier performed this computation in time $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbbm{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> on its own, in our protocol the verifier performs it <em>exponentially faster</em>, in time </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbbm{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, by receiving help from the prover and having oracle access to the polynomials produced by the indexer. We introduce notation and then discuss the protocol.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Some notation. Consider an index <span class="math">\\mathbbm{i}=(\\mathbb{F},n,m,A,B,C)</span> specifying coefficient matrices, an instance <span class="math">\\mathbbm{x}=x\\in\\mathbb{F}^{<em>}</span> specifying a partial assignment to the variables, and a witness <span class="math">\\mathbb{w}=w\\in\\mathbb{F}^{</em>}</span> specifying an assignment to the other variables such that the R1CS equation holds. The R1CS equation holds if and only if <span class="math">Az\\circ Bz=Cz</span> for <span class="math">z:=(x,w)\\in\\mathbb{F}^{n}</span>. Below, we let <span class="math">H</span> and <span class="math">K</span> be prescribed subsets of <span class="math">\\mathbb{F}</span> of sizes <span class="math">n</span> and <span class="math">m</span> respectively; we also let <span class="math">v_{H}(X)</span> and <span class="math">v_{K}(X)</span> be the vanishing polynomials of these two sets. (The vanishing polynomial of a set <span class="math">S</span> is the monic polynomial of degree $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> that vanishes on </span>S<span class="math">, i.e., </span>\\prod_{\\gamma\\in S}(X-\\gamma)<span class="math">.) We assume that both </span>H<span class="math"> and </span>K<span class="math"> are smooth multiplicative subgroups. This allows interpolation/evaluation over </span>H<span class="math"> in </span>O(n\\log n)<span class="math"> operations and also makes </span>v_{H}(X)<span class="math"> computable in </span>O(\\log n)<span class="math"> operations (and similarly for </span>K<span class="math">). Given an </span>n\\times n<span class="math"> matrix </span>M<span class="math"> with rows/columns indexed by elements of </span>H<span class="math">, we denote by </span>\\hat{M}(X,Y)<span class="math"> the low-degree extension of </span>M<span class="math">, i.e., the polynomial of individual degree less than </span>n<span class="math"> such that </span>\\hat{M}(\\kappa,\\iota)$ is the</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">(\\kappa, \\iota)</span>-th entry of <span class="math">M</span> for every <span class="math">\\kappa, \\iota \\in H</span>.</p>

    <p class="text-gray-300">A non-holographic starting point. We sketch a non-holographic protocol for R1CS with linear proof length and constant query complexity, inspired from [Ben+19c], that forms the starting point of our work. In this case the prover receives as input <span class="math">(\\dot{\\mathfrak{s}}, \\mathbb{R}, \\mathbb{W})</span> and the verifier receives as input <span class="math">(\\check{\\mathfrak{s}}, \\mathbb{R})</span>. (The verifier reads the non-encoded index <span class="math">\\check{\\mathfrak{s}}</span> because we are describing a non-holographic protocol.)</p>

    <p class="text-gray-300">In the first message the prover <span class="math">\\mathbf{P}</span> sends the univariate polynomial <span class="math">\\hat{z}(X)</span> of degree less than <span class="math">n</span> that agrees with the variable assignment <span class="math">z</span> on <span class="math">H</span>, and also sends the univariate polynomials <span class="math">\\hat{z}_A(X), \\hat{z}_B(X), \\hat{z}_C(X)</span> of degree less than <span class="math">n</span> that agree with the linear combinations <span class="math">z_A := Az</span>, <span class="math">z_B := Bz</span>, and <span class="math">z_C := Cz</span> on <span class="math">H</span>. The prover is left to convince the verifier that the following two conditions hold:</p>

    <p class="text-gray-300">(1) Entry-wise product: <span class="math">\\forall \\kappa \\in H, \\hat{z}_A(\\kappa)\\hat{z}_B(\\kappa) - \\hat{z}_C(\\kappa) = 0</span>. (2) Linear relation: <span class="math">\\forall M \\in \\{A, B, C\\}, \\forall \\kappa \\in H, \\hat{z}_M(\\kappa) = \\sum_{\\iota \\in H} M[\\kappa, \\iota] \\hat{z}(\\iota)</span>.</p>

    <p class="text-gray-300">(The prover also needs to convince the verifier that <span class="math">\\hat{z}(X)</span> encodes a full assignment <span class="math">z</span> that is consistent with the partial assignment <span class="math">x</span>, but we for simplicity we ignore this in this informal discussion.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In order to convince the verifier of the first (entry-wise product) condition, the prover sends the polynomial <span class="math">h_0(X)</span> such that <span class="math">\\hat{z}_A(X)\\hat{z}_B(X) - \\hat{z}_C(X) = h_0(X)v_H(X)</span>. This polynomial equation is equivalent to the first condition (the left-hand side equals zero everywhere on <span class="math">H</span> if and only if it is a multiple of <span class="math">H</span>'s vanishing polynomial). The verifier will check the equation at a random point <span class="math">\\beta \\in \\mathbb{F}</span>: it queries <span class="math">\\hat{z}_A(X), \\hat{z}_B(X), \\hat{z}_C(X), h_0(X)</span> at <span class="math">\\beta</span>, evaluates <span class="math">v_H(X)</span> at <span class="math">\\beta</span> on its own, and checks that <span class="math">\\hat{z}_A(\\beta)\\hat{z}_B(\\beta) - \\hat{z}_C(\\beta) = h_0(\\beta)v_H(\\beta)</span>. The soundness error is the maximum degree over the field size, which is at most $2n /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In order to convince the verifier of the second (linear relation) condition, the prover expects a random challenge <span class="math">\\alpha \\in \\mathbb{F}</span> from the verifier, and then replies in a second message. For each <span class="math">M \\in \\{A, B, C\\}</span>, the prover sends polynomials <span class="math">h_M(X)</span> and <span class="math">g_M(X)</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">r(\\alpha, X) \\hat{z}_M(X) - r_M(\\alpha, X) \\hat{z}(X) = h_M(X) v_H(X) + X g_M(X) \\quad \\text{for} \\quad r_M(Z, X) := \\sum_{\\kappa \\in H} r(Z, \\kappa) \\hat{M}(\\kappa, X)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">r(Z, X)</span> is a prescribed polynomial of individual degree less than <span class="math">n</span> such that <span class="math">(r(Z, \\kappa))_{\\kappa \\in H}</span> are <span class="math">n</span> linearly independent polynomials. Prior work [Ben+19c] on checking linear relations via univariate sumchecks shows that this polynomial equation is equivalent, up to a soundness error of $n /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over </span>\\alpha<span class="math">, to the second condition. The verifier will check this polynomial equation at the random point </span>\\beta \\in \\mathbb{F}<span class="math">: it queries </span>\\hat{z}(X), \\hat{z}_A(X), \\hat{z}_B(X), \\hat{z}_C(X), h_M(X), g_M(X)<span class="math"> at </span>\\beta<span class="math">, evaluates </span>v_H(X)<span class="math"> at </span>\\beta<span class="math"> on its own, evaluates </span>r(Z, X)<span class="math"> and </span>r_M(Z, X)<span class="math"> at </span>(\\alpha, \\beta)<span class="math"> on its own, and checks that </span>r(\\alpha, \\beta) \\hat{z}_M(\\beta) - r_M(\\alpha, \\beta) \\hat{z}(\\beta) = h_M(\\beta) v_H(\\beta) + \\beta g_M(\\beta)<span class="math">. The additional soundness error is </span>2n /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The above is a simple 3-message protocol for R1CS with soundness error $\\max \\{2n /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, 3n /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\} = 3n /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> in the setting where the honest prover and malicious provers send polynomials of prescribed degrees, which the verifier can query at any location. The proof length (sum of all degrees) is linear in </span>n$ and the query complexity is constant.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Barrier to holography. The verifier in the above protocol runs in time that is $\\Omega(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = \\Omega(n + m)<span class="math">. While this is inherent in the non-holographic setting (because the verifier must read </span>\\mathfrak{i}<span class="math">), we now discuss how exactly the verifier&#x27;s computation depends on </span>\\mathfrak{i}<span class="math">. We shall later use this understanding to achieve an exponential improvement in the verifier&#x27;s time when given a suitable encoding of </span>\\mathfrak{i}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9In particular, we are using the fact from [Ben+19c] that, given a multiplicative subgroup <span class="math">S</span> of <span class="math">\\mathbb{F}</span>, a polynomial <span class="math">f(X)</span> sums to <span class="math">\\sigma</span> over <span class="math">S</span> if and only if <span class="math">f(X)</span> can be written as $h(X)v_{S}(X) + Xg(X) + \\sigma /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for some </span>h(X)<span class="math"> and </span>g(X)<span class="math"> with </span>\\deg (g) &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">14</p>

    <p class="text-gray-300">The verifier’s check for the entry-wise product is <span class="math">\\hat{z}_{A}(\\beta)\\hat{z}_{B}(\\beta)-\\hat{z}_{C}(\\beta)=h_{0}(\\beta)v_{H}(\\beta)</span>, and can be carried out in <span class="math">O(\\log n)</span> operations <em>regardless</em> of the coefficient matrices contained in the index <span class="math">\\mathbbm{i}</span>. In other words, this check is efficient even in the non-holographic setting. However, the verifier’s check for the linear relation is <span class="math">r(\\alpha,\\beta)\\hat{z}_{M}(\\beta)-r_{M}(\\alpha,\\beta)\\hat{z}(\\beta)=h_{M}(\\beta)v_{H}(\\beta)+\\beta g_{M}(\\beta)</span>, which has a linear cost. Concretely, evaluating the polynomial <span class="math">r_{M}(Z,X)</span> at <span class="math">(\\alpha,\\beta)</span> requires <span class="math">\\Omega(n+m)</span> operations.</p>

    <p class="text-gray-300">In the holographic setting, a natural idea to reduce this cost would be to grant the verifier oracle access to the low-degree extension <span class="math">\\hat{M}</span> for <span class="math">M\\in\\{A,B,C\\}</span>. This idea has two problems: the verifier <em>still</em> needs <span class="math">\\Omega(n)</span> operations to evaluate <span class="math">r_{M}(Z,X)</span> at <span class="math">(\\alpha,\\beta)</span> and, moreover, the size of <span class="math">\\hat{M}</span> is <em>quadratic</em> in <span class="math">n</span>, which means that the encoding of the index <span class="math">\\mathbbm{i}</span> is <span class="math">\\Omega(n^{2})</span>. We cannot afford such an expensive encoding in the offline preprocessing phase. We now describe how we overcome both of these problems, and obtain a holographic protocol.</p>

    <p class="text-gray-300">Achieving holography. To overcome the above problems and obtain a holographic protocol, we rely yet again on the univariate sumcheck protocol. We introduce two additional rounds of interaction, and in each round the verifier learns that their verification equation holds provided the sumcheck from the next round holds. The last sumcheck will rely on polynomials output by the indexer, which the verifier knows are correct.</p>

    <p class="text-gray-300">We address the first problem by letting the prover and verifier interact in an additional round, where we rely on an additional univariate sumcheck to reduce the problem of evaluating <span class="math">r_{M}(Z,X)</span> at <span class="math">(\\alpha,\\beta)</span> to the problem of evaluating <span class="math">\\hat{M}</span> at <span class="math">(\\beta_{2},\\beta)</span> for a random <span class="math">\\beta_{2}\\in\\mathbb{F}</span>. Namely, the verifier sends <span class="math">\\beta</span> to the prover, who computes</p>

    <p class="text-gray-300"><span class="math">\\sigma_{2}:=r_{M}(\\alpha,\\beta)=\\sum_{\\kappa\\in H}r(\\alpha,\\kappa)\\hat{M}(\\kappa,\\beta).</span></p>

    <p class="text-gray-300">Then the prover replies with <span class="math">\\sigma_{2}</span> and the polynomials <span class="math">h_{2}(X)</span> and <span class="math">g_{2}(X)</span> such that</p>

    <p class="text-gray-300"><span class="math">r(\\alpha,X)\\hat{M}(X,\\beta)=h_{2}(X)v_{H}(X)+Xg_{2}(X)+\\sigma_{2}/n\\enspace.</span></p>

    <p class="text-gray-300">Prior techniques on univariate sumcheck <em>[x1, x10]</em> tell us that this equation is equivalent to the polynomial <span class="math">r(\\alpha,X)\\hat{M}(X,\\beta)</span> summing to <span class="math">\\sigma_{2}</span> on <span class="math">H</span>. Thus the verifier needs to check this equation at a random <span class="math">\\beta_{2}\\in\\mathbb{F}</span>: <span class="math">r(\\alpha,\\beta_{2})\\hat{M}(\\beta_{2},\\beta)=h_{2}(\\beta_{2})v_{H}(\\beta_{2})+\\beta_{2}g_{2}(\\beta_{2})+\\sigma_{2}/n</span>. The only expensive part of this equation for the verifier is computing the value <span class="math">\\hat{M}(\\beta_{2},\\beta)</span>, which is problematic. Indeed, we have already noted that we cannot afford to simply let the verifier have oracle access to <span class="math">\\hat{M}</span>, because this polynomial has quadratic size (it contains a quadratic number of terms).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We address this second problem as follows. Let <span class="math">u_{H}(X,Y):=\\frac{v_{H}(X)-v_{H}(Y)}{X-Y}</span> be the formal derivative of the vanishing poynomial <span class="math">v_{H}(X)</span>, and note that <span class="math">u_{H}(X,Y)</span> vanishes on the square <span class="math">H\\times H</span> except for on the diagonal, where it takes on the (non-zero) values <span class="math">(u_{H}(a,a))_{a\\in H}</span>. Moreover, <span class="math">u_{H}(X,Y)</span> can be evaluated at any point in <span class="math">\\mathbb{F}\\times\\mathbb{F}</span> in <span class="math">O(\\log n)</span> operations. Using this polynomial, we can write <span class="math">\\hat{M}</span> as a sum of $m=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> terms instead of </span>n^{2}=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}$ terms:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\hat{M}(X,Y):=\\sum_{\\kappa\\in K}u_{H}(X,\\mathsf{row}_{M}(\\kappa))\\cdot u_{H}(Y,\\mathsf{col}_{M}(\\kappa))\\cdot\\mathsf{val}_{M}(\\kappa)\\enspace,</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{row}_{M},\\mathsf{col}_{M},\\mathsf{val}_{M}</span> are the low-degree extensions of the row, column, and value of the non-zero entries in <span class="math">M</span> according to some canonical order over <span class="math">K</span>.</p>

    <p class="text-gray-300">This method of representing the low-degree extension of <span class="math">M</span> suggests an idea: let the verifier have oracle access to the polynomials <span class="math">\\mathsf{row}_{M},\\mathsf{col}_{M},\\mathsf{val}_{M}</span> and do <em>yet another</em> univariate sumcheck, but this time over the set <span class="math">K</span>. The verifier sends <span class="math">\\beta_{2}</span> to the prover, who computes</p>

    <p class="text-gray-300"><span class="math">\\sigma_{3}:=\\hat{M}(\\beta_{2},\\beta)=\\sum_{\\kappa\\in K}u_{H}(\\beta_{2},\\mathsf{row}_{M}(\\kappa))\\cdot u_{H}(\\beta,\\mathsf{col}_{M}(\\kappa))\\cdot\\mathsf{val}_{M}(\\kappa)\\enspace.</span></p>

    <p class="text-gray-300">Then the prover replies with <span class="math">\\sigma_{3}</span> and the polynomials <span class="math">h_{3}(X)</span> and <span class="math">g_{3}(X)</span> such that</p>

    <p class="text-gray-300"><span class="math">u_{H}(\\beta_{2},\\mathsf{row}_{M}(X))u_{H}(\\beta,\\mathsf{col}_{M}(X))\\mathsf{val}_{M}(X)=h_{3}(X)v_{K}(X)+Xg_{3}(X)+\\sigma_{3}/m\\enspace.</span></p>

    <p class="text-gray-300">The verifier can then check this equation at a random <span class="math">\\beta_{3}\\in\\mathbb{F}</span>, which only requires <span class="math">O(\\log m)</span> operations.</p>

    <p class="text-gray-300">The above idea almost works; the one remaining problem is that <span class="math">h_{3}(X)</span> has degree <span class="math">\\Omega(nm)</span> (because the left-hand size of the equation has quadratic degree), which is too expensive for our target of a quasilinear-time prover. We overcome this problem by letting the prover run the univariate sumcheck protocol on the unique low-degree extension <span class="math">\\hat{f}(X)</span> of the function <span class="math">f\\colon K\\to\\mathbb{F}</span> defined as <span class="math">f(\\kappa):=u_{H}(\\beta_{2},\\mathsf{row}_{M}(\\kappa))u_{H}(\\beta,\\mathsf{col}_{M}(\\kappa))\\mathsf{val}_{M}(\\kappa)</span>. Observe that <span class="math">\\hat{f}(X)</span> has degree less than <span class="math">m</span>. The verifier checks that <span class="math">\\hat{f}(X)</span> and <span class="math">u_{H}(\\beta_{2},\\mathsf{row}_{M}(X))u_{H}(\\beta,\\mathsf{col}_{M}(X))\\mathsf{val}_{M}(X)</span> agree on <span class="math">K</span>.</p>

    <p class="text-gray-300">From sketch to protocol. In the above discussion we have ignored a number of technical aspects, such as proof of knowledge and zero knowledge (which are ultimately needed in the compiler if we want to construct a preprocessing zkSNARK). We have also not discussed time complexities of many algebraic steps, and we omitted discussion of how to batch multiple sumchecks into fewer ones, which brings important savings in argument size. For details, see our detailed construction in Section 5.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">2.5 Construction: extractable polynomial commitments</h3>

    <p class="text-gray-300">We now sketch how to construct a polynomial commitment scheme that achieves the strong functionality and security requirements of our definition in Section 2.2. Our starting point is the <span class="math">\\mathsf{PolyCommit}_{\\mathsf{DL}}</span> construction of Kate et al. <em>[x14]</em>, and then describe a sequence of natural and generic transformations that extend this construction to enable extractability, commitments to multiple polynomials, and the enforcement of per-polynomial degree bounds. In fact, once we arrive at a scheme that supports extractability for committed polynomials at a single point (Appendix B), our transformations build on this construction in a black box way to first support per-polynomial degree bounds (Appendix C), and then query sets that may request multiple evaluation points per polynomial (Appendix D). Indeed, it is sufficient to produce a polynomial commitment scheme that satisfies the much more simple interface and definitions in Appendix B.1, and apply these black box transformations to obtain a polynomial commitment scheme that satisfies the interface of and provides the properties described in Section 6.1 ultimately needed by our compiler.</p>

    <p class="text-gray-300">Starting point: <span class="math">\\mathsf{PolyCommit}_{\\mathsf{DL}}</span>. The setup phase samples a cryptographically secure bilinear group <span class="math">(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},q,G,H,e)</span> and then samples a committer key <span class="math">\\mathsf{ck}</span> and receiver key <span class="math">\\mathsf{rk}</span> for a given degree bound <span class="math">D</span>. The committer key consists of group elements encoding powers of a random field element <span class="math">\\beta</span>, namely, <span class="math">\\mathsf{ck}:=\\{G,\\beta G,\\ldots,\\beta^{D}G\\}\\in\\mathbb{G}_{1}^{D+1}</span>. The receiver key consists of the group elements <span class="math">\\mathsf{rk}:=(G,H,\\beta H)\\in\\mathbb{G}_{1}\\times\\mathbb{G}_{2}^{2}</span>. Note that the SRS, which consists of the keys <span class="math">\\mathsf{ck}</span> and <span class="math">\\mathsf{rk}</span>, is updatable because the coefficients of group elements in the SRS are all monomials (see Remark 7.1).</p>

    <p class="text-gray-300">To commit to a polynomial <span class="math">p\\in\\mathbb{F}_{q}[X]</span>, the sender computes <span class="math">c:=p(\\beta)G</span>. To subsequently prove that the committed polynomial evaluates to <span class="math">v</span> at a point <span class="math">z</span>, the sender computes a witness polynomial <span class="math">w(X):=(p(X)-p(z))/(X-z)</span>, and provides as proof a commitment to <span class="math">w</span>: <span class="math">\\pi:=w(\\beta)G</span>. The idea is that the witness function <span class="math">w</span> is a polynomial if and only if <span class="math">p(z)=v</span>; otherwise, it is a rational function, and cannot be committed to using <span class="math">\\mathsf{ck}</span>.</p>

    <p class="text-gray-300">Finally, to verify a proof of evaluation, the receiver checks that the commitment and proof of evaluation are consistent. That is, it checks that the proof commits to a polynomial of the form <span class="math">(p(X)-p(z))/(X-z)</span> by checking the equality <span class="math">e(c-vG,H)=e(\\pi,\\beta H-zH)</span>.</p>

    <p class="text-gray-300">Achieving extractability. While the foregoing construction guarantees correctness of evaluations, it does not by itself guarantee that a commitment actually “contains” a suitable polynomial of degree at most <span class="math">D</span>. We</p>

    <p class="text-gray-300">study two methods to address this issue, and thereby achieve extractability. One method is to modify the construction to use knowledge commitments <em>[x10]</em>, and rely on a concrete knowledge assumption. The main disadvantage of this approach is that each commitment doubles in size. The other method is to move away from the plain model, and instead conduct the security analysis in the algebraic group model (AGM) <em>[x11]</em>. This latter method is more efficient because each commitment remains a single group element.</p>

    <p class="text-gray-300">Committing to multiple polynomials at once. We enable the sender to simultaneously open multiple polynomials <span class="math">[p_{i}]_{i=1}^{n}</span> at the same point <span class="math">z</span> as follows. Before generating a proof of evaluation for <span class="math">[p_{i}]_{i=1}^{n}</span>, the sender requests from the receiver a random field element <span class="math">\\xi</span>, which he uses to take a random linear combination of the polynomials: <span class="math">p:=\\sum_{i=1}^{n}\\xi^{i}p_{i}</span>, and generates a proof of evaluation <span class="math">\\pi</span> for this polynomial <span class="math">p</span>.</p>

    <p class="text-gray-300">The receiver verifies <span class="math">\\pi</span> by using the fact that the commitments are additively homomorphic. The receiver takes a linear combination of the commitments and claimed evaluations, obtaining the combined commitment <span class="math">c=\\sum_{i=1}^{n}\\xi^{i}c_{i}</span> and evaluation <span class="math">v=\\sum_{i=1}^{n}\\xi^{i}v_{i}</span>. Finally, it checks the pairing equations for <span class="math">c</span>, <span class="math">\\pi</span>, and <span class="math">v</span>.</p>

    <p class="text-gray-300">Completeness of this check is straightforward, while soundness follows from the fact that if any polynomial does not match its evaluation, then the combined polynomial will not match its evaluation with high probability.</p>

    <p class="text-gray-300">Enforcing multiple degree bounds. The construction so far enforces a single bound <span class="math">D</span> on the degrees of all the polynomials <span class="math">p_{i}</span>. To enforce a different degree bound <span class="math">d_{i}</span> for each <span class="math">p_{i}</span>, we require the sender to commit not only to each <span class="math">p_{i}</span>, but also to “shifted polynomials” <span class="math">p_{i}^{\\prime}(X):=X^{D-d_{i}}p_{i}(X)</span>. The proof of evaluation proves that, if <span class="math">p_{i}</span> evaluates to <span class="math">v_{i}</span> at <span class="math">z</span>, then <span class="math">p_{i}^{\\prime}</span> evaluates to <span class="math">z^{D-d_{i}}v_{i}</span>.</p>

    <p class="text-gray-300">The receiver checks that the commitment for each <span class="math">p_{i}^{\\prime}</span> corresponds to an evaluation <span class="math">z^{D-d_{i}}v_{i}</span> so that, if <span class="math">z</span> is sampled from a super-polynomial subset of <span class="math">\\mathbb{F}_{q}</span>, the probability that <span class="math">\\deg(p_{i})\\neq d_{i}</span> is negligible. This trick is similar to the one used in <em>[x5, x2]</em> to derive low-degree tests for specific degree bounds.</p>

    <p class="text-gray-300">However, while sound, this approach is inefficient in our setting: the witness polynomial for <span class="math">p_{i}^{\\prime}</span> has <span class="math">\\Omega(D)</span> non-zero coefficients (instead of <span class="math">O(d_{i})</span>), and so constructing an evaluation proof for it requires <span class="math">\\Omega(D)</span> scalar multiplications (instead of <span class="math">O(d_{i})</span>). To work around this, we instead produce a proof that the related polynomial <span class="math">p_{i}^{\\star}(X):=p_{i}^{\\prime}(X)-p_{i}(z)X^{D-d_{i}}</span> evaluates to <span class="math">0</span> at <span class="math">z</span>. As we show in Lemma C.2, the witness polynomial for this claim has <span class="math">O(d_{i})</span> non-zero coefficients, and so constructing the evaluation proof can be done in <span class="math">O(d_{i})</span> scalar multiplications. Completeness is preserved because the receiver can check the correct evaluation of <span class="math">p_{i}^{\\star}</span> by subtracting <span class="math">p_{i}(z)(\\beta^{D-d_{i}}\\mathbb{G})</span> from the commitment to the shifted polynomial <span class="math">p_{i}^{\\prime}</span>, thereby obtaining a commitment to <span class="math">p_{i}^{\\star}</span>, while security is preserved because <span class="math">p_{i}^{\\prime}(z)=z^{D-d_{i}}v_{i}\\iff p_{i}^{\\star}(z)=0</span>.</p>

    <p class="text-gray-300">Evaluating at a query set instead of a single point. To support the case where the polynomials <span class="math">[p_{i}]_{i=1}^{n}</span> are evaluated at a set of points <span class="math">Q</span>, the sender proceeds as follows. Say that there are <span class="math">k</span> different points <span class="math">[z_{i}]_{i=1}^{k}</span> in <span class="math">Q</span>. The sender partitions the polynomials <span class="math">[p_{i}]_{i=1}^{n}</span> into different groups such that every polynomial in a group is to be evaluated at the same point <span class="math">z_{i}</span>. The sender runs PC.Open on each group, and outputs the resulting list of evaluation proofs.</p>

    <p class="text-gray-300">Achieving hiding. To additionally achieve hiding, we follow the above blueprint, replacing <span class="math">\\mathsf{PolyCommit}_{\\mathsf{DL}}</span> with the hiding scheme <span class="math">\\mathsf{PolyCommit}_{\\mathsf{Ped}}</span> described in <em>[x16]</em>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">3 Preliminaries</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We denote by <span class="math">[n]</span> the set <span class="math">\\{1,\\ldots,n\\}\\subseteq\\mathbb{N}</span>. We use <span class="math">\\bm{a}=[a_{i}]_{i=1}^{n}</span> as a short-hand for the tuple <span class="math">(a_{1},\\ldots,a_{n})</span>, and <span class="math">[\\bm{a}_{i}]_{i=1}^{n}=[[a_{i,j}]_{j=1}^{m}]_{i=1}^{n}</span> as a short-hand for the tuple <span class="math">(a_{1,1},\\ldots,a_{1,m},\\ldots,a_{n,1},\\ldots,a_{n,m})</span>; $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{a}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the number of entries in </span>\\bm{a}<span class="math">. If </span>x<span class="math"> is a binary string then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes its bit length. If </span>M<span class="math"> is a matrix then </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the number of nonzero entries in </span>M<span class="math">. If </span>S<span class="math"> is a finite set then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes its cardinality and </span>x\\leftarrow S<span class="math"> denotes that </span>x<span class="math"> is an element sampled at random from </span>S<span class="math">. We denote by </span>\\mathbb{F}<span class="math"> a finite field, and whenever </span>\\mathbb{F}<span class="math"> is an input to an algorithm we implicitly assume that </span>\\mathbb{F}<span class="math"> is represented in a way that allows efficient field arithmetic. Given a finite set </span>S<span class="math">, we denote by </span>\\mathbb{F}^{S}<span class="math"> the set of vectors indexed by elements in </span>S<span class="math">. We denote by </span>\\mathbb{F}[X]<span class="math"> the ring of univariate polynomials over </span>\\mathbb{F}<span class="math"> in </span>X<span class="math">, and by </span>\\mathbb{F}^{<d}[X]<span class="math"> the set of polynomials in </span>\\mathbb{F}[X]<span class="math"> with degree less than </span>d$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We denote by <span class="math">\\lambda\\in\\mathbb{N}</span> a security parameter. When we state that <span class="math">n\\in\\mathbb{N}</span> for some variable <span class="math">n</span>, we implicitly assume that <span class="math">n=\\mathrm{poly}(\\lambda)</span>. We denote by <span class="math">\\mathrm{negl}(\\lambda)</span> an unspecified function that is negligible in <span class="math">\\lambda</span> (namely, a function that vanishes faster than the inverse of any polynomial in <span class="math">\\lambda</span>). When a function can be expressed in the form <span class="math">1-\\mathrm{negl}(\\lambda)</span>, we say that it is overwhelming in <span class="math">\\lambda</span>. When we say that <span class="math">\\mathcal{A}</span> is an efficient adversary we mean that <span class="math">\\mathcal{A}</span> is a family <span class="math">\\{\\mathcal{A}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> of non-uniform polynomial-size circuits. If the adversary consists of multiple circuit families <span class="math">\\mathcal{A}_{1},\\mathcal{A}_{2},\\ldots</span> then we write <span class="math">\\mathcal{A}=(\\mathcal{A}_{1},\\mathcal{A}_{2},\\ldots)</span>.</p>

    <p class="text-gray-300">Given two interactive algorithms <span class="math">A</span> and <span class="math">B</span>, we denote by <span class="math">\\langle A(x),B(y)\\rangle(z)</span> the output of <span class="math">B(y,z)</span> when interacting with <span class="math">A(x,z)</span>. Note that this output could be a random variable. If we use this notation when <span class="math">A</span> or <span class="math">B</span> is a circuit, we mean that we are considering a circuit that implements a suitable next-message function to interact with the other party of the interaction.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.1 Indexed relations</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An indexed relation <span class="math">\\mathcal{R}</span> is a set of triples <span class="math">(\\mathfrak{i},\\mathfrak{x},\\mathfrak{w})</span> where <span class="math">\\mathfrak{i}</span> is the index, <span class="math">\\mathfrak{x}</span> is the instance, and <span class="math">\\mathfrak{w}</span> is the witness; the corresponding indexed language <span class="math">\\mathcal{L}(\\mathcal{R})</span> is the set of pairs <span class="math">(\\mathfrak{i},\\mathfrak{x})</span> for which there exists a witness <span class="math">\\mathfrak{w}</span> such that <span class="math">(\\mathfrak{i},\\mathfrak{x},\\mathfrak{w})\\in\\mathcal{R}</span>. For example, the indexed relation of satisfiable boolean circuits consists of triples where <span class="math">\\mathfrak{i}</span> is the description of a boolean circuit, <span class="math">\\mathfrak{x}</span> is a partial assignment to its input wires, and <span class="math">\\mathfrak{w}</span> is an assignment to the remaining wires that makes the circuit to output 0. Given a size bound <span class="math">\\mathsf{N}\\in\\mathbb{N}</span>, we denote by <span class="math">\\mathcal{R}_{\\mathsf{N}}</span> the restriction of <span class="math">\\mathcal{R}</span> to triples <span class="math">(\\mathfrak{i},\\mathfrak{x},\\mathfrak{w})</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathsf{N}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">4 Algebraic holographic proofs</p>

    <p class="text-gray-300">We define <em>algebraic holographic proofs</em> (AHPs), the notion of proofs that we use. For simplicity, the formal definition below is tailored to univariate polynomials, because our AHP construction is in this setting. The definition can be modified in a straightforward way to consider the general case of multivariate polynomials.</p>

    <p class="text-gray-300">We represent polynomials through the coefficients that define them, as opposed to through their evaluation over a sufficiently large domain (as is typically the case in probabilistic proofs). This definitional choice is due to the fact that we will consider verifiers that may query the polynomials at any location in the field of definition. Moreover, the field of definition itself can be chosen from a given field family, and so we make the field an additional input to all algorithms; this degree of freedom is necessary when combining this component with polynomial commitment schemes (see Section 8). Finally, we consider the setting of <em>indexed relations</em> (see Section 3.1), where the verifier’s input has two parts, the index and the instance; in the definition below, the verifier receives the index encoded and the instance explicitly.</p>

    <p class="text-gray-300">Formally, an algebraic holographic proof (AHP) over a field family <span class="math">\\mathcal{F}</span> for an indexed relation <span class="math">\\mathcal{R}</span> is specified by a tuple</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AHP}=(\\mathsf{k},\\mathsf{s},\\mathsf{d},\\mathbf{I},\\mathbf{P},\\mathbf{V})</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{k},\\mathsf{s},\\mathsf{d}\\colon\\{0,1\\}^{<em>}\\to\\mathbb{N}</span> are polynomial-time computable functions and <span class="math">\\mathbf{I},\\mathbf{P},\\mathbf{V}</span> are three algorithms known as the </em>indexer<em>, </em>prover<em>, and </em>verifier*. The parameter <span class="math">\\mathsf{k}</span> specifies the number of interaction rounds, <span class="math">\\mathsf{s}</span> specifies the number of polynomials in each round, and <span class="math">\\mathsf{d}</span> specifies degree bounds on these polynomials.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the offline phase (“0-th round”), the indexer <span class="math">\\mathbf{I}</span> receives as input a field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span> and an index <span class="math">\\dot{\\mathsf{s}}</span> for <span class="math">\\mathcal{R}</span>, and outputs <span class="math">\\mathsf{s}(0)</span> polynomials <span class="math">p_{0,1},\\ldots,p_{0,\\mathsf{s}(0)}\\in\\mathbb{F}[X]</span> of degrees at most $\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathsf{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,0,1),\\ldots,\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathsf{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,0,\\mathsf{s}(0))<span class="math"> respectively. Note that the offline phase does not depend on any particular instance or witness, and merely considers the task of encoding the given index </span>\\dot{\\mathsf{s}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the online phase, given an instance <span class="math">\\mathbbm{x}</span> and witness <span class="math">\\mathbb{w}</span> such that <span class="math">(\\dot{\\mathsf{s}},\\mathbbm{x},\\mathbb{w})\\in\\mathcal{R}</span>, the prover <span class="math">\\mathbf{P}</span> receives <span class="math">(\\mathbb{F},\\dot{\\mathsf{s}},\\mathbbm{x},\\mathbb{w})</span> and the verifier <span class="math">\\mathbf{V}</span> receives <span class="math">(\\mathbb{F},\\mathbbm{x})</span> and oracle access to the polynomials output by <span class="math">\\mathbf{I}(\\mathbb{F},\\dot{\\mathsf{s}})</span>. The prover <span class="math">\\mathbf{P}</span> and the verifier <span class="math">\\mathbf{V}</span> interact over $\\mathsf{k}=\\mathsf{k}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathsf{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ rounds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For <span class="math">i\\in[\\mathsf{k}]</span>, in the <span class="math">i</span>-th round of interaction, the verifier <span class="math">\\mathbf{V}</span> sends a message <span class="math">\\rho_{i}\\in\\mathbb{F}^{*}</span> to the prover <span class="math">\\mathbf{P}</span>; then the prover <span class="math">\\mathbf{P}</span> replies with <span class="math">\\mathsf{s}(i)</span> oracle polynomials <span class="math">p_{i,1},\\ldots,p_{i,\\mathsf{s}(i)}\\in\\mathbb{F}[X]</span>. The verifier may query any of the polynomials it has received any number of times. A query consists of a location <span class="math">z\\in\\mathbb{F}</span> for an oracle <span class="math">p_{i,j}</span>, and its corresponding answer is <span class="math">p_{i,j}(z)\\in\\mathbb{F}</span>. After the interaction, the verifier accepts or rejects.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The function <span class="math">\\mathsf{d}</span> determines which provers to consider for the completeness and soundness properties of the proof system. In more detail, we say that a (possibly malicious) prover <span class="math">\\tilde{\\mathbf{P}}</span> is admissible for <span class="math">\\mathsf{AHP}</span> if, on every interaction with the verifier <span class="math">\\mathbf{V}</span>, it holds that for every round <span class="math">i\\in[\\mathsf{k}]</span> and oracle index <span class="math">j\\in[\\mathsf{s}(i)]</span> we have $\\deg(p_{i,j})\\leq\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathsf{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,i,j)<span class="math">. The honest prover </span>\\mathbf{P}$ is required to be admissible under this definition.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say that <span class="math">\\mathsf{AHP}</span> has perfect completeness and soundness error <span class="math">\\epsilon</span> if the following holds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>Completeness. For every field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span> and index-instance-witness tuple <span class="math">(\\dot{\\mathsf{s}},\\mathbbm{x},\\mathbb{w})\\in\\mathcal{R}</span>, the probability that <span class="math">\\mathbf{P}(\\mathbb{F},\\dot{\\mathsf{s}},\\mathbbm{x},\\mathbb{w})</span> convinces <span class="math">\\mathbf{V}^{\\mathbf{I}(\\mathbb{F},\\dot{\\mathsf{s}})}(\\mathbb{F},\\mathbbm{x})</span> to accept in the interactive oracle protocol is <span class="math">1</span>.</li>

      <li>Soundness. For every field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span>, index-instance pair <span class="math">(\\dot{\\mathsf{s}},\\mathbbm{x})\\notin\\mathcal{L}(\\mathcal{R})</span>, and admissible prover <span class="math">\\tilde{\\mathbf{P}}</span>, the probability that <span class="math">\\tilde{\\mathbf{P}}</span> convinces <span class="math">\\mathbf{V}^{\\mathbf{I}(\\mathbb{F},\\dot{\\mathsf{s}})}(\\mathbb{F},\\mathbbm{x})</span> to accept in the interactive oracle protocol is at most <span class="math">\\epsilon</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The <em>proof length</em> <span class="math">\\mathsf{l}</span> is the sum of all degree bounds in the offline and online phases, $\\mathsf{l}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathsf{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">):=\\sum_{i=0}^{\\mathsf{k}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathsf{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\sum_{j=1}^{\\mathsf{s}(i)}\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathsf{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,i,j)$. The intuition for this definition is that in a probabilistic proof each oracle would consist of the evaluation of a polynomial over a domain whose size (in field elements) is linearly related to its degree bound, so that the resulting proof length would be linearly related to the sum of all degree bounds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The query complexity <span class="math">q</span> is the total number of queries made by the verifier to the polynomials. This includes queries to the polynomials output by the indexer and those sent by the prover.</p>

    <p class="text-gray-300">All AHPs that we construct achieve the stronger property of knowledge soundness (against admissible provers), and optionally also zero knowledge. We define both of these properties below.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Knowledge soundness. We say that <span class="math">\\mathsf{AHP}</span> has knowledge error <span class="math">\\epsilon</span> if there exists a probabilistic polynomial-time extractor <span class="math">\\mathbf{E}</span> for which the following holds. For every field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span>, index <span class="math">\\mathbb{i}</span>, instance <span class="math">\\mathbb{x}</span>, and admissible prover <span class="math">\\tilde{\\mathbf{P}}</span>, the probability that $\\mathbf{E}^{\\tilde{\\mathbf{P}}}(\\mathbb{F},\\mathbb{i},\\mathbb{x},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)})<span class="math"> outputs </span>\\mathbb{w}<span class="math"> such that </span>(\\mathbb{i},\\mathbb{x},\\mathbb{w})\\in\\mathcal{R}<span class="math"> is at least the probability that </span>\\tilde{\\mathbf{P}}<span class="math"> convinces </span>\\mathbf{V}^{\\mathbf{I}(\\mathbb{F},\\mathbb{i})}(\\mathbb{F},\\mathbb{x})<span class="math"> to accept minus </span>\\epsilon<span class="math">. Here the notation </span>\\mathbf{E}^{\\tilde{\\mathbf{P}}}<span class="math"> means that the extractor </span>\\mathbf{E}<span class="math"> has black-box access to each of the next-message functions that define the interactive algorithm </span>\\tilde{\\mathbf{P}}<span class="math">. (In particular, the extractor </span>\\mathbf{E}<span class="math"> can “rewind” the prover </span>\\tilde{\\mathbf{P}}<span class="math">.) Note that since </span>\\mathbf{E}<span class="math"> receives the proof length </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> in unary, </span>\\mathbf{E}<span class="math"> has enough time to receive, and perform efficient computations on, polynomials output by </span>\\tilde{\\mathbf{P}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Zero knowledge. We say that <span class="math">\\mathsf{AHP}</span> has (perfect) zero knowledge with query bound <span class="math">\\mathsf{b}</span> and query checker <span class="math">\\mathbf{C}</span> if there exists a probabilistic polynomial-time simulator <span class="math">\\mathbf{S}</span> such that for every field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span>, index-instance-witness tuple <span class="math">(\\mathbb{i},\\mathbb{x},\\mathbb{w})\\in\\mathcal{R}</span>, and <span class="math">(\\mathsf{b},\\mathbf{C})</span>-query algorithm <span class="math">\\tilde{\\mathbf{V}}</span> the random variables <span class="math">\\mathrm{View}(\\mathbf{P}(\\mathbb{F},\\mathbb{i},\\mathbb{x},\\mathbb{w}),\\tilde{\\mathbf{V}})</span> and <span class="math">\\mathbf{S}^{\\tilde{\\mathbf{V}}}(\\mathbb{F},\\mathbb{i},\\mathbb{x})</span>, defined below, are identical. Here, we say that an algorithm is <span class="math">(\\mathsf{b},\\mathbf{C})</span>-query if it makes at most <span class="math">\\mathsf{b}</span> queries to oracles it has access to, and each query individually leads the checker <span class="math">\\mathbf{C}</span> to output “ok”.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{View}(\\mathbf{P}(\\mathbb{F},\\mathbb{i},\\mathbb{x},\\mathbb{w}),\\tilde{\\mathbf{V}})</span> is the view of <span class="math">\\tilde{\\mathbf{V}}</span>, namely, is the random variable <span class="math">(r,a_{1},\\ldots,a_{q})</span> where <span class="math">r</span> is <span class="math">\\tilde{\\mathbf{V}}</span>’s randomness and <span class="math">a_{1},\\ldots,a_{q}</span> are the responses to <span class="math">\\tilde{\\mathbf{V}}</span>’s queries determined by the oracles sent by <span class="math">\\mathbf{P}(\\mathbb{F},\\mathbb{i},\\mathbb{x},\\mathbb{w})</span>.</li>

      <li><span class="math">\\mathbf{S}^{\\tilde{\\mathbf{V}}}(\\mathbb{F},\\mathbb{i},\\mathbb{x})</span> is the output of <span class="math">\\mathbf{S}(\\mathbb{F},\\mathbb{i},\\mathbb{x})</span> when given straightline access to <span class="math">\\tilde{\\mathbf{V}}</span> (<span class="math">\\mathbf{S}</span> may interact with <span class="math">\\tilde{\\mathbf{V}}</span>, without rewinding, by exchanging messages with <span class="math">\\tilde{\\mathbf{V}}</span> and answering any oracle queries along the way), prepended with <span class="math">\\tilde{\\mathbf{V}}</span>’s randomness <span class="math">r</span>. Note that <span class="math">r</span> could be of super-polynomial size, so <span class="math">\\mathbf{S}</span> cannot sample <span class="math">r</span> on <span class="math">\\tilde{\\mathbf{V}}</span>’s behalf and then output it; instead, as in prior work, we restrict <span class="math">\\mathbf{S}</span> to not see <span class="math">r</span>, and prepend <span class="math">r</span> to <span class="math">\\mathbf{S}</span>’s output.</li>

    </ul>

    <p class="text-gray-300">A special case of interest. We only consider AHPs that satisfy the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Public coins: <span class="math">\\mathsf{AHP}</span> is public-coin if each verifier message to the prover is a uniformly random string of some prescribed length (or an empty string). Hence the verifier’s randomness is its messages <span class="math">\\rho_{1},\\ldots,\\rho_{\\mathsf{k}}\\in\\mathbb{F}^{<em>}</span> and possibly additional randomness <span class="math">\\rho_{\\mathsf{k}+1}\\in\\mathbb{F}^{</em>}</span> used after the interaction. All verifier queries can be postponed, without loss of generality, to a query phase that occurs after the interactive phase with the prover.</li>

      <li>Non-adaptive queries: <span class="math">\\mathsf{AHP}</span> is non-adaptive if all of the verifier’s query locations are solely determined by the verifier’s randomness and inputs (the field <span class="math">\\mathbb{F}</span> and the instance <span class="math">\\mathbb{x}</span>).</li>

    </ul>

    <p class="text-gray-300">Given these properties, we can view the verifier as two subroutines that execute in the query phase: a query algorithm <span class="math">\\mathbf{Q}_{\\mathbf{V}}</span> that produces query locations based on the verifier’s randomness, and a decision algorithm <span class="math">\\mathbf{D}_{\\mathbf{V}}</span> that accepts or rejects based on the answers to the queries (and the verifier’s randomness). In more detail, <span class="math">\\mathbf{Q}_{\\mathbf{V}}</span> receives as input the field <span class="math">\\mathbb{F}</span>, the instance <span class="math">\\mathbb{x}</span>, and randomness <span class="math">\\rho_{1},\\ldots,\\rho_{\\mathsf{k}},\\rho_{\\mathsf{k}+1}</span>, and outputs a query set <span class="math">Q</span> consisting of tuples <span class="math">((i,j),z)</span> to be interpreted as “query <span class="math">p_{i,j}</span> at <span class="math">z\\in\\mathbb{F}</span>”; and <span class="math">\\mathbf{D}_{\\mathbf{V}}</span> receives as input the field <span class="math">\\mathbb{F}</span>, the instance <span class="math">\\mathbb{x}</span>, answers <span class="math">(v_{((i,j),z)})_{((i,j),z)\\in Q}</span>, and randomness <span class="math">\\rho_{1},\\ldots,\\rho_{\\mathsf{k}},\\rho_{\\mathsf{k}+1}</span>, and outputs the decision bit.</p>

    <p class="text-gray-300">While the above properties are not strictly necessary for the compiler that we describe in Section 8, all “natural” protocols that we are aware of (including those that we construct in this paper) satisfy these properties, and so we restrict our attention to public-coin non-adaptive protocols for simplicity.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">5 AHP for constraint systems</p>

    <p class="text-gray-300">We construct an AHP for <em>rank-1 constraint satisfiability</em> (R1CS) that has linear proof length and constant query complexity. Below we define the indexed relation that represents this problem, and then state our result.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 5.1 (R1CS indexed relation).</h6>

    <p class="text-gray-300">The indexed relation <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> is the set of all triples</p>

    <p class="text-gray-300"><span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})=\\big{(}(\\mathbb{F},H,K,A,B,C),x,w\\big{)}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">H</span> and <span class="math">K</span> are subsets of <span class="math">\\mathbb{F}</span>, <span class="math">A,B,C</span> are <span class="math">H\\times H</span> matrices over <span class="math">\\mathbb{F}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\max\\{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math">, and </span>z:=(x,w)<span class="math"> is a vector in </span>\\mathbb{F}^{H}<span class="math"> such that </span>Az\\circ Bz=Cz$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-16" class="text-base font-medium mt-4">Theorem 5.2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">There exists an AHP for the indexed relation <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> that is a zero knowledge proof of knowledge with the following features. The indexer uses $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> field operations and outputs </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> field elements. The prover and verifier exchange </span>7<span class="math"> messages. To achieve zero knowledge against </span>\\mathsf{b}<span class="math"> queries (with a query checker </span>\\mathbf{C}<span class="math"> that rejects queries in </span>H<span class="math">), the prover uses </span>O((</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{b})\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{b}))<span class="math"> field operations and outputs a total of </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{b})<span class="math"> field elements. The verifier makes </span>O(1)<span class="math"> queries to the encoded index and to the prover’s messages, has soundness error </span>O((</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{b})/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, and uses </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ field operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-17" class="text-base font-medium mt-4">Remark 5.3 (restrictions on domains).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our protocol uses the univariate sumcheck of <em>[x1]</em> as a subroutine, and in particular inherits the requirement that the domains <span class="math">H</span> and <span class="math">K</span> must be additive or multiplicative subgroups of the field <span class="math">\\mathbb{F}</span>. For simplicity, in our descriptions we use multiplicative subgroups because we use this case in our implementation; the case of additive subgroups involves only minor modifications. Moreover, the arithmetic complexities for the indexer and prover stated in Theorem 5.2 assume that the domains <span class="math">H</span> and <span class="math">K</span> are “FFT-friendly” (e.g., they have smooth sizes); this is not a requirement, since in general the arithmetic complexities will be that of an FFT over the domains <span class="math">H</span> and <span class="math">K</span>. Note that we can assume without loss of generality that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, for otherwise (if </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/3<span class="math">) then are empty rows or columns across the matrices that we can drop and reduce their size. Finally, we assume that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This section is organized as follows: in Section 5.1 we introduce algebraic notations and facts used in this section; in Section 5.2 we describe an AHP for checking linear relations; and in Section 5.3 we build on this latter to obtain an AHP for R1CS.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Throughout we assume that <span class="math">H</span> and <span class="math">K</span> come equipped with bijections $\\phi_{{}_{H}}\\colon H\\to[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math"> and </span>\\phi_{{}_{K}}\\colon K\\to[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math"> that are computable in linear time. Moreover, we define the two sets </span>H[\\leq k]:=\\{\\kappa\\in H\\colon 1\\leq\\phi_{{}_{H}}(\\kappa)\\leq k\\}<span class="math"> and </span>H[>k]:=\\{\\kappa\\in H\\colon\\phi_{{}_{H}}(\\kappa)>k\\}<span class="math"> to denote the first </span>k<span class="math"> elements in </span>H<span class="math"> and the remaining elements, respectively. We can then write that </span>x\\in\\mathbb{F}^{H[\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}<span class="math"> and </span>w\\in\\mathbb{F}^{H[></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">5.1 Algebraic preliminaries</h3>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Polynomial encodings.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a finite field <span class="math">\\mathbb{F}</span>, subset <span class="math">S\\subseteq\\mathbb{F}</span>, and function <span class="math">f\\colon S\\to\\mathbb{F}</span> we denote by <span class="math">\\hat{f}</span> the (unique) univariate polynomial over <span class="math">\\mathbb{F}</span> with degree less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> such that </span>\\hat{f}(a)=f(a)<span class="math"> for every </span>a\\in S<span class="math">. We sometimes abuse notation and write </span>\\hat{f}<span class="math"> to denote <em>some</em> polynomial that agrees with </span>f<span class="math"> on </span>S$, which need not equal the (unique) such polynomial of smallest degree.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Vanishing polynomials.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a finite field <span class="math">\\mathbb{F}</span> and subset <span class="math">S\\subseteq\\mathbb{F}</span>, we denote by <span class="math">v_{S}</span> the unique non-zero monic polynomial of degree at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> that is zero everywhere on </span>S<span class="math">; </span>v_{S}<span class="math"> is called the <em>vanishing polynomial</em> of </span>S<span class="math">. If </span>S<span class="math"> is an additive or multiplicative coset in </span>\\mathbb{F}<span class="math"> then </span>v_{S}<span class="math"> can be evaluated in </span>\\mathrm{polylog}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> field operations. For example, if </span>S<span class="math"> is a multiplicative subgroup of </span>\\mathbb{F}<span class="math"> then </span>v_{S}(X)=X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}-1<span class="math"> and, more generally, if </span>S<span class="math"> is a </span>\\xi$-coset</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">of a multiplicative subgroup <span class="math">S_{0}</span> (namely, <span class="math">S=\\xi S_{0}</span>) then $v_{S}(X)=\\xi^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}v_{S_{0}}(X/\\xi)=X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}-\\xi^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">; in either case, </span>v_{S}<span class="math"> can be evaluated in </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ field operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Derivative of vanishing polynomials. We rely on various properties of a bivariate polynomial <span class="math">u_{S}</span> introduced in <em>[x1]</em>. For a finite field <span class="math">\\mathbb{F}</span> and subset <span class="math">S\\subseteq\\mathbb{F}</span>, we define</p>

    <p class="text-gray-300"><span class="math">u_{S}(X,Y):=\\frac{v_{S}(X)-v_{S}(Y)}{X-Y}\\enspace,</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which is a polynomial of individual degree $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> because </span>X-Y<span class="math"> divides </span>X^{i}-Y^{i}<span class="math"> for any positive integer </span>i<span class="math">. Note that </span>u_{S}(X,X)<span class="math"> is the formal derivative of the vanishing polynomial </span>v_{S}(X)<span class="math">. The bivariate polynomial </span>u_{S}(X,Y)<span class="math"> satisfies two useful algebraic properties. First, the univariate polynomials </span>(u_{S}(X,a))_{a\\in S}<span class="math"> are linearly independent, and </span>u_{S}(X,Y)<span class="math"> is their (unique) low-degree extension. Second, </span>u_{S}(X,Y)<span class="math"> vanishes on the square </span>S\\times S<span class="math"> except for on the diagonal, where it takes on the (non-zero) values </span>(u_{S}(a,a))_{a\\in S}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">S</span> is an additive or multiplicative coset in <span class="math">\\mathbb{F}</span>, <span class="math">u_{S}(X,Y)</span> can be evaluated at any <span class="math">(\\alpha,\\beta)\\in\\mathbb{F}^{2}</span> in $\\operatorname{polylog}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> field operations because in this case both </span>v_{S}<span class="math"> (and its derivative) can be evaluated in </span>\\operatorname{polylog}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> field operations. For example, if </span>S<span class="math"> is a multiplicative subgroup then </span>u_{S}(X,Y)=(X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}-Y^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})/(X-Y)<span class="math"> and </span>u_{S}(X,X)=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}<span class="math">, so both can be evaluated in </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ field operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Univariate sumcheck for subgroups. Prior work <em>[x1]</em> shows that, given a multiplicative subgroup <span class="math">S</span> of <span class="math">\\mathbb{F}</span>, a polynomial <span class="math">f(X)</span> sums to <span class="math">\\sigma</span> over <span class="math">S</span> if and only if <span class="math">f(X)</span> can be written as $h(X)v_{S}(X)+Xg(X)+\\sigma/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for some </span>h(X)<span class="math"> and </span>g(X)<span class="math"> with </span>\\deg(g)<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1$. This can be viewed as a univariate sumcheck protocol, and we shall rely on it throughout this section.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">5.2 AHP for the lincheck problem</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The <em>lincheck problem</em> for univariate polynomials considers the task of deciding whether two polynomials encode vectors that are linearly related in a prescribed way. In more detail, the problem is parametrized by a field <span class="math">\\mathbb{F}</span>, two subsets <span class="math">H</span> and <span class="math">K</span> of <span class="math">\\mathbb{F}</span>, and a matrix <span class="math">M\\in\\mathbb{F}^{H\\times H}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>0<span class="math">. Given oracle access to two low-degree polynomials </span>f_{1},f_{2}\\in\\mathbb{F}^{<d}[X]<span class="math">, the problem asks to decide whether for every </span>a\\in H<span class="math"> it holds that </span>f_{1}(a)=\\sum_{b\\in H}M_{a,b}\\cdot f_{2}(b)<span class="math">, by asking a small number of queries to </span>f_{1}<span class="math"> and </span>f_{2}<span class="math">. The matrix </span>M<span class="math"> thus prescribes the linear relations that relate the values of </span>f_{1}<span class="math"> and </span>f_{2}<span class="math"> on </span>H$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Ben-Sasson et al. <em>[x1]</em> solve this problem by reducing the lincheck problem to a sumcheck problem, and then reducing the sumcheck problem to low-degree testing (of univariate polynomials). In particular, this prior work achieves a <span class="math">2</span>-message algebraic <em>non-holographic</em> protocol that solves the lincheck problem with linear proof length and constant query complexity. In this section we show how to achieve a <span class="math">6</span>-message algebraic <em>holographic</em> protocol, again with linear proof length and constant query complexity. In Section 5.2.1 we describe the indexer algorithm, in Section 5.2.2 we describe the prover and verifier algorithms, and in Section 5.2.3 we analyze the protocol. Fig. 4 summarizes the protocol.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">5.2.1 Offline phase: encoding the linear relation</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The indexer <span class="math">\\mathbf{I}</span> for the lincheck problem receives as input a field <span class="math">\\mathbb{F}</span>, two subsets <span class="math">H</span> and <span class="math">K</span> of <span class="math">\\mathbb{F}</span>, and a matrix <span class="math">M\\in\\mathbb{F}^{H\\times H}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The non-zero entries of </span>M<span class="math"> are assumed to be presented in some canonical order (e.g., row-wise or column-wise). The output of </span>\\mathbf{I}<span class="math"> is three univariate polynomials </span>\\operatorname{\\sf row},\\operatorname{\\sf col},\\operatorname{\\sf val}<span class="math"> over </span>\\mathbb{F}<span class="math"> of degree less than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> such that the following polynomial is a low-degree extension of </span>M$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\hat{M}(X,Y):=\\sum_{\\kappa\\in K}u_{H}(X,\\operatorname{\\sf row}\\!\\operatorname{\\sf vol}(\\kappa))u_{H}(Y,\\operatorname{\\sf col}(\\kappa))\\operatorname{\\sf val}(\\kappa)\\enspace.</span> (1)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The three three aforementioned polynomials are the (unique) low-degree extensions of the three functions <span class="math">\\mathsf{row},\\mathsf{col},\\mathsf{val}\\colon K\\to \\mathbb{F}</span> that respectively represent the row index, column index, and value of the non-zero entries of the matrix <span class="math">M</span>. In more detail, for every <span class="math">\\kappa \\in K</span> with $1\\leq \\phi_{K}(\\kappa)\\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{row}(\\kappa) \\coloneqq \\phi_{H}^{-1}(t_{\\kappa})</span> where <span class="math">t_{\\kappa}</span> is the row index of the <span class="math">\\phi_{K}(\\kappa)</span>-th nonzero entry in <span class="math">M</span>;</li>

      <li><span class="math">\\operatorname{col}(\\kappa) \\coloneqq \\phi_{H}^{-1}(t_{\\kappa})</span> where <span class="math">t_{\\kappa}</span> is the column index of the <span class="math">\\phi_{K}(\\kappa)</span>-th nonzero entry in <span class="math">M</span>;</li>

      <li><span class="math">\\mathsf{val}(\\kappa)</span> is the value of the <span class="math">\\phi_{K}(\\kappa)</span>-th nonzero entry in <span class="math">M</span>, divided by <span class="math">u_{H}(\\mathsf{row}(\\kappa),\\mathsf{row}(\\kappa))u_{H}(\\mathsf{col}(\\kappa),\\mathsf{col}(\\kappa))</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Also, <span class="math">\\operatorname{val}(\\kappa)</span> returns the element 0 for every <span class="math">\\kappa \\in K</span> with $\\phi_K(\\kappa) &gt; \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, while </span>\\operatorname{row}(\\kappa)<span class="math"> and </span>\\operatorname{col}(\\kappa)<span class="math"> return an arbitrary element in </span>H<span class="math"> for such </span>\\kappa<span class="math">. The evaluation tables of these functions can be found in </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> operations, from which interpolation yields the desired polynomials in </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall from Section 5.1 that the bivariate polynomial <span class="math">u_{H}(X,Y)</span> vanishes on the square <span class="math">H\\times H</span> except for on the diagonal, where it takes on the (non-zero) values <span class="math">(u_{H}(a,a))_{a\\in H}</span>. By construction of the polynomials <span class="math">\\hat{\\mathsf{row}},\\hat{\\mathsf{col}},\\hat{\\mathsf{val}}</span>, the polynomial <span class="math">\\hat{M} (X,Y)</span> agrees with the matrix <span class="math">M</span> everywhere on the domain <span class="math">H\\times H</span>. The individual degree of <span class="math">\\hat{M} (X,Y)</span> is less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Thus, </span>\\hat{M}<span class="math"> is the unique low-degree extension of </span>M$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We rewrite the polynomial <span class="math">\\hat{M} (X,Y)</span> in a form that will be useful later:</p>

    <p class="text-gray-300">Claim 5.4.</p>

    <div class="my-4 text-center"><span class="math-block">\\hat {M} (X, Y) = \\sum_ {\\kappa \\in K} \\frac {v _ {H} (X)}{(X - \\hat {\\operatorname {r o w}} (\\kappa))} \\cdot \\frac {v _ {H} (Y)}{(Y - \\hat {\\operatorname {c o l}} (\\kappa))} \\cdot \\hat {\\operatorname {v a l}} (\\kappa). \\tag {2}</span></div>

    <p class="text-gray-300">Proof. Note that <span class="math">v_{H}(\\hat{\\mathrm{row}}(\\kappa)) = v_{H}(\\hat{\\mathrm{col}}(\\kappa)) = 0</span> for every <span class="math">\\kappa \\in K</span> because <span class="math">\\hat{\\mathrm{row}}(X)</span> and <span class="math">\\hat{\\mathrm{col}}(X)</span> map <span class="math">K</span> to <span class="math">H</span> and <span class="math">v_{H}</span> vanishes on <span class="math">H</span>. Therefore:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\hat {M} (X, Y) = \\sum_ {\\kappa \\in K} u _ {H} (X, \\hat {\\operatorname {r o w}} (\\kappa)) \\cdot u _ {H} (Y, \\hat {\\operatorname {c o l}} (\\kappa)) \\cdot \\hat {\\operatorname {v a l}} (\\kappa) \\\\ = \\sum_ {\\kappa \\in K} \\frac {v _ {H} (X) - v _ {H} (\\hat {\\mathrm {r o w}} (\\kappa))}{X - \\hat {\\mathrm {r o w}} (\\kappa)} \\cdot \\frac {v _ {H} (Y) - v _ {H} (\\hat {\\mathrm {c o l}} (\\kappa))}{Y - \\hat {\\mathrm {c o l}} (\\kappa)} \\cdot \\hat {\\mathrm {v a l}} (\\kappa) \\\\ = \\sum_ {\\kappa \\in K} \\frac {v _ {H} (X)}{(X - \\hat {\\mathrm {r o w}} (\\kappa))} \\cdot \\frac {v _ {H} (Y)}{(Y - \\hat {\\mathrm {c o l}} (\\kappa))} \\cdot \\hat {\\mathrm {v a l}} (\\kappa). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">□</p>

    <h2 id="sec-23" class="text-2xl font-bold">5.2.2 Online phase: proving and verifying the linear relation</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The prover <span class="math">\\mathbf{P}</span> for the lincheck problem receives as input a field <span class="math">\\mathbb{F}</span>, two subsets <span class="math">H</span> and <span class="math">K</span> of <span class="math">\\mathbb{F}</span>, a matrix <span class="math">M \\in \\mathbb{F}^{H \\times H}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and two polynomials </span>f_{1}, f_{2} \\in \\mathbb{F}^{&lt;d}[X]<span class="math">. The verifier </span>\\mathbf{V}<span class="math"> for the lincheck problem receives as input the field </span>\\mathbb{F}<span class="math"> and two subsets </span>H<span class="math"> and </span>K<span class="math"> of </span>\\mathbb{F}<span class="math">; </span>\\mathbf{V}<span class="math"> also has oracle access to the polynomials </span>\\hat{\\mathrm{row}}, \\hat{\\mathrm{col}}, \\hat{\\mathrm{val}}<span class="math"> output by the indexer </span>\\mathbf{I}$ invoked on appropriate inputs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The protocol begins with a reduction from a lincheck problem to a sumcheck problem: <span class="math">\\mathbf{V}</span> samples a random element <span class="math">\\alpha \\in \\mathbb{F}</span> and sends it to <span class="math">\\mathbf{P}</span>. Indeed, letting <span class="math">r(X,Y)</span> denote the polynomial <span class="math">u_{H}(X,Y)</span>, <span class="math">\\mathbf{P}</span> is left to convince <span class="math">\\mathbf{V}</span> that the following univariate polynomial sums to 0 on <span class="math">H</span>:</p>

    <div class="my-4 text-center"><span class="math-block">q _ {1} (X) := r (\\alpha , X) f _ {1} (X) - r _ {M} (\\alpha , X) f _ {2} (X) \\quad \\text {where} \\quad r _ {M} (X, Y) := \\sum_ {\\kappa \\in H} r (X, \\kappa) \\hat {M} (\\kappa , Y). \\tag {3}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We rely on the univariate sumcheck protocol for this step: <span class="math">\\mathbf{P}</span> sends to <span class="math">\\mathbf{V}</span> the polynomials <span class="math">g_{1}(X)</span> and <span class="math">h_{1}(X)</span> such that <span class="math">q_{1}(X)=h_{1}(X)v_{H}(X)+Xg_{1}(X)</span>. In order to check this polynomial identity, <span class="math">\\mathbf{V}</span> samples a random element <span class="math">\\beta_{1}\\in\\mathbb{F}</span> with the intention of checking the identity at <span class="math">X:=\\beta_{1}</span>. For the right-hand side, <span class="math">\\mathbf{V}</span> queries <span class="math">g_{1}</span> and <span class="math">h_{1}</span> at <span class="math">\\beta_{1}</span>, and then evaluates <span class="math">h_{1}(\\beta_{1})v_{H}(\\beta_{1})+\\beta_{1}g_{1}(\\beta_{1})</span> in $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> operations. For the left-hand side, </span>\\mathbf{V}<span class="math"> queries </span>f_{1}<span class="math"> and </span>f_{2}<span class="math"> at </span>\\beta_{1}<span class="math"> and then needs to ask help from </span>\\mathbf{P}<span class="math"> to evaluate </span>r(\\alpha,\\beta_{1})f_{1}(\\beta_{1})-r_{M}(\\alpha,\\beta_{1})f_{2}(\\beta_{1})<span class="math">. The reason is that while </span>r(\\alpha,\\beta_{1})<span class="math"> is easy to evaluate (it requires </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> operations), </span>r_{M}(\\alpha,\\beta_{1})=\\sum_{\\kappa\\in H}r(\\alpha,\\kappa)\\hat{M}(\\kappa,\\beta_{1})<span class="math"> in general requires </span>\\Omega(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We thus rely on the univariate sumcheck protocol again. We define</p>

    <p class="text-gray-300"><span class="math">q_{2}(X):=r(\\alpha,X)\\hat{M}(X,\\beta_{1})</span> (4)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathbf{V}</span> sends <span class="math">\\beta_{1}</span> to <span class="math">\\mathbf{P}</span>, and then <span class="math">\\mathbf{P}</span> replies with the sum <span class="math">\\sigma_{2}:=\\sum_{\\kappa\\in H}r(\\alpha,\\kappa)\\hat{M}(\\kappa,\\beta_{1})</span> and the polynomials <span class="math">g_{2}(X)</span> and <span class="math">h_{2}(X)</span> such that $q_{2}(X)=h_{2}(X)v_{H}(X)+Xg_{2}(X)+\\sigma_{2}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. In order to check this polynomial identity, </span>\\mathbf{V}<span class="math"> samples a random element </span>\\beta_{2}\\in\\mathbb{F}<span class="math"> with the intention of checking the identity at </span>X:=\\beta_{2}<span class="math">. For the right-hand side, </span>\\mathbf{V}<span class="math"> queries </span>g_{2}<span class="math"> and </span>h_{2}<span class="math"> at </span>\\beta_{2}<span class="math">, and then evaluates </span>h_{2}(\\beta_{2})v_{H}(\\beta_{2})+\\beta_{2}g_{2}(\\beta_{2})+\\sigma_{2}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> in </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> operations. To evaluate the left-hand side, however, </span>\\mathbf{V}<span class="math"> needs to ask help from </span>\\mathbf{P}<span class="math">. The reason is that while </span>r(\\alpha,\\beta_{2})<span class="math"> is easy to evaluate (it requires </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> operations), </span>\\hat{M}(\\beta_{2},\\beta_{1})<span class="math"> in general requires </span>\\Omega(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We thus rely on the univariate sumcheck protocol (yet) again: <span class="math">\\mathbf{V}</span> sends <span class="math">\\beta_{2}</span> to <span class="math">\\mathbf{P}</span>, and then <span class="math">\\mathbf{P}</span> replies with the value <span class="math">\\sigma_{3}:=\\hat{M}(\\beta_{2},\\beta_{1})</span>, which the verifier must check. Note though that we cannot use the sumcheck protocol directly to compute the sum obtained from Eq. (1):</p>

    <p class="text-gray-300"><span class="math">\\hat{M}(\\beta_{2},\\beta_{1})=\\sum_{\\kappa\\in K}u_{H}(\\beta_{2},\\mathsf{row}(\\kappa))u_{H}(\\beta_{1},\\mathsf{col}(\\kappa))\\mathsf{val}(\\kappa)\\enspace.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The reason is because the degree of the above addend, if we replace <span class="math">\\kappa</span> with an indeterminate, is $\\Omega(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, which means that the degree of the polynomial </span>h_{3}<span class="math"> sent as part of a sumcheck protocol also has degree </span>\\Omega(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, which is not within our budget of an AHP with proof length </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Instead, we make the minor modification that in the earlier rounds </span>\\beta_{1}<span class="math"> and </span>\\beta_{2}<span class="math"> are sampled from </span>\\mathbb{F}\\setminus H<span class="math"> instead of </span>\\mathbb{F}$, and we will leverage the sumcheck protocol to verify the equivalent (well defined) expression from Eq. (2):</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\hat{M}(\\beta_{2},\\beta_{1})=\\sum_{\\kappa\\in K}\\frac{v_{H}(\\beta_{2})v_{H}(\\beta_{1})\\mathsf{val}(\\kappa)}{(\\beta_{2}-\\mathsf{row}(\\kappa))(\\beta_{1}-\\mathsf{col}(\\kappa))}\\enspace.</span></p>

    <p class="text-gray-300">This may appear to be an odd choice, because if we replace <span class="math">\\kappa</span> with an indeterminate in the sum above, we obtain a rational function that is (in general) not a polynomial, and so does not immediately fit the sumcheck protocol. Nevertheless, we are still able to use the sumcheck protocol with it, as we now explain.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Define <span class="math">f_{3}(X)</span> to be the (unique) polynomial of degree less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\forall\\,\\kappa\\in K\\,,\\ f_{3}(\\kappa)=\\frac{v_{H}(\\beta_{2})v_{H}(\\beta_{1})\\mathsf{val}(\\kappa)}{(\\beta_{2}-\\mathsf{row}(\\kappa))(\\beta_{1}-\\mathsf{col}(\\kappa))}\\enspace.</span> (5)</p>

    <p class="text-gray-300">The prover computes the polynomials <span class="math">g_{3}(X)</span> and <span class="math">h_{3}(X)</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$f_{3}(X)=Xg_{3}(X)+\\sigma_{3}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\enspace,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">v_{H}(\\beta_{2})v_{H}(\\beta_{1})\\mathsf{val}(X)-(\\beta_{2}-\\mathsf{row}(X))(\\beta_{1}-\\mathsf{col}(X))f_{3}(X)=h_{3}(X)v_{K}(X)\\enspace.</span></p>

    <p class="text-gray-300">The first equation demonstrates that <span class="math">f_{3}</span> sums to <span class="math">\\sigma_{3}</span> over <span class="math">K</span>, and the second equation demonstrates that <span class="math">f_{3}</span> agrees with the correct addends over <span class="math">K</span>. These two equations can be combined in a single equation that involves only <span class="math">g_{3}(X)</span> and <span class="math">h_{3}(X)</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$v_{H}(\\beta_{2})v_{H}(\\beta_{1})\\mathop{\\sf val}(X)-(\\beta_{2}-\\mathop{\\sf row}\\nolimits\\mathop{\\sf row}\\nolimits(\\beta_{1})(\\beta_{1}-\\mathop{\\sf col}(X))(Xg_{3}(X)+\\sigma_{3}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=h_{3}(X)v_{K}(X)\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The prover thus only sends the two polynomials <span class="math">g_{3}(X)</span> and <span class="math">h_{3}(X)</span>. In order to check this polynomial identity, <span class="math">\\mathbf{V}</span> samples a random element <span class="math">\\beta_{3}\\in\\mathbb{F}</span> with the intention of checking the identity at <span class="math">X:=\\beta_{3}</span>. Then <span class="math">\\mathbf{V}</span> queries <span class="math">g_{3}</span>, <span class="math">h_{3}</span>, <span class="math">\\mathop{\\sf row}\\nolimits</span>, <span class="math">\\mathop{\\sf col}</span>, <span class="math">\\mathop{\\sf val}</span> at <span class="math">\\beta_{3}</span>, and then evaluates $v_{H}(\\beta_{2})v_{H}(\\beta_{1})\\mathop{\\sf val}(\\beta_{3})-(\\beta_{2}-\\mathop{\\sf row}\\nolimits(\\beta_{3}))(\\beta_{1}-\\mathop{\\sf col}(\\beta_{3}))(\\beta_{3}g_{3}(\\beta_{3})+\\sigma_{3}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=h_{3}(\\beta_{3})v_{K}(\\beta_{3})<span class="math"> in </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If this third test passes then <span class="math">\\mathbf{V}</span> can use the value <span class="math">\\sigma_{3}</span> in place of <span class="math">\\hat{M}(\\beta_{2},\\beta_{1})</span> to finish the second test. If this latter passes, <span class="math">\\mathbf{V}</span> can in turn use the value <span class="math">\\sigma_{2}</span> in place of <span class="math">r_{M}(\\alpha,\\beta_{1})</span> to finish the first test.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">5.2.3 Analysis</h4>

    <h5 id="sec-25" class="text-base font-semibold mt-4">Soundness.</h5>

    <p class="text-gray-300">We argue that the soundness error is at most</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\frac{d+3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\setminus H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">There are four ways in which the verifier could still accept if the lincheck statement is false: if the randomized reduction to the first sumcheck produces a polynomial that sums to zero; or if any one of the three sumchecks accepts despite the claimed sum being incorrect. The probability that the randomized reduction to sumcheck fails is at most the individual degree in <span class="math">X</span> of <span class="math">r(X,Y)</span> divided by $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, which is less than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The probability that any one of the sumchecks fail to detect an incorrectly declared sum is at most the maximum degree of the polynomial equation tested in the respective sumcheck divided by the size from which the test element is sampled. The innermost sumcheck has maximum degree less than </span>3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, the intermediate sumcheck has maximum degree less than </span>2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and the outermost sumcheck has maximum degree less than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d$. These errors add up to the soundness error claimed above.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency. The protocol consists of 6 messages, with the verifier moving first. The verifier makes a constant number of queries, evaluates <span class="math">v_{H}</span> and <span class="math">v_{K}</span> at a constant number of locations, and then performs a constant number of field operations. In particular, the arithmetic complexity of the verifier is $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The prover sends a constant number of polynomials with degrees linearly related to </span>d<span class="math"> (the bound on the degrees of </span>f_{1}<span class="math"> and </span>f_{2}<span class="math">), </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. We now argue that prover time is </span>O((</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{d})\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{d})+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. In the first round, the prover sends the coefficients of the polynomials </span>g_{1}(X)<span class="math"> and </span>h_{1}(X)<span class="math">, which can be found in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{d})\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{d}))<span class="math">, as we argue in Lemma 5.5. In the second round, the prover sends the field element </span>\\sigma_{2}<span class="math"> and the polynomials </span>g_{2}(X)<span class="math"> and </span>h_{2}(X)<span class="math">, which can be found in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, as we argue in Lemma 5.6. In the third round, the prover sends the field element </span>\\sigma_{3}<span class="math"> and the polynomials </span>g_{3}(X)<span class="math"> and </span>h_{3}(X)<span class="math">, which can be found in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, as we argue in Lemma 5.7.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-26" class="text-base font-medium mt-4">Lemma 5.5 (first round).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The coefficients of the polynomials <span class="math">g_{1}(X)</span> and <span class="math">h_{1}(X)</span> can be found in $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{d})\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{d}))<span class="math"> field operations, when given coefficients of the polynomials </span>f_{1}(X)<span class="math"> and </span>f_{2}(X)<span class="math">, the subsets </span>H<span class="math"> and </span>K<span class="math">, and the matrix </span>M$ (in sparse form).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It suffices to find the coefficients of the polynomial <span class="math">q_{1}(X)</span> from Eq. (3), which has degree at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{d}-2<span class="math">, because the polynomials </span>g_{1}(X)<span class="math"> and </span>h_{1}(X)<span class="math"> can be found via polynomial long division of </span>q_{1}(X)<span class="math"> by </span>v_{H}<span class="math"> in time </span>O((</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{d})\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. In turn, </span>q_{1}(X)<span class="math"> can be computed from the coefficients of </span>f_{1}(X)<span class="math">, </span>f_{2}(X)$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">r(\\alpha,X)</span>, and <span class="math">r_{M}(\\alpha,X)</span> in time $O((</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{d})\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{d}))<span class="math"> via fast polynomial multiplication and polynomial addition. The first two are given to us in coefficient form; to find the coefficients of the latter two polynomials, we can evaluate each of them over </span>H$ and then interpolate.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The values of <span class="math">r(\\alpha,X)</span> on <span class="math">H</span> can be obtained in $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> operations via direct computation of formulas described in Section 5.1. The problem is now reduced to finding the values of </span>r_{M}(\\alpha,X)<span class="math"> on </span>H$ — this is the “hard part” that motivates the present proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Observe that, by definition of <span class="math">r_{M}</span> (see Eq. (3)) and <span class="math">\\hat{M}</span> (see Eq. (1)), the following holds:</p>

    <p class="text-gray-300"><span class="math">r_{M}(\\alpha,X)</span> <span class="math">=\\sum_{\\kappa_{1}\\in H}r(\\alpha,\\kappa_{1})\\sum_{\\kappa_{2}\\in K}u_{H}(\\kappa_{1},\\mathsf{row}(\\kappa_{2}))u_{H}(X,\\mathsf{col}(\\kappa_{2}))\\mathsf{val}(\\kappa_{2})</span> <span class="math">=\\sum_{\\kappa_{2}\\in K}u_{H}(X,\\mathsf{col}(\\kappa_{2}))\\mathsf{val}(\\kappa_{2})\\sum_{\\kappa_{1}\\in H}r(\\alpha,\\kappa_{1})u_{H}(\\kappa_{1},\\mathsf{row}(\\kappa_{2}))</span> <span class="math">=\\sum_{\\kappa_{2}\\in K}u_{H}(X,\\mathsf{col}(\\kappa_{2}))\\mathsf{val}(\\kappa_{2})r(\\alpha,\\mathsf{row}(\\kappa_{2}))u_{H}(\\mathsf{row}(\\kappa_{2}),\\mathsf{row}(\\kappa_{2}))\\enspace.</span></p>

    <p class="text-gray-300">The last equality uses the fact that, for every <span class="math">\\kappa_{2}\\in K</span>, the summation <span class="math">\\sum_{\\kappa_{1}\\in H}r(\\alpha,\\kappa_{1})u_{H}(\\kappa_{1},\\mathsf{row}(\\kappa_{2}))</span> collapses to a single term corresponding to <span class="math">\\kappa_{1}=\\mathsf{row}(\\kappa_{2})</span>; the other terms, which correspond to <span class="math">\\kappa_{1}\\neq\\mathsf{row}(\\kappa_{2})</span>, are zero due to the fact that the polynomial <span class="math">u_{H}</span> vanishes on the square <span class="math">H\\times H</span> except for on its diagonal.</p>

    <p class="text-gray-300">Next, again using the fact that <span class="math">u_{H}</span> vanishes on the square <span class="math">H\\times H</span> except for on its diagonal, we note that for every <span class="math">\\kappa_{1}\\in H</span></p>

    <p class="text-gray-300"><span class="math">r_{M}(\\alpha,\\kappa_{1})=\\sum_{\\kappa_{2}\\in K\\ \\text{s.t.}\\ \\mathsf{col}(\\kappa_{2})=\\kappa_{1}}u_{H}(\\kappa_{1},\\mathsf{col}(\\kappa_{2}))\\mathsf{val}(\\kappa_{2})\\cdot r(\\alpha,\\mathsf{row}(\\kappa_{2}))u_{H}(\\mathsf{row}(\\kappa_{2}),\\mathsf{row}(\\kappa_{2}))\\enspace.</span></p>

    <p class="text-gray-300">In other words, as <span class="math">\\kappa_{1}</span> ranges over <span class="math">H</span>, each element of the sum in <span class="math">r_{M}(\\alpha,\\kappa_{1})</span> contributes a nonzero value precisely when <span class="math">\\kappa_{1}</span> equals a particular element of <span class="math">H</span>, namely, when <span class="math">\\kappa_{1}=\\mathsf{col}(\\kappa_{2})</span>. Also, since <span class="math">\\kappa_{2}</span> ranges only in <span class="math">K</span>, <span class="math">\\mathsf{row}(\\kappa_{2})=\\mathsf{row}(\\kappa_{2})</span>, <span class="math">\\mathsf{col}(\\kappa_{2})=\\mathsf{col}(\\kappa_{2})</span>, and <span class="math">\\mathsf{val}(\\kappa_{2})=\\mathsf{val}(\\kappa_{2})</span> are just the row index, column index, and value of the <span class="math">\\kappa_{2}</span>-th entry of <span class="math">M</span> (or zero).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This immediately leads to the following strategy to finding the values of <span class="math">r_{M}(\\alpha,X)</span> on <span class="math">H</span>. Initialize for each <span class="math">\\kappa_{1}\\in H</span> a variable for <span class="math">r_{M}(\\alpha,\\kappa_{1})</span> that is initially set to <span class="math">0</span>. Then, for each <span class="math">\\kappa_{2}\\in K</span>, compute the term <span class="math">u_{H}(\\mathsf{col}(\\kappa_{2}),\\mathsf{col}(\\kappa_{2}))\\mathsf{val}(\\kappa_{2})r(\\alpha,\\mathsf{row}(\\kappa_{2}))u_{H}(\\mathsf{row}(\\kappa_{2}),\\mathsf{row}(\\kappa_{2}))</span> and add it to the variable for <span class="math">r_{M}(\\alpha,\\mathsf{col}(\\kappa_{2}))</span>. Since the values <span class="math">(u_{H}(\\kappa_{1},\\kappa_{1}))_{\\kappa_{1}\\in H}</span> and <span class="math">(r(\\alpha,\\kappa_{1}))_{\\kappa_{1}\\in H}</span> can be precomputed in $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> operations, the foregoing strategy can be carried out in </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ operations. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-28" class="text-base font-medium mt-4">Lemma 5.6 (second round).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The field element <span class="math">\\sigma_{2}</span> and the coefficients of the polynomials <span class="math">g_{2}(X)</span> and <span class="math">h_{2}(X)</span> can be found in $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> field operations, when given the subsets </span>H<span class="math"> and </span>K<span class="math"> and the matrix </span>M$ (in sparse form).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It suffices to find the coefficients of the polynomial <span class="math">q_{2}(X)</span> from Eq. (4), which has degree at most $2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2<span class="math">, because the polynomials </span>g_{2}(X)<span class="math"> and </span>h_{2}(X)<span class="math"> can be found via polynomial long division of </span>q_{2}(X)<span class="math"> by </span>v_{H}<span class="math"> in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, and the sum </span>\\sigma_{2}<span class="math"> can be found by evaluating </span>q_{2}(X)<span class="math"> over </span>H<span class="math"> in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and summing in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. In turn, </span>q_{2}(X)<span class="math"> can be computed from the coefficients of </span>r(\\alpha,X)<span class="math"> and of </span>\\hat{M}(X,\\beta_{1})<span class="math"> in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> using fast polynomial multiplication. To find the coefficients of these two polynomials, we can evaluate each of them over </span>H<span class="math"> and then interpolate. The values of </span>r(\\alpha,X)<span class="math"> on </span>H<span class="math"> can be obtained in </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> operations. We now need to find the values of </span>\\hat{M}(X,\\beta_{1})<span class="math"> on </span>H$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Recall that</p>

    <p class="text-gray-300"><span class="math">\\hat{M}(X,\\beta_{1})=\\sum_{\\kappa\\in K}u_{H}(X,\\mathsf{row}(\\kappa))u_{H}(\\beta_{1},\\mathsf{col}(\\kappa))\\mathsf{val}(\\kappa)\\enspace.</span></p>

    <p class="text-gray-300">Using the fact that <span class="math">u_{H}</span> vanishes on the square <span class="math">H\\times H</span> except for the diagonal, we note that for every <span class="math">\\kappa_{1}\\in H</span></p>

    <p class="text-gray-300"><span class="math">\\hat{M}(\\kappa_{1},\\beta_{1})=\\sum_{\\kappa_{2}\\in K\\text{ s.t. }\\mathsf{row}(\\kappa_{2})=\\kappa_{1}}u_{H}(\\kappa_{1},\\mathsf{row}(\\kappa_{2}))u_{H}(\\beta_{1},\\mathsf{col}(\\kappa_{2}))\\mathsf{val}(\\kappa_{2})\\enspace.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus, to find the values of <span class="math">\\hat{M}(X,\\beta_{1})</span> on <span class="math">H</span>, we initialize for each <span class="math">\\kappa_{1}\\in H</span> a variable for <span class="math">\\hat{M}(\\kappa_{1},\\beta_{1})</span> that is initially set to <span class="math">0</span>. Then, for each <span class="math">\\kappa_{2}\\in K</span>, we compute the term <span class="math">u_{H}(\\mathsf{row}(\\kappa_{2}),\\mathsf{row}(\\kappa_{2}))u_{H}(\\beta_{1},\\mathsf{col}(\\kappa_{2}))\\mathsf{val}(\\kappa_{2})</span> and add it to the variable for <span class="math">\\hat{M}(\\mathsf{row}(\\kappa_{2}),\\beta_{1})</span>. Since the values <span class="math">(u_{H}(\\kappa,\\kappa))_{\\kappa\\in H}</span> and <span class="math">(u_{H}(\\beta_{1},\\kappa))_{\\kappa\\in H}</span> can be precomputed in $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> operations, the foregoing strategy can be carried out in </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ operations. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-30" class="text-base font-medium mt-4">Lemma 5.7 (third round).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The field element <span class="math">\\sigma_{3}</span> and the coefficients of the polynomials <span class="math">g_{3}(X)</span> and <span class="math">h_{3}(X)</span> can be found in $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> field operations, when given the subsets </span>H<span class="math"> and </span>K<span class="math"> and the matrix </span>M$ (in sparse form).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-31" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, we find the coefficients of the polynomial <span class="math">f_{3}(X)</span> from Eq. (5), which has degree at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math">. We traverse the matrix </span>M<span class="math"> to find the values of </span>\\mathsf{row}(\\kappa)=\\mathsf{row}(\\kappa)<span class="math">, </span>\\mathsf{col}(\\kappa)=\\mathsf{col}(\\kappa)<span class="math">, and </span>\\mathsf{val}(\\kappa)=\\mathsf{val}(\\kappa)<span class="math">, for every </span>\\kappa\\in K<span class="math">. Then, for each </span>\\kappa\\in K<span class="math">, we calculate </span>f_{3}(\\kappa)=\\frac{v_{H}(\\beta_{2})v_{H}(\\beta_{1})\\mathsf{val}(\\kappa)}{(\\beta_{2}-\\mathsf{row}(\\kappa))(\\beta_{1}-\\mathsf{col}(\\kappa))}<span class="math">, and interpolate those </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> values, in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Those values can also be summed, in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, to obtain </span>\\sigma_{3}<span class="math">. Then </span>g_{3}(X)<span class="math"> can be found easily, by subtracting </span>\\sigma_{3}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> from </span>f_{3}(X)<span class="math"> and dividing by </span>X$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, the prover interpolates the values from <span class="math">M</span> to find the three polynomials <span class="math">\\mathsf{row}</span>, <span class="math">\\mathsf{col}</span>, and <span class="math">\\mathsf{val}</span>. Using fast polynomial multiplication, the prover calculates <span class="math">v_{H}(\\beta_{2})v_{H}(\\beta_{1})\\mathsf{val}(X)-(\\beta_{2}-\\mathsf{row}(X))(\\beta_{1}-\\mathsf{col}(X))f_{3}(X)</span>, and divides this polynomial by <span class="math">v_{K}(X)</span> to find <span class="math">h_{3}(X)</span>. This too can be done in time $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">5.3 AHP for R1CS</h3>

    <p class="text-gray-300">We prove Theorem 5.2. In Section 5.3.1 we describe the indexer algorithm, in Section 5.3.2 we describe the prover and verifier algorithms, and in Section 5.3.3 we analyze the protocol. Fig. 5 summarizes the protocol.</p>

    <p class="text-gray-300">The AHP for R1CS directly builds on the AHP for the lincheck problem, analogously to how in <em>[x1]</em> the non-holographic protocol for R1CS builds on the non-holographic lincheck protocol. The three lincheck problems associated to the three matrices in the index are bundled together via random coefficients, while the entry-wise product is checked with a polynomial identity. Zero knowledge is achieved via bounded independence and random masks <em>[x1, x2]</em>. Consistency with the instance is achieved by having the verifier combine a low-degree extension of the instance and the low-degree extension of the (alleged) witness sent by the prover, in order to create a low-degree extension of the full assignment.</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">5.3.1 Offline phase: encoding the constraint system</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The indexer <span class="math">\\mathbf{I}</span> for R1CS receives as input a field <span class="math">\\mathbb{F}</span>, two subsets <span class="math">H</span> and <span class="math">K</span> of <span class="math">\\mathbb{F}</span>, and three matrices <span class="math">A,B,C\\in\\mathbb{F}^{H\\times H}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\max\\{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math">. The non-zero entries of </span>A,B,C<span class="math"> are assumed to be presented in some common canonical order. The output of </span>\\mathbf{I}<span class="math"> consists of the output of the lincheck indexer separately invoked on </span>A,B,C<span class="math">. This produces nine univariate polynomials </span>\\{\\mathsf{row}_{M},\\mathsf{col}_{M},\\mathsf{val}_{M}\\}_{M\\in\\{A,B,C\\}}<span class="math"> over </span>\\mathbb{F}<span class="math"> of degree less than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> that can be used to compute the low-degree extensions of </span>A,B,C$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">5.3.2 Online phase: proving and verifying satisfiability</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The prover <span class="math">\\mathbf{P}</span> for R1CS receives as input a field <span class="math">\\mathbb{F}</span>, two subsets <span class="math">H</span> and <span class="math">K</span> of <span class="math">\\mathbb{F}</span>, three matrices <span class="math">A,B,C\\in\\mathbb{F}^{H\\times H}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\max\\{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math">, input </span>x\\in\\mathbb{F}^{H[\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}<span class="math">, and witness </span>w\\in\\mathbb{F}^{H[></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}<span class="math">. The verifier </span>\\mathbf{V}<span class="math"> for R1CS receives as input the field </span>\\mathbb{F}<span class="math">, two subsets </span>H<span class="math"> and </span>K<span class="math"> of </span>\\mathbb{F}<span class="math">, and input </span>x\\in\\mathbb{F}^{H[\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}<span class="math">; </span>\\mathbf{V}<span class="math"> also has oracle access to the polynomials </span>\\{\\mathsf{row}_{M},\\mathsf{col}_{M},\\mathsf{val}_{M}\\}_{M\\in\\{A,B,C\\}}<span class="math"> output by the indexer </span>\\mathbf{I}$ invoked on appropriate inputs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The protocol begins with the prover sending randomized encodings for (a certain shift of) the assignment and its linear combinations. Define <span class="math">\\hat{x}(X)</span> to be the polynomial of degree less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> that agrees with the instance </span>x<span class="math"> in </span>H[\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math">. Define the shifted witness </span>\\bar{w}\\colon H[></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]\\to\\mathbb{F}$ according to the equation</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\forall\\,\\gamma\\,,\\ \\bar{w}(\\gamma):=\\frac{w(\\gamma)-\\hat{x}(\\gamma)}{v_{H[\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}(\\gamma)}\\ \\ .$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The prover <span class="math">\\mathbf{P}</span> sends to <span class="math">\\mathbf{V}</span> a random $\\hat{w}(X)\\in\\mathbb{F}^{<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathbf{b}}[X]<span class="math"> that agrees with </span>\\bar{w}<span class="math"> on </span>H[></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math">; </span>\\mathbf{P}<span class="math"> also sets </span>z:=(x,w)\\in\\mathbb{F}^{H}<span class="math"> to be the full assignment, computes the three linear combinations </span>z_{A}:=Az<span class="math">, </span>z_{B}:=Bz<span class="math">, and </span>z_{C}:=Cz<span class="math">, and sends to </span>\\mathbf{V}<span class="math"> random </span>\\hat{z}_{A}(X),\\hat{z}_{B}(X),\\hat{z}_{C}(X)\\in\\mathbb{F}^{<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathbf{b}}[X]<span class="math"> that agree with </span>z_{A},z_{B},z_{C}<span class="math"> on </span>H<span class="math">. Note that the values of up to </span>\\mathsf{b}<span class="math"> locations in each of </span>\\hat{w}(X),\\hat{z}_{A}(X),\\hat{z}_{B}(X),\\hat{z}_{C}(X)<span class="math"> reveal no information about the witness </span>w<span class="math">, provided the locations are in </span>\\mathbb{F}\\setminus H<span class="math">. Note also that </span>\\hat{z}(X):=\\hat{w}(X)v_{H[\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}(X)+\\hat{x}(X)<span class="math"> agrees with </span>z<span class="math"> on </span>H<span class="math">; moreover, </span>\\mathbf{V}<span class="math"> can evaluate </span>\\hat{z}(X)<span class="math"> at any location </span>\\gamma<span class="math"> with </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> operations by querying </span>\\hat{w}<span class="math"> at </span>\\gamma<span class="math"> and computing the expression </span>\\hat{w}(\\gamma)v_{H[\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}(\\gamma)+\\hat{x}(\\gamma)<span class="math"> by using </span>x$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The rest of the protocol is for <span class="math">\\mathbf{P}</span> to convince <span class="math">\\mathbf{V}</span> that <span class="math">z_{A}\\circ z_{B}=z_{C}</span> and also that <span class="math">z_{A},z_{B},z_{C}</span> are obtained as linear combinations from <span class="math">z</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the same message as above, <span class="math">\\mathbf{P}</span> also sends to <span class="math">\\mathbf{V}</span> the polynomial <span class="math">h_{0}(X)</span> such that <span class="math">\\hat{z}_{A}(X)\\hat{z}_{B}(X)-\\hat{z}_{C}(X)=h_{0}(X)v_{H}(X)</span>. In addition, <span class="math">\\mathbf{P}</span> sends to <span class="math">\\mathbf{V}</span> a (fully) random $s(X)\\in\\mathbb{F}^{<2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathbf{b}-1}[X]<span class="math"> and its sum </span>\\sigma_{1}:=\\sum_{\\kappa\\in H}s(\\kappa)<span class="math"> over </span>H$. This random polynomial will be used as a “mask” to make the univariate sumcheck zero knowledge.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, <span class="math">\\mathbf{V}</span> samples random elements <span class="math">\\alpha,\\eta_{A},\\eta_{B},\\eta_{C}\\in\\mathbb{F}</span> and sends them to <span class="math">\\mathbf{P}</span>. The element <span class="math">\\alpha</span> is used to reduce lincheck problems to sumcheck, while the elements <span class="math">\\eta_{A},\\eta_{B},\\eta_{C}</span> are used to bundle the three sumcheck problems into one. Indeed, <span class="math">\\mathbf{P}</span> is left to convince <span class="math">\\mathbf{V}</span> that the following univariate polynomial sums to <span class="math">\\sigma_{1}</span> on <span class="math">H</span>:</p>

    <p class="text-gray-300"><span class="math">q_{1}(X):=\\ s(X)+r(\\alpha,X)\\left(\\sum_{M\\in\\{A,B,C\\}}\\eta_{M}\\hat{z_{M}}(X)\\right)-\\left(\\sum_{M\\in\\{A,B,C\\}}\\eta_{M}r_{M}(\\alpha,X)\\right)\\hat{z}(X)</span> (6)</p>

    <p class="text-gray-300">where <span class="math">r_{M}(X,Y):=\\sum_{\\kappa\\in H}r(X,\\kappa)\\hat{M}(\\kappa,Y)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now rely on the univariate sumcheck protocol: <span class="math">\\mathbf{P}</span> sends to <span class="math">\\mathbf{V}</span> the polynomials <span class="math">g_{1}(X)</span> and <span class="math">h_{1}(X)</span> such that <span class="math">q_{1}(X)=h_{1}(X)v_{H}(X)+Xg_{1}(X)</span>. In order to check this polynomial identity, <span class="math">\\mathbf{V}</span> samples a random element <span class="math">\\beta_{1}\\in\\mathbb{F}\\setminus H</span> with the intention of checking the identity at <span class="math">X:=\\beta_{1}</span>. For the right-hand side, <span class="math">\\mathbf{V}</span> queries <span class="math">g_{1}</span> and <span class="math">h_{1}</span> at <span class="math">\\beta_{1}</span> and then evaluates <span class="math">h_{1}(\\beta_{1})v_{H}(\\beta_{1})+\\beta_{1}g_{1}(\\beta_{1})</span> in $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> operations. For the left-hand side, </span>\\mathbf{V}<span class="math"> queries </span>s,\\hat{z}_{A},\\hat{z}_{B},\\hat{z}_{C},\\hat{w}<span class="math"> at </span>\\beta_{1}<span class="math"> and then needs to ask help from </span>\\mathbf{P}<span class="math"> to evaluate </span>q_{1}(\\beta_{1})<span class="math">. The reason is that the term </span>\\eta_{A}r_{A}(\\alpha,\\beta_{1})+\\eta_{B}r_{B}(\\alpha,\\beta_{1})+\\eta_{C}r_{C}(\\alpha,\\beta_{1})<span class="math"> in general requires </span>\\Omega(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ operations to compute.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Observe that</p>

    <p class="text-gray-300"><span class="math">\\eta_{A}r_{A}(\\alpha,\\beta_{1})+\\eta_{B}r_{B}(\\alpha,\\beta_{1})+\\eta_{C}r_{C}(\\alpha,\\beta_{1})</span> <span class="math">=\\eta_{A}\\sum_{\\kappa\\in H}r(\\alpha,\\kappa)\\hat{A}(\\kappa,\\beta_{1})+\\eta_{B}\\sum_{\\kappa\\in H}r(\\alpha,\\kappa)\\hat{B}(\\kappa,\\beta_{1})+\\eta_{C}\\sum_{\\kappa\\in H}r(\\alpha,\\kappa)\\hat{C}(\\kappa,\\beta_{1})</span></p>

    <p class="text-gray-300"><span class="math">\\sum_{\\kappa\\in H}r(\\alpha,\\kappa)(\\eta_{A}\\hat{A}(\\kappa,\\beta_{1})+\\eta_{B}\\hat{B}(\\kappa,\\beta_{1})+\\eta_{C}\\hat{C}(\\kappa,\\beta_{1}))\\enspace.</span></p>

    <p class="text-gray-300">We define the polynomial</p>

    <p class="text-gray-300"><span class="math">q_{2}(X):=r(\\alpha,X)(\\eta_{A}\\hat{A}(X,\\beta_{1})+\\eta_{B}\\hat{B}(X,\\beta_{1})+\\eta_{C}\\hat{C}(X,\\beta_{1}))</span> (7)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and rely on the univariate sumcheck protocol again: <span class="math">\\mathbf{V}</span> sends <span class="math">\\beta_{1}</span> to <span class="math">\\mathbf{P}</span>, and then <span class="math">\\mathbf{P}</span> replies with the sum <span class="math">\\sigma_{2}:=\\sum_{\\kappa\\in H}q_{2}(\\kappa)</span> and the polynomials <span class="math">g_{2}(X)</span> and <span class="math">h_{2}(X)</span> such that $q_{2}(X)=h_{2}(X)v_{H}(X)+Xg_{2}(X)+\\sigma_{2}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. In order to check this polynomial identity, </span>\\mathbf{V}<span class="math"> samples a random element </span>\\beta_{2}\\in\\mathbb{F}\\setminus H<span class="math"> with the intention of checking the identity at </span>X:=\\beta_{2}<span class="math">. (Excluding </span>H<span class="math"> is needed later in the protocol, as discussed below.) For the right-hand side, </span>\\mathbf{V}<span class="math"> queries </span>g_{2}<span class="math"> and </span>h_{2}<span class="math"> at </span>\\beta_{2}<span class="math">, and then evaluates </span>h_{2}(\\beta_{2})v_{H}(\\beta_{2})+\\beta_{2}g_{2}(\\beta_{2})+\\sigma_{2}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> in </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> operations. To evaluate the left-hand side, however, </span>\\mathbf{V}<span class="math"> needs to ask help from </span>\\mathbf{P}<span class="math">. The reason is that while </span>r(\\alpha,\\beta_{2})<span class="math"> is easy to evaluate (it requires </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> operations), each term </span>\\bar{M}(\\beta_{2},\\beta_{1})<span class="math"> in general requires </span>\\Omega(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We thus rely on the univariate sumcheck protocol (yet) again: <span class="math">\\mathbf{V}</span> sends <span class="math">\\beta_{2}</span> to <span class="math">\\mathbf{P}</span>, and then <span class="math">\\mathbf{P}</span> replies with the value <span class="math">\\sigma_{3}:=\\eta_{A}\\hat{A}(\\beta_{2},\\beta_{1})+\\eta_{B}\\hat{B}(\\beta_{2},\\beta_{1})+\\eta_{C}\\hat{C}(\\beta_{2},\\beta_{1})</span>, which the verifier much check. Observe that</p>

    <p class="text-gray-300"><span class="math">\\eta_{A}\\hat{A}(\\beta_{2},\\beta_{1})+\\eta_{B}\\hat{B}(\\beta_{2},\\beta_{1})+\\eta_{C}\\hat{C}(\\beta_{2},\\beta_{1})=\\sum_{\\kappa\\in K}\\sum_{M\\in\\{A,B,C\\}}\\eta_{M}\\frac{v_{H}(\\beta_{2})v_{H}(\\beta_{1})\\hat{\\mathsf{val}}_{M}(\\kappa)}{(\\beta_{2}-\\mathsf{row}_{M}(\\kappa))(\\beta_{1}-\\hat{\\mathsf{col}}_{M}(\\kappa))}\\enspace.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Define <span class="math">f_{3}(X)</span> to be the (unique) polynomial of degree less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\forall\\,\\kappa\\in K\\,,\\;f_{3}(\\kappa)=\\sum_{M\\in\\{A,B,C\\}}\\eta_{M}\\frac{v_{H}(\\beta_{2})v_{H}(\\beta_{1})\\hat{\\mathsf{val}}_{M}(\\kappa)}{(\\beta_{2}-\\mathsf{row}_{M}(\\kappa))(\\beta_{1}-\\hat{\\mathsf{col}}_{M}(\\kappa))}\\enspace.</span> (8)</p>

    <p class="text-gray-300">The prover computes the polynomials <span class="math">g_{3}(X)</span> and <span class="math">h_{3}(X)</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$f_{3}(X)=Xg_{3}(X)+\\sigma_{3}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\quad\\text{and}\\quad a(X)-b(X)f_{3}(X)=h_{3}(X)v_{K}(X)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">a(X):=\\sum_{M\\in\\{A,B,C\\}}\\eta_{M}v_{H}(\\beta_{2})v_{H}(\\beta_{1})\\hat{\\mathsf{val}}_{M}(X)\\prod_{N\\in\\{A,B,C\\}\\setminus\\{M\\}}(\\beta_{2}-\\mathsf{row}_{N}(X))(\\beta_{1}-\\hat{\\mathsf{col}}_{N}(X))\\enspace,</span> <span class="math">b(X):=\\prod_{M\\in\\{A,B,C\\}}(\\beta_{2}-\\mathsf{row}_{M}(X))(\\beta_{1}-\\hat{\\mathsf{col}}_{M}(X))\\enspace.</span></p>

    <p class="text-gray-300">The first equation demonstrates that <span class="math">f_{3}</span> sums to <span class="math">\\sigma_{3}</span> over <span class="math">K</span>, and the second equation demonstrates that <span class="math">f_{3}</span> agrees with the correct addends over <span class="math">K</span>. These two equations can be combined in a single equation that involves only <span class="math">g_{3}(X)</span> and <span class="math">h_{3}(X)</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$a(X)-b(X)(Xg_{3}(X)+\\sigma_{3}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=h_{3}(X)v_{K}(X)\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The prover thus only sends the two polynomials <span class="math">g_{3}(X)</span> and <span class="math">h_{3}(X)</span>. In order to check this polynomial identity, <span class="math">\\mathbf{V}</span> samples a random element <span class="math">\\beta_{3}\\in\\mathbb{F}</span> with the intention of checking the identity at <span class="math">X:=\\beta_{3}</span>. Then <span class="math">\\mathbf{V}</span> queries <span class="math">g_{3}</span>, <span class="math">h_{3}</span>, <span class="math">\\{\\mathsf{row}_{M},\\hat{\\mathsf{col}}_{M},\\hat{\\mathsf{val}}_{M}\\}_{M\\in\\{A,B,C\\}}</span> at <span class="math">\\beta_{3}</span>, and checks the identity in $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If this third test passes then <span class="math">\\mathbf{V}</span> can use the value <span class="math">\\sigma_{3}</span> in place of <span class="math">\\sum_{M\\in\\{A,B,C\\}}\\eta_{M}\\hat{M}(\\beta_{2},\\beta_{1})</span> to finish the second test. If this latter passes, <span class="math">\\mathbf{V}</span> can in turn use the value <span class="math">\\sigma_{2}</span> in place of <span class="math">\\sum_{M\\in\\{A,B,C\\}}\\eta_{M}r_{M}(\\alpha,\\beta_{1})</span> to finish the first test.</p>

    <p class="text-gray-300">5.3.3 Analysis</p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">Soundness.</h4>

    <p class="text-gray-300">We argue that the soundness error is at most</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\max\\left\\{\\frac{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+2\\mathsf{b}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\,,\\,\\,\\frac{3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\frac{4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{b}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\setminus H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right\\}\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that for the given index <span class="math">\\mathbbm{i}=(\\mathbb{F},H,K,A,B,C)</span> and instance <span class="math">\\mathbbm{z}=x</span> there is no witness <span class="math">\\mathbbm{w}=w</span> such that <span class="math">Az\\circ Bz=Cz</span> for <span class="math">z:=(x,w)</span> is a vector in <span class="math">\\mathbb{F}^{H}</span>. In particular, this holds for the witness <span class="math">w</span> that is encoded in the polynomial <span class="math">\\hat{w}(X)</span> sent by the prover. Let <span class="math">z_{A},z_{B},z_{C}</span> be the vectors encoded in the polynomials <span class="math">\\hat{z}_{A}(X),\\hat{z}_{B}(X),\\hat{z}_{C}(X)</span> sent by the prover, respectively. We know that either <span class="math">z_{A}\\circ z_{B}\\neq z_{C}</span> or one of <span class="math">z_{A},z_{B},z_{C}</span> is not the correct linear combination of <span class="math">z</span>. In the first case, the polynomial identity <span class="math">\\hat{z}_{A}\\hat{z}_{B}-\\hat{z}_{C}=h_{0}v_{H}</span> does not hold, so the probability that the verifier still accepts is at most $(2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+2\\mathsf{b})/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. In the second case, we rely on the randomized reduction to sumcheck, which fails with probability at most </span>(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Next we have to account for the soundness errors of the three sequential sumchecks, which are bounded by the maximum degree in the respective polynomial equation divided by the size of the set from which the test point is chosen. Thus, the innermost sumcheck has soundness error at most </span>3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; the intermediate sumcheck has soundness error at most </span>2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\setminus H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">; the outermost sumcheck has soundness error at most </span>(2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{b})/(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\setminus H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">Proof of knowledge.</h4>

    <p class="text-gray-300">If the verifier accepts with probability greater than the soundness error argued above, then the prover’s polynomial <span class="math">\\hat{w}</span> must encode a valid witness <span class="math">w</span>.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">Zero knowledge.</h4>

    <p class="text-gray-300">We only sketch the intuition because a full proof (which includes constructing a simulator) is similar to the non-holographic setting described in <em>[x1]</em>. The first message of the prover includes an encoding of the witness and encodings of its linear combinations. These encodings are protected against up to <span class="math">\\mathsf{b}</span> queries outside of <span class="math">H</span> because the encodings are <span class="math">\\mathsf{b}</span>-wise independent over <span class="math">\\mathbb{F}\\setminus H</span>. The first message also includes the polynomial <span class="math">h_{0}(X)</span>, which in fact is <span class="math">\\mathsf{b}</span>-wise independent everywhere on <span class="math">\\mathbb{F}</span>. Subsequent messages from the prover do not reveal any further information because they are produced for a sumcheck instance that is shifted by a random polynomial (the polynomial <span class="math">s(X)</span>). This leads to (perfect) zero knowledge with query bound <span class="math">\\mathsf{b}</span> and a query checker <span class="math">\\mathbf{C}</span> that rejects any query to any of <span class="math">\\hat{w}(X),\\hat{z}_{A}(X),\\hat{z}_{B}(X),\\hat{z}_{C}(X)</span> that lies in <span class="math">H</span>.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Efficiency.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The indexer computes and outputs a constant number of polynomials of degree less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, using time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The subsequent protocol between the prover and verifier consists of 7 messages, with the prover moving first. The verifier makes a constant number of queries, evaluates </span>\\hat{x},v_{H},v_{K}<span class="math"> at a constant number of locations, and then performs a constant number of field operations. Thus, verifier time is </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The prover sends a constant number of polynomials whose degree is linearly related to </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{b}<span class="math"> or </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. In the first round, the prover computes the linear combinations </span>Az,Bz,Cz<span class="math"> and interpolates them, which can be done in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{b})\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{b}))<span class="math">; in the second round, the prover finds the coefficients of the polynomials </span>g_{1}(X)<span class="math"> and </span>h_{1}(X)<span class="math"> in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{b})\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{b}))<span class="math">, similarly to the proof of Lemma 5.5; in the third round, the prover finds the sum </span>\\sigma_{2}<span class="math"> and the coefficients of </span>g_{2}(X)<span class="math"> and </span>h_{2}(X)<span class="math"> in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, similarly to the proof of Lemma 5.6; and in the final round, the prover finds the sum </span>\\sigma_{3}<span class="math"> and the coefficients of </span>g_{3}(X)<span class="math"> and </span>h_{3}(X)<span class="math"> in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, similarly to the proof of Lemma 5.7. Thus, prover time is </span>O((</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{b})\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{b})+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, which is </span>O((</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{b})\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{b}))<span class="math"> since </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ (see Remark 5.3).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathcal{P}(\\mathbb{F},H,K,M,f_1,f_2)</p>

    <p class="text-gray-300">\\mathcal{V}^{f_1,f_2,\\mathrm{row},\\mathrm{col},\\mathrm{val}}(\\mathbb{F},H,K)</p>

    <p class="text-gray-300"><span class="math">\\alpha \\in \\mathbb{F}</span></p>

    <p class="text-gray-300"><span class="math">\\alpha \\gets \\mathbb{F}</span></p>

    <p class="text-gray-300">sumcheck for  <span class="math">r(\\alpha, X)f_1(X) - \\overline{r_M(\\alpha, X)}f_2(X)</span>  over  <span class="math">H</span></p>

    <p class="text-gray-300">to evaluate  <span class="math">\\sum_{\\kappa \\in H}r(\\alpha ,\\kappa)f_1(\\kappa) - r_M(\\alpha ,\\kappa)f_2(\\kappa)</span></p>

    <p class="text-gray-300">find  <span class="math">g_{1}(X)</span>  and  <span class="math">h_1(X)</span>  such that</p>

    <p class="text-gray-300"><span class="math">r(\\alpha ,X)f_{1}(X) - r_{M}(\\alpha ,X)f_{2}(X)</span></p>

    <p class="text-gray-300"><span class="math">= h_{1}(X)v_{H}(X) + Xg_{1}(X)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{g_1 \\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}[X], h_1 \\in \\mathbb{F}^{&lt;d-1}[X]}{\\beta_1 \\in \\mathbb{F}}<span class="math"> </span>\\beta_1 \\gets \\mathbb{F} \\setminus H$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">sumcheck for  <span class="math">r(\\alpha, X)\\hat{M}(X, \\beta_1)</span>  over  <span class="math">H</span></p>

    <p class="text-gray-300">to evaluate  <span class="math">r_M(\\alpha, \\beta_1) = \\sum_{\\kappa \\in H} r(\\alpha, \\kappa) \\hat{M}(\\kappa, \\beta_1)</span></p>

    <p class="text-gray-300">compute sum  <span class="math">\\sigma_{2} := \\sum_{\\kappa \\in H} r(\\alpha, \\kappa) \\hat{M}(\\kappa, \\beta_{1})</span></p>

    <p class="text-gray-300">and find  <span class="math">g_{2}(X)</span>  and  <span class="math">h_2(X)</span>  such that</p>

    <p class="text-gray-300"><span class="math">r(\\alpha ,X)\\hat{M} (X,\\beta_1)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$= h_{2}(X)v_{H}(X) + Xg_{2}(X) + \\sigma_{2} /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sigma_{2}\\in \\mathbb{F},g_{2},h_{2}\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}[X]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\beta_{2}\\in \\mathbb{F}</span></p>

    <p class="text-gray-300"><span class="math">\\beta_{2}\\gets \\mathbb{F}\\setminus H</span></p>

    <p class="text-gray-300">sumcheck for  <span class="math">\\frac{v_H(\\beta_2)v_H(\\beta_1)\\hat{\\mathrm{val}}(X)}{(\\beta_2 - \\mathrm{row}(X))(\\beta_1 - \\mathrm{col}(X))}</span>  over  <span class="math">K</span></p>

    <p class="text-gray-300">to evaluate  <span class="math">\\hat{M} (\\beta_2,\\beta_1) = \\sum_{\\kappa \\in K}\\frac{v_H(\\beta_2)v_H(\\beta_1)\\hat{\\mathrm{val}} (\\kappa)}{(\\beta_2 - \\mathrm{row}(\\kappa))(\\beta_1 - \\mathrm{col}(\\kappa))}</span></p>

    <p class="text-gray-300">compute sum  <span class="math">\\sigma_{3} := \\sum_{\\kappa \\in K} \\frac{v_{H}(\\beta_{2}) v_{H}(\\beta_{1}) \\hat{\\mathrm{val}}(\\kappa)}{(\\beta_{2} - \\mathrm{row}(\\kappa)) (\\beta_{1} - \\mathrm{col}(\\kappa))}</span></p>

    <p class="text-gray-300">and find  <span class="math">g_{3}(X)</span>  and  <span class="math">h_3(X)</span>  such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$v_{H}(\\beta_{2})v_{H}(\\beta_{1})\\hat{\\mathrm{val}} (X) - (\\beta_{2} - \\mathrm{row}(X))(\\beta_{1} - \\hat{\\mathrm{col}} (X))(Xg_{3}(X) + \\sigma_{3} /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">= h_{3}(X)v_{K}(X)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sigma_{3}\\in \\mathbb{F},g_{3}\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}[X],h_{3}\\in \\mathbb{F}^{&lt;  2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2}[X]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\beta_{3}\\gets \\mathbb{F}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$v_{H}(\\beta_{2})v_{H}(\\beta_{1})\\hat{\\mathrm{val}} (\\beta_{3}) - (\\beta_{2} - \\mathrm{row}(\\beta_{3}))(\\beta_{1} - \\hat{\\mathrm{col}} (\\beta_{3}))(\\beta_{3}g_{3}(\\beta_{3}) + \\sigma_{3} /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\stackrel{?}{=} h_{3}(\\beta_{3})v_{K}(\\beta_{3})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$r(\\alpha ,\\beta_2)\\sigma_3\\stackrel {?}{=}h_2(\\beta_2)v_H(\\beta_2) + \\beta_2g_2(\\beta_2) + \\sigma_2 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">r(\\alpha ,\\beta_1)f_1(\\beta_1) - \\sigma_2f_2(\\beta_1)\\stackrel {?}{=}h_1(\\beta_1)v_H(\\beta_1) + \\beta_1g_1(\\beta_1)</span></p>

    <p class="text-gray-300">Figure 4: AHP for the lincheck problem.</p>

    <p class="text-gray-300">\\mathcal{P}(\\mathbb{F},H,K,A,B,C,x,w)</p>

    <p class="text-gray-300">\\mathcal{V}^{\\mathrm{row}\\{A,B,C\\}},\\overleftrightarrow{\\mathrm{col}}\\{A,B,C\\},\\overleftrightarrow{\\mathrm{val}}\\{A,B,C\\}}(\\mathbb{F},H,K,x)</p>

    <p class="text-gray-300"><span class="math">z\\coloneqq (x,w)</span> <span class="math">z_{A}\\coloneqq Az</span> <span class="math">z_{B}\\coloneqq Bz</span> <span class="math">z_{C}\\coloneqq Cz</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sample  $\\hat{w} (X)\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{b}}[X]<span class="math">  and  </span>\\hat{z}_A(X),\\hat{z}_B(X),\\hat{z}_C(X)\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{b}}[X]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">find  <span class="math">h_0(X)</span>  s.t.  <span class="math">\\hat{z}_A(X)\\hat{z}_B(X) - \\hat{z}_C(X) = h_0(X)v_H(X)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sample  $s(X)\\in \\mathbb{F}^{&lt; 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{b} - 1}[X]<span class="math">  and compute sum  </span>\\sigma_{1}\\coloneqq \\sum_{\\kappa \\in H}s(\\kappa)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sigma_{1}\\in \\mathbb{F},\\hat{w}\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{b}}[X],\\hat{z}_{A},\\hat{z}_{B},\\hat{z}_{C}\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{b}}[X],$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$h_0\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2\\mathsf{b} - 1}[X],s\\in \\mathbb{F}^{&lt;  2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{b} - 1}[X]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\alpha ,\\eta_{A},\\eta_{B},\\eta_{C}\\in \\mathbb{F}</span></p>

    <p class="text-gray-300">sumcheck for  <span class="math">s(X) + r(\\alpha, X)(\\sum_{M} \\eta_{M} z_{M}^{-}(X)) - (\\sum_{M} \\eta_{M} r_{M}(\\alpha, X)) \\hat{z}(X)</span>  over  <span class="math">H</span></p>

    <p class="text-gray-300">find  <span class="math">g_{1}(X)</span>  and  <span class="math">h_1(X)</span>  such that</p>

    <p class="text-gray-300"><span class="math">s(X) + r(\\alpha ,X)(\\sum_{M}\\eta_{M}z_{M}^{-}(X)) - (\\sum_{M}\\eta_{M}r_{M}(\\alpha ,X))\\hat{z} (X)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$= h_{1}(X)v_{H}(X) + Xg_{1}(X) + \\sigma_{1} /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$g_{1}\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}[X],h_{1}\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ b - 1}[X]\\longrightarrow$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\beta_{1}\\gets \\mathbb{F}\\setminus H</span></p>

    <p class="text-gray-300"><span class="math">\\sigma_{2}:= \\sum_{\\kappa \\in H}r(\\alpha ,\\kappa)\\sum_{M\\in \\{A,B,C\\}}\\eta_{M}\\hat{M} (\\kappa ,\\beta_{1})</span></p>

    <p class="text-gray-300">and find  <span class="math">g_{2}(X)</span>  and  <span class="math">h_2(X)</span>  such that</p>

    <p class="text-gray-300"><span class="math">r(\\alpha ,X)\\sum_{M\\in \\{A,B,C\\}}\\eta_M\\hat{M} (X,\\beta_1)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$= h_{2}(X)v_{H}(X) + Xg_{2}(X) + \\sigma_{2} /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sigma_{2}\\in \\mathbb{F},g_{2},h_{2}\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}[X]\\longrightarrow$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\beta_{2}\\gets \\mathbb{F}\\setminus H</span></p>

    <p class="text-gray-300"><span class="math">\\sigma_{3}:= \\sum_{\\kappa \\in K}\\sum_{M\\in \\{A,B,C\\}}\\eta_{M}\\frac{v_{H}(\\beta_{2})v_{H}(\\beta_{1})\\hat{\\mathsf{val}}_{M}(X)}{(\\beta_{2} - \\mathsf{row}_{M}(X))(\\beta_{1} - \\mathsf{col}_{M}(X))}</span>  over  <span class="math">K</span></p>

    <p class="text-gray-300">to evaluate  <span class="math">\\eta_A\\hat{A} (\\beta_2,\\beta_1) + \\eta_B\\hat{B} (\\beta_2,\\beta_1) + \\eta_C\\hat{C} (\\beta_2,\\beta_1)</span></p>

    <p class="text-gray-300"><span class="math">\\sigma_{3}:= \\sum_{\\kappa \\in K}\\sum_{M\\in \\{A,B,C\\}}\\eta_{M}\\frac{v_{H}(\\beta_{2})v_{H}(\\beta_{1})\\hat{\\mathsf{val}}_{M}(\\kappa)}{(\\beta_{2} - \\mathsf{row}_{M}(\\kappa))(\\beta_{1} - \\mathsf{col}_{M}(\\kappa))}</span></p>

    <p class="text-gray-300">and find  <span class="math">g_{3}(X)</span>  and  <span class="math">h_3(X)</span>  such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$h_3(X)v_K(X) = a(X) - b(X)(Xg_3(X) + \\sigma_3 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sigma_{3}\\in \\mathbb{F},g_{3}\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}[X],h_{3}\\in \\mathbb{F}^{&lt;  6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 6}[X]\\longrightarrow<span class="math"> </span>\\beta_{3}\\gets \\mathbb{F}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$h_3(\\beta_3)v_K(\\beta_3)\\stackrel {?}{=}a(\\beta_3) - b(\\beta_3)(\\beta_3g_3(\\beta_3) + \\sigma_3 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The polynomials  <span class="math">a(X), b(X)</span>  are defined as follows:</p>

    <p class="text-gray-300"><span class="math">a(X)\\coloneqq \\sum_{M\\in \\{A,B,C\\}}\\eta_{M}v_{H}(\\beta_{2})v_{H}(\\beta_{1})\\hat{\\mathsf{val}}_{M}(X)\\prod_{N\\in \\{A,B,C\\} \\setminus \\{M\\}}(\\beta_{2} - \\mathsf{row}_{N}(X))(\\beta_{1} - \\mathsf{col}_{N}(X))</span></p>

    <p class="text-gray-300"><span class="math">b(X)\\coloneqq \\prod_{M\\in \\{A,B,C\\}}(\\beta_2 - \\mathsf{row}_M(X))(\\beta_1 - \\mathsf{col}_M(X))</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$r(\\alpha ,\\beta_2)\\sigma_3\\stackrel {?}{=}h_2(\\beta_2)v_H(\\beta_2) + \\beta_2g_2(\\beta_2) + \\sigma_2 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">s(\\beta_1) + r(\\alpha, \\beta_1)(\\sum_M \\eta_M z_M^-( \\beta_1)) - \\sigma_2 \\hat{z}(\\beta_1)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\stackrel{?}{=} h_1(\\beta_1)v_H(\\beta_1) + \\beta_1g_1(\\beta_1) + \\sigma_1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\hat{z}_A(\\beta_1)\\hat{z}_B(\\beta_1) - \\hat{z}_C(\\beta_1)\\stackrel {?}{=}h_0(\\beta_1)v_H(\\beta_1)</span></p>

    <p class="text-gray-300">Figure 5: AHP for R1CS.</p>

    <p class="text-gray-300">6 Polynomial commitment schemes with extractability</p>

    <p class="text-gray-300">We use polynomial commitment schemes, a class of commitment schemes specialized to work with univariate polynomials. This notion was introduced by Kate, Zaverucha, and Goldberg <em>[x10]</em>, who gave an elegant construction using bilinear groups. The security properties in <em>[x10]</em>, however, do not appear sufficient for standalone use (nor for use in this paper). This limitation was recently noted in <em>[x14]</em>, which relies on a different construction for which certain properties are proved in the algebraic group model <em>[x6]</em>. However, <em>[x14]</em> stops short of formulating a cryptographic primitive that captures the features of the construction.</p>

    <p class="text-gray-300">In this section we propose definitions for polynomial commitment schemes that incorporate the functionality and security that we believe to be a bare minimum for standalone use. (In particular, in Section 8 we generically rely on these definitions to build preprocessing arguments with universal SRS.) We also describe a “knowledge” variant of the construction in <em>[x10]</em>, which we prove secure under knowledge of exponent assumptions. To learn more about the insights motivating our definitions, we refer the reader back to Section 2.2.</p>

    <p class="text-gray-300">The rest of this section is organized as follows. In Section 6.1 we present the definitions that we propose. In Section 6.2 we provide a theorem statement for constructions that realize the definitions, and then sketch these constructions. We formal descriptions of the constructions are in Appendices B to C.</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">6.1 Definition</h3>

    <p class="text-gray-300">A polynomial commitment scheme over a field family <span class="math">\\mathcal{F}</span> is a tuple of algorithms <span class="math">\\mathsf{PC}=(\\mathsf{Setup},\\mathsf{Trim},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Check})</span> with the following syntax.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{PC}.{\\mathsf{Setup}}(1^{\\lambda},D)\\to\\mathsf{pp}</span>. On input a security parameter <span class="math">\\lambda</span> (in unary), and a maximum degree bound <span class="math">D\\in\\mathbb{N}</span>, <span class="math">\\mathsf{PC}.{\\mathsf{Setup}}</span> samples public parameters <span class="math">\\mathsf{pp}</span>. The parameters contain the description of a finite field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span>.</li>

      <li><span class="math">\\mathsf{PC}.{\\mathsf{Trim}}^{\\mathsf{pp}}(1^{\\lambda},\\bm{d})\\to(\\mathsf{ck},\\mathsf{rk})</span>. Given oracle access to public parameters <span class="math">\\mathsf{pp}</span>, and on input a security parameter <span class="math">\\lambda</span> (in unary), and degree bounds <span class="math">\\bm{d}</span>, <span class="math">\\mathsf{PC}.{\\mathsf{Trim}}</span> deterministically computes a key pair <span class="math">(\\mathsf{ck},\\mathsf{rk})</span> that is specialized to <span class="math">\\bm{d}</span>.</li>

      <li><span class="math">\\mathsf{PC}.{\\mathsf{Commit}}(\\mathsf{ck},\\bm{p},\\bm{d};\\bm{\\omega})\\to\\bm{c}</span>. On input <span class="math">\\mathsf{ck}</span>, univariate polynomials <span class="math">\\bm{p}=[p_{i}]_{i=1}^{n}</span> over the field <span class="math">\\mathbb{F}</span>, and degree bounds <span class="math">\\bm{d}=[d_{i}]_{i=1}^{n}</span> with <span class="math">\\deg(p_{i})\\leq d_{i}\\leq D</span>, <span class="math">\\mathsf{PC}.{\\mathsf{Commit}}</span> outputs commitments <span class="math">\\bm{c}=[c_{i}]_{i=1}^{n}</span> to the polynomials <span class="math">\\bm{p}=[p_{i}]_{i=1}^{n}</span>. The randomness <span class="math">\\bm{\\omega}=[\\omega_{i}]_{i=1}^{n}</span> is used if the commitments <span class="math">\\bm{c}=[c_{i}]_{i=1}^{n}</span> are hiding.</li>

      <li><span class="math">\\mathsf{PC}.{\\mathsf{Open}}(\\mathsf{ck},\\bm{p},\\bm{d},Q,\\xi;\\bm{\\omega})\\to\\pi</span>. On input <span class="math">\\mathsf{ck}</span>, univariate polynomials <span class="math">\\bm{p}=[p_{i}]_{i=1}^{n}</span>, degree bounds <span class="math">\\bm{d}=[d_{i}]_{i=1}^{n}</span>, a query set <span class="math">Q</span> consisting of tuples <span class="math">(i,z)\\in[n]\\times\\mathbb{F}</span>, and opening challenge <span class="math">\\xi</span>, <span class="math">\\mathsf{PC}.{\\mathsf{Open}}</span> outputs an evaluation proof <span class="math">\\pi</span>. The randomness <span class="math">\\bm{\\omega}</span> must equal the one previously used in <span class="math">\\mathsf{PC}.{\\mathsf{Commit}}</span>.</li>

      <li><span class="math">\\mathsf{PC}.{\\mathsf{Check}}(\\mathsf{rk},\\bm{c},\\bm{d},Q,\\bm{v},\\pi,\\xi)\\in\\{0,1\\}</span>. On input <span class="math">\\mathsf{rk}</span>, commitments <span class="math">\\bm{c}=[c_{i}]_{i=1}^{n}</span>, degree bounds <span class="math">\\bm{d}=[d_{i}]_{i=1}^{n}</span>, query set <span class="math">Q</span> consisting of tuples <span class="math">(i,z)\\in[n]\\times\\mathbb{F}</span>, alleged evaluations <span class="math">\\bm{v}=(v_{(i,z)})_{(i,z)\\in Q}</span>, evaluation proof <span class="math">\\pi</span>, and opening challenge <span class="math">\\xi</span>, <span class="math">\\mathsf{PC}.{\\mathsf{Check}}</span> outputs <span class="math">1</span> if <span class="math">\\pi</span> attests that, for every <span class="math">(i,z)\\in Q</span>, the polynomial <span class="math">p_{i}</span> committed in <span class="math">c_{i}</span> has degree at most <span class="math">d_{i}</span> and evaluates to <span class="math">v_{(i,z)}</span> at <span class="math">z</span>.</li>

    </ul>

    <p class="text-gray-300">A polynomial commitment scheme <span class="math">\\mathsf{PC}</span> must satisfy the completeness and extractability properties defined below. We also consider two additional properties, efficiency and hiding, also defined below. To simplify notation, we denote by <span class="math">\\deg(\\bm{p})</span> the degrees <span class="math">[\\deg(p_{i})]_{i=1}^{n}</span> of polynomials <span class="math">\\bm{p}=[p_{i}]_{i=1}^{n}</span>, and denote by <span class="math">\\bm{p}(Q)</span> the evaluations <span class="math">(p_{i}(z))_{(i,z)\\in Q}</span> of the polynomials <span class="math">\\bm{p}=[p_{i}]_{i=1}^{n}</span> at a query set <span class="math">Q\\subseteq[n]\\times\\mathbb{F}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Definition 6.1 (Completeness). For every maximum degree bound  <span class="math">D \\in \\mathbb{N}</span>  and efficient adversary  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} \\deg (\\boldsymbol {p}) \\leq \\boldsymbol {d} \\leq D &amp;amp; \\text {p p} \\leftarrow \\operatorname {P C. S e t u p} (1 ^ {\\lambda}, D) \\\\ \\Downarrow &amp;amp; (\\boldsymbol {p}, \\boldsymbol {d}, Q, \\xi , \\omega) \\leftarrow \\mathcal {A} (\\operatorname {p p}) \\\\ \\operatorname {P C. C h e c k} (\\operatorname {r k}, \\boldsymbol {c}, \\boldsymbol {d}, Q, \\boldsymbol {v}, \\pi , \\xi) = 1 &amp;amp; (\\operatorname {c k}, \\operatorname {r k}) \\leftarrow \\operatorname {P C. T r i m} ^ {\\operatorname {p p}} (1 ^ {\\lambda}, \\boldsymbol {d}) \\\\ &amp;amp; \\boldsymbol {c} \\leftarrow \\operatorname {P C. C o m m i t} (\\operatorname {c k}, \\boldsymbol {p}, \\boldsymbol {d}; \\boldsymbol {\\omega}) \\\\ &amp;amp; \\boldsymbol {v} \\leftarrow \\boldsymbol {p} (Q) \\\\ &amp;amp; \\pi \\leftarrow \\operatorname {P C. O p e n} (\\operatorname {c k}, \\boldsymbol {p}, \\boldsymbol {d}, Q, \\xi ; \\boldsymbol {\\omega}) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Definition 6.2 (Extractability). For every maximum degree bound  <span class="math">D \\in \\mathbb{N}</span>  and efficient adversary  <span class="math">\\mathcal{A}</span>  there exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that for every round bound  <span class="math">r \\in \\mathbb{N}</span> , efficient public-coin challenger  <span class="math">\\mathcal{C}</span>  (each of its messages is a uniformly random string of prescribed length, or an empty string), efficient query sampler  <span class="math">\\mathcal{Q}</span> , and efficient adversary  <span class="math">\\mathcal{B} = (\\mathcal{B}_1, \\mathcal{B}_2)</span>  the probability below is negligibly close to 1 (as a function of  <span class="math">\\lambda</span> ):</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PP←PC.Setup(1λ,D)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| For i=1,...,r: ρi←C(pp,i) (ci,di)←A(pp, [ρj]rj=1) pi←E(pp, [ρj]rj=1) |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PC.Check(rk,c,d,Q,v,π,ξ)=1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q←Q(pp, [ρj]rj=1) (v,st)←B1(pp, [ρj]rj=1,Q)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">deg(p)≤d≤D and v=p(Q)</td>

            <td class="px-3 py-2 border-b border-gray-700">Set [ci]i=1n := [ci]r=1, [pi]i=1n := [pi]r=1, [di]i=1n := [di]i=1n (ck,rk)←PC.Trimpp(1λ, [di]i=1n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Define the set of queried polynomials T := {i∈[n]</td>

            <td class="px-3 py-2 border-b border-gray-700">(i,z)∈Q}</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  | Set c := [ci]i∈T, p := [pi]i∈T, d := [di]i∈T |</p>

    <p class="text-gray-300">(The above definition captures the case where  <span class="math">\\mathcal{A},\\mathcal{Q},\\mathcal{B}</span>  share the same random string to win the game.)</p>

    <p class="text-gray-300">Definition 6.3 (Efficiency). We say that a polynomial commitment scheme PC is:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- degree-efficient if the time to run PC. Commit and PC. Open is proportional to the maximum degree  <span class="math">\\max(d)</span>  (as opposed to the maximum supported degree  <span class="math">D</span> ). In particular this implies that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{ck}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= O_{\\lambda}(\\max(d))$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 6.4 (Hiding). There exists a polynomial-time simulator  <span class="math">S =</span>  (Setup, Commit, Open) such that, for every maximum degree bound  <span class="math">D \\in \\mathbb{N}</span> , and efficient adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2, \\mathcal{A}_3)</span> , the probability that  <span class="math">b = 1</span>  in the following two experiments is identical:</p>

    <p class="text-gray-300">Real  <span class="math">(1^{\\lambda},D,\\mathcal{A})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp}\\gets \\mathsf{PC}.Setup(1^{\\lambda},D)</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Letting  <span class="math">c_0 \\coloneqq \\bot</span> , for  <span class="math">i = 1, \\ldots, r</span> :</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">(\\pmb {p}_i,\\pmb {d}_i,\\mathsf{h}_i)\\gets \\mathcal{A}_1(\\mathsf{pp},\\pmb {c}_0,\\pmb {c}_1,\\dots ,\\pmb {c}_{i - 1}).</span></p>

    <p class="text-gray-300">(b)  <span class="math">(\\mathrm{ck}_i,\\mathrm{rk}_i)\\gets \\mathrm{PC}.\\mathrm{Trim}^{\\mathrm{pp}}(1^{\\lambda},\\pmb {d}_i).</span></p>

    <p class="text-gray-300">(c) If  <span class="math">h_i = 0</span> : sample commitment randomness  <span class="math">\\omega_i</span> .</p>

    <p class="text-gray-300">(d) If  <span class="math">h_i = 1</span> : set randomness  <span class="math">\\omega_i</span>  to  <span class="math">\\bot</span> .</p>

    <p class="text-gray-300">(e)  <span class="math">c_{i}\\gets \\mathsf{PC}.Commit(\\mathsf{ck}_{i},\\pmb {p}_{i},\\pmb {d}_{i};\\omega_{i})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pmb{c} \\coloneqq [\\pmb{c}_i]_{i=1}^r, \\pmb{p} \\coloneqq [\\pmb{p}_i]_{i=1}^r, \\pmb{d} \\coloneqq [\\pmb{d}_i]_{i=1}^r, \\pmb{\\omega} \\coloneqq [\\pmb{\\omega}_i]_{i=1}^r.</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{ck},\\mathrm{rk})\\gets \\mathrm{PC}.\\mathrm{Trim}^{\\mathrm{pp}}(1^{\\lambda},\\pmb {d}).</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">([Q_j]_{j = 1}^r,[\\xi_j]_{j = 1}^r,\\mathsf{st})\\gets \\mathcal{A}_2(\\mathsf{pp},\\pmb {c}).</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">j \\in [\\tau]</span> :</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\pi_j \\gets \\mathsf{PC}. \\mathsf{Open}(\\mathsf{ck}, \\pmb{p}, \\pmb{d}, Q_j, \\xi_j; \\omega)</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b\\gets \\mathcal{A}_3(\\mathsf{st},[\\pi ]_{j = 1}^r)</span></li>

    </ol>

    <p class="text-gray-300">Ideal  <span class="math">(1^{\\lambda},D,\\mathcal{A})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{pp},\\mathsf{trap})\\gets S.\\mathsf{Setup}(1^{\\lambda},D).</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Letting  <span class="math">c_0 \\coloneqq \\bot</span> , for  <span class="math">i = 1, \\ldots, r</span> :</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">(\\pmb {p}_i,\\pmb {d}_i,\\mathsf{h}_i)\\gets \\mathcal{A}_1(\\mathsf{pp},\\pmb {c}_0,\\pmb {c}_1,\\dots ,\\pmb {c}_{i - 1}).</span></p>

    <p class="text-gray-300">(b)  <span class="math">(\\mathrm{ck}_i,\\mathrm{rk}_i)\\gets \\mathrm{PC}.\\mathrm{Trim}^{\\mathrm{pp}}(1^\\lambda ,\\pmb {d}_i).</span></p>

    <p class="text-gray-300">(c) If  <span class="math">\\mathsf{h}_i = 0</span> : sample randomness  <span class="math">\\omega_i</span>  and compute simulated commitments  <span class="math">c_i \\gets S</span> . Commit(trap,  <span class="math">d_i; \\omega_i</span> ).</p>

    <p class="text-gray-300">(d) If  <span class="math">\\mathsf{h}_i = 1</span> : set  <span class="math">\\omega_i \\coloneqq \\bot</span>  and compute (real) commitments  <span class="math">c_i \\gets \\mathsf{PC}.Commit(\\mathsf{ck}_i, \\pmb{p}_i, \\pmb{d}_i; \\omega_i)</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pmb{c} \\coloneqq [\\pmb{c}_i]_{i=1}^r, \\pmb{p} \\coloneqq [\\pmb{p}_i]_{i=1}^r, \\pmb{d} \\coloneqq [\\pmb{d}_i]_{i=1}^r, \\pmb{\\omega} \\coloneqq [\\pmb{\\omega}_i]_{i=1}^r.</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{ck},\\mathrm{rk})\\gets \\mathrm{PC}.\\mathrm{Trim}^{\\mathrm{pp}}(1^{\\lambda},\\pmb {d}).</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">([Q_j]_{j=1}^r, [\\xi_j]_{j=1}^r, \\mathsf{st}) \\gets \\mathcal{A}_2(\\mathsf{pp}, \\mathbf{c})</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Zero out hidden polynomials:  <span class="math">\\pmb{p}^{\\prime} \\coloneqq [\\mathsf{h}_{i}\\pmb{p}_{i}]_{i = 1}^{r}</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">j \\in [\\tau]</span> :</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\pi_j \\gets S. \\text{Open}(\\text{trap}, \\boldsymbol{p}&#x27;, \\boldsymbol{p}(Q_j), \\boldsymbol{d}, Q_j, \\xi_j; \\omega)</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b\\gets \\mathcal{A}_3(\\mathsf{st},[\\pi ]_{j = 1}^r)</span></li>

    </ol>

    <p class="text-gray-300">(We implicitly assume that  <span class="math">\\mathcal{A}_1</span>  outputs poly  <span class="math">(\\lambda)</span>  polynomials overall and that  <span class="math">\\mathcal{A}_2</span>  outputs poly  <span class="math">(\\lambda)</span>  query sets each consisting of poly  <span class="math">(\\lambda)</span>  points, ensuring that  <span class="math">\\mathrm{PC_s}</span> . Commit,  <span class="math">\\mathrm{PC_s}</span> . Open, S. Commit, S. Open are efficient.)</p>

    <p class="text-gray-300">The theorem below states the properties of our constructions. For simplicity, our construction are restricted to work with respect to "admissible" query samplers.</p>

    <p class="text-gray-300">Definition 6.5. A query sampler  <span class="math">\\mathcal{Q}</span>  is admissible if it outputs query sets such that each polynomial to be evaluated is evaluated at a point sampled uniformly at random from a super-polynomially large subset of the field, and possibly also at other points that can be arbitrarily chosen.</p>

    <p class="text-gray-300">Theorem 6.6. There exist succinct polynomial commitment schemes that: (a) achieve extractability against admissible query samplers under knowledge assumptions, or in the algebraic group model; (b) achieve hiding; and (c) have an updatable SRS. See Table 2 for the efficiency of these schemes under these assumptions.</p>

    <p class="text-gray-300">We note that the restriction to admissible query samplers is minor because one can transform an arbitrary query sampler  <span class="math">\\mathcal{Q}</span>  into an admissible query sampler  <span class="math">\\mathcal{Q}&#x27;</span>  as follows:  <span class="math">\\mathcal{Q}&#x27;</span>  invokes  <span class="math">\\mathcal{Q}</span>  to obtain a query set  <span class="math">Q</span> , and then outputs  <span class="math">Q&#x27; := Q \\cup \\{(i, t)\\}_{i \\in [n]}</span> , where  <span class="math">t \\in \\mathbb{F}</span>  is a random field element and  <span class="math">n</span>  is the number of polynomials. This transformation yields evaluation proofs that are twice as a large, a minor cost. That said, this transformation is often not even needed because "natural" query samplers are often already admissible, as is the case for those that we consider in this paper.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 6: Our approach to construct polynomial commitment schemes.</p>

    <p class="text-gray-300">The constructions behind Theorem 6.6 are achieved in three steps, as summarized in Fig. 6. The rest of this section is organized in three parts sketching these three steps respectively: (1) opening multiple polynomials with the same degree bound at a single point; (2) opening multiple polynomials with multiple degree bounds at a single point; (3) opening multiple polynomials with multiple degree bounds at multiple points. Detailed descriptions, along with security proofs, are provided in the corresponding appendices.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">assumption</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">hiding</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">communication complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ck</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">rk</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ci</td>

            <td class="px-3 py-2 border-b border-gray-700">i=1n</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Setup</td>

            <td class="px-3 py-2 border-b border-gray-700">Commit</td>

            <td class="px-3 py-2 border-b border-gray-700">Open</td>

            <td class="px-3 py-2 border-b border-gray-700">Check</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PKE</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

            <td class="px-3 py-2 border-b border-gray-700">2d G1</td>

            <td class="px-3 py-2 border-b border-gray-700">2 G2</td>

            <td class="px-3 py-2 border-b border-gray-700">4n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G1</td>

            <td class="px-3 py-2 border-b border-gray-700">2 f-MSM(D)</td>

            <td class="px-3 py-2 border-b border-gray-700">4n v-MSM(d)</td>

            <td class="px-3 py-2 border-b border-gray-700">1 v-MSM(d)</td>

            <td class="px-3 py-2 border-b border-gray-700">2 v-MSM(2n) + 4 pairings</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">dPKE</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">4d G1</td>

            <td class="px-3 py-2 border-b border-gray-700">2 G2</td>

            <td class="px-3 py-2 border-b border-gray-700">4n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G1 + 1 Fq</td>

            <td class="px-3 py-2 border-b border-gray-700">4 f-MSM(D)</td>

            <td class="px-3 py-2 border-b border-gray-700">8n v-MSM(d)</td>

            <td class="px-3 py-2 border-b border-gray-700">2 v-MSM(d)</td>

            <td class="px-3 py-2 border-b border-gray-700">2 v-MSM(2n) + 4 pairings</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AGM</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

            <td class="px-3 py-2 border-b border-gray-700">d G1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G2</td>

            <td class="px-3 py-2 border-b border-gray-700">2n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 f-MSM(D)</td>

            <td class="px-3 py-2 border-b border-gray-700">2n v-MSM(d)</td>

            <td class="px-3 py-2 border-b border-gray-700">1 v-MSM(d)</td>

            <td class="px-3 py-2 border-b border-gray-700">1 v-MSM(2n) + 2 pairings</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AGM</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">2d G1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G2</td>

            <td class="px-3 py-2 border-b border-gray-700">2n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G1 + 1 Fq</td>

            <td class="px-3 py-2 border-b border-gray-700">2 f-MSM(D)</td>

            <td class="px-3 py-2 border-b border-gray-700">4n v-MSM(d)</td>

            <td class="px-3 py-2 border-b border-gray-700">2 v-MSM(d)</td>

            <td class="px-3 py-2 border-b border-gray-700">1 v-MSM(2n) + 2 pairings</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Efficiency of our polynomial commitment schemes. Here f-MSM(m) and v-MSM(m) denote fixed-base and variable-base multi-scalar multiplications (MSM) each of size  <span class="math">m</span> , respectively. All MSMs are carried out over  <span class="math">\\mathbb{G}_1</span> . For simplicity we assume above that the query set evaluates each polynomial at the same point. If there are multiple points in the set, then proof size and time for checking proofs scales linearly with the number of points. Furthermore, we assume above that the  <span class="math">n</span>  committed polynomials all have degree  <span class="math">d</span> .</p>

    <p class="text-gray-300">We begin by discussing the case of opening multiple polynomials with the same degree bound at a single point. We describe a non-hiding construction based on  <span class="math">\\mathrm{PolyCommit}_{\\mathrm{DL}}</span>  from [KZG10] (see Section 2.5) and a hiding construction based on  <span class="math">\\mathrm{PolyCommit}_{\\mathrm{Ped}}</span>  from [KZG10], using "knowledge commitments" [Gro10] or the algebraic group model [FKL18] to achieve extractability for a single degree bound  <span class="math">D</span>  chosen at setup.</p>

    <p class="text-gray-300">Extractability with knowledge commitments. While  <span class="math">\\mathrm{PolyCommit}_{\\mathrm{DL}}</span>  guarantees correctness of evaluations, it does not ensure extractability: there is no guarantee that a commitment actually "contains" a polynomial. To achieve extraction, we modify the construction in such a way that the PKE assumption [Gro10] forces the sender to demonstrate knowledge of the committed polynomial. In more detail, we extend ck to encode of powers of  <span class="math">\\beta</span>  with respect to a different generator  <span class="math">\\alpha G</span> :  <span class="math">\\mathrm{ck} := \\{(G, \\beta G, \\ldots, \\beta^D G), (G, \\alpha \\beta G, \\ldots, \\alpha \\beta^D G)\\} \\in \\mathbb{G}_1^{2(D + 1)}</span> . (Note that this modification does not affect the updatability of the SRS.) To commit to a polynomial  <span class="math">p</span>  of degree at most  <span class="math">D</span> , the sender now provides a "knowledge commitment":  <span class="math">c := (U, V) := (p(\\beta)G, \\alpha p(\\beta)G)</span> . Proving correctness of evaluations proceeds unchanged, while verification additionally requires checking extractability of the commitment by checking the pairing equation  <span class="math">e(U, \\alpha H) = e(V, H)</span> .</p>

    <p class="text-gray-300">Extractability in the AGM. Knowledge commitments require, unfortunately, two group elements instead of one. Alternatively, we could keep each commitment as one group element, by relying on the algebraic group model (AGM) [FKL18]. Informally, whenever an adversary in the AGM outputs a group element  <span class="math">G_{n}</span> , it is required to additionally output scalar coefficients  <span class="math">a_1, \\ldots, a_{n-1}</span>  which "explain"  <span class="math">G_{n}</span>  as a linear combination of any group elements  <span class="math">G_1, \\ldots, G_{n-1}</span>  that it has seen previously. In our setting, this means that whenever the adversarial sender outputs a group element  <span class="math">c</span>  representing a commitment, it must additionally output scalar coefficients that explain  <span class="math">c</span>  in terms of the group elements in ck. An extractor can use these coefficients to reconstruct the underlying polynomial, thus achieving extractability.</p>

    <p class="text-gray-300">Efficiently opening multiple polynomials at the same point. To enable the sender to simultaneously commit to multiple polynomials  <span class="math">[p_i]_{i=1}^n</span>  of degree at most  <span class="math">D</span>  and then open these at the same point  <span class="math">z</span> , we rely on the fact that the commitments for both variants above are additively homomorphic. That is, if commitments  <span class="math">[c_i]_{i=1}^n</span>  commit to  <span class="math">[p_i]_{i=1}^n</span> , then  <span class="math">\\sum_{i=1}^n c_i</span>  commits to  <span class="math">\\sum_{i=1}^n p_i</span>  (where  <span class="math">c_1 + c_2</span>  is defined as  <span class="math">(U_1 + U_2, V_1 + V_2)</span> ).</p>

    <p class="text-gray-300">We take advantage of this by simultaneously verifying the evaluations of each polynomial  <span class="math">p_i \\in [p_i]_{i=1}^n</span>  as follows. Before generating a proof of evaluation for  <span class="math">[p_i]_{i=1}^n</span> , the sender requests from the receiver a</p>

    <p class="text-gray-300">random field element <span class="math">\\xi</span>. The sender then uses this to take a random linear combination of the polynomials: <span class="math">p:=\\sum_{i=1}^{n}\\xi^{i}p_{i}</span>, and generates a single evaluation proof <span class="math">\\pi</span> for this derived polynomial <span class="math">p</span>.</p>

    <p class="text-gray-300">To verify <span class="math">\\pi</span>, the receiver uses the additive homomorphism of the input commitments to derive the linear combination <span class="math">c=\\sum_{i=1}^{n}\\xi^{i}c_{i}</span> induced by <span class="math">\\xi</span>. It does the same with the claimed evaluations, thus deriving the evaluation <span class="math">v=\\sum_{i=1}^{n}\\xi^{i}v_{i}</span>. Finally, it checks that the pairing equations are satisfied for <span class="math">c</span>, <span class="math">\\pi</span>, and <span class="math">v</span>.</p>

    <p class="text-gray-300">This works because if the sender is honest, then <span class="math">c</span> is a commitment to <span class="math">p:=\\sum_{i=1}^{n}\\xi^{i}p_{i}</span>, and <span class="math">\\pi</span> is a proof of evaluation of <span class="math">p</span> at <span class="math">z</span>. On the other hand, if the sender is dishonest, then with high probability over the choice of <span class="math">\\xi</span>, <span class="math">c</span> is not a commitment to <span class="math">p</span>, and the pairing equations would fail.</p>

    <p class="text-gray-300">Hiding. To additionally achieve hiding, we follow the above blueprint, replacing <span class="math">\\mathsf{PolyCommit}_{\\mathsf{DL}}</span> with the hiding scheme <span class="math">\\mathsf{PolyCommit}_{\\mathsf{Ped}}</span>. Extraction now follows from an assumption related to <span class="math">\\mathsf{PKE}</span> called <span class="math">\\mathsf{dPKE}</span> (see Appendix B.2.3 for details). Our constructions in Appendix B in fact use both variants to provide optional hiding on a per-polynomial basis. Further, the near-identical form of the commitment variants makes it possible to open a combination of hiding and non-hiding polynomials at the same point.</p>

    <h4 id="sec-41" class="text-lg font-semibold mt-6">6.2.2 Multiple-bound single-query (see Appendix C for details)</h4>

    <p class="text-gray-300">Thus far, we have focused on commitment schemes for polynomials of degree <span class="math">D</span> where the cost of committing and providing evaluation proofs grows as <span class="math">\\Omega(D)</span>. However, when working with polynomials of degree <span class="math">d&lt;D</span>, we would like to pay a cost that instead grows as <span class="math">O(d)</span>. Furthermore, the foregoing schemes only guarantee that committed polynomials have degree at most <span class="math">D</span>, whereas in many cases it is desirable to enforce more specific degree bounds. Below we show how to adapt the foregoing construction to achieve these desirable properties.</p>

    <p class="text-gray-300">To achieve extractability with respect to a different degree bound <span class="math">d_{i}</span> for each polynomial <span class="math">p_{i}</span>, we require the sender to commit not only to each <span class="math">p_{i}</span>, but also to “shifted polynomials” <span class="math">p^{\\prime}_{i}(X):=X^{D-d_{i}}p_{i}(X)</span>. During <span class="math">\\mathsf{PC.Open}</span>, one could then produce an evaluation proofs that attests that if <span class="math">p_{i}</span> evaluates to <span class="math">v_{i}</span> at <span class="math">z</span> then <span class="math">p^{\\prime}_{i}</span> evaluates to <span class="math">z^{D-d_{i}}v_{i}</span> at <span class="math">z</span>.</p>

    <p class="text-gray-300">The receiver checks that the commitment for each <span class="math">p^{\\prime}_{i}</span> corresponds to an evaluation <span class="math">z^{D-d_{i}}v_{i}</span> so that, if <span class="math">z</span> is sampled from a super-polynomial subset of <span class="math">\\mathbb{F}_{q}</span>, the probability that <span class="math">\\deg(p_{i})\\neq d_{i}</span> is negligible. This trick is similar to the one used in <em>[x1, x2]</em> to enforce derive low-degree tests for specific degree bounds.</p>

    <p class="text-gray-300">However, while sound, this approach is inefficient in our setting: the witness polynomial for <span class="math">p^{\\prime}_{i}</span> has <span class="math">\\Omega(D)</span> non-zero coefficients (instead of <span class="math">O(d_{i})</span>), and so constructing an evaluation proof for it requires <span class="math">\\Omega(D)</span> scalar multiplications (instead of <span class="math">O(d_{i})</span>). To work around this, we instead produce a proof that the related polynomial <span class="math">p^{\\star}_{i}(X):=p^{\\prime}_{i}(X)-p_{i}(z)X^{D-d_{i}}</span> evaluates to <span class="math">0</span> at <span class="math">z</span>. As we show in Lemma C.2, the witness polynomial for this claim has <span class="math">O(d_{i})</span> non-zero coefficients, and so constructing the evaluation proof can be done in <span class="math">O(d_{i})</span> scalar multiplications. Completeness is preserved because the receiver can check the correct evaluation of <span class="math">p^{\\star}_{i}</span> by subtracting <span class="math">p_{i}(z)(\\beta^{D-d_{i}}\\mathbb{G})</span> from the commitment to the shifted polynomial <span class="math">p^{\\prime}_{i}</span>, thereby obtaining a commitment to <span class="math">p^{\\star}_{i}</span>, while security is preserved because <span class="math">p^{\\prime}_{i}(z)=z^{D-d_{i}}v_{i}\\iff p^{\\star}_{i}(z)=0</span>.</p>

    <p class="text-gray-300">Note that to commit to the shifted polynomial <span class="math">p^{\\prime}_{i}</span>, the committer must obtain <span class="math">\\{\\beta^{D-d_{i}}\\mathbb{G},\\ldots,\\beta^{D}\\mathbb{G}\\}</span> from <span class="math">\\mathsf{ck}</span>, while to adjust the shifted commitment, the receiver must obtain <span class="math">\\beta^{D-d_{i}}\\mathbb{G}</span> from <span class="math">\\mathsf{rk}</span>. Thus <span class="math">\\mathsf{PC.Trim}</span> must produce <span class="math">(\\mathsf{ck},\\mathsf{rk})</span> containing these group elements.</p>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">6.2.3 Multiple-bound multiple-query (see Appendix D for details)</h4>

    <p class="text-gray-300">Assume that we have <em>any</em> construction that achieves extractability with respect to individual degree bounds, and evaluation of multiple polynomials <span class="math">\\bm{p}=[p_{i}]_{i=1}^{n}</span> at the same point <span class="math">z</span>.</p>

    <p class="text-gray-300">We extend this construction to support query sets <span class="math">Q</span> consisting of multiple evaluation points (as required in Section 6.1). If there are <span class="math">k</span> distinct points <span class="math">[z_{i}]_{i=1}^{k}</span> in the query set <span class="math">Q</span>, the sender partitions the polynomials <span class="math">\\bm{p}</span> into different (possibly overlapping) groups <span class="math">[\\bm{p}_{i}]_{i=1}^{k}</span> such that every polynomial in <span class="math">\\bm{p}_{i}</span> is to be evaluated at the same point <span class="math">z_{i}</span>. It then runs PC.Open on each <span class="math">\\bm{p}_{i}</span>, and outputs the resulting list of <span class="math">k</span> evaluation proofs.</p>

    <p class="text-gray-300">We note that <em>[x13]</em> describe how one can enable the sender to produce a <em>single</em> evaluation proof attesting to the correct evaluation of the same polynomial at multiple points. While we could use this to enable batch evaluation of <span class="math">\\bm{p}</span> at multiple points, we avoid doing so for efficiency reasons in our setting.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">7 Preprocessing arguments with universal SRS</p>

    <p class="text-gray-300">An <em>argument system</em> <em>[x1]</em> is an interactive proof where the soundness property is only required to hold against all efficient adversaries, as opposed to all (possibly computationally unbounded) adversaries. In this paper we consider argument systems for indexed relations (see Section 3.1) that have the following features.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Security is proved, under cryptographic assumptions, in a model where all parties have access to a “long” structured reference string (SRS) that is <em>universal</em>. (In fact, the SRS in our constructions will also be <em>updatable</em> <em>[x12]</em> but for simplicity we do not formally discuss this property; see Remark 7.1.)</li>

      <li>Anyone can publicly <em>preprocess</em> a given index (e.g., a circuit) in an offline phase, in order to avoid incurring costs related to the index in (any number of) subsequent online phases that check different instances.</li>

    </ul>

    <p class="text-gray-300">We refer to argument systems with the above properties as preprocessing arguments with universal SRS. All interactive constructions in this paper are public-coin zero-knowledge succinct arguments of knowledge so that, via the Fiat–Shamir transformation <em>[x10]</em>, we obtain their non-interactive analogues: preprocessing zkSNARKs with universal SRS. See Section 9 for an efficient construction of such a zkSNARK.</p>

    <p class="text-gray-300">A preprocessing argument with universal SRS is a tuple of four algorithms <span class="math">\\mathsf{ARG}=(\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>. The probabilistic polynomial-time generator <span class="math">\\mathcal{G}</span>, given a size bound <span class="math">\\mathsf{N}\\in\\mathbb{N}</span>, samples an SRS srs that supports indices of size up to <span class="math">\\mathsf{N}</span>. The indexer <span class="math">\\mathcal{I}</span> is a <em>deterministic</em> polynomial-time algorithm that, given oracle access to srs and an index <span class="math">\\dot{\\mathfrak{s}}</span> of size at most <span class="math">\\mathsf{N}</span>, outputs an index proving key ipk used by the prover <span class="math">\\mathcal{P}</span> in place of <span class="math">\\dot{\\mathfrak{s}}</span> and an index verification key ivk used by the verifier <span class="math">\\mathcal{V}</span> in place of <span class="math">\\dot{\\mathfrak{s}}</span>; the verifier <span class="math">\\mathcal{V}</span> will be able to use ivk for significant efficiency gains compared to just using <span class="math">\\dot{\\mathfrak{s}}</span> directly. The prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span> are probabilistic polynomial-time interactive algorithms.</p>

    <p class="text-gray-300">Formally, <span class="math">\\mathsf{ARG}=(\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span> is a preprocessing argument with universal SRS for an indexed relation <span class="math">\\mathcal{R}</span> if the following properties hold.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For all size bounds <span class="math">\\mathsf{N}\\in\\mathbb{N}</span> and efficient <span class="math">\\mathcal{A}</span>,</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c c}(\\dot{\\mathfrak{s}},\\mathbbm{x},\\mathbbm{w})\\not\\in\\mathcal{R}_{\\mathsf{N}}\\\\ \\vee\\\\ \\langle\\mathcal{P}(\\mathsf{ipk},\\mathbbm{x},\\mathbbm{w}),\\mathcal{V}(\\mathsf{ivk},\\mathbbm{x})\\rangle=1\\end{array}\\right]\\begin{array}[]{c c}\\mathsf{srs}\\leftarrow\\mathcal{G}(1^{\\lambda},\\mathsf{N})\\\\ (\\dot{\\mathfrak{s}},\\mathbbm{x},\\mathbbm{w})\\leftarrow\\mathcal{A}(\\mathsf{srs})\\\\ (\\mathsf{ipk},\\mathsf{ivk})\\leftarrow\\mathcal{I}^{\\mathsf{srs}}(\\dot{\\mathfrak{s}})\\end{array}\\Bigg{]}=1\\enspace. \\]</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness. For all size bounds <span class="math">\\mathsf{N}\\in\\mathbb{N}</span> and efficient <span class="math">\\tilde{\\mathcal{P}}=(\\tilde{\\mathcal{P}}_{1},\\tilde{\\mathcal{P}}_{2})</span>,</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c c}(\\dot{\\mathfrak{s}},\\mathbbm{x})\\not\\in\\mathcal{L}(\\mathcal{R}_{\\mathsf{N}})\\\\ \\wedge\\\\ \\langle\\tilde{\\mathcal{P}}_{2}(\\mathsf{st}),\\mathcal{V}(\\mathsf{ivk},\\mathbbm{x})\\rangle=1\\end{array}\\right]\\begin{array}[]{c c}\\mathsf{srs}\\leftarrow\\mathcal{G}(1^{\\lambda},\\mathsf{N})\\\\ (\\dot{\\mathfrak{s}},\\mathbbm{x},\\mathsf{st})\\leftarrow\\tilde{\\mathcal{P}}_{1}(\\mathsf{srs})\\\\ (\\mathsf{ipk},\\mathsf{ivk})\\leftarrow\\mathcal{I}^{\\mathsf{srs}}(\\dot{\\mathfrak{s}})\\end{array}\\Bigg{]}=\\mathrm{negl}(\\lambda)\\enspace. \\]</p>

    <p class="text-gray-300">Our definition of completeness allows <span class="math">(\\dot{\\mathfrak{s}},\\mathbbm{x},\\mathbbm{w})</span> to depend on srs, while our formulation of soundness allows <span class="math">(\\dot{\\mathfrak{s}},\\mathbbm{x})</span> to depend on srs.</p>

    <p class="text-gray-300">All constructions in this paper achieve the stronger property of <em>knowledge soundness</em>, and optionally also the property of (perfect) <em>zero knowledge</em>. We define these properties below.</p>

    <p class="text-gray-300">Knowledge soundness. We say that <span class="math">\\mathsf{ARG}=(\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span> has knowledge soundness if for every size bound <span class="math">\\mathsf{N}\\in\\mathbb{N}</span> and efficient adversary <span class="math">\\tilde{\\mathcal{P}}=(\\tilde{\\mathcal{P}}_{1},\\tilde{\\mathcal{P}}_{2})</span> there exists an efficient extractor <span class="math">\\mathcal{E}</span> such that</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c c}(\\dot{\\mathfrak{s}},\\mathbbm{x},\\mathbbm{w})\\not\\in\\mathcal{R}_{\\mathsf{N}}\\\\ \\wedge\\\\ \\langle\\tilde{\\mathcal{P}}_{2}(\\mathsf{st}),\\mathcal{V}(\\mathsf{ivk},\\mathbbm{x})\\rangle=1\\end{array}\\right]\\begin{array}[]{c c}\\mathsf{srs}\\leftarrow\\mathcal{G}(1^{\\lambda},\\mathsf{N})\\\\ (\\dot{\\mathfrak{s}},\\mathbbm{x},\\mathsf{st})\\leftarrow\\tilde{\\mathcal{P}}_{1}(\\mathsf{srs})\\\\ \\mathbbm{w}\\leftarrow\\mathcal{E}(\\mathsf{srs})\\\\ (\\mathsf{ipk},\\mathsf{ivk})\\leftarrow\\mathcal{I}^{\\mathsf{srs}}(\\dot{\\mathfrak{s}})\\end{array}\\Bigg{]}=\\mathrm{negl}(\\lambda)\\enspace. \\]</p>

    <p class="text-gray-300">Zero knowledge. We say that  <span class="math">\\mathsf{ARG} = (\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>  has (perfect) zero knowledge if there exists an efficient simulator  <span class="math">S = (\\mathsf{Setup},\\mathsf{Prove})</span>  such that for every efficient adversary  <span class="math">\\tilde{\\mathcal{V}} = (\\tilde{\\mathcal{V}}_1,\\tilde{\\mathcal{V}}_2)</span>  it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c c} (\\mathbb {i}, \\mathbb {x}, \\mathbb {w}) \\in \\mathcal {R} _ {\\mathsf {N}} &amp;amp; \\mathsf {s r s} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, \\mathsf {N}) \\\\ \\wedge &amp;amp; (\\mathbb {i}, \\mathbb {x}, \\mathbb {w}, \\mathsf {s t}) \\leftarrow \\tilde {\\mathcal {V}} _ {1} (\\mathsf {s r s}) \\\\ \\langle \\mathcal {P} (\\mathsf {i p k}, \\mathbb {x}, \\mathbb {w}), \\tilde {\\mathcal {V}} _ {2} (\\mathsf {s t}) \\rangle = 1 &amp;amp; (\\mathsf {i p k}, \\mathsf {i v k}) \\leftarrow \\mathcal {I} ^ {\\mathsf {s r s}} (\\mathbb {i}) \\end{array} \\right] \\\\ = \\Pr \\left[ \\begin{array}{c c} (\\mathbb {i}, \\mathbb {x}, \\mathbb {w}) \\in \\mathcal {R} _ {\\mathsf {N}} &amp;amp; (\\mathsf {s r s}, \\mathsf {t r a p}) \\leftarrow \\mathcal {S}. \\mathsf {S e t u p} (1 ^ {\\lambda}, \\mathsf {N}) \\\\ \\wedge &amp;amp; (\\mathbb {i}, \\mathbb {x}, \\mathbb {w}, \\mathsf {s t}) \\leftarrow \\tilde {\\mathcal {V}} _ {1} (\\mathsf {s r s}) \\\\ \\langle \\mathcal {S}. \\mathsf {P r o v e} (\\mathsf {t r a p}, \\mathbb {i}, \\mathbb {x}), \\tilde {\\mathcal {V}} _ {2} (\\mathsf {s t}) \\rangle = 1 &amp;amp; \\end{array} \\right] \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Efficiency. We say that  <span class="math">\\mathsf{ARG} = (\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>  is:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- index efficient if the running time of the prover  <span class="math">\\mathcal{P}(\\mathrm{ipk},\\mathbb{x},\\mathbb{w})</span>  is  $\\mathrm{poly}_{\\lambda}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> , i.e., it does not depend on the size of the universal structured reference string  </span>\\mathrm{srs}$ ;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>proof succinct if the size of the communication transcript between the prover  <span class="math">\\mathcal{P}(\\mathrm{ipk},\\mathbb{x},\\mathbb{w})</span>  and verifier  <span class="math">\\mathcal{V}(\\mathrm{ivk},\\mathbb{x})</span>  is  <span class="math">\\mathrm{poly}(\\lambda)</span> , i.e., the size is bounded by a universal polynomial in the security parameter  <span class="math">\\lambda</span> ;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- verifier succinct if the running time of  <span class="math">\\mathcal{V}(\\mathrm{ivk},\\mathbb{x})</span>  is  $\\mathrm{poly}(\\lambda +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> , i.e., the time is bounded by a universal polynomial in the security parameter  </span>\\lambda<span class="math">  and the size of the instance  </span>\\mathbb{x}<span class="math">  and does not depend on the size of the index  </span>\\mathbb{i}<span class="math">  that led to  </span>\\mathrm{ivk}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Index efficiency implies that  <span class="math">\\mathrm{ipk}</span>  output by  <span class="math">\\mathcal{I}</span>  is of size  $\\mathrm{poly}_{\\lambda}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> , while verifier succinctness implies that  </span>\\mathrm{ivk}<span class="math">  output by  </span>\\mathcal{I}<span class="math">  is of size  </span>\\mathrm{poly}(\\lambda)$ . All constructions in this paper are index efficient, proof succinct, and verifier succinct.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Public coins. We say that  <span class="math">\\mathsf{ARG} = (\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>  is public-coin if every message output by the verifier  <span class="math">\\mathcal{V}</span>  is a uniform random string of some prescribed length. All constructions in this paper are public-coin, and have a (small) constant number of rounds; in particular, they can be "squashed" to non-interactive arguments that are publicly verifiable by additionally using random oracles via the Fiat-Shamir transformation [FS86]. Hence, due to their succinctness, our constructions directly lead to preprocessing zkSNARKs with universal SRS.</p>

    <p class="text-gray-300">Remark 7.1 (updatable SRS). An SRS is updatable [Gro+18] if there exists an update algorithm that can be run at any time by anyone to update the SRS, with the guarantee that security holds as long as there is at least one honest updater since the beginning of time. This property significantly simplifies cryptographic ceremonies to sample the SRS. All preprocessing arguments that we construct in this paper have updatable SRS because they only contain "monomial terms", and thus fall within the framework of [Gro+18].</p>

    <p class="text-gray-300">Remark 7.2 (auxiliary inputs). The definition of knowledge soundness above does not consider auxiliary inputs, for simplicity. One could consider a stronger definition, where the adversary and extractor additionally receive an auxiliary input  <span class="math">\\mathbb{Z}</span>  sampled from a fixed distribution  <span class="math">\\mathcal{Z}(1^{\\lambda})</span> , or even sampled from any distribution  <span class="math">\\mathcal{Z}(1^{\\lambda})</span>  that belongs to a given class. Such stronger definitions are useful when using argument systems as subroutines within other protocols. When relying on auxiliary inputs, however, one must be careful to ensure that they come from "benign" distributions, or else extraction is impossible, as discussed in [BP15; Bit+16]. We stress that all of our constructions of argument systems directly extend to hold with respect to an auxiliary-input distribution  <span class="math">\\mathcal{Z}(1^{\\lambda})</span>  under the assumption that the relevant underlying knowledge assumptions are extended to hold with respect to the auxiliary-input distribution  <span class="math">\\mathcal{Z}(1^{\\lambda})</span>  concatenated with some randomness. (In other words, our security reduction adds to the auxiliary input some random strings.)</p>

    <p class="text-gray-300">8 From AHPs to preprocessing arguments with universal SRS</p>

    <p class="text-gray-300">The following theorems capture key properties of our compiler.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Theorem 8.1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{F}</span> be a field family and let <span class="math">\\mathcal{R}</span> be an indexed relation. Consider the following components: – <span class="math">\\mathsf{AHP}=(\\mathsf{k},\\mathsf{s},\\mathsf{d},\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> is an AHP over <span class="math">\\mathcal{F}</span> for <span class="math">\\mathcal{R}</span> with negligible soundness error (see Section 4); – <span class="math">\\mathsf{PC}=(\\mathsf{Setup},\\mathsf{Trim},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Check})</span> is a polynomial commitment scheme over <span class="math">\\mathcal{F}</span> (see Section 6). Then <span class="math">\\mathsf{ARG}=(\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span> described in Section 8.1 is a preprocessing argument with universal SRS for <span class="math">\\mathcal{R}</span> (see Section 7). Moreover, if <span class="math">q</span> is the query complexity of <span class="math">\\mathsf{AHP}</span>, <span class="math">\\mathsf{ARG}</span> has the following efficiency: <span class="math">\\bullet</span> round complexity is <span class="math">\\mathsf{k}+2</span>; <span class="math">\\bullet</span> communication complexity is <span class="math">O_{\\lambda}(q)</span> bits if <span class="math">\\mathsf{PC}</span> is additionally succinct (see Definition 6.3); <span class="math">\\bullet</span> indexer time is the sum of the indexer time in <span class="math">\\mathsf{AHP}</span> and the time to commit to <span class="math">\\mathsf{s}(0)</span> polynomials in <span class="math">\\mathsf{PC}</span>; <span class="math">\\bullet</span> prover time is the sum of the prover time in <span class="math">\\mathsf{AHP}</span>, the time to commit to <span class="math">\\sum_{i=1}^{\\mathsf{k}}\\mathsf{s}(i)</span> polynomials in <span class="math">\\mathsf{PC}</span>, the time to produce evaluations that answer the <span class="math">q</span> queries along with a batch evaluation proof for them in <span class="math">\\mathsf{PC}</span>; <span class="math">\\bullet</span> verifier time is the sum of the verifier time in <span class="math">\\mathsf{AHP}</span> and the time to batch verify <span class="math">q</span> evaluations in <span class="math">\\mathsf{PC}</span>.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Remark 8.2 (updatable SRS).</h6>

    <p class="text-gray-300">If the SRS for <span class="math">\\mathsf{PC}</span> is updatable then so is the SRS for <span class="math">\\mathsf{ARG}</span>. All constructions of polynomial commitments in this paper satisfy this property, including the one used in Section 9.</p>

    <p class="text-gray-300">The construction underlying the above theorem preserves knowledge soundness and, if the polynomial commitment scheme is also hiding, preserves zero knowledge.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Theorem 8.3.</h6>

    <p class="text-gray-300">In Theorem 8.1, if <span class="math">\\mathsf{AHP}</span> has a negligible knowledge soundness error, then <span class="math">\\mathsf{ARG}</span> has knowledge soundness.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Theorem 8.4.</h6>

    <p class="text-gray-300">In Theorem 8.1, if <span class="math">\\mathsf{PC}</span> is hiding and if <span class="math">\\mathsf{AHP}</span> is zero knowledge with query bound <span class="math">q</span> (the query complexity of <span class="math">\\mathsf{AHP}</span>) and some polynomial-time query checker <span class="math">\\mathbf{C}</span>, then <span class="math">\\mathsf{ARG}</span> is (perfect) zero knowledge.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Remark 8.5 (the multivariate case).</h6>

    <p class="text-gray-300">In this paper we give definitions for algebraic holographic proofs and polynomial commitment schemes that are restricted to the case of univariate polynomials, because the constructions that we consider are univariate. Theorems 8.1, 8.3 and 8.4, however, directly extend to the multivariate case when considering an AHP in the general case of multivariate polynomials and a polynomial commitment scheme for multivariate polynomials. This provides a proof of security for several prior works that considered constructions that are special cases of this paradigm but did not prove security (because the polynomial commitment schemes were only assumed to satisfy evaluation binding as discussed in Section 1.2).</p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">8.1 Construction</h3>

    <p class="text-gray-300">We describe the construction behind Theorem 8.1, and then discuss its efficiency features.</p>

    <h4 id="sec-49" class="text-lg font-semibold mt-6">Generator <span class="math">\\mathcal{G}</span>.</h4>

    <p class="text-gray-300">The generator <span class="math">\\mathcal{G}</span>, on input a security parameter <span class="math">\\lambda\\in\\mathbb{N}</span> and size bound <span class="math">\\mathsf{N}\\in\\mathbb{N}</span>, uses <span class="math">\\mathsf{N}</span> to compute a maximum degree bound <span class="math">D\\in\\mathbb{N}</span>, samples public parameters <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{PC}.\\mathsf{Setup}(1^{\\lambda},D)</span> for the polynomial commitment scheme <span class="math">\\mathsf{PC}</span>, and then outputs <span class="math">\\mathsf{srs}:=\\mathsf{pp}</span>. The integer <span class="math">D</span> is computed to be the maximum degree bound in <span class="math">\\mathsf{AHP}</span> for indices of size <span class="math">\\mathsf{N}</span>. In other words,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$D:=\\max\\left\\{\\mathsf{d}(\\mathsf{N},i,j)\\;\\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\;i\\in\\{0,1,\\ldots,\\mathsf{k}(\\mathsf{N})\\}\\;,\\;j\\in\\{1,\\ldots,\\mathsf{s}(i)\\}\\right\\}\\ .$ (9)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-50" class="text-lg font-semibold mt-6">Indexer <span class="math">\\mathcal{I}</span>.</h4>

    <p class="text-gray-300">The indexer <span class="math">\\mathcal{I}</span> upon input <span class="math">\\mathsf{i}</span> and given oracle access to <span class="math">\\mathsf{srs}</span>, deduces the field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span> contained in <span class="math">\\mathsf{srs}=\\mathsf{pp}</span>, runs the AHP indexer <span class="math">\\mathbf{I}</span> on <span class="math">(\\mathbb{F},\\mathsf{i})</span> to obtain <span class="math">\\mathsf{s}(0)</span> polynomials <span class="math">p_{0,1},\\ldots,p_{0,\\mathsf{s}(0)}\\in\\mathbb{F}[X]</span> of degrees</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">at most $\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathfrak{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,0,1),\\ldots,\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathfrak{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,0,\\mathsf{s}(0))<span class="math">, computes the degree bounds for the index and prover polynomials, invokes PC.Trim on these bounds to compute </span>(\\mathsf{ck},\\mathsf{rk})$ that are specialized for these degree bounds, and computes commitments to all of the index polynomials.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Namely, <span class="math">\\mathcal{I}</span> calculates the bounds $\\pmb{d} := \\{\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathfrak{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, i, \\mathsf{s}(i))\\}_{i=0}^{\\mathsf{k}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathfrak{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}<span class="math">, invokes </span>(\\mathsf{ck}, \\mathsf{rk}) := \\mathsf{PC.Trim}^{\\mathsf{srs}}(\\pmb{d})<span class="math">, and then computes </span>[c_{0,j}]_{j=1}^{\\mathsf{s}(0)} := \\mathsf{PC.Commit}(\\mathsf{ck}, [p_{0,j}]_{j=1}^{\\mathsf{s}(0)}, [\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathfrak{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, 0, j)]_{j=1}^{\\mathsf{s}(0)}; [\\omega_{0,j}]_{j=1}^{\\mathsf{s}(0)})<span class="math"> for &quot;empty randomness&quot; </span>[\\omega_{0,j}]_{j=1}^{\\mathsf{s}(0)} := \\bot<span class="math">. The indexer </span>\\mathcal{I}<span class="math"> outputs </span>\\mathsf{ipk} := (\\mathsf{ck}, \\dot{\\mathfrak{s}}, [p_{0,j}]_{j=1}^{\\mathsf{s}(0)}, [c_{0,j}]_{j=1}^{\\mathsf{s}(0)})<span class="math"> and </span>\\mathsf{ivk} := (\\mathsf{rk}, [c_{0,j}]_{j=1}^{\\mathsf{s}(0)})<span class="math">. (Note that </span>[c_{0,j}]_{j=1}^{\\mathsf{s}(0)}<span class="math"> are commitments to non-secret information so no randomness is used in producing them. In particular, </span>\\mathcal{I}$ is a deterministic polynomial-time algorithm, as required. Also see Remark 8.6 below for additional considerations.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span>. The prover <span class="math">\\mathcal{P}</span> receives <span class="math">(\\mathsf{ipk}, \\mathfrak{x}, \\mathfrak{w})</span> and the verifier <span class="math">\\mathcal{V}</span> receives <span class="math">(\\mathsf{ivk}, \\mathfrak{x})</span>, where <span class="math">(\\mathsf{ipk}, \\mathsf{ivk})</span> is the index key pair output by <span class="math">\\mathcal{I}^{\\mathsf{srs}}(\\dot{\\mathfrak{s}})</span>, and <span class="math">(\\dot{\\mathfrak{s}}, \\mathfrak{x}, \\mathfrak{w})</span> is in the indexed relation <span class="math">\\mathcal{R}</span>. By construction of <span class="math">\\mathcal{I}</span>, <span class="math">\\mathsf{ipk}</span> contains a trimmed committer key <span class="math">\\mathsf{ck}</span> and <span class="math">\\mathsf{ivk}</span> contains a trimmed receiver key <span class="math">\\mathsf{rk}</span> for the polynomial commitment scheme <span class="math">\\mathsf{PC}</span>. Let <span class="math">\\mathbb{F} \\in \\mathcal{F}</span> be the field described by <span class="math">(\\mathsf{ck}, \\mathsf{rk})</span> (each of <span class="math">\\mathsf{ck}</span> and <span class="math">\\mathsf{rk}</span> individually contain a description of <span class="math">\\mathbb{F}</span>), and let $\\mathsf{k} := \\mathsf{k}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathfrak{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> be the number of rounds in AHP. For </span>i \\in \\{1, \\dots, \\mathsf{k}\\}<span class="math">, </span>\\mathcal{P}<span class="math"> and </span>\\mathcal{V}<span class="math"> simulate the </span>i<span class="math">-th round of the interaction between the AHP prover </span>\\mathbf{P}(\\mathbb{F}, \\dot{\\mathfrak{s}}, \\mathfrak{x}, \\mathfrak{w})<span class="math"> and the AHP verifier </span>\\mathbf{V}(\\mathbb{F}, \\mathfrak{x})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> receives <span class="math">\\rho_{i} \\in \\mathbb{F}^{*}</span> from <span class="math">\\mathbf{V}</span>, and forwards it to <span class="math">\\mathcal{P}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. <span class="math">\\mathcal{P}</span> forwards <span class="math">\\rho_{i}</span> to <span class="math">\\mathbf{P}</span>, which replies with polynomials <span class="math">p_{i,1}, \\ldots, p_{i,\\mathbf{s}(i)} \\in \\mathbb{F}[X]</span> with $\\deg(p_{i,j}) \\leq \\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathfrak{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, i, j)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> samples commitment randomness <span class="math">[\\omega_{i,j}]_{j=1}^{\\mathsf{s}(i)}</span> and sends to <span class="math">\\mathcal{V}</span> the polynomial commitments below</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[ c _ {i, j} ] _ {j = 1} ^ {\\mathsf {s} (i)} := \\mathsf {P C . C o m m i t} (\\mathsf {c k}, [ p _ {i, j} ] _ {j = 1} ^ {\\mathsf {s} (i)}, [ \\mathsf {d} (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot {\\mathfrak {s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, i, j) ] _ {j = 1} ^ {\\mathsf {s} (i)}; [ \\omega_ {i, j} ] _ {j = 1} ^ {\\mathsf {s} (i)}) .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> notifies <span class="math">\\mathbf{V}</span> that the <span class="math">i</span>-th round has finished.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span> are done simulating the interactive phase of AHP, and in the remaining two rounds simulate the (non-adaptive) query phase of AHP. Below we use <span class="math">\\pmb{c}</span> to denote the commitments <span class="math">[[c_{i,j}]_{j=1}^{\\mathsf{s}(i)}]_{i=0}^{\\mathsf{k}}</span>, <span class="math">\\pmb{p}</span> to denote the polynomials <span class="math">[[p_{i,j}]_{j=1}^{\\mathsf{s}(i)}]_{i=0}^{\\mathsf{k}}</span>, <span class="math">\\pmb{d}</span> to denote the degree bounds $[[d(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathfrak{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, i, j)]_{j=1}^{\\mathsf{s}(i)}]_{i=0}^{\\mathsf{k}}<span class="math">, and </span>\\pmb{\\omega}<span class="math"> to denote the randomness </span>[[\\omega_{i,j}]_{j=1}^{\\mathsf{s}(i)}]_{i=0}^{\\mathsf{k}}<span class="math"> with </span>[\\omega_{0,j}]_{j=1}^{\\mathsf{s}(0)} := \\bot$. Note that these three vectors include the commitments, polynomials, degrees, and randomness of the "0-th round".</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> sends a message <span class="math">\\rho_{\\mathrm{k + 1}}\\in \\mathbb{F}^*</span> that represents randomness for the query phase of <span class="math">\\mathbf{V}(\\mathbb{F},\\mathfrak{x})</span> to <span class="math">\\mathcal{P}</span>.</li>

      <li><span class="math">\\mathcal{P}</span> uses the query algorithm of <span class="math">\\mathbf{V}</span> to compute the query set <span class="math">Q := \\mathbf{Q}_{\\mathbf{V}}(\\mathbb{F}, \\mathfrak{x}; \\rho_1, \\ldots, \\rho_{\\mathrm{k}}, \\rho_{\\mathrm{k + 1}})</span>.</li>

      <li><span class="math">\\mathcal{P}</span> replies with answers <span class="math">\\pmb{v} \\coloneqq \\pmb{p}(Q)</span>.</li>

      <li><span class="math">\\mathcal{V}</span> samples and sends an opening challenge <span class="math">\\xi \\in \\mathbb{F}</span> to <span class="math">\\mathcal{P}</span>.</li>

      <li><span class="math">\\mathcal{P}</span> replies with an evaluation proof to demonstrate correctness of all claimed evaluations:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\pi := \\mathsf {P C . O p e n} (\\mathsf {c k}, \\boldsymbol {p}, \\boldsymbol {d}, Q, \\xi ; \\boldsymbol {\\omega}).</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> accepts if and only if the following conditions hold:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the decision algorithm of <span class="math">\\mathbf{V}</span> accepts the answers, i.e., <span class="math">\\mathbf{D}_{\\mathbf{V}}(\\mathbb{F},\\mathfrak{x},\\boldsymbol {v};\\rho_1,\\ldots ,\\rho_{\\mathrm{k}},\\rho_{\\mathrm{k + 1}}) = 1</span></li>

      <li>the alleged answers pass the test, i.e., <span class="math">\\mathsf{PC.Check}(\\mathsf{rk},\\pmb {c},\\pmb {d},Q,\\pmb {v},\\pi ,\\xi) = 1</span></li>

    </ul>

    <p class="text-gray-300">Completeness of the preprocessing argument ARG follows in a straightforward way from completeness of the AHP AHP and completeness of the polynomial commitment scheme PC.</p>

    <p class="text-gray-300">We now discuss the efficiency features of the construction above.</p>

    <p class="text-gray-300">42</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Round complexity. The first <span class="math">k</span> rounds simulate the interactive phase of AHP, with polynomials sent as commitments; one round is to answer the desired queries; and one round is to certify the queries' answers.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Communication complexity. The argument prover <span class="math">\\mathcal{P}</span> sends <span class="math">\\sum_{i=1}^{k} s(i)</span> commitments, <span class="math">q</span> field elements representing query answers, and an evaluation proof that certifies the <span class="math">q</span> answers. The argument verifier <span class="math">\\mathcal{V}</span> sends $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\cdots +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{k+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1<span class="math"> field elements. In Theorem 8.1 we state that the communication complexity is </span>O_{\\lambda}(q)<span class="math"> because typically it holds that </span>\\sum_{i=0}^{k} s(i) \\leq q<span class="math"> (each polynomial is queried at least once) and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\cdots +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{k+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is a small constant (each verifier message is a few field elements).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Indexer time. The time complexity of <span class="math">\\mathcal{I}</span> equals the time complexity of the AHP indexer <span class="math">\\mathbf{I}</span> plus the time to trim the PC public parameters <span class="math">\\mathsf{pp}</span>, and then to commit to the <span class="math">s(0)</span> polynomials output by <span class="math">\\mathbf{I}</span>.</li>

      <li>Prover time. The time complexity of <span class="math">\\mathcal{P}</span> equals the time complexity of the AHP prover <span class="math">\\mathbf{P}</span> plus the time to commit to the <span class="math">\\sum_{i=1}^{k} s(i)</span> polynomials output by <span class="math">\\mathbf{P}</span>, evaluate <span class="math">\\sum_{i=0}^{k} s(i)</span> polynomials at the query set <span class="math">Q</span>, and produce an evaluation proof that certifies the correctness of these evaluations.</li>

      <li>Verifier time. The time complexity of <span class="math">\\mathcal{V}</span> equals the time complexity of the AHP verifier <span class="math">\\mathbf{V}</span> plus the time to verify the batch evaluation proof for the <span class="math">q</span> evaluations that provide answers to the query set <span class="math">Q</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Remark 8.6 (commitments to index polynomials).</strong> The construction described above uses the same polynomial commitment scheme PC for committing to polynomials output by the AHP indexer and to polynomials output by the AHP prover. This simplifies exposition, and allows for a single evaluation proof to certify all query answers. For security, however, it would suffice (even for Theorem 8.4) to commit to index polynomials via a commitment scheme that merely satisfies "evaluation binding" (Definition B.8), which is strictly weaker than the notion of extractability that we use for the other commitments. This is because the commitments in the index verification key are honestly produced in the preprocessing phase. Moreover, for Theorem 8.3 to hold we do not need the commitments to index polynomials to be hiding.</p>

    <h2 id="sec-51" class="text-2xl font-bold">8.2 Proof of Theorem 8.1</h2>

    <p class="text-gray-300">Suppose that <span class="math">\\tilde{\\mathcal{P}} = (\\tilde{\\mathcal{P}}_1, \\tilde{\\mathcal{P}}_2)</span> is an efficient adversarial prover for ARG that wins with probability at least <span class="math">\\epsilon</span>, that is,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} (\\dot {\\mathfrak {s}}, \\mathfrak {z}) \\notin \\mathcal {L} (\\mathcal {R} _ {\\mathsf {N}}) &amp;amp; \\mathsf {s r s} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, \\mathsf {N}) \\\\ \\wedge &amp;amp; (\\dot {\\mathfrak {s}}, \\mathfrak {z}, \\mathsf {s t}) \\leftarrow \\tilde {\\mathcal {P}} _ {1} (\\mathsf {s r s}) \\\\ \\langle \\tilde {\\mathcal {P}} _ {2} (\\mathsf {s t}), \\mathcal {V} (\\mathsf {i v k}, \\mathfrak {z}) \\rangle = 1 &amp;amp; (\\mathsf {i p k}, \\mathsf {i v k}) \\leftarrow \\mathcal {I} ^ {\\mathsf {s r s}} (\\dot {\\mathfrak {s}}) \\end{array} \\right] \\geq \\epsilon (\\lambda) .</span></div>

    <p class="text-gray-300">We assume without loss of generality that <span class="math">\\mathsf{st}</span> output by <span class="math">\\tilde{\\mathcal{P}}_1</span> contains the public parameters <span class="math">\\mathsf{srs} = \\mathsf{pp}</span>. Also note that <span class="math">\\tilde{\\mathcal{P}}_2</span> can be represented via its <span class="math">k + 2</span> next-message functions:</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde {\\mathcal {P}} _ {2} (\\mathsf {s t}; \\rho_ {1}), \\tilde {\\mathcal {P}} _ {2} (\\mathsf {s t}; \\rho_ {1}, \\rho_ {2}), \\ldots , \\tilde {\\mathcal {P}} _ {2} (\\mathsf {s t}; \\rho_ {1}, \\ldots , \\rho_ {\\mathsf {k}}), \\tilde {\\mathcal {P}} _ {2} (\\mathsf {s t}; \\rho_ {1}, \\ldots , \\rho_ {\\mathsf {k}}, Q), \\tilde {\\mathcal {P}} _ {2} (\\mathsf {s t}; \\rho_ {1}, \\ldots , \\rho_ {\\mathsf {k}}, Q, \\xi).</span></div>

    <p class="text-gray-300">We describe how to construct a prover <span class="math">\\tilde{\\mathbf{P}}</span>, which is admissible for AHP, and an efficient adversary <span class="math">\\mathcal{A}_{\\mathsf{PC}}</span> against the extractability of PC such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} (\\dot {\\mathfrak {s}}, \\mathfrak {z}) \\notin \\mathcal {L} (\\mathcal {R} _ {\\mathsf {N}}) &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {P C}. \\mathsf {S e t u p} (1 ^ {\\lambda}, D) \\\\ \\wedge &amp;amp; \\mathbb {F} \\leftarrow \\mathsf {f i e l d} (\\mathsf {p p}) \\\\ \\langle \\tilde {\\mathbf {P}} (\\mathsf {s t}), \\mathbf {V} ^ {\\mathbf {I} (\\mathbb {F}, \\dot {\\mathfrak {s}})} (\\mathbb {F}, \\mathfrak {z}) \\rangle = 1 &amp;amp; (\\dot {\\mathfrak {s}}, \\mathfrak {z}, \\mathsf {s t}) \\leftarrow \\tilde {\\mathcal {P}} _ {1} (\\mathsf {p p}) \\end{array} \\right] + \\Pr \\left[ \\begin{array}{c} \\mathcal {A} _ {\\mathsf {P C}} \\text {w i n s t h e} \\\\ \\text {e x t r a c t a b i l i t y g a m e} \\end{array} \\right] \\geq \\epsilon (\\lambda)  ,</span></div>

    <p class="text-gray-300">Above, <span class="math">D</span> is computed according to Eq. (9) and <span class="math">\\mathbb{F}</span> is the field described in pp. This concludes the proof because if <span class="math">\\epsilon (\\lambda)</span> were to be non-negligible then either: (i) by averaging there would exist a choice of public parameters pp that yields a state st, field <span class="math">\\mathbb{F}\\in \\mathcal{F}</span>, and <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{z})\\notin \\mathcal{L}(\\mathcal{R})</span> for which <span class="math">\\operatorname *{Pr}[\\langle \\tilde{\\mathbf{P}} (\\mathsf{st}),\\mathbf{V}^{\\mathbf{I}(\\mathbb{F},\\dot{\\mathfrak{s}})}(\\mathbb{F},\\mathfrak{z})\\rangle = 1]</span></p>

    <p class="text-gray-300">is non-negligible, contradicting our hypothesis AHP has negligible soundness error; or (ii) there would exist an efficient adversary  <span class="math">\\mathcal{A}_{\\mathrm{PC}}</span>  that, for any given efficient extractor, succeeds in the extractability game for PC (Definition 6.2) with non-negligible probability, contradicting our hypothesis PC is extractable.</p>

    <p class="text-gray-300">Constructing  <span class="math">\\mathcal{A}_{\\mathrm{PC}}</span> . The adversary  <span class="math">\\mathcal{A}_{\\mathrm{PC}}</span>  is built from the argument prover  <span class="math">\\tilde{\\mathcal{P}}</span>  (and the argument indexer  <span class="math">\\mathcal{I}</span>  and degree bounds  <span class="math">\\mathsf{d}</span> ) as follows. For round  <span class="math">i \\in \\{0, \\dots, k\\}</span>  and verifier messages  <span class="math">\\rho_0, \\dots, \\rho_i</span> :</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}_{\\mathrm{PC}}(\\mathrm{ck},\\mathrm{rk},\\rho_0,\\rho_1,\\ldots ,\\rho_i)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\mathsf{srs} \\coloneqq \\mathsf{pp}</span>  and compute  <span class="math">(\\dot{\\mathbf{i}}, \\mathbf{x}, \\mathbf{st}) \\gets \\tilde{\\mathcal{P}}_1(\\mathsf{srs})</span> .</li>

      <li>If  <span class="math">i = 0</span> , ignore  <span class="math">\\rho_0</span> , compute index keys  <span class="math">(\\mathrm{ipk}, \\mathrm{ivk}) \\gets \\mathcal{I}^{\\mathrm{srs}}(\\dot{\\mathbf{i}})</span> , and parse  <span class="math">\\mathrm{ivk}</span>  as polynomial commitments  <span class="math">[c_{0,j}]_{j=1}^{\\mathrm{s}(0)}</span> . If  <span class="math">i &amp;gt; 0</span> , compute polynomial commitments  <span class="math">[c_{i,j}]_{j=1}^{\\mathrm{s}(i)} \\gets \\tilde{\\mathcal{P}}_2(\\mathrm{st}; \\rho_1, \\ldots, \\rho_i)</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. For each  <span class="math">j \\in \\{1, \\dots, s(i)\\}</span> , compute the degree  $d_{i,j} := \\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathbf{i}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, i, j)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">\\left([c_{i,j}]_{j=1}^{\\mathbf{s}(i)}, [d_{i,j}]_{j=1}^{\\mathbf{s}(i)}\\right)</span> .</li>

    </ol>

    <p class="text-gray-300">Since  <span class="math">\\tilde{\\mathcal{P}},\\mathcal{I},\\mathsf{d}</span>  are all efficient, so is  <span class="math">\\mathcal{A}_{\\mathrm{PC}}</span> . Let  <span class="math">\\mathcal{E}_{\\mathrm{PC}}</span>  be the extractor for  <span class="math">\\mathcal{A}_{\\mathrm{PC}}</span> . Note that in the "0-th round",  <span class="math">\\mathcal{A}_{\\mathrm{PC}}</span>  outputs the commitments generated by the indexer  <span class="math">\\mathcal{I}</span> . To capture that these "0-th round" commitments need only satisfy evaluation binding (unlike the commitments in all other rounds), we consider an extractor  <span class="math">\\mathcal{E}_{\\mathrm{PC}}^{\\prime}</span>  that works as follows. For round  <span class="math">i\\in \\{0,\\dots ,k\\}</span>  and verifier messages  <span class="math">\\rho_0,\\ldots ,\\rho_i</span> :</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}_{\\mathrm{PC}}^{\\prime}(\\mathrm{pp},\\rho_0,\\rho_1,\\ldots ,\\rho_i)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\mathsf{srs} \\coloneqq \\mathsf{pp}</span>  and compute  <span class="math">(\\dot{\\mathbf{i}}, \\mathbf{x}, \\mathbf{st}) \\gets \\tilde{\\mathcal{P}}_1(\\mathsf{srs})</span> .</li>

    </ol>

    <p class="text-gray-300">Obtain the field description  <span class="math">\\mathbb{F}\\gets</span>  field(pp).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">i = 0</span> , output polynomials  <span class="math">[p_{0,j}]_{j=1}^{\\mathbf{s}(0)} \\gets \\mathbf{I}(\\mathbb{F}, \\dot{\\mathbf{i}})</span> .</li>

    </ol>

    <p class="text-gray-300">If  <span class="math">i &amp;gt; 0</span> , output polynomials  <span class="math">[p_{i,j}]_{j=1}^{\\mathbf{s}(i)} \\gets \\mathcal{E}_{\\mathrm{PC}}(\\mathsf{st}; \\rho_1, \\ldots, \\rho_i)</span> .</p>

    <p class="text-gray-300">Observe that the probability that  <span class="math">\\mathcal{E}_{\\mathrm{PC}}^{\\prime}</span>  succeeds for  <span class="math">\\mathcal{A}_{\\mathrm{PC}}</span>  is at least the probability that  <span class="math">\\mathcal{E}_{\\mathrm{PC}}</span>  succeeds for  <span class="math">\\mathcal{A}_{\\mathrm{PC}}</span> .</p>

    <p class="text-gray-300">Constructing  <span class="math">\\tilde{\\mathbf{P}}</span> . We define  <span class="math">\\tilde{\\mathbf{P}}</span>  via its  <span class="math">k</span>  next-message functions, by relying on the polynomial commitment extractor  <span class="math">\\mathcal{E}_{\\mathrm{PC}}^{\\prime}</span>  defined above. For round number  <span class="math">i \\in \\{1, \\dots, k\\}</span>  and verifier messages  <span class="math">\\rho_1, \\dots, \\rho_i</span> :</p>

    <p class="text-gray-300"><span class="math">\\tilde{\\mathbf{P}} (\\mathsf{st};\\rho_1,\\ldots ,\\rho_i)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\rho_0\\coloneqq \\bot</span>  and run  <span class="math">\\mathcal{E}_{\\mathrm{PC}}^{\\prime}(\\mathrm{pp},\\rho_0,\\rho_1,\\ldots ,\\rho_i)</span>  to obtain polynomials  <span class="math">p_{i,1},p_{i,2},\\ldots ,p_{i,\\mathbf{s}(i)}\\in \\mathbb{F}[X]</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Check that for every  <span class="math">j \\in [\\mathbf{s}(i)]</span>  it holds that  $\\deg(p_{i,j}) \\leq \\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathbf{i}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, i, j)<span class="math"> . (If not, output  </span>\\bot$ .)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the polynomials  <span class="math">p_{i,1}, p_{i,2}, \\ldots, p_{i,\\mathbf{s}(i)}</span> .</li>

    </ol>

    <p class="text-gray-300">Observe that, by construction,  <span class="math">\\tilde{\\mathbf{P}}</span>  is an admissible prover for AHP.</p>

    <p class="text-gray-300">Analyzing  <span class="math">\\tilde{\\mathbf{P}}</span>  and  <span class="math">\\mathcal{A}_{\\mathrm{PC}}</span> . Define  <span class="math">\\epsilon_{\\mathrm{PC}}(\\lambda) \\coloneqq \\operatorname*{Pr}\\left[\\mathcal{A}_{\\mathrm{PC}}\\right.</span>  wins the extractability game]. We want to argue that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c c} (\\dot {\\mathbf {i}}, \\mathbf {x}) \\notin \\mathcal {L} (\\mathcal {R} _ {\\mathsf {N}}) &amp;amp; \\mathbf {s r s} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, \\mathsf {N}) \\\\ \\wedge &amp;amp; (\\dot {\\mathbf {i}}, \\mathbf {x}, \\mathbf {s t}) \\leftarrow \\tilde {\\mathcal {P}} _ {1} (\\mathbf {s r s}) \\\\ \\langle \\tilde {\\mathcal {P}} _ {2} (\\mathbf {s t}), \\mathcal {V} (\\mathbf {i v k}, \\mathbf {x}) \\rangle = 1 &amp;amp; (\\mathbf {i p k}, \\mathbf {i v k}) \\leftarrow \\mathcal {I} ^ {\\mathbf {s r s}} (\\dot {\\mathbf {i}}) \\end{array} \\right] \\\\ \\leq \\Pr \\left[ \\begin{array}{c c} (\\dot {\\mathbf {i}}, \\mathbf {x}) \\notin \\mathcal {L} (\\mathcal {R} _ {\\mathsf {N}}) &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {P C}. \\mathsf {S e t u p} (1 ^ {\\lambda}, D) \\\\ \\wedge &amp;amp; \\mathbb {F} \\leftarrow \\mathsf {f i e l d} (\\mathsf {p p}) \\\\ \\langle \\tilde {\\mathbf {P}} (\\mathsf {s t}), \\mathbf {V} ^ {\\mathbf {I} (\\mathbb {F}, \\dot {\\mathbf {i}})} (\\mathbb {F}, \\mathbf {x}) \\rangle = 1 &amp;amp; (\\dot {\\mathbf {i}}, \\mathbf {x}, \\mathsf {s t}) \\leftarrow \\tilde {\\mathcal {P}} _ {1} (\\mathsf {p p}) \\end{array} \\right] + \\epsilon_ {\\mathsf {P C}} (\\lambda)  . \\\\ \\end{array}</span></div>

    <p class="text-gray-300">First recall that by construction it holds that  <span class="math">\\mathcal{G}(1^{\\lambda},\\mathsf{N}) = \\mathsf{PC}.Setup(1^{\\lambda},D)</span> . It follows that the distributions of  <span class="math">\\mathsf{srs} / \\mathsf{pp}</span> ,  <span class="math">\\dot{\\mathbf{i}},\\mathbf{x},\\mathbf{st}</span> , as well as the underlying field  <span class="math">\\mathbb{F}</span> , are identical in the two probability expressions above.</p>

    <p class="text-gray-300">Next recall that we have constructed  <span class="math">\\tilde{\\mathbf{P}}</span>  in such a way that, in round  <span class="math">i\\in \\{1,\\ldots ,k\\}</span> ,  <span class="math">\\tilde{\\mathbf{P}}</span>  outputs polynomials that (provided  <span class="math">\\mathcal{E}_{\\mathrm{PC}}^{\\prime}</span>  has succeeded) correspond to the commitments output in round  <span class="math">i</span>  by  <span class="math">\\tilde{\\mathcal{P}}_2</span> . At the same time, we have constructed  <span class="math">\\nu</span>  in such a way that in the first  <span class="math">k</span>  rounds  <span class="math">\\nu</span>  behaves exactly as  <span class="math">\\mathbf{V}</span> , and in the remaining two rounds  <span class="math">\\nu</span>  uses the polynomial commitment scheme to validate, against commitments received from the prover and contained in ivk, the answers claimed by  <span class="math">\\tilde{\\mathcal{P}}_2</span>  in response to  <span class="math">\\mathbf{V}</span> 's query set  <span class="math">Q</span> , and then checks that  <span class="math">\\mathbf{V}</span>  accepts these answers.</p>

    <p class="text-gray-300">Hence, as long as  <span class="math">\\tilde{\\mathcal{P}}</span>  provides correct evaluations for polynomials committed to in ivk, and as long as  <span class="math">\\tilde{\\mathbf{P}}</span>  outputs polynomials that correspond to the commitments output by  <span class="math">\\tilde{\\mathcal{P}}_2</span> , it holds that  <span class="math">\\mathbf{V}</span>  accepts whenever  <span class="math">\\mathcal{V}</span>  accepts. Since  <span class="math">\\tilde{\\mathbf{P}}</span>  relies on the extractor  <span class="math">\\mathcal{E}_{\\mathrm{PC}}^{\\prime}</span>  for the polynomial commitment to find such polynomials (if they exist) and to correctly answer queries to polynomials in ivk,  <span class="math">\\tilde{\\mathbf{P}}</span>  "works" whenever  <span class="math">\\mathcal{E}_{\\mathrm{PC}}^{\\prime}</span>  and  <span class="math">\\tilde{\\mathcal{P}}</span>  do.</p>

    <p class="text-gray-300">We now argue that, whenever  <span class="math">\\mathcal{V}</span>  accepts,  <span class="math">\\mathcal{E}_{\\mathrm{PC}}^{\\prime}</span>  has succeeded, up to the error  <span class="math">\\epsilon_{\\mathrm{PC}}(\\lambda)</span> . This is because the interaction between  <span class="math">\\tilde{\\mathcal{P}}_2</span>  and  <span class="math">\\mathcal{V}</span>  can be re-cast as an extractability game for PC, as we now explain. Define a public-coin challenger  <span class="math">\\mathcal{C}</span>  to output randomness  <span class="math">\\rho_0 \\coloneqq \\bot</span>  in the 0-th round, and to equal the interactive phase of  <span class="math">\\mathbf{V}(\\mathbb{F}, \\mathbb{x})</span>  in the remaining rounds. This means that in the  <span class="math">i</span> -th round (for  <span class="math">i \\in \\{1, \\dots, k\\}</span> ) the challenger  <span class="math">\\mathcal{C}</span>  will output the randomness  <span class="math">\\rho_i</span>  output by  <span class="math">\\mathbf{V}(\\mathbb{F}, \\mathbb{x})</span>  in round  <span class="math">i</span> . Also, define a query sampler  <span class="math">\\mathcal{Q}</span>  to equal the query phase of  <span class="math">\\mathbf{V}(\\mathbb{F}, \\mathbb{x})</span> : given all challenger outputs  <span class="math">[\\rho_j]_{j=1}^k</span>  so far and auxiliary input  <span class="math">\\rho_{k+1}</span> , compute the query set  <span class="math">Q \\coloneqq \\mathbf{Q}_{\\mathbf{V}}(\\mathbb{F}, \\mathbb{x}; \\rho_1, \\dots, \\rho_k, \\rho_{k+1})</span> . Finally, let  <span class="math">\\mathcal{B} = (\\mathcal{B}_1, \\mathcal{B}_2)</span>  be the adversary defined below.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}_1(\\mathsf{pp},[\\rho_j]_{j = 0}^k,Q)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\mathsf{srs} \\coloneqq \\mathsf{pp}</span> .</li>

      <li>Compute  <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{st})\\gets \\tilde{\\mathcal{P}}_1(\\mathfrak{srs})</span></li>

      <li>Compute  <span class="math">\\pmb{v} \\gets \\tilde{\\mathcal{P}}_2(\\mathsf{st}; \\rho_1, \\dots, \\rho_{\\mathbf{k}}, Q)</span> .</li>

      <li>Set  <span class="math">\\mathsf{st}_{\\mathsf{PC}} \\coloneqq (\\mathsf{st}, \\rho_1, \\ldots, \\rho_{\\mathsf{k}}, Q)</span> .</li>

      <li>Output  <span class="math">(\\pmb{v}, \\mathbf{st}_{\\mathrm{PC}})</span> .</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{B}_2(\\mathsf{st}_{\\mathsf{PC}},\\xi)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\mathsf{st}_{\\mathsf{PC}}</span>  as  <span class="math">(\\mathsf{st},\\rho_1,\\ldots ,\\rho_{\\mathsf{k}},Q)</span></li>

      <li>Compute  <span class="math">\\pi \\gets \\tilde{\\mathcal{P}}_2(\\mathsf{st};\\rho_1,\\ldots ,\\rho_{\\mathsf{k}},Q,\\xi)</span></li>

      <li>Output  <span class="math">\\pi</span></li>

    </ol>

    <p class="text-gray-300">Using the above definitions of  <span class="math">\\mathcal{C},\\mathcal{Q},\\mathcal{B}</span>  , and  <span class="math">\\mathcal{E}_{\\mathrm{PC}}^{\\prime}</span>  we obtain the following inequality:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathrm{Pr}\\left[ \\begin{array}{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c} (\\dot{\\mathfrak{s}}, \\mathfrak{x}) \\notin \\mathcal{L}(\\mathcal{R}_{\\mathsf{N}}) &amp; \\mathsf{srs} \\leftarrow \\mathcal{G}(1^{\\lambda}, \\mathsf{N}) \\\\ \\wedge &amp; (\\dot{\\mathfrak{s}}, \\mathfrak{x}, \\mathfrak{st}) \\leftarrow \\tilde{\\mathcal{P}}_{1}(\\mathsf{srs}) \\\\ \\langle \\tilde{\\mathcal{P}}_{2}(\\mathfrak{st}), \\mathcal{V}(\\mathsf{ivk}, \\mathfrak{x}) \\rangle = 1 &amp; (\\mathsf{ipk}, \\mathsf{ivk}) \\leftarrow \\mathcal{I}^{\\mathsf{srs}}(\\dot{\\mathfrak{s}}) \\end{array} \\right]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\leq \\mathrm{Pr}\\left[ \\begin{array}{c} \\begin{array}{c} (\\dot{\\mathfrak{s}},\\mathfrak{x})\\notin \\mathcal{L}(\\mathcal{R}_{\\mathsf{N}})\\\\ \\wedge \\\\ \\mathrm{PC. Check}(\\mathsf{rk},\\boldsymbol {c},\\boldsymbol {d},Q,\\boldsymbol {v},\\pi ,\\xi) = 1\\\\ \\wedge \\\\ \\deg (\\boldsymbol {p})\\leq \\boldsymbol {d}\\leq D\\text{and}\\boldsymbol {v} = \\boldsymbol {p}(Q)\\\\ \\wedge \\\\ \\langle \\tilde{\\mathbf{P}} (\\mathsf{st}),\\mathbf{V}^{\\mathbf{I}(\\mathbb{F},\\dot{\\mathfrak{s}})}(\\mathbb{F},\\mathfrak{x};\\rho_1,\\ldots ,\\rho_{\\mathbf{k}},\\rho_{\\mathbf{k} + 1})\\rangle = 1 \\end{array} \\end{array} \\right]\\left\\{ \\begin{array}{c} \\begin{array}{c} \\mathsf{pp}\\leftarrow \\mathsf{PC}.Setup(1^{\\lambda},D)\\\\ \\mathbb{F}\\leftarrow \\mathsf{field}(\\mathsf{rk})\\\\ (\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{st})\\leftarrow \\tilde{\\mathcal{P}}_{1}(\\mathsf{pp}) \\end{array} \\end{array} \\right.</span>  For  <span class="math">i = 0,\\dots ,k</span>  ..  <span class="math">\\rho_{i}\\gets \\mathcal{C}(\\mathsf{pp},i)</span> <span class="math">([c_{i,j}]_{j = 1}^{s(i)},[d_{i,j}]_{j = 1}^{s(i)})\\gets \\mathcal{A}_{\\mathrm{PC}}(\\mathsf{pp},[\\rho_j]_{j = 0}^i)</span> <span class="math">[p_{i,j}]_{j = 1}^{s(i)}\\gets \\mathcal{E}_{\\mathrm{PC}}^{\\prime}(\\mathsf{pp},[\\rho_j]_{j = 0}^i)</span> <span class="math">Q\\gets \\mathcal{Q}(\\mathsf{pp},[\\rho_j]_{j = 0}^k;\\rho_{\\mathbf{k} + 1})</span> <span class="math">(v,\\mathsf{st})\\gets \\mathcal{B}_1(\\mathsf{pp},[\\rho_j]_{j = 0}^k,Q)</span>  Sample opening challenge  <span class="math">\\xi</span> <span class="math">\\pi \\gets \\mathcal{B}_2(\\mathsf{st},\\xi)</span>  Set  <span class="math">c\\coloneqq [[c_{i,j}]_{j = 1}^{s(i)}]_{i = 0}^{\\mathbf{k}}</span> <span class="math">d\\coloneqq [[d_{i,j}]_{j = 1}^{s(i)}]_{i = 0}^{\\mathbf{k}}</span> <span class="math">(\\mathrm{ck},\\mathrm{rk})\\gets \\mathrm{PC}.Trim^{\\mathrm{pp}}(1^{\\lambda},d)</span>  1</p>

    <p class="text-gray-300">As argued above, whenever  <span class="math">\\mathcal{E}_{\\mathrm{PC}}^{\\prime}</span>  and  <span class="math">\\tilde{\\mathcal{P}}</span>  succeed,  <span class="math">\\tilde{\\mathbf{P}}</span>  does. The first term after the inequality captures the case where the AHP verifier  <span class="math">\\mathbf{V}</span>  is convinced to accept a pair  <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x})</span>  not in the indexed language  <span class="math">\\mathcal{L}(\\mathcal{R}_{\\mathbb{N}})</span> . If  <span class="math">\\mathcal{A}_{\\mathrm{PC}}</span></p>

    <p class="text-gray-300">succeeds, then there is still some chance that  <span class="math">\\tilde{\\mathbf{P}}</span>  succeeds assuming it holds that  <span class="math">\\deg (\\pmb {p})\\leq \\pmb {d}\\leq D</span>  for the polynomials output by  <span class="math">\\mathcal{E}_{\\mathrm{PC}}^{\\prime}</span>  (otherwise  <span class="math">\\tilde{\\mathbf{P}}</span>  outputs  <span class="math">\\perp</span> ). This joint success probability is upper bounded by the probability that just  <span class="math">\\mathcal{A}_{\\mathrm{PC}}</span>  succeeds, which is in turn upper bounded by  <span class="math">\\epsilon_{\\mathrm{PC}}(\\lambda)</span> . Hence the  <span class="math">\\epsilon_{\\mathrm{PC}}(\\lambda)</span>  term above and the inequality rather than equality above. Since the above inequality implies our claim, we have concluded the proof.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathbf{E}</span>  be the extractor for AHP, which by hypothesis has a negligible knowledge soundness error  <span class="math">\\epsilon_{\\mathrm{AHP}}(\\lambda)</span> . Suppose that  <span class="math">\\tilde{\\mathcal{P}} = (\\tilde{\\mathcal{P}}_1,\\tilde{\\mathcal{P}}_2)</span>  is an efficient adversary for ARG. We use  <span class="math">\\tilde{\\mathcal{P}}</span>  to construct an admissible prover  <span class="math">\\tilde{\\mathbf{P}}</span>  for AHP, exactly as in the proof of soundness (see Section 8.2). Then we define the extractor  <span class="math">\\mathcal{E}</span>  for  <span class="math">\\tilde{\\mathcal{P}}</span>  to be as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}(\\mathrm{srs})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">(\\dot{\\mathbf{i}},\\mathbf{x},\\mathbf{st})\\gets \\tilde{\\mathcal{P}}_1(\\mathrm{srs})</span></li>

      <li>Compute  <span class="math">\\mathbb{F}\\gets</span>  field(srs).</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Compute  $\\mathbb{W}\\gets \\mathbf{E}^{\\tilde{\\mathbf{P}} (\\mathbf{st})}(\\mathbb{F},\\dot{\\mathbb{1}},\\mathbb{x},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\dot{\\mathbb{1}})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output w.</li>

    </ol>

    <p class="text-gray-300">Observe that by construction we have the equality:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c c} (\\dot {\\mathbb {1}}, \\mathbb {x}, \\mathbb {w}) \\notin \\mathcal {R} _ {\\mathsf {N}} &amp; \\text {s r s} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, \\mathsf {N}) \\\\ \\wedge &amp; (\\dot {\\mathbb {1}}, \\mathbb {x}, \\mathbb {s t}) \\leftarrow \\tilde {\\mathcal {P}} _ {1} (\\text {s r s}) \\\\ \\langle \\tilde {\\mathcal {P}} _ {2} (\\mathsf {s t}), \\mathcal {V} (\\mathsf {i v k}, \\mathbb {x}) \\rangle = 1 &amp; (\\mathsf {i p k}, \\mathsf {i v k}) \\leftarrow \\mathcal {I} ^ {\\mathsf {s r s}} (\\dot {\\mathbb {1}}) \\\\ &amp; \\mathbb {w} \\leftarrow \\mathcal {E} (\\mathsf {s r s}) \\end{array} \\right] \\\\ = \\Pr \\left[ \\begin{array}{c c} (\\dot {\\mathbb {1}}, \\mathbb {x}, \\mathbb {w}) \\notin \\mathcal {R} _ {\\mathsf {N}} &amp; \\text {p p} \\leftarrow \\text {P C . S e t u p} (1 ^ {\\lambda}, D) \\\\ \\wedge &amp; \\text {F} \\leftarrow \\text {f i e l d} (\\text {p p}) \\\\ \\langle \\tilde {\\mathcal {P}} _ {2} (\\mathsf {s t}), \\mathcal {V} (\\mathsf {r k}, \\mathsf {i v k}, \\mathbb {x}) \\rangle = 1 &amp; (\\dot {\\mathbb {1}}, \\mathbb {x}, \\mathbb {s t}) \\leftarrow \\tilde {\\mathcal {P}} _ {1} (\\mathsf {p p}) \\\\ &amp; (\\mathsf {i p k}, \\mathsf {i v k}) \\leftarrow \\mathcal {I} ^ {\\mathsf {p p}} (\\dot {\\mathbb {1}}) \\\\ &amp; \\mathbb {w} \\leftarrow \\mathbf {E} ^ {\\tilde {\\mathbf {P}} (\\mathsf {s t})} (\\mathbb {F}, \\dot {\\mathbb {1}}, \\mathbb {x}, 1 ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\dot {\\mathbb {1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}) \\end{array} \\right]. \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Similarly to the proof of soundness (see Section 8.2), we can argue the following inequality:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c c} &amp; \\mathsf {p p} \\leftarrow \\mathsf {P C . S e t u p} (1 ^ {\\lambda}, D) \\\\ (\\dot {\\mathbb {1}}, \\mathbb {x}, \\mathbb {w}) \\notin \\mathcal {R} _ {\\mathsf {N}} &amp; \\mathbb {F} \\leftarrow \\mathsf {f i e l d} (\\mathsf {p p}) \\\\ \\wedge &amp; (\\dot {\\mathbb {1}}, \\mathbb {x}, \\mathbb {s t}) \\leftarrow \\tilde {\\mathcal {P}} _ {1} (\\mathsf {p p}) \\\\ \\langle \\tilde {\\mathcal {P}} _ {2} (\\mathsf {s t}), \\mathcal {V} (\\mathsf {i v k}, \\mathbb {x}) \\rangle = 1 &amp; (\\mathsf {i p k}, \\mathsf {i v k}) \\leftarrow \\mathcal {I} ^ {\\mathsf {p p}} (\\dot {\\mathbb {1}}) \\\\ &amp; \\mathbb {w} \\leftarrow \\mathbf {E} ^ {\\tilde {\\mathbf {P}} (\\mathsf {s t})} (\\mathbb {F}, \\dot {\\mathbb {1}}, \\mathbb {x}, 1 ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\dot {\\mathbb {1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}) \\end{array} \\right] \\\\ \\leq \\Pr \\left[ \\begin{array}{c c} (\\dot {\\mathbb {1}}, \\mathbb {x}, \\mathbb {w}) \\notin \\mathcal {R} _ {\\mathsf {N}} &amp; \\mathsf {p p} \\leftarrow \\mathsf {P C . S e t u p} (1 ^ {\\lambda}, D) \\\\ \\wedge &amp; \\mathbb {F} \\leftarrow \\mathsf {f i e l d} (\\mathsf {p p}) \\\\ \\langle \\tilde {\\mathbf {P}} (\\mathsf {s t}), \\mathbf {V} ^ {\\mathbf {I} (\\mathbb {F}, \\dot {\\mathbb {1}})} (\\mathbb {F}, \\mathbb {x}) \\rangle = 1 &amp; (\\dot {\\mathbb {1}}, \\mathbb {x}, \\mathbb {s t}) \\leftarrow \\tilde {\\mathcal {P}} _ {1} (\\mathsf {p p}) \\\\ &amp; \\mathbb {w} \\leftarrow \\mathbf {E} ^ {\\tilde {\\mathbf {P}} (\\mathsf {s t})} (\\mathbb {F}, \\dot {\\mathbb {1}}, \\mathbb {x}, 1 ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\dot {\\mathbb {1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}) \\end{array} \\right] + \\epsilon_ {\\mathsf {P C}} (\\lambda) . \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The knowledge soundness of AHP implies that the probability above is at most  <span class="math">\\epsilon_{\\mathrm{AHP}}(\\lambda)</span> . Since  <span class="math">\\epsilon_{\\mathrm{AHP}}(\\lambda) + \\epsilon_{\\mathrm{PC}}(\\lambda)</span>  is negligible, we have established that the extractor  <span class="math">\\mathcal{E}</span>  for  <span class="math">\\tilde{\\mathcal{P}}</span>  works.</p>

    <p class="text-gray-300">8.4 Proof of Theorem 8.4</p>

    <p class="text-gray-300">Let <span class="math">\\mathbf{S}</span> be the zero knowledge simulator for <span class="math">\\mathsf{AHP}</span> (see definition in Section 4), and let <span class="math">\\mathcal{S}_{\\mathsf{PC}}</span> be the simulator for <span class="math">\\mathsf{PC}</span> (see definition in Section 6). We describe how to construct a (perfect) zero knowledge simulator <span class="math">\\mathcal{S}=(\\mathsf{Setup},\\mathsf{Prove})</span> for <span class="math">\\mathsf{ARG}</span> (see definition in Section 7). Let <span class="math">\\tilde{\\mathcal{V}}=(\\tilde{\\mathcal{V}}_{1},\\tilde{\\mathcal{V}}_{2})</span> be any malicious verifier.</p>

    <p class="text-gray-300">The simulated setup algorithm <span class="math">\\mathcal{S}.\\mathsf{Setup}</span> receives a security parameter <span class="math">\\lambda\\in\\mathbb{N}</span> and size bound <span class="math">\\mathsf{N}\\in\\mathbb{N}</span> as input, and then proceeds as follows. First, <span class="math">\\mathcal{S}.\\mathsf{Setup}</span> uses <span class="math">\\mathsf{N}</span> to compute the same maximum degree bound <span class="math">D\\in\\mathbb{N}</span> computed by the generator <span class="math">\\mathcal{G}</span> (see Eq. (9)). Second, it runs <span class="math">\\mathcal{S}_{\\mathsf{PC}}.\\mathsf{Setup}(1^{\\lambda},D)</span> to sample simulated public parameters <span class="math">\\mathsf{pp}</span> for the polynomial commitment and their trapdoor <span class="math">\\mathsf{trap}</span>, and outputs <span class="math">(\\mathsf{srs},\\mathsf{trap}):=(\\mathsf{pp},\\mathsf{trap})</span>. Let <span class="math">\\mathbb{F}\\in\\mathcal{F}</span> be the field described in the public parameters <span class="math">\\mathsf{pp}</span>.</p>

    <p class="text-gray-300">The zero knowledge game states that first <span class="math">\\tilde{\\mathcal{V}}_{1}</span> receives <span class="math">\\mathsf{srs}</span>, and then outputs an index-instance-witness tuple <span class="math">(\\dot{\\mathsf{i}},\\mathbf{x},\\mathbf{w})</span> and a state <span class="math">\\mathsf{st}</span> to pass onto <span class="math">\\tilde{\\mathcal{V}}_{2}</span>. The proving subroutine of the simulator, <span class="math">\\mathcal{S}.\\mathsf{Prove}</span>, receives <span class="math">(\\mathsf{trap},\\dot{\\mathsf{i}},\\mathbf{x})</span> as input, and interacts with <span class="math">\\tilde{\\mathcal{V}}_{2}(\\mathsf{st})</span> over <span class="math">\\mathsf{k}+2</span> rounds. We construct <span class="math">\\mathcal{S}.\\mathsf{Prove}</span> as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i\\in\\{1,\\ldots,\\mathsf{k}\\}</span>, simulate the polynomial commitments for round <span class="math">i</span> as follows:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Receive a message <span class="math">\\rho_{i}\\in\\mathbb{F}^{*}</span> from <span class="math">\\tilde{\\mathcal{V}}_{2}</span>, and forward it to the AHP simulator <span class="math">\\mathbf{S}(\\mathbb{F},\\dot{\\mathsf{i}},\\mathbf{x})</span>.</li>

      <li>Sample commitment randomness <span class="math">[\\omega_{i,j}]_{j=1}^{\\mathsf{s}(i)}</span>, and then send to <span class="math">\\tilde{\\mathcal{V}}_{2}</span> the simulated commitments below</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$[c_{i,j}]_{j=1}^{\\mathsf{s}(i)}\\leftarrow\\mathcal{S}_{\\mathsf{PC}}.\\mathsf{Commit}(\\mathsf{trap},[\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathsf{i}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,i,j)]_{j=1}^{\\mathsf{s}(i)};[\\omega_{i,j}]_{j=1}^{\\mathsf{s}(i)})\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulate the evaluations in round <span class="math">\\mathsf{k}+1</span> as follows:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Receive a message <span class="math">\\rho_{\\mathsf{k}+1}\\in\\mathbb{F}^{*}</span> from <span class="math">\\tilde{\\mathcal{V}}_{2}</span>.</li>

      <li>Use the (honest) query algorithm of <span class="math">\\mathsf{AHP}</span> to compute the query set <span class="math">Q:=\\mathbf{Q}_{\\mathbf{V}}(\\mathbb{F},\\mathbf{x};\\rho_{1},\\ldots,\\rho_{\\mathsf{k}},\\rho_{\\mathsf{k}+1})</span>, and abort if any query does not satisfy the query checker <span class="math">\\mathbf{C}</span>. (The honest prover would also abort.)</li>

      <li>We need to assemble a list of evaluations <span class="math">\\bm{v}</span>, containing actual evaluations of index polynomials and simulated evaluations of prover polynomials. In more detail, first run the AHP indexer <span class="math">\\mathbf{I}(\\mathbb{F},\\dot{\\mathsf{i}})</span> to obtain polynomials <span class="math">[p_{0,j}]_{j=1}^{\\mathsf{s}(0)}</span>, and evaluate these on (the relevant queries in) the query set <span class="math">Q</span>. Next, forward the query set <span class="math">Q</span> to the AHP simulator <span class="math">\\mathbf{S}(\\mathbb{F},\\dot{\\mathsf{i}},\\mathbf{x})</span> in order to obtain a simulated view, which in particular contains simulated answers for queries to the AHP prover’s polynomials.</li>

      <li>Simulate the evaluation proof in round <span class="math">\\mathsf{k}+2</span> as follows:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Receive a challenge <span class="math">\\xi</span> from <span class="math">\\tilde{\\mathcal{V}}_{2}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Compute $\\pi\\leftarrow\\mathcal{S}_{\\mathsf{PC}}.\\mathsf{Open}(\\mathsf{trap},[[p_{i,j}]_{j=1}^{\\mathsf{s}(i)}]_{i=0}^{\\mathsf{k}},\\bm{v},[[\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathsf{i}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,i,j)]_{j=1}^{\\mathsf{s}(i)}]_{i=0}^{\\mathsf{k}},Q,\\xi;[[\\omega_{i,j}]_{j=1}^{\\mathsf{s}(i)}]_{i=0}^{\\mathsf{k}})<span class="math"> where all polynomials </span>[p_{i,j}]_{j=1}^{\\mathsf{s}(i)}<span class="math"> with </span>i>0<span class="math"> are defined to be zero and the randomness </span>[\\omega_{0,j}]_{j=1}^{\\mathsf{s}(0)}<span class="math"> is set to </span>\\bot$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send <span class="math">\\pi</span> to <span class="math">\\tilde{\\mathcal{V}}_{2}</span>.</li>

    </ol>

    <h6 id="sec-53" class="text-base font-medium mt-4">Lemma 8.7.</h6>

    <p class="text-gray-300">The view of the malicious verifier <span class="math">\\tilde{\\mathcal{V}}=(\\tilde{\\mathcal{V}}_{1},\\tilde{\\mathcal{V}}_{2})</span> while interacting with the honest prover is identically distributed as its view while interacting with the simulator <span class="math">\\mathcal{S}=(\\mathcal{S}_{1},\\mathcal{S}_{2})</span> described above.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The zero knowledge property of <span class="math">\\mathsf{AHP}</span> states that interaction with the honest prover <span class="math">\\mathbf{P}(\\mathbb{F},\\dot{\\mathsf{i}},\\mathbf{x},\\mathbf{w})</span> can be replaced with interaction with the simulator <span class="math">\\mathbf{S}(\\mathbb{F},\\dot{\\mathsf{i}},\\mathbf{x})</span>, which adaptively answers oracle queries of the malicious verifier to prover oracles, <em>provided</em> the number of oracle queries is below the zero knowledge query bound and each query satisfies the query checker. In our setting, the number of oracle queries is bounded by the query complexity <span class="math">q</span> of the <em>honest</em> AHP verifier, because the query set <span class="math">Q</span> is derived via the honest query algorithm run on the messages sent by the malicious argument verifier. Moreover, the honest prover and</p>

    <p class="text-gray-300">simulator ensure that each query in <span class="math">Q</span> satisfies the query checker. This explains why the zero knowledge query bound in Theorem 8.4 is <span class="math">q</span>, and why we consider any polynomial-time query checker in Theorem 8.4.</p>

    <p class="text-gray-300">Next, given that <span class="math">\\mathbf{S}(\\mathbb{F},\\mathbb{i},\\mathbb{x})</span> provides oracle responses that are identically distributed to those of polynomials output by <span class="math">\\mathbf{P}(\\mathbb{F},\\mathbb{i},\\mathbb{x},\\mathbb{w})</span>, we are left to discuss the other information received by the malicious verifier: the commitments (in the first <span class="math">k</span> rounds) and the evaluation proof (in round <span class="math">k+2</span>). The hiding property of the polynomial commitment scheme ensures that the simulator <span class="math">\\mathcal{S}_{\\mathsf{PC}}</span>, by using the trapdoor <span class="math">\\mathsf{trap}</span>, can perfectly simulate these commitments and this evaluation proof. ∎</p>

    <p class="text-gray-300">49</p>

    <p class="text-gray-300">We describe how to obtain a preprocessing zkSNARK with universal and updatable SRS that achieves the efficiency reported in Fig. 1.</p>

    <p class="text-gray-300">The first step is to apply our compiler (Section 8) to two ingredients: the AHP described in Section 5, and the AGM-based polynomial commitment scheme described in Section 6.2 and Appendix D.1. The second step is to apply the Fiat-Shamir transformation to the resulting public-coin preprocessing argument. These “generic” steps immediately yield a preprocessing zkSNARK with universal and updatable SRS that has the same asymptotics as Sonic [Mal+19].¹¹ Moreover, in terms of concrete efficiency, this zkSNARK achieves argument size comparable to Sonic [Mal+19], and also achieves proving and verification times that are close to the state of the art for circuit-specific zkSNARKs [Gro16].</p>

    <p class="text-gray-300">Below in Sections 9.1 and 9.2 we describe optimizations that further reduce argument size, and as a positive side effect also reduce prover and verifier costs. Fig. 1 includes these optimizations.</p>

    <p class="text-gray-300">Before we discuss optimizations, we summarize the argument size that we obtain directly from the compilation mentioned above. Recall that in the offline phase, the AHP indexer, given an index <span class="math">\\hat{\\mathbf{s}} = (\\mathbb{F}, H, K, A, B, C)</span>, outputs for each matrix <span class="math">M \\in \\{A, B, C\\}</span> three polynomials that together define the low-degree extension of <span class="math">M</span>. Then, during the interactive online phase, the prover outputs twelve proof oracles. The verifier queries each of the nine indexer polynomials and the twelve prover polynomials at exactly one location, which amounts to 21 queries.</p>

    <p class="text-gray-300">After compilation, the argument indexer outputs 9 polynomial commitments, and the argument prover outputs 12 commitments, 21 evaluations, and 3 evaluation proofs. In more detail, the argument indexer outputs commitments to <span class="math">\\mathsf{row}_M, \\mathsf{col}_M, \\mathsf{val}_M</span> for each <span class="math">M \\in \\{A, B, C\\}</span>; and the argument prover outputs commitments to the following twelve polynomials: <span class="math">\\hat{w}, \\hat{z}_A, \\hat{z}_B, \\hat{z}_C, h_0, s, h_1, g_1, h_2, g_2, h_3, g_3</span>. The polynomials <span class="math">\\hat{w}, \\hat{z}_A, \\hat{z}_B, \\hat{z}_C, h_0, s, h_1, g_1</span> are all evaluated at the same point <span class="math">\\beta_1</span>; <span class="math">h_2</span> and <span class="math">g_2</span> are evaluated at the same point <span class="math">\\beta_2</span>; and <span class="math">h_3, g_3</span>, and <span class="math">\\mathsf{row}_M, \\mathsf{col}_M, \\mathsf{val}_M</span> for each <span class="math">M \\in \\{A, B, C\\}</span> are all evaluated at the same point <span class="math">\\beta_3</span>. Overall our argument consists of 27 <span class="math">\\mathbb{G}_1</span> elements and 24 <span class="math">\\mathbb{F}_q</span> elements.</p>

    <h2 id="sec-56" class="text-2xl font-bold">9.1 Optimizations for the AHP</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Eliminating <span class="math">h_0</span> and <span class="math">\\hat{z}_C</span>.</strong> The AHP prover <span class="math">\\mathbf{P}</span> sends a polynomial <span class="math">h_0(X)</span> in the first round, and the AHP verifier <span class="math">\\mathbf{V}</span> checks the polynomial equation <span class="math">\\hat{z}_A(X)\\hat{z}_B(X) - \\hat{z}_C(X) = h_0(X)v_H(X)</span> at a random point. This is a standard technique from the probabilistic proof literature to ensure that <span class="math">\\hat{z}_A(X)\\hat{z}_B(X)</span> and <span class="math">\\hat{z}_C(X)</span> agree on <span class="math">H</span>. An alternative (used, e.g., in [Ben+17a]) is to replace each occurrence of <span class="math">\\hat{z}_C(X)</span> in the protocol with the product <span class="math">\\hat{z}_A(X)\\hat{z}_B(X)</span>, which “forces” the desired property without any checks. This increases the degree of certain expressions by $\\deg(\\hat{z}_C) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math">, but this cost in our setting is negligible because it leads to a negligible increase in the soundness error. This eliminates the need to commit to </span>h_0(X)<span class="math"> and </span>\\hat{z}_C(X)$ and later reveal their evaluations, which reduces argument size by two polynomial commitments and two field elements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Minimal zero knowledge query bound.</strong> The query algorithm of the AHP verifier <span class="math">\\mathbf{V}</span> queries each prover polynomial at exactly one location, regardless of the randomness used to generate the queries. In particular, <span class="math">\\hat{w}(X), \\hat{z}_A(X), \\hat{z}_B(X), \\hat{z}_C(X)</span> are queried at exactly one location. So it suffices to set the parameter <span class="math">\\mathsf{b} := 1</span>.</p>

    <p class="text-gray-300"><strong>Eliminating <span class="math">\\sigma_1</span>.</strong> We can sample the random polynomial <span class="math">s(X)</span> conditioned on it summing to zero on <span class="math">H</span>. The prover can thus omit <span class="math">\\sigma_1</span>, because it will always be zero, without affecting zero knowledge.</p>

    <p class="text-gray-300">¹¹The SRS of the zkSNARK is updatable because the SRS of the polynomial commitment scheme is updatable (see Remark 8.2 and Section 6.2). Note also that the query algorithm in the AHP fulfills the admissibility requirement imposed by the polynomial commitment scheme (see Section 6.2), as each query location is sampled at random from a set of superpolynomial size.</p>

    <h4 id="sec-57" class="text-lg font-semibold mt-6">Single low-degree extension for each matrix (unimplemented).</h4>

    <p class="text-gray-300">The AHP indexer <span class="math">\\mathbf{I}</span> constructs the low-degree extensions of the nine functions <span class="math">\\{\\mathsf{row}_{M},\\mathsf{col}_{M},\\mathsf{val}_{M}\\}_{M\\in\\{A,B,C\\}}</span>, which define the low-degree extensions of <span class="math">A,B,C</span>. The AHP verifier <span class="math">\\mathbf{V}</span> queries each of these at a single location. This means that, after compilation, the argument prover must provide <em>nine</em> field elements (the evaluations) as part of the proof.</p>

    <p class="text-gray-300">We can reduce this to only <em>three</em> field elements as follows. We modify the AHP indexer <span class="math">\\mathbf{I}</span> to construct, for each <span class="math">M\\in\\{A,B,C\\}</span>, a <em>single</em> low-degree extension of the functions <span class="math">\\mathsf{row}_{M},\\mathsf{col}_{M},\\mathsf{val}_{M}</span>. Namely, let <span class="math">s_{1},s_{2}\\in\\mathbb{F}</span> be “shifts” such that <span class="math">K</span>, <span class="math">K+s_{1}</span>, and <span class="math">K+s_{2}</span> are pairwise disjoint, and define the set <span class="math">\\bar{K}:=K\\cup(K+s_{1})\\cup(K+s_{2})</span>. Define the function <span class="math">\\mathsf{m}_{M}\\colon\\bar{K}\\to\\mathbb{F}</span> where</p>

    <p class="text-gray-300">\\[ \\mathsf{m}_{M}(\\kappa):=\\begin{cases}\\mathsf{row}_{M}(\\kappa)&\\kappa\\in K\\\\ \\mathsf{col}_{M}(\\kappa-s_{1})&\\kappa\\in K+s_{1}\\\\ \\mathsf{val}_{M}(\\kappa-s_{2})&\\kappa\\in K+s_{2}\\end{cases}\\enspace. \\]</p>

    <p class="text-gray-300">Then Eq. (1) can be rewritten as</p>

    <p class="text-gray-300"><span class="math">\\hat{M}(X,Y):=\\sum_{\\kappa\\in K}u_{H}(X,\\hat{\\mathsf{m}}_{M}(\\kappa))u_{H}(Y,\\hat{\\mathsf{m}}_{M}(\\kappa+s_{1}))\\hat{\\mathsf{m}}_{M}(\\kappa+s_{2})\\enspace.</span> (10)</p>

    <p class="text-gray-300">The modified AHP indexer <span class="math">\\mathbf{I}</span> constructs the three polynomials <span class="math">\\hat{\\mathsf{m}}_{A},\\hat{\\mathsf{m}}_{B},\\hat{\\mathsf{m}}_{C}</span>, and the modified AHP verifier <span class="math">\\mathbf{V}</span> will query each of these at a single location. Thus, after compilation, the argument prover will only need to provide three field elements, instead of nine, as part of the proof. Note that this optimization triples the degree of the polynomials output by the AHP indexer <span class="math">\\mathbf{I}</span>, which after compilation increases the SRS size. Even given this tradeoff our SRS is still shorter than prior work, and furthermore it represents a one-time offline cost (in contrast to argument size, which is a recurring online cost).</p>

    <h4 id="sec-58" class="text-lg font-semibold mt-6">A more efficient holographic lincheck.</h4>

    <p class="text-gray-300">Based on an earlier draft of this work, Chiesa, Ojha, and Spooner <em>[x10]</em> devised a more efficient holographic lincheck, which saves one round of interaction, in a different model of proof system. In Appendix E we show how to incorporate their ideas into our <span class="math">7</span>-message AHP for R1CS (see Fig. 5) to obtain a <span class="math">5</span>-message AHP for R1CS (see Fig. 7). This optimization has no downsides.</p>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">9.2 Optimizations for the polynomial commitment scheme</h3>

    <h4 id="sec-60" class="text-lg font-semibold mt-6">Reducing the cost of hiding commitments.</h4>

    <p class="text-gray-300">The hiding property that we adopt for polynomial commitments (Definition 6.4) ensures that no information is revealed about the committed polynomial regardless of how many evaluations are revealed. Achieving this strong notion has a cost: in our constructions we randomize a commitment <span class="math">c</span> to a polynomial <span class="math">p</span> by additionally committing to a random polynomial <span class="math">\\bar{p}</span> of degree <span class="math">\\deg(p)</span>. Compared to the non-hiding variant, this requires <span class="math">\\deg(p)</span> additional elements in the SRS, and also requires PC.Commit and PC.Open to perform an additional variable-base MSM of size <span class="math">\\deg(p)</span>.</p>

    <p class="text-gray-300">In our compiler, however, the only evaluations the argument verifier sees are those sent by the argument prover, and these are determined by the query sets produced by the query algorithm. This, together with the fact in our AHP each polynomial is queried at exactly one location, implies that we can relax our construction to provide hiding only for a single evaluation per polynomial. Concretely, we can set <span class="math">\\bar{p}</span> to have degree <span class="math">1</span>. (Note that <span class="math">\\bar{p}</span> cannot be a constant because it is used to hide both the commitment to <span class="math">p</span> and to hide the commitment to the witness polynomial <span class="math">w</span>.) This allows us to eliminate (most of) the additional generators from the SRS, and the additional variable-base MSM for PC.Commit and PC.Open.</p>

    <h4 id="sec-61" class="text-lg font-semibold mt-6">Reducing the number of hiding commitments.</h4>

    <p class="text-gray-300">Each hiding commitment, even taking into account the above optimizations, requires an evaluation proof that is one field element larger than a proof in the non-hiding</p>

    <p class="text-gray-300">case. We reduce this overhead by using the fact that only certain polynomials reveal information about the witness and necessitate hiding. In particular, only the polynomials <span class="math">\\hat{w},\\hat{z}_{A},\\hat{z}_{B},\\hat{z}_{C}</span>, <span class="math">s</span>, <span class="math">h_{1}</span>, and <span class="math">g_{1}</span> need hiding commitments. All other polynomials can rely on non-hiding commitments because they can be derived in polynomial-time from the index <span class="math">\\mathbbm{i}</span>. This observation removes a further <span class="math">1</span> field element from the proof.</p>

    <p class="text-gray-300">Eliminating unnecessary degree checks. The notion of polynomial commitment scheme that we consider enables each commitment to guarantee a chosen degree bound that is up to the maximum degree bound chosen for the SRS. This flexibility has a cost: ensuring a degree bound strictly less than the maximum degree bound requires two group elements per commitment, corresponding to unshifted and shifted polynomials respectively. When compiling our AHP, we need this feature only when committing to <span class="math">g_{1},g_{2},g_{3}</span> (the exact degree bound matters for soundness) but for all other polynomials it suffices to rely on the maximum degree bound and so for them we omit the shifted polynomials altogether. This increases the soundness error by a negligible amount (which is fine), and lets us reduce argument size by <span class="math">9</span> group elements.</p>

    <p class="text-gray-300">Batching pairing equations. We can reduce the cost of the argument verifier by batching pairing equations. Recall that, to verify an evaluation proof with evaluation <span class="math">v</span> and point <span class="math">z</span>, PC.Check needs to check the pairing equation <span class="math">e(U-vG-\\gamma\\bar{v}G,H)=e(\\mathsf{w},\\beta H-zH)</span>. In our compiled zkSNARK, PC.Check is invoked three times, each with different values of <span class="math">U</span>, <span class="math">\\mathsf{w}</span>, <span class="math">z</span>, and <span class="math">v</span>. This results in <span class="math">3</span> pairing equations. To reduce the number of pairing equations needed down to just one, we use the following reduction that ensures that the <span class="math">\\mathbb{G}_{2}</span> argument to every pairing is constant:</p>

    <p class="text-gray-300"><span class="math">e(U-vG-\\gamma\\bar{v}G,H)</span> <span class="math">=e(\\mathsf{w},\\beta H-zH)</span> <span class="math">=e(\\mathsf{w},\\beta H)\\cdot e(\\mathsf{w},-zH)</span> <span class="math">=e(\\mathsf{w},\\beta H)\\cdot e(-z\\mathsf{w},H)\\enspace.</span></p>

    <p class="text-gray-300">Hence, we have that</p>

    <p class="text-gray-300"><span class="math">e(U-vG-\\gamma\\bar{v}G+z\\mathsf{w},H)=e(\\mathsf{w},\\beta H)\\enspace.</span></p>

    <p class="text-gray-300">Because we have three proofs to check, the verifier has to check three of the above equations. These equations can be batch verified together as follows. The verifier samples a random field element <span class="math">r</span>, and then uses the identity <span class="math">\\prod_{i}e(G_{i},H)^{r^{i}}=e(\\sum_{i}r^{i}G_{i},H)</span> to check the following equation:</p>

    <p class="text-gray-300"><span class="math">e(\\sum_{i}r^{i}(C_{0,i}-v_{i}G-\\gamma\\bar{v}_{i}G+z_{i}\\mathsf{w}_{i}),H)=e(\\sum_{i}r^{i}\\mathsf{w}_{i},\\beta H)\\enspace.</span></p>

    <p class="text-gray-300">By properties of random linear combinations, the above equation holds only if each of the individual equations also hold (up to a negligible soundness error). In sum, the verifier only needs to evaluate two pairings.</p>

    <p class="text-gray-300">Opening linear combinations of polynomials. The decision procedure of the AHP verifier checks polynomial equations such as</p>

    <p class="text-gray-300"><span class="math">p_{1}(X)+p_{2}(X)p_{3}(X)=p_{4}(X)\\enspace.</span> (11)</p>

    <p class="text-gray-300">It does so by querying the polynomials <span class="math">p_{1},\\ldots,p_{4}</span> at a random point <span class="math">z\\in\\mathbb{F}</span>, and then checking that the above equation holds with respect to the resulting evaluations <span class="math">p_{1}(z),\\ldots,p_{4}(z)</span>. To enable the compiled SNARK verifier to invoke the AHP decision procedure, the SNARK proof must also contain these evaluations. However, if we instead enable the AHP verifier to query <em>linear combinations</em> of polynomial oracles, then one can avoid providing all these evaluations. For example, we can rewrite the check in Equation (11) as follows:</p>

    <p class="text-gray-300"><span class="math">p_{2}(z)=v_{2}\\quad\\text{and}\\quad p_{5}(X):=p_{1}(X)+v_{2}p_{3}(X)-p_{4}(X)=0\\enspace.</span></p>

    <p class="text-gray-300">Then the AHP decision procedure only needs the evaluation <span class="math">p_{2}(z)</span>, which means that the corresponding SNARK proof will contain only <span class="math">1</span> field element, instead of <span class="math">4</span>. For this, we need that the polynomial commitment scheme allows checking evaluations of linear combinations of committed polynomials. The schemes constructed in Appendix D have linearly homomorphic commitments, and so support this feature.</p>

    <p class="text-gray-300">Applying this optimization to the equations in our AHP reduces the proof size of the corresponding compiled SNARK by <span class="math">10</span> field elements.</p>

    <p class="text-gray-300">We describe the cryptographic assumptions that underlie the constructions of polynomial commitment schemes in this paper (Section 6.2). In Appendix A.1 we define bilinear group samplers. In Appendix A.2 we define (a minor variant of) the Strong Diffie-Hellman Assumption. In Appendix A.3 we define (a minor variant of) the Power Knowledge of Exponent Assumption. In Appendix A.4 we recall the Algebraic Group Model.</p>

    <p class="text-gray-300">The cryptographic primitives that we construct in this paper rely on cryptographic assumptions about bilinear groups. We formalize these via a bilinear group sampler, which is a probabilistic polynomial-time algorithm SampleGrp that, on input a security parameter  <span class="math">\\lambda</span>  (represented in unary), outputs a tuple  <span class="math">\\langle \\mathrm{group} \\rangle = (\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, q, G, H, e)</span>  where  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T</span>  are groups of a prime order  <span class="math">q \\in \\mathbb{N}</span> ,  <span class="math">G</span>  generates  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">H</span>  generates  <span class="math">\\mathbb{G}_2</span> , and  <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span>  is a (non-degenerate) bilinear map.</p>

    <p class="text-gray-300">Assumption 1 ([BB04]). The Strong Diffie-Hellman (SDH) Assumption states that for every efficient adversary  <span class="math">\\mathcal{A}</span>  and degree bound  <span class="math">d\\in \\mathbb{N}</span>  the following probability is negligible in  <span class="math">\\lambda</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\langle \\text {g r o u p} \\rangle \\leftarrow \\text {S a m p l e G r p} (1 ^ {\\lambda}) \\\\ C = \\frac {1}{\\beta + c} G &amp;amp; \\beta \\leftarrow \\mathbb {F} _ {q} \\\\ &amp;amp; \\boldsymbol {\\Sigma} \\leftarrow \\{\\{\\beta^ {i} G \\} _ {i = 0} ^ {d}, \\beta H \\} \\\\ &amp;amp; (c, C) \\leftarrow \\mathcal {A} (\\langle \\text {g r o u p} \\rangle , \\boldsymbol {\\Sigma}) \\end{array} \\right].</span></div>

    <p class="text-gray-300">The non-hiding variant of our polynomial commitment scheme relies on the PKE assumption below, while the variant relies on the dPKE assumption below.</p>

    <p class="text-gray-300">Assumption 2 ([Gro10]). The Power Knowledge of Exponent (PKE) Assumption states that for every efficient adversary  <span class="math">\\mathcal{A}</span>  and degree bound  <span class="math">d\\in \\mathbb{N}</span>  there exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that for every benign auxiliary input distribution  <span class="math">\\mathcal{Z}</span>  the following probability is negligible in  <span class="math">\\lambda</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\langle \\text {g r o u p} \\rangle \\leftarrow \\text {S a m p l e G r p} (1 ^ {\\lambda}) \\\\ G _ {1} = \\alpha G _ {0} &amp;amp; \\mathbb {z} \\leftarrow \\mathcal {Z} (\\langle \\text {g r o u p} \\rangle) \\\\ \\wedge &amp;amp; \\alpha , \\beta \\leftarrow \\mathbb {F} _ {q} \\\\ G _ {0} \\neq \\sum_ {i = 0} ^ {d} a _ {i} \\beta^ {i} G &amp;amp; \\boldsymbol {\\Sigma} \\leftarrow \\{\\{\\beta^ {i} G, \\alpha \\beta^ {i} G \\} _ {i = 0} ^ {d}, \\alpha H, \\beta H \\} \\\\ &amp;amp; (G _ {0}, G _ {1}) \\leftarrow \\mathcal {A} (\\langle \\text {g r o u p} \\rangle , \\boldsymbol {\\Sigma}, \\mathbb {z}) \\\\ &amp;amp; (a _ {0}, \\ldots , a _ {d}) \\leftarrow \\mathcal {E} (\\langle \\text {g r o u p} \\rangle , \\boldsymbol {\\Sigma}, \\mathbb {z}) \\end{array} \\right].</span></div>

    <p class="text-gray-300">Assumption 3. The duplex Power Knowledge of Exponent Assumption (dPKE) states that for every efficient adversary  <span class="math">\\mathcal{A}</span>  and degree bound  <span class="math">d\\in \\mathbb{N}</span>  there exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that for every benign</p>

    <p class="text-gray-300">auxiliary input distribution  <span class="math">\\mathcal{Z}</span>  the following probability is negligible in  <span class="math">\\lambda</span> :</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G1=αG0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">⟨group⟩← SampleGrp(1λ)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G0≠∑i=0daiβiG+∑i=0dbiγβiG</td>

            <td class="px-3 py-2 border-b border-gray-700">z← Z(⟨group⟩)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   | α,β,γ← Fq  |</p>

    <p class="text-gray-300">|   |   | Σ← {{βiG,αβiG,γβiG,αγβiG}i=0,αH,βH}  |</p>

    <p class="text-gray-300">|   |   | (G0,G1)← A(⟨group⟩, Σ, z)  |</p>

    <p class="text-gray-300">|   |   | (a0,...,ad,b0,...,bd)← E(⟨group⟩, Σ, z)  |</p>

    <p class="text-gray-300">Remark A.1 (benign auxiliary inputs). Extraction with auxiliary input requires that the auxiliary input is sampled from a "benign" distribution, as discussed in [BP15; Bit+16]. In this paper we only rely on auxiliary inputs that consist of a prescribed number of random field elements, which are indeed considered benign.</p>

    <p class="text-gray-300">Remark A.2 (asymmetric PKE). The PKE assumption in [Gro10] is stated for symmetric bilinear group samplers  <span class="math">(\\mathbb{G}_1 = \\mathbb{G}_2)</span> . Instead, like many prior works, we consider asymmetric bilinear group samplers due to efficiency reasons. Our approach to adapting PKE to the asymmetric setting differs from that taken in prior works such as [Gen+13; Dan+14]. Prior constructions rely on secret powers of  <span class="math">\\beta</span>  in  <span class="math">\\mathbb{G}_2</span>  for both completeness and security (and in particular incur the costs of many  <span class="math">\\mathbb{G}_2</span>  exponentiations). In contrast, our constructions (of polynomial commitment schemes) do not need secret powers of  <span class="math">\\beta</span>  in  <span class="math">\\mathbb{G}_2</span> , for either completeness or security, and therefore are not part of the inputs to the adversary. (Also see Appendix A.5.)</p>

    <p class="text-gray-300">Remark A.3 (prior duplex variants). The dPKE assumption is similar to, but different from, the assumption used in [Zha+17b; Zha+17a]. Namely, in dPKE the instance contains powers of  <span class="math">\\beta</span>  with respect to a different generator  <span class="math">\\gamma G</span> , whereas the assumption in [Zha+17b; Zha+17a] contains powers of  <span class="math">\\gamma</span>  with respect to  <span class="math">G</span> .</p>

    <p class="text-gray-300">The PKE assumption implies a similar assumption where the adversary may output multiple knowledge commitments and its corresponding extractor must extract a linear combination for each knowledge commitment. We call this assumption MPKE, where the letter "M" denotes "multiple". MPKE implies PKE, so the two assumptions are equivalent. We use MPKE to prove extractability of the non-hiding variant our polynomial commitment scheme. In order to prove extractability of the hiding variant we rely on dMPKE, an analogous generalization of dPKE to the case of multiple knowledge commitments.</p>

    <p class="text-gray-300">Assumption 4. The MPKE assumption states that for every efficient adversary  <span class="math">\\mathcal{A}</span>  and degree bound  <span class="math">d\\in \\mathbb{N}</span>  there exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that for every benign auxiliary input distribution  <span class="math">\\mathcal{Z}</span> , the following probability is negligible in  <span class="math">\\lambda</span> :</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∃i∈[n] such that</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">⟨group⟩← SampleGrp(1λ)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Gi,1=αGi,0</td>

            <td class="px-3 py-2 border-b border-gray-700">z← Z(⟨group⟩)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">α,β← Fq</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Gi,0≠∑j=0dai,jβjG</td>

            <td class="px-3 py-2 border-b border-gray-700">Σ← {{βiG,αβiG}i=0,βH,αH}</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   | [(Gi,0,Gi,1)]i=1n← A(⟨group⟩, Σ, z)  |</p>

    <p class="text-gray-300">|   |   | [[ai,j]j=0]i=1n← E(⟨group⟩, Σ, z)  |</p>

    <p class="text-gray-300">Lemma A.4. The PKE and MPKE assumptions are equivalent.</p>

    <p class="text-gray-300">Proof. That MPKE implies PKE follows because MPKE is a generalization of PKE. For the reverse direction, PKE implies MPKE because a successful adversary  <span class="math">\\mathcal{A}</span>  against MPKE can be used to construct a successful adversary  <span class="math">\\mathcal{B}</span>  against PKE that projects the output of  <span class="math">\\mathcal{A}</span>  to one of the "lucky" entries. In more detail, let  <span class="math">\\mathcal{B}_i(\\langle \\mathrm{group} \\rangle, \\Sigma, \\mathbb{Z})</span>  be the adversary that returns the  <span class="math">i</span> -th commitment output by  <span class="math">\\mathcal{A}(\\langle \\mathrm{group} \\rangle, \\Sigma, \\mathbb{Z})</span> . Let  <span class="math">\\mathcal{E}_{\\mathcal{B}_i}</span>  be any PKE extractor corresponding to  <span class="math">\\mathcal{B}_i</span> . Consider the following MPKE extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  for  <span class="math">\\mathcal{A}</span> : given  <span class="math">(\\langle \\mathrm{group} \\rangle, \\Sigma, \\mathbb{Z})</span> , compute  <span class="math">[a_{i,j}]_{j=0}^d \\gets \\mathcal{E}_{\\mathcal{B}_i}(\\langle \\mathrm{group} \\rangle, \\Sigma, \\mathbb{Z})</span>  for each  <span class="math">i \\in [n]</span> , and output  <span class="math">[[a_{i,j}]_{j=0}^{d}]_{i=1}^n</span> . Observe that  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  can fail only if at least one of the PKE extractors  <span class="math">\\mathcal{E}_{\\mathcal{B}_i}</span>  fails. Thus, if  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  fails with non-negligible probability  <span class="math">\\mu(\\lambda)</span> , then by averaging at least one  <span class="math">\\mathcal{E}_{\\mathcal{B}_i}</span>  fails with non-negligible probability  <span class="math">\\mu(\\lambda)/n</span> , contradicting the fact that assumption PKE holds. We conclude that MPKE holds if PKE holds.</p>

    <p class="text-gray-300">Assumption 5. The dMPKE assumption states that for every efficient adversary  <span class="math">\\mathcal{A}</span>  and degree bound  <span class="math">d\\in \\mathbb{N}</span>  there exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that for every benign auxiliary input distribution  <span class="math">\\mathcal{Z}</span> , the following probability is negligible in  <span class="math">\\lambda</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\exists i \\in [ n ] \\text {s u c h t h a t} &amp;amp; \\langle \\text {g r o u p} \\rangle \\leftarrow \\text {S a m p l e G r p} (1 ^ {\\lambda}) \\\\ G _ {i, 1} = \\alpha G _ {i, 0} &amp;amp; \\mathbb {Z} \\leftarrow \\mathcal {Z} (\\langle \\text {g r o u p} \\rangle) \\\\ \\wedge &amp;amp; \\alpha , \\beta , \\gamma \\leftarrow \\mathbb {F} _ {q} \\\\ G _ {i, 0} \\neq \\sum_ {j = 0} ^ {d} a _ {i, j} \\beta^ {j} G + \\sum_ {j = 0} ^ {d} (b _ {i, j} \\gamma \\beta^ {j}) G &amp;amp; \\Sigma \\leftarrow \\{\\{\\beta^ {i} G, \\alpha \\beta^ {i} G, \\gamma \\beta^ {i} G, \\alpha \\gamma \\beta^ {i} G \\} _ {i = 0} ^ {d}, \\alpha H, \\beta H \\} \\\\ &amp;amp; [ (G _ {i, 0}, G _ {i, 1}) ] _ {i = 1} ^ {n} \\leftarrow \\mathcal {A} (\\langle \\text {g r o u p} \\rangle , \\Sigma , \\mathbb {Z}) \\\\ &amp;amp; [ [ (a _ {i, j}, b _ {i, j}) ] _ {j = 0} ^ {d} ] _ {i = 1} ^ {n} \\leftarrow \\mathcal {E} (\\langle \\text {g r o u p} \\rangle , \\Sigma , \\mathbb {Z}) \\end{array} \\right]</span></div>

    <p class="text-gray-300">Lemma A.5. The dPKE and dMPKE assumptions are equivalent.</p>

    <p class="text-gray-300">Proof. Follows via straightforward modifications to the proof of Lemma A.4.  <span class="math">\\square</span></p>

    <p class="text-gray-300">Remark A.6 (dMPKE\\<em>). For technical reasons, our proof of hiding (Appendix B.2.3) for the hiding variant of our polynomial commitment scheme relies on the dMPKE\\</em> assumption, which is a variant of dMPKE where  <span class="math">\\gamma</span>  is sampled not from  <span class="math">\\mathbb{F}_q</span> , but rather from  <span class="math">\\mathbb{F}_q^<em></span> . dMPKE implies dMPKE\\</em> via a straightforward reduction: given an adversary  <span class="math">\\mathcal{A}</span>  against dMPKE\\*, one can construct an adversary  <span class="math">\\mathcal{B}</span>  against dMPKE that, on input  <span class="math">(\\langle \\mathrm{group} \\rangle, \\Sigma, \\mathbb{Z})</span> , aborts if  <span class="math">\\gamma G = G</span> , and outputs  <span class="math">\\mathcal{A}(\\langle \\mathrm{group} \\rangle, \\Sigma, \\mathbb{Z})</span>  otherwise. Because  <span class="math">\\gamma = 0</span>  with probability at most  <span class="math">1/q</span> ,  <span class="math">\\mathcal{B}</span>  and  <span class="math">\\mathcal{A}</span>  (and thus  <span class="math">\\mathcal{E}_{\\mathcal{B}}</span>  and  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> ) differ in success probability by only  <span class="math">1/q</span> .</p>

    <p class="text-gray-300">In order to achieve additional efficiency, we also construct polynomial commitment schemes in the Algebraic Group Model (AGM) [FKL18], which replaces specific knowledge assumptions (such as Power Knowledge of Exponent assumptions). In the AGM, all algorithms are modeled as algebraic, which means that whenever an algorithm outputs a group element  <span class="math">G</span> , the algorithm must also output an "explanation" of  <span class="math">G</span>  in terms of the group elements that it has seen.</p>

    <p class="text-gray-300">Definition A.7 (algebraic algorithm). Let  <span class="math">\\mathbb{G}</span>  be a cyclic group of prime order  <span class="math">q</span>  and  <span class="math">\\mathcal{A}_{\\mathrm{alg}}</span>  a probabilistic algorithm run on initial inputs including description  <span class="math">\\langle \\mathrm{group} \\rangle</span>  of  <span class="math">\\mathbb{G}</span> . During its execution  <span class="math">\\mathcal{A}_{\\mathrm{alg}}</span>  may interact with oracles or other parties and receive further inputs including obliviously sampled group elements (which it cannot sample directly 12). Let  <span class="math">L \\in \\mathbb{G}^n</span>  be the list of all group elements  <span class="math">\\mathcal{A}_{\\mathrm{alg}}</span>  has been given so far such that all</p>

    <p class="text-gray-300">other inputs it has received do not depend in any way on group elements <span class="math">^{13}</span> . We call <span class="math">\\mathcal{A}_{\\mathrm{alg}}</span> algebraic if whenever it outputs a group element <span class="math">G \\in \\mathbb{G}</span> it also outputs a vector <span class="math">\\mathbf{a} = [a_i]_{i=1}^n \\in \\mathbb{F}_q^n</span> such that <span class="math">G = \\sum_{i=1}^n a_i L_i</span>. The coefficients <span class="math">\\mathbf{a}</span> are called the "representation" of <span class="math">G</span> with respect to <span class="math">\\mathbf{L}</span>, denoted <span class="math">G := \\langle \\mathbf{a}, \\mathbf{L} \\rangle</span>.</p>

    <p class="text-gray-300"><strong>Remark A.8 (AGM vs. GGM).</strong> The Algebraic Group Model (AGM) [FKL18] is weaker than the Generic Group Model (GGM) [Sho97; Mau05] but is stronger than the plain model. Indeed, every generic algorithm is an algebraic algorithm [PV05], and so anything proved secure in the AGM is also secure in the GGM. On the other hand, the AGM captures non-generic algorithms that exploit the representation of group elements. For example, index-calculus and some factoring attacks fall outside the class of generic algorithms and apply only over groups in which the elements are represented as integers. Furthermore, there exist (pathological) algebraic-but-not-generic algorithms that can be used to construct schemes that are secure in the GGM, but are insecure in the standard and algebraic group models [Den02]. At present, it is not known if such a scheme could be constructed to illustrate a similar gap between the AGM and the standard model.</p>

    <p class="text-gray-300">To analyze the hardness of an assumption in the GGM one must explicitly augment the model by any functionality offered by the structure of the group, e.g., providing a pairing oracle <span class="math">\\mathcal{A}^{e(\\cdot,\\cdot)}</span>. However, in the AGM, the adversary has direct access to <span class="math">e</span> (and thus to its description). Though it is widely believe that <span class="math">e</span> provides no additional information about the elements of <span class="math">\\mathbb{G}</span>, the AGM captures a hypothetical exploit without needing to explicitly model it and considers the relation between two problems instead of their <em>individual hardness</em>. This means that if one can reduce problem A to problem G in the AGM and A is conjectured to remain hard with respect to algebraic algorithms, even when given <span class="math">e</span>, then G also remains hard. No similar statement can be inferred in the GGM.</p>

    <h2 id="sec-68" class="text-2xl font-bold">A.5 The effect of powers on security</h2>

    <p class="text-gray-300">The SDH assumption and PKE assumption rely (in particular) on the hardness of computing the discrete logarithm <span class="math">\\beta</span> when given the generator <span class="math">G \\in \\mathbb{G}_1</span> and challenge <span class="math">\\beta G \\in \\mathbb{G}_1</span>. In fact, in both cases the adversary is also given elements of the form <span class="math">\\beta^i G</span>, which can have a small, but noticeable, impact on concrete security. There are generic algorithms [BG04; KKM07; Che10] that, for any power <span class="math">i</span> such that <span class="math">i \\mid (q - 1)</span> where <span class="math">q</span> is the prime order of <span class="math">\\mathbb{G}_1</span>, compute the secret <span class="math">\\beta</span> in time <span class="math">O(\\sqrt{q / i} + \\sqrt{i})</span>, improving on the usual <span class="math">O(\\sqrt{q})</span>-time algorithm. This "polynomial speedup" should be taken into account in practice.</p>

    <p class="text-gray-300">Moreover, while our construction of polynomial commitment schemes in Appendix B does not use powers of <span class="math">\\beta</span> in <span class="math">\\mathbb{G}_2</span>, other schemes that wish to share the same SRS might. Hence it is natural to discuss whether our construction in Appendix B remains secure even in the presence of elements of the form <span class="math">\\beta^i H</span>. Our security reduction to the SDH and PKE assumptions does not rely on the absence of powers of <span class="math">\\beta</span> in <span class="math">\\mathbb{G}_2</span>, and in particular can be modified in a straightforward way to obtain a security reduction to variants of the SDH and PKE assumptions that additionally give to the adversary the additional elements in <span class="math">\\mathbb{G}_2</span>. These variants, while similarly plausible assumptions, provide the adversary with a further polynomial speedup that must also be taken into account in practice. Namely, given the generator <span class="math">G \\in \\mathbb{G}_1</span>, challenge <span class="math">\\beta G</span>, and elements of the form <span class="math">\\beta^i G \\in \\mathbb{G}_1</span> and <span class="math">\\beta^j H \\in \\mathbb{G}_2</span>, one can use the pairing to compute <span class="math">e(G, H)^{\\beta^{i+j}} = e(\\beta^i G, \\beta^j H)</span>. If <span class="math">i + j \\mid q - 1</span>, then the generic algorithms mentioned above compute <span class="math">\\beta</span> in time <span class="math">O(\\sqrt{q / (i + j)} + \\sqrt{i + j})</span>.</p>

    <p class="text-gray-300">56</p>

    <p class="text-gray-300">We construct (succinct) polynomial commitment schemes that support a single degree bound chosen at setup time. We temporarily restrict our attention to the case where, in the reveal phase, all polynomials are evaluated at the same evaluation point. (We will relax this restriction in Appendix D.) This section is organized as follows: in Appendix B.1 we provide formal definitions, in Appendix B.2 we give a construction in the plain model under knowledge assumptions, and in Appendix B.3 we give a more efficient construction in the algebraic group model under standard assumptions. In both cases we provide non-hiding and hiding variants.</p>

    <p class="text-gray-300">A polynomial commitment scheme over a field family  <span class="math">\\mathcal{F}</span>  for a single degree bound and a single evaluation point is a tuple of algorithms  <span class="math">\\mathrm{PC}_{\\mathrm{s}} = (\\mathrm{Setup}, \\mathrm{Commit}, \\mathrm{Open}, \\mathrm{Check})</span>  with the following syntax.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{PC}_{\\mathsf{s}}.\\mathsf{Setup}(1^{\\lambda},D)\\to (\\mathsf{ck},\\mathsf{rk})</span> . On input a security parameter  <span class="math">\\lambda</span>  (in unary), and a maximum degree bound  <span class="math">D\\in \\mathbb{N}</span> ,  <span class="math">\\mathsf{PC}_{\\mathsf{s}}.\\mathsf{Setup}</span>  samples a key pair  <span class="math">(\\mathsf{ck},\\mathsf{rk})</span> . The keys contain the description of a finite field  <span class="math">\\mathbb{F}\\in \\mathcal{F}</span> .</li>

      <li><span class="math">\\mathsf{PC}_{\\mathsf{s}}.\\mathsf{Commit}(\\mathsf{ck},\\pmb {p};\\pmb {\\omega})\\to \\pmb{c}</span> . On input ck and univariate polynomials  <span class="math">\\pmb {p} = [p_i]_{i = 1}^n</span>  over the field  <span class="math">\\mathbb{F}</span>  with  <span class="math">\\deg (p_i)\\leq D</span> ,  <span class="math">\\mathsf{PC}_{\\mathsf{s}}.\\mathsf{Commit}</span>  outputs commitments  <span class="math">\\pmb {c} = [c_i]_{i = 1}^n</span>  to the polynomials  <span class="math">\\pmb{p}</span> . The randomness  <span class="math">\\pmb {\\omega} = [\\omega_{i}]_{i = 1}^{n}</span>  is used if the commitments  <span class="math">\\pmb{c}</span>  are meant to be hiding.</li>

      <li><span class="math">\\mathsf{PC}_{\\mathsf{s}}.\\mathsf{Open}(\\mathsf{ck},\\pmb {p},z,\\xi ;\\pmb {\\omega})\\to \\pi</span>  . On input ck, univariate polynomials  <span class="math">\\pmb {p} = [p_i]_{i = 1}^n</span>  , evaluation point  <span class="math">z\\in \\mathbb{F}</span>  and opening challenge  <span class="math">\\xi</span>  ,  <span class="math">\\mathsf{PC}_{\\mathsf{s}}.\\mathsf{Open}</span>  outputs an evaluation proof  <span class="math">\\pi</span>  . The randomness  <span class="math">\\omega</span>  must equal the one previously used in  <span class="math">\\mathsf{PC}_{\\mathsf{s}}.\\mathsf{Commit}</span></li>

      <li><span class="math">\\mathsf{PC}_{\\mathsf{s}}.\\mathsf{Check}(\\mathsf{rk},\\pmb {c},z,\\pmb {v},\\pi ,\\xi)\\in \\{0,1\\}</span> . On input rk, commitments  <span class="math">\\pmb {c} = [c_i]_{i = 1}^n</span> , evaluation point  <span class="math">z\\in \\mathbb{F}</span> , alleged evaluations  <span class="math">\\pmb {v} = [v_i]_{i = 1}^n</span> , evaluation proof  <span class="math">\\pi</span> , and opening challenge  <span class="math">\\xi</span> ,  <span class="math">\\mathsf{PC}_{\\mathsf{s}}.\\mathsf{Check}</span>  outputs 1 if  <span class="math">\\pi</span>  attests that, for each  <span class="math">i\\in [n]</span> , the polynomial committed in  <span class="math">c_{i}</span>  has degree at most  <span class="math">D</span>  and evaluates to  <span class="math">v_{i}</span>  at  <span class="math">z</span> .</li>

    </ul>

    <p class="text-gray-300">The polynomial commitment scheme satisfies the completeness and extractability properties defined below. The polynomial commitment scheme is (perfectly) hiding if it also satisfies the hiding property defined below.</p>

    <p class="text-gray-300">Definition B.1 (Completeness). For every maximum degree bound  <span class="math">D \\in \\mathbb{N}</span>  and efficient adversary  <span class="math">\\mathcal{A}</span>  it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\deg (\\boldsymbol {p}) \\leq D &amp;amp; (c k, r k) \\leftarrow P C _ {s}. S e t u p (1 ^ {\\lambda}, D) \\\\ \\Downarrow &amp;amp; (\\boldsymbol {p}, z, \\xi) \\leftarrow A (c k, r k) \\\\ P C _ {s}. C h e c k (r k, \\boldsymbol {c}, z, \\boldsymbol {v}, \\pi , \\xi) = 1 &amp;amp; \\boldsymbol {c} \\leftarrow P C _ {s}. C o m m i t (c k, \\boldsymbol {p}) \\\\ &amp;amp; \\boldsymbol {v} \\leftarrow \\boldsymbol {p} (z) \\\\ &amp;amp; \\pi \\leftarrow P C _ {s}. O p e n (c k, \\boldsymbol {p}, z, \\xi) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Definition B.2 (Extractability). For every maximum degree bound  <span class="math">D \\in \\mathbb{N}</span>  and efficient adversary  <span class="math">\\mathcal{A}</span> , there exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that for every round bound  <span class="math">r \\in \\mathbb{N}</span> , efficient public-coin challenger  <span class="math">\\mathcal{C}</span> , efficient query sampler  <span class="math">\\mathcal{Q}</span> , and efficient adversary  <span class="math">\\mathcal{B} = (\\mathcal{B}_1, \\mathcal{B}_2)</span>  the following probability is negligibly close</p>

    <p class="text-gray-300">to 1:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PCs.Check(rk, c, z, v, π,ξ) = 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(ck, rk) ← PCs.Setup(1λ, D)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">↓</td>

            <td class="px-3 py-2 border-b border-gray-700">For i = 1, ..., r: ρi ← C(ck, rk, i) ci ← A(ck, rk, [ρj]rj=1) pi ← E(ck, rk, [ρj]rj=1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">deg(p) ≤ D and v = p(z)</td>

            <td class="px-3 py-2 border-b border-gray-700">Q ← Q(ck, rk, [ρj]rj=1) (v, st) ← B1(ck, rk, [ρj]rj=1, Q) Sample opening challengeξ π ← B2(st,ξ) Set [ci]i=1n := [ci]i=1, [pi]i=1n := [pi]i=1, [di]i=1n := [di]i=1 Parse Q as T × {z} for some T ⊆ [n] and z ∈ F Set c := [ci]i∈T, p := [pi]i∈T, d := [di]i∈T</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition B.3 (Succinctness). A polynomial commitment scheme is succinct if the size of commitments, the size of evaluation proofs, and the time to check an opening are all independent of the degree of the committed polynomials. That is,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb{c}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n \\cdot \\mathrm{poly}(\\lambda)<span class="math"> ,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{poly}(\\lambda)<span class="math"> , and time(Check) =  </span>n \\cdot \\mathrm{poly}(\\lambda)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition B.4 (Hiding). There exists a polynomial-time simulator  <span class="math">S =</span>  (Setup, Commit, Open) such that, for every maximum degree bound  <span class="math">D \\in \\mathbb{N}</span> , round bound  <span class="math">r \\in \\mathbb{N}</span> , and (even unbounded) non-uniform adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2, \\mathcal{A}_3)</span> , the probability that  <span class="math">b = 1</span>  in the following two experiments is identical.</p>

    <p class="text-gray-300">Real(1 <span class="math">\\lambda</span> , D, A):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{ck},\\mathrm{rk})\\gets \\mathrm{PC}_{\\mathrm{s}}\\cdot \\mathrm{Setup}(1^{\\lambda},D)</span></li>

      <li>Letting  <span class="math">c_0 \\coloneqq \\bot</span> , for  <span class="math">i = 1, \\dots, r</span> :</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">(\\pmb {p}_i,\\mathsf{h}_i)\\gets \\mathcal{A}_1(\\mathrm{ck},\\mathrm{rk},\\pmb {c}_0,\\pmb {c}_1,\\dots ,\\pmb {c}_{i - 1}).</span> (b) If  <span class="math">\\mathsf{h}_i = 0</span> : sample commitment randomness  <span class="math">\\omega_i</span> . (c) If  <span class="math">\\mathsf{h}_i = 1</span> : set randomness  <span class="math">\\omega_i</span>  to  <span class="math">\\perp</span> . (d)  <span class="math">c_{i}\\gets \\mathrm{PC}_{\\mathrm{s}}</span>  .Commit  <span class="math">(\\mathrm{ck},\\pmb {p}_i;\\omega_i)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pmb{c} \\coloneqq [\\pmb{c}_i]_{i=1}^r, \\pmb{p} \\coloneqq [\\pmb{p}_i]_{i=1}^r, \\pmb{\\omega} \\coloneqq [\\pmb{\\omega}_i]_{i=1}^r.</span></li>

      <li><span class="math">([Q_j]_{j = 1}^r,[\\xi_j]_{j = 1}^r,\\mathsf{st})\\gets \\mathcal{A}_2(\\mathsf{ck},\\mathsf{rk},\\pmb {c}).</span></li>

      <li>For  <span class="math">j\\in [\\tau ]</span> <span class="math">\\pi_j\\gets \\mathsf{PC}_{\\mathsf{s}}.\\mathsf{Open}(\\mathsf{ck},\\pmb {p},Q_j,\\xi_j;\\omega).</span></li>

      <li><span class="math">b\\gets \\mathcal{A}_3(\\mathsf{st},[\\pi_j]_{j = 1}^\\tau)</span></li>

    </ol>

    <p class="text-gray-300">Ideal  <span class="math">(1^{\\lambda},D,\\mathcal{A})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{ck},\\mathrm{rk},\\mathrm{trap})\\gets S.\\mathrm{Setup}(1^{\\lambda},D)</span></li>

      <li>Letting  <span class="math">c_0 \\coloneqq \\bot</span> , for  <span class="math">i = 1, \\dots, r</span> :</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">(\\pmb {p}_i,\\mathsf{h}_i)\\gets \\mathcal{A}_1(\\mathrm{ck},\\mathrm{rk},\\pmb {c}_0,\\pmb {c}_1,\\dots ,\\pmb {c}_{i - 1}).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(b) If  <span class="math">\\mathsf{h}_i = 0</span> : sample randomness  <span class="math">\\omega_i</span>  and compute simulated commitments  <span class="math">c_i \\gets S</span> . Commit(trap,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">; \\omega_i$ ).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(c) If  <span class="math">\\mathsf{h}_i = 1</span> : set  <span class="math">\\omega_i \\coloneqq \\bot</span>  and compute (real) commitments  <span class="math">c_i \\gets \\mathsf{PC}_{\\mathsf{s}}</span> . Commit  <span class="math">(\\mathsf{ck}, p_i; \\omega_i)</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pmb{c} \\coloneqq [\\pmb{c}_i]_{i=1}^r, \\pmb{p} \\coloneqq [\\pmb{p}_i]_{i=1}^r, \\pmb{\\omega} \\coloneqq [\\pmb{\\omega}_i]_{i=1}^r.</span></li>

      <li>Zero out hidden polynomials:  <span class="math">\\pmb{p}^{\\prime} \\coloneqq [\\mathsf{h},\\pmb{p}_{i}]_{i = 1}^{\\tau}</span> .</li>

      <li><span class="math">([Q_j]_{j=1}^\\tau, [\\xi_j]_{j=1}^\\tau, \\mathsf{st}) \\gets \\mathcal{A}_2(\\mathsf{ck}, \\mathsf{rk}, \\mathsf{c})</span> .</li>

      <li>For  <span class="math">j\\in [\\tau ]</span> <span class="math">\\pi_j\\gets S.\\mathrm{Open}(\\mathrm{trap},\\pmb {p}&#x27;,\\pmb {p}(Q_j),Q_j,\\xi_j;\\omega).</span></li>

      <li><span class="math">b\\gets \\mathcal{A}_3(\\mathsf{st},[\\pi_j]_{j = 1}^\\tau)</span></li>

    </ol>

    <p class="text-gray-300">Above we implicitly assume that  <span class="math">\\mathcal{A}_1</span>  outputs  <span class="math">\\mathrm{poly}(\\lambda)</span>  polynomials in each round, and that  <span class="math">\\mathcal{A}_2</span>  outputs  <span class="math">\\tau = \\mathrm{poly}(\\lambda)</span>  query sets  <span class="math">Q_j</span> , so that  <span class="math">\\mathrm{PC}_{\\mathrm{s}}</span> . Commit,  <span class="math">\\mathrm{PC}_{\\mathrm{s}}</span> . Open, S. Commit, and S. Open are all efficient.</p>

    <p class="text-gray-300">We adapt the polynomial commitment scheme in [KZG10] to use "knowledge commitments", and to support commitments to multiple polynomials. We then prove that the resulting scheme satisfies the definitions in Appendix B.1 under knowledge assumptions. We discuss both non-hiding and hiding variants of the scheme.</p>

    <p class="text-gray-300">We use notation for bilinear groups introduced in Appendix A.1. The highlighted text below denotes parts of the construction that are not needed if hiding is not desired. We refer to the non-hiding variant as  <span class="math">\\mathsf{nhPC}_{\\mathsf{s}}</span> , and</p>

    <p class="text-gray-300">to the perfectly hiding variant as <span class="math">\\mathsf{phPC}_s</span>.</p>

    <p class="text-gray-300"><strong>Setup.</strong> On input a security parameter <span class="math">\\lambda</span> (in unary), and a maximum degree bound <span class="math">D \\in \\mathbb{N}</span>, <span class="math">\\mathsf{PC}_s</span>. Setup samples a key pair <span class="math">(\\mathsf{ck}, \\mathsf{rk})</span> as follows. Sample a bilinear group <span class="math">\\langle \\text{group} \\rangle \\leftarrow \\text{SampleGrp}(1^{\\lambda})</span>, and parse <span class="math">\\langle \\text{group} \\rangle</span> as a tuple <span class="math">(\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, q, G, H, e)</span>. Sample random elements <span class="math">\\alpha, \\beta, \\in \\mathbb{F}_q</span> and <span class="math">\\gamma \\in \\mathbb{F}_q^*</span>. Then compute the vector</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\Sigma} := \\left( \\begin{array}{c c c c c} G &amp;amp; \\beta G &amp;amp; \\beta^ {2} G &amp;amp; \\ldots &amp;amp; \\beta^ {D} G \\\\ \\alpha G &amp;amp; \\alpha \\beta G &amp;amp; \\alpha \\beta^ {2} G &amp;amp; \\ldots &amp;amp; \\alpha \\beta^ {D} G \\\\ \\gamma G &amp;amp; \\gamma \\beta G &amp;amp; \\gamma \\beta^ {2} G &amp;amp; \\ldots &amp;amp; \\gamma \\beta^ {D} G \\\\ \\alpha \\gamma G &amp;amp; \\alpha \\gamma \\beta G &amp;amp; \\alpha \\gamma \\beta^ {2} G &amp;amp; \\ldots &amp;amp; \\alpha \\gamma \\beta^ {D} G \\end{array} \\right) \\in \\mathbb {G} _ {1} ^ {4 D + 4}.</span></div>

    <p class="text-gray-300">Set <span class="math">\\mathsf{ck} := (\\langle \\mathsf{group} \\rangle, \\pmb{\\Sigma})</span> and <span class="math">\\mathsf{rk} := (D, \\langle \\mathsf{group} \\rangle, \\gamma G, \\alpha H, \\beta H)</span>, and then output the public parameters <span class="math">(\\mathsf{ck}, \\mathsf{rk})</span>. These public parameters will support polynomials over the field <span class="math">\\mathbb{F}_q</span> of degree at most <span class="math">D</span>.</p>

    <p class="text-gray-300"><strong>Commit.</strong> On input ck, univariate polynomials <span class="math">\\pmb{p} = [p_i]_{i=1}^n</span> over <span class="math">\\mathbb{F}_q</span> with <span class="math">\\deg(\\pmb{p}) \\leq D</span>, and randomness <span class="math">\\omega = [\\omega_i]_{i=1}^n</span>, <span class="math">\\mathsf{PC}_s</span>. Commit outputs commitments <span class="math">\\pmb{c} = [c_i]_{i=1}^n</span> that are computed as follows. If for any <span class="math">p_i \\in \\pmb{p}</span>, <span class="math">\\deg(p_i) &amp;gt; D</span>, abort. For each <span class="math">i \\in [n]</span>, if <span class="math">\\omega_i</span> is not <span class="math">\\perp</span>, then interpret the randomness <span class="math">\\omega_i</span> as the coefficients of a random univariate polynomial <span class="math">\\bar{p}_i</span> of degree <span class="math">\\deg(p_i)</span>. Otherwise, set <span class="math">\\bar{p}_i</span> to be the zero polynomial. For each <span class="math">i \\in [n]</span>, output <span class="math">c_i := (U_i, V_i) \\in \\mathbb{G}_1^2</span> where</p>

    <div class="my-4 text-center"><span class="math-block">U _ {i} := p _ {i} (\\beta) G + \\gamma \\bar {p} _ {i} (\\beta) G \\quad V _ {i} := \\alpha (p _ {i} (\\beta) G + \\gamma \\bar {p} _ {i} (\\beta) G).</span></div>

    <p class="text-gray-300">Note that <span class="math">p_i</span> and <span class="math">\\bar{p}_i</span> have degree at most <span class="math">D</span>, and so the above terms are linear combinations of terms in ck.</p>

    <p class="text-gray-300"><strong>Open.</strong> On input ck, univariate polynomials <span class="math">\\pmb{p} = [p_i]_{i=1}^n</span> over <span class="math">\\mathbb{F}_q</span>, evaluation point <span class="math">z \\in \\mathbb{F}_q</span>, opening challenge <span class="math">\\xi \\in \\mathbb{F}_q</span>, and randomness <span class="math">\\omega = [\\omega_i]_{i=1}^n</span> (the same randomness used for <span class="math">\\mathsf{PC}_s</span>. Commit), <span class="math">\\mathsf{PC}_s</span>. Open outputs an evaluation proof <span class="math">\\pi \\in \\mathbb{G}_1</span> that is computed as follows. If for any <span class="math">p_i \\in \\pmb{p}</span>, <span class="math">\\deg(p_i) &amp;gt; D</span>, abort. For each <span class="math">i \\in [n]</span>, if <span class="math">\\omega_i</span> is not <span class="math">\\perp</span>, then obtain a random univariate polynomial <span class="math">\\bar{p}_i</span> of degree <span class="math">\\deg(p_i)</span> from <span class="math">\\omega_i</span>, otherwise set <span class="math">\\bar{p}_i</span> to be the zero polynomial. Then compute the linear combination of polynomials <span class="math">p(X) := \\sum_{i=1}^{n} \\xi^i p_i(X)</span> and <span class="math">\\bar{p}(X) := \\sum_{i=1}^{n} \\xi^i \\bar{p}_i(X)</span>. Compute witness polynomials <span class="math">w(X) := \\frac{p(X) - p(z)}{X - z}</span> and <span class="math">\\bar{w}(X) := \\frac{\\bar{p}(X) - \\bar{p}(z)}{X - z}</span>. Set <span class="math">w := w(\\beta) G + \\gamma \\bar{w}(\\beta) G \\in \\mathbb{G}_1</span> and <span class="math">\\bar{v} := \\bar{p}(z) \\in \\mathbb{F}_q</span>. The evaluation proof is <span class="math">\\pi := (w, \\bar{v})</span>.</p>

    <p class="text-gray-300"><strong>Check.</strong> On input rk, commitments <span class="math">c = [c_i]_{i=1}^n</span>, evaluation point <span class="math">z \\in \\mathbb{F}_q</span>, alleged evaluations <span class="math">v = [v_i]_{i=1}^n</span>, evaluation proof <span class="math">\\pi = (w, \\bar{v})</span>, and opening challenge <span class="math">\\xi \\in \\mathbb{F}_q</span>, <span class="math">\\mathsf{PC}_s</span>. Check proceeds as follows. Parse each commitment <span class="math">c_i</span> as a tuple <span class="math">(U_i, V_i) \\in \\mathbb{G}_1^2</span>. Compute the two linear combinations</p>

    <div class="my-4 text-center"><span class="math-block">U := \\sum_ {i = 1} ^ {n} \\xi^ {i} U _ {i} \\quad \\text{and} \\quad V := \\sum_ {i = 1} ^ {n} \\xi^ {i} V _ {i},</span></div>

    <p class="text-gray-300">and ensure that the commitment <span class="math">(U,V)</span> is extractable by checking that <span class="math">e(U,\\alpha H) = e(V,H)</span>. Then compute the linear combination of evaluations <span class="math">v \\coloneqq \\sum_{i=1}^{n} \\xi^i v_i</span> and check the evaluation proof via the equality <span class="math">e(U - vG - \\bar{v}\\gamma G, H) = e(w, \\beta H - zH)</span>.</p>

    <p class="text-gray-300"><strong>Lemma B.5.</strong> The scheme <span class="math">\\mathsf{PC}_s</span> constructed above achieves completeness (Definition B.1).</p>

    <p class="text-gray-300"><strong>Proof.</strong> Fix any maximum degree bound <span class="math">D</span> and efficient adversary <span class="math">\\mathcal{A}</span>. Let <span class="math">(\\mathsf{ck}, \\mathsf{rk})</span> be any key pair output by the algorithm <span class="math">\\mathsf{PC}_s</span>. <span class="math">\\mathsf{Setup}(1^\\lambda, D)</span> constructed above. The keys contain a description <span class="math">\\langle \\text{group} \\rangle</span> of a bilinear group of some prime order <span class="math">q</span>, which in particular induces a field <span class="math">\\mathbb{F}_q</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}(\\mathsf{ck},\\mathsf{rk})</span> select polynomials <span class="math">\\pmb {p} = [p_i]_{i = 1}^n</span> over <span class="math">\\mathbb{F}_q</span>, location <span class="math">z\\in \\mathbb{F}_q</span>, and opening challenge <span class="math">\\xi \\in \\mathbb{F}_q</span>. We only need to consider adversaries <span class="math">\\mathcal{A}</span> that make choices for which <span class="math">\\deg (\\pmb {p})\\leq D</span>. Now consider commitments <span class="math">\\pmb {c} = [c_i]_{i = 1}^n</span> and evaluation proof <span class="math">\\pi</span> that are all computed according to the construction above.</p>

    <p class="text-gray-300">59</p>

    <p class="text-gray-300">We need to show that, for the correct evaluations <span class="math">\\pmb{v} \\coloneqq \\pmb{p}(z)</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {P C} _ {\\mathsf {s}}. \\mathsf {C h e c k} (\\mathsf {r k}, \\boldsymbol {c}, z, \\boldsymbol {v}, \\pi , \\xi) = 1.</span></div>

    <p class="text-gray-300">This amounts to arguing that the two pairing equations are satisfied.</p>

    <p class="text-gray-300">For the first pairing equation, note that the pair <span class="math">(U_i, V_i)</span> has the property that the second element is the first element multiplied by the secret scalar <span class="math">\\alpha</span>. This is also true about the pair <span class="math">(U, V)</span> obtained by taking the linear combination determined by <span class="math">\\xi</span>, as the following computation shows:</p>

    <div class="my-4 text-center"><span class="math-block">U = \\sum_ {i = 1} ^ {n} \\xi^ {i} U _ {i} = \\sum_ {i = 1} ^ {n} \\left(\\xi^ {i} p _ {i} (\\beta) G + \\gamma \\bar {p} _ {i} (\\beta) G\\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">V = \\sum_ {i = 1} ^ {n} \\xi^ {i} V _ {i} = \\alpha \\sum_ {i = 1} ^ {n} (\\xi^ {i} p _ {i} (\\beta) G + \\gamma \\bar {p} _ {i} (\\beta) G).</span></div>

    <p class="text-gray-300">We conclude that <span class="math">V = \\alpha U</span>, and so the check <span class="math">e(U, \\alpha H) = e(V, H)</span> passes.</p>

    <p class="text-gray-300">For the second pairing equation, note that in the evaluation proof <span class="math">\\pi = (\\mathsf{w},\\bar{v})</span>, <span class="math">\\mathsf{w}</span> equals the element <span class="math">\\mathsf{w} := \\frac{p(X) - p(z) + \\gamma(\\bar{p}(X) - \\bar{p}(z))}{X - z} G</span> where <span class="math">p(X) := \\sum_{i=1}^{n} \\xi^i p_i(X)</span> and <span class="math">\\bar{p}(X) := \\sum_{i=1}^{n} \\xi^i \\bar{p}_i(X)</span>. Also note that the value <span class="math">v</span> computed by <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span>. Check is the evaluation of <span class="math">p</span> at <span class="math">z</span>. Therefore,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e (U - v G - \\gamma \\bar {v} G, H) = e (((p (\\beta) - v) + \\gamma (\\bar {p} (\\beta) - \\bar {v})) G, H) \\\\ = e \\left(\\frac {p (\\beta) - p (z) + \\gamma (\\bar {p} (\\beta) - \\bar {p} (z))}{\\beta - z} G, (\\beta - z) H\\right) \\\\ = e ((w (\\beta) + \\gamma \\bar {w} (\\beta)) G, \\beta H - z H) \\\\ = e (\\mathbf {w}, \\beta H - z H). \\end{array}</span></div>

    <p class="text-gray-300">We conclude that the second pairing equation also holds.</p>

    <p class="text-gray-300">Lemma B.6. The scheme <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> constructed above achieves succinctness (Definition B.3).</p>

    <p class="text-gray-300">Proof. For a list of <span class="math">n</span> polynomials, the scheme <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> requires <span class="math">2n \\mathbb{G}_1</span> elements for the commitment and one <span class="math">\\mathbb{G}_1</span> element and one <span class="math">\\mathbb{F}_q</span> element for the evaluation proof, while the time to check this proof requires two variable-base multi-scalar multiplications of size <span class="math">n</span> and four pairings.</p>

    <h2 id="sec-73" class="text-2xl font-bold">B.2.2 Extractability</h2>

    <p class="text-gray-300">Theorem B.7. If the bilinear group sampler SampleGrp satisfies the SDH and dPKE assumptions, <span class="math">\\mathsf{nhPC}_{\\mathsf{s}}</span> and <span class="math">\\mathsf{phPC}_{\\mathsf{s}}</span> constructed in Appendix B.2.1 achieve extractability (Definition B.2).</p>

    <p class="text-gray-300">First in Lemma B.9 we argue that <span class="math">\\mathsf{nhPC}_{\\mathsf{s}}</span> and <span class="math">\\mathsf{phPC}_{\\mathsf{s}}</span> satisfy evaluation binding, a property stating that for any point <span class="math">z \\in \\mathbb{F}_q</span> and commitments <span class="math">\\pmb{c} = [c_i]_{i=1}^n</span>, no efficient adversary can produce valid proofs that open <span class="math">\\pmb{c}</span> to different lists of values at <span class="math">z</span>. Then in Lemma B.10 we build on this fact to argue that <span class="math">\\mathsf{nhPC}_{\\mathsf{s}}</span> and <span class="math">\\mathsf{phPC}_{\\mathsf{s}}</span> achieve extractability.</p>

    <p class="text-gray-300">Definition B.8. <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> satisfies evaluation binding if for every maximum degree bound <span class="math">D \\in \\mathbb{N}</span> and efficient adversary <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span> the following probability is negligible in the security parameter <span class="math">\\lambda</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\boldsymbol {v} \\neq \\boldsymbol {v} ^ {\\prime} &amp;amp; (\\mathrm {c k}, \\mathrm {r k}) \\leftarrow \\mathrm {P C} _ {\\mathrm {s}}. \\mathrm {S e t u p} (1 ^ {\\lambda}, D) \\\\ \\wedge &amp;amp; \\left(\\boldsymbol {c}, z, \\boldsymbol {v}, \\boldsymbol {v} ^ {\\prime}, \\mathrm {s t}\\right) \\leftarrow \\mathcal {A} _ {1} (\\mathrm {c k}, \\mathrm {r k}) \\\\ \\mathsf {P C} _ {\\mathrm {s}}. \\mathsf {C h e c k} (\\mathsf {r k}, \\boldsymbol {c}, z, \\boldsymbol {v}, \\pi , \\xi) = 1 &amp;amp; \\text {Sample opening challenge} \\xi \\\\ \\wedge &amp;amp; (\\pi , \\pi^ {\\prime}) \\leftarrow \\mathcal {A} _ {2} (\\mathsf {s t}, \\xi) \\end{array} \\right].</span></div>

    <p class="text-gray-300">Lemma B.9. If the bilinear group sampler SampleGrp satisfies the SDH assumption (Assumption 1),  <span class="math">\\mathsf{nhPC}_{\\mathsf{s}}</span>  and  <span class="math">\\mathsf{phPC}_{\\mathsf{s}}</span>  constructed in Appendix B.2.1 achieve evaluation binding (Definition B.8).</p>

    <p class="text-gray-300">Proof. Suppose for contradiction that there exists a maximum degree bound  <span class="math">D</span>  and an efficient adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span>  that breaks evaluation binding with non-negligible probability. We show that either  <span class="math">\\mathcal{A}</span>  can be used to break DL with non-negligible probability or that we can use  <span class="math">\\mathcal{A}</span>  to construct an efficient adversary  <span class="math">\\mathcal{B}</span>  that breaks SDH with non-negligible probability. Since the SDH assumption implies the DL assumption, in either case we obtain a contradiction that SDH holds with respect to SampleGrp. We define  <span class="math">\\mathcal{B}</span>  as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}(\\langle \\mathrm{group}\\rangle ,\\Sigma)</span>  ..</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\pmb{\\Sigma}</span>  as  <span class="math">\\{\\{\\beta^i G\\}_{i = 0}^D,\\beta H\\}</span></li>

      <li>Randomly sample  <span class="math">\\alpha \\gets \\mathbb{F}_q,\\gamma \\in \\mathbb{F}_q^*</span>  and set  <span class="math">\\begin{array}{rl} &amp;amp; {\\mathrm{ck}:= (\\langle \\mathrm{group}\\rangle ,\\{\\beta^i G,\\alpha \\beta^i G,\\gamma \\beta^i G,\\alpha \\gamma \\beta^i G\\}_{i = 0}^D),}\\\\ &amp;amp; {\\mathrm{rk}:= (\\langle \\mathrm{group}\\rangle ,\\alpha H,\\beta H).} \\end{array}</span></li>

      <li>Compute  <span class="math">(c,z,v,v^{\\prime},st)\\gets \\mathcal{A}_{1}(\\mathrm{ck},\\mathrm{rk})</span></li>

      <li>Sample random opening challenge  <span class="math">\\xi \\in \\mathbb{F}_q</span></li>

      <li>Compute  <span class="math">(\\pi ,\\pi^{\\prime})\\gets \\mathcal{A}_{2}(\\mathsf{st},\\xi)</span></li>

      <li>Parse  <span class="math">(\\pi, \\pi&#x27;)</span>  as  <span class="math">((\\mathsf{w}, \\bar{v}), (\\mathsf{w}&#x27;, \\bar{v}&#x27;)</span> ,  <span class="math">\\pmb{v}</span>  as  <span class="math">[v_i]_{i=1}^n</span> , and  <span class="math">\\pmb{v}&#x27;</span>  as  <span class="math">[v_i&#x27;]_{i=1}^n</span> .</li>

      <li>Compute  <span class="math">v \\coloneqq \\sum_{i=1}^{n} \\xi^i v_i</span>  and  <span class="math">v&#x27; \\coloneqq \\sum_{i=1}^{n} \\xi^i v_i&#x27;</span> .</li>

      <li>If  <span class="math">zG = \\beta G</span>  (i.e.,  <span class="math">z = \\beta</span> ): choose  <span class="math">a</span>  from  <span class="math">\\mathbb{F}_q \\setminus \\{z\\}</span> , and output  <span class="math">\\left(a, \\frac{1}{z + a} G\\right)</span> , breaking SDH.</li>

      <li>Else if  <span class="math">(zG\\neq \\beta G)\\wedge (\\mathsf{w}\\neq \\mathsf{w}^{\\prime})</span>  .. output  <span class="math">\\left(-z,\\frac{1}{v&#x27; - v + \\gamma(\\bar{v}&#x27; - \\bar{v})} (\\mathsf{w} - \\mathsf{w}&#x27;)\\right)</span>  , breaking SDH.</li>

      <li>Else abort.</li>

    </ol>

    <p class="text-gray-300">First, we show that if either the predicate in Step 8 or the predicate in Step 9 is satisfied, then  <span class="math">\\mathcal{B}</span>  does in fact break SDH. Next, we show that one of these predicates is satisfied with non-negligible probability whenever  <span class="math">\\mathcal{A}</span>  breaks evaluation binding. We do this by showing that if  <span class="math">\\mathcal{B}</span>  aborts but  <span class="math">\\mathcal{A}</span>  still succeeds, then  <span class="math">\\mathcal{A}</span>  can be used to solve the discrete logarithm problem in SampleGrp with non-negligible probability.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span>  succeeds if predicates are satisfied. If  <span class="math">\\mathcal{A}</span>  outputs  <span class="math">z = \\beta</span> , then  <span class="math">\\mathcal{B}</span>  can construct an arbitrary solution to the SDH problem. If on the other hand  <span class="math">(\\beta \\neq z) \\land (\\mathsf{w} \\neq \\mathsf{w}&#x27;)</span> , then if  <span class="math">\\mathcal{A}</span>  breaks evaluation binding, by construction of  <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> . Check the following equations must hold:</p>

    <div class="my-4 text-center"><span class="math-block">e (U - v G - \\gamma \\bar {v} G, H) = e (\\mathrm {w}, \\beta H - z H), \\tag {12}</span></div>

    <div class="my-4 text-center"><span class="math-block">e \\left(U - v ^ {\\prime} G - \\gamma \\bar {v} ^ {\\prime} G, H\\right) = e \\left(\\mathrm {w} ^ {\\prime}, \\beta H - z H\\right). \\tag {13}</span></div>

    <p class="text-gray-300">Then,  <span class="math">\\mathsf{w} \\neq \\mathsf{w}&#x27;</span>  and  <span class="math">\\beta \\neq z</span>  together imply that  <span class="math">v&#x27; - v + \\gamma (\\bar{v}&#x27; - \\bar{v}) \\neq 0</span> . The above equations can then be rewritten as</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {1}{v ^ {\\prime} - v + \\gamma (\\bar {v} ^ {\\prime} - \\bar {v})} (\\mathsf {w} - \\mathsf {w} ^ {\\prime}) = \\frac {1}{\\beta - z} G,</span></div>

    <p class="text-gray-300">making  <span class="math">\\left(-z, \\frac{1}{v&#x27; - v + \\gamma(\\bar{v}&#x27; - \\bar{v})} (\\mathsf{w} - \\mathsf{w}&#x27;)\\right)</span>  a pair that breaks the SDH assumption.</p>

    <p class="text-gray-300">Probability that predicates are satisfied. We analyze the probability with which  <span class="math">\\mathcal{B}</span>  aborts by considering the probability that the predicates are not satisfied, i.e.,  <span class="math">(\\beta \\neq z) \\land (\\mathsf{w} = \\mathsf{w}&#x27;)</span> . We break this case down into the following two disjoint subcases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1:  <span class="math">\\bar{v} \\neq \\bar{v}&#x27;</span> . In this case, Equations (12) and (13) imply that  <span class="math">v&#x27; - v + \\gamma (\\bar{v}&#x27; - \\bar{v}) = 0</span> . We can rewrite this equation to compute the secret discrete logarithm  <span class="math">\\gamma = \\frac{v - v&#x27;}{\\bar{v}&#x27; - \\bar{v}}</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 2:  <span class="math">\\bar{v} = \\bar{v}&#x27;</span> . In this case, it must hold that  <span class="math">v = v&#x27;</span> . Since  <span class="math">\\pmb{v} \\neq \\pmb{v}&#x27;</span> , this occurs with probability at most  <span class="math">\\frac{n}{q}</span> .</li>

    </ul>

    <p class="text-gray-300">Hence, we conclude that if  <span class="math">(\\beta \\neq z) \\land (\\mathsf{w} = \\mathsf{w}&#x27;)</span>  with non-negligible probability and  <span class="math">\\mathcal{A}</span>  still succeeds, then  <span class="math">\\mathcal{A}</span>  can be used to break DL with non-negligible probability, which cannot occur if SDH is hard for SampleGrp.</p>

    <p class="text-gray-300">Thus, if  <span class="math">\\mathcal{A}</span>  succeeds, then with non-negligible probability either  <span class="math">\\beta = z</span> , or  <span class="math">(\\beta \\neq z) \\land (\\mathsf{w} \\neq \\mathsf{w}&#x27;)</span> , which in turn implies that  <span class="math">\\mathcal{B}</span>  breaks SDH, contradicting our assumption.</p>

    <p class="text-gray-300">Lemma B.10. If  <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span>  constructed in Appendix B.2.1 achieves evaluation binding (Definition B.8), and if the bilinear group sampler SampleGrp satisfies the dPKE assumption (Assumptions 2 and 3), then  <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span>  achieves extractability (Definition B.2).</p>

    <p class="text-gray-300">Proof. The dPKE assumption implies the dMPKE<em> assumption, which considers the case where the adversary outputs multiple knowledge commitments; see Appendix A.3.1. Below we rely on dMPKE</em>.</p>

    <p class="text-gray-300">Fix a maximum degree bound  <span class="math">D</span>  and an efficient adversary  <span class="math">\\mathcal{A}</span>  against extractability. We use  <span class="math">\\mathcal{A}</span>  to define the adversary  <span class="math">\\mathcal{D}</span>  below, which is against dMPKE.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{D}(\\langle \\mathrm{group}\\rangle ,\\Sigma ,\\mathbb{Z})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse instance  <span class="math">\\pmb{\\Sigma}</span>  as  <span class="math">\\{\\pmb{\\Sigma}_{\\mathsf{PC}} = \\{\\beta^i G,\\alpha \\beta^i G,\\gamma \\beta^i G,\\alpha \\gamma \\beta^i G\\}_{i = 0}^D,\\alpha H,\\beta H\\}</span> .</li>

      <li>Parse the auxiliary input  <span class="math">\\mathbb{Z}</span>  as randomness  <span class="math">[\\rho_j]_{j=1}^i</span> .</li>

      <li>Construct  <span class="math">\\operatorname{ck} := (\\langle \\operatorname{group} \\rangle, \\Sigma_{\\mathsf{PC}})</span> .</li>

      <li>Construct  <span class="math">\\mathsf{rk} := (\\langle \\mathsf{group} \\rangle, \\alpha H, \\beta H)</span> .</li>

      <li>Let  <span class="math">c\\gets \\mathcal{A}(\\mathrm{ck},\\mathrm{rk},[\\rho_j]_{j = 1}^i)</span></li>

      <li>Output  <span class="math">c</span> .</li>

    </ol>

    <p class="text-gray-300">By assumption there exists a  <span class="math">\\mathsf{dMPKE}^*</span>  extractor  <span class="math">\\mathcal{E}_{\\mathcal{D}}</span>  against  <span class="math">\\mathcal{D}</span>  that works with overwhelming probability. We use  <span class="math">\\mathcal{E}_{\\mathcal{D}}</span>  to construct an extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  for the polynomial commitment scheme. The rest of this proof will argue that  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  defined below succeeds with overwhelming probability. For each round  <span class="math">i \\in [\\mathsf{r}]</span> ,  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  proceeds as follows. We denote by  <span class="math">\\mathsf{k}_i</span>  the number of polynomials output by  <span class="math">\\mathcal{A}</span>  in round  <span class="math">i</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}_{\\mathcal{A}}(\\mathrm{ck},\\mathrm{rk},[\\rho_j]_{j = 1}^i)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse ck as  <span class="math">(\\langle \\mathrm{group}\\rangle ,\\Sigma_{\\mathsf{PC}})</span>  and rk as  <span class="math">(\\langle \\mathrm{group}\\rangle ,\\alpha H,\\beta H)</span></li>

      <li>Construct dMPKE instance  <span class="math">\\pmb{\\Sigma} := \\{\\pmb{\\Sigma}_{\\mathsf{PC}}, \\alpha H, \\beta H\\}</span> .</li>

      <li>Construct auxiliary input  <span class="math">\\mathbb{Z} := [\\rho_j]_{j=1}^i</span> .</li>

      <li>Run the dMPKE extractor:  <span class="math">([a_j]_{j=1}^{k_i}, [b_j]_{j=1}^{k_i}) \\gets \\mathcal{E}_{\\mathcal{D}}(\\langle \\text{group} \\rangle, \\Sigma, \\mathbb{Z})</span> .</li>

      <li>Set  <span class="math">\\mathbf{X} \\coloneqq (1, X, \\ldots, X^D)</span> .</li>

      <li>For each  <span class="math">j</span>  in  <span class="math">[k_i]</span> , define polynomials  <span class="math">p_j(X) \\coloneqq \\langle \\pmb{a}_j, \\pmb{X} \\rangle \\in \\mathbb{F}_q[X]</span>  and  <span class="math">\\bar{p}_j(X) \\coloneqq \\langle \\pmb{b}_j, \\pmb{X} \\rangle \\in \\mathbb{F}_q[X]</span> .</li>

      <li>For each  <span class="math">j</span>  in  <span class="math">[k_i]</span> , let the randomness  <span class="math">\\omega_{j}</span>  be the coefficients of  <span class="math">\\bar{p}_j</span> .</li>

      <li>Output the polynomials  <span class="math">\\pmb{p} \\coloneqq [p_j]_{j=1}^{k_i}</span>  and the randomness  <span class="math">\\omega \\coloneqq [\\omega_j]_{j=1}^{k_i}</span> .</li>

    </ol>

    <p class="text-gray-300">For the purpose of our proof, we additionally let the above extractor output the randomness  <span class="math">\\omega</span> .</p>

    <p class="text-gray-300">Suppose for contradiction that the extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  fails with some non-negligible probability, for a choice of round bound  <span class="math">r \\in \\mathbb{N}</span> , efficient public-coin challenger  <span class="math">\\mathcal{C}</span> , efficient query sampler  <span class="math">\\mathcal{Q}</span> , and efficient adversary  <span class="math">\\mathcal{B} = (\\mathcal{B}_1, \\mathcal{B}_2)</span> . We show this implies that either  <span class="math">\\mathcal{D}</span>  succeeds with non-negligible probability (contradicting our dPKE assumption), or that we can construct an adversary  <span class="math">\\mathcal{A}&#x27;</span>  that contradicts Lemma B.9. In more detail, the extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  may fail due to (at least) one of two reasons.</p>

    <p class="text-gray-300">(1) Incorrect polynomial or randomness: there exists an  <span class="math">i \\in T</span>  such that polynomial  <span class="math">p_i</span>  or random polynomial  <span class="math">\\bar{p}_i</span>  does not match its commitment.</p>

    <p class="text-gray-300">(2) Incorrect evaluation: for every  <span class="math">i \\in T</span> , the extracted polynomial  <span class="math">p_i</span>  and corresponding random polynomial  <span class="math">\\bar{p}_i</span>  match their commitments, but claimed evaluation for one such  <span class="math">p_i</span>  is incorrect.</p>

    <p class="text-gray-300">If  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  fails with non-negligible probability, then at least one of these cases occurs with non-negligible probability. We analyze each case, and argue that this cannot be (or else we contradict our assumptions).</p>

    <p class="text-gray-300">(1) Incorrect polynomial or randomness. Informally, this case occurs with negligible probability if the dMPKE* assumption holds for SampleGrp. In more detail, we have to demonstrate that since  <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> . Check accepts, every knowledge commitment in  <span class="math">c</span>  is "extractable", i.e., for each  <span class="math">c \\in c</span> ,  <span class="math">c = (U, V)</span>  satisfies  <span class="math">\\alpha U = V</span>  with overwhelming probability.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We do this as follows. Since  <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> . Check accepts, we know that  <span class="math">e(U,\\alpha H) = e(V,H)</span> , where  <span class="math">U \\coloneqq \\sum_{i \\in T} \\xi^i U_i</span>  and  <span class="math">V \\coloneqq \\sum_{i \\in T} \\xi^i V_i</span>  are linear combinations of the input commitments. In this case, we have that  <span class="math">\\alpha U_i \\neq V_i</span>  for some  <span class="math">i</span>  with probability at most  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ q<span class="math">  over random choice of  </span>\\xi<span class="math"> . Thus with probability  </span>1 -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ q<span class="math"> , each knowledge commitment satisfies the equality  </span>V_i = \\alpha U_i$ , and is thus extractable. In this case we have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">U _ {i} \\neq \\sum_ {k = 0} ^ {D} \\left(a _ {i, k} \\beta^ {k} G + b _ {i, k} \\gamma \\beta^ {k} G\\right),</span></div>

    <p class="text-gray-300">for some  <span class="math">i \\in T</span>  only if  <span class="math">\\mathcal{E}_{\\mathcal{D}}</span>  has failed, and by assumption this only happens with negligible probability.</p>

    <p class="text-gray-300">(2) Incorrect evaluation. We show that this case occurs with negligible probability if evaluation binding holds for  <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> . If  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  outputs polynomials that do not match the claimed evaluations with non-negligible probability  <span class="math">\\mu(\\lambda)</span> , then we can use  <span class="math">(\\mathcal{A}, \\mathcal{B}_1, \\mathcal{B}_2)</span> , the public-coin challenger  <span class="math">\\mathcal{C}</span>  and the query sampler  <span class="math">\\mathcal{Q}</span>  to construct the following adversary  <span class="math">\\mathcal{A}&#x27; = (\\mathcal{A}_1&#x27;, \\mathcal{A}_2&#x27;)</span>  that succeeds in breaking evaluation binding (Definition B.8) with the same non-negligible probability  <span class="math">\\mu(\\lambda)</span> .</p>

    <p class="text-gray-300">|  A1'(ck, rk):  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  1. For i = 1, ..., r: (a) Obtain challenge: ρi← C(ck, rk, i). (b) Obtain commitments: ci← A(ck, rk, [ρj]i=1). (c) Extract polynomials and randomness: (pi, ωi) ← EA(ck, rk, [ρj]i=1).  |</p>

    <p class="text-gray-300">|  2. Sample query set: Q ← Q(ck, rk, [ρj]i=1).  |</p>

    <p class="text-gray-300">|  3. Set [ci]i=1n := [ci]i=1, [pi]i=1n := [pi]i=1, and [ωi]i=1n := [ωi]i=1.  |</p>

    <p class="text-gray-300">|  4. Parse Q as T × {z} for some T ⊆ [n] and z ∈ F.  |</p>

    <p class="text-gray-300">|  5. Set c := [ci]i∈T, p := [pi]i∈T, and ω := [ωi]i∈T.  |</p>

    <p class="text-gray-300">|  6. (v, stB) ← B1(ck, rk, [ρj]k=1, Q).  |</p>

    <p class="text-gray-300">|  7. Compute alternate evaluations v' := p(z).  |</p>

    <p class="text-gray-300">|  8. Set st := (ck, rk, p, z, ω, stB).  |</p>

    <p class="text-gray-300">|  9. Output (c, z, v, v', st).  |</p>

    <p class="text-gray-300">|  A2'(st,ξ):  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  1. Parse st as (ck, rk, p, z, ω, stB).  |</p>

    <p class="text-gray-300">|  2. Obtain proof of evaluation: π ← B2(stB,ξ).  |</p>

    <p class="text-gray-300">|  3. Compute alternate proof: π' ← PCs.Open(ck, p, z,ξ; ω).  |</p>

    <p class="text-gray-300">|  4. Output (π, π').  |</p>

    <p class="text-gray-300">Since the extractor successfully extracts each polynomial and the randomness, and since  <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span>  satisfies perfect completeness,  <span class="math">\\mathcal{A}_2^\\prime</span>  should be able to produce an alternate valid proof  <span class="math">\\pi^{\\prime}</span>  that is also accepted by  <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> . Check. Thus, if  <span class="math">\\mathcal{A}</span>  breaks polynomial extractability with non-negligible probability by producing valid proofs for incorrect evaluations, then  <span class="math">\\mathcal{A}&#x27; = (\\mathcal{A}_1&#x27;,\\mathcal{A}_2&#x27;)</span>  breaks evaluation binding for  <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span>  with non-negligible probability, which contradicts our assumption.</p>

    <p class="text-gray-300">Theorem B.11.  <span class="math">\\mathsf{PC}_{\\mathbf{s}}</span>  constructed in Appendix B.2.1 achieves hiding (Definition B.4).</p>

    <p class="text-gray-300">Proof. We describe a polynomial-time simulator  <span class="math">S</span>  such that, for every maximum degree bound  <span class="math">D</span>  and efficient adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2, \\mathcal{A}_3)</span> , the adversary  <span class="math">\\mathcal{A}</span>  cannot distinguish the real world and ideal world experiments.</p>

    <p class="text-gray-300">We leverage the fact that by knowing the "trapdoor" the simulator  <span class="math">S</span>  can create the evaluation proof for arbitrary values with respect to the commitment. We build our simulator  <span class="math">S</span>  as follows:</p>

    <p class="text-gray-300">|  S.Setup(1λ, D): 1. Run PCs.Setup(1λ, D), additionally defining trap := (ck, rk, β, γ). 2. Output (ck, rk, trap).  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  S.Commit(trap, k; ω): 1. Parse ω as [ωi]k i=1. 2. For i = 1, ..., k: (a) Obtain the random polynomial p_i(X) from ωi. (b) Compute Ui := p_i(β)γG and Vi := αp_i(β)γG. (c) Set ci = (Ui, Vi). 3. Output c := [ci]k i=1.  |</p>

    <p class="text-gray-300">|  S.Open(trap, p, v, Q,ξ; ω): 1. Parse p := [pi]n i=1, v := [vi]n i=1, and ω := [ωi]n i=1. 2. Parse query set Q as T × {z} for some T ⊆ [n] and z ∈ Fq. 3. For i ∈ T: (a) If ωi ≠ ⊥: i. Compute (Ui, Vi) ← S.Commit(trap, 1; ωi). ii. Obtain the random polynomial p_i(X) from ωi. iii. Set v̅i := p_i(z) - v̅i/γ. (b) Else ωi = ⊥: i. Compute (Ui, Vi) ← PCs.Commit(ck, pi; ⊥). ii. Set v̅i := 0. 4. Compute v̅i := ∑i=1n εi v̅i, v := ∑i=1n εi v̅i, U := ∑i=1n εi U_i. 5. If z ≠ β: Compute w := 1/β-z U - v-γv/β-z G. 6. Else z = β: Set w := 0G. 7. Output π := (w, v̅).  |</p>

    <p class="text-gray-300">Clearly,  <span class="math">S</span>  is polynomial-time. Associated with each  <span class="math">p_i</span>  output by  <span class="math">\\mathcal{A}</span>  there is an independently and randomly sampled degree  <span class="math">D</span>  polynomial  <span class="math">\\bar{p}_i</span>  defined by  <span class="math">\\omega_i</span> . We define a polynomial  <span class="math">\\bar{p}_i&#x27;</span>  such that in the real world,  <span class="math">\\bar{p}_i&#x27; := \\bar{p}_i</span> , whereas in the ideal world, if  <span class="math">h_i = 0</span>  (and hence  <span class="math">\\omega_i \\neq \\bot</span> ), then  <span class="math">\\bar{p}_i&#x27;(X) := \\bar{p}_i(X) - \\frac{p_i(X)}{\\gamma}</span> , and  <span class="math">\\bar{p}_i&#x27; = 0</span>  otherwise. Observe that each  <span class="math">\\bar{p}_i&#x27;</span>  is of degree  <span class="math">D</span>  and is independently and randomly distributed if the corresponding polynomial is required to be hiding. It follows that these polynomials are identically distributed in the two worlds. Furthermore, since  <span class="math">S</span> . Setup uses  <span class="math">PC_s</span> . Setup to generate (ck, rk), we see that (ck, rk) is also identically distributed.</p>

    <p class="text-gray-300">We claim that for each round  <span class="math">i \\in [r]</span> , upon fixing  <span class="math">(\\mathsf{ck}, \\mathsf{rk})</span>  and  <span class="math">\\bar{\\pmb{p}}_i&#x27;</span> , the resulting  <span class="math">\\pmb{c}_i</span>  are given by a deterministic function in  <span class="math">\\pmb{p}_i(\\beta)</span>  and, after fixing all the  <span class="math">\\bar{\\pmb{p}}&#x27;</span> , for each query point  <span class="math">[z_j]_{j=1}^{\\tau}</span>  the corresponding proof</p>

    <p class="text-gray-300"><span class="math">\\pi_{j}</span> is given by a deterministic function in <span class="math">(\\bm{p}(z_{j}),z_{j},\\xi_{j})</span>. Since these deterministic functions are parametrized by <span class="math">\\mathsf{ck}</span>, <span class="math">\\mathsf{rk}</span>, and the <span class="math">\\bar{\\bm{p}}^{\\prime}</span>, which we have already shown are identically distributed in the two worlds, it follows that the mappings of these functions will likewise be identically distributed, and thus we claim the two worlds are indistinguishable even by unbounded adversaries.</p>

    <p class="text-gray-300">Abusing notation to express group elements (or vectors thereof) as functions, we claim that for commitments <span class="math">\\bm{c}_{i}:=(\\bm{U}_{i},\\bm{V}_{i})</span> that <span class="math">\\bm{U}_{i}\\left(\\bm{p}_{i}(\\beta)\\right)=\\bm{p}_{i}(\\beta)G+\\gamma\\bar{\\bm{p}}^{\\prime}_{i}(\\beta)G</span> and <span class="math">\\bm{V}_{i}=\\alpha\\bm{U}_{i}</span>. Similarly, we claim the proof elements <span class="math">\\pi_{j}:=(\\bar{v}_{j},\\mathsf{w}_{j})</span> that</p>

    <p class="text-gray-300">\\[ \\bar{v}_{j}\\left(z_{j},\\,\\xi_{j}\\right)=\\sum_{i=1}^{n}\\xi_{j}^{i}\\cdot\\bar{p}_{i}^{\\prime}(z_{j})\\;,\\quad\\mathsf{w}_{j}\\left(z_{j}\\right)=\\begin{cases}\\frac{1}{\\beta-z_{j}}U-\\frac{v-\\gamma\\bar{v}_{j}}{\\beta-z_{j}}G&\\text{ if }z_{j}\\neq\\beta\\\\ 0&\\text{ if }z_{j}=\\beta\\end{cases}\\;, \\]</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">U\\left(\\xi_{j}\\right)=\\sum_{i=1}^{n}\\xi_{j}^{i}\\cdot U_{i}\\;,\\quad v\\left(\\bm{p}(z_{j}),\\,\\xi_{j}\\right)=\\sum_{i=1}^{n}\\xi_{j}^{i}\\cdot p_{i}(z_{j})\\;.</span></p>

    <p class="text-gray-300">To conclude the proof it now only remains to be shown that the functions above describe the outputs of <span class="math">\\mathsf{PC_{s}}</span> and <span class="math">\\mathcal{S}</span>. We demonstrate this sequentially below.</p>

    <h4 id="sec-75" class="text-lg font-semibold mt-6">Indistinguishability of commitments.</h4>

    <p class="text-gray-300">In the real world we have</p>

    <p class="text-gray-300"><span class="math">U_{i}:=p_{i}(\\beta)G+\\gamma\\bar{p}_{i}(\\beta)G\\;,\\quad V_{i}:=\\alpha(p_{i}(\\beta)+\\gamma\\bar{p}_{i}(\\beta))G\\;\\;,</span></p>

    <p class="text-gray-300">where since in this world we have defined <span class="math">\\bar{p}^{\\prime}:=\\bar{p}</span> our claim that <span class="math">U_{i}(p_{i})=p_{i}(\\beta)G+\\gamma\\bar{p}_{i}^{\\prime}(\\beta)G</span> and <span class="math">V_{i}=\\alpha U_{i}</span> follows immediately. Now considering the ideal world case, from our pseudocode above we have that</p>

    <p class="text-gray-300"><span class="math">U_{i}:=\\gamma\\bar{p}_{i}(\\beta)G\\;,\\quad V_{i}:=\\alpha U_{i}\\;,</span></p>

    <p class="text-gray-300">where now we have defined <span class="math">\\bar{p}_{i}^{\\prime}(z):=\\bar{p}_{i}(z)-\\frac{p(z)}{\\gamma}</span>. Plugging this in we have</p>

    <p class="text-gray-300"><span class="math">p_{i}(\\beta)G+\\gamma\\bar{p}_{i}^{\\prime}(\\beta)G=p_{i}(\\beta)G+\\gamma\\left(\\bar{p}_{i}(\\beta)-\\frac{p(\\beta)}{\\gamma}\\right)G=\\gamma\\bar{p}_{i}(\\beta)G\\;,</span></p>

    <p class="text-gray-300">and thus may conclude that commitments are indistinguishable with respect to all adversaries.</p>

    <h4 id="sec-76" class="text-lg font-semibold mt-6">Indistinguishability of evaluation proofs.</h4>

    <p class="text-gray-300">In the real world world we have <span class="math">\\bar{v}_{j}=\\sum_{i=1}^{n}\\xi_{j}^{i}\\cdot\\bar{p}_{i}(z_{j})</span>, where since <span class="math">\\bar{\\bm{p}}_{i}^{\\prime}=\\bar{\\bm{p}}_{i}</span> we arrive at the expected function. In the ideal world we have that <span class="math">\\bar{v}_{j}:=\\sum_{i=1}^{n}\\xi_{j}^{i}\\cdot\\tilde{v}_{i}</span>, where in the pseudocode above we see that <span class="math">\\tilde{v}_{i}=\\bar{p}_{i}^{\\prime}(z_{j})</span>. We conclude that the <span class="math">\\bar{\\bm{v}}</span> are indistinguishable with respect to all adversaries.</p>

    <p class="text-gray-300">Finally, we consider the <span class="math">\\mathsf{w}_{j}</span>. In the real world we have <span class="math">\\mathsf{w}_{j}:=w(\\beta)G+\\gamma\\bar{w}(\\beta)G</span>, where</p>

    <p class="text-gray-300"><span class="math">w(X):=\\frac{p(X)-p(z)}{X-z}\\;,\\quad\\bar{w}(X):=\\frac{\\bar{p}(X)-\\bar{p}(z)}{X-z}\\;.</span></p>

    <p class="text-gray-300">Plugging these values in we obtain</p>

    <p class="text-gray-300"><span class="math">\\mathsf{w}_{j}:=\\frac{p(\\beta)-p(z)}{\\beta-z}G+\\gamma\\frac{\\bar{p}(\\beta)-\\bar{p}(z)}{\\beta-z}G=\\frac{p(\\beta)+\\gamma\\bar{p}(\\beta)}{\\beta-z}G-\\frac{p(z)+\\gamma\\bar{p}(z)}{\\beta-z}G\\quad.</span></p>

    <p class="text-gray-300">Recall our expressions for <span class="math">p</span> and <span class="math">\\bar{p}</span> are</p>

    <p class="text-gray-300"><span class="math">p(X):=\\sum_{i=1}^{n}\\xi^{i}p_{i}(X)\\;,\\quad\\bar{p}(X):=\\sum_{i=1}^{n}\\xi^{i}\\bar{p}_{i}(X)\\;.</span></p>

    <p class="text-gray-300">Then we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {p (\\beta) + \\gamma \\bar {p} (\\beta)}{\\beta - z} G = \\frac {1}{\\beta - z} U, \\quad \\frac {p (z) + \\gamma \\bar {p} (z)}{\\beta - z} G = \\frac {v - \\gamma \\bar {v} _ {j}}{\\beta - z _ {j}} G,</span></div>

    <p class="text-gray-300">with  <span class="math">U</span>  and  <span class="math">v</span>  above defined in terms of a polynomial over the  <span class="math">U_{i}</span>  and  <span class="math">p_i(z_j)</span> , respectively, evaluated at  <span class="math">\\xi_{j}</span> . We note that  <span class="math">w</span>  and  <span class="math">\\bar{w}</span>  are not rational functions because  <span class="math">X - z</span>  always divides  <span class="math">p(X) - p(z)</span>  for any univariate polynomial  <span class="math">p</span> , and that evaluated at  <span class="math">z = \\beta</span>  they are both 0 rather than undefined. Thus we have shown that in the real world each  <span class="math">\\mathsf{w}_j</span>  is defined as promised.</p>

    <p class="text-gray-300">In the ideal world, it is easy to see our expression for  <span class="math">\\mathsf{w}_j</span>  already has the expected form, as do the corresponding equations used for computing  <span class="math">U</span>  and  <span class="math">v</span> . We conclude that no adversary can distinguish between the two worlds.</p>

    <h2 id="sec-77" class="text-2xl font-bold">B.3 In the algebraic group model</h2>

    <p class="text-gray-300">The constructions in Appendix B.2 require two group elements to commit to a polynomial due to their use of knowledge assumptions. In this section we achieve better efficiency (one group element per polynomial) by proving extractability in the AGM. Instead of relying on the PKE extractor to extract polynomials from commitment, we simply use the algebraic adversary's own explanations. This makes the extractability proof straightforward.</p>

    <p class="text-gray-300">We proceed as follows. First, in Appendix B.3.1, we describe how to modify the constructions in Appendix B.2.1 to rely on the AGM, and then in Appendix B.3.2, we demonstrate that these modified constructions achieve extractability against algebraic adversaries.</p>

    <h2 id="sec-78" class="text-2xl font-bold">B.3.1 Construction</h2>

    <p class="text-gray-300">We use notation for bilinear groups introduced in Appendix A.1 and notation for algebraic algorithms from Definition A.7. The highlighted text below denotes parts of the construction that are not needed if hiding is not desired. Reusing notation from Appendix B.2.1, we refer to the non-hiding variant as  <span class="math">\\mathsf{nhPC}_{\\mathsf{s}}</span> , and the hiding variant as  <span class="math">\\mathsf{phPC}_{\\mathsf{s}}</span>  (perfectly-hiding  <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> ). At a high level, the construction follows the blueprint of Appendix B.2.1 closely, but all the terms including  <span class="math">\\alpha</span>  are never generated during setup (and thus never subsequently used). This is because these are precisely the terms used to prove knowledge when relying on PKE.</p>

    <p class="text-gray-300"><strong>Setup.</strong> On input a security parameter  <span class="math">\\lambda</span>  (in unary), and a maximum degree bound  <span class="math">D \\in \\mathbb{N}</span> ,  <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> . Setup samples public parameters  <span class="math">(\\mathsf{ck}, \\mathsf{rk})</span>  as follows. Sample a bilinear group  <span class="math">\\langle \\mathsf{group} \\rangle \\gets \\mathsf{SampleGrp}(1^{\\lambda})</span> , and parse  <span class="math">\\langle \\mathsf{group} \\rangle</span>  as a tuple  <span class="math">(\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, q, G, H, e)</span> . Sample random elements  <span class="math">\\beta, \\gamma \\in \\mathbb{F}_q</span> . Then compute the vector</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\Sigma} := \\left( \\begin{array}{c c c c c} G &amp;amp; \\beta G &amp;amp; \\beta^ {2} G &amp;amp; \\dots &amp;amp; \\beta^ {D} G \\\\ \\gamma G &amp;amp; \\gamma \\beta G &amp;amp; \\gamma \\beta^ {2} G &amp;amp; \\dots &amp;amp; \\gamma \\beta^ {D} G \\end{array} \\right) \\in \\mathbb {G} _ {1} ^ {2 D + 2}.</span></div>

    <p class="text-gray-300">Set  <span class="math">\\mathsf{ck} \\coloneqq (\\langle \\mathsf{group} \\rangle, \\Sigma)</span>  and  <span class="math">\\mathsf{rk} \\coloneqq (D, \\langle \\mathsf{group} \\rangle, \\gamma G, \\beta H)</span> , and then output the public parameters  <span class="math">(\\mathsf{ck}, \\mathsf{rk})</span> . These public parameters will support polynomials over the field  <span class="math">\\mathbb{F}_q</span>  of degree at most  <span class="math">D</span> .</p>

    <p class="text-gray-300"><strong>Commit.</strong> On input ck, univariate polynomials  <span class="math">\\pmb{p} \\coloneqq [p_i]_{i=1}^n</span>  over  <span class="math">\\mathbb{F}_q</span> , and randomness  <span class="math">\\pmb{\\omega} \\coloneqq [\\omega_i]_{i=1}^n</span> ,  <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> . Commit outputs commitments  <span class="math">\\pmb{c} \\coloneqq [c_i]_{i=1}^n</span>  that are computed as follows. If for any  <span class="math">p_i \\in \\pmb{p}</span> ,  <span class="math">\\deg(p_i) &amp;gt; D</span> , abort. Else, for each  <span class="math">i \\in [n]</span> , if  <span class="math">\\omega_i</span>  is not  <span class="math">\\perp</span> , then obtain random univariate polynomial  <span class="math">\\bar{p}_i</span>  of degree  <span class="math">\\deg(p_i)</span>  from  <span class="math">\\omega_i</span> , otherwise  <span class="math">\\bar{p}_i</span>  is set to be a zero polynomial. For each  <span class="math">i \\in [n]</span> , output  <span class="math">c_i \\coloneqq p_i(\\beta)G + \\gamma \\bar{p}_i(\\beta)G</span> . Note that because  <span class="math">p_i</span>  and  <span class="math">\\bar{p}_i</span>  have degree at most  <span class="math">D</span> , the above terms are linear combinations of terms in ck.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{op}\\mathsf{e}\\mathsf{n}</span>. On input ck, univariate polynomials <span class="math">\\bm{p}:=[p_{i}]_{i=1}^{n}</span> over <span class="math">\\mathbb{F}_{q}</span>, evaluation point <span class="math">z\\in\\mathbb{F}_{q}</span>, opening challenge <span class="math">\\xi\\in\\mathbb{F}_{q}</span>, and randomness <span class="math">\\bm{\\omega}:=[\\omega_{i}]_{i=1}^{n}</span>, which is the same randomness used for <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span>.Commit, <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span>.Open outputs an evaluation proof <span class="math">\\pi\\in\\mathbb{G}_{1}</span> that is computed as follows. If for any <span class="math">p_{i}\\in\\bm{p}</span>, <span class="math">\\deg(p_{i})&gt;D</span>, abort. For each <span class="math">i\\in[n]</span>, if <span class="math">\\omega_{i}</span> is not <span class="math">\\bot</span>, then obtain random univariate polynomial <span class="math">\\bar{p}_{i}</span> of degree <span class="math">\\deg(p_{i})</span> from <span class="math">\\omega_{i}</span>, otherwise <span class="math">\\bar{p}_{i}</span> is set to be a zero polynomial. Then compute the linear combination of polynomials <span class="math">p(X):=\\sum_{i=1}^{n}\\xi^{i}p_{i}(X)</span> and <span class="math">\\bar{p}(X):=\\sum_{i=1}^{n}\\xi^{i}\\bar{p}_{i}(X)</span>. Compute witness polynomials <span class="math">w(X):=\\frac{p(X)-p(z)}{X-z}</span> and <span class="math">\\bar{w}(X):=\\frac{\\bar{p}(X)-\\bar{p}(z)}{X-z}</span>. Set <span class="math">\\mathsf{w}:=w(\\beta)G+\\gamma\\bar{w}(\\beta)G\\in\\mathbb{G}_{1}</span> and <span class="math">\\bar{v}:=\\bar{p}(z)\\in\\mathbb{F}_{q}</span>. The evaluation proof is <span class="math">\\pi:=(\\mathsf{w},\\bar{v})</span>.</p>

    <p class="text-gray-300">Check. On input rk, commitments <span class="math">\\bm{c}:=[c_{i}]_{i=1}^{n}</span>, evaluation point <span class="math">z\\in\\mathbb{F}_{q}</span>, alleged evaluations <span class="math">\\bm{v}:=[v_{i}]_{i=1}^{n}</span>, evaluation proof <span class="math">\\pi:=(\\mathsf{w},\\bar{v})</span>, and randomness <span class="math">\\xi\\in\\mathbb{F}_{q}</span>, <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span>.Check proceeds as follows. Compute the linear combination <span class="math">C:=\\sum_{i=1}^{n}\\xi^{i}c_{i}</span> Then compute the linear combination of evaluations <span class="math">v:=\\sum_{i=1}^{n}\\xi^{i}v_{i}</span>, and check the evaluation proof via the equality <span class="math">e(C-vG-\\gamma\\bar{v}G,H)=e(\\mathsf{w},\\beta H-zH)</span>.</p>

    <p class="text-gray-300">Completeness. Completeness can be proved by suitably modifying the completeness proof in Appendix B.2.1.</p>

    <p class="text-gray-300">Succinctness. The scheme <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> constructed in this section requires <span class="math">n</span> <span class="math">\\mathbb{G}_{1}</span> elements to commit to <span class="math">\\bm{c}=[c_{i}]_{i=1}^{n}</span>, one <span class="math">\\mathbb{G}_{1}</span> and one <span class="math">\\mathbb{F}_{q}</span> element for the evaluation proof, and the time to check this proof of evaluation requires two pairings and one variable-base multi-scalar multiplication of size <span class="math">n</span>.</p>

    <h4 id="sec-79" class="text-lg font-semibold mt-6">B.3.2 Extractability and hiding</h4>

    <h6 id="sec-80" class="text-base font-medium mt-4">Theorem B.12.</h6>

    <p class="text-gray-300">If the bilinear group sampler <span class="math">\\mathsf{SampleGrp}</span> satisfies the <span class="math">\\mathsf{SDH}</span> assumption against algebraic adversaries (Assumption 1), <span class="math">\\mathsf{nhPC}_{\\mathsf{s}}</span> and <span class="math">\\mathsf{phPC}_{\\mathsf{s}}</span> constructed in Appendix B.3.1 achieve extractability against algebraic adversaries (Definition B.2).</p>

    <p class="text-gray-300">To prove this, we rely on the fact that <span class="math">\\mathsf{nhPC}_{\\mathsf{s}}</span> and <span class="math">\\mathsf{phPC}_{\\mathsf{s}}</span> satisfy evaluation binding (Definition B.8):</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Lemma B.13.</h6>

    <p class="text-gray-300">If the bilinear group sampler <span class="math">\\mathsf{SampleGrp}</span> satisfies the <span class="math">\\mathsf{SDH}</span> assumption (Assumption 1), then <span class="math">\\mathsf{nhPC}_{\\mathsf{s}}</span> and <span class="math">\\mathsf{phPC}_{\\mathsf{s}}</span> constructed in Appendix B.3.1 achieve evaluation binding (Definition B.8).</p>

    <p class="text-gray-300">The proof of the above lemma is easily achieved by straightforward modifications to the proof of Lemma B.9.</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Lemma B.14.</h6>

    <p class="text-gray-300">If the bilinear group sampler <span class="math">\\mathsf{SampleGrp}</span> satisfies the <span class="math">\\mathsf{SDH}</span> assumption against algebraic adversaries (Assumption 1), <span class="math">\\mathsf{nhPC}_{\\mathsf{s}}</span> and <span class="math">\\mathsf{phPC}_{\\mathsf{s}}</span> constructed in Appendix B.3.1 achieve extractability against algebraic adversaries (Definition B.2).</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Fix any efficient, algebraic adversary <span class="math">\\mathcal{A}_{\\mathsf{alg}}</span> and maximum degree bound <span class="math">D\\in\\mathbb{N}</span>. We show how to construct an efficient extractor <span class="math">\\mathcal{E}_{\\mathcal{A}_{\\mathsf{alg}}}</span> for the polynomial commitment scheme that succeeds with overwhelming probability. In each round <span class="math">i\\in[r]</span> algorithm <span class="math">\\mathcal{E}_{\\mathcal{A}_{\\mathsf{alg}}}</span> proceeds as follows. We denote by <span class="math">\\mathsf{k}</span> the number of group elements output by the adversary <span class="math">\\mathcal{A}_{\\mathsf{alg}}</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}_{\\mathcal{A}_{\\mathrm{alg}}}(\\mathrm{ck},\\mathrm{rk};[\\rho_j]_{j = 1}^i)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse ck as  <span class="math">(\\langle \\mathrm{group}\\rangle ,\\Sigma)</span></li>

      <li>Parse  <span class="math">\\pmb{\\Sigma}</span>  as  <span class="math">\\left( \\begin{array}{cccc}G &amp;amp; \\beta G &amp;amp; \\beta^2 G &amp;amp; \\dots &amp;amp; \\beta^D G\\\\ \\gamma G &amp;amp; \\gamma \\beta G &amp;amp; \\gamma \\beta^2 G &amp;amp; \\dots &amp;amp; \\gamma \\beta^D G \\end{array} \\right)</span> .</li>

      <li>Set  <span class="math">\\Sigma_{1} := (G, \\beta G, \\beta^{2}G, \\ldots, \\beta^{D}G)</span> .</li>

      <li>Set  <span class="math">\\Sigma_{2} := (\\gamma G, \\gamma \\beta G, \\gamma \\beta^{2}G, \\dots, \\gamma \\beta^{D}G)</span> .</li>

      <li>Invoke the adversary:  <span class="math">[\\langle \\pmb{a}_j, \\pmb{\\Sigma}_1 \\rangle + \\langle \\pmb{b}_j, \\pmb{\\Sigma}_2 \\rangle]_{j=1}^k \\gets \\mathcal{A}_{\\mathrm{alg}}(\\mathrm{ck}, \\mathrm{rk}; [\\rho_j]_{j=1}^i)</span> .</li>

      <li>Set  <span class="math">\\pmb{X} \\coloneqq (1, X, \\dots, X^{D})</span> .</li>

      <li>For each  <span class="math">j</span>  in  <span class="math">[k]</span> , define polynomials  <span class="math">p_j(X) \\coloneqq \\langle \\pmb{a}_j, \\pmb{X} \\rangle \\in \\mathbb{F}_q[X]</span>  and  <span class="math">\\bar{p}_j(X) \\coloneqq \\langle \\pmb{b}_j, \\pmb{X} \\rangle \\in \\mathbb{F}_q[X]</span> .</li>

      <li>For each  <span class="math">j</span>  in  <span class="math">[k]</span> , let the randomness  <span class="math">\\omega_{j}</span>  be the coefficients of  <span class="math">\\bar{p}_j</span> .</li>

      <li>Output the polynomials  <span class="math">\\pmb{p} = [p_j]_{j=1}^k</span>  and randomness  <span class="math">\\omega := [\\omega_j]_{j=1}^k</span> .</li>

    </ol>

    <p class="text-gray-300">For a given efficient public-coin challenger  <span class="math">\\mathcal{C}</span> , efficient adversary  <span class="math">\\mathcal{B} := (\\mathcal{B}_1, \\mathcal{B}_2)</span> , efficient query sampler  <span class="math">\\mathcal{Q}</span> , and round bound  <span class="math">r \\in \\mathbb{N}</span> , the extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}_{\\mathrm{alg}}}</span>  can fail with non-negligible probability only if there exists a polynomial whose claimed evaluation is incorrect. However, because  <span class="math">\\mathsf{nhPC_s}</span>  and  <span class="math">\\mathsf{phPC_s}</span>  satisfy evaluation binding, all evaluations are correct with overwhelming probability. This latter fact follows from a reduction identical to that in the corresponding portion of the extractability proof of Lemma B.10. Hence,  <span class="math">\\mathcal{E}_{\\mathcal{A}_{\\mathrm{alg}}}</span>  succeeds with overwhelming probability.</p>

    <p class="text-gray-300">Lemma B.15.  <span class="math">\\mathsf{phPC}_{\\mathbf{s}}</span>  constructed in Appendix B.3.1 is perfectly hiding (Definition B.4).</p>

    <p class="text-gray-300">At a high level, one can adapt the proof in Theorem B.11 into a proof of Lemma B.15 by removing from it all terms related to  <span class="math">\\alpha</span> , as the proof only reasons about these terms for the sake of completeness.</p>

    <p class="text-gray-300">We construct a polynomial commitment scheme that supports multiple degree bounds up to a maximum degree chosen at setup time.</p>

    <p class="text-gray-300">We again temporarily restrict our attention to the case where, in the reveal phase, all polynomials are evaluated at the same evaluation point. (We will relax this restriction in Appendix D.) We do not provide a standalone definition for the construction that we consider below, because it equals the definition in Section 6.1 when restricted to admissible query samplers which output query sets  <span class="math">Q</span>  consisting of a single evaluation point at which a subset of the polynomials are evaluated (i.e.,  <span class="math">Q = T \\times \\{z\\}</span>  for some  <span class="math">T \\subseteq [n]</span> , and  <span class="math">z \\in \\mathbb{F}</span> ).</p>

    <p class="text-gray-300">We proceed as follows. First, in Appendix C.1, we present a construction for the above goal that builds upon ideas in Appendix B.3.1. Then, in Appendix C.2, we reduce the hiding and extractability of this construction to the hiding and extractability of a related construction that is simpler to analyze, but is not degree-efficient. This simpler construction might also be of independent interest.</p>

    <p class="text-gray-300">We demonstrate how to construct a polynomial commitment that supports multiple degree bounds efficiently. Our construction builds upon the construction in Appendix B.3.1. A polynomial commitment scheme over a field family  <span class="math">\\mathcal{F}</span>  for multiple degree bounds and a single evaluation point is a tuple of algorithms  <span class="math">\\mathrm{PC}_{\\mathfrak{m}} = (\\mathrm{Setup}, \\mathrm{Trim}, \\mathrm{Commit}, \\mathrm{Open}, \\mathrm{Check})</span>  with the following syntax. Below we use  <span class="math">[[a_i, b_i]]_{i=1}^n</span>  as a short-hand for the tuple  <span class="math">(a_1, b_1, \\ldots, a_n, b_n)</span> . The highlighted text below denotes the parts of the construction that differ from the construction in Appendix B.3.1.</p>

    <p class="text-gray-300">Setup. On input a security parameter  <span class="math">\\lambda</span>  (in unary), and a maximum degree bound  <span class="math">D\\in \\mathbb{N}</span> <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span>  .Setup samples public parameters pp as follows. Sample a bilinear group  <span class="math">\\langle \\mathrm{group}\\rangle \\gets \\mathrm{SampleGrp}(1^{\\lambda})</span>  , and parse  <span class="math">\\langle \\mathrm{group}\\rangle</span>  as a tuple  <span class="math">(\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T,q,G,H,e)</span>  . Sample random elements  <span class="math">\\beta ,\\gamma \\in \\mathbb{F}_q</span>  . Then compute the vector</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\Sigma} := \\left( \\begin{array}{c c c c c} G &amp;amp; \\beta G &amp;amp; \\beta^ {2} G &amp;amp; \\ldots &amp;amp; \\beta^ {D} G \\\\ \\gamma G &amp;amp; \\gamma \\beta G &amp;amp; \\gamma \\beta^ {2} G &amp;amp; \\ldots &amp;amp; \\gamma \\beta^ {D} G \\end{array} \\right) \\in \\mathbb {G} _ {1} ^ {2 D + 2}.</span></div>

    <p class="text-gray-300">Set  <span class="math">\\mathsf{pp} := (D, \\langle \\mathsf{group} \\rangle, \\Sigma, \\beta H)</span> , and then output the public parameters  <span class="math">\\mathsf{pp}</span> . These public parameters will support polynomials over the field  <span class="math">\\mathbb{F}_q</span>  of degree at most  <span class="math">D</span> .</p>

    <p class="text-gray-300">Trim. Given oracle access to public parameters pp, and on input a security parameter  <span class="math">\\lambda</span>  (in unary), and degree bounds  <span class="math">d = [d_i]_{i=1}^n</span> ,  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span> . Trim <span class="math">^{\\mathrm{pp}}</span>  deterministically computes a key pair (ck, rk) that is specialized to  <span class="math">d</span>  as follows. Let  <span class="math">d</span>  be the maximum degree bound in  <span class="math">d</span> . Then obtain  <span class="math">\\Sigma_{\\mathrm{ck}}</span>  from public parameters:</p>

    <div class="my-4 text-center"><span class="math-block">\\Sigma_ {\\mathrm {c k}} := \\left( \\begin{array}{c c c c c c c c} G &amp;amp; \\beta G &amp;amp; \\ldots &amp;amp; \\beta^ {d} G &amp;amp; \\beta^ {D - d} G &amp;amp; \\beta^ {D - d + 1} G &amp;amp; \\ldots &amp;amp; \\beta^ {D} G \\\\ \\gamma G &amp;amp; \\gamma \\beta G &amp;amp; \\ldots &amp;amp; \\gamma \\beta^ {d} G \\end{array} \\right) \\in \\mathbb {G} _ {1} ^ {3 d + 3}.</span></div>

    <p class="text-gray-300">Set  <span class="math">\\mathsf{ck} := (\\Sigma_{\\mathsf{ck}}, d)</span> . Let  <span class="math">\\Sigma_{\\mathsf{rk}}</span>  be the set  <span class="math">\\{\\beta^{D - d_i}G\\}_{i \\in [n]}</span>  and  <span class="math">\\mathsf{rk} := (D, \\langle \\mathsf{group} \\rangle, \\Sigma_{\\mathsf{rk}}, \\gamma G, \\beta H, d)</span> , and then output the key pair  <span class="math">(\\mathsf{ck}, \\mathsf{rk})</span> . This key pair is specialized to  <span class="math">d</span> .</p>

    <p class="text-gray-300">Commit. On input ck, univariate polynomials  <span class="math">\\pmb{p} = [p_i]_{i=1}^n</span>  over the field  <span class="math">\\mathbb{F}_q</span> , degree bounds  <span class="math">\\pmb{d} = [d_i]_{i=1}^n</span>  with  <span class="math">\\deg(\\pmb{p}) \\leq \\pmb{d} \\leq D</span> , and randomness  <span class="math">\\pmb{\\omega} = [[\\omega_i, \\omega_i&#x27;]]_{i=1}^n</span> ,  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span> . Commit outputs commitments  <span class="math">\\pmb{c} = [c_i]_{i=1}^n</span>  that are computed as follows. Obtain the supported degree bounds  <span class="math">\\pmb{d}&#x27;</span>  from ck. If for any  <span class="math">p_i \\in \\pmb{p}</span> ,  <span class="math">\\deg(p_i) &amp;gt; d_i</span></p>

    <p class="text-gray-300">or <span class="math">d_i \\notin d&#x27;</span>, abort. For each <span class="math">i \\in [n]</span>, if <span class="math">\\omega_i</span> and <span class="math">\\omega_i&#x27;</span> are not <span class="math">\\perp</span>, then obtain from them random univariate polynomials <span class="math">\\bar{p}_i</span> and <span class="math">\\bar{p}_i&#x27;</span> of degree <span class="math">\\deg(p_i)</span>; otherwise, set <span class="math">\\bar{p}_i</span> and <span class="math">\\bar{p}_i&#x27;</span> to be the zero polynomial. For each <span class="math">i \\in [n]</span>, compute <span class="math">\\mathbb{C}_i := p_i(\\beta)G + \\gamma \\bar{p}_i(\\beta)G</span> and <span class="math">\\mathbb{C}_i&#x27; := \\beta^{D - d_i}p_i(\\beta)G + \\gamma \\bar{p}_i&#x27;(\\beta)G</span>. Finally, set <span class="math">c_i := (\\mathbb{C}_i, \\mathbb{C}_i&#x27;)</span>, and output <span class="math">c := [c_i]_{i=1}^n</span>. Note that because <span class="math">p_i(X)</span>, <span class="math">X^{D - d_i}p_i(X)</span>, <span class="math">\\bar{p}_i(X)</span> and <span class="math">\\bar{p}_i&#x27;(X)</span> have at most <span class="math">d_i</span> non-zero coefficients, the above terms are linear combinations of terms in ck.</p>

    <p class="text-gray-300"><strong>Open.</strong> On input ck, univariate polynomials <span class="math">\\pmb{p} = [p_i]_{i=1}^n</span> over the field <span class="math">\\mathbb{F}_q</span>, degree bounds <span class="math">\\pmb{d} = [d_i]_{i=1}^n</span>, evaluation point <span class="math">z \\in \\mathbb{F}_q</span>, opening challenge <span class="math">\\xi</span>, and randomness <span class="math">\\omega = [[\\omega_i, \\omega_i&#x27;]]_{i=1}^n</span>, <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span>. Open outputs the evaluation proof <span class="math">\\pi</span> as follows. Obtain the supported degree bounds <span class="math">\\pmb{d}&#x27;</span> from ck. If for any <span class="math">p_i \\in \\pmb{p}</span>, <span class="math">\\deg(p_i) &amp;gt; d_i</span> or <span class="math">d_i \\notin d&#x27;</span>, abort. For each <span class="math">i \\in [n]</span>, if <span class="math">\\omega_i</span> and <span class="math">\\omega_i&#x27;</span> are not <span class="math">\\perp</span>, obtain from them random univariate polynomials <span class="math">\\bar{p}_i</span> and <span class="math">\\bar{p}_i&#x27;</span> of degree <span class="math">\\deg(p_i)</span>; otherwise, set <span class="math">\\bar{p}_i</span> and <span class="math">\\bar{p}_i&#x27;</span> to be the zero polynomial.</p>

    <p class="text-gray-300">Then, for each <span class="math">i \\in [n]</span>, define the polynomial <span class="math">p_i^\\star(X) := X^{D - d_i} p_i(X) - X^{D - d_i} p_i(z)</span>, and compute a witness polynomial <span class="math">w_i(X) := \\frac{p_i(X) - p_i(z)}{X - z}</span> for <span class="math">p_i</span>, and a witness polynomial <span class="math">w_i^\\star(X) := X^{D - d_i} w_i(X)</span> for <span class="math">p_i^\\star</span>. Finally, compute the witness polynomial for these 2n polynomials as <span class="math">w := \\sum_{i=1}^n \\xi^i w_i + \\sum_{i=1}^n \\xi^{n+i} w_i^\\star</span>.</p>

    <p class="text-gray-300">Next, compute the linear combination of the random polynomials <span class="math">\\bar{p} := \\sum_{i=1}^{n} \\xi^i \\bar{p}_i</span> and <span class="math">\\bar{p}&#x27; := \\sum_{i=1}^{n} \\xi^{n+i} \\bar{p}_i&#x27;</span>, and compute the witness polynomial <span class="math">\\bar{w}(X) := \\frac{\\bar{p}(X) - \\bar{p}(z) + \\bar{p}&#x27;(X) - \\bar{p}&#x27;(z)}{X - z}</span> for these. Set <span class="math">\\mathsf{w} := w(\\beta)G + \\gamma \\bar{w}(\\beta)G \\in \\mathbb{G}_1</span>, and <span class="math">\\bar{v} := \\bar{p}(z) + \\bar{p}&#x27;(z) \\in \\mathbb{F}_q</span>. The evaluation proof is <span class="math">\\pi := (\\mathsf{w}, \\bar{v})</span>.</p>

    <p class="text-gray-300"><strong>Check.</strong> On input rk, commitments <span class="math">\\pmb{c} = [c_i]_{i=1}^n</span>, degree bounds <span class="math">\\pmb{d} = [d_i]_{i=1}^n</span>, evaluation point <span class="math">z \\in \\mathbb{F}_q</span>, alleged evaluations <span class="math">\\pmb{v} = [v_i]_{i=1}^n</span>, evaluation proof <span class="math">\\pi = (\\mathsf{w}, \\bar{v})</span>, and opening challenge <span class="math">\\xi</span>, <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span>. Check proceeds as follows. Obtain the supported degree bounds <span class="math">\\pmb{d}&#x27;</span> from rk. If for any <span class="math">d_i \\in \\pmb{d}</span>, <span class="math">d_i \\notin d&#x27;</span>, abort. Parse each commitment <span class="math">c_i</span> as a pair of sub-commitments <span class="math">(\\mathbb{C}_i, \\mathbb{C}_i&#x27;)</span>, and construct <span class="math">\\mathbb{C}_i^\\star := \\mathbb{C}_i&#x27; - v_i \\beta^{D - d_i} G</span>. Next, compute the two linear combinations</p>

    <div class="my-4 text-center"><span class="math-block">C := \\sum_{i=1}^{n} \\xi^i \\mathbb{C}_i + \\sum_{i=1}^{n} \\xi^{n+i} \\mathbb{C}_i^\\star, \\quad v := \\sum_{i=1}^{n} \\xi^i v_i,</span></div>

    <p class="text-gray-300">Then check the evaluation proof <span class="math">\\pi = (\\mathsf{w},\\bar{v})</span> via the equality <span class="math">e(C - vG - \\gamma \\bar{v} G,H) = e(\\mathsf{w},\\beta H - zH)</span>.</p>

    <p class="text-gray-300"><strong>Lemma C.1.</strong> The scheme <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span> constructed above achieves completeness (Definition 6.1).</p>

    <p class="text-gray-300"><strong>Proof.</strong> Fix any maximum degree bounds <span class="math">D</span>, <span class="math">\\pmb{d} = [d_i]_{i=1}^n</span> and efficient adversary <span class="math">\\mathcal{A}</span>. Let <span class="math">\\mathsf{pp}</span> be any public parameters output by the algorithm <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span>. <span class="math">\\mathsf{Setup}(1^\\lambda, D)</span>. Let <span class="math">\\mathcal{A}(\\mathsf{pp})</span> select polynomials <span class="math">\\pmb{p} = [p_i]_{i=1}^n</span> over <span class="math">\\mathbb{F}_q</span>, degree bounds <span class="math">\\pmb{d} = [d_i]_{i=1}^n</span>, location <span class="math">z \\in \\mathbb{F}_q</span>, and opening challenge <span class="math">\\xi \\in \\mathbb{F}_q</span>. We only need to consider adversaries <span class="math">\\mathcal{A}</span> that make choices for which <span class="math">\\deg(\\pmb{p}) \\leq d_i \\leq D</span>. Let <span class="math">(\\mathsf{ck}, \\mathsf{rk})</span> be any key pair output by the algorithm <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span>. <span class="math">\\mathsf{Trim}^{\\mathsf{pp}}(1^\\lambda, \\pmb{d})</span> constructed above. The keys contain a description <span class="math">\\langle \\mathsf{group} \\rangle</span> of a bilinear group of some prime order <span class="math">q</span>, which in particular induces a field <span class="math">\\mathbb{F}_q</span>.</p>

    <p class="text-gray-300">Now consider commitments <span class="math">\\pmb{c} = [c_i]_{i=1}^n</span> and evaluation proof <span class="math">\\pi</span> that are all computed according to the construction above. We need to show that, for the correct evaluations <span class="math">\\pmb{v} := \\pmb{p}(z)</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{PC}_{\\mathfrak{m}} \\cdot \\mathsf{Check}(\\mathsf{rk}, \\boldsymbol{c}, \\boldsymbol{d}, z, \\boldsymbol{v}, \\pi, \\xi) = 1.</span></div>

    <p class="text-gray-300">This amounts to arguing that the pairing equations are satisfied. For these equations, note that the combined commitment <span class="math">C</span> and evaluation <span class="math">v</span> are computed by <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span>. Check as follows:</p>

    <p class="text-gray-300">70</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} C = \\sum_{i=1}^{n} \\xi^{i} \\mathbb{C}_{i} + \\sum_{i=1}^{n} \\xi^{n+i} \\mathbb{C}_{i}^{\\star} \\\\ = \\sum_{i=1}^{n} \\xi^{i} (p_{i}(\\beta) G + \\gamma \\bar{p}_{i}(\\beta) G) + \\sum_{i=1}^{n} \\xi^{n+i} (\\beta^{D-d_{i}} (p_{i}(\\beta) - p_{i}(z)) G + \\gamma \\bar{p}_{i}&#x27;(\\beta) G) \\\\ = \\sum_{i=1}^{n} \\xi^{i} (p_{i}(\\beta) G + \\gamma \\bar{p}_{i}(\\beta) G) + \\sum_{i=1}^{n} \\xi^{n+i} (p_{i}^{\\star}(\\beta) G + \\gamma \\bar{p}_{i}&#x27;(\\beta) G), \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">v = \\sum_{i=1}^{n} \\xi^{i} v_{i} = \\sum_{i=1}^{n} \\xi^{i} p_{i}(z).</span></div>

    <p class="text-gray-300">In the evaluation proof <span class="math">\\pi = (\\mathsf{w},\\bar{v})</span>, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{w} = (w(\\beta) + \\gamma \\bar{w}(\\beta)) G \\\\ = \\sum_{i=1}^{n} \\xi^{i} w_{i}(\\beta) G + \\sum_{i=1}^{n} \\xi^{n+i} w_{i}^{\\star}(\\beta) G + \\sum_{i=1}^{n} \\xi^{i} \\bar{w}_{i}(\\beta) \\gamma G + \\sum_{i=1}^{n} \\xi^{n+i} \\bar{w}_{i}&#x27;(\\beta) \\gamma G \\\\ = \\sum_{i=1}^{n} \\frac{\\xi^{i} (p_{i}(\\beta) - p_{i}(z)) + \\xi^{n+i} p_{i}^{\\star}(\\beta) + \\xi^{i} (\\bar{p}_{i}(\\beta) - \\bar{p}_{i}(z)) \\gamma + \\xi^{n+i} (\\bar{p}_{i}&#x27;(\\beta) - \\bar{p}_{i}&#x27;(z)) \\gamma}{\\beta - z} G \\\\ \\end{array}</span></div>

    <p class="text-gray-300">We also have that the evaluation <span class="math">\\bar{v} = \\bar{p}(z) + \\bar{p}&#x27;(z)</span>. Therefore,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e (C - v G - \\gamma \\bar{v} G, H) \\\\ = e \\left(\\sum_{i=1}^{n} \\left(\\xi^{i} \\left((p_{i}(\\beta) - v_{i}) + \\gamma (\\bar{p}_{i}(\\beta) - \\bar{p}_{i}(z))\\right) + \\xi^{n+i} \\left(p_{i}^{\\star}(\\beta) + \\gamma (\\bar{p}_{i}&#x27;(\\beta) - \\bar{p}_{i}&#x27;(z))\\right)\\right) G, H\\right) \\\\ = e \\left(\\frac{\\sum_{i=1}^{n} \\xi^{i} (p_{i}(\\beta) - p_{i}(z)) + \\xi^{n+i} p_{i}^{\\star}(\\beta) + \\xi^{i} (\\bar{p}_{i}(\\beta) - \\bar{p}_{i}(z)) \\gamma + \\xi^{n+i} (\\bar{p}_{i}&#x27;(\\beta) - \\bar{p}_{i}&#x27;(z)) \\gamma}{\\beta - z} G, (\\beta - z) H\\right) \\\\ = e \\left(\\left(w(\\beta) + \\gamma \\bar{w}(\\beta)\\right) G, \\beta H - z H\\right) \\\\ = e (\\mathsf{w}, \\beta H - z H). \\end{array}</span></div>

    <p class="text-gray-300">We conclude that the pairing equation also holds.</p>

    <p class="text-gray-300">Lemma C.2. The scheme <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span> constructed achieves efficiency, as defined in Definition 6.3.</p>

    <p class="text-gray-300">Proof. <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span> satisfies both efficiency properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Degree-efficiency: For a list of <span class="math">n</span> polynomials with degree bounds <span class="math">\\mathbf{d} = [d_i]_{i=1}^n</span> where <span class="math">d = \\max(\\mathbf{d})</span> is the maximum supported degree bounds for these polynomials, both <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span>. Commit and <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span>. Open only handle polynomials having at most <span class="math">d</span> coefficients, and so the time to commit to the polynomials is the time for <span class="math">4n</span> variable-base multi-scalar multiplications of size at most <span class="math">d</span>, while the time to compute an evaluation proof is the time to compute two polynomial divisions of degree at most <span class="math">d</span> plus the time required for two variable-base multi-scalar multiplications of size at most <span class="math">d</span>.</li>

      <li>Succinctness: For a list of <span class="math">n</span> polynomials, the scheme <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span> requires <span class="math">2n \\mathbb{G}_1</span> elements for a commitment and one <span class="math">\\mathbb{G}_1</span> element and one <span class="math">\\mathbb{F}_q</span> element for an evaluation proof, while the time to check this proof requires two variable-base multi-scalar multiplications of size <span class="math">n</span> and two pairings.</li>

    </ul>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">Extractability and hiding. We reduce the extractability and hiding properties of our construction to those of a simpler-to-analyze construction described below. This latter construction makes black-box use of any <span class="math">\\mathsf{PC}_{\\mathfrak{s}}</span> scheme.</p>

    <p class="text-gray-300">71</p>

    <p class="text-gray-300">C.2 Black-box construction</p>

    <p class="text-gray-300">We now provide a simpler construction of <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span> that makes black-box use of <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span>. This construction is not degree-efficient (Definition 6.3), but is simpler to analyze.</p>

    <p class="text-gray-300">Setup. On input a security parameter <span class="math">\\lambda</span> (in unary), and a maximum degree bound <span class="math">D\\in\\mathbb{N}</span>, <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span>.Setup samples and outputs <span class="math">\\mathsf{pp}:=\\mathsf{PC}_{\\mathsf{s}}</span>.<span class="math">\\mathsf{Setup}(1^{\\lambda},D)</span>. The keys contain the description of a finite field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span>.</p>

    <p class="text-gray-300">Trim. Given oracle access to public parameters <span class="math">\\mathsf{pp}</span>, and on input a security parameter <span class="math">\\lambda</span> (in unary), and degree bounds <span class="math">\\bm{d}</span>, <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span>.Trim simply parses <span class="math">\\mathsf{pp}</span> as <span class="math">(\\mathsf{ck},\\mathsf{rk})</span> and outputs these.</p>

    <p class="text-gray-300">Commit. On input <span class="math">\\mathsf{ck}</span>, univariate polynomials <span class="math">\\bm{p}=[p_{i}]_{i=1}^{n}</span> over the field <span class="math">\\mathbb{F}</span>, degree bounds <span class="math">\\bm{d}=[d_{i}]_{i=1}^{n}</span> with <span class="math">\\deg(\\bm{p})\\leq\\bm{d}\\leq D</span>, and randomness <span class="math">\\bm{\\omega}=[[\\omega_{i},\\omega_{i}^{\\prime}]]_{i=1}^{n}</span>, <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span>.Commit outputs commitments <span class="math">\\bm{c}=[c_{i}]_{i=1}^{n}</span> that are computed as follows. First, for each <span class="math">i\\in[n]</span>, define the shifted polynomial <span class="math">p_{i}^{\\prime}(X):=X^{D-d_{i}}p_{i}(X)</span>. Next, use <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> to simultaneously commit to all unshifted and shifted polynomials: <span class="math">[[\\mathbbm{e}_{i},\\mathbbm{e}_{i}^{\\prime}]]_{i=1}^{n}:=\\mathsf{PC}_{\\mathsf{s}}</span>.<span class="math">\\mathsf{Commit}(\\mathsf{ck},[[p_{i},p_{i}^{\\prime}]]_{i=1}^{n};\\bm{\\omega})</span>. Finally, set <span class="math">c_{i}:=(\\mathbbm{e}_{i},\\mathbbm{e}_{i}^{\\prime})</span>, and output <span class="math">\\bm{c}:=[c_{i}]_{i=1}^{n}</span>. Note that every polynomial being committed has degree at most <span class="math">D</span>.</p>

    <p class="text-gray-300">Open. On input <span class="math">\\mathsf{ck}</span>, univariate polynomials <span class="math">\\bm{p}=[p_{i}]_{i=1}^{n}</span> over the field <span class="math">\\mathbb{F}</span>, degree bounds <span class="math">\\bm{d}=[d_{i}]_{i=1}^{n}</span>, evaluation point <span class="math">z\\in\\mathbb{F}</span>, opening challenge <span class="math">\\xi</span>, and randomness <span class="math">\\bm{\\omega}=[[\\omega_{i},\\omega_{i}^{\\prime}]]_{i=1}^{n}</span>, <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span>.Open outputs the evaluation proof <span class="math">\\pi:=\\mathsf{PC}_{\\mathsf{s}}</span>.<span class="math">\\mathsf{Open}(\\mathsf{ck},[[p_{i},p_{i}^{\\prime}]]_{i=1}^{n},z,\\xi;\\bm{\\omega})</span>, where each <span class="math">p_{i}^{\\prime}</span> is the shift of <span class="math">p_{i}</span> respectively.</p>

    <p class="text-gray-300">Check. On input <span class="math">\\mathsf{rk}</span>, commitments <span class="math">\\bm{c}=[c_{i}]_{i=1}^{n}</span>, degree bounds <span class="math">\\bm{d}=[d_{i}]_{i=1}^{n}</span>, evaluation point <span class="math">z\\in\\mathbb{F}</span>, alleged evaluations <span class="math">\\bm{v}=[v_{i}]_{i=1}^{n}</span>, evaluation proof <span class="math">\\pi</span>, and opening challenge <span class="math">\\xi</span>, <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span>.Check proceeds as follows. Parse each commitment <span class="math">c_{i}</span> as a pair of sub-commitments <span class="math">(\\mathbbm{e}_{i},\\mathbbm{e}_{i}^{\\prime})</span>. For each <span class="math">i\\in[n]</span>, compute the shifted evaluation <span class="math">v_{i}^{\\prime}:=z^{D-d_{i}}v_{i}</span>. Check that <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span>.<span class="math">\\mathsf{Check}(\\mathsf{rk},[[\\mathbbm{e}_{i},\\mathbbm{e}_{i}^{\\prime}]]_{i=1}^{n},z,[[v_{i},v_{i}^{\\prime}]]_{i=1}^{n},\\pi,\\xi)</span> accepts.</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Lemma C.3.</h6>

    <p class="text-gray-300">If <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> achieves completeness (Definition B.1) then <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span> achieves completeness (Definition 6.1).</p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">If an adversary <span class="math">\\mathcal{A}(\\mathsf{ck},\\mathsf{rk})</span> selects polynomials <span class="math">[p_{i}]_{i=1}^{n}</span>, degree bounds <span class="math">[d_{i}]_{i=1}^{n}</span>, evaluation point <span class="math">z\\in\\mathbb{F}</span>, and opening challenge <span class="math">\\xi</span> such that, for every <span class="math">i\\in[n]</span>, we have <span class="math">\\deg(p_{i})\\leq d_{i}\\leq D</span>, then both the unshifted polynomials <span class="math">[p_{i}]_{i=1}^{n}</span> and shifted polynomials <span class="math">[p_{i}^{\\prime}]_{i=1}^{n}</span> have degree at most <span class="math">D</span>. Furthermore, because the shifted polynomials are computed as <span class="math">p^{\\prime}(X)=X^{D-d_{i}}p(X)</span>, the shifted evaluations will always match: <span class="math">v_{i}^{\\prime}=z^{D-d_{i}}\\cdot v_{i}</span>. This means that the completeness of <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> ensures that the commitments produced via <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> will pass the tests in <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span>.Check. ∎</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Lemma C.4.</h6>

    <p class="text-gray-300">If <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> achieves succinctness (Definition B.3) then <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span> achieves succinctness (Definition 6.3).</p>

    <h6 id="sec-89" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The commitment of <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span> contains <span class="math">2n</span> <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> commitments and the evaluation proof contains one <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> proof. The time to check <span class="math">n</span> evaluations is the same as the time to check <span class="math">2n</span> evaluations in <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span>, plus at most <span class="math">n\\cdot(\\log D)</span> field operations to compute <span class="math">\\bm{v}^{\\prime}</span>. ∎</p>

    <h6 id="sec-90" class="text-base font-medium mt-4">Lemma C.5.</h6>

    <p class="text-gray-300">If the construction in Appendix C.2 achieves extractability and hiding when instantiated with <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span> from Appendix B.3, then so does the construction in Appendix C.1.</p>

    <h6 id="sec-91" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We show how to reduce the extractability and hiding of the construction in Appendix C.1 (denoted by <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span>) to that of the foregoing construction (denoted by <span class="math">\\mathsf{PC}_{\\mathsf{m}}^{\\prime}</span>). For simplicity, we consider the case of a single polynomial <span class="math">p</span> with a single degree bound <span class="math">d</span> evaluated at the query point <span class="math">z</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Extractability: Note that <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span> commitments are identical to <span class="math">\\mathsf{PC}_{\\mathsf{m}}^{\\prime}</span> commitments. The same holds for evaluation proofs for unshifted polynomials. Hence, the only difference is in how degree bounds are enforced, and so we focus on this latter aspect.</li>

    </ul>

    <p class="text-gray-300">Define the polynomials  <span class="math">p_1 \\coloneqq X^{D - d}p(X) - X^{D - d}v</span>  and  <span class="math">p_2 \\coloneqq X^{D - d}p(X)</span> . To enforce degree bounds,  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span>  provides an evaluation proof for the claim that  <span class="math">p_1(z) = 0</span> , while  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}&#x27;</span>  provides a proof for the claim that  <span class="math">p_2(z) = z^{D - d}v</span> . However, notice that  <span class="math">p_2(z) = z^{D - d}v</span>  if and only if  <span class="math">p_2(z) = 0</span> , and so a  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span>  evaluation proof is valid only if the "corresponding"  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}&#x27;</span>  proof is also valid.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Hiding: Note that  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span>  commitments and evaluation proofs for unshifted polynomials are identical to those for  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}&#x27;</span> , and so we focus on evaluation proofs for shifted polynomials. As seen from the calculation of  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span> , the witness polynomial for  <span class="math">p_1</span>  is a shifted version of the witness polynomial for  <span class="math">p</span> , and hence the evaluation proof does not reveal any additional information about  <span class="math">p</span> .</li>

    </ul>

    <p class="text-gray-300">Theorem C.6. If  <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span>  achieves extractability (Definition B.2) then  <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span>  achieves extractability (Definition 6.2 restricted to query sets  <span class="math">Q</span>  querying a subset of polynomials at the same point (i.e.,  <span class="math">Q = T \\times \\{z\\}</span>  for some  <span class="math">T \\subseteq [n]</span> , and  <span class="math">z \\in \\mathbb{F}</span> ).</p>

    <p class="text-gray-300">Proof. Fix a maximum degree bound  <span class="math">D</span>  and an efficient adversary  <span class="math">\\mathcal{A}</span>  against  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span> . We use  <span class="math">\\mathcal{A}</span>  to construct an adversary  <span class="math">\\mathcal{B}</span>  and query sampler  <span class="math">\\mathcal{Q}&#x27;</span>  against  <span class="math">\\mathsf{PC}_{\\mathfrak{s}}</span> . By assumption there exists a  <span class="math">\\mathsf{PC}_{\\mathfrak{s}}</span>  extractor  <span class="math">\\mathcal{E}_{\\mathcal{B}}</span>  against  <span class="math">\\mathcal{B}</span> . We use  <span class="math">\\mathcal{E}_{\\mathcal{B}}</span>  to construct an  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span>  extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  for  <span class="math">\\mathcal{A}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B(ck, rk, [ρj]i j=1):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">EA(pp, [ρj]i j=1):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1. Set pp := (ck, rk).</td>

            <td class="px-3 py-2 border-b border-gray-700">1. Parse pp as (ck, rk).</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2. Compute (c, d) ← A(pp, [ρj]i j=1).</td>

            <td class="px-3 py-2 border-b border-gray-700">2. Compute p ← EB(ck, rk, [ρj]i j=1).</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. Parse c as [[c_i, c_i']]i i=1.</td>

            <td class="px-3 py-2 border-b border-gray-700">3. Parse p as [[p_i, p_i']]i i=1.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4. Output [[c_i, c_i']]i i=1.</td>

            <td class="px-3 py-2 border-b border-gray-700">4. Output [p_i]i i=1.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Suppose for contradiction that the extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  fails with non-negligible probability for some choice of round bound  <span class="math">\\mathsf{r} \\in \\mathbb{N}</span> , efficient public-coin challenger  <span class="math">\\mathcal{C}</span> , efficient query sampler  <span class="math">\\mathcal{Q}</span> , and efficient adversary  <span class="math">\\mathcal{B} = (\\mathcal{B}_1, \\mathcal{B}_2)</span> . This can occur due to one of two reasons.</p>

    <p class="text-gray-300">(1) Extracted polynomial does not match evaluation: there exists an extracted polynomial whose claimed evaluation is incorrect. (2) Degree bounds are not satisfied: all extracted polynomials match their claimed evaluations, but there exists a polynomial whose degree differs from the claimed degree.</p>

    <p class="text-gray-300">If  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  fails with non-negligible probability, then one of these cases occurs with non-negligible probability. We analyze both cases, and argue that this cannot be.</p>

    <p class="text-gray-300">(1) Extracted polynomial does not match evaluation. Each  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span>  commitment  <span class="math">c_{i}</span>  in  <span class="math">[c_i]_{i\\in T}</span>  is a pair of  <span class="math">\\mathsf{PC}_{\\mathfrak{s}}</span>  commitments  <span class="math">(c_{i},c_{i}^{\\prime})</span> . Since  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span> . Check invokes  <span class="math">\\mathsf{PC}_{\\mathfrak{s}}</span> . Check,  <span class="math">[c_i]_{i\\in T}</span>  are accepted by  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span> . Check if and only if  <span class="math">[[c_i,c_i&#x27;]]_{i\\in T}</span>  are accepted by  <span class="math">\\mathsf{PC}_{\\mathfrak{s}}</span> . Check. Thus, if  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span> . Check accepts but the extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  fails with non-negligible probability, then we deduce that  <span class="math">\\mathsf{PC}_{\\mathfrak{s}}</span> . Check accepts but the extractor  <span class="math">\\mathcal{E}_{\\mathcal{B}}</span>  fails with non-negligible probability against a  <span class="math">\\mathsf{PC}_{\\mathfrak{s}}</span>  query sampler  <span class="math">\\mathcal{Q}&#x27;</span>  that obtains  <span class="math">Q</span>  from  <span class="math">\\mathcal{Q}</span>  and outputs  <span class="math">Q&#x27; := \\{(2i - 1,z),(2i,z) \\mid (i,z)\\in Q\\}</span> . This contradicts the fact that  <span class="math">\\mathsf{PC}_{\\mathfrak{s}}</span>  achieves extractability. Hence, we conclude that all extracted polynomials match their claimed evaluations with probability negligibly close to 1. (2) Degree bounds are not satisfied. We first recall how the extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  works: it invokes the  <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span>  extractor to obtain  <span class="math">2n</span>  polynomials  <span class="math">\\pmb {p}\\coloneqq [p_i,p_i&#x27;]_{i = 1}^n</span> , and outputs  <span class="math">[p_i]_{i = 1}^n</span> . The remaining polynomials  <span class="math">[p_i&#x27;]_{i = 1}^n</span></p>

    <p class="text-gray-300">are supposedly "shifted" versions of the output polynomials. It should be the case that for each  <span class="math">i \\in T</span>  it holds that  <span class="math">p_i&#x27;(X) = X^{D - d_i}p_i(X)</span> . To check that this condition is satisfied,  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span> . Check verifies that, for a point  <span class="math">z \\in \\mathbb{F}</span>  sampled by the admissible query sampler  <span class="math">\\mathcal{Q}</span> ,  <span class="math">v_i&#x27; := z^{D - d_i}p_i(z)</span>  is a valid evaluation for  <span class="math">p_i&#x27;</span> . The probability that this equation holds but  <span class="math">p_i&#x27;(X) \\neq X^{D - d_i}p_i(X)</span>  is negligibly small because  <span class="math">\\mathcal{Q}</span> , being admissible, samples  <span class="math">z</span>  from a super-polynomially-large subset of  <span class="math">\\mathbb{F}</span> .</p>

    <p class="text-gray-300">Theorem C.7. If  <span class="math">\\mathsf{PC}_{\\mathsf{s}}</span>  achieves hiding (Definition B.4) then  <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span>  achieves hiding (Definition 6.4 restricted to query sets  <span class="math">Q_{j}</span>  querying a subset of polynomials at the same point (i.e.,  <span class="math">Q_{j} = T_{j} \\times \\{z_{j}\\}</span>  for some  <span class="math">T_{j} \\subseteq [n]</span> , and  <span class="math">z_{j} \\in \\mathbb{F}</span> ).</p>

    <p class="text-gray-300">Proof. Below we construct a simulator  <span class="math">S_{\\mathfrak{m}}</span>  for  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span>  using a simulator  <span class="math">S_{\\mathfrak{s}}</span>  for  <span class="math">\\mathsf{PC}_{\\mathfrak{s}}</span>  as a subroutine.</p>

    <p class="text-gray-300">| Sm.Setup(1λ,D): 1. Compute (ck, rk, trap) ← Ss.Setup(1λ,D). 2. Output (pp := (ck, rk), trap). |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">| Sm.Commit(trap, d; ω): 1. Ignore the degrees d, and parse the randomness ω as [[ωi, ωi']]i=1. 2. Compute [[v_i, v_i']]i=1 := Ss.Commit(trap, 2k; [[ωi, ωi']]i=1). 3. For each i ∈ [k], assemble the pair ci := (v_i, v_i') of simulated commitments. 4. Output the simulated commitments c := [ci]i=1 for PCm. |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sm.Open(trap, p, v, d, Q,ξ; ω): 1. Parse p, v, d, ω as [pi]i=1, [vi]i=1, [di]i=1, [[ωi, ωi']]i=1. 2. Parse Q as T × {z} for some T ⊆ [n] and z ∈ F. 3. For each i ∈ T, set pi(X) := XD-di pi(X) and vi' := zD-di vi. 4. Construct PCs query set Q' := {(2i-1, z), (2i, z)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(i, z) ∈ Q}. 5. Output π ← Ss.Open(trap, [pi, pi']i=1, [vi, vi']i=1, Q',ξ; [[ωi, ωi']]i=1).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The simulator  <span class="math">S_{\\mathfrak{m}}</span>  is a simple wrapper around the simulator  <span class="math">S_{\\mathfrak{s}}</span> , and it is straightforward to see that if  <span class="math">S_{\\mathfrak{s}}</span>  simulates correctly for  <span class="math">\\mathsf{PC}_{\\mathfrak{s}}</span>  then  <span class="math">S_{\\mathfrak{m}}</span>  simulates correctly for  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span> .</p>

    <p class="text-gray-300">D Polynomial commitments that support different query locations</p>

    <p class="text-gray-300">We construct a polynomial commitment scheme <span class="math">\\mathsf{PC}</span> that supports different query locations–an instantiation of the primitive defined in Section 6.1. The query set <span class="math">Q</span> consists of tuples <span class="math">(i,z)\\in[n]\\times\\mathbb{F}_{q}</span> of polynomial indices and evaluation points. The construction is again a black-box extension of the polynomial commitment scheme <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span> considered in Appendix C which only supports a single query.</p>

    <h3 id="sec-94" class="text-xl font-semibold mt-8">D.1 Construction</h3>

    <p class="text-gray-300">PC.Setup, PC.Trim, and PC.Commit equal <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span>.Setup, <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span>.Trim, and <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span>.Commit in Appendix C, and so below we show how to construct PC.Open and PC.Check.</p>

    <p class="text-gray-300">Open. On input ck, univariate polynomials <span class="math">\\bm{p}</span> over the field <span class="math">\\mathbb{F}</span>, degree bounds <span class="math">\\bm{d}</span>, the query set <span class="math">Q</span>, opening challenge <span class="math">\\xi</span>, and randomness <span class="math">\\bm{\\omega}</span> that is the same one used in PC.Commit, PC.Open proceeds as follows. Suppose there are <span class="math">t</span> different evaluation points <span class="math">[z_{i}]_{i=1}^{t}</span> in the query set <span class="math">Q</span>. Divide <span class="math">\\bm{p}</span> into different (possibly overlapping) groups <span class="math">[\\bm{p}_{i}]_{i=1}^{t}</span>, where every polynomial in <span class="math">\\bm{p}_{i}</span> is evaluated at point <span class="math">z_{i}</span> according to <span class="math">Q</span>. Similarly divide degree bounds <span class="math">\\bm{d}</span> and <span class="math">\\bm{\\omega}</span> as <span class="math">[\\bm{d}_{i}]_{i=1}^{t}</span> and <span class="math">[\\bm{\\omega}_{i}]_{i=1}^{t}</span> so that <span class="math">\\deg(\\bm{p}_{i})\\leq\\bm{d}_{i}</span> and <span class="math">\\bm{\\omega}_{i}</span> is the randomness for the polynomial <span class="math">\\bm{p}_{i}</span>. For each group <span class="math">\\bm{p}_{i}</span>, obtain the evaluation proof <span class="math">\\pi_{i}:=\\mathsf{PC}_{\\mathsf{m}}</span>.Open(ck, <span class="math">\\bm{p}_{i},\\bm{d}_{i},z_{i},\\xi;\\bm{\\omega}_{i}</span>). Output all the proofs of evaluation <span class="math">[\\pi_{i}]_{i=1}^{t}</span>.</p>

    <p class="text-gray-300">Check. On input rk, commitments <span class="math">\\bm{c}</span>, degree bounds <span class="math">\\bm{d}</span>, the query set <span class="math">Q</span>, alleged evaluations <span class="math">\\bm{v}</span>, evaluation proof <span class="math">\\pi</span>, and opening challenge <span class="math">\\xi</span>, PC.Check proceeds as follows. Suppose there are <span class="math">t</span> different evaluation points <span class="math">[z_{i}]_{i=1}^{t}</span> in the query set <span class="math">Q</span>. Parse <span class="math">\\bm{c}</span>, <span class="math">\\bm{d}</span>, <span class="math">\\bm{v}</span> and <span class="math">\\pi</span> as <span class="math">[\\bm{c}_{i}]_{i=1}^{t}</span>, <span class="math">[\\bm{d}_{i}]_{i=1}^{t}</span>, <span class="math">[\\bm{v}_{i}]_{i=1}^{t}</span> and <span class="math">[\\pi_{i}]_{i=1}^{t}</span> so that <span class="math">\\bm{c}_{i}</span> are the commitments of polynomials <span class="math">\\bm{p}_{i}</span>, where <span class="math">\\deg(\\bm{p}_{i})\\leq\\bm{d}_{i}</span> and <span class="math">\\bm{p}_{i}(z_{i})</span> is supposed to be <span class="math">\\bm{v}_{i}</span>. For each <span class="math">i\\in[t]</span>, check that <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span>.Check(rk, <span class="math">\\bm{c}_{i},\\bm{d}_{i},z_{i},\\bm{v}_{i},\\pi_{i},\\xi)</span> accepts.</p>

    <p class="text-gray-300">Completeness. The completeness of PC follows directly from the completeness of <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span>.</p>

    <p class="text-gray-300">Efficiency. PC satisfies both efficiency properties defined in Definition 6.3:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Degree efficiency: The degree efficiency of PC follows directly from the degree efficiency of <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span>, because PC.Commit is the same as <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span>.Commit, and PC.Open invokes <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span>.Open a total of $t=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-95" class="text-xl font-semibold mt-8">D.2 Extractability</h3>

    <h6 id="sec-96" class="text-base font-medium mt-4">Theorem D.1.</h6>

    <p class="text-gray-300">If <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span> in Appendix C achieves extractability (Definition 6.2) then PC also achieves extractability (Definition 6.2).</p>

    <p class="text-gray-300">Proof. Suppose for contradiction that there exists a maximum degree bound <span class="math">D\\in\\mathbb{N}</span> and efficient adversary <span class="math">\\mathcal{A}</span> against PC such that for some choice of round bound <span class="math">\\mathsf{r}\\in\\mathbb{N}</span>, efficient public-coin challenger <span class="math">\\mathcal{C}</span>, efficient query sampler <span class="math">\\mathcal{Q}</span>, and efficient adversary <span class="math">\\mathcal{B}=(\\mathcal{B}_{1},\\mathcal{B}_{2})</span>, every efficient extractor <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> fails with non-negligible probability <span class="math">\\mu(\\lambda)</span>.</p>

    <p class="text-gray-300">Then, we show how to use these to break extractability for <span class="math">\\mathsf{PC}_{\\mathsf{m}}</span> by constructing adversary <span class="math">\\mathcal{A}^{\\prime}</span>, query sampler <span class="math">\\mathcal{Q}^{\\prime}</span>, and adversary <span class="math">\\mathcal{B}^{\\prime}</span> as follows. We define <span class="math">\\mathcal{A}^{\\prime}</span> to equal <span class="math">\\mathcal{A}</span>, and construct <span class="math">\\mathcal{Q}^{\\prime}</span> and <span class="math">\\mathcal{B}^{\\prime}</span> below.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">| Q'(pp, [ρj]j=1): |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">| 1. Obtain query set Q ← Q(pp, [ρj]j=1). |</p>

    <p class="text-gray-300">| 2. Parse Q as ∪j∈[t]Tj × {zj}, for some Tj ⊆ [n] and zj ∈ F, where each zj is distinct. |</p>

    <p class="text-gray-300">| 3. Uniformly sample k ∈ [t]. |</p>

    <p class="text-gray-300">| 4. Output Q' := Tk × {zk}. |</p>

    <p class="text-gray-300">| B1'(pp, [ρj]j=1, Q): |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Parse Q as {(i, z)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i ∈ [n]} for some z ∈ F.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 2. Obtain query set QPC ← Q(pp, [ρj]j=1). |</p>

    <p class="text-gray-300">| 3. Parse QPC as ∪j∈[t]Tj × {zj}, for some Tj ⊆ [n] and zj ∈ F, where each zj is distinct. |</p>

    <p class="text-gray-300">| 4. Check that for some k ∈ [t], Q = Qk. |</p>

    <p class="text-gray-300">| 5. Obtain (v, stPC) ← B1(pp, [ρj]j=1, QPC). |</p>

    <p class="text-gray-300">| 6. Parse v as [vi]i=1 similarly to above. |</p>

    <p class="text-gray-300">| 7. Output (vk, st := (stPC, k)). |</p>

    <p class="text-gray-300">| B2'(st,ξ): |</p>

    <p class="text-gray-300">| 1. Parse st as (stPC, k). |</p>

    <p class="text-gray-300">| 2. Obtain proof π ← B2(stPC,ξ). |</p>

    <p class="text-gray-300">| 3. Parse π as [πj]j=1. |</p>

    <p class="text-gray-300">| 4. Output πk. |</p>

    <p class="text-gray-300">Now, by assumption, there exists an extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}&#x27;}</span>  for  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span>  that succeeds in extracting against any choice of  <span class="math">\\mathcal{Q}&#x27;</span>  and  <span class="math">\\mathcal{B}&#x27;</span> . In particular, it succeeds against  <span class="math">\\mathcal{Q}&#x27;</span>  and  <span class="math">\\mathcal{B}&#x27;</span>  constructed above. Because the extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}} := \\mathcal{E}_{\\mathcal{A}&#x27;}</span>  fails only if  <span class="math">\\mathcal{E}_{\\mathcal{A}&#x27;}</span>  fails, we need only to analyze the probability with which this latter algorithm fails. We know that whenever  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  fails, PC.Check accepts, but there exists  <span class="math">k \\in [t]</span>  such that</p>

    <p class="text-gray-300"><span class="math">\\deg (\\pmb {p}_k)\\not\\leq \\pmb {d}_k\\quad \\lor \\quad \\pmb {v}_k\\neq \\pmb {p}_k(z_k).</span></p>

    <p class="text-gray-300">By construction of PC.Check, this means that the  <span class="math">k</span> -th invocation of  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span> . Check succeeds, but the corresponding polynomials are either of incorrect degree or have incorrect claimed evaluations. Because  <span class="math">\\mathcal{Q}&#x27;</span>  selects this index  <span class="math">k</span>  with probability  <span class="math">1 / t</span> ,  <span class="math">\\mathcal{A}&#x27;</span>  and  <span class="math">\\mathcal{B}&#x27;</span>  break extractability of  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span>  with non-negligible probability  <span class="math">\\mu(\\lambda) / t</span> , thus contradicting our assumption.</p>

    <p class="text-gray-300">Theorem D.2. If  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span>  in Appendix C achieves hiding (Definition 6.4) then PC also achieves hiding (Definition 6.4).</p>

    <p class="text-gray-300">Proof. We achieve this by constructing a simulator  <span class="math">S_{\\mathsf{PC}}</span>  for PC using the  <span class="math">\\mathsf{PC}_{\\mathfrak{m}}</span>  simulator  <span class="math">S_{\\mathfrak{m}}</span> .  <span class="math">S_{\\mathsf{PC}}</span> . Setup,  <span class="math">S_{\\mathsf{PC}}</span> . Trim, and  <span class="math">S_{\\mathsf{PC}}</span> . Commit are the same as  <span class="math">S_{\\mathfrak{m}}</span> . Setup,  <span class="math">S_{\\mathfrak{m}}</span> . Trim, and  <span class="math">S_{\\mathfrak{m}}</span> . Commit, and so we focus on constructing  <span class="math">S_{\\mathsf{PC}}</span> . Open.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}_{\\mathrm{PC}}</span>  .Open(trap,  <span class="math">\\pmb {p},\\pmb {v},\\pmb {d},Q_{i},\\xi_{i};\\omega)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">Q</span>  as  <span class="math">\\cup_{i\\in [t]}T_j\\times \\{z_i\\}</span> , for some  <span class="math">T_{i}\\subseteq [n]</span>  and  <span class="math">z_{i}\\in \\mathbb{F}</span> , where each  <span class="math">z_{i}</span>  is distinct.</li>

      <li>Divide  <span class="math">\\pmb{p}</span> ,  <span class="math">\\pmb{d}</span> , and  <span class="math">\\pmb{\\omega}</span>  into  <span class="math">[\\pmb{p}_i]_{i=1}^t</span> ,  <span class="math">[\\pmb{d}_i]_{i=1}^t</span> , and  <span class="math">[\\pmb{\\omega}_i]_{i=1}^t</span>  so that  <span class="math">\\pmb{p}_i = [p_j]_{j \\in T_i}</span> ,  <span class="math">\\pmb{d}_i = [d_j]_{j \\in T_i}</span> , and  <span class="math">\\pmb{\\omega}_i = [\\omega_j]_{j \\in T_i}</span> .</li>

      <li>For each  <span class="math">i</span>  in  <span class="math">1, \\ldots, t</span> , compute evaluation proof  <span class="math">\\pi_i \\gets S_{\\mathfrak{m}}</span> . Open(trap,  <span class="math">\\pmb{p}_i, \\pmb{v}_i, Q_i := T_i \\times \\{z_i\\}, \\xi; \\omega_i</span> ).</li>

      <li>Output  <span class="math">\\pi_i\\coloneqq [\\pi_i]_{i = 1}^t</span></li>

    </ol>

    <p class="text-gray-300">The simulator  <span class="math">S_{\\mathrm{PC}}</span>  is a simple wrapper around the simulator  <span class="math">S_{\\mathrm{m}}</span> . Since  <span class="math">S_{\\mathrm{m}}</span>  achieves perfect hiding, so does  <span class="math">S_{\\mathrm{PC}}</span>  regardless of  <span class="math">\\tau</span> , the number of query sets  <span class="math">Q_{i}</span> , or  <span class="math">t_i</span> , the respective number of distinct points in each query set.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}(\\mathbb{F},H,K,A,B,C,x,w)</span> <span class="math">\\mathcal{V}^{\\mathrm{row}_{\\{A^{<em>},B^{</em>},C^{<em>}\\}},\\mathrm{col}_{\\{A^{</em>},B^{<em>},C^{</em>}\\}},\\mathrm{val}_{\\{A^{<em>},B^{</em>},C^{*}\\}}(\\mathbb{F},H,K,x)</span></p>

    <p class="text-gray-300"><span class="math">z\\coloneqq (x,w),z_{A}\\coloneqq Az,z_{B}\\coloneqq Bz,z_{C}\\coloneqq Cz</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sample  $\\hat{w} (X)\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{b}}[X]<span class="math">  and  </span>\\hat{z}_A(X),\\hat{z}_B(X),\\hat{z}_C(X)\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{b}}[X]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">find  <span class="math">h_0(X)</span>  s.t.  <span class="math">\\hat{z}_A(X)\\hat{z}_B(X) - \\hat{z}_C(X) = h_0(X)v_H(X)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sample  $s(X)\\in \\mathbb{F}^{&lt; 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{b} - 1}[X]<span class="math">  and compute sum  </span>\\sigma_{1}\\coloneqq \\sum_{\\kappa \\in H}s(\\kappa)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sigma_{1}\\in \\mathbb{F},\\hat{w}\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{b}}[X],\\hat{z}_{A},\\hat{z}_{B},\\hat{z}_{C}\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{b}}[X],$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$h_0\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2\\mathsf{b} - 1}[X],s\\in \\mathbb{F}^{&lt; 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{b} - 1}[X]<span class="math"> </span>\\eta_A,\\eta_B,\\eta_C\\gets \\mathbb{F}<span class="math"> </span>\\alpha \\leftarrow \\mathbb{F}\\setminus H$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\alpha ,\\eta_{A},\\eta_{B},\\eta_{C}\\in \\mathbb{F}</span></p>

    <p class="text-gray-300">compute  <span class="math">t(X)\\coloneqq \\sum_{M}\\eta_{M}r_{M}(\\alpha ,X)</span></p>

    <p class="text-gray-300">sumcheck for  <span class="math">s(X) + r(\\alpha, X)(\\sum_{M} \\eta_{M} z_{M}^{-}(X)) - t(X) \\hat{z}(X)</span>  over  <span class="math">H</span></p>

    <p class="text-gray-300">find  <span class="math">g_{1}(X)</span>  and  <span class="math">h_1(X)</span>  s.t.</p>

    <p class="text-gray-300"><span class="math">s(X) + r(\\alpha ,X)(\\sum_{M}\\eta_{M}z_{M}^{-}(X)) - t(X)\\hat{z} (X)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$= h_{1}(X)v_{H}(X) + Xg_{1}(X) + \\sigma_{1} /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$t\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}[X],g_1\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}[X],h_1\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{b} - 1}[X]\\longrightarrow$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\beta_{1}\\gets \\mathbb{F}\\setminus H</span></p>

    <p class="text-gray-300"><span class="math">\\begin{array}{r}\\longleftarrow \\beta_1\\in \\mathbb{F}\\end{array}</span></p>

    <p class="text-gray-300">sumcheck for  <span class="math">\\sum_{M\\in \\{A,B,C\\}}\\eta_M\\frac{v_H(\\beta_1)v_H(\\alpha)\\hat{\\mathrm{val}}_{M^<em>}(X)}{(\\beta_1 - \\mathrm{row}_{M^</em>}(X))(\\alpha - \\mathrm{col}_{M^*}(X))}</span>  over  <span class="math">K</span></p>

    <p class="text-gray-300">find  <span class="math">g_{2}(X)</span>  and  <span class="math">h_2(X)</span>  s.t.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$h_2(X)v_K(X) = a(X) - b(X)(Xg_2(X) + t(\\beta_1) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$g_{2}\\in \\mathbb{F}^{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}[X],h_{2}\\in \\mathbb{F}^{&lt; 6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 6}[X]<span class="math"> </span>\\beta_{2}\\gets \\mathbb{F}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$h_2(\\beta_2)v_K(\\beta_2)\\stackrel {?}{=}a(\\beta_2) - b(\\beta_2)(\\beta_2g_2(\\beta_2) + t(\\beta_1) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The polynomials  <span class="math">a(X), b(X)</span>  are defined as follows:</p>

    <p class="text-gray-300"><span class="math">a(X)\\coloneqq \\sum_{M\\in \\{A,B,C\\}}\\eta_{M}v_{H}(\\beta_{1})v_{H}(\\alpha)\\hat{\\mathsf{val}}_{M^{<em>}}(X)\\prod_{N\\in \\{A,B,C\\} \\setminus \\{M\\}}(\\beta_{1} - \\mathsf{row}_{N^{</em>}}(X))(\\alpha -\\mathsf{col}_{N^{*}}(X))</span></p>

    <p class="text-gray-300"><span class="math">b(X)\\coloneqq \\prod_{M\\in \\{A,B,C\\}}(\\beta_1 - \\mathsf{row}_{M^<em>}(X))(\\alpha -\\mathsf{col}_{M^</em>}(X))</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$s(\\beta_1) + r(\\alpha, \\beta_1)(\\sum_M \\eta_M z_M^-(\\beta_1)) - t(\\beta_1) \\hat{z}(\\beta_1) \\stackrel{?}{=} h_1(\\beta_1)v_H(\\beta_1) + \\beta_1 g_1(\\beta_1) + \\sigma_1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\hat{z}_A(\\beta_1)\\hat{z}_B(\\beta_1) - \\hat{z}_C(\\beta_1)\\stackrel {?}{=}h_0(\\beta_1)v_H(\\beta_1)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 7: An AHP for R1CS that improves upon that described in Fig. 5, by incorporating ideas from [COS20]. Above we use notation from [COS20, Claim 6.7]: for any matrix  <span class="math">M \\in \\mathbb{F}^{H \\times H}</span> ,  <span class="math">M^<em> \\in F^{H \\times H}</span>  is the matrix given by  <span class="math">M_{a,b}^</em> := M_{b,a} \\cdot u_H(b,b)</span>  for all  <span class="math">a, b \\in H</span> ; note that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^* \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . The main idea behind the improvement is that  </span>r_M(X,Y) \\equiv M^*(Y,X)$ . See [COS20] for more details.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Acknowledgments</p>

    <p class="text-gray-300">This research was supported by: an Engineering and Physical Sciences Research Council grant (EP/N028104/1), a Google Faculty Award, the RISELab at UC Berkeley, and donations from the Ethereum Foundation and the Interchain Foundation. The authors thank Dev Ojha and Nicholas Spooner for identifying and helping to fix an error in a prior version of our AHP for the lincheck problem (Fig. 4), and also Kobi Gurkan for pointing out an error in our analysis of Cheon’s attack in Appendix A.5.</p>

    <h2 id="sec-99" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Abd+19] B. Abdolmaleki, K. Baghery, H. Lipmaa, J. Siim, and M. Zajac. “UC-Secure CRS Generation for SNARKs”. In: Proceedings of the 11th International Conference on Cryptology in Africa. AFRICACRYPT ’19. 2019, pp. 99–117.</li>

      <li>[Ame+17] S. Ames, C. Hazay, Y. Ishai, and M. Venkitasubramaniam. “Ligero: Lightweight Sublinear Arguments Without a Trusted Setup”. In: Proceedings of the 24th ACM Conference on Computer and Communications Security. CCS ’17. 2017, pp. 2087–2104.</li>

      <li>[Aro+98] S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. “Proof verification and the hardness of approximation problems”. In: Journal of the ACM 45.3 (1998). Preliminary version in FOCS ’92., pp. 501–555.</li>

      <li>[AS98] S. Arora and S. Safra. “Probabilistic checking of proofs: a new characterization of NP”. In: Journal of the ACM 45.1 (1998). Preliminary version in FOCS ’92., pp. 70–122.</li>

      <li>[Bab85] L. Babai. “Trading group theory for randomness”. In: Proceedings of the 17th Annual ACM Symposium on Theory of Computing. STOC ’85. 1985, pp. 421–429.</li>

      <li>[Bab+91] L. Babai, L. Fortnow, L. A. Levin, and M. Szegedy. “Checking computations in polylogarithmic time”. In: Proceedings of the 23rd Annual ACM Symposium on Theory of Computing. STOC ’91. 1991, pp. 21–32.</li>

      <li>[BB04] D. Boneh and X. Boyen. “Short Signatures Without Random Oracles”. In: Proceedings of the 23rd Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’04. 2004, pp. 56–73.</li>

      <li>[BCC88] G. Brassard, D. Chaum, and C. Crépeau. “Minimum disclosure proofs of knowledge”. In: Journal of Computer and System Sciences 37.2 (1988), pp. 156–189.</li>

      <li>[BCS16] E. Ben-Sasson, A. Chiesa, and N. Spooner. “Interactive Oracle Proofs”. In: Proceedings of the 14th Theory of Cryptography Conference. TCC ’16-B. 2016, pp. 31–60.</li>

      <li>[Ben+14a] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. “Scalable Zero Knowledge via Cycles of Elliptic Curves”. In: Proceedings of the 34th Annual International Cryptology Conference. CRYPTO ’14. Extended version at http://eprint.iacr.org/2014/595. 2014, pp. 276–294.</li>

      <li>[Ben+14b] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. “Succinct Non-Interactive Zero Knowledge for a von Neumann Architecture”. In: Proceedings of the 23rd USENIX Security Symposium. USENIX Security ’14. Extended version at http://eprint.iacr.org/2013/879. 2014, pp. 781–796.</li>

      <li>[Ben+15] E. Ben-Sasson, A. Chiesa, M. Green, E. Tromer, and M. Virza. “Secure Sampling of Public Parameters for Succinct Zero Knowledge Proofs”. In: Proceedings of the 36th IEEE Symposium on Security and Privacy. S&P ’15. 2015, pp. 287–304.</li>

      <li>[Ben+16] E. Ben-Sasson, A. Chiesa, A. Gabizon, and M. Virza. “Quasilinear-Size Zero Knowledge from Linear-Algebraic PCPs”. In: Proceedings of the 13th Theory of Cryptography Conference. TCC ’16-A. 2016, pp. 33–64.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Ben+17a] E. Ben-Sasson, A. Chiesa, A. Gabizon, M. Riabzev, and N. Spooner. “Interactive Oracle Proofs with Constant Rate and Query Complexity”. In: Proceedings of the 44th International Colloquium on Automata, Languages and Programming. ICALP ’17. 2017, 40:1–40:15.</li>

      <li>[Ben+17b] E. Ben-Sasson et al. “Computational integrity with a public random string from quasi-linear PCPs”. In: Proceedings of the 36th Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’17. 2017, pp. 551–579.</li>

      <li>[Ben+19a] E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev. “Scalable Zero Knowledge with No Trusted Setup”. In: Proceedings of the 39th Annual International Cryptology Conference. CRYPTO ’19. 2019, pp. 733–764.</li>

      <li>[Ben+19b] E. Ben-Sasson, A. Chiesa, L. Goldberg, T. Gur, M. Riabzev, and N. Spooner. “Linear-Size Constant-Query IOPs for Delegating Computation”. In: Proceedings of the 17th Theory of Cryptography Conference. TCC ’19. 2019.</li>

      <li>[Ben+19c] E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P. Ward. “Aurora: Transparent Succinct Arguments for R1CS”. In: Proceedings of the 38th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’19. Full version available at https://eprint.iacr.org/2018/828. 2019, pp. 103–128.</li>

      <li>[BG04] D. R. L. Brown and R. P. Gallant. The Static Diffie–Hellman Problem. Cryptology ePrint Archive, Report 2004/306. 2004.</li>

      <li>[BG12] S. Bayer and J. Groth. “Efficient Zero-Knowledge Argument for Correctness of a Shuffle”. In: Proceedings of the 31st Annual International Conference on Theory and Applications of Cryptographic Techniques. EUROCRYPT ’12. 2012, pp. 263–280.</li>

      <li>[BGG17] S. Bowe, A. Gabizon, and M. Green. A multi-party protocol for constructing the public parameters of the Pinocchio zk-SNARK. Cryptology ePrint Archive, Report 2017/602. 2017.</li>

      <li>[BGM17] S. Bowe, A. Gabizon, and I. Miers. Scalable Multi-party Computation for zk-SNARK Parameters in the Random Beacon Model. Cryptology ePrint Archive, Report 2017/1050. 2017.</li>

      <li>[Bit+13] N. Bitansky, A. Chiesa, Y. Ishai, R. Ostrovsky, and O. Paneth. “Succinct Non-Interactive Arguments via Linear Interactive Proofs”. In: Proceedings of the 10th Theory of Cryptography Conference. TCC ’13. 2013, pp. 315–333.</li>

      <li>[Bit+16] N. Bitansky, R. Canetti, O. Paneth, and A. Rosen. “On the Existence of Extractable One-Way Functions”. In: SIAM Journal on Computing 45.5 (2016). Preliminary version appeared in STOC ’14., pp. 1910–1952.</li>

      <li>[Bon+17] D. Boneh, Y. Ishai, A. Sahai, and D. J. Wu. “Lattice-Based SNARGs and Their Application to More Efficient Obfuscation”. In: Proceedings of the 36th Annual International Conference on Theory and Applications of Cryptographic Techniques. EUROCRYPT ’17. 2017, pp. 247–277.</li>

      <li>[Bon+18] D. Boneh, Y. Ishai, A. Sahai, and D. J. Wu. “Quasi-Optimal SNARGs via Linear Multi-Prover Interactive Proofs”. In: Proceedings of the 37th Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’18. 2018, pp. 222–255.</li>

      <li>[Boo+16] J. Bootle, A. Cerulli, P. Chaidos, J. Groth, and C. Petit. “Efficient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting”. In: Proceedings of the 35th Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’16. 2016, pp. 327–357.</li>

      <li>[BP15] E. Boyle and R. Pass. “Limits of Extractability Assumptions with Distributional Auxiliary Input”. In: Proceedings of the 21st International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’15. 2015, pp. 236–261.</li>

      <li>[BS08] E. Ben-Sasson and M. Sudan. “Short PCPs with Polylog Query Complexity”. In: SIAM Journal on Computing 38.2 (2008). Preliminary version appeared in STOC ’05., pp. 551–607.</li>

    </ul>

    <p class="text-gray-300">[Bün+18] B. Bünz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell. “Bulletproofs: Short Proofs for Confidential Transactions and More”. In: <em>Proceedings of the 39th IEEE Symposium on Security and Privacy</em>. S&amp;P ’18. 2018, pp. 315–334.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CD98] R. Cramer and I. Damgård. “Zero-Knowledge Proofs for Finite Field Arithmetic; or: Can Zero-Knowledge be for Free?” In: <em>Proceedings of the 18th Annual International Cryptology Conference</em>. CRYPTO ’98. 1998, pp. 424–441.</li>

      <li>[CFS17] A. Chiesa, M. A. Forbes, and N. Spooner. <em>A Zero Knowledge Sumcheck and its Applications</em>. Cryptology ePrint Archive, Report 2017/305. 2017.</li>

      <li>[Che10] J. H. Cheon. “Discrete Logarithm Problems with Auxiliary Inputs”. In: <em>Journal of Cryptology</em> 23.3 (2010), pp. 457–476.</li>

      <li>[COS20] A. Chiesa, D. Ojha, and N. Spooner. “Fractal: Post-Quantum and Transparent Recursive Proofs from Holography”. In: <em>Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques</em>. EUROCRYPT ’20. 2020.</li>

      <li>[Dan+14] G. Danezis, C. Fournet, J. Groth, and M. Kohlweiss. “Square Span Programs with Applications to Succinct NIZK Arguments”. In: <em>Proceedings of the 20th International Conference on the Theory and Application of Cryptology and Information Security</em>. ASIACRYPT ’14. 2014, pp. 532–550.</li>

      <li>[Den02] A. W. Dent. “Adapting the Weaknesses of the Random Oracle Model to the Generic Group Model”. In: <em>Proceedings of the 8th International Conference on the Theory and Application of Cryptology and Information Security</em>. ASIACRYPT ’02. 2002, pp. 100–109.</li>

      <li>[FKL18] G. Fuchsbauer, E. Kiltz, and J. Loss. “The Algebraic Group Model and its Applications”. In: <em>Proceedings of the 38th Annual International Cryptology Conference</em>. CRYPTO ’18. 2018, pp. 33–62.</li>

      <li>[FS86] A. Fiat and A. Shamir. “How to prove yourself: practical solutions to identification and signature problems”. In: <em>Proceedings of the 6th Annual International Cryptology Conference</em>. CRYPTO ’86. 1986, pp. 186–194.</li>

      <li>[Gab19] A. Gabizon. <em>Improved prover efficiency and SRS size in a Sonic-like system</em>. Cryptology ePrint Archive, Report 2019/601. 2019.</li>

      <li>[Gen+13] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. “Quadratic Span Programs and Succinct NIZKs without PCPs”. In: <em>Proceedings of the 32nd Annual International Conference on Theory and Application of Cryptographic Techniques</em>. EUROCRYPT ’13. 2013, pp. 626–645.</li>

      <li>[GKR15] S. Goldwasser, Y. T. Kalai, and G. N. Rothblum. “Delegating Computation: Interactive Proofs for Muggles”. In: <em>Journal of the ACM</em> 62.4 (2015), 27:1–27:64.</li>

      <li>[GMR89] S. Goldwasser, S. Micali, and C. Rackoff. “The knowledge complexity of interactive proof systems”. In: <em>SIAM Journal on Computing</em> 18.1 (1989). Preliminary version appeared in STOC ’85., pp. 186–208.</li>

      <li>[Gro10] J. Groth. “Short Pairing-Based Non-interactive Zero-Knowledge Arguments”. In: <em>Proceedings of the 16th International Conference on the Theory and Application of Cryptology and Information Security</em>. ASIACRYPT ’10. 2010, pp. 321–340.</li>

      <li>[Gro16] J. Groth. “On the Size of Pairing-Based Non-interactive Arguments”. In: <em>Proceedings of the 35th Annual International Conference on Theory and Applications of Cryptographic Techniques</em>. EUROCRYPT ’16. 2016, pp. 305–326.</li>

      <li>[Gro+18] J. Groth, M. Kohlweiss, M. Maller, S. Meiklejohn, and I. Miers. “Updatable and Universal Common Reference Strings with Applications to zk-SNARKs”. In: <em>Proceedings of the 38th Annual International Cryptology Conference</em>. CRYPTO ’18. 2018, pp. 698–728.</li>

      <li>[GWC19] A. Gabizon, Z. J. Williamson, and O. Ciobotaru. <em>PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge</em>. Cryptology ePrint Archive, Report 2019/953. 2019.</li>

    </ul>

    <p class="text-gray-300">[Kil92] J. Kilian. “A note on efficient zero-knowledge proofs and arguments”. In: Proceedings of the 24th Annual ACM Symposium on Theory of Computing. STOC ’92. 1992, pp. 723–732.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[KKM07] S. Kozaki, T. Kutsuma, and K. Matsuo. “Remarks on Cheon’s Algorithms for Pairing-Related Problems”. In: Proceedings of the 1st International Conference on Pairing-Based Cryptography. Pairing ’07. 2007, pp. 302–316.</li>

      <li>[KZG10] A. Kate, G. M. Zaverucha, and I. Goldberg. “Constant-Size Commitments to Polynomials and Their Applications”. In: Proceedings of the 16th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’10. 2010, pp. 177–194.</li>

      <li>[Lip12] H. Lipmaa. “Progression-Free Sets and Sublinear Pairing-Based Non-Interactive Zero-Knowledge Arguments”. In: Proceedings of the 9th Theory of Cryptography Conference on Theory of Cryptography. TCC ’12. 2012, pp. 169–189.</li>

      <li>[Mal+19] M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn. “Sonic: Zero-Knowledge SNARKs from Linear-Size Universal and Updateable Structured Reference Strings”. In: Proceedings of the 26th ACM Conference on Computer and Communications Security. CCS ’19. 2019, pp. 2111–2128.</li>

      <li>[Mau05] U. M. Maurer. “Abstract Models of Computation in Cryptography”. In: Proceedings of the 10th IMA International Conference on Cryptography and Coding. IMA ’05. 2005, pp. 1–12.</li>

      <li>[PST13] C. Papamanthou, E. Shi, and R. Tamassia. “Signatures of Correct Computation”. In: Proceedings of the 10th Theory of Cryptography Conference. TCC ’13. 2013, pp. 222–242.</li>

      <li>[PV05] P. Paillier and D. Vergnaud. “Discrete-Log-Based Signatures May Not Be Equivalent to Discrete Log”. In: Proceedings of the 11th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’05. 2005, pp. 1–20.</li>

      <li>[RRR16] O. Reingold, R. Rothblum, and G. Rothblum. “Constant-Round Interactive Proofs for Delegating Computation”. In: Proceedings of the 48th ACM Symposium on the Theory of Computing. STOC ’16. 2016, pp. 49–62.</li>

      <li>[Set19] S. Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. Cryptology ePrint Archive, Report 2019/550. 2019.</li>

      <li>[Sho97] V. Shoup. “Lower bounds for discrete logarithms and related problems”. In: Proceedings of the 16th International Conference on the Theory and Application of Cryptographic Techniques. EUROCRYPT ’97. 1997, pp. 256–266.</li>

      <li>[Wah+18] R. S. Wahby, I. Tzialla, A. Shelat, J. Thaler, and M. Walfish. “Doubly-Efficient zkSNARKs Without Trusted Setup”. In: Proceedings of the 39th IEEE Symposium on Security and Privacy. S&P ’18. 2018, pp. 926–943.</li>

      <li>[Xie+19] T. Xie, J. Zhang, Y. Zhang, C. Papamanthou, and D. Song. “Libra: Succinct Zero-Knowledge Proofs with Optimal Prover Computation”. In: Proceedings of the 39th Annual International Cryptology Conference. CRYPTO ’19. 2019, pp. 733–764.</li>

      <li>[Zcash] Zcash. https://z.cash/. 2014.</li>

      <li>[ZcashMPC] The Zcash Ceremony. https://z.cash/blog/the-design-of-the-ceremony.html. 2016.</li>

      <li>[Zha+17a] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou. A Zero-Knowledge Version of vSQL. Cryptology ePrint Archive, Report 2017/1146. 2017.</li>

      <li>[Zha+17b] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou. “vSQL: Verifying Arbitrary SQL Queries over Dynamic Outsourced Databases”. In: Proceedings of the 38th IEEE Symposium on Security and Privacy. S&P ’17. 2017, pp. 863–880.</li>

      <li>[Zha+18] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou. “vRAM: Faster Verifiable RAM with Program-Independent Preprocessing”. In: Proceedings of the 39th IEEE Symposium on Security and Privacy. S&P ’18. 2018, pp. 908–925.</li>

    </ul>`;
---

<BaseLayout title="Marlin: Preprocessing zkSNARKs with Universal and Updatable ... (2019/1047)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/1047
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
