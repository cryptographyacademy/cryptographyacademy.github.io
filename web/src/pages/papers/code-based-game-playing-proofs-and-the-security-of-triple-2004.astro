---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/331';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Code-Based Game-Playing Proofs and the Security of Triple Encryption';
const AUTHORS_HTML = 'Mihir Bellare, Phillip Rogaway';

const CONTENT = `    <p class="text-gray-300">The proceedings version of this papers, entitled <em>The Security of Triple Encryption and a Framework for Code-Based Game-Playing Proofs</em>, appears in <em>Advances in Cryptology – Eurocrypt 2006</em>, LNCS vol. 4004, Springer, pp. 409–426, 2006. This is the full version of the paper.</p>

    <p class="text-gray-300">MIHIR BELLAR\\* PHILLIP ROGAWAY†</p>

    <p class="text-gray-300">November 27, 2008</p>

    <p class="text-gray-300">(Draft 3.0)</p>

    <h2 id="sec-2" class="text-2xl font-bold">Abstract</h2>

    <p class="text-gray-300">The game-playing technique is a powerful tool for analyzing cryptographic constructions. We illustrate this by using games as the central tool for proving security of three-key triple-encryption, a long-standing open problem. Our result, which is in the ideal-cipher model, demonstrates that for DES parameters (56-bit keys and 64-bit plaintexts) an adversary's maximal advantage is small until it asks about <span class="math">2^{78}</span> queries. Beyond this application, we develop the foundations for game playing, formalizing a general framework for game-playing proofs and discussing techniques used within such proofs. To further exercise the game-playing framework we show how to use games to get simple proofs for the PRP/PRF Switching Lemma, the security of the basic CBC MAC, and the chosen-plaintext-attack security of OAEP.</p>

    <p class="text-gray-300"><strong>Keywords</strong>: Cryptographic analysis techniques, games, provable security, triple encryption.</p>

    <p class="text-gray-300">\\*Department of Computer Science &amp; Engineering, University of California at San Diego, 9500 Gilman Drive, La Jolla, California 92093 USA. E-mail: mihir@cs.ucsd.edu WWW: www.cse.ucsd.edu/users/mihir/</p>

    <p class="text-gray-300">†Department of Computer Science, University of California at Davis, Davis, California, 95616, USA; and Department of Computer Science, Faculty of Science, Chiang Mai University, Chiang Mai 50200, Thailand. E-mail: rogaway@cs.ucdavis.edu WWW: www.cs.ucdavis.edu/~rogaway/</p>

    <p class="text-gray-300">1 Introduction 3 2 The PRP/PRF Switching Lemma 7 3 The Game-Playing Framework 9 4 The Security of Three-Key Triple-Encryption 14 4.1 Definitions 14 4.2 Results 14 4.3 Reduction to simplified adversary 15 4.4 Pseudorandomness of three correlated permutations 17 4.5 The improbability of forming a 3-chain 18 4.6 Putting together the pieces to conclude Theorem 4 18 4.7 Proof of Lemma 6 19 4.8 Proof of Lemma 7 23 5 Elementary Proof for the CBC MAC 25 6 A Game-Based Proof for OAEP 28 7 Game-Rewriting Techniques 32 7.1 Game chains 32 7.2 Basic techniques 33 7.3 Coin fixing 34 7.4 Lazy sampling 35 Acknowledgments 37 References 37 A Fixing the PRP/PRF Switching Lemma Without Games 39 B An Example Programming Language for Games 40</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Foundations and applications. The game-playing technique has become a popular approach for doing proofs in cryptography. We will explain the method shortly. In this paper we take the initial steps in developing a theory of game-playing proofs. We believe that such a theory will prove beneficial for our field. Then we demonstrate the utility of game-playing by providing examples of the technique, the most striking of which is the first proof that triple-encryption (using three independent keys) is far more secure than single or double encryption. The result, which is in the ideal-cipher model, is the first to prove that the cascade of blockciphers can markedly improve security. Other examples that we work out with games include the PRP/PRF Switching Lemma, the PRF-security of the CBC MAC, and the chosen-plaintext-attack security for OAEP.</p>

    <p class="text-gray-300">Why games? There are several reasons why we take a fresh look at the game-playing technique. First, the method is widely applicable, easily employed, and provides a unifying structure for diverse proofs. Games can be used in the standard model, the random-oracle model, the ideal-blockcipher model, and more; in the symmetric setting, the public-key setting, and further trust models; for simple schemes (eg, justifying the Carter-Wegman MAC) and complex protocols (eg, proving the correctness of a key-distribution protocol).</p>

    <p class="text-gray-300">Second, the game-playing technique can lead to significant new results. We demonstrate this by developing a game-based proof for three-key triple encryption. Proving security for triple encryption is a well-known problem, but technical difficulties have always frustrated attempts at a solution.</p>

    <p class="text-gray-300">Finally, we believe that the game-playing approach can lead to proofs that are less error-prone and more easily verifiable, even mechanically verifiable, than proofs grounded solely in more conventional probabilistic language. In our opinion, many proofs in cryptography have become essentially unverifiable. Our field may be approaching a crisis of rigor. While game-playing is not a panacea to this problem (which has at its core a significant cultural element), game-playing may play a role in the answer.</p>

    <p class="text-gray-300">The cascade construction. The security of the cascade construction, where two or more independently keyed blockciphers are composed with one another, is a nearly 30-year-old problem <em>[19, 36]</em>. Even and Goldreich refer to it as a “critical question” in cryptography <em>[21, p. 109]</em>. They showed that the cascade of ciphers is at least as strong as the <em>weakest</em> cipher in the chain <em>[21]</em>, while Maurer and Massey showed that, in a weaker attack model, it is at least as strong as the <em>first</em> cipher in the chain. We know that double encryption (the two-stage cascade) can’t strengthen security much, due to the classic meet-in-the-middle attack <em>[19]</em>, although Aiello, Bellare, Di Creczenzo, and Venkatesan show that the “shape” of the security curve is slightly improved <em>[3]</em>. This means that triple encryption (the three-stage cascade) is the shortest potentially “good” cascade. And, indeed, triple DES is the cascade that is widely standardized and used <em>[38]</em>.</p>

    <p class="text-gray-300">Triple encryption “works.” In this paper we prove that triple-encryption vastly improves security over single or double encryption. Given a blockcipher <span class="math">E\\colon\\{0,1\\}^{k}\\times\\{0,1\\}^{n}\\to\\{0,1\\}^{n}</span> with inverse <span class="math">D</span> we consider <span class="math">\\mathsf{Cascade}_{E}^{\\mathsf{eee}}(K_{0}K_{1}K_{2},\\ X)=E_{K_{2}}(E_{K_{1}}(E_{K_{0}}(X)))</span> and <span class="math">\\mathsf{Cascade}_{E}^{\\mathsf{ede}}(K_{0}K_{1}K_{2},\\ X)=E_{K_{2}}(D_{K_{1}}(E_{K_{0}}(X)))</span>. Our results are the same for both versions of triple encryption. Following <em>[22, 32, 44]</em>, we model <span class="math">E</span> as a family of random permutations, one for each key, and we provide the adversary with oracle access to the blockcipher <span class="math">E(\\cdot,\\cdot)</span> and its inverse <span class="math">E^{-1}(\\cdot,\\cdot)</span> Given such oracles, the adversary is asked to distinguish between (a) <span class="math">\\mathsf{Cascade}_{E}^{\\mathsf{eee}}(K_{0}K_{1}K_{2},\\ \\cdot\\,)</span> and its inverse, for a random key <span class="math">K_{0}K_{1}K_{2}</span>, and (b) a random permutation on <span class="math">n</span> bits and its inverse. We show that the adversary’s advantage in making this determination, <span class="math">\\mathbf{Adv}_{k,n}^{\\mathsf{eee}}(q)</span>, remains small until it asks about <span class="math">q=2^{k+0.5\\min\\{k,n\\}}</span> queries (the actual expression is more complex). The bound we get is</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Upper bound on adversarial advantage (proven security) verses  <span class="math">\\log_2q</span>  (where  <span class="math">q =</span>  number of queries) for the cascade construction, assuming key length  <span class="math">k = 56</span>  and block length  <span class="math">n = 64</span> . Single encryption is the leftmost curve, double encryption is the middle curve [3], and triple encryption in the rightmost curve, as given by Theorem 4.</p>

    <p class="text-gray-300">plotted as the rightmost curve of Figure 1 for DES parameters  <span class="math">k = 56</span>  and  <span class="math">n = 64</span> . In this case an adversary must ask more than  <span class="math">2^{77.79}</span>  queries to get advantage 0.5. Also plotted are the security curves for single and double encryption, where the adversary must ask  <span class="math">2^{55}</span>  and  <span class="math">2^{55.5}</span>  queries to get advantage 0.5. For a blockcipher with  <span class="math">k = n = 64</span> , the adversary must about  <span class="math">2^{89}</span>  queries to get advantage 0.5. As there are matching attacks and security bounds for single and double encryption, our result proves that, in the ideal-cipher model, triple encryption is more secure than single or double encryption.</p>

    <p class="text-gray-300">Our proof for triple-encryption uses game-playing in an integral way, first to recast the advantage we wish to bound to a simpler game, and later to analyze that game by investigating another one. Ultimately one is left with a game where conventional probabilistic reasoning (a special-purpose occupancy bound) can be applied. Game playing does not replace conventional probabilistic reasoning; it supplements it.</p>

    <p class="text-gray-300">As for the cascade of  <span class="math">\\ell \\geq 4</span>  blockciphers, the maximal advantage in our attack model is no worse than it is for triple encryption, so our result proves that cascade "works" (provides improved security over single and double encryption) for all  <span class="math">\\ell \\geq 3</span> . It is an open question if security actually increases with increasing  <span class="math">\\ell</span> .</p>

    <p class="text-gray-300">WHAT IS THE GAME-PLAYING TECHNIQUE? One complication in any discussion about game-playing proofs is that the term means different things to different people. To some, a game-playing proof in cryptography is any proof where one conceptualizes the adversary's interaction with its environment as a kind of game, the proof proceeding by stepwise refinement to that game. Viewed in this way, game-playing proofs have their origin in the earliest hybrid arguments, which began with Goldwasser and Micali [25] and Yao [50]. Bellare and Goldwasser provide an early example of an intricate proof of this flavor, demonstrating the security of a signature scheme that uses multiple cryptographic primitives [4]. In recent years Shoup has come to use such game-based proofs extensively [1, 16-18, 43, 45, 46, 48], as have other authors.</p>

    <p class="text-gray-300">We believe that game-playing proofs can be most effectively studied and systematized by imposing some discipline on the process and, in particular, regarding games as code. This viewpoint begins in 1994 with Kilian and Rogaway [32]. Code-based game-playing soon became the favored technique of Rogaway, who, along with coauthors, used it in many subsequent papers [6, 10, 12-14, 27, 28, 40-42]. Code-based game-playing typically works like this. Suppose you wish to upper bound the advantage of an adversary  <span class="math">A</span>  in attacking some cryptographic construction. This is the difference between the probability that  <span class="math">A</span>  outputs 1 in each of two different "worlds." First, write some code—a game—that captures the behavior of world 0. The code initializes variables, inter</p>

    <p class="text-gray-300">acts with the adversary, and then runs some more. Then write another piece of code—a second game—that captures the behavior of world 1. Arrange that games 0 and 1 are <em>syntactically identical</em> apart from statements that follow the setting of a flag <em>bad</em> to <em>true</em>. Now invoke the “fundamental lemma of game playing” (which we formalize and prove in this paper) to say that, in this setup, the adversary’s advantage is upper-bounded by the probability that <em>bad</em> gets set (in either game). Next, choose one of the two games and slowly transform it, modifying it in ways that increase or leave unchanged the probability that <em>bad</em> gets set, or decrease the probability that <em>bad</em> gets set by a bounded amount. In this way you produce a <em>chain</em> of games, ending at some <em>terminal</em> game. Bound the probability that <em>bad</em> gets set in the terminal game using conventional (not game-based) techniques.</p>

    <p class="text-gray-300">Formalizing the foundations. In our treatment games are code and not abstract environments; as we develop it, game-playing centers around making disciplined transformations to code. The code can be written in pseudocode or a formalized programming language <span class="math">\\mathcal{L}</span>. We will describe a sample programming language for writing games, using it (apart from some “syntactic sugar”) in our examples.</p>

    <p class="text-gray-300">Under our framework, a game <span class="math">G</span> is a program that is <em>run</em> with an adversary <span class="math">A</span>, which is also a program (look ahead to Figure 3). The adversary calls out to procedures, called <em>oracles</em>, specified by the game. We define what it means for two games to be identical-until-<em>bad</em>, where <em>bad</em> is a boolean variable in the game. This is a syntactical condition. We prove that if two games are identical-until-<em>bad</em> then the difference in the probabilities of a given outcome is bounded by the probability that <em>bad</em> gets set (in either game). This result, the <em>fundamental lemma of game-playing</em>, is the central tool justifying the technique.</p>

    <p class="text-gray-300">We go on to give describe some general lemmas and techniques for analyzing the probability that <em>bad</em> gets set. Principle among these is a lemma that lets you change anything you want after the flag <em>bad</em> gets set. Other techniques speak to eliminating adaptivity, de-randomization, making “lazy” probabilistic choices, resampling, using “poisoned” points, and so forth.</p>

    <p class="text-gray-300">Further applications. We illustrate the applicability of games in a wide variety of settings, providing results in the standard model, the random-oracle model <em>[9]</em>, and the ideal-cipher model, and in both the symmetric and asymmetric settings.</p>

    <p class="text-gray-300">We begin with a motivating observation, due to Tadayoshi Kohno, that the standard proof of the PRP/PRF Switching Lemma (<em>[30, Theorem 5.1]</em>, <em>[5]</em>, and <em>[29]</em>) contains an error in reasoning about conditional probabilities. (The lemma says that an adversary that asks <span class="math">q</span> queries can distinguish with advantage at most <span class="math">q^{2}/2^{n+1}</span> a random permutation on <span class="math">n</span>-bits from a random function of <span class="math">n</span>-bits to <span class="math">n</span>-bits.) We regard this as evidence that reasoning about cryptographic constructions via conditional probabilities can be subtle and error-prone even in the simplest of settings. This motivates our use of games as an alternative. We re-prove the Switching Lemma with a simple game-based proof.</p>

    <p class="text-gray-300">Next we look at the CBC MAC. Let <span class="math">\\mathbf{Adv}_{n,m}^{\\mathrm{cbc}}(q)</span> denote the maximum advantage that an adversary restricted to making at most <span class="math">q</span> oracle queries can obtain in distinguishing between (1) the <span class="math">m</span>-block CBC MAC, keyed by a random permutation on <span class="math">n</span> bits, and (2) a random function from <span class="math">mn</span>-bits to <span class="math">n</span>-bits. A result of Bellare, Kilian, and Rogaway <em>[5]</em> says that <span class="math">\\mathbf{Adv}_{n,m}^{\\mathrm{cbc}}(q)\\leq 2m^{2}q^{2}/2^{n}</span>. But the proof <em>[5]</em> is very complex and does not directly capture the intuition behind the security of the scheme. Here we use games to give an elementary proof for an <span class="math">m^{2}q^{2}/2^{n}</span> bound, the proof directly capturing, in our view, the underlying intuition.</p>

    <p class="text-gray-300">Finally, we give an example of using games in the public-key, random-oracle setting by proving that OAEP <em>[8]</em> with any trapdoor permutation is an IND-CPA secure encryption scheme. The original proof of this result <em>[8]</em> was hard to follow or verify; the new proof is simpler and clearer,</p>

    <p class="text-gray-300">and illustrates the use of games in a computational rather than information-theoretic setting.</p>

    <p class="text-gray-300">Further related work. The best-known attack on three-key triple-encryption is due to Lucks <em>[33]</em>. He does not work out an explicit lower bound for <span class="math">\\mathbf{Adv}^{\\text{ese}}_{k,n}(q)</span> but in the case of triple-DES the advantage becomes large by <span class="math">q=2^{90}</span> queries. We prove security to about <span class="math">2^{78}</span> queries, so there is no contradiction.</p>

    <p class="text-gray-300">The DESX construction has been proven secure up to about <span class="math">2^{k+n-\\lg m}</span> blockcipher queries for key length <span class="math">k</span>, block length <span class="math">n</span>, and <span class="math">m</span> queries to the construction <em>[32]</em>. This is stronger than our bound for triple encryption when the adversary can obtain few points encrypted by the construction, a weaker bound otherwise.</p>

    <p class="text-gray-300">Double encryption and two-key triple encryption were analyzed Aiello, Bellare, Di Crescenzo, and Venkatesan <em>[3]</em>, where it is shown that the meet-in-the-middle attack is optimal (in the ideal-cipher model). Their result is the first to show that the cascade construction buys you <em>something</em> (half a bit of security for advantage 0.5), but what it buys is inherently limited, because of the meet-in-the-middle attack. We comment that games provide an avenue to a much simpler proof of their result.</p>

    <p class="text-gray-300">With motivation similar to our own, Maurer develops a framework for the analysis of cryptographic constructions and applies it to the CBC MAC and other examples <em>[34]</em>. Vaudenay has likewise developed a framework for the analysis of blockciphers and blockcipher-based constructions, and has applied it to the encrypted CBC MAC <em>[49]</em>. Neither Maurer’s nor Vaudenay’s approach is geared towards making stepwise, code-directed refinements for computing a probability.</p>

    <p class="text-gray-300">A more limited and less formal version of the Fundamental Lemma appears in <em>[6, Lemma 7.1]</em>. A lemma by Shoup <em>[45, Lemma 1]</em> functions in a similar way for games that are not necessarily code-based.</p>

    <p class="text-gray-300">Shoup has independently and contemporaneously prepared a manuscript on game playing <em>[47]</em>. It is more pedagogically-oriented than this paper. Shoup does not try to develop a theory for game playing beyond <em>[45, Lemma 1]</em>. As with us, one of Shoup’s examples is the PRP/PRF Switching Lemma.</p>

    <p class="text-gray-300">In response to a web distribution of this paper, Bernstein offers his own proof for the CBC MAC <em>[11]</em>, re-obtaining the conventional bound. Bernstein sees no reason for games, and offers his own explanation for why cryptographic proofs are often complex and hard to verify: author incompetence with probability.</p>

    <p class="text-gray-300">In work derivative of an earlier version of this paper, Bellare, Pietrzak, and Rogaway <em>[7]</em> improve the bound <span class="math">\\mathbf{Adv}^{\\text{cbc}}_{n,m}(q)\\leq m^{2}q^{2}/2^{n}</span> of <em>[5, 34]</em> to about <span class="math">mq^{2}/2^{n}</span>, and consider generalizations to this claim as well. The proof of <em>[7]</em> springs from games, refining the game used here for the CBC MAC and then analyzing it using techniques derivative of <em>[20]</em>.</p>

    <p class="text-gray-300">Following the web distribution of this paper, Halevi argues for the creation of an automated tool to help write and verify game-based proofs <em>[26]</em>. We agree. The possibility for such tools has always been one of our motivations, and one of the reasons why we focused on code-based games.</p>

    <p class="text-gray-300">Gaži and Maurer <em>[24]</em> pointed out a couple of bugs that we corrected in draft 3.0. Game <span class="math">H</span> is now parameterized by a permutation <span class="math">S</span> and a formerly missing factor of 3 now appears in the second terms of (14). A consequence is that the claimed bound for triple DES was reduced from <span class="math">2^{78.5}</span> to <span class="math">2^{77.79}</span>. Gaži and Maurer also provide an alternative proof for the security of triple encryption using Maurer’s framework <em>[34]</em> and extend the result to longer cascades.</p>

    <p class="text-gray-300">Why should game-playing work? It is fair to ask if anything is actually “going on” when using games—couldn’t you recast everything into more conventional probabilistic language and drop all that ugly code? Our experience is that it does not work to do so. The kind of probabilistic statements and thought encouraged by the game-playing paradigm seems to be a better fit, for</p>

    <p class="text-gray-300">many cryptographic problems, than that which is encouraged by (just) defining random-variables, writing conventional probability expressions, conditioning, and the like. Part of the power of the approach stems from the fact that pseudocode is the most precise and easy-to-understand language we know for describing the sort of probabilistic, reactive environments encountered in cryptography, and by remaining in that domain to do ones reasoning you are better able to see what is happening, manipulate what is happening, and validate the changes.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 The PRP/PRF Switching Lemma</h2>

    <p class="text-gray-300">The lemma. The natural and conventional assumption to make about a blockcipher is that it behaves as a pseudorandom permutation (PRP). However, it usually turns out to be easier to analyze the security of a blockcipher-based construction assuming the blockcipher is secure as a pseudorandom function (PRF). The gap is then bridged (meaning, a result about the security of the construct assuming the blockcipher is a PRP is obtained) using the following lemma. In what follows, we denote by <span class="math">A^{P}\\Rightarrow 1</span> the event that adversary <span class="math">A</span>, equipped with an oracle <span class="math">P</span>, outputs the bit <span class="math">1</span>. Let <span class="math">\\mathrm{Perm}(n)</span> be the set of all permutations on <span class="math">\\{0,1\\}^{n}</span> and let <span class="math">\\mathrm{Func}(n)</span> be the set of all functions from <span class="math">\\{0,1\\}^{n}</span> to <span class="math">\\{0,1\\}^{n}</span>. We assume below that <span class="math">\\pi</span> is randomly sampled from <span class="math">\\mathrm{Perm}(n)</span> and <span class="math">\\rho</span> is randomly sampled from <span class="math">\\mathrm{Func}(n)</span>.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Lemma 1</h6>

    <p class="text-gray-300"><em>[PRP/PRF Switching Lemma]</em> Let <span class="math">n\\geq 1</span> be an integer. Let <span class="math">A</span> be an adversary that asks at most <span class="math">q</span> oracle queries. Then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr\\left[\\,A^{\\pi}\\Rightarrow 1\\,\\right]-\\Pr\\left[\\,A^{\\rho}\\Rightarrow 1\\,\\right]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\leq\\ \\frac{q(q-1)}{2^{n+1}}\\ .\\ \\ \\hbox to0.0pt{\\hss\\hss}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this section we point to some subtleties in the “standard” proof of this widely used result, as given for example in <em>[5, 29, 30]</em>, showing in particular that one of the claims made in these proofs is incorrect. We then show how to prove the lemma in a simple and correct way using games. This example provides a gentle introduction to the game-playing technique and a warning about perils of following ones intuition when dealing with conditional probability in provable-security cryptography.</p>

    <p class="text-gray-300">The standard proof. The standard analysis proceeds as follows. Let Coll (“collision”) be the event that <span class="math">A</span>, interacting with oracle <span class="math">\\rho\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathrm{Func}(n)<span class="math">, asks distinct queries </span>X<span class="math"> and </span>X^{\\prime}$ that return the same answer. Let Dist (“distinct”) be the complementary event. Now</p>

    <p class="text-gray-300"><span class="math">\\Pr[A^{\\pi}\\Rightarrow 1]\\ =\\ \\Pr[A^{\\rho}\\Rightarrow 1\\mid\\mathrm{Dist}]</span> (1)</p>

    <p class="text-gray-300">since a random permutation is the same as a random function in which everything one obtains from distinct queries is distinct. Letting <span class="math">x</span> be this common value and <span class="math">y=\\Pr[A^{\\rho}\\Rightarrow 1\\mid\\mathrm{Coll}]</span> we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[A^{\\pi}\\Rightarrow 1]-\\Pr[A^{\\rho}\\Rightarrow 1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> </span>=<span class="math"> </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x-x\\Pr[\\mathrm{Dist}]-y\\Pr[\\mathrm{Coll}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ =\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x(1-\\Pr[\\mathrm{Dist}])-y\\Pr[\\mathrm{Coll}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where the final inequality follows because <span class="math">x,y\\in[0,1]</span>. One next argues that <span class="math">\\Pr[\\mathrm{Coll}]\\leq q(q-1)/2^{n+1}</span> and so the Switching Lemma follows.</p>

    <p class="text-gray-300">Where is the error in the simple proof above? It’s at equation (1): it needn’t be the case that <span class="math">\\Pr[A^{\\pi}\\Rightarrow 1]=\\Pr[A^{\\rho}\\Rightarrow 1\\mid\\mathrm{Dist}]</span>, and the sentence we gave by way of justification was mathematically meaningless. Here is a simple example to demonstrate that <span class="math">\\Pr[A^{\\pi}\\Rightarrow 1]</span> can be different from <span class="math">\\Pr[A^{\\rho}\\Rightarrow 1\\mid\\mathrm{Dist}]</span>. Let <span class="math">n=1</span> and consider the following adversary <span class="math">A</span> with oracle <span class="math">P\\colon\\{0,1\\}\\to\\{0,1\\}</span>:</p>

    <p class="text-gray-300">procedure Adversary <span class="math">A</span></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: Games used in the proof of the Switching Lemma. Game  <span class="math">S_{1}</span>  includes the boxed statement and  <span class="math">S_{0}</span>  doesn't.</p>

    <p class="text-gray-300">if  <span class="math">P(0) = 0</span>  then return 1</p>

    <p class="text-gray-300">else if  <span class="math">P(1) = 1</span>  then return 1 else return 0</p>

    <p class="text-gray-300">We claim that</p>

    <p class="text-gray-300"><span class="math">\\operatorname{Pr}[A^{\\pi} \\Rightarrow 1] = 1/2 \\quad \\text{and} \\quad \\operatorname{Pr}[A^{\\rho} \\Rightarrow 1 \\mid \\mathrm{DIST}] = 2/3</span> .</p>

    <p class="text-gray-300">The first equation is true because there are two possibilities for  <span class="math">(\\pi(0), \\pi(1))</span> , namely  <span class="math">(0, 1), (1, 0)</span>  and  <span class="math">A</span>  returns 1 for one of them, namely  <span class="math">(0, 1)</span> . On the other hand, there are four possibilities for  <span class="math">(\\rho(0), \\rho(1))</span> , namely  <span class="math">(0, 0), (0, 1), (1, 0), (1, 1)</span> . The event  <span class="math">A^{\\rho} \\Rightarrow 1 \\land \\mathrm{DIST}</span>  is true for two of them, namely  <span class="math">(0, 0), (0, 1)</span> , while the event  <span class="math">\\mathrm{DIST}</span>  is true for three of them, namely  <span class="math">(0, 0), (0, 1), (1, 0)</span> . Thus  <span class="math">\\operatorname{Pr}[A^{\\rho} \\Rightarrow 1 \\land \\mathrm{DIST}] / \\operatorname{Pr}[\\mathrm{DIST}] = 2/3</span> .</p>

    <p class="text-gray-300">Notice that the number of oracle queries made by the adversary of this counterexample varies, being either one or two, depending on the reply it receives to its first query. This turns out to be crucial in making equation (1) fail, in that if  <span class="math">A</span>  always makes exactly  <span class="math">q</span>  oracle queries (regardless of  <span class="math">A</span> 's coins and the answers returned to its queries) then equation (1) is true. (This was pointed out by Kohno, and his argument is re-produced in Appendix A.) Since one can always first modify  <span class="math">A</span>  to make exactly  <span class="math">q</span>  queries without altering  <span class="math">\\operatorname{Pr}[A^{\\rho} \\Rightarrow 1]</span>  or  <span class="math">\\operatorname{Pr}[A^{\\pi} \\Rightarrow 1]</span> , we would be loath to say that the proofs in [5, 29, 30] are incorrect. But the authors make claim (1), and view it as "obvious," without restricting the adversary to exactly  <span class="math">q</span>  queries, masking a subtlety that is not apparent at a first (or even second) glance.</p>

    <p class="text-gray-300">The fact that one can write something like (1) and people assume this to be correct, and even obvious, suggests to us that the language of conditional probability may often be unsuitable for thinking about and dealing with the kind of probabilistic scenarios that arise in cryptography. Games may more directly capture the desired intuition. Let us use them to give a correct proof.</p>

    <p class="text-gray-300">GAME-BASED PROOF. Assume without loss of generality (since  <span class="math">A</span> 's oracle is deterministic) that  <span class="math">A</span>  never asks an oracle query twice. We imagine answering  <span class="math">A</span> 's queries by running one of two games. Instead of thinking of  <span class="math">A</span>  as interacting with a random permutation oracle  <span class="math">\\pi \\stackrel{\\sharp}{\\leftarrow} \\operatorname{Perm}(n)</span> , think of it as interacting with the Game  <span class="math">S_1</span>  shown in Figure 2. Instead of thinking of  <span class="math">A</span>  as interacting with a random function oracle  <span class="math">\\rho \\stackrel{\\sharp}{\\leftarrow} \\operatorname{Func}(n)</span> , think of  <span class="math">A</span>  as interacting with the game  <span class="math">S_0</span>  shown in the same figure. Game  <span class="math">S_0</span>  is game  <span class="math">S_1</span>  without the boxed statement. By convention, the boolean variable bad is initialized to false while the array  <span class="math">\\pi</span>  begins everywhere undefined. The games make available to  <span class="math">A</span>  an oracle which has a formal name, in this case  <span class="math">P</span> . Adversary  <span class="math">A</span>  can query this oracle with a string  <span class="math">X \\in \\{0,1\\}^n</span> , in which case the code following the procedure  <span class="math">P(X)</span>  line is executed and the value in the return statement is provided to  <span class="math">A</span>  as the response to its oracle query. As the game runs, we fill-in values of  <span class="math">\\pi[X]</span>  with  <span class="math">n</span> -bit strings. At any point in time, we let  <span class="math">\\operatorname{image}(\\pi)</span>  be the set of all  <span class="math">n</span> -bit strings  <span class="math">Y</span>  such that  <span class="math">\\pi[X] = Y</span>  for some  <span class="math">X</span> . Let  <span class="math">\\overline{\\operatorname{image}}(\\pi)</span>  be the complement of this set relative to  <span class="math">\\{0,1\\}^n</span> . Let  <span class="math">A^S \\Rightarrow 1</span>  denote the event that  <span class="math">A</span>  outputs 1 in game  <span class="math">S \\in \\{S_0, S_1\\}</span> .</p>

    <p class="text-gray-300">Notice that the adversary never sees the flag bad. The flag will play a central part in our analysis, but it is not something that the adversary can observe. It's only there for our bookkeeping. What does adversary  <span class="math">A</span>  see as it plays game  <span class="math">S_0</span> ? Whatever query  <span class="math">X</span>  it asks, the game returns a random</p>

    <p class="text-gray-300"><span class="math">n</span>-bit string <span class="math">Y</span>. So game <span class="math">S_{0}</span> perfectly simulates a random function <span class="math">\\rho\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathrm{Func}(n)<span class="math"> (remember that the adversary isn’t allowed to repeat a query) and </span>\\Pr[A^{\\rho}\\Rightarrow 1]=\\Pr[A^{S_{0}}\\Rightarrow 1]<span class="math">. Similarly, if we’re in game </span>S_{1}<span class="math">, then what the adversary gets in response to each query </span>X<span class="math"> is a random point </span>Y<span class="math"> that has not already been returned to </span>A<span class="math">. The behavior of a random permutation oracle is exactly this, too. (This is guaranteed by what we will call the “principle of lazy sampling.”) So </span>\\Pr[A^{\\pi}\\Rightarrow 1]=\\Pr[A^{S_{1}}\\Rightarrow 1]$. We complete the proof via the following chain of inequalities, the first of which we have just justified:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[A^{\\pi}\\Rightarrow 1]-\\Pr[A^{\\rho}\\Rightarrow 1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> </span>=<span class="math"> </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[A^{S_{1}}\\Rightarrow 1]-\\Pr[A^{S_{0}}\\Rightarrow 1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ (2)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\leq</span> <span class="math">\\Pr[A^{S_{0}}\\mbox{ sets }bad\\,]</span> <span class="math">\\leq</span> <span class="math">q(q-1)/2^{n+1}\\;.</span></p>

    <p class="text-gray-300">Above, “<span class="math">A^{S_{0}}</span> sets bad ” refers to the event that the flag bad is set to true in the execution of <span class="math">A</span> with game <span class="math">S_{0}</span>. We justify (2) by appealing to the fundamental lemma of game playing (Lemma 2), which says that whenever two games are written so as to be syntactically identical except for things that immediately follow the setting of bad, the difference in the probabilities that <span class="math">A</span> outputs <span class="math">1</span> in the two games is bounded by the probability that bad is set in either game. (It actually says something a bit more general, as we will see.) We justify (3) by observing that, by the union bound, the probability that a <span class="math">Y</span> will ever be in image<span class="math">(\\pi)</span> at line <span class="math">101</span> is at most <span class="math">(1+2+\\cdots+(q-1))/2^{n}=q(q-1)/2^{n+1}</span>. This completes the proof.</p>

    <p class="text-gray-300">Counter-example revisited. It is instructive to see how the adversary <span class="math">A</span> of the counter-example above fares in the game-playing proof. A computation shows that</p>

    <p class="text-gray-300"><span class="math">\\Pr[A^{S_{0}}\\Rightarrow 1]=3/4\\;,\\qquad\\Pr[A^{S_{1}}\\Rightarrow 1]=1/2\\;,\\qquad\\mbox{and}\\qquad\\Pr[A^{S_{0}}\\mbox{ sets }bad\\,]=1/4\\;.</span></p>

    <p class="text-gray-300">So none of the equalities or inequalities that arose in the game-playing proof are violated.</p>

    <h2 id="sec-6" class="text-2xl font-bold">3 The Game-Playing Framework</h2>

    <p class="text-gray-300">Programming language. A game is a program, viewed as a collection of procedures, and the adversary is likewise a program, but one consisting of a single procedure. We will, for the moment, regard games and adversaries as being written in pseudocode. Below we outline some elements of our pseudocode. We find that a pseudocode-based descriptive language is adequate to make game-playing unambiguous and productive. To make a truly rigorous theory one should, in fact, fully specify the underlying programming language. In Appendix B we provide an example language <span class="math">\\mathcal{L}</span> suitable for describing games and adversaries (we specify the syntax but dispense with the operational semantics, which should be clear). The games of this paper conform to the syntax of <span class="math">\\mathcal{L}</span> apart from some minor matters.</p>

    <p class="text-gray-300">Our programming language is strongly typed, with the type of each variable apparent from its usage (we dispense with explicit declarations). We will have variables of type integer, boolean, string, set, and array. A set is a finite set of strings and an array is an associative array, one taking on values of strings. The semantics of a boolean variable, which we will also call a flag, is that once true it stays true.</p>

    <p class="text-gray-300">We allow conventional statements like if statements, for statements, and assignment statements. There is also a random-assignment statement, which is the only source of randomness in programs. Such a statement has the form <span class="math">s\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}S<span class="math"> where </span>S<span class="math"> is a finite set. The result is to uniformly select a random element from the set </span>S<span class="math"> and assign it to </span>s<span class="math">. If </span>S=\\emptyset<span class="math"> or </span>S=\\mbox{undefined}<span class="math"> (we regard undefined as a possible value for a variable) then the result of the random-assignment statement is to set </span>s$ to undefined. A comma or newline serves as a statement separator and indentation is used to indicate grouping.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: Running a game  <span class="math">G</span>  with an adversary  <span class="math">A</span> . The game is the code at the top, the adversary is the code at the bottom. The adversary interacts with the game by calling the oracles provided (two of which are shown).</p>

    <p class="text-gray-300">A game has three kinds of procedures: an initialization procedure (Initialize), a finalization procedure (Finalize), and named oracles (each one a procedures). The adversary can make calls to the oracles, passing in values from some finite domain associated to each oracle. The initialization or finalization procedures may be absent, and often are, and there may be any number of oracles, including none. All variables in a game are global variables and are not visible to the adversary's code. All variables in adversary code are local.</p>

    <p class="text-gray-300">RUNNING A GAME. We can run a game  <span class="math">G</span>  with an adversary  <span class="math">A</span> . To begin, variables are given initial values. Integer variables are initialized to 0; boolean variables are initialized to false; string variables are initialized to the empty string  <span class="math">\\varepsilon</span> ; set variables are initialized to the empty set  <span class="math">\\emptyset</span> ; and array variables hold the value undefined at every point. These conventions facilitate omitting explicit initialization code in many cases.</p>

    <p class="text-gray-300">The Initialize procedure is the first to execute, possibly producing an output inp. This is provided as input to the procedure Adversary, denoted  <span class="math">A</span> , which now runs. The adversary code can make oracle queries via statements of the form  <span class="math">y \\gets P(\\dots)</span>  for any oracle  <span class="math">P</span>  that has been defined in the game. The result is to assign to  <span class="math">y</span>  the value returned by the procedure call. We assume that the game and adversary match syntactically, meaning that all the oracle calls made by the adversary are to oracles specified in the game, and with arguments that match in type or quantity. The semantics of a call is call-by-value; the only way for an oracle to return a value to the adversary is via a return statement. When adversary  <span class="math">A</span>  halts, possibly with some output out, we call the Finalize procedure, providing it any output produced by  <span class="math">A</span> . The Finalize procedure returns a string that is the outcome of the game. If we omit specifying Initialize or Finalize it means that these procedures do nothing: they compute the identity function.</p>

    <p class="text-gray-300">TERMINATION AND FINITE RANDOMNESS. We assume that an underlying execution model provides a notion for the number of steps (the running time) of a program. We require that both the adversary and the game always terminate in finite time. By this we mean that, for any adversary  <span class="math">A</span>  there must exist an integer  <span class="math">T</span>  such that  <span class="math">A</span>  always halts within  <span class="math">T</span>  steps (regardless of the random choices  <span class="math">A</span>  makes and the answers it receives to its oracle queries). Similarly, for any game  <span class="math">G</span>  there must exist an integer  <span class="math">T</span>  such that  <span class="math">G</span>  always halts within  <span class="math">T</span>  steps (regardless of the random choices made, Initialize halts within  <span class="math">T</span>  steps, and, regardless of the inputs they are provided, Finalize and the oracles halt within  <span class="math">T</span>  steps). The finite-termination requirement is guaranteed automatically</p>

    <p class="text-gray-300">by our sample programming language <span class="math">\\mathcal{L}</span>.</p>

    <p class="text-gray-300">Since the adversary and game terminate in finite time, there must be an integer <span class="math">T</span> such that they each execute at most <span class="math">T</span> random-assignment statements, and there must be an integer <span class="math">B</span> such that the size of the set <span class="math">S</span> in any random-assignment statement <span class="math">s\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}S<span class="math"> executed by the adversary or the game is at most </span>B<span class="math">. Taken together, this means that the execution of </span>G<span class="math"> with </span>A<span class="math"> uses <em>finite randomness</em>, meaning </span>G<span class="math"> and </span>A<span class="math"> are underlain by a finite sample space </span>\\Omega$. Thus probabilities are well-defined and henceforth we can talk about the probabilities of various events in the execution.</p>

    <p class="text-gray-300">Adversary and game outputs. We associate two outputs to the process of running a game with an adversary. The first, called the adversary output, is the value <em>out</em> returned by <span class="math">A</span> after it has completed its interaction with the oracles provided by the game. The second, called the game output, is the value <em>outcome</em> returned by the Finalize procedure. Often the two outputs are the same, because the Finalize procedure is not specified (whence we define it to do nothing but pass on its input as its output).</p>

    <p class="text-gray-300">The adversary and game outputs can be regarded as random variables. We write <span class="math">\\Pr[A^{G}\\Rightarrow 1]</span> for the probability that the adversary output is <span class="math">1</span> when we run game <span class="math">G</span> with adversary <span class="math">A</span>, and <span class="math">\\Pr[G^{A}\\Rightarrow 1]</span> for the probability that the game output is <span class="math">1</span> when we run game <span class="math">G</span> with adversary <span class="math">A</span>.</p>

    <p class="text-gray-300">Advantages. If <span class="math">G</span> and <span class="math">H</span> are games and <span class="math">A</span> is an adversary, let</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}(A^{G},A^{H})~{}=~{}\\Pr[A^{G}\\Rightarrow 1]-\\Pr[A^{H}\\Rightarrow 1]~{}~{}~{}~{}\\text{and}~{}~{}~{}~{}\\mathbf{Adv}(G^{A},H^{A})~{}=~{}\\Pr[G^{A}\\Rightarrow 1]-\\Pr[H^{A}\\Rightarrow 1]~{}.</span></p>

    <p class="text-gray-300">These represent the advantage of the adversary in distinguishing the games, the first measured via adversary output and the second via game output. We refer to the first as the <em>adversarial advantage</em> and the second as the <em>game advantage</em>. We say that <span class="math">G,H</span> are <em>adversarially indistinguishable</em> if for any adversary <span class="math">A</span> it is the case that <span class="math">\\mathbf{Adv}(A^{G},A^{H})=0</span>, and <em>equivalent</em> if, for any adversary <span class="math">A</span> it is the case that <span class="math">\\mathbf{Adv}(G^{A},H^{A})=0</span>. We will often use the fact that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}(A^{G},A^{I})</span> <span class="math">=</span> <span class="math">\\mathbf{Adv}(A^{G},A^{H})+\\mathbf{Adv}(A^{H},A^{I})</span> (4) <span class="math">\\mathbf{Adv}(G^{A},I^{A})</span> <span class="math">=</span> <span class="math">\\mathbf{Adv}(G^{A},H^{A})+\\mathbf{Adv}(H^{A},I^{A})</span> (5)</p>

    <p class="text-gray-300">for any games <span class="math">G,H,I</span> and any adversary <span class="math">A</span>. These will be referred to as the <em>triangle equalities</em>.</p>

    <p class="text-gray-300">We will usually be interested in adversarial advantage (eg, this is the case in the game-playing proof of the PRP/PRF Switching Lemma). Game advantage is useful when we are interested in how the adversary’s output relates to some game variable such as a hidden bit chosen by the game (this happens in our proof of the security of OAEP).</p>

    <p class="text-gray-300">Identical-until-<em>bad</em> games. We are interested in programs that are syntactically identical except for statements that follow the setting of a flag <em>bad</em> to true. Somewhat more precisely, let <span class="math">G</span> and <span class="math">H</span> be programs and let <em>bad</em> be a flag that occurs in both of them. Then we say that <span class="math">G</span> and <span class="math">H</span> are <em>identical-until-bad</em> if their code is the same except that there might be places where <span class="math">G</span> has a statement <em>bad</em> <span class="math">\\leftarrow</span> true, <span class="math">S</span> while game <span class="math">H</span> has a corresponding statement <em>bad</em> <span class="math">\\leftarrow</span> true, <span class="math">T</span> for some <span class="math">T</span> that is different from <span class="math">S</span>. As an example, in the games <span class="math">S_{0}</span> and <span class="math">S_{1}</span> from Figure 2, the former has the empty statement following <em>bad</em> <span class="math">\\leftarrow</span> true while in <span class="math">S_{1}</span> we have <span class="math">Y\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\overline{\\text{image}}(\\pi)<span class="math"> following <em>bad</em> </span>\\leftarrow<span class="math"> true. Since this is the only difference in the programs, the games are identical-until-<em>bad</em>. One could also say that </span>G<span class="math"> and </span>H<span class="math"> are are identical-until-<em>bad</em> if one has the statement if <em>bad</em> then </span>S$ where the other has the empty statement, for this can be rewritten in the form above.</p>

    <p class="text-gray-300">A fully formal definition of identical-until-<em>bad</em> requires one to pin down the programming language and talk about the parse trees of programs in the language. We establish the needed language in Appendix B but, in fact, such formality isn’t needed in applications: for any two games one writes down, whether or not they are identical-until-<em>bad</em> is obvious. We emphasize that identical-until-<em>bad</em> is a purely “syntactic” requirement.</p>

    <p class="text-gray-300">We write <span class="math">\\operatorname{Pr}[A^G \\text{ sets } bad]</span> or <span class="math">\\operatorname{Pr}[G^A \\text{ sets } bad]</span> to refer to the probability that the flag <span class="math">bad</span> is true at the end of the execution of the adversary <span class="math">A</span> with game <span class="math">G</span>, namely at the point when the Finalize procedure terminates. It is easy to see that, for any flag <span class="math">bad</span>, identical-until-<span class="math">bad</span> is an equivalence relation on games. When we say that a sequence of games <span class="math">G_1, G_2, \\ldots</span> are identical-until-<span class="math">bad</span>, we mean that each pair of games in the sequence are identical-until-<span class="math">bad</span>.</p>

    <p class="text-gray-300">THE FUNDAMENTAL LEMMA. The fundamental lemma says that the advantage that an adversary can obtain in distinguishing a pair of identical-until-<span class="math">bad</span> games is at most the probability that its execution sets <span class="math">bad</span> in one of the games (either game will do).</p>

    <p class="text-gray-300"><strong>Lemma 2</strong> [Fundamental lemma of game-playing] Let <span class="math">G</span> and <span class="math">H</span> be identical-until-bad games and let <span class="math">A</span> be an adversary. Then</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Adv}(A^G, A^H) \\leq \\Pr[A^G \\text{ sets } bad] \\quad \\text{and} \\tag{6}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Adv}(G^A, H^A) \\leq \\Pr[G^A \\text{ sets } bad]. \\tag{7}</span></div>

    <p class="text-gray-300">More generally, let <span class="math">G, H, I</span> be identical-until-bad games. Then</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Adv}(A^G, A^H) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\Pr[A^I \\text{ sets } bad] \\quad \\text{and} \\tag{8}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Adv}(G^A, H^A) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\Pr[I^A \\text{ sets } bad]. \\tag{9}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Proof:</strong> Statement (6) follows from (7) by applying the latter to games <span class="math">G&#x27;, H&#x27;</span> formed by replacing the Finalize procedure of games <span class="math">G, H</span>, respectively, with the trivial one that simply returns the adversary output. Similarly, (8) follows from (9). We will now prove (7) and then derive (9) from it.</p>

    <p class="text-gray-300">We have required that the adversary and game always terminate in finite time, and also that there is an integer that bounds the size of any set <span class="math">S</span> in any random-assignment statement <span class="math">s \\stackrel{\\</span>}{\\leftarrow} S<span class="math"> executed by the adversary or game. This means that there exists an integer </span>b<span class="math"> such that the execution of </span>G<span class="math"> with </span>A<span class="math"> and the execution of </span>H<span class="math"> with </span>A<span class="math"> perform no more than </span>b<span class="math"> random-assignment statements, each of these sampling from a set of size at most </span>b<span class="math">. Let </span>C = \\operatorname{Coins}(A, G, H) = [1..b!]^b<span class="math"> be the set of </span>b<span class="math">-tuples of numbers, each number between 1 and </span>b!<span class="math">. We call </span>C<span class="math"> the coins for </span>(A, G, H)<span class="math">. For </span>c = (c_1, \\ldots, c_b) \\in C<span class="math">, the execution of </span>G<span class="math"> with </span>A<span class="math"> on coins </span>c<span class="math"> is defined as follows: on the </span>i^{\\text{th}}<span class="math"> random-assignment statement, call it </span>X \\stackrel{\\<span class="math">}{\\leftarrow} S</span>, if <span class="math">S = \\{a_0, \\ldots, a_{m-1}\\}</span> is nonempty and <span class="math">a_0 &amp;lt; a_1 &amp;lt; \\cdots &amp;lt; a_{m-1}</span> in lexicographic order then let <span class="math">X</span> take on the value <span class="math">a_{c_i \\bmod m}</span>. If <span class="math">S = \\emptyset</span> then let <span class="math">X</span> take on the value undefined. This way to perform random-assignment statements is done regardless of whether it is <span class="math">A</span> or one of the procedures from <span class="math">G</span> that is performing the random-assignment statement. Notice that <span class="math">m</span> will divide <span class="math">b!</span> and so if <span class="math">c</span> is chosen at random from <span class="math">C</span> then the mechanism above will return a point <span class="math">X</span> drawn uniformly from <span class="math">S</span>, and also the return values for each random-assignment statement are independent. For <span class="math">c \\in C</span> we let <span class="math">G^A(c)</span> denote the output of <span class="math">G</span> when <span class="math">G</span> is executed with <span class="math">A</span> on coins <span class="math">c</span>. We define the execution of <span class="math">H</span> with <span class="math">A</span> on coins <span class="math">c \\in C</span>, and <span class="math">H^A(c)</span>, similarly.</p>

    <p class="text-gray-300">Let <span class="math">CG_{\\mathrm{one}} = \\{c \\in C : G^A(c) \\Rightarrow 1\\}</span> be the set of coins <span class="math">c \\in C</span> such that <span class="math">G</span> outputs 1 when executed with <span class="math">A</span> on coins <span class="math">c</span>. Partition <span class="math">CG_{\\mathrm{one}}</span> into <span class="math">CG_{\\mathrm{one}}^{\\mathrm{bad}}</span> and <span class="math">CG_{\\mathrm{one}}^{\\mathrm{good}}</span>, where <span class="math">CG_{\\mathrm{one}}^{\\mathrm{bad}}</span> is the set of all <span class="math">c \\in CG_{\\mathrm{one}}</span> such that the execution of <span class="math">G</span> with <span class="math">A</span> on coins <span class="math">c</span> sets bad and <span class="math">CG_{\\mathrm{one}}^{\\mathrm{good}} = CG_{\\mathrm{one}} \\setminus CG_{\\mathrm{one}}^{\\mathrm{bad}}</span>. Similarly define <span class="math">CH_{\\mathrm{one}}</span>, <span class="math">CH_{\\mathrm{one}}^{\\mathrm{bad}}</span> and <span class="math">CH_{\\mathrm{one}}^{\\mathrm{good}}</span>. Observe that because games <span class="math">G</span> and <span class="math">H</span> are identical-until-bad, an element <span class="math">c \\in C</span> is in <span class="math">CG_{\\mathrm{one}}^{\\mathrm{good}}</span> iff it is in <span class="math">CH_{\\mathrm{one}}^{\\mathrm{good}}</span>. Thus these sets are equal and in particular have</p>

    <p class="text-gray-300">the same size. Now we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\Pr[G^{A}\\Rightarrow 1]-\\Pr[A^{H}\\Rightarrow 1]</span> <span class="math">=</span> $\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CG_{\\text{one}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}-\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CH_{\\text{one}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\ =\\ \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CG_{\\text{one}}^{\\text{bad}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CG_{\\text{one}}^{\\text{good}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CH_{\\text{one}}^{\\text{good}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CH_{\\text{one}}^{\\text{bad}}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This completes the proof of (7). Now, if <span class="math">G,H</span> are identical-until-<span class="math">bad</span> then (7) tells us that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}(G^{A},H^{A})\\ \\leq\\ \\Pr[G^{A}\\text{ sets }bad\\ ]\\quad\\text{and}\\quad\\ \\mathbf{Adv}(H^{A},G^{A})\\ \\leq\\ \\Pr[H^{A}\\text{ sets }bad\\ ]\\ .</span></p>

    <p class="text-gray-300">However, if <span class="math">G,H,I</span> are all identical-until-<span class="math">bad</span>, then Proposition 3 says that</p>

    <p class="text-gray-300"><span class="math">\\Pr[G^{A}\\text{ sets }bad\\ ]\\ =\\ \\Pr[H^{A}\\text{ sets }bad\\ ]\\ =\\ \\Pr[I^{A}\\text{ sets }bad\\ ]\\ .</span></p>

    <p class="text-gray-300">Thus we have established (9).</p>

    <p class="text-gray-300">We have used finite randomness in our proof of the Fundamental Lemma, but we comment that this is more for simplicity than necessity: probabilities over the execution of <span class="math">G</span> with <span class="math">A</span> can be defined quite generally, even when the underlying sample space is infinite, and the Fundamental Lemma can still be proved. But we have never encountered any situation where such an extension is useful.</p>

    <p class="text-gray-300">After bad is set, nothing matters. One of the most common manipulations of games along a game chain is to change what happens after <span class="math">bad</span> gets set to true. Often one expunges code that follows the setting of <span class="math">bad</span>, as we did in the PRP/PRF Switching Lemma,but it is also fine to insert alternative code. Any modification following the setting of <span class="math">bad</span> leaves unchanged the probability of setting <span class="math">bad</span>, as the following result shows.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Proposition 3</h6>

    <p class="text-gray-300">[After <span class="math">bad</span> is set, nothing matters] Let <span class="math">G</span> and <span class="math">H</span> be identical-until-bad games. Let <span class="math">A</span> be an adversary. Then <span class="math">\\Pr[G^{A}\\text{ sets }bad\\ ]=\\Pr[H^{A}\\text{ sets }bad\\ ]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof: Using the definition from the proof of Lemma 2, fix coins <span class="math">C=\\text{Coins}(A,G,H)</span> and execute <span class="math">G^{A}</span> and <span class="math">H^{A}</span> in the manner we described using these coins. Let <span class="math">CG^{\\text{bad}}\\subseteq C</span> be the coins that result in <span class="math">bad</span> getting set to true when we run <span class="math">G^{A}</span>, and let <span class="math">CH^{\\text{bad}}\\subseteq C</span> be the coins that result in <span class="math">bad</span> getting set to true when we run <span class="math">H^{A}</span>. Since <span class="math">G</span> and <span class="math">H</span> are identical-until-<span class="math">bad</span>, each <span class="math">c\\in C</span> causes <span class="math">bad</span> to be set to true in <span class="math">G^{A}</span> iff it causes <span class="math">bad</span> to be set to true in <span class="math">H^{A}</span>. Thus <span class="math">CG^{\\text{bad}}=\\ CH^{\\text{bad}}</span> and hence $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CG^{\\text{bad}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CH^{\\text{bad}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CG^{\\text{bad}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\ CH^{\\text{bad}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, which is to say that </span>\\Pr[G^{A}\\text{ sets }bad\\ ]=\\Pr[H^{A}\\text{ sets }bad\\ ]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Besides the lemma above, many other ways to manipulate games are illustrated by our examples and our discussion in Section 7.</p>

    <p class="text-gray-300">Game inputs. The setting discussed above can be extended to allow a game to take an input parameter: the Initialize procedure would take an optional input that is a string parameter <span class="math">input</span>. The adversary and game outputs will now be denoted <span class="math">\\Pr[A^{G}(input)\\Rightarrow 1]</span> and <span class="math">\\Pr[G^{A}(input)\\Rightarrow 1]</span> respectively. Similarly, the advantages become <span class="math">\\mathbf{Adv}(A^{G}(input),A^{H}(input))</span> and <span class="math">\\mathbf{Adv}(G^{A}(input)</span>, <span class="math">H^{A}(input))</span>, these being defined in the obvious ways. The definition of identical-until-<span class="math">bad</span> obviously extends to games with inputs, as does the Fundamental Lemma.</p>

    <p class="text-gray-300">We can imagine that it might be convenient for games to have inputs, for example in the asymptotic setting where <span class="math">input</span> might be the security parameter, but our experience has been that it is not really necessary. Rather than giving a game an input <span class="math">input</span>, we can usually imagine a family of games, one for each value of <span class="math">input</span>, and reason about these; since the games are involved only in the analysis, this usually suffices. Accordingly our treatment of games omits explicit game inputs.</p>

    <p class="text-gray-300">4 The Security of Three-Key Triple-Encryption</p>

    <p class="text-gray-300">In this section we show that, in the ideal-cipher model, triple encryption dramatically increases security compared to single (or double) encryption. The result covers both EEE-style triple encryption and EDE-style triple encryption.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">4.1 Definitions</h3>

    <p class="text-gray-300">Let <span class="math">E\\colon\\{0,1\\}^{k}\\times\\{0,1\\}^{n}\\to\\{0,1\\}^{n}</span> be a blockcipher with key length <span class="math">k</span> and block length <span class="math">n</span>. For <span class="math">K\\in\\{0,1\\}^{k}</span> and <span class="math">X\\in\\{0,1\\}^{n}</span> let <span class="math">E_{K}(X)=E(K,X)</span>. Let <span class="math">E^{-1}\\colon\\{0,1\\}^{k}\\times\\{0,1\\}^{n}\\to\\{0,1\\}^{n}</span> be the blockcipher that is the inverse of <span class="math">E</span>. We associate to <span class="math">E</span> two blockciphers formed by composition; denoted <span class="math">\\mathsf{Cascade}_{E}^{\\mathrm{eee}},\\mathsf{Cascade}_{E}^{\\mathrm{ede}}\\colon\\{0,1\\}^{3k}\\times\\{0,1\\}^{n}\\to\\{0,1\\}^{n}</span>, these are defined as</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Cascade}_{E}^{\\mathrm{eee}}(K_{0}K_{1}K_{2},\\;X)</span> <span class="math">=</span> <span class="math">E_{K_{2}}(E_{K_{1}}(E_{K_{0}}(X)))\\quad\\text{and}</span> <span class="math">\\mathsf{Cascade}_{E}^{\\mathrm{ede}}(K_{0}K_{1}K_{2},\\;X)</span> <span class="math">=</span> <span class="math">E_{K_{2}}(D_{K_{1}}(E_{K_{0}}(X)))</span></p>

    <p class="text-gray-300">for all <span class="math">K_{0},K_{1},K_{2}\\in\\{0,1\\}^{k}</span> and <span class="math">X\\in\\{0,1\\}^{n}</span>. These blockciphers have key length <span class="math">3k</span> and block length <span class="math">n</span> and are sometimes referred to as the <em>three-key</em> forms of triple encryption. We will call the two methods EEE and EDE, respectively. There is also a <em>two-key</em> variant of triple encryption, obtained by setting <span class="math">K_{0}=K_{2}</span>, but we do not investigate it since the method admits comparatively efficient attacks <em>[36]</em>.</p>

    <p class="text-gray-300">We will be working in the ideal-blockcipher model, as in works like <em>[22, 3, 32]</em>. Let <span class="math">\\mathrm{Bloc}(k,n)</span> be the set of all blockciphers <span class="math">E\\colon\\{0,1\\}^{k}\\times\\{0,1\\}^{n}\\to\\{0,1\\}^{n}</span>. Thus <span class="math">E\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathrm{Bloc}(k,n)<span class="math"> means that </span>E_{K}\\colon\\{0,1\\}^{n}\\to\\{0,1\\}^{n}<span class="math"> is a random permutation on </span>n<span class="math">-bit strings for each </span>K\\in\\{0,1\\}^{k}<span class="math">. We consider an adversary </span>A<span class="math"> that can make four types of oracle queries: </span>\\bm{T}(X)<span class="math">, </span>\\bm{T^{-1}}(Y)<span class="math">, </span>\\bm{E}(K,X)<span class="math">, and </span>\\bm{E^{-1}}(K,Y)<span class="math">, where </span>X,Y\\in\\{0,1\\}^{n}<span class="math"> and </span>K\\in\\{0,1\\}^{k}<span class="math">. (As for our syntax, </span>\\bm{T}<span class="math">, </span>\\bm{T^{-1}}<span class="math">, </span>\\bm{E}<span class="math">, </span>\\bm{E^{-1}}<span class="math"> are formal symbols, not specific functions.) The <em>advantage of </span>A<span class="math"> against EEE</em> and the <em>maximal advantage against EEE obtainable using </span>q$ queries</em> are defined as</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}_{k,n}^{\\mathrm{eee}}(A)\\;=\\;\\mathbf{Adv}(A_{0}^{C},A_{0}^{R})\\quad\\text{and}\\quad\\mathbf{Adv}_{k,n}^{\\mathrm{eee}}(q)\\;=\\;\\max_{A}\\big{\\{}\\,\\mathbf{Adv}_{k,n}^{\\mathrm{eee}}(A)\\;\\big{\\}}</span></p>

    <p class="text-gray-300">where the games <span class="math">C_{0},R_{0}</span> are shown in Figure 4 and the maximum is over all adversaries <span class="math">A</span> that make at most <span class="math">q</span> oracle queries (that is, a total of <span class="math">q</span> across all four oracles). The advantage of <span class="math">A</span> measures its ability to tell whether <span class="math">\\bm{T}(\\cdot)</span> is a random permutation or is <span class="math">\\mathsf{Cascade}_{E}^{\\mathrm{eee}}(K_{0}K_{1}K_{2},\\;\\cdot\\;)</span> for <span class="math">K_{0}K_{1}K_{2}</span> chosen independently at random from <span class="math">\\{0,1\\}^{3k}</span> and where <span class="math">\\bm{E}</span> realizes a random blockcipher and <span class="math">\\bm{T^{-1}},\\bm{E^{-1}}</span> realize inverses of <span class="math">\\bm{T},\\bm{E}</span>, respectively.</p>

    <p class="text-gray-300">Define the <em>query threshold</em> <span class="math">\\mathbf{QTh}_{1/2}^{\\mathrm{eee}}(k,n)</span> as the largest integer <span class="math">q</span> for which <span class="math">\\mathbf{Adv}_{k,n}^{\\mathrm{eee}}(q)\\leq 1/2</span>. We will regard EEE as being secure up to <span class="math">\\mathbf{QTh}_{1/2}^{\\mathrm{eee}}(k,n)</span> queries. Let <span class="math">\\mathbf{Adv}_{k,n}^{\\mathrm{ede}}(A),\\mathbf{Adv}_{k,n}^{\\mathrm{ede}}(q)</span>, and <span class="math">\\mathbf{QTh}_{1/2}^{\\mathrm{ede}}(k,n)</span> be defined in the analogous way.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">4.2 Results</h3>

    <p class="text-gray-300">We are now ready to state our result about the security of triple encryption.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Theorem 4</h6>

    <p class="text-gray-300"><em>[Security of triple-encryption]</em> Let <span class="math">k,n\\geq 2</span>. Let <span class="math">\\alpha=\\max(2e2^{k-n},2n+k)</span>. Then</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}_{k,n}^{\\mathrm{eee}}(q)\\;\\leq\\;12\\alpha\\,\\frac{q^{2}}{2^{3k}}+10.7\\,\\left(\\frac{q}{2^{k+n/2}}\\right)^{2/3}+\\;\\frac{12}{2^{k}}\\;.\\qquad\\text{\\hskip 28.45274pt\\text{\\hskip 28.45274pt\\text{\\hskip 28.45274pt\\text{\\hskip 28.45274pt}}</span> (10)</p>

    <p class="text-gray-300">We display the result graphically in Figure 1 for DES parameters <span class="math">k=56</span> and <span class="math">n=64</span>. Our bound implies that <span class="math">\\mathbf{QTh}_{1/2}^{\\mathrm{eee}}(k,n)</span> is, very roughly, about <span class="math">2^{k+\\min(k,n)/2}</span>, meaning that EEE is secure up to this many queries.</p>

    <p class="text-gray-300">For EDE the result is the same, meaning that <span class="math">\\mathbf{Adv}^{\\mathrm{ede}}_{k,n}(q)</span> is also bounded by the quantity on the right-hand-side of (10). This can be shown by mostly-notational modifications to the proof of Theorem 4.</p>

    <p class="text-gray-300">Overview of the proof. The first step in our proof reduces the problem of bounding the advantage of an adversary <span class="math">A</span> against EEE to bounding certain quantities that relate to a different, <em>simplified</em> adversary <span class="math">B</span>. By a simplified adversary we mean one that makes no <span class="math">\\boldsymbol{T}(\\cdot)</span>, <span class="math">\\boldsymbol{T^{-1}}(\\cdot)</span> queries, meaning it only has oracles <span class="math">\\boldsymbol{E}(\\cdot,\\cdot)</span> and <span class="math">\\boldsymbol{E^{-1}}(\\cdot,\\cdot)</span>. We will consider two games, both involving random, distinct keys <span class="math">K_{0},K_{1},K_{2}</span>. In one game <span class="math">(R_{3})</span> <span class="math">E_{K_{2}}</span> is random, while in the other <span class="math">(D_{S})</span>, it is correlated to <span class="math">E_{K_{0}},E_{K_{1}}</span>. The quantities we will need to bound are the ability of our simplified adversary to either distinguish these games without extending a 2-chain, or to extend a 2-chain in one of the games, where what it means to extend a 2-chain is explained below. We will be able to provide these two bounds via two lemmas. The first considers a simplified game in which an adversary has only three permutation oracles, either all random or one correlated to the rest, and has to distinguish them without extending a 2-chain. The second bounds the probability that the adversary can extend a 2-chain in <span class="math">R_{3}</span>.</p>

    <p class="text-gray-300">Conventions. We begin with some conventions. An adversary <span class="math">A</span> against EEE can make oracle queries <span class="math">\\boldsymbol{T}(X)</span>, <span class="math">\\boldsymbol{T^{-1}}(Y)</span>, <span class="math">\\boldsymbol{E}(K,X)</span>, or <span class="math">\\boldsymbol{E^{-1}}(K,Y)</span> for any <span class="math">X,Y\\in\\{0,1\\}^{n}</span> and <span class="math">K\\in\\{0,1\\}^{k}</span>. We will assume that any adversary against EEE is deterministic and never makes a <em>redundant</em> query. A query is redundant if it has been made before; a query <span class="math">\\boldsymbol{T^{-1}}(Y)</span> is redundant if <span class="math">A</span> has previously received <span class="math">Y</span> in answer to a query <span class="math">\\boldsymbol{T}(X)</span>; a query <span class="math">\\boldsymbol{T}(X)</span> is redundant if <span class="math">A</span> has previously received <span class="math">X</span> in answer to a query <span class="math">\\boldsymbol{T^{-1}}(Y)</span>; a query <span class="math">\\boldsymbol{E^{-1}}(K,Y)</span> is redundant if <span class="math">A</span> has previously received <span class="math">Y</span> in answer to a query <span class="math">\\boldsymbol{E}(K,X)</span>; a query <span class="math">\\boldsymbol{E}(K,X)</span> is redundant if <span class="math">A</span> has previously received <span class="math">X</span> in answer to a query <span class="math">\\boldsymbol{E^{-1}}(K,Y)</span>. Assuming <span class="math">A</span> to be deterministic and not to ask redundant queries is without loss of generality in the sense that for any <span class="math">A</span> that asks <span class="math">q</span> queries there is an <span class="math">A^{\\prime}</span> asking at most <span class="math">q</span> queries that satisfies these assumptions and achieves the same advantage as <span class="math">A</span>. Our general conventions about games imply that <span class="math">A</span> never asks a query with arguments outside of the intended domain, meaning <span class="math">\\{0,1\\}^{k}</span> for keys and <span class="math">\\{0,1\\}^{n}</span> for messages.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">4.3 Reduction to simplified adversary</h3>

    <p class="text-gray-300">Consider the games in Figure 4. The <span class="math">R</span>-games (where <span class="math">R</span> stands for random) omit the boxed assignment statements while the <span class="math">C</span>-games and <span class="math">D</span>-game include them. <span class="math">\\mathrm{Distinct}_{3}^{k}</span> denotes the set of all triples <span class="math">(K_{0},K_{1},K_{2})\\in(\\{0,1\\}^{k})^{3}</span> such that <span class="math">K_{0}\\neq K_{1}</span> and <span class="math">K_{1}\\neq K_{2}</span> and <span class="math">K_{0}\\neq K_{2}</span>. Games <span class="math">R_{0}</span>, <span class="math">R_{1}</span>, <span class="math">C_{0}</span>, <span class="math">C_{1}</span> will be run with an adversary against EEE. The rest of the games will be run with a simplified adversary. Game <span class="math">C_{T}</span> is parameterized by a permutation <span class="math">T\\in\\mathrm{Perm}(n)</span>, meaning we are effectively defining one such game for every <span class="math">T</span>, and similarly <span class="math">D_{S}</span> is parameterized by a permutation <span class="math">S\\in\\mathrm{Perm}(n)</span>. Game <span class="math">D_{S}</span> grows an (initially without edges) edge-labeled directed graph with vertex set <span class="math">\\{0,1\\}^{n}</span>. An arc <span class="math">X\\xrightarrow{i}Y</span> is created when a query <span class="math">\\mathbf{E}_{K_{i}}(X)</span> returns the value <span class="math">Y</span> or a query <span class="math">E_{K_{i}}^{-1}(Y)</span> returns the value <span class="math">X</span>. The boolean flag <span class="math">x2ch</span> is set if the adversary extends a 2-chain, meaning that a path <span class="math">P\\xrightarrow{i+1}Q\\xrightarrow{i+2}R</span> exists in the graph and the adversary asks either <span class="math">E_{K_{i}}(R)</span> or <span class="math">E_{K_{i}}^{-1}(P)</span>, where the indicated addition is modulo 3. Note that <span class="math">D_{S}</span> has an explicit Finalize procedure, indicating we will be interested in the game output rather than the adversary output.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Lemma 5</h6>

    <p class="text-gray-300">Let <span class="math">A</span> be an adversary that makes at most <span class="math">q</span> queries. Then there is a permutation <span class="math">S\\in\\mathrm{Perm}(n)</span> and a simplified adversary <span class="math">B</span> making at most <span class="math">q</span> queries such that <span class="math">\\mathbf{Adv}^{\\mathrm{eee}}_{k,n}(A)</span> is at most</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}(D_{S}^{B},R_{3}^{B})+\\Pr\\big{[}\\,D_{S}^{B}\\text{ sets }x2ch\\;\\big{]}+\\Pr\\big{[}\\,R_{3}^{B}\\text{ sets }x2ch\\;\\big{]}+\\frac{6}{2^{k}}\\;.</span></p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">|  procedure Initialize K0,K1,K2←{0,1}k, E←Bloc(k,n), T←Perm(n), T←EK2○EK1○EK0  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return T[P]</td>

            <td class="px-3 py-2 border-b border-gray-700">return T-1[S]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure E(K,X)</td>

            <td class="px-3 py-2 border-b border-gray-700">procedure E-1(K,Y)</td>

            <td class="px-3 py-2 border-b border-gray-700">Game R0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return EK[X]</td>

            <td class="px-3 py-2 border-b border-gray-700">return EK-1[Y]</td>

            <td class="px-3 py-2 border-b border-gray-700">Game C0</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  procedure Initialize (K0,K1,K2)←Distinct3k, E←Bloc(k,n), T←Perm(n), EK2←T○EK0○EK1  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">procedure T(P)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">procedure T-1(S)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure E(K,X)</td>

            <td class="px-3 py-2 border-b border-gray-700">procedure E-1(K,Y)</td>

            <td class="px-3 py-2 border-b border-gray-700">Game R1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return EK[X]</td>

            <td class="px-3 py-2 border-b border-gray-700">return EK-1[Y]</td>

            <td class="px-3 py-2 border-b border-gray-700">Game C1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  procedure Initialize (K0,K1,K2)←Distinct3k, E←Bloc(k,n), EK2←T○EK0○EK1  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">procedure E(K,X)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">procedure E-1(K,Y)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game R2</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  procedure Initialize (K0,K1,K2)←Distinct3k, E←Bloc(k,n), EK2←S○EK0○EK1  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">procedure E(K,X)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">if ∃i∈{0,1,2} such that K=Ki then Q←EKi+2[X], P←EKi+1[Q]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game R3</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Add arc X i→EK[X] |  |   |</p>

    <p class="text-gray-300">|  return EK[X] |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">procedure E-1(K,Y)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">procedure Finalize(out)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  if Yi+1Q i+2R then x2ch ← true |  |   |</p>

    <p class="text-gray-300">|  Add arc EK-1[Y] i→Y |  |   |</p>

    <p class="text-gray-300">|  return EK-1[Y] |  |   |</p>

    <p class="text-gray-300">Figure 4: The  <span class="math">C_X</span>  or  <span class="math">D_X</span>  games include the boxed statements while the  <span class="math">R_i</span>  games do not.</p>

    <p class="text-gray-300">Proof of Lemma 5: Game  <span class="math">C_0</span>  defines  <span class="math">T</span>  as  <span class="math">E_{K_2} \\circ E_{K_1} \\circ E_{K_0}</span>  while game  <span class="math">C_1</span>  defines  <span class="math">E_{K_2}</span>  as  <span class="math">T \\circ E_{K_0}^{-1} \\circ E_{K_1}^{-1}</span> . However, these processes are identical. With this factored out, the difference between  <span class="math">C_1</span>  and  <span class="math">C_0</span>  is that the former draws the keys  <span class="math">K_0, K_1, K_2</span>  from  <span class="math">\\mathrm{Distinct}_3^k</span>  while the latter draws them from  <span class="math">(\\{0,1\\}^k)^3</span> . Games  <span class="math">R_1</span>  and  <span class="math">R_0</span>  differ in only the latter way. So using (4) we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {k, n} ^ {\\mathrm {e e e}} (A) = \\mathbf {A d v} (A _ {0} ^ {C}, A _ {0} ^ {R}) \\leq \\mathbf {A d v} (A _ {1} ^ {C}, A _ {1} ^ {R}) + \\frac {6}{2 ^ {k}}.</span></div>

    <p class="text-gray-300">Game  <span class="math">C_T</span>  is parameterized by a permutation  <span class="math">T \\in \\mathrm{Perm}(n)</span> . For any such  <span class="math">T</span>  we consider an adversary  <span class="math">A_T</span>  that has  <span class="math">T</span>  hardwired in its code and is simplified, meaning can make queries  <span class="math">E(K, X)</span>  and  <span class="math">E^{-1}(K, Y)</span>  only. This adversary runs  <span class="math">A</span> , answering the latter's  <span class="math">E(K, X)</span>  and  <span class="math">E^{-1}(K, Y)</span>  queries</p>

    <p class="text-gray-300">via its own oracles, and answering <span class="math">\\mathbf{T}(X)</span> and <span class="math">\\mathbf{T^{-1}}(Y)</span> queries using <span class="math">T</span>. Note that <span class="math">A_{T}</span> makes at most <span class="math">q</span> oracle queries. Choose <span class="math">S\\in\\mathrm{Perm}(n)</span> such that <span class="math">\\mathbf{Adv}(A_{S}^{C_{S}},A_{S}^{R_{2}})</span> is the maximum over all <span class="math">T\\in\\mathrm{Perm}(n)</span> of <span class="math">\\mathbf{Adv}(A_{T}^{C_{T}},A_{T}^{R_{2}})</span> and let <span class="math">B=A_{S}</span>. We now have <span class="math">\\mathbf{Adv}(A_{1}^{C},A_{1}^{R})\\leq\\mathbf{Adv}(B_{S}^{C},B_{2}^{R})</span>. Now by (5) we have</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}(B_{S}^{C},B_{2}^{R})\\leq\\mathbf{Adv}(C_{S}^{B},D_{S}^{B})+\\mathbf{Adv}(D_{S}^{B},R_{3}^{B})+\\mathbf{Adv}(R_{3}^{B},R_{2}^{B})\\;.</span></p>

    <p class="text-gray-300">Game <span class="math">C_{S}</span> (resp. game <span class="math">R_{2}</span>) can be easily transformed into an equivalent game such that this game and game <span class="math">D_{S}</span> (resp. <span class="math">R_{3}</span>) are identical-until-<span class="math">x2ch</span>, so by the Fundamental Lemma we have <span class="math">\\mathbf{Adv}(C_{S}^{B},D_{S}^{B})\\leq\\mathrm{Pr}[D_{S}^{B}\\text{ sets }x2ch\\,]</span> and <span class="math">\\mathbf{Adv}(R_{3}^{B},R_{2}^{B})\\leq\\mathrm{Pr}[R_{3}^{B}\\text{ sets }x2ch\\,]</span>. Putting all this together completes the lemma’s proof.</p>

    <p class="text-gray-300">Letting <span class="math">p=\\mathrm{Pr}\\left[\\,R_{3}^{B}\\text{ sets }x2ch\\,\\,\\right]</span>, we now need to bound</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}(D_{S}^{B},R_{3}^{B})+(\\mathrm{Pr}\\left[\\,D_{S}^{B}\\text{ sets }x2ch\\,\\,\\right]-p)+2p\\;.</span> (11)</p>

    <p class="text-gray-300">We will be able to bound the first two terms by bounding the advantages of a pair <span class="math">B_{1},B_{2}</span> of adversaries, related to <span class="math">B</span>, in distinguishing between a pair of games that involve only three permutation oracles, the first two random, and the third either random or correlated to the first two. We will bound <span class="math">p</span> separately via a combinatorial argument. We now state the lemmas we need, conclude the proof of Theorem 4 using them in Section 4.6, and then return to provide the proofs of the two lemmas.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">4.4 Pseudorandomness of three correlated permutations</h3>

    <p class="text-gray-300">We posit a new problem. Consider games <span class="math">G</span> and <span class="math">H_{S}</span>, for <span class="math">S\\in\\mathrm{Perm}(n)</span>, defined in Figure 5. Game <span class="math">G</span> grows an edge-labeled graph, which we shall describe shortly. An adversary may make queries <span class="math">\\mathbf{\\Pi}(i,X)</span> or <span class="math">\\mathbf{\\Pi^{-1}}(i,Y)</span> where <span class="math">i\\in\\{0,1,2\\}</span> and <span class="math">X,Y\\in\\{0,1\\}^{n}</span>. The oracles realize three permutations and their inverses, the function realized by <span class="math">\\mathbf{\\Pi^{-1}}(i,\\cdot\\,)</span> being the inverse of that realized by <span class="math">\\mathbf{\\Pi}(i,\\cdot\\,)</span>. In both games permutations <span class="math">\\pi_{0},\\pi_{1}</span> underlying <span class="math">\\mathbf{\\Pi}(0,\\cdot\\,)</span> and <span class="math">\\mathbf{\\Pi}(1,\\cdot\\,)</span> are uniform and independent. In game <span class="math">G</span> the permutation <span class="math">\\pi_{2}</span> underlying <span class="math">\\mathbf{\\Pi}(2,\\cdot\\,)</span> is also uniform and independent of <span class="math">\\pi_{0}</span> and <span class="math">\\pi_{1}</span>, but in game <span class="math">H_{S}</span> it is equal to <span class="math">S\\circ\\pi_{0}^{-1}\\circ\\pi_{1}^{-1}</span>.</p>

    <p class="text-gray-300">Notice that it is easy for an adversary to distinguish between games <span class="math">G</span> and <span class="math">H_{S}</span> by making queries that form a “chain” of length three: for any <span class="math">P\\in\\{0,1\\}^{n}</span>, let the adversary ask and be given <span class="math">Q\\leftarrow\\pi_{0}(P)</span>, then <span class="math">R\\leftarrow\\pi_{1}(Q)</span>, then <span class="math">P^{\\prime}\\leftarrow\\pi_{2}(R)</span>, and then have the adversary output <span class="math">1</span> if <span class="math">P=P^{\\prime}</span> (a “triangle” has been found) or <span class="math">0</span> if <span class="math">P\\neq P^{\\prime}</span> (the “three-chain” is not in fact a triangle). What we will establish is that, apart from such behavior—extending a known “2-chain”—the adversary is not able to gain much advantage. To capture this, as the adversary <span class="math">A</span> makes its queries and gets replies, the games grow an (initially without edges) edge-labeled directed graph <span class="math">\\mathcal{G}</span> with vertex set <span class="math">\\{0,1\\}^{n}</span>. An arc <span class="math">X{\\overset{i}{\\longrightarrow}}Y</span> is created when a query <span class="math">\\mathbf{\\Pi}(i,X)</span> returns the value <span class="math">Y</span> or a query <span class="math">\\mathbf{\\Pi^{-1}}(i,Y)</span> returns the value <span class="math">X</span>. The boolean flag <span class="math">x2ch</span> is set in the games if the adversary extends a 2-chain, meaning that a path <span class="math">P{\\overset{i+1}{\\longrightarrow}}Q{\\overset{i+2}{\\longrightarrow}}R</span> exists in the graph and the adversary asks either <span class="math">\\mathbf{\\Pi}(i,R)</span> or <span class="math">\\mathbf{\\Pi^{-1}}(i,P)</span>, where the indicated addition is modulo <span class="math">3</span>. We will be interested in the game outputs rather than the adversary outputs. Again using a game-based proof, we prove the following in Section 4.7:</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Lemma 6</h6>

    <p class="text-gray-300">Fix <span class="math">S\\in\\mathrm{Perm}(n)</span>. If <span class="math">\\mathrm{Pr}\\left[\\,B^{G}\\text{ makes}\\geq h\\text{ oracle queries}\\,\\right]\\leq\\delta</span> then <span class="math">\\mathbf{Adv}(H_{S}^{B},G^{B})\\ \\leq 2.5\\,h^{2}/2^{n}+\\delta</span>.</p>

    <p class="text-gray-300">We remark that the lemma makes no (explicit) assumption about the probability that <span class="math">B^{H}</span> makes <span class="math">h</span> or more oracle queries.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 5: Game  <span class="math">H</span>  includes the boxed statement, game  <span class="math">G</span>  does not.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 6: Game  <span class="math">L</span>  captures improbability of making three chains.</p>

    <p class="text-gray-300">Consider an adversary  <span class="math">B</span>  that can make  <span class="math">\\pmb{E}(K, X)</span>  or  <span class="math">\\pmb{E}^{-1}(K, Y)</span>  queries. Game  <span class="math">L</span>  of Figure 5 implements the oracles as a random blockcipher and its inverse, respectively, but samples these lazily, defining points as they are needed. Write  <span class="math">X \\xrightarrow{K} Y</span>  to mean that that  <span class="math">B</span>  has made query  <span class="math">\\pmb{E}(K, X)</span>  and obtained  <span class="math">Y</span>  as a result, or made query  <span class="math">\\pmb{E}^{-1}(K, Y)</span>  and obtained  <span class="math">X</span>  as a result, for  <span class="math">K \\in \\{0, 1\\}^k</span>  and  <span class="math">X, Y \\in \\{0, 1\\}^n</span> . The Finalize procedure picks keys  <span class="math">K_0, K_1, K_2</span>  at random, and sets bad if the adversary's queries have formed a three chain, meaning that there exist points  <span class="math">P, Q, R, S \\in \\{0, 1\\}^n</span>  such that  <span class="math">P \\xrightarrow{K_0} Q \\xrightarrow{K_1} R \\xrightarrow{K_2} S</span> : the conditional which is the last line of Finalize means that there is a  <span class="math">P</span>  for which  <span class="math">E_{K_0}[P]</span>  is defined and  <span class="math">E_{K_1}[E_{K_0}[P]]</span>  is defined and  <span class="math">E_{K_2}[E_{K_1}[E_{K_0}[P]]]</span>  is defined. Our next lemma bounds the probability of this happening. The proof is in Section 4.8.</p>

    <p class="text-gray-300">Lemma 7 Let  <span class="math">k, n \\geq 1</span> . Let  <span class="math">B</span>  be an adversary that asks at most  <span class="math">q</span>  queries. Let  <span class="math">\\alpha = \\max(2e2^{k - n}, 2n + k)</span> . Then  <span class="math">\\operatorname{Pr}[B^L \\text{ sets bad}] &amp;lt; 2\\alpha q^2 / 2^{3k}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">B</span>  be a simplified adversary and  <span class="math">S \\in \\mathrm{Perm}(n)</span>  a permutation. We associate to  <span class="math">B, S</span>  a pair of adversaries  <span class="math">B_{S,1}</span>  and  <span class="math">B_{S,2}</span>  that make  <span class="math">\\Pi(i, X)</span>  or  <span class="math">\\Pi^{-1}(i, Y)</span>  queries, where  <span class="math">i \\in \\{0, 1, 2\\}</span>  and  <span class="math">X, Y \\in \\{0, 1\\}^n</span> , as follows. For  <span class="math">b \\in \\{1, 2\\}</span> , adversary  <span class="math">B_{S,b}</span>  picks  <span class="math">(K_0, K_1, K_2)</span>  at random from  <span class="math">\\mathrm{Distinct}_3^k</span>  and picks  <span class="math">E</span>  at random from  <span class="math">\\mathrm{Bloc}(k, n)</span> . It then runs  <span class="math">B</span> , replying to its oracle queries as follows. If  <span class="math">B</span>  makes a query  <span class="math">E(K, X)</span> , adversary  <span class="math">B_{S,b}</span>  returns  <span class="math">E_K(X)</span>  if  <span class="math">K \\notin \\{K_0, K_1, K_2\\}</span>  and returns  <span class="math">\\Pi(i, X)</span>  if  <span class="math">K = K_i</span>  for  <span class="math">i \\in \\{0, 1, 2\\}</span> . Similarly, if  <span class="math">B</span>  makes a query  <span class="math">E^{-1}(K, Y)</span> , adversary  <span class="math">B_{S,b}</span>  returns  <span class="math">E_K^{-1}(Y)</span>  if  <span class="math">K \\notin \\{K_0, K_1, K_2\\}</span>  and returns  <span class="math">\\Pi^{-1}(i, Y)</span>  if  <span class="math">K = K_i</span>  for  <span class="math">i \\in \\{0, 1, 2\\}</span> . Adversaries  <span class="math">B_{S,1}, B_{S,2}</span>  differ only in their output, the first always returning 0 and the second returning the output out of  <span class="math">B</span> .</p>

    <p class="text-gray-300">Lemma 8 Let  <span class="math">B</span>  be a simplified adversary that makes at most  <span class="math">q</span>  oracle queries, and let  <span class="math">S \\in \\mathrm{Perm}(n)</span> . Let  <span class="math">B_{S,1}, B_{S,2}</span>  be defined as above. Let  <span class="math">K = 2^k</span> . Then for  <span class="math">b \\in \\{1,2\\}</span>  and any  <span class="math">c &amp;gt; 0</span> ,  <span class="math">\\operatorname*{Pr}[B_{S,b}^G \\text{makes} \\geq 3cq / K \\text{ oracle queries}] \\leq 1 / c</span> .</p>

    <p class="text-gray-300">Proof of Lemma 8: The oracles <span class="math">B</span> sees when it is run by <span class="math">B_{S,b}</span> are exactly a random block cipher and its inverse. (A random permutation composed with a fixed one is still random so the composition by <span class="math">S</span> does not change anything.) Now let <span class="math">X</span> be the random variable that is the number of queries by <span class="math">B</span> that involve keys <span class="math">K_0, K_1</span>, or <span class="math">K_2</span> in the experiment where we first run <span class="math">B</span> with oracles <span class="math">E, E^{-1}</span> for <span class="math">E \\stackrel{\\</span>}{\\leftarrow} \\operatorname{Bloc}(k, n)<span class="math"> and then pick </span>(K_0, K_1, K_2) \\stackrel{\\<span class="math">}{\\leftarrow} \\operatorname{Distinct}_3^k</span>. Then the probability that <span class="math">B_{S,b}^G</span> makes <span class="math">\\geq 3cq / K</span> oracle queries is exactly the probability that <span class="math">X \\geq 3cq / K</span>. Now assume wlog that <span class="math">B</span> always makes exactly <span class="math">q</span> distinct oracle queries rather than at most <span class="math">q</span>. Then</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf{E}[X] = q \\cdot \\left[ 1 - \\left(1 - \\frac{1}{K}\\right) \\left(1 - \\frac{1}{K - 1}\\right) \\left(1 - \\frac{1}{K - 2}\\right) \\right] \\\\ = q \\cdot \\left[ 1 - \\frac{K - 1}{K} \\frac{K - 2}{K - 1} \\frac{K - 3}{K - 2} \\right] = q \\cdot \\left[ 1 - \\frac{K - 3}{K} \\right] = \\frac{3q}{K}. \\end{array}</span></div>

    <p class="text-gray-300">We can conclude via Markov's inequality.</p>

    <p class="text-gray-300">Proof of Theorem 4: Let <span class="math">A</span> be an adversary against EEE that makes at most <span class="math">q</span> oracle queries. Let <span class="math">B</span> be the simplified adversary, and <span class="math">S</span> the permutation, given by Lemma 5, and let <span class="math">p = \\operatorname*{Pr}\\left[R_3^B\\text{ sets } x2ch\\right]</span>. Let <span class="math">B_{S,1}, B_{S,2}</span> be the adversaries associated to <span class="math">B</span> as described above. Note that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ D_S^B \\text{ sets } x2ch \\right] = \\Pr \\left[ H_S^{B_{S,1}} \\Rightarrow 1 \\right] \\quad \\text{and} \\quad \\Pr \\left[ R_3^B \\text{ sets } x2ch \\right] = \\Pr \\left[ G^{B_{S,1}} \\Rightarrow 1 \\right] \\tag{12} \\\\ \\Pr \\left[ D_S^B \\Rightarrow 1 \\right] = \\Pr \\left[ H_S^{B_{S,2}} \\Rightarrow 1 \\right] \\quad \\text{and} \\quad \\Pr \\left[ R_3^B \\Rightarrow 1 \\right] = \\Pr \\left[ G^{B_{S,2}} \\Rightarrow 1 \\right]. \\end{array}</span></div>

    <p class="text-gray-300">Combining (11) and (12) we have:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Adv}_{k,n}^{\\mathrm{eee}}(A) \\leq 2p + \\mathbf{Adv}(H_S^{B_{S,1}}, G^{B_{S,1}}) + \\mathbf{Adv}(H_S^{B_{S,2}}, G^{B_{S,2}}) + \\frac{6}{2^k}. \\tag{13}</span></div>

    <p class="text-gray-300">Let <span class="math">\\alpha = \\max(2e2^{k - n}, 2n + k)</span> and let <span class="math">c</span> be any positive real number. Since the probability that <span class="math">R_3^B</span> extends a 2-chain is at most three times the probability that <span class="math">L^B</span> forms a 3-chain we have</p>

    <div class="my-4 text-center"><span class="math-block">p \\leq 3 \\cdot 2^{-k} + 3 \\cdot \\Pr \\left[ B^L \\text{ sets } bad \\right]. \\tag{14}</span></div>

    <p class="text-gray-300">The first term is because <span class="math">L</span> picks the keys <span class="math">K_0, K_1, K_2</span> independently at random while <span class="math">R_3</span> picks them from <span class="math">\\mathrm{Distinct}_3^k</span>. The factor of three in the second term accounts for the fact that game <span class="math">L</span> fixes the order of the permutations in the chain as <span class="math">E_{K_2} \\circ E_{K_1} \\circ E_{K_0}</span> whereas game <span class="math">R_3</span> considers all three rotations of these permutations, <span class="math">E_{K_{i+2}} \\circ E_{K_{i+1}} \\circ E_{K_i}</span>. Applying Lemma 7 we get <span class="math">p \\leq 3 \\cdot 2^{-k} + 6\\alpha q^2 \\cdot 2^{-3k}</span>. Applying Lemma 6 in conjunction with Lemma 8 we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Adv}(H^{B_{S,b}}, G^{B_{S,b}}) \\leq \\frac{2.5}{2^n} \\left(\\frac{3cq}{2^k}\\right)^2 + \\frac{1}{c}</span></div>

    <p class="text-gray-300">for both <span class="math">b = 1</span> and <span class="math">b = 2</span>. Putting everything together we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Adv}_{k,n}^{\\mathrm{eee}}(A) \\leq 2 \\left(\\frac{3}{2^k} + 6\\alpha \\frac{q^2}{2^{3k}}\\right) + \\frac{5}{2^n} \\left(\\frac{3cq}{2^k}\\right)^2 + \\frac{2}{c} + \\frac{6}{2^k}.</span></div>

    <p class="text-gray-300">Now, since the above is true for any <span class="math">c &amp;gt; 0</span>, we pick a particular one that minimizes the function <span class="math">f(c) = 45c^2q^22^{-n - 2k} + 2c^{-1}</span>. The derivative is <span class="math">f&#x27;(c) = 90cq^22^{-n - 2k} - 2c^{-2}</span>, and the only real root of the equation <span class="math">f&#x27;(c) = 0</span> is <span class="math">c = (2^{n + 2k} / 45q^2)^{1/3}</span>, for which we have <span class="math">f(c) = 3(45q^2 / 2^{n + 2k})^{1/3}</span>. Plugging this into the above yields (10) and concludes the proof of Theorem 4.</p>

    <h2 id="sec-17" class="text-2xl font-bold">4.7 Proof of Lemma 6</h2>

    <p class="text-gray-300">We prove Lemma 6 as a corollary of:</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Lemma 9</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix <span class="math">S\\in\\mathrm{Perm}(n)</span>. If <span class="math">A</span> asks at most <span class="math">q</span> queries then $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Adv}(G^{A},H^{A}_{S})\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2.5\\,q^{2}/2^{n}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof of Lemma 6: We construct an adversary <span class="math">A</span> that has the same oracles as <span class="math">B</span>. Adversary <span class="math">A</span> runs <span class="math">B</span>, answering <span class="math">B</span>’s oracle queries via its own oracles. It also keeps track of the number of oracle queries that <span class="math">B</span> makes. If this number hits <span class="math">h</span>, it stops and outputs <span class="math">1</span>; else it outputs whatever <span class="math">B</span> outputs. Then we note that <span class="math">\\Pr[H^{B}_{S}\\Rightarrow 1]\\leq\\Pr[H^{A}_{S}\\Rightarrow 1]</span> and <span class="math">\\Pr[G^{A}\\Rightarrow 1]\\leq\\Pr[G^{B}\\Rightarrow 1]+\\delta</span>. Thus we have</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}(H^{B}_{S},G^{B})</span> <span class="math">=</span> <span class="math">\\Pr[H^{B}_{S}\\Rightarrow 1]-\\Pr[G^{B}\\Rightarrow 1]</span> <span class="math">\\leq</span> <span class="math">\\Pr[H^{A}_{S}\\Rightarrow 1]-\\left(\\Pr[G^{A}\\Rightarrow 1]-\\delta\\right)</span> <span class="math">=</span> <span class="math">\\mathbf{Adv}(H^{A}_{S},G^{A})+\\delta\\;.</span></p>

    <p class="text-gray-300">As <span class="math">A</span> makes <span class="math">\\leq h</span> queries, conclude by applying Lemma 9 to <span class="math">A</span> with <span class="math">q=h</span>.</p>

    <p class="text-gray-300">Proof of Lemma 9: We assume that the adversary <span class="math">A</span> never repeats a query, never asks a query <span class="math">\\mathbf{\\Pi^{-1}}(i,Y)</span> having asked some <span class="math">\\mathbf{\\Pi}(i,X)</span> that returned <span class="math">Y</span>, and never asks a query <span class="math">\\mathbf{\\Pi}(i,X)</span> having asked some <span class="math">\\mathbf{\\Pi^{-1}}(i,Y)</span> that returned <span class="math">X</span>. Call an adversary <em>valid</em> if it never extends a two-chain.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We begin by noting that to bound <span class="math">A</span>’s advantage in distinguishing games <span class="math">G</span> and <span class="math">H</span> we may assume that <span class="math">A</span> is valid. Why? Because for any adversary <span class="math">A^{<em>}</span> making at most <span class="math">q_{0}</span> queries there exists a valid <span class="math">A</span> that makes at most <span class="math">q_{0}</span> queries and the advantage of <span class="math">A</span> is at least that of <span class="math">A^{</em>}</span>. Adversary <span class="math">A</span> runs <span class="math">A^{<em>}</span>, answering <span class="math">A^{</em>}</span>’s oracle queries via its own oracles, but at any point that <span class="math">A^{*}</span> would extend a two chain, adversary <span class="math">A</span> simply halts and outputs <span class="math">1</span>. So now assuming <span class="math">A</span>’s validity, our task is to show that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Adv}(A^{G}_{1},A^{H}_{1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2.5\\,q^{2}/2^{n}<span class="math"> where the games </span>G_{1},H_{1}<span class="math"> are shown in Figure 7. We show that games </span>G_{1}<span class="math"> and </span>H_{1}<span class="math"> are close by showing that both are close to game </span>G_{3}<span class="math"> (defined in the same figure). First, we claim that </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Adv}(A^{G}_{1},A^{G}_{3})\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 0.5\\,q^{2}/N<span class="math"> where, here and in the rest of this proof, </span>N=2^{n}<span class="math">. Rewrite game </span>G_{1}<span class="math"> to game </span>G_{1.5}<span class="math"> (not shown) by lazily growing </span>\\pi_{0},\\pi_{1},\\pi_{2}<span class="math">, setting the flag <em>bad</em> whenever there is a collision; that is, game </span>G_{1.5}<span class="math"> is identical to game </span>G_{2}<span class="math"> except, after setting <em>bad</em> at line </span>211<span class="math">, set </span>Y\\stackrel{{\\scriptstyle\\sharp}}{{\\leftarrow}}\\overline{\\mathrm{image}}(\\pi_{i})<span class="math">, and after setting <em>bad</em> at line </span>221<span class="math">, set </span>X\\stackrel{{\\scriptstyle\\sharp}}{{\\leftarrow}}\\overline{\\mathrm{domain}}(\\pi_{i})<span class="math">. Then modify game </span>G_{1.5}<span class="math"> to <em>not</em> re-sample after setting <em>bad</em>, obtaining game </span>G_{2}<span class="math">. Now </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Adv}(A^{G}_{1},A^{G}_{3})\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Adv}(A^{G}_{1.5},A^{G}_{3})\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Adv}(A^{G}_{1.5},A^{G}_{2})\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[A^{G}_{2}\\text{ sets }bad\\,]<span class="math">. Then note that on the </span>i^{\\mathrm{th}}<span class="math"> query the probability that <em>bad</em> will be set in game </span>G_{2}<span class="math"> is at most </span>(i-1)/N<span class="math"> since the size of </span>\\mathrm{domain}(\\pi_{j})<span class="math"> and </span>\\mathrm{image}(\\pi_{j})<span class="math"> will be at most </span>i-1<span class="math"> for each </span>j\\in\\{0,1,2\\}<span class="math">. So over all </span>q<span class="math"> queries, the probability that <em>bad</em> ever gets set in game </span>G_{2}<span class="math"> is at most </span>0.5q(q-1)/N\\leq 0.5q^{2}/N$. To establish Lemma 9 we now claim that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Adv}(A^{H}_{1},A^{G}_{3})\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> </span>\\leq<span class="math"> </span>2\\,q^{2}/N\\;.$ (15)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">First rewrite game <span class="math">H_{1}</span> as game <span class="math">G_{4}</span> (again in Figure 7). In the game we have written <span class="math">S_{0}=S_{1}=\\mathsf{id}</span> and <span class="math">S_{2}=S</span> where <span class="math">\\mathsf{id}</span> is the identity function on <span class="math">\\{0,1\\}^{n}</span> and <span class="math">S</span> is the fixed permutation in the lemma statement. Addition (<span class="math">+1</span> and <span class="math">+2</span>) is again understood to be modulo <span class="math">3</span>. Game <span class="math">G_{4}</span> uses a form of lazy sampling, but it is not maximally lazy; on each query, not only is its answer chosen, but answers for some related queries are chosen and stored. In particular, the game maintains a set <span class="math">\\mathcal{C}</span> of <em>commitments</em>. Initially there are no commitments, but every time a query <span class="math">\\mathbf{\\Pi}(i,X)</span> or <span class="math">\\mathbf{\\Pi^{-1}}(i,Y)</span> is asked, one of two things happens: if a commitment has already been made specifying how to answer this query, we answer according to that commitment; else we not only answer the query asked, but commit ourselves to all of the queries in a “triangle” containing the queried point. In greater detail, <span class="math">(i,X,Y)\\in\\mathcal{C}</span> (for <span class="math">i\\in\\{0,1,2\\}</span> and <span class="math">X,Y\\in\\{0,1\\}^{n}</span>) means that it has already been decided that <span class="math">\\pi_{i}(X)=Y</span>, so a forward query <span class="math">\\mathbf{\\Pi}(i,X)</span> will need to be answered by <span class="math">Y</span> and a backward</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">procedure Initialize</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game G1</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">π0, π1, π2←* Perm(n),</td>

            <td class="px-3 py-2 border-b border-gray-700">π2← S o π0-1 o π1-1</td>

            <td class="px-3 py-2 border-b border-gray-700">Game H1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure Π(i, X)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure Π-1(i, Y)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">110</td>

            <td class="px-3 py-2 border-b border-gray-700">return πi[X]</td>

            <td class="px-3 py-2 border-b border-gray-700">120 return πi-1[Y]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure Π(i, X)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure Π-1(i, Y)</td>

            <td class="px-3 py-2 border-b border-gray-700">Game G2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">210</td>

            <td class="px-3 py-2 border-b border-gray-700">Y←{0,1}n</td>

            <td class="px-3 py-2 border-b border-gray-700">220 X←{0,1}n</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">211</td>

            <td class="px-3 py-2 border-b border-gray-700">if Y ∈ image(πi) then bad ← true</td>

            <td class="px-3 py-2 border-b border-gray-700">221 if X ∈ domain(πi) then bad ← true</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">213</td>

            <td class="px-3 py-2 border-b border-gray-700">π[X] ← Y</td>

            <td class="px-3 py-2 border-b border-gray-700">223 π[X] ← Y</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">214</td>

            <td class="px-3 py-2 border-b border-gray-700">return Y</td>

            <td class="px-3 py-2 border-b border-gray-700">224 return X</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure Π(i, X)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure Π-1(i, Y)</td>

            <td class="px-3 py-2 border-b border-gray-700">Game G3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">310</td>

            <td class="px-3 py-2 border-b border-gray-700">return Y←{0,1}n</td>

            <td class="px-3 py-2 border-b border-gray-700">320 return X←{0,1}n</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure Π(i,X)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Game G4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">410</td>

            <td class="px-3 py-2 border-b border-gray-700">if ∃ (i,X,Y) ∈ C then return Y</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">411</td>

            <td class="px-3 py-2 border-b border-gray-700">Xi← X</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">412</td>

            <td class="px-3 py-2 border-b border-gray-700">Xi+1←{0,1}n, if Xi+1 ∈ Di+1 then bad ← true, Xi+1←{0,1}n \\ Si+1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">413</td>

            <td class="px-3 py-2 border-b border-gray-700">Xi+2←{0,1}n, if Xi+2 ∈ Di+2 then bad ← true, Xi+2←{0,1}n \\ Si+2</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">414</td>

            <td class="px-3 py-2 border-b border-gray-700">Di← Di∪{Xi}, Di+1 ← Di+1 ∪ {Xi+1}, Di+2 ← Di+2 ∪ {Xi+2}</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">415</td>

            <td class="px-3 py-2 border-b border-gray-700">C← C∪{(i, Xi, Si(Xi+1)), (i+1, Xi+1, Si+1(Xi+2)), (i+2, Xi+2, Si+2(Xi))}</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">416</td>

            <td class="px-3 py-2 border-b border-gray-700">return Si(Xi+1)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  procedure Π-1(i,Y) |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">420</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">if ∃ (i,X,Y) ∈ C then return X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">422</td>

            <td class="px-3 py-2 border-b border-gray-700">Xi←{0,1}n, if Xi ∈ Di+1 then bad ← true, Xi←{0,1}n \\ Si+1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">423</td>

            <td class="px-3 py-2 border-b border-gray-700">Xi+2←{0,1}n, if Xi+2 ∈ Di+2 then bad ← true, Xi+2←{0,1}n \\ Si+2</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">424</td>

            <td class="px-3 py-2 border-b border-gray-700">Di← Di∪{Xi}, Di+1 ← Di+1 ∪ {Xi+1}, Di+2 ← Di+2 ∪ {Xi+2}</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">425</td>

            <td class="px-3 py-2 border-b border-gray-700">C← C∪{(i, Xi, Si(Xi+1)), (i+1, Xi+1, Si+1(Xi+2)), (i+2, Xi+2, Si+2(Xi))}</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">426</td>

            <td class="px-3 py-2 border-b border-gray-700">return Si+2(Xi)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 7: Games for bounding the probability of distinguishing  <span class="math">(\\pi_0, \\pi_1, \\pi_2)</span>  and  <span class="math">(\\pi_0, \\pi_1, \\pi_1^{-1} \\circ \\pi_0^{-1})</span>  by an adversary that never extends a two-chain.</p>

    <p class="text-gray-300">query  <span class="math">\\Pi^{-1}(i,Y)</span>  will need to be answered by  <span class="math">X</span> . In effect, we grow permutations  <span class="math">\\pi_0</span> ,  <span class="math">\\pi_1</span> , and  <span class="math">\\pi_2</span>  but store their values in  <span class="math">\\mathcal{C}</span>  and their domains in  <span class="math">D_0, D_1</span> , and  <span class="math">D_2</span> .</p>

    <p class="text-gray-300">We claim that games  <span class="math">H_{1}</span>  and  <span class="math">G_{4}</span>  are adversarially indistinguishable even by an adversary that is not valid and asks all  <span class="math">6N</span>  possible queries. From this we know that  <span class="math">\\operatorname{Pr}[A_4^G \\Rightarrow 1] = \\operatorname{Pr}[A^{H_1} \\Rightarrow 1]</span> . To show this equivalence we claim that whether the queries are answered by game  <span class="math">G_{4}</span>  or by game  <span class="math">H_{1}</span>  the adversary gets the same view: any of  <span class="math">(N!)^2</span>  possible outcomes, each with probability  <span class="math">1 / (N!)^2</span> , the answers correspond to a pair of permutations  <span class="math">\\pi_0, \\pi_1</span>  along with  <span class="math">\\pi_2 = \\pi_0^{-1} \\circ \\pi_1^{-1}</span> . This is obviously the case when playing game  <span class="math">H_{1}</span> ; we must show it is so for game  <span class="math">G_{4}</span> . Note that sets  <span class="math">D_0, D_1, D_2</span> , and  <span class="math">\\mathcal{C}</span>  begin with no points in them, then they grow to 1, 1, 1, and 3 points; then to 2, 2, 2, and 6 points; and so forth, until they have  <span class="math">N, N, N</span> , and  <span class="math">3N</span>  points. Not every query changes the sizes of these sets; it either leaves the sets unaltered or changes them as indicated. The first query that augments  <span class="math">\\mathcal{C}</span>  extends the partial functions  <span class="math">(\\pi_0, \\pi_1, \\pi_2)</span>  in any of  <span class="math">N^2</span>  different ways, each with the same probability; the second query that augments  <span class="math">\\mathcal{C}</span>  extends  <span class="math">(\\pi_0, \\pi_1, \\pi_2)</span>  in any of  <span class="math">(N - 1)^2</span>  different ways, each with the same probability; and so forth, until we have extended  <span class="math">(\\pi_0, \\pi_1, \\pi_2)</span>  in any of  <span class="math">(N!)^2</span>  different ways, each with the same probability. This establishes the claim.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 8: Game  <span class="math">G_{5}</span> .</p>

    <p class="text-gray-300">Now let us go back to assuming that the adversary is valid. We make a change to game  <span class="math">G_{4}</span>  to arrive at game  <span class="math">G_{5}</span> , shown in Figure 8. In the transition, we drop the first commitment from each group of three, since our assumptions about the adversary's behavior mean that these queries cannot be asked. We also drop the sequels to bad getting set at lines 412, 413, 422, and 423. More interestingly, in game  <span class="math">G_{5}</span>  we maintain a set of "poisoned" queries  <span class="math">\\mathcal{P}</span> . As with game  <span class="math">G_{4}</span> , when the adversary asks  <span class="math">\\Pi(i, X_{i})</span>  we return a random  <span class="math">X_{i+1}</span> , and when the adversary asks  <span class="math">\\Pi^{-1}(i, X_{i+1})</span>  we return a random  <span class="math">X_{i}</span> , and in either case we choose a random  <span class="math">X_{i+2}</span>  and "complete the triangle" using this point. We don't expect the adversary to ask about  <span class="math">X_{i+2}</span> , and, what is more, his asking will cause problems. So we record the unlikely but problematic queries involving  <span class="math">X_{i+2}</span>  in  <span class="math">\\mathcal{P}</span> . If the adversary makes a poisoned query then we set bad. The changes we have made can only increase the probability that bad gets set:  <span class="math">\\operatorname{Pr}[A^{G_{4}} \\text{ sets } bad] \\leq \\operatorname{Pr}[A^{G_{5}} \\text{ sets } bad]</span> .</p>

    <p class="text-gray-300">We claim that game  <span class="math">G_{5}</span>  is adversarially indistinguishable from game  <span class="math">G_{3}</span> . Remember that our adversary is valid: it does not ask queries whose answers are trivially known and it does not ask to extend any 2-chain. Suppose first that the adversary asks a query whose answer has not been memoized in a commitment. Then for a forward query, we choose a uniform value  <span class="math">X_{i+1}</span>  at line 514 and return it at line 519. Likewise for a backward query, we choose a uniform value  <span class="math">X_{i}</span>  at line 524 and return it at line 529. So consider instead a query for which a commitment has been memoized. The code executes at lines 511-512 or lines 521-522. If the memoized query was poisoned—added to set  <span class="math">\\mathcal{P}</span>  by an earlier execution of lines 518 or 528—then we return a random string (at line 511 or 521). If the memoized query was not poisoned, then we are extending a 1-chain, providing a value  <span class="math">X_{i+2}</span>  that was selected uniformly from  <span class="math">\\{0,1\\}^{n}</span>  at an earlier execution of line 515 or 525, with this value not yet having influenced the run. Thus we return a uniform random value, independent of all oracle responses so far, and  <span class="math">\\operatorname{Pr}[A^{G_{5}} \\Rightarrow 1] = \\operatorname{Pr}[A^{G_{3}} \\Rightarrow 1]</span> .</p>

    <p class="text-gray-300">Finally, we must bound the probability that bad gets set in game <span class="math">G_{5}</span>. The probability that bad ever gets set at any of lines 514, 515, 524, or 525 is at most <span class="math">2(1 + 2 + \\dots + (q - 1)) / N \\leq q^{2} / N</span>. The probability that it gets set at lines 511 or 521 is at most <span class="math">2(1 + 2 + \\dots + (q - 1)) / N</span> because no information about the poisoned query is surfaced to the adversary. Overall we have that <span class="math">\\operatorname{Pr}[A^{G_5} \\text{ sets } \\text{bad}] \\leq 2q^2 / N</span>. Putting everything together we have (15) and the proof of the lemma is complete.</p>

    <h2 id="sec-19" class="text-2xl font-bold">4.8 Proof of Lemma 7</h2>

    <p class="text-gray-300">To prove this lemma we can assume without loss of generality that <span class="math">B</span> is deterministic. For any particular blockcipher <span class="math">E \\in \\mathrm{Bloc}(k, n)</span> we consider the game in which <span class="math">B</span> is executed with oracles <span class="math">E, E^{-1}</span>, which it queries, adaptively, until it halts. Note that there is no randomness involved in this game, since <span class="math">E</span> is fixed and <span class="math">B</span> is deterministic. Recall that <span class="math">X \\xrightarrow{K} Y</span> means that <span class="math">B</span> has either made query <span class="math">E(K, X)</span> and obtained <span class="math">Y</span> as a result, or it has made query <span class="math">E^{-1}(K, Y)</span> and obtained <span class="math">X</span> as a result, for <span class="math">K \\in \\{0, 1\\}^k</span> and <span class="math">X, Y \\in \\{0, 1\\}^n</span>. Now we let</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {C h} _ {3} ^ {E, B} = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{\\left(K _ {0}, K _ {1}, K _ {2}, P\\right): \\exists Q, R, S \\left[ P \\xrightarrow {K _ {0}} Q \\xrightarrow {K _ {1}} R \\xrightarrow {K _ {2}} S \\right] \\right\\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">This is the number of 3-chains created by <span class="math">B</span>'s queries. Here <span class="math">K_0, K_1, K_2 \\in \\{0, 1\\}^k</span> are keys, and <span class="math">P, Q, R, S \\in \\{0, 1\\}^n</span>. As the notation indicates, <span class="math">\\mathsf{Ch}_3^{E,B}</span> is a number that depends on <span class="math">E</span> and <span class="math">B</span>. Regarding it as a random variable over the choice of <span class="math">E</span> we have the following lemma, from which Lemma 7 will follow.</p>

    <p class="text-gray-300"><strong>Lemma 10</strong> Let <span class="math">\\alpha = \\max (2e2^{k - n},2n + k)</span>. Then <span class="math">\\mathbf{E}[\\mathsf{Ch}_3^{E,B}] &amp;lt; 2\\alpha \\cdot q^2</span>, the expectation over <span class="math">E \\stackrel{\\</span>}{\\leftarrow} \\mathrm{Bloc}(k,n)$.</p>

    <p class="text-gray-300"><strong>Proof of Lemma 7:</strong> Consider the following game <span class="math">L^E</span> parameterized by a blockcipher <span class="math">E \\in \\mathrm{Bloc}(k, n)</span>: adversary <span class="math">B</span> is executed with oracles <span class="math">E, E^{-1}</span> until it halts, then <span class="math">K_0, K_1, K_2</span> are chosen at random from <span class="math">\\{0, 1\\}^k</span>, and flag bad is set if there exist <span class="math">P, Q, R, S</span> such that <span class="math">P \\xrightarrow{K_0} Q \\xrightarrow{K_1} R \\xrightarrow{K_2} S</span>. Let <span class="math">p^{E,B} = \\operatorname*{Pr}[L_B^E \\text{ sets } \\text{bad}]</span>, the probability being over the random choices of <span class="math">K_0, K_1, K_2</span>. Then for any <span class="math">E \\in \\mathrm{Bloc}(k, n)</span> we have</p>

    <p class="text-gray-300">$$ \\begin{array}{l} p ^ {E, B} = \\Pr \\left[ \\exists P, Q, R, S: P \\xrightarrow {K _ {0}} Q \\xrightarrow {K _ {1}} R \\xrightarrow {K _ {2}} S \\right] \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\frac {\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{\\left(K _ {0} , K _ {1} , K _ {2}\\right) : \\exists P , Q , R , S : P \\xrightarrow {K _ {0}} Q \\xrightarrow {K _ {1}} R \\xrightarrow {K _ {2}} S \\right\\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{2 ^ {3 k}} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">By Lemma 10 we have <span class="math">\\operatorname*{Pr}[B^L\\text{ sets } \\text{bad}] = \\mathbf{E}[p^{E,B}] \\leq \\mathbf{E}[\\mathsf{Ch}_3^{E,B}] \\cdot 2^{-3k} &amp;lt; 2\\alpha q^2 2^{-3k}</span> where <span class="math">\\alpha = \\max (2e2^{k - n}, 2n + k)</span> and the expectation is over <span class="math">E \\stackrel{\\</span>}{\\leftarrow} \\mathrm{Bloc}(k, n)$.</p>

    <p class="text-gray-300">Towards the proof of Lemma 10, for <span class="math">E \\in \\mathrm{Bloc}(k,n)</span> and <span class="math">Q,R \\in \\{0,1\\}^n</span> we let</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {K e y s} ^ {E} (Q, R) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{K: E (K, Q) = R \\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\quad \\text{and} \\quad \\mathsf {K e y s} ^ {E} = \\max _ {Q, R} \\{\\mathsf {K e y s} ^ {E} (Q, R) \\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The first is the number of keys for which <span class="math">Q</span> maps to <span class="math">R</span> under <span class="math">E</span>, and the second is the maximum value of <span class="math">\\mathsf{Keys}^E (Q,R)</span> over all <span class="math">Q,R\\in \\{0,1\\} ^n</span>. No adversary is involved in this definition; <span class="math">\\mathsf{Keys}^E</span> is simply a number associated to a given blockcipher. Viewing it as a random variable over the choice of blockcipher we have the following.</p>

    <p class="text-gray-300">Lemma 11 Suppose <span class="math">\\beta \\geq 2e2^{k - n}</span>. Then <span class="math">\\operatorname*{Pr}\\left[\\mathsf{Keys}^E\\geq \\beta \\right] &amp;lt; 2^{2n + 1 - \\beta}</span>, where the probability is over <span class="math">E\\stackrel {\\S}{\\leftarrow}\\operatorname {Bloc}(k,n)</span>.</p>

    <p class="text-gray-300">Proof of Lemma 11: We claim that for any <span class="math">Q,R\\in \\{0,1\\} ^n</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\operatorname {K e y s} ^ {E} (Q, R) \\geq \\beta \\right] &amp;lt;   2 ^ {1 - \\beta}. \\tag {16}</span></div>

    <p class="text-gray-300">The lemma follows via the union bound. We prove (16) using an occupancy-problem approach. Let <span class="math">b = \\lceil \\beta \\rceil</span>. Then</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\mathsf {K e y s} ^ {E} (Q, R) \\geq \\beta \\right] = \\sum_ {i = b} ^ {2 ^ {k}} \\binom {2 ^ {k}} {i} \\left(\\frac {1}{2 ^ {n}}\\right) ^ {i} \\left(1 - \\frac {1}{2 ^ {n}}\\right) ^ {2 ^ {k} - i} \\\\ \\leq \\sum_ {i = b} ^ {2 ^ {k}} \\left(\\frac {2 ^ {k} e}{i}\\right) ^ {i} \\left(\\frac {1}{2 ^ {n}}\\right) ^ {i} \\leq \\sum_ {i = b} ^ {2 ^ {k}} \\left(\\frac {2 ^ {k} e}{2 ^ {n} b}\\right) ^ {i}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Let <span class="math">x = (e / b)2^{k - n}</span>. The assumption <span class="math">\\beta \\geq 2e2^{k - n}</span> gives <span class="math">x \\leq 1 / 2</span>. So the above is</p>

    <div class="my-4 text-center"><span class="math-block">= \\sum_ {i = b} ^ {2 ^ {k}} x ^ {i} &amp;lt;   x ^ {b} \\cdot \\sum_ {i = 0} ^ {\\infty} x ^ {i} = \\frac {x ^ {b}}{1 - x} \\leq \\frac {2 ^ {- b}}{1 - 1 / 2} = 2 ^ {1 - b} \\leq 2 ^ {1 - \\beta}</span></div>

    <p class="text-gray-300">as desired.</p>

    <p class="text-gray-300">Proof of Lemma 10: For any <span class="math">Q, R \\in \\{0,1\\}^n</span> we let</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {C h} _ {2} ^ {E, B} (R) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{(K _ {0}, K _ {1}, P): \\exists Q [ P \\xrightarrow {K _ {0}} Q \\xrightarrow {K _ {1}} R ] \\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {C h} _ {1} ^ {E, B} (Q) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{(K _ {0}, P): P \\xrightarrow {K _ {0}} Q \\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {C h} _ {0} ^ {E, B} (R) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{K _ {2}: \\exists S [ R \\xrightarrow {K _ {2}} S ] \\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Then for any <span class="math">E \\in \\mathrm{Bloc}(k,n)</span> we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf {C h} _ {3} ^ {E, B} = \\sum_ {R} \\mathsf {C h} _ {2} ^ {E, B} (R) \\cdot \\mathsf {C h} _ {0} ^ {E, B} (R) \\\\ \\leq \\sum_ {R} \\left(\\sum_ {Q} \\operatorname {C h} _ {1} ^ {E, B} (Q) \\cdot \\operatorname {K e y s} ^ {E} (Q, R)\\right) \\cdot \\operatorname {C h} _ {0} ^ {E, B} (R) \\\\ \\leq \\sum_ {R} \\left(\\sum_ {Q} \\operatorname {C h} _ {1} ^ {E, B} (Q) \\cdot \\operatorname {K e y s} ^ {E}\\right) \\cdot \\operatorname {C h} _ {0} ^ {E, B} (R) \\\\ = \\operatorname {K e y s} ^ {E} \\cdot \\left(\\sum_ {Q} \\operatorname {C h} _ {1} ^ {E, B} (Q)\\right) \\cdot \\left(\\sum_ {R} \\operatorname {C h} _ {0} ^ {E, B} (R)\\right) \\\\ \\leq \\operatorname {K e y s} ^ {E} \\cdot q \\cdot q = q ^ {2} \\cdot \\operatorname {K e y s} ^ {E}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Using the above and Lemma 11, we have the following, where the probability and expectation are both over <span class="math">E \\stackrel{\\S}{\\leftarrow} \\operatorname{Bloc}(k,n)</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {E} \\left[ \\mathrm {C h} _ {3} ^ {E, B} \\right] &amp;lt;   \\mathbf {E} \\left[ \\mathrm {C h} _ {3} ^ {E, B} \\mid \\mathrm {K e y s} ^ {E} &amp;lt;   \\alpha \\right] + \\mathbf {E} \\left[ \\mathrm {C h} _ {3} ^ {E, B} \\mid \\mathrm {K e y s} ^ {E} \\geq \\alpha \\right] \\cdot 2 ^ {2 n + 1 - \\alpha} \\\\ \\leq q ^ {2} \\cdot \\alpha + q ^ {2} \\cdot 2 ^ {k} \\cdot 2 ^ {2 n + 1 - \\alpha}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The last inequality above used the fact that <span class="math">\\mathsf{Keys}^E</span> is always at most <span class="math">2^{k}</span>. Since <span class="math">\\alpha = \\max (2e2^{k - n}, 2n + k) &amp;gt; 2</span> we get <span class="math">\\mathbf{E}[\\mathsf{Ch}_3^{E,B}] &amp;lt; q^2\\alpha + q^2 \\cdot 2 &amp;lt; 2\\alpha \\cdot q^2</span> as desired.</p>

    <p class="text-gray-300">24</p>

    <p class="text-gray-300">5 Elementary Proof for the CBC MAC</p>

    <p class="text-gray-300">In this section we give a new proof for the security of the CBC MAC. Our proof is far simpler than the original one [5] or the recently devised one that offers an improved bound [7].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix <span class="math">n \\geq 1</span>. A block is a string of length <span class="math">n</span>, and <span class="math">M</span> is a string of blocks if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is divisible by </span>n<span class="math">. If </span>M \\in (\\{0,1\\}^n)^*<span class="math"> is a string of blocks we let </span>M_i = M[n(i-1) + 1..ni]<span class="math"> denote the </span>i^{\\text{th}}<span class="math"> block of </span>M<span class="math">. If </span>\\pi: \\{0,1\\}^n \\to \\{0,1\\}^n<span class="math"> is a function and </span>M \\in (\\{0,1\\}^n)^m<span class="math"> is a string of </span>n<span class="math">-bit blocks then we define </span>\\mathrm{CBC}_{\\pi}(M)<span class="math"> as the result of running the following algorithm: </span>C \\gets 0^n<span class="math">, for </span>i \\gets 1<span class="math"> to </span>m<span class="math"> do </span>C \\gets \\pi(C \\oplus M_i)<span class="math">; return </span>C<span class="math">. Let </span>\\mathrm{Perm}(n)<span class="math"> denote the set of all permutations on </span>\\{0,1\\}^n<span class="math"> and let </span>\\mathrm{Func}(mn,n)<span class="math"> denote the set of all functions from </span>\\{0,1\\}^{mn}<span class="math"> to </span>\\{0,1\\}^n<span class="math">. For </span>m \\geq 1<span class="math"> and </span>\\pi \\in \\mathrm{Perm}(n)<span class="math"> let </span>\\mathrm{CBC}_{\\pi}^m<span class="math"> be the restriction of </span>\\mathrm{CBC}_{\\pi}<span class="math"> to the domain </span>\\{0,1\\}^{mn}<span class="math">. Given an algorithm </span>A<span class="math"> that never repeats a query and asks queries that are strings of </span>n<span class="math">-bit blocks, the adversary having oracle-access to a function </span>F: \\{0,1\\}^{mn} \\to \\{0,1\\}^n$, let</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Adv}_{n,m}^{\\mathrm{cbc}}(A) = \\Pr\\left[\\pi \\stackrel{\\$}{\\leftarrow} \\mathrm{Perm}(n): A^{\\mathrm{CBC}_{\\pi}^{m}(\\cdot)} \\Rightarrow 1\\right] - \\Pr\\left[\\rho \\stackrel{\\$}{\\leftarrow} \\mathrm{Func}(mn,n): A^{\\rho(\\cdot)} \\Rightarrow 1\\right] \\text{ and}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Adv}_{n,m}^{\\mathrm{cbc}}(q) = \\max\\left\\{\\mathbf{Adv}_{n,m}^{\\mathrm{cbc}}(A)\\right\\}</span></div>

    <p class="text-gray-300">where, for the second definition, the maximum is over all adversaries <span class="math">A</span> that ask at most <span class="math">q</span> queries, regardless of oracle responses. To avoid working out uninteresting special cases, we assume throughout that <span class="math">q, m \\geq 2</span>. We will show the following using games followed by a simple case analysis.</p>

    <p class="text-gray-300">Theorem 12 [CBC MAC, conventional bound] <span class="math">\\mathbf{Adv}_{n,m}^{\\mathrm{cbc}}(q) \\leq m^{2}q^{2}/2^{n}</span> for any <span class="math">m, q \\geq 2</span>, <span class="math">n \\geq 1</span>.</p>

    <p class="text-gray-300">Proof: Without loss of generality assume that <span class="math">A</span> is deterministic and asks exactly <span class="math">q</span> queries of <span class="math">m</span> blocks each and that it never repeats a query. Refer to games <span class="math">C_0 - C_9</span> defined in Figures 9 and 10. Let us begin by explaining the conventions used in these games. When <span class="math">M</span> is string of blocks we write <span class="math">M_i</span> for the <span class="math">i^{th}</span> block of <span class="math">M</span>, as before, and we write <span class="math">M_{1..j} = M[1..jn]</span> for the first <span class="math">j</span> blocks. In writing <span class="math">\\overline{\\mathrm{domain}}(\\pi)</span> the complement is with respect to <span class="math">\\{0,1\\}^n</span>. The value defined is an arbitrary string (it is never used), for concreteness, <span class="math">0^n</span>. Finally, <span class="math">\\mathsf{Prefix}(M^1,\\ldots,M^s)</span> is the longest string of blocks <span class="math">P = P_1\\cdots P_p</span> that is a prefix of <span class="math">M^s</span> and is also a prefix of <span class="math">M^r</span> for some <span class="math">r &amp;lt; s</span>. If <span class="math">\\mathsf{Prefix}</span> is applied to a single string the result is the empty string, <span class="math">\\mathsf{Prefix}(P^1) = \\varepsilon</span>. As an example, letting A, B, and C be distinct blocks, <span class="math">\\mathsf{Prefix}(\\mathsf{ABC}) = \\varepsilon</span>, <span class="math">\\mathsf{Prefix}(\\mathsf{ACC}, \\mathsf{ACB}, \\mathsf{ABB}, \\mathsf{ABA}) = \\mathsf{AB}</span>, and <span class="math">\\mathsf{Prefix}(\\mathsf{ACC}, \\mathsf{ACB}, \\mathsf{BBB}) = \\varepsilon</span>.</p>

    <p class="text-gray-300">We briefly explain the game chain up until the terminal game. <span class="math">\\triangleright</span> Game <span class="math">C_0</span> is obtained from game <span class="math">C_1</span> by dropping the assignment statements that immediately follow the setting of <span class="math">bad</span>. <span class="math">\\triangleright</span> Game <span class="math">C_1</span> is a realization of <span class="math">\\mathsf{CBC}^m[\\mathrm{Perm}(n)]</span> and game <span class="math">C_0</span> is a realization of <span class="math">\\mathrm{Func}(mn,n)</span>. The games use lazy sampling of a random permutation (as described in Section 7.4) and the resampling idiom (as described in Section 7.2). Games <span class="math">C_1</span> and <span class="math">C_0</span> are designed so that the Fundamental Lemma applies, so the advantage of <span class="math">A</span> in attacking the CBC construction is at most <span class="math">\\operatorname<em>{Pr}[A^{\\mathrm{C}_0} \\text{ sets } bad]</span>. <span class="math">\\triangleright C_0 \\to C_2</span>: This is a lossy transition that takes care of <span class="math">bad</span> getting set at line 105, which clearly happens with probability at most <span class="math">(0 + 1 + \\dots + (mq - 1)) / 2^n \\leq 0.5m^2q^2 / 2^n</span>, so <span class="math">\\operatorname</em>{Pr}[A^{\\mathrm{C}_0} \\text{ sets } bad] \\leq \\operatorname*{Pr}[A^{\\mathrm{C}_2} \\text{ sets } bad] + 0.5m^2q^2 / 2^n</span>. <span class="math">\\triangleright C_2 \\to C_3</span>: Next notice that in game <span class="math">C_2</span> we never actually use the values assigned to <span class="math">\\pi</span>, all that matters is that we record that a value has been placed in the domain of <span class="math">\\pi</span>, and so game <span class="math">C_3</span> does just that, dropping a fixed value defined into <span class="math">\\pi[X]</span> when we want <span class="math">X</span> to join the domain of <span class="math">\\pi</span>. This is the technique we called "marking instead of recording" in Section 7.2. The change is conservative. <span class="math">\\triangleright C_3 \\to C_4</span>: Now notice that in game <span class="math">C_3</span> the value returned to the adversary, although dropped into <span class="math">T[M_1^s \\cdots M_m^s]</span>, is never subsequently used in the game so we could</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Initialize</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game C0</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">100 T[ε]←0n</td>

            <td class="px-3 py-2 border-b border-gray-700">[Game C1]</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  procedure F(M) |   |</p>

    <p class="text-gray-300">|  110 s←s+1, Ms←M |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">111 P←Prefix(M1,...,Ms), p←</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/n, C←T[P]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  112 for j←p+1 to m do |   |</p>

    <p class="text-gray-300">|  113 X←C ⊕Mj |   |</p>

    <p class="text-gray-300">|  114 C←{0,1}n |   |</p>

    <p class="text-gray-300">|  115 if C∈image(π) then bad←true, C←image(π) |   |</p>

    <p class="text-gray-300">|  116 if X∈domain(π) then bad←true, C←π[X] |   |</p>

    <p class="text-gray-300">|  117 π[X]←C |   |</p>

    <p class="text-gray-300">|  118 T[M1..j]←C |   |</p>

    <p class="text-gray-300">|  119 return C |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Initialize</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game C3</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  300 T[ε]←0n, defined←0n |   |</p>

    <p class="text-gray-300">|  procedure F(M) |   |</p>

    <p class="text-gray-300">|  310 s←s+1, Ms←M |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">311 P←Prefix(M1,...,Ms), p←</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/n, C←T[P]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  312 for j←p+1 to m do |   |</p>

    <p class="text-gray-300">|  313 X←C ⊕Mj |   |</p>

    <p class="text-gray-300">|  314 C←{0,1}n |   |</p>

    <p class="text-gray-300">|  315 if X∈domain(π) then bad←true |   |</p>

    <p class="text-gray-300">|  316 π[X]←defined |   |</p>

    <p class="text-gray-300">|  317 T[M1..j]←C |   |</p>

    <p class="text-gray-300">|  318 return C |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finalize</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game C5</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  500 T[ε]←0n, defined←0n |   |</p>

    <p class="text-gray-300">|  501 for s←1 to q do |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">502 P←Prefix(M1,...,Ms), p←</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/n, C←T[P]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  503 for j←p+1 to m do |   |</p>

    <p class="text-gray-300">|  504 X←C ⊕Mj |   |</p>

    <p class="text-gray-300">|  505 if X∈domain(π) then bad←true |   |</p>

    <p class="text-gray-300">|  506 π[X]←defined |   |</p>

    <p class="text-gray-300">|  507 C←T[M1..j]←{0,1}n |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finalize</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game C7</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  700 T[ε]←0n, defined←0n |   |</p>

    <p class="text-gray-300">|  701 for X∈{0,1}n+ do T[X]←{0,1}n |   |</p>

    <p class="text-gray-300">|  701 for s←1 to q do |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">702 P←Prefix(M1,...,Ms), p←</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  703 if T[P] ⊕Mp+1∈domain(π) then bad←true |   |</p>

    <p class="text-gray-300">|  704 π[T[P] ⊕Mp+1]←defined |   |</p>

    <p class="text-gray-300">|  705 for j←p+2 to m do |   |</p>

    <p class="text-gray-300">|  706 if T[M1..j-1] ⊕Mj∈domain(π) then bad←true |   |</p>

    <p class="text-gray-300">|  707 π[T[M1..j-1] ⊕Mj]←defined |   |</p>

    <p class="text-gray-300">Figure 9: Games used for the CBC MAC analysis. Prefix  <span class="math">(M^1,\\dots ,M^s)</span> ,  <span class="math">M_{i}</span> , and  <span class="math">M_{1..j}</span>  are defined in the text.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Figure 10: Terminal game used in the analysis of the CBC MAC.</p>

    <p class="text-gray-300">as well choose a random value  <span class="math">Z^s</span>  and return it to the adversary, doing nothing else with  <span class="math">Z^s</span> . This is the change made for game  <span class="math">C_4</span> . The transition is conservative.  <span class="math">\\triangleright C_4 \\to C_5</span> : Changing game  <span class="math">C_4</span>  to  <span class="math">C_5</span>  is by the de-randomization technique. First de-randomize line 417, letting each  <span class="math">Z^s</span>  be a constant  <span class="math">Z^s</span> . Thus we are not returning random values  <span class="math">Z^1, \\ldots, Z^q</span>  to the adversary, we are returning constants  <span class="math">Z^1, \\ldots, Z^q</span>  instead. Since adversary  <span class="math">A</span>  is deterministic there are corresponding queries  <span class="math">M^1, \\ldots, M^q</span>  that it will ask. As these are constants, we need no longer consider the adversary as interacting with its oracle; in game  <span class="math">C_5</span>  we "hardwire in" the sequence of queries  <span class="math">M^1, \\ldots, M^q</span>  (and responses  <span class="math">Z^1, \\ldots, Z^q</span>  except that these have no influence on the game) that the adversary  <span class="math">A</span>  would have asked. The "virtual-queries"  <span class="math">M^1, \\ldots, M^q</span>  still have to be valid: each  <span class="math">M^s</span>  is an mn-bit string different from all prior ones. We have that  <span class="math">\\operatorname{Pr}[A^{C_4} \\text{ sets } bad] \\leq \\operatorname{Pr}[C_5 \\text{ sets } bad]</span> .  <span class="math">\\triangleright C_5 \\to C_6</span> : Game  <span class="math">C_6</span>  unrolls the first iteration of the loop at lines 503-507. This transformation is conservative.  <span class="math">\\triangleright C_6 \\to C_7</span> : Game  <span class="math">C_7</span>  is a rewriting of game  <span class="math">C_6</span>  that omits mention of the variables  <span class="math">C</span>  and  <span class="math">X</span> , directly using values from the  <span class="math">T</span> -table instead, these values now being chosen at the beginning of the game. The change is conservative.  <span class="math">\\triangleright C_7 \\to C_8</span> : Game  <span class="math">C_8</span>  re-indexes the for loop at line 705-707. The change is conservative.  <span class="math">\\triangleright C_8 \\to C_9</span> : Game  <span class="math">C_9</span>  restructures the setting of bad inside the loop at 802-808 to set bad in a single statement. Points were put into the domain of  <span class="math">\\pi</span>  at lines 805 and 808 and we checked if any of these points coincide with specified other points at lines 804 and 807. Running through the four possible types of collisions gives rise to the tests at lines 904-907. The change is conservative.</p>

    <p class="text-gray-300">At this point we have only to bound  <span class="math">\\operatorname{Pr}[C_9 \\text{ sets } bad]</span> . We do this using the sum bound and a case analysis. Fix a line number among 904, 905, 906, and 907, and fix a corresponding  <span class="math">r, i, s, j</span>  as specified on that line. We will show that the probability that the indicated equation holds is at most  <span class="math">2^{-n}</span>  and so, adding the loss incurred in transitioning from From this we can conclude that  <span class="math">\\operatorname{Pr}[C_9 \\text{ sets } bad] \\leq 0.5m^2q^2</span>  because the total number of equations under consideration is less than  <span class="math">0.5m^2q^2</span> . To see that this is the total number of equations note that we can name a candidate equation by choosing a pair of points  <span class="math">(r, i), (q, j) \\in [1..q] \\times [0..m-1]</span>  and then rejecting this pair if  <span class="math">(r, i)</span>  does not proceed  <span class="math">(s, j)</span>  in lexicographic order. Adding in the  <span class="math">0.5m^2q^2</span>  term we lost in going from game  <span class="math">C_0</span>  to game  <span class="math">C_2</span> , we will be done. The case analysis follows.</p>

    <p class="text-gray-300">Line 904. We first bound  <span class="math">\\operatorname{Pr}[T[\\mathsf{P}^r] \\oplus \\mathsf{M}_{\\mathsf{P}^r + 1}^r = T[\\mathsf{P}^s] \\oplus \\mathsf{M}_{\\mathsf{P}^s + 1}^s]</span> . If  <span class="math">\\mathsf{P}^r = \\mathsf{P}^s = \\varepsilon</span>  then  <span class="math">\\operatorname{Pr}[T[\\mathsf{P}^r] \\oplus \\mathsf{M}_{\\mathsf{P}^r + 1}^r = T[\\mathsf{P}^s] \\oplus \\mathsf{M}_{\\mathsf{P}^s + 1}^s] = \\operatorname{Pr}[\\mathsf{M}_1^r = \\mathsf{M}_1^s] = 0</span>  because  <span class="math">\\mathsf{M}^r</span>  and  <span class="math">\\mathsf{M}^s</span> , having only  <span class="math">\\varepsilon</span>  as a common block prefix, must differ in their first blocks. If  <span class="math">\\mathsf{P}^r = \\varepsilon</span>  but  <span class="math">\\mathsf{P}^s \\neq \\varepsilon</span>  then  <span class="math">\\operatorname{Pr}[T[\\mathsf{P}^r] \\oplus \\mathsf{M}_{\\mathsf{P}^r + 1}^r = T[\\mathsf{P}^s] \\oplus \\mathsf{M}_{\\mathsf{P}^s + 1}^s] = \\operatorname{Pr}[\\mathsf{M}_1^r = T[\\mathsf{P}^s] \\oplus \\mathsf{M}_{\\mathsf{P}^s + 1}^s] = 2^{-n}</span>  since the probability expression involves the single random variable  <span class="math">T[\\mathsf{P}^s]</span>  that is uniformly distributed in  <span class="math">\\{0, 1\\}^n</span> . If  <span class="math">\\mathsf{P}^r \\neq \\varepsilon</span>  and  <span class="math">\\mathsf{P}^s = \\varepsilon</span>  the same reasoning applies. If  <span class="math">\\mathsf{P}^r \\neq \\varepsilon</span>  and  <span class="math">\\mathsf{P}^s \\neq \\varepsilon</span>  then  <span class="math">\\operatorname{Pr}[T[\\mathsf{P}^r] \\oplus \\mathsf{M}_{\\mathsf{P}^r + 1}^r = T[\\mathsf{P}^s] \\oplus \\mathsf{M}_{\\mathsf{P}^s + 1}^s] = 2^{-n}</span>  unless  <span class="math">\\mathsf{P}^r = \\mathsf{P}^s</span> , so assume that to be the case. Then  <span class="math">\\operatorname{Pr}[T[\\mathsf{P}^r] \\oplus \\mathsf{M}_{\\mathsf{P}^r + 1}^r = T[\\mathsf{P}^s] \\oplus \\mathsf{M}_{\\mathsf{P}^s + 1}^s] = \\operatorname{Pr}[\\mathsf{M}_{\\mathsf{P}^r + 1}^r = \\mathsf{M}_{\\mathsf{P}^s + 1}^s] = 0</span>  because  <span class="math">\\mathsf{P}^r = \\mathsf{P}^s</span>  is the longest block prefix that coincides in  <span class="math">\\mathsf{M}^r</span>  and  <span class="math">\\mathsf{M}^s</span> .</p>

    <p class="text-gray-300">Line 905. We want to bound  <span class="math">\\operatorname<em>{Pr}[T[\\mathsf{P}^s] \\oplus \\mathsf{M}_{\\mathsf{P}^s + 1}^s = T[\\mathsf{M}_{1..i}^r] \\oplus \\mathsf{M}_{i + 1}^r]</span> . If  <span class="math">\\mathsf{P}^s = \\varepsilon</span>  then  <span class="math">\\operatorname</em>{Pr}[T[\\mathsf{P}^s] \\oplus \\mathsf{M}_{\\mathsf{P}^s + 1}^s = T[\\mathsf{M}_{1..i}^r] \\oplus \\mathsf{M}_{i + 1}^r] = \\operatorname<em>{Pr}[\\mathsf{M}_{\\mathsf{P}^s + 1}^s = T[\\mathsf{M}_{1..i}^r] \\oplus \\mathsf{M}_{i + 1}^r] = 2^{-n}</span>  because it involves a single random value  <span class="math">T[\\mathsf{M}_{1..i}^r]</span> . So assume that  <span class="math">\\mathsf{P}^s \\neq \\varepsilon</span> . Then  <span class="math">\\operatorname</em>{Pr}[T[\\mathsf{P}^s] \\oplus \\mathsf{M}_{\\mathsf{P}^s + 1}^s = T[\\mathsf{M}_{1..i}^r] \\oplus \\mathsf{M}_{i + 1}^r] = 2^{-n}</span>  unless  <span class="math">\\mathsf{P}^s = \\mathsf{M}_{1..i}^r</span>  in which case we are looking at  <span class="math">\\operatorname*{Pr}[\\mathsf{M}_{\\mathsf{P}^s + 1}^s = \\mathsf{M}_{\\mathsf{P}^s + 1}^r]</span> . But this is 0 because  <span class="math">\\mathsf{P}^s = \\mathsf{M}_{1..i}^r</span>  means that the longest prefix that  <span class="math">\\mathsf{M}^s</span>  shares with  <span class="math">\\mathsf{M}^r</span>  is  <span class="math">\\mathsf{P}^s</span>  and so  <span class="math">\\mathsf{M}_{\\mathsf{P}^s + 1}^s \\neq \\mathsf{M}_{\\mathsf{P}^s + 1}^r</span> .</p>

    <p class="text-gray-300">Line 906. We must bound  <span class="math">\\operatorname*{Pr}[T[\\mathsf{P}^r] \\oplus \\mathsf{M}_{\\mathsf{P}^r + 1}^r = T[\\mathsf{M}_{1..j}^s] \\oplus \\mathsf{M}_{j + 1}^s]</span> . It is at most by  <span class="math">2^{-n}</span>  as above.</p>

    <p class="text-gray-300">Line 907. What is  <span class="math">\\operatorname*{Pr}[T[\\mathsf{M}_{1..j}^s] \\oplus \\mathsf{M}_{j+1}^s = T[\\mathsf{M}_{1..i}^r] \\oplus \\mathsf{M}_{i+1}^r]</span> . It is  <span class="math">2^{-n}</span>  unless  <span class="math">i = j</span>  and  <span class="math">\\mathsf{M}_{1..j}^s = \\mathsf{M}_{1..i}^r</span> . In that case  <span class="math">\\mathfrak{p}^s \\geq j</span>  and  <span class="math">\\mathfrak{p}^r \\geq i</span> , contradicting the allowed values for  <span class="math">i</span>  and  <span class="math">j</span>  at line 907. This completes the proof.</p>

    <p class="text-gray-300">BACKGROUND. We recall the needed background for the asymmetric encryption scheme OAEP [8]. A trapdoor-permutation generator with associated security parameter  <span class="math">k</span>  is a randomized algorithm  <span class="math">\\mathcal{F}</span>  that returns a pair  <span class="math">(f, f^{-1})</span>  where  <span class="math">f: \\{0, 1\\}^k \\to \\{0, 1\\}^k</span>  is (the encoding of) a permutation and  <span class="math">f^{-1}</span>  is (the encoding of) its inverse. Let</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathcal {F}} ^ {\\mathrm {o w f}} (I) = \\Pr [ (f, f ^ {- 1}) \\stackrel {\\S} {\\leftarrow} \\mathcal {F}; x \\stackrel {\\S} {\\leftarrow} \\{0, 1 \\} ^ {k}: I (f, f (x)) = x ]</span></div>

    <p class="text-gray-300">be the advantage of adversary  <span class="math">I</span>  in inverting  <span class="math">\\mathcal{F}</span> . Let  <span class="math">\\rho &amp;lt; k</span>  be an integer. The key-generation algorithm of asymmetric encryption scheme  <span class="math">\\mathsf{OAEP}^{\\rho}[\\mathcal{F}]</span>  is simply  <span class="math">\\mathcal{F}</span> , meaning it returns  <span class="math">f</span>  as the public key and  <span class="math">f^{-1}</span>  as the secret key. The encryption and decryption algorithms have oracles  <span class="math">G\\colon \\{0,1\\}^{\\rho}\\to \\{0,1\\}^{k - \\rho}</span>  and  <span class="math">H\\colon \\{0,1\\}^{k - \\rho}\\to \\{0,1\\}^{\\rho}</span>  and work as follows (for the basic, no-authenticity scheme):</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">algorithm EfG,H(M) /<em> M ∈ {0,1}k-ρ</em>/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">algorithm DfG,H(Y) /<em> Y ∈ {0,1}k</em>/</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">R←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">X←f-1(Y)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">S←G(R) ⊕ M, T←H(S) ⊕ R</td>

            <td class="px-3 py-2 border-b border-gray-700">S←X[1..k-ρ], T←X[k-ρ+1..k]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Y←f(S</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">T)</td>

            <td class="px-3 py-2 border-b border-gray-700">R←H(S) ⊕ T, M←G(R) ⊕ S</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return Y</td>

            <td class="px-3 py-2 border-b border-gray-700">return M</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Security of an asymmetric encryption scheme  <span class="math">\\mathsf{AE} = (\\mathcal{F},\\mathcal{E},\\mathcal{D})</span>  is defined via the following game. Keys  <span class="math">(f,f^{-1})</span>  are chosen by running  <span class="math">\\mathcal{F}</span> , and a bit  <span class="math">b</span>  is chosen at random. Adversary  <span class="math">A</span>  is given input  <span class="math">f</span>  and a left-or-right oracle  <span class="math">LR(\\cdot ,\\cdot)</span>  which on input a pair  <span class="math">M_0,M_1</span>  of equal-length messages computes  <span class="math">Y\\stackrel {\\S}{\\leftarrow}\\mathcal{E}_f(M_b)</span>  and returns  <span class="math">Y</span> . The output of adversary is a bit  <span class="math">b^{\\prime}</span>  and  <span class="math">\\mathbf{Adv}_{\\mathsf{AE}}^{\\mathrm{ind - cpa}}(A) = 2\\operatorname *{Pr}[b&#x27; = b] - 1</span> .</p>

    <p class="text-gray-300">Theorem 13 [IND-CPA security of OAEP] Let  <span class="math">\\mathcal{F}</span>  be a trapdoor permutation generator with associated security parameter  <span class="math">k</span> , and let  <span class="math">\\rho &amp;lt; k</span>  be an integer. Let  <span class="math">A</span>  be an adversary with running time  <span class="math">t_A</span> , making at most  <span class="math">q_G</span>  queries to its  <span class="math">G</span>  oracle,  <span class="math">q_H</span>  to its  <span class="math">H</span>  oracle, and exactly one query to its left-or-right oracle. Then there is an adversary  <span class="math">I</span>  with running time  <span class="math">t_I</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathcal {F}} ^ {\\mathrm {o w f}} (I) \\geq \\frac {1}{2} \\mathbf {A d v} _ {\\mathsf {O A E P} ^ {\\rho} [ \\mathcal {F} ]} ^ {\\mathrm {i n d - c p a}} (A) - \\frac {2 q _ {G}}{2 ^ {\\rho}} - \\frac {q _ {H}}{2 ^ {k - \\rho}} \\quad \\text {a n d} \\quad t _ {I} \\leq t _ {A} + c q _ {G} q _ {H} t _ {\\mathcal {F}}</span></div>

    <p class="text-gray-300">where  <span class="math">t_{\\mathcal{F}}</span>  is the time for one computation of a function output by  <span class="math">\\mathcal{F}</span>  and  <span class="math">c</span>  is an absolute constant depending only on details of the model of computation.</p>

    <p class="text-gray-300">Proof: The proof is based on games shown in Figures 11-13. For these games regard  <span class="math">\\mathcal{F}</span> ,  <span class="math">k</span> , and  <span class="math">\\rho</span>  as fixed; they are hardwired into the games. We have striven to make steps between adjacent games small at the cost of a somewhat longer game chain.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">procedure LR(M0,M1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game P0</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">000</td>

            <td class="px-3 py-2 border-b border-gray-700">R*←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">001</td>

            <td class="px-3 py-2 border-b border-gray-700">GR*←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">002</td>

            <td class="px-3 py-2 border-b border-gray-700">if G[R<em>] then bad ← true, GR</em> ← G[R*]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">003</td>

            <td class="px-3 py-2 border-b border-gray-700">S<em> ← GR</em> ⊕ Mb</td>

            <td class="px-3 py-2 border-b border-gray-700">004</td>

            <td class="px-3 py-2 border-b border-gray-700">HS*←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">005</td>

            <td class="px-3 py-2 border-b border-gray-700">if H[S<em>] then bad ← true, HS</em> ← H[S*]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">006</td>

            <td class="px-3 py-2 border-b border-gray-700">T<em> ← R</em> ⊕ HS*</td>

            <td class="px-3 py-2 border-b border-gray-700">007</td>

            <td class="px-3 py-2 border-b border-gray-700">return Y<em> ← f(S</em></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">T*)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure G(R)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure H(S)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">010</td>

            <td class="px-3 py-2 border-b border-gray-700">if R = R<em> then return G[R</em>] ← GR*</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">020</td>

            <td class="px-3 py-2 border-b border-gray-700">if S = S<em> then return H[S</em>] ← HS*</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">011</td>

            <td class="px-3 py-2 border-b border-gray-700">return G[R] ←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">021</td>

            <td class="px-3 py-2 border-b border-gray-700">return H[S] ←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure LR(M0,M1)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Game P1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">R* ←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">101</td>

            <td class="px-3 py-2 border-b border-gray-700">GR* ←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">102</td>

            <td class="px-3 py-2 border-b border-gray-700">S<em> ← GR</em> ⊕ Mb</td>

            <td class="px-3 py-2 border-b border-gray-700">103</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">104</td>

            <td class="px-3 py-2 border-b border-gray-700">T<em> ← R</em> ⊕ HS*</td>

            <td class="px-3 py-2 border-b border-gray-700">105</td>

            <td class="px-3 py-2 border-b border-gray-700">return Y<em> ← f(S</em></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">T*)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure G(R)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure H(S)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">110</td>

            <td class="px-3 py-2 border-b border-gray-700">if R = R<em> then return G[R</em>] ← GR*</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">120</td>

            <td class="px-3 py-2 border-b border-gray-700">if S = S<em> then return H[S</em>] ← HS*</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">111</td>

            <td class="px-3 py-2 border-b border-gray-700">return G[R] ←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">121</td>

            <td class="px-3 py-2 border-b border-gray-700">return H[S] ←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure LR(M0,M1)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Game P2</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">200</td>

            <td class="px-3 py-2 border-b border-gray-700">R* ←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">201</td>

            <td class="px-3 py-2 border-b border-gray-700">GR* ←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">202</td>

            <td class="px-3 py-2 border-b border-gray-700">S<em> ← GR</em> ⊕ Mb</td>

            <td class="px-3 py-2 border-b border-gray-700">203</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">204</td>

            <td class="px-3 py-2 border-b border-gray-700">T<em> ← R</em> ⊕ HS*</td>

            <td class="px-3 py-2 border-b border-gray-700">205</td>

            <td class="px-3 py-2 border-b border-gray-700">return Y<em> ← f(S</em></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">T*)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure G(R)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure H(S)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">210</td>

            <td class="px-3 py-2 border-b border-gray-700">if R = R* then bad ← true,</td>

            <td class="px-3 py-2 border-b border-gray-700">return G[R<em>] ← GR</em></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">if S = S<em> then return H[S</em>] ← HS*</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">211</td>

            <td class="px-3 py-2 border-b border-gray-700">return G[R] ←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">221</td>

            <td class="px-3 py-2 border-b border-gray-700">return H[S] ←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure LR(M0,M1)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Game P3</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">300</td>

            <td class="px-3 py-2 border-b border-gray-700">R* ←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">301</td>

            <td class="px-3 py-2 border-b border-gray-700">GR* ←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">302</td>

            <td class="px-3 py-2 border-b border-gray-700">S<em> ← GR</em> ⊕ Mb</td>

            <td class="px-3 py-2 border-b border-gray-700">303</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">304</td>

            <td class="px-3 py-2 border-b border-gray-700">T<em> ← R</em> ⊕ HS*</td>

            <td class="px-3 py-2 border-b border-gray-700">305</td>

            <td class="px-3 py-2 border-b border-gray-700">return Y<em> ← f(S</em></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">T*)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure G(R)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure H(S)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">310</td>

            <td class="px-3 py-2 border-b border-gray-700">if R = R* then bad ← true</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">320</td>

            <td class="px-3 py-2 border-b border-gray-700">if S = S<em> then return H[S</em>] ← HS*</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">311</td>

            <td class="px-3 py-2 border-b border-gray-700">return G[R] ←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">321</td>

            <td class="px-3 py-2 border-b border-gray-700">return H[S] ←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure LR(M0,M1)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Game P4</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">400</td>

            <td class="px-3 py-2 border-b border-gray-700">R* ←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">401</td>

            <td class="px-3 py-2 border-b border-gray-700">S* ←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">402</td>

            <td class="px-3 py-2 border-b border-gray-700">HS* ←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">403</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">404</td>

            <td class="px-3 py-2 border-b border-gray-700">return Y<em> ← f(S</em></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">T*)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure G(R)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure H(S)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">410</td>

            <td class="px-3 py-2 border-b border-gray-700">if R = R* then bad ← true</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">420</td>

            <td class="px-3 py-2 border-b border-gray-700">if S = S<em> then return H[S</em>] ← HS*</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">411</td>

            <td class="px-3 py-2 border-b border-gray-700">return G[R] ←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">421</td>

            <td class="px-3 py-2 border-b border-gray-700">return H[S] ←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure LR(M0,M1)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Game P5</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">500</td>

            <td class="px-3 py-2 border-b border-gray-700">R* ←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">501</td>

            <td class="px-3 py-2 border-b border-gray-700">S* ←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">502</td>

            <td class="px-3 py-2 border-b border-gray-700">HS* ←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">503</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">504</td>

            <td class="px-3 py-2 border-b border-gray-700">return Y<em> ← f(S</em></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">T*)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure G(R)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure H(S)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">510</td>

            <td class="px-3 py-2 border-b border-gray-700">if H[S<em>] and R = R</em> then bad ← true</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">520</td>

            <td class="px-3 py-2 border-b border-gray-700">if S = S<em> then return H[S</em>] ← HS*</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">511</td>

            <td class="px-3 py-2 border-b border-gray-700">if ¬H[S<em>] and R = R</em> then bad ← true</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">521</td>

            <td class="px-3 py-2 border-b border-gray-700">return H[S] ←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">return G[R] ←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 11: Games used in the analysis of OAEP. Procedure Initialize is the same in all of these games:  <span class="math">(f, f^{-1}) \\leftarrow^{\\mathbb{S}} \\mathcal{F}(k)</span> ,  <span class="math">b \\leftarrow^{\\mathbb{S}} \\{0, 1\\}</span> , return  <span class="math">f</span> . Procedure Finalize(out) is also the same: return  <span class="math">(out = b)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">procedure LR(M0,M1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game Q0</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">000</td>

            <td class="px-3 py-2 border-b border-gray-700">R*←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">001</td>

            <td class="px-3 py-2 border-b border-gray-700">S*←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">002</td>

            <td class="px-3 py-2 border-b border-gray-700">HS*←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">003 T<em>←R</em>⊕HS*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">004</td>

            <td class="px-3 py-2 border-b border-gray-700">return Y<em>←f(S</em>∥T*)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure G(R)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure H(S)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">010</td>

            <td class="px-3 py-2 border-b border-gray-700">if H[S<em>] and R = R</em> then bad ← true</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">020</td>

            <td class="px-3 py-2 border-b border-gray-700">if S = S<em> then return H[S</em>] ← HS*</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">011</td>

            <td class="px-3 py-2 border-b border-gray-700">return G[R]←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">021</td>

            <td class="px-3 py-2 border-b border-gray-700">return H[S]←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure LR(M0,M1)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Game Q1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">R*←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">101</td>

            <td class="px-3 py-2 border-b border-gray-700">S*←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">102</td>

            <td class="px-3 py-2 border-b border-gray-700">T*←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">103 HS<em>←R</em>⊕T*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">104</td>

            <td class="px-3 py-2 border-b border-gray-700">return Y<em>←f(S</em>∥T*)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure G(R)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure H(S)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">110</td>

            <td class="px-3 py-2 border-b border-gray-700">if H[S<em>] and R = R</em> then bad ← true</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">120</td>

            <td class="px-3 py-2 border-b border-gray-700">if S = S<em> then return H[S</em>] ← HS*</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">111</td>

            <td class="px-3 py-2 border-b border-gray-700">return G[R]←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">121</td>

            <td class="px-3 py-2 border-b border-gray-700">return H[S]←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure LR(M0,M1)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Game Q2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">200</td>

            <td class="px-3 py-2 border-b border-gray-700">S*←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">201</td>

            <td class="px-3 py-2 border-b border-gray-700">T*←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">202</td>

            <td class="px-3 py-2 border-b border-gray-700">R*←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">203 return Y<em>←f(S</em>∥T*)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure G(R)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure H(S)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">210</td>

            <td class="px-3 py-2 border-b border-gray-700">if H[S<em>] and R = R</em> then bad ← true</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">if S = S<em> then return H[S</em>] ← R<em>⊕T</em></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">211</td>

            <td class="px-3 py-2 border-b border-gray-700">return G[R]←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">221</td>

            <td class="px-3 py-2 border-b border-gray-700">return H[S]←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure LR(M0,M1)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Game Q3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">300</td>

            <td class="px-3 py-2 border-b border-gray-700">S*←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">301</td>

            <td class="px-3 py-2 border-b border-gray-700">T*←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">302</td>

            <td class="px-3 py-2 border-b border-gray-700">return Y<em>←f(S</em>∥T*)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure G(R)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure H(S)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">310</td>

            <td class="px-3 py-2 border-b border-gray-700">if H[S<em>] and R = R</em> then bad ← true</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">320</td>

            <td class="px-3 py-2 border-b border-gray-700">if S = S<em> then R</em>←{0,1}ρ, return H[S<em>] ← R</em>⊕T*</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">311</td>

            <td class="px-3 py-2 border-b border-gray-700">return G[R]←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">321</td>

            <td class="px-3 py-2 border-b border-gray-700">return H[S]←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure LR(M0,M1)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Game Q4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">400</td>

            <td class="px-3 py-2 border-b border-gray-700">S*←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">401</td>

            <td class="px-3 py-2 border-b border-gray-700">T*←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">402</td>

            <td class="px-3 py-2 border-b border-gray-700">return Y<em>←f(S</em>∥T*)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure G(R)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure H(S)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">410</td>

            <td class="px-3 py-2 border-b border-gray-700">if H[S<em>] and R = R</em> then bad ← true</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">420</td>

            <td class="px-3 py-2 border-b border-gray-700">H[S]←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">411</td>

            <td class="px-3 py-2 border-b border-gray-700">return G[R]←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">421</td>

            <td class="px-3 py-2 border-b border-gray-700">if S = S<em> then R</em>←H[S<em>]⊕T</em></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">422</td>

            <td class="px-3 py-2 border-b border-gray-700">return H[S]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure LR(M0,M1)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Game Q5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">500</td>

            <td class="px-3 py-2 border-b border-gray-700">S*←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">501</td>

            <td class="px-3 py-2 border-b border-gray-700">T*←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">502</td>

            <td class="px-3 py-2 border-b border-gray-700">return Y<em>←f(S</em>∥T*)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure G(R)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure H(S)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">510</td>

            <td class="px-3 py-2 border-b border-gray-700">if R = H[S<em>]⊕T</em> then bad ← true</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">520</td>

            <td class="px-3 py-2 border-b border-gray-700">return H[S]←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">511</td>

            <td class="px-3 py-2 border-b border-gray-700">return G[R]←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure LR(M0,M1)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Game Q6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">600</td>

            <td class="px-3 py-2 border-b border-gray-700">S*←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">601</td>

            <td class="px-3 py-2 border-b border-gray-700">T*←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">602</td>

            <td class="px-3 py-2 border-b border-gray-700">return Y<em>←f(S</em>∥T*)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure G(R)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure H(S)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">610</td>

            <td class="px-3 py-2 border-b border-gray-700">if ∃ S s.t. f(S∥T<em>) = Y</em> and R = H[S]⊕T* then bad ← true</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">620</td>

            <td class="px-3 py-2 border-b border-gray-700">return H[S]←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">611</td>

            <td class="px-3 py-2 border-b border-gray-700">return G[R]←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure LR(M0,M1)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Game Q7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">700</td>

            <td class="px-3 py-2 border-b border-gray-700">return Y*←{0,1}k</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure G(R)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure H(S)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">710</td>

            <td class="px-3 py-2 border-b border-gray-700">if ∃ S s.t. f(S∥H[S]⊕R) = Y* then bad ← true</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">720</td>

            <td class="px-3 py-2 border-b border-gray-700">return H[S]←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">711</td>

            <td class="px-3 py-2 border-b border-gray-700">return G[R]←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 12: Games used in the analysis of OAERQ continued. Initialize and Finalize are as before.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">procedure LR(M0,M1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game Q0</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">000</td>

            <td class="px-3 py-2 border-b border-gray-700">R*←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">001</td>

            <td class="px-3 py-2 border-b border-gray-700">S*←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">002</td>

            <td class="px-3 py-2 border-b border-gray-700">HS*←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">003 T<em>←R</em> ⊕ HS*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">004</td>

            <td class="px-3 py-2 border-b border-gray-700">return Y<em>←f(S</em></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">T*)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure G(R)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure H(S)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">010</td>

            <td class="px-3 py-2 border-b border-gray-700">if ¬H[S<em>] and R = R</em> then bad ← true</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">020</td>

            <td class="px-3 py-2 border-b border-gray-700">if S = S<em> then return H[S</em>] ← HS*</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">011</td>

            <td class="px-3 py-2 border-b border-gray-700">return G[R]←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">021</td>

            <td class="px-3 py-2 border-b border-gray-700">return H[S]←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure LR(M0,M1)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Game Q1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">R*←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">101</td>

            <td class="px-3 py-2 border-b border-gray-700">S*←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">102</td>

            <td class="px-3 py-2 border-b border-gray-700">HS*←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">103 T<em>←R</em> ⊕ HS*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">104</td>

            <td class="px-3 py-2 border-b border-gray-700">return Y<em>←f(S</em></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">T*)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure G(R)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure H(S)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">110</td>

            <td class="px-3 py-2 border-b border-gray-700">if ¬H[S<em>] and R = R</em> then bad ← true</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">120</td>

            <td class="px-3 py-2 border-b border-gray-700">return H[S]←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">111</td>

            <td class="px-3 py-2 border-b border-gray-700">return G[R]←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure LR(M0,M1)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Game Q2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">200</td>

            <td class="px-3 py-2 border-b border-gray-700">R*←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">201</td>

            <td class="px-3 py-2 border-b border-gray-700">S*←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">202</td>

            <td class="px-3 py-2 border-b border-gray-700">T*←{0,1}k</td>

            <td class="px-3 py-2 border-b border-gray-700">203 return Y<em>←f(S</em></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">T*)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure G(R)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure H(S)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">210</td>

            <td class="px-3 py-2 border-b border-gray-700">if R = R* then bad ← true</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">return H[S]←{0,1}ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">211</td>

            <td class="px-3 py-2 border-b border-gray-700">return G[R]←{0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure LR(M0,M1)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Procedures of Inverter I</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">900</td>

            <td class="px-3 py-2 border-b border-gray-700">return Y*</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">procedure G(R)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">procedure H(S)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">910</td>

            <td class="px-3 py-2 border-b border-gray-700">if ∃ S s.t. f(S</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">H[S] ⊕ R) = Y<em> then bad ← true, S</em></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">T* ← S</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">H[S] ⊕ R</td>

            <td class="px-3 py-2 border-b border-gray-700">920 return H[S] ← {0,1}ρ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">911</td>

            <td class="px-3 py-2 border-b border-gray-700">return G[R] ← {0,1}k-ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 13: Top: Games used in the analysis of OAEP, continued. Procedures Initialize and Finalize are as before. Bottom: The inverting algorithm  <span class="math">I</span> , likewise with an identical Initialize procedure.</p>

    <p class="text-gray-300">For the analysis let  <span class="math">p_i = \\operatorname*{Pr}\\left[P_i^A\\Rightarrow \\mathsf{true}\\right]</span>  for  <span class="math">0\\leq i\\leq 5</span>  (the Finalize procedure of these games outputs a boolean).  <span class="math">\\triangleright</span>  Game  <span class="math">P_0</span>  perfectly mimics the game defining the security of  <span class="math">\\mathsf{OAEP}^{\\rho}[\\mathcal{F}]</span> . Thus</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>5 + 0. 5 \\mathbf {A d v} _ {\\mathbf {O A E P} ^ {\\rho} [ \\mathcal {F} ]} ^ {\\mathrm {i n d - c p a}} (A) = p _ {0} = p _ {1} + (p _ {0} - p _ {1}) \\leq p _ {1} + \\Pr [ P _ {0} ^ {A} \\text {s e t s} b a d ],</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">the last step by the Fundamental Lemma. Since game  <span class="math">P_0</span>  chooses  <span class="math">R^<em></span> ,  <span class="math">S^</em></span>  at random,  <span class="math">\\operatorname*{Pr}[P_0^A \\text{ sets } bad] \\leq q_G / 2^\\rho + q_H / 2^{k - \\rho}</span> .  <span class="math">\\triangleright</span>  Game  <span class="math">P_2</span>  differs from game  <span class="math">P_1</span>  only in the setting of  <span class="math">bad</span> , so  <span class="math">p_1 = p_2</span> , and using the Fundamental Lemma again we have</p>

    <div class="my-4 text-center"><span class="math-block">p _ {1} = p _ {2} = p _ {3} + \\left(p _ {2} - p _ {3}\\right) \\leq p _ {3} + \\Pr \\left[ P _ {3} ^ {A} \\text {s e t s} b a d \\right].</span></div>

    <p class="text-gray-300"><span class="math">\\triangleright</span>  In game  <span class="math">P_4</span>  the string  <span class="math">GR^<em></span>  is chosen but not referred to in responding to any oracle queries of the adversary. Thus  <span class="math">P_4</span>  is a conservative replacement for  <span class="math">P_3</span> ,  <span class="math">p_3 = p_4</span> , and  <span class="math">\\operatorname</em>{Pr}[P_3^A \\text{ sets } bad] = \\operatorname*{Pr}[P_4^A \\text{ sets } bad]</span> . However, the bit  <span class="math">b</span>  is not used in  <span class="math">P_4</span> , and hence  <span class="math">p_4 = 1/2</span> . In summary</p>

    <div class="my-4 text-center"><span class="math-block">p _ {3} + \\Pr \\left[ P _ {3} ^ {A} \\text {s e t s} b a d \\right] = p _ {4} + \\Pr \\left[ P _ {4} ^ {A} \\text {s e t s} b a d \\right] = 1 / 2 + \\Pr \\left[ P _ {4} ^ {A} \\text {s e t s} b a d \\right].</span></div>

    <p class="text-gray-300">Putting all this together we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>5 \\mathbf {A d v} _ {\\mathbf {O A E P} ^ {\\rho} [ \\mathcal {F} ]} ^ {\\text {i n d - c p a}} (A) - \\frac {q _ {G}}{2 ^ {\\rho}} - \\frac {q _ {H}}{2 ^ {k - \\rho}} \\leq \\Pr \\left[ P _ {4} ^ {A} \\text {s e t s} b a d \\right]. \\tag {17}</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We proceed to upper bound the right-hand-side of the above. We have</p>

    <p class="text-gray-300"><span class="math">\\Pr[P_{4}^{A}\\mbox{ sets }bad\\,]\\leq\\Pr[P_{5}^{A}\\mbox{ sets }bad\\,]\\leq\\Pr[Q_{0}^{A}\\mbox{ sets }bad\\,]+\\Pr[\\hat{Q}_{0}^{A}\\mbox{ sets }bad\\,]\\leq\\Pr[Q_{0}^{A}\\mbox{ sets }bad\\,]+q_{G}/2^{\\rho}\\,.</span></p>

    <p class="text-gray-300">Above, we have split the analysis of game <span class="math">P_{5}</span> into the analysis of games <span class="math">Q_{0}</span> and <span class="math">\\hat{Q}_{0}</span>, the former being accomplished by the game chain at Figure 12 and the latter by the game chain of Figure 13. The second term is readily shown to be at most <span class="math">q_{G}/2^{\\rho}</span> by way of the game chain at Figure 13. Going back to the analysis of game <span class="math">Q_{0}</span> in Figure 12, we have a series of conservative changes, giving <span class="math">Q_{1}</span>, <span class="math">Q_{2}</span>, <span class="math">Q_{3}</span>, <span class="math">Q_{4}</span>, <span class="math">Q_{5}</span> leading to</p>

    <p class="text-gray-300"><span class="math">\\Pr[Q_{0}^{A}\\mbox{ sets }bad\\,]\\ =\\ \\Pr[Q_{5}^{A}\\mbox{ sets }bad\\,]\\ \\leq\\ \\Pr[Q_{6}^{A}\\mbox{ sets }bad\\,]\\ =\\ \\Pr[Q_{7}^{A}\\mbox{ sets }bad\\,]\\ .</span></p>

    <p class="text-gray-300">To conclude the proof we design <span class="math">I</span> so that</p>

    <p class="text-gray-300"><span class="math">\\Pr[Q_{7}^{A}\\mbox{ sets }bad\\,]\\ \\leq\\ {\\bf Adv}_{\\cal F}^{\\rm opf}(I)\\ .</span> (18)</p>

    <p class="text-gray-300">On input <span class="math">f,Y^{<em>}</span>, inverter <span class="math">I</span> runs <span class="math">A</span> on input public key <span class="math">f</span>, responding to its oracle queries via the procedures specified in the last box in Figure 13. When <span class="math">A</span> halts, inverter <span class="math">I</span> returns <span class="math">S^{</em>}\\parallel T^{*}</span> if this has been defined. By comparison with game <span class="math">Q_{7}</span> we see that (18) is true, completing the proof.</p>

    <h2 id="sec-21" class="text-2xl font-bold">7 Game-Rewriting Techniques</h2>

    <p class="text-gray-300">In this section we name, describe, and justify some game-transformation techniques that seem universally useful. Our enumeration is not comprehensive, only aiming to hit some of the most interesting and widely applicable methods. We begin with some useful terminology.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">7.1 Game chains</h3>

    <p class="text-gray-300">The power of the game-playing technique stems, in large part, from our ability to incrementally rewrite games, constructing chains of them. Using the Fundamental Lemma, you first arrange that the analysis you want to carry out amounts to bounding <span class="math">\\epsilon=\\Pr[G_{1}^{A}\\mbox{ sets }bad\\,]</span> for some first game <span class="math">G_{1}</span> and some adversary <span class="math">A</span>. (In fact, a game chain may be used also for this first phase, before we apply the Fundamental Lemma; triple encryption and OAEP are such examples.) You want to bound <span class="math">\\epsilon</span> as a function of the resources expended by <span class="math">A</span>. To this end, you modify the game <span class="math">G_{1}</span>, one step at a time, constructing a chain of games <span class="math">G_{1}\\longrightarrow G_{2}\\longrightarrow G_{3}\\longrightarrow\\cdots\\longrightarrow G_{n}</span>. Game <span class="math">G_{1}</span> is the <em>initial</em> game and game <span class="math">G_{n}</span> is the <em>terminal</em> game. Game <span class="math">G_{1}</span> is run using adversary <span class="math">A</span>; other games may run with different adversaries.</p>

    <p class="text-gray-300">Consider a transition <span class="math">G^{A}\\rightarrow H^{B}</span>. Let <span class="math">p_{G}=\\Pr[G^{A}\\mbox{ sets }bad\\,]</span> and let <span class="math">p_{H}=\\Pr[H^{B}\\mbox{ sets }bad\\,]</span>. We want to bound <span class="math">p_{G}</span> in terms of <span class="math">p_{H}</span>. Sometimes we show that <span class="math">p_{G}\\leq p_{H}</span>. In this case, the transformation is <em>safe</em>. A common case of this is when <span class="math">p_{G}=p_{H}</span>, in which case the transformation is <em>conservative</em>. Sometimes we show that <span class="math">p_{G}\\leq p_{H}+\\epsilon</span> or <span class="math">p_{G}\\leq c\\cdot p_{H}</span> for some particular <span class="math">\\epsilon&gt;0</span> or <span class="math">c&gt;1</span>. Either way, the transformation is <em>lossy</em>. When a chain of safe and lossy transformations is performed, a bound for <em>bad</em> getting set in the initial game is obtained from a bound for <em>bad</em> getting set in the terminal game by adding and/or multiplying the loss terms in the natural way. We use the terms safe, conservative, or lossy to apply to pairs of games even in the absence of a specific adversary: the statement is then understood to apply to all adversaries with understood resource bounds.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">7.2 Basic techniques</p>

    <p class="text-gray-300">We start off with game-transformation methods that do not require an extensive discussion. The methods can be quite powerful just the same.</p>

    <p class="text-gray-300">Resampling idiom. Let <span class="math">T</span> be a finite, nonempty set and let <span class="math">S\\subseteq T</span>. Then the code fragment <span class="math">x\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}S<span class="math"> can be replaced by the equivalent code fragment </span>x\\stackrel{{\\scriptstyle\\<span class="math">}}{{\\leftarrow}}T</span>, if <span class="math">x\\not\\in S</span> then <span class="math">x\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}S<span class="math">. We call this motif <em>resampling</em>. It is a basic “idiom” employed in games, often with <em>bad</em> getting set when resampling is required, replacing </span>x\\stackrel{{\\scriptstyle\\<span class="math">}}{{\\leftarrow}}S</span> by <span class="math">x\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}T<span class="math">, if </span>x\\not\\in S<span class="math"> then <em>bad</em> </span>\\leftarrow<span class="math"> true, </span>x\\stackrel{{\\scriptstyle\\<span class="math">}}{{\\leftarrow}}S</span>. The code-replacement just specified is clearly safe (but not conservative). Our proof for the PRP/PRF Switching Lemma, our proof for triple-encryption, and our proof for the CBC MAC all employ the resampling idiom.</p>

    <p class="text-gray-300">Swapping dependent and independent variables. Instead of choosing a random value <span class="math">X\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\{0,1\\}^{n}<span class="math"> and then defining </span>Y\\leftarrow X\\oplus C<span class="math">, one can choose </span>Y\\stackrel{{\\scriptstyle\\<span class="math">}}{{\\leftarrow}}\\{0,1\\}^{n}</span> and define <span class="math">X\\leftarrow Y\\oplus C</span>. This can be generalized in natural ways. Swapping dependent and independent variables is invariably a conservative change. This technique is used in our proof of OAEP.</p>

    <p class="text-gray-300">Code motion. It is often convenient to move around statements, as an optimizing compiler might. Permissible code motion is usually trivial to verify because games need not employ those programming-language constructs (aliasing and side-effects) that complicate seeing whether or not code motion is permissible. One particular form of code motion that is often used is to postpone until procedure Finalize making random choices that had been made earlier. Permissible code motion is conservative. Examples of code motion are given in the proof of the CBC MAC.</p>

    <p class="text-gray-300">Marking-instead-of-recording. Suppose that a variable <span class="math">\\pi</span> is being used in a game to record a lazily-defined permutation: we start off with <span class="math">\\pi</span> everywhere undefined, and then we set some first value <span class="math">\\pi[X_{1}]</span> to <span class="math">Y_{1}</span>, and later we set some second value <span class="math">\\pi[X_{2}]</span> to <span class="math">Y_{2}</span>, and so forth. Sometimes an inspection of the code will reveal that all we are paying attention to is which points are in the domain of <span class="math">\\pi</span> and which points are in the range. In such a case, we didn’t need to record the association of <span class="math">Y_{i}</span> to <span class="math">X_{i}</span>, we could just as well have “marked” <span class="math">X_{i}</span> as being a now-used domain-point, and marked <span class="math">Y_{i}</span> as being a now-used range-point. Dropping the use of <span class="math">Y_{i}</span> may now permit other changes in the code, like code motion. The method is conservative. Marking-instead-of-recording is used in our proof of the CBC MAC.</p>

    <p class="text-gray-300">Derandomizing a variable. Suppose a game <span class="math">G</span> chooses a variable <span class="math">X\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathcal{X}<span class="math"> and never re-defines it. We may eliminate the random-assignment statement </span>X\\stackrel{{\\scriptstyle\\<span class="math">}}{{\\leftarrow}}\\mathcal{X}</span> and replace all uses of <span class="math">X</span> by a fixed constant <span class="math">c\\in X</span>, obtaining a new game <span class="math">G_{c}</span>. Given an adversary <span class="math">A</span>, let <span class="math">H</span> be <span class="math">G_{c}</span> for the lexicographically first <span class="math">c\\in\\mathcal{X}</span> that maximizes <span class="math">\\Pr[G_{c}^{A}\\text{ sets }bad\\,]</span>. We say that game <span class="math">H</span> has been obtained by derandomizing the variable <span class="math">X</span>. It is easy to see that <span class="math">\\Pr[G^{A}\\text{ sets }bad\\,]\\leq\\Pr[H^{A}\\text{ sets }bad\\,]</span>; that is, derandomizing a variable is a safe transformation. One can also de-randomize when elements of an array are chosen at random, replacing code for <span class="math">i\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}1<span class="math"> to </span>q<span class="math"> do </span>A[i]\\stackrel{{\\scriptstyle\\<span class="math">}}{{\\leftarrow}}\\mathcal{X}</span> by references to constants. Our analysis of the triple can be viewed as using this method in passing from game <span class="math">C_{2}</span> to <span class="math">C_{T}</span> (but see Section 7.3 for a fuller discussion).</p>

    <p class="text-gray-300">Poisoned points. Sometimes a game will place a value in an array that it probably will not use; that is, <span class="math">A[x]</span> is defined as some value <span class="math">c</span> but it is unlikely that the value of <span class="math">A[x]</span> will actually be needed. In this case, one can think of “poisoning” array position <span class="math">x</span> of <span class="math">A</span>, dropping <span class="math">c</span> into <span class="math">A[x]</span> but setting a flag <em>bad</em> if <span class="math">A[x]</span> is ever accessed. Next one can imagine storing a value <span class="math">b</span> different from <span class="math">c</span> in at <span class="math">A[x]</span>, and since any access to <span class="math">A[x]</span> will set <em>bad</em>, it doesn’t matter that a “wrong” value was placed in <span class="math">A[x]</span>: it will not increase the probability that <em>bad</em> gets set. We call this the “poisoned-point technique.” It is useful because it allows one to make a change in what is stored</p>

    <p class="text-gray-300">in an array (setting <span class="math">A[x]</span> to <span class="math">b</span> instead of <span class="math">c</span>) and pay for corrupting the game only later, and only if <span class="math">A[x]</span> is actually accessed. We use the poisoned-point technique in our proof of triple encryption when passing from game <span class="math">G_{4}</span> to game <span class="math">G_{5}</span>.</p>

    <p class="text-gray-300">Unplayable games. We point out that the games in a game chain do not normally have to be efficient: a game chain is a thought experiment that, typically, is not performed by any user or adversary. We refer to a game that seems to have no efficient implementation as an <em>unplayable game</em>. In most settings it is perfectly fine to use unplayable games, although none are used within this paper.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">7.3 Coin fixing</h3>

    <p class="text-gray-300">It is often much easier to carry out an analysis if one can assume that adversaries decide on their queries in advance; the fact that adversaries can choose their queries adaptively is one of the major factors complicating many analyses. We now describe the <em>coin-fixing technique</em> to eliminate or reduce adversarial adaptivity. You can’t <em>always</em> apply this method to remove adaptivity; our purpose is to given an example of a sufficient condition when you can. The coin-fixing technique stems from a classical method in complexity theory to eliminate coins, hardwiring them in, as in the proof that <span class="math">\\text{BPP}\\subseteq\\text{P/poly}</span> <em>[2]</em>.</p>

    <p class="text-gray-300">Fix a game <span class="math">G</span> and an enumeration of its oracles, <span class="math">P_{1},\\ldots,P_{m}</span> for some <span class="math">m\\geq 0</span>. We would like to eliminate oracle <span class="math">P_{1}</span>, constructing a new game <span class="math">H</span> with oracles <span class="math">P_{2},\\ldots,P_{m}</span>. If <span class="math">G</span> has only one oracle, <span class="math">P_{1}</span>, then <span class="math">H</span> will be left with no oracles: it will be a non-interactive game, a game whose execution does not depend on an adversary. A <em>resource vector</em> is a sequence of numbers <span class="math">R=(q_{1},\\ldots,q_{m})\\in\\mathbb{N}^{m}</span>. For such a vector <span class="math">R=(q_{1},\\ldots,q_{m})</span> let <span class="math">\\mathcal{A}_{R}</span> denote the set of all adversaries that ask exactly <span class="math">q_{i}</span> queries to oracle <span class="math">P_{i}</span>. Let <span class="math">\\text{tail}(R)=(q_{2},\\ldots,q_{m})</span> be <span class="math">R</span> stripped of its first component. When speaking of a game <span class="math">G</span> where each oracle <span class="math">P_{i}</span> has an understood domain <span class="math">D_{i}</span>, the adversary class <span class="math">\\mathcal{A}_{R}</span> is further assumed to include only adversaries that ask queries that are within the domain of each oracle.</p>

    <p class="text-gray-300">Now suppose that oracle <span class="math">P_{1}</span> is of the form:</p>

    <p class="text-gray-300"><span class="math">\\text{\\bf procedure }P_{1}(X)\\quad\\ i\\leftarrow i+1,\\ \\ X[i]\\leftarrow X,\\ \\ Y[i]\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}D_{X[1],...,X[i],Y[1],...,Y[i-1]},\\ \\ S,\\ \\ \\text{return }Y[i]</span></p>

    <p class="text-gray-300">where <span class="math">i</span> is some integer variable and <span class="math">X</span> and <span class="math">Y</span> are distinct array variables and <span class="math">i</span>, <span class="math">X[\\cdot]</span>, and <span class="math">Y[\\cdot]</span> appear in game <span class="math">G</span> as <span class="math">l</span>-values (that is, on the left-hand-side of an assignment operator or random-assignment operator) only in the statements shown. Statement <span class="math">S</span> is empty if <span class="math">m&gt;1</span> and an arbitrary compound statement if <span class="math">m=1</span>. By <span class="math">D_{X[1],...,X[i],Y[1],...,Y[i-1]}</span> we mean a finite set that depends only on <span class="math">X[1],\\ldots,X[i],Y[1],\\ldots,Y[i-1]</span>. To fall within our code-based framework the set <span class="math">D_{X[1],...,X[i],Y[1],...,Y[i-1]}</span> must be specified in code; what we are asserting that this code computes the associated set and is without side-effects. A useful special cases is <span class="math">Y[i]\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\{0,1\\}^{n}</span> for some constant <span class="math">n</span>. When <span class="math">P_{1}</span> has the form we have just described we say that it is <em>eliminable</em> and has parameters <span class="math">i,X,Y,S</span>.</p>

    <p class="text-gray-300">With all notation as above, let <span class="math">\\text{\\tt X},\\text{\\tt Y}\\in(\\{0,1\\}^{<em>})^{q_{1}}</span>. We say that <span class="math">(\\text{\\tt X},\\text{\\tt Y})</span> is </em>possible<em> for <span class="math">(G,\\mathcal{A}_{R})</span> if there exists an adversary <span class="math">A\\in\\mathcal{A}_{R}</span> for which there is nonzero probability that, in the interaction between <span class="math">A</span> and <span class="math">G</span>, the former asks queries <span class="math">\\text{\\tt X}_{1},\\ldots,\\text{\\tt X}_{q_{1}}</span> and receives in response <span class="math">\\text{\\tt Y}_{1},\\ldots,\\text{\\tt Y}_{q_{1}}</span>. A </em>query set* for <span class="math">(G,\\mathcal{A}_{R})</span> is a finite set of points <span class="math">\\mathcal{Q}</span> that includes all possible <span class="math">(\\text{\\tt X},\\text{\\tt Y})</span> for <span class="math">(G,\\mathcal{A}_{R})</span>.</p>

    <p class="text-gray-300">For <span class="math">\\text{\\tt X},\\text{\\tt Y}\\in(\\{0,1\\}^{*})^{q_{1}}</span> define the game <span class="math">G_{\\text{\\tt X},\\text{\\tt Y}}</span> to be identical to <span class="math">G</span> except for the following: (1) Eliminate the procedure for oracle <span class="math">P_{1}</span>. (2) Replace every expression of the form <span class="math">X[e]</span> by <span class="math">\\text{\\tt X}[e]</span>. (no <span class="math">X[e]</span> appears as an l-value). (3) Replace every expression of the form <span class="math">Y[e]</span> by <span class="math">\\text{\\tt Y}[e]</span> (no <span class="math">Y[e]</span> appears as</p>

    <p class="text-gray-300">an l-value). (4) At the beginning of procedure Finalize, add the statement: for <span class="math">i\\leftarrow 1</span> to <span class="math">q_{1}</span> do <span class="math">S</span>.</p>

    <p class="text-gray-300">We eliminate <span class="math">P_{1}</span> by appealing to the following.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proposition 14</h6>

    <p class="text-gray-300">Let <span class="math">G</span> be a game with oracles <span class="math">P_{1},\\ldots,P_{m}</span>. Let <span class="math">R=(q_{1},\\ldots,q_{m})\\in\\mathbb{N}^{m}</span> and <span class="math">R^{\\prime}=\\mathrm{tail}(R)</span>. Let <span class="math">\\mathcal{Q}</span> be a query set. Then</p>

    <p class="text-gray-300">$\\max_{A\\in\\mathcal{A}_{R}}\\{\\Pr\\big{[}\\,G^{A}\\text{ sets }bad\\,\\,\\big{]}\\}\\ \\leq\\ \\max_{B\\in\\mathcal{A}_{R^{\\prime}},\\;(\\mathbb{X},\\Upsilon)\\in\\mathcal{Q}}\\{\\Pr\\big{[}\\,G^{B}_{\\mathbb{X},\\Upsilon}\\text{ sets }bad\\,\\,\\big{]}\\}\\qquad\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636pt\\hbox{\\hskip 14.22636</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Figure 14: Games referred to in discussion of lazy sampling.</p>

    <p class="text-gray-300">There could, however, be some different lazy sampling method that did work in this case. We present a possibility via game  <span class="math">H_{3}</span>  of Figure 14. We leave as an exercise for the reader to determine whether or not  <span class="math">H_{3}</span>  is equivalent to  <span class="math">H_{1}</span>  and prove the answer correct.</p>

    <p class="text-gray-300">AN AID TO JUSTIFYING LAZY SAMPLING METHODS. We would like some way to "test" a candidate lazy sampling method and determine whether or not it works. At least we would like a sufficient condition which, if met by the method, allows us to conclude it works. Here we put forth a result in this vein. Basically we say that we can restrict our attention to adversaries that make all possible oracle queries. Let us now make this more precise.</p>

    <p class="text-gray-300">Let  <span class="math">I</span>  be a game with an oracle  <span class="math">P</span> . We say that  <span class="math">I</span>  implements  <span class="math">P</span>  consistently if for any adversary  <span class="math">A</span> , if  <span class="math">A</span>  has made a query  <span class="math">P(X)</span>  and got back a value  <span class="math">Y</span> , then, if  <span class="math">A</span>  again makes query  <span class="math">P(X)</span> , the response will be  <span class="math">Y</span> . (This does not mean that there are no random choices involved in implementing  <span class="math">P</span> , but rather that the value of this oracle at some point, once defined, is not changed.) When all oracles provided by a game are implemented consistently, we can without loss of generality restrict attention to adversaries that never repeat an oracle query.</p>

    <p class="text-gray-300">We say that games  <span class="math">G, H</span>  are compatible if they provide access to oracles of the same names, meaning there is some  <span class="math">n \\geq 0</span>  and some  <span class="math">P_1, \\ldots, P_n</span>  such that both games provide these oracles and no others, and also both games implement all oracles consistently. (The oracles might be implemented differently in the two games. Think of  <span class="math">G</span>  as implementing them via an eager sampling method and  <span class="math">H</span>  via a lazy sampling one.)</p>

    <p class="text-gray-300">Let  <span class="math">G, H</span>  be compatible games providing oracles  <span class="math">P_{1}, \\ldots, P_{n}</span>  for some  <span class="math">n \\geq 1</span> . We assume there is a finite domain  <span class="math">D_{i}</span>  associated to  <span class="math">P_{i}</span>  and that all adversaries considered must pick their queries to  <span class="math">P_{i}</span>  from  <span class="math">D_{i}</span>  for  <span class="math">1 \\leq i \\leq n</span> . (Such domains are always implicit in games.) We say that an adversary  <span class="math">A</span>  is exhaustive if it queries all oracles at all possible points. That is, for any game  <span class="math">I</span>  compatible with games  <span class="math">G, H</span> , for each  <span class="math">i</span>  and each  <span class="math">X \\in D_{i}</span> , there is some point in the execution of  <span class="math">A</span>  with  <span class="math">I</span>  at which  <span class="math">A</span>  makes query  <span class="math">P_{i}(X)</span> . Note there are many possible exhaustive adversaries, for we do not impose requirements on the order in which they make their queries, or even on whether they are adaptive or not.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Lemma 15</h6>

    <p class="text-gray-300">Let <span class="math">G,H</span> be compatible games. Then <span class="math">G</span> and <span class="math">H</span> are equivalent if and only if <span class="math">\\mathbf{Adv}(G^{A},H^{A})=0</span> for all exhaustive adversaries <span class="math">A</span>.</p>

    <p class="text-gray-300">Proof: If the games are equivalent then by definition <span class="math">\\mathbf{Adv}(G^{A},H^{A})=0</span> for any adversary <span class="math">A</span>, so in particular this is true when <span class="math">A</span> is exhaustive. Conversely, let <span class="math">B</span> be any adversary, and associate to it an exhaustive adversary <span class="math">A</span> that works as follows. Adversary <span class="math">A</span> runs <span class="math">B</span>, answering <span class="math">B</span>’s oracle queries via its own oracles. When <span class="math">B</span> halts with some output <span class="math">b</span>, adversary <span class="math">A</span> continues, making all oracle queries not made by <span class="math">B</span>. (Since the domains of the oracles are finite, <span class="math">A</span> will terminate.) Finally it outputs <span class="math">b</span> and halts. Then <span class="math">\\mathbf{Adv}(G^{B},H^{B})=\\mathbf{Adv}(G^{A},H^{A})</span>. But the latter is by assumption zero since <span class="math">A</span> is exhaustive, and thus <span class="math">\\mathbf{Adv}(G^{B},H^{B})=0</span> as well. Since <span class="math">B</span> was arbitrary, this shows the games are equivalent.</p>

    <p class="text-gray-300">We remark that we effectively used the principle of the above lemma in justifying the lazy sampling method of <span class="math">G_{4}</span> in the proof of Lemma 9, when we assumed that <span class="math">A</span> makes all <span class="math">6N</span> oracle queries.</p>

    <h2 id="sec-26" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We thank Tadayoshi Kohno for permission to use his observations about the standard proof of the PRP/PRF Switching Lemma noted in Section 2 and Appendix A. Thanks to the Eurocrypt 2006 PC for their comments. Thanks to Deukjo Hong for pointing out an error in the exposition of Section 2. Finally, thanks to Peter Gaži and Ueli Maurer for identifying bugs in earlier version, as described in Section 1.</p>

    <p class="text-gray-300">Mihir Bellare was supported by NSF 0098123, ANR-0129617, NSF 0208842, and an IBM Faculty Partnership Development Award. Phil Rogaway was supported by NSF 0208842 and a gift from Intel Corp. Much of the work on this paper was carried out while Phil was hosted by Chiang Mai University, Thailand.</p>

    <h2 id="sec-27" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] M. Abe, R. Gennaro, K. Kurosawa and V. Shoup. Tag-KEM/DEM: A new framework for hybrid encryption and a new analysis of Kurosawa-Desmedt KEM. Eurocrypt ’05.</li>

      <li>[2] L. Adleman. Two theorems on random polynomial time. FOCS 78.</li>

      <li>[3] W. Aiello, M. Bellare, G. Di Crescenzo, and R. Venkatesan. Security amplification by composition: the case of doubly-iterated, ideal ciphers. Crypto ’98.</li>

      <li>[4] M. Bellare and S. Goldwasser. New paradigms for digital signatures and message authentication based on non-interactive zero knowledge proofs. Crypto 89, pp. 194–211, 1989.</li>

      <li>[5] M. Bellare, J. Kilian, and P. Rogaway. The security of the cipher block chaining message authentication code. Journal of Computer and System Sciences (JCSS), vol. 61, no. 3, pp. 362–399, 2000. Earlier version in Crypto ’94.</li>

      <li>[6] M. Bellare, T. Krovetz, and P. Rogaway. Luby-Rackoff backwards: increasing security by making block ciphers non-invertible. Eurocrypt ’98.</li>

      <li>[7] M. Bellare, K. Pietrzak, and P. Rogaway. Improved security analyses for CBC MACs. Crypto 05.</li>

      <li>[8] M. Bellare and P. Rogaway. Optimal asymmetric encryption. Eurocrypt ’94.</li>

      <li>[9] M. Bellare and P. Rogaway. Random oracles are practical: a paradigm for designing efficient protocols. ACM CCS ’93.</li>

      <li>[10] M. Bellare, P. Rogaway, and D. Wagner. The EAX mode of operation (a two-pass authenticated encryption scheme). FSE ’04</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[11] D. Bernstein. A short proof of the unpredictability of cipher block chaining. Manuscript, January 2005. Available on Bernstein’s web page.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[12] J. Black and P. Rogaway. CBC MACs for arbitrary-length messages: the three-key constructions. Crypto ’00.</li>

      <li>[13] J. Black and P. Rogaway. A block-cipher mode of operation for parallelizable message authentication. Eurocrypt ’02.</li>

      <li>[14] J. Black, P. Rogaway, and T. Shrimpton. Encryption-scheme security in the presence of key-dependent messages. SAC 2002.</li>

      <li>[15] D. Boneh. Simplified OAEP for the RSA and Rabin functions. Crypto ’01.</li>

      <li>[16] J. Camenisch and V. Shoup. Practical verifiable encryption and decryption of discrete logs. Crypto ’03.</li>

      <li>[17] R. Cramer and V. Shoup. Design and analysis of practical public-key encryption schemes secure against adaptive chosen ciphertext attack. SIAM J. of Computing, vol. 33, pp. 167–226, 2003.</li>

      <li>[18] R. Cramer and V. Shoup. Universal hash proofs and a paradigm for adaptive chosen ciphertext secure public key encryption. Eurocrypt ’02.</li>

      <li>[19] W. Diffie and M. Hellman. Exhaustive cryptanalysis of the data encryption standard. Computer, vol. 10, pp. 74–84, 1977.</li>

      <li>[20] Y. Dodis, R. Gennaro, J. Håstad, H. Krawczyk, and T. Rabin. Randomness extraction and key derivation using the CBC, Cascade, and HMAC modes. Crypto ’04.</li>

      <li>[21] S. Even and O. Goldreich. On the power of cascade ciphers. ACM Transactions on Computer Systems, vol. 3, no. 2, pp. 108–116, 1985.</li>

      <li>[22] S. Even and Y. Mansour. A construction of a cipher from a single pseudorandom permutation. Asiacrypt ’91. LNCS 739, Springer, pp. 210–224, 1992.</li>

      <li>[23] E. Fujisaki, T. Okamoto, D. Pointcheval, and J. Stern. RSA-OAEP is secure under the RSA assumption. J. of Cryptology, vol. 17, no. 2, pp. 81–104, 2004.</li>

      <li>[24] P. Gaži and U. Maurer. Cascade encryption revisited. Manuscript provided by the authors. Received September 2008.</li>

      <li>[25] S. Goldwasser and S. Micali. Probabilistic encryption. J. Comput. Syst. Sci., vol. 28, no. 2, pp. 270–299, 1984. Earlier version in STOC ’82.</li>

      <li>[26] S. Halevi. A plausible approach to computer-aided cryptographic proofs. Cryptology ePrint archive report 2005/181, 2005.</li>

      <li>[27] S. Halevi and P. Rogaway. A parallelizable enciphering mode. CT-RSA ’04. LNCS 2964, Springer, pp. 292–304, 2004.</li>

      <li>[28] S. Halevi and P. Rogaway. A tweakable enciphering mode. Crypto ’03. LNCS 2729, pp. 482–499, 2004.</li>

      <li>[29] C. Hall, D. Wagner, J. Kelsey, and B. Schneier. Building PRFs from PRPs. Available on Wagner’s web page. Earlier version in Crypto ’98.</li>

      <li>[30] R. Impagliazzo and S. Rudich. Limits on the provable consequences of one-way permutations. Crypto ’88. LNCS 403, pp. 8–26, 1988.</li>

      <li>[31] E. Jaulmes, A. Joux, and F. Valette. On the security of randomized CBC-MAC beyond the birthday paradox limit: a new construction. FSE ’02. LNCS 2365, pp. 237–251, 2002.</li>

      <li>[32] J. Kilian and P. Rogaway. How to protect DES against exhaustive key search (an analysis of DESX). J. of Cryptology, vol. 14, no. 1, pp. 17–35, 2001. Earlier version in Crypto ’96.</li>

      <li>[33] S. Lucks. Attacking triple encryption. FSE ’98. LNCS 1372, pp. 239–253, 1998.</li>

      <li>[34] U. Maurer. Indistinguishability of random systems. Eurocrypt ’02. LNCS 2332, Springer, pp. 110–132, 2002.</li>

      <li>[35] U. Maurer and J. Massey. Cascade ciphers: the importance of being first. J. of Cryptology,</li>

    </ul>

    <p class="text-gray-300">vol. 6, no. 1, pp. 55–61, 1993.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[36] R. Merkle and M. Hellman. On the security of multiple encryption. Communications of the ACM, vol. 24, pp. 465–467, 1981.</li>

      <li>[37] R. Motwani and P. Raghavan. Randomized Algorithms. Cambridge University Press, 1995.</li>

      <li>[38] National Institute of Standards and Technology. FIPS PUB 46-3, Data Encryption Standard (DES), 1999. Also ANSI X9.52, Triple Data Encryption Algorithm modes of operation, 1998, and other standards.</li>

      <li>[39] E. Petrank and C. Rackoff. CBC MAC for real-time data sources. J. of Cryptology, vol. 13, no. 3, pp. 315–338, 2000.</li>

      <li>[40] P. Rogaway. Authenticated-encryption with associated-data. ACM CCS ’02.</li>

      <li>[41] P. Rogaway. Efficient instantiations of tweakable blockciphers and refinements to modes OCB and PMAC. Asiacrypt ’04.</li>

      <li>[42] P. Rogaway, M. Bellare, and J. Black. OCB: A block-cipher mode of operation for efficient authenticated encryption. ACM Transactions on Information and System Security, vol. 6, no. 3, pp. 365–403, 2003. Earlier version in ACM CCS ’01.</li>

      <li>[43] T. Schweinberger and V. Shoup. ACE: the advanced cryptographic engine. Cryptology ePrint report 2000/022, 2000.</li>

      <li>[44] C. Shannon. Communication theory of secrecy systems. Bell Systems Technical Journal, vol. 28, no. 4, pp. 656–715, 1949.</li>

      <li>[45] V. Shoup. OAEP reconsidered. J. of Cryptology, vol. 15, no. 4, pp. 223–249, 2002. Earlier version in Crypto ’01.</li>

      <li>[46] V. Shoup. A proposal for an ISO standard for public key encryption. Cryptology ePrint report 2001/112, 2001.</li>

      <li>[47] V. Shoup. Sequences of games: a tool for taming complexity in security proofs. Cryptology ePrint report 2004/332, November 30, 2004.</li>

      <li>[48] V. Shoup. Using hash function as a hedge against chosen ciphertext attack. Eurocrypt ’00.</li>

      <li>[49] S. Vaudenay. Decorrelation over infinite domains: the encrypted CBC-MAC case. Communications in Information and Systems (CIS), vol. 1, pp. 75–85, 2001.</li>

      <li>[50] A. Yao. Theory and applications of trapdoor functions. FOCS 1982, pp. 80–91, 1982.</li>

    </ul>

    <h2 id="sec-28" class="text-2xl font-bold">Appendix A Fixing the PRP/PRF Switching Lemma Without Games</h2>

    <p class="text-gray-300">Let adversary <span class="math">A</span> and other notation be as in Section 2,where we showed by example that if the number of oracle queries made by <span class="math">A</span> depends on the answers it receives in response to previous queries, then (1) may not hold. Here we show that if the number of oracle queries made by <span class="math">A</span> is always exactly <span class="math">q</span>—meaning the number of queries is this value regardless of <span class="math">A</span>’s coins and the answers to the oracle queries—then (1) is true.</p>

    <p class="text-gray-300">Note that given any adversary <span class="math">A_{1}</span> making at most <span class="math">q</span> queries, it is easy to modify it to an <span class="math">A_{2}</span> that has the same advantage as <span class="math">A_{1}</span> but makes exactly <span class="math">q</span> oracle queries. (Adversary <span class="math">A_{2}</span> will run <span class="math">A_{1}</span> until it halts, counting the number of oracle queries the latter makes. Calling this number <span class="math">q_{1}</span>, it now makes some <span class="math">q-q_{1}</span> oracle queries, whose answers it ignores, outputting exactly what <span class="math">A_{1}</span> outputs.) In other words, if an adversary is assumed to make at most <span class="math">q</span> queries, one can assume wlog that the number of queries is exactly <span class="math">q</span>. This means that one can in fact obtain a correct proof of the PRP/PRF Switching Lemma based on (1). The bug we highlighted in Section 2thus amounts to having claimed (1) for all <span class="math">A</span> making at most <span class="math">q</span> queries rather than those making exactly <span class="math">q</span> queries.</p>

    <p class="text-gray-300">Let us now show that if the number of oracle queries made by <span class="math">A</span> is always exactly <span class="math">q</span> then (1) is true. Since <span class="math">A</span> is computationally unbounded, we may assume wlog that <span class="math">A</span> is deterministic.</p>

    <p class="text-gray-300">We also assume it never repeats an oracle query. Let <span class="math">V = (\\{0,1\\}^n)^q</span> and for a <span class="math">q</span>-vector <span class="math">a \\in V</span> let <span class="math">a[i] \\in \\{0,1\\}^n</span> denote the <span class="math">i</span>-th coordinate of <span class="math">a</span>, <span class="math">1 \\leq i \\leq q</span>. We can regard <span class="math">A</span> as a function <span class="math">f: V \\to \\{0,1\\}</span> that gives a <span class="math">q</span>-vector <span class="math">a</span> of replies to its oracle queries returns a bit <span class="math">f(a)</span>. Let <span class="math">\\mathbf{a}</span> denote the random variable that takes value the <span class="math">q</span>-vector of replies returned by the oracle to the queries made by <span class="math">A</span>. Also let</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\text{dist} = \\{a \\in V: a[1], \\dots, a[n] \\text{ are distinct} \\} \\\\ \\text{one} = \\{a \\in V: f(a) = 1 \\}. \\end{array}</span></div>

    <p class="text-gray-300">Let <span class="math">\\operatorname{Pr}_{\\mathrm{rand}}[\\cdot]</span> denote the probability in the experiment where <span class="math">\\rho \\stackrel{\\</span>}{\\leftarrow} \\operatorname{Func}(n)$. Then</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\operatorname{Pr}\\left[ A^{\\rho} \\Rightarrow 1 \\mid \\text{DIST} \\right] = \\operatorname{Pr}_{\\text{rand}} \\left[ f(\\mathbf{a}) = 1 \\mid \\mathbf{a} \\in \\text{dist} \\right] = \\frac{\\operatorname{Pr}_{\\text{rand}} \\left[ f(\\mathbf{a}) = 1 \\wedge \\mathbf{a} \\in \\text{dist} \\right]}{\\operatorname{Pr}_{\\text{rand}} \\left[ \\mathbf{a} \\in \\text{dist} \\right]} \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\frac{\\sum_{a \\in \\text{dist} \\cap \\text{one}} \\Pr_{\\text{rand}} [\\mathbf{a} = a]}{\\sum_{a \\in \\text{dist}} \\Pr_{\\text{rand}} [\\mathbf{a} = a]} = \\frac{\\sum_{a \\in \\text{dist} \\cap \\text{one}} 2^{-nq}}{\\sum_{a \\in \\text{dist}} 2^{-nq}} = \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{dist} \\cap \\text{one}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{dist}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">On the other hand let <span class="math">\\operatorname{Pr}_{\\mathrm{perm}}[\\cdot]</span> denote the probability in the experiment where <span class="math">\\pi \\stackrel{\\</span>}{\\leftarrow} \\operatorname{Perm}(n)$. Then</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\operatorname{Pr} \\left[ A^{\\pi} \\Rightarrow 1 \\right] = \\operatorname{Pr}_{\\text{perm}} \\left[ f(\\mathbf{a}) = 1 \\right] = \\sum_{a \\in \\text{dist} \\cap \\text{one}} \\operatorname{Pr}_{\\text{perm}} \\left[ \\mathbf{a} = a \\right] \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\sum_{a \\in \\text{dist} \\cap \\text{one}} \\prod_{i=0}^{q-1} \\frac{1}{2^n - i} = \\sum_{a \\in \\text{dist} \\cap \\text{one}} \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{dist}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{dist} \\cap \\text{one}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{dist}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <h2 id="sec-29" class="text-2xl font-bold">B An Example Programming Language for Games</h2>

    <p class="text-gray-300">Formalizing the underlying programming language. Games, as well as adversaries, are programs written in some programming language. In this section we describe a suitable programming language for specifying games, denoted <span class="math">\\mathcal{L}</span>. See Figure 15 for the context-free grammar <span class="math">\\mathcal{G}</span> for <span class="math">\\mathcal{L}</span>. As usual, not every program generated by this grammar is valid (eg, identifiers mustn't be keywords, two procedures can't have the same name, and so forth). The start symbol for a game is game and that for an adversary is adversary. We regard a game (and an adversary) as being specified by its parse tree and therefore ignore the fact that <span class="math">\\mathcal{G}</span> is ambiguous. If one wants to regard games as textual strings instead of parse trees then ambiguity can easily be dealt with by bracketing if and for statements, adding parenthesis to expressions, and making extra productions to account for precedence and grouping rules.</p>

    <p class="text-gray-300">Structure of <span class="math">\\mathcal{L}</span>. Our programming language is intentionally simple. Games employ only static, global variables. A game consists of a sequence of procedures (the order of which is irrelevant). There are three kinds of procedures in games: an initialization procedure, a finalization procedure, and oracle procedures. The first two are distinguished by the keyword Initialize or Finalize, which is used as though it were the procedure name. The adversary is a single procedure, one which uses the keyword Adversary as though it were the procedure name.</p>

    <p class="text-gray-300">The language <span class="math">\\mathcal{L}</span> is strongly typed. The types of expressions are integer, boolean, string, set, and array. <span class="math">\\triangleright</span> integer: A value of this type is a point in the set <span class="math">Z = \\{\\dots, -2, -1, 0, 1, 2, \\dots\\}</span>, or else undefined. <span class="math">\\triangleright</span> boolean: A value of this type is either true or false, or else undefined. <span class="math">\\triangleright</span> string: A value of this type is a finite string over the binary alphabet <span class="math">\\Sigma = \\{\\mathbf{0}, \\mathbf{1}\\}</span>, or else undefined. <span class="math">\\triangleright</span> set: A value of this type is a finite set of strings, or else undefined. <span class="math">\\triangleright</span> array: A value of this type is an associative</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Figure 15: CFG for the sample game-programming-language  <span class="math">\\mathcal{L}</span> . A game G is a program in this language starting from the "game" production. An adversary is also a program in this language, but starting from the "adversary" nonterminal.</p>

    <p class="text-gray-300">array from and to strings; formally, an array  <span class="math">A</span>  is a map  <span class="math">A \\colon \\{0,1\\}^<em> \\to \\{0,1\\}^</em> \\cup \\{\\text{undefined}\\}</span> . At any given time, there will be a finite number of strings  <span class="math">X</span>  for which  <span class="math">A[X] \\neq \\text{undefined}</span> . An array can alternatively be regarded as a partial function from strings to strings. An array cannot have the value of undefined, but can be everywhere undefined:  <span class="math">A[X] = \\text{undefined}</span>  for all  <span class="math">X \\in \\{0,1\\}^*</span> . We assert that  <span class="math">A[\\text{undefined}] = \\text{undefined}</span> .</p>

    <p class="text-gray-300">We do not bother to declare variables, but each variable and each expression must have a well-defined type, this type inferable from the program. Demanding that each variable has a statically-inferable type rules out programs with statements like  <span class="math">x \\gets x</span>  or  <span class="math">x \\gets</span>  undefined where  <span class="math">x</span>  occurs in no other context to make manifest its type. The possible types for variables are integer, boolean, string, set, or array. These mean the same as they did for expressions except that a boolean</p>

    <p class="text-gray-300">variable has the semantics of a flag: once true a boolean variable remains true, even if it is assigned false or undefined.</p>

    <p class="text-gray-300">We provide traditional operators like addition on integers, concatenation of strings, and union of sets. Observe that no operator can create an infinite set (eg, we do not provide for Kleene-closure). For an array <span class="math">A</span> we support operators domain(<span class="math">A</span>) and image(<span class="math">A</span>) that return <span class="math">\\{x\\in\\{0,1\\}^{<em>}\\colon A[x]\\neq\\textsf{undefined}]\\}</span> and <span class="math">\\{A[x]\\colon\\,x\\in\\{0,1\\}^{</em>}\\}</span>, respectively. We provide an operator encode(<span class="math">\\cdots</span>) that takes a list of values, of any type, and creates a string in such a way that encode(<span class="math">L</span>) <span class="math">\\neq</span> encode(<span class="math">L^{\\prime}</span>) when <span class="math">L\\neq L^{\\prime}</span>. We assume lazy evaluation of <em>and</em> and <em>or</em>, so false and undefined = false, while true or undefined = true.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Each procedure is a sequence of statements. The types of statements supported in <span class="math">\\mathcal{L}</span> are as follows. <span class="math">\\rhd</span> The <em>empty statement</em> does nothing. <span class="math">\\rhd</span> The <em>assignment statement</em> is of the form <span class="math">x\\leftarrow e</span> where the left-hand-side must be either a variable or an array reference <span class="math">A[s]</span> for an expression <span class="math">s</span> of type string. In the first case the expression <span class="math">e</span> must have the same type as the variable <span class="math">x</span>, and in the second case it must be a string. The semantics is to evaluate the expression <span class="math">e</span> and then modify the store by assigning this value to <span class="math">x</span>. <span class="math">\\rhd</span> For the <em>random-assignment statement</em> <span class="math">x\\stackrel{{\\scriptstyle 3}}{{\\leftarrow}}S</span>, we require <span class="math">x</span> to be a string variable or an array reference <span class="math">A[s]</span> for an array <span class="math">A</span> and string expression <span class="math">s</span>. The right-hand-side <span class="math">S</span> must be a set. The statement uniformly selects a random element from the set <span class="math">S</span> and assigns that value to <span class="math">x</span>. If <span class="math">S=\\emptyset</span> or <span class="math">S=\\textsf{undefined}</span> then the result of the random-assignment statement is to set <span class="math">x</span> to undefined. Random-assignment statements are the only source of randomness in programs. An <em>if</em> statement comes in two forms, if <span class="math">e</span> then <span class="math">S</span>, and if <span class="math">e</span> then <span class="math">S</span> else <span class="math">S^{\\prime}</span>. The expression <span class="math">e</span> may have any type. If it is not a boolean then undefined is treated as false and any other value is treated as true (so “if <span class="math">A[B[s]]</span> then <span class="math">S</span>” is legal, and it tests if both <span class="math">B[s]</span> and <span class="math">A[B[s]]</span> are both defined). <span class="math">\\rhd</span> A <em>for</em> statement comes in two forms: for <span class="math">x\\in A</span> do <span class="math">S</span>, and for <span class="math">i\\leftarrow a</span> to <span class="math">b</span> do <span class="math">S</span>. In the first case <span class="math">x</span> must be a string variable and <span class="math">A</span> must be a set. The expression <span class="math">A</span> is evaluated once and the value remembered. The statement that follows is then executed $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> times, with </span>x<span class="math"> taking on the values in </span>A<span class="math"> in lexicographic order. If </span>A<span class="math"> is empty or undefined then </span>S<span class="math"> is not executed. For the form for </span>i\\leftarrow a<span class="math"> to </span>b<span class="math"> do </span>S<span class="math">, the variable </span>i<span class="math"> must be an integer variable and expressions </span>a<span class="math"> and </span>b<span class="math"> are evaluated once, their values being saved. The statement is then evaluated for successive integers between </span>a<span class="math"> and </span>b<span class="math">. If </span>a<b<span class="math"> or either is undefined then </span>S<span class="math"> is not executed. </span>\\rhd<span class="math"> The <em>return</em> </span>x<span class="math"> statement returns the value </span>x$ to the caller. All procedures (including Initialize and Finalize) return values in this way. If control flows to the end of a routine without encountering a return statement then undefined is returned. It is understood that identifiers must not be keywords and that oracles must have unique names. The procedure invocation <em>call</em> may not be used in a game; it is provided for the benefit of an adversary, who may call out to named oracles.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">An adversary is syntactically identical to an oracle except that the oracle is named “Adversary” and a new expression is allowed, the <em>call</em> expression.</p>

    <p class="text-gray-300">We refer the reader to Section 3 for a discussion of initialization and the subsequent execution of a game with an adversary. The description of an execution there is admittedly informal. A rich theory in computer science exists to formalize the execution of programs, and our programming language is simple enough to present no particular difficulties in pinning down an operational semantics.</p>

    <p class="text-gray-300">We observe that programs in our programming language must terminate. This is because we gave the language no <em>goto</em>, <em>while</em>, or the like; the only way to do repetition is via the <em>for</em> statement, which iterates over a finite set. We have never seen it to be an issue if a game programming language is not Turing-complete. It is, intuitively, more of a concern if adversaries are written in a language that is not Turing-complete (and one might wish to add a statement like a <em>while</em> statement to address that concern). But note that once a game is fixed and a bound is set on the total number</p>

    <p class="text-gray-300">of oracle queries and their lengths, the optimal adversary for this game (optimal in terms of setting a flag <em>bad</em>, maximizing the chance of the game outcome is <span class="math">1</span>, etc.) will be computable, and it will be computable by a program over <span class="math">\\mathcal{L}</span>. So at least when adversary computational complexity is not at issue, there is no loss of generality to assume that adversaries are programs over <span class="math">\\mathcal{L}</span>.</p>

    <p class="text-gray-300">Enhancing the language. The language <span class="math">\\mathcal{L}</span> is a bit too restrictive to make for a convenient description of some games; it is conveniently supplemented with a bit of “syntactic sugar” (and beyond). (1) We use indentation to indicate grouping for compound statements. (2) We often omit commas as statement separators and use line breaks instead. (3) We allow arrays to be indexed by things other than strings. In such a case the meaning is to apply the <span class="math">\\operatorname{encode}(\\cdot)</span> operator to the argument: <span class="math">A[i,x]</span> is short for <span class="math">A[\\operatorname{encode}(i,x)]</span>. (4) We allow use subscripts, superscripts, and Greek characters in identifiers. (5) We sometimes use a subscript in place of an array argument, as in <span class="math">E_{K}[X]</span> for <span class="math">E[K,X]</span>. (6) We write <span class="math">\\overline{\\operatorname{domain}}(A)</span> and <span class="math">\\overline{\\operatorname{image}}(A)</span> for <span class="math">U-\\operatorname{domain}(A)</span> and <span class="math">U-\\operatorname{image}(A)</span> for an understood and specified set <span class="math">U</span>, such as <span class="math">U=\\{0,1\\}^{n}</span>. (7) Sometimes we write a shorthand that actually would be implemented with a fragment of code. For example, when <span class="math">\\pi</span> is an array and one writes <span class="math">\\pi^{-1}[Y]</span>, this would have to be re-coded to fit into the syntax of <span class="math">\\mathcal{L}</span>. If one knows that <span class="math">\\operatorname{domain}(\\pi)\\subseteq\\{0,1\\}^{n}</span> then <span class="math">\\pi^{-1}[Y]</span> could be re-coded as a <em>for</em> loop that runs over <span class="math">\\{0,1\\}^{n}</span> looking for the first (and presumably only) point <span class="math">X</span> such that <span class="math">\\pi[X]=Y</span>; <span class="math">\\pi^{-1}[Y]</span> is then that value.</p>

    <p class="text-gray-300">In general, we view a game as being written in the language <span class="math">\\mathcal{L}</span> as long as it is obvious how to transform the program so as to be literally in <span class="math">\\mathcal{L}</span>. If one were using some sort of automated tool for verifying game-based proofs then it would be necessary to make sure that each game was <em>literally</em> in the target programming language. But when giving a human-readable proof, incorporating whatever constructs or conventions work to simplify the games one is writing is not only permissible, it is nearly essential: a few well-chosen and problem-specific conventions can make for much more readable code, facilitating more easily verified proofs.</p>`;
---

<BaseLayout title="Code-Based Game-Playing Proofs and the Security of Triple En... (2004/331)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/331
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
