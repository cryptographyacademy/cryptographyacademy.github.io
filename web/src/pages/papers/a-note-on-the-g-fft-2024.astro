---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/1036';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A note on the G-FFT';
const AUTHORS_HTML = 'Ulrich Haböck';

const CONTENT = `    <h2 id="sec-2" class="text-2xl font-bold">Ulrich Hab¨ock uhaboeck@polygon.technology,</h2>

    <p class="text-gray-300">June 26, 2024</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">For primes p with p + 1 being smooth, the G-FFT from Li and Xing [\\[LX23\\]](#page-15-0) is an algebraic FFT, which at first glance seems equivalent to the circle FFT from [\\[HLP24\\]](#page-15-1): It also uses the circle curve over F<sup>p</sup> (in other words the projective line) as underlying domain, and interpolates by low-degree functions with poles over the same set of points. However, their approach to control the degree of the FFT basis is fundamentally different. The G-FFT makes use of punctured Riemann-Roch spaces, and the construction works with the group doubling map only, no projection onto the x-axis involved.</p>

    <p class="text-gray-300">In this note we give an elementary description of the G-FFT without using abstract algebra. We describe a variant which uses a simpler, and in our opinion more natural function space, and which treats the exceptional point of the domain (the group identity) differently. In comparison to the circle FFT, the G-FFT (both the original as well as our variant) has the following downsides. Interpolation and domain evaluation costs the double number of multiplications (the twiddle is not an "odd" function), and the function space is not invariant under the group action, causing additional overhead when applied in STARKs.</p>

    <h2 id="sec-4" class="text-2xl font-bold">Contents</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Intro</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">Preliminaries</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">The G-FFT<br>3.1<br>Coset case<br>3.2<br>Group position<br><br>3.3<br>Explicit form of the basis<br></td>

            <td class="px-3 py-2 border-b border-gray-700">6<br>6<br>10<br>12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">Comparison with the circle FFT</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">Appendix</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

          </tr>

        </tbody>

      </table>

    </div>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1 Intro</h3>

    <p class="text-gray-300">Algebraic FFTs [Can89, vzGG96, LCH14, BSCKL21, LX23, HLP24] are generalizations of the Fast Fourier Transform to finite fields  <span class="math">\\mathbb{F}_q</span>  which do not have a smooth multiplicative group  <span class="math">\\mathbb{F}_q^*</span> . (Here and in the sequel, q is a prime, or a power of a prime.) Instead, they work over suitable algebraic varieties over  <span class="math">\\mathbb{F}_q</span>  (e.g. the line, or more generally a curve) with a sufficiently smooth subgroup G of automorphisms, which induces the necessary group structure on its non-degenerated orbits, the FFT domains. Similar to the multiplicative Fourier transform [CT65] based on the even-odd decomposition, algebraic FFTs are built from the following two main ingredients (for simplicity we restrict to the two-adic case):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A chain of 2-to-1 reduction mappings,</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">S_0 \\xrightarrow{\\pi_1} S_1 \\xrightarrow{\\pi_2} \\dots \\xrightarrow{\\pi_n} S_n,</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which gradually halve the size of the FFT domain  <span class="math">D = S_0</span> ,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^n$ , until a singleton (or, small enough). These mappings stem from the group structure of D, and in most cases, they are group homomorphisms of algebraic degree 2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every k = 0, ..., n - 1, a carefully selected twiddle function<sup>1</sup>, i.e. a function</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">t_k: S_k \\longrightarrow \\mathbb{F}_q,</span></div>

    <p class="text-gray-300">which distinguishes preimages under  <span class="math">\\pi_{k+1}</span> . Typically, the algebraic degree of the twiddle is taken as small as possible. (In all the transforms we are aware of, they are either linear or linear fractional functions.)</p>

    <p class="text-gray-300">The reduction chain, together with the twiddle functions, bootstrap a tensor-like basis of low-degree functions over the variety (often, polynomials), the FFT basis, and a divide-and-conquer algorithm for efficient interpolation with respect to that basis. (When run reversed, for domain evaluation<sup>2</sup>.)</p>

    <p class="text-gray-300">The main challenge in the construction is an appropriate choice of reduction mappings and twiddle functions. Foremost, the function spaces  <span class="math">\\mathscr{F}_n</span>  spanned by the FFT bases of different two-adic sizes (for n up to the maximum supported order) need to build a bedrock for efficient arithmetics. Ideally, as in the case of the multiplicative FFT, the product of functions from  <span class="math">\\mathscr{F}_n</span>  should be contained in  <span class="math">\\mathscr{F}_{n+1}</span> , i.e.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathscr{F}_n \\cdot \\mathscr{F}_n \\subseteq \\mathscr{F}_{n+1}</span></div>

    <p class="text-gray-300"><span id="page-1-1"></span> <span class="math">&lt;sup&gt;^1&lt;/sup&gt;</span> The naming is due to the final algorithm written down as a butterfly network. Then, the so-called twiddle factors of a butterfly are the values of  <span class="math">t_k</span>  at the corresponding points of the domain.</p>

    <p class="text-gray-300"><span id="page-1-2"></span> <span class="math">&lt;sup&gt;^2\\&lt;/sup&gt;mathrm{We}</span>  stress the fact that we use the deprecated notions, FFT for interpolation and inverse FFT for evaluation.</p>

    <p class="text-gray-300">but in general an efficient embedding from F<sup>n</sup> · F<sup>n</sup> into Fn+1 is sufficient. The property is related to bounding the degree of the functions which, in terms of algebraic geometry, amounts to controlling their poles. Second, the specific choice of the twiddle function has impact on the concrete efficiency of the butterfly network. Again, ideally one would have the same computational cost as for the multiplicative FFT, which is</p>

    <div class="my-4 text-center"><span class="math-block">n \\cdot 2^n \\cdot \\left(\\frac{1}{2} \\cdot \\mathsf{M} + \\mathsf{A}\\right)</span></div>

    <p class="text-gray-300">for a domain of size 2n, where M denotes multiplications and A additions.</p>

    <p class="text-gray-300">In this writeup we compare the Galois FFT (in short, G-FFT) from Li and Xing [\\[LX23\\]](#page-15-0) with the recent circle FFT from [\\[HLP24\\]](#page-15-1), both tailored to the case that q+ 1 is smooth. We highlight the G-FFT construction in term of the above described principle, and in doing this we keep the exposition as elementary as possible. That is, we do not use the theory of algebraic function fields, the reader is only assumed to be familiar with the concept of the projective closure of a curve.</p>

    <p class="text-gray-300">This note is structured as follows. Section <a href="#page-2-0">2</a> surveys the circle curve, its univariate representation as projective line, and related function spaces. Then, in Section <a href="#page-5-0">3,</a> we elaborate our variants of the G-FFT. These variants use a "tighter" function space than the original G-FFT, and treat the exceptional point of a subgroup domain (corresponding to the group identity) differently. The comparison with the circle FFT is then discussed in Section <a href="#page-13-0">4.</a> Finally, in Appendix <a href="#page-15-2">A</a> we describe the original G-FFT from [\\[LX23\\]](#page-15-0), and draw the connection between their notation and ours.</p>

    <p class="text-gray-300">Throughout this writeup we restrict to the two-adic setting, in which the domain sizes are a power of two. The mixed radix case, as considered in full generality in [\\[LX23\\]](#page-15-0), is beyond our scope.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">In this section we state elementary properties of the circle curve and its univariate description as projective line. For details we refer to <a href="#page-15-1">\\[HLP24,</a> Section 3]. As therein, we occasionally make use of algebraic geometry terms to address readers which are familiar with it. However, this is merely for connecting the dots between concrete and general. We demand no background in geometry beyond the concept of a projective space.</p>

    <p class="text-gray-300">Throughout the note, we assume that F<sup>q</sup> (where q is a prime, or a prime power) is a finite field with q + 1 being divisible by 2<sup>n</sup> a sufficiently large power of two, for some  <span class="math">n \\geq 2</span> , and F denotes a finite extension field of  <span class="math">\\mathbb{F}_q</span> . The circle curve</p>

    <div class="my-4 text-center"><span class="math-block">C: x^2 + y^2 = 1</span></div>

    <p class="text-gray-300">over  <span class="math">\\mathbb{F}_q</span> , is a cyclic group of order q+1, with the group law inherited from the rotation group  <span class="math">SO(2,\\mathbb{F}_q)</span> , i.e.</p>

    <div class="my-4 text-center"><span class="math-block">(x,y)\\cdot(x&#x27;,y&#x27;) = (x\\cdot x&#x27; - y\\cdot y&#x27;, x\\cdot y&#x27; + y\\cdot x&#x27;). \\tag{1}</span></div>

    <p class="text-gray-300">Its neutral element is e = (1,0), the group squaring map is</p>

    <div class="my-4 text-center"><span class="math-block">\\pi(x,y) = (x,y) \\cdot (x,y) = (2 \\cdot x^2 - 1, 2 \\cdot xy),</span></div>

    <p class="text-gray-300">and group inversion is given by the map J(x,y)=(x,-y). For any integer m,  <span class="math">0 \\le m \\le n</span>  we shall denote by  <span class="math">G_m</span>  the unique cyclic subgroup of order  <span class="math">2^m</span> . The definition includes the trivial subgroup  <span class="math">G_0</span>  consisting of the neutral group element. The circle curve over  <span class="math">\\mathbb{F}_q</span>  is affine, meaning it has no additional points in its projective closure. However, the picture changes when considering the curve over the algebraic closure, or any even degree extension of  <span class="math">\\mathbb{F}_q</span> . In this case the circle curve has two points at infinity,</p>

    <div class="my-4 text-center"><span class="math-block">\\infty = (1:i:0), \\quad \\bar{\\infty} = (1:-i:0),</span></div>

    <p class="text-gray-300">which are fixed points under the action of the rotation group. (Here  <span class="math">\\pm i</span>  are the square roots of -1.)</p>

    <p class="text-gray-300">The circle curve over  <span class="math">\\mathbb{F}_q</span>  is algebraically isomorphic to the projective line  <span class="math">P^1(\\mathbb{F}_q) = \\mathbb{F}_q \\cup \\{\\infty\\}</span> , and the isomorphism is given via chordal projection through the neutral group element<sup>4</sup>,</p>

    <div class="my-4 text-center"><span class="math-block">t = \\frac{y}{x - 1},</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">(x,y) = \\left(\\frac{t^2 - 1}{t^2 + 1}, \\frac{2 \\cdot t}{t^2 + 1}\\right).</span></div>

    <p class="text-gray-300">The isomorphism extends to any extension field of  <span class="math">\\mathbb{F}_q</span> , and whenever present, the points at infinity  <span class="math">\\infty</span>  and  <span class="math">\\bar{\\infty}</span>  are mapped to  <span class="math">t=\\pm i</span>  on the projective line. We advise the reader to internalize this one-to-one correspondence, as we will frequently jump between bivariate and univariate representation, thinking of the projective line and the circle as one and the same geometric object.</p>

    <p class="text-gray-300">For example, the circle group law in univariate coordinates is</p>

    <div class="my-4 text-center"><span class="math-block">t \\odot t&#x27; = \\frac{t \\cdot t&#x27; - 1}{t + t&#x27;},\\tag{2}</span></div>

    <p class="text-gray-300"><span id="page-3-0"></span><sup>&</sup>lt;sup>3</sup>The condition  <span class="math">n \\ge 2</span>  guarantees that  <span class="math">q-1=2 \\cdot t</span>  for some odd number t, and hence -1 does not have a square root in  <span class="math">\\mathbb{F}_q</span> .</p>

    <p class="text-gray-300"><span id="page-3-1"></span>does not have a square root in  <span class="math">\\mathbb{F}_q</span> .</p>

    <p class="text-gray-300"><sup>4</sup>Note that we use a different convention as in [HLP24], with the neutral group element (1,0) instead of (-1,0) being mapped to  <span class="math">t=\\infty</span>  of the projective line.</p>

    <p class="text-gray-300">with  <span class="math">\\infty \\in P^1(F)</span>  as the neutral element satisfying  <span class="math">t \\odot \\infty = t</span>  for all  <span class="math">t \\in F</span> . (We overload notation here by using the same notation for the point at infinity of the projective line. As the environmental space is clear from the context, this should not cause confusion.) By means of the group operation,  <span class="math">P^1(\\mathbb{F}_p)</span>  acts on itself via the translation map  <span class="math">T_{\\tau}(t) = \\tau \\odot t</span> , the group squaring map is</p>

    <p class="text-gray-300"><span class="math-block">\\pi(t) = t \\odot t = \\frac{t^2 - 1}{2 \\cdot t},</span> (3)</p>

    <p class="text-gray-300">and (-1,0) the unique circle element of order 2 corresponds to  <span class="math">\\tau=0</span>  on the line, with translation map  <span class="math">T_0(t) = -1/t</span> .</p>

    <p class="text-gray-300">The circle FFT from [HLP24] is expressed in bivariate coordinates, and its function spaces  <span class="math">\\mathscr{F}_m</span> ,  <span class="math">m \\geq 1</span> , are closely related to the spaces</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{L}_M(F) = \\left\\{ p \\in F[x, y] / (x^2 + y^2 + 1) : \\deg p \\le \\frac{M}{2} \\right\\},\\tag{4}</span></div>

    <p class="text-gray-300">for any extension field F of  <span class="math">\\mathbb{F}_q</span> , where  <span class="math">M=2^m</span> , and deg p means the smallest total degree amongst all representatives modulo the circle relation  <span class="math">x^2+y^2-1=0</span> . In terms of algebraic geometry, this is the space of all F-rational functions in the Riemann-Roch space of the divisor</p>

    <p class="text-gray-300"><span id="page-4-1"></span> <span class="math-block">\\frac{M}{2} \\cdot \\infty + \\frac{M}{2} \\cdot \\bar{\\infty}.</span></p>

    <p class="text-gray-300">Even though restricted to F, not necessarily the algebraic closure of  <span class="math">\\mathbb{F}_q</span> , we simply refer to  <span class="math">\\mathcal{L}_M(F)</span>  as Riemann-Roch space. In univariate coordinates, the space corresponds to</p>

    <div class="my-4 text-center"><span class="math-block">\\mathscr{L}_M(F) = \\left\\{ \\frac{p(t)}{(1+t^2)^{M/2}} : p(t) \\in F[t]^{\\leq M} \\right\\},\\tag{5}</span></div>

    <p class="text-gray-300">consisting of all rational functions of degree at most M, and having poles only at  <span class="math">t = \\pm i</span> . As for points and group operations, we override notation here and identify the two representations of the Riemann-Roch space.</p>

    <p class="text-gray-300">On the other hand, we mainly express the G-FFT in univariate coordinates. Its function spaces  <span class="math">\\mathscr{F}_m</span> ,  <span class="math">m \\geq 1</span> , are related to the punctured Riemann-Roch spaces</p>

    <div class="my-4 text-center"><span class="math-block">\\mathscr{L}_M(F)&#x27; = \\mathscr{L}_M(F) \\cap \\mathcal{V}(G_0)^5 = \\left\\{ \\frac{p(t)}{(1+t^2)^{M/2}} : p(t) \\in F[t]^{&lt; M} \\right\\}, \\quad (6)</span></div>

    <p class="text-gray-300">corresponding to all functions in  <span class="math">\\mathcal{L}_M(F)</span>  which evaluate to zero at  <span class="math">t=\\infty</span> , the neutral group element constituting the trivial subgroup  <span class="math">G_0</span> . (Note the strict degree bound in (6).) The dimension of  <span class="math">\\mathscr{L}&#x27;_M(F)</span>  is dim  <span class="math">\\mathscr{L}&#x27;_M(F) = M</span> , one less than the entire Riemann-Roch space  <span class="math">\\mathscr{L}_M(F)</span> .</p>

    <p class="text-gray-300"><span id="page-4-0"></span><sup>&</sup>lt;sup>5</sup>Here and in the sequel,  <span class="math">\\mathcal{V}(S) = \\bigcap_{P \\in S} \\{ p \\in F[x,y]/(x^2 + y^2 - 1) : p(P) = 0 \\}</span> , for any set  <span class="math">S\\subseteq C(\\mathbb{F}_q)</span> .</p>

    <p class="text-gray-300"><sup>6</sup>We deviate here from the notation in [HLP24], where  <span class="math">\\mathscr{L}_M(F)&#x27;</span>  is the circle FFT space.</p>

    <p class="text-gray-300"><span id="page-4-2"></span></p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">3 The G-FFT</h3>

    <p class="text-gray-300">We keep with the notation of the previous section, and assume that q be a prime (or more generally, a prime power) so that  <span class="math">2^n</span>  divides q+1, for some  <span class="math">n \\geq 2</span> . For any  <span class="math">0 \\leq m \\leq n</span> ,  <span class="math">G_m</span>  is the unique cyclic subgroup of the circle  <span class="math">C(\\mathbb{F}_q)</span> , having order  <span class="math">M = 2^m</span> , and  <span class="math">P_m</span>  denotes a generator of  <span class="math">G_m</span> . In particular,  <span class="math">P_0</span>  is the neutral group element, and  <span class="math">P_1</span>  the unique point of order two.</p>

    <p class="text-gray-300">Compared to the circle FFT, the Galois FFT is closer to the regular multiplicative FFT. It works over arbitrary cosets  <span class="math">D_m</span>  of  <span class="math">G_m</span> ,  <span class="math">m \\leq n</span> , and it uses the chain of domains obtained throughout from the group doubling map  <span class="math">\\pi</span> ,</p>

    <p class="text-gray-300"><span class="math-block">D_m \\xrightarrow{\\pi} D_{m-1} \\xrightarrow{\\pi} D_{m-2} \\xrightarrow{\\pi} \\dots</span>  (7)</p>

    <p class="text-gray-300">where in each step the domain sizes are halved. However, in stark contrast to other FFTs, the Galois FFT takes a twiddle function which has a pole <em>outside</em> the set of fixed points of the group action, and thus is not contained in the Riemann-Roch space: The linear fractional function</p>

    <div class="my-4 text-center"><span class="math-block">t_0(t) = \\frac{1}{t} = \\frac{x-1}{y}</span></div>

    <p class="text-gray-300">has a pole at t=0 corresponding to  <span class="math">P_1</span>  the unique element of order two. We will see that this pole however does not harm, if one works with the punctured Riemann-Roch spaces</p>

    <div class="my-4 text-center"><span class="math-block">\\mathscr{L}&#x27;_M(F) = \\mathscr{L}_M(F) \\cap \\mathcal{V}(G_0).</span></div>

    <p class="text-gray-300">The vanishing constraint at the neutral element  <span class="math">P_0</span>  assures that the pull-back  <span class="math">f \\circ \\pi</span>  of functions from the punctured Riemann-Roch space have a zero at  <span class="math">P_1</span> , cancelling out the pole of the twiddle.</p>

    <p class="text-gray-300">For the sake of simplicity we first describe the coset FFT, in Section 3.1, where the interpolation domain is a non-trivial coset of  <span class="math">G_m</span>  and thus does not contain the exceptional point  <span class="math">P_0</span> , the neutral group element. The remaining case, which we call the group position FFT, is then discussed in Section 3.2. We note that the algorithms in Section 3.1 and 3.2 are minor modifications of the one in [LX23]. Our variant takes the punctured Riemann-Roch space  <span class="math">\\mathscr{L}&#x27;_M(F)</span>  as the function space  <span class="math">\\mathscr{F}_m</span> , whereas Li and Xing choose the space of double dimension, and then size it down by additional vanishing constraints. We postpone a description of their original algorithm to Appendix A.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">3.1 Coset case</h4>

    <p class="text-gray-300">Let  <span class="math">D_m</span>  be a non-trivial coset of the cyclic subgroup  <span class="math">G_m</span> ,  <span class="math">m \\ge 1</span> , and F any extension field of  <span class="math">\\mathbb{F}_q</span> . Given a set of values  <span class="math">f \\in F^{D_m}</span>  the coset FFT computes</p>

    <p class="text-gray-300">the coefficients of  <span class="math">\\hat{f} \\in \\mathcal{L}&#x27;_M(F)</span>  with respect to a specific basis  <span class="math">\\mathcal{B}_m</span>  of  <span class="math">\\mathcal{L}&#x27;_M(F)</span> , defined below, so that  <span class="math">\\hat{f}(P) = f(P)</span>  for every  <span class="math">P \\in D_m</span> . The variant described in this section takes the chain</p>

    <div class="my-4 text-center"><span class="math-block">D_m \\xrightarrow{\\pi} D_{m-1} \\xrightarrow{\\pi} \\dots \\xrightarrow{\\pi} D_1, \\tag{8}</span></div>

    <p class="text-gray-300">down to the two-point domain  <span class="math">D_1</span> , each of which are again non-trivial cosets of the subgroups  <span class="math">G_m</span> ,  <span class="math">G_{m-1}</span> , ...,  <span class="math">G_1</span> , respectively. (The reason why we do not continue down to a singleton domain is that the definition of  <span class="math">\\mathscr{L}_M</span>  fits our purpose only for even degree bounds  <span class="math">M=2^m</span> ,  <span class="math">m\\geq 1</span> .)</p>

    <p class="text-gray-300">Given the function  <span class="math">f \\in F^{D_m}</span>  to be interpolated, the FFT is as follows. In the first step, k = 1, the function  <span class="math">f \\in F^{D_m}</span>  is decomposed into  <span class="math">f_0, f_1 \\in F^{D_{m-1}}</span>  over the "projected" domain, via</p>

    <p class="text-gray-300"><span id="page-6-2"></span><span id="page-6-1"></span><span id="page-6-0"></span> <span class="math-block">f(t) = f_0(\\pi(t)) + \\frac{1}{t} \\cdot f_1(\\pi(t)), \\tag{9}</span></p>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">f_1(\\pi(t)) = \\frac{t}{1+t^2} \\cdot \\left( f(t) - f\\left(-\\frac{1}{t}\\right) \\right),\\tag{10}</span></div>

    <div class="my-4 text-center"><span class="math-block">f_0(\\pi(t)) = f(t) - \\frac{1}{t} \\cdot f_1(\\pi(t)) = \\frac{t}{1+t^2} \\cdot \\left(t \\cdot f(t) + \\frac{1}{t} \\cdot f\\left(-\\frac{1}{t}\\right)\\right). \\tag{11}</span></div>

    <p class="text-gray-300">Note that the right-hand sides of Equation (10) and (11) are well-defined and invariant with respect to  <span class="math">T_0(t) = -\\frac{1}{t}</span> , i.e. the group translation with respect to the generator  <span class="math">P_1</span>  of  <span class="math">G_1</span> . In fact, denoting the right-hand side of Equation (10) by  <span class="math">F_1(t)</span> , we obtain that</p>

    <div class="my-4 text-center"><span class="math-block">F_1\\left(-\\frac{1}{t}\\right) = -\\frac{t}{1+t^2} \\cdot \\left(f\\left(-\\frac{1}{t}\\right) - f(t)\\right) = F_1(t)</span></div>

    <p class="text-gray-300">and likewise the right-hand side  <span class="math">F_0(t)</span>  of Equation (11) satisfies</p>

    <div class="my-4 text-center"><span class="math-block">F_0\\left(-\\frac{1}{t}\\right) = -\\frac{t}{1+t^2}\\cdot\\left(-\\frac{1}{t}\\cdot f\\left(-\\frac{1}{t}\\right) - t\\cdot f(t)\\right) = F_0(t).</span></div>

    <p class="text-gray-300">By invariance with respect to  <span class="math">G_1</span> , both  <span class="math">F_0</span>  and  <span class="math">F_1</span>  are of the claimed form  <span class="math">f_0 \\circ \\pi</span>  and  <span class="math">f_1 \\circ \\pi</span>  with  <span class="math">f_0, f_1 \\in F^{D_{m-1}}</span> , respectively.</p>

    <p class="text-gray-300">In the further steps,  <span class="math">k=2,\\ldots,m-1</span> , corresponding to the domains  <span class="math">D_{m-1},\\ldots,D_2</span> , one proceeds with each of the functions  <span class="math">f_{i_1,\\ldots,i_{k-1}}\\in F^{D_{m-k+1}}</span>  from the previous step,  <span class="math">(i_1,\\ldots,i_{k-1})\\in\\{0,1\\}^{k-1}</span> , in the same manner as with f in the first step, decomposing them into  <span class="math">f_{i_1,\\ldots,i_{k-1},0}</span>  and  <span class="math">f_{i_1,\\ldots,i_{k-1},1}\\in F^{D_{m-k}}</span>  by means of Equation (9), (10) and (11).</p>

    <p class="text-gray-300">In the last step k=m, corresponding to the two-point coset  <span class="math">D_1</span> , each of the functions  <span class="math">f_{i_1,\\dots,i_{m-1}} \\in F^{D_1}</span> ,  <span class="math">(i_1,\\dots,i_{m-1}) \\in \\{0,1\\}^{m-1}</span> , is interpolated by</p>

    <p class="text-gray-300"> <span class="math">(c_1 + c_0 \\cdot t)/(1 + t^2) \\in \\mathcal{L}&#x27;_2(F)</span>  using the explicit formulas<sup>7</sup></p>

    <p class="text-gray-300"><span id="page-7-2"></span> <span class="math-block">c_1 = f(t) + f\\left(-\\frac{1}{t}\\right),\\tag{12}</span></p>

    <p class="text-gray-300"><span id="page-7-3"></span> <span class="math-block">c_0 = t \\cdot f(t) - \\frac{1}{t} \\cdot f\\left(-\\frac{1}{t}\\right). \\tag{13}</span></p>

    <p class="text-gray-300">The obtained coefficients  <span class="math">c_{i_1,\\ldots,i_m} \\in F</span> ,  <span class="math">(i_1,\\ldots,i_m) \\in \\{0,1\\}^m</span> , two for each of the  <span class="math">f_{i_1,\\ldots,i_{m-1}}</span> , are the output of the algorithm.</p>

    <p class="text-gray-300">The coefficients output by the algorithm are in fact the coordinates with respect to the basis as described in the following main theorem.</p>

    <p class="text-gray-300"><span id="page-7-1"></span><strong>Theorem 1</strong> (Coset FFT). Given  <span class="math">f \\in F^{D_m}</span>  a function over a non-trivial coset  <span class="math">D_m</span>  of the subgroup  <span class="math">G_m</span> , where  <span class="math">1 \\leq m \\leq n</span> , the above described algorithm determines the coefficients  <span class="math">c_{i_1,\\ldots,i_m} \\in F</span> ,  <span class="math">(i_1,\\ldots,i_m) \\in \\{0,1\\}^m</span> , of  <span class="math">\\hat{f} = \\sum_{i \\in \\{0,1\\}^m} c_i \\cdot b_{m,i}</span>  with respect to the family  <span class="math">\\mathcal{B}_m</span>  of functions from  <span class="math">\\mathscr{F}_m = \\mathscr{L}&#x27;_M(F)</span>  defined by</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{B}_m = \\{b_{m,i}\\} = \\left\\{ v_{G_m} \\cdot \\prod_{k=0}^{m-1} (t_0 \\circ \\pi^k)^{i_{k+1}} : i = (i_1, \\dots, i_m) \\in \\{0, 1\\}^m \\right\\}, \\quad (14)</span></div>

    <p class="text-gray-300">where  <span class="math">t_0(t) = 1/t</span> ,  <span class="math">v_{G_1}(t) = \\frac{t}{1+t^2}</span>  and  <span class="math">v_{G_m} = v_{G_1} \\circ \\pi^{m-1}</span> . In particular, the functions from  <span class="math">\\mathcal{B}_m</span>  form a basis of  <span class="math">\\mathscr{F}_m</span> .</p>

    <p class="text-gray-300"><strong>Remark 2.</strong> Together with the constant function,  <span class="math">\\mathcal{B}_m \\cup \\{1\\}</span>  is a basis of the non-punctured Riemann-Roch space  <span class="math">\\mathcal{L}_M(F)</span> . Up to non-zero scaling factors, this is the same basis as in [LX23, Lemma 4.4], see Appendix A.</p>

    <p class="text-gray-300"><em>Proof of Theorem 1.</em> We prove the theorem by induction on m. In the case m = 1, Equation (12) and Equation (13) yield the coefficients  <span class="math">c_1</span>  and  <span class="math">c_0</span>  of</p>

    <div class="my-4 text-center"><span class="math-block">b_{0,i_0}(t) = \\frac{v_{G_1}(t)}{t^{i_0}} = \\begin{cases} \\frac{t}{1+t^2} &amp; i_1 = 0, \\\\ \\frac{1}{1+t^2} &amp; i_0 = 1, \\end{cases}</span></div>

    <p class="text-gray-300">which form a basis of the punctured space  <span class="math">\\mathscr{L}&#x27;_2(F) = \\mathscr{L}_2(F) \\cap \\mathcal{V}(G_0)</span> .</p>

    <p class="text-gray-300">Next, suppose that the statement of the theorem is true for some  <span class="math">m, 1 \\le m \\le n-1</span> , and let  <span class="math">f \\in F^{D_{m+1}}</span> . Then for each of the functions  <span class="math">f_0, f_1 \\in F^{D_m}</span>  defined by decomposition</p>

    <div class="my-4 text-center"><span class="math-block">f(t) = f_0(\\pi(t)) + \\frac{1}{t} \\cdot f_1(\\pi(t))</span></div>

    <p class="text-gray-300">the algorithm outputs the coefficients  <span class="math">(c_{0,i_1,\\ldots,i_m})</span>  and  <span class="math">(c_{1,i_1,\\ldots,i_m})</span>  with respect to  <span class="math">\\mathcal{B}_m</span> , and this family is a basis of  <span class="math">\\mathscr{L}&#x27;_M(F)</span> , for  <span class="math">M=2^m</span> . Combining them into</p>

    <p class="text-gray-300"><span id="page-7-0"></span><sup>&</sup>lt;sup>7</sup>Notice that these formulas are normalized and sign-switched variants of (10) and (11).</p>

    <p class="text-gray-300">a single vector  <span class="math">(c_{i_0,i_1,...,i_m})</span>  of size  <span class="math">2^{m+1}</span>  yields the coefficients of f with respect to the family of functions defined by</p>

    <div class="my-4 text-center"><span class="math-block">b_{m+1,i}(t) = \\frac{1}{t^{i_0}} \\cdot b_{m,i_1,\\dots,i_m}(\\pi(t)),</span></div>

    <p class="text-gray-300">where  <span class="math">i=(i_0,\\ldots,i_m)\\in\\{0,1\\}^{m+1}</span> . Since each  <span class="math">b_{m,i_1,\\ldots,i_m}</span>  is from  <span class="math">\\mathscr{L}_M</span>  and vanishes over  <span class="math">G_0</span> , their pull-backs  <span class="math">b_{m,i_1,\\ldots,i_m}\\circ\\pi</span>  belong to  <span class="math">\\mathscr{L}_{2M}</span>  and they vanish over  <span class="math">G_1</span> . In particular, multiplication by the twiddle  <span class="math">t_0(t)=1/t</span> , which has a single simple pole at  <span class="math">P_1</span> , does change neither the membership to  <span class="math">\\mathscr{L}_{2M}</span> , nor the value zero at  <span class="math">P_0</span> . This shows that the functions from  <span class="math">\\mathcal{B}_{m+1}</span>  belong to  <span class="math">\\mathscr{L}&#x27;_{2\\cdot M}(F)=\\mathscr{L}_{2\\cdot M}(F)\\cap\\mathcal{V}(G_0)</span> , and their linear combination using the coefficient vector  <span class="math">(c_{i_0,\\ldots,i_{m+1}})</span>  interpolate the given function  <span class="math">f\\in F^{D_{m+1}}</span> . Since f was arbitrary, the span of  <span class="math">\\mathcal{B}_{m+1}</span>  is  <span class="math">2^{m+1}</span> -dimensional, which equals the dimension of the punctured space  <span class="math">\\mathscr{L}&#x27;_{2\\cdot M}(F)</span> . In other words,  <span class="math">\\mathcal{B}_{m+1}</span>  is a basis of  <span class="math">\\mathscr{L}&#x27;_{2\\cdot M}(F)</span> , proving the statement of the theorem for m+1.</p>

    <p class="text-gray-300"><span id="page-8-0"></span><strong>Remark 3.</strong> The coset FFT can be implemented as a butterfly network, which modifies the values over  <span class="math">D_m</span>  pairwise and in-place by means of Equation (10) and (11), and in the last step via Equation (12) and (13). Counting subtractions as additions, each butterfly costs two additions over F and two multiplications by precomputed elements of  <span class="math">\\mathbb{F}_q</span> , yielding an overall cost of</p>

    <div class="my-4 text-center"><span class="math-block">m \\cdot 2^m \\cdot (\\mathsf{M} + \\mathsf{A})</span></div>

    <p class="text-gray-300">for the entire algorithm, where M are multiplications of elements from F by scalars of  <span class="math">\\mathbb{F}_q</span> , and A additions in F.</p>

    <p class="text-gray-300">The inverse FFT for domain evaluation reverses each of the decomposition steps of the FFT. Given the coefficient vector  <span class="math">(c_{i_1,\\dots,i_{m-1},i_m})</span> , each of the functions  <span class="math">f_{i_1,\\dots,i_{m-1}} = c_{i_1,\\dots,i_{m-1},0} \\cdot b_{1,0} + c_{i_1,\\dots,i_{m-1},1} \\cdot b_{1,1}</span>  is evaluated over  <span class="math">D_1</span>  via the inverse butterfly of Equation (12) and Equation (13),</p>

    <div class="my-4 text-center"><span class="math-block">f(t) = \\frac{1}{1+t^2} \\cdot c_1 + \\frac{t}{1+t^2} \\cdot c_0, \\tag{15}</span></div>

    <div class="my-4 text-center"><span class="math-block">f\\left(-\\frac{1}{t}\\right) = \\frac{t^2}{1+t^2} \\cdot c_1 - \\frac{t}{1+t^2} \\cdot c_0 = c_1 - f(t). \\tag{16}</span></div>

    <p class="text-gray-300">In the other steps, one takes</p>

    <div class="my-4 text-center"><span class="math-block">f(t) = f_0(\\pi(t)) + \\frac{1}{t} \\cdot f_1(\\pi(t)), \\tag{17}</span></div>

    <div class="my-4 text-center"><span class="math-block">f\\left(-\\frac{1}{t}\\right) = f_0(\\pi(t)) - t \\cdot f_1(\\pi(t)),\\tag{18}</span></div>

    <p class="text-gray-300">to combine the values of  <span class="math">f_{i_1,...,i_{m-k},0}</span> ,  <span class="math">f_{i_1,...,i_{m-k},1} \\in F^{D_{m-k}}</span>  into the values of  <span class="math">f_{i_1,...,i_{m-k},i_{m-k+1}}</span>  over  <span class="math">D_{m-k+1}</span> . Both butterflies again cost two additions in F and two multiplications by elements from  <span class="math">\\mathbb{F}_q</span> . We summarize the result by the following theorem.</p>

    <p class="text-gray-300"><span id="page-9-5"></span><strong>Theorem 4</strong> (Evaluation over cosets). Given the coefficients  <span class="math">c_i \\in F</span> ,  <span class="math">i = (i_1, \\ldots, i_m) \\in \\{0, 1\\}^m</span> , with respect to  <span class="math">\\mathcal{B}_m = \\{b_{m,i}\\}</span>  as in Theorem 1, the above sketched algorithm computes the values of</p>

    <div class="my-4 text-center"><span class="math-block">f(t) = \\sum_{i \\in \\{0,1\\}^m} c_i \\cdot b_{m,i}(t)</span></div>

    <p class="text-gray-300">over the non-trivial coset  <span class="math">D_m</span> , within  <span class="math">m \\cdot 2^m</span>  additions in F and  <span class="math">m \\cdot 2^m</span>  multiplications of elements in F with (precomputed) elements from  <span class="math">\\mathbb{F}_q</span> .</p>

    <h2 id="sec-9" class="text-2xl font-bold">3.2 Group position</h2>

    <p class="text-gray-300">For the exceptional case that the coset  <span class="math">D_m</span>  is in group position, i.e.  <span class="math">D_m = G_m</span> , the FFT from Section 3.1 can be easily modified to solve the generalized interpolation problem over the domain.</p>

    <p class="text-gray-300"><strong>Definition 5.</strong> Given values  <span class="math">f \\in F^{G_m}</span> , the generalized interpolation problem asks for a function  <span class="math">\\hat{f}</span>  from the punctured Riemann-Roch space  <span class="math">\\mathscr{F}_m = \\mathscr{L}&#x27;_M(F)</span>  such that  <span class="math">\\hat{f}(t) = f(t)</span>  for every  <span class="math">t \\in G_m \\setminus G_0</span> , and  <span class="math">t \\cdot \\hat{f}(t) = f(t)</span>  at the exceptional point  <span class="math">t = \\infty</span> .</p>

    <p class="text-gray-300">The function  <span class="math">f \\in F^{D_m}</span>  is decomposed into  <span class="math">f_0, f_1 \\in F^{D_{m-1}}</span>  in the usual way, using Equation (10) and (11) for  <span class="math">t \\in D_m \\setminus G_1</span> , yielding their values over  <span class="math">D_{m-1} \\setminus G_0</span> . To determine  <span class="math">f_0</span>  and  <span class="math">f_1</span>  at the exceptional point, one takes</p>

    <p class="text-gray-300"><span id="page-9-3"></span> <span class="math-block">f_1(\\infty) = -\\frac{f(0)}{2},\\tag{19}</span></p>

    <p class="text-gray-300"><span id="page-9-4"></span> <span class="math-block">f_0(\\infty) = \\frac{f(\\infty)}{2}. (20)</span></p>

    <p class="text-gray-300">The rationale behind these formulas is taken from the observation that their low-degree extensions satisfy</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{aligned} t' \\cdot \\hat{f}_1(t') \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{t'=\\infty} &= \\left. \\frac{t^2 - 1}{2 \\cdot t} \\cdot \\frac{t}{1 + t^2} \\cdot \\left( \\hat{f}(t) - \\hat{f}\\left( -\\frac{1}{t} \\right) \\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{t=\\infty}, \\\\ t' \\cdot \\hat{f}_0(t') \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{t'=\\infty} &= \\left. \\frac{t^2 - 1}{2 \\cdot t} \\cdot \\frac{t}{1 + t^2} \\cdot \\left( t \\cdot \\hat{f}(t) + \\frac{1}{t} \\cdot \\hat{f}\\left( -\\frac{1}{t} \\right) \\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{t=\\infty}, \\end{aligned}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where in both formulas  <span class="math">t&#x27; = \\pi(t)</span> . This procedure is applied to all the other steps k = 2, ..., m-1 which correspond to domain sizes larger than two. In the final step, k = m, determining the coefficients of  <span class="math">f := f_{i_1,...,f_{m-1}} \\in F^{G_1}</span>  with respect to  <span class="math">\\mathcal{B}_1 = \\{b_{1,0}, b_{1,1}\\}</span>  is trivial: Taking</p>

    <p class="text-gray-300"><span id="page-9-1"></span> <span class="math-block">c_1 = f(0),</span>  (21)</p>

    <p class="text-gray-300"><span id="page-9-2"></span> <span class="math-block">c_0 = f(\\infty), \\tag{22}</span></p>

    <p class="text-gray-300">gives  <span class="math">\\hat{f}(t) = c_0 \\cdot b_{1,0}(t) + c_1 \\cdot b_{1,1}(t)</span>  which solves the generalized interpolation problem over  <span class="math">G_1</span> .</p>

    <p class="text-gray-300"><strong>Theorem 6</strong> (Group position FFT). Given  <span class="math">f \\in F^{G_m}</span> , the above sketched modified FFT computes the coefficients of  <span class="math">\\hat{f} \\in \\mathscr{F}_m</span>  with respect to the basis  <span class="math">\\mathcal{B}_m</span>  as in Theorem 1, so that  <span class="math">\\hat{f}(t) = f(t)</span>  for  <span class="math">t \\in G_m \\setminus G_0</span> , and  <span class="math">t \\cdot \\hat{f}(t) = f(t)</span>  at  <span class="math">t = \\infty</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The proof is similar to that of Theorem 1. For m=1, the function  <span class="math">\\hat{f}(t)=c_0\\cdot b_{1,0}(t)+c_1\\cdot b_{1,1}(t)</span>  with  <span class="math">c_1,c_0</span>  as in Equation (21) and (22) obviously satisfies the generalized interpolation problem over  <span class="math">G_1=\\{0,\\infty\\}</span> , since</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\hat{f}(t) = c_0 \\cdot \\frac{t}{1+t^2} + c_1 \\cdot \\frac{1}{1+t^2} \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{t=0} = c_1,$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$t \\cdot \\hat{f}(t) = c_0 \\cdot \\frac{t^2}{1 + t^2} + c_1 \\cdot \\frac{t}{1 + t^2} \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{t = \\infty} = c_0.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For the induction step, if  <span class="math">\\hat{f}_0, \\hat{f}_1 \\in \\mathscr{L}&#x27;_M(F)</span>  satisfy the generalized interpolation problem for  <span class="math">f_0, f_1 \\in F^{G_m}</span>  as defined by Equation (10) and (11) for  <span class="math">t \\in G_{m+1} \\setminus G_1</span> , and Equation (19) and (20) at the exceptional point, then</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{f}(t) = \\hat{f}_0(\\pi(t)) + \\frac{1}{t} \\cdot \\hat{f}_1(\\pi(t))</span></div>

    <p class="text-gray-300">satisfies the generalized interpolation problem for  <span class="math">f \\in F^{G_{m+1}}</span> : For the regular points  <span class="math">t \\in D_{m+1} \\setminus G_1</span>  we have  <span class="math">\\hat{f}(t) = f(t)</span>  for the usual reasons, and over  <span class="math">G_1</span>  we get</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\hat{f}(t) = \\hat{f}_0(\\pi(t)) + \\frac{1}{t} \\cdot \\hat{f}_1(\\pi(t)) \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{t=0} = \\hat{f}_0(t') - 2 \\cdot t' \\cdot \\hat{f}_1(t') \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{t'=\\infty} = f(0),$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">since  $t \\cdot t' = t \\cdot \\frac{t^2 - 1}{2 \\cdot t} \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{t=0} = -1/2<span class="math">  and  </span>\\hat{f}_0(\\infty) = 0$ , whereas</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$t \\cdot \\hat{f}(t) = t \\cdot \\hat{f}_0(\\pi(t)) + \\hat{f}_1(\\pi(t))\\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{t=\\infty} = 2 \\cdot t' \\cdot \\hat{f}_0(t') + \\hat{f}_1(t')\\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{t=\\infty} = f(\\infty),$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">since</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$t/t' = t \\cdot \\frac{2 \\cdot t}{t^2 - 1} \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{t=\\infty} = 2$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> and  <span class="math">\\hat{f}_1(\\infty) = 0</span> .</p>

    <p class="text-gray-300">Likewise, the inverse FFT can be modified to compute the generalized evaluation of a function  <span class="math">\\hat{f} \\in \\mathcal{L}&#x27;_M(F)</span>  over the group position domain  <span class="math">G_m</span> .</p>

    <p class="text-gray-300"><strong>Definition 7.</strong> The generalized evaluation of a function  <span class="math">\\hat{f} \\in \\mathscr{F}_m</span>  over  <span class="math">G_m</span>  outputs the value of  <span class="math">\\hat{f}(t)</span>  for every  <span class="math">t \\in G_m \\setminus G_0</span>  and the value of  <span class="math">t \\cdot \\hat{f}(t)</span>  at  <span class="math">t = \\infty</span> .</p>

    <p class="text-gray-300">In the first step k=1, generalized evaluation of each  <span class="math">f_{i_1,...,i_{m-1}}</span>  over  <span class="math">D_1</span>  is directly read off the coefficients  <span class="math">c_{i_1,...,i_{m-1},0}</span>  and  <span class="math">c_{i_1,...,i_{m-1},1}</span>  using Equation (21) and Equation (22), and in the other steps  <span class="math">2 \\le k \\le m</span> , corresponding to</p>

    <p class="text-gray-300">the larger domains  <span class="math">G_2, \\ldots, G_m</span> , the values of  <span class="math">\\hat{f}_{i_1,\\ldots,i_{m-k},0}</span>  and  <span class="math">\\hat{f}_{i_1,\\ldots,i_{m-k},1}</span>  are combined into those of  <span class="math">\\hat{f}_{i_1,\\ldots,i_{m-k},i_{m-k+1}}</span>  in the usual manner at the regular points  <span class="math">t \\in G_k \\setminus G_1</span> , and by Equation (19) and Equation (20) at the exceptional point.</p>

    <p class="text-gray-300"><strong>Theorem 8</strong> (Evaluation over subgroups). Given coefficients  <span class="math">c_i \\in F</span> ,  <span class="math">i \\in \\{0,1\\}^m</span> , the above sketched inverse FFT computes the generalized evaluation of  <span class="math">\\hat{f} = \\sum_i c_i \\cdot b_{m,i} \\in \\mathscr{F}_m</span>  over  <span class="math">G_m</span> .</p>

    <p class="text-gray-300">In terms of group operations, the cost of both the group position FFT and its inverse is essentially that of the coset FFT.</p>

    <h2 id="sec-10" class="text-2xl font-bold">3.3 Explicit form of the basis</h2>

    <p class="text-gray-300">For an explicit form of the basis  <span class="math">\\mathcal{B}_m</span>  of the FFT space  <span class="math">\\mathscr{F}_m = \\mathscr{L}&#x27;_M(F)</span> , an alternative representation based on vanishing functions is more useful than the one from Theorem 1. For  <span class="math">1 \\leq k &lt; n</span> , let  <span class="math">v_{G_k} = v_{G_1} \\circ \\pi^{k-1}</span>  and  <span class="math">v_{G&#x27;_k} = v_{G&#x27;_1} \\circ \\pi^{k-1}</span> , where</p>

    <div class="my-4 text-center"><span class="math-block">v_{G_1} = y = \\frac{2 \\cdot t}{t^2 + 1}, \\quad v_{G&#x27;_1} = x = \\frac{t^2 - 1}{t^2 + 1}.</span></div>

    <p class="text-gray-300">(Note that, compared to the previous sections we use a scaled variant of  <span class="math">v_{G_1}</span>  here. This is for more elegant expressions.) It follows from their definition that  <span class="math">v_{G_k}</span>  and  <span class="math">v_{G&#x27;_k}</span>  have simple zeros over  <span class="math">G_k</span>  and its complementing coset  <span class="math">G&#x27;_k</span> , respectively, and poles at  <span class="math">t = \\pm i</span>  of order  <span class="math">2^k</span>  each. (No other poles and zeros present.) Thus they belong to  <span class="math">\\mathcal{L}_{2^k}(\\mathbb{F}_q)</span> . Their explicit representation</p>

    <div class="my-4 text-center"><span class="math-block">v_{G_k}(t) = \\frac{u_k(t)}{(t^2+1)^{2^{k-1}}}, \\quad v_{G&#x27;_k}(t) = \\frac{v_k(t)}{(t^2+1)^{2^{k-1}}},</span></div>

    <p class="text-gray-300">with polynomials  <span class="math">u_k(t), v_k(t) \\in \\mathbb{F}_q[t]</span> , where  <span class="math">\\deg u_k = 2^k - 1</span>  and  <span class="math">\\deg v_k = 2^k</span> , can be obtained recursively via the same law</p>

    <div class="my-4 text-center"><span class="math-block">u_{k+1}(t) = (2 \\cdot t)^{2^k} \\cdot u_k \\left( \\frac{t^2 - 1}{2 \\cdot t} \\right), \\quad v_{k+1}(t) = (2 \\cdot t)^{2^k} \\cdot v_k \\left( \\frac{t^2 - 1}{2 \\cdot t} \\right),</span></div>

    <p class="text-gray-300">starting with  <span class="math">u_1(t) = 2 \\cdot t</span>  and  <span class="math">v_1(t) = t^2 - 1</span> , respectively. Alternatively, they can be derived from the circle polynomials  <span class="math">v_{G_k}</span>  and  <span class="math">v_{G&#x27;_k}</span> , which are recursively given by</p>

    <div class="my-4 text-center"><span class="math-block">v_{G&#x27;_{k+1}}(x) = v_{G&#x27;_{k}}(2 \\cdot x^{2} - 1),</span></div>

    <div class="my-4 text-center"><span class="math-block">v_{G_{k+1}} = 2 \\cdot v_{G_{k}} \\cdot v_{G&#x27;_{k}},</span></div>

    <p class="text-gray-300">starting with  <span class="math">v_{G_1&#x27;} = x</span>  and  <span class="math">v_{G_1} = y</span> .</p>

    <p class="text-gray-300"><span id="page-12-0"></span><strong>Lemma 1.</strong> For  <span class="math">1 \\le k &lt; n</span> , it holds that  <span class="math">v_{G_k} \\cdot v_{G&#x27;_k} = 2 \\cdot v_{G_{k+1}}</span> . In particular  <span class="math">v_{G_m} = 2^{m-1} \\cdot v_{G_1} \\cdot v_{G&#x27;_1} \\cdot \\dots \\cdot v_{G&#x27;_{m-1}}</span> , for  <span class="math">1 \\le m \\le n</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The first assertion follows from  <span class="math">v_{G_k} = v_{G_1} \\circ \\pi^{k-1}</span>  and  <span class="math">v_{G&#x27;_k} = v_{G&#x27;_1} \\circ \\pi^{k-1}</span> , and that</p>

    <div class="my-4 text-center"><span class="math-block">v_{G_2} = v_{G_1} \\circ \\pi = 4 \\cdot t \\cdot \\frac{t^2 - 1}{(t^2 - 1)^2 + 4 \\cdot t^2} = 2 \\cdot \\frac{2 \\cdot t \\cdot (t^2 - 1)}{(t^2 + 1)^2} = 2 \\cdot v_{G_1} \\cdot v_{G_1&#x27;}.</span></div>

    <p class="text-gray-300">The second assertion is obtained by repeated application of the first.  <span class="math">\\Box</span></p>

    <p class="text-gray-300"><strong>Proposition 1.</strong> In terms of the vanishing functions  <span class="math">v_{G_k}</span>  and  <span class="math">v_{G&#x27;_k}</span>  we have</p>

    <div class="my-4 text-center"><span class="math-block">b_{m,i} = 2^{m-2} \\cdot \\frac{v_{G_1}}{t^{i_1}} \\cdot \\prod_{k=1}^{m-1} \\left( i_{k+1} \\cdot v_{G_k} + (1 - i_{k+1}) \\cdot v_{G&#x27;_k} \\right). \\tag{23}</span></div>

    <p class="text-gray-300">Therefore, by means of the univariate vanishing polynomials  <span class="math">u_k</span>  and  <span class="math">v_k</span> , we obtain the representation  <span class="math">b_{m,i} = p_{m,i}(t)/(1+t^2)^{2^{m-1}}</span> , with polynomials</p>

    <div class="my-4 text-center"><span class="math-block">p_{m,i} = 2^{m-2} \\cdot t^{1-i_1} \\cdot \\prod_{k=1}^{m-1} (i_{k+1} \\cdot u_k + (1-i_{k+1}) \\cdot v_k), \\qquad (24)</span></div>

    <p class="text-gray-300">These polynomials form a basis of  <span class="math">\\mathbb{F}_q[t]^{&lt; M}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Using Lemma 1, and  <span class="math">t_0 \\circ \\pi^k = \\frac{v_{G_k}}{v_{G&#x27;_k}}</span>  for  <span class="math">1 \\le k \\le m-1</span> , we obtain</p>

    <div class="my-4 text-center"><span class="math-block">b_{m,i} = \\frac{1}{2} \\cdot 2^{m-1} \\cdot \\frac{v_{G_1}}{t^{i_1}} \\cdot v_{G&#x27;_1} \\cdot \\ldots \\cdot v_{G&#x27;_{m-1}} \\cdot \\prod_{k=1}^{m-1} \\left(\\frac{v_{G_k}}{v_{G&#x27;_k}}\\right)^{i_{k+1}}.</span></div>

    <p class="text-gray-300">(The leading factor 1/2 is for the different convention of  <span class="math">v_{G_m}</span>  in Theorem 1.) Thus the bit  <span class="math">i_{k+1}</span>  effectively selects between  <span class="math">v_{G&#x27;_k}</span>  and  <span class="math">v_{G_k}</span> , for  <span class="math">k=1,\\ldots,m-1</span> , yielding</p>

    <div class="my-4 text-center"><span class="math-block">b_{m,i} = 2^{m-1} \\cdot \\frac{v_{G_1}}{t^{i_1}} \\cdot \\prod_{k=1}^{m-1} \\left( i_{k+1} \\cdot v_{G_k} + (1 - i_{k+1}) \\cdot v_{G&#x27;_k} \\right),</span></div>

    <p class="text-gray-300">from which the univariate representation follows.</p>

    <p class="text-gray-300">In bivariate coordinates, the first four vanishing polynomials are</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} v_{G_1&#x27;} &amp;= x, &amp; v_{G_1} &amp;= y, \\\\ v_{G_2&#x27;} &amp;= 2 \\; x^2 - 1, &amp; v_{G_2} &amp;= y \\cdot x, \\\\ v_{G_3&#x27;} &amp;= 8 \\; x^4 - 8 \\; x^2 + 1, &amp; v_{G_3} &amp;= y \\cdot (2 \\; x^3 - x), \\\\ v_{G_4&#x27;} &amp;= 128 \\; x^8 - 256 \\; x^6 + 160 \\; x^4 - 32 \\; x^2 + 1, &amp; v_{G_4} &amp;= y \\cdot (16 \\; x^7 - 24 \\; x^5 + 10 \\; x^3 - x), \\end{split}</span></div>

    <p class="text-gray-300">whereas in univariate coordinates we obtain the numerator polynomials</p>

    <p class="text-gray-300"><span class="math-block">v_1 = t^2 - 1,</span>   <span class="math">u_1 = 2t,</span>  <span class="math">v_2 = t^4 - 6t^2 + 1,</span>   <span class="math">u_2 = 2t \\cdot (t^2 - 1),</span>  <span class="math">v_3 = t^8 - 28t^6 + 70t^4 - 28t^2 + 1,</span>   <span class="math">u_3 = 2t \\cdot (t^6 - 7t^4 + 6t^2 - 1),</span></p>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">v_4 = t^{16} - 120 \\ t^{14} + 1820 \\ t^{12} - 8008 \\ t^{10} + 12870 \\ t^8 - 8008 \\ t^6 + 1820 \\ t^4 - 120 \\ t^2 + 1,</span></div>

    <div class="my-4 text-center"><span class="math-block">u_4 = 2 \\ t \\cdot (t^{14} - 35 \\ t^{12} + 273 \\ t^{10} - 715 \\ t^8 + 715 \\ t^6 - 273 \\ t^4 + 35 \\ t^2 - 1).</span></div>

    <h2 id="sec-11" class="text-2xl font-bold">4 Comparison with the circle FFT</h2>

    <p class="text-gray-300">The circle FFT from [HLP24] uses a fundamentally different strategy for bounding the degree of the function spaces  <span class="math">\\mathscr{F}_m</span> . Instead of working with the group squaring map  <span class="math">\\pi</span>  alone, the first step of the FFT is with respect to the quotient map</p>

    <div class="my-4 text-center"><span class="math-block">\\phi_J: C(\\mathbb{F}_q) \\longrightarrow C(\\mathbb{F}_q)/J</span></div>

    <p class="text-gray-300">of the group inversion automorphism J(x,y)=(x,-y), which is a linear (and not quadratic) algebraic map. The subsequent steps are then performed with respect to the group squaring map  <span class="math">\\pi</span> , which uniquely translates to a map on the quotient  <span class="math">C(\\mathbb{F}_q)/J</span> , since J and  <span class="math">\\pi</span>  commute, i.e.  <span class="math">J \\circ \\pi = \\pi \\circ J</span> . This leads to the reduction chain</p>

    <div class="my-4 text-center"><span class="math-block">D_m \\xrightarrow{\\phi_J} D_m/J \\xrightarrow{\\pi} D_{m-1}/J \\xrightarrow{\\pi} \\dots \\xrightarrow{\\pi} D_m/J,</span></div>

    <p class="text-gray-300">whereas the quotient sets may be also regarded as subset of the x-axis, and  <span class="math">\\phi_J</span>  as projection onto it. Considering the domain  <span class="math">D_m</span>  being the standard position cosets of  <span class="math">G_m</span>  (i.e.  <span class="math">D_m = G&#x27;_m</span>  with  <span class="math">G&#x27;_m</span>  being the unique coset of  <span class="math">G_m</span>  such that  <span class="math">G&#x27;_m \\cap G_m = G_{m+1}</span> ) all maps are 2-to-1, halving the domains in each of the steps. In the first step, the twiddle function y is taken, and in the other steps x. The resulting function space  <span class="math">\\mathcal{F}_m</span>  is the subspace of  <span class="math">\\mathscr{L}_M(F)</span>  spanned by the basis</p>

    <div class="my-4 text-center"><span class="math-block">b_{m,i} = y^{i_1} \\cdot \\prod_{k=1}^{m-1} (x \\circ \\pi^{k-1})^{i_{k+1}} = y^{i_1} \\cdot \\prod_{k=1}^{m-1} v_{G&#x27;_k}^{i_{k+1}},</span></div>

    <p class="text-gray-300">where  <span class="math">i=(i_1,\\ldots,i_m)\\in\\{0,1\\}^m</span> . The complete Riemann-Roch space  <span class="math">\\mathscr{L}_M(F)</span>  decomposes as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathscr{L}_M(F) = \\mathscr{F}_m(F) + \\langle v_{D_m} \\rangle,</span></div>

    <p class="text-gray-300">and this decompositions is orthogonal in a certain sense [HLP24, Section 4.3].</p>

    <p class="text-gray-300">Overall, the circle FFT has the following advantages over the G-FFT:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Concrete performance. The twiddle functions of the circle FFT are alternating under the action of the kernel group (which acts transitively on the fibers of the projections), and thus yield a butterfly network which consumes only the half number of multiplications (by pre-computed twiddle values) than additions, yielding the usual computational cost</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{FFT}(2^m) = m \\cdot 2^{m-1} \\cdot \\mathsf{M} + m \\cdot 2^m \\cdot \\mathsf{A},</span></div>

    <p class="text-gray-300">as for a regular multiplicative FFT. The G-FFT instead (both the variants from Section 3.1 and 3.2, as well as the original described in Appendix A) costs the double amount of multiplications</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{FFT}(2^m) = m \\cdot 2^m \\cdot \\mathsf{M} + m \\cdot 2^m \\cdot \\mathsf{A},</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>cf. Remark 3 of Theorem 1, and Theorem 4. This double multiplication cost is due to the fact that the twiddle function  <span class="math">t_0</span>  does not alternate under action of the kernel group<sup>8</sup> <span class="math">G_1</span> , i.e.  <span class="math">t_0(-1/t) \\neq -t_0(t)</span> .</li>

      <li>2. Rotation invariance. Contrary to the punctured Riemann-Roch space  <span class="math">\\mathscr{L}&#x27;_M(F)</span> , the circle FFT space  <span class="math">\\mathscr{F}_m</span>  is invariant under rotations by elements from  <span class="math">G_m</span>  [HLP24, Section 4.3], which makes it more suitable for the proving algebraic intermediate representations (AIR) [BSBHR18, BSGKS20, Sta23], or more generally Plonk-ish arithmetization [GWC19].</li>

    </ul>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">References</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-14-3"></span>[BSBHR18] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. In <em>IACR ePrint Archive 2018/046</em>, 2018. https: //eprint.iacr.org/2018/046.</li>

      <li><span id="page-14-1"></span>[BSCKL21] Eli Ben-Sasson, Dan Carmon, Swastik Kopparty, and David Levit. Elliptic Curve Fast Fourier Transform (ECFFT) Part I: Fast polynomial algorithms over all finite fields. In <em>Electronic Colloquium on Compputational Complexity</em>, volume TR21-103, 2021. https://eccc.weizmann.ac.il/report/2021/103/.</li>

      <li><span id="page-14-4"></span>[BSGKS20] Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. DEEP-FRI: Sampling outside the box improves soundness. In ITCS 2020, 2020. Full paper: https://eprint.iacr.org/ 2019/336.</li>

      <li><span id="page-14-0"></span>[Can89] David G. Cantor. On arithmetical algorithms over finite fields. In Journal of Combinatorial Theory, volume Series A 50, 1989.</li>

    </ul>

    <p class="text-gray-300"><span id="page-14-2"></span><sup>&</sup>lt;sup>8</sup>The kernel group parametrizes the fibers of the 2-to-1 mappings, hence the name.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-15-5"></span>[CT65] James W. Cooley and John W. Tukey. An algorithm for the machine calculation of complex Fourier series. In Mathematics of Computation, volume 19 (90), pages 297–301, 1965.</li>

      <li><span id="page-15-7"></span>[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over Lagrange-bases for oecumenical noninteractive arguments of knowledge. In IACR ePrint Archive 2019/953, 2019. <https://eprint.iacr.org/2019/953>.</li>

      <li><span id="page-15-1"></span>[HLP24] Ulrich Hab¨ock, David Levit, and Shahar Papini. Circle STARKs. In IACR preprint archive, 2024. <a href="https://eprint.iacr.org/2024/278">https://eprint.iacr.org/2024/</a> <a href="https://eprint.iacr.org/2024/278">278</a>.</li>

      <li><span id="page-15-4"></span>[LCH14] Sian-Jheng Lin, Wei-Ho Chung, and Yunghsiang S. Han. Novel polynomial basis and its application to Reed-Solomon erasure codes. In FOCS 2014, 2014.</li>

      <li><span id="page-15-0"></span>[LX23] Songsong Li and Chaoping Xing. Fast Fourier transform via automorphicsm groups of rational function fields. In arXiv:2310.14462, 2023. <https://arxiv.org/abs/2310.14462>.</li>

      <li><span id="page-15-6"></span>[Sta23] StarkWare Team. ethSTARK documentation – version 1.2. In IACR preprint archive 2021/582, 2023. <a href="https://eprint.iacr.org/2021/582">https://eprint.iacr.</a> <a href="https://eprint.iacr.org/2021/582">org/2021/582</a>.</li>

      <li><span id="page-15-3"></span>[vzGG96] Joachim von zur Gathen and J¨urgen Gerhard. Arithemtic and factorization of polynomials over F2. In ISSAC'96, 1996.</li>

    </ul>

    <p class="text-gray-300">We describe the original G-FFT from Li and Xing, restricted to the two-adic case, and domains of size smaller than q + 1.</p>

    <p class="text-gray-300">As before, q is a prime (or a prime power) so that q + 1 = 2<sup>n</sup> · t for some integer n ≥ 0 and odd t ≥ 1. Given domain size M = 2m, where we assume that m ≤ n − 1 in our description, the authors construct a function basis of the Riemann-Roch space from the Gk-invariant functions<a href="#page-15-8">9</a></p>

    <div class="my-4 text-center"><span class="math-block">x_k = \\sum_{\\tau \\in G_k} \\tau(t), \\quad y_k = \\prod_{\\tau \\in G_k} \\tau\\left(\\frac{1}{1+t^2}\\right), \\tag{25}</span></div>

    <p class="text-gray-300">where 0 ≤ k ≤ m, which (up to scaling factors) is the basis from Theorem <a href="#page-7-1">1.</a> This can be seen from their definition of the basis functions as</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{x_{m-1} \\cdot y_{m-1}}{x_0^{i_0} \\cdots x_{m-1}^{i_{m-1}}},</span></div>

    <p class="text-gray-300"><span id="page-15-8"></span><sup>9</sup>The group action of G<sup>k</sup> on the space of rational functions is given by τ(f)(t) := f(τ−<sup>1</sup> ⊙t) for τ ∈ Gk.</p>

    <p class="text-gray-300">and the following two lemmas.</p>

    <p class="text-gray-300"><span id="page-16-1"></span><strong>Lemma 2.</strong> For any  <span class="math">0 \\le k \\le n</span>  the  <span class="math">G_k</span> -invariant function  <span class="math">x_k</span>  is equal to</p>

    <p class="text-gray-300"><span id="page-16-0"></span> <span class="math-block">x_k = 2^k \\cdot \\pi^k(t), \\tag{26}</span></p>

    <p class="text-gray-300">where  <span class="math">\\pi</span>  is the group squaring map. The function has simple poles over  <span class="math">G_k</span> , and whenever k < n it has simple zeros over the complementing coset  <span class="math">G&#x27;_k = \\sigma \\odot G_k</span> , where  <span class="math">\\sigma</span>  is of order  <span class="math">2^{k+1}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We proof Equation (26) by induction. Taking  <span class="math">\\pi^0</span>  as the identity map, Equation (26) is trivially true for k=0. Assume that it holds for some  <span class="math">0 \\le k &lt; n</span> . Taking the decomposition  <span class="math">G_{k+1} = G_k \\cup \\sigma \\odot G_k</span> , where  <span class="math">\\sigma</span>  is an element of order  <span class="math">2^{k+1}</span> , we obtain</p>

    <div class="my-4 text-center"><span class="math-block">x_{k+1} = \\sum_{\\tau \\in G_{k+1}} \\tau(t) = \\sum_{\\tau \\in G_k} \\tau(t) + \\sum_{\\tau \\in G_k} \\tau(\\sigma(t))$$ $$= 2^k \\cdot (\\pi^k(t) + \\pi^k(\\sigma(t))).</span></div>

    <p class="text-gray-300">Note that  <span class="math">\\pi^k</span>  is a group endomorphism which maps  <span class="math">\\sigma</span>  to  <span class="math">P_1 = 0</span> , the generator of the two-point subgroup  <span class="math">G_1</span> . Hence for every point t on the projective line  <span class="math">\\pi^k(\\sigma(t)) = \\pi^k(\\sigma^{-1} \\odot t) = 0 \\odot \\pi^k(t) = -1/\\pi^k(t)</span> , which by degree holds as a formal identity. Therefore,</p>

    <div class="my-4 text-center"><span class="math-block">x_{k+1} = 2^k \\cdot \\left(\\pi^k(t) - \\frac{1}{\\pi^k(t)}\\right) = 2^{k+1} \\cdot \\frac{\\pi^k(t)^2 - 1}{2 \\cdot \\pi^k(t)}$$ $$= 2^{k+1} \\cdot \\pi(\\pi^k(t)) = 2^{k+1} \\cdot \\pi^{k+1}(t),</span></div>

    <p class="text-gray-300">which proves the claim for k+1. The assertion on the poles and zeros of  <span class="math">x_k</span>  follows from Equation (26).</p>

    <p class="text-gray-300"><span id="page-16-3"></span><strong>Lemma 3.</strong> For any  <span class="math">0 \\le k \\le n</span>  the  <span class="math">G_k</span> -invariant function  <span class="math">y_k</span>  is equal to</p>

    <p class="text-gray-300"><span id="page-16-2"></span> <span class="math-block">y_k = \\frac{1}{4^{2^k - 1}} \\cdot \\frac{1}{\\pi^k(t)^2 + 1} \\tag{27}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">\\pi</span>  is the group squaring map. The function has zeros over  <span class="math">G_k</span> , each of order 2, and poles at  <span class="math">t = \\pm i</span> , each of order  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>Proof.</em> Since the action of  <span class="math">G_k</span>  leaves  <span class="math">\\pm i</span>  fixed, and lets  <span class="math">\\infty</span>  visit every point from  <span class="math">G_k</span> , the product  <span class="math">y_k</span>  has poles at  <span class="math">t = \\pm i</span> , each of order  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , and zeros over  </span>G_k<span class="math"> , each of order 2. No other poles and zeros present. The same is true for  </span>1/(\\pi^k(t)^2+1)<span class="math">  which shows that  </span>y_k = c_k \\cdot 1/(\\pi^k(t)^2+1)<span class="math">  for some constant  </span>c_k \\neq 0$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For the concrete value of  <span class="math">c_k</span>  we use a similar trick as in the proof of Lemma 2. For  <span class="math">k \\leq n-1</span>  we write</p>

    <div class="my-4 text-center"><span class="math-block">y_{k+1} = \\prod_{\\tau \\in G_k} \\frac{1}{1 + \\tau(t)^2} \\cdot \\prod_{\\tau \\in G_k} \\frac{1}{1 + \\tau(\\sigma(t))^2}$$ $$= c_k^2 \\cdot \\frac{1}{\\pi^k(t)^2 + 1} \\cdot \\frac{1}{\\pi^k(\\sigma(t))^2 + 1},</span></div>

    <p class="text-gray-300">where  <span class="math">\\sigma</span>  is an element of order  <span class="math">2^{k+1}</span> , and therefore  <span class="math">\\pi^k(\\sigma(t)) = -1/\\pi^k(t)</span> . Thus</p>

    <div class="my-4 text-center"><span class="math-block">y_{k+1} = c_k^2 \\cdot \\frac{\\pi^k(t)^2}{(\\pi^k(t)^2 + 1)^2},</span></div>

    <p class="text-gray-300">but also</p>

    <div class="my-4 text-center"><span class="math-block">y_{k+1} = c_{k+1} \\cdot \\frac{1}{\\pi^{k+1}(t)^2 + 1} = c_{k+1} \\cdot \\frac{4 \\cdot \\pi^k(t)^2}{(\\pi^k(t)^2 + 1)^2},</span></div>

    <p class="text-gray-300">where we have used that  <span class="math">\\pi^{k+1}(t) = \\left(\\pi^k(t)^2 - 1\\right)/(2 \\cdot \\pi^k(t))</span> . This yields the recursive law</p>

    <p class="text-gray-300"><span id="page-17-0"></span> <span class="math-block">c_k^2 \\cdot \\frac{1}{4} = c_{k+1},</span></p>

    <p class="text-gray-300">for any  <span class="math">0 \\le k \\le n-1</span> , where the starting value is  <span class="math">c_0 = 1</span> . Writing  <span class="math">c_k = 4^{e_k}</span>  we get  <span class="math">e_{k+1} = 2 \\cdot e_k - 1</span> , where  <span class="math">e_0 = 0</span> , which has the solution  <span class="math">e_k = -(2^k - 1)</span> . The assertion on the poles and zeros of  <span class="math">y_k</span>  follows from Equation (27).</p>

    <p class="text-gray-300"><strong>Corollary 1.</strong> For  <span class="math">m \\leq n-1</span> , and up to non-zero scaling factors from  <span class="math">\\mathbb{F}_q</span> , the set of functions</p>

    <p class="text-gray-300"><span class="math-block">\\tilde{\\mathcal{B}}_{m} = \\left\\{ \\frac{x_{m-1} \\cdot y_{m-1}}{x_{0}^{i_{0}} \\cdots x_{m-1}^{i_{m-1}}} : (i_{0}, \\dots, i_{m-1}) \\in \\{0, 1\\}^{m} \\right\\}</span> (28)</p>

    <p class="text-gray-300">equals the basis  <span class="math">\\mathcal{B}_m</span>  from Theorem 1.</p>

    <p class="text-gray-300"><em>Proof.</em> Lemma 2 implies that  <span class="math">1/x_k</span>  is a (non-zero) scalar multiple of  <span class="math">t_0 \\circ \\pi^k</span> , since they have the same set of poles and zeros. For the same reason, Lemma 2 and 3 imply that the product  <span class="math">x_{m-1} \\cdot y_{m-1}</span>  is a non-zero scalar multiple of the vanishing function  <span class="math">v_{G_m}</span> . In other words, up to a non-zero scaling factor, the functions from Equation (28) equal  <span class="math">b_{m,i_0,\\ldots,i_{m-1}}</span>  as defined in Theorem 1.</p>

    <p class="text-gray-300">Let us turn to the FFT. For domain size  <span class="math">M=2^m</span> , where  <span class="math">m \\leq n-1</span> , Li an Xing use the function space</p>

    <p class="text-gray-300"><span id="page-17-1"></span> <span class="math-block">\\mathscr{F}_m = \\mathscr{L}_{2 \\cdot M}(F)&#x27; \\cap \\mathcal{V}(G&#x27;_m) = \\mathscr{L}_{2 \\cdot M}(F) \\cap \\mathcal{V}(G_0) \\cap \\mathcal{V}(G&#x27;_m)</span>  (29)</p>

    <p class="text-gray-300">consisting of all functions from  <span class="math">\\mathcal{L}_{2\\cdot M}(F)&#x27;</span>  which also vanish over  <span class="math">G&#x27;_m</span>  the unique coset of  <span class="math">G_m</span>  so that  <span class="math">G_m \\cup G&#x27;_m = G_{m+1}</span> . (By our assumption  <span class="math">m \\leq n-1</span>  such a</p>

    <p class="text-gray-300">coset exists.) Contrary to  <span class="math">\\mathscr{L}_M&#x27;(F)</span>  the space  <span class="math">\\mathscr{F}_m</span>  is also well-defined in the case m=0, where</p>

    <div class="my-4 text-center"><span class="math-block">\\mathscr{F}_0 = \\mathscr{L}_2(F) \\cap \\mathcal{V}(G_0) \\cap \\mathcal{V}(G_0&#x27;) = \\mathscr{L}_2(F) \\cap \\mathcal{V}(G_1), \\tag{30}</span></div>

    <p class="text-gray-300">spanned by the vanishing function  <span class="math">v_{G_1}(t) = t/(1+t^2)</span> . For  <span class="math">m \\ge 1</span>  it has the univariate representation</p>

    <div class="my-4 text-center"><span class="math-block">\\mathscr{F}_m = \\left\\{ v_{G&#x27;_m}(t) \\cdot \\frac{p(t)}{(1+t^2)^{M/2}} : p(t) \\in F[t]^{&lt; M} \\right\\},\\tag{31}</span></div>

    <p class="text-gray-300">where  <span class="math">v_{G&#x27;_m}(t)</span>  is the vanishing function of  <span class="math">G&#x27;_m</span> . In other words,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathscr{F}_m = \\frac{u_m(t)}{(1+t^2)^M} \\cdot F[t]^{&lt; M},</span></div>

    <p class="text-gray-300">where  <span class="math">u_m(t) = v_{G&#x27;_m}(t) \\cdot (1+t^2)^{M/2}</span>  is the univariate vanishing polynomial of  <span class="math">G&#x27;_m</span> . Up to a non-zero scaling factor, this is the polynomial  <span class="math">u_{m,0}</span>  from [LX23, Lemma 4.2].</p>

    <p class="text-gray-300">Both the coset FFT from Section 3.1 and the group position FFT from Section 3.2 apply to the function spaces  <span class="math">\\mathscr{F}_m</span>  from (29) with as good as no changes, assuming that the FFT domain  <span class="math">D_m</span>  is disjoint to the vanishing set  <span class="math">G&#x27;_m</span> . The only difference is that the double-sized Riemann-Roch spaces allow a reduction chain down to a singleton domain. Given domain  <span class="math">D_m</span> , a coset of  <span class="math">G_m</span>  the subgroup of size  <span class="math">M=2^m</span> , the reduction chain is</p>

    <div class="my-4 text-center"><span class="math-block">D_m \\xrightarrow{\\pi} D_{m-1} \\xrightarrow{\\pi} \\dots \\xrightarrow{\\pi} D_1 \\xrightarrow{\\pi} D_0, \\tag{32}</span></div>

    <p class="text-gray-300">using the same decomposition also in the last step, leading again to Equation (10) and (11) whenever  <span class="math">t \\notin G_1</span> , and Equation (19) and (20) in the case  <span class="math">t \\in G_1</span> . With  <span class="math">\\{v_{G_1}\\}</span>  as the basis for  <span class="math">\\mathscr{F}_0</span> , the resulting basis of  <span class="math">\\mathscr{F}_m</span>  is</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{B}&#x27;_{m+1} = \\left\\{ v_{G_{m+1}} \\cdot \\prod_{k=0}^{m-1} (t_0 \\circ \\pi^k)^{i_{k+1}} : i = (i_1, \\dots, i_m) \\in \\{0, 1\\}^m \\right\\},\\,</span></div>

    <p class="text-gray-300">where  <span class="math">t_0(t) = 1/t</span> . This is the sub-basis of  <span class="math">\\mathcal{B}_{m+1}</span>  from Theorem 1 when taking the last index entry zero,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{B}&#x27;_{m+1} = \\{b_{m+1,i_1,\\dots,i_m,0} : (i_1,\\dots,i_m) \\in \\{0,1\\}^m\\}.</span></div>

    <p class="text-gray-300">We leave the details to the reader, and only state the main result [LX23, Theorem 4.6].</p>

    <p class="text-gray-300"><strong>Theorem 9</strong> (G-FFT, two-adic case). Let  <span class="math">D_m</span>  be a coset of  <span class="math">G_m</span>  the subgroup of size  <span class="math">M=2^m</span> , where  <span class="math">0 \\le m \\le n-1</span> , and such that  <span class="math">D_m \\ne G&#x27;_m</span> , the unique coset of  <span class="math">G_m</span>  with  <span class="math">G_m \\cup G&#x27;_m = G_{m+1}</span> . Given a function f over  <span class="math">D_m</span>  with values in an extension field F of  <span class="math">\\mathbb{F}_q</span> , the above algorithm outputs the coefficients  <span class="math">c_{i_1,\\ldots,i_m}</span>  of the unique low-degree extension  <span class="math">\\hat{f}(t) = \\sum c_{i_1,\\ldots,i_m} \\cdot b_{m+1,i_1,\\ldots,i_m,0}(t)</span>  from  <span class="math">\\mathscr{F}_m</span>  as defined in (29), which solves the (generalized, in case that  <span class="math">D_m = G_m</span> ) interpolation problem for f over  <span class="math">G_m</span> .</p>

    <p class="text-gray-300"><strong>Remark 10.</strong> There are still some minor differences of our description of the G-FFT to that in [LX23]. Therein, the authors use group position domains  <span class="math">D_m = G_m</span>  only in the edge case M = q + 1, which we do not handle for the sake of interpreting  <span class="math">\\mathscr{F}_m</span>  as a vanishing subspace of  <span class="math">\\mathscr{L}_{2\\cdot M}(F)</span> . Whenever M < q + 1 they take coset domains but miss to exclude the choice  <span class="math">D_m = G&#x27;_m</span> , over which the function space  <span class="math">\\mathscr{F}_m</span>  throughout evaluates to zero. Besides, their group position FFT only serves usual domain evaluation, not in the generalized sense as in Section 3.2.</p>`;
---

<BaseLayout title="A note on the G-FFT (2024/1036)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/1036
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
