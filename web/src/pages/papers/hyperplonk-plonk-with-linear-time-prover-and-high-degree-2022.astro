---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/1355';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'HyperPlonk: Plonk with Linear-Time Prover and High-Degree Custom Gates';
const AUTHORS_HTML = 'Binyi Chen, Benedikt Bünz, Dan Boneh, Zhenfei Zhang';

const CONTENT = `    <p class="text-gray-300">Binyi Chen Espresso Systems Benedikt Bünz Stanford University, Espresso Systems Dan Boneh Stanford University Zhenfei Zhang Espresso Systems</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Plonk is a widely used succinct non-interactive proof system that uses univariate polynomial commitments. Plonk is quite flexible: it supports circuits with low-degree “custom” gates as well as circuits with lookup gates (a lookup gate ensures that its input is contained in a predefined table). For large circuits, the bottleneck in generating a Plonk proof is the need for computing a large FFT.</p>

    <p class="text-gray-300">We present HyperPlonk, an adaptation of Plonk to the boolean hypercube, using multilinear polynomial commitments. HyperPlonk retains the flexibility of Plonk but provides several additional benefits. First, it avoids the need for an FFT during proof generation. Second, and more importantly, it supports custom gates of much higher degree than Plonk without harming the running time of the prover. Both of these can dramatically speed up the prover’s running time. Since HyperPlonk relies on multilinear polynomial commitments, we revisit two elegant constructions: one from Orion and one from Virgo. We show how to reduce the Orion opening proof size to less than 10kb (an almost factor 1000 improvement) and show how to make the Virgo FRI-based opening proof simpler and shorter.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 1.1  Technical overview  6 1.2  Additional related work  10</p>

    <p class="text-gray-300">2  Preliminaries  10 2.1  Proofs and arguments of knowledge.  11 2.2  Multilinear polynomial commitments.  13 2.3  PIOP compilation  15</p>

    <p class="text-gray-300">3  A toolbox for multivariate polynomials  16 3.1  SumCheck PIOP for high degree polynomials  16 3.2  ZeroCheck PIOP  19 3.3  ProductCheck PIOP  21 3.4  Multiset Check PIOP  22 3.5  Permutation PIOP  24 3.6  Another permutation PIOP for small fields  25 3.7  Lookup PIOP  27 3.8  Batch openings  30 3.8.1  A more efficient batching scheme in a special setting  32</p>

    <p class="text-gray-300">4  HyperPlonk: Plonk on the boolean hypercube  33 4.1  Constraint systems  34 4.2  The PolyIOP protocol  35</p>

    <p class="text-gray-300">5  HyperPlonk+: HyperPlonk with Lookup Gates  37 5.1  Constraint systems  37 5.2  The PolyIOP protocol  38</p>

    <p class="text-gray-300">6  Instantiation and evaluation  40 6.1  Implementation  40 6.2  Evaluation  40 6.3  MultiThreading performance  41 6.4  High degree gates  42 6.5  Comparisons  42</p>

    <p class="text-gray-300">7  Orion+: a linear-time multilinear PCS with constant proof size  43</p>

    <p class="text-gray-300">A  Zero Knowledge PIOPs and zk-SNARKs  59 A.1  Definition  59 A.2  Polynomial masking  59 A.3  Zero knowledge SumCheck  60 A.4  Zero knowledge compilation for SumCheck-based PIOPs  61 A.5  zk-SNARKs from PIOPs  63</p>

    <p class="text-gray-300">B  The FRI-based multilinear polynomial commitment  63</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Proof systems <em>[49, 6]</em> have a long and rich history in cryptography and complexity theory. In recent years, the efficiency of proof systems has dramatically improved and this has enabled a multitude of new real-world applications that were not previously possible. In this paper, we focus on succinct non-interactive arguments of knowledge, also called SNARKs <em>[16]</em>. Here, succinct refers to the fact that the proof is short and verification time is fast, as explained below. Recent years have seen tremendous progress in improving the efficiency of the prover <em>[75, 62, 79, 2, 12, 84, 35, 27, 44, 68, 24, 50, 80]</em>.</p>

    <p class="text-gray-300">Let us briefly review what a (preprocessing) SNARK is. We give a precise definition in Section 2. Fix a finite field <span class="math">\\mathbb{F}</span>, and consider the relation <span class="math">\\mathcal{R}(\\mathcal{C},\\mathtt{x},\\mathtt{w})</span> that is true whenever <span class="math">\\mathtt{x}\\in\\mathbb{F}^{n}</span>, <span class="math">\\mathtt{w}\\in\\mathbb{F}^{m}</span>, and <span class="math">\\mathcal{C}(\\mathtt{x},\\mathtt{w})=0</span>, where <span class="math">\\mathcal{C}</span> is the description of an arithmetic circuit over <span class="math">\\mathbb{F}</span> that takes <span class="math">n+m</span> inputs. A SNARK enables a prover <span class="math">\\mathcal{P}</span> to non-interactively and succinctly convince a verifier <span class="math">\\mathcal{V}</span> that <span class="math">\\mathcal{P}</span> knows a witness <span class="math">\\mathtt{w}\\in\\mathbb{F}^{m}</span> such that <span class="math">\\mathcal{R}(\\mathcal{C},\\mathtt{x},\\mathtt{w})</span> holds, for some public circuit <span class="math">\\mathcal{C}</span> and <span class="math">\\mathtt{x}\\in\\mathbb{F}^{n}</span>.</p>

    <p class="text-gray-300">In more detail, a SNARK is a tuple of four algorithms <span class="math">(\\mathsf{Setup},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>, where <span class="math">\\mathsf{Setup}(1^{\\lambda})</span> is a randomized algorithm that outputs parameters <span class="math">\\mathsf{gp}</span>, and <span class="math">\\mathcal{I}(\\mathsf{gp},\\mathcal{C})</span> is a deterministic algorithm that pre-processes the circuit <span class="math">\\mathcal{C}</span> and outputs prover parameters <span class="math">\\mathsf{pp}</span> and verifier parameters <span class="math">\\mathsf{vp}</span>. The prover <span class="math">\\mathcal{P}(\\mathsf{pp},\\mathtt{x},\\mathtt{w})</span> is a randomized algorithm that outputs a proof <span class="math">\\pi</span>, and the verifier <span class="math">\\mathcal{V}(\\mathsf{vp},\\mathtt{x},\\pi)</span> is a deterministic algorithm that outputs <span class="math">0</span> or <span class="math">1</span>. The SNARK must be complete, knowledge sound, and succinct, as defined in Section 2. Here succinct means that if <span class="math">\\mathcal{C}</span> contains <span class="math">s</span> gates, and <span class="math">\\mathtt{x}\\in\\mathbb{F}^{n}</span>, then the size of the proof should be <span class="math">O_{\\lambda}(\\log s)</span> and the verifier’s running time should be <span class="math">\\tilde{O}_{\\lambda}(n+\\log s)</span>. A SNARK is often set in the random oracle model where all four algorithms can query the oracle. If the <span class="math">\\mathsf{Setup}</span> algorithm is randomized, then we say that the SNARK requires a trusted setup; otherwise, the SNARK is said to be transparent because <span class="math">\\mathsf{Setup}</span> only has access to public randomness via the random oracle. Optionally, we might want the SNARK to be zero-knowledge, in which case it is called a zkSNARK.</p>

    <p class="text-gray-300">Modern SNARKs are constructed by compiling an information-theoretic object called an Interactive Oracle Proof (IOP) <em>[13]</em> to a SNARK using a suitable cryptographic commitment scheme. There are several examples of this paradigm. Some SNARKs use a univariate polynomial commitment scheme to compile a Polynomial-IOP to a SNARK. Examples include Sonic <em>[62]</em>,Marlin <em>[35]</em>, and Plonk <em>[44]</em>. Other SNARKs use a multivariate linear (multilinear) commitment scheme to compile a multilinear-IOP to a SNARK. Examples include Hyrax <em>[75]</em>, Libra <em>[79]</em>, Spartan <em>[68]</em>, Quarks <em>[69]</em>, and Gemini <em>[24]</em>. Yet other SNARKs use a vector commitment scheme (such as a Merkle tree) to compile a vector-IOP to a SNARK. The STARK system <em>[10]</em> is the prime example in this category, but other examples include Aurora <em>[12]</em>, Virgo <em>[84]</em>, Brakedown <em>[50]</em>, and Orion <em>[80]</em>. While STARKs are post-quantum secure, require no trusted setup, and have an efficient prover, they generate a relatively long proof (tens of kilobytes in practice). The paradigm of compiling an IOP to a SNARK using a suitable commitment scheme lets us build universal SNARKs where a single trusted setup can support many circuits. In earlier SNARKs, such as <em>[52, 47, 18]</em>, every circuit required a new trusted setup.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">The Plonk system.</h4>

    <p class="text-gray-300">Among the IOP-based SNARKs that use a Polynomial-IOP, the Plonk system <em>[44]</em> has emerged as one of the most widely adopted in industry. This is because Plonk</p>

    <p class="text-gray-300">proofs are very short (about 400 bytes in practice) and fast to verify. Moreover, Plonk supports custom gates, as we will see in a minute. An extension of Plonk, called PlonKup <em>[66]</em>, further extends Plonk to incorporate lookup gates using the Plookup IOP of <em>[44]</em>.</p>

    <p class="text-gray-300">One difficulty with Plonk, compared to some other schemes, is the prover’s complexity. For a circuit <span class="math">\\mathcal{C}</span> with <span class="math">s</span> arithmetic gates, the Plonk prover runs in time <span class="math">O_{\\lambda}(s\\log s)</span>. The primary bottlenecks come from the fact that the prover must commit to and later open several degree <span class="math">O(s)</span> polynomials. When using the KZG polynomial commitment scheme <em>[56]</em>, the prover must (i) compute a multi-exponentiation of size <span class="math">O(s)</span> in a pairing-friendly group where discrete log is hard, and (ii) compute several FFTs and inverse-FFTs of dimension <span class="math">O(s)</span>. When using a FRI-based polynomial commitment scheme <em>[9, 57, 84]</em>, the prover computes an <span class="math">O(cs)</span>-sized FFT and <span class="math">O(cs)</span> hashes, where <span class="math">1/c</span> is the rate of a certain Reed-Solomon code. The performance further degrades for circuits that contain <em>high-degree</em> custom gates, as some FFTs and multi-exponentiations have size proportional to the degree of the custom gates.</p>

    <p class="text-gray-300">In practice, when the circuit size <span class="math">s</span> is bigger than <span class="math">2^{20}</span>, the FFTs become a significant part of the running time. This is due to the quasi-linear running time of the FFT algorithm, while other parts of the prover scale linearly in <span class="math">s</span>. The reliance on FFT is a direct result of Plonk’s use of <em>univariate</em> polynomials. We note that some proof systems eliminate the need for an FFT by moving away from Plonk altogether <em>[68, 24, 50, 80, 41]</em>.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Hyperplonk.</h4>

    <p class="text-gray-300">In this paper, we introduce HyperPlonk, an adaptation of the Plonk IOP and its extensions to operate over the boolean hypercube <span class="math">B_{\\mu}:=\\{0,1\\}^{\\mu}</span>. We present HyperPlonk as a multilinear-IOP, which means that it can be compiled using a suitable multilinear commitment scheme to obtain a SNARK (or a zkSNARK) with an efficient prover.</p>

    <p class="text-gray-300">HyperPlonk inherits the flexibility of Plonk to support circuits with custom gates, but presents several additional advantages. First, by moving to the boolean hypercube we eliminate the need for an FFT during proof generation. We do so by making use of the classic SumCheck protocol <em>[61]</em>, and this reduces the prover’s running time from <span class="math">O_{\\lambda}(s\\log s)</span> to <span class="math">O_{\\lambda}(s)</span>. The efficiency of SumCheck is the reason why many of the existing multilinear SNARKs <em>[75, 79, 68, 69, 24]</em> use the boolean hypercube. Here we show that Plonk can similarly benefit from the SumCheck protocol.</p>

    <p class="text-gray-300">Second, and more importantly, we show that the hypercube lets us incorporate custom gates more efficiently into HyperPlonk. A custom gate is a function <span class="math">G:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span>, for some <span class="math">\\ell</span>. An arithmetic circuit <span class="math">\\mathcal{C}</span> with a custom gate <span class="math">G</span>, denoted <span class="math">\\mathcal{C}[G]</span>, is a circuit with addition and multiplication gates along with a custom gate <span class="math">G</span> that can appear many times in the circuit. The circuit may contain multiple types of custom gates, but for now, we will restrict to one type to simplify the presentation. These custom gates can greatly reduce the circuit size needed to compute a function, leading to a faster prover. For example, if one needs to implement the S-box in a block cipher, it can be more efficient to implement it as a custom gate.</p>

    <p class="text-gray-300">Custom gates are not free. Let <span class="math">G:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span> be a custom gate that computes a multivariate polynomial of total degree <span class="math">d</span>. Let <span class="math">\\mathcal{C}[G]</span> be a circuit with a total of <span class="math">s</span> gates. In the Plonk IOP, the circuit <span class="math">\\mathcal{C}[G]</span> results in a prover that manipulates univariate polynomials of degree <span class="math">O(s\\cdot d)</span>. Consequently, when compiling Plonk using KZG <em>[56]</em>, the prover needs to do a group multi-exponentiation of size <span class="math">O(sd)</span> as well as FFTs of this dimension. This restricts custom gates in Plonk to gates of low degree.</p>

    <p class="text-gray-300">We show that the prover’s work in HyperPlonk is much lower. Let <span class="math">G:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span> be a custom gate that can be evaluated using <span class="math">k</span> arithmetic operations. In HyperPlonk, the bulk of the prover’s work</p>

    <p class="text-gray-300">when processing <span class="math">\\mathcal{C}[G]</span> is only <span class="math">O(sk\\log^{2}k)</span> field operations. Moreover, when using KZG multilinear commitments <em>[65]</em>, the total number of group exponentiations is only <span class="math">O(s+d\\log s)</span>, where <span class="math">d</span> is the total degree of <span class="math">G</span>. This is much lower than Plonk’s <span class="math">O(sd)</span> group exponentiations. It lets us use custom gates of much higher degree in HyperPlonk.</p>

    <p class="text-gray-300">Making Plonk and its Plonkup extension work over the hypercube raises interesting challenges, as discussed in Section 1.1. In particular, adapting the Plookup IOP <em>[44]</em>, used to implement table lookups, requires changing the protocol to make it work over the hypercube (see Section 3.7). The resulting version of HyperPlonk that supports lookup gates is called HyperPlonk+ and is described in Section 5. There are also subtleties in making HyperPlonk zero knowledge. In Appendix A, we describe a general compiler to transform a multilinear-IOP into one that is zero knowledge.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Batch openings and commit-and-prove SNARKs.</h4>

    <p class="text-gray-300">The prover in HyperPlonk needs to open several multilinear polynomials at random points. We present a new sum-check-based batch-opening protocol (Section 3.8) that can batch many openings into one, significantly reducing the prover time, proof size, and verifier time. Our protocol takes <span class="math">O(k\\cdot 2^{\\mu})</span> field operations for the prover for batching <span class="math">k</span> of <span class="math">\\mu</span>-variate polynomials, compared to <span class="math">O(k^{2}\\mu\\cdot 2^{\\mu})</span> for the previously best protocol <em>[73]</em>. Under certain conditions, we also obtain a more efficient batching scheme with complexity <span class="math">O(2^{\\mu})</span>, which yields a very efficient commit-and-prove protocol.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Improved multilinear commitments.</h4>

    <p class="text-gray-300">Since HyperPlonk relies on a multilinear commitment scheme, we revisit two approaches to constructing multilinear commitments and present significant improvements to both.</p>

    <p class="text-gray-300">First, in Section 7 we use our commit-and-prove protocol to improve the Orion multilinear commitment scheme <em>[80]</em>. Orion is highly efficient: the prover time is strictly linear, taking only <span class="math">O(2^{\\mu})</span> field operations and hashes for a multilinear polynomial in <span class="math">\\mu</span> variables (no group exponentiations are used). The proof size is <span class="math">O(\\lambda\\mu^{2})</span> hash and field elements, and the verifier time is proportional to the proof size. In Section 7 we describe Orion+, that has the same prover complexity, but has <span class="math">O(\\mu)</span> proof size and <span class="math">O(\\mu)</span> verifier time, with good constants. In particular, for security parameter <span class="math">\\lambda=128</span> and <span class="math">\\mu=25</span> the proof size with Orion+ is only about 7 KBs, compared with 5.5 MB with Orion, a nearly 1000x improvement. Using Orion+ in HyperPlonk gives a strictly linear time prover.</p>

    <p class="text-gray-300">Second, in Appendix B, we show how to generically transform a univariate polynomial commitment scheme into a multilinear commitment scheme using the tensor-product univariate Polynomial-IOP from <em>[24]</em>. This yields a new construction for multilinear commitments from FRI <em>[9]</em> by applying the transformation to the univariate FRI-based commitment scheme from <em>[57]</em>. This approach leads to a more efficient FRI-based multilinear commitment scheme compared to the prior construction in <em>[84]</em>, which uses recursive techniques. Using this commitment scheme in HyperPlonk gives a quantum-resistant quasilinear-time prover.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Another permutation PIOP for small fields.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Looking ahead, the HyperPlonk IOP builds upon a linear-time polynomial IOP for the permutation check relation. However, for <span class="math">\\mu</span>-variate polynomials, the linear-time permutation PIOP has soundness error $O(\\frac{2^{\\mu}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">, which limits its usage with polynomial-sized fields <em>[23]</em>. To remedy this, we also propose another permutation PIOP with a much smaller soundness error, that is, </span>O(\\frac{\\mu^{2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$. The tradeoff is that the PIOP has quasi-linear (rather than linear) prover time.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Application</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\( \\mathcal{R}_{\\text{R1CS}} \\)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Spartan</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\( \\mathcal{R}_{\\text{PLONK+}} \\)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Jellyfish</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">HyperPlonk</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3-to-1 Rescue Hash</td>

            <td class="px-3 py-2 border-b border-gray-700">288 [1]</td>

            <td class="px-3 py-2 border-b border-gray-700">422 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">144 [71]</td>

            <td class="px-3 py-2 border-b border-gray-700">40 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">88 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Zexe's recursive circuit</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( 2^{22} \\) [81]</td>

            <td class="px-3 py-2 border-b border-gray-700">6 min</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( 2^{17} \\) [81]</td>

            <td class="px-3 py-2 border-b border-gray-700">13.1s</td>

            <td class="px-3 py-2 border-b border-gray-700">5.1s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rollup of 50 private tx</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( 2^{25} \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">39 min</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( 2^{20} \\) [71]</td>

            <td class="px-3 py-2 border-b border-gray-700">110 s</td>

            <td class="px-3 py-2 border-b border-gray-700">38.2 s</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: The prover runtime of Hyperplonk, Spartan [68], and Jellyfish Plonk, for popular applications. The first column (next to the column of the applications) shows the number of R1CS constraints for each application. The third column shows the corresponding number of constraints in HyperPlonk+. Note that the Zexe and the Rollup applications are using the BW6-761 curve. For more detail see Section 6.5.</p>

    <p class="text-gray-300">Evaluation results. After applying the optimizations in Appendix C, when instantiated with the pairing-based multilinear commitment scheme of [65], the proof size of Hyperplonk is  <span class="math">\\mu + 5</span>  group elements and  <span class="math">4\\mu + 29</span>  field elements <span class="math">^1</span> . Using BLS12-381 as the pairing group, we obtain  <span class="math">4.7KB</span>  proofs for  <span class="math">\\mu = 20</span>  and  <span class="math">5.5KB</span>  proofs for  <span class="math">\\mu = 25</span> . For comparison, Kopis [69] and Gemini [24], which also have linear-time provers, report proofs of size  <span class="math">39KB</span>  and  <span class="math">18KB</span>  respectively for  <span class="math">\\mu = 20</span> . In Table 1 and Table 6 we show that our prototype HyperPlonk implementation outperforms an optimized commercial-strength Plonk system for circuits with more than  <span class="math">2^{14}</span>  gates. It also shows the effects of PLONK arithmetization compared to R1CS by comparing the prover runtime for several important applications. Hyperplonk outperforms Spartan [68] for these applications by a factor of over 60. We discuss the evaluation further in Section 6.</p>

    <p class="text-gray-300">In this section we give a high level overview of how to make Plonk and its extensions work over the hypercube. We begin by describing Plonk in a modular way, breaking it down into a sequence of elementary components shown in Figure 1. In Section 3 we show how to instantiate each component over the hypercube.</p>

    <p class="text-gray-300">Some components of Plonk in Figure 1 rely on the simple linear ordering of the elements of a finite cyclic group induced by the powers of a generator. On the hypercube there is no natural simple ordering, and this causes a problem in the Plookup protocol [44] that is used to implement a lookup gate. To address this we modify the Plookup argument in Section 5 to make it work over the hypercube. We give an overview of our approach below.</p>

    <p class="text-gray-300">A review of Plonk. Let us briefly review the Plonk SNARK. Let  <span class="math">\\mathcal{C}[G]:\\mathbb{F}^{n + m}\\to \\mathbb{F}</span>  be a circuit with a total of  <span class="math">s</span>  gates, where each gate has fan-in two and can be one of addition, multiplication, or a custom gate  <span class="math">G:\\mathbb{F}^2\\rightarrow \\mathbb{F}</span> . Let  <span class="math">\\mathbb{x}\\in \\mathbb{F}^n</span>  be a public input to the circuit. Plonk represents the resulting computation as a sequence of  <span class="math">n + s + 1</span>  triples <span class="math">^2</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\hat {M} := \\left\\{\\left(L _ {i}, R _ {i}, O _ {i}\\right) \\in \\mathbb {F} ^ {3} \\right\\} _ {i = 0, \\dots , n + s}. \\tag {1}</span></div>

    <p class="text-gray-300">This <span class="math">\\hat{M}</span> is a matrix with three columns and <span class="math">n + s + 1</span> rows. The first <span class="math">n</span> rows encode the <span class="math">n</span> public input; the next <span class="math">s</span> rows represent the left and right inputs and the output for each gate; and the final row enforces that the final output of the circuit is zero. We will see how in a minute.</p>

    <p class="text-gray-300">In basic (univariate) Plonk, the prover encodes the cells of <span class="math">\\hat{M}</span> using a cyclic subgroup <span class="math">\\Omega \\subseteq \\mathbb{F}</span> of order <span class="math">3(n + s + 1)</span>. Specifically, let <span class="math">\\omega \\in \\Omega</span> be a generator. Then the prover interpolates and commits to a polynomial <span class="math">M \\in \\mathbb{F}[X]</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">M (\\omega^ {3 i}) = L _ {i}, \\quad M (\\omega^ {3 i + 1}) = R _ {i}, \\quad M (\\omega^ {3 i + 2}) = O _ {i} \\quad \\mathrm {f o r} i = 0, \\ldots , n + s.</span></div>

    <p class="text-gray-300">Now the prover needs to convince the verifier that the committed <span class="math">M</span> encodes a valid computation of the circuit <span class="math">\\mathcal{C}</span>. This is the bulk of Plonk system.</p>

    <p class="text-gray-300"><strong>Hyperplonk.</strong> In HyperPlonk we instead use the boolean hypercube to encode <span class="math">\\hat{M}</span>. From now on, suppose that <span class="math">n + s + 1</span> is a power of two, so that <span class="math">n + s + 1 = 2^{\\mu}</span>. The prover interpolates and commits to a multilinear polynomial <span class="math">M \\in \\mathbb{F}[X^{\\mu + 2}] = \\mathbb{F}[X_1, \\ldots, X_{\\mu + 2}]</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">M \\big (0, 0, \\langle i \\rangle \\big) = L _ {i}, \\quad M \\big (0, 1, \\langle i \\rangle \\big) = R _ {i}, \\quad M \\big (1, 0, \\langle i \\rangle \\big) = O _ {i}, \\quad \\text {f o r} i = 0, \\dots , n + s. \\tag {2}</span></div>

    <p class="text-gray-300">Here <span class="math">\\langle i\\rangle</span> is the <span class="math">\\mu</span>-bit binary representation of <span class="math">i</span>. Note that a multilinear polynomial on <span class="math">\\mu + 2</span> variables is defined by a vector of <span class="math">2^{\\mu + 2} = 4 \\times 2^{\\mu}</span> coefficients. Hence, it is always possible to find a multilinear polynomial that satisfies the <span class="math">3 \\times 2^{\\mu}</span> constraints in (2). Next, the prover needs to convince the verifier that the committed <span class="math">M</span> encodes a valid computation of the circuit <span class="math">\\mathcal{C}</span>. To do so, we need to adapt Plonk to work over the hypercube.</p>

    <p class="text-gray-300">Let us start with the pre-processing algorithm <span class="math">\\mathcal{I}(\\mathsf{gp},\\mathcal{C})</span> that outputs prover and verifier parameters <span class="math">\\mathsf{pp}</span> and <span class="math">\\mathsf{vp}</span>. The verifier parameters <span class="math">\\mathsf{vp}</span> encode the circuit <span class="math">\\mathcal{C}[G]</span> as a commitment to four multilinear polynomials <span class="math">(S_{1},S_{2},S_{3},\\sigma)</span>, where <span class="math">S_{1},S_{2},S_{3}\\in \\mathbb{F}[X^{\\mu}]</span> and <span class="math">\\sigma \\in \\mathbb{F}[X^{\\mu +2}]</span>. The first three are called selector polynomials and <span class="math">\\sigma</span> is called the wiring polynomial. We will see how they are defined in a minute. There is one more auxiliary multilinear polynomial <span class="math">I\\in \\mathbb{F}[X^{\\mu}]</span> that encodes the input <span class="math">\\mathbb{x}\\in \\mathbb{F}^n</span>. This polynomial is defined as <span class="math">I(\\langle i\\rangle) = \\mathbb{x}_i</span> for <span class="math">i = 0,\\ldots ,n - 1</span>, and is zero on the rest of the boolean cube <span class="math">B_{\\mu}</span>. The verifier, on its own, computes a commitment to the polynomial <span class="math">I</span> to ensure that the correct input <span class="math">\\mathbb{x}\\in \\mathbb{F}^n</span> is being used in the proof. Computing a commitment to <span class="math">I</span> can be done in time <span class="math">O_{\\lambda}(n)</span>, which is within the verifier's time budget.</p>

    <p class="text-gray-300">With this setup, the Plonk prover <span class="math">\\mathcal{P}</span> convinces the verifier that the committed <span class="math">M</span> satisfies two polynomial identities:</p>

    <p class="text-gray-300"><strong>The gate identity:</strong> Let <span class="math">S_{1}, S_{2}, S_{3}: \\mathbb{F}^{\\mu} \\to \\{0, 1\\}</span> be the three selector polynomials that the preprocessing algorithm <span class="math">\\mathcal{I}(\\mathsf{gp}, \\mathcal{C})</span> committed to in <span class="math">\\mathsf{vp}</span>. To prove that all gates were evaluated correctly, the prover convinces the verifier that the following identity holds for all <span class="math">\\mathbf{x} \\in B_{\\mu} := \\{0, 1\\}^{\\mu}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 0 = S _ {1} (\\mathbf {x}) \\cdot \\left(\\underbrace {M (0 , 0 , \\mathbf {x})} _ {L _ {[ \\mathbf {x} ]}} + \\underbrace {M (0 , 1 , \\mathbf {x})} _ {R _ {[ \\mathbf {x} ]}}\\right) + S _ {2} (\\mathbf {x}) \\cdot \\underbrace {M (0 , 0 , \\mathbf {x})} _ {L _ {[ \\mathbf {x} ]}} \\cdot \\underbrace {M (0 , 1 , \\mathbf {x})} _ {R _ {[ \\mathbf {x} ]}} \\tag {3} \\\\ + \\quad S _ {3} (\\mathbf {x}) \\cdot \\boldsymbol {G} \\left(\\underbrace {M (0 , 0 , \\mathbf {x})} _ {L _ {[ \\mathbf {x} ]}}, \\underbrace {M (0 , 1 , \\mathbf {x})} _ {R _ {[ \\mathbf {x} ]}}\\right) - \\underbrace {M (1 , 0 , \\mathbf {x})} _ {O _ {[ \\mathbf {x} ]}} + I (\\mathbf {x}) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">[\\mathbf{x}] = \\sum_{i=0}^{\\mu-1} \\mathbf{x}_i 2^i</span> is the integer whose binary representation is <span class="math">\\mathbf{x} \\in B_\\mu</span>. For each <span class="math">i = 0, \\dots, n + s</span>, the selector polynomials <span class="math">S_1, S_2, S_3</span> are defined to do the "right" thing:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for an addition gate: <span class="math">S_{1}(\\langle i\\rangle)=1,\\quad S_{2}(\\langle i\\rangle)=S_{3}(\\langle i\\rangle)=0\\quad\\hbox{ (so </span>O_{i}=L_{i}+R_{i}<span class="math"> )}</span></li>

      <li>for a multiplication gate: <span class="math">S_{1}(\\langle i\\rangle)=S_{3}(\\langle i\\rangle)=0,\\quad S_{2}(\\langle i\\rangle)=1\\quad\\hbox{ (so </span>O_{i}=L_{i}\\cdot R_{i}<span class="math"> )}</span></li>

      <li>for a <span class="math">G</span> gate: <span class="math">S_{1}(\\langle i\\rangle)=S_{2}(\\langle i\\rangle)=0,\\quad S_{3}(\\langle i\\rangle)=1\\quad\\hbox{ (so </span>O_{i}=G(L_{i},R_{i})<span class="math"> )}</span></li>

      <li>when <span class="math">i&lt;n</span> or <span class="math">i=n+s</span>: <span class="math">S_{1}(\\langle i\\rangle)=S_{2}(\\langle i\\rangle)=S_{3}(\\langle i\\rangle)=0\\quad\\hbox{ (so </span>O_{i}=I(\\langle i\\rangle)<span class="math"> )}</span>.</li>

    </ul>

    <p class="text-gray-300">The last bullet ensures that <span class="math">O_{i}</span> is equal to the <span class="math">i</span>-th input for <span class="math">i=0,\\ldots,n-1</span>, and that the final output of the circuit, <span class="math">O_{n+s}</span>, is equal to zero.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">The wiring identity:</h4>

    <p class="text-gray-300">Every wire in the circuit <span class="math">\\mathcal{C}</span> induces an equality constraint on two cells in the matrix <span class="math">\\hat{M}</span>. In HyperPlonk, the wiring constraints are captured by a permutation <span class="math">\\hat{\\sigma}:B_{\\mu+2}\\rightarrow B_{\\mu+2}</span>. The prover needs to convince the verifier that</p>

    <p class="text-gray-300"><span class="math">M(\\mathbf{x})=M(\\hat{\\sigma}(\\mathbf{x}))\\quad\\hbox{for all </span>\\mathbf{x}\\in B_{\\mu+2}:=\\{0,1\\}^{\\mu+2}<span class="math">.}</span> (4)</p>

    <p class="text-gray-300">To do so, the pre-processing algorithm <span class="math">\\mathcal{I}(\\mathsf{gp},\\mathcal{C})</span> commits to a multilinear polynomial <span class="math">\\sigma:\\mathbb{F}^{\\mu+2}\\rightarrow\\mathbb{F}</span> that satisfies <span class="math">\\sigma(\\mathbf{x})=[\\hat{\\sigma}(\\mathbf{x})]</span> for all <span class="math">\\mathbf{x}\\in B_{\\mu+2}</span> (recall that <span class="math">[\\hat{\\sigma}(\\mathbf{x})]</span> is the integer whose binary representation is <span class="math">\\hat{\\sigma}(\\mathbf{x})\\in B_{\\mu+2}</span>). The prover then convinces the verifier that the following two sets are equal (both sets are subsets of <span class="math">\\mathbb{F}^{2}</span>):</p>

    <p class="text-gray-300"><span class="math">\\Big{\\{}\\big{(}[\\mathbf{x}],M(\\mathbf{x})\\big{)}\\Big{\\}}_{\\mathbf{x}\\in B_{\\mu+2}}=\\Big{\\{}\\big{(}[\\hat{\\sigma}(\\mathbf{x})],M(\\mathbf{x})\\big{)}\\Big{\\}}_{\\mathbf{x}\\in B_{\\mu+2}}.</span> (5)</p>

    <p class="text-gray-300">This equality of sets implies that (4) holds.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Proving the gate identity.</h4>

    <p class="text-gray-300">The prover convinces the verifier that the Gate identity holds by proving that the polynomial defined by the right hand side of (3) is zero for all <span class="math">\\mathbf{x}\\in B_{\\mu}</span>. This is done using a ZeroCheck IOP, defined in Section 3.2. If the custom gate <span class="math">G</span> has total degree <span class="math">d</span> and there are <span class="math">s</span> gates in the circuit, then the total degree of the polynomial in (3) is <span class="math">(d+1)(s+n+1)</span> which is about <span class="math">(d\\cdot s)</span>. If this were a univariate polynomial, as in Plonk, then a ZeroCheck would require a multi-exponentiation of dimension <span class="math">(d\\cdot s)</span> and an FFT of the same dimension. When the polynomial is defined over the hypercube, the ZeroCheck is implemented using the SumCheck protocol in Section 3.1, which requires no FFTs. In that section we describe two optimizations to the SumCheck protocol for the settings where the multivariate polynomial has a high degree <span class="math">d</span> in every variable:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, in every round of SumCheck the prover sends a polynomial commitment to a univariate polynomial of degree <span class="math">d</span>, instead of sending the polynomial in the clear as in regular SumCheck. This greatly reduces the proof size.</li>

      <li>Second, in standard SumCheck, the prover opens the univariate polynomial commitment at three points: at 0, 1, and at a random <span class="math">r\\in\\mathbb{F}</span>. We optimize this step by showing that opening the commitment at a single point is sufficient. This further shortens the final proof.</li>

    </ul>

    <p class="text-gray-300">The key point is that the resulting ZeroCheck requires the prover to do only about <span class="math">s+d\\cdot\\mu</span> group exponentiations, which is much smaller than <span class="math">d\\cdot s</span> in Plonk. The additional arithmetic work that the prover needs to do depends on the number of multiplication gates in the circuit implementing the custom gate <span class="math">G</span>, not on the total degree of <span class="math">G</span>, as in Plonk. As such, we can support much larger custom gates than Plonk.</p>

    <p class="text-gray-300">In summary, proof generation time is reduced for two reasons: (i) the elimination of the FFTs, and (ii) the better handling of high-degree custom gates.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: The multilinear polynomial-IOPs that make up HyperPlonk.</p>

    <p class="text-gray-300">Proving the wiring identity. The prover convinces the verifier that the Wiring identity holds by proving the set equality in (5). We describe a set equality protocol over the hypercube in Section 3.4. Briefly, we use a technique from Bayer and Groth [8], that is also used in Plonk, to reduce this problem to a certain ProductCheck over the hypercube (Section 3.3). We then use an idea from Quarks [69] to reduce the hypercube ProductCheck to a ZeroCheck, which then reduces to a SumCheck. This sequence of reductions is shown in Figure 1. Again, no FFTs are needed.</p>

    <p class="text-gray-300">Table lookups. An important extension to Plonk supports circuits with table lookup gates. The table is represented as a fixed vector  <span class="math">\\mathbf{t} \\in \\mathbb{F}^{2^{\\mu} - 1}</span> . A table lookup gate ensures that a specific cell in the matrix  <span class="math">\\hat{M}</span>  is contained in  <span class="math">\\mathbf{t}</span> . For example, one can set  <span class="math">\\mathbf{t}</span>  to be the field elements in  <span class="math">\\{0,1,\\dots,B\\}</span>  for some  <span class="math">B</span>  (padding the vector by 0 as needed). Now, checking that a cell in  <span class="math">\\hat{M}</span>  is contained in  <span class="math">\\mathbf{t}</span>  is a simple way to implement a range check.</p>

    <p class="text-gray-300">Let  <span class="math">f, t: B_{\\mu} \\to \\mathbb{F}</span>  be two multilinear polynomials. Here the polynomial  <span class="math">t</span>  encodes the table  <span class="math">\\mathbf{t}</span> , where the table values are  <span class="math">t(B_{\\mu})</span> . The polynomial  <span class="math">f</span>  encodes the cells of  <span class="math">\\hat{M}</span>  that need to be checked. An important step in supporting lookup gates in Plonk is a way for the prover to convince the verifier that  <span class="math">f(B_{\\mu}) \\subseteq t(B_{\\mu})</span> , when the verifier has commitments to  <span class="math">f</span>  and  <span class="math">t</span> . The Plookup proof system by Gabizon and Williamson [44] is a way for the prover to do just that. More recently preprocessed alternatives to lookup have been developed[82, 67]. These perform better if the table is known, e.g. a range of values but are in general orthogonal to Plookup.</p>

    <p class="text-gray-300">The problem is that Plookup is designed to work when the polynomials are defined over a cyclic subgroup  <span class="math">\\mathbb{G} \\subseteq \\mathbb{F}^*</span>  of order  <span class="math">q</span>  with generator  <span class="math">\\omega \\in \\mathbb{G}</span> . In particular, Plookup requires a function  <span class="math">\\text{next} : \\mathbb{F} \\to \\mathbb{F}</span>  that induces an ordering of  <span class="math">\\mathbb{G}</span> . This function must satisfy two properties: (i) the sequence</p>

    <div class="my-4 text-center"><span class="math-block">\\omega , \\quad \\operatorname {n e x t} (\\omega), \\quad \\operatorname {n e x t} \\left(\\operatorname {n e x t} (\\omega)\\right), \\quad \\dots , \\quad \\operatorname {n e x t} ^ {(q - 1)} (\\omega) \\tag {6}</span></div>

    <p class="text-gray-300">should traverse all of  <span class="math">\\mathbb{G}</span> , and (ii) the function next should be a linear function. This is quite easy in a cyclic group: simply define  <span class="math">\\operatorname{next}(x) \\coloneqq \\omega x</span> .</p>

    <p class="text-gray-300">To adapt Plookup to the hypercube we need a linear function  <span class="math">\\text{next} : \\mathbb{F}^{\\mu} \\to \\mathbb{F}^{\\mu}</span>  that traverses all of  <span class="math">B_{\\mu}</span>  as in (6), starting with some element  <span class="math">\\mathbf{x}_0 \\in B_{\\mu}</span> . However, such an  <span class="math">\\mathbb{F}</span> -linear function</p>

    <p class="text-gray-300">does not exist. Nevertheless, we construct in Section 3.7 a quadratic function from <span class="math">\\mathbb{F}^{\\mu}</span> to <span class="math">\\mathbb{F}^{\\mu}</span> that traverses <span class="math">B_{\\mu}</span>. The function simulates <span class="math">B_{\\mu}</span> using a binary extension and has a beautiful connection to similar techniques used in early PCP work<em>[15]</em>. We then show how to linearize the function by modifying some of the building blocks that <span class="math">\\mathsf{Plookup}</span> uses. This gives an efficient <span class="math">\\mathsf{Plookup}</span> protocol over the hypercube. Finally, in Section 5 we use this hypercube <span class="math">\\mathsf{Plookup}</span> protocol to support lookup gates in <span class="math">\\mathsf{HyperPlonk}</span>. The resulting protocol is called <span class="math">\\mathsf{HyperPlonk+}</span>.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">1.2 Additional related work</h3>

    <p class="text-gray-300">The origins of SNARKs date back to the work of Kilian <em>[58]</em> and Micali <em>[64]</em> based on the PCP theorem. Many of the SNARK constructions cited in the previous sections rely on techniques introduced in the proof of the PCP theorem.</p>

    <p class="text-gray-300">Recursive SNARKs <em>[74]</em> are an important technique for building a SNARK for a long computation. Early recursive SNARKs <em>[37, 17, 14, 36]</em> built a prover for the entire SNARK circuit and then repeatedly used this prover. More recent recursive SNARKs rely on accumulation schemes <em>[26, 29, 19, 28, 59]</em> where the bulk of the SNARK verifier runs outside of the prover.</p>

    <p class="text-gray-300">Many practical SNARKs rely on the random oracle model and often use a non-falsifiable assumption. Indeed, a separation result due to Gentry and Wichs <em>[48]</em> suggests that a SNARK requires either an idealized model or a non-falsifiable assumption. An interesting recent direction is the construction of <em>batch proofs</em> <em>[38, 39, 76]</em> in the standard model from standard assumptions. These give succinct proofs for computations in <span class="math">\\mathcal{P}</span>, namely succinct proofs for computations that do not rely on a hidden witness. SNARKs give succinct proofs for computations in <span class="math">\\mathcal{NP}</span>.</p>

    <h2 id="sec-13" class="text-2xl font-bold">2 Preliminaries</h2>

    <h5 id="sec-14" class="text-base font-semibold mt-4">Notation:</h5>

    <p class="text-gray-300">We use <span class="math">\\lambda</span> to denote the security parameter. For <span class="math">n\\in\\mathbb{N}</span> let <span class="math">[n]</span> be the set <span class="math">\\{1,2,\\ldots,n\\}</span>; for <span class="math">a,b\\in\\mathbb{N}</span> let <span class="math">[a,b)</span> denote the set <span class="math">\\{a,a+1,\\ldots b-1\\}</span>. A function <span class="math">f(\\lambda)</span> is <span class="math">\\mathsf{poly}(\\lambda)</span> if there exists a <span class="math">c\\in\\mathbb{N}</span> such that <span class="math">f(\\lambda)=O(\\lambda^{c})</span>. If for all <span class="math">c\\in\\mathbb{N}</span>, <span class="math">f(\\lambda)</span> is <span class="math">o(\\lambda^{-c})</span>, then <span class="math">f(\\lambda)</span> is in <span class="math">\\mathsf{negl}(\\lambda)</span> and is said to be negligible. A probability that is <span class="math">1-\\mathsf{negl}(\\lambda)</span> is overwhelming. We use <span class="math">\\mathbb{F}</span> to denote a field of prime order <span class="math">p</span> such that <span class="math">\\log(p)=\\Omega(\\lambda)</span>.</p>

    <p class="text-gray-300">A <em>multiset</em> is an extension of the concept of a set where every element has a positive multiplicity. Two finite multisets are equal if they contain the same elements with the same multiplicities.</p>

    <p class="text-gray-300">Recall that a relation is a set of pairs <span class="math">(\\mathbf{x},\\mathbf{w})</span>. An indexed relation is a set of triples <span class="math">(\\mathbf{i},\\mathbf{x};\\mathbf{w})</span>. The index <span class="math">\\mathbf{i}</span> is fixed at setup time.</p>

    <p class="text-gray-300">In defining the syntax of the various protocols, we use the following convention concerning public values (known to both the prover and the verifier) and secret ones (known only to the prover). In any list of arguments or returned tuple <span class="math">(a,b,c;d,e)</span>, those variables listed before the semicolon are public, and those listed after it are secret. When there is no secret information, the semicolon is omitted.</p>

    <h5 id="sec-15" class="text-base font-semibold mt-4">Useful facts.</h5>

    <p class="text-gray-300">We next list some facts that will be used throughout the paper.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Lemma 2.1 (Multilinear extensions).</h6>

    <p class="text-gray-300">For every function <span class="math">f:\\{0,1\\}^{\\mu}\\to\\mathbb{F}</span>, there is a unique multilinear polynomial <span class="math">\\tilde{f}\\in\\mathbb{F}[X_{1},\\ldots,X_{\\mu}]</span> such that <span class="math">\\tilde{f}(\\bm{b})=f(\\bm{b})</span> for all <span class="math">\\bm{b}\\in\\{0,1\\}^{\\mu}</span>. We call <span class="math">\\tilde{f}</span> the</p>

    <p class="text-gray-300">multilinear extension of <span class="math">f</span>, and <span class="math">\\tilde{f}</span> can be expressed as</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde{f}(\\mathbf{X}) = \\sum_{\\boldsymbol{b} \\in \\{0,1\\}^{\\mu}} f(\\boldsymbol{b}) \\cdot eq(\\boldsymbol{b}, \\mathbf{X})</span></div>

    <p class="text-gray-300">where <span class="math">eq(\\pmb{b}, \\pmb{X}) \\coloneqq \\prod_{i=1}^{\\mu} \\big( \\pmb{b}_i \\pmb{X}_i + (1 - \\pmb{b}_i)(1 - \\pmb{X}_i) \\big)</span>.</p>

    <p class="text-gray-300"><strong>Lemma 2.2 (Schwartz-Zippel Lemma).</strong> Let <span class="math">f \\in \\mathbb{F}[X_1, \\ldots, X_\\mu]</span> be a non-zero polynomial of total degree <span class="math">d</span> over field <span class="math">\\mathbb{F}</span>. Let <span class="math">S</span> be any finite subset of <span class="math">\\mathbb{F}</span>, and let <span class="math">r_1, \\ldots, r_\\mu</span> be <span class="math">\\mu</span> field elements selected independently and uniformly from set <span class="math">S</span>. Then</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ f(r_1, \\ldots, r_\\mu) = 0 \\right] \\leq \\frac{d}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Linear codes.</strong> We review the definition of linear code.</p>

    <p class="text-gray-300"><strong>Definition 2.1 (Linear Code).</strong> An <span class="math">(n,k,\\delta)</span>-linear error-correcting code <span class="math">E: \\mathbb{F}^k \\to \\mathbb{F}^n</span> is an injective mapping from <span class="math">\\mathbb{F}^k</span> to a linear subspace <span class="math">C</span> in <span class="math">\\mathbb{F}^n</span>, such that (i) the injective mapping can be computed in linear time in <span class="math">k</span>; (ii) any linear combination of codewords is still a codeword; and (iii) the relative hamming distance <span class="math">\\Delta(u,v)</span> between any two different codewords <span class="math">u,v \\in \\mathbb{F}^k</span> is at least <span class="math">\\delta</span>. The rate of the code <span class="math">E</span> is defined as <span class="math">k/n</span>.</p>

    <h2 id="sec-17" class="text-2xl font-bold">2.1 Proofs and arguments of knowledge.</h2>

    <p class="text-gray-300">We define interactive proofs of knowledge, which consist of a non-interactive <em>preprocessing</em> phase run by an indexer as well as an interactive <em>online</em> phase between a prover and a verifier.</p>

    <p class="text-gray-300"><strong>Definition 2.2 (Interactive Proof and Argument of Knowledge).</strong> An interactive protocol <span class="math">\\Pi = (\\mathsf{Setup}, \\mathcal{I}, \\mathcal{P}, \\mathcal{V})</span> between a prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span> is an argument of knowledge for an indexed relation <span class="math">\\mathcal{R}</span> with knowledge error <span class="math">\\delta : \\mathbb{N} \\to [0,1]</span> if the following properties hold, where given an index <span class="math">\\mathfrak{i}</span>, common input <span class="math">\\mathbf{x}</span> and prover witness <span class="math">\\mathbf{w}</span>, the deterministic indexer outputs <span class="math">(\\mathsf{vp}, \\mathsf{pp}) \\gets \\mathcal{I}(\\mathfrak{i})</span> and the output of the verifier is denoted by the random variable <span class="math">\\langle \\mathcal{P}(\\mathsf{pp}, \\mathbf{x}, \\mathbf{w}), \\mathcal{V}(\\mathsf{vp}, \\mathbf{x}) \\rangle</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Perfect Completeness:</strong> for all <span class="math">(\\mathfrak{i}, \\mathbf{x}, \\mathbf{w}) \\in \\mathcal{R}</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\langle \\mathcal{P}(\\mathsf{pp}, \\mathbf{x}, \\mathbf{w}), \\mathcal{V}(\\mathsf{vp}, \\mathbf{x}) \\rangle = 1 \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf{gp} \\gets \\mathsf{Setup}(1^{\\lambda}) \\\\ (\\mathsf{vp}, \\mathsf{pp}) \\gets \\mathcal{I}(\\mathsf{gp}, \\mathfrak{i}) \\end{array} \\right] = 1</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong><span class="math">\\delta</span>-Soundness (adaptive):</strong> Let <span class="math">\\mathcal{L}(\\mathcal{R})</span> be the language corresponding to the indexed relation <span class="math">\\mathcal{R}</span> such that <span class="math">(\\mathfrak{i}, \\mathbf{x}) \\in \\mathcal{L}(\\mathcal{R})</span> if and only if there exists <span class="math">\\mathbf{w}</span> such that <span class="math">(\\mathfrak{i}, \\mathbf{x}, \\mathbf{w}) \\in \\mathcal{R}</span>. <span class="math">\\Pi</span> is <span class="math">\\delta</span>-sound if for every pair of probabilistic polynomial time adversarial prover algorithm <span class="math">(\\mathcal{A}_1, \\mathcal{A}_2)</span> the following holds:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\langle \\mathcal{A}_2(\\mathfrak{i}, \\mathbf{x}, \\mathbf{st}), \\mathcal{V}(\\mathsf{vp}, \\mathbf{x}) \\rangle = 1 \\wedge (\\mathfrak{i}, \\mathbf{x}) \\notin \\mathcal{L}(\\mathcal{R}) \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf{gp} \\gets \\mathsf{Setup}(1^{\\lambda}) \\\\ (\\mathfrak{i}, \\mathbf{x}, \\mathbf{st}) \\gets \\mathcal{A}_1(\\mathsf{gp}) \\\\ (\\mathsf{vp}, \\mathsf{pp}) \\gets \\mathcal{I}(\\mathsf{gp}, \\mathfrak{i}) \\end{array} \\right] \\leq \\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We say a protocol is computationally sound if <span class="math">\\delta</span> is negligible. If <span class="math">\\mathcal{A}_1, \\mathcal{A}_2</span> are unbounded and <span class="math">\\delta</span> is negligible, then the protocol is statistically sound. If <span class="math">A = (\\mathcal{A}_1, \\mathcal{A}_2)</span> is unbounded, the soundness definition becomes for all <span class="math">(\\dot{\\mathfrak{i}}, \\mathfrak{x}) \\notin \\mathcal{L}(\\mathcal{R})</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\langle \\mathcal {A} _ {2} (\\dot {\\mathfrak {i}}, \\mathfrak {x}, \\mathsf {g p}), \\mathcal {V} (\\mathsf {v p}, \\mathfrak {x}) \\rangle = 1 \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf {g p} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ (\\mathsf {v p}, \\mathsf {p p}) \\leftarrow \\mathcal {I} (\\mathsf {g p}, \\dot {\\mathfrak {i}}) \\end{array} \\right] \\leq \\delta (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot {\\mathfrak {i}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak {x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\delta</span>-Knowledge Soundness: There exists a polynomial <span class="math">\\mathsf{poly}(\\cdot)</span> and a probabilistic polynomial-time oracle machine <span class="math">\\mathcal{E}</span> called the extractor such that given oracle access to any pair of probabilistic polynomial time adversarial prover algorithm <span class="math">(\\mathcal{A}_1, \\mathcal{A}_2)</span> the following holds:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{c c} \\langle \\mathcal {A} _ {2} (\\mathfrak {i}, \\mathfrak {x}, \\mathfrak {s t}), \\mathcal {V} (\\mathsf {v p}, \\mathfrak {x}) \\rangle = 1 &amp; \\mathsf {g p} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ \\wedge &amp; (\\dot {\\mathfrak {i}}, \\mathfrak {x}, \\mathfrak {w}) \\notin \\mathcal {R} \\\\ \\end{array} \\right] \\begin{array}{c} (\\mathfrak {i}, \\mathfrak {x}, \\mathfrak {s t}) \\leftarrow \\mathcal {A} _ {1} (\\mathsf {g p}) \\\\ (\\mathsf {v p}, \\mathsf {p p}) \\leftarrow \\mathcal {I} (\\mathsf {g p}, \\mathfrak {i}) \\\\ \\mathfrak {w} \\leftarrow \\mathcal {E} ^ {\\mathcal {A} _ {1}, \\mathcal {A} _ {2}} (\\mathsf {g p}, \\mathfrak {i}, \\mathfrak {x}) \\end{array} \\right] \\leq \\delta (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak {i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak {x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">An interactive protocol is "knowledge sound", or simply an "argument of knowledge", if the knowledge error <span class="math">\\delta</span> is negligible in <span class="math">\\lambda</span>. If the adversary is unbounded, then the argument is called an interactive proof of knowledge.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Public coin An interactive protocol is considered to be public coin if all of the verifier messages (including the final output) can be computed as a deterministic function given a random public input.</li>

      <li>Zero knowledge: An interactive protocol <span class="math">\\langle \\mathcal{P},\\mathcal{V}\\rangle</span> is considered to be zero-knowledge if there is a PPT simulator <span class="math">\\mathcal{S}</span> such that for every PPT adversary <span class="math">\\mathcal{A} = (\\mathcal{A}_1,\\mathcal{A}_2)</span>, auxiliary input <span class="math">z\\in \\{0,1\\}^{\\mathrm{poly}(\\lambda)}</span>, it holds that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\langle \\mathcal {P} (\\mathsf {p p}, \\mathfrak {x}, \\mathfrak {w}), \\mathcal {A} _ {2} (\\mathsf {s t}, \\dot {\\mathfrak {i}}, \\mathfrak {x}) \\rangle = 1 \\wedge (\\dot {\\mathfrak {i}}, \\mathfrak {x}, \\mathfrak {w}) \\in \\mathcal {R} \\right. \\right. \\left. \\begin{array}{c} \\mathsf {g p} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ (\\dot {\\mathfrak {i}}, \\mathfrak {x}, \\mathfrak {w}, \\mathsf {s t}) \\leftarrow \\mathcal {A} _ {1} (z, \\mathsf {g p}) \\\\ (\\mathsf {v p}, \\mathsf {p p}) \\leftarrow \\mathcal {I} (\\mathsf {g p}, \\dot {\\mathfrak {i}}) \\end{array} \\right] - \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\langle \\mathcal {S} (\\sigma , z, \\mathsf {p p}, \\mathfrak {x}), \\mathcal {A} _ {2} (\\mathsf {s t}, \\dot {\\mathfrak {i}}, \\mathfrak {x}) \\rangle = 1 \\wedge (\\dot {\\mathfrak {i}}, \\mathfrak {x}, \\mathfrak {w}) \\in \\mathcal {R} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\mathsf {g p}, \\sigma) \\leftarrow \\mathcal {S} (1 ^ {\\lambda}) \\\\ (\\dot {\\mathfrak {i}}, \\mathfrak {x}, \\mathfrak {w}, \\mathsf {s t}) \\leftarrow \\mathcal {A} _ {1} (z, \\mathsf {g p}) \\\\ (\\mathsf {v p}, \\mathsf {p p}) \\leftarrow \\mathcal {I} (\\mathsf {g p}, \\dot {\\mathfrak {i}}) \\end{array} \\right] \\right] \\leq \\mathsf {n e g l} (\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We say that <span class="math">\\langle \\mathcal{P},\\mathcal{V}\\rangle</span> is statistically zero knowledge if <span class="math">\\mathcal{A}</span> is unbounded; and say it perfectly zero knowledge if <span class="math">\\mathrm{negl}(\\lambda)</span> is replaced with zero. <span class="math">\\langle \\mathcal{P},\\mathcal{V}\\rangle</span> is honest-verifier zero knowledge (HVZK) if the adversary <span class="math">\\mathcal{A}_2</span> honestly follows the verifier algorithm.</p>

    <p class="text-gray-300">We introduce both notions of soundness and knowledge soundness. Knowledge soundness implies soundness, as the existence of an extractor implies that <span class="math">(\\dot{\\mathfrak{i}},\\mathfrak{x})\\in \\mathcal{L}(\\mathcal{R})</span>. Furthermore, we show in Lemma 2.3 that soundness directly implies knowledge soundness for certain oracle relations and oracle arguments.</p>

    <p class="text-gray-300">PolyIOPs. SNARKs can be constructed from information-theoretic proof systems that give the verifier oracle access to prover messages. The information-theoretic proof is then compiled using a cryptographic tool, such as a polynomial commitment. We now define a specific type of information-theoretic proof system called polynomial interactive oracle proofs.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 2.3.</h6>

    <p class="text-gray-300">A polynomial interactive oracle proof (PIOP) is a public-coin interactive proof for a polynomial oracle relation <span class="math">\\mathcal{R}=\\{(\\mathfrak{i},\\mathtt{x};\\mathtt{w})\\}</span>. The relation is an oracle relation in that <span class="math">\\mathfrak{i}</span>, and <span class="math">\\mathtt{x}</span> can contain oracles to <span class="math">\\mu</span>-variate polynomials over some field <span class="math">\\mathbb{F}</span>. The oracles specify <span class="math">\\mu</span> and the degree in each variable. These oracles can be queried at arbitrary points in <span class="math">\\mathbb{F}^{\\mu}</span> to evaluate the polynomial at these points. The actual polynomials corresponding to the oracles are contained in the <span class="math">\\mathtt{pp}</span> and the <span class="math">\\mathtt{w}</span>, respectively. We denote an oracle to a polynomial <span class="math">f</span> by <span class="math">[[f]]</span>. In every protocol message, the <span class="math">\\mathcal{P}</span> sends multi-variate polynomial oracles. The verifier in every round sends a random challenge.</p>

    <p class="text-gray-300">We measure the following parameters for the complexity of a PIOP:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover time measures the runtime of the prover.</li>

      <li>The verifier time measures the runtime of the verifier.</li>

      <li>The query complexity is the number of queries the verifier performs to the oracles.</li>

      <li>The round complexity measures the number of rounds. In our protocols, it is always equivalent to the number of oracles sent.</li>

      <li>The size of the proof oracles is the length of the transmitted polynomials.</li>

      <li>The size of the witness is the length of the witness polynomial.</li>

    </ul>

    <p class="text-gray-300">Proof of Knowledge. As a proof system, the PIOP satisfies perfect completeness and unbounded knowledge-soundness with knowledge-error <span class="math">\\delta</span>. Note that the extractor can query the oracle at arbitrary points to efficiently recover the entire polynomial.</p>

    <h5 id="sec-19" class="text-base font-semibold mt-4">Non-interactive arguments.</h5>

    <p class="text-gray-300">Interactive public-coin arguments can be made non-interactive using the Fiat-Shamir transform. The Fiat-Shamir transform replaces the verifier challenges with hashes of the transcript up to that point. The works by <em>[5, 78]</em> show that this is secure for multi-round special-sound protocols and multi-round oracle proofs.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Soundness and knowledge soundness.</h4>

    <h6 id="sec-21" class="text-base font-medium mt-4">Lemma 2.3 (Sound PIOPs are knowledge sound).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider a <span class="math">\\delta</span>-sound PIOP for oracle relations <span class="math">\\mathcal{R}</span> such that for all <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})\\in\\mathcal{R}</span>, <span class="math">\\mathtt{w}</span> consists only of polynomials such that the instance contains oracles to these polynomials. The PIOP has <span class="math">\\delta</span> knowledge-soundness, and the extractor runs in time $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathtt{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-22" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We will show that we can construct an extractor <span class="math">\\mathcal{E}</span> that can produce <span class="math">\\mathtt{w}^{<em>}</span> such that <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w}^{</em>})\\in\\mathcal{R}</span> if and only if <span class="math">(\\mathfrak{i},\\mathtt{x})\\in\\mathcal{L}(\\mathcal{R})</span>. This implies that the soundness error exactly matches the knowledge soundness error. For each oracle of a <span class="math">\\mu</span>-variate polynomial with degree <span class="math">d</span> in each variable, the extractor queries the polynomial at <span class="math">(d+1)^{\\mu}</span> distinct points to extract the polynomial inside the oracle and thus <span class="math">w^{<em>}</span>. If <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w}^{</em>})\\in\\mathcal{R}</span> then by definition <span class="math">(\\mathfrak{i},\\mathtt{x})\\in\\mathcal{L}(\\mathcal{R})</span>. Additionally assume that <span class="math">(\\mathfrak{i},\\mathtt{x})\\in\\mathcal{L}(\\mathcal{R})</span> but <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w}^{<em>})\\not\\in\\mathcal{R}</span>. Then there must exists <span class="math">\\mathtt{w}^{\\prime}\\neq\\mathtt{w}^{</em>}</span> such that <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w}^{\\prime})\\in\\mathcal{R}</span>. Since the relation only admits polynomials as witnesses and these polynomials are degree <span class="math">d</span> and <span class="math">\\mu</span>-variate, then there cannot be two distinct witnesses that agree on <span class="math">(d+1)^{\\mu}</span> oracle queries. Therefore <span class="math">\\mathtt{w}^{\\prime}=\\mathtt{w}^{*}</span> which leads to a contradiction. The extractor, therefore, outputs the unique, valid witness for every <span class="math">(\\mathfrak{i},\\mathtt{x})</span> in the language, and thus, the soundness and knowledge soundness error are the same. ∎</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">2.2 Multilinear polynomial commitments.</h3>

    <h6 id="sec-24" class="text-base font-medium mt-4">Definition 2.4 (Commitment scheme).</h6>

    <p class="text-gray-300">A commitment scheme <span class="math">\\Gamma</span> is a tuple <span class="math">\\Gamma=({\\sf Setup},{\\sf Commit},{\\sf Open})</span> of PPT algorithms where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup <span class="math">(1^{\\lambda}) \\to \\mathbf{gp}</span> generates public parameters <span class="math">\\mathbf{gp}</span>;</li>

      <li>Commit(gp; x) → (C; r) takes a secret message x and outputs a public commitment C and (optionally) a secret opening hint r (which might or might not be the randomness used in the computation).</li>

      <li>Open(gp, C, x, r) → b ∈ {0, 1} verifies the opening of commitment C to the message x provided with the opening hint r.</li>

    </ul>

    <p class="text-gray-300">A commitment scheme Γ is <strong>binding</strong> if for all PPT adversaries A:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{c c} &amp;amp; \\mathbf{gp} \\leftarrow \\operatorname{Setup}(1^{\\lambda}) \\\\ b_0 = b_1 \\neq 0 \\wedge x_0 \\neq x_1 : &amp;amp; (C, x_0, x_1, r_0, r_1) \\leftarrow \\mathcal{A}(\\mathbf{gp}) \\\\ &amp;amp; b_0 \\leftarrow \\operatorname{Open}(\\mathbf{gp}, C, x_0, r_0) \\\\ &amp;amp; b_1 \\leftarrow \\operatorname{Open}(\\mathbf{gp}, C, x_1, r_1) \\end{array} \\right] \\leq \\operatorname{negl}(\\lambda)</span></div>

    <p class="text-gray-300">A commitment scheme Γ is <strong>hiding</strong> if for any polynomial-time adversary A:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr} \\left[ \\begin{array}{c c} &amp; \\mathbf{gp} \\leftarrow \\operatorname{Setup}(1^{\\lambda}) \\\\ &amp; (x_0, x_1, st) \\leftarrow \\mathcal{A}(\\mathbf{gp}) \\\\ b = b' : &amp; b \\stackrel{\\circ}{\\leftarrow} \\{0, 1\\} \\\\ &amp; (C_b; r_b) \\leftarrow \\operatorname{Commit}(\\mathbf{gp}; x_b) \\\\ &amp; b' \\leftarrow \\mathcal{A}(\\mathbf{gp}, st, C_b) \\end{array} \\right] - 1/2 \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\operatorname{negl}(\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">If the adversary is unbounded, then we say the commitment is statistically hiding. We additionally define polynomial commitment schemes for multi-variate polynomials.</p>

    <p class="text-gray-300"><strong>Definition 2.5.</strong> (Polynomial commitment) A polynomial commitment scheme is a tuple of protocols <span class="math">\\Gamma = (\\text{Setup}, \\text{Commit}, \\text{Open}, \\text{Eval})</span> where <span class="math">(\\text{Setup}, \\text{Commit}, \\text{Open})</span> is a binding commitment scheme for a message space <span class="math">R[X]</span> of polynomials over some ring <span class="math">R</span>, and</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Eval((vp, pp), C, z, y, d, μ; f) → b ∈ {0, 1} is an interactive public-coin protocol between a PPT prover P and verifier V. Both P and V have as input a commitment C, points z ∈ F^μ and y ∈ F, and a degree d. The prover has prover parameters pp, and the verifier has verifier parameters vp. The prover additionally knows the opening of C to a secret polynomial f ∈ F^(&lt;d_μ). The protocol convinces the verifier that f(z) = y.</li>

    </ul>

    <p class="text-gray-300">A polynomial commitment scheme is <strong>correct</strong> if an honest committer can successfully convince the verifier of any evaluation. Specifically, if the prover is honest, then for all polynomials f ∈ F^(&lt;d_μ) and all points z ∈ F^μ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{c c} &amp;amp; \\mathbf{gp} \\leftarrow \\operatorname{Setup}(1^{\\lambda}) \\\\ b = 1 : &amp;amp; (C; r) \\leftarrow \\operatorname{Commit}(\\mathbf{gp}, f) \\\\ &amp;amp; y \\leftarrow f(\\mathbf{z}) \\\\ &amp;amp; b \\leftarrow \\operatorname{Eval}(\\mathbf{gp}, c, z, y, d, \\mu; f, r) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">We require that Eval is an interactive argument of knowledge and has knowledge soundness, which ensures that we can extract the committed polynomial from any evaluation.</p>

    <p class="text-gray-300">Multi-variate polynomial commitments can be instantiated from random oracles using the FRI protocol [84], bilinear groups [65], groups of unknown order [30] and discrete logarithm groups. We give a table of polynomial commitments with their different properties in Table 2:</p>

    <p class="text-gray-300">14</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover time: Commit+ Eval</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n = 225</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Add.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KZG-based [65]</td>

            <td class="px-3 py-2 border-b border-gray-700">BL</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">log(n) P</td>

            <td class="px-3 py-2 border-b border-gray-700">log(n) G1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.8KB</td>

            <td class="px-3 py-2 border-b border-gray-700">Univ.</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Dory [60]</td>

            <td class="px-3 py-2 border-b border-gray-700">BL</td>

            <td class="px-3 py-2 border-b border-gray-700">nG1+ √nP</td>

            <td class="px-3 py-2 border-b border-gray-700">log(n) G1</td>

            <td class="px-3 py-2 border-b border-gray-700">6 log(n) G1</td>

            <td class="px-3 py-2 border-b border-gray-700">30KB</td>

            <td class="px-3 py-2 border-b border-gray-700">Trans.</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproofs [27]</td>

            <td class="px-3 py-2 border-b border-gray-700">DL</td>

            <td class="px-3 py-2 border-b border-gray-700">n G</td>

            <td class="px-3 py-2 border-b border-gray-700">n G</td>

            <td class="px-3 py-2 border-b border-gray-700">2 log(n) G</td>

            <td class="px-3 py-2 border-b border-gray-700">1.6KB</td>

            <td class="px-3 py-2 border-b border-gray-700">Trans.</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FRI-based (§B)</td>

            <td class="px-3 py-2 border-b border-gray-700">RO</td>

            <td class="px-3 py-2 border-b border-gray-700">n log(n)/ρF + n/ρH</td>

            <td class="px-3 py-2 border-b border-gray-700">log2(n) λ/ log ρ H</td>

            <td class="px-3 py-2 border-b border-gray-700">log2(n) λ/ log ρ H</td>

            <td class="px-3 py-2 border-b border-gray-700">250KB</td>

            <td class="px-3 py-2 border-b border-gray-700">Trans.</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Orion</td>

            <td class="px-3 py-2 border-b border-gray-700">RO</td>

            <td class="px-3 py-2 border-b border-gray-700">nH + n/k + k rec.</td>

            <td class="px-3 py-2 border-b border-gray-700">λ log2 nH</td>

            <td class="px-3 py-2 border-b border-gray-700">λ log2 nH</td>

            <td class="px-3 py-2 border-b border-gray-700">5.5MB</td>

            <td class="px-3 py-2 border-b border-gray-700">Trans.</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Orion + (§7)</td>

            <td class="px-3 py-2 border-b border-gray-700">BL</td>

            <td class="px-3 py-2 border-b border-gray-700">n/kG1 + nH + (kλH + n/kF) rec.</td>

            <td class="px-3 py-2 border-b border-gray-700">log(n)P</td>

            <td class="px-3 py-2 border-b border-gray-700">4 log n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">7KB</td>

            <td class="px-3 py-2 border-b border-gray-700">Univ.</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Multi-linear polynomial commitment schemes for  <span class="math">\\mu</span> -variate linear polynomials and  <span class="math">n = 2^{\\mu}</span> . The prover time measures the complexity of committing to a polynomial and evaluating it once. The commitment size is constant for all protocols. Unless constants are mentioned, the metrics are assumed to be asymptotic. In the 4th row,  <span class="math">\\rho</span>  denotes the rate of Reed-Solomon codes. In the 5th and 6th rows,  <span class="math">k</span>  denotes the number of rows of the matrix that represents the polynomial coefficients. The 6th column measures the concrete proof size for  <span class="math">n = 2^{25}</span> , i.e.  <span class="math">\\mu = 25</span>  and 128-bit security. Legend: BL=Bilinear Group, DL=Discrete Logarithm, RO=Random Oracle,  <span class="math">H =</span>  Hashes,  <span class="math">P =</span>  pairings,  <span class="math">\\mathbb{G} =</span>  group scalar multiplications, rec. = Recursive circuit size, univ. = universal setup, trans. = transparent setup, Add. = Additive</p>

    <p class="text-gray-300">Virtual oracles and commitments. Given multiple polynomial oracles, we can construct virtual oracles to the functions of these polynomials. An oracle to  <span class="math">g([f_1], \\ldots, [f_k])</span>  for some function  <span class="math">g</span>  is simply the list of oracles  <span class="math">\\{[[f_1]], \\ldots, [[f_k]]\\}</span>  as well as a description of  <span class="math">g</span> . In order to evaluate  <span class="math">g([f_1], \\ldots, [f_k])</span>  at some point  <span class="math">\\mathbf{x}</span>  we compute  <span class="math">y_i = f_i(\\mathbf{x}) \\forall i \\in [k]</span>  and output  <span class="math">g(y_1, \\ldots, y_k)</span> . Equivalently given commitments to polynomials, we can construct a virtual commitment to a function of these polynomials in the same manner. If  <span class="math">g</span>  is an additive function and the polynomial commitment is additively homomorphic, then we can use the homomorphism to do the evaluation. A common example is that given additive commitments  <span class="math">C_f</span> ,  <span class="math">C_g</span>  to polynomials  <span class="math">f(\\mathbf{X})</span> ,  <span class="math">g(\\mathbf{X})</span> , we want to construct a commitment to  <span class="math">(1 - Y)f + Yg</span> . Then  <span class="math">(C_f, C_g)</span>  serves as such a commitment and we can evaluate it at  <span class="math">(y, \\mathbf{x})</span>  by evaluating  <span class="math">(1 - y)C_f + y \\cdot C_g</span>  at  <span class="math">\\mathbf{x}</span> .</p>

    <p class="text-gray-300">PIOP compilation transforms the interactive oracle proof into an interactive argument of knowledge (without oracles)  <span class="math">\\Pi</span> . The compilation replaces the oracles with polynomial commitments. Every query by the verifier is replaced with an invocation of the Eval protocol at the query point  <span class="math">\\mathbf{z}</span> . The compiled verifier accepts if the PIOP verifier accepts and if the output of all Eval invocations is 1. If  <span class="math">\\Pi</span>  is public-coin, then it can further be compiled to a non-interactive argument of knowledge (or NARK) using the Fiat-Shamir transform.</p>

    <p class="text-gray-300">Theorem 2.4 (PIOP Compilation [30, 35]). If the polynomial commitment scheme  <span class="math">\\Gamma</span>  has witnessed extended emulation, and if the  <span class="math">t</span> -round Polynomial IOP for  <span class="math">\\mathcal{R}</span>  has negligible knowledge error, then  <span class="math">\\Pi</span> , the output of the PIOP compilation, is a secure (non-oracle) argument of knowledge for  <span class="math">\\mathcal{R}</span> . The compilation also preserves zero knowledge. If  <span class="math">\\Gamma</span>  is hiding and Eval is honest-verifier zero-knowledge, then  <span class="math">\\Pi</span>  is honest-verifier zero-knowledge. The efficiency of the resulting argument of knowledge  <span class="math">\\Pi</span>  depends on the efficiency of both the PIOP and  <span class="math">\\Gamma</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Prover time</em> The prover time is equal to the sum of (i) prover time of the PIOP, (ii) the oracle length times the commitment time, and (iii) the query complexity times the prover time of <span class="math">\\Gamma</span>.</li>

      <li><em>Verifier time</em> The verifier time is equal to the sum of (i) the verifier time of the PIOP and (ii) the verifier time for <span class="math">\\Gamma</span> times the query complexity of the PIOP.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <em>Proof size</em> The proof size is equal to sum of (i) the message complexity of the PIOP times the commitment size and (ii) the query complexity times the proof size of <span class="math">\\Gamma</span>. If the proof size is $O(\\log^{c}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$, then we say the proof is succinct.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">Batching.</h4>

    <p class="text-gray-300">The prover time, verifier time, and proof size can be significantly reduced using batch openings of the polynomial commitments. After batching, the proof size only depends on the number of oracles plus a single polynomial commitment opening.</p>

    <h2 id="sec-27" class="text-2xl font-bold">3 A toolbox for multivariate polynomials</h2>

    <p class="text-gray-300">We begin by reviewing several important PolyIOPs that will serve as building blocks for HyperPlonk. Some are well-known, and some are new. Figure 1 serves as a guide for this section: we define the PolyIOPs listed in the figure following the dependency order.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">Notation.</h4>

    <p class="text-gray-300">From here on, we let <span class="math">B_{\\mu}:=\\{0,1\\}^{\\mu}\\subseteq\\mathbb{F}^{\\mu}</span> be the boolean hypercube. We use <span class="math">\\mathcal{F}^{(\\leq d)}_{\\mu}</span> to denote the set of multivariate polynomials in <span class="math">\\mathbb{F}[X_{1},\\ldots,X_{\\mu}]</span> where the degree in each variable is at most <span class="math">d</span>; moreover, we require that each polynomial in <span class="math">\\mathcal{F}^{(\\leq d)}_{\\mu}</span> can be expressed as a virtual oracle to <span class="math">c=O(1)</span> multilinear polynomials. that is, with the form <span class="math">f(\\mathbf{X}):=g(h_{1}(\\mathbf{X}),\\ldots,h_{c}(\\mathbf{X}))</span> where <span class="math">h_{i}\\in\\mathcal{F}^{(\\leq 1)}_{\\mu}</span> (<span class="math">1\\leq i\\leq c</span>) is multilinear and <span class="math">g</span> is a <span class="math">c</span>-variate polynomial of total degree at most <span class="math">d</span>. Looking ahead, we restrict ourselves to this kind of polynomials so that we can have sumchecks for the polynomials with linear-time provers. For polynomials <span class="math">f,g\\in\\mathcal{F}^{(\\leq d)}_{\\mu}</span>, we denote <span class="math">\\mathsf{merge}(f,g)\\in\\mathcal{F}^{(\\leq d)}_{\\mu+1}</span> as</p>

    <p class="text-gray-300"><span class="math">\\mathsf{merge}(f,g):=h(\\mathbf{X}_{0},\\ldots,\\mathbf{X}_{\\mu}):=(1-\\mathbf{X}_{0})\\cdot f(\\mathbf{X}_{1},\\ldots,\\mathbf{X}_{\\mu})+\\mathbf{X}_{0}\\cdot g(\\mathbf{X}_{1},\\ldots,\\mathbf{X}_{\\mu})</span> (7)</p>

    <p class="text-gray-300">so that <span class="math">h(0,\\mathbf{X})=f(\\mathbf{X})</span> and <span class="math">h(1,\\mathbf{X})=g(\\mathbf{X})</span>. In the following definitions, we omit the public parameters <span class="math">\\mathsf{gp}:=(\\mathbb{F},\\mu,d)</span> when the context is clear. We use <span class="math">\\delta^{d,\\mu}_{\\text{check}}</span> to denote the soundness error of the PolyIOP for relation <span class="math">\\mathcal{R}_{\\text{check}}</span> with public parameter <span class="math">(\\mathbb{F},d,\\mu)</span>, where check <span class="math">\\in\\{\\text{sum},\\text{zero},\\text{prod},\\text{mset},\\text{perm},\\text{lkup}\\}</span>.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">3.1 SumCheck PIOP for high degree polynomials</h3>

    <p class="text-gray-300">In this section, we describe a PIOP for the sumcheck relation using the classic sumcheck protocol <em>[61]</em>. However, we modify the protocol and adapt it to our setting of high-degree polynomials.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Definition 3.1 (SumCheck relation).</h6>

    <p class="text-gray-300">The relation <span class="math">\\mathcal{R}_{\\text{SUM}}</span> is the set of all tuples <span class="math">(\\mathbf{x};\\mathfrak{w})=\\big{(}(v,[[f]]);f\\big{)}</span> where <span class="math">f\\in\\mathcal{F}^{(\\leq d)}_{\\mu}</span> and <span class="math">\\sum_{\\bm{b}\\in B_{\\mu}}f(\\bm{b})=v</span>.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">Construction.</h4>

    <p class="text-gray-300">The classic SumCheck protocol <em>[61]</em> is a PolyIOP for the relation <span class="math">\\mathcal{R}_{\\text{SUM}}</span>. When applying the protocol to a polynomial <span class="math">f\\in\\mathcal{F}^{(\\leq d)}_{\\mu}</span>, the protocol runs in <span class="math">\\mu</span> rounds where in every round, the prover sends a univariate polynomial of degree at most <span class="math">d</span> to the verifier. The verifier</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Num of queries</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Num of rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof oracle size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Witness size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SumCheck</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2μd log2d)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(μ)</td>

            <td class="px-3 py-2 border-b border-gray-700">μ+1</td>

            <td class="px-3 py-2 border-b border-gray-700">μ</td>

            <td class="px-3 py-2 border-b border-gray-700">dμ</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2μ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ZeroCheck</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2μd log2d)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(μ)</td>

            <td class="px-3 py-2 border-b border-gray-700">μ+1</td>

            <td class="px-3 py-2 border-b border-gray-700">μ</td>

            <td class="px-3 py-2 border-b border-gray-700">dμ</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2μ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ProdCheck</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2μd log2d)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(μ)</td>

            <td class="px-3 py-2 border-b border-gray-700">μ+2</td>

            <td class="px-3 py-2 border-b border-gray-700">μ+1</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2μ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2μ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MsetEqChk</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2μd log2d)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(μ)</td>

            <td class="px-3 py-2 border-b border-gray-700">μ+2</td>

            <td class="px-3 py-2 border-b border-gray-700">μ+1</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2μ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(k2μ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PermCheck</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2μd log2d)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(μ)</td>

            <td class="px-3 py-2 border-b border-gray-700">μ+2</td>

            <td class="px-3 py-2 border-b border-gray-700">μ+1</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2μ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2μ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Plookup</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2μd log2d)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(μ)</td>

            <td class="px-3 py-2 border-b border-gray-700">μ+3</td>

            <td class="px-3 py-2 border-b border-gray-700">μ+2</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2μ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2μ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BatchEval</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2μk)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kμ)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">μ+log k</td>

            <td class="px-3 py-2 border-b border-gray-700">O(μ+log k)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(k2μ)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: The complexity of PIOPs.  <span class="math">d</span>  and  <span class="math">\\mu</span>  denote the degree and the number of variables of the multivariate polynomials;  <span class="math">k</span>  in MsetCheck is the length of each element in the multisets;  <span class="math">k</span>  in BatchEval is the number of evaluations.</p>

    <p class="text-gray-300">then sends a random challenge point for the univariate polynomial. At the end of the protocol, the verifier checks the consistency between the univariate polynomials and the multi-variate polynomial using a single query to  <span class="math">f</span> .</p>

    <p class="text-gray-300">Given a tuple  <span class="math">(\\mathbf{z};\\mathbf{w}) = (v,[[f]];f)</span>  for  <span class="math">\\mu</span> -variate degree  <span class="math">d</span>  polynomial  <span class="math">f</span>  such that  <span class="math">\\sum_{b\\in B_{\\mu}}f(\\pmb {b}) = v</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i = \\mu, \\mu - 1, \\ldots, 1</span> :</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover computes  <span class="math">r_i(X) \\coloneqq \\sum_{\\pmb{b} \\in B_{i-1}} f(\\pmb{b}, X, \\alpha_{i+1}, \\dots, \\alpha_\\mu)</span>  and sends the oracle  <span class="math">[[r_i]]</span>  to the verifier.  <span class="math">r_i</span>  is univariate and of degree at most  <span class="math">d</span> .</li>

      <li>The verifier checks that  <span class="math">v = r_{i}(0) + r_{i}(1)</span> , samples  <span class="math">\\alpha_{i} \\gets \\mathbb{F}</span> , sends  <span class="math">\\alpha_{i}</span>  to the prover, and sets  <span class="math">v \\gets r_{i}(\\alpha_{i})</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally, the verifier accepts if  <span class="math">f(\\alpha_{1},\\ldots ,\\alpha_{\\mu}) = v</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 3.1. The PIOP for  <span class="math">\\mathcal{R}_{SUM}</span>  is perfectly complete and has knowledge error  $\\delta_{sum}^{d,\\mu} \\coloneqq d\\mu /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We refer to [73] for the proof of the theorem.</p>

    <p class="text-gray-300">Sending  <span class="math">r</span>  as an oracle. Unlike in the classic sumcheck protocol, we send an oracle to  <span class="math">r_i</span> , in each round, instead of the actual polynomial. This does not change the soundness analysis, as the soundness is still proportional to the degree of the univariate polynomials sent in each round. However, it reduces the communication and verifier complexity, especially if the degree of  <span class="math">r</span>  is large, as in our application of Hyperplonk with custom gates.</p>

    <p class="text-gray-300">Moreover, the verifier has to evaluate  <span class="math">r_i</span>  at three points: 0, 1, and  <span class="math">\\alpha_i</span> . As a useful optimization, the prover can instead send an oracle for the degree  <span class="math">d - 2</span>  polynomial</p>

    <div class="my-4 text-center"><span class="math-block">r _ {i} ^ {\\prime} (X) := \\frac {r _ {i} (X) - (1 - X) \\cdot r _ {i} (0) - X \\cdot r _ {i} (1)}{X \\cdot (1 - X)},</span></div>

    <p class="text-gray-300">along with  <span class="math">r_i(0)</span> . The verifier then computes  <span class="math">r_i(1) \\gets v - r_i(0)</span>  and</p>

    <div class="my-4 text-center"><span class="math-block">r _ {i} (\\alpha_ {i}) \\leftarrow r _ {i} ^ {\\prime} (\\alpha) \\cdot (1 - \\alpha_ {i}) \\cdot \\alpha_ {i} + (1 - \\alpha_ {i}) \\cdot r _ {i} (0) + \\alpha_ {i} \\cdot r _ {i} (1).</span></div>

    <p class="text-gray-300">This requires only one query to the oracle of  <span class="math">r_i&#x27;</span>  at  <span class="math">\\alpha_i</span>  and one field element per round.</p>

    <p class="text-gray-300">Computing sumcheck for high-degree polynomials. Consider a multi-variate polynomial  <span class="math">f(\\mathbf{X}) \\coloneqq h(g_1(\\mathbf{X}), \\ldots, g_c(\\mathbf{X}))</span>  such that  <span class="math">h</span>  is degree  <span class="math">d</span>  and can be evaluated through an arithmetic circuit with  <span class="math">O(d)</span>  gates. In the sumcheck protocol, the prover has to compute a univariate polynomial  <span class="math">r_i(X)</span>  in each round using the previous verifier messages  <span class="math">\\alpha_1, \\ldots, \\alpha_{i-1}</span> . We adapt the algorithm by [72, 79] that showed how the sumcheck prover can be run in time linear in  <span class="math">2^\\mu</span>  using dynamic programming. The algorithm takes as input a description of  <span class="math">f</span>  as well as the sumcheck round challenges  <span class="math">\\alpha_1, \\ldots, \\alpha_\\mu</span> . It outputs the round polynomials  <span class="math">r_1, \\ldots, r_\\mu</span> . The sumcheck prover runs the algorithm in parallel to the sumcheck protocol, taking each computed  <span class="math">r_i</span>  as that rounds message:</p>

    <p class="text-gray-300">Algorithm 1 Computing  <span class="math">r_1, \\ldots, r_\\mu</span>  [72, 79] 1: procedure SUMCHECK PROVER  <span class="math">(h,g_{1}(\\mathbf{X}),\\dots ,g_{c}(\\mathbf{X}))</span> 2: For each  <span class="math">g_{j}</span>  build table  <span class="math">A_{j}:\\{0,1\\}^{\\mu}\\to \\mathbb{F}</span>  of all evaluations over  <span class="math">B_{\\mu}</span> 3: for  <span class="math">i\\gets \\mu \\ldots 1</span>  do 4: For each  <span class="math">\\pmb {b}\\in B_{i - 1}</span>  and each  <span class="math">j\\in [c]</span>  , define  <span class="math">r^{(j,\\pmb {b})}(X)\\coloneqq (1 - X)A_j[\\pmb {b},0] + XA_j[\\pmb {b},1]</span> 5: Compute  <span class="math">r^{(\\pmb {b})}(X)\\gets h(r^{(1,\\pmb {b})}(X),\\dots ,r^{(c,\\pmb {b})}(X))</span>  for all  <span class="math">\\pmb {b}\\in B_{i - 1}</span>  using Algorithm 2. 6:  <span class="math">r_i(X)\\gets \\sum_{\\pmb {b}\\in B_{i - 1}}r_{\\pmb{b}}(X)</span> 7: Send  <span class="math">r_i(X)</span>  to  <span class="math">\\mathcal{V}</span> 8: Receive  <span class="math">\\alpha_{i}</span>  from  <span class="math">\\mathcal{V}</span> 9: Set  <span class="math">A_{j}[\\pmb {b}]\\gets r^{(j,\\pmb {b})}(\\alpha_{i})</span>  for each  <span class="math">\\pmb {b}\\in B_{i - 1}</span> 10: end for 11: end procedure</p>

    <p class="text-gray-300">In [72, 79],  <span class="math">r^{(\\pmb{b})}(X) \\coloneqq h(r^{(1,\\pmb{b})}(X),\\dots,r^{(c,\\pmb{b})}(X))</span>  is computed by evaluating  <span class="math">h</span>  on  <span class="math">d</span>  distinct values for  <span class="math">X</span> , e.g.  <span class="math">X \\in \\{0,\\dots,d\\}</span>  and interpolating the output. This works as  <span class="math">h</span>  is a degree  <span class="math">d</span>  polynomial and each  <span class="math">r^{j,\\pmb{b}}</span>  is linear. Evaluating  <span class="math">r^{j,\\pmb{b}}</span>  on  <span class="math">d</span>  points can be done in  <span class="math">d</span>  steps. So the total time to evaluate all  <span class="math">r^{j,\\pmb{b}}</span>  for  <span class="math">j \\in [c]</span>  is  <span class="math">c \\cdot d</span> . Furthermore, the circuit has  <span class="math">O(d)</span>  gates, and evaluating it on  <span class="math">d</span>  inputs, takes time  <span class="math">O(d^2)</span> . Assuming that  <span class="math">c \\approx d</span>  the total time to compute  <span class="math">r^{(\\pmb{b})}</span>  with this algorithm is  <span class="math">O(d^2)</span>  and the time to run Algorithm 1 is  <span class="math">O(2^\\mu d^2)</span> .</p>

    <p class="text-gray-300">We show how this can be reduced to  <span class="math">O(2^{\\mu} \\cdot d\\log^{2}d)</span>  for certain low depth circuits, such as  <span class="math">h := \\prod_{c} r_{c}(\\mathbf{X})</span> . The core idea is that evaluating the circuit for  <span class="math">h</span>  symbolically, instead of at  <span class="math">d</span>  individual points, is faster if fast polynomial multiplication algorithms are used.</p>

    <p class="text-gray-300">We will present the algorithm for computing  <span class="math">h(X) \\coloneqq \\prod_{j=1}^{d} r_j(X)</span> , then we will discuss how to extend this for more general  <span class="math">h</span> . Assume w.l.o.g. that  <span class="math">d</span>  is a power of 2.</p>

    <p class="text-gray-300">In round  <span class="math">i</span>  there are  <span class="math">d / 2^i</span>  polynomial multiplications for polynomials of degree  <span class="math">2^{i - 1}</span> . In FFT-friendly <span class="math">^3</span>  fields, polynomial multiplication can be performed in time  <span class="math">O(d\\log (d))</span> . The total running time of the algorithm is therefore  <span class="math">\\sum_{i = 1}^{\\log_2(d)}\\frac{d}{2^i} 2^{i - 1}\\log (2^{i - 1}) = \\sum_{i = 1}^{\\log_2(d)}O(d\\cdot i) = O(d\\log^2 (d))</span> .</p>

    <p class="text-gray-300">Algorithm 2 naturally extends to more complicated, low-depth circuits. Addition gates are performed directly through polynomial addition, which takes  <span class="math">O(d)</span>  time for degree  <span class="math">d</span>  polynomials. As long as the circuit is low-depth and has  <span class="math">O(d)</span>  multiplication gates, the complexity remains  <span class="math">O(d\\log^2 (d))</span> . Furthermore, we can compute  <span class="math">r^k (X)</span>  for  <span class="math">k\\leq d</span>  using only a single FFT of length  <span class="math">\\deg (r)\\cdot k</span>  for an input polynomial  <span class="math">r</span> . The FFT evaluates  <span class="math">r</span>  at  <span class="math">\\deg (r)\\cdot k</span>  points. Then we raise each</p>

    <p class="text-gray-300">|  Algorithm 2 Evaluating h := ∏j=1d rj  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Require: r1, ..., rd are linear functions  |   |</p>

    <p class="text-gray-300">|  1: procedure h(r1(X), ..., rd(X))  |   |</p>

    <p class="text-gray-300">|  2: t1,j ← rj for all j ∈ [d].  |   |</p>

    <p class="text-gray-300">|  3: for i ← 1... log d do  |   |</p>

    <p class="text-gray-300">|  4: for j ∈ [d/2i] do  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5: ti+1,j(X) ← ti,2j-1(X) · ti,2j(X)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Using fast polynomial multiplication</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  6: end for  |   |</p>

    <p class="text-gray-300">|  7: end for  |   |</p>

    <p class="text-gray-300">|  8: return h = tlog2(d),1  |   |</p>

    <p class="text-gray-300">|  9: end procedure  |   |</p>

    <p class="text-gray-300">point to the power of  <span class="math">k</span> . This takes time  <span class="math">O(\\deg(r) \\cdot k(\\log(\\deg(r)) + \\log(k)))</span>  and saves a factor of  <span class="math">\\log(k)</span>  over a repeated squaring implementation.</p>

    <p class="text-gray-300">Batching. Multiple sumcheck instances, e.g.  <span class="math">(s,[[f]])</span>  and  <span class="math">(s&#x27;,[[g]])</span>  can easily be batched together. This is done using a random-linear combination, i.e. showing that  <span class="math">(s + \\alpha s&#x27;,[[f]] + \\alpha [[g]]) \\in \\mathcal{L}(\\mathcal{R}_{\\mathrm{SUM}})</span>  for a random verifier-generated  <span class="math">\\alpha</span>  [75, 34]. The batching step has soundness  <span class="math">\\frac{1}{\\mathbb{P}}</span> .</p>

    <p class="text-gray-300">Complexity. Overall, Algorithm 1 calls Algorithm 2 for each point in the boolean hypercube and then on each point in a cube of half the size. The total runtime of Algorithm 1 is, therefore,  <span class="math">O(2^{\\mu}d\\log^{2}d)</span>  if  <span class="math">h</span>  is degree  <span class="math">d</span>  and low-depth. We summarize the complexity of the PIOP for  <span class="math">\\mathcal{R}_{\\mathrm{SUM}}</span>  with respect to  <span class="math">f \\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span> , below:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover time is  <span class="math">\\mathfrak{tp}_{\\mathrm{sum}}^f = \\mathcal{O}(2^\\mu \\cdot d\\log^2 d)</span> <span class="math">\\mathbb{F}</span> -ops (for low-depth  <span class="math">f</span>  that can be evaluated in time  <span class="math">O(d)</span> ).</li>

      <li>The verifier time is  <span class="math">\\mathsf{tv}_{\\mathrm{sum}}^f = \\mathcal{O}(\\mu)</span> .</li>

      <li>The query complexity is  <span class="math">\\mathfrak{q}_{\\mathrm{sum}}^f = \\mu + 1</span> ,  <span class="math">\\mu</span>  queries to univariate oracles, one to multi-variate  <span class="math">f</span> .</li>

      <li>The round complexity and the number of proof oracles is  <span class="math">\\mathsf{rc}_{\\mathrm{sum}}^f = \\mu</span> .</li>

      <li>The number of field elements sent by  <span class="math">\\mathcal{P}</span>  is  <span class="math">\\mu</span> .</li>

      <li>The size of the proof oracles is  <span class="math">\\mathsf{pl}_{\\mathrm{sum}}^f = d \\cdot \\mu</span> ; the size of the witness is  <span class="math">c \\cdot 2^\\mu</span> .</li>

    </ul>

    <p class="text-gray-300">In this section, we describe a PIOP showing that a multivariate polynomial evaluates to zero everywhere on the boolean hypercube. The PIOP builds upon the sumcheck PIOP in Section 3.1 and is a key building block for product-check PIOP in Section 3.3. The zerocheck PIOP is also helpful in HyperPlonk for proving the gate identity.</p>

    <p class="text-gray-300">Definition 3.2 (ZeroCheck relation). The relation  <span class="math">\\mathcal{R}_{ZERO}</span>  is the set of all tuples  <span class="math">(\\mathbf{x};\\mathbf{w}) = (([[f]]);f)</span>  where  <span class="math">f\\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span>  and  <span class="math">f(\\mathbf{x}) = 0</span>  for all  <span class="math">\\mathbf{x}\\in B_{\\mu}</span> .</p>

    <p class="text-gray-300">We use an idea from [68] to reduce a ZeroCheck to a SumCheck.</p>

    <p class="text-gray-300">Construction. Given a tuple <span class="math">(\\mathbf{x};\\mathbf{w}) = \\big(([[f]]);f\\big)</span>, the protocol is the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> sends <span class="math">\\mathcal{P}</span> a random vector <span class="math">\\mathbf{r} \\gets \\mathbb{F}^{\\mu}</span></li>

      <li>Let <span class="math">\\hat{f}(\\mathbf{X}) := f(\\mathbf{X}) \\cdot eq(\\mathbf{X}, \\mathbf{r})</span> where <span class="math">eq(\\mathbf{x}, \\mathbf{y}) := \\prod_{i=1}^{\\mu} (x_i y_i + (1 - x_i)(1 - y_i))</span>.</li>

      <li>Run a sumcheck PolyIOP to convince the verifier that <span class="math">\\big((0, [[\\hat{f}]]); \\hat{f}\\big) \\in \\mathcal{R}_{\\mathrm{SUM}}</span>.</li>

    </ul>

    <p class="text-gray-300">Batching. It is possible to batch two instances <span class="math">\\big(([[f]]);f\\big)\\in \\mathcal{R}_{\\mathrm{ZERO}}</span> and <span class="math">\\big(([[g]]);g\\big)\\in \\mathcal{R}_{\\mathrm{ZERO}}</span> by running a zerocheck on <span class="math">\\big(([[f + \\alpha g]]);f + \\alpha g\\big)</span> for a random <span class="math">\\alpha \\in \\mathbb{F}</span>. The soundness error of the batching protocol <span class="math">\\frac{1}{\\mathbb{F}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 3.2. The PIOP for <span class="math">\\mathcal{R}_{\\text{ZERO}}</span> is perfectly complete and has knowledge error $\\delta_{\\text{zero}}^{d,\\mu} \\coloneqq d\\mu /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\delta_{\\text{sum}}^{d+1,\\mu} = \\mathcal{O}(d\\mu /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Completeness. For every <span class="math">\\big(([[f]]);f\\big)\\in \\mathcal{R}_{\\mathrm{ZERO}}</span>, <span class="math">\\hat{f}</span> is also zero everywhere on the boolean hypercube, thus the sumcheck of <span class="math">\\hat{f}</span> is zero, and completeness follows from sumcheck's completeness.</p>

    <p class="text-gray-300">Knowledge soundness. By Lemma 2.3, it is sufficient to argue the soundness error of the protocol. We note that <span class="math">[[f]] \\in \\mathcal{L}(\\mathcal{R}_{\\mathrm{ZERO}})</span> (i.e., <span class="math">\\big(([[f]]);f\\big) \\in \\mathcal{R}_{\\mathrm{ZERO}}</span>) if and only if the following auxiliary polynomial</p>

    <div class="my-4 text-center"><span class="math-block">g (\\mathbf {Y}) := \\sum_ {\\mathbf {x} \\in B _ {\\mu}} f (\\mathbf {x}) \\cdot e q (\\mathbf {x}, \\mathbf {Y})</span></div>

    <p class="text-gray-300">is identically zero. This is because <span class="math">eq(x, y)</span> for a <span class="math">\\mathbf{x}, \\mathbf{y} \\in B_{\\mu}</span> is 1 if <span class="math">\\mathbf{x} = \\mathbf{y}</span> and 0 otherwise. So <span class="math">g(\\mathbf{y}) = f(\\mathbf{y})</span> for all <span class="math">\\mathbf{y} \\in B_{\\mu}</span>. Therefore, for any <span class="math">[[f]] \\notin \\mathcal{L}(\\mathcal{R}_{\\mathrm{ZERO}})</span>, the corresponding <span class="math">g</span> is a non-zero polynomial and by Lemma 2.2,</p>

    <div class="my-4 text-center"><span class="math-block">g (\\mathbf {r}) = \\sum_ {\\mathbf {x} \\in B _ {\\mu}} f (\\mathbf {x}) \\cdot e q (\\mathbf {x}, \\mathbf {r}) = 0</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">with probability $d\\mu /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over the choice of </span>\\mathbf{r}<span class="math">, thus the probability that the verifier accepts is at most </span>d\\mu /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> plus the probability that the SumCheck PIOP verifier accepts when </span>\\big((0, [[\\hat{f}]]); \\hat{f}\\big) \\notin \\mathcal{R}_{\\mathrm{SUM}}<span class="math">, which is </span>d\\mu /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\delta_{\\mathrm{sum}}^{d + 1,\\mu}$ as desired.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Complexity. We analyze the complexity of the PIOP for <span class="math">\\mathcal{R}_{\\mathrm{ZERO}}</span> with respect to <span class="math">f \\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover time is <span class="math">\\mathsf{tp}_{\\mathrm{zero}}^f = \\mathsf{tp}_{\\mathrm{sum}}^f = \\mathcal{O}(d\\log^2 d\\cdot 2^\\mu)</span> <span class="math">\\mathbb{F}</span>-ops.</li>

      <li>The verifier time is <span class="math">\\mathsf{tv}_{\\mathrm{zero}}^f = \\mathcal{O}(\\mu)</span>.</li>

      <li>The query complexity is <span class="math">\\mathfrak{q}_{\\mathrm{zero}}^f = \\mathfrak{q}_{\\mathrm{sum}}^f = \\mu + 1</span>.</li>

      <li>The round complexity and the number of proof oracles is <span class="math">\\mathsf{rc}_{\\mathrm{zero}}^f = \\mathsf{rc}_{\\mathrm{sum}}^f = \\mu</span>.</li>

      <li>The number of field elements sent by <span class="math">\\mathcal{P}</span> is <span class="math">\\mathsf{nf}_{\\mathrm{zero}}^f = \\mathsf{nf}_{\\mathrm{sum}}^f = \\mu</span>.</li>

      <li>The size of the proof oracles is <span class="math">\\mathsf{pl}_{\\mathrm{zero}}^f = \\mathsf{pl}_{\\mathrm{sum}}^f = d\\mu</span>; the size of the witness is <span class="math">\\mathcal{O}(2^\\mu)</span>.</li>

    </ul>

    <p class="text-gray-300">20</p>

    <p class="text-gray-300">3.3 ProductCheck PIOP</p>

    <p class="text-gray-300">We describe a PIOP for the product check relation, that is, for a rational polynomial (where both the nominator and the denominator are multivariate polynomials), the product of the evaluations on the boolean hypercube is a claimed value <span class="math">s</span>. The PIOP uses the idea from the Quark system [69, §5], we adapt it to build upon the zerocheck PIOP in Section 3.2. Product check PIOP is a key building block for the multiset equality check PIOP in Section 3.4.</p>

    <p class="text-gray-300">Definition 3.3 (ProductCheck relation). The relation <span class="math">\\mathcal{R}_{\\text{PROD}}</span> is the set of all tuples <span class="math">(\\mathbf{x};\\mathbf{w}) = \\big((s,[[f_1]],[[f_2]]);f_1,f_2\\big)</span> where <span class="math">f_{1}\\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span>, <span class="math">f_{2}\\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span>, <span class="math">f_{2}(b)\\neq 0</span> <span class="math">\\forall b\\in B_{\\mu}</span> and <span class="math">\\prod_{\\mathbf{x}\\in B_{\\mu}}f^{\\prime}(\\mathbf{x}) = s</span>, where <span class="math">f^{\\prime}</span> is the rational polynomial <span class="math">f^{\\prime}\\coloneqq f_{1} / f_{2}</span>. In the case that <span class="math">f_{2} = c</span> is a constant polynomial, we directly set <span class="math">f\\coloneqq f_{1} / c</span> and write <span class="math">(\\mathbf{x};\\mathbf{w}) = \\big((s,[[f]]);f\\big)</span>.</p>

    <p class="text-gray-300">Construction. The Quark system [69, §5] constructs a proof system for the <span class="math">\\mathcal{R}_{\\mathrm{PROD}}</span> relation. The proof system uses an instance of the <span class="math">\\mathcal{R}_{\\mathrm{ZERO}}</span> PolyIOP on <span class="math">\\mu + 1</span> variables. Given a tuple <span class="math">(\\mathbf{x}; \\mathbf{w}) = \\big((s, [[f_1]], [[f_2]]); f_1, f_2\\big)</span>, we denote by <span class="math">f&#x27; := f_1 / f_2</span>. The protocol is the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> sends an oracle <span class="math">\\tilde{v} \\in \\mathcal{F}_{\\mu + 1}^{(\\leq 1)}</span> such that for all <span class="math">\\mathbf{x} \\in B_{\\mu}</span>,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\tilde {v} (0, \\mathbf {x}) = f ^ {\\prime} (\\mathbf {x}), \\qquad \\tilde {v} (1, \\mathbf {x}) = \\tilde {v} (\\mathbf {x}, 0) \\cdot \\tilde {v} (\\mathbf {x}, 1).</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define <span class="math">\\hat{h} := \\mathsf{merge}(\\hat{f}, \\hat{g}) \\in \\mathcal{F}_{\\mu + 1}^{(\\leq \\max(2, d + 1))}</span> where</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\hat {f} (\\mathbf {X}) := \\tilde {v} (1, \\mathbf {X}) - \\tilde {v} (\\mathbf {X}, 0) \\cdot \\tilde {v} (\\mathbf {X}, 1), \\qquad \\hat {g} (\\mathbf {X}) := f _ {2} (\\mathbf {X}) \\cdot \\tilde {v} (0, \\mathbf {X}) - f _ {1} (\\mathbf {X}).</span></div>

    <p class="text-gray-300">Run a ZeroCheck PolyIOP for <span class="math">\\left([[\\hat{h}]];\\hat{h}\\right)\\in \\mathcal{R}_{\\mathrm{ZERO}}</span>, i.e., the polynomial <span class="math">\\tilde{v}</span> is computed correctly.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> queries <span class="math">[[\\tilde{v}]]</span> at point <span class="math">(1, \\ldots, 1, 0) \\in \\mathbb{F}^{\\mu + 1}</span>, and checks that the evaluation is <span class="math">s</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 3.3. Let <span class="math">d&#x27; \\coloneqq \\max(2, d + 1)</span>. The PIOP for <span class="math">\\mathcal{R}_{\\text{PROD}}</span> is perfectly complete and has knowledge error $\\delta_{\\text{prod}}^{d,\\mu} \\coloneqq \\delta_{\\text{zero}}^{d',\\mu + 1} = \\mathcal{O}(d'\\mu /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Completeness. First, if the prover honestly generates <span class="math">\\tilde{v}</span>, it holds that <span class="math">\\big(([[\\hat{h}]]);\\hat{h}\\big) \\in \\mathcal{R}_{\\mathrm{ZERO}}</span>, and the verifier accepts in the sub-PIOP, given that ZeroCheck is complete. Second, if <span class="math">\\big((s,[[f_1]],[[f_2]]);f_1,f_2\\big) \\in \\mathcal{R}_{\\mathrm{PROD}}</span>, the evaluation <span class="math">\\tilde{v}(1,\\ldots,1,0)</span> is exactly the product of <span class="math">f</span>'s evaluations on the boolean hypercube <span class="math">B_{\\mu}</span> (c.f. [69, §5]), which is <span class="math">s</span> as desired.</p>

    <p class="text-gray-300">Knowledge soundness. By Lemma 2.3, it is sufficient to argue the soundness error of the protocol. For any <span class="math">(s,[[f_1]],[[f_2]]) \\notin \\mathcal{L}(\\mathcal{R}_{\\mathrm{PROD}})</span> and any <span class="math">\\tilde{v}</span> sent by a malicious prover, it holds that either <span class="math">\\tilde{v}</span> is not computed correctly (i.e., <span class="math">\\big(([[\\hat{h}]]);\\hat{h}\\big) \\notin \\mathcal{R}_{\\mathrm{ZERO}}</span>), or the evaluation <span class="math">\\tilde{v}(1,\\ldots,1,0) \\neq s</span> and <span class="math">\\mathcal{V}</span> rejects. Hence the probability that <span class="math">\\mathcal{V}</span> accepts is at most <span class="math">\\max\\bigl(\\delta_{\\mathrm{zero}}^{d&#x27;,\\mu +1},0\\bigr) = \\delta_{\\mathrm{zero}}^{d&#x27;,\\mu +1}</span> as claimed.</p>

    <p class="text-gray-300">Complexity. Let <span class="math">\\hat{h}</span> be the polynomials described in the construction, we analyze the complexity of the PIOP for <span class="math">\\mathcal{R}_{\\mathrm{PROD}}</span> with respect to <span class="math">f&#x27; := f_1 / f_2</span> where <span class="math">f_1, f_2 \\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover time is <span class="math">\\mathfrak{tp}_{\\mathrm{prod}}^{f&#x27;} = \\mathfrak{tp}_{\\mathrm{zero}}^{\\hat{h}} + 2^{\\mu} = \\mathcal{O}(d\\log^2 d\\cdot 2^\\mu)</span> <span class="math">\\mathbb{F}</span>-ops. The term <span class="math">2^{\\mu}</span> is for computing the product polynomial <span class="math">\\tilde{v}</span>.</li>

      <li>The verifier time is <span class="math">\\mathsf{tv}_{\\mathrm{prod}}^{f&#x27;} = \\mathsf{tv}_{\\mathrm{zero}}^{\\hat{h}} = \\mathcal{O}(\\mu)</span>.</li>

      <li>The query complexity is <span class="math">\\mathfrak{q}_{\\mathrm{prod}}^{f&#x27;} = \\mathfrak{q}_{\\mathrm{zero}}^{\\hat{h}} + 1 = \\mu + 2</span>, the additional query is for <span class="math">\\tilde{v}(1, \\ldots, 1, 0)</span>.</li>

    </ul>

    <p class="text-gray-300">21</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The round complexity and the number of proof oracles is <span class="math">\\mathsf{rc}_{\\mathrm{prod}}^{f^{\\prime}}=\\mathsf{rc}_{\\mathrm{zero}}^{\\hat{h}}+1=\\mu+1</span>.</li>

      <li>The number of field elements sent by <span class="math">\\mathcal{P}</span> is <span class="math">\\mathsf{nf}_{\\mathrm{prod}}^{f^{\\prime}}=\\mathsf{nf}_{\\mathrm{zero}}^{\\hat{h}}=\\mu</span>.</li>

      <li>The size of the proof oracles is <span class="math">\\mathsf{pl}_{\\mathrm{prod}}^{f}=2^{\\mu}+\\mathsf{pl}_{\\mathrm{zero}}^{\\hat{h}}=\\mathcal{O}(2^{\\mu})</span>; the size of the witness is <span class="math">\\mathcal{O}(2^{\\mu})</span>.</li>

    </ul>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">3.4 Multiset Check PIOP</h3>

    <p class="text-gray-300">We describe a multivariate PIOP checking that two multisets are equal. The PIOP builds upon the product-check PIOP in Section 3.3. The multiset check PIOP is a key building block for the permutation PIOP in Section 3.5 and the lookup PIOP in Section 3.7. A similar idea has been proposed in the univariate polynomial setting by Gabizon in a blogpost <em>[43]</em>.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Definition 3.4 (Multiset Check relation).</h6>

    <p class="text-gray-300">For any <span class="math">k\\geq 1</span>, the relation <span class="math">\\mathcal{R}^{k}_{\\mathrm{MSET}}</span> is the set of all tuples</p>

    <p class="text-gray-300"><span class="math">(\\mathbf{x};\\mathbf{w})=\\big{(}([[f_{1}]],\\ldots,[[f_{k}]],[[g_{1}]],\\ldots,[[g_{k}]]);(f_{1},\\ldots,f_{k},g_{1},\\ldots,g_{k})\\big{)}</span></p>

    <p class="text-gray-300">where <span class="math">f_{i},g_{i}\\in\\mathcal{F}^{(\\leq d)}_{\\mu}</span> <span class="math">(1\\leq i\\leq k)</span> and the following two multisets of tuples are equal:</p>

    <p class="text-gray-300"><span class="math">\\left\\{\\mathbf{f}_{\\mathbf{x}}:=\\big{[}f_{1}(\\mathbf{x}),\\ldots,f_{k}(\\mathbf{x})\\big{]}\\right\\}_{\\mathbf{x}\\in B_{\\mu}}=\\left\\{\\mathbf{g}_{\\mathbf{x}}:=\\big{[}g_{1}(\\mathbf{x}),\\ldots,g_{k}(\\mathbf{x})\\big{]}\\right\\}_{\\mathbf{x}\\in B_{\\mu}}</span></p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">Basic construction.</h4>

    <p class="text-gray-300">We start by describing a PolyIOP for <span class="math">\\mathcal{R}^{1}_{\\mathrm{MSET}}</span>. The protocol can be obtained from a protocol for <span class="math">\\mathcal{R}_{\\mathrm{PROD}}</span>. Given a tuple <span class="math">\\big{(}([[f]],[[g]]);(f,g)\\big{)}</span>, the protocol is the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> samples and sends <span class="math">\\mathcal{P}</span> a challenge <span class="math">r\\stackrel{{\\scriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle 0}}}</span>.</li>

      <li>Set <span class="math">f^{\\prime}:=r+f</span> and <span class="math">g^{\\prime}:=r+g</span>, run a ProductCheck PolyIOP for <span class="math">\\big{(}(1,[[f^{\\prime}]],[[g^{\\prime}]]);f^{\\prime},g^{\\prime}\\big{)}\\in\\mathcal{R}_{\\mathrm{PROD}}</span>.</li>

    </ul>

    <h6 id="sec-36" class="text-base font-medium mt-4">Theorem 3.4.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The PIOP for <span class="math">\\mathcal{R}^{1}_{\\mathrm{MSET}}</span> is perfectly complete and has knowledge error $\\delta^{d,\\mu}_{mset,1}:=2^{\\mu}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\delta^{d,\\mu}_{prod}=\\mathcal{O}\\big{(}(2^{\\mu}+d\\mu)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\big{)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness. For any <span class="math">\\big{(}([[f]],[[g]]);(f,g)\\big{)}\\in\\mathcal{R}^{1}_{\\mathrm{MSET}}</span>, it holds that</p>

    <p class="text-gray-300"><span class="math">\\prod_{\\mathbf{x}\\in B_{\\mu}}\\big{(}r+f(\\mathbf{x})\\big{)}=\\prod_{\\mathbf{x}\\in B_{\\mu}}\\big{(}r+g(\\mathbf{x})\\big{)}\\,,</span></p>

    <p class="text-gray-300">thus <span class="math">\\prod_{\\mathbf{x}\\in B_{\\mu}}\\big{(}r+f(\\mathbf{x})\\big{)}/\\big{(}r+g(\\mathbf{x})\\big{)}=1</span>, i.e., <span class="math">\\big{(}(1,[[r+f]],[[r+g]]);r+f,r+g\\big{)}\\in\\mathcal{R}_{\\mathrm{PROD}}</span>. Therefore completeness holds given that the PolyIOP for <span class="math">\\mathcal{R}_{\\mathrm{PROD}}</span> is complete.</p>

    <p class="text-gray-300">Knowledge soundness. By Lemma 2.3, it is sufficient to argue the soundness error of the protocol. For any <span class="math">([[f]],[[g]])\\notin\\mathcal{L}(\\mathcal{R}^{1}_{\\mathrm{MSET}})</span> (i.e., <span class="math">\\big{(}([[f]],[[g]]);(f,g)\\big{)}\\notin\\mathcal{R}^{1}_{\\mathrm{MSET}}</span>), it holds that</p>

    <p class="text-gray-300"><span class="math">F(Y):=\\prod_{\\mathbf{x}\\in B_{\\mu}}(Y+f(\\mathbf{x}))\\neq G(Y):=\\prod_{\\mathbf{x}\\in B_{\\mu}}(Y+g(\\mathbf{x}))\\,.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By Lemma 2.2, <span class="math">F(r)\\neq G(r)</span> with probability at least $1-(2^{\\mu}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Conditioned on </span>F(r)\\neq G(r)<span class="math">, it holds that </span>\\big{(}(1,[[r+f]],[[r+g]]);r+f,r+g\\big{)}\\notin\\mathcal{R}_{\\mathrm{PROD}}<span class="math">. Hence the probability that </span>\\mathcal{V}<span class="math"> accepts conditioned on </span>F(r)\\neq G(r)<span class="math"> is at most </span>\\delta^{d,\\mu}_{\\mathrm{prod}}<span class="math">. In summary, the probability that </span>\\mathcal{V}<span class="math"> accepts is at most </span>2^{\\mu}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\delta^{d,\\mu}_{\\mathrm{prod}}$ as claimed. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">The final construction. Next we describe the protocol for <span class="math">\\mathcal{R}_{\\mathrm{MSET}}^k</span> for any <span class="math">k \\geq 1</span>. Given a tuple</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left([ [ f _ {1} ] ], \\dots , [ [ f _ {k} ] ], [ [ g _ {1} ] ], \\dots , [ [ g _ {k} ] ]\\right); \\left(f _ {1}, \\dots , f _ {k}, g _ {1}, \\dots , g _ {k}\\right)\\right),</span></div>

    <p class="text-gray-300">the protocol is the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> samples and sends <span class="math">\\mathcal{P}</span> challenges <span class="math">r_2, \\ldots, r_k \\stackrel{\\circ}{\\leftarrow} \\mathbb{F}</span>.</li>

      <li>Run a Multiset Check PolyIOP for <span class="math">(([[ \\hat{f} ]], [[ \\hat{g} ]]); (\\hat{f}, \\hat{g})) \\in \\mathcal{R}_{\\mathrm{MSET}}^{1}</span>, where <span class="math">\\hat{f}, \\hat{g} \\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span> are defined as <span class="math">\\hat{f} := f_1 + r_2 \\cdot f_2 + \\dots + r_k \\cdot f_k</span> and <span class="math">\\hat{g} := g_1 + r_2 \\cdot g_2 + \\dots + r_k \\cdot g_k</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 3.5. The PIOP for <span class="math">\\mathcal{R}_{\\mathrm{MSET}}^k</span> is perfectly complete and has knowledge error $\\delta_{mset,k}^{d,\\mu} := 2^{\\mu} /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\delta_{mset,1}^{d,\\mu} = \\mathcal{O}\\big((2^{\\mu} + d\\mu) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\big)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Completeness. Completeness holds since the PolyIOP for <span class="math">(([[f]], [[g]]) \\in \\mathcal{R}_{\\mathrm{MSET}}^{1}</span> is complete.</p>

    <p class="text-gray-300">Knowledge soundness. By Lemma 2.3, it is sufficient to argue the soundness error of the protocol. Given any</p>

    <div class="my-4 text-center"><span class="math-block">\\left([ [ f _ {1} ] ], \\dots , [ [ f _ {k} ] ], [ [ g _ {1} ] ], \\dots , [ [ g _ {k} ] ]\\right) \\notin \\mathcal {L} \\left(\\mathcal {R} _ {\\mathrm {M S E T}} ^ {k}\\right),</span></div>

    <p class="text-gray-300">let</p>

    <div class="my-4 text-center"><span class="math-block">U := \\left\\{\\mathbf {f} _ {\\mathbf {x}} := \\left[ f _ {1} (\\mathbf {x}), \\dots , f _ {k} (\\mathbf {x}) \\right] \\right\\} _ {\\mathbf {x} \\in B _ {\\mu}}, \\qquad V := \\left\\{\\mathbf {g} _ {\\mathbf {x}} := \\left[ g _ {1} (\\mathbf {x}), \\dots , g _ {k} (\\mathbf {x}) \\right] \\right\\} _ {\\mathbf {x} \\in B _ {\\mu}}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">denote the corresponding multisets. Let <span class="math">W</span> be the maximal multiset such that <span class="math">W \\subseteq U</span> and <span class="math">W \\subseteq V</span>. We set <span class="math">U&#x27; := U \\setminus W</span>, <span class="math">V&#x27; := V \\setminus W</span>. We observe that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; 0<span class="math"> as </span>U \\neq V<span class="math">, and </span>U' \\cap V' = \\emptyset<span class="math"> by definition of </span>W<span class="math">. Thus there exists an element </span>\\mathbf{x} \\in \\mathbb{F}^k<span class="math"> where </span>\\mathbf{x} \\in U'<span class="math"> but </span>\\mathbf{x} \\notin V'<span class="math">. It is well-known that the map </span>\\phi_{\\mathbf{r}}: (x_1, \\ldots, x_k) \\to x_1 + r_2 x_2 + \\dots + r_k x_k<span class="math"> is a universal hash family [33, 77, 70], that is, for any </span>\\mathbf{x}, \\mathbf{y} \\in \\mathbb{F}^k<span class="math">, </span>\\mathbf{x} \\neq \\mathbf{y}$, it holds that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_ {\\mathbf {r}} \\left[ \\phi_ {\\mathbf {r}} (\\mathbf {x}) = \\phi_ {\\mathbf {r}} (\\mathbf {y}) \\right] \\leq \\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Thus by union bound, the probability (over the choice of <span class="math">\\mathbf{r}</span>) that</p>

    <div class="my-4 text-center"><span class="math-block">\\phi_ {\\mathbf {r}} (\\mathbf {x}) \\in \\left\\{\\phi_ {\\mathbf {r}} (\\mathbf {y}): \\mathbf {y} \\in V ^ {\\prime} \\right\\}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{\\mu} /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Conditioned on that above does not happen, we have that </span>(([[ \\hat{f} ]], [[\\hat{g} ]])\\in \\mathcal{L}(\\mathcal{R}_{\\mathrm{MSET}}^{1})<span class="math"> and the probability that </span>\\nu<span class="math"> accepts in the PolyIOP for </span>\\mathcal{R}_{\\mathrm{MSET}}^{1}<span class="math"> is at most </span>\\delta_{\\mathrm{mset},1}^{d,\\mu}<span class="math">. In summary, the soundness error is at most </span>2^{\\mu} /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\delta_{\\mathrm{mset},1}^{d,\\mu}$ as claimed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Complexity. We analyze the complexity of the PIOP for <span class="math">\\mathcal{R}_{\\mathrm{MSET}}</span> with respect to</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {F} := \\left(f _ {1}, \\dots , f _ {k}, g _ {1}, \\dots , g _ {k}\\right) \\in \\left(\\mathcal {F} _ {\\mu} ^ {(\\leq d)}\\right) ^ {2 k}.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover time is <span class="math">\\mathfrak{tp}_{\\mathbf{k},\\mathrm{mset}}^{\\mathbf{F}} = \\mathfrak{tp}_{1,\\mathrm{mset}}^{\\hat{f},\\hat{g}} = \\mathfrak{tp}_{\\mathrm{prod}}^{f&#x27; / g&#x27;} = \\mathcal{O}\\left(d\\log^2 d\\cdot 2^\\mu\\right)</span> <span class="math">\\mathbb{F}</span>-ops (for <span class="math">k</span> where <span class="math">\\hat{f} := f_1 + r_2\\cdot f_2 + \\dots +r_k\\cdot f_k</span> and <span class="math">\\hat{g} := g_1 + r_2\\cdot g_2 + \\dots +r_k\\cdot g_k</span> can be evaluated in time <span class="math">O(d)</span>).</li>

    </ul>

    <p class="text-gray-300">23</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier time is <span class="math">\\mathsf{tv}_{\\mathrm{mset}}^{\\mathbf{F}} = \\mathsf{tv}_{\\mathrm{prod}}^{f&#x27;/g&#x27;} = \\mathcal{O}(\\mu)</span>.</li>

      <li>The query complexity is <span class="math">\\mathfrak{q}_{\\mathrm{mset}}^{\\mathbf{F}} = \\mathfrak{q}_{\\mathrm{prod}}^{f&#x27;/g&#x27;} = \\mu + 2</span>.</li>

      <li>The round complexity and the number of proof oracles is <span class="math">\\mathsf{rc}_{\\mathrm{mset}}^{\\mathbf{F}} = \\mathsf{rc}_{\\mathrm{prod}}^{f&#x27;/g&#x27;} = \\mu + 1</span>.</li>

      <li>The number of field elements sent by <span class="math">\\mathcal{P}</span> is <span class="math">\\mathsf{nf}_{\\mathrm{mset}}^{\\mathbf{F}} = \\mathsf{nf}_{\\mathrm{prod}}^{f&#x27;/g&#x27;} = \\mu</span>.</li>

      <li>The size of the proof oracles is <span class="math">\\mathsf{pl}_{\\mathrm{mset}}^{\\mathbf{F}} = \\mathsf{pl}_{\\mathrm{prod}}^{f&#x27;/g&#x27;} = \\mathcal{O}(2^{\\mu})</span>; the size of the witness is <span class="math">\\mathcal{O}(k \\cdot 2^{\\mu})</span>.</li>

    </ul>

    <h2 id="sec-38" class="text-2xl font-bold">3.5 Permutation PIOP</h2>

    <p class="text-gray-300">We describe a multivariate PIOP showing that for two multivariate polynomials <span class="math">f, g \\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span>, the evaluations of <span class="math">g</span> on the boolean hypercube is a predefined permutation <span class="math">\\sigma</span> of <span class="math">f</span>'s evaluations on the boolean hypercube. The permutation PIOP is a key building block of HyperPlonk for proving the wiring identity.</p>

    <p class="text-gray-300"><strong>Definition 3.5 (Permutation relation).</strong> The indexed relation <span class="math">\\mathcal{R}_{\\text{PERM}}</span> is the set of tuples</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbf{i}; \\mathbf{x}; \\mathbf{w}) = \\left(\\sigma; \\left([ [f]], [ [g]]\\right); (f, g)\\right),</span></div>

    <p class="text-gray-300">where <span class="math">\\sigma : B_{\\mu} \\to B_{\\mu}</span> is a permutation, <span class="math">f, g \\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span>, and <span class="math">g(\\mathbf{x}) = f(\\sigma(\\mathbf{x}))</span> for all <span class="math">\\mathbf{x} \\in B_{\\mu}</span>.</p>

    <p class="text-gray-300"><strong>Construction.</strong> Gabizon et. al. [46] construct a permutation argument. We adapt their scheme into a multivariate PolyIOP. The construction uses a PolyIOP instance for <span class="math">\\mathcal{R}_{\\mathrm{MSET}}</span>. Given a tuple <span class="math">(\\sigma; ([[f]], [[g]]); (f, g))</span> where <span class="math">\\sigma</span> is the predefined permutation, the indexer generates two oracles <span class="math">[[s_{\\mathrm{id}}]]</span>, <span class="math">[[s_{\\sigma}]]</span> such that <span class="math">s_{\\mathrm{id}} \\in \\mathcal{F}_{\\mu}^{(\\leq 1)}</span> maps each <span class="math">\\mathbf{x} \\in B_{\\mu}</span> to <span class="math">[\\mathbf{x}] := \\sum_{i=1}^{\\mu} \\mathbf{x}_i \\cdot 2^{i-1} \\in \\mathbb{F}</span>, and <span class="math">s_{\\sigma} \\in \\mathcal{F}_{\\mu}^{(\\leq 1)}</span> maps each <span class="math">\\mathbf{x} \\in B_{\\mu}</span> to <span class="math">[\\sigma(\\mathbf{x})]</span>. The PolyIOP is the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run a Multiset Check PolyIOP for</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left([ [s_{\\mathrm{id}}]], [ [f]], [ [s_{\\sigma}] ], [ [g]]\\right); (s_{\\mathrm{id}}, f, s_{\\sigma}, g)\\right) \\in \\mathcal{R}_{\\mathrm{MSET}}^2.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Theorem 3.6.</strong> The PIOP for <span class="math">\\mathcal{R}_{\\text{PERM}}</span> is perfectly complete and has knowledge error $\\delta_{\\text{perm}}^{d,\\mu} := \\delta_{\\text{mset},2}^{d,\\mu} = \\mathcal{O}\\big((2^{\\mu} + d\\mu) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\big)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> Completeness. For any <span class="math">(\\sigma; ([[f]], [[g]]); (f, g)) \\in \\mathcal{R}_{\\mathrm{PERM}}</span>, it holds that the multiset <span class="math">\\{([\\mathbf{x}], f(\\mathbf{x}))\\}_{\\mathbf{x} \\in B_{\\mu}}</span> is identical to the multiset <span class="math">\\{([\\sigma(\\mathbf{x})], g(\\mathbf{x}))\\}_{\\mathbf{x} \\in B_{\\mu}}</span>. Thus</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left([ [s_{\\mathrm{id}}]], [ [f]], [ [s_{\\sigma}] ], [ [g]]\\right); (s_{\\mathrm{id}}, f, s_{\\sigma}, g)\\right) \\in \\mathcal{R}_{\\mathrm{MSET}}^2</span></div>

    <p class="text-gray-300">and completeness follows from the completeness of the PolyIOP for <span class="math">\\mathcal{R}_{\\mathrm{MSET}}^2</span>.</p>

    <p class="text-gray-300"><strong>Knowledge soundness.</strong> By Lemma 2.3, it is sufficient to argue the soundness error of the protocol. The PolyIOP has soundness error <span class="math">\\delta_{\\mathrm{mset},2}^{d,\\mu}</span> as the permutation relation holds if and only if the above multiset check relation holds.</p>

    <p class="text-gray-300"><strong>Complexity.</strong> The complexity of the PIOP for <span class="math">\\mathcal{R}_{\\mathrm{PERM}}</span> with respect to <span class="math">f, g \\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span> is identical to the complexity of the PIOP for <span class="math">\\mathcal{R}_{\\mathrm{MSET}}^2</span> with respect to <span class="math">(s_{\\mathrm{id}}, f, s_{\\sigma}, g)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6Here we further require $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{\\mu}<span class="math"> so that </span>[\\mathbf{x}]$ never overflow.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">3.6 Another permutation PIOP for small fields</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We describe a different multivariate PIOP for <span class="math">\\mathcal{R}_{\\mathrm{PERM}}</span>. This PIOP directly reduces to <span class="math">\\mathcal{R}_{\\mathrm{SUM}}</span> and has soundness $O(\\mu^{2}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> instead of </span>O(2^{\\mu}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. This enables using polynomial-sized fields such as in <em>[23]</em>. The downside is that the PIOP has quasi-linear (rather than linear) prover time. This comes from splitting up the permutation into </span>\\mu$ multi-linear polynomials. We emphasize that to obtain linear-time provers, the PIOPs used in Section 4 and Section 5 are the version in Section 3.5, rather than in this section.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For simplicity, we only describe the construction for multi-linear polynomials <span class="math">f,g</span>. It can be easily extended to higher degree polynomials by adding an additional ZeroCheck and proving equivalence between a multi-variate and a multi-linear polynomial on the boolean hypercube.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">Construction.</h4>

    <p class="text-gray-300">Our core idea is similar to the protocol in <span class="math">\\mathcal{R}_{\\mathrm{BATCH}}</span>. Given a permutation <span class="math">\\sigma:B_{\\mu}\\to B_{\\mu}</span>, we reduce the equality check <span class="math">f(b^{\\prime})=g(\\sigma(b^{\\prime}))</span> for a given point <span class="math">b^{\\prime}\\in B_{\\mu}</span> to a sum-check via multilinear extension. We then use a zero-check over all <span class="math">b^{\\prime}</span> to prove the equality for all <span class="math">b^{\\prime}\\in B_{\\mu}</span>, which in turn can be reduced to another sumcheck. The resulting sumcheck is over a polynomial with <span class="math">2\\mu</span> variables and individual degree <span class="math">\\mu+1</span>, and naively running the protocol takes time quadratic in <span class="math">2^{\\mu}</span>. Fortunately, we can utilize that <span class="math">\\sigma</span> is a permutation on <span class="math">B_{\\mu}</span> and reduce the prover computation to <span class="math">O(2^{\\mu}\\mu\\log^{2}(\\mu))</span>.</p>

    <p class="text-gray-300">We begin by defining a multi-linear version of the permutation <span class="math">\\sigma</span>. <span class="math">\\tilde{\\sigma}=(\\sigma_{1}(\\mathbf{X}),\\ldots,\\sigma_{\\mu}(\\mathbf{X})):\\mathbb{F}^{\\mu}\\to\\mathbb{F}^{\\mu}</span>, such that for all <span class="math">i\\in[\\mu]</span>, <span class="math">\\sigma_{i}</span> is the multi-linear extension of the <span class="math">i</span>th binary digit of <span class="math">\\sigma</span>. Note that <span class="math">\\sigma_{i}(\\mathbf{x})\\in\\{0,1\\}</span> for all <span class="math">\\mathbf{x}\\in B_{\\mu}</span> and <span class="math">i\\in[\\mu]</span>. We now rewrite the permutation relation as an <span class="math">\\mathcal{R}_{\\mathrm{ZERO}}</span> relation for a polynomial equality equation.</p>

    <p class="text-gray-300"><span class="math">f(\\tilde{\\sigma}(\\mathbf{x}))-g(\\mathbf{x})=0\\forall\\mathbf{x}\\in B_{\\mu}\\,.</span></p>

    <p class="text-gray-300">We can now expand <span class="math">f(\\tilde{\\sigma}(\\mathbf{x}))-g(\\mathbf{x})</span> to its multilinear extension form just as in the protocol for <span class="math">\\mathcal{R}_{\\mathrm{BATCH}}</span>. This becomes</p>

    <p class="text-gray-300"><span class="math">\\sum_{\\mathbf{y}\\in B_{\\mu}}(f(\\mathbf{y})eq(\\tilde{\\sigma}(\\mathbf{x}),\\mathbf{y})-g(\\mathbf{y})eq(\\mathbf{x},\\mathbf{y}))=0\\forall\\mathbf{x}\\in B_{\\mu}\\,.</span></p>

    <p class="text-gray-300">Next, we use the standard trick in Section 3.2 to reduce the zerocheck to another sumcheck. Namely, for a random challenge <span class="math">\\mathbf{t}\\in\\mathbb{F}^{\\mu}</span>, we check that</p>

    <p class="text-gray-300"><span class="math">\\sum_{\\mathbf{x}\\in B_{\\mu}}eq(\\mathbf{t},\\mathbf{x})\\cdot\\sum_{\\mathbf{y}\\in B_{\\mu}}(f(\\mathbf{y})eq(\\tilde{\\sigma}(\\mathbf{x}),\\mathbf{y})-g(\\mathbf{y})eq(\\mathbf{x},\\mathbf{y}))=0\\,.</span> (8)</p>

    <p class="text-gray-300">This is a <span class="math">2\\mu</span>-round sumcheck. Unfortunately, we cannot directly evaluate this sumcheck efficiently. To see this, consider the second round of the sumcheck after the verifier has sent a challenge <span class="math">\\alpha_{1}</span>. The prover needs to evaluate</p>

    <p class="text-gray-300"><span class="math">eq(\\tilde{\\sigma}(\\alpha_{1},x_{2},\\ldots,x_{\\mu}),\\mathbf{y})=eq((\\sigma_{1}(\\alpha_{1},x_{2},\\ldots,x_{\\mu})\\ldots,\\sigma_{\\mu}(\\alpha_{1},x_{2},\\ldots),x_{\\mu}),\\mathbf{y})</span></p>

    <p class="text-gray-300">for all <span class="math">(x_{2},\\ldots,x_{\\mu})\\in B_{\\mu-1}</span> and all <span class="math">\\mathbf{y}\\in B_{\\mu}</span>. This takes time <span class="math">O(2^{2\\mu})</span>, i.e. quadratic in the size of the permutation.</p>

    <p class="text-gray-300">To remedy this we take advantage of the fact that <span class="math">\\sigma</span> is a permutation and has an inverse permutation <span class="math">\\sigma^{-1}</span> such that <span class="math">\\sigma(\\sigma^{-1}(\\mathbf{x}))=\\mathbf{x}\\forall\\mathbf{x}\\in B_{\\mu}</span>. We similarly define <span class="math">\\tilde{\\sigma}^{-1}:\\mathbb{F}^{\\mu}\\to\\mathbb{F}^{\\mu}</span> as the</p>

    <p class="text-gray-300">multi-linear version of the inverse permutation <span class="math">\\sigma^{-1}</span>. More precisely, <span class="math">\\tilde{\\sigma}^{-1} = (\\sigma_1^{-1}(\\mathbf{X}),\\ldots ,\\sigma_\\mu^{-1}(\\mathbf{X})): \\mathbb{F}^\\mu \\to \\mathbb{F}^\\mu</span>, such that for all <span class="math">i\\in [\\mu ]</span>, <span class="math">\\sigma_i^{-1}</span> is the multi-linear extension of the <span class="math">i</span>th binary digit of <span class="math">\\sigma^{-1}</span>. We can then rewrite the sumcheck from Equation 8 as</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\mathbf{x} \\in B_\\mu} e q(\\mathbf{t}, \\mathbf{x}) \\cdot \\sum_{\\mathbf{y} \\in B_\\mu} (f(\\mathbf{y}) e q(\\mathbf{x}, \\tilde{\\sigma}^{-1}(\\mathbf{y})) - g(\\mathbf{y}) e q(\\mathbf{x}, \\mathbf{y})) = 0 \\tag{9}</span></div>

    <p class="text-gray-300">For any <span class="math">\\mathbf{x}</span> and <span class="math">\\mathbf{y} \\in B_{\\mu}</span> the inner sum is <span class="math">f(\\mathbf{y})</span> if <span class="math">\\mathbf{x} = \\sigma^{-1}(\\mathbf{y})</span> or equivalently <span class="math">f(\\sigma(\\mathbf{x}))</span> and <span class="math">-g(\\mathbf{x})</span> if <span class="math">\\mathbf{x} = \\mathbf{y}</span> and 0 otherwise. Since we sum over the entire boolean hypercube for both <span class="math">\\mathbf{x}</span> and <span class="math">\\mathbf{y}</span> and <span class="math">\\sigma</span> is a permutation on <span class="math">B_{\\mu}</span>, (9) is equivalent to <span class="math">\\sum_{\\mathbf{x} \\in B_{\\mu}} eq(\\mathbf{t}, \\mathbf{x})(f(\\sigma(\\mathbf{x})) - g(\\mathbf{x}))</span></p>

    <p class="text-gray-300">The prover can run the sumcheck from (9) efficiently by treating <span class="math">\\tilde{\\sigma}^{-1}</span> as a permutation in the first <span class="math">\\mu</span> rounds of the sumcheck, where we only consider <span class="math">\\mathbf{x}</span> values within the hypercube. In the latter <span class="math">\\mu</span> rounds <span class="math">\\mathbf{x}</span> has been replaced with verifier challenges <span class="math">\\alpha_{1},\\ldots ,\\alpha_{\\mu}</span> and we can now treat <span class="math">\\tilde{\\sigma}^{-1}</span> as a collection of <span class="math">\\mu</span> multi-linear functions. We present the PIOP and the corresponding prover algorithm in Algorithm 3. The verifier is identical to the <span class="math">\\mathcal{R}_{\\mathrm{SUM}}</span> verifier for the sumcheck equation (9).</p>

    <p class="text-gray-300"><strong>Algorithm 3</strong> Permutation PIOP with better soundness.</p>

    <p class="text-gray-300">1: <strong>procedure</strong> PERM2 PROVER <span class="math">(f \\in \\mathcal{F}_{\\mu}^{(\\leq 1)}, g \\in \\mathcal{F}_{\\mu}^{(\\leq 1)}, \\sigma : B_{\\mu} \\to B_{\\mu})</span> 2: <span class="math">\\mathcal{V}</span> sends <span class="math">\\mathcal{P}</span> a random vector <span class="math">\\mathbf{t} \\gets^{\\mathrm{s}} \\mathbb{F}^{\\mu}</span>. 3: Run the sumcheck for <span class="math">\\mu</span> rounds on the outer sum as described in Algorithm 1. Note that in the <span class="math">i</span>th round, for any given value of <span class="math">\\mathbf{x} \\in B_{\\mu - i}</span>, <span class="math">eq((\\alpha_1, \\ldots, \\alpha_i, \\mathbf{x}), \\tilde{\\sigma}^{-1}(\\mathbf{y}))</span> is non-zero for at most <span class="math">2^i</span> values of <span class="math">\\mathbf{y} \\in B_{\\mu}</span>. This is because <span class="math">\\tilde{\\sigma}^{-1}</span> is a permutation on the boolean hypercube, thus the <span class="math">eq</span> value is non-zero only if the last <span class="math">\\mu - i</span> values of <span class="math">\\tilde{\\sigma}^{-1}(\\mathbf{y})</span> are identical to <span class="math">\\mathbf{x}</span>. Similarly <span class="math">eq((\\alpha_1, \\ldots, \\alpha_i, \\mathbf{x}), \\mathbf{y}) \\neq 0</span> for at most <span class="math">2^i</span> values of <span class="math">\\mathbf{y}</span> for any given <span class="math">\\mathbf{x}</span>. The prover can, therefore, evaluate all inner sumchecks in each round in time <span class="math">O(2^\\mu)</span>. The prover runs in time <span class="math">O(\\mu 2^\\mu)</span>. 4: Run the inner sumcheck with <span class="math">\\mathbf{x} = \\boldsymbol{\\alpha}</span> as described in Algorithm 1 and treating <span class="math">\\tilde{\\sigma}_1^{-1},\\ldots ,\\tilde{\\sigma}_\\mu^{-1}</span> as multi-linear polynomials. The prover runs in time <span class="math">O(2^{\\mu}\\mu \\log^{2}(\\mu))</span> as the sumcheck has <span class="math">\\mu</span> rounds and degree <span class="math">\\mu</span>. 5: <strong>end procedure</strong></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Theorem 3.7.</strong> The PERM2 PIOP described by the sumcheck for Equation (9) and the corresponding prover from Algorithm 3 for <span class="math">\\mathcal{R}_{\\text{PERM}}</span> is perfectly complete and has knowledge error $\\delta_{\\text{perm2}}^{1,\\mu} \\coloneqq \\delta_{\\text{sum}}^{\\mu + 1,2\\mu} = O(\\mu^2 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> <strong>Completeness.</strong> For any <span class="math">\\left(\\sigma; ([[f]], [[g]]); (f, g)\\right) \\in \\mathcal{R}_{\\mathrm{PERM}}</span>, it holds that <span class="math">f(\\sigma(\\mathbf{x})) - g(\\mathbf{x}) = 0</span> for all <span class="math">\\mathbf{x} \\in B_{\\mu}</span>. Moreover, for all <span class="math">\\mathbf{x}, \\mathbf{y} \\in B_{\\mu}</span>, it holds that <span class="math">eq(\\mathbf{x}, \\tilde{\\sigma}^{-1}(\\mathbf{y})) = 1</span> if <span class="math">\\sigma(\\mathbf{x}) = \\mathbf{y}</span> and <span class="math">eq(\\mathbf{x}, \\tilde{\\sigma}^{-1}(\\mathbf{y})) = 0</span> otherwise; and <span class="math">eq(\\mathbf{x}, \\mathbf{y}) = 1</span> if <span class="math">\\mathbf{x} = \\mathbf{y}</span> and <span class="math">eq(\\mathbf{x}, \\mathbf{y}) = 0</span> otherwise. Thus for <span class="math">h(\\mathbf{x}) = \\sum_{\\mathbf{y} \\in B_{\\mu}} f(\\mathbf{y}) \\cdot eq(\\mathbf{x}, \\tilde{\\sigma}^{-1}(\\mathbf{y})) - g(\\mathbf{y}) eq(\\mathbf{x}, \\mathbf{y})</span></p>

    <div class="my-4 text-center"><span class="math-block">\\left([ [h ] ]; h\\right) \\in \\mathcal {R} _ {\\mathrm {Z E R O}}</span></div>

    <p class="text-gray-300">and completeness follows from the completeness of the PolyIOP for <span class="math">\\mathcal{R}_{\\mathrm{ZERO}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Knowledge soundness.</strong> By Lemma 2.3, it is sufficient to argue the soundness error of the protocol. The permutation relation holds if and only if the above zerocheck relation holds, which reduces to a sumcheck for Equation (9). The sumcheck PolyIOP is over a virtual polynomial that has <span class="math">2\\mu</span> variables and individual degree <span class="math">\\mu + 1</span>. Thus the soundness error is $\\delta_{\\mathcal{R}_{\\mathrm{SUM}}}^{\\mu + 1,2\\mu} = O(\\mu^2 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">Complexity.</h4>

    <p class="text-gray-300">The prover complexity of the PERM2 PIOP with respect to <span class="math">f,g\\in\\mathcal{F}_{\\mu}^{(\\leq 1)}</span> is <span class="math">O(2^{\\mu}\\mu\\log^{2}(\\mu))</span> as the prover uses <span class="math">O(\\mu 2^{\\mu})</span> in step 3 and <span class="math">O(2^{\\mu}\\mu\\log^{2}(\\mu))</span> in step 4 of the algorithm. The verifier is simply the sumcheck verifier for a <span class="math">2\\mu</span> round sumcheck and runs in time <span class="math">O(\\mu)</span>. The verifier queries <span class="math">2\\mu</span> univariate polynomials and <span class="math">2+\\mu</span> multi-linear polynomials <span class="math">(f,g,\\tilde{\\sigma}^{-1})</span> each at one point. The PIOP proof size consists of <span class="math">2\\mu</span> univariate oracles (one per round of the sumcheck).</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">3.7 Lookup PIOP</h3>

    <p class="text-gray-300">This section describes a multivariate PIOP checking the table lookup relation. The PIOP builds upon the multiset check PIOP (Section 3.4) and is a key building block for HyperPlonk+ (Section 5). Our construction is inspired by a univariate PIOP for the table lookup relation called Plookup <em>[44]</em>. However, it is non-trivial to adapt Plookup to the multivariate setting because their scheme requires the existence of a subdomain of the polynomial that is a cyclic subgroup <span class="math">\\mathbb{G}</span> with a generator <span class="math">\\omega\\in\\mathbb{G}</span>. Translating to the multilinear case, we need to build an efficient function <span class="math">g</span> that generates the entire boolean hypercube; moreover, <span class="math">g</span> has to be linear so that the degree of the polynomial does not blow up. However, such a linear function does not exist. Fortunately, we can construct a quadratic function from <span class="math">\\mathbb{F}^{\\mu}</span> to <span class="math">\\mathbb{F}^{\\mu}</span> that traverses <span class="math">B_{\\mu}</span>. We then show how to linearize it by modifying some of the building blocks that Plookup uses. This gives an efficient Plookup protocol over the hypercube.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Definition 3.6 (Lookup relation).</h6>

    <p class="text-gray-300">The indexed relation <span class="math">\\mathcal{R}_{\\text{LOOKUP}}</span> is the set of tuples</p>

    <p class="text-gray-300"><span class="math">(\\mathfrak{i};\\mathbf{x};\\mathbf{w})=\\big{(}\\mathbf{t};[[f]];(f,\\mathsf{addr})\\big{)}</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbf{t}\\in\\mathbb{F}^{2^{\\mu}-1}</span>, <span class="math">f\\in\\mathcal{F}_{\\mu}^{(\\leq d)}</span>, and <span class="math">\\mathsf{addr}:B_{\\mu}\\to[1,2^{\\mu})</span> is a map such that <span class="math">f(\\mathbf{x})=\\mathbf{t}_{\\mathsf{addr}(\\mathbf{x})}</span> for all <span class="math">\\mathbf{x}\\in B_{\\mu}</span>.</p>

    <p class="text-gray-300">Before presenting the PIOP for <span class="math">\\mathcal{R}_{\\text{LOOKUP}}</span>, we first show how to build a <em>quadratic</em> function that generates the entire boolean hypercube.</p>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">A quadratic generator in <span class="math">\\mathbb{F}_{2^{\\mu}}</span>.</h4>

    <p class="text-gray-300">For every <span class="math">\\mu\\in\\mathbb{N}</span>, we fix a <em>primitive polynomial</em> <span class="math">p_{\\mu}\\in\\mathbb{F}_{2}[X]</span> where <span class="math">p_{\\mu}:=X^{\\mu}+\\sum_{s\\in S}X^{s}+1</span> for some set <span class="math">S\\subseteq[\\mu-1]</span>, so that <span class="math">\\mathbb{F}_{2}[X]/(p_{\\mu})\\cong\\mathbb{F}_{2}^{\\mu}[X]\\cong\\mathbb{F}_{2^{\\mu}}</span>. By definition of primitive polynomials, <span class="math">X\\in\\mathbb{F}_{2}^{\\mu}[X]</span> is a generator of <span class="math">\\mathbb{F}_{2}^{\\mu}[X]\\setminus\\{0\\}</span>. This naturally defines a generator function <span class="math">g_{\\mu}:B_{\\mu}\\to B_{\\mu}</span> as</p>

    <p class="text-gray-300"><span class="math">g_{\\mu}(\\bm{b}_{1},\\ldots,\\bm{b}_{\\mu})=\\left(\\bm{b}_{\\mu},\\bm{b}_{1}^{\\prime},\\ldots,\\bm{b}_{\\mu-1}^{\\prime}\\right),</span></p>

    <p class="text-gray-300">where <span class="math">\\bm{b}_{i}^{\\prime}=\\bm{b}_{i}\\oplus\\bm{b}_{\\mu}</span> (<span class="math">i\\leq 1&lt;\\mu</span>) if <span class="math">i\\in S</span>, and <span class="math">\\bm{b}_{i}^{\\prime}=\\bm{b}_{i}</span> otherwise. Essentially, for a polynomial <span class="math">f\\in\\mathbb{F}_{2}^{\\mu}[X]</span> with coefficients <span class="math">\\bm{b}</span>, <span class="math">g_{\\mu}(\\bm{b})</span> is the coefficient vector of <span class="math">X\\cdot f(X)</span>. Hence the following lemma is straightforward.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Lemma 3.8.</h6>

    <p class="text-gray-300">Let <span class="math">g_{\\mu}:B_{\\mu}\\to B_{\\mu}</span> be the generator function defined above. For every <span class="math">\\mathbf{x}\\in B_{\\mu}\\setminus\\{0^{\\mu}\\}</span>, it holds that <span class="math">\\{g_{\\mu}^{(i)}(\\mathbf{x})\\}_{i\\in[2^{\\mu}-1]}=B_{\\mu}\\setminus\\{0^{\\mu}\\}</span>, where <span class="math">g_{\\mu}^{(i)}(\\cdot)</span> denotes <span class="math">i</span> repeated application of <span class="math">g_{\\mu}</span>.</p>

    <p class="text-gray-300">Directly composing a polynomial <span class="math">f</span> with the generator <span class="math">g</span> will blow up the degree of the resulting polynomial; moreover, the prover needs to send the composed oracle <span class="math">f(g(\\cdot))</span>. Both of which affect the efficiency of the PIOP. We address the issue by describing a trick that manipulates <span class="math">f</span> in a way that simulates the behavior of <span class="math">f(g(\\cdot))</span> on the boolean hypercube, but without blowing up the degree.</p>

    <p class="text-gray-300">Linearizing the generator. For a multivariate polynomial <span class="math">f \\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span>, we define <span class="math">f_{\\Delta_{\\mu}} \\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span> as</p>

    <div class="my-4 text-center"><span class="math-block">f _ {\\Delta_ {\\mu}} (\\mathbf {X} _ {1}, \\dots , \\mathbf {X} _ {\\mu}) := \\mathbf {X} _ {\\mu} \\cdot f (1, \\mathbf {X} _ {1} ^ {\\prime}, \\dots , \\mathbf {X} _ {\\mu - 1} ^ {\\prime}) + (1 - \\mathbf {X} _ {\\mu}) \\cdot f (0, \\mathbf {X} _ {1}, \\dots , \\mathbf {X} _ {\\mu - 1})</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{X}_i^{\\prime} := 1 - \\mathbf{X}_i</span> (<span class="math">i \\leq 1 &amp;lt; \\mu</span>) if <span class="math">i \\in S</span>, and <span class="math">\\mathbf{X}_i^{\\prime} := \\mathbf{X}_i</span> otherwise.</p>

    <p class="text-gray-300"><strong>Lemma 3.9.</strong> For every <span class="math">\\mu \\in \\mathbb{N}</span>, let <span class="math">g_{\\mu}: B_{\\mu} \\to B_{\\mu}</span> be the generator function defined in Lemma 3.8. For every <span class="math">d \\in \\mathbb{N}</span> and polynomial <span class="math">f \\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span>, it holds that <span class="math">f_{\\Delta_{\\mu}}(\\mathbf{x}) = f(g_{\\mu}(\\mathbf{x}))</span> for every <span class="math">\\mathbf{x} \\in B_{\\mu}</span>. Moreover, <span class="math">f_{\\Delta_{\\mu}}</span> has individual degree <span class="math">d</span> and one can evaluate <span class="math">f_{\\Delta_{\\mu}}</span> from 2 evaluations of <span class="math">f</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> By definition, <span class="math">f_{\\Delta_{\\mu}}</span> has individual degree <span class="math">d</span> and an evaluation of <span class="math">f_{\\Delta_{\\mu}}</span> can be derived from 2 evaluations of <span class="math">f</span>. Next, we argue that <span class="math">f_{\\Delta_{\\mu}}(\\mathbf{x}) = f(g_{\\mu}(\\mathbf{x}))</span> for every <span class="math">\\mathbf{x} \\in B_{\\mu}</span>.</p>

    <p class="text-gray-300">First, <span class="math">f_{\\Delta_{\\mu}}(0^{\\mu}) = f(g_{\\mu}(0^{\\mu}))</span> because <span class="math">f_{\\Delta_{\\mu}}(0^{\\mu}) = f(0^{\\mu})</span> and <span class="math">g_{\\mu}(0^{\\mu}) = 0^{\\mu}</span> by definition of <span class="math">f_{\\Delta_{\\mu}}, g_{\\mu}</span>. Second, for every <span class="math">\\mathbf{x} \\in B_{\\mu} \\setminus \\{0^{\\mu}\\}</span>, by definition of <span class="math">g_{\\mu}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">f (g _ {\\mu} (\\mathbf {x} _ {1}, \\dots , \\mathbf {x} _ {\\mu})) = f (\\mathbf {x} _ {\\mu}, \\mathbf {x} _ {1} ^ {\\prime}, \\dots , \\mathbf {x} _ {\\mu - 1} ^ {\\prime}),</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{x}_i&#x27; = \\mathbf{x}_i \\oplus \\mathbf{x}_\\mu</span> (<span class="math">i \\leq 1 &amp;lt; \\mu</span>) for every <span class="math">i</span> in the fixed set <span class="math">S</span>, and <span class="math">\\mathbf{x}_i&#x27; = \\mathbf{x}_i</span> otherwise. We observe that <span class="math">\\mathbf{x}_i \\oplus \\mathbf{x}_\\mu = 1 - \\mathbf{x}_i</span> when <span class="math">\\mathbf{x}_\\mu = 1</span> and <span class="math">\\mathbf{x}_i \\oplus \\mathbf{x}_\\mu = \\mathbf{x}_i</span> when <span class="math">\\mathbf{x}_\\mu = 0</span>, thus we can rewrite</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f (\\mathbf {x} _ {\\mu}, \\mathbf {x} _ {1} ^ {\\prime}, \\dots , \\mathbf {x} _ {\\mu - 1} ^ {\\prime}) = \\mathbf {x} _ {\\mu} \\cdot f (1, \\mathbf {x} _ {1} ^ {*}, \\dots , \\mathbf {x} _ {\\mu - 1} ^ {*}) + (1 - \\mathbf {x} _ {\\mu}) \\cdot f (0, \\mathbf {x} _ {1}, \\dots , \\mathbf {x} _ {\\mu - 1}) \\\\ = f _ {\\Delta_ {\\mu}} \\left(\\mathbf {x} _ {1}, \\dots , \\mathbf {x} _ {\\mu}\\right) \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{x}_i^<em> = 1 - \\mathbf{x}_i</span> (<span class="math">i \\leq 1 &amp;lt; \\mu</span>) for every <span class="math">i</span> in the fixed set <span class="math">S</span>, and <span class="math">\\mathbf{x}_i^</em> = \\mathbf{x}_i</span> otherwise. The last equality holds by definition of <span class="math">f_{\\Delta_\\mu}</span>. In summary, <span class="math">f(g_\\mu(\\mathbf{x}_1, \\ldots, \\mathbf{x}_\\mu)) = f_{\\Delta_\\mu}(\\mathbf{x}_1, \\ldots, \\mathbf{x}_\\mu)</span> for every <span class="math">B_\\mu</span> and the lemma holds.</p>

    <p class="text-gray-300"><strong>Construction.</strong> Now we are ready to present the PIOP for <span class="math">\\mathcal{R}_{\\mathrm{LOOKUP}}</span>, which is an adaptation of Plookup [44] in the multivariate setting. The PIOP invokes a protocol for <span class="math">\\mathcal{R}_{\\mathrm{MSET}}^2</span>. We introduce a notation that embeds a vector to the hypercube while still preserving the vector order with respect to the generator function. For a vector <span class="math">\\mathbf{t} \\in \\mathbb{F}^{2^\\mu - 1}</span>, we denote by <span class="math">t \\gets \\mathsf{emb}(\\mathbf{t}) \\in \\mathcal{F}_\\mu^{(\\leq 1)}</span> the multilinear polynomial such that <span class="math">t(0^\\mu) = 0</span> and <span class="math">t\\big(g_\\mu^{(i)}(1, 0^{\\mu - 1})\\big) = \\mathbf{t}_i</span> for every <span class="math">i \\in [2^\\mu - 1]</span>. By Lemma 3.8, <span class="math">t</span> is well-defined and embeds the entire vector <span class="math">\\mathbf{t}</span> onto <span class="math">B_\\mu \\setminus \\{0^\\mu\\}</span>.</p>

    <p class="text-gray-300">For an index <span class="math">\\mathbf{t} \\in \\mathbb{F}^{2^{\\mu} - 1}</span>, the indexer generates an oracle <span class="math">[[t]]</span> where <span class="math">t \\gets \\mathsf{emb}(\\mathbf{t})</span>. For a tuple <span class="math">(\\mathbf{t}; [[f]]; (f, \\mathsf{addr}))</span> where <span class="math">f(B_{\\mu}) \\subseteq t(B_{\\mu}) \\setminus \\{0\\}</span>, let <span class="math">(\\mathbf{a}_1, \\ldots, \\mathbf{a}_{2^{\\mu} - 1})</span> be the vector where <span class="math">\\mathbf{a}_i \\in \\mathbb{N}</span> is the number of appearance of <span class="math">\\mathbf{t}_i</span> in <span class="math">f(B_{\\mu})</span>. Note that <span class="math">\\sum_{i=1}^{2^{\\mu} - 1} \\mathbf{a}_i = 2^{\\mu}</span>. Denote by <span class="math">\\mathbf{h} \\in \\mathbb{F}^{2^{\\mu + 1} - 1}</span> the vector</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {h} := \\left(\\underbrace {\\mathbf {t} _ {1} , \\ldots , \\mathbf {t} _ {1}} _ {1 + \\mathbf {a} _ {1}}, \\mathbf {t} _ {2}, \\ldots , \\mathbf {t} _ {i - 1}, \\underbrace {\\mathbf {t} _ {i} , \\ldots , \\mathbf {t} _ {i}} _ {1 + \\mathbf {a} _ {i}}, \\mathbf {t} _ {i + 1}, \\ldots , \\mathbf {t} _ {2 ^ {\\mu} - 2}, \\underbrace {\\mathbf {t} _ {2 ^ {\\mu} - 1} , \\ldots \\mathbf {t} _ {2 ^ {\\mu} - 1}} _ {1 + \\mathbf {a} _ {2 ^ {\\mu} - 1}}\\right).</span></div>

    <p class="text-gray-300">We present the protocol below:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> sends <span class="math">\\mathcal{V}</span> oracles <span class="math">[[h]]</span>, where <span class="math">h \\gets \\mathrm{emb}(\\mathbf{h}) \\in \\mathcal{F}_{\\mu + 1}^{(\\leq 1)}</span>.</li>

      <li>Define <span class="math">g_1 \\coloneqq \\mathsf{merge}(f, t) \\in \\mathcal{F}_{\\mu + 1}^{(\\leq d)}</span> and <span class="math">g_2 \\coloneqq \\mathsf{merge}(f, t_{\\Delta_\\mu}) \\in \\mathcal{F}_{\\mu + 1}^{(\\leq d)}</span>, where <span class="math">\\mathsf{merge}</span> is defined in equation (7). Run a multiset check PIOP (Section 3.4) for</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left([ [ g _ {1} ] ], [ [ g _ {2} ] ], [ [ h ] ], [ [ h _ {\\Delta_ {\\mu + 1}} ] ]\\right); (f, t, h)\\right) \\in \\mathcal {R} _ {\\mathrm {M S E T}} ^ {2}.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> queries <span class="math">h(0^{\\mu + 1})</span> and checks that the answer equals 0.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Theorem 3.10.</strong> The PIOP for <span class="math">\\mathcal{R}_{\\text{LOOKUP}}</span> is perfectly complete and has knowledge error $\\delta_{\\text{lkup}}^{d,\\mu} \\coloneqq \\delta_{\\text{mset},2}^{d,\\mu + 1} = \\mathcal{O}\\big((2^{\\mu} + d\\mu) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\big)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> Completeness. Denote by <span class="math">n \\coloneqq 2^{\\mu}</span>. For any <span class="math">(\\mathbf{t}; [[f]]; (f, \\mathsf{addr})) \\in \\mathcal{R}_{\\mathrm{LOOKUP}}</span>, let <span class="math">\\mathbf{h} \\in \\mathbb{F}^{2n - 1}</span> be the vector defined in the construction. Gabizon and Williamson [44] observed that</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{\\left[ \\mathbf {f} _ {i}, \\mathbf {f} _ {i} \\right] \\right\\} _ {i \\in [ n ]} \\cup \\left\\{\\left[ \\mathbf {t} _ {i}, \\mathbf {t} _ {(i \\bmod (n - 1)) + 1} \\right] \\right\\} _ {i \\in [ n - 1 ]} = \\left\\{\\left[ \\mathbf {h} _ {i}, \\mathbf {h} _ {(i \\bmod (2 n - 1)) + 1} \\right] \\right\\} _ {i \\in [ 2 n - 1 ]},</span></div>

    <p class="text-gray-300">equivalently, by definition of <span class="math">t,h</span> and by Lemma 3.9, the following two multisets of tuples are equal</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{\\left[ f (\\mathbf {x}), f (\\mathbf {x}) \\right] \\right\\} _ {\\mathbf {x} \\in B _ {\\mu}} \\cup \\left\\{\\left[ t (\\mathbf {x}), t _ {\\Delta_ {\\mu}} (\\mathbf {x}) \\right] \\right\\} _ {\\mathbf {x} \\in B _ {\\mu} \\backslash \\{0 ^ {\\mu} \\}} = \\left\\{\\left[ h (\\mathbf {x}), h _ {\\Delta_ {\\mu + 1}} (\\mathbf {x}) \\right] \\right\\} _ {\\mathbf {x} \\in B _ {\\mu + 1} \\backslash \\{0 ^ {\\mu + 1} \\}}.</span></div>

    <p class="text-gray-300">By adding element <span class="math">[0,0] = \\left[t(0^{\\mu}),t_{\\Delta_{\\mu}}(0^{\\mu})\\right] = \\left[h(0^{\\mu +1}),h_{\\Delta_{\\mu +1}}(0^{\\mu +1})\\right]</span> on both sides, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{\\left[ f (\\mathbf {x}), f (\\mathbf {x}) \\right] \\right\\} _ {\\mathbf {x} \\in B _ {\\mu}} \\cup \\left\\{\\left[ t (\\mathbf {x}), t _ {\\Delta_ {\\mu}} (\\mathbf {x}) \\right] \\right\\} _ {\\mathbf {x} \\in B _ {\\mu}} = \\left\\{\\left[ h (\\mathbf {x}), h _ {\\Delta_ {\\mu + 1}} (\\mathbf {x}) \\right] \\right\\} _ {\\mathbf {x} \\in B _ {\\mu + 1}}.</span></div>

    <p class="text-gray-300">Hence the verifier accepts in the multiset check by completeness of the PIOP for <span class="math">\\mathcal{R}_{\\mathrm{MSET}}^2</span>.</p>

    <p class="text-gray-300"><strong>Knowledge soundness.</strong> By Lemma 2.3, to argue knowledge soundness, it is sufficient to argue the soundness error of the protocol. Fix <span class="math">n \\coloneqq 2^{\\mu}</span>, for any <span class="math">(\\mathbf{t}; [[f]]) \\notin \\mathcal{L}(\\mathcal{R}_{\\mathrm{LOOKUP}})</span>, denote by <span class="math">\\mathbf{f} \\in \\mathbb{F}^n</span> the evaluations of <span class="math">f</span> on <span class="math">B_{\\mu}</span>. Gabizon et. al. [44] showed that for any <span class="math">\\mathbf{h} \\in \\mathbb{F}^{2n-1}</span>, it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{\\left[ \\mathbf {f} _ {i}, \\mathbf {f} _ {i} \\right] \\right\\} _ {i \\in [ n ]} \\cup \\left\\{\\left[ \\mathbf {t} _ {i}, \\mathbf {t} _ {(i \\bmod (n - 1)) + 1} \\right] \\right\\} _ {i \\in [ n - 1 ]} \\neq \\left\\{\\left[ \\mathbf {h} _ {i}, \\mathbf {h} _ {(i \\bmod (2 n - 1)) + 1} \\right] \\right\\} _ {i \\in [ 2 n - 1 ]},</span></div>

    <p class="text-gray-300">since <span class="math">t(0^{\\mu}) = 0</span> and <span class="math">\\mathcal{V}</span> checks that <span class="math">h(0^{\\mu +1}) = 0</span>, with a similar argument as in the completeness proof, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{\\left[ f (\\mathbf {x}), f (\\mathbf {x}) \\right] \\right\\} _ {\\mathbf {x} \\in B _ {\\mu}} \\cup \\left\\{\\left[ t (\\mathbf {x}), t _ {\\Delta_ {\\mu}} (\\mathbf {x}) \\right] \\right\\} _ {\\mathbf {x} \\in B _ {\\mu}} \\neq \\left\\{\\left[ h (\\mathbf {x}), h _ {\\Delta_ {\\mu + 1}} (\\mathbf {x}) \\right] \\right\\} _ {\\mathbf {x} \\in B _ {\\mu + 1}}</span></div>

    <p class="text-gray-300">and the multiset check relation does not hold. Therefore, the probability that <span class="math">\\mathcal{V}</span> accepts is at most <span class="math">\\delta_{\\mathrm{mset},2}^{d,\\mu +1}</span> as claimed.</p>

    <p class="text-gray-300"><strong>Complexity.</strong> Let <span class="math">f</span>, <span class="math">\\mathbf{F} \\coloneqq (g_1, g_2, h, h_{\\Delta_{\\mu + 1}}) \\in \\left(\\mathcal{F}_{\\mu + 1}^{(\\leq d)}\\right)^2 \\times \\left(\\mathcal{F}_{\\mu + 1}^{(\\leq 1)}\\right)^2</span> be the polynomials defined in the construction. We analyze the complexity of the PIOP for <span class="math">\\mathcal{R}_{\\mathrm{LOOKUP}}</span> with respect to <span class="math">f \\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover time is <span class="math">\\mathsf{tp}_{\\mathrm{lkup}}^f = \\mathsf{tp}_{\\mathrm{mset}}^{\\mathbf{F}} = \\mathcal{O}\\left(d\\log^2 d\\cdot 2^\\mu\\right)</span> <span class="math">\\mathbb{F}</span>-ops.</li>

      <li>The verifier time is <span class="math">\\mathsf{tv}_{\\mathrm{lkup}}^f = \\mathsf{tv}_{\\mathrm{mset}}^{\\mathbf{F}} = \\mathcal{O}(\\mu)</span>.</li>

      <li>The query complexity is <span class="math">\\mathfrak{q}_{\\mathrm{lkup}}^f = 1 + \\mathfrak{q}_{\\mathrm{mset}}^{\\mathbf{F}} = \\mu + 3</span>.</li>

      <li>The round complexity and the number of proof oracles is <span class="math">\\mathsf{rc}_{\\mathrm{lkup}}^f = 1 + \\mathsf{rc}_{\\mathrm{mset}}^{\\mathbf{F}} = \\mu + 2</span>.</li>

      <li>The number of field elements sent by <span class="math">\\mathcal{P}</span> is <span class="math">\\mathsf{nf}_{\\mathrm{lkup}}^f = \\mathsf{nf}_{\\mathrm{mset}}^{\\mathbf{F}} = \\mu</span>.</li>

      <li>The size of the proof oracles is <span class="math">\\mathsf{pl}_{\\mathrm{lkup}}^f = 2^{\\mu +1} + \\mathsf{pl}_{\\mathrm{mset}}^{\\mathbf{F}} = \\mathcal{O}(2^\\mu)</span> where <span class="math">2^{\\mu +1}</span> is the oracle size of <span class="math">h</span>. The size of the witness is <span class="math">\\mathcal{O}(2^{\\mu})</span>.</li>

    </ul>

    <p class="text-gray-300">29</p>

    <p class="text-gray-300">3.8 Batch openings</p>

    <p class="text-gray-300">This section describes a batching protocol proving the correctness of multiple multivariate polynomial evaluations. Essentially, the protocol reduces multiple oracle queries to different polynomials into a <em>single</em> query to a multivariate oracle. The batching protocol is helpful for HyperPlonk to enable efficient batch evaluation openings. In particular, the SNARK prover only needs to compute a single multilinear PCS evaluation proof, even if there are multiple PCS evaluations.</p>

    <p class="text-gray-300">We note that Thaler <em>[73, §4.5.2]</em> shows how to batch two evaluations of a <em>single</em> multilinear polynomial. The algorithm can be generalized for multiple evaluations of <em>different</em> multilinear polynomials. However, the prover time complexity is <span class="math">O(k^{2}\\mu\\cdot 2^{\\mu})</span> where <span class="math">k</span> is the number of evaluations, and <span class="math">\\mu</span> is the number of variables. In comparison, our algorithm achieves complexity <span class="math">O(k\\cdot 2^{\\mu})</span> which is <span class="math">k\\mu</span>-factor faster. Note that <span class="math">O(k\\cdot 2^{\\mu})</span> is already optimal as the prover needs to take <span class="math">O(k\\cdot 2^{\\mu})</span> time to evaluate <span class="math">\\{f_{i}(\\mathbf{z}_{i})\\}_{i\\in[k]}</span> before batching.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Definition 3.7 (BatchEval relation).</h6>

    <p class="text-gray-300">The relation <span class="math">\\mathcal{R}^{k}_{{\\text{BATCH}}}</span> is the set of all tuples <span class="math">(\\mathbf{x};\\mathbf{w})=\\big{(}(\\mathbf{z}_{i})_{i\\in[k]},(y_{i})_{i\\in[k]},\\big{(}[[f_{i}]]\\big{)}_{i\\in[k]};(f_{i})_{i\\in[k]}\\big{)}</span> where <span class="math">\\mathbf{z}_{i}\\in\\mathbb{F}^{\\mu}</span>, <span class="math">y_{i}\\in\\mathbb{F}</span>, <span class="math">f_{i}\\in\\mathcal{F}^{(\\leq d)}_{\\mu}</span> and <span class="math">f_{i}(\\mathbf{z}_{i})=y_{i}</span> for all <span class="math">i\\in[k]</span>.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Remark 3.1.</h6>

    <p class="text-gray-300">The polynomials <span class="math">\\{f_{i}\\}_{i\\in[k]}</span> are not necessarily distinct. E.g., to evaluate a single polynomial <span class="math">f</span> at <span class="math">k</span> distinct points, we can set <span class="math">f_{1}=f_{2}=\\dots=f_{k}=f</span>.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Remark 3.2.</h6>

    <p class="text-gray-300">The polynomials <span class="math">\\{f_{i}\\}_{i\\in[k]}</span> are all <span class="math">\\mu</span>-variate. This is without loss of generality. E.g., suppose one of the evaluated polynomial <span class="math">f_{j}^{\\prime}</span> has only <span class="math">\\mu-1</span> variables, we can define <span class="math">f_{j}(Y,\\mathbf{X})=Y\\cdot f_{j}^{\\prime}(\\mathbf{X})+(1-Y)\\cdot f_{j}^{\\prime}(\\mathbf{X})</span> which is essentially <span class="math">f_{j}^{\\prime}</span> but with <span class="math">\\mu</span> variables. The same trick easily extends to <span class="math">f_{j}^{\\prime}</span> with arbitrary <span class="math">\\mu^{\\prime}&lt;\\mu</span> variables.</p>

    <h4 id="sec-48" class="text-lg font-semibold mt-6">Construction.</h4>

    <p class="text-gray-300">For ease of exposition, we consider the case where <span class="math">f_{1},\\dots,f_{k}</span> are <em>multilinear</em>. We emphasize that the same techniques can be extended for multi-variate polynomials.</p>

    <p class="text-gray-300">Assume w.l.o.g that <span class="math">k=2^{\\ell}</span> is a power of <span class="math">2</span>. We observe that <span class="math">\\mathcal{R}^{k}_{{\\text{BATCH}}}</span> is essentially a ZeroCheck relation over the set <span class="math">Z:=\\{\\mathbf{z}_{i}\\}_{i\\in[k]}\\subseteq\\mathbb{F}^{\\mu}</span>, that is, for every <span class="math">i\\in[k]</span>, <span class="math">f_{i}(\\mathbf{z}_{i})-y_{i}=0</span>. Nonetheless, <span class="math">Z</span> is outside the boolean hypercube, and we cannot directly reuse the ZeroCheck PIOP.</p>

    <p class="text-gray-300">The key idea is to interpret each zero constraint as a sumcheck via multilinear extension, so that we can work on the boolean hypercube later. In particular, for every <span class="math">i\\in[k]</span>, we want to constrain <span class="math">f_{i}(\\mathbf{z}_{i})-y_{i}=0</span>. Since <span class="math">f_{i}</span> is multilinear, by definition of multilinear extension, this is equivalent to constraining that</p>

    <p class="text-gray-300"><span class="math">c_{i}:=\\left(\\sum_{\\bm{b}\\in B_{\\mu}}f_{i}(\\bm{b})\\cdot eq(\\bm{b},\\mathbf{z}_{i})\\right)-y_{i}=0\\,.</span> (10)</p>

    <p class="text-gray-300">Note that equation (10) holds for every <span class="math">i\\in[k]</span> if and only if the polynomial</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in[k]}eq(\\mathbf{Z},\\langle i\\rangle)\\cdot c_{i}</span></p>

    <p class="text-gray-300">is identically zero, where <span class="math">\\langle i\\rangle</span> is <span class="math">\\ell</span>-bit representation of <span class="math">i-1</span>. By Lemma 2.2, it is sufficient to check that for a random vector <span class="math">\\mathbf{t}\\xleftarrow{}\\mathbb{F}^{\\ell}</span>, it holds that</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in[k]}eq(\\mathbf{t},\\langle i\\rangle)\\cdot c_{i}=\\sum_{i\\in[k]}eq(\\mathbf{t},\\langle i\\rangle)\\cdot\\left[\\left(\\sum_{\\bm{b}\\in B_{\\mu}}f_{i}(\\bm{b})\\cdot eq(\\bm{b},\\mathbf{z}_{i})\\right)-y_{i}\\right]=0\\,.</span> (11)</p>

    <p class="text-gray-300">Next, we arithmetize equation (11) and make it an algebraic formula. For every <span class="math">(i,\\bm{b})\\in[k]\\times B_{\\mu}</span>, we set value <span class="math">g_{i,\\bm{b}}:=eq(\\mathbf{t},\\langle i\\rangle)\\cdot f_{i}(\\bm{b})</span>, and define an MLE <span class="math">\\tilde{g}</span> for <span class="math">(g_{i,\\bm{b}})_{i\\in[k],\\bm{b}\\in B_{\\mu}}</span> such that <span class="math">\\tilde{g}(\\langle i\\rangle,\\bm{b})=g_{i,\\bm{b}}\\forall(i,\\bm{b})\\in[k]\\times B_{\\mu}</span>; similarly, we define an MLE <span class="math">\\tilde{e}q</span> for <span class="math">(eq(\\bm{b},\\mathbf{z}_{i}))_{i\\in[k],\\bm{b}\\in B_{\\mu}}</span> where <span class="math">\\tilde{e}q(\\langle i\\rangle,\\bm{b})=eq(\\bm{b},\\mathbf{z}_{i})\\forall(i,\\bm{b})\\in[k]\\times B_{\\mu}</span>. Let <span class="math">s:=\\sum_{i\\in[k]}eq(\\mathbf{t},\\langle i\\rangle)\\cdot y_{i}</span>, then equation (11) can be rewritten as</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in[k],\\bm{b}\\in B_{\\mu}}\\tilde{g}(\\langle i\\rangle,\\bm{b})\\cdot\\tilde{e}q(\\langle i\\rangle,\\bm{b})=s\\,.</span></p>

    <p class="text-gray-300">This is equivalent to prove a sumcheck claim for the degree-2 polynomial <span class="math">g^{<em>}:=\\tilde{g}(\\mathbf{Y},\\mathbf{X})\\cdot\\tilde{e}q(\\mathbf{Y},\\mathbf{X})</span> over set <span class="math">B_{\\ell+\\mu}</span>. Hence we obtain the following PIOP protocol in Algorithm 4. Note that <span class="math">g^{</em>}=\\tilde{g}\\cdot\\tilde{e}q</span> is only with degree 2. Thus we can run a classic sumcheck without sending any univariate oracles.</p>

    <p class="text-gray-300">Algorithm 4 Batch evaluation of multi-linear polynomials</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1:procedure BatchEval$([f_{i}\\in\\mathcal{F}_{\\mu}^{(\\leq 1)},\\mathbf{z}_{i}\\in\\mathbb{F}^{\\mu},y_{i}\\in\\mathbb{F}_{i=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">2: <span class="math">\\mathcal{V}</span> sends <span class="math">\\mathcal{P}</span> a random vector <span class="math">\\mathbf{t}\\xleftarrow{*}\\mathbb{F}^{\\ell}</span>. 3: Define sum <span class="math">s:=\\sum_{i\\in[k]}eq(\\mathbf{t},\\langle i\\rangle)\\cdot y_{i}</span>. 4: Let <span class="math">\\tilde{g}</span> be the MLE for <span class="math">(g_{i,\\bm{b}})_{i\\in[k],\\bm{b}\\in B_{\\mu}}</span> where</p>

    <p class="text-gray-300"><span class="math">g_{i,\\bm{b}}:=eq(\\mathbf{t},\\langle i\\rangle)\\cdot f_{i}(\\bm{b})\\,.</span> 5: Let <span class="math">\\tilde{e}q</span> be the MLE for <span class="math">(eq(\\bm{b},\\mathbf{z}_{i}))_{i\\in[k],\\bm{b}\\in B_{\\mu}}</span> such that <span class="math">\\tilde{e}q(\\langle i\\rangle,\\bm{b})=eq(\\bm{b},\\mathbf{z}_{i})</span>. 6: <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> run a SumCheck PIOP for <span class="math">\\big{(}s,[[g^{<em>}]];g^{</em>}\\big{)}\\in\\mathcal{R}_{\\mathrm{SUM}}</span>, where <span class="math">g^{*}:=\\tilde{g}\\cdot\\tilde{e}q</span>. 7: Let <span class="math">(\\bm{a}_{1},\\bm{a}_{2})\\in\\mathbb{F}^{\\ell+\\mu}</span> be the sumcheck challenge vector. <span class="math">\\mathcal{P}</span> answers the oracle query <span class="math">\\tilde{g}(\\bm{a}_{1},\\bm{a}_{2})</span>. 8: <span class="math">\\mathcal{V}</span> evaluates <span class="math">\\tilde{e}q(\\bm{a}_{1},\\bm{a}_{2})</span> herself, and checks that</p>

    <p class="text-gray-300"><span class="math">\\tilde{g}(\\bm{a}_{1},\\bm{a}_{2})\\cdot\\tilde{e}q(\\bm{a}_{1},\\bm{a}_{2})</span></p>

    <p class="text-gray-300">is consistent with the last message of the sumcheck. 9:end procedure</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Remark 3.3.</h6>

    <p class="text-gray-300">If the SNARK is using a homomorphic commitment scheme, to answer query <span class="math">\\tilde{g}(\\bm{a}_{1},\\bm{a}_{2})</span> the prover only needs to provide a single PCS opening proof for a <span class="math">\\mu</span>-variate polynomial</p>

    <p class="text-gray-300"><span class="math">g^{\\prime}(\\mathbf{X}):=\\tilde{g}(\\bm{a}_{1},\\mathbf{X})=\\sum_{i\\in[k]}eq(\\langle i\\rangle,\\bm{a}_{1})\\cdot eq(\\mathbf{t},\\langle i\\rangle)\\cdot f_{i}(\\mathbf{X})</span></p>

    <p class="text-gray-300">on point <span class="math">\\bm{a}_{2}</span>. The verifier can evaluate <span class="math">\\{eq(\\langle i\\rangle,\\bm{a}_{1})\\cdot eq(\\mathbf{t},\\langle i\\rangle)\\}_{i\\in[k]}</span> in time <span class="math">O(k)</span>, and homomorphically compute <span class="math">g^{\\prime}</span>’s commitment from the commitments to <span class="math">\\{f_{i}\\}_{i\\in[k]}</span>, and checks the opening proof against <span class="math">g^{\\prime}</span>’s commitment. Finally, the verifier checks that <span class="math">g^{\\prime}(\\bm{a}_{2})</span> matches the claimed evaluation <span class="math">\\tilde{g}(\\bm{a}_{1},\\bm{a}_{2})</span>.</p>

    <h4 id="sec-50" class="text-lg font-semibold mt-6">Analysis.</h4>

    <p class="text-gray-300">The PIOP for <span class="math">\\mathcal{R}_{\\mathrm{BATCH}}</span> is complete and knowledge-sound given the completeness and knowledge-soundness of the sumcheck PIOP.</p>

    <p class="text-gray-300">Next, we analyze the complexity of the protocol: The prover time is <span class="math">O(k\\cdot 2^{\\mu})</span> as it runs a sumcheck PIOP for a polynomial <span class="math">g^{*}:=\\tilde{g}\\cdot\\tilde{e}q</span> of degree 2 and <span class="math">\\mu+\\log k</span> variables, where <span class="math">\\tilde{g}</span> and</p>

    <p class="text-gray-300"><span class="math">\\tilde{e}q</span> can both be constructed in time <span class="math">O(k\\cdot 2^{\\mu})</span>. Note that this is already optimal as the prover anyway needs to take <span class="math">O(k\\cdot 2^{\\mu})</span> time to evaluate <span class="math">\\{f_{i}(\\mathbf{z}_{i})\\}_{i\\in[k]}</span> before batching. The verifier takes time <span class="math">O(\\mu+\\log k)</span> in the sumcheck; the sum <span class="math">s</span> can be computed in time <span class="math">O(k)</span>; the evaluation <span class="math">\\tilde{e}q(\\bm{a}_{1},\\bm{a}_{2})=\\sum_{i\\in[k]}eq(\\bm{a}_{1},\\langle i\\rangle)\\cdot\\tilde{e}q(\\langle i\\rangle,\\bm{a}_{2})</span> can be derived from <span class="math">\\bm{a}_{1}</span> and the <span class="math">k</span> evaluations <span class="math">\\{\\tilde{e}q(\\langle i\\rangle,\\bm{a}_{2})=eq(\\bm{a}_{2},\\mathbf{z}_{i})\\}_{i\\in[k]}</span> where each evaluation <span class="math">eq(\\bm{a}_{2},\\mathbf{z}_{i})</span> takes time <span class="math">O(\\mu)</span>. In summary, the verifier time is <span class="math">O(k\\mu)</span>.</p>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">3.8.1 A more efficient batching scheme in a special setting</h4>

    <p class="text-gray-300">Sometimes one only needs to open a <em>single</em> multilinear polynomial at multiple points, where each point is <em>in the boolean hypercube</em>. In this setting, we provide a more efficient algorithm with complexity <span class="math">O(2^{\\mu})</span> which is <span class="math">k</span> times faster than Algorithm 4. We also note that the technique can be used to construct an efficient Commit-and-Prove SNARK scheme from multilinear commitments.</p>

    <p class="text-gray-300">Recall the sumcheck equation (11) in the general batch opening scheme, when there is only one polynomial <span class="math">f</span> and assume for simplicity that <span class="math">y_{i}=0\\forall i\\in[k]</span>, we can rewrite it as</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in[k]}eq(\\mathbf{t},\\langle i\\rangle)\\cdot\\left(\\sum_{\\bm{b}\\in B_{\\mu}}f(\\bm{b})\\cdot eq(\\bm{b},\\mathbf{z}_{i})\\right)=\\sum_{\\bm{b}\\in B_{\\mu}}f(\\bm{b})\\left(\\sum_{i\\in[k]}eq(\\mathbf{t},\\langle i\\rangle)\\cdot eq(\\bm{b},\\mathbf{z}_{i})\\right)\\,.</span></p>

    <p class="text-gray-300">Denote by <span class="math">d_{i}=eq(\\mathbf{t},\\langle i\\rangle)</span>. The above is essentially a sumcheck for polynomial <span class="math">f\\cdot\\tilde{eq^{*}}</span> on set <span class="math">B_{\\mu}</span>, where</p>

    <p class="text-gray-300"><span class="math">\\tilde{eq^{*}}(\\mathbf{X}):=\\sum_{i\\in[k]}d_{i}\\cdot eq(\\mathbf{X},\\mathbf{z}_{i})\\,.</span></p>

    <p class="text-gray-300">Thus we can reduce the batching argument to a PCS opening on polynomial <span class="math">f</span>.</p>

    <p class="text-gray-300">In the sumcheck protocol, in each round <span class="math">\\mu-i+1\\in[\\mu]</span>, the prover needs to evaluate a degree-2 polynomial <span class="math">r_{i}(X)</span> on point <span class="math">x_{i}\\in\\{0,1,2\\}</span>, where</p>

    <p class="text-gray-300"><span class="math">r_{i}(X):=\\sum_{\\bm{b}\\in B_{i-1}}f(\\bm{b},X,\\bm{\\alpha})\\cdot\\tilde{eq^{*}}(\\bm{b},X,\\bm{\\alpha})</span> (12)</p>

    <p class="text-gray-300">and <span class="math">\\bm{\\alpha}=(\\alpha_{i+1},\\ldots,\\alpha_{\\mu})</span> are the round challenges. Note that the evaluation <span class="math">f(\\bm{b},x_{i},\\bm{\\alpha})</span> is easy to obtain by maintaining a table <span class="math">f(B_{i-1},\\{0,1,2\\},\\bm{\\alpha})</span> as in Algorithm 1. Next we argue that the evaluation <span class="math">r_{i}(x_{i})</span> can be computed in time <span class="math">O(k)</span> given the evaluations <span class="math">f(B_{i-1},\\{0,1,2\\},\\bm{\\alpha})</span>. Since there are <span class="math">\\mu</span> rounds and the complexity for maintaining the table is <span class="math">O(2^{\\mu})</span>, the total complexity is <span class="math">O(2^{\\mu}+k\\mu)</span>.</p>

    <p class="text-gray-300">We observe that in equation (12), since <span class="math">\\{\\mathbf{z}_{i}\\}_{i\\in[k]}</span> are in the boolean hypercube, and</p>

    <p class="text-gray-300"><span class="math">\\tilde{eq^{*}}(\\bm{b},X,\\bm{\\alpha})</span> <span class="math">=\\sum_{j\\in[k]}d_{i}\\cdot eq((\\bm{b},X,\\bm{\\alpha}),\\mathbf{z}_{j})</span> <span class="math">=\\sum_{j\\in[k]}d_{j}\\cdot eq(\\bm{b},\\mathbf{z}_{j}[1..i-1])\\cdot eq(X,\\mathbf{z}_{j}[i])\\cdot eq(\\bm{\\alpha},\\mathbf{z}_{j}[i+1..])\\,,</span></p>

    <p class="text-gray-300">by definition of <span class="math">eq</span>, there are at most <span class="math">k</span> choices of <span class="math">\\bm{b}</span> where <span class="math">\\tilde{eq^{*}}(\\bm{b},X,\\bm{\\alpha})</span> is non-zero. In particular, the <span class="math">\\ell</span>-th (<span class="math">1\\leq\\ell\\leq k</span>) such vector is <span class="math">\\mathbf{c}_{\\ell}:=\\mathbf{z}_{\\ell}[1..i-1]</span> such that</p>

    <p class="text-gray-300"><span class="math">\\tilde{eq^{*}}(\\mathbf{c}_{\\ell},X,\\bm{\\alpha})=\\sum_{j\\in[k]}d_{j}\\cdot eq(\\mathbf{z}_{\\ell}[1..i-1],\\mathbf{z}_{j}[1..i-1])\\cdot eq(X,\\mathbf{z}_{j}[i])\\cdot eq(\\bm{\\alpha},\\mathbf{z}_{j}[i+1..])\\,.</span></p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">we note that for each <span class="math">j \\in [k]</span>, the value <span class="math">eq(\\alpha, \\mathbf{z}_j[i + 1..])</span> can be maintained dynamically; the value <span class="math">eq(X, \\mathbf{z}_j[i])</span> can be computed in time <span class="math">O(1)</span>. Moreover, <span class="math">eq(\\mathbf{z}_{\\ell}[1..i - 1], \\mathbf{z}_j[1..i - 1])</span> equals 1 if <span class="math">\\mathbf{z}_{\\ell}[1..i - 1] = \\mathbf{z}_j[1..i - 1]</span> and equals 0 otherwise. In summary, all non-zero values <span class="math">\\{\\widehat{eq}^<em>(\\mathbf{c}_{\\ell}, X, \\alpha)\\}_{\\ell \\in [k]}</span> can be computed in a batch in time <span class="math">O(k)</span>. Therefore for each <span class="math">x_i \\in \\{0, 1, 2\\}</span>, one can evaluate <span class="math">r_i(x_i)</span> from evaluations <span class="math">\\{f(\\mathbf{c}_{\\ell}, x_i, \\alpha)\\}_{\\ell \\in [k]}</span> in time <span class="math">O(k)</span>, by evaluating <span class="math">\\{\\widehat{eq}^</em>(\\mathbf{c}_{\\ell}, x_i, \\alpha)\\}_{\\ell \\in [k]}</span> first and computing the inner product between <span class="math">(\\widehat{eq}^*(\\mathbf{c}_{\\ell}, x_i, \\alpha))_{\\ell \\in [k]}</span> and <span class="math">(f(\\mathbf{c}_{\\ell}, x_i, \\alpha))_{\\ell \\in [k]}</span>.</p>

    <h2 id="sec-52" class="text-2xl font-bold">Applications to Commit-and-Prove SNARKs.</h2>

    <p class="text-gray-300">Our batching scheme is helpful for building Commit-and-Prove SNARKs (CP-SNARKs) from multilinear commitments. In the setting of CP-SNARKs, given two commitments <span class="math">C_f, C_g</span> that commit to vectors <span class="math">\\mathbf{f} \\in \\mathbb{F}^n</span>, <span class="math">\\mathbf{g} \\in \\mathbb{F}^m</span> (<span class="math">m \\leq n</span>), and given two sets <span class="math">I_f \\subseteq [n]</span>, <span class="math">I_g \\subseteq [m]</span>, one needs to prove that the values of <span class="math">\\mathbf{f}(I_f)</span> is consistent with <span class="math">\\mathbf{g}(I_g)</span>. This problem can be solved using a variant of our special batching scheme with complexity <span class="math">O(n)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For simplicity suppose that <span class="math">n = m</span>, and we assume w.l.o.g that <span class="math">n = 2^\\mu</span>. The idea is to view <span class="math">\\mathbf{f}, \\mathbf{g}</span> as the evaluations of polynomials <span class="math">f, g \\in \\mathcal{F}_\\mu^{(\\leq 1)}</span> on the boolean hypercube <span class="math">B_\\mu</span>. Then the commitments <span class="math">C_f, C_g</span> can be instantiated with multilinear commitments to polynomials <span class="math">f, g</span> respectively. The relation that <span class="math">\\mathbf{f}(I_f) = \\mathbf{g}(I_g)</span> is a slightly more general version of the batching relation: let $k =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, it is equivalent to prove that </span>f(\\mathbf{z}_i) = g(\\mathbf{u}_i)<span class="math"> for all </span>i \\in [k]<span class="math">, where </span>\\mathbf{z}_i, \\mathbf{u}_i \\in B_\\mu<span class="math"> map to the </span>i<span class="math">-th index of set </span>I_f, I_g$ respectively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Similar to equation (11), we can define a sumcheck relation</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_{i \\in [k]} eq(\\mathbf{t}, \\langle i \\rangle) \\cdot \\left[ \\left(\\sum_{\\mathbf{b} \\in B_\\mu} f(\\mathbf{b}) \\cdot eq(\\mathbf{b}, \\mathbf{z}_i)\\right) - \\left(\\sum_{\\mathbf{b} \\in B_\\mu} g(\\mathbf{b}) \\cdot eq(\\mathbf{b}, \\mathbf{u}_i)\\right) \\right] \\\\ = \\sum_{\\mathbf{b} \\in B_\\mu} f(\\mathbf{b}) \\left(\\sum_{i \\in [k]} eq(\\mathbf{t}, \\langle i \\rangle) \\cdot eq(\\mathbf{b}, \\mathbf{z}_i)\\right) - \\sum_{\\mathbf{b} \\in B_\\mu} g(\\mathbf{b}) \\left(\\sum_{i \\in [k]} eq(\\mathbf{t}, \\langle i \\rangle) \\cdot eq(\\mathbf{b}, \\mathbf{u}_i)\\right) = 0, \\end{array}</span></div>

    <p class="text-gray-300">which is essentially a sumcheck for the degree-2 polynomial <span class="math">h \\coloneqq f \\cdot e\\tilde{q}_f - g \\cdot e\\tilde{q}_g</span> on set <span class="math">B_\\mu</span>, where</p>

    <div class="my-4 text-center"><span class="math-block">e\\tilde{q}_f(\\mathbf{X}) := \\sum_{i \\in [k]} eq(\\mathbf{t}, \\langle i \\rangle) \\cdot eq(\\mathbf{X}, \\mathbf{z}_i), \\qquad e\\tilde{q}_g(\\mathbf{X}) := \\sum_{i \\in [k]} eq(\\mathbf{t}, \\langle i \\rangle) \\cdot eq(\\mathbf{X}, \\mathbf{u}_i).</span></div>

    <p class="text-gray-300">We can use the same sumcheck algorithm underlying the special batching scheme. The complexity is <span class="math">O(2^\\mu)</span>. The CP-SNARK proving is then reduced to two PCS openings, one for commitment <span class="math">C_f</span> and one for <span class="math">C_g</span>.</p>

    <h2 id="sec-53" class="text-2xl font-bold">4 HyperPlonk: Plonk on the boolean hypercube</h2>

    <p class="text-gray-300">Equipped with the building blocks in Section 3, we now describe the Polynomial IOP for HyperPlonk. In Section 4.1, we introduce <span class="math">\\mathcal{R}_{\\mathrm{PLONK}}</span> — an indexed relation on the boolean hypercube that generalizes the vanilla Plonk constraint system [46]. We present a Polynomial IOP protocol for <span class="math">\\mathcal{R}_{\\mathrm{PLONK}}</span> and analyze its security and efficiency in Section 4.2.</p>

    <p class="text-gray-300">8the same technique applies for $n\\neq m</p>

    <p class="text-gray-300">34</p>

    <h2 id="sec-54" class="text-2xl font-bold">4.1 Constraint systems</h2>

    <p class="text-gray-300"><strong>Notation.</strong> For any <span class="math">m \\in \\mathbb{Z}</span> and <span class="math">i \\in [0,2^m)</span>, we use <span class="math">\\langle i \\rangle_m = \\mathbf{v} \\in B_m</span> to denote the <span class="math">m</span>-bit binary representation of <span class="math">i</span>, that is, <span class="math">i = \\sum_{j=1}^{m} \\mathbf{v}_j \\cdot 2^{j-1}</span>.</p>

    <p class="text-gray-300"><strong>Definition 4.1 (HyperPlonk indexed relation).</strong> Fix public parameters <span class="math">\\mathsf{gp} := (\\mathbb{F}, \\ell, n, \\ell_w, \\ell_q, f)</span> where <span class="math">\\mathbb{F}</span> is the field, <span class="math">\\ell = 2^\\nu</span> is the public input length, <span class="math">n = 2^\\mu</span> is the number of constraints, <span class="math">\\ell_w = 2^{\\nu_w}, \\ell_q = 2^{\\nu_q}</span> are the number of witnesses and selectors per constraint<span class="math">^9</span>, and <span class="math">f: \\mathbb{F}^{\\ell_q + \\ell_w} \\to \\mathbb{F}</span> is an algebraic map with degree <span class="math">d</span>. The indexed relation <span class="math">\\mathcal{R}_{\\text{PLONK}}</span> is the set of all tuples</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbf{i}; \\mathbf{x}; \\mathbf{w}) = ((q, \\sigma); (p, [[w]]); w),</span></div>

    <p class="text-gray-300">where <span class="math">\\sigma : B_{\\mu + \\nu_w} \\to B_{\\mu + \\nu_w}</span> is a permutation, <span class="math">q \\in \\mathcal{F}_{\\mu + \\nu_q}^{(\\leq 1)}</span>, <span class="math">p \\in \\mathcal{F}_{\\mu + \\nu}^{(\\leq 1)}</span>, <span class="math">w \\in \\mathcal{F}_{\\mu + \\nu_w}^{(\\leq 1)}</span>, such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the wiring identity is satisfied, that is, <span class="math">(\\sigma; ([[w]], [[w]]); w) \\in \\mathcal{R}_{\\text{PERM}}</span> (Definition 3.5);</li>

      <li>the gate identity is satisfied, that, is, <span class="math">\\left(([\\tilde{f}]]\\tilde{f}\\right) \\in \\mathcal{R}_{\\text{ZERO}}</span> (Definition 3.2), where the virtual polynomial <span class="math">\\tilde{f} \\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span> is defined as</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\tilde{f}(\\mathbf{X}) := f\\left(q\\left(\\langle 0 \\rangle_{\\nu_q}, \\mathbf{X}\\right), \\dots, q\\left(\\langle \\ell_q - 1 \\rangle_{\\nu_q}, \\mathbf{X}\\right), w\\left(\\langle 0 \\rangle_{\\nu_w}, \\mathbf{X}\\right), \\dots, w\\left(\\langle \\ell_w - 1 \\rangle_{\\nu_w}, \\mathbf{X}\\right)\\right); \\tag{13}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the public input is consistent with the witness, that is, the public input polynomial <span class="math">p \\in \\mathcal{F}_{\\nu}^{(\\leq 1)}</span> is identical to <span class="math">w(0^{\\mu + \\nu_w - \\nu}, \\mathbf{X}) \\in \\mathcal{F}_{\\nu}^{(\\leq 1)}</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{\\text{PLONK}}</span> is general enough to capture many computational models. In the introduction, we reviewed how <span class="math">\\mathcal{R}_{\\text{PLONK}}</span> captures simple arithmetic circuits. <span class="math">\\mathcal{R}_{\\text{PLONK}}</span> can be used to capture higher degree circuits with higher arity and more complex gates, including state machine computations.</p>

    <p class="text-gray-300"><strong>State machines.</strong> <span class="math">\\mathcal{R}_{\\text{PLONK}}</span> can model state machine computations, as shown by Gabizon and Williamson [45]. A state machine execution with <span class="math">n - 1</span> steps starts with an initial state <span class="math">\\mathsf{state}_0 \\in \\mathbb{F}^k</span> where <span class="math">k</span> is the width of the state vector. In each step <span class="math">i \\in [0, n - 1)</span>, given input the previous state <span class="math">\\mathsf{state}_i</span> and an online input <span class="math">\\mathsf{inp}_i \\in \\mathbb{F}</span>, the state machine executes a transition function <span class="math">f</span> and outputs <span class="math">\\mathsf{state}_{i + 1} \\in \\mathbb{F}^w</span>. Let <span class="math">\\mathcal{T} := (\\mathsf{state}_0, \\ldots, \\mathsf{state}_{n - 1})</span> be the execution trace and define <span class="math">\\mathsf{inp}_{n - 1} := \\bot</span>, we say that <span class="math">\\mathcal{T}</span> is valid for input <span class="math">(\\mathsf{inp}_0, \\ldots, \\mathsf{inp}_{n - 1})</span> if and only if (i) <span class="math">\\mathsf{state}_{n - 1}[0] = 0^k</span>, and (ii) <span class="math">\\mathsf{state}_{i + 1} = f(\\mathsf{state}_i, \\mathsf{inp}_i)</span> for all <span class="math">i \\in [0, n - 1)</span>.</p>

    <p class="text-gray-300">We build a HyperPlonk indexed relation that captures the state machine computation. W.l.o.g. we assume that <span class="math">n = 2^\\mu</span> for some <span class="math">\\mu \\in \\mathbb{N}</span>. Let <span class="math">\\nu_w</span> be the minimal integer such that <span class="math">2^{\\nu_w} &amp;gt; 2k</span>. We also assume that there is a low-depth algebraic predicate <span class="math">f_<em></span> that captures the transition function <span class="math">f</span>, that is, <span class="math">f_</em>(\\mathsf{state}&#x27;, \\mathsf{state}, \\mathsf{inp}) = 0</span> if and only if <span class="math">\\mathsf{state}&#x27; = f(\\mathsf{state}, \\mathsf{inp})</span>. For each <span class="math">i \\in [0, n)</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the online input at the <span class="math">i</span>-th step is <span class="math">\\mathsf{inp}_i := w(\\langle 0 \\rangle_{\\nu_w}, \\langle i \\rangle_\\mu)</span>;</li>

      <li>the input state of step <span class="math">i</span> is <span class="math">\\mathsf{state}_{\\mathrm{in},i} := \\left[w\\left(\\langle 1 \\rangle_{\\nu_w}, \\langle i \\rangle_\\mu\\right), \\ldots, w\\left(\\langle k \\rangle_{\\nu_w}, \\langle i \\rangle_\\mu\\right)\\right]</span>;</li>

      <li>the output state of step <span class="math">i</span> is <span class="math">\\mathsf{state}_{\\mathrm{out},i} := \\left[w\\left(\\langle k + 1 \\rangle_{\\nu_w}, \\langle i \\rangle_\\mu\\right), \\ldots, w\\left(\\langle 2k \\rangle_{\\nu_w}, \\langle i \\rangle_\\mu\\right)\\right]</span>;</li>

      <li>the selector for step <span class="math">i</span> is <span class="math">\\mathbf{q}_i := q(\\langle i \\rangle_\\mu)</span>;</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the transition and output correctness are jointly captured by a high-degree algebraic map <span class="math">f&#x27;</span>,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">f&#x27;(\\mathsf{inp}_i, \\mathsf{state}_{\\mathrm{in},i}, \\mathsf{state}_{\\mathrm{out},i}; \\mathbf{q}_i) := (1 - \\mathbf{q}_i) \\cdot f_*(\\mathsf{state}_{\\mathrm{out},i}, \\mathsf{state}_{\\mathrm{in},i}, \\mathsf{inp}_i) + \\mathbf{q}_i \\cdot \\mathsf{state}_{\\mathrm{in},i}[0].</span></div>

    <p class="text-gray-300">For all <span class="math">i \\in [0, n-1)</span>, we set <span class="math">\\mathbf{q}_i = 0</span> so that <span class="math">\\mathsf{state}_{i+1} = f_i(\\mathsf{state}_i, \\mathsf{inp}_i)</span> if and only if</p>

    <div class="my-4 text-center"><span class="math-block">f&#x27;(\\mathsf{inp}_i, \\mathsf{state}_{\\mathrm{in},i}, \\mathsf{state}_{\\mathrm{out},i}; \\mathbf{q}_i) = f_*(\\mathsf{state}_{\\mathrm{out},i}, \\mathsf{state}_{\\mathrm{in},i}, \\mathsf{inp}_i) = 0;</span></div>

    <p class="text-gray-300">we set <span class="math">\\mathbf{q}_{n-1} = 1</span> so that <span class="math">\\mathsf{state}_{\\mathrm{in},n-1}[0] = 0</span> if and only if</p>

    <div class="my-4 text-center"><span class="math-block">f&#x27;(\\mathsf{inp}_{n-1}, \\mathsf{state}_{\\mathrm{in},n-1}, \\mathsf{state}_{\\mathrm{out},n-1}; \\mathbf{q}_{n-1}) = \\mathsf{state}_{\\mathrm{in},n-1}[0] = 0.</span></div>

    <p class="text-gray-300">Note that we also need to enforce equality between the <span class="math">i</span>-th input state and the <span class="math">(i-1)</span>-th output state for all <span class="math">i \\in [n-1]</span>. We achieve it by fixing a permutation <span class="math">\\sigma</span> and constraining that the witness assignment is invariant after applying the permutation.</p>

    <p class="text-gray-300"><strong>Remark 4.1.</strong> We can halve the size of the witness and remove the permutation check by using the polynomial shifting technique in Section 3.7. Specifically, we can remove output state columns <span class="math">\\mathsf{state}_{out,i}</span> and replace it with <span class="math">\\mathsf{state}_{in,i+1}</span> for every <span class="math">i \\in [0,n)</span>.</p>

    <h2 id="sec-55" class="text-2xl font-bold">4.2 The PolyIOP protocol</h2>

    <p class="text-gray-300">In this Section, we present a multivariate PIOP for <span class="math">\\mathcal{R}_{\\mathrm{PLONK}}</span> that removes expensive FFTs.</p>

    <p class="text-gray-300"><strong>Construction.</strong> Intuitively, the PIOP for <span class="math">\\mathcal{R}_{\\mathrm{PLONK}}</span> builds on a zero-check PIOP (Section 3.2) for custom algebraic gates and a permutation-check PIOP (Section 3.5) for copy constraints; consistency between the public input and the online witness is achieved via a random evaluation check between the public input polynomial and the witness polynomial.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{gp} \\coloneqq (\\mathbb{F}, \\ell, n, \\ell_w, \\ell_q, f)</span> be the public parameters and let <span class="math">d \\coloneqq \\deg(f)</span>. For a tuple <span class="math">(\\mathbf{i}; \\mathbf{x}; \\mathbf{w}) = ((q, \\sigma); (p, [[w]]); w)</span>, we describe the protocol in Figure 2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Theorem 4.1.</strong> Let <span class="math">\\mathsf{gp} \\coloneqq (\\mathbb{F}, \\ell, n, \\ell_w, \\ell_q, f)</span> be the public parameters where <span class="math">\\ell_w, \\ell_q = O(1)</span> are some constants. Let <span class="math">d \\coloneqq \\deg(f)</span>. The construction in Figure 2 is a multivariate PolyIOP for relation <span class="math">\\mathcal{R}_{\\text{PLONK}}</span> (Definition 4.1) with soundness error $\\mathcal{O}\\left(\\frac{2^n + d\\mu}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)$ and the following complexity:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the prover time is <span class="math">\\mathsf{tp}_{\\text{plonk}}^{\\mathsf{gp}} = \\mathcal{O}\\left(nd\\log^2 d\\right)</span>;</li>

      <li>the verifier time is <span class="math">\\mathsf{tv}_{\\text{plonk}}^{\\mathsf{gp}} = \\mathcal{O}(\\mu + \\ell)</span>;</li>

      <li>the query complexity is <span class="math">\\mathsf{q}_{\\text{plonk}}^{\\mathsf{gp}} = 2\\mu + 4 + \\log \\ell_w</span>, that is, <span class="math">2\\mu + \\log \\ell_w</span> univariate oracle queries, 3 multilinear oracle queries, and 1 query to the virtual polynomial <span class="math">\\tilde{f}</span>;</li>

      <li>the round complexity and the number of proof oracles is <span class="math">\\mathsf{rc}_{\\text{plonk}}^{\\mathsf{gp}} = 2\\mu + 1 + \\nu_w</span>;</li>

      <li>the number of field elements sent by the prover is <span class="math">\\mathsf{nf}_{\\text{plonk}}^{\\mathsf{gp}} = 2\\mu</span>;</li>

      <li>the size of the proof oracles is <span class="math">\\mathsf{pl}_{\\text{plonk}}^{\\mathsf{gp}} = \\mathcal{O}(n)</span>; the size of the witness is <span class="math">n\\ell_w</span>.</li>

    </ul>

    <p class="text-gray-300">35</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: PIOP for  <span class="math">\\mathcal{R}_{\\mathrm{PLONK}}</span></p>

    <p class="text-gray-300">Remark 4.2. Two separate sumcheck PIOPs are underlying the HyperPlonk PIOP. We can batch the two sumchecks into one by random linear combination. The optimized protocol has round complexity  <span class="math">\\mu + 1 + \\log \\ell_w</span> , and the number of field elements sent by the prover is  <span class="math">\\mu</span> . The query complexity  <span class="math">\\mu + 3 + \\log \\ell_w</span> , that is,  <span class="math">\\mu + \\log \\ell_w</span>  univariate queries, 2 multilinear queries, and 1 queries to the virtual polynomial  <span class="math">\\tilde{f}</span> .</p>

    <p class="text-gray-300">Remark 4.3. The prover's memory consumption is linear to the number of constraints. For space-bounded provers, we can split the proving work to multiple parallel parties or apply the techniques from [24] to obtain a space-efficient prover with quasilinear proving time. We leave concrete specifications of space-efficient HyperPlonk provers as future work.</p>

    <p class="text-gray-300">Lemma 4.2. The PIOP in Figure 2 is perfectly complete.</p>

    <p class="text-gray-300">Proof. For any  <span class="math">\\left((q,\\sigma);(p,[[w]]);w\\right)\\in \\mathcal{R}_{\\mathrm{PLONK}}</span> , by Definition 4.1, it holds that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\left([[\\tilde{f}]]\\tilde{f}\\right) \\in \\mathcal{R}_{\\mathrm{ZERO}}</span> , thus  <span class="math">\\mathcal{V}</span>  passes the check in Step 2 as the ZeroCheck PIOP is complete;</li>

      <li><span class="math">\\left(\\sigma; \\left([[w]], [[w]]\\right); w\\right) \\in \\mathcal{R}_{\\mathrm{PERM}}</span> , thus  <span class="math">\\mathcal{V}</span>  passes the check in Step 3 as the permutation PIOP is complete;</li>

      <li>the public input polynomial  <span class="math">p \\in \\mathcal{F}_{\\nu}^{(\\leq 1)}</span>  is identical to  <span class="math">w(0^{\\mu + \\nu_w - \\nu}, \\mathbf{X}) \\in \\mathcal{F}_{\\nu}^{(\\leq 1)}</span> , thus their evaluations are always the same, and  <span class="math">\\mathcal{V}</span>  passes the check in Step 4.</li>

    </ul>

    <p class="text-gray-300">In summary, the lemma holds as desired.</p>

    <p class="text-gray-300">Lemma 4.3. Let  <span class="math">\\mathbf{gp} \\coloneqq \\left(\\mathbb{F}, \\ell = 2^{\\nu}, n = 2^{\\mu}, \\ell_{w} = 2^{\\nu_{w}}, \\ell_{q}, f\\right)</span>  be the public parameters and let  <span class="math">d \\coloneqq \\deg(f)</span> . The PIOP in Figure 2 has soundness error</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\delta_ {p l o n k} ^ {\\mathbf {g p}} := \\max  \\left\\{\\delta_ {z e r o} ^ {d, \\mu}, \\delta_ {p e r m} ^ {1, \\mu + \\nu_ {w}}, \\frac {\\nu}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. For any <span class="math">\\big{(}(q,\\sigma);(p,[[w]])\\big{)}\\notin\\mathcal{L}(\\mathcal{R}_{\\mathrm{PLONK}})</span>, that is, <span class="math">\\big{(}(q,\\sigma);(p,[[w]]);w\\big{)}\\notin\\mathcal{R}_{\\mathrm{PLONK}}</span>, at least one of the following conditions holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\big{(}[[\\tilde{f}]];\\tilde{f}\\big{)}\\notin\\mathcal{R}_{\\mathrm{ZERO}}</span>;</li>

      <li><span class="math">\\big{(}\\sigma;([[w]],[[w]]);w\\big{)}\\notin\\mathcal{R}_{\\mathrm{PERM}}</span>;</li>

      <li><span class="math">p(\\mathbf{X})\\neq w(0^{\\mu+\\nu_{w}-\\nu},\\mathbf{X})</span>;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the first condition, the probability that <span class="math">\\mathcal{V}</span> passes the ZeroCheck in Step 2 is at most <span class="math">\\delta_{\\mathrm{zero}}^{d,\\mu}</span>; in the second condition, the probability that <span class="math">\\mathcal{V}</span> passes the permutation check in Step 3 is at most <span class="math">\\delta_{\\mathrm{perm}}^{1,\\mu+\\nu_{w}}</span>; in the last condition, by Lemma 2.2, <span class="math">\\mathcal{V}</span> passes the evaluation check in Step 4 with probability at most $\\nu/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. In summary, for any </span>\\big{(}(q,\\sigma);(p,[[w]]);w\\big{)}\\notin\\mathcal{R}_{\\mathrm{PLONK}}<span class="math">, the probability that </span>\\mathcal{V}<span class="math"> accepts is at most </span>\\max\\{\\delta_{\\mathrm{zero}}^{d,\\mu},\\delta_{\\mathrm{perm}}^{1,\\mu+\\nu_{w}},\\nu/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}$ as claimed. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Zero knowledge. We refer to Appendix A for the zero-knowledge version of the HyperPlonk PIOP.</p>

    <h2 id="sec-56" class="text-2xl font-bold">5 HyperPlonk+: HyperPlonk with Lookup Gates</h2>

    <p class="text-gray-300">This section illustrates how to integrate lookup gates into the HyperPlonk constraint system. Then we present and analyze a Polynomial IOP protocol for the extended relation.</p>

    <h3 id="sec-57" class="text-xl font-semibold mt-8">5.1 Constraint systems</h3>

    <p class="text-gray-300">The HyperPlonk+ indexed relation <span class="math">\\mathcal{R}_{\\mathrm{PLONK+}}</span> is built on <span class="math">\\mathcal{R}_{\\mathrm{PLONK}}</span> (Definition 4.1). The difference is that <span class="math">\\mathcal{R}_{\\mathrm{PLONK+}}</span> further enables a set of <em>non-algebraic</em> constraints enforcing that some function over the witness values belongs to a preprocessed table. We illustrate via a simple example. Suppose we capture a fan-in-2 circuit with <span class="math">n</span> addition/multiplication gates using relation <span class="math">\\mathcal{R}_{\\mathrm{PLONK}}</span>. We need to further constrain that for a subset of gates, the sum of two input wires should be in the range <span class="math">[0,\\ldots,B)</span>. What we can do is to set up a preprocessed table <span class="math">\\mathsf{table}=\\{0,1,\\ldots,B\\}</span> and a selector <span class="math">q_{\\mathrm{lk}}\\in\\mathbb{F}^{n}</span> so that for every <span class="math">i\\in[n]</span>, <span class="math">q_{\\mathrm{lk}}(i)=1</span> if the <span class="math">i</span>-th gate has a range-check, and <span class="math">q_{\\mathrm{lk}}(i)=0</span> otherwise. Then we prove a lookup relation that for all <span class="math">i\\in[n]</span>, the value <span class="math">q_{\\mathrm{lk}}(i)\\cdot\\big{(}w_{1}(i)+w_{2}(i)\\big{)}</span> is in <span class="math">\\mathsf{table}</span>, where <span class="math">w_{1}(i),w_{2}(i)</span> are the first and the second input wire of gate <span class="math">i</span>.</p>

    <p class="text-gray-300">We generalize the idea above and enable enforcing <em>arbitrary algebraic functions</em> (over the selectors and witnesses) to be in the table. Namely, the index further setups an algebraic functions <span class="math">f_{\\mathrm{lk}}</span>. Each constraint is of the form</p>

    <p class="text-gray-300"><span class="math">f_{\\mathrm{lk}}\\left(q_{\\mathrm{lk}}(\\langle 0\\rangle,\\langle i\\rangle),\\ \\ldots,\\ q_{\\mathrm{lk}}(\\langle\\ell_{\\mathrm{lk}}-1\\rangle,\\langle i\\rangle),\\ w(\\langle 0\\rangle,\\langle i\\rangle),\\ \\ldots,\\ w(\\langle\\ell_{w}-1\\rangle,\\langle i\\rangle)\\right)\\in\\mathsf{table}</span></p>

    <p class="text-gray-300">where <span class="math">\\ell_{\\mathrm{lk}}</span> is the number of selectors, <span class="math">\\ell_{w}</span> is the number of witness wires and <span class="math">\\langle i\\rangle</span> is the binary representation of <span class="math">i</span>. Note that the constraint in the previous paragraph is a special case where <span class="math">f_{\\mathrm{lk}}=q_{\\mathrm{lk}}(i)\\cdot\\big{(}w_{1}(i)+w_{2}(i)\\big{)}</span>. We formally define the relation below.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Definition 5.1 (HyperPlonk+ indexed relation).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{gp}_{1}:=\\big{(}\\mathbb{F},\\ell,n,\\ell_{w},\\ell_{q},f\\big{)}</span> be the public parameters for relation <span class="math">\\mathcal{R}_{\\mathrm{PLONK}}</span> (Definition 4.1). Let <span class="math">\\mathsf{gp}_{2}:=(\\ell_{lk},f_{lk})</span> be the additional public parameters</p>

    <p class="text-gray-300">where <span class="math">\\ell_{lk} = 2^{\\nu_{lk}}</span> is the number of lookup selectors and <span class="math">f_{lk}:\\mathbb{F}^{\\ell_{lk} + \\ell_w}\\to \\mathbb{F}</span> is an algebraic map. The indexed relation <span class="math">\\mathcal{R}_{PLONK+}</span> is the set of all triples</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathrm {i}; \\mathrm {x}; \\mathrm {w}) = ((\\mathrm {i} _ {1}, \\mathrm {i} _ {2}); (p, [ [ w ] ]); w)</span></div>

    <p class="text-gray-300">where <span class="math">\\mathrm{i}_2\\coloneqq \\left(\\mathsf{table}\\in \\mathbb{F}^{n - 1},q_{lk}\\in \\mathcal{F}_{\\mu +\\nu_{lk}}^{(\\leq 1)}\\right)</span> such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{i}_1; \\mathbf{x}; \\mathbf{w}) \\in \\mathcal{R}_{PLONK}</span>;</li>

      <li>there exists <span class="math">\\mathsf{addr}: B_{\\mu} \\to [1, 2^{\\mu})</span> such that <span class="math">(\\mathsf{table}; [[g]]; (g, \\mathsf{addr})) \\in \\mathcal{R}_{LOOKUP}</span> (Definition 3.6), where <span class="math">g \\in \\mathcal{F}_{\\mu}^{(\\leq \\deg(f_{lk}))}</span> is defined as</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">g (\\mathbf {X}) := f _ {l k} \\left(q _ {l k} \\left(\\langle 0 \\rangle_ {\\nu_ {l k}}, \\mathbf {X}\\right), \\dots , q _ {l k} \\left(\\left\\langle \\ell_ {l k} - 1 \\right\\rangle_ {\\nu_ {l k}}, \\mathbf {X}\\right), w \\left(\\left\\langle 0 \\right\\rangle_ {\\nu_ {w}}, \\mathbf {X}\\right), \\dots , w \\left(\\left\\langle \\ell_ {w} - 1 \\right\\rangle_ {\\nu_ {w}}, \\mathbf {X}\\right)\\right). \\tag {14}</span></div>

    <p class="text-gray-300"><strong>Remark 5.1 (Supporting vector lookups).</strong> We can generalize <span class="math">\\mathcal{R}_{PLONK+}</span> to support vector lookups where each "element" in the table is a vector rather than a single field element. Let <span class="math">k \\in \\mathbb{N}</span> be the length of the vector. The lookup table is <span class="math">\\text{table} \\in \\mathbb{F}^{k \\times (n-1)}</span>; the lookup function <span class="math">f_{lk}: \\mathbb{F}^{2^{\\nu_{lk}} + 2^{\\nu_w}} \\to \\mathbb{F}^k</span> is an algebraic map that outputs <span class="math">k</span> field elements.</p>

    <p class="text-gray-300"><strong>Remark 5.2 (Supporting multiple tables).</strong> We can generalize <span class="math">\\mathcal{R}_{PLONK+}</span> to support multiple lookup tables. In particular, the index <span class="math">\\mathrm{i}_2</span> can specify <span class="math">k &amp;gt; 1</span> lookup tables <span class="math">\\text{table}_1, \\ldots, \\text{table}_k</span> and <span class="math">k</span> lookup functions <span class="math">f_{lk}^{(1)}, \\ldots, f_{lk}^{(k)}</span>, and we require that all of the <span class="math">k</span> lookup relations hold.</p>

    <h2 id="sec-59" class="text-2xl font-bold">5.2 The PolyIOP protocol</h2>

    <p class="text-gray-300"><strong>Construction.</strong> The PIOP for <span class="math">\\mathcal{R}_{\\mathrm{PLONK + }}</span> is a combination of the PIOP for <span class="math">\\mathcal{R}_{\\mathrm{PLONK}}</span> and the PIOP for a lookup relation (Section 3.7). Let <span class="math">\\mathsf{gp} := (\\mathsf{gp}_1, \\mathsf{gp}_2)</span> be the public parameters where <span class="math">\\mathsf{gp}_1 := (\\mathbb{F}, \\ell, n, \\ell_w, \\ell_q, f)</span> and <span class="math">\\mathsf{gp}_2 := (\\ell_{\\mathrm{lk}}, f_{\\mathrm{lk}})</span>. We denote <span class="math">d_{\\mathrm{lk}} := \\deg(f_{\\mathrm{lk}})</span>. For a tuple <span class="math">(\\mathrm{i}; \\mathrm{x}; \\mathrm{w}) = ((\\mathrm{i}_1, \\mathrm{i}_2); (p, [[w]]); w)</span> where <span class="math">\\mathrm{i}_2 := (\\text{table} \\in \\mathbb{F}^{n-1}, q_{\\mathrm{lk}} \\in \\mathcal{F}_{\\mu + \\nu_{\\mathrm{lk}}}^{(\\leq 1)})</span> we describe the protocol in Figure 3.</p>

    <p class="text-gray-300"><strong>Indexer.</strong> <span class="math">\\mathcal{I}(\\mathrm{i}_1,\\mathrm{i}_2 = (\\mathrm{table},q_{\\mathrm{lk}}))</span> calls the HyperPlonk PIOP indexer <span class="math">\\mathsf{vp}_{\\mathrm{plonk}}\\gets \\mathcal{I}_{\\mathrm{plonk}}(\\mathrm{i}_1)</span>, and calls the Lookup PIOP indexer <span class="math">\\mathsf{vp}_t\\gets \\mathcal{I}_{\\mathrm{lkup}}(\\mathrm{table})</span>. The oracle output is <span class="math">\\mathsf{vp}\\coloneqq ([[q_{\\mathrm{lk}}]],\\mathsf{vp}_t,\\mathsf{vp}_{\\mathrm{plonk}})</span>.</p>

    <p class="text-gray-300"><strong>The protocol.</strong> <span class="math">\\mathcal{P}(\\mathsf{gp},\\mathsf{i},p,w)</span> and <span class="math">\\mathcal{V}(\\mathsf{gp},p,\\mathsf{vp})</span> run the following protocol.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> sends <span class="math">\\mathcal{V}</span> the witness oracle <span class="math">[[w]]</span> where <span class="math">w\\in \\mathcal{F}_{\\mu +\\nu_w}^{(\\leq 1)}</span>.</li>

      <li>Run a HyperPlonk PIOP (Section 4.2) for <span class="math">(\\mathrm{i}_1;\\mathrm{x};\\mathrm{w})\\in \\mathcal{R}_{\\mathrm{PLONK}}</span>.</li>

      <li>Run a lookup PIOP (Section 3.7) for <span class="math">(\\text{table};[[g]])\\in \\mathcal{L}(\\mathcal{R}_{\\mathrm{LOOKUP}})</span> where <span class="math">g\\in \\mathcal{F}_{\\mu}^{(\\leq d_{\\mathrm{lk}})}</span> is as defined in Equation 14.</li>

    </ol>

    <p class="text-gray-300">Figure 3: PIOP for <span class="math">\\mathcal{R}_{\\mathrm{PLONK + }}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Theorem 5.1.</strong> Let <span class="math">\\mathsf{gp} := (\\mathsf{gp}_1, \\mathsf{gp}_2)</span> be the public parameters, where <span class="math">\\mathsf{gp}_1 := (\\mathbb{F}, \\ell, n, \\ell_w, \\ell_q, f)</span> and <span class="math">\\ell_w, \\ell_q = O(1)</span> are some constants; <span class="math">\\mathsf{gp}_2 := (\\ell_{lk}, f_{lk})</span> and <span class="math">\\ell_{lk} = O(1)</span> is some constant. Let <span class="math">d&#x27; := \\max(\\deg(f), \\deg(f_{lk}))</span> and let <span class="math">g</span> be the polynomial defined in Equation 14. The construction in Figure 3 is a multivariate PolyIOP for relation <span class="math">\\mathcal{R}_{PLONK+}</span> with soundness error $\\mathcal{O}\\left(\\frac{2^{\\mu} + d' \\mu}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)$ and the following complexity:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">38</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover time is <span class="math">\\mathsf{tp}_{\\text{plonk}+}^{\\mathsf{gp}} = \\mathsf{tp}_{\\text{plonk}}^{\\mathsf{gp}_1} + \\mathsf{tp}_{\\text{lkup}}^g = \\mathcal{O}\\big(nd&#x27;\\log^2 d&#x27;\\big)</span> <span class="math">\\mathbb{F}</span>-ops.</li>

      <li>The verifier time is <span class="math">\\mathsf{tv}_{\\text{plonk}+}^{\\mathsf{gp}} := \\mathsf{tv}_{\\text{plonk}}^{\\mathsf{gp}_1} + \\mathsf{tv}_{\\text{lkup}}^g = \\mathcal{O}(\\mu + \\ell)</span> <span class="math">\\mathbb{F}</span>-ops.</li>

      <li>The query complexity is <span class="math">\\mathfrak{q}_{\\text{plonk}+}^{\\mathsf{gp}} = \\mathfrak{q}_{\\text{plonk}}^{\\mathsf{gp}_1} + \\mathfrak{q}_{\\text{lkup}}^g = 3\\mu + 7 + \\log \\ell_w</span>, that is, <span class="math">3\\mu + \\log \\ell_w</span> univariate oracle queries, 5 multilinear oracle queries, 1 query to the virtual polynomial <span class="math">\\tilde{f}</span>, and 1 query to the virtual polynomial <span class="math">g</span> defined in Equation 14.</li>

      <li>The round complexity and the number of proof oracles is <span class="math">\\mathsf{rc}_{\\text{plonk}+}^{\\mathsf{gp}} = \\mathsf{rc}_{\\text{plonk}}^{\\mathsf{gp}_1} + \\mathsf{rc}_{\\text{lkup}}^g = 3\\mu + 3 + \\log \\ell_w</span>.</li>

      <li>The number of field elements sent by <span class="math">\\mathcal{P}</span> is <span class="math">3\\mu</span>.</li>

      <li>The size of the proof oracles is <span class="math">\\mathcal{O}(n)</span>; the size of the witness is <span class="math">n\\ell_w</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Remark 5.3.</strong> Similar to Remark 4.2, there are 3 separate sumcheck PIOPs underlying the HyperPlonk+ PIOP. By random linear combination, we can batch the 3 sumchecks into a single one. The optimized protocol has query complexity <span class="math">\\mu + 7 + \\log \\ell_w</span>, round complexity <span class="math">\\mu + 3 + \\log \\ell_w</span>, and the number of field elements sent by the prover is <span class="math">\\mu</span>.</p>

    <p class="text-gray-300"><strong>Remark 5.4.</strong> We emphasize that the PolyIOP for <span class="math">\\mathcal{R}_{\\text{PLONK}+}</span> naturally works for the more general versions of <span class="math">\\mathcal{R}_{\\text{PLONK}+}</span> that involve vector lookups (Remark 5.1) or multiple tables (Remark 5.2). Because we can transform the problem of building PIOPs for the more general relations to the problem of building PIOPs for <span class="math">\\mathcal{R}_{\\text{PLONK}+}</span> by applying the randomization and domain separation techniques in Section 4 of [44].</p>

    <p class="text-gray-300"><strong>Lemma 5.2.</strong> The PIOP in Figure 3 is perfectly complete.</p>

    <p class="text-gray-300"><strong>Proof.</strong> For any <span class="math">\\big((\\mathfrak{i}_1,\\mathsf{table},q_{\\mathrm{lk}});(p,[[w]]);w\\big)\\in \\mathcal{R}_{\\mathrm{PLONK}+}</span>, by Definition 5.1, it holds that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathfrak{i}_1;\\mathbf{x};\\mathbf{w})\\in \\mathcal{R}_{\\mathrm{PLONK}}</span>, thus <span class="math">\\mathcal{V}</span> passes the check in Step 2 as the HyperPlonk PIOP is complete;</li>

      <li><span class="math">\\left(\\text{table};[[g]]\\right) \\in \\mathcal{L}(\\mathcal{R}_{\\text{LOOKUP}})</span>, thus <span class="math">\\mathcal{V}</span> passes the check in Step 3 as the lookup PIOP is complete.</li>

    </ul>

    <p class="text-gray-300">In summary, the lemma holds as desired.</p>

    <p class="text-gray-300"><strong>Lemma 5.3.</strong> Let <span class="math">\\mathsf{gp} := (\\mathsf{gp}_1, \\mathsf{gp}_2)</span> be the public parameters. Let <span class="math">n = 2^\\mu \\in \\mathsf{gp}_1</span> denote the number of constraints. Let <span class="math">f_{lk} \\in \\mathsf{gp}_2</span> be the lookup gate map and set <span class="math">d_{lk} := \\deg(f_{lk})</span>. The PIOP in Figure 3 has soundness error</p>

    <div class="my-4 text-center"><span class="math-block">\\delta_{plonk+}^{\\mathsf{gp}} := \\max \\left\\{\\delta_{plonk}^{\\mathsf{gp}_1}, \\delta_{lkup}^{d_{lk},\\mu} \\right\\}.</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> For any <span class="math">\\big((\\mathfrak{i}_1,\\mathsf{table},q_{\\mathrm{lk}});(p,[[w]]) \\big)\\notin \\mathcal{L}(\\mathcal{R}_{\\mathrm{PLONK}+})</span>, that is, <span class="math">\\big((\\mathfrak{i}_1,\\mathsf{table},q_{\\mathrm{lk}});(p,[[w]]);w\\big)\\notin \\mathcal{R}_{\\mathrm{PLONK}}</span>, at least one of the following conditions holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathfrak{i}_1; \\mathbf{x}; \\mathbf{w}) \\notin \\mathcal{R}_{\\mathrm{PLONK}}</span>;</li>

      <li><span class="math">\\left(\\text{table};[[g]]\\right) \\notin \\mathcal{L}(\\mathcal{R}_{\\text{LOOKUP}})</span>, where <span class="math">g \\in \\mathcal{F}_{\\mu}^{(\\leq d_{\\mathrm{lk}})}</span> is as defined in Equation 14.</li>

    </ul>

    <p class="text-gray-300">For the first case, the probability that <span class="math">\\mathcal{V}</span> accepts in the HyperPlonk PIOP is at most <span class="math">\\delta_{\\mathrm{plonk}}^{\\mathsf{gp}_1}</span>; for the second case, the probability that <span class="math">\\mathcal{V}</span> passes the lookup check is at most <span class="math">\\delta_{\\mathrm{lkup}}^{d_{\\mathrm{lk}},\\mu}</span>. Thus for every instance not in <span class="math">\\mathcal{L}(\\mathcal{R}_{\\mathrm{PLONK}+})</span>, the probability that <span class="math">\\mathcal{V}</span> accepts is at most <span class="math">\\max \\bigl (\\delta_{\\mathrm{plonk}}^{\\mathsf{gp}_1},\\delta_{\\mathrm{lkup}}^{d_{\\mathrm{lk}},\\mu}\\bigr)</span>.</p>

    <p class="text-gray-300">Zero knowledge. We refer to Appendix A for the zero-knowledge version of the HyperPlonk+ PIOP.</p>

    <p class="text-gray-300">We implement HyperPlonk as a library using about 5600 lines of RUST. Figure 4 highlights the building blocks contributing to our HyperPlonk code base. Our backend is built on top of the Arkworks [4]. Specifically, we adopted the finite field, elliptic curve, and polynomial libraries from this project. We then build our PIOP libraries, including our core zero and permutation checks, and use merlin transcript [40] to turn it into a non-interactive protocol. We also implement a multilinear KZG commitment scheme variant that is compatible with our batch-evaluation PIOP.</p>

    <p class="text-gray-300">Our implementation is highly modular: one may switch between different elliptic curves, other multilinear polynomial commitment schemes and various circuit frontends within our framework.</p>

    <p class="text-gray-300">The current version of our code base has a few limitations, which do not affect the benchmarks reported in this section. Firstly, it is built for benchmarking purposes with mock circuits, but we aim to support Halo2 and Jellyfish arithmetization as frontends. Secondly, we are not yet supporting lookup tables and thus HyperPlonk+.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 4: Stack of libraries comprising HyperPlonk. The components in grey we implemented ourselves. The arithmetization frontends have not yet been linked to the implementation.</p>

    <p class="text-gray-300">We benchmark HyperPlonk on an AWS EC2 instance running Ubuntu 20.04. The server has 64 cores (AMD EPYC 7R13 at  <span class="math">2.65\\mathrm{GHz}</span> ) and 128 GB of RAM. The hyperplonk benchmarks were run using a rust implementation available online[11]. We utilize a multi-linear KZG commitment built using curve BLS12-381. If not otherwise indicated, we use the same custom gate as the Jellyfish library. The gate has 5 inputs, 13 selectors, and degree 5.</p>

    <p class="text-gray-300">Proof size and verification time. Our implementation is modeled after the unrolled and optimized Hyperplonk scheme described in Appendix C. The proof size is  <span class="math">176\\mu + 1168</span>  bytes. One</p>

    <p class="text-gray-300">caveat is that we do not yet commit to the univariate polynomials in each round of the sum check. This slightly increases the proof size. The verification time for  <span class="math">\\mu = 20</span>  is less than  <span class="math">20\\mathrm{ms}</span>  on a consumer-grade laptop.</p>

    <p class="text-gray-300">Cost breakdown. We present a cost breakdown of HyperPlonk's prover cost. The breakdown is measured on a consumer-grade laptop <span class="math">^{12}</span> . As we see in Figure 5a, the majority of the computation is spent on committing and (batch) opening the commitment; the actual time spent on the information-theoretic PIOPs (Perm Check and Circuit Check) is about  <span class="math">30\\%</span> . The batch opening does not yet take advantage of the fact that many evaluation points and polynomials are identical. This could reduce the complexity of the resulting zero-check.</p>

    <p class="text-gray-300">Figure 5b gives another breakdown. It shows that the majority of the time (61%) is spent on multi-linear evaluations. This includes the operations performed within the sumcheck protocol. The rest of the time is spent on elliptic curve multi-exponentiations. Batching zero-checks and improving the batch-opening implementation could further reduce the number of MLE operations. We note that both multi-exponentiations and sumchecks are highly parallelizable and hardware-friendly, thus we expect further performance improvement on special-purpose hardware (e.g. GPUs).</p>

    <p class="text-gray-300">It is also worth noting that HyperPlonk never requires the explicit multiplication of polynomials. This enables high-degree custom gates for HyperPlonk.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> (a) In terms of building blocks</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> (b) In terms of computations Figure 5: Cost breakdown for vanilla  <span class="math">\\mathcal{R}_{\\mathrm{PLONK}}</span>  with  <span class="math">2^{20}</span>  constraints.</p>

    <p class="text-gray-300">A key advantage of HyperPlonk is that it does not rely on FFT algorithms that are less parallelizable. Indeed, in Figure 6a we observe an almost linear improvement when num of threads is small. We also observe that with low parallelization, the prover's run time is linear in the number of gates. For example, increase from a single thread to two threads, the prover time is reduced by  <span class="math">45\\%</span>  on average. In contrast, from 32 to 64 threads, there is almost no additional speedup. We assume that this is implementation dependent.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> (a) Prover time vs. number of constraints for different number of threads Figure 6</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> (b) Prover time vs. custom gate degree.</p>

    <p class="text-gray-300">It has been shown in VeriZexe [81] that custom gates, even at degree 5, allow for significant improvement of circuit size and prover time. For example, one may perform an elliptic curve group addition with just two gates; while a naive version may require  <span class="math">10+</span>  gates. The better expressibility of high-degree gates enables VeriZexe to improve  <span class="math">9\\mathrm{x}</span>  of prover time over the previous state-of-the-art [25].</p>

    <p class="text-gray-300">However, in a univariate Plonk system, such as [44, 66], high-degree custom gates increase the size of the required FFTs as well as the number of group operations. This limits their utility as they get larger. In comparison, in HyperPlonk, high-degree only affects the number of field operations. Our benchmark result in Figure 6b validates this observation and shows that the prover time from a degree 2 gate to a degree 32 gate only increases by  <span class="math">30\\%</span> . These more expressive gates can significantly reduce the number of gates in the circuit which more than offsets the added cost.</p>

    <p class="text-gray-300">We compare our scheme with both Jellyfish Plonk <span class="math">^{13}</span> , and Spartan  <span class="math">[68]^{14}</span> . Jellyfish is a highly optimized implementation of Plonk with lookup arguments. It is the state-of-the-art plonk prove system that uses Arkworks as the backend. Spartan is a multilinear ZKP system. Spartan's statements are written in Rank-1-Constraint-System  <span class="math">(\\mathcal{R}_{\\mathrm{R1CS}})</span> , which is simpler but less expressive.</p>

    <p class="text-gray-300">Hyperplonk, Plonk, and Spartan are polynomial IOPs that can be combined with various polynomial commitments. The commitment has a large impact on the performance of the proof system. For sake of comparison, we ensure that all 3 systems use the same elliptic curve and the same implementation. Concretely we use the Arkworks BLS12-381 implementation. Hyperplonk uses the multi-linear KZG commitment, Jellyfish the univariate KZG commitment, and Spartan uses an inner product argument [20, 27] -based polynomial commitment. We refer to the Spartan fork as Ark-Spartan to highlight the use of the Arkworks BLS12-381 backend.</p>

    <p class="text-gray-300">Comparison by application. We have presented data points for a few typical applications in Table 4. The proof systems are evaluated using mock circuits. The circuit sizes for both the  <span class="math">\\mathcal{R}_{\\mathrm{PLONK+}}</span>  (using the Jellyfish custom gate) and for the  <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span>  arithmetization are taken from references and demonstrate the advantages of (Hyper)Plonk. For example, a proof of knowledge of exponent for a 256-bits elliptic curve group element requires 3315  <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span>  constraints [63], while it reduces to 783 for  <span class="math">\\mathcal{R}_{\\mathrm{PLONK+}}</span>  [81]. Note that our HyperPlonk implementation does not yet support lookup, but we estimate that the slowdown will only be minor and offset by further optimizations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Application</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\( \\mathcal{R}_{\\text{R1CS}} \\)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ark-Spartan</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\( \\mathcal{R}_{\\text{PLONK+}} \\)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Jellyfish</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">HyperPlonk</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3-to-1 Rescue Hash</td>

            <td class="px-3 py-2 border-b border-gray-700">288 [1]</td>

            <td class="px-3 py-2 border-b border-gray-700">422 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">144 [71]</td>

            <td class="px-3 py-2 border-b border-gray-700">40 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">88 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PoK of Exponent</td>

            <td class="px-3 py-2 border-b border-gray-700">3315 [63]</td>

            <td class="px-3 py-2 border-b border-gray-700">902 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">783 [63]</td>

            <td class="px-3 py-2 border-b border-gray-700">64 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">105 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ZCash circuit</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( 2^{17} \\) [55]</td>

            <td class="px-3 py-2 border-b border-gray-700">8.3 s</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( 2^{15} \\) [42]</td>

            <td class="px-3 py-2 border-b border-gray-700">0.8 s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.6 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Zexe's recursive circuit</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( 2^{22} \\) [81]</td>

            <td class="px-3 py-2 border-b border-gray-700">6 min</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( 2^{17} \\) [81]</td>

            <td class="px-3 py-2 border-b border-gray-700">13.1 s</td>

            <td class="px-3 py-2 border-b border-gray-700">5.1 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rollup of 50 private tx</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( 2^{25} \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( 39 \\min^b \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( 2^{20} \\) [71]</td>

            <td class="px-3 py-2 border-b border-gray-700">110 s</td>

            <td class="px-3 py-2 border-b border-gray-700">38.2 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">zkEVM \\( circuit^a \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( 2^{27} \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">1 hourb,c</td>

            <td class="px-3 py-2 border-b border-gray-700">25 minb,c</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Prover runtime of Hyperplonk vs. Spartan[68] and the Jellyfish Plonk implementation for popular applications. Column 2 shows the number of  <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span>  constraints for each application and column 4 shows the corresponding number of constraints in HyperPlonk+/Ultraplonk. We emphasize that the Zexe and the Rollup applications are using the BW6-761 curve because they need to use two-chain curves. The rest of the applications are using the BLS12-381 curve.</p>

    <p class="text-gray-300"><span class="math">{}^{a}</span>  So far,there have been no approaches to express zkEVM as an R1CS circuit. Common approaches rely heavily on lookup tables which require plonk+.  <span class="math">{}^{b}</span>  Estimations.  <span class="math">{}^{c}</span>  This assumes a linear scaling factor that is in favor of Jellyfish. Note that we observe a super-linear growth for log degree from 20 to 23 in Jellyfish,while a sub-linear growth in HyperPlonk.</p>

    <p class="text-gray-300">Comparison by circuit size. We also compare HyperPlonk with Jellyfish and Ark-Spartan. We run both the vanilla-gate version of HyperPlonk that supports just additions and multiplication gates as well as the degree 5 Jellyfish gate. Note that  <span class="math">n</span>  Jellyfish gates are significantly more expressive than  <span class="math">n</span>  vanilla or R1CS gates. We measure both the single-threaded performance in Table 5 and the multi-threaded performance in Table 6. Our benchmark shows that multi-threaded HyperPlonk outperforms Jellyfish starting from  <span class="math">2^{14}</span>  constraints; the advantage grows when circuit size increases. This is mainly because FFTs scale worse than multi-exponentiations.</p>

    <p class="text-gray-300">HyperPlonk also has slightly better performance than Spartan. The difference is more pronounced in the multi-threaded benchmark which is likely because the Ark-Spartan implementation does not take full advantage of parallelism. We stress again that  <span class="math">\\text{plonk} +</span>  is more expressive than  <span class="math">\\mathcal{R}_{\\text{R1CS}}</span> , and thus a fair comparison should be over the same application rather than the same size of constraints. Table 4 shows that HyperPlonk is  <span class="math">5 \\sim 60x</span>  faster than Spartan in those applications.</p>

    <p class="text-gray-300">Recently, Xie et al. [80] introduced a highly efficient multilinear polynomial commitment scheme called Orion. The prover time is strictly linear, that is,  <span class="math">O(2^{\\mu})</span>  field operations and hashes where  <span class="math">\\mu</span>  is the number of variables. For  <span class="math">\\mu = 27</span> , it takes only 115 seconds to commit to a polynomial and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">210</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">211</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">212</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">213</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">214</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">215</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">216</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">217</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">218</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">219</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HP (Vanilla Gate)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.22</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.7</td>

            <td class="px-3 py-2 border-b border-gray-700">1.2</td>

            <td class="px-3 py-2 border-b border-gray-700">2.2</td>

            <td class="px-3 py-2 border-b border-gray-700">4.1</td>

            <td class="px-3 py-2 border-b border-gray-700">7.8</td>

            <td class="px-3 py-2 border-b border-gray-700">14.6</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">103</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HP (Jellyfish Gate)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.33</td>

            <td class="px-3 py-2 border-b border-gray-700">0.6</td>

            <td class="px-3 py-2 border-b border-gray-700">1.1</td>

            <td class="px-3 py-2 border-b border-gray-700">1.9</td>

            <td class="px-3 py-2 border-b border-gray-700">3.6</td>

            <td class="px-3 py-2 border-b border-gray-700">6.8</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">24.5</td>

            <td class="px-3 py-2 border-b border-gray-700">49.5</td>

            <td class="px-3 py-2 border-b border-gray-700">95</td>

            <td class="px-3 py-2 border-b border-gray-700">185</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Jellyfish Plonk</td>

            <td class="px-3 py-2 border-b border-gray-700">0.49</td>

            <td class="px-3 py-2 border-b border-gray-700">0.9</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5</td>

            <td class="px-3 py-2 border-b border-gray-700">2.8</td>

            <td class="px-3 py-2 border-b border-gray-700">5.5</td>

            <td class="px-3 py-2 border-b border-gray-700">10.5</td>

            <td class="px-3 py-2 border-b border-gray-700">19.4</td>

            <td class="px-3 py-2 border-b border-gray-700">37.9</td>

            <td class="px-3 py-2 border-b border-gray-700">74</td>

            <td class="px-3 py-2 border-b border-gray-700">143</td>

            <td class="px-3 py-2 border-b border-gray-700">284</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ark-Spartan</td>

            <td class="px-3 py-2 border-b border-gray-700">0.95</td>

            <td class="px-3 py-2 border-b border-gray-700">1.6</td>

            <td class="px-3 py-2 border-b border-gray-700">2.5</td>

            <td class="px-3 py-2 border-b border-gray-700">4.4</td>

            <td class="px-3 py-2 border-b border-gray-700">6.4</td>

            <td class="px-3 py-2 border-b border-gray-700">12.1</td>

            <td class="px-3 py-2 border-b border-gray-700">20.8</td>

            <td class="px-3 py-2 border-b border-gray-700">38.7</td>

            <td class="px-3 py-2 border-b border-gray-700">69.2</td>

            <td class="px-3 py-2 border-b border-gray-700">135</td>

            <td class="px-3 py-2 border-b border-gray-700">223</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5: Single-thread prover's performance (in seconds) for varying number of constraints under different schemes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">210</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">211</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">212</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">213</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">214</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">215</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">216</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">217</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">218</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">219</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HP (Vanilla Gate)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.07</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.14</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.5</td>

            <td class="px-3 py-2 border-b border-gray-700">0.8</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4</td>

            <td class="px-3 py-2 border-b border-gray-700">2.5</td>

            <td class="px-3 py-2 border-b border-gray-700">5.1</td>

            <td class="px-3 py-2 border-b border-gray-700">9.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HP (Jellyfish Gate)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.13</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18</td>

            <td class="px-3 py-2 border-b border-gray-700">0.27</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.67</td>

            <td class="px-3 py-2 border-b border-gray-700">1.2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">3.7</td>

            <td class="px-3 py-2 border-b border-gray-700">7.3</td>

            <td class="px-3 py-2 border-b border-gray-700">13.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Jellyfish Plonk</td>

            <td class="px-3 py-2 border-b border-gray-700">0.07</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.15</td>

            <td class="px-3 py-2 border-b border-gray-700">0.25</td>

            <td class="px-3 py-2 border-b border-gray-700">0.46</td>

            <td class="px-3 py-2 border-b border-gray-700">0.78</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4</td>

            <td class="px-3 py-2 border-b border-gray-700">2.7</td>

            <td class="px-3 py-2 border-b border-gray-700">5.5</td>

            <td class="px-3 py-2 border-b border-gray-700">10.8</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ark-Spartan</td>

            <td class="px-3 py-2 border-b border-gray-700">0.51</td>

            <td class="px-3 py-2 border-b border-gray-700">0.72</td>

            <td class="px-3 py-2 border-b border-gray-700">0.9</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4</td>

            <td class="px-3 py-2 border-b border-gray-700">1.9</td>

            <td class="px-3 py-2 border-b border-gray-700">3.1</td>

            <td class="px-3 py-2 border-b border-gray-700">4.7</td>

            <td class="px-3 py-2 border-b border-gray-700">8.3</td>

            <td class="px-3 py-2 border-b border-gray-700">13.7</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6: 64-thread prover's performance (in seconds) for varying number of constraints under different schemes.</p>

    <p class="text-gray-300">compute an evaluation proof using a single thread on a consumer-grade desktop. The verifier time and proof size is  <span class="math">O_{\\lambda}(\\mu^{2})</span> , which also improves the state-of-the-art [22, 50]. However, the concrete proof size is still unsatisfactory, e.g., for  <span class="math">\\mu = 27</span> , the proof size is 6 MBs. In this section, we describe a variant of Orion PCS that enjoys similar proving complexity but has  <span class="math">O(\\mu)</span>  proof size and verifier time, with good constants. In particular, for security parameter  <span class="math">\\lambda = 128</span>  and  <span class="math">\\mu = 27</span> , the proof size is less than 10KBs, which is  <span class="math">600 \\times</span>  smaller than Orion for  <span class="math">\\mu = 27</span> .</p>

    <p class="text-gray-300">This section is organized as follows. We start by reviewing the linear-time PCS from tensor product arguments [22, 50], which Orion builds upon, then we describe our techniques for shrinking the proof size. Finally, we analyze the security and complexity of the construction.</p>

    <p class="text-gray-300">Linear-time PCS from tensor-product argument [22, 50]. Bootle, Chiesa, and Groth [22] propose an elegant scheme for building PCS with strictly linear-time provers. Golovnev et al. [50] later further simplify the scheme. Let  <span class="math">f \\in \\mathcal{F}_{\\mu}^{(\\leq 1)}</span>  be a multilinear polynomial where  <span class="math">f_{b} \\in \\mathbb{F}</span>  is the coefficient of  <span class="math">\\mathbf{X}_b \\coloneqq \\mathbf{X}_1^{b_1} \\cdots \\mathbf{X}_\\mu^{b_\\mu}</span>  for every  <span class="math">b \\in B_\\mu</span> . Denote by  <span class="math">n = 2^\\mu</span> ,  <span class="math">k = 2^\\nu &amp;lt; 2^\\mu</span>  and  <span class="math">m = n / k</span> , one can view the evaluation of  <span class="math">f</span>  as a tensor product, that is,</p>

    <div class="my-4 text-center"><span class="math-block">f (\\mathbf {X}) = \\left\\langle \\mathbf {w}, \\mathbf {t} _ {0} \\otimes \\mathbf {t} _ {1} \\right\\rangle \\tag {15}</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbf{w} = (f_{\\langle 0\\rangle},\\dots ,f_{\\langle n - 1\\rangle})</span> <span class="math">\\mathbf{t}_0 = \\left(\\mathbf{X}_{\\langle 0\\rangle},\\mathbf{X}_{\\langle 1\\rangle},\\dots ,\\mathbf{X}_{\\langle k - 1\\rangle}\\right)</span>  and  <span class="math">\\mathbf{t}_1 = \\left(\\mathbf{X}_{\\langle 0\\rangle},\\mathbf{X}_{\\langle k\\rangle},\\dots ,\\mathbf{X}_{\\langle (m - 1)\\cdot k\\rangle}\\right)</span> . Here  <span class="math">\\langle i\\rangle</span>  denotes the  <span class="math">\\mu</span> -bit binary representation of  <span class="math">i</span> . Let  <span class="math">E:\\mathbb{F}^m\\to \\mathbb{F}^M</span>  be a linear encoding scheme, that is, a linear function whose image is a linear code (Definition 2.1). Golovnev et al. [50, §4.2] construct a PCS scheme as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Commitment: To commit a multilinear polynomial  <span class="math">f</span>  with coefficients  <span class="math">\\mathbf{w} \\in \\mathbb{F}^n</span> , the prover  <span class="math">\\mathcal{P}</span>  interprets  <span class="math">\\mathbf{w}</span>  as a  <span class="math">k \\times m</span>  matrix, namely  <span class="math">\\mathbf{w} \\in \\mathbb{F}^{k \\times m}</span> , encodes  <span class="math">\\mathbf{w}</span> 's rows, and obtains matrix  <span class="math">W \\in \\mathbb{F}^{k \\times M}</span>  such that  <span class="math">W[i,:] = E(\\mathbf{w}[i,:])</span>  for every  <span class="math">i \\in [k]</span> . Then  <span class="math">\\mathcal{P}</span>  computes a Merkle tree commitment for each column of  <span class="math">W</span>  and builds another Merkle tree  <span class="math">T</span>  on top of the column commitments. The polynomial commitment  <span class="math">C_f</span>  is the Merkle root of  <span class="math">T</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Evaluation proof: To prove that <span class="math">f(\\mathbf{z}) = y</span> for some point <span class="math">\\mathbf{z} \\in \\mathbb{F}^{\\mu}</span> and value <span class="math">y \\in \\mathbb{F}</span>, the prover <span class="math">\\mathcal{P}</span> translates <span class="math">\\mathbf{z}</span> to vectors <span class="math">\\mathbf{t}_0 \\in \\mathbb{F}^k</span> and <span class="math">\\mathbf{t}_1 \\in \\mathbb{F}^m</span> as above and proves that <span class="math">\\langle \\mathbf{w}, \\mathbf{t}_0 \\otimes \\mathbf{t}_1 \\rangle = y</span> (where <span class="math">\\mathbf{w} \\in \\mathbb{F}^{k \\times m}</span> is the message encoded and committed in <span class="math">C_f</span>). To do so, <span class="math">\\mathcal{P}</span> does two things:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proximity check: The prover shows that the matrix <span class="math">W \\in \\mathbb{F}^{k \\times M}</span> committed by <span class="math">C_f</span> is close to <span class="math">k</span> codewords. Specifically, the verifier sends a random vector <span class="math">\\mathbf{r} \\in \\mathbb{F}^k</span>, the prover replies with a vector <span class="math">\\mathbf{y}_{\\mathbf{r}} := \\mathbf{r} \\cdot \\mathbf{w} \\in \\mathbb{F}^m</span> which is the linear combination of <span class="math">\\mathbf{w}</span>'s rows according to <span class="math">\\mathbf{r}</span>. The verifier checks that the encoding of <span class="math">\\mathbf{y}_{\\mathbf{r}}</span>, namely <span class="math">E(\\mathbf{y}_{\\mathbf{r}}) \\in \\mathbb{F}^M</span>, is close to <span class="math">\\mathbf{r} \\cdot W</span>, the linear combination of <span class="math">W</span>'s rows. This implies that the <span class="math">k</span> rows of <span class="math">W</span> are all close to codewords [50, §4.2].</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consistency check: The prover shows that <span class="math">\\langle \\mathbf{w}, \\mathbf{t}_0 \\otimes \\mathbf{t}_1 \\rangle = y</span> where <span class="math">\\mathbf{w} \\in \\mathbb{F}^{k \\times m}</span> is the <span class="math">k</span> error-decoded messages from <span class="math">W \\in \\mathbb{F}</span> committed in <span class="math">C_f</span>. The scheme is similar to the proximity check except that we replace the random vector <span class="math">\\mathbf{r}</span> with <span class="math">\\mathbf{t}_0</span>. After receiving the linearly combined vector <span class="math">\\mathbf{y}_0 \\in \\mathbb{F}^m</span>, the verifier further checks that <span class="math">\\langle \\mathbf{y}_0, \\mathbf{t}_1 \\rangle = y</span>.</li>

    </ul>

    <p class="text-gray-300">We describe the concrete PCS evaluation protocol below.</p>

    <p class="text-gray-300">Protocol 1 (PCS evaluation [50]): The goal is to check that <span class="math">\\langle \\mathbf{w}, \\mathbf{t}_0 \\otimes \\mathbf{t}_1 \\rangle = y</span> (where <span class="math">\\mathbf{w} \\in \\mathbb{F}^{k \\times m}</span> is the message encoded and committed in <span class="math">C_f</span>).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> sends a random vector <span class="math">\\mathbf{r} \\in \\mathbb{F}^k</span>.</li>

      <li><span class="math">\\mathcal{P}</span> sends vector <span class="math">\\mathbf{y}_{\\mathbf{r}}, \\mathbf{y}_0 \\in \\mathbb{F}^m</span> where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {y} _ {\\mathbf {r}} = \\sum_ {i = 1} ^ {k} \\mathbf {r} _ {i} \\cdot \\mathbf {w} [ i,: ], \\text{ and } \\mathbf {y} _ {0} = \\sum_ {i = 1} ^ {k} \\mathbf {t} _ {0, i} \\cdot \\mathbf {w} [ i,: ],</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{w} \\in \\mathbb{F}^{k \\times m}</span> is the message matrix being encoded and committed.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. <span class="math">\\mathcal{V}</span> sends <span class="math">\\mathcal{P}</span> a random subset <span class="math">I \\subseteq [M]</span> with size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\Theta(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> opens the entire column <span class="math"> \\{W[:,j]\\}_{j\\in I}</span> using Merkle proofs, where <span class="math">W\\in \\mathbb{F}^{k\\times M}</span> is the row-wise encoded matrix. That is, <span class="math">\\mathcal{P}</span> outputs the column commitment <span class="math">h_j</span> for every column <span class="math">j\\in I</span>, and provide the Merkle proof for <span class="math">h_j</span> w.r.t. to Merkle root <span class="math">C_f</span>.</li>

      <li><span class="math">\\mathcal{V}</span> checks that (i) the Merkle openings are correct w.r.t. <span class="math">C_f</span>, and (ii) for all <span class="math">j \\in I</span>, it holds that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">E (\\mathbf {y} _ {\\mathbf {r}}) _ {j} = \\langle \\mathbf {r}, W [:, j ] \\rangle \\text{ and } E (\\mathbf {y} _ {0}) _ {j} = \\langle \\mathbf {t} _ {0}, W [:, j ] \\rangle .</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> checks that <span class="math">\\langle \\mathbf{y}_0, \\mathbf{t}_1 \\rangle = y</span>.</li>

    </ol>

    <p class="text-gray-300">Note that by sampling a subset <span class="math">I</span> with size <span class="math">\\Theta(\\lambda)</span> and checking that <span class="math">\\mathbf{r} \\cdot W</span>, <span class="math">\\mathbf{t}_0 \\cdot W</span> are consistent with the encodings <span class="math">E(\\mathbf{y}_{\\mathbf{r}})</span>, <span class="math">E(\\mathbf{y}_0)</span> on set <span class="math">I</span>, the verifier is confident that <span class="math">\\mathbf{r} \\cdot W</span>, <span class="math">\\mathbf{t}_0 \\cdot W</span> are indeed close to the encodings <span class="math">E(\\mathbf{y}_{\\mathbf{r}})</span>, <span class="math">E(\\mathbf{y}_0)</span> with high probability. By setting <span class="math">k = \\sqrt{n}</span>, the prover takes <span class="math">O(n)</span> <span class="math">\\mathbb{F}</span>-ops and hashes; the verifier time and proof size are both <span class="math">O_{\\lambda}(\\sqrt{n})</span>. Orion describes an elegant code-switching scheme that reduces the proof size and verifier time down to <span class="math">O_{\\lambda}(\\log^2(n))</span>. However, the concrete proof size is still large. Next, we describe a scheme that has much smaller proof.</p>

    <p class="text-gray-300">Linear-time PCS with small proofs. Similar to Orion (and more generally, the proof composition technique [21, 22, 50]), instead of letting the verifier check the correctness of <span class="math">\\mathbf{y}_{\\mathbf{r}}</span>, <span class="math">\\mathbf{y}_0</span> and the openings of the columns <span class="math">W[:,j]\\forall j\\in I</span>, the prover can compute another (succinct) outer proof validating the correctness of <span class="math">\\mathbf{y}_{\\mathbf{r}},\\mathbf{y}_0,W[:,j]</span>. However, we need to minimize the outer proof's circuit complexity, which is non-trivial. Orion builds an efficient SNARK circuit that removes all of the</p>

    <p class="text-gray-300">45</p>

    <p class="text-gray-300">hashing gadgets, with the tradeoff of larger proof size. We describe a variant of their scheme that minimizes the proof size without significantly increasing the circuit complexity.</p>

    <p class="text-gray-300">Specifically, after receiving challenge vector <span class="math">\\mathbf{r}\\in\\mathbb{F}^{k}</span>, <span class="math">\\mathcal{P}</span> instead sends <span class="math">\\mathcal{V}</span> commitments <span class="math">C_{\\mathbf{r}},C_{0}</span> to the messages <span class="math">\\mathbf{y}_{\\mathbf{r}},\\mathbf{y}_{0}</span>; after receiving <span class="math">\\mathcal{V}</span>’s random subset <span class="math">I\\subset[M]</span>, <span class="math">\\mathcal{P}</span> computes a SNARK proof for the following statement:</p>

    <p class="text-gray-300">Statement 1 (PCS Eval verification):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Witness: <span class="math">\\mathbf{y}_{\\mathbf{r}},\\mathbf{y}_{0}\\in\\mathbb{F}^{m}</span>, <span class="math">\\{W[:,j]\\}_{j\\in I}</span>.</li>

      <li>Circuit statements:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">C_{\\mathbf{r}}</span>, <span class="math">C_{0}</span> are the commitments to <span class="math">\\mathbf{y}_{\\mathbf{r}}</span>, <span class="math">\\mathbf{y}_{0}</span> respectively.</li>

      <li>For all <span class="math">j\\in I</span>, it holds that</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">h_{j}=H(W[:,j])</span> where <span class="math">H</span> is a fast hashing scheme;</li>

      <li><span class="math">E(\\mathbf{y}_{\\mathbf{r}})_{j}=\\langle\\mathbf{r},W[:,j]\\rangle</span> and <span class="math">E(\\mathbf{y}_{0})_{j}=\\langle\\mathbf{t}_{0},W[:,j]\\rangle</span>.</li>

      <li><span class="math">\\langle\\mathbf{y}_{0},\\mathbf{t}_{1}\\rangle=y</span>.</li>

      <li>Public output: <span class="math">\\{h_{j}\\}_{j\\in I}</span>, and <span class="math">C_{\\mathbf{r}},C_{0}</span>.</li>

    </ul>

    <p class="text-gray-300">Besides the SNARK proof, the prover also provides the openings of <span class="math">\\{h_{j}\\}_{j\\in I}</span> with respect to the commitments <span class="math">C_{f}</span>. Intuitively, the new protocol is “equivalent” to Protocol 1, because the SNARK witness <span class="math">\\{W[:,j]\\}_{j\\in I}</span> and <span class="math">\\mathbf{y}_{\\mathbf{r}},\\mathbf{y}_{0}</span> are identical to those committed in <span class="math">C_{f},C_{\\mathbf{r}},C_{0}</span> by the binding property of the commitments; and the SNARK does all of the verifier checks. Unfortunately, the scheme has the following drawbacks:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Instantiating the commitments with Merkle trees leads to a large overhead on the proof size. In particular, the proof contains $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> Merkle proofs, each with length </span>O(\\log n)<span class="math">. For 128-bit security, we need to set </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1568<span class="math">, and the proof size is at least 1 MBs for </span>\\mu=20$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The random subset <span class="math">I</span> varies for different evaluation instances. It is non-trivial to efficiently lookup the witness <span class="math">\\{E(\\mathbf{y}_{\\mathbf{r}})_{j},E(\\mathbf{y}_{0})_{j}\\}_{j\\in I}</span> in the circuit if the set <span class="math">I</span> is dynamic (i.e. we need an efficient random access gadget).</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The circuit complexity is huge. In particular, the circuit is dominated by the commitments to <span class="math">\\mathbf{y}_{\\mathbf{r}},\\mathbf{y}_{0}</span> and the hash commitments to <span class="math">\\{W[:,j]\\}_{j\\in I}</span>. This leads to $2m+k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> hash gadgets in the circuit. Note that we can’t use algebraic hash functions like Rescue <em>[1]</em> or Poseidon <em>[51]</em>, which are circuit-friendly, but have slow running times. For </span>\\mu=26<span class="math">, </span>k=m=\\sqrt{n}<span class="math"> and 128-bit security (where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1568$), this leads to 13 million hash gadgets where each hash takes hundreds to thousands of constraints, which is unaffordable.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We resolve the above issues via the following observations.</p>

    <p class="text-gray-300">First, a large portion of the multilinear PCS evaluation proof is Merkle opening paths. We can shrink the proof size by replacing Merkle trees with multilinear PCS that enable efficient batch openings (Section 3.8). Specifically, in the committing phase, after computing the hashes of <span class="math">W</span>’s columns, instead of building another Merkle tree <span class="math">T</span> of size <span class="math">M=O(n/k)</span> and set the Merkle root as the commitment, the prover can commit to the column hashes using a multilinear PCS (e.g. KZG). Though the KZG committing is more expensive, the problem size has been reduced to <span class="math">O(n/k)</span>, thus for sufficiently large <span class="math">k</span>, the committing complexity is still approximately <span class="math">O(n)</span> <span class="math">\\mathbb{F}</span>-ops. A great advantage is that the batch opening proof for <span class="math">\\{h_{j}\\}_{j\\in I}</span> consists of only <span class="math">O(\\log n)</span> group/field elements, with good constant. Even better, when instantiating the outer proof with HyperPlonk(+),</p>

    <p class="text-gray-300">the openings can be batched with those in the outer SNARK and thus incur almost no extra cost in proof size.</p>

    <p class="text-gray-300">Second, with Plookup, we can efficiently simulate random access in arrays in the SNARK circuit. For example, to extract witness <span class="math">\\{\\mathbf{Y}_{\\mathbf{r},j}=E(\\mathbf{y}_{\\mathbf{r}})_{j}\\}_{j\\in I}</span>, we can build an (online) table <span class="math">T</span> where each element of the table is a pair <span class="math">(i,E(\\mathbf{y}_{\\mathbf{r}})_{i})</span> (<span class="math">1\\leq i\\leq M</span>). Then for every <span class="math">j\\in I</span>, we build a lookup gate checking that <span class="math">(j,\\mathbf{Y}_{\\mathbf{r},j})</span> is in the table <span class="math">T</span>, thus guarantee that <span class="math">\\mathbf{Y}_{\\mathbf{r},j}</span> is identical to <span class="math">E(\\mathbf{y}_{\\mathbf{r}})_{j}</span>. The circuit description is now independent of the random set <span class="math">I</span> and we only need to preprocess the circuit once in the setup phase.</p>

    <p class="text-gray-300">Third, with the help of Commit-and-Prove-SNARKs (CP-SNARK) <em>[31, 32, 3]</em>, there is no need to check the consistency between commitments <span class="math">C_{\\mathbf{r}},C_{0}</span> and <span class="math">\\mathbf{y}_{\\mathbf{r}},\\mathbf{y}_{0}</span> in the circuit. Instead, we can commit <span class="math">(\\mathbf{y}_{\\mathbf{r}},\\mathbf{y}_{0})</span> to a multilinear commitment <span class="math">C</span>, and build a CP-SNARK proof showing that the vector underlying <span class="math">C</span> is identical to the witness vector <span class="math">(\\mathbf{y}_{\\mathbf{r}},\\mathbf{y}_{0})</span> in the circuit. We further observe that <span class="math">C</span> can be a part of the witness polynomials, which further removes the need of an additional CP-SNARK proof.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">After applying previous optimizations, the proof size is dominated by the $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> field elements </span>\\{h_{j}\\}_{j\\in I}<span class="math">. We can altogether remove them by applying the CP-SNARK trick again. In particular, since </span>\\{h_{j}\\}_{j\\in I}<span class="math"> are both committed in the polynomial commitment </span>C_{f}<span class="math"> and the SNARK witness commitment, it is sufficient to construct a CP-SNARK proving that they are consistent in the two commitments with respect to set </span>I$. We refer to Section 3.8 for constructing CP-SNARK proofs from multilinear commitments.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since the bulk of verification work is delegated to the prover, there is no need to set <span class="math">k=\\sqrt{n}</span>. Instead, we can set an appropriate <span class="math">k=\\Theta(\\lambda/\\log n)</span> to minimize the outer circuit size. In particular, the circuit is dominated by 2 linear encodings (of length <span class="math">n/k</span>) and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> hashes (of length </span>k<span class="math">). If we use vanilla HyperPlonk+ as the outer SNARK scheme and use Reinforced Concrete <em>[7]</em> as the hashing scheme that has a similar running time to SHA-256, for </span>\\mu=30<span class="math">, </span>k=64<span class="math"> and 128-bit security (where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1568<span class="math">), the circuit complexity is only </span>\\approx 2^{26}<span class="math"> constraints. And we can expect the running time of the outer proof to be </span>O_{\\lambda}(n)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The resulting multilinear polynomial commitment scheme is shown in Figure 7.</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Remark 7.1 (CP-SNARKs instantiation.).</h6>

    <p class="text-gray-300">We can use the algorithm in Section 3.8.1 to instantiate the CP-SNARK in Figure 7 from any multilinear PIOP-based SNARKs with minimal overhead. First, we can split the witness polynomial into two parts: one includes the vector <span class="math">(\\mathbf{y}_{\\mathbf{r}},\\mathbf{y}_{0})</span> while the other includes the rest. The witness polynomial commitment to <span class="math">(\\mathbf{y}_{\\mathbf{r}},\\mathbf{y}_{0})</span> is essentially the commitment <span class="math">C_{p_{\\mathbf{y}}}</span> in Figure 7, so that we don’t need to additionally commit to <span class="math">(\\mathbf{y}_{\\mathbf{r}},\\mathbf{y}_{0})</span> and provide a proof. We emphasize that <span class="math">C_{p_{\\mathbf{y}}}</span> is sent before the prover receives the challenge set <span class="math">I</span>, which is essential for knowledge soundness.</p>

    <p class="text-gray-300">Second, the CP-proof generation between the multilinear commitment <span class="math">C_{f}</span> and the SNARK witness polynomial commitment (w.r.t. set <span class="math">I</span>) consists of a sumcheck with <span class="math">O(\\log m)</span> rounds and <span class="math">2</span> PCS openings (one for <span class="math">C_{f}</span> and one for the witness polynomial). If we instantiate the SNARK with HyperPlonk+, we can batch the proving of the CP-proof and the SNARK proof so that the CP-proof adds no extra cost to the proof size beyond the original SNARK proof.</p>

    <p class="text-gray-300">Building blocks: A CP-SNARK scheme OSNARK; an (extractable) polynomial commitment scheme PC; a hash commitment scheme HCom; and a linear encoding scheme  <span class="math">E</span>  with minimum distance  <span class="math">\\delta</span> .</p>

    <p class="text-gray-300">Setup  <span class="math">(1^{\\lambda},\\mu^{<em>})\\to \\mathsf{gp}</span>  : Given security parameter  <span class="math">\\lambda</span>  , upper bound  <span class="math">\\mu^{</em>}</span>  on the number of variables, set  <span class="math">m^{<em>}</span>  so that the running time of OSNARK (and PC) is  <span class="math">O_{\\lambda}(2^{\\mu^{</em>}})</span>  for circuit size (and degree)  <span class="math">m^{<em>}</span>  . Run  <span class="math">\\mathsf{gp}_o\\gets \\mathsf{OSNARK.Setup}(1^\\lambda ,m^</em>)</span> <span class="math">\\mathsf{gp}_{pc}\\gets \\mathsf{PC.Setup}(1^{\\lambda},m^{*})</span>  , run the indexing phase of OSNARK for the circuit statement in Figure 8 and obtain  <span class="math">(\\mathsf{vp}_o,\\mathsf{pp}_o)</span>  . Output  <span class="math">\\mathsf{gp}:= (\\mathsf{gp}_o,\\mathsf{gp}_{pc},\\mathsf{vp}_o,\\mathsf{pp}_o)</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{Commit}(\\mathsf{gp};f)\\to C_f</span>  : Given polynomial  <span class="math">f\\in \\mathcal{F}_{\\mu}^{(\\leq 1)}</span>  with coefficients  <span class="math">\\mathbf{w} = (f_{\\langle 0\\rangle},\\dots ,f_{\\langle n - 1\\rangle})</span>  , set  <span class="math">m = n / k</span>  so that the running time of OSNARK (and PC) is  <span class="math">O_{\\lambda}(2^{\\mu})</span>  for circuit size (and degree)  <span class="math">m</span>  . Interpret  <span class="math">\\mathbf{w}</span>  as a  <span class="math">k\\times m</span>  matrix (i.e.  <span class="math">\\mathbf{w}\\in \\mathbb{F}^{k\\times m}</span> ):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute matrix  <span class="math">W \\in \\mathbb{F}^{k \\times M}</span>  such that  <span class="math">W[i,:] = E(\\mathbf{w}[i,:]) \\forall i \\in [k]</span> . Here  <span class="math">E: \\mathbb{F}^m \\to \\mathbb{F}^M</span>  is the linear encoding.</li>

      <li>For each column  <span class="math">j \\in [M]</span> , compute hash commitment  <span class="math">h_j \\gets \\mathsf{HCom}(W[:,j])</span> , where  <span class="math">W[:,j] \\in \\mathbb{F}^k</span>  is the  <span class="math">j</span> -th column of  <span class="math">W</span> .</li>

      <li>Let  <span class="math">p_h</span>  be the polynomial that interpolates vector  <span class="math">(h_j)_{j \\in [M]}</span> . Output commitment  <span class="math">C_f \\gets \\mathsf{PC.Commit}(\\mathsf{gp}_{pc}, p_h)</span> .</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{Open}(\\mathsf{gp},C_f,f)</span>  : Given polynomial  <span class="math">f\\in \\mathcal{F}_{\\mu}^{(\\leq 1)}</span>  with coefficients  <span class="math">\\mathbf{w}\\in \\mathbb{F}^{k\\times m}</span> , run the committing algorithm and check if the output is consistent with  <span class="math">C_f</span> .</p>

    <p class="text-gray-300"><span class="math">\\operatorname{Eval}(\\mathsf{gp}; C_f, \\mathbf{z}, y; f)</span> : Given public parameter  <span class="math">\\mathsf{gp}</span> , point  <span class="math">\\mathbf{z} \\in \\mathbb{F}^{\\mu}</span>  and commitment  <span class="math">C_f</span>  to polynomial  <span class="math">f \\in \\mathcal{F}_{\\mu}^{(\\leq 1)}</span>  with coefficients  <span class="math">\\mathbf{w} \\in \\mathbb{F}^{k \\times m}</span> , transform  <span class="math">\\mathbf{z}</span>  to vectors  <span class="math">\\mathbf{t}_0 \\in \\mathbb{F}^k</span>  and  <span class="math">\\mathbf{t}_1 \\in \\mathbb{F}^m</span>  as in Equation (15) such that  <span class="math">f(\\mathbf{z}) = \\langle \\mathbf{w}, \\mathbf{t}_0 \\otimes \\mathbf{t}_1 \\rangle</span> . The prover  <span class="math">\\mathcal{P}</span>  and the verifier  <span class="math">\\mathcal{V}</span>  run the following protocol:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  sends  <span class="math">\\mathcal{P}</span>  a random vector  <span class="math">\\mathbf{r} \\in \\mathbb{F}^k</span> .</li>

      <li>Define vectors</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {y} _ {\\mathbf {r}} = \\sum_ {i = 1} ^ {k} \\mathbf {r} _ {i} \\cdot \\mathbf {w} [ i,: ], \\quad \\mathbf {y} _ {0} = \\sum_ {i = 1} ^ {k} \\mathbf {t} _ {0, i} \\cdot \\mathbf {w} [ i,: ].</span></div>

    <p class="text-gray-300">Let  <span class="math">p_{\\mathbf{r}}</span>  be the polynomial that interpolates  <span class="math">(\\mathbf{y}_{\\mathbf{r}},\\mathbf{y}_0)</span> .  <span class="math">\\mathcal{P}</span>  sends  <span class="math">\\mathcal{V}</span>  commitment  <span class="math">C_{p_{\\mathbf{y}}} \\gets \\mathrm{PC.Commit}(\\mathsf{gp}_{pc},p_{\\mathbf{y}})</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  sends a random subset  <span class="math">I\\subseteq [M]</span>  with size  <span class="math">t\\coloneqq \\frac{-\\lambda}{\\log(1 - \\delta)}</span></li>

      <li><span class="math">\\mathcal{P}</span>  sends  <span class="math">\\mathcal{V}</span> , a CP-SNARK proof  <span class="math">\\pi_o</span>  showing that</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the statement in Figure 8 holds true;</li>

      <li>the SNARK witness  <span class="math">(\\mathbf{y}_{\\mathbf{r}},\\mathbf{y}_0)</span>  is identical to the vector committed in  <span class="math">C_{p_{\\mathbf{y}}}</span> ;</li>

      <li>the SNARK witness  <span class="math">(h_j)_{j \\in I}</span>  is consistent with that in the polynomial commitment  <span class="math">C_f</span>  w.r.t. set  <span class="math">I</span> .</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  checks  <span class="math">\\pi_o</span>  with public input  <span class="math">(\\alpha, \\mathbf{r}, y, \\mathbf{z})</span> , and commitments  <span class="math">C_{p_y}, C_f</span> .</li>

    </ol>

    <p class="text-gray-300">Figure 7: The multilinear polynomial commitment scheme.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>messages  <span class="math">\\mathbf{y}_{\\mathbf{r}}, \\mathbf{y}_0 \\in \\mathbb{F}^m</span> , encodings  <span class="math">\\mathbf{Y}_{\\mathbf{r}}, \\mathbf{Y}_0 \\in \\mathbb{F}^M</span> , and evaluation vectors  <span class="math">\\mathbf{t}_0 \\in \\mathbb{F}^k</span> ,  <span class="math">\\mathbf{t}_1 \\in \\mathbb{F}^m</span> ;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- the columns of  <span class="math">W</span>  in subset  <span class="math">I</span> , that is,  $W' = (W[:, j])_{j \\in I} \\in \\mathbb{F}^{k \\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ ;</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- column hashes  $\\mathbf{h} = (h_1, \\ldots, h_{</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">}) \\in \\mathbb{F}^{</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">}$ .</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>challenge vector  <span class="math">\\mathbf{r} \\in \\mathbb{F}^k</span> ;</li>

      <li>random subset  <span class="math">I \\subseteq [M]</span> ;</li>

      <li>evaluation point  <span class="math">\\mathbf{z} \\in \\mathbb{F}^{\\mu}</span>  and claimed evaluation  <span class="math">y \\in \\mathbb{F}</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{t}_0, \\mathbf{t}_1</span>  is the correct transformation from  <span class="math">\\mathbf{z}</span>  as in Equation (15).</li>

      <li><span class="math">\\mathbf{Y}_{\\mathbf{r}} = E(\\mathbf{y}_{\\mathbf{r}})</span>  and  <span class="math">\\mathbf{Y}_0 = E(\\mathbf{y}_0)</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For  $i = 1 \\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , let  </span>j_{i} \\in I<span class="math">  be the  </span>i<span class="math"> -th element in  </span>I$ , it holds that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{Y}_{\\mathbf{r},i}^{\\prime} = \\mathbf{Y}_{\\mathbf{r},j_{i}}</span> , that is,  <span class="math">(j_{i},\\mathbf{Y}_{\\mathbf{r},i}^{\\prime})</span>  is in the table  <span class="math">\\{(k,\\mathbf{Y}_{\\mathbf{r},k})\\}_{k\\in [M]}</span> , and</li>

      <li><span class="math">\\mathbf{Y}_{0,i}^{\\prime} = \\mathbf{Y}_{0,j_{i}}</span> , that is,  <span class="math">(j_{i},\\mathbf{Y}_{0,i}^{\\prime})</span>  is in the table  <span class="math">\\{(k,\\mathbf{Y}_{0,k})\\}_{k\\in [M]}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For  $i = 1 \\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ , it holds that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">h_i = \\mathsf{HCom}(W&#x27;[:,i])</span>  where  <span class="math">\\mathsf{HCom}:\\mathbb{F}^k\\to \\mathbb{F}</span>  is the hash commitment scheme;</li>

      <li><span class="math">\\mathbf{Y}_{\\mathbf{r},i}^{\\prime} = \\langle \\mathbf{r},W^{\\prime}[:,i]\\rangle</span>  and  <span class="math">\\mathbf{Y}_{0,i}^{\\prime} = \\langle \\mathbf{t}_0,W^{\\prime}[:,i]\\rangle</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\langle \\mathbf{y}_0, \\mathbf{t}_1 \\rangle = y</span> .</li>

    </ul>

    <p class="text-gray-300">Figure 8: The outer SNARK circuit statement. The circuit configuration is independent of the random set  <span class="math">I</span> .</p>

    <p class="text-gray-300">Theorem 7.1. The multilinear polynomial commitment scheme in Figure 7 is correct and binding. The PCS evaluation protocol is knowledge-sound.</p>

    <p class="text-gray-300">Proof. Correctness and binding. Correctness holds obviously by inspection of the protocol. We prove the binding property by contradiction. Suppose an adversary finds a commitment  <span class="math">C_f</span>  and two polynomials  <span class="math">f_1, f_2</span>  with different coefficients  <span class="math">\\mathbf{w}_1, \\mathbf{w}_2 \\in \\mathbb{F}^{k \\times m}</span>  such that  <span class="math">C_f</span>  can open to both  <span class="math">\\mathbf{w}_1</span>  and  <span class="math">\\mathbf{w}_2</span> . There are two cases:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">C_f</span>  can open to two different vectors of column hash commitments  <span class="math">\\mathbf{h}_1, \\mathbf{h}_2 \\in \\mathbb{F}^M</span> , which contradicts the binding property of the PCS PC.</li>

      <li><span class="math">C_f</span>  binds to a single vector  <span class="math">\\mathbf{h} \\in \\mathbb{F}^M</span> , but encoding  <span class="math">\\mathbf{w}_1, \\mathbf{w}_2</span>  lead to two different encoded matrices  <span class="math">W_1, W_2 \\in \\mathbb{F}^{k \\times M}</span> . This contradicts the collision resistance of the hash function.</li>

    </ol>

    <p class="text-gray-300">In summary, the binding property holds.</p>

    <p class="text-gray-300">Knowledge soundness. We use a similar technique as in [50] that enables extracting polynomials even if the linear code  <span class="math">E</span>  is not efficiently decodable. For any adversary  <span class="math">\\mathcal{A}</span>  that can pass the PCS evaluation check with probability more than  <span class="math">\\epsilon</span> , the extractor  <span class="math">\\mathcal{E}^{\\mathcal{A}}</span>  works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run  <span class="math">\\mathcal{A}</span>  and obtain commitment  <span class="math">C_f</span> , point  <span class="math">\\mathbf{z} \\in \\mathbb{F}^{\\mu}</span> , and evaluation  <span class="math">y \\in \\mathbb{F}</span> . Run the extractors of the PCS and the hash function to recover the matrix  <span class="math">W&#x27; \\in \\mathbb{F}^{k \\times M}</span>  underlying  <span class="math">C_f</span> . Abort if the extraction fails.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Set <span class="math">S \\gets \\emptyset</span>, repeat the following procedures until $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq k<span class="math"> or the number of </span>\\mathbf{r}<span class="math"> being sampled is more than </span>8k / \\epsilon$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample and send <span class="math">\\mathcal{A}</span> a random vector <span class="math">\\mathbf{r} \\stackrel{\\circ}{\\leftarrow} \\mathbb{F}^k</span>.</li>

      <li>Obtain the PCS commitments <span class="math">C_{p_{\\mathbf{r}}}</span>. Use the PCS extractor to extract the vector <span class="math">(\\mathbf{y}_{\\mathbf{r}}, \\mathbf{y}_0) \\in \\mathbb{F}^{2m}</span>. Abort and rerun with another <span class="math">\\mathbf{r}</span> if the extraction fails.</li>

      <li>Sample and send <span class="math">\\mathcal{A}</span> a random subset <span class="math">I \\subseteq [M]</span>.</li>

      <li>Obtain the CP-SNARK proof <span class="math">\\pi_o</span>. Add the pair <span class="math">(\\mathbf{r}, \\mathbf{y}_{\\mathbf{r}})</span> into set <span class="math">S</span> if the proof correctly verifies.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. If $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq k<span class="math"> and the random vectors </span>\\{\\mathbf{r}\\}<span class="math"> in </span>S<span class="math"> are linearly independent, run the Gaussian elimination algorithm to extract the witness </span>\\mathbf{w}<span class="math"> from </span>S = \\{(\\mathbf{r}, \\mathbf{y}_{\\mathbf{r}})\\}$, otherwise abort.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The extractor runs in polynomial time as Step 2 runs in polynomial time, and the extractor executes Step 2 for at most <span class="math">8k / \\epsilon</span> times. Next, we argue that the extractor's success probability is nonnegligible. Since <span class="math">\\mathcal{A}</span> succeeds with probability at least <span class="math">\\epsilon</span>, with probability at least <span class="math">\\epsilon / 2</span> over the choice of <span class="math">(C_f, \\mathbf{z}, y)</span>, the adversary passes the PCS evaluation protocol <span class="math">\\operatorname{Eval}(\\mathbf{gp}; C_f, \\mathbf{z}, y)</span> with probability at least <span class="math">\\epsilon / 2</span>. We denote by <span class="math">B</span> the event that the above happens.</p>

    <p class="text-gray-300">Conditioned on event <span class="math">B</span>, we first argue that with high probability, <span class="math">\\mathcal{E}</span> can add <span class="math">k</span> pairs to <span class="math">S</span>, and the <span class="math">\\mathbf{r}</span>'s in <span class="math">S</span> are linearly-independent. Note that for each run of PCS evaluation (with a freshly sampled vector <span class="math">\\mathbf{r}</span>), the probability that the extractor adds a pair to <span class="math">S</span> is at least <span class="math">\\epsilon / 2 - \\mathrm{negl}(\\lambda) \\geq \\epsilon / 4</span>. This is because <span class="math">\\mathcal{A}</span> passes the checks with probability at least <span class="math">\\epsilon / 2</span>, and thus with probability at least <span class="math">\\epsilon / 2 - \\mathrm{negl}(\\lambda)</span>, <span class="math">\\mathcal{A}</span> passes all the checks, and the PCS extractor succeeds. Therefore, by Chernoff bound, the probability that <span class="math">\\mathcal{E}</span> adds <span class="math">k</span> pairs to <span class="math">S</span> within <span class="math">8k / \\epsilon</span> runs of Step 2 is at least <span class="math">1 - \\exp(-k / 8)</span>. Moreover, as noted by Lemma 2 of [50], the random vectors <span class="math">\\{\\mathbf{r}\\}</span> in set <span class="math">S</span> are linearly independent with overwhelming probability.</p>

    <p class="text-gray-300">Next, still conditioned on event <span class="math">B</span>, we argue that with probability <span class="math">1 - \\mathrm{negl}(\\lambda)</span>, there exists a coefficient matrix <span class="math">\\mathbf{w} \\in \\mathbb{F}^{k \\times m}</span> that is consistent with the commitment <span class="math">C_f</span>, such that <span class="math">\\langle \\mathbf{w}, \\mathbf{t}_0 \\otimes \\mathbf{t}_1 \\rangle = y</span> (i.e. the evaluation is correct) and <span class="math">\\mathbf{y}_{\\mathbf{r}} = \\sum_{i=1}^{k} \\mathbf{r}_i \\cdot \\mathbf{w}_i</span> for every pair <span class="math">(\\mathbf{r}, \\mathbf{y}_{\\mathbf{r}})</span> in set <span class="math">S</span>. Let <span class="math">W&#x27; \\in \\mathbb{F}^{k \\times M}</span> be the matrix extracted by <span class="math">\\mathcal{E}</span> at Step 1, note that <span class="math">W&#x27;</span> commits to <span class="math">C_f</span>. Consider each run of PCS evaluation where the extractor adds a pair <span class="math">(\\mathbf{r}, \\mathbf{y}_{\\mathbf{r}})</span> to <span class="math">S</span>. Since <span class="math">C_f, C_{p_{\\mathbf{r}}}</span> are binding, and the SNARK proofs verify, it holds that w.h.p over the choice of <span class="math">I</span>, <span class="math">E(\\mathbf{y}_{\\mathbf{r}})</span> is close to <span class="math">\\sum_{i=1}^{k} \\mathbf{r}_i \\cdot W_i&#x27;</span>. By Lemma 1 in [50], w.h.p. over the choice of <span class="math">\\mathbf{r}</span>, it also holds that <span class="math">W_i&#x27;</span> is close to a codeword for all <span class="math">i \\in [k]</span>. Therefore, there exists a matrix <span class="math">\\mathbf{w} \\in \\mathbb{F}^{k \\times m}</span> such that (i) <span class="math">W_i&#x27;</span> is close to <span class="math">E(\\mathbf{w}_i)</span> for all <span class="math">i \\in [k]</span>, and (ii) <span class="math">\\mathbf{y}_{\\mathbf{r}} = \\sum_{i=1}^{k} \\mathbf{r}_i \\cdot \\mathbf{w}_i</span>. Moreover, by the uniqueness of encoding, <span class="math">\\mathbf{w}</span> is identical for every challenge vector <span class="math">\\mathbf{r}</span> in set <span class="math">S</span>. Similarly, we can argue that <span class="math">\\mathbf{y}_0 = \\sum_{i=1}^{k} \\mathbf{t}_{0,i} \\cdot \\mathbf{w}_i</span> and thus <span class="math">\\langle \\mathbf{w}, \\mathbf{t}_0 \\otimes \\mathbf{t}_1 \\rangle = y</span>.</p>

    <p class="text-gray-300">Given the above, we conclude that with high probability, it holds that (i) <span class="math">\\mathcal{E}</span> adds <span class="math">k</span> pairs to <span class="math">S</span> where the <span class="math">\\mathbf{r}</span>'s in <span class="math">S</span> are linearly independent; and (ii) there exists <span class="math">\\mathbf{w} \\in \\mathbb{F}^{k \\times m}</span> that is consistent with <span class="math">C_f</span> and <span class="math">\\langle \\mathbf{w}, \\mathbf{t}_0 \\otimes \\mathbf{t}_1 \\rangle = y</span> and <span class="math">\\mathbf{y}_{\\mathbf{r}} = \\sum_{i=1}^{k} \\mathbf{r}_i \\cdot \\mathbf{w}_i</span> for every pair <span class="math">(\\mathbf{r}, \\mathbf{y}_{\\mathbf{r}})</span> in set <span class="math">S</span>. In summary, conditioned on event <span class="math">B</span>, the extractor can extract the coefficient matrix <span class="math">\\mathbf{w}</span> via Gaussian elimination with high probability, which completes the proof.</p>

    <p class="text-gray-300">Theorem 7.2. When instantiating the outer SNARK with HyperPlonk+, the multilinear PCS in Figure 7 has committing and evaluation opening complexity <span class="math">O_{\\lambda}(n)</span>; the proof size and verifier time is <span class="math">O_{\\lambda}(\\log n)</span>.</p>

    <p class="text-gray-300">50</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">Fix <span class="math">k=\\Theta(\\lambda/\\log n)</span> and let <span class="math">m=n/k</span>. The committing algorithm takes <span class="math">O(n)</span> <span class="math">\\mathbb{F}</span>-ops to encode the coefficients <span class="math">\\mathbf{w}\\in\\mathbb{F}^{k\\times m}</span> to <span class="math">W\\in\\mathbb{F}^{k\\times M}</span>, <span class="math">O(n)</span> hashes to compute the column commitments, and an <span class="math">O(m)</span>-sized MSM to commit to the vector of column commitments. The total complexity is <span class="math">O_{\\lambda}(n)</span>.</p>

    <p class="text-gray-300">The evaluation proving mainly consists of the following steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>compute a HyperPlonk+ SNARK proof for the statement in Figure 8;</li>

      <li>compute a CP-SNARK proof between the commitment <span class="math">C_{f}</span> and the SNARK witness polynomial commitment with respect to a set <span class="math">I</span>.</li>

    </ul>

    <p class="text-gray-300">By the linear algorithm specified in Section 3.8.1, the CP-SNARK proof generation is dominated by a multi-group-exponentiations with size <span class="math">s</span>, where <span class="math">s</span> is the circuit size; similarly, the HyperPlonk+ SNARK proving is also dominated by a few multi-group-exponentiations with size <span class="math">s</span>. Next, we prove that the outer circuit complexity is <span class="math">s=O(m)</span>, Hence the evaluation opening complexity is also <span class="math">O_{\\lambda}(n)</span>.</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Lemma 7.3.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The number of constraints in the circuit in Figure 8 is $O(m)+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot O(k\\lambda)<span class="math">, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is the number of constraints for a hash instance.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-72" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The circuit for computing <span class="math">\\mathbf{t}_{0}</span>, <span class="math">\\mathbf{t}_{1}</span> from <span class="math">\\mathbf{z}</span> takes <span class="math">O(k)</span> and <span class="math">O(m)</span> constraints, respectively; the circuit for encoding <span class="math">\\mathbf{y_{r}}</span>, <span class="math">\\mathbf{y}_{0}</span> takes <span class="math">O(m)</span> constraints; the extraction of <span class="math">\\mathbf{Y^{\\prime}_{r}}</span>, <span class="math">\\mathbf{Y^{\\prime}_{0}}</span> from <span class="math">\\{E(\\mathbf{y_{r}})_{j},E(\\mathbf{y}_{0})\\}_{j\\in I}</span>, takes $2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> lookup gates; the computation of </span>\\mathbf{Y^{\\prime}_{r}}<span class="math">, </span>\\mathbf{Y^{\\prime}_{0}}<span class="math"> takes </span>O(k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> constraints; the computation of </span>y<span class="math"> takes </span>O(m)<span class="math"> constraints; the computation of hashes </span>\\{h_{i}\\}<span class="math"> takes </span>k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(k\\lambda)<span class="math"> hash gadgets as </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\Theta(\\lambda)<span class="math">, thus the number of constraints is </span>O(m)+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot O(k\\lambda)$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The evaluation verifier checks the the CP-SNARK proof <span class="math">\\pi_{o}</span> which takes time <span class="math">O_{\\lambda}(\\log n)</span>.</p>

    <p class="text-gray-300">The evaluation proof consists of a single CP-SNARK proof <span class="math">\\pi_{o}</span>. As noted by Remark 7.1, the proof size is no more than that of a single HyperPlonk+ proof for circuit size <span class="math">s=O(m)</span>. In summary, the proof size is <span class="math">O_{\\lambda}(\\log n)</span>. ∎</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Remark 7.2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We stress that the CP-SNARK proving time (between <span class="math">C_{f}</span> and the SNARK witness) for set <span class="math">I</span> is independent of the size of <span class="math">I</span>, as the complexity of the special batching algorithm in Section 3.8.1 is independent of the number of evaluations. This is highly important because $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ can be as large as thousands in practice.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-74" class="text-base font-medium mt-4">Remark 7.3.</h6>

    <p class="text-gray-300">If we instantiate the linear code with the generalized Spielman code proposed in <em>[80]</em>, and instantiate the outer SNARK with vanilla HyperPlonk+, for <span class="math">128</span>-bit security and <span class="math">\\mu=30</span>, the outer circuit size is approximately <span class="math">2^{26}</span>, thus the proof is less than <span class="math">10</span> KBs.</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Remark 7.4.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In practice, to minimize the outer circuit complexity, we choose <span class="math">k</span> such that $2\\cdot\\ell(n/k)=k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span>\\ell(n/k)<span class="math"> is the circuit size for encoding a message with length </span>n/k<span class="math">. Note that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1568<span class="math"> for </span>128<span class="math">-bit security and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=980<span class="math"> for </span>80$-bit security.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-76" class="text-base font-medium mt-4">Remark 7.5.</h6>

    <p class="text-gray-300">In contrast with Orion, Orion+ requires using a pairing-friendly field. We leave the construction of linear-time PCS with succinct proofs/verifier that supports arbitrary fields as future work.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Conclusions and open problems</p>

    <p class="text-gray-300">We presented a SNARK with a fast prover that is an adaption of Plonk to the boolean hypercube. We also present Orion+, a significantly improved multi-linear commitment scheme with short proofs and fully-linear prover time. There are several open questions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Higher degree shifts: We show how to build a generator for the boolean hypercube that enables a next function that shifts points in the hypercube by 1. This is critical for building a lookup protocol. In some versions of the Halo 2 arithmetization, the proof system accesses machine states from more than the previous step. To implement this, we need higher degree shifts. This can be done by composing the next function multiple times, but this has an exponential blow-up in verifier time. Implementing higher degree next functions efficiently remains an open problem.</li>

      <li>Better codes and hash functions for Orion+: The utility of Orion+ for smaller polynomials is limited by the use of recursion. Only for large multilinear polynomials (approximately with more than 24 variables), does the recursive circuit size become less than the original polynomial size. The keys to improving this are linear codes with better distance and more efficient and circuit-friendly hash functions.</li>

      <li>Automatic custom gate design: HyperPlonk+ supports high-degree custom gates efficiently. Currently, designing suitable custom gates for specific applications is a task left to the circuit designer. It remains an open problem to have a more principled approach that automates and optimizes the design of the custom gates for any given application.</li>

      <li>Linear-time permutation argument for small fields: In Section 3.6 we present a permutation argument with good soundness even for non-exponential fields. The argument unfortunately only has quasi-linear prover time. An important open question is whether there exists a permutation argument or a multi-set argument with linear prover time and optimal soundness.</li>

    </ul>

    <h4 id="sec-77" class="text-lg font-semibold mt-6">Acknowledgments.</h4>

    <p class="text-gray-300">We want to thank Ben Fisch and Alex Oezdemir for helpful discussions and Tiancheng Xie for answering many questions regarding Orion and Virgo. We want to thank Alessandro Chiesa for bringing the permutation check soundness question as well a connection to PCPs to our attention. Finally, we thank Srinath Setty for suggesting improvements to our evaluation section. This work was partially funded by NSF, DARPA, the Simons Foundation, UBRI, and NTT Research. Opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of DARPA.</p>

    <h2 id="sec-78" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] A. Aly, T. Ashur, E. Ben-Sasson, S. Dhooghe, and A. Szepieniec. Design of symmetric-key primitives for advanced cryptographic protocols. IACR Trans. Symm. Cryptol., 2020(3):1–45, 2020.</li>

      <li>[2] S. Ames, C. Hazay, Y. Ishai, and M. Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In B. M. Thuraisingham, D. Evans, T. Malkin, and D. Xu, editors, ACM CCS 2017, pages 2087–2104. ACM Press, Oct. / Nov. 2017.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[3] D. F. Aranha, E. M. Bennedsen, M. Campanelli, C. Ganesh, C. Orlandi, and A. Takahashi. ECLIPSE: Enhanced compiling method for pedersen-committed zkSNARK engines. Cryptology ePrint Archive, Report 2021/934, 2021. https://eprint.iacr.org/2021/934.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[4] arkworks contributors. arkworks zksnark ecosystem, 2022.</li>

      <li>[5] T. Attema, S. Fehr, and M. Klooß. Fiat-shamir transformation of multi-round interactive proofs. Cryptology ePrint Archive, Report 2021/1377, 2021. https://eprint.iacr.org/2021/1377.</li>

      <li>[6] L. Babai and S. Moran. Arthur-merlin games: A randomized proof system, and a hierarchy of complexity classes. J. Comput. Syst. Sci., 36(2):254–276, 1988.</li>

      <li>[7] M. Barbara, L. Grassi, D. Khovratovich, R. Lueftenegger, C. Rechberger, M. Schofnegger, and R. Walch. Reinforced concrete: Fast hash function for zero knowledge proofs and verifiable computation. Cryptology ePrint Archive, Report 2021/1038, 2021. https://eprint.iacr.org/2021/1038.</li>

      <li>[8] S. Bayer and J. Groth. Efficient zero-knowledge argument for correctness of a shuffle. In D. Pointcheval and T. Johansson, editors, EUROCRYPT 2012, volume 7237 of LNCS, pages 263–280. Springer, Heidelberg, Apr. 2012.</li>

      <li>[9] E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev. Fast reed-solomon interactive oracle proofs of proximity. In I. Chatzigiannakis, C. Kaklamanis, D. Marx, and D. Sannella, editors, ICALP 2018, volume 107 of LIPIcs, pages 14:1–14:17. Schloss Dagstuhl, July 2018.</li>

      <li>[10] E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev. Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046, 2018. https://eprint.iacr.org/2018/046.</li>

      <li>[11] E. Ben-Sasson, D. Carmon, S. Kopparty, and D. Levit. Elliptic curve fast fourier transform (ecfft) part ii: Scalable and transparent proofs over all large fields. 2022.</li>

      <li>[12] E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P. Ward. Aurora: Transparent succinct arguments for R1CS. In Y. Ishai and V. Rijmen, editors, EUROCRYPT 2019, Part I, volume 11476 of LNCS, pages 103–128. Springer, Heidelberg, May 2019.</li>

      <li>[13] E. Ben-Sasson, A. Chiesa, and N. Spooner. Interactive oracle proofs. In M. Hirt and A. D. Smith, editors, TCC 2016-B, Part II, volume 9986 of LNCS, pages 31–60. Springer, Heidelberg, Oct. / Nov. 2016.</li>

      <li>[14] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Scalable zero knowledge via cycles of elliptic curves. In J. A. Garay and R. Gennaro, editors, CRYPTO 2014, Part II, volume 8617 of LNCS, pages 276–294. Springer, Heidelberg, Aug. 2014.</li>

      <li>[15] E. Ben-Sasson and M. Sudan. Short pcps with polylog query complexity. SIAM Journal on Computing, 38(2):551–607, 2008.</li>

      <li>[16] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In S. Goldwasser, editor, ITCS 2012, pages 326–349. ACM, Jan. 2012.</li>

    </ul>

    <p class="text-gray-300">[17] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. Recursive composition and bootstrapping for SNARKs and proof-carrying data. Cryptology ePrint Archive, Report 2012/095, 2012. https://eprint.iacr.org/2012/095.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[18] N. Bitansky, A. Chiesa, Y. Ishai, R. Ostrovsky, and O. Paneth. Succinct non-interactive arguments via linear interactive proofs. In A. Sahai, editor, TCC 2013, volume 7785 of LNCS, pages 315–333. Springer, Heidelberg, Mar. 2013.</li>

      <li>[19] D. Boneh, J. Drake, B. Fisch, and A. Gabizon. Halo infinite: Proof-carrying data from additive polynomial commitments. In T. Malkin and C. Peikert, editors, CRYPTO 2021, Part I, volume 12825 of LNCS, pages 649–680, Virtual Event, Aug. 2021. Springer, Heidelberg.</li>

      <li>[20] J. Bootle, A. Cerulli, P. Chaidos, J. Groth, and C. Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In M. Fischlin and J.-S. Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 327–357. Springer, Heidelberg, May 2016.</li>

      <li>[21] J. Bootle, A. Cerulli, E. Ghadafi, J. Groth, M. Hajiabadi, and S. K. Jakobsen. Linear-time zero-knowledge proofs for arithmetic circuit satisfiability. In T. Takagi and T. Peyrin, editors, ASIACRYPT 2017, Part III, volume 10626 of LNCS, pages 336–365. Springer, Heidelberg, Dec. 2017.</li>

      <li>[22] J. Bootle, A. Chiesa, and J. Groth. Linear-time arguments with sublinear verification from tensor codes. In R. Pass and K. Pietrzak, editors, TCC 2020, Part II, volume 12551 of LNCS, pages 19–46. Springer, Heidelberg, Nov. 2020.</li>

      <li>[23] J. Bootle, A. Chiesa, Z. Guan, and S. Liu. Linear-time probabilistic proofs with sublinear verification for algebraic automata over every field. Cryptology ePrint Archive, Report 2022/1056, 2022. https://eprint.iacr.org/2022/1056.</li>

      <li>[24] J. Bootle, A. Chiesa, Y. Hu, and M. Orrù. Gemini: Elastic SNARKs for diverse environments. In O. Dunkelman and S. Dziembowski, editors, EUROCRYPT 2022, Part II, volume 13276 of LNCS, pages 427–457. Springer, Heidelberg, May / June 2022.</li>

      <li>[25] S. Bowe, A. Chiesa, M. Green, I. Miers, P. Mishra, and H. Wu. ZEXE: Enabling decentralized private computation. In 2020 IEEE Symposium on Security and Privacy, pages 947–964. IEEE Computer Society Press, May 2020.</li>

      <li>[26] S. Bowe, J. Grigg, and D. Hopwood. Halo: Recursive proof composition without a trusted setup. Cryptology ePrint Archive, Report 2019/1021, 2019. https://eprint.iacr.org/2019/1021.</li>

      <li>[27] B. Bünz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In 2018 IEEE Symposium on Security and Privacy, pages 315–334. IEEE Computer Society Press, May 2018.</li>

      <li>[28] B. Bünz, A. Chiesa, W. Lin, P. Mishra, and N. Spooner. Proof-carrying data without succinct arguments. In T. Malkin and C. Peikert, editors, CRYPTO 2021, Part I, volume 12825 of LNCS, pages 681–710, Virtual Event, Aug. 2021. Springer, Heidelberg.</li>

    </ul>

    <p class="text-gray-300">[29] B. Bünz, A. Chiesa, P. Mishra, and N. Spooner. Recursive proof composition from accumulation schemes. In R. Pass and K. Pietrzak, editors, TCC 2020, Part II, volume 12551 of LNCS, pages 1–18. Springer, Heidelberg, Nov. 2020.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[30] B. Bünz, B. Fisch, and A. Szepieniec. Transparent SNARKs from DARK compilers. In A. Canteaut and Y. Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 677–706. Springer, Heidelberg, May 2020.</li>

      <li>[31] M. Campanelli, A. Faonio, D. Fiore, A. Querol, and H. Rodríguez. Lunar: A toolbox for more efficient universal and updatable zkSNARKs and commit-and-prove extensions. In M. Tibouchi and H. Wang, editors, ASIACRYPT 2021, Part III, volume 13092 of LNCS, pages 3–33. Springer, Heidelberg, Dec. 2021.</li>

      <li>[32] M. Campanelli, D. Fiore, and A. Querol. LegoSNARK: Modular design and composition of succinct zero-knowledge proofs. In L. Cavallaro, J. Kinder, X. Wang, and J. Katz, editors, ACM CCS 2019, pages 2075–2092. ACM Press, Nov. 2019.</li>

      <li>[33] J. L. Carter and M. N. Wegman. Universal classes of hash functions. In Proceedings of the ninth annual ACM symposium on Theory of computing, pages 106–112, 1977.</li>

      <li>[34] A. Chiesa, M. A. Forbes, and N. Spooner. A zero knowledge sumcheck and its applications. Cryptology ePrint Archive, Report 2017/305, 2017. https://eprint.iacr.org/2017/305.</li>

      <li>[35] A. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. P. Ward. Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In A. Canteaut and Y. Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 738–768. Springer, Heidelberg, May 2020.</li>

      <li>[36] A. Chiesa, D. Ojha, and N. Spooner. Fractal: Post-quantum and transparent recursive proofs from holography. In A. Canteaut and Y. Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 769–793. Springer, Heidelberg, May 2020.</li>

      <li>[37] A. Chiesa and E. Tromer. Proof-carrying data and hearsay arguments from signature cards. In A. C.-C. Yao, editor, ICS 2010, pages 310–331. Tsinghua University Press, Jan. 2010.</li>

      <li>[38] A. R. Choudhuri, A. Jain, and Z. Jin. Non-interactive batch arguments for NP from standard assumptions. In T. Malkin and C. Peikert, editors, CRYPTO 2021, Part IV, volume 12828 of LNCS, pages 394–423, Virtual Event, Aug. 2021. Springer, Heidelberg.</li>

      <li>[39] A. R. Choudhuri, A. Jain, and Z. Jin. SNARGs for <span class="math">\\mathcal{P}</span> from LWE. Cryptology ePrint Archive, Report 2021/808, 2021. https://eprint.iacr.org/2021/808.</li>

      <li>[40] H. de Valence. Merlin transcript, 2022.</li>

      <li>[41] J. Drake. Plonk-style SNARKs without FFTs. link, 2019.</li>

      <li>[42] EspressoSystems. Specifications: Configurable asset privacy. Github, 2022.</li>

      <li>[43] A. Gabizon. Multiset checks in plonk and plookup. https://hackmd.io/@arielg/ByFgSDA7D.</li>

    </ul>

    <p class="text-gray-300">[44] A. Gabizon and Z. J. Williamson. plookup: A simplified polynomial protocol for lookup tables. Cryptology ePrint Archive, Report 2020/315, 2020. https://eprint.iacr.org/2020/315.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[45] A. Gabizon and Z. J. Williamson. Proposal: The turbo-plonk program syntax for specifying snark programs. https://docs.zkproof.org/pages/standards/accepted-workshop3/proposal-turbo_plonk.pdf, 2020.</li>

      <li>[46] A. Gabizon, Z. J. Williamson, and O. Ciobotaru. PLONK: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953, 2019. https://eprint.iacr.org/2019/953.</li>

      <li>[47] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct NIZKs without PCPs. In T. Johansson and P. Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 626–645. Springer, Heidelberg, May 2013.</li>

      <li>[48] C. Gentry and D. Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In L. Fortnow and S. P. Vadhan, editors, 43rd ACM STOC, pages 99–108. ACM Press, June 2011.</li>

      <li>[49] S. Goldwasser, S. Micali, and C. Rackoff. The knowledge complexity of interactive proof systems. SIAM Journal on Computing, 18(1):186–208, 1989.</li>

      <li>[50] A. Golovnev, J. Lee, S. Setty, J. Thaler, and R. S. Wahby. Brakedown: Linear-time and post-quantum SNARKs for R1CS. Cryptology ePrint Archive, Report 2021/1043, 2021. https://eprint.iacr.org/2021/1043.</li>

      <li>[51] L. Grassi, D. Khovratovich, C. Rechberger, A. Roy, and M. Schofnegger. Poseidon: A new hash function for zero-knowledge proof systems. In M. Bailey and R. Greenstadt, editors, USENIX Security 2021, pages 519–535. USENIX Association, Aug. 2021.</li>

      <li>[52] J. Groth. On the size of pairing-based non-interactive arguments. In M. Fischlin and J.-S. Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 305–326. Springer, Heidelberg, May 2016.</li>

      <li>[53] U. Haböck. A summary on the fri low degree test. Cryptology ePrint Archive, 2022.</li>

      <li>[54] D. Harvey and J. Van Der Hoeven. Polynomial multiplication over finite fields in time. Journal of the ACM (JACM), 69(2):1–40, 2022.</li>

      <li>[55] D. Hopwood, S. Bowe, T. Hornby, and N. Wilcox. Zcash protocol specification. version 2022.3.8. Online, 2022. https://zips.z.cash/protocol/protocol.pdf.</li>

      <li>[56] A. Kate, G. M. Zaverucha, and I. Goldberg. Constant-size commitments to polynomials and their applications. In M. Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 177–194. Springer, Heidelberg, Dec. 2010.</li>

      <li>[57] A. Kattis, K. Panarin, and A. Vlasov. RedShift: Transparent SNARKs from list polynomial commitment IOPs. Cryptology ePrint Archive, Report 2019/1400, 2019. https://eprint.iacr.org/2019/1400.</li>

    </ul>

    <p class="text-gray-300">[58] J. Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In 24th ACM STOC, pages 723–732. ACM Press, May 1992.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[59] A. Kothapalli, S. Setty, and I. Tzialla. Nova: Recursive zero-knowledge arguments from folding schemes. Cryptology ePrint Archive, Report 2021/370, 2021. https://eprint.iacr.org/2021/370.</li>

      <li>[60] J. Lee. Dory: Efficient, transparent arguments for generalised inner products and polynomial commitments. In K. Nissim and B. Waters, editors, TCC 2021, Part II, volume 13043 of LNCS, pages 1–34. Springer, Heidelberg, Nov. 2021.</li>

      <li>[61] C. Lund, L. Fortnow, H. Karloff, and N. Nisan. Algebraic methods for interactive proof systems. Journal of the ACM (JACM), 39(4):859–868, 1992.</li>

      <li>[62] M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn. Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings. In L. Cavallaro, J. Kinder, X. Wang, and J. Katz, editors, ACM CCS 2019, pages 2111–2128. ACM Press, Nov. 2019.</li>

      <li>[63] S. Masson, A. Sanso, and Z. Zhang. Bandersnatch: a fast elliptic curve built over the BLS12-381 scalar field. Cryptology ePrint Archive, Report 2021/1152, 2021. https://eprint.iacr.org/2021/1152.</li>

      <li>[64] S. Micali. CS proofs (extended abstracts). In 35th FOCS, pages 436–453. IEEE Computer Society Press, Nov. 1994.</li>

      <li>[65] C. Papamanthou, E. Shi, and R. Tamassia. Signatures of correct computation. In A. Sahai, editor, TCC 2013, volume 7785 of LNCS, pages 222–242. Springer, Heidelberg, Mar. 2013.</li>

      <li>[66] L. Pearson, J. Fitzgerald, H. Masip, M. Bellés-Muñoz, and J. L. Muñoz-Tapia. PlonKup: Reconciling PlonK with plookup. Cryptology ePrint Archive, Report 2022/086, 2022. https://eprint.iacr.org/2022/086.</li>

      <li>[67] J. Posen and A. A. Kattis. Caulk+: Table-independent lookup arguments. Cryptology ePrint Archive, Report 2022/957, 2022. https://eprint.iacr.org/2022/957.</li>

      <li>[68] S. Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In D. Micciancio and T. Ristenpart, editors, CRYPTO 2020, Part III, volume 12172 of LNCS, pages 704–737. Springer, Heidelberg, Aug. 2020.</li>

      <li>[69] S. Setty and J. Lee. Quarks: Quadruple-efficient transparent zkSNARKs. Cryptology ePrint Archive, Report 2020/1275, 2020. https://eprint.iacr.org/2020/1275.</li>

      <li>[70] D. R. Stinson. Universal hashing and authentication codes. Designs, Codes and Cryptography, 4(3):369–380, 1994.</li>

      <li>[71] E. System. Jellyfish jellyfish cryptographic library, 2022.</li>

      <li>[72] J. Thaler. Time-optimal interactive proofs for circuit evaluation. In R. Canetti and J. A. Garay, editors, CRYPTO 2013, Part II, volume 8043 of LNCS, pages 71–89. Springer, Heidelberg, Aug. 2013.</li>

    </ul>

    <p class="text-gray-300">[73] J. Thaler. Proofs, arguments, and zero-knowledge, 2020.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[74] P. Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In R. Canetti, editor, TCC 2008, volume 4948 of LNCS, pages 1–18. Springer, Heidelberg, Mar. 2008.</li>

      <li>[75] R. S. Wahby, I. Tzialla, a. shelat, J. Thaler, and M. Walfish. Doubly-efficient zkSNARKs without trusted setup. In 2018 IEEE Symposium on Security and Privacy, pages 926–943. IEEE Computer Society Press, May 2018.</li>

      <li>[76] B. Waters and D. J. Wu. Batch arguments for NP and more from standard bilinear group assumptions. Cryptology ePrint Archive, Report 2022/336, 2022. https://eprint.iacr.org/2022/336.</li>

      <li>[77] M. N. Wegman and J. L. Carter. New hash functions and their use in authentication and set equality. Journal of computer and system sciences, 22(3):265–279, 1981.</li>

      <li>[78] D. Wikström. Special soundness in the random oracle model. Cryptology ePrint Archive, Report 2021/1265, 2021. https://eprint.iacr.org/2021/1265.</li>

      <li>[79] T. Xie, J. Zhang, Y. Zhang, C. Papamanthou, and D. Song. Libra: Succinct zero-knowledge proofs with optimal prover computation. In A. Boldyreva and D. Micciancio, editors, CRYPTO 2019, Part III, volume 11694 of LNCS, pages 733–764. Springer, Heidelberg, Aug. 2019.</li>

      <li>[80] T. Xie, Y. Zhang, and D. Song. Orion: Zero knowledge proof with linear prover time. Cryptology ePrint Archive, Report 2022/1010, 2022. https://eprint.iacr.org/2022/1010.</li>

      <li>[81] A. L. Xiong, B. Chen, Z. Zhang, B. Bünz, B. Fisch, F. Krell, and P. Camacho. VERI-ZEXE: Decentralized private computation with universal setup. Cryptology ePrint Archive, Report 2022/802, 2022. https://eprint.iacr.org/2022/802.</li>

      <li>[82] A. Zapico, V. Buterin, D. Khovratovich, M. Maller, A. Nitulescu, and M. Simkin. Caulk: Lookup arguments in sublinear time. Cryptology ePrint Archive, Report 2022/621, 2022. https://eprint.iacr.org/2022/621.</li>

      <li>[83] Zcash. PLONKish arithmetization. link, 2022.</li>

      <li>[84] J. Zhang, T. Xie, Y. Zhang, and D. Song. Transparent polynomial delegation and its applications to zero knowledge proof. In 2020 IEEE Symposium on Security and Privacy, pages 859–876. IEEE Computer Society Press, May 2020.</li>

    </ul>

    <p class="text-gray-300">A Zero Knowledge PIOPs and zk-SNARKs</p>

    <p class="text-gray-300">In this Section, we describe a compiler that transforms a class of sumcheck-based multivariate PolyIOPs into ones that are zero knowledge. The general framework consists of two parts. The first part is to mask the oracle polynomials so that their oracle query answers do not reveal the information of the original polynomial; moreover, we require that the masking do not change evaluations over the boolean hypercube, thus the correctness of PIOPs still holds. The second part is making the underlying sumcheck PIOPs zero knowledge. For this we reuse the ZK sumchecks described in <em>[79]</em>.</p>

    <p class="text-gray-300">We note that in contrast with univariate PIOPs, there is a subtlety in compiling multivariate PIOPs: the zero-knowledge property is hard to achieve if the set of query points is highly structural. E.g., suppose <span class="math">f</span> is 2-variate and there are are 4 query points <span class="math">(r_{1},r_{2})</span>, <span class="math">(r_{1},r_{1})</span>, <span class="math">(r_{2},r_{1})</span>, <span class="math">(r_{2},r_{2})</span>. Though all of the 4 points are distinct, each dimension has at least 2 points that share the same value. This makes the adversary much easier to cancel out the masking randomness and obtain a correlation between the evaluations of <span class="math">f</span> on the 4 points. We resolve the issue by restricting the set of query points to be less structured. In particular, we require that there is at least one dimension where each point has a distinct value. We also slightly modify the underlying sumcheck protocols to satisfy the restriction while the soundness is not affected.</p>

    <p class="text-gray-300">The Section is organized as follows. We define zero knowledge PIOPs in Section A.1. In Section A.2, we describe a scheme masking the multivariate polynomials. Section A.3 reviews the ZK sumchecks in <em>[79]</em>. We describe the ZK compiler for PIOPs in Section A.4 and explain how to obtain a zk-SNARK from a zk-PIOP and a PCS in Section A.5.</p>

    <h3 id="sec-79" class="text-xl font-semibold mt-8">A.1 Definition</h3>

    <p class="text-gray-300">We follow <em>[35]</em> and define the (honest verifier) zero-knowledge property of PIOPs. Since the provers in sumcheck PIOPs also send field elements, we slightly adapt the definition in <em>[35]</em>.</p>

    <h6 id="sec-80" class="text-base font-medium mt-4">Definition A.1.</h6>

    <p class="text-gray-300">A PIOP <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> has perfect zero-knowledge with query bound <span class="math">t</span> and query checker <span class="math">C</span> if there is a PPT simulator <span class="math">\\mathcal{S}</span> such that for every field <span class="math">\\mathbb{F}</span>, index <span class="math">\\mathtt{i}</span>, instance <span class="math">\\mathtt{x}</span>, witness <span class="math">\\mathtt{w}</span>, and every <span class="math">(t,C)</span>-admissable verifier <span class="math">\\mathcal{V}^{*}</span>, the following transcripts are identically distributed:</p>

    <p class="text-gray-300"><span class="math">\\mathtt{View}\\left(\\mathcal{P}(\\mathbb{F},\\mathtt{i};\\mathtt{x};\\mathtt{w}),\\mathcal{V}^{<em>}\\right)\\approx\\mathcal{S}^{\\mathcal{V}^{</em>}}(\\mathbb{F},\\mathtt{i};\\mathtt{x})\\,.</span></p>

    <p class="text-gray-300">Here the view consists of <span class="math">\\mathcal{V}^{<em>}</span>’s randomness, the non-oracle messages sent by <span class="math">\\mathcal{P}</span>, and the list of answers to <span class="math">\\mathcal{V}^{</em>}</span>’s oracle queries. A verifier is <span class="math">(t,C)</span>-admissible if it makes no more than <span class="math">t</span> queries, and each query is accepted by the checker <span class="math">C</span>. We say that <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> is <em>honest-verifier-zero-knowlege</em> (HVZK) if there is a simulator for <span class="math">\\mathcal{V}</span>.</p>

    <h3 id="sec-81" class="text-xl font-semibold mt-8">A.2 Polynomial masking</h3>

    <h6 id="sec-82" class="text-base font-medium mt-4">Definition A.2.</h6>

    <p class="text-gray-300">A randomized algorithm <span class="math">\\mathtt{msk}</span> is a <span class="math">(t,C,\\mu)</span>-masking if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for every <span class="math">d\\in\\mathbb{N}</span> and every polynomial <span class="math">f\\in\\mathcal{F}_{\\mu}^{(\\leq d)}</span>, the masked polynomial <span class="math">f^{<em>}\\xleftarrow{</em>}\\mathtt{msk}(f,t,C)</span> does not change evaluations over the boolean hypercube <span class="math">B_{\\mu}</span>;</li>

      <li>for every <span class="math">d\\in\\mathbb{N}</span> and every polynomials <span class="math">f\\in\\mathcal{F}_{\\mu}^{(\\leq d)}</span>, and every list of queries <span class="math">\\mathbf{q}:=(q_{1},\\ldots,q_{t})</span> that is accepted by the checker <span class="math">C</span>, let <span class="math">f^{<em>}\\xleftarrow{</em>}\\mathtt{msk}(f,t,C)</span>. It holds that <span class="math">\\left(f^{<em>}(q_{1}),\\ldots,f^{</em>}(q_{t})\\right)</span> is uniformly distributed over <span class="math">\\mathbb{F}^{t}</span>.</li>

    </ol>

    <p class="text-gray-300">Lemma A.1. There is a <span class="math">(t, C_{\\ell}, \\mu)</span>-masking algorithm <span class="math">\\mathsf{msk}(f, t, \\ell)</span> for every <span class="math">\\mu, t \\in \\mathbb{N}</span> and <span class="math">\\ell \\in [\\mu]</span>, where checker <span class="math">C_{\\ell}</span> accepts a list of queries <span class="math">(q_1, \\ldots, q_t)</span> if and only if <span class="math">b_{i,\\ell} \\notin \\{0, 1, b_{1,\\ell}, \\ldots, b_{i-1,\\ell}\\}</span> for every query <span class="math">q_i := (b_{i,1}, \\ldots, b_{i,\\mu}) \\in \\mathbb{F}^{\\mu}</span> (<span class="math">1 \\leq i \\leq t</span>). For any <span class="math">f \\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span> and <span class="math">\\ell \\in [\\mu]</span>, the degree of the masked polynomial <span class="math">f^* \\gets \\mathsf{msk}(f, t, \\ell)</span> is <span class="math">\\max(d, t + 1)</span>.</p>

    <p class="text-gray-300">Proof. Given a polynomial <span class="math">f \\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span>, query bound <span class="math">t</span>, and checker <span class="math">C_{\\ell}</span>, the algorithm does follow:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample a univariate polynomial <span class="math">R(X) \\coloneqq c_0 + c_1X + \\ldots + c_{t-1}X^{t-1}</span> where <span class="math">c_0, \\ldots, c_{t-1} \\stackrel{\\mathrm{s}}{\\leftarrow} \\mathbb{F}</span>.</li>

      <li>Output <span class="math">f^{*} \\coloneqq f + Z(X_{\\ell}) \\cdot R(X_{\\ell})</span>, where <span class="math">Z(X_{\\ell}) \\coloneqq X_{\\ell} \\cdot (1 - X_{\\ell})</span>.</li>

    </ul>

    <p class="text-gray-300">It is clear that <span class="math">f^{<em>}</span> has degree <span class="math">\\max(d, t + 1)</span>; <span class="math">f^{</em>}</span> does not change <span class="math">f</span>'s evaluations over <span class="math">B_{\\mu}</span> as <span class="math">Z</span> evaluates to zero over <span class="math">B_{\\mu}</span>. Next, we argue that <span class="math">\\mathbf{f}^{<em>} \\coloneqq (f^{</em>}(q_{1}), \\ldots, f^{*}(q_{t})) \\in \\mathbb{F}^{t}</span> is uniformly random. Denote query <span class="math">q_{i} \\coloneqq (b_{i,1}, \\ldots, b_{i,\\mu})</span> (<span class="math">1 \\leq i \\leq t</span>), we define <span class="math">\\mathbf{R}</span> to be</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{R} := \\left(Z (b_{1,\\ell}) \\cdot R (b_{1,\\ell}), \\ldots, Z (b_{t,\\ell}) \\cdot R (b_{t,\\ell})\\right).</span></div>

    <p class="text-gray-300">Since the queries satisfy <span class="math">b_{i,\\ell} \\notin \\{0,1\\}</span> for every <span class="math">i \\in [t]</span>, it holds that <span class="math">z_i := Z(b_{i,\\ell})</span> are non-zero and thus invertible. Moreover, since <span class="math">R</span> is a random univariate polynomial with degree <span class="math">t - 1</span> and <span class="math">\\{b_{1,\\ell}, \\ldots, b_{t,\\ell}\\}</span> are distinct, it holds that <span class="math">\\{R(b_{1,\\ell}), \\ldots, R(b_{t,\\ell})\\}</span> are uniformly random. Therefore <span class="math">\\mathbf{R}</span> is uniformly random, and thus <span class="math">\\mathbf{f}^* = \\mathbf{f} + \\mathbf{q}</span> is also uniformly random where <span class="math">\\mathbf{f} := (f(q_1), \\ldots, f(q_t))</span>.</p>

    <h2 id="sec-83" class="text-2xl font-bold">A.3 Zero knowledge SumCheck</h2>

    <p class="text-gray-300"><strong>Construction.</strong> Xie et al. [79] described an efficient ZK compiler for sumchecks. For reader's convenience, we adapt Construction 1 in [79] to a PIOP.</p>

    <p class="text-gray-300">Zero knowledge SumCheck PIOP <span class="math">\\langle \\mathcal{P}, \\mathcal{V} \\rangle</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input: polynomial <span class="math">f \\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span> and claimed sum <span class="math">H \\in \\mathbb{F}</span>.</li>

      <li><span class="math">\\mathcal{P}</span> samples a polynomial <span class="math">g := c_0 + g_1(\\mathbf{x}_1) + \\dots + g_\\mu(\\mathbf{x}_\\mu)</span> where <span class="math">g_i(\\mathbf{x}_i) := c_{i,1} \\mathbf{x}_i + \\dots + c_{i,d} \\mathbf{x}_i^d</span> and <span class="math">c_{i,1}, \\ldots, c_{i,d}</span> are uniformly random. <span class="math">\\mathcal{P}</span> sends oracle <span class="math">g</span> and a claimed sum <span class="math">G := \\sum_{\\mathbf{x} \\in B_\\mu} g(\\mathbf{x})</span>.</li>

      <li><span class="math">\\mathcal{V}</span> sends a challenge <span class="math">\\rho \\stackrel{\\mathrm{s}}{\\leftarrow} \\mathbb{F}^*</span>.</li>

      <li><span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> run SumCheck PIOP (Section 3.1) over polynomial <span class="math">f + \\rho g</span> and claimed sum <span class="math">H + \\rho G</span>.</li>

      <li><span class="math">\\mathcal{V}</span> queries <span class="math">g</span> and <span class="math">f</span> at point <span class="math">\\mathbf{r}</span> where <span class="math">\\mathbf{r} \\in \\mathbb{F}^{\\mu}</span> is the vector of sumcheck's challenges. <span class="math">\\mathcal{V}</span> then checks that <span class="math">f(\\mathbf{r}) + \\rho g(\\mathbf{r})</span> is consistent with the last message of the sumcheck.</li>

    </ul>

    <p class="text-gray-300">The completeness of the ZK PIOP holds obviously, it was shown in [34] that the PIOP also preserves soundness. The zero knowledge property is proved in [79] and we state it below.</p>

    <p class="text-gray-300">Lemma A.2 (Theorem 3 of [79]). For every field <span class="math">\\mathbb{F}</span>, verifier <span class="math">\\mathcal{V}^*</span> and multivariate polynomial <span class="math">f \\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span>, there is a simulator <span class="math">\\mathcal{S}_{sum}(\\mathbb{F}, \\mu, d, H)</span> that perfectly simulates <span class="math">\\mathcal{P}</span>'s oracle answers except for <span class="math">f(\\mathbf{r})</span>. Here <span class="math">H := \\sum_{\\mathbf{x} \\in B_{\\mu}} f(\\mathbf{x})</span>.</p>

    <p class="text-gray-300">60</p>

    <p class="text-gray-300">A.4 Zero knowledge compilation for SumCheck-based PIOPs</p>

    <p class="text-gray-300">A general description to the sumcheck-based PIOPs. The multivariate PIOPs considered in this paper can all be adapted to the following format.</p>

    <p class="text-gray-300">General sumcheck-based PIOPs:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Both <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> have oracle access to a public multilinear polynomial <span class="math">p_0 \\in \\mathcal{F}_{\\mu_0}^{(\\leq 1)}</span>.</li>

      <li>For every <span class="math">i \\in [k_1]</span>, <span class="math">\\mathcal{P}</span> sends a multilinear polynomial <span class="math">p_i \\in \\mathcal{F}_{\\mu_i}^{(\\leq 1)}</span>, and <span class="math">\\mathcal{V}</span> sends some random challenges. <span class="math">p_i</span> is a function of <span class="math">p_0, \\ldots, p_{i-1}</span> and verifier's previous challenges.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> sequentially run <span class="math">k_{2}</span> sumcheck PIOPs. The <span class="math">i</span>-th <span class="math">(1 \\leq i \\leq k_{2})</span> sumcheck is over a polynomial <span class="math">f_{i} := h_{i}(g_{1}, \\ldots, g_{c_{i}}) \\in \\mathcal{F}_{\\nu_{i}}^{(\\leq d_{i})}</span>, where <span class="math">h_{i}</span> is public information and each multilinear polynomial <span class="math">g_{j} \\in \\mathcal{F}_{\\nu_{i}}^{(\\leq 1)}</span> <span class="math">(1 \\leq j \\leq c_{i})</span> is $g_{j} := v_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{X}_{S} = \\mathbf{b}}<span class="math"> for some boolean vector </span>\\mathbf{b}<span class="math"> and some </span>v \\in \\{p_{1}, \\ldots, p_{k_{1}}\\}<span class="math">, that is, </span>g_{j}<span class="math"> is a partial polynomial of </span>v<span class="math"> where the variables in </span>S<span class="math"> are set to </span>\\mathbf{b}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">i \\in [k_2]</span>, <span class="math">\\mathcal{V}</span> queries a random point <span class="math">\\mathbf{r}_i \\in \\mathbb{F}^{\\nu_i}</span> to the oracle <span class="math">f_i</span>, where <span class="math">\\mathbf{r}_i</span> are the round challenges in the <span class="math">i</span>-th sumcheck. <span class="math">\\mathcal{V}</span> then checks that <span class="math">f_i(\\mathbf{r}_i)</span> is consistent with the last message in the <span class="math">i</span>-th sumcheck.</li>

      <li>For every <span class="math">i \\in [k_3]</span>, the verifier queries a point <span class="math">\\mathbf{c}_i \\in \\mathbb{F}^{\\mu_{j_i}}</span> to an oracle <span class="math">p_{j_i}</span> <span class="math">(0 \\leq j_i \\leq k_1)</span> and checks that the evaluation is <span class="math">y_i</span>. We emphasize that the evaluations <span class="math">\\{y_i\\}_{i \\in [k_3]}</span> can be efficiently and deterministically derived from <span class="math">\\{\\mathbf{c}_i, j_i\\}_{i \\in [k_3]}</span> and the public oracle <span class="math">p_0</span>.</li>

    </ol>

    <p class="text-gray-300">We note that the above description captures all of the multivariate PIOPs in this paper because</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for the case where <span class="math">\\mathcal{P}</span> sends an oracle <span class="math">f \\coloneqq h(g_1, \\ldots, g_c) \\in \\mathcal{F}_{\\mu}^{(\\leq d)}</span> for <span class="math">d &amp;gt; 1</span>, we can instead let <span class="math">\\mathcal{P}</span> send <span class="math">g_1, \\ldots, g_c \\in \\mathcal{F}_{\\mu}^{(\\leq 1)}</span> as <span class="math">h</span> is public information;</li>

      <li>for the case where <span class="math">\\mathcal{P}</span> sends multiple multilinear oracles in a round, we can merge the polynomials into a single polynomial;</li>

      <li>the PIOPs we consider are all finally reduced to one or more sumcheck PIOPs.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Construction. We present a generic framework that transforms any (sumcheck-based) multivariate PIOPs into zero knowledge PIOPs. For a PIOP <span class="math">\\langle \\mathcal{P},\\mathcal{V}\\rangle</span>, let <span class="math">\\big(\\{p_i\\}_{i\\in [0,k_1]},\\{f_i\\}_{i\\in [k_2]}\\big)</span> be the polynomials denoted in the above protocol. For every <span class="math">i\\in [k_1]</span>, let <span class="math">t_i\\in \\mathbb{N}</span> be the number of <span class="math">p_i</span>'s partial polynomials that appear in the sumcheck polynomials <span class="math">f_{1},\\ldots ,f_{k_{2}}</span>, and let <span class="math">t^{*}\\coloneqq \\max \\{t_{i}\\}_{i\\in [k_{1}]}</span>. For every <span class="math">i\\in [k_1]</span>, we assume that there exists index <span class="math">\\ell_{i}\\in [\\mu_{i}]</span> such that for every <span class="math">p_i</span>'s partial polynomial $v_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{X}_S = \\mathbf{b}}<span class="math"> that appears in some sumcheck (where </span>p_i<span class="math">&#x27;s variables in set </span>S<span class="math"> are boolean), it holds that </span>\\ell_{i}<span class="math"> is not in the set </span>S<span class="math">. Let </span>\\mathsf{msk}<span class="math"> be the masking algorithm described in Lemma A.1. The compiled zero knowledge PIOP </span>\\langle \\hat{\\mathcal{P}},\\hat{\\mathcal{V}}\\rangle$ works as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The ZK-compiler for sumcheck-based PIOPs:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">i \\in [k_1]</span>, <span class="math">\\hat{\\mathcal{P}}</span> sends an oracle <span class="math">[[p_i^<em>]]</span> where <span class="math">p_i^</em> \\stackrel{\\mathrm{s}}{\\leftarrow} \\mathsf{msk}(p_i, t_i, \\ell_i)</span>. <span class="math">\\hat{\\mathcal{V}}</span> sends the same challenges as <span class="math">\\mathcal{V}</span> does.</li>

    </ol>

    <p class="text-gray-300">61</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. <span class="math">\\hat{\\mathcal{P}}</span> and <span class="math">\\hat{\\mathcal{V}}</span> sequentially run <span class="math">k_{2}</span> zero knowledge sumcheck PIOPs (Section A.3). The <span class="math">i</span>-th (<span class="math">1 \\leq i \\leq k_{2}</span>) sumcheck is over the polynomial <span class="math">f_{i}^{<em>} := h_{i}(g_{1}^{</em>}, \\ldots, g_{c_{i}}^{<em>}) \\in \\mathcal{F}_{\\nu_{i}}^{(\\leq d_{i}t^{</em>})}</span>, where <span class="math">h_{i}</span> is the same as in <span class="math">\\langle \\mathcal{P}, \\mathcal{V} \\rangle</span>; each <span class="math">g_{j}^{<em>} \\in \\mathcal{F}_{\\nu_{i}}^{(\\leq t^{</em>})}</span> (<span class="math">1 \\leq j \\leq c_{i}</span>) is $g_{j}^{*} := v_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{X}_{S} = \\mathbf{b}}^{<em>}<span class="math"> for some boolean vector </span>\\mathbf{b}<span class="math"> and some </span>v^{</em>} \\in \\{p_{1}^{<em>}, \\ldots, p_{k_{1}}^{</em>}\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">i \\in [k_2]</span>, <span class="math">\\hat{\\mathcal{V}}</span> queries a random point <span class="math">\\mathbf{r}_i \\in \\mathbb{F}^{\\nu_i}</span> to the oracle <span class="math">f_i</span>, where <span class="math">\\mathbf{r}_i</span> are the round challenges in the <span class="math">i</span>-th ZK sumcheck. <span class="math">\\hat{\\mathcal{V}}</span> then checks that <span class="math">f_i(\\mathbf{r}_i)</span> is consistent with the last message of the <span class="math">i</span>-th ZK sumcheck. We emphasize a slight modification over the original PIOP <span class="math">\\langle \\mathcal{P}, \\mathcal{V} \\rangle</span>: in the <span class="math">i</span>-th sumcheck, <span class="math">\\hat{\\mathcal{V}}</span> samples each round challenge <span class="math">\\mathbf{r}_{i,j}</span> (<span class="math">1 \\leq j \\leq \\mu_i</span>) in the set <span class="math">\\mathbb{F} \\setminus \\{0, 1, \\mathbf{r}_{1,j}, \\ldots, \\mathbf{r}_{i-1,j}\\}</span> rather than in <span class="math">\\mathbb{F}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\hat{\\mathcal{V}}</span> simulates <span class="math">\\mathcal{V}</span>, i.e., for all <span class="math">i \\in [k_3]</span>, queries points <span class="math">\\mathbf{c}_i</span> to oracle <span class="math">p_{j_i}^*</span> and checks the evaluation.</li>

    </ol>

    <p class="text-gray-300"><strong>Theorem A.3.</strong> Given any PIOP <span class="math">\\langle \\mathcal{P},\\mathcal{V}\\rangle</span> for some relation over the boolean hypercube, the compiled PIOP <span class="math">\\langle \\hat{\\mathcal{P}},\\hat{\\mathcal{V}}\\rangle</span> is HVZK. Moreover, <span class="math">\\langle \\hat{\\mathcal{P}},\\hat{\\mathcal{V}}\\rangle</span> preserves perfect completeness and negligible soundness.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Completeness. Completeness holds because the sumcheck relations are over boolean hypercubes and the masked polynomials' evaluations do not change over the boolean hypercubes by the property of msk.</p>

    <p class="text-gray-300"><strong>Soundness.</strong> Compared to the sumchecks in <span class="math">\\langle \\mathcal{P},\\mathcal{V}\\rangle</span>, the following changes of the sumchecks in <span class="math">\\langle \\hat{\\mathcal{P}},\\hat{\\mathcal{V}}\\rangle</span> affect soundness error:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The degrees of the sumcheck polynomials are increased by a factor <span class="math">t^*</span>.</li>

      <li>The challenge space of <span class="math">j</span>-th round in the <span class="math">i</span>-th (<span class="math">1 \\leq i \\leq k_2</span>) sumcheck is <span class="math">\\mathbb{F} \\setminus \\{0, 1, \\mathbf{r}_{1,j}, \\ldots, \\mathbf{r}_{i-1,j}\\}</span> rather than <span class="math">\\mathbb{F}</span>.</li>

      <li>The sumcheck protocols are replaced with ZK sumchecks.</li>

    </ol>

    <p class="text-gray-300">Since <span class="math">t^*</span> and <span class="math">k_2</span> are constants and ZK sumchecks preserves soundness [34], the compiled protocol preserves negligible soundness.</p>

    <p class="text-gray-300"><strong>HVZK.</strong> We describe the simulator as follows.</p>

    <p class="text-gray-300">The simulator <span class="math">\\mathcal{S}^{\\hat{\\mathcal{V}}}(\\mathbb{F},\\mathfrak{i};\\mathbb{x})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Honestly generate the public polynomial <span class="math">p_0 \\in \\mathcal{F}_{\\mu_0}^{(\\leq 1)}</span>.</li>

      <li>Pick arbitrary polynomial <span class="math">\\{\\tilde{p}_i\\}_{i\\in [k_1]}</span> conditioned on that the sumcheck relations over <span class="math">f_{1},\\ldots ,f_{k_{2}}</span> hold. Send <span class="math">\\hat{\\mathcal{V}}</span> polynomials <span class="math">\\{\\tilde{p}_i^<em>\\}_{i\\in [k_1]}</span> where <span class="math">\\tilde{p}_i^</em>\\stackrel {\\mathrm{i}}{\\leftarrow}\\mathsf{msk}(\\tilde{p}_i,t_i,\\ell_i)</span>, obtain from <span class="math">\\hat{\\mathcal{V}}</span> the challenges in the first <span class="math">k_{1}</span> rounds.</li>

      <li>Run the next <span class="math">k_{2}</span> ZK sumcheck PIOPs using <span class="math">p_0</span> and the sampled polynomials <span class="math">\\{\\tilde{p}_i^*\\}_{i\\in [k_1]}</span>.</li>

      <li>For every <span class="math">i \\in [k_2]</span>, answer query <span class="math">f_i^<em>(\\mathbf{r}_i)</span> honestly using <span class="math">\\{\\tilde{p}_i^</em>\\}_{i \\in [k_1]}</span>.</li>

      <li>For every <span class="math">i \\in [k_3]</span>, answer query <span class="math">\\mathbf{c}_i</span> with value <span class="math">y_i</span>, where <span class="math">\\{y_i\\}_{i \\in [k_3]}</span> are deterministically derived from <span class="math">\\{\\mathbf{c}_i, j_i\\}_{i \\in [k_3]}</span> and the public polynomial <span class="math">p_0</span>.</li>

    </ol>

    <p class="text-gray-300">Next we show that <span class="math">\\mathcal{S}^{\\hat{\\mathcal{V}}}(\\mathbb{F},\\mathfrak{i};\\mathbb{x})\\approx \\mathrm{View}(\\hat{\\mathcal{P}} (\\mathbb{F},\\mathfrak{i};\\mathbb{x};\\mathbb{w}),\\hat{\\mathcal{V}})</span>. We set <span class="math">H_0\\coloneqq \\mathcal{S}^{\\hat{\\mathcal{V}}}(\\mathbb{F},\\mathfrak{i};\\mathbb{x})</span> and consider following hybrid games.</p>

    <p class="text-gray-300">62</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game <span class="math">H_{1}</span>: identical to <span class="math">H_{0}</span> except that step 3 is replaced with the ZK sumcheck simulator’s output. We note that <span class="math">H_{1} \\approx H_{0}</span> by the ZK property of the ZK sumchecks.</li>

      <li>Game <span class="math">H_{2}</span>: identical to <span class="math">H_{1}</span> except that the queries in step 4 are answered with random values. (Note that <span class="math">f_{i}^{<em>}(\\mathbf{r}_{i})</span>'s answer is a random value consistent with the last message of the <span class="math">i</span>-th sumcheck.) We argue that <span class="math">H_{2} \\approx H_{1}</span>: for every <span class="math">i \\in [k_{1}]</span>, the number of queries to oracle <span class="math">\\tilde{p}_{i}^{</em>} \\gets \\mathsf{msk}(\\tilde{p}_{i}, t_{i}, \\ell_{i})</span> is no more than <span class="math">t_{i}</span> and the <span class="math">\\ell_{i}</span>-th element in each of the query point are distinct and non-boolean, by Lemma A.1, the answers to the queries are uniformly random.</li>

      <li>Game <span class="math">H_{3}</span>: identical to <span class="math">H_{2}</span> except that the polynomials <span class="math">\\{\\tilde{p}_i\\}_{i\\in [k_1]}</span> in step 2 are replaced with <span class="math">\\{p_i\\}_{i\\in [k_1]}</span>. Note that <span class="math">H_{3} \\approx H_{2}</span> as the verifier’s view does not change at all.</li>

      <li>Game <span class="math">H_4 \\coloneqq \\text{View}(\\hat{\\mathcal{P}}(\\mathbb{F}, \\mathfrak{i}; \\mathbf{x}; \\mathbf{w}), \\hat{\\mathcal{V}})</span>: identical to <span class="math">H_3</span> except that the queries in step 4 are answered honestly and the ZK sumchecks are run honestly using <span class="math">p_0</span> and the sampled polynomials <span class="math">\\{p_i^*\\}_{i \\in [k_1]}</span>. With similar arguments (for <span class="math">H_1</span> and <span class="math">H_2</span>) we have <span class="math">H_4 \\approx H_3</span>.</li>

    </ul>

    <p class="text-gray-300">Given above, it holds that <span class="math">\\mathcal{S}^{\\hat{\\mathcal{V}}}(\\mathbb{F},\\mathfrak{i};\\mathbf{x})\\approx \\text{View} (\\hat{\\mathcal{P}} (\\mathbb{F},\\mathfrak{i};\\mathbf{x};\\mathbf{w}),\\hat{\\mathcal{V}})</span> and we complete the proof.</p>

    <h2 id="sec-84" class="text-2xl font-bold">A.5 zk-SNARKs from PIOPs</h2>

    <p class="text-gray-300">In the ZK PIOP of Section A.4, the masked polynomials sent by the prover are with the form <span class="math">f^{<em>} := f + Z(\\mathbf{x}_{\\ell}) \\cdot R(\\mathbf{x}_{\\ell})</span> where <span class="math">f \\in \\mathcal{F}_{\\mu}^{(\\leq 1)}</span> is multilinear and <span class="math">Z(\\mathbf{x}_{\\ell}) := \\mathbf{x}_{\\ell} \\cdot (1 - \\mathbf{x}_{\\ell})</span> is univariate and with degree <span class="math">t + 1</span>. It is shown in Theorem 10 of [19] that every additive and <span class="math">m</span>-spanning PCS can be compiled into a hiding PCS with a zero-knowledge Eval protocol, where <span class="math">m</span>-spanning means that commitments to polynomials of degree at most <span class="math">m</span> can already generate the commitment space <span class="math">\\mathbb{G}</span>. Thus we can construct a hiding PCS for <span class="math">f^{</em>}</span> with ZK evaluations from any additive and spanning polynomial commitment schemes (e.g., KZG and FRI). In particular, one instantiation is to set the commitment of <span class="math">f^{*}</span> to be <span class="math">(C_1, C_2) \\in \\mathbb{G}</span> where <span class="math">C_1</span> is the multilinear commitment to <span class="math">f</span> and <span class="math">C_2</span> is the univariate commitment to <span class="math">Z(X) \\cdot R(X)</span>, then apply the ZK transformation in [19].</p>

    <p class="text-gray-300">By combining Theorem 2.4 and Theorem A.3 we obtain the following corollary.</p>

    <p class="text-gray-300"><strong>Corollary A.4.</strong> Given any (non-hiding) additive and spanning polynomial commitment schemes, we can transform any (non-ZK) sumcheck-based PIOP (Section A.4) for relation <span class="math">\\mathcal{R}</span> to a zk-SNARK for <span class="math">\\mathcal{R}</span>.</p>

    <h2 id="sec-85" class="text-2xl font-bold">B The FRI-based multilinear polynomial commitment</h2>

    <p class="text-gray-300">In this Section, we construct a simple multilinear polynomial commitment scheme (PCS) from FRI [9]. Along the way, we also show how to generically transform a univariate PCS to a multilinear PCS using the tensor-product univariate PIOP from [24], which might be of independent interest. We note that Virgo [84, §3] describes another scheme constructing multilinear PCS from FRI. The main idea is to build the evaluation opening proof from a univariate sumcheck [12], which in turn uses FRI. However, the naive scheme incurs linear-time overhead for the verifier. Virgo [84, §3] resolves the issue by delegating the verifier computation to the prover. To this end, the prover needs to compute another GKR proof convincing that the linear-time verifier will accept the proof. This complicates the scheme and adds additional concrete overhead on prover time and proof size.</p>

    <p class="text-gray-300">We refer to <em>[9, 57]</em> and <em>[53]</em> for background of FRI low-degree testing and the approach to build univariate PCS from FRI. We note that the FRI-based univariate PCS supports batch opening. The evaluation opening protocol for multiple points on multiple polynomials invokes only a <em>single</em> call to the FRI protocol. Below we present a generic approach to transforming any univariate PCS into a multilinear PCS.</p>

    <h4 id="sec-86" class="text-lg font-semibold mt-6">Generic transformation from univariate PCS to multilinear PCS.</h4>

    <p class="text-gray-300">Bootle et al. built a <em>univariate</em> PIOP for the tensor-product relation in Section 5 of <em>[24]</em>. The tensor-product relation <span class="math">(\\mathtt{x},\\mathtt{w})=\\big{(}(\\mathbb{F},n,z_{1},\\ldots,z_{\\mu},y),\\mathbf{f}\\big{)}</span> states that <span class="math">\\mathbf{f}\\in\\mathbb{F}^{n}</span> satisfies that <span class="math">\\langle\\mathbf{f},\\otimes_{j}(1,z_{j})\\rangle=y</span>, where <span class="math">\\langle\\cdot,\\cdot\\rangle</span> denotes an inner product, and <span class="math">\\otimes</span> denotes a tensor product. The PIOP naturally implies an algorithm that transforms univariate polynomial commitment schemes to multilinear polynomial commitment schemes.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The commitment to a multilinear polynomial <span class="math">\\tilde{f}</span> with monomial coefficients, <span class="math">\\mathbf{f}</span> is the commitment to a univariate polynomial <span class="math">f</span> with the same coefficients.</li>

      <li>To open <span class="math">\\tilde{f}</span> at point <span class="math">(z_{1},\\ldots,z_{\\mu})</span> that evaluates <span class="math">y</span>, the prover and the verifier runs the univariate PIOP for the relation <span class="math">(\\mathtt{x},\\mathtt{w})=\\big{(}(\\mathbb{F},n,z_{1},\\ldots,z_{\\mu},y),\\mathbf{f}\\big{)}</span>, which reduces to a batch evaluation on a set of <span class="math">\\mu+1</span> univariate polynomials.</li>

    </ul>

    <p class="text-gray-300">We provide the concrete construction below. Let <span class="math">\\mathsf{PC}_{u}=(\\mathsf{Setup},\\mathsf{Commit},\\mathsf{BatchOpen},\\mathsf{BatchVfy})</span> be a univariate PCS, we construct a multilinear PCS <span class="math">\\mathsf{PC}_{m}</span> as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{PC}_{m}.\\mathsf{Setup}(1^{\\lambda},\\mu)\\to(\\mathsf{ck},\\mathsf{vk})</span>. On input security parameter <span class="math">\\lambda</span> and the number of variables <span class="math">\\mu</span>, output <span class="math">\\mathsf{PC}_{u}.\\mathsf{Setup}(1^{\\lambda},n)</span> where <span class="math">n=2^{\\mu}</span>.</li>

      <li><span class="math">\\mathsf{PC}_{m}.\\mathsf{Commit}(\\mathsf{ck},\\tilde{f})\\to c</span>. On input committer key <span class="math">\\mathsf{ck}</span>, multilinear polynomial <span class="math">\\tilde{f}</span> with coefficients <span class="math">\\mathbf{f}\\in\\mathbb{F}^{n}</span>, output <span class="math">\\mathsf{PC}_{u}.\\mathsf{Commit}(\\mathsf{ck},f)</span> where <span class="math">f</span> has the same coefficients as <span class="math">\\mathbf{f}</span>.</li>

      <li><span class="math">\\mathsf{PC}_{m}.\\mathsf{Open}(\\mathsf{ck},\\tilde{f},\\mathbf{z},y)\\to\\pi</span>. On input committer key <span class="math">\\mathsf{ck}</span>, multilinear polynomial <span class="math">\\tilde{f}</span>, point <span class="math">\\mathbf{z}\\in\\mathbb{F}^{\\mu}</span> and evaluation <span class="math">y\\in\\mathbb{F}</span>, the prover computes the proof as follows. Let <span class="math">f_{0}(X):=f(X)</span> be the committed univariate polynomial that has the same coefficients as <span class="math">\\tilde{f}</span>, consider the following PIOP for the tensor-product relation <span class="math">(\\mathtt{x},\\mathtt{w})=\\big{(}(\\mathbb{F},n,\\mathbf{z},y),\\mathbf{f}\\big{)}</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover sends the verifier univariate polynomials <span class="math">f_{1},\\ldots,f_{\\mu}</span> such that for all <span class="math">i\\in[\\mu]</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">f_{i}(X)=g_{i-1}(X)+\\mathbf{z}_{i}\\cdot h_{i-1}(X)\\,,</span></p>

    <p class="text-gray-300">where <span class="math">g_{i-1},h_{i-1}</span> satisfies that <span class="math">f_{i-1}(X)=g_{i-1}(X^{2})+X\\cdot h_{i-1}(X^{2})</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier samples a random challenge <span class="math">\\beta\\mathop{\\leftarrow\\mathop{\\scriptstyle\\parallel}}\\nolimits\\mathbb{F}^{\\times}</span> (where <span class="math">\\mathbb{F}^{\\times}</span> is a multiplicative subgroup of <span class="math">\\mathbb{F}</span>), and queries the oracles to obtain evaluations <span class="math">\\{a_{i},b_{i},c_{i}\\}_{i\\in\\{0,\\ldots,\\mu\\}}</span> such that</li>

    </ul>

    <p class="text-gray-300"><span class="math">a_{i}:=f_{i}(\\beta),\\qquad b_{i}:=f_{i}(-\\beta),\\qquad c_{i}:=f_{i+1}(\\beta^{2})\\,.</span></p>

    <p class="text-gray-300">Note that we skip <span class="math">f_{\\mu+1}(\\beta^{2})</span> and set <span class="math">c_{\\mu}:=y</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier checks that for all <span class="math">i\\in\\{0,\\ldots,\\mu\\}</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">c_{i}=\\frac{a_{i}+b_{i}}{2}+z_{i}\\cdot\\frac{a_{i}-b_{i}}{2\\beta}\\,.</span></p>

    <p class="text-gray-300">The opening proof <span class="math">\\pi</span> comprises (i) the univariate commitments to <span class="math">f_{1},\\ldots,f_{\\mu}</span>, (ii) the evaluations <span class="math">\\{a_{i},b_{i},c_{i}\\}_{i\\in\\{0,\\ldots,\\mu\\}}</span>, and (iii) the batch opening proof for polynomials <span class="math">(f_{0},f_{1},\\ldots,f_{\\mu})</span> at points <span class="math">(\\beta,-\\beta,\\beta^{2})</span>, where the random challenge <span class="math">\\beta</span> is derived via the Fiat-Shamir transform.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{PC}_{m}.\\mathsf{Vfy}(\\mathsf{vk},c,\\mathbf{z},y,\\pi)\\in\\{0,1\\}</span>. On input verifier key <span class="math">\\mathsf{vk}</span>, commitment <span class="math">c</span>, point <span class="math">\\mathbf{z}</span>, evaluation <span class="math">y</span>, and proof <span class="math">\\pi</span>, parse <span class="math">\\pi</span> to commitments <span class="math">(c_{1},\\ldots,c_{\\mu})</span>, evaluations <span class="math">\\mathsf{evals}</span>, and the batch opening proof <span class="math">\\pi^{<em>}</span>. Derive random challenge <span class="math">\\beta</span> via the Fiat-Shamir transform, perform the verification check in the above PIOP, and run <span class="math">\\mathsf{PC}_{u}.\\mathsf{BatchVfy}(\\mathsf{vk},(c,c_{1},\\ldots,c_{\\mu}),(\\beta,-\\beta,\\beta^{2}),\\mathsf{evals},\\pi^{</em>})</span>.</li>

    </ul>

    <p class="text-gray-300">Efficiency. We emphasize that when instantiated <span class="math">\\mathsf{PC}_{u}</span> with the FRI-based PCS, the multilinear polynomial commitment scheme has approximately the same complexity as that in the univariate setting. In particular, the committing phase takes only a Merkle root computation with tree depth <span class="math">\\log(n)</span>; the opening phase takes (i) <span class="math">\\mu</span> Merkle commitment computation where the <span class="math">i</span>-th (<span class="math">1\\leq i\\leq\\mu</span>) Merkle tree is with size <span class="math">2^{\\mu-i}</span>, and (ii) a univariate PCS batch evaluation protocol that is simply a <em>single</em> call to the FRI protocol.</p>

    <h2 id="sec-87" class="text-2xl font-bold">Appendix C Unrolled and optimized Hyperplonk</h2>

    <p class="text-gray-300">In Figure 9 and Figure 10, we present an optimized and batched version of HyperPlonk. The protocol batches the zerochecks and additionally batches all evaluations using <span class="math">\\mathcal{R}_{\\mathrm{BATCH}}</span>. Moreover, the sumcheck has complexity proportional to <span class="math">2^{\\mu}</span> rather than <span class="math">2^{\\mu+\\nu_{w}}</span> where <span class="math">\\nu_{w}</span> is the logarithm of the number of wires.</p>

    <p class="text-gray-300">Proof size analysis of the compiled protocol. We analyze the concrete proof size of the optimized PIOP. We analyze the proof size after compilation, i.e., where the prover sends commitments and performs evaluation proofs. The prover sends</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\ell_{w}+2</span> of <span class="math">\\mu</span>-variate multilinear polynomial commitments (<span class="math">\\ell_{w}</span> for the witness and <span class="math">2</span> for the product polynomial),</li>

      <li><span class="math">\\mu</span> of degree <span class="math">\\max(d-2,\\ell_{w}-1)</span> univariate polynomial commitments and <span class="math">2\\mu</span> claimed evaluations (in the first batched sumcheck),</li>

      <li><span class="math">8+2\\cdot\\ell_{w}+\\ell_{q}</span> claimed multilinear evaluations,</li>

      <li><span class="math">1</span> univariate evaluation of a batched univariate polynomial,</li>

      <li><span class="math">1</span> multilinear evaluation of a batched multilinear polynomial, and</li>

      <li><span class="math">2\\cdot(\\mu+\\lceil\\log_{2}(8+2\\cdot\\ell_{w}+\\ell_{q})\\rceil)</span> field elements for the sumcheck in the PIOP of <span class="math">\\mathcal{R}_{\\mathrm{BATCH}}</span>.</li>

    </ol>

    <p class="text-gray-300">For KZG-based commitments, the proof size is <span class="math">2+\\ell_{w}+\\mu</span> <span class="math">\\mathbb{G}_{1}</span> elements and <span class="math">4\\mu+10+2\\cdot\\ell_{w}+\\ell_{q}+2\\lceil\\log_{2}(8+2\\cdot\\ell_{w}+\\ell_{q})\\rceil</span> field elements. For the case where <span class="math">\\ell_{w}=\\ell_{q}=3</span>, using BLS12-381, where <span class="math">\\mathbb{G}_{1}</span> elements are <span class="math">48</span> bytes and field elements are <span class="math">32</span> bytes the proof size becomes <span class="math">176\\cdot\\mu+1168</span> bytes. For <span class="math">\\mu=20</span>, this is only <span class="math">4688</span> bytes.</p>

    <h2 id="sec-88" class="text-2xl font-bold">Appendix</h2>

    <p class="text-gray-300">Indexer. The indexer  <span class="math">\\mathcal{I}</span>  on an input circuit  <span class="math">C</span>  calls the permutation indexer  <span class="math">\\mathcal{I}_{\\mathrm{perm}}(\\sigma)</span> :  <span class="math">([s_{\\mathrm{id}}], [[s_{\\sigma}]]) \\gets \\mathcal{I}_{\\mathrm{perm}}(\\sigma)</span>  and computes the selector polynomial  <span class="math">q \\in \\mathcal{F}_{\\mu + \\nu_q}^{(\\leq 1)}</span> . Let  <span class="math">\\ell_w = 2^{\\nu_w}</span>  be the number of wires, denote by</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {S} _ {\\sigma} := \\left(\\left[ \\left[ s _ {\\sigma} (\\langle 0 \\rangle_ {\\nu_ {w}}, \\mathbf {X}) \\right] \\right], \\left[ \\left[ s _ {\\sigma} (\\langle 1 \\rangle_ {\\nu_ {w}}, \\mathbf {X}) \\right] \\right], \\dots , \\left[ \\left[ s _ {\\sigma} (\\langle \\ell_ {w} - 1 \\rangle_ {\\nu_ {w}}, \\mathbf {X}) \\right] \\right]\\right)</span></div>

    <p class="text-gray-300">the lists of partial polynomials of  <span class="math">s_{\\sigma}\\in \\mathcal{F}_{\\mu +\\nu_w}^{(\\leq 1)}</span>  . The indexer outputs ([[q]],  <span class="math">\\mathbf{S}_{\\sigma}</span></p>

    <p class="text-gray-300">We note that for all  <span class="math">i \\in [0, 2^{\\mu + \\nu_w})</span> ,  <span class="math">s_{\\mathrm{id}} \\in \\mathcal{F}_{\\mu + \\nu_w}^{(\\leq 1)}</span>  evaluates to  <span class="math">i</span>  at point  <span class="math">\\langle i \\rangle_{\\mu + \\nu_w} \\in B_{\\mu + \\nu_w}</span>  (where  <span class="math">\\langle i \\rangle_{\\mu + \\nu_w}</span>  denotes  <span class="math">\\mu + \\nu_w</span> -bit binary encoding of  <span class="math">i</span> ). Since multilinear extension is unique, it holds that  <span class="math">s_{\\mathrm{id}}(\\mathbf{X}) = \\sum_{i \\in [\\mu + \\nu_w]} 2^{i - 1} \\cdot \\mathbf{X}_i</span>  and thus one can evaluate  <span class="math">s_{\\mathrm{id}}</span>  at any points in time  <span class="math">O(\\mu + \\nu_w)</span> . Hence, there is no need for the indexer to output oracle  <span class="math">[[s_{\\mathrm{id}}]]</span> .</p>

    <p class="text-gray-300">Figure 9: The indexer of the optimized PIOP for  <span class="math">\\mathcal{R}_{\\mathrm{PLONK}}</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}(\\mathbf{gp},\\mathbf{i},p,w)</span>  and  <span class="math">\\mathcal{V}(\\mathbf{gp},p,[[q]],\\mathbf{S}_{\\sigma})</span>  run the following protocol.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  sends  <span class="math">\\mathcal{V}</span>  the witness oracles  <span class="math">\\mathbf{W} \\coloneqq \\left([w_0], [w_1], \\ldots, [w_{\\ell_w - 1}]]\\right)</span>  where  <span class="math">w_i \\coloneqq w(\\langle i \\rangle_{\\nu_w}, \\mathbf{X})</span>  is the  <span class="math">i</span> th  <span class="math">(0 \\leq i &amp;lt; \\ell_w)</span>  partial polynomial of the witness polynomial  <span class="math">w \\in \\mathcal{F}_{\\mu + \\nu_w}^{(\\leq 1)}</span> .</li>

      <li><span class="math">\\mathcal{V}</span>  sends input challenge  <span class="math">\\mathbf{r}_{IO} \\stackrel{\\mathrm{i}}{\\leftarrow} \\mathbb{F}^{\\nu}</span> ,  <span class="math">\\mathcal{R}_{\\mathrm{MSET}}^{1}</span>  challenge  <span class="math">\\gamma</span>  and  <span class="math">\\mathcal{R}_{\\mathrm{MSET}}^{2}</span>  challenges  <span class="math">\\beta</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  computes the product polynomial  <span class="math">\\tilde{v} \\in \\mathcal{F}_{\\mu + 1}^{(\\leq 1)}</span>  from  <span class="math">\\mathbf{W}, \\mathbf{S}_{\\sigma}, s_{\\mathrm{id}}</span>  and the challenges  <span class="math">\\beta, \\gamma</span>  (See Section 3.3), where for all  <span class="math">\\mathbf{x} \\in B_{\\mu}</span> ,</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\tilde {v} (0, \\mathbf {x}) = \\prod_ {i \\in [ 0, \\ell_ {w})} \\frac {\\mathbf {W} _ {i} (\\mathbf {x}) + \\beta \\cdot s _ {\\mathrm {i d}} (\\langle i \\rangle_ {\\nu_ {w}}, \\mathbf {x}) + \\gamma}{\\mathbf {W} _ {i} (\\mathbf {x}) + \\beta \\mathbf {S} _ {\\sigma , i} (\\mathbf {x}) + \\gamma}.</span></div>

    <p class="text-gray-300">Here  <span class="math">\\mathbf{W}_i, \\mathbf{S}_{\\sigma,i}</span>  denotes the  <span class="math">i</span> th polynomial in  <span class="math">\\mathbf{W}, \\mathbf{S}_{\\sigma}</span>  respectively.  <span class="math">\\mathcal{P}</span>  then sends oracles  <span class="math">[[ \\tilde{v}(0,\\mathbf{X}) ]], [[ \\tilde{v}(1,\\mathbf{X}) ]]</span>  to  <span class="math">\\mathcal{V}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier sends challenges  <span class="math">\\alpha_{1},\\alpha_{2}</span>  to batch three zerochecks, one resulting from the gate identity (see Section 4.2) and two from the productcheck (see Section 3.3). The two zerocheck virtual polynomials  <span class="math">Q_{1}(\\mathbf{X})\\in \\mathcal{F}_{\\mu}^{(\\leq 2)}</span> <span class="math">Q_{2}(\\mathbf{X})\\in \\mathcal{F}_{\\mu}^{(\\leq \\ell_{w} + 1)}</span>  for the productcheck are  <span class="math">Q_{1}(\\mathbf{X}):= \\tilde{v} (1,\\mathbf{X}) - \\tilde{v} (\\mathbf{X},0)\\tilde{v} (\\mathbf{X},1)</span>  and</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">Q _ {2} (\\mathbf {X}) := \\prod_ {i \\in [ 0, \\ell_ {w})} \\left(\\mathbf {W} _ {i} (\\mathbf {X}) + \\beta \\cdot s _ {\\mathrm {i d}} \\left(\\langle i \\rangle_ {\\nu_ {w}}, \\mathbf {X}\\right) + \\gamma\\right) - \\tilde {v} (0, \\mathbf {X}) \\prod_ {i \\in [ 0, \\ell_ {w})} \\left(\\mathbf {W} _ {i} (\\mathbf {X}) + \\beta \\mathbf {S} _ {\\sigma , i} (\\mathbf {X}) + \\gamma\\right).</span></div>

    <p class="text-gray-300">Note that  <span class="math">\\tilde{v} (\\mathbf{X},0),\\tilde{v} (\\mathbf{X},1)</span>  can be simulated given the oracle accesses to  <span class="math">[[ \\tilde{v} (0,\\mathbf{X}) ]],[[ \\tilde{v} (1,\\mathbf{X}) ]]</span>  , because for all  <span class="math">b\\in \\{0,1\\}</span> <span class="math">\\tilde{v} (\\mathbf{X},b) = (1 - \\mathbf{X}_1)\\cdot \\tilde{v} (0,\\mathbf{X}_2,\\dots ,\\mathbf{X}_\\mu ,b) + \\mathbf{X}_1\\cdot \\tilde{v} (1,\\mathbf{X}_2,\\dots ,\\mathbf{X}_\\mu ,b).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  send zerocheck challenge  <span class="math">r_Z\\stackrel {\\mathrm{i}}{\\leftarrow}\\mathbb{F}^\\mu</span></li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run sumcheck resulting from batched zerocheck. The sumcheck is of size  <span class="math">\\mu</span>  and has degree  <span class="math">\\max(d + 1, \\ell_w + 2)</span> . In each round, the prover sends an oracle to the univariate round polynomial as well as the claimed evaluation. The verifier delays querying the oracles. Similarly, in the last round, the verifier receives the claimed evaluations of all the multilinear polynomials. There are  <span class="math">8 + 2 \\cdot \\ell_w + \\ell_q</span>  total evaluations:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">1 + \\ell_w</span>  of  <span class="math">\\mathbf{W}</span>  ( <span class="math">\\ell_w</span>  from the batched sumcheck, one to check the outputs)</li>

      <li>3 of  <span class="math">\\tilde{v}(0, \\mathbf{X})</span>  and 4 of  <span class="math">\\tilde{v}(1, \\mathbf{X})</span>  from the product check</li>

      <li><span class="math">\\ell_q</span>  of  <span class="math">q</span>  (one per selector)</li>

      <li><span class="math">\\ell_w</span>  of  <span class="math">\\mathbf{S}_{\\sigma}</span>  from the product check (there is no need to query  <span class="math">s_{\\mathrm{id}}</span>  as  <span class="math">\\mathcal{V}</span>  can efficiently evaluate it).</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  uses the claimed evaluations to verify all previous protocols.</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run the univariate batch-opening algorithm from [19] to reduce all the round polynomial queries to one.</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run  <span class="math">\\mathcal{R}_{\\mathrm{BATCH}}</span>  on all evaluations using a degree 2,  <span class="math">\\mu + \\lceil \\log_2(8 + 2 \\cdot \\ell_w + \\ell_q) \\rceil</span>  round sum-check. In the protocol, the prover directly transmits the round polynomial using 2 field elements. The verifier can compute the third from the claimed sum.</li>

    </ol>

    <p class="text-gray-300">Figure 10: Optimized PIOP for  <span class="math">\\mathcal{R}_{\\mathrm{PLONK}}</span></p>`;
---

<BaseLayout title="HyperPlonk: Plonk with Linear-Time Prover and High-Degree Cu... (2022/1355)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/1355
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
