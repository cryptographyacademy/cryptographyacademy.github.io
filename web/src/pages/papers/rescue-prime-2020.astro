---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1143';
const CRAWLER = 'marker';
---

<BaseLayout title="Rescue-Prime Standard Specification (2020/1143)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Rescue-Prime: a Standard Specification (SoK)
      </h1>
      <p class="text-gray-400 mb-2">
        Alan Szepieniec, Tomer Ashur, Siemen Dhooghe
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; Full Version &middot; eprint 2020/1143
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">Converted with: {CRAWLER}</p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-1.1"
                class="hover:text-white">
                This Document</a>
            </li>
            <li>
              <a href="#sec-1.2"
                class="hover:text-white">
                Not in This Document</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">
            Specification of Rescue-Prime</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-2.1"
                class="hover:text-white">Parameters</a>
            </li>
            <li>
              <a href="#sec-2.2"
                class="hover:text-white">
                The Rescue-Prime Hash Function</a>
            </li>
            <li>
              <a href="#sec-2.3"
                class="hover:text-white">
                The Rescue-XLIX Permutation</a>
            </li>
            <li>
              <a href="#sec-2.4"
                class="hover:text-white">
                Selecting the Parameters</a>
            </li>
            <li>
              <a href="#sec-2.5"
                class="hover:text-white">
                Computing
                <span class="math">\alpha</span> and
                <span class="math">\alpha^&#123;-1&#125;</span></a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">
            Motivation for Changes from the Original
            Publication</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1"
                class="hover:text-white">
                Flipped Order of S-boxes</a>
            </li>
            <li>
              <a href="#sec-3.2"
                class="hover:text-white">
                Simplified Specification of Round Constants</a>
            </li>
            <li>
              <a href="#sec-3.3"
                class="hover:text-white">
                Reduced Security Margin</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">
            Deviations from the Rescue-Prime Standard
            Specification</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-4.1"
                class="hover:text-white">
                Small Fields and High Security</a>
            </li>
            <li>
              <a href="#sec-4.2"
                class="hover:text-white">
                Alternate MDS Matrices</a>
            </li>
            <li>
              <a href="#sec-4.3"
                class="hover:text-white">
                Omission of the Padding Rule</a>
            </li>
            <li>
              <a href="#sec-4.4"
                class="hover:text-white">
                Algebraically Dependent Round Constants</a>
            </li>
            <li>
              <a href="#sec-4.5"
                class="hover:text-white">
                Permitting
                <span class="math">n &gt; r_p</span></a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">Conclusion</a>
        </li>
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ol>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold mb-4">Abstract</h2>
      <p class="text-gray-300">
        This document provides a simple standard specification for the
        Rescue-Prime family of arithmetization-oriented hash functions.
      </p>
      <p class="text-gray-300 mt-2">
        <strong>Keywords:</strong> Arithmetization-Oriented &middot;
        Hash &middot; Rescue &middot; Standard
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold mb-4">1 &ensp; Introduction</h2>

      <p class="text-gray-300">
        A large number of projects are being developed and deployed
        that rely on the evaluation of a hash function inside of a
        cryptographic protocol such as a multiparty computation or a
        zero-knowledge proof system. The common strategy employed by
        both types of protocols is to represent a computation as a
        series of native finite field operations, a process called
        <em>arithmetization</em>. The complexity of the resulting
        protocol is linked to that of the arithmetic representation.
        Consequently, there is a high demand for hash functions with an
        efficient arithmetization &mdash; arithmetization-oriented hash
        functions.
      </p>

      <p class="text-gray-300 mt-4">
        We consider one particular family of arithmetization-oriented
        hash functions called Rescue, first introduced as part of the
        Marvellous universe
        [<a href="#ref-2" class="text-blue-400
          hover:text-blue-300">2</a>].
        In the time since the publication of the first electronic
        preprint, the paper&rsquo;s scope has been proven needlessly
        broad on two counts.
      </p>

      <ul class="list-disc list-inside text-gray-300 mt-4 space-y-2">
        <li>
          The advanced cryptographic protocols almost universally
          prefer prime fields over binary extension fields. As a
          result, the Rescue family has received much more attention
          than its binary field (and equally Marvellous) counterpart,
          Vision.
        </li>
        <li>
          The original paper specifies the Vision and Rescue hash
          functions in multiple steps in order to offer more
          flexibility with regards to the exact symmetric primitive
          required. However, the demand for arithmetization-oriented
          hash functions dwarfs the demand for alternative symmetric
          constructions with similar properties. In light of this
          imbalance, the flexibility is unnecessary and the stepwise
          derivation convoluted.
        </li>
      </ul>

      <p class="text-gray-300 mt-4">
        The complexity arising from this broad focus is compounded by
        the paper&rsquo;s target audience. It is written primarily for
        symmetric key cryptanalysts and cipher designers who must be
        led by the hand and in tiny steps to the understanding that
        their hard-won knowledge and intuition about traditional cipher
        design and analysis needs adaptation in order to apply to
        arithmetization-oriented ciphers. Rather than merely specifying
        the new proposals, the paper surveys the field in order to
        identify differences and pitfalls before proceeding to
        formulate (candidates for) sound design principles. When the
        ciphers finally are specified, this specification is
        overshadowed by an elaborate security analysis and performance
        benchmark justifying the proposals&rsquo; existence by driving
        home once again the alternate target for optimization &mdash;
        arithmetic complexity, not hardware or software complexity.
      </p>

      <p class="text-gray-300 mt-4">
        In the mist of this discussion, the instructions for
        implementers are lost.
      </p>

      <!-- 1.1 This Document -->

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8 mb-3">
        1.1 &ensp; This Document
      </h3>

      <p class="text-gray-300">
        This document specifies the arithmetization-oriented hash
        function Rescue-Prime, which is based on the original Rescue
        proposal
        [<a href="#ref-2" class="text-blue-400
          hover:text-blue-300">2</a>].
        The hash function is presented in an easy-to-digest format. The
        target audience consists of implementers rather than
        cryptanalysts. We can therefore omit discussions that distract
        from the matter at hand.
      </p>

      <p class="text-gray-300 mt-4">
        No scientific novelty is claimed. Rather, the contribution
        consists in making existing knowledge more accessible to a
        wider audience. This document should be read through the lens
        of a standards document or a systematization of knowledge.
      </p>

      <p class="text-gray-300 mt-4">
        That being said, we do make use of the opportunity to apply
        three simplifications to the construction. The motivation for
        these changes is segregated from the specification itself.
      </p>

      <ul class="list-disc list-inside text-gray-300 mt-4 space-y-2">
        <li>We change the derivation of round constants.</li>
        <li>We reduce the security margin from 100% to 50%.</li>
        <li>We flip the order of S-Boxes.</li>
      </ul>

      <p class="text-gray-300 mt-4">
        The resulting families of permutations and hash functions are
        technically dissimilar from their analogues in the original
        proposal. To draw a clear distinction between all objects, we
        introduce new names for the primitives specified here.
        <em>Rescue-XLIX</em> (pronounced Rescue Forty Nine) refers to
        the permutation that incorporates these changes.
        <em>Rescue-Prime</em> refers to the hash function obtained by
        instantiating the sponge construction with this permutation.
      </p>

      <!-- 1.2 Not in This Document -->

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8 mb-3">
        1.2 &ensp; Not in This Document
      </h3>

      <p class="text-gray-300">
        This document targets brevity and clarity. As a result, any
        discussion on the following questions is omitted.
      </p>

      <ul class="list-disc list-inside text-gray-300 mt-4 space-y-2">
        <li>
          The Vision and Rescue block ciphers, as well as the Vision
          hash function.
        </li>
        <li>How to arithmetize Rescue-Prime.</li>
        <li>
          Other symmetric-key primitives derived from Rescue-XLIX.
        </li>
        <li>Security arguments.</li>
      </ul>
    </section>

    <!-- ============================================================ -->
    <!-- 2. SPECIFICATION OF RESCUE-PRIME                             -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold mb-4">
        2 &ensp; Specification of Rescue-Prime
      </h2>

      <!-- 2.1 Parameters -->

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8 mb-3">
        2.1 &ensp; Parameters
      </h3>

      <p class="text-gray-300">
        A member of the Rescue-Prime family of hash functions is fully
        determined by a tuple of primary parameters
        <span class="math">(p, m, c_p, s)</span>.
      </p>

      <ul class="list-disc list-inside text-gray-300 mt-4 space-y-2">
        <li>
          <span class="math">p</span> determines the prime field
          <span class="math">\mathbb&#123;F&#125;_p</span> over which
          the operations are defined.
          <span class="math">p</span> must be a prime number with a
          binary expansion of at least 32 bits.
        </li>
        <li>
          <span class="math">m</span> determines the state width of
          the hash function. Phrased differently, in the evaluation of
          the function, the state is fully determined by
          <span class="math">m &gt; 1</span> field elements.
        </li>
        <li>
          <span class="math">c_p</span> is the <em>capacity</em> of
          the arithmetic sponge. The complement,
          <span class="math">r_p = m - c_p</span>, is the
          <em>rate</em> of the arithmetic sponge which determines the
          number of field elements that are absorbed between
          invocations of the Rescue-XLIX permutation.
        </li>
        <li>
          <span class="math">
            80 \le s \le 512
          </span> is the target security level, measured in bits.
        </li>
      </ul>

      <p class="text-gray-300 mt-4">
        Furthermore, there are parameters that depend entirely on the
        tuple of primary parameters but are included in the parameter
        list for convenience.
      </p>

      <ul class="list-disc list-inside text-gray-300 mt-4 space-y-2">
        <li>
          <span class="math">\alpha</span> and
          <span class="math">\alpha^&#123;-1&#125;</span> are the
          exponents in the power maps in the S-boxes. These parameters
          are set to guarantee that
          <span class="math">
            (x^&#123;\alpha&#125;)^&#123;\alpha^&#123;-1&#125;&#125;
            = x
          </span>
          for all
          <span class="math">
            x \in \mathbb&#123;F&#125;_p
          </span>.
        </li>
        <li>
          <span class="math">
            M \in \mathbb&#123;F&#125;_p^&#123;m \times m&#125;
          </span>
          is an
          <span class="math">m \times m</span> MDS matrix.
        </li>
        <li>
          <span class="math">N \in \mathbb&#123;N&#125;</span> is the
          number of rounds. A single Rescue-XLIX permutation consists
          of <span class="math">N</span> iterations of a simpler base
          permutation called a <em>round</em>.
        </li>
      </ul>

      <p class="text-gray-300 mt-4">
        Lastly, there are an additional
        <span class="math">2mN</span> field elements
        <span class="math">
          \&#123;C_i\&#125;_&#123;i=0&#125;^&#123;2mN-1&#125;
        </span>
        called the round constants. These serve to individualize each
        round of the permutation. We provide a way to derive them
        pseudorandomly in Section
        <a href="#sec-2.4" class="text-blue-400
          hover:text-blue-300">2.4</a>.
      </p>

      <!-- 2.2 The Rescue-Prime Hash Function -->

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8 mb-3">
        2.2 &ensp; The Rescue-Prime Hash Function
      </h3>

      <p class="text-gray-300">
        The Rescue-Prime hash function sends arbitrary-length sequences
        of field elements to
        <span class="math">r_p</span> field elements:
      </p>

      <div class="math-block">
        f_&#123;\mathbf&#123;R&#125;'&#125; :
        \mathbb&#123;F&#125;_p^* \to
        \mathbb&#123;F&#125;_p^&#123;r_p&#125;
      </div>

      <p class="text-gray-300 mt-4">
        It is obtained by employing the Rescue-XLIX permutation in a
        sponge construction. The resulting sponge function sends
        arbitrary-length sequences to infinite-length sequences of
        field elements:
      </p>

      <div class="math-block">
        f_&#123;\mathbf&#123;R&#125;'\text&#123;-sponge&#125;&#125; :
        \mathbb&#123;F&#125;_p^* \to
        \mathbb&#123;F&#125;_p^*
      </div>

      <p class="text-gray-300 mt-4">
        Rescue-Prime results from truncating this sponge function.
        Specifically, the first
        <span class="math">r_p</span> elements are retained and the
        rest is ignored.
      </p>

      <p class="text-gray-300 mt-4">
        The evaluation of the sponge function involves a permutation
        <span class="math">
          f_&#123;\mathbf&#123;R&#125;^&#123;\mathrm&#123;XLIX&#125;&#125;&#125; :
          \mathbb&#123;F&#125;_p^m \to
          \mathbb&#123;F&#125;_p^m
        </span>,
        a register of <span class="math">m</span> field elements
        called the <em>state</em>, and two phases. The state is
        initially set to the all-zero sequence
        <span class="math">
          \mathbf&#123;0&#125; \in
          \mathbb&#123;F&#125;_p^m
        </span>.
      </p>

      <p class="text-gray-300 mt-4">
        In the <em>absorbing phase</em>, the following iteration is
        repeated: the next
        <span class="math">r_p</span> elements from the input
        sequence are added to the
        <span class="math">r_p</span> top elements of the state,
        after which the permutation
        <span class="math">
          f_&#123;\mathbf&#123;R&#125;^&#123;\mathrm&#123;XLIX&#125;&#125;&#125;
        </span>
        is applied to the state. This loop runs until all the input
        elements have been absorbed.
      </p>

      <p class="text-gray-300 mt-4">
        In the <em>squeezing phase</em>, the top
        <span class="math">r_p</span> elements of the state are
        output. In theory, the permutation
        <span class="math">
          f_&#123;\mathbf&#123;R&#125;^&#123;\mathrm&#123;XLIX&#125;&#125;&#125;
        </span>
        can be applied to the state iteratively to produce an
        arbitrarily long sequence of output elements. However, this
        specification restricts the number of output elements to at
        most <span class="math">r_p</span>.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Padding.</strong> &ensp;
        A sponge function operating on arbitrary-length inputs requires
        a padding rule. To pad the input, append a single
        <span class="math">
          1 \in \mathbb&#123;F&#125;_p
        </span>
        and as many
        <span class="math">
          0 \in \mathbb&#123;F&#125;_p
        </span>
        elements as required to make the number of input elements a
        multiple of <span class="math">r_p</span>.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Truncation and generic security.</strong> &ensp;
        For some applications only
        <span class="math">n &lt; r_p</span> field elements are
        required. The most straightforward way to obtain them is to
        truncate the output of Rescue-Prime.
      </p>

      <p class="text-gray-300 mt-4">
        In general, the security proof for sponge constructions assumes
        that the underlying permutation is uniformly sampled from the
        set of all permutations on the state space. The discussion in
        Section
        <a href="#sec-2.3" class="text-blue-400
          hover:text-blue-300">2.3</a>
        is aimed to ensure that the Rescue-XLIX permutation is
        indistinguishable from a random permutation, thus satisfying
        the prerequisite for the security proof. When this is the case,
        a sponge-based hash function whose output is truncated to
        <span class="math">
          n \le r_p
        </span>
        field elements, generically affords at least
        <span class="math">
          \log_2 \sqrt&#123;p&#125; \cdot
          \min(n, c_p)
        </span>
        bits of security against finding collisions, preimages, and
        second-preimages.
      </p>

      <h4 class="text-lg font-semibold mt-6 mb-3">
        Algorithm 1: Rescue-Prime hash function (without padding)
      </h4>

      <pre><code class="language-python">def rescue_prime_hash(parameters, input_sequence):
    p, m, capacity, security_level, alpha, alphainv, N, MDS, \
        round_constants = parameters
    rate = m - capacity
    Fp = FiniteField(p)
    assert len(input_sequence) % rate == 0
    # initialize state to all zeros
    state = matrix([[Fp(0)] for i in range(m)])
    # absorbing
    absorb_index = 0
    while absorb_index &lt; len(input_sequence):
        for i in range(0, rate):
            state[i,0] += input_sequence[absorb_index]
            absorb_index += 1
        state = rescue_XLIX_permutation(parameters, state)
    # squeezing
    output_sequence = []
    for i in range(0, rate):
        output_sequence.append(state[i,0])
    return output_sequence</code></pre>

      <h4 class="text-lg font-semibold mt-6 mb-3">
        Algorithm 2: Rescue-Prime hash function, with padding
      </h4>

      <pre><code class="language-python">def rescue_prime_wrapper(parameters, input_sequence):
    p, m, capacity, security_level, alpha, alphainv, N, MDS, \
        round_constants = parameters
    rate = m - capacity
    Fp = FiniteField(p)
    padded_input = input_sequence + [Fp(1)]
    while len(padded_input) % rate != 0:
        padded_input.append(Fp(0))
    return rescue_prime_hash(parameters, padded_input)</code></pre>

      <!-- 2.3 The Rescue-XLIX Permutation -->

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8 mb-3">
        2.3 &ensp; The Rescue-XLIX Permutation
      </h3>

      <p class="text-gray-300">
        The Rescue-XLIX permutation
        <span class="math">
          f_&#123;\mathbf&#123;R&#125;^&#123;\mathrm&#123;XLIX&#125;&#125;&#125;
        </span>
        consists of <span class="math">N</span> iterations of the
        Rescue-XLIX round function. A single round consists of the
        following components:
      </p>

      <ul class="list-disc list-inside text-gray-300 mt-4 space-y-2">
        <li>
          <strong>S-box layer:</strong> apply the power map
          <span class="math">
            (\cdot)^&#123;\alpha&#125;
          </span>
          to each element of the state.
        </li>
        <li>
          <strong>Linear layer:</strong> apply the MDS matrix to the
          state, through matrix-vector multiplication.
        </li>
        <li>
          <strong>Constants injection:</strong> add the next
          <span class="math">m</span> constants from the list of
          round constants
          <span class="math">
            \&#123;C_i\&#125;_&#123;i=0&#125;^&#123;2mN-1&#125;
          </span>
          into the state.
        </li>
        <li>
          <strong>Inverse S-box layer:</strong> apply the inverse
          power map
          <span class="math">
            (\cdot)^&#123;\alpha^&#123;-1&#125;&#125;
          </span>
          to each element of the state.
        </li>
        <li>
          <strong>Linear layer:</strong> apply the MDS matrix to the
          state, through matrix-vector multiplication.
        </li>
        <li>
          <strong>Constants injection:</strong> add the next
          <span class="math">m</span> constants from the list of
          round constants
          <span class="math">
            \&#123;C_i\&#125;_&#123;i=0&#125;^&#123;2mN-1&#125;
          </span>
          into the state.
        </li>
      </ul>

      <h4 class="text-lg font-semibold mt-6 mb-3">
        Algorithm 3: The Rescue-XLIX permutation
      </h4>

      <pre><code class="language-python">def rescue_XLIX_permutation(parameters, state):
    p, m, capacity, security_level, alpha, alphainv, N, MDS, \
        round_constants = parameters
    Fp = state[0,0].parent()
    for i in range(N):
        # S-box
        for j in range(m):
            state[j,0] = state[j,0]^alpha
        # mds
        state = MDS * state
        # constants
        for j in range(m):
            state[j,0] += round_constants[i*2*m + j]
        # inverse S-box
        for j in range(m):
            state[j,0] = state[j,0]^alphainv
        # mds
        state = MDS * state
        # constants
        for j in range(m):
            state[j,0] += round_constants[i*2*m + m + j]
    return state</code></pre>

      <!-- 2.4 Selecting the Parameters -->

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8 mb-3">
        2.4 &ensp; Selecting the Parameters
      </h3>

      <p class="text-gray-300">
        <strong>Selecting the MDS Matrix.</strong> &ensp;
        Let <span class="math">g</span> be the smallest primitive
        element of
        <span class="math">\mathbb&#123;F&#125;_p</span>. Typically
        <span class="math">g = 2</span> is fine, but for some choices
        of <span class="math">p</span>,
        <span class="math">g</span> only generates a subgroup of
        <span class="math">
          \mathbb&#123;F&#125;_p \setminus \&#123;0\&#125;, \times
        </span>.
        To test whether a candidate
        <span class="math">g</span> is primitive, raise it to all
        factors of <span class="math">p - 1</span> and verify that the
        result is not 1.
      </p>

      <p class="text-gray-300 mt-4">
        Build a Vandermonde matrix
        <span class="math">
          V \in \mathbb&#123;F&#125;_p^&#123;m \times 2m&#125;
        </span>
        by setting the
        <span class="math">(i, j)</span>-th element to
        <span class="math">g^&#123;ij&#125;</span>, with both indices
        starting from zero. The rows of
        <span class="math">V</span> form a basis for a maximum
        distance separable (MDS) code. To obtain a generator matrix
        for this code, bring <span class="math">V</span> into reduced
        row-echelon form. At this point,
        <span class="math">V</span> has the shape
        <span class="math">
          (I \mid M^&#123;\mathsf&#123;T&#125;&#125;)
        </span>,
        where <span class="math">M</span> is the sought-after MDS
        matrix.
      </p>

      <h4 class="text-lg font-semibold mt-6 mb-3">
        Algorithm 4: Generating the MDS matrix
      </h4>

      <pre><code class="language-python">def get_mds_matrix(p, m):
    # get a primitive element
    Fp = FiniteField(p)
    g = Fp(2)
    while g.multiplicative_order() != p-1:
        g = g + 1
    # get a systematic generator matrix for the code
    V = matrix([[g^(i*j) for j in range(0, 2*m)]
                for i in range(0, m)])
    V_ech = V.echelon_form()
    # the MDS matrix is the transpose of the right half
    MDS = V_ech[:, m:].transpose()
    return MDS</code></pre>

      <p class="text-gray-300 mt-4">
        <strong>Selecting the Round Constants.</strong> &ensp;
        Let <span class="math">|p|</span> denote the number of bits
        in the binary representation of
        <span class="math">p</span>. Generate a string of
        <span class="math">
          \left(\lceil \tfrac&#123;|p|&#125;&#123;8&#125;
          \rceil + 1\right) \times 2mN
        </span>
        bytes using SHAKE-256 to expand the ASCII string
        <code>"Rescue-XLIX(%i,%i,%i,%i)"</code> where the
        <code>%i</code> wild cards represent the decimal expansions of
        the primary parameters
        <span class="math">p, m, c_p, s</span>, respectively.
      </p>

      <p class="text-gray-300 mt-4">
        Next, build the list of constants one by one. To do this,
        iterate over all <span class="math">2mN</span> chunks of
        <span class="math">
          \lceil \tfrac&#123;|p|&#125;&#123;8&#125; \rceil + 1
        </span>
        bytes from this string and cast the chunk into an integer
        using least significant byte first encoding. Reducing this
        integer modulo <span class="math">p</span> gives the next
        element of the list of constants.
      </p>

      <h4 class="text-lg font-semibold mt-6 mb-3">
        Algorithm 5: Generating the round constants
      </h4>

      <pre><code class="language-python">def get_round_constants(p, m, capacity, security_level, N):
    # generate pseudorandom bytes
    bytes_per_int = ceil(len(bin(p)[2:]) / 8) + 1
    num_bytes = bytes_per_int * 2 * m * N
    seed_string = "Rescue-XLIX(%i,%i,%i,%i)" % (
        p, m, capacity, security_level)
    byte_string = SHAKE256(
        bytes(seed_string, "ascii"), num_bytes)
    # process byte string in chunks
    round_constants = []
    Fp = FiniteField(p)
    for i in range(2*m*N):
        chunk = byte_string[
            bytes_per_int*i : bytes_per_int*(i+1)]
        integer = sum(
            256^j * ZZ(chunk[j])
            for j in range(len(chunk)))
        round_constants.append(Fp(integer % p))
    return round_constants</code></pre>

      <!-- 2.5 Computing alpha -->

      <h3 id="sec-2.5" class="text-xl font-semibold mt-8 mb-3">
        2.5 &ensp; Computing
        <span class="math">\alpha</span> and
        <span class="math">\alpha^&#123;-1&#125;</span>
      </h3>

      <p class="text-gray-300">
        The parameter <span class="math">\alpha</span> is defined as
        the smallest integer that is coprime with
        <span class="math">p - 1</span>, and
        <span class="math">\alpha^&#123;-1&#125;</span> is defined as
        its multiplicative inverse in the ring
        <span class="math">
          \mathbb&#123;Z&#125; / \langle p - 1 \rangle
        </span>.
        For fields satisfying
        <span class="math">
          \gcd(p - 1, 3) = 1
        </span>,
        we have
        <span class="math">\alpha = 3</span> and
        <span class="math">
          \alpha^&#123;-1&#125; = \tfrac&#123;2p - 1&#125;&#123;3&#125;
        </span>.
        However, for other fields
        <span class="math">\alpha</span> must be larger and
        <span class="math">\alpha^&#123;-1&#125;</span> must be
        computed with the extended Euclidean algorithm.
      </p>

      <h4 class="text-lg font-semibold mt-6 mb-3">
        Algorithm 6: Computing
        <span class="math">\alpha</span> and
        <span class="math">\alpha^&#123;-1&#125;</span>
      </h4>

      <pre><code class="language-python">def get_alphas(p):
    for alpha in range(3, p):
        if gcd(alpha, p-1) == 1:
            break
    g, alphainv, garbage = xgcd(alpha, p-1)
    return (alpha, (alphainv % (p-1)))</code></pre>

      <p class="text-gray-300 mt-4">
        <strong>Choosing the Number of Rounds.</strong> &ensp;
        For <span class="math">|p| \ge 32</span> and
        <span class="math">80 \le s \le 512</span>, the
        Gr&ouml;bner basis attack performs best and should be used to
        set the number of rounds. Let
      </p>

      <div class="math-block">
        d_&#123;\text&#123;con&#125;&#125; =
        0.5(\alpha - 1) m (N - 1) + 2
      </div>

      <p class="text-gray-300 mt-2">
        and
      </p>

      <div class="math-block">
        v = m(N - 1) + r_p
      </div>

      <p class="text-gray-300 mt-2">
        The complexity of a Gr&ouml;bner basis attack is at least
        <span class="math">
          \binom&#123;d_&#123;\text&#123;con&#125;&#125; + v&#125;&#123;v&#125;^2
        </span>
        field operations. Set
        <span class="math">\ell_1</span> to the smallest positive
        value for <span class="math">N</span> that makes this
        binomial expression larger than
        <span class="math">2^s</span>, or formally
      </p>

      <div class="math-block">
        \ell_1 = \min_N \quad \text&#123;subject to&#125; \;
        \binom&#123;d_&#123;\text&#123;con&#125;&#125;
        + v&#125;&#123;v&#125;^2 &gt; 2^s
      </div>

      <p class="text-gray-300 mt-4">
        Additionally, account for a sanity factor of at least 5 rounds
        and a security margin of 50%. This makes the number of rounds
        equal to
      </p>

      <div class="math-block">
        N = \lceil 1.5 \cdot \max(5, \ell_1) \rceil
      </div>

      <h4 class="text-lg font-semibold mt-6 mb-3">
        Algorithm 7: Calculating the number of rounds
      </h4>

      <pre><code class="language-python">def get_number_of_rounds(p, m, capacity, security_level,
                          alpha):
    # get number of rounds for Groebner basis attack
    rate = m - capacity
    dcon = lambda N: floor(0.5 * (alpha-1) * m * (N-1) + 2)
    v = lambda N: m * (N-1) + rate
    target = 2^security_level
    for l1 in range(1, 25):
        if binomial(v(l1) + dcon(l1), v(l1))^2 &gt; target:
            break
    # set a minimum value for sanity and add 50%
    return ceil(1.5 * max(5, l1))</code></pre>
    </section>

    <!-- ============================================================ -->
    <!-- 3. MOTIVATION FOR CHANGES                                    -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold mb-4">
        3 &ensp; Motivation for Changes from the Original Publication
      </h2>

      <p class="text-gray-300">
        Rescue-XLIX departs from the original specification of Rescue
        [<a href="#ref-2" class="text-blue-400
          hover:text-blue-300">2</a>]
        in three ways.
      </p>

      <!-- 3.1 Flipped Order of S-boxes -->

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8 mb-3">
        3.1 &ensp; Flipped Order of S-boxes
      </h3>

      <p class="text-gray-300">
        In Rescue, the first step of each round involves the
        <span class="math">\alpha^&#123;-1&#125;</span> power map, and
        the second step uses <span class="math">\alpha</span>. In
        Rescue-XLIX, this order is reversed. As a result, the
        arithmetization technique the original publication called
        <em>folding</em> &mdash; representing two steps as a single
        set of equations without increasing their degree and omitting
        intermediate state variables &mdash; now applies across the
        entire cipher and does not require special care for the very
        first and last steps.
      </p>

      <p class="text-gray-300 mt-4">
        Conceptually, the new variant can be thought of as adding a
        single step to the front and to the back. The number of
        equations and variables in a Gr&ouml;bner basis attack does not
        change as a result of this addition, because the same improved
        arithmetization is available to the attacker. However, the
        shape of the equations at the very first and last steps are
        different.
      </p>

      <!-- 3.2 Simplified Specification of Round Constants -->

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8 mb-3">
        3.2 &ensp; Simplified Specification of Round Constants
      </h3>

      <p class="text-gray-300">
        The specification of the round constants for the original
        version of Rescue is rather convoluted. It specifies the round
        constants for the block cipher&rsquo;s key schedule using an
        affine relation determined by SHAKE-256. By setting the key to
        zero, the sub-keys are fixed, and these are the round constants
        that are used in the hash function.
      </p>

      <p class="text-gray-300 mt-4">
        The specification of the round constants for Rescue-XLIX is
        much more straightforward. In principle, uniformly random round
        constants suffice. However, we chose to use SHAKE-256 to expand
        a seed phrase and derive the constants from the resulting byte
        stream. This achieves two goals:
      </p>

      <ul class="list-disc list-inside text-gray-300 mt-4 space-y-2">
        <li>
          It establishes that the designers did not select these round
          constants because they hide a secret trapdoor, an approach
          known as <em>nothing-up-my-sleeve</em>.
        </li>
        <li>
          It provides a single standard way to instantiate
          Rescue-Prime that different projects and implementations can
          agree on. After all, this paper provides a reference
          standard.
        </li>
      </ul>

      <!-- 3.3 Reduced Security Margin -->

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8 mb-3">
        3.3 &ensp; Reduced Security Margin
      </h3>

      <p class="text-gray-300">
        The original specification of Rescue had a 100% security
        margin. A reasonable amount of time has passed since the
        publication of the preprint. In the intervening time multiple
        projects have chosen to use Rescue
        [<a href="#ref-9" class="text-blue-400
          hover:text-blue-300">9</a>,
        <a href="#ref-6" class="text-blue-400
          hover:text-blue-300">6</a>,
        <a href="#ref-10" class="text-blue-400
          hover:text-blue-300">10</a>],
        several studies of the security of arithmetization-oriented
        hash functions and Rescue in particular have appeared
        [<a href="#ref-4" class="text-blue-400
          hover:text-blue-300">4</a>,
        <a href="#ref-3" class="text-blue-400
          hover:text-blue-300">3</a>,
        <a href="#ref-7" class="text-blue-400
          hover:text-blue-300">7</a>,
        <a href="#ref-8" class="text-blue-400
          hover:text-blue-300">8</a>,
        <a href="#ref-5" class="text-blue-400
          hover:text-blue-300">5</a>],
        and even a bountiful competition has run its course
        [<a href="#ref-1" class="text-blue-400
          hover:text-blue-300">1</a>].
        None of these endeavors have exposed any weaknesses in the
        construction. We therefore determine that it is timely and
        fitting to reduce the security margin to 50%.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 4. DEVIATIONS                                                -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold mb-4">
        4 &ensp; Deviations from the Rescue-Prime Standard
        Specification
      </h2>

      <p class="text-gray-300">
        Following Section
        <a href="#sec-2" class="text-blue-400
          hover:text-blue-300">2</a>
        is the simplest and most straightforward way to generate a
        safe instance of Rescue-Prime. However, certain special cases
        may warrant deviation from the standard approach. In this
        section we outline directions for such deviations and assign a
        confidence score to the security claim of the resulting
        variant. We stress that we highly recommend whenever possible
        to follow the specification in Section
        <a href="#sec-2" class="text-blue-400
          hover:text-blue-300">2</a>
        and to seek an expert&rsquo;s help before deciding to deviate.
      </p>

      <!-- 4.1 Small Fields and High Security -->

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8 mb-3">
        4.1 &ensp; Small Fields and High Security
      </h3>

      <p class="text-gray-300">
        Section
        <a href="#sec-2" class="text-blue-400
          hover:text-blue-300">2</a>
        mandated that the binary expansion of
        <span class="math">p</span> is at least 32-bit long and
        offered a formula for a safe number of rounds when the security
        level is between 80 bits and 512 bits. This ensures that
        resistance against Gr&ouml;bner basis attacks is the decisive
        factor in setting the number of rounds.
      </p>

      <p class="text-gray-300 mt-4">
        However, the original publication allows for fields as small
        as 4-bit long. In some cases, when both the field size
        <span class="math">p</span> and the state size
        <span class="math">m</span> are small compared to the required
        security, differential cryptanalysis may outperform
        Gr&ouml;bner basis attacks.
      </p>

      <p class="text-gray-300 mt-4">
        In this case, the number of rounds should take into account the
        maximal number of rounds that can be attacked by a differential
        attack:
      </p>

      <div class="math-block">
        \ell_0 =
        \frac&#123;2s&#125;&#123;\log_2(p^&#123;m+1&#125;)
        - \log_2((\alpha - 1)^&#123;m+1&#125;)&#125;
        =
        \frac&#123;2s&#125;&#123;(m+1)(\log_2(p)
        - \log_2(\alpha - 1))&#125;
      </div>

      <p class="text-gray-300 mt-4">
        The number of rounds is then set to
        <span class="math">
          N = \lceil 1.5 \cdot
          \max(5, \ell_0, \ell_1) \rceil
        </span>.
      </p>

      <h4 class="text-lg font-semibold mt-6 mb-3">
        Algorithm 8: Number of rounds for high-security/small-field
        instances
      </h4>

      <pre><code class="language-python">def get_number_of_rounds1(p, m, capacity,
                           security_level, alpha):
    # get number of rounds for Groebner basis attack
    rate = m - capacity
    dcon = lambda N: floor(0.5 * (alpha-1) * m * (N-1) + 2)
    v = lambda N: m * (N-1) + rate
    target = 2^security_level
    for l1 in range(1, 25):
        if binomial(v(l1) + dcon(l1), v(l1))^2 &gt; target:
            break
    # get number of rounds for differential attack
    l0 = 2*security_level / (
        log(1.0*p^(m+1), 2.0)
        - log(1.0*(alpha-1)^(m+1), 2.0))
    # take minimum of numbers, sanity factor, and add 50%
    return ceil(1.5 * max(5, l0, l1))</code></pre>

      <p class="text-gray-300 mt-4">
        Many of the parameter choices where differential attacks are
        relevant, are artificial. In order to generate a practical
        generic security level for the sponge construction, a small
        field must be paired with a large state size, or vice versa. In
        other words, at most one of
        <span class="math">
          \&#123;m, |p|\&#125;
        </span>
        can be small, practically speaking.
      </p>

      <p class="text-gray-300 mt-4">
        <em>Selection of the MDS Matrix</em> is unaffected by this
        decision.
      </p>

      <p class="text-gray-300 mt-4">
        <em>Selection of the Round Constants</em> is unaffected by
        this decision.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Confidence Level</strong> is medium-high. This variant
        was explicitly covered in the generic security argument of the
        original publication. However, most of the focus so far was on
        more natural settings.
      </p>

      <!-- 4.2 Alternate MDS Matrices -->

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8 mb-3">
        4.2 &ensp; Alternate MDS Matrices
      </h3>

      <p class="text-gray-300">
        There are cases where better performance is afforded by
        optimizing the MDS with respect to some design criterion.
        Section
        <a href="#sec-2.4" class="text-blue-400
          hover:text-blue-300">2.4</a>
        specifies Vandermonde matrices as the standard way to generate
        the MDS matrix. However the original publication did not limit
        the choice of MDS to any specific type and argues its security
        with respect to any MDS matrix. The decision to be more
        restrictive merely simplifies the standard specification and is
        not known to have any security implications for algorithms
        following the Marvellous design strategy.
      </p>

      <p class="text-gray-300 mt-4">
        <em>Choosing the MDS matrix:</em> any MDS matrix can be used.
      </p>

      <p class="text-gray-300 mt-4">
        <em>The number of rounds</em> is unaffected by this decision.
      </p>

      <p class="text-gray-300 mt-4">
        <em>Selection of the Round Constants</em> is unaffected by
        this decision.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Confidence Level</strong> is high. This variant was
        explicitly covered in the generic security argument of the
        original publication.
      </p>

      <!-- 4.3 Omission of the Padding Rule -->

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8 mb-3">
        4.3 &ensp; Omission of the Padding Rule
      </h3>

      <p class="text-gray-300">
        A padding rule is required when the sponge function is used to
        absorb inputs of arbitrary length. If the length of the input
        is fixed and known in advance (when building a Merkle tree,
        for instance) the padding can be omitted.
      </p>

      <p class="text-gray-300 mt-4">
        <em>The number of rounds</em> is unaffected by this decision.
      </p>

      <p class="text-gray-300 mt-4">
        <em>Selection of the MDS matrix</em> is unaffected by this
        decision.
      </p>

      <p class="text-gray-300 mt-4">
        <em>Selection of the Round Constants</em> is unaffected by
        this decision.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Confidence Level</strong> is medium-high. This is a
        well known property of sponge constructions and is independent
        of Rescue-Prime.
      </p>

      <!-- 4.4 Algebraically Dependent Round Constants -->

      <h3 id="sec-4.4" class="text-xl font-semibold mt-8 mb-3">
        4.4 &ensp; Algebraically Dependent Round Constants
      </h3>

      <p class="text-gray-300">
        The point in injecting round constants is to ensure that every
        round is unique, thereby foiling attacks that exploit a
        repetitive structure of the cipher. In some applications it is
        cumbersome to specify
        <span class="math">2mN</span> unstructured round constants,
        and it would be convenient to derive some of the round
        constants from the others. We sketch two ways to do this.
      </p>

      <ul class="list-disc list-inside text-gray-300 mt-4 space-y-2">
        <li>
          Select
          <span class="math">
            C_i, \; i \equiv 0 \bmod m
          </span>
          at random and set
          <span class="math">
            C_&#123;i+j&#125; = C_i^&#123;j+1&#125;
          </span>,
          for
          <span class="math">0 &lt; j &lt; m</span>.
          The <span class="math">C_i</span> should be selected
          uniformly at random but with rejection sampling to ensure
          that <span class="math">C_i</span> generates the entire
          group
          <span class="math">
            \mathbb&#123;F&#125;_p \setminus
            \&#123;0\&#125;, \times
          </span>.
        </li>
        <li>
          Select
          <span class="math">
            (C_0, \ldots, C_&#123;m-1&#125;)
          </span>
          uniformly at random along with an invertible matrix
          <span class="math">
            A \in \mathbb&#123;F&#125;_p^&#123;m \times m&#125;
          </span>
          and an offset vector
          <span class="math">
            \mathbf&#123;b&#125; \in
            \mathbb&#123;F&#125;_p^m
          </span>.
          Then derive
          <span class="math">
            (C_&#123;im&#125;, \ldots,
            C_&#123;(i+1)m - 1&#125;)^&#123;\mathsf&#123;T&#125;&#125;
            = A (C_&#123;(i-1)m&#125;, \ldots,
            C_&#123;im - 1&#125;)^&#123;\mathsf&#123;T&#125;&#125;
            + \mathbf&#123;b&#125;
          </span>,
          for
          <span class="math">1 \le i &lt; 2N</span>.
        </li>
      </ul>

      <p class="text-gray-300 mt-4">
        <em>The number of rounds</em> is unaffected by this decision.
      </p>

      <p class="text-gray-300 mt-4">
        <em>Selection of the MDS matrix</em> is unaffected by this
        decision.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Confidence Level</strong> is high. Consult an expert
        to avoid pitfalls.
      </p>

      <!-- 4.5 Permitting n > r_p -->

      <h3 id="sec-4.5" class="text-xl font-semibold mt-8 mb-3">
        4.5 &ensp; Permitting
        <span class="math">n &gt; r_p</span>
      </h3>

      <p class="text-gray-300">
        <strong>Doubly-extendable cryptographic (DEC)
        functions.</strong> &ensp;
        Such functions allow to absorb a sequence of arbitrary length
        and output a sequence of arbitrary length (up to the security
        bound). Hash functions are a private case of DEC functions
        with a fixed length input.
      </p>

      <p class="text-gray-300 mt-4">
        The Rescue-Prime hash function specified in Section
        <a href="#sec-2" class="text-blue-400
          hover:text-blue-300">2</a>
        restricts the squeezing phase to a single iteration, and
        defines the output length as
        <span class="math">n \le r_p</span>.
        Algorithm 9 (resp., Algorithm 10) modifies Algorithm 2
        (resp., Algorithm 1) for the case of a DEC function.
      </p>

      <p class="text-gray-300 mt-4">
        <em>The number of rounds</em> is unaffected by this decision.
      </p>

      <p class="text-gray-300 mt-4">
        <em>Selection of the MDS matrix</em> is unaffected by this
        decision.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Confidence Level</strong> is high. This variant was
        explicitly covered in the generic security argument of the
        original publication.
      </p>

      <h4 class="text-lg font-semibold mt-6 mb-3">
        Algorithm 9: Rescue-Prime DEC function
      </h4>

      <pre><code class="language-python">def rescue_prime_DEC(parameters, input_sequence,
                     output_length):
    p, m, capacity, security_level, alpha, alphainv, N, MDS, \
        round_constants = parameters
    rate = m - capacity
    Fp = FiniteField(p)
    padded_input = input_sequence + [Fp(1)]
    while len(padded_input) % rate != 0:
        padded_input.append(Fp(0))
    return rescue_prime_sponge(
        parameters, padded_input, output_length)</code></pre>

      <h4 class="text-lg font-semibold mt-6 mb-3">
        Algorithm 10: Rescue-Prime sponge with arbitrary output length
      </h4>

      <pre><code class="language-python">def rescue_prime_sponge(parameters, input_sequence,
                        output_length):
    p, m, capacity, security_level, alpha, alphainv, N, MDS, \
        round_constants = parameters
    rate = m - capacity
    Fp = FiniteField(p)
    assert len(input_sequence) % rate == 0
    # initialize state to all zeros
    state = matrix([[Fp(0)] for i in range(m)])
    # absorbing
    absorb_index = 0
    while absorb_index &lt; len(input_sequence):
        for i in range(0, rate):
            state[i,0] += input_sequence[absorb_index]
            absorb_index += 1
        state = rescue_XLIX_permutation(parameters, state)
    # squeezing
    output_sequence = []
    squeeze_index = 0
    while squeeze_index &lt; output_length:
        for i in range(0, rate):
            output_sequence.append(state[i,0])
            squeeze_index += 1
        if squeeze_index &lt; output_length:
            state = rescue_XLIX_permutation(
                parameters, state)
    return output_sequence[:output_length]</code></pre>
    </section>

    <!-- ============================================================ -->
    <!-- 5. CONCLUSION                                                -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold mb-4">
        5 &ensp; Conclusion
      </h2>

      <p class="text-gray-300">
        We close with a note on the utility of conclusions, making use
        of the opportunity provided by a clear example of when there
        isn&rsquo;t any. The purpose of a conclusion is not to
        summarize a body of text (that would be an insult to the
        reader!) but rather to cast new and more light on the knowledge
        conveyed therein. It serves to interpret the results, and to
        suggest improved thought patterns appropriate for the context
        at hand.
      </p>

      <p class="text-gray-300 mt-4">
        This document does not introduce new results or even new
        knowledge. Readers looking for a better way to think about
        arithmetization-oriented ciphers are referred to the original
        Marvellous paper
        [<a href="#ref-2" class="text-blue-400
          hover:text-blue-300">2</a>].
        There is nothing left to say in this conclusion; goodbye.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Acknowledgments.</strong> &ensp;
        Alan Szepieniec is supported by the Nervos Foundation. Tomer
        Ashur is an FWO post-doctoral fellow under Grant Number
        12ZH420N. Siemen Dhooghe is supported by a Ph.D. Fellowship
        from the Research Foundation &ndash; Flanders (FWO).
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold mb-4">References</h2>
      <ol class="list-decimal list-inside text-gray-300 space-y-3
        text-sm">
        <li id="ref-1">
          STARK-friendly hash challenge,
          <a href="https://starkware.co/developers-community/hash-challenge/"
            target="_blank" rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300">
            https://starkware.co/developers-community/hash-challenge/</a>,
          accessed: 2020-09-09
        </li>
        <li id="ref-2">
          Aly, A., Ashur, T., Ben-Sasson, E., Dhooghe, S.,
          Szepieniec, A.: Design of symmetric-key primitives for
          advanced cryptographic protocols. IACR Cryptol. ePrint Arch.
          2019, 426 (2019),
          <a href="https://eprint.iacr.org/2019/426"
            target="_blank" rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300">
            https://eprint.iacr.org/2019/426</a>
        </li>
        <li id="ref-3">
          Ben-Sasson, E., Goldberg, L., Levit, D.: STARK friendly
          hash &ndash; survey and recommendation. IACR Cryptol. ePrint
          Arch. 2020, 948 (2020),
          <a href="https://eprint.iacr.org/2020/948"
            target="_blank" rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300">
            https://eprint.iacr.org/2020/948</a>
        </li>
        <li id="ref-4">
          Beyne, T., Canteaut, A., Dinur, I., Eichlseder, M.,
          Leander, G., Leurent, G., Naya-Plasencia, M., Perrin, L.,
          Sasaki, Y., Todo, Y., Wiemer, F.: Out of oddity &ndash; new
          cryptanalytic techniques against symmetric primitives
          optimized for integrity proof systems. In: Micciancio, D.,
          Ristenpart, T. (eds.) CRYPTO, Part III. LNCS, vol. 12172,
          pp. 299&ndash;328. Springer (2020),
          <a href="https://doi.org/10.1007/978-3-030-56877-1_11"
            target="_blank" rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300">
            https://doi.org/10.1007/978-3-030-56877-1_11</a>
        </li>
        <li id="ref-5">
          Beyne, T., Canteaut, A., Leander, G., Naya-Plasencia, M.,
          Perrin, L., Wiemer, F.: Report on the security of the Rescue
          hash function (2020),
          <a href="https://starkware.co/wp-content/uploads/2020/06/report.pdf"
            target="_blank" rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300">
            https://starkware.co/wp-content/uploads/2020/06/report.pdf</a>
        </li>
        <li id="ref-6">
          Bowe, S., Grigg, J., Hopwood, D.: Halo: Recursive proof
          composition without a trusted setup. IACR Cryptol. ePrint
          Arch. 2019, 1021 (2019),
          <a href="https://eprint.iacr.org/2019/1021"
            target="_blank" rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300">
            https://eprint.iacr.org/2019/1021</a>
        </li>
        <li id="ref-7">
          Canteaut, A., Beyne, T., Dinur, I., Eichlseder, M.,
          Leander, G., Leurent, G., Plasencia, M.N., Perrin, L.,
          Sasaki, Y., Todo, Y., Wiemer, F.: Report on the security of
          STARK-friendly hash functions (version 2.0) (2020),
          <a href="https://starkware.co/wp-content/uploads/2020/03/reportv2.pdf"
            target="_blank" rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300">
            https://starkware.co/wp-content/uploads/2020/03/reportv2.pdf</a>
        </li>
        <li id="ref-8">
          Keller, N., Rosemarin, A.: Mind the middle layer: The HADES
          design strategy revisited. IACR Cryptol. ePrint Arch. 2020,
          179 (2020),
          <a href="https://eprint.iacr.org/2020/179"
            target="_blank" rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300">
            https://eprint.iacr.org/2020/179</a>
        </li>
        <li id="ref-9">
          StarkWare: EthSTARK,
          <a href="https://github.com/starkware-libs/ethSTARK"
            target="_blank" rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300">
            https://github.com/starkware-libs/ethSTARK</a>,
          accessed: 2020-09-09
        </li>
        <li id="ref-10">
          Threadbare, B.: Distaff,
          <a href="https://github.com/GuildOfWeavers/distaff"
            target="_blank" rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300">
            https://github.com/GuildOfWeavers/distaff</a>
        </li>
      </ol>
    </section>
  </article>
</BaseLayout>
