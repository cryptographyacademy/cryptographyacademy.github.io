---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2013/816';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Fast Prime Field Elliptic Curve Cryptography with 256 Bit Primes';
const AUTHORS_HTML = 'Shay Gueron, Vlad Krasnov';

const CONTENT = `    <p class="text-gray-300">Shay Gueron<span class="math">^{1,2}</span>, Vlad Krasnov<span class="math">^{2}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> Department of Mathematics, University of Haifa, Israel <span class="math">^{2}</span> Intel Corporation, Israel Development Center, Haifa, Israel</p>

    <p class="text-gray-300">Abstract. This paper studies software optimization of Elliptic Curve Cryptography with 256-bit prime fields. We propose a constant-time implementation of the NIST and SECG standardized curve <span class="math">P-256</span>, that can be seamlessly integrated into OpenSSL. This accelerates Perfect Forward Secrecy TLS handshakes that use ECDSA and/or ECDHE, and can help improving the efficiency of TLS servers. We report significant performance improvements for ECDSA and ECDH, on several architectures. For example, on the latest Intel Haswell microarchitecture, our ECDSA sign is <span class="math">2.33x</span> faster than OpenSSL's implementation.</p>

    <p class="text-gray-300">Keywords: ECDSA, ECDH, EC, SSL, TLS, optimization, Haswell</p>

    <p class="text-gray-300">TLS [7] is the leading protocol for secure network communications. It supports a variety of symmetric ciphers and MAC algorithms for the authenticated and encrypted client-server communication, and a variety of public key algorithms for establishing a symmetric session key (for the authenticated encryption).</p>

    <p class="text-gray-300">Currently, the most popular key-exchange algorithm is based on RSA. Here, the client generates a secret value (master key) and encrypts it using the server's public RSA key. The server decrypts that value, and both parties apply some agreed Key Derivation Function to derive the session key.</p>

    <p class="text-gray-300">With this approach, the confidentiality of all the sessions depends on the server's private RSA key: the confidentiality of any session, with any client (even past recorded sessions) is lost if this key is compromised (e.g., lost, hacked, subpoenaed). In response to increased sensitivity to this property (e.g., due to information on the PRISM projects [11]¹), some bodies and companies are migrating to a "Perfect Forward Secrecy" (PFS) protocol (e.g., [19]), and some have already implemented it</p>

    <p class="text-gray-300">¹ "Demand for encryption apps has increased dramatically ever since the exposure of massive internet surveillance programs run by US and UK intelligence agencies. Now Facebook is reportedly moving to implement a strong, decades-old encryption technique that's been largely avoided by the online services that need it most"; J. Kopstein, The Verge, http://www.theverge.com/2013/6/26/4468050/facebook-follows-google-with-tough-encryption-standard.</p>

    <p class="text-gray-300">Fast Prime Field Elliptic Curve Cryptography with 256 Bit Primes</p>

    <p class="text-gray-300">(e.g., [14]). Here, the server-client key exchange uses ephemeral parameters, rather than a single fixed key. Two such key exchange algorithms are supported by TLS: Ephemeral Diffie-Hellman (DHE), and Elliptic-Curve Ephemeral Diffie-Hellman (ECDHE). These algorithms require the server and the client to (randomly) select a secret key, and to use it for generating and exchanging "public key parameters". These are subsequently used for deriving a shared session key. In such protocols, the server is required to authenticate itself (to the client) by signing the parameters that it sends to the client. Several signature algorithms can be agreed during the initial client-server handshake, and the two leading ones are RSA signature and Elliptic Curve Digital Signature Algorithm (ECDSA). Consequently, adding support for PFS protocols makes DHE+RSA, ECDHE+RSA and ECDHE+ECDSA key exchange and signature combinations important targets for optimization, especially for servers.</p>

    <p class="text-gray-300">From the server's viewpoint, migration to ECC based TLS connections can be done in two ways. Adopting the full ECDHE+ECDSA combination requires the server to use an EC certificate. On the other hand, the ECDHE+RSA combination allows a server to continue using an existing RSA certificate, and use ECC only for the key exchange. Direct browsing indicates that current ECC adopters indeed use both combinations. Few examples are Google (using ECDHE+RSA and ECDHE+ECDSA), Facebook and Twitter (recently adopting ECDHE+RSA).</p>

    <p class="text-gray-300">The currently recommended RSA key size is 2048-bit, and it is estimated to provide 112 bits of security [2] (for 128 bits security, one needs RSA3072, which is  <span class="math">\\sim 3.375</span>  times slower). The computational cost of RSA2048 can be estimated as the cost of two 1024-bit modular exponentiations. The DHE protocol (providing 112 bits of security) requires two modular exponentiations with a 2048-bit modulus, and it suffices to use a 224/256 bits exponent. With these parameters, the performance of DHE is comparable to that of RSA. Elliptic Curve algorithms for signature and key exchange require shorter keys of 224/256 bits for 112/128 bits of security. With such keys, ECDSA signatures <span class="math">^2</span>  and ECDH are significantly faster than RSA signatures and DH key exchange counterparts. Fig. 1 shows the performance of these signature and key exchange algorithms, with a comparison to the classical non-PFS key exchange based on RSA alone. It shows that supporting PFS key exchange, with DHE+RSA and ECDHE+RSA combinations, comes with a performance cost, but the ECDHE+ECDSA combination is actually faster than the non-PFS key exchange.</p>

    <p class="text-gray-300">Elliptic-Curve cryptography with a 224-bit prime (NIST  <span class="math">P</span> -224 curve) has been recently optimized by [13], contributed to OpenSSL, and is now part of its current offering. Subsequently, a similar optimized implementation was derived from [13], to support the 256-bit and 521-bit NIST primes <span class="math">^3</span> . These optimizations provide significant speedups compared to original OpenSSL implementations. However, as NSA's Suite</p>

    <p class="text-gray-300">2 RSA signature verification with the standard short public exponent remains faster than ECDSA verification. However, verification is done by the client, and not by the server side. 3 An optimized implementation of P-224, P-256 and P-521 was contributed to OpenSSL by Emilia Käsper, Adam Langley and Bodo Moeller. To enable it, OpenSSL should be configured with 'enable-ec_nistp_64_gcc_128'.</p>

    <p class="text-gray-300">Shay Gueron and Vlad Krasnov</p>

    <p class="text-gray-300">B endorses only 256 and 384-bit prime curves ECC [20], the de-facto standard that is adopted on the web, uses the 256-bit prime.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. The performance of PFS supporting algorithms, measured in CPU cycles on the latest Intel Haswell Microarchitecture. The RSA2048 and DH2048 numbers are based on the currently fastest implementation [8]. DH2048 is shown with both 2048-bit exponent (OpenSSL's default) and with 224-bit exponent (that suffices for 112 bits of security). For ECDSA and ECDHE, the numbers correspond to the NIST  <span class="math">P</span> -256 curve (OpenSSL development version of OpenSSL; September 9, 2013, configured with 'enable-ec_nistp_64_gcc_128'). Note that the ECDHE+ECDSA combination provides 128 bits of security, and the other combinations provide only 112 bits. For comparison, the rightmost (green) bar shows the performance of the RSA-based key exchange, that does not provide PFS.</p>

    <p class="text-gray-300">While ECC can be used with any prime, NIST specifies one prime for each curve with 192, 224, 256, 384 and 521 bits [16]. These are "Generalized Mersenne" primes [21], where modular reduction can be implemented efficiently.</p>

    <p class="text-gray-300">This paper studies software optimizations for ECC with 256-bit primes (NIST  <span class="math">P</span> -256 curve in particular). We apply our proposed optimizations to x86-64 architectures, but any 64 or 32 bit architecture may potentially benefit from them as well. Our implementation includes side channel protection up to the protocol level, and we use several optimizations for improving the performance. In particular, we propose a method for implementing ECC in the Montgomery domain, and optimize it to what we call "Montgomery Friendly" primes. The NIST  <span class="math">P</span> -256 curve has such a prime.</p>

    <p class="text-gray-300">Fast Prime Field Elliptic Curve Cryptography with 256 Bit Primes</p>

    <p class="text-gray-300">Prime field Elliptic Curves are defined by the pairs  <span class="math">(x, y)</span>  satisfying the relation  <span class="math">y^2 = x^3 + ax + b</span>  with  <span class="math">a, b \\in GF(p)</span>  (satisfying  <span class="math">4a^3 + 27b^2 \\neq 0</span> ) and where  <span class="math">p &amp;gt; 3</span>  is a prime. For any two points  <span class="math">P, Q</span>  on a given curve, their addition  <span class="math">(P + Q)</span>  is defined as a fundamental operation (using the tangent-and-chord rule), and this defines a group of points on the curve. The addition  <span class="math">P + Q</span>  when  <span class="math">P \\neq Q</span>  is called point addition, and addition  <span class="math">P + Q = 2P</span>  when  <span class="math">P = Q</span>  is called point doubling (and they are different operations). Consequently, for non-negative integer  <span class="math">k</span> , it is possible to define the scalar point multiplication  <span class="math">k \\cdot P</span>  on the curve.</p>

    <p class="text-gray-300">In this paper, we consider the two Elliptic Curves Cryptosystems (ECC) mentioned above, namely ECDHE and ECDSA. Their security relies on the difficulty of the Elliptic Curve Discrete Logarithm Problem, i.e., finding the value of  <span class="math">k</span> , when  <span class="math">k \\cdot P</span>  is given. Obviously, implementation of these protocols involves (among other computations) the computation of point multiplications over the given field.</p>

    <p class="text-gray-300">For the sake of optimization, the EC affine coordinates  <span class="math">(x,y)</span>  can be converted to a representation where the group operations are cheaper (specifically, involve fewer  <span class="math">GF(p)</span>  inversions). We use here the Jacobian point representation with three coordinates  <span class="math">(X,Y,Z)</span> , where  <span class="math">x = X / Z^2</span> ,  <span class="math">y = Y / Z^3</span>  (modulo the relevant prime). The point doubling and point addition operations in these coordinates are provided in Fig. 2.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2. Point doubling and point addition in Jacobian coordinates. The arithmetic operations are in the underlying field  <span class="math">GF(p)</span> .</p>

    <p class="text-gray-300">Shay Gueron and Vlad Krasnov</p>

    <p class="text-gray-300">By definition, converting the triplet  <span class="math">(X,Y,Z)</span>  from Jacobian back to affine coordinates requires field inversion(s). This conversion needs to be carried out only once, at the end of the computation of the point multiplication  <span class="math">k\\cdot P</span></p>

    <p class="text-gray-300">Generalized-Mersenne [21] primes are of special interest. They are defined as primes of a special form, that allows for efficient reduction, without integer-division. Generalized-Mersenne primes are frequently used for ECC (all the NIST primes in [16] are such) because reduction modulo such primes can be carried out efficiently.  <span class="math">p_{256}</span>  is a Generalized-Mersenne prime (see Fig. 4).</p>

    <p class="text-gray-300">Fig. 3 illustrates the ECDH and ECDSA flows (note that during the TLS handshake, the server computes an ECDSA signature).</p>

    <p class="text-gray-300">|  The (public) curve parameters are: a, b, p (prime), G (the generator point), n (the multi- plicative order of G). The private data: d_a - server secret The signed data: z - hash(message) truncated to len(n)  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  ECDSA signature  |</p>

    <p class="text-gray-300">|  Pick a random integer k∈[1,n-1] Compute (x1, y1) = k·G r = x1 mod n s = k-1(z + rd_s) mod n The signature is the pair (r, s)  |</p>

    <p class="text-gray-300">|  ECDH  |</p>

    <p class="text-gray-300">|  Server picks a random integer d_s∈[1,n-1] Client picks a random integer d_c∈[1,n-1] Generate key: Server generates it's public key Q_s = d_s·G Client generates it's public key Q_c = d_c·G Compute key: Server computes (x1, y1) = d_s·Q_c Client computes (x1, y1) = d_c·Q_s The shared secret is x1  |</p>

    <p class="text-gray-300">Fig. 3. The flows for ECDSA signature and ECDH key exchange.</p>

    <p class="text-gray-300">In the rest of the paper, we consider only the case  <span class="math">a = -3 \\mod p</span> , and primes whose bit-length is 256 (i.e., satisfying  <span class="math">2^{255} &amp;lt; p &amp;lt; 2^{256}</span> ).</p>

    <p class="text-gray-300">The results we show in this paper relate to optimizations for the NIST 256-bit curve,  <span class="math">P - 256</span> , with a prime denoted by  <span class="math">p_{256}</span> . The related parameters are given in Fig. 4.</p>

    <p class="text-gray-300">Fast Prime Field Elliptic Curve Cryptography with 256 Bit Primes</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 4. The NIST 256-bit curve parameters [16].</p>

    <p class="text-gray-300">The Montgomery Multiplication [15] (MM hereafter) is a well-known efficient technique for computing modular exponentiation [9]. Similarly, it can be used for other modular arithmetic intensive algorithms, such as the elliptic curve point multiplication.</p>

    <p class="text-gray-300">Point doubling and addition (see Fig. 2) involves a sequence of operations modulo the prime  <span class="math">p</span> . It is possible to execute them in the so-called Montgomery domain, where the modular multiplication  <span class="math">A \\times B \\mod p</span>  is replaced by the Montgomery Multiplication operation,  <span class="math">MM(A, B) = A \\times B \\times 2^{-l} \\mod p</span> , and where the positive integer  <span class="math">l</span>  is some parameter. When  <span class="math">A = B</span> , we call the operation a Montgomery Square (MSQR), and this case can be optimized by leveraging the fact that  <span class="math">A = B</span> .</p>

    <p class="text-gray-300">To compute a point multiplication using  <span class="math">MM</span>  operations, the coordinates of the input point  <span class="math">(X, Y, Z)</span>  need to be converted to the Montgomery domain. This is done by multiplying (modulo  <span class="math">p</span> ) each coordinate by  <span class="math">2^l</span> , or alternatively, performing an  <span class="math">MM</span>  by the constant  <span class="math">H = 2^{2l} \\mod p</span> . After all the computations are completed (in the Montgomery domain), they need to be converted back to the residue domain. This is done by  <span class="math">MM</span>  by  <span class="math">l</span> . The Word-by-Word flow for computing  <span class="math">MM</span>  (WW-MM) is described in Fig. 5 (left panel).</p>

    <p class="text-gray-300">For some cases, such as the one we discuss here, a shortcut is available, and to this end, we use the following definition.</p>

    <p class="text-gray-300">Definition 1: let  <span class="math">p</span>  be an odd modulus and  <span class="math">s</span>  be a positive integer. If  <span class="math">p</span>  satisfies  <span class="math">-1/p \\mod 2^s = 1</span> , then  <span class="math">p</span>  is called an  <span class="math">s</span> -Montgomery Friendly modulus (MF for short).</p>

    <p class="text-gray-300">For an MF modulus, the WW-MM computations can be optimized, as shown in Fig. 5 (right panel).</p>

    <p class="text-gray-300">Our study discusses a modulus which is a 256-bit prime, implying  <span class="math">l = 256</span> . To optimize code for 64-bit architectures, we use  <span class="math">s = 64</span> . This implies that  <span class="math">k = 4</span> . In other words, each field element is considered as a "4 digits number", where each digit has 64 bits.</p>

    <p class="text-gray-300">Shay Gueron and Vlad Krasnov</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm 1: Word-by-Word Montgomery Multiplication (WW-MM) Input: p < 2i (odd modulus), 0 ≤ a, b < p, l=s×k Output: a×b×2-1 mod p Pre-computed: k0 = -p-1 mod 2s Flow 1. T = a×b For i = 1 to k do 2. T1 = T mod 2s 3. Y = T1 × k0 mod 2s 4. T2 = Y × p 5. T3 = (T + T2) 6. T = T3 / 2s End For 7. If T ≥ p then X = T - p; else X = T Return X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm 2: Word-by-Word Montgomery Multiplication for a Montgomery Friendly modulus p (Montgomery Friendly Multiplica- tion) Satisfying -p-1 mod 2s=1. Input: p < 2i (Montgomery Friendly modulus) 0 ≤ a, b < p, l=s×k Output: a×b×2-1 mod p Flow 1. T = a×b For i = 1 to k do 2. T1 = T mod 2s 3. T2 = T1 × p 4. T3 = (T + T1) 5. T = T3 / 2s End For 6. If T ≥ p then X = T - p; else X = T Return X</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 5. Left panel: Word by Word Montgomery Multiplication (WW-MM). Right panel: WW-MM for a Montgomery Friendly modulus. In our context, the relevant parameters for a 256-bit prime modulus  <span class="math">(p)</span>  are  <span class="math">l = 256</span> ,  <span class="math">s = 64</span> , and  <span class="math">k = 4</span> .</p>

    <p class="text-gray-300">In the general case, where an  <span class="math">l</span> -bit number can be represented using  <span class="math">k</span>  digits,  <span class="math">MM</span>  requires  <span class="math">2k^2 + k</span>  single-precision multiplication operations. Optimizing for an MF prime reduces the number of single-precision multiplications to  <span class="math">2k^2</span> . With  <span class="math">k = 4</span> , as in our case, this saves more than  <span class="math">10\\%</span>  of the operations (for a large  <span class="math">k</span> , the saving can be insignificant).</p>

    <p class="text-gray-300">A similar optimization is employed in the NSS[17] project, for  <span class="math">s = 32</span> .</p>

    <p class="text-gray-300">Observation 1. A 256-bit MF modulus  <span class="math">q</span>  has the form  <span class="math">q = 2^{255\\text{-offset}} \\times L + 2^{64} - 1</span> , or the form  <span class="math">q = 2^{255\\text{-offset}} \\times L - 1</span> , where offset = floor ( <span class="math">\\log_2(L)</span> ) (and it is bounded appropriately, to assure that  <span class="math">q &amp;lt; 2^{256}</span> ).</p>

    <p class="text-gray-300">Example 1. The first 256-bit MF prime of the first form is  <span class="math">2^{250} \\times 61 + 2^{64} - 1</span> . The first 256-bit MF prime of the second form is  <span class="math">2^{247} \\times 321 - 1</span> .</p>

    <p class="text-gray-300">Observation 2. The NIST prime  <span class="math">p_{256}</span>  is a MF prime.</p>

    <p class="text-gray-300">Observation 3. Another property of  <span class="math">p_{256}</span> , can be used for optimization in Step 3 (on the right pane of Fig. 5). We use it to optimize the multi-precision multiplication by  <span class="math">p_{256}</span> . When writing  <span class="math">p_{256}</span>  in hexadecimal notation (64-bit "quad-words"), we note that quad-word 0 is:  <span class="math">0xffffffffffffffff</span> . Since  <span class="math">T1 \\times 0xffffffffffffff = T1 \\times 2^{64} - T1</span> , it follows that</p>

    <p class="text-gray-300">Fast Prime Field Elliptic Curve Cryptography with 256 Bit Primes</p>

    <p class="text-gray-300">the multiplication by this quad-words can be replaced by a (quicker) subtraction. In addition, quad-word 2 of  <span class="math">p_{256}</span> , is 0 (i.e., no multiplication is needed at all).</p>

    <p class="text-gray-300">The operations in Montgomery domain correspond to operations in the Residue domain as follows: if  <span class="math">OP(a, b)</span>  is the operation in the Residue domain, it corresponds to  <span class="math">MOP(a \\times 2^{-n}, b \\times 2^{-n}) = OP(a, b) \\times 2^{-n}</span>  in the Montgomery domain. Unlike modular-exponentiation that has only multiplications, Point Addition and Point Doubling involve addition, subtraction, and also multiplications by some small constants. These can be performed using regular modular (modulo  <span class="math">p</span> ) operations:</p>

    <p class="text-gray-300">Addition:  <span class="math">a \\times 2^{-n} + b \\times 2^{-n} = (a + b) \\times 2^{-n}</span>  (mod  <span class="math">p</span> )</p>

    <p class="text-gray-300">Subtraction:  <span class="math">a \\times 2^{-n} - b \\times 2^{-n} = (a - b) \\times 2^{-n}</span>  (mod  <span class="math">p</span> )</p>

    <p class="text-gray-300">Multiplication by constant  <span class="math">c</span> :  <span class="math">c \\times (a \\times 2^{-n}) = (c \\times a) \\times 2^{-n}</span>  (mod  <span class="math">p</span> )</p>

    <p class="text-gray-300">The relevant constants for Point-Doubling are 2, 4, 8, and 3. However we use an equivalent flow that requires multiplication by 2 and 3, and a division by 2. Multiplication and division by two is implemented using bit shift to the left/right, and a constant time conditional subtraction/addition of the modulus, similarly do the addition and subtraction operations. Multiplication by 3 is implemented as multiplication by two followed by an addition.</p>

    <p class="text-gray-300">This section describes the methods we applied in order to optimize the ECDSA and the ECDH at the protocol level.</p>

    <p class="text-gray-300">ECDSA and ECDH implementations include four independent algorithmic flows: ECDSA sign, ECDSA verify, ECDH generate key, ECDH compute key. The efficiency of these flows depends on optimization of the following four Computational Problems (CP hereafter):</p>

    <p class="text-gray-300">CP 1: multiply the point  <span class="math">G</span>  (the generator) by a scalar.</p>

    <p class="text-gray-300">CP 2: multiply an arbitrary point  <span class="math">P</span>  by a scalar.</p>

    <p class="text-gray-300">CP 3: extract the affine coordinate  <span class="math">x</span>  (and  <span class="math">y</span> ). We use here the Jacobian coordinates, so the back-conversion involves a 256 bit modular inverse (modulo  <span class="math">p_{256}</span> ).</p>

    <p class="text-gray-300">CP 4: Compute a 256-bit modular inverse, with the modulus  <span class="math">n = \\text{Order}(G)</span> .</p>

    <p class="text-gray-300">Shay Gueron and Vlad Krasnov</p>

    <p class="text-gray-300">These problems are used in the following combinations.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>ECDSA sign uses: CP1, CP3 and CP4.</li>

      <li>ECDSA verify uses: CP1, CP2, CP3 and CP4.</li>

      <li>ECDH generate key uses: CP1 and CP3.</li>

      <li>ECDH compute key uses: CP2 and CP3.</li>

    </ul>

    <h2 id="sec-9" class="text-2xl font-bold">6 The different components of the optimization</h2>

    <p class="text-gray-300">Obviously, CP1 and CP2 dominate the computations, so they are the first optimization target. For CP1, we note that the generator <span class="math">(G)</span> is part of the pre-defined curve parameters (i.e., fixed). We implement the scalar multiplication (by <span class="math">G</span>) with a windowing method and Booth encoding [3], using a window of size 7, and avoid <span class="math">MSQR</span>’s via pre-computation. There are <span class="math">\\sqrt[7]{256/7} = 37</span> windows, and hence <span class="math">37 \\times 2</span> tables (storing the <span class="math">X</span> and the <span class="math">Y</span> coordinate; <span class="math">Z</span> is implicitly 1). The values stored in the tables are</p>

    <div class="my-4 text-center"><span class="math-block">\\text{Table}[i][j] = 2^{7i} \\times (j \\times G) \\ (\\text{mod } p_{256})</span></div>

    <p class="text-gray-300">Each table is stored, and fetched in a side-channel protected manner: accessing a table does not employ memory access patterns that depend on the (secret) scalar, instead, for a given window all elements are loaded sequentially, and masked based on the secret window value. The mask is such, that all values but the required one are zeroed. To optimize this flow we make use of SIMD instructions.</p>

    <p class="text-gray-300">The pre-computed (fixed) tables require slightly more than 150KB of storage, which exceeds the size of the first level cache in modern CPU’s. However, our tests indicate that using these large tables yields better performance than the performance obtained with smaller tables. For completeness, our implementation includes a function that generates the tables, but a server can choose to just hold a static-fixed value for <span class="math">P-256</span>.</p>

    <p class="text-gray-300">Note that for this usage, a server needs a single table for all the connections (unlike RSA’s modular exponentiation computations, where the tables depend on the exponentiation base, and are different for each connection).</p>

    <p class="text-gray-300">To speed up point multiplication (for a general point <span class="math">P</span> and also by <span class="math">G</span>) we wrote <span class="math">MM</span> and <span class="math">MSQR</span> assembly routines that are specifically optimized for the MF prime <span class="math">p_{256}</span>. We also use windowing method with Booth encoding, but with a smaller window size of 5.</p>

    <p class="text-gray-300">The aggressive optimization of CP1 and CP2 increases the relative weight of CP3, which becomes the next optimization target. To implement modular inversion (modulo <span class="math">p_{256}</span>) we used the Fermat’s Little Theorem and wrote a dedicated modular-exponentiation function (optimized for the Generalized-Merssene <span class="math">p_{256}</span>). It computes the modular inverse at the cost of 255 MSQR’s and 13 MM’s. When only the <span class="math">x</span> coordinate is required, thus only <span class="math">Z^2</span> (mod <span class="math">p</span>) needs to be computed, we can reduce the number of MM’s to 12.</p>

    <p class="text-gray-300">We did not prepare a dedicated function for CP4, because <span class="math">n</span> is neither a Pseudo-Mersenne nor a MF prime. Instead, we used the already highly-optimized constant</p>

    <p class="text-gray-300">Fast Prime Field Elliptic Curve Cryptography with 256 Bit Primes</p>

    <p class="text-gray-300">time implementation of Montgomery modular exponentiation, that is present in the OpenSSL (this implementation was recently improved by incorporating some contributed ideas from <em>[9]</em>).</p>

    <h2 id="sec-10" class="text-2xl font-bold">7 Side channel protection</h2>

    <p class="text-gray-300">Cryptographic software implementations are nowadays expected to be protected against side channel leakage. Specifically, a protected implementation must not include branches, memory access patterns and instructions flows that depend on secret information.</p>

    <p class="text-gray-300">Side-channel information in an ECC implementation can potentially leak from two sources. The first is the scalar multiplication <span class="math">k\\cdot P</span>, where <span class="math">k</span> is secret (i.e., a key). This happens if the implementation accesses tables in a way that depends on the value of <span class="math">k</span>, or if it has branches that depend on <span class="math">k</span>. However, we point out that closing this potential leak is not sufficient for generating a fully protected ECDSA implementation: the step <span class="math">(z+rd_{3})/k</span> mod <span class="math">n</span> (see Fig. 3) can also leak secret information if the modular inverse <span class="math">1/k</span> mod <span class="math">n</span> is computed in an unsafe manner.</p>

    <p class="text-gray-300">The recent optimized implementation <em>[13]</em> and the subsequently derived implementation for <em>P-256</em>, have a constant-time point multiplication. By comparison, our implementation addresses both side channel leak sources via constant-time point multiplications, as well as constant time modular inversion. To this end, we modified the OpenSSL <em>ecdsa_sign_setup</em> routine so that it uses OpenSSL’s constant time modular exponentiation function based on Fermat’s Little Theorem (rather than the original OpenSSL <em>BN_mod_inverse</em> that is based on Extended Euclidean Algorithm and is implemented with branches that can potentially give away <span class="math">k</span> ; see <em>[1]</em> for details discussing this leak). As a result, our software patch makes the entire ECDSA sign function constant time.</p>

    <h2 id="sec-11" class="text-2xl font-bold">8 Results</h2>

    <p class="text-gray-300">This section details the performance results that we obtain through our proposed optimizations. We compare them to the performance of the latest development branch of OpenSSL (from September 9, 2013; retrieved from the “git” repository of OpenSSL <em>[18]</em>). We configured OpenSSL with both the default parameters (denoted ‘OpenSSL default’ here), and with ‘enable-ec_nistp_64_gcc_128’ (denoted ‘OpenSSL NISTP enabled’).</p>

    <p class="text-gray-300">Fig. 6 shows the performance gains in CP1, CP2, CP3 (see Section 5 for the definitions). The computation of <span class="math">k\\cdot G</span> gains a speedup factor of more than <span class="math">3x</span> on the new Haswell microarchitecture. Most of this gain can be attributed to the pre-computations that we use. Recall that the computation of <span class="math">k\\cdot G</span> is used for both ECDSA signature and ECDHE generate key routines. These are computed by the server side during a TLS handshake.</p>

    <p class="text-gray-300">The <span class="math">k\\cdot P</span> computation shows significant speedup as well: on the Haswell microarchitecture it is <span class="math">1.8x</span> times faster than the optimized implementation of OpenSSL</p>

    <p class="text-gray-300">Shay Gueron and Vlad Krasnov</p>

    <p class="text-gray-300">NISTP. This performance gain is due to our MM and MSQR implementations that are also optimized for the MF  <span class="math">p_{256}</span>  prime.</p>

    <p class="text-gray-300">Finally, conversion from Jacobian to affine coordinates is sped up by a factor of  <span class="math">2.11x</span>  on the Haswell microarchitecture, thanks to using optimized MM and MSQR routines and a reduced number of operations (using  <span class="math">(p_{256}) - 2</span>  as the exponent).</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 6. The performance (in 1000s of CPU cycles) on the NIST  <span class="math">P</span> -256 curve, of the fundamental EC operations  <span class="math">k \\cdot G</span> ,  <span class="math">k \\cdot P</span>  and Jacobian-to-affine coordinates transformation. The left panel shows the performance on the Haswell Microarchitecture, and the right panel shows the performance on the Sandy Bridge Microarchitecture.</p>

    <p class="text-gray-300">Fig. 7 and Fig. 8 demonstrate the performance, at the protocol level, of ECDSA signing, verifying, and the ECDH Compute Key. This performance is measured via OpenSSL's built-in benchmarking utility "openssl speed". Note that this utility benchmarks only the Compute Key part of the ECDH key exchange (and not the Generate Key part), although in a real application, the ECDH parameters are ephemeral, and the Generate Key routine is also performed for every connection.</p>

    <p class="text-gray-300">For ECDSA signature, we point out that only our implementation is entirely constant-time. For ECDH, both ours and OpenSSL's optimized NISTP implementations are constant-time.</p>

    <p class="text-gray-300">On a Haswell CPU, in a single threaded run, our implementation is  <span class="math">2.33x</span>  faster for ECDSA sign,  <span class="math">1.86x</span>  faster for ECDSA verify, and  <span class="math">1.8x</span>  faster for the key computation. The Hyper-threaded performance shows an even larger gap, with the respective speedup factors of  <span class="math">2.46x</span> ,  <span class="math">1.91x</span>  and  <span class="math">1.81x</span>  (all compared to OpenSSL's optimized NISTP implementation).</p>

    <p class="text-gray-300">Fast Prime Field Elliptic Curve Cryptography with 256 Bit Primes</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 7. The performance of ECDSA sign, ECDSA verify, and ECDE Compute key, measured by 'openssl speed', for  <span class="math">P - 256</span> , at the frequency of  <span class="math">3.4\\mathrm{GHz}</span> , for a single core, and a single threaded run. The left panel shows the performance on the Haswell Microarchitecture, and the right panel shows the performance on the Sandy Bridge microarchitecture.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 8. The performance of ECDSA sign, ECDSA verify, and ECDE Compute key, measured by 'openssl speed', for  <span class="math">P - 256</span> , at the frequency of  <span class="math">3.4\\mathrm{GHz}</span> , for a single core, and a Hyper Threaded run. The left panel shows the performance on the Haswell Microarchitecture, and the right panel shows the performance on the Sandy Bridge microarchitecture.</p>

    <p class="text-gray-300">Shay Gueron and Vlad Krasnov</p>

    <p class="text-gray-300">We show here the impact of our optimizations at the system level. We measured the actual performance of a Haswell based server machine, running on single core at  <span class="math">1\\mathrm{GHz}</span> , using the ECDHE-ECDSA-AES128-GCM-SHA256 cipher suite (this is the cipher suite selected when connecting to Gmail service with the Chrome browser version 31). We defined the session to download a 500KB file. More details on the configuration used for the experiment are described in Appendix A.</p>

    <p class="text-gray-300">By applying our patch, the server improved its throughput by  <span class="math">1.22x</span>  (from  <span class="math">\\sim 300</span>  to  <span class="math">\\sim 367</span>  connections/second), compared to the original OpenSSL based connection. Fig. 9 shows how the time spent on the different parts of the session (with and without the patch). The ECC computations are reduced from  <span class="math">45\\%</span>  of the CPU time, to only  <span class="math">23\\%</span> .</p>

    <p class="text-gray-300">Fig. 10 provides an update to Fig. 1. It compares the performance of several PFS combinations after our improved ECC implementation. From the figure we can see that the gap between using DHE+RSA vs. ECDHE+RSA grew significantly. In addition, using the combination of ECDHE+ECDSA is roughly five times faster than using RSA, while at the same time providing greater security (128 bit vs. 112 bit) and Perfect Forward Secrecy.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Fig. 9. The time (and its breakdown) to service 2,000 TLS connections, each one downloading a 500KB file. The experiment uses an Apache server profiling tool ("ab"), and is run on a single Haswell core that is down-clocked to 1GHz (Hyper-Threading enabled). The graph compares the development version of OpenSSL to a system with OpenSSL patched with our improved software. It shows that our improvements make the server's throughput  <span class="math">1.2\\mathrm{x}</span>  higher.</p>

    <p class="text-gray-300">Fast Prime Field Elliptic Curve Cryptography with 256 Bit Primes</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Fig. 10. The performance of several signature and key exchange algorithms that can be used for TLS handshake, and provide PFS. The presented results are obtained after the ECC optimizations have been applied, and are to be compared to the graph shown in Fig. 1.</p>

    <p class="text-gray-300">A future Intel microarchitecture may introduce two new instructions, namely ADCX and ADOX that assist high-speed multi-precision integer arithmetic [12]. Together with the instruction MULX (which already exists in the Haswell microarchitecture), two "carry chains" can be parallelized, and this can lead to an efficient implementation of MM. We used these instructions to obtain a further optimized ECC implementation, and report our preliminary results.</p>

    <p class="text-gray-300">Since there is not yet any processor with these instructions, the actual performance of the additional optimization cannot be measured at this point. Therefore, we took a different approach. The code can be compiled (using gcc version 4.8.0 and above), and executed on an emulator (Intel Software Development Emulator - SDE <span class="math">^4</span> ). We used the SDE tool to count the number of executed instructions. Table 1 compares the instructions count of three implementations: OpenSSL and the two optimizations discussed here. The ADCX/ADOX based implementation offers an incremental reduction of  <span class="math">22\\%</span> ,  <span class="math">9\\%</span>  and  <span class="math">18\\%</span>  in the instructions count for ECDH, ECDSA sign, and ECDSA verify, respectively (compared to our first optimization). This gives a strong indication for a future performance improvement in the next generation's processor.</p>

    <p class="text-gray-300">Shay Gueron and Vlad Krasnov</p>

    <p class="text-gray-300">|   | Instructions count  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ECDH</td>

            <td class="px-3 py-2 border-b border-gray-700">2,338,113</td>

            <td class="px-3 py-2 border-b border-gray-700">972,520</td>

            <td class="px-3 py-2 border-b border-gray-700">757,114</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ECDSA sign</td>

            <td class="px-3 py-2 border-b border-gray-700">882,879</td>

            <td class="px-3 py-2 border-b border-gray-700">412,982</td>

            <td class="px-3 py-2 border-b border-gray-700">375,773</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ECDSA verify</td>

            <td class="px-3 py-2 border-b border-gray-700">2,336,523</td>

            <td class="px-3 py-2 border-b border-gray-700">1,077,205</td>

            <td class="px-3 py-2 border-b border-gray-700">880,185</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1. The instructions count for three implementations (see explanation in the text). It shows the potential improvement available by using the future ADCX/ADOX instructions.</p>

    <p class="text-gray-300">Using a combination of algorithmic and software implementation improvements, we considerably sped up the ECC operations with the NIST  <span class="math">P</span> -256 curve. We also showed that this optimization provides a significant improvement at the server's performance level. This makes ECC with this NIST prime more attractive to use.</p>

    <p class="text-gray-300">One of the properties of the NIST 256-bit prime, which we used for optimizing the underlying computations, was that  <span class="math">p_{256}</span>  is an MF prime. However, this property is not unique for the NIST prime, and any ECC standard that uses an MF prime can enjoy the same optimization (of course, with the correct pre-computed tables being used, but this does not affect the resulting performance). Interestingly, there is already such a standardized case, namely the Chinese SM2 public key standard [6]. The relevant SM2 parameters are shown in Fig. 11.</p>

    <pre><code class="language-txt">$\\mathrm{p} = 2^{256} - 2^{225} + 2^{224} - 2^{96} + 2^{64} - 1$  FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
a  $=$  p-3
The base point G:
$\\mathbf{x}_{\\mathrm{G}} =$  0x32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7
$\\mathbf{y}_{\\mathrm{G}} =$  0xBC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0
the order of G, n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123</code></pre>

    <p class="text-gray-300">Fig. 11. The recommended parameters of the State Public Key Cryptographic Algorithm SM2 for public key [6], using a 256-bit Elliptic Curve Cryptography [5]. Note that is satisfies  <span class="math">a = p - 3</span> , and that the prime is an MF prime. This implies that all of the optimizations proposed here can be equally applied to this standard (with the appropriate pre-computed tables).</p>

    <p class="text-gray-300">The implementation described in this paper can be seamlessly integrated into the OpenSSL library, as demonstrated in [10]. The code was contributed as a patch [10], for integration as a whole or in parts, for the benefit the open source community.</p>

    <p class="text-gray-300">Fast Prime Field Elliptic Curve Cryptography with 256 Bit Primes</p>

    <p class="text-gray-300">We conclude with a word of caution with regards to intellectual properties and elliptic curves cryptography. The information in this paper is provided as is. No license (expressed or implied) to any intellectual property right is granted by this paper. The authors and Intel assume no liability whatsoever and disclaim any expressed or implied warranty, including liability or warranties relating to fitness for a particular purpose, merchantability, or infringement of any patent, copyright, or other intellectual property rights.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Aciçmez, O., Gueron, S., Seifert, J.P.: New Branch Prediction Vulnerabilities in Open SSL and Necessary Software Countermeasures. In: Galbarith, S.D (ed.) Cryptography and Coding. LNCS, vol. 4887, pp. 185--203. Springer, Heidelberg (2007).</li>

      <li>Barker, E., Roginsky, A.: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths. NIST Special Publication 800-131A, NIST (2011), http://csrc.nist.gov/publications/nistpubs/800-131A/sp800-131A.pdf</li>

      <li>Booth, A.D.: A Signed Binary Multiplication Technique. In: The Quarterly Journal of Mechanics and Applied Mathematics, 4(2), pp. 236--240. Oxford University Press, Oxford (1951).</li>

      <li>Brent, R., Zimmermann, P.: Modern Computer Arithmetic. In: Cambridge Monographs on Computational and Applied Mathematics (No. 18). Cambridge University Press, Cambridge (2010).</li>

      <li>China Cryptography Administration: SM2 Elliptic curve recommended parameters (in Chinese). http://www.oscca.gov.cn/UpFile/2010122214836668.pdf</li>

      <li>China Cryptography Administration: State Public Key Cryptographic Algorithm SM2 Based on Elliptic Curves (in Chinese). (December 2010), http://www.oscca.gov.cn/UpFile/2010122214822692.pdf</li>

      <li>Dierks, T., Rescorla, E.: The Transport Layer Security (TLS) Protocol Version 1.2. IETF RFC5246. IETF (2008), http://tools.ietf.org//rfc5246</li>

      <li>Gueron, S., Krasnov, V.: [PATCH] Efficient and side channel analysis resistant 1024-bit and 2048-bit modular exponentiation, optimizing RSA, DSA and DH of compatible sizes, for AVX2 capable x86_64 platforms. OpenSSL patch (May 2013), http://rt.openssl.org/Ticket/Display.?id=3054&amp;user=guest&amp;pass=guest</li>

      <li>Gueron, S.: Efficient Software Implementations of Modular Exponentiation. In: Journal of Cryptographic Engineering, vol. 2, pp. 31--43. Springer, Heidelberg (2012).</li>

      <li>Gueron, S., Krasnov, V.: [PATCH] Fast and side channel protected implementation of the NIST P-256 Elliptic Curve, for x86-64 platforms. OpenSSL patch (October 2013), http://rt.openssl.org/Ticket/Display.?id=3149&amp;user=guest&amp;pass=guest</li>

      <li>Greenwald, G., MacAskill, E.: NSA Prism program taps in to user data of Apple, Google and others. In: The Guardian (June 2013), http://www.theguardian.com/world/2013/jun/06/us-tech-giants-nsa-data</li>

      <li>Intel: Intel® Architecture Instruction Set Extensions Programming Reference. http://download-software.intel.com/sites/default/files/319433-015.pdf (July 2013).</li>

      <li>Kasper, E.: Fast Elliptic Curve Cryptography in OpenSSL. In: Danezis, G., Dietrich, S., Sako, K. (eds.) Financial Cryptography and Data Security. LNCS, vol. 7126, pp. 27--39. Springer, Heidelberg (2012).</li>

      <li>Langley, A.: Protecting data for the long term with forward secrecy. In: Google Online Security Blog (November 2011),</li>

    </ol>

    <p class="text-gray-300">Shay Gueron and Vlad Krasnov</p>

    <p class="text-gray-300">http://googleonlinesecurity.blogspot.co.il/2011/11/protecting-data-for-long-term-with.html</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Montgomery, P.L.: Modular Multiplication without Trial Division. In: Mathematics of Computation, vol. 44, pp. 519--521. (1985).</li>

      <li>NIST: Mathematical routines for the NIST prime elliptic curves. (April 2010), http://www.nsa.gov/ia/_files/nist-routines.pdf</li>

      <li>NSS, Mozilla, https://developer.mozilla.org/en/docs/NSS</li>

      <li>OpenSSL git repository, http://git.openssl.org/gitweb/</li>

      <li>Renfro, S.: Secure browsing by default. In: Facebook, Facebook Engineering, https://www.facebook.com/notes/facebook-engineering/secure-browsing-by-default/10151590414803920</li>

      <li>Satler, M., Housley, R.: Suite B Profile for Transport Layer Security (TLS). IETF RFC6460. IETF (January 2012), http://tools.ietf.org//rfc6460</li>

      <li>Solinas, J.A.: Generalized Mersenne Numbers. Technical Report, Center for Applied Cryptographic Research. University of Waterloo (1999).</li>

    </ol>

    <h2 id="sec-17" class="text-2xl font-bold">Appendix A</h2>

    <p class="text-gray-300">The configuration details of the platform that was used for the system profiling experiment:</p>

    <p class="text-gray-300">CPU: Engineering sample of Intel microarchitecture codename Haswell, native speed of 2.9GHz, 4 cores 8 threads. For the experiment, we disabled 3 out of 4 cores and underclocked the CPU to 1 GHz, this helps eliminating the network bottleneck.</p>

    <p class="text-gray-300">Memory: 8GB DDR3 1600MHz, two channel configuration.</p>

    <p class="text-gray-300">Hard Drive: Intel SSD X25-M 80GB.</p>

    <p class="text-gray-300">Software: Apache server version 2.4.4; OpenSSL development version (from September 9, 2013).</p>

    <p class="text-gray-300">Network: Engineering sample of Intel 10Gbit Ethernet adapter</p>`;
---

<BaseLayout title="Fast Prime Field Elliptic Curve Cryptography with 256 Bit Pr... (2013/816)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2013 &middot; eprint 2013/816
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
