---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/1048';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Aggregating and thresholdizing hash-based signatures using STARKs';
const AUTHORS_HTML = 'Irakliy Khaburzaniya, Konstantinos Chalkias, Kevin Lewi, Harjasleen Malvai';

const CONTENT = `    <p class="text-gray-300">Irakiyi Khaburzaniya</p>

    <p class="text-gray-300">Polygon/Meta</p>

    <p class="text-gray-300">irakiy81@gmail.com</p>

    <p class="text-gray-300">Kevin Lewi</p>

    <p class="text-gray-300">Meta</p>

    <p class="text-gray-300">klewi@fb.com</p>

    <p class="text-gray-300">This work presents an approach for compressing hash-based signatures using STARKs (Ben-Sasson et. al.'18). We focus on constructing a hash-based  <span class="math">t</span> -of-  <span class="math">n</span>  threshold signature scheme, as well as an aggregate signature scheme. In both constructions, an aggregator collects individual one-time hash-based signatures and outputs a STARK proof attesting that the signatures are valid and meet the required thresholds. This proof then serves the role of the aggregate or threshold signature. We demonstrate the concrete performance of such constructions, having implemented the algebraic intermediate representations (AIR) for them, along with an experimental evaluation over our implementation of the STARK protocol.</p>

    <p class="text-gray-300">We find that, even when we aggregate thousands of signatures, the final aggregated size ranges between 100KB and 200KB. This makes our schemes attractive when there exist at least 50 one-or-few-times hash-based signatures – such as in the blockchain setting. We also observe that for STARK-based signature aggregation, the size of individual signatures is less important than the number of hash invocations and the complexity of the signature verification algorithm. This implies that simple hash-based signature variants (e.g. Lamport, HORST, BPQS) are well-suited for aggregation, as their large individual signatures serve only as witnesses to the ZKP circuit and are not needed for aggregate signature verification.</p>

    <p class="text-gray-300">Our constructions are directly applicable as scalable solutions for post-quantum secure blockchains which typically employ blocks of hundreds or thousands of signed transactions. Moreover, stateful hash-based one-or-few-times signatures are already used in some PQ-ready blockchains, as address reuse is typically discouraged for privacy reasons.</p>

    <p class="text-gray-300">Irakiyi Khaburzaniya, Kostantinos Chalkias, Kevin Lewi, and Harjasleen Malvai. 2022. Aggregating and thresholdizing hash-based signatures using STARKs. In Proceedings of the 2022 ACM Asia Conference on Computer and Communications Security (ASIA CCS '22), May 30-June 3, 2022, Nagasaki, Japan. ACM, New York, NY, USA, 15 pages. https://doi.org/10.1145/3488932.3524128</p>

    <p class="text-gray-300">Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org.</p>

    <p class="text-gray-300">ASIA CCS '22, May 30-June 3, 2022, Nagasaki, Japan</p>

    <p class="text-gray-300">© 2022 Copyright held by the owner/author(s). Publication rights licensed to ACM.</p>

    <p class="text-gray-300">ACM ISBN 978-1-4503-9140-5/22/05...$15.00</p>

    <p class="text-gray-300">https://doi.org/10.1145/3488932.3524128</p>

    <p class="text-gray-300">Kostantinos Chalkias</p>

    <p class="text-gray-300">Meta</p>

    <p class="text-gray-300">chalkiaskostas@gmail.com</p>

    <p class="text-gray-300">Harjasleen Malvai</p>

    <p class="text-gray-300">UIUC / IC3</p>

    <p class="text-gray-300">hmalvai2@illinois.edu</p>

    <p class="text-gray-300">Aggregate and threshold signature schemes are important cryptographic primitives with real-world applications ranging from Public Key Infrastructure (PKI) to blockchains. Roughly speaking, in an aggregate signature scheme, signatures over unrelated messages that are signed individually by different parties are combined into a single signature. In a threshold signature scheme,  <span class="math">t</span>  out of  <span class="math">n</span>  parties sign a single message  <span class="math">M</span> , and the resulting signature stands in as the signature of all  <span class="math">n</span>  parties over  <span class="math">M</span> .</p>

    <p class="text-gray-300">Of particular interest are schemes where these resulting signatures are succinct (poly-logarithmic in the number of individual signatures) and the amount of interaction between signers is minimal. Schemes with minimal interaction are called one-round or non-interactive. In these non-interactive constructions, a single party (not necessarily one of the signers), usually called the aggregator, collects signatures from individual signers and combines them into a single short aggregate or threshold signature. No other interaction is needed.</p>

    <p class="text-gray-300">As discussed in Sec. 1.2, both aggregate and threshold signatures can be constructed as extensions from a variety of popular choices, including: Schnorr signatures, BLS signatures, and others. Of these, pairing-based signatures stand out as the only ones yielding both succinct and non-interactive aggregate and threshold schemes.</p>

    <p class="text-gray-300">Scaling signatures for blockchains. There are two primary ways in which digital signatures are used in blockchains today:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To sign transactions authorizing transfer of funds between accounts. For example, a single Bitcoin block may contain over 2,500 ECDSA signatures [12], while in some high throughput blockchains, each block may contain upward of 25,000 signatures [43]. Each of these signatures is a one-time-signature and needs to be included in a block. This forms the motivation for aggregate signatures over distinct messages, to compress the footprint of the blockchain.</li>

      <li>In Byzantine Fault Tolerant (BFT) consensus systems, a subset of validators needs to sign the same message to agree on the latest state of the system, and their signatures must be stored on chain. In practical settings, the number of validators could be in the hundreds or even thousands [29]. This informs the need for threshold signatures.</li>

      <li>In particular, compressing the size of threshold signatures allows light clients to verify the evolution of the blockchain, without introducing additional, non-cryptographic trust assumptions. While some work addresses this problem [32], it</li>

    </ul>

    <p class="text-gray-300">remains open in the post-quantum setting. Even bootstrapping regular blockchain clients is becoming increasingly challenging due to the large size of blocks. Aggregating blocks solves this problem.</p>

    <p class="text-gray-300">In both cases, the ability to non-interactively compress thousands of signatures, both with and without thresholds, is instrumental to solving blockchain scalability challenges. Moreover, the blockchain context imposes additional requirements on potential aggregate and threshold signature schemes: public keys of individual signers must be small, and aggregate/threshold signatures must be fast to verify. Small keys are important because even if the signatures are compressed, individual public keys must still be stored on-chain. Fast verification is important because the compressed signatures need to be verified in a variety of settings, including devices with limited capabilities (i.e., light clients).</p>

    <p class="text-gray-300">Note that this setting requires aggregation/thresholdizing to be performed only once, by any third party service which can obtain the individual signatures. Given that providing services to light clients has already proved a viable business model, it is not unreasonable to predict that signature aggregation/thresholdizing for light clients would too. In fact, various (well-funded) businesses already exist <em>(40; 47; 49)</em>, which provide zero-knowledge-based solutions for blockchains, including running servers for heavy-weight computations. So, even the need for relatively powerful machines for aggregating/thresholdizing signatures, does not seem to be a hindrance to adoption.</p>

    <p class="text-gray-300">Finally, given the rising threat of quantum computing and the attacks enabled by them against elliptic curve (EC) based signatures, the blockchain community has an increased interest in exploring the implementation of cryptographic primitives that are not as susceptible to quantum adversaries. Due to their information theoretic security guarantees, hash-based signatures make good candidates for long-lasting, post-quantum blockchains, but so far, the absence of practical threshold and aggregate constructions have hindered their wider adoption. To the best of our knowledge, there are currently no signature schemes which meet all of the above requirements: succinctness, non-interactivity, and resistance to quantum attacks. However, a general methodology for constructing such a scheme is well-known: one can use a general-purpose zero-knowledge proof (ZKP) system to generate a proof attesting that a set of signatures is valid and/or meets the required threshold. In fact, these techniques have already been applied in practice to EC-based signatures <em>(32)</em>.</p>

    <p class="text-gray-300">In this work, we present the first practical construction and concrete implementation of using a post-quantum ZKP to compress hash-based signatures, which are inherently more resistant to quantum attacks. Although the idea of using ZKPs for compression is not new, in practice these techniques are straightforward neither to implement nor evaluate for concrete performance statistics. We show how to make existing one-time hash-based signatures STARK-friendly by employing optimized encoding techniques. We provide concrete results as well as an open-source framework for performing efficient signature compression that is resistant against quantum attacks. We believe that our work can form the basis of reusing the proposed aggregated and threshold one-time signature gadgets for more complex many-times hash-based signature schemes (if required), when a zero knowledge proof friendly hash function, such as Rescue<em>(3)</em>, is applied. Specifically, all of the presented algorithms are available in our open-sourced <em>(6)</em> STARK library for arbitrary computations, which will hopefully help the community on benchmarking, reusing and modifying the proposed <em>multi</em> and <em>threshold</em> hash-based signatures via STARK <em>(8)</em> proofs.</p>

    <p class="text-gray-300">Note that while recent work <em>(33)</em> has provided general purpose virtual machines for STARKs, it is well-known that hand optimized representations of STARK programs are significantly more performant. Yet, writing special purpose represenatations of programs for STARKs programs remains challenging. Writing algebraic intermediate representations (AIRs) for these constructions is, hence, a useful contribution of this work. We hope that our work will provide useful examples for others in the community.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.1. Overview of Our Constructions</h3>

    <p class="text-gray-300">Our constructions of aggregate and threshold signatures are built using a combination of hash-based signatures and a STARK protocol. In both constructions, individual signers sign messages using a regular hash-based signature scheme, and an aggregator uses the STARK to compress individual signatures into a single succinct proof.</p>

    <p class="text-gray-300">Our aggregate signature scheme is described in Sec. 4, and the threshold scheme is described in Sec. 5. In both cases, aggregate signature sizes are logarithmic in the number of individual signatures, with practical output sizes between 100KB and 200KB. This makes our schemes especially attractive when aggregating over 50 individual signatures. The signature verification is fast (i.e., 5 ms), but the aggregation may require significant time and/or processing power. We provide evaluation of concrete results in Sec. 6.</p>

    <p class="text-gray-300">Our constructions can be immediately applicable to post-quantum resistant blockchains deployed today <em>(31)</em> without requiring users to update their existing private keys. Many of these blockchains use stateful and one-or-few times hash-based signature schemes, resulting in individual signatures of <span class="math">\\sim</span>2KB in the best case. For example, Quantum Resistant Ledger <em>(51)</em> uses XMSS (recommended by NIST in SP 800-208 <em>(26)</em>) and WOTS+ <em>(20)</em>, IOTA <em>(46)</em> depends on a custom hash-based signature called Kerl (based on Keccak, with conversion to ternary) and implements WOTS, and finally Corda <em>(18)</em> supports Sphincs <em>(11)</em> and explores BPQS <em>(22)</em>, a blockchain friendly XMSS variant, that starts as one-time, but can be extended to a many-times scheme only when required.</p>

    <p class="text-gray-300">Hash-based signatures. For our underlying signature scheme, we present a one-time signature (OTS) scheme, <span class="math">\\text{Lamport+}</span> which is described in detail in Sec. 3 and based on <span class="math">\\text{Lamport}</span>’s original one-time signatures. The primary motivation for using <span class="math">\\text{Lamport+}</span> is its efficient encoding in ZKP systems. Our instantiation of plain <span class="math">\\text{Lamport+}</span> has 32-byte public keys, produces 8KB signatures, and targets 123 bits of security. We also provide an optimized <span class="math">\\text{Lamport+}</span> version applying a “mining” technique to the message hash to be signed, which allows targeting 127 bits of security.</p>

    <p class="text-gray-300">Extending to many-time signatures. While <span class="math">\\text{Lamport+}</span> is designed to be an OTS scheme primarily to minimize implementation complexity, it is possible to replace it with a many-time hash-based signature scheme at the expense of a slight increase in ZKP circuit</p>

    <p class="text-gray-300">complexity and aggregate signature generation time. After all, Lamport/WOTS variants are the building blocks of many-time schemes like Sphincs <em>(11)</em> and XMSS <em>(20)</em>.</p>

    <p class="text-gray-300">STARKs. For the ZKP system used to combine individual hash-based signatures into a single aggregate or threshold signature, we employ STARKs <em>(8)</em>. The primary motivation is that this scheme is hash-based and hence secure against quantum attacks <em>(24)</em>. Although post-quantum security is not unique to STARKs, they yield the best concrete efficiency of all known alternatives <em>(4; 9; 25)</em>, especially in terms of proof verification times.</p>

    <p class="text-gray-300">In this work, we do not cover the details of the STARK protocol itself(see for e.g. <em>(8)</em> for more details); however, we provide descriptions of arithmetizations for all computations involved in STARK proof generation. Arithmetization in STARKs consists of defining an intermediate algebraic representation (AIR) for a computation. STARKs are especially performant when proving computations which have a large number of repeated operations. However, translating computations into efficient AIRs is non-trivial, and we anticipate that our presentation of AIRs will motivate developers to using STARKs.</p>

    <p class="text-gray-300">Moreover, we have implemented a fully-featured and performant STARK prover and verifier in Rust, and open-sourced our implementation under the MIT license <em>(6)</em>. In addition to the STARK prover and verifier, our open-source Github repository contains examples of all AIRs described in this work.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.2. Related Work</h3>

    <p class="text-gray-300">Currently some of the most popular signature schemes in both literature and practice include the elliptic curve based ECDSA and EdDSA (or other Schnorr variants), RSA, pairing-based schemes such as BLS, and the many post-quantum (PQ) algorithms proposed in NIST’s PQ standardization process i.e., based on hash functions or lattices <em>(1)</em>. Various research efforts have focused on extending the original schemes by supporting faster batch verification, shorter aggregated signatures over the same or different messages and threshold schemes. Two of the most common metrics include signature compression rate and rounds of interactivity, ideally offering a non-interactive solution where signers do not need to engage in any type of communication between them to output a compressed aggregated signature.</p>

    <p class="text-gray-300">Regarding ECDSA, to the best of our knowledge schemes for non-interactive aggregation don’t exist, mainly due to the modular inversion involved <em>(41)</em>. Similarly, in RSA the modulus <span class="math">N</span> is different between users, which makes interactivity essential <em>(15)</em>. Aggregating Schnorr-based schemes requires various additional steps such as distributed key generation (DKG) or at least one round of interaction (see, for example <em>(37)</em>). A promising work is that of Musig2 <em>(44)</em>, which can support pre-processing of all but the first round, but this still cannot work for blockchain users, since they do not engage in a setup protocol. Two other interesting approaches include the recent non-interactive EdDSA half-aggregation <em>(23)</em> and <span class="math">\\Gamma</span>-signatures <em>(52)</em> (a Schnorr variant), where both achieve 50% signature compression. Of these schemes, BLS aggregation is most notable for its efficiency and the fact that third parties can aggregate public keys as well as signatures. In other words, no interaction between individual signers is needed. Unfortunately though, all of the above are not PQ-secure.</p>

    <p class="text-gray-300">Recent works construct post-quantum aggregatable signature schemes relying on lattice-based assumptions <em>(13; 30; 45)</em>, but also require a setup step such as DKG or an interactive protocol to generate aggregated keys. A few schemes including MMSAT <em>(28)</em>, the scheme of Boneh and Kim <em>(16)</em> and that of Boudgoust and Roux-Langlois <em>(17)</em> are aggregatable and don’t require setup. These are based on the random oracle model (ROM) and the Short Integer Solution (SIS) problem. In particular, <em>(17)</em> is based on the well-studied Module SIS and Module LWE assumptions. None of <em>(16; 17; 28)</em> provides a threshold signature scheme. Further, the aggregate signatures of <em>(28)</em> grow linearly in the number of parties, even though the constant is small. Various post-quantum constructions for ring and group signatures have also been proposed using lattices <em>(50)</em> as well as the ROM <em>(36)</em>. However, we are not aware of efficient aggregatable constructions for hash-based post-quantum schemes, (e.g. XMSS <em>(20)</em>, Sphincs <em>(11)</em>, BPQS <em>(22)</em>), although there exist STARK-based signature schemes (e.g. Ziggy <em>(48)</em>), which, with recursive STARKs might be efficiently aggregated; although as far as we know, such a construction has been mentioned in webinars <em>(7)</em>, but not yet been published or standardized.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2. Preliminaries</h2>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.1. STARKs Protocol</h3>

    <p class="text-gray-300">We define a STARK protocol as a tuple of three algorithms <span class="math">\\textsc{STARK}=(\\textsc{Setup},\\textsc{Prove},\\textsc{Verify})</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\textsc{pp}\\leftarrow\\textsc{STARK}.\\textsc{Setup}(1^{\\lambda},\\textsc{Prog})</span>: Takes in the security parameter <span class="math">\\lambda</span>, and the description of a <span class="math">\\textsc{Prog},\\{0,1\\}^{*}\\rightarrow\\{0,1\\}</span> and outputs public parameters <span class="math">\\textsc{pp}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\pi\\leftarrow\\textsc{Prove}(\\textsc{pp},\\textsc{stmt},w)</span>: Takes in the public parameters, a statement <span class="math">\\textsc{stmt}</span>, witness <span class="math">w</span>, such that $\\textsc{Prog}(\\textsc{stmt}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w)=1<span class="math"> and outputs a proof </span>\\pi$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b\\leftarrow\\textsc{Verify}(\\textsc{pp},\\pi,\\textsc{stmt})</span>: Takes in the public parameters and outputs a bit 1 or 0 (denoting accept or reject).</li>

    </ul>

    <p class="text-gray-300">We also assume that <span class="math">\\textsc{STARK}.\\textsc{Setup}</span> is <em>transparent</em>, meaning that it relies only on public randomness and satisfies standard security definitions for SNARKs including completeness and knowledge soundness (also known as knowledge extraction). We defer to the literature for more details (e.g. see <em>(4; 8; 9; 25; 38)</em>).</p>

    <p class="text-gray-300">STARK parameters. Our instantiation of the STARK protocol uses parameters shown in Table 1. For the base field we use a 128-bit prime field with modulus <span class="math">q=2^{128}-45\\cdot 2^{40}+1</span>. This choice is motivated by the following factors:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Modern CPUs can perform arithmetic operations with 128-bit integers relatively efficiently, and Rust has native support for u128 integer type.</li>

      <li>This specific field is STARK-friendly as it has high-order roots of unity. (specifically, <span class="math">2^{40}</span> roots of unity).</li>

      <li>This specific field allows computing roots of 5th power, i.e., <span class="math">(M-1)\\mod 5\\neq 0</span>. This is required for our instantiation of Rescue hash function.</li>

    </ol>

    <p class="text-gray-300">ASIA CCS '22, May 30-June 3, 2022, Nagasaki, Japan</p>

    <p class="text-gray-300">Irakliy Khaburzaniya, Kostantinos Chalkias, Kevin Lewi, and Harjasleen Malvai</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Security level</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Base field</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Blowup factor</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Query count</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Grinding factor</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Folding factor</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hash function</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">96 bits</td>

            <td class="px-3 py-2 border-b border-gray-700">128 bits</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">BLAKE3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">123 bits</td>

            <td class="px-3 py-2 border-b border-gray-700">128 bits</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">BLAKE3</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: STARK parameters for 96-bit and 123-bit security levels using the same base field. For 96-bit security level, output of BLAKE3 hash function is truncated to 24 bytes to provide up to 96-bit collision resistance. For 123-bit security level, FRI protocol must be run in a quadratic extension of the base field.</p>

    <p class="text-gray-300">Arithmetization is the reduction of computational statements to a set of algebraic statements involving a set of bounded-degree polynomials. In the STARK protocol, the output of arithmetization is an Algebraic Intermediate Representation of a computation. Formal definition of AIR is provided in [8], but informally, AIR consists of the following three elements:</p>

    <p class="text-gray-300">(1) execution trace which is a two-dimensional matrix, in which each row represents the state of the computation at a single point in time and each column corresponds to an algebraic register tracked over all steps of the computation. Let  <span class="math">T</span>  denote the execution trace matrix. (2) transition constraints which define algebraic relationships between two (or more) rows of the execution trace. (3) boundary constraints which enforce equality between certain cells of the execution trace and a set of constant values. Boundary constraints can be thought of as defining a set of input and output values for the computation.</p>

    <p class="text-gray-300">Execution trace. Denote  <span class="math">m</span>  as the width of the execution trace and  <span class="math">n</span>  as the number of steps in the execution trace, i.e.  <span class="math">T</span>  is an  <span class="math">m \\times n</span>  matrix. We define the register trace of a register  <span class="math">k</span>  as the polynomial interpolation  <span class="math">f_{k}</span>  of the set  <span class="math">\\{(\\omega^{i}, T[i][k]) \\mid i \\in [0, n)\\}</span> , where  <span class="math">\\omega</span>  is a generator of a multiplicative subgroup of size  <span class="math">n</span>  in the base field specified for an instantiation of a STARK protocol. The set  <span class="math">\\{f_{k} \\mid k \\in [0, m)\\}</span>  is called the set of trace polynomials.</p>

    <p class="text-gray-300">Notice that if  <span class="math">f_{k}(x)</span>  is the value in the execution trace matrix in column  <span class="math">k</span>  and row  <span class="math">i</span> , then  <span class="math">f_{k}(x \\cdot \\omega)</span>  is the value in  <span class="math">k</span>  at step  <span class="math">i + 1</span> .</p>

    <p class="text-gray-300">For efficient execution of the STARK protocol,  <span class="math">n</span>  must be a power of two. This allows us to use FFT-based polynomial evaluation and interpolation, which have the complexity of  <span class="math">O(n\\log n)</span> . Thus, the base field for the STARK protocol must be 2-smooth <span class="math">^1</span> , which indeed is the case for out selected field with modulus  <span class="math">q = 2^{128} - 45 \\cdot 2^{40} + 1</span> .</p>

    <p class="text-gray-300">In addition to registers of the execution trace, we also use periodic registers (also called periodic columns), which are not included in the execution trace but can be referenced in transition constraints. Periodic columns are typically used in STARKs to encode a small set of values which can be represented by succinct polynomials of size much smaller than  <span class="math">n</span> . One example is a register where values repeats in a cycle and the length of the cycle is a power of two.</p>

    <p class="text-gray-300">Constraints. Both boundary and transition constraints are defined by rational functions of the form:</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {p (x)}{z (x)}</span></div>

    <p class="text-gray-300">where,  <span class="math">p(x)</span>  defines the constraint relationship, and  <span class="math">z(x)</span>  defines the constraint domain (a set of steps at which the constraint should hold). This constraint is said to hold if the polynomial  <span class="math">z</span>  divides the polynomial  <span class="math">p</span> .</p>

    <p class="text-gray-300">For boundary constraints,  <span class="math">p(x)</span>  has the following form:</p>

    <div class="my-4 text-center"><span class="math-block">p (x) = c \\left(f _ {k} (x)\\right)</span></div>

    <p class="text-gray-300">where,  <span class="math">f_{k}(x)</span>  is the trace polynomial for register  <span class="math">k</span>  against which the constraint is enforced. For example, to specify that the value in the first column of the first row in the execution trace must be 1, we could use the following constraint:</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {f _ {0} (x) - 1}{x - 1}</span></div>

    <p class="text-gray-300">Similarly, to specify that the value in the 7th row of the second column must be 987, we could use the following constraint:</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {f _ {1} (x) - 9 8 7}{x - \\omega^ {7}}</span></div>

    <p class="text-gray-300">For transition constraints,  <span class="math">c(x)</span>  has the following form:</p>

    <div class="my-4 text-center"><span class="math-block">p (x) = c \\left(\\left\\{f _ {0} (x), \\dots , f _ {m - 1} (x) \\right\\}, \\left\\{f _ {0} (x \\cdot \\omega), \\dots , f _ {m - 1} (x \\cdot \\omega) \\right\\}\\right)</span></div>

    <p class="text-gray-300">that is,  <span class="math">c(x)</span>  is a function of all register values in two consecutive steps of a computation. For example, the following constraint enforces that a value in the first register of the execution trace must be incremented by 1 at every step:</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {f _ {0} (x \\cdot \\omega) - (f _ {0} (x) + 1)}{\\prod_ {i = 0} ^ {n - 1} (x - \\omega^ {i})}</span></div>

    <p class="text-gray-300">Additionally, since trace polynomials are evaluated over a multiplicative subgroup of a field, the denominator of the constraint above can be expressed succinctly, and the constraint can be rewritten as:</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {f _ {0} (x \\cdot \\omega) - (f _ {0} (x) + 1)}{x ^ {n} - 1}</span></div>

    <p class="text-gray-300">Below, we describe transition constraints using the notation  <span class="math">c(x)</span>  for  <span class="math">(x^n - 1) / (x - \\omega^{n-1})</span> , as the denominator for all transitions constraints is the same. This denominator specifies that transition constrains should hold on all but the last steps of the execution trace. The degree of a transition constraint is defined as  <span class="math">deg(c(x))</span> .</p>

    <p class="text-gray-300">Accumulators are well-studied cryptographic primitives used for committing to sets and verifying set membership and non-membership. In particular, we denote an accumulator protocol  <span class="math">\\mathrm{ACC} = (\\mathrm{ACC}. \\mathrm{Setup}, \\mathrm{ACC}. \\mathrm{Eval}, \\mathrm{ACC}. \\mathrm{WitCreate}, \\mathrm{ACC}. \\mathrm{Verify})</span>  and require it to be a secure static accumulator as defined in Definition 5 of [27].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Accumulator for Lamport+ public key. For the purpose of constructing a Lamport+ public key, we construct ACC using a linear accumulator with minor modifications. Specifically, in a standard linear accumulator, given a random oracle <span class="math">\\mathcal{H}</span> and a set of <span class="math">n</span> elements <span class="math">S</span>, ACC.Eval(<span class="math">\\mathcal{H},S</span>) outputs a commitment to <span class="math">S</span> as $\\mathcal{H}(s_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{n-1})<span class="math"> where </span>s_{i}\\in S<span class="math">. However, in our instantiation, ACC.Eval(</span>\\mathcal{H},S<span class="math">) outputs </span>\\mathcal{H}(s_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{n/2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{n/2+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{n/2-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{n-1})$. We call this construction a “zig-zag” accumulator. This construction allows us to simplify the design of AIR for Lamport+ signature verification. Specifically, using zig-zag accumulator, we are able to absorb public sub-keys for message bits which are 128 bits apart in a single execution trace step. This, in turn, allows us to verify sub-keys for both message elements in parallel, with no extra computational overhead.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Accumulator for key aggregation. In our implementation, we construct ACC using a Merkle Tree in the standard way i.e., given a random oracle <span class="math">\\mathcal{H}</span>, each of the leaves is a binding commitment to the elements of a set <span class="math">S</span>, and the output of ACC.Eval(<span class="math">\\mathcal{H},S</span>) is root, the root of the Merkle tree. Correspondingly, the output of ACC.WitCreate(<span class="math">\\mathcal{H},\\text{root},x</span>) for some <span class="math">x\\in S</span> is the Merkle Tree path to the commitment to <span class="math">x</span> and the opening to that commitment. Ultimately, this implies that the proofs of membership for a set <span class="math">S</span> are logarithmic in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-11" class="text-2xl font-bold">3. Lamport+: The Modified Wots Signature Scheme</h2>

    <p class="text-gray-300">A majority of recent work focuses on stateless many-times hash-based signatures, optimized for both short public keys and signatures. This leads to compromises in efficiency, mainly for key generation and signing. To optimize instead, for the blockchain context and signature aggregation using STARKs, we arrive at the following desiderata: (1) short public keys, ideally one 32-byte hash element; (2) small and easy to implement circuits, optimized for AIR; (3) the fewest possible hash invocations during verification.</p>

    <p class="text-gray-300">The size of the signature is not our primary focus, because the aim of this work is for a powerful prover to aggregate signatures using STARKs and thus, the sizes of the original signatures do not have a bearing on the bandwidth of the end verifier. For this reason, for our proof-of-concept, we use the simplest version of the Winternitz one-time signature (WOTS) <em>(WOTS, 2018)</em>, which we call Lamport+. For the hash function, we use Rescue, for which no quantum attacks are known and which has a very efficient AIR, which we describe in App. A. We also note that OTS is a powerful primitive used in building most hash-based many-time signatures. Instantiated with the Rescue hash-function, the final Lamport+ algorithm outputs signatures of about 8KB (254 <span class="math">\\times</span> 32B hash elements).</p>

    <p class="text-gray-300">Our proof of concept implementation is based on an OTS algorithm we will refer to as Lamport+, a checksum-based OTS proposed by Merkle (section 4 in <em>(Merkle, 2018)</em>) which happens to be an instance of WOTS using <span class="math">w=2</span> as the Winternitz parameter. We picked this scheme to minimize the number of hash invocations, which otherwise would a) complicate the AIR representation of the algorithm and b) result to slower proof generation. The major difference against the naive Lamport OTS is that instead of requiring two keys per bit, one for the “0” bit and one for the “1” bit, we can by convention only sign the set bits of the signed message. This cuts the public and secret key sizes in half, while maintaining the same number of hash invocations with the original Lamport scheme. However, an extra checksum is required to prevent an adaptive chosen message attack where adversaries can just flip set bits to “0”. The checksum is nothing more than the total number of zero bits in the original message.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">3.1. Formal construction</h3>

    <p class="text-gray-300">Let <span class="math">M</span> be a bit-string that represents the message of length <span class="math">m</span> to be signed and G : <span class="math">\\{0,1\\}^{*}\\to\\{0,1\\}^{m}</span> be a hash function in the ROM. The public parameters are pp = (pp_{ACC}, G, <span class="math">m</span>), where pp^{acc} is the public key for an accumulator as described in Sec. 2. The Lamport+ construction LP = (LP.KeyGen, LP.Sign, LP.Verify) is defined as:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(priv, pub) <span class="math">\\leftarrow</span> LP.KeyGen(pp; <span class="math">r</span>). Given the public parameters pp and randomness <span class="math">r</span> as inputs, KeyGen computes the private key, which consists of <span class="math">n=m+\\mathit{log}(m)</span> bit-strings of length <span class="math">m</span> chosen randomly from a uniform distribution. For <span class="math">i\\in[0,n)</span> compute a list of tuples (<span class="math">pr_{i},pb_{i}=\\text{G}(pr_{i})</span>). Each <span class="math">pb_{i}</span> corresponds to the sub-public-key for each the message-hash bit <span class="math">m_{i}</span> to be signed. Optionally, we can derive the final public key as pub <span class="math">\\leftarrow</span> ACC.Eval(pp_{ACC}, <span class="math">\\{pb_{0},\\ldots,pb_{n-1}\\}</span>) and output (priv, pub). The latter is a commonly used practice in hash-based schemes to compress sub-public-keys into a single short value.</li>

      <li>sig <span class="math">\\leftarrow</span> LP.Sign(pp, <span class="math">M</span>, priv). On inputs public parameters pp, message <span class="math">M</span> and private key priv, expand the private key to the list of tuples (<span class="math">pr_{i},pb_{i}</span>) similarly to KeyGen .</li>

    </ul>

    <p class="text-gray-300">Count the number of zeros on the message’s <span class="math">m</span> bits (this is the Winternitz checksum) and append this number to <span class="math">M</span> representing it with <span class="math">\\lceil\\log(m)\\rceil</span> bits, which will result to a <span class="math">n</span> bit length bit-string. We call the resulted <span class="math">n</span>-sized bitstream as <span class="math">m^{\\prime}</span>. Compute the signature as follows: For <span class="math">i\\in[0,n)</span> if <span class="math">m^{\\prime}_{i}=1</span> append <span class="math">pr_{i}</span> to sig, else append <span class="math">pb_{i}</span>. Output sig, which is a list of size <span class="math">n</span> of <span class="math">m</span>-sized elements.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>z <span class="math">\\leftarrow</span> LP.Verify(pp, <span class="math">M</span>, pub, sig). On input the public parameters pp, the signed message <span class="math">M</span>, the public key pub and the signature <span class="math">sig</span>, compute <span class="math">m^{\\prime}</span> similarly to Sign and execute the following logic: <span class="math">x\\leftarrow</span> For <span class="math">i\\in[0,n)</span> if <span class="math">m^{\\prime}_{i}=1</span> append G(sig_{i}) to <span class="math">x</span>, else append sig_{i}. The verify algorithm outputs the bit z <span class="math">\\leftarrow</span> pub == ACC.Eval(pp_{ACC}, <span class="math">\\{x_{0},\\ldots,x_{n-1}\\}</span>).</li>

    </ul>

    <p class="text-gray-300">Security intuition. As already mentioned, Lamport+ is a WOTS instance for <span class="math">w=2</span> (Winternitz parameter). <em>Buchmann et al. (2018)</em> present and prove the security of the WOTS signature scheme. In particular, they include the definition for security of a one-time signature as existential unforgeability under chosen message attacks (EU-CMA), where the attacker has access to a signing oracle but makes only one query. Under the assumption that the used hash function is a PRF, they show that a EU-CMA adversary has negligible advantage, which inherently applies to Lamport+ too.</p>

    <p class="text-gray-300">Compression via mining without security loss Note that it is possible to further compress the input message to less than <span class="math">m</span> bits and still maintain the security level at <span class="math">m/2</span> (collision resistance) as proposed in <em>(Buchmann et al., 2018)</em>. That would allow for reducing the size of <span class="math">n</span>,</p>

    <p class="text-gray-300">ASIA CCS '22, May 30-June 3, 2022, Nagasaki, Japan</p>

    <p class="text-gray-300">Irakliy Khaburzaniya, Kostantinos Chalkias, Kevin Lewi, and Harjasleen Malvai</p>

    <p class="text-gray-300">which effectively means less sub-key tuples. Briefly, it is a common practice to sign hashes of the message, which makes sense especially when the message is larger than <span class="math">m</span> bits. The algorithm applies the following “mining” technique to any Lamport or WOTS based scheme: instead of directly using the output of G(<span class="math">M</span>), we could apply an extra HMAC <span class="math">H^{\\prime}:\\left(\\{0,1\\}^{<em>},\\{0,1\\}^{</em>}\\right)\\rightarrow\\{0,1\\}^{m^{\\prime}}</span>, with inputs the <span class="math">M</span> and a counter <span class="math">c</span>. In fact, we retry HMACing (mining) as <span class="math">h_{m}=H^{\\prime}(M,c_{i})</span>, for a counter <span class="math">c</span> starting from <span class="math">0</span>, until <span class="math">h_{m}</span> starts with <span class="math">k</span> zero bits. Then an application can completely omit the prefix zero-bits and only accept inputs of size <span class="math">m^{\\prime}</span>. Although this reduces the message space, the pre-image and collision resistance do not change, essentially like proof-of-work. The verifier could either try the same mining technique or signers can just attach the counter <span class="math">c</span> to the signature and the verifier will verify (outside the STARK proof) that <span class="math">h_{m}=H^{\\prime}(M,c)</span> starts with <span class="math">k</span> zero bits.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">3.2. Signature verification AIR</h3>

    <p class="text-gray-300">LP.Verify procedure, as it is described above, is not particularly ”AIR-friendly”, neither from the standpoint of circuit design complexity, nor from the standpoint of STARK proof generation complexity. Therefore, we make several adjustments to the original procedure to make it more AIR-friendly.</p>

    <p class="text-gray-300">First, we set hash function G to Rescue-Prime (see App. A). In our instantiation, G accepts a sequence of 128-bit field elements as input, and outputs a hash which is represented by a tuple of 128-bit field elements . This means that all sub-keys <span class="math">pr_{i}</span> must be tuples of valid field elements, and thus, we augment the key generation procedure to output tuples of field elements rather than bit strings for <span class="math">pr_{i}</span>. This naturally implies that sub-keys <span class="math">pb_{i}</span> are also represented by tuples of field elements since <span class="math">pb_{i}=\\text{G}(pr_{i})</span>, and G outputs a tuple of field elements as mentioned above.</p>

    <p class="text-gray-300">Second, as described above, LP.Verify accepts message <span class="math">M</span> as a bit string and reduces it to a value <span class="math">h^{\\prime}</span>, and then verifies the signature against this value. For AIR-friendly version, we need <span class="math">h^{\\prime}</span> to be a tuple of field elements. However, performing this reduction inside a STARK is expensive. Thus, to minimize complexity of AIR for LP.Verify, we break it into two parts. The first part consists of reducing <span class="math">M</span> to a tuple of field elements <span class="math">h^{\\prime}=(m_{0},m_{1})</span> and is done outside of the ZKP circuit (this also includes computing message checksum). The second part verifies the signature against <span class="math">(m_{0},m_{1})</span>, and requires at most 381 invocations of hash function <span class="math">G</span>.</p>

    <p class="text-gray-300">Alg. 1 provides a high-level description of an AIR-friendly version of LP.Verify procedure. The algorithm receives pre-processed message <span class="math">(m_{0},m_{1})</span> and a public key <span class="math">pub</span> (which is also represented by a tuple of field elements) as public inputs. The signature, as well as arrays with binary decompositions of <span class="math">m_{0}</span> and <span class="math">m_{1}</span> in little-endian byte order, are passed in as a private witness.</p>

    <p class="text-gray-300">With each iteration of the loop, the algorithm consumes two bits from the message bit arrays (one bit from <span class="math">m_{{}_{0}}</span> and another bit from <span class="math">m_{{}_{1}}</span>), accumulates these bits in accumulators <span class="math">m^{acc}_{0}</span> and <span class="math">m^{acc}_{1}</span>, and based on the values of these bits, updates public key accumulator <span class="math">pub^{acc}</span>. Specifically, when a message bit at position <span class="math">i</span> is one, G(<span class="math">sig_{i}</span>) is added to the accumulator; otherwise, <span class="math">sig_{i}</span> is added to the accumulator.</p>

    <p class="text-gray-300">The program outputs <span class="math">true</span>, iff values of all accumulators are equal to the corresponding values passed in via public inputs. This ensures that signature verification passes only if a valid signature over the message represented by <span class="math">(m_{0},m_{1})</span> was passed in via the private witness.</p>

    <p class="text-gray-300">Algorithm 1 AIR-friendly variant of LP.Verify ⬇ inputs: <span class="math">m_{0},m_{1},pub</span> witness: <span class="math">m_{{}_{0}}[],m_{{}_{1}}[],sig[]</span> <span class="math">m^{acc}_{0}\\leftarrow 0</span>, <span class="math">m^{acc}_{1}\\leftarrow 0</span> <span class="math">pub^{acc}\\leftarrow new\\_hasher()</span> for i in 0..128 do <span class="math">m^{acc}_{0}\\leftarrow m^{acc}_{0}+m_{{}_{0}}[i]<em>2^{i}</span> <span class="math">m^{acc}_{1}\\leftarrow m^{acc}_{1}+m_{{}_{1}}[i]</em>2^{i}</span> if <span class="math">m_{{}_{0}}[i]==1</span> then <span class="math">pub^{acc}\\leftarrow pub^{acc}.update(hash(sig[i]))</span> else <span class="math">pub^{acc}\\leftarrow pub^{acc}.update(sig[i])</span> end if if <span class="math">m_{{}_{1}}[i]==1</span> then <span class="math">pub^{acc}\\leftarrow pub^{acc}.update(hash(sig[i+128]))</span> else <span class="math">pub^{acc}\\leftarrow pub^{acc}.update(sig[i+128])</span> end if end for <span class="math">pub^{acc}\\leftarrow pub^{acc}.finalize()</span> return <span class="math">m_{0}==m^{acc}_{0}\\&amp;amp;&amp;amp;m_{1}==m^{acc}_{1}\\&amp;amp;&amp;amp;pub=pub^{acc}</span></p>

    <p class="text-gray-300">In our implementation, AIR for the program described in Alg. 1 works over an execution trace of 22 registers and 1024 steps. The highest degree of transition constraints is 6. The registers are grouped into three logical groups:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Message accumulators: 4 registers for computing <span class="math">m^{acc}_{0}</span> and <span class="math">m^{acc}_{1}</span> values.</li>

      <li>Signature element hashing: 12 registers for computing G(<span class="math">sig_{i}</span>). Here, we use 12 registers because we hash two signature elements in parallel: <span class="math">sig_{i}</span> and <span class="math">sig_{i+128}</span> for all <span class="math">i\\in\\{0..128\\}</span>, and each hash requires 6 registers to compute.</li>

      <li>Public key accumulator: 6 registers for computing the value of <span class="math">pub^{acc}</span>.</li>

    </ol>

    <p class="text-gray-300">Each of these groups and corresponding transition constraints are described in detail in the following sections.</p>

    <p class="text-gray-300">The length of the execution trace is 1024 steps because for every consumed pair of message bits, we compute hashes of corresponding signature elements. As described in App. A, in our implementation, the AIR for a single invocation Rescue-Prime hash function requires an execution trace of 8 steps long. Thus, for each pair of message bits we need to add 8 steps to the execution trace, and since the total number of bit pairs is 128, we arrive at 1024 total steps.</p>

    <p class="text-gray-300">Our AIR also relies on several periodic columns, two of which are of particular importance:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Column <span class="math">m_{h}</span> encodes a pattern of values which specifies that every <span class="math">8^{th}</span> step, starting with step 7, <span class="math">m_{h}=1</span>. For all other steps <span class="math">m_{h}=0</span>. This column is used to simulate rudimentary control flow.</li>

      <li>Column <span class="math">m_{p}</span> contains increasing powers of two incremented every 8 steps. For example, for the first 8 steps, <span class="math">m_{p}=2^{0}</span>,</li>

    </ul>

    <p class="text-gray-300">Aggregating and thresholdizing hash-based signatures using STARKs</p>

    <p class="text-gray-300">ASIA CCS '22, May 30-June 3, 2022, Nagasaki, Japan</p>

    <p class="text-gray-300">for the following 8 steps, <span class="math">m_{p}=2^{1}</span>, for the following 8 steps <span class="math">m_{p}=2^{2}</span> etc. This column is used by message accumulators.</p>

    <p class="text-gray-300">A simplified schematic of a trace for verifying a signature over a 6-bit message is shown in Fig. 1.</p>

    <p class="text-gray-300">Message accumulators. Registers <span class="math">\\{r_{0},..,r_{3}\\}</span> bind the execution trace to the message over which the signature is being verified. Recall that in our case, a message is represented by two elements in a 128-bit field: <span class="math">m_{0}</span> and <span class="math">m_{1}</span>. Registers <span class="math">r_{2}</span> and <span class="math">r_{3}</span> contain binary decompositions of <span class="math">m_{0}</span> and <span class="math">m_{1}</span> respectively, in little-endian byte order such that new bits are inserted into the registers every 8 steps. Registers <span class="math">r_{0}</span> and <span class="math">r_{1}</span> contain accumulated values of <span class="math">m_{0}</span> and <span class="math">m_{1}</span> at a given step of the execution trace, such that by the end of the trace, <span class="math">r_{0}=m_{0}</span> and <span class="math">r_{1}=m_{1}</span>.</p>

    <p class="text-gray-300">The accumulation is performed as follows: on every <span class="math">8^{th}</span> step of the computation, the value of register <span class="math">r_{2}</span> is multiplied by the value of <span class="math">m_{p}</span>, which contains powers of two incremented every 8 steps as described previously. The result is then added into the register <span class="math">r_{0}</span>. The same computation is applied to registers <span class="math">r_{1}</span> and <span class="math">r_{3}</span>. We perform these computations on every <span class="math">8^{th}</span> step because intermediate steps are needed for Rescue hash computations in other registers, and all registers must have the same number of steps. This effectively ”wastes” most of the cells in registers <span class="math">r_{0}</span>, <span class="math">r_{1}</span>, <span class="math">r_{2}</span>, and <span class="math">r_{3}</span>, however, this is a small penalty to pay for the simplicity of resulting AIR.</p>

    <p class="text-gray-300">Denoting <span class="math">r_{i}</span> to be the value of register <span class="math">i</span> at the current step of the computation, and <span class="math">r_{i}^{\\prime}</span> to be the value of register <span class="math">i</span> at the next step of the computation, transition constraints for registers <span class="math">\\{r_{0},..,r_{3}\\}</span> are:</p>

    <p class="text-gray-300"><span class="math">r_{2}^{2}-r_{2}=0</span> (1)</p>

    <p class="text-gray-300"><span class="math">r_{3}^{2}-r_{3}=0</span> (2)</p>

    <p class="text-gray-300"><span class="math">r_{0}^{\\prime}-(r_{0}+m_{h}\\cdot m_{p}\\cdot r_{2})=0</span> (3)</p>

    <p class="text-gray-300"><span class="math">r_{1}^{\\prime}-(r_{1}+m_{h}\\cdot m_{p}\\cdot r_{3})=0</span> (4)</p>

    <p class="text-gray-300">The first two constraints enforce that values in registers <span class="math">r_{2}</span> and <span class="math">r_{3}</span> must be binary (0 or 1). Constraint (3) enforces that when <span class="math">m_{h}=1</span> (which happens on every <span class="math">8^{th}</span> step), the current value of <span class="math">r_{2}</span> is accumulated into <span class="math">r_{0}</span>, otherwise, the value of <span class="math">r_{0}</span> remains the same. Constraint (4) does the same for registers <span class="math">r_{1}</span> and <span class="math">r_{3}</span>.</p>

    <p class="text-gray-300">Signature element hashing. Registers <span class="math">\\{r_{4},..,r_{9}\\}</span> and <span class="math">\\{r_{10},..,r_{15}\\}</span> are used to hash signature elements corresponding to 1 bits of the message (the <span class="math">pr_{i}</span> elements). Registers <span class="math">\\{r_{4},..,r_{9}\\}</span> do this for elements corresponding to bits 0…127 of the message, while registers <span class="math">\\{r_{10},..,r_{15}\\}</span> do this for elements corresponding to bits 128…254.</p>

    <p class="text-gray-300">The hashing is performed as follows: on every <span class="math">8^{th}</span> step of the execution trace, starting with step 0, if the corresponding message bit is 1, a new signature element is copied into registers <span class="math">\\{r_{4},r_{5}\\}</span> and <span class="math">\\{r_{10},r_{11}\\}</span>, and all other registers are set to zeros. If message bit is 0, zeros are inserted into all registers, though this will not be enforced via constraints. On all other steps, Rescue-Prime round function is applied. The effect of this is that on the last step of each 8-step cycle, registers <span class="math">\\{r_{4},r_{5}\\}</span> and <span class="math">\\{r_{10},r_{11}\\}</span> will contain <span class="math">pb_{i}=\\mathrm{G}(pr_{i})</span>, iff corresponding message bits were set to 1.</p>

    <p class="text-gray-300">Using <span class="math">r_{i}</span> and <span class="math">r_{i}^{\\prime}</span> notation as in the previous section, and denoting <span class="math">resc_{i}</span> to be a function which computes transition constraints for a single round for Rescue-XLIX permutation for hash state element <span class="math">i</span>, we define transition constraints for registers <span class="math">\\{r_{4},..,r_{15}\\}</span> as follows:</p>

    <p class="text-gray-300"><span class="math">(1-m_{h})\\cdot resc_{0}(r_{4},r_{4}^{\\prime})=0</span> (5)</p>

    <p class="text-gray-300"><span class="math">(1-m_{h})\\cdot resc_{1}(r_{5},r_{5}^{\\prime})=0</span> (6)</p>

    <p class="text-gray-300"><span class="math">m_{h}\\cdot r_{6}^{\\prime}+(1-m_{h})\\cdot resc_{2}(r_{6},r_{6}^{\\prime})=0</span> (7)</p>

    <p class="text-gray-300"><span class="math">m_{h}\\cdot r_{7}^{\\prime}+(1-m_{h})\\cdot resc_{3}(r_{7},r_{7}^{\\prime})=0</span> (8)</p>

    <p class="text-gray-300"><span class="math">m_{h}\\cdot r_{8}^{\\prime}+(1-m_{h})\\cdot resc_{4}(r_{8},r_{8}^{\\prime})=0</span> (9)</p>

    <p class="text-gray-300"><span class="math">m_{h}\\cdot r_{9}^{\\prime}+(1-m_{h})\\cdot resc_{5}(r_{9},r_{9}^{\\prime})=0</span> (10)</p>

    <p class="text-gray-300"><span class="math">(1-m_{h})\\cdot resc_{0}(r_{10},r_{10}^{\\prime})=0</span> (11)</p>

    <p class="text-gray-300"><span class="math">(1-m_{h})\\cdot resc_{1}(r_{11},r_{11}^{\\prime})=0</span> (12)</p>

    <p class="text-gray-300"><span class="math">m_{h}\\cdot r_{12}^{\\prime}+(1-m_{h})\\cdot resc_{2}(r_{12},r_{12}^{\\prime})=0</span> (13)</p>

    <p class="text-gray-300"><span class="math">m_{h}\\cdot r_{13}^{\\prime}+(1-m_{h})\\cdot resc_{3}(r_{13},r_{13}^{\\prime})=0</span> (14)</p>

    <p class="text-gray-300"><span class="math">m_{h}\\cdot r_{14}^{\\prime}+(1-m_{h})\\cdot resc_{4}(r_{14},r_{14}^{\\prime})=0</span> (15)</p>

    <p class="text-gray-300"><span class="math">m_{h}\\cdot r_{15}^{\\prime}+(1-m_{h})\\cdot resc_{5}(r_{15},r_{15}^{\\prime})=0</span> (16)</p>

    <p class="text-gray-300">Constraints (5), (6), (11), (12) enforce that Rescue-XLIX round function is applied to registers <span class="math">r_{4},..,r_{11}</span> whenever <span class="math">m_{h}=0</span>, but don’t place any constraints on these registers when <span class="math">m_{h}=1</span>. The remaining constraints also enforce that Rescue-XLIX round function is applied to the corresponding registers when <span class="math">m_{h}=0</span>, but in addition specify that these registers should be set to zeros when <span class="math">m_{h}=1</span>.</p>

    <p class="text-gray-300">Public key accumulator. Registers <span class="math">\\{r_{16},..,r_{21}\\}</span> are used to accumulate <span class="math">pb_{i}</span> elements into Lamport+ public key. The methodology is similar to the one used to hash private key elements described in the previous section, except for the following differences:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The capacity portion of the state (registers <span class="math">r_{20}</span> and <span class="math">r_{21}</span>) is not reset on every <span class="math">8^{th}</span> step. Instead, values of these registers are copied over to the next step when <span class="math">m_{h}=1</span>. This means that every new set of <span class="math">pb_{i}</span> elements is absorbed into the sponge, and and a single result is squeezed out of the sponge on the last step of the computation.</li>

      <li>On every <span class="math">8^{th}</span> step, if message bits are 1 (registers <span class="math">r_{2}</span> and <span class="math">r_{3}</span>), hashes of the corresponding <span class="math">pr_{i}</span> elements (register <span class="math">r_{4}</span>, <span class="math">r_{5}</span>, and <span class="math">r_{10}</span>, <span class="math">r_{11}</span>) must be equal to the <span class="math">pb_{i}</span> elements (register <span class="math">r_{16}</span>, <span class="math">r_{17}</span>, and <span class="math">r_{18}</span>, <span class="math">r_{19}</span>) absorbed into the sponge of the public key hash.</li>

    </ul>

    <p class="text-gray-300">This last set of constraints ties together different parts of the execution trace in such a way that trying to insert invalid values in one of the parts will invalidate constraints in another part.</p>

    <p class="text-gray-300">Using the notations defined in the prior sections, we define transition constraints for registers <span class="math">\\{r_{16},..,r_{21}\\}</span> as follows:</p>

    <p class="text-gray-300"><span class="math">m_{h}\\cdot r_{2}\\cdot(r_{16}^{\\prime}-r_{4})+(1-m_{h})\\cdot resc_{0}(r_{16},r_{16}^{\\prime})=0</span> (17)</p>

    <p class="text-gray-300"><span class="math">m_{h}\\cdot r_{2}\\cdot(r_{17}^{\\prime}-r_{5})+(1-m_{h})\\cdot resc_{1}(r_{17},r_{17}^{\\prime})=0</span> (18)</p>

    <p class="text-gray-300"><span class="math">m_{h}\\cdot r_{3}\\cdot(r_{18}^{\\prime}-r_{10})+(1-m_{h})\\cdot resc_{2}(r_{18},r_{18}^{\\prime})=0</span> (19)</p>

    <p class="text-gray-300"><span class="math">m_{h}\\cdot r_{3}\\cdot(r_{19}^{\\prime}-r_{11})+(1-m_{h})\\cdot resc_{3}(r_{19},r_{19}^{\\prime})=0</span> (20)</p>

    <p class="text-gray-300"><span class="math">m_{h}\\cdot(r_{20}^{\\prime}-r_{20})+(1-m_{h})\\cdot resc_{4}(r_{20},r_{20}^{\\prime})=0</span> (21)</p>

    <p class="text-gray-300"><span class="math">m_{h}\\cdot(r_{21}^{\\prime}-r_{21})+(1-m_{h})\\cdot resc_{5}(r_{21},r_{21}^{\\prime})=0</span> (22)</p>

    <p class="text-gray-300">Boundary constraints. In addition to the transition constraints described above, we also define the following boundary constraints for the computation:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Values in all registers except for <span class="math">r_{2}</span>, <span class="math">r_{3}</span>, <span class="math">r_{4}</span>, <span class="math">r_{5}</span>, <span class="math">r_{10}</span>, <span class="math">r_{11}</span> must be equal to zeros at the first step of the computation (<span class="math">s_{0}</span>).</li>

    </ol>

    <p class="text-gray-300">ASIA CCS '22, May 30-June 3, 2022, Nagasaki, Japan</p>

    <p class="text-gray-300">Irakliy Khaburzaniya, Kostantinos Chalkias, Kevin Lewi, and Harjasleen Malvai</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: A trace table for Lamport+ signature verification over a 6-bit message: 011101. Only the first and the last steps in an 8-step cycle are shown. In this example,  <span class="math">m_0 = 011</span>  and  <span class="math">m_1 = 101</span> .</p>

    <p class="text-gray-300">(2) Values in registers  <span class="math">r_0</span>  and  <span class="math">r_1</span>  must be equal to message values  <span class="math">m_0</span>  and  <span class="math">m_1</span>  at step  <span class="math">s_{1023}</span>  (the last step of the computation). (3) Values in  <span class="math">r_{16}</span>  and  <span class="math">r_{17}</span>  at step  <span class="math">s_{1023}</span>  must be equal to the values of the public key pub which was used to sign the message.</p>

    <p class="text-gray-300">In this section, we describe our aggregate signature scheme. Our scheme is non-interactive: any party can collect Lamport+ signatures over unrelated messages signed individually by different parties and compress them into a single aggregate signature. The aggregate signature size is logarithmic in the number of individual signatures. The signature is fast to verify, but the aggregation procedure may require significant time and/or processing power (see evaluation of concrete results in Sec. 6).</p>

    <p class="text-gray-300">Given  <span class="math">M = (M_1, \\dots, M_n)</span> , a tuple of  <span class="math">n</span>  messages,  <span class="math">PK = (pk_1, \\dots, pk_n)</span> , a tuple of Lamport+ public keys and  <span class="math">\\Sigma = (\\sigma_1, \\dots, \\sigma_n)</span> , a tuple of Lamport+ signatures, let LP.pp := a set of public parameters for LP defined in Sec. 3. We define  <span class="math">\\operatorname{Prog}_{\\text{verif-agg}}((n, M, PK, \\text{LP.pp}), \\Sigma)</span> :</p>

    <p class="text-gray-300">(1) verif  <span class="math">\\leftarrow 1</span> (2) For  <span class="math">i</span>  in 1...n:</p>

    <p class="text-gray-300">verif  <span class="math">\\leftarrow</span>  LP.Verify(LP.pp,  <span class="math">M_{i},pk_{i},\\sigma_{i})\\ast</span>  verif</p>

    <p class="text-gray-300">(3) Output verif.</p>

    <p class="text-gray-300">Now, LP can be augmented with additional operations LP.AggSig and LP.AggSigVerify, given public parameters,  <span class="math">\\mathrm{pp} = (\\mathrm{LP}. \\mathrm{pp}, \\mathrm{STARK}. \\mathrm{pp})</span> , where LP.pp and STARK.pp  <span class="math">\\leftarrow</span>  STARK.Setup(1 <span class="math">\\hat{\\lambda}</span> , Progverif-agg) are the public parameters for Lamport+ and STARK respectively. Note that given the sets of public parameters LP.pp and STARK.pp, any party can call LP.AggSig.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>AggSig  <span class="math">\\leftarrow</span>  LP.AggSig(LP.pp, n, M, PK,  <span class="math">\\Sigma</span> ): Given public parameters, LP.pp, integer  <span class="math">n</span> , messages  <span class="math">M = (M_1, \\dots, M_n)</span> , public keys  <span class="math">PK = (pk_1, \\dots, pk_n)</span>  and signatures  <span class="math">\\Sigma = (\\sigma_1, \\dots, \\sigma_n)</span> , let stmt := (n, M, PK, LP.pp) and  <span class="math">w = \\Sigma</span>  and return STARK.Prove(STARK.pp, stmt, w).</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\gets \\text{LP.AggSigVerify(pp, n, M, PK, AggSig): On inputs integer } n</span> , messages  <span class="math">M = (M_1, \\dots, M_n)</span> , public keys  <span class="math">PK = (pk_1, \\dots, pk_n)</span> , aggregated signature AggSig and public parameters  <span class="math">\\text{pp} = (\\text{LP.pp}, \\text{STARK.pp}), \\text{stmt} \\gets (n, M, PK, \\text{LP.pp}).</span>  Output  <span class="math">b \\gets \\text{STARK.Verify(STARK.pp, stmt, AggSig)}.</span></li>

    </ul>

    <p class="text-gray-300">We define the security of aggregate signatures in the aggregate chosen-key security model akin to [14], but with the adversary being permitted only one signing oracle query. Define  <span class="math">\\mathrm{Game}_{\\mathrm{H}}^{\\mathrm{AggSig}}(\\mathcal{A}, N, q_{\\mathrm{H}})</span> , as follows, where  <span class="math">\\mathrm{H}</span>  is the hash function used in the signature scheme:</p>

    <p class="text-gray-300">Setup. pp is the set of public parameters for the signature scheme. The adversary  <span class="math">\\mathcal{A}</span> , is provided with a public key  <span class="math">pk_{1}</span>  chosen at random and pp.</p>

    <p class="text-gray-300">Query.  <span class="math">\\mathcal{A}</span>  makes at most  <span class="math">q_{\\mathrm{H}}</span>  queries to  <span class="math">\\mathrm{H}</span>  and requests a signature on a message  <span class="math">M^{*}</span>  of its choice, that verifies with  <span class="math">pk_{1}</span> .</p>

    <p class="text-gray-300">Response.  <span class="math">\\mathcal{A}</span>  outputs  <span class="math">N - 1</span>  distinct public keys  <span class="math">pk_{2},\\ldots ,pk_{N}</span>  and a tuple of messages  <span class="math">M = (M_1,\\dots,M_N)</span> , where  <span class="math">M_{1}\\neq M^{*}</span>  and an aggregated signature  <span class="math">\\sigma</span> .</p>

    <p class="text-gray-300">Output. Output AggSigVerify(pp,  <span class="math">N,M,(pk_{1},\\dots,pk_{N}),\\sigma)</span></p>

    <p class="text-gray-300">Finally, we define the advantage  <span class="math">\\mathrm{Adv}_{\\mathcal{A},\\mathrm{H}}^{\\mathrm{aggSig}}(N,q_{\\mathrm{H}})</span>  of  <span class="math">\\mathcal{A}</span>  as the probability that  <span class="math">\\mathrm{Game}_{\\mathrm{H}}^{\\mathrm{AggSig}}(\\mathcal{A},N,q_{\\mathrm{H}})</span>  outputs 1. We say that a one-time aggregate signature scheme is secure if, for any efficient adversary  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\mathrm{Adv}_{\\mathcal{A},\\mathrm{H}}^{\\mathrm{aggSig}}(N,q_{\\mathrm{H}})</span>  is negligible in the security parameter.</p>

    <p class="text-gray-300">LEMMA 4.1. The one-time aggregate signature scheme, LP, with operations LP.AggSig and LP.AggSigVerify, is satisfies the security definition above.</p>

    <p class="text-gray-300">PROOF SKETCH. Concretely,  <span class="math">\\mathrm{Adv}_{\\mathcal{A},\\mathrm{H}}^{\\mathrm{aggSig}}(N,q_{\\mathrm{H}})</span>  is given by</p>

    <p class="text-gray-300"><span class="math">P[\\mathrm{pp}\\gets (\\mathrm{LP.pp},\\mathrm{STARK.pp}),r\\gets^{\\S}\\{0,1\\}^{\\ast},pk_{1}\\gets \\mathrm{LP.KeyGen}(pp,r);</span>  ((pk2,...,pkN),M:= (M1,...,MN),σ)←A H,SigningOracle(·) 1←STARK.Verify(STARK.pp,(N,M,(pk1,...,pkN),LP.pp),σ)]</p>

    <p class="text-gray-300">To generate a verifying signature, an adversary must do one of the following : (1) generate a verifying a proof <span class="math">\\sigma</span>, <em>without</em> knowledge of <span class="math">\\sigma_{1}</span>, such that LP.Verify(LP.pp, <span class="math">M_{1},p_{1},\\sigma_{1}</span>) returns 1. (2) forge <span class="math">\\sigma_{1}</span> such that LP.Verify(LP.pp, <span class="math">M_{1},pk_{1},\\sigma_{1}</span>) returns 1. The probability of (1) is upper bounded by the knowledge soundness error of the STARK protocol, which we assume here to be negligible. The probability of (2) is upper bounded by the advantage of an EU-CMA adversary for LP. In both cases, the argument follows from the fact that an adversary with non-negligible probability of success can be used as a subroutine by a STARK or EU-CMA adversary, respectively. Thus, by the union bound, the advantage of the aggregate signature adversary is negligible in the security parameter. ∎</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">4.3. Aggregate signature verification AIR</h3>

    <p class="text-gray-300">The AIR for program <span class="math">\\text{Prog}_{\\text{verif-agg}}</span> is very similar to the AIR of a single <span class="math">\\text{Lamport+}</span> signature verification program described in Sec. 3.2. Specifically, we can concatenate execution traces of individual signatures (as shown in Fig. 2 for a two-signature case), and keep all constraints virtually unchanged. Thus, aggregating <span class="math">n</span> signatures would require an execution trace of 22 registers and <span class="math">1024\\cdot\\lceil n\\rceil</span> steps. where <span class="math">\\lceil n\\rceil</span> is the number of signatures rounded to the next power of two. The adjustments we need to make transition and boundary constraints are described in the sections below.</p>

    <p class="text-gray-300">Transition constraint adjustments. First, we need to ensure that transition constraints are not enforced on steps between the signatures (e.g. between steps 1023 and 1024). To do this, we introduce a new periodic column <span class="math">m_{s}</span>, which contains a cycle of 1024 values comprised of 1023 zeros followed by 1 one. We then multiply all transition constraints by the expression <span class="math">(1-m_{s})</span>, which has the effect of enforcing all constraints on steps where <span class="math">m_{s}\\neq 1</span>, but ignoring them on steps where <span class="math">m_{s}=1</span>. This also increases the degree of transition constraints by one, and, thus, the maximum constraint degree of AIR for <span class="math">\\text{Prog}_{\\text{verif-agg}}</span> program is 7.</p>

    <p class="text-gray-300">Boundary constraint adjustments. Second, we need to place boundary constraints at the end of each signature cycle to ensure that messages (registers <span class="math">r_{2}</span> and <span class="math">r_{3}</span>) and public keys (registers <span class="math">r_{16}</span> and <span class="math">r_{17}</span>) at the end of each signature verification trace are indeed equal to the expected values. Such constraints would have the following form:</p>

    <p class="text-gray-300"><span class="math">\\frac{f(x)-b(x)}{(x-\\omega^{1023})\\cdot(x-\\omega^{2047})...(x-\\omega^{(1024\\cdot n-1)})}</span></p>

    <p class="text-gray-300">where: <span class="math">\\omega</span> is the generator of the trace domain, <span class="math">f(x)</span> is a trace polynomial, and <span class="math">b(x)</span> is the boundary polynomial. For example, for register <span class="math">r_{2}</span>, <span class="math">f(\\omega^{i})=r_{2}[i]</span> for all <span class="math">i\\in\\{0..n\\cdot 1024\\}</span>, and <span class="math">b(\\omega^{(1024\\cdot i-1)})=m_{i,0}</span> for all <span class="math">i\\in\\{0..n\\}</span>.</p>

    <p class="text-gray-300">It should be noted that this constraint cannot be evaluated succinctly by the verifier as complexities <span class="math">b(x)</span> and the denominator of the constraint are linear in the number of signatures. However, there are two mitigating circumstances.</p>

    <p class="text-gray-300">First, because STARK domains are multiplicative subgroups of size equal to a power of two, and we enforce the constraints at intervals equal to powers of two, the denominator has a succinct form and the constraint can be written as:</p>

    <p class="text-gray-300"><span class="math">\\frac{f(x)-b(x)}{x^{n}-\\omega^{(n+1023)}}</span></p>

    <p class="text-gray-300">Second, and for the same reasons, the verifier can obtain <span class="math">b(x)</span> polynomial using FFT-based interpolation. Even though such interpolation has complexity <span class="math">O(n\\log n)</span>, in practice it can be performed very quickly. For example, for <span class="math">n=8192</span>, interpolating <span class="math">b(x)</span> takes under 0.5ms on a single CPU core. Thus, when aggregating fewer than 10,000 signatures, time needed to evaluate this constraint will be under 2ms, which has a minor impact on the overall verification time. Even for <span class="math">n&gt;100,000</span> the proofs can be verified in under 50 ms, however, for such large number of signatures, verification of this constraint will dominate the overall proof verification time.</p>

    <h2 id="sec-18" class="text-2xl font-bold">5. Threshold Signatures</h2>

    <p class="text-gray-300">This section describes our threshold signature scheme. Signature sizes in our scheme are logarithmic in the total number of signers. The threshold signature is fast to verify but the aggregation procedure may require significant time and/or processing power (see evaluation of concrete results in Sec. 6).</p>

    <p class="text-gray-300">Informally, to generate a <span class="math">t</span>-of-<span class="math">n</span> threshold signature over message <span class="math">M</span>, <span class="math">n</span> signers send their <span class="math">\\text{Lamport+}</span> public keys to an aggregator. The aggregator uses the individual public keys to generate a single public key, <span class="math">PK</span>, for this set of signers by outputting an accumulation of their keys. This is the threshold signature scheme’s public key. The aggregator, then, distributes <span class="math">M</span> to all signers. The signers sign <span class="math">M</span> with their individual private keys, and send their signatures back to the aggregator. Once the aggregator receives <span class="math">t</span> signatures, they compute a STARK proof attesting that they verified <span class="math">t</span> distinct signatures over <span class="math">M</span>, and that signers of all signatures belong to the original set of signers. This proof serves as the threshold signature of <span class="math">n</span> signers over <span class="math">M</span>, with respect to the single public key <span class="math">PK</span>.</p>

    <p class="text-gray-300">Note that our threshold signatures provide only <em>weak anonymity</em>. That is, for different subsets of <span class="math">t</span> signers, resulting threshold signatures will not be identical. The latter means that anyone with access to all <span class="math">t</span> individual signatures can determine the set of signers included in the threshold signature.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">5.1. Formal construction</h3>

    <p class="text-gray-300">To construct threshold signatures, we introduce three additional operations to LP: LP.AggregatePublicKeys, LP.ThresholdSigAgg and LP.ThresholdSigVerify. As in Sec. 4.1, we let LP.pp be a set of <span class="math">\\text{Lamport+}</span> public parameters, including the parameters for an accumulator ACC. For an integer <span class="math">n</span> and a set <span class="math">S=\\{pk_{1},...,pk_{n}\\}</span>, define</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">PK\\leftarrow\\text{LP.AggregatePublicKeys}(\\text{LP}.pp,n,S)</span>: Output <span class="math">PK:=\\text{acc}_{S}\\leftarrow\\text{ACC.Eval}(\\text{ACC.pp},S)</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a threshold <span class="math">t</span>, a set $PK^{\\prime}\\subseteq S,PK^{\\prime}=(pk^{\\prime}_{i},...,pk^{\\prime}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PK^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> such that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PK^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq t+1<span class="math">, a message </span>M<span class="math">, a tuple of accumulator witnesses </span>\\text{Wit}=(\\text{wt}_{1},...,\\text{wt}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PK^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">, a tuple of signatures </span>\\Sigma=(\\sigma_{1},...,\\sigma_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PK^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> on </span>M<span class="math"> we define </span>\\text{Prog}_{\\text{verif-threshold}}((n,t,PK,M)<span class="math">, </span>(PK^{\\prime},\\text{Wit},\\Sigma))$ as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{verif}\\leftarrow 0</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. For <span class="math">i</span> in $1...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PK^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\text{signature\\_verif}\\leftarrow\\text{LP.Verify}(\\text{LP}.pp,M,pk^{\\prime}_{i},\\sigma_{i})</span> <span class="math">\\text{acc\\_verif}\\leftarrow\\text{ACC.Verify}(\\text{ACC}.pp,PK,\\text{wt}_{i},pk^{\\prime}_{i})</span> <span class="math">\\text{verif}\\leftarrow\\text{verif}+\\text{(signature\\_verif}*\\text{acc\\_verif})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">\\text{verif}\\geq t+1</span>.</li>

    </ol>

    <p class="text-gray-300">Our aggregated threshold signature scheme, therefore, takes the parameters <span class="math">M,n,t</span>, an aggregated public key <span class="math">PK</span> and setting <span class="math">PK^{\\prime},\\Sigma</span>, as</p>

    <p class="text-gray-300">ASIA CCS '22, May 30-June 3, 2022, Nagasaki, Japan</p>

    <p class="text-gray-300">Irakliy Khaburzaniya, Kostantinos Chalkias, Kevin Lewi, and Harjasleen Malvai</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: A trace table for verification of two Lamport+ signatures.</p>

    <p class="text-gray-300">above.  <span class="math">pp = (\\mathrm{LP}.pp, \\mathrm{STARK}.pp)</span> , where  <span class="math">\\mathrm{STARK}.pp \\gets \\mathrm{STARK}.Setup(1^{\\lambda}, \\mathrm{Prog}_{\\mathrm{verif - threshold}})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- ThresholdSig  <span class="math">\\leftarrow</span>  LP.ThresholdSigAgg(pp, n, t, M, PK,  <span class="math">PK&#x27;</span> ,  <span class="math">\\Sigma</span> ): First, get wit  <span class="math">\\leftarrow</span>  ACC.WitCreate(ACC.pp, PK,  <span class="math">pk_{i}&#x27;</span> ), set Wit  <span class="math">\\leftarrow</span>  {wit1, ..., wit  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{PK'}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , then set stmt  </span>\\leftarrow<span class="math">  (n, t, PK, M) and w  </span>\\leftarrow<span class="math">  (PK&#x27;, Wit,  </span>\\Sigma$ ). Finally, output STARK.Prove(STARK.pp, stmt, w).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\gets \\text{LP. ThresholdSigVerify}(\\text{LP.pp}, n, t, PK, M, \\text{ThresholdSig})</span> : Let stmt  <span class="math">\\leftarrow (n, t, PK, M, \\text{ThresholdSig})</span>  and return  <span class="math">b \\gets \\text{STARK. Verify(STARK.pp, stmt)}</span> .</li>

    </ul>

    <p class="text-gray-300">We modify the game from Sec. 4.2, to define the following game, GameThresholdSig  <span class="math">(\\mathcal{A},N,t,q_{\\mathrm{H}})</span> , where  <span class="math">\\mathsf{H}</span>  is the hash function used in the signature scheme:</p>

    <p class="text-gray-300">Setup. pp is the set of public parameters for the signature scheme. The adversary  <span class="math">\\mathcal{A}</span> , is provided with public keys  <span class="math">pk_{1},\\ldots ,pk_{N - t}</span>  chosen at random and pp.</p>

    <p class="text-gray-300">Query.  <span class="math">\\mathcal{A}</span>  makes at most  <span class="math">q_{\\mathrm{H}}</span>  queries to  <span class="math">\\mathsf{H}</span>  and makes a single query to the signing oracle for each  <span class="math">pk_{i}</span>  on message  <span class="math">M_{i}^{*}</span>  of its choice.</p>

    <p class="text-gray-300">Key Aggregation.  <span class="math">\\mathcal{A}</span>  outputs  <span class="math">t</span>  distinct public keys  <span class="math">pk_{N - t + 1},\\dots,pk_N</span>  Let  <span class="math">S = \\{pk_1,\\ldots ,pk_N\\}</span>  and  <span class="math">PK\\gets</span>  AggregatePublicKeys(pp,  <span class="math">N,S)</span></p>

    <p class="text-gray-300">Response.  <span class="math">\\mathcal{A}</span>  outputs a message  <span class="math">M \\neq M_i^*</span> , for any  <span class="math">i \\in [N - t]</span>  and an aggregated threshold signature  <span class="math">\\sigma</span> .</p>

    <p class="text-gray-300">Output. Output ThresholdSigVerify(pp, N, t, PK, M, (pk1, ..., pkN),  <span class="math">\\sigma</span> ). Define the advantage Adv ThresholdSig  <span class="math">(N, t, q_{\\mathrm{H}})</span>  of  <span class="math">\\mathcal{A}</span>  as the probability that Game ThresholdSig  <span class="math">(\\mathcal{A}, N, t, q_{\\mathrm{H}})</span>  outputs 1. A one-time threshold signature scheme is secure if, for any efficient adversary  <span class="math">\\mathcal{A}</span> , Adv ThresholdSig  <span class="math">(N, t, q_{\\mathrm{H}})</span> , is negligible in the security parameter.</p>

    <p class="text-gray-300">LEMMA 5.1. The one-time threshold signature scheme, LP, with LP.AggregatePublicKeys, LP.ThresholdSigAgg, LP.ThresholdSigVerify, is satisfies the security definition above.</p>

    <p class="text-gray-300">PROOF SKETCH. We want to show that the following is negligible:</p>

    <p class="text-gray-300"><span class="math">P[\\mathrm{pp}\\leftarrow (\\mathrm{LP}.pp,\\mathrm{STARK}.pp),r_i\\leftarrow^{\\S}\\{0,1\\}^*,pk_i\\leftarrow \\mathrm{LP.KeyGen}(pp,</span> <span class="math">r_i)</span>  for  <span class="math">i\\in [N - t];(pk_{N - t + 1},\\dots,pk_N,M,\\sigma)\\gets \\mathcal{A}^{H,\\mathrm{SigningOracle}}(\\cdot);</span></p>

    <p class="text-gray-300"><span class="math">PK\\gets \\mathrm{ACC.Eval}(\\mathrm{ACC}.pp,\\{pk_i\\}_{i\\in [N]})\\wedge</span> <span class="math">1\\gets \\mathrm{STARK.Verify}(\\mathrm{STARK}.pp,(N,t,PK,M,\\sigma))]</span></p>

    <p class="text-gray-300">For the adversary to produce terms such that  <span class="math">PK \\gets \\mathrm{ACC.Eval}(\\mathrm{ACC}.pp, \\{pk_i\\}_{i \\in [N]}) \\wedge 1 \\gets \\mathrm{STARK.Verify}(\\mathrm{STARK}.pp, (N, t, PK, \\sigma))</span> , it needs to achieve at least one of the following: (1) produce a proof  <span class="math">\\sigma</span> , attesting to  <span class="math">t + 1</span>  valid signatures on  <span class="math">M</span> , while owning only  <span class="math">t</span>  of the keys committed in  <span class="math">PK</span> , i.e. providing a verifying proof without a valid witness. (2) forge a signature by one of the keys generated by the challenger. (3) provide a witness for membership in the accumulated key  <span class="math">PK</span>  for a key  <span class="math">pk_{N+1}</span> , which was not originally input to ACC.Eval. (1) would violate knowledge soundness of STARK. (2) violates the EU-CMA security of LP, and (3) violates the collision-freeness of ACC. Thus, due to the union bound, adversary's advantage is upper bounded by sum of the knowledge soundness error of STARK, the advantage of an EU-CMA adversary of LP and the probability of an ACC adversary generating a witness for an uncommitted value. Since each of these terms is negligible, the above expression is negligible in the security parameter.</p>

    <p class="text-gray-300">The AIR for program  <span class="math">\\mathrm{Prog}_{\\mathrm{verif - threshold}}</span>  is similar to the AIR for aggregate signature verification program described in Sec. 4.3, with additional logic for verifying that all individual signatures belong to the members of  <span class="math">S</span> . We do this by verifying that public keys for the signatures are leaves in the Merkle tree defined by  <span class="math">PK</span> . The AIR for Merkle path verification program described in App. B.</p>

    <p class="text-gray-300">In our implementation, AIR for  <span class="math">\\mathrm{Prog}_{\\mathrm{verif - threshold}}</span>  program works over an execution trace of 28 registers, and requires  <span class="math">1024 \\cdot n</span>  steps, where  <span class="math">n</span>  is the total number of signers in the threshold group rounded to the next power of two. For example, if the total number of signers is 7, the execution trace will be 8192 steps long, regardless of the number of individual signatures verified. This means that programs for 1-out-of-7 and 6-out-of-7 signatures will result in execution traces of exactly the same length (8192 steps). A simplified schematic of an execution trace for a 2-out-of-3 signature is shown in Fig. 3. The components of the trace and associated constraints are described in the following sections. Signature verification. Registers  <span class="math">\\{r_0, \\dots, r_{17}\\}</span>  are used to verify individual Lamport+ signatures in a manner similar to the aggregate signature verification AIR, with the following differences:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Instead of  <span class="math">n</span>  distinct messages only a single message  <span class="math">M</span>  is provided to the program as a public input. Thus, the first 4 registers of Lamport+ signature verification trace are replaced</li>

    </ul>

    <p class="text-gray-300">Aggregating and thresholdizing hash-based signatures using STARKs</p>

    <p class="text-gray-300">ASIA CCS '22, May 30-June 3, 2022, Nagasaki, Japan</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: Threshold signature verification trace for  <span class="math">n = 3</span> .</p>

    <p class="text-gray-300">with two periodic columns:  <span class="math">m_0</span>  and  <span class="math">m_1</span> . These columns will contain binary decomposition of the tuple of field elements describing  <span class="math">M</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Boundary constraints against public key registers ( <span class="math">r_{12}</span>  and  <span class="math">r_{13}</span> ) are removed as ensuring that signature verification trace resolves to a valid public key is enforced by a set of transition constraints described further in this section.</li>

      <li>When a signature from a specific signer is missing, a null signature is inserted in its place. The constraint system is unchanged, as validity of null signatures is not enforced.</li>

    </ul>

    <p class="text-gray-300">Merkle path verification. Registers  <span class="math">\\{r_{18},\\dots,r_{25}\\}</span>  are used to verify that all individual public keys against which the signatures are verified are present in the Merkle tree with the root equal to the aggregate public key of all signers. AIR for this registers is almost identical to Merkle path verification program described in App. B, except for the following differences:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Additional boundary constraints are placed against leaf indices to ensure that all Merkle paths in the tree are verified. The order of indexes is offset by  <span class="math">-1</span> . Thus, a Merkle path for the last leaf is verified first, then Merkle path for the first leaf, second leaf etc. This allows for output values of the signature verification segment to align with input values for Merkle path verification segment, and simplifies transition constraint definitions described further in this section.</li>

      <li>The above arrangement also dictates that the last leaf in the Merkle tree of the aggregated public key is always a zero key. Thus, we also impose boundary constraints enforcing that values in registers  <span class="math">r_{18}</span>  and  <span class="math">r_{19}</span>  at step 0 are set to zero.</li>

    </ul>

    <p class="text-gray-300">Signature counter. Registers  <span class="math">r_{26}</span>  and  <span class="math">r_{27}</span>  are used to count the number of verified signatures. Specifically, the value of register  <span class="math">r_{26}</span>  is set to one at the end of each 1024 step cycle (i.e. on steps 1023, 2047 etc.) iff the signature verified in this cycle is valid. If the signature is not valid (i.e., it is a null signature),  <span class="math">r_{26}</span>  is set to zero.</p>

    <p class="text-gray-300">Register  <span class="math">r_{27}</span>  is used as the actual counter. It is initialized to zero, and its value is incremented whenever value of register  <span class="math">r_{26} = 1</span> . Thus, by the end of the execution trace, the value of register  <span class="math">r_{27}</span>  will be equal to the number of valid signatures.</p>

    <p class="text-gray-300">Denoting  <span class="math">r_i</span>  to be the value of register  <span class="math">i</span>  at the current step of the computation, and  <span class="math">r_i&#x27;</span>  to be the value of register  <span class="math">i</span>  at the next step of</p>

    <p class="text-gray-300">the computation, transition constraints for registers  <span class="math">r_{26}</span>  and  <span class="math">r_{27}</span>  are defined as follows:</p>

    <div class="my-4 text-center"><span class="math-block">r _ {2 6} ^ {2} - r _ {2 6} = 0 \\tag {1}</span></div>

    <div class="my-4 text-center"><span class="math-block">r _ {2 7} ^ {\\prime} - \\left(r _ {2 7} + m _ {s} \\cdot r _ {2 6}\\right) = 0 \\tag {2}</span></div>

    <div class="my-4 text-center"><span class="math-block">m _ {s} \\cdot r _ {2 6} \\cdot \\left(r _ {1 8} ^ {\\prime} - r _ {1 2}\\right) = 0 \\tag {3}</span></div>

    <div class="my-4 text-center"><span class="math-block">m _ {s} \\cdot r _ {2 6} \\cdot \\left(r _ {1 9} ^ {\\prime} - r _ {1 3}\\right) = 0 \\tag {4}</span></div>

    <p class="text-gray-300">where,  <span class="math">m_{s}</span>  is periodic column identical to the one described in Sec. 4.3 - a cycle of 1024 values comprised of 1023 zeros followed by 1 one.</p>

    <p class="text-gray-300">The first constraint above enforces that values in  <span class="math">r_{26}</span>  must be binary, while the second constraint enforces that value of  <span class="math">r_{27}</span>  is incremented only if  <span class="math">r_{26} = 1</span>  and we are at the end of a signature verification cycle (i.e.  <span class="math">m_s = 1</span> ). The other two constraints tie the signature verification and the Merkle path verification segments together. They enforce that whenever we are at the end of a signature verification cycle and  <span class="math">r_{26} = 1</span> , the public key resulting from signature verification trace (registers  <span class="math">r_{12}</span>  and  <span class="math">r_{13}</span> ) must be equal to the leaf of the Merkle path at the corresponding index (registers  <span class="math">r_{18}</span>  and  <span class="math">r_{19}</span> ). Thus,  <span class="math">r_{26}</span>  can be set to one iff the prover indeed has a valid signature for the individual public key at the respective index.</p>

    <p class="text-gray-300">Boundary constraints. In addition to the boundary constraints required for signature verification and Merkle path verification segments discussed previously, we also need to impose boundary constraints against the signature counter. Specifically, we enforce the following additional constraints:</p>

    <p class="text-gray-300">(1) Value in register  <span class="math">r_{27}</span>  at step 0 must be set to zero. (2) Value in register  <span class="math">r_{27}</span>  at the last step must be equal to the expected number of valid signatures.</p>

    <p class="text-gray-300">Thus, after verifying the proof, the verifier will learn the total number of valid signatures known to the prover. The verifier can then compute the ratio of valid signatures to the total number of signers and check if the resulting value meets the required threshold - outside of the circuit to reduce circuit complexity.</p>

    <p class="text-gray-300">To evaluate concrete performance of our signature schemes, we implemented the following components using Rust programming language: (1) the Rescue hash function, (2) Lamport+ signature</p>

    <p class="text-gray-300">scheme, (3) a generic STARK prover and verifier, and (4) the AIRs for our aggregate and threshold signature schemes. Our implementation of STARK prover supports multi-threaded proof generation, but does not make use of any advanced CPU instructions, leaving room for optimizations in future work. We ran benchmarks on an 8-core Intel Core i9 processor @ 2.4 GHz with 32 GB of RAM.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">6.1. Rescue and Lamport+</h3>

    <p class="text-gray-300">Our implementation of Rescue-Prime hash function achieves about 15,000 hashes per second on a single CPU core when hashing values up to 64 bytes long. This is approximately two orders of magnitude slower than for such widely used hash functions as SHA2/3 or BLAKE2/3. However, this slowdown is expected, given that modern CPUs are not optimized for prime field arithmetic. Even with existing hardware, we believe that this performance can be improved 5x-6x, by instantiating Rescue with different parameters (e.g. smaller field) and optimizing underlying field operations.</p>

    <p class="text-gray-300">Performance of Rescue translates directly to performance of Lamport+ signatures as shown in Table 2. Lamport+ is an OTS, so, key generation time is lumped with signing time. For verification, we show average time, with the worse case time being 30 ms.</p>

    <p class="text-gray-300">It should be noted that if Lamport+ is instantiated with a fast hash function such as BLAKE3, it becomes extremely fast, with a single CPU core capable of verifying almost 45,000 signatures/sec.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">6.2. Signature aggregation</h3>

    <p class="text-gray-300">The concrete performance of our signature schemes is shown in Table 3. We benchmark STARK proof generation at different security levels, by varying the number of queries included in a proof (see Sec. 2.1). Table 4 shows a comparison with other signature schemes.</p>

    <p class="text-gray-300">Aggregate and threshold signature verification times are between 3 ms and 10 ms. As explained in Sec. 4.3, verification time is linear in the number of individual signatures. However, practical impact of this linear complexity is negligible when verifying an aggregation of fewer than 10, 000 signatures.</p>

    <p class="text-gray-300">As Table 3 shows, a large number of signatures may take significant time to aggregate. However, STARK proof generation is massively parallelizable, so prover time may be reduced significantly by utilizing more powerful hardware. For example, aggregating 1024 signatures at 96-bit security level can be completed in 3.9 seconds on a 64-core machine (vs. 19.7 seconds on an 8-core machine).</p>

    <p class="text-gray-300">Note that the comparison in Table 4 is not entirely “apples-to-apples”, since our schemes are OTS, while other schemes (with the exception of WOTS) support a practically unlimited number of signatures. Nevertheless, this comparison is informative as transforming our scheme to a many-times signature scheme should have relatively minor impact on the resulting signature sizes.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">6.3. Further optimizations</h3>

    <p class="text-gray-300">The results presented above are taken from a stable version of our STARK library, which has since been updated to support STARKs defined over small fields (e.g. 62-bit or 64-bit primes). The benefit of using such small fields is that modular reductions can be performed very quickly on 64-bit machines – currently the most common CPU architecture. This, in turn, translates into two tangible benefits.</p>

    <p class="text-gray-300">First, we observe a significant improvement in Rescue Prime hash function performance. Specifically, we’ve implemented a version of Rescue Prime in a 62-bit prime field, which yielded roughly 10x speed up as compared to our implementation in a 128-bit field used in the benchmarks above. We expect this speed up to carry over into faster signing and verification time for Lamport+ signature scheme (i.e., we can expect these times go down from 30ms and 20ms to 3ms and 2ms, respectively).</p>

    <p class="text-gray-300">Second, faster field arithmetic translates directly into faster STARK proof generation. However, the impact here is not as significant as with Rescue Prime hash function. Based on our preliminary benchmarks, we expect proof generation time (and, thus, signature aggregation time) to decrease by a factor between 2x and 4x. Thus, it may be possible to aggregate 1000+ Lamport+ signatures in under a second on a 64-core machine such as Azure HB120-64rs v3.</p>

    <h2 id="sec-26" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">While working on this project, Harjasleen Malvai was funded in part by the Initiative for Cryptocurrencies and Contracts (IC3).</p>

    <h2 id="sec-27" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] G. Alagic, J. Alperin-Sheriff, D. Apon, D. Cooper, Q. Dang, J. Kelsey, Y.-K. Liu, C. Miller, D. Moody, R. Peralta, et al. Status report on the second round of the nist post-quantum cryptography standardization process. US Department of Commerce, NIST, 2020.</li>

      <li>[2] M. R. Albrecht, L. Grassi, L. Perrin, S. Ramacher, C. Rechberger, D. Rotaru, A. Roy, and M. Schofnegger. Feistel structures for mpc, and more. In European Symposium on Research in Computer Security, pages 151–171. Springer, 2019.</li>

      <li>[3] A. Aly, T. Ashur, E. Ben-Sasson, S. Dhooghe, and A. Szepieniec. Design of symmetric-key primitives for advanced cryptographic protocols. IACR Transactions on Symmetric Cryptology, pages 1–45, 2020.</li>

      <li>[4] S. Ames, C. Hazay, Y. Ishai, and M. Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In Proceedings of the 2017 acm sigsac conference on computer and communications security, pages 2087–2104, 2017.</li>

      <li>[5] T. Ashur, S. Dhooghe, and A. Szepieniec. Rescue-prime: a standard specification (sok). IACR Transactions on Symmetric Cryptology, pages 1–16, 2020.</li>

      <li>[6] A. authors. STARK prover and verifier (Rust implementation). https://github.com/anonauthorsub/asiacrs_2021_440.</li>

      <li>[7] E. Ben-Sasson. Recursive STARKs. https://www.crowdcast.io/e/recursive-starks, 2020.</li>

      <li>[8] E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev. Scalable, transparent, and post-quantum secure computational integrity. IACR Cryptol. ePrint Arch., 2018:46, 2018.</li>

      <li>[9] E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P. Ward. Aurora: Transparent succinct arguments for r1cs. In Annual international conference on the theory and applications of cryptographic techniques. Springer, 2019.</li>

      <li>[10] E. Ben-Sasson, L. Goldberg, and D. Levit. Stark friendly hash–survey and recommendation. Technical report, Cryptology ePrint Archive, Report 2020/948. https://eprint. iacr. org/2020/948, 2020.</li>

      <li>[11] D. J. Bernstein, D. Hopwood, A. Hülsing, T. Lange, R. Niederhagen, L. Papachristodoulou, M. Schneider, P. Schwabe, and Z. Wilcox-O’Hearn. Sphincs: practical stateless hash-based signatures. In Annual international conference on the theory and applications of cryptographic techniques. Springer, 2015.</li>

      <li>[12] Blockchain-Charts. Average Transactions Per Block. https://www.blockchain. com/charts/n-transactions-per-block, 2021.</li>

      <li>[13] D. Boneh, R. Gennaro, S. Goldfeder, and S. Kim. A lattice-based universal thresholdizer for cryptographic systems. IACR Cryptol. ePrint Arch., 2017:251, 2017.</li>

      <li>[14] D. Boneh, C. Gentry, B. Lynn, and H. Shacham. Aggregate and verifiably encrypted signatures from bilinear maps. In International Conference on the Theory and Applications of Cryptographic Techniques, pages 416–432. Springer, 2003.</li>

      <li>[15] D. Boneh, C. Gentry, B. Lynn, H. Shacham, et al. A survey of two signature aggregation techniques, 2003.</li>

      <li>[16] D. Boneh and S. Kim. One-time and interactive aggregate signatures from lattices.</li>

      <li>[17] K. Boudgoust and A. Roux-Langlois. Compressed linear aggregate signatures based on module lattices. Cryptology ePrint Archive, Report 2021/263, 2021. https://eprint.iacr.org/2021/263.</li>

    </ul>

    <p class="text-gray-300">Aggregating and thresholdizing hash-based signatures using STARKs</p>

    <p class="text-gray-300">ASIA CCS '22, May 30-June 3, 2022, Nagasaki, Japan</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Private key size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Public key size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Signature size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Signing time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verification time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">32 bytes</td>

            <td class="px-3 py-2 border-b border-gray-700">8 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">30 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">20 ms</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Performance of Lamport+ signature scheme instantiated with Rescue-Prime hash function. Private key can be generated from a single 32-byte seed.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">96-bit security</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">123-bit security</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Prover Time</td>

            <td class="px-3 py-2 border-b border-gray-700">Prover RAM</td>

            <td class="px-3 py-2 border-b border-gray-700">Signature Size</td>

            <td class="px-3 py-2 border-b border-gray-700">Prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">Prover RAM</td>

            <td class="px-3 py-2 border-b border-gray-700">Signature Size</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Aggregate signatures  |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2.5 sec</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.9 GB</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">68 KB</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3.2 sec</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1.2 GB</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">129 KB</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">10.5 sec</td>

            <td class="px-3 py-2 border-b border-gray-700">3.7 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">77 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">13.6 sec</td>

            <td class="px-3 py-2 border-b border-gray-700">4.8 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">155 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">19.7 sec</td>

            <td class="px-3 py-2 border-b border-gray-700">7.4 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">83 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">25.7 sec</td>

            <td class="px-3 py-2 border-b border-gray-700">9.5 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">165 KB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Threshold signatures  |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">127</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2.9 sec</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1.0 GB</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">69 KB</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3.8 sec</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1.3 GB</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">136 KB</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">511</td>

            <td class="px-3 py-2 border-b border-gray-700">12.6 sec</td>

            <td class="px-3 py-2 border-b border-gray-700">3.9 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">80 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">15.6 sec</td>

            <td class="px-3 py-2 border-b border-gray-700">5.1 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">159 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1023</td>

            <td class="px-3 py-2 border-b border-gray-700">25.8 sec</td>

            <td class="px-3 py-2 border-b border-gray-700">7.8 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">86 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">32.4 sec</td>

            <td class="px-3 py-2 border-b border-gray-700">10.0 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">170 KB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: Performance for our implementations at various parameters.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PQ-Secure</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Public Key Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Individual Sig. Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Aggregated Sig. Size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ed25519</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

            <td class="px-3 py-2 border-b border-gray-700">32 B</td>

            <td class="px-3 py-2 border-b border-gray-700">64 B</td>

            <td class="px-3 py-2 border-b border-gray-700">62.5 KB*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BLS12-381</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

            <td class="px-3 py-2 border-b border-gray-700">48 B</td>

            <td class="px-3 py-2 border-b border-gray-700">96 B</td>

            <td class="px-3 py-2 border-b border-gray-700">96 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">WOTS (w = 16)</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">32 B</td>

            <td class="px-3 py-2 border-b border-gray-700">2.14 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">2.09 MB*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Sphincs* -128s</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">32 B</td>

            <td class="px-3 py-2 border-b border-gray-700">8 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">7.8 MB*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Falcon-512</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">897 B</td>

            <td class="px-3 py-2 border-b border-gray-700">618 B</td>

            <td class="px-3 py-2 border-b border-gray-700">603 KB*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Dilithium3</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">1.9 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">3.3 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">3.2 MB*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MMSAT-128</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">4.2 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">3 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">36 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">32 B</td>

            <td class="px-3 py-2 border-b border-gray-700">8 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">165 KB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Comparison of various schemes, and their aggregation over 1000 signatures. 128-bit security is assumed, but for certain schemes the practical security level is slightly less than 128-bits. Schemes that do not support aggregation are marked with  <span class="math">^{**}</span> , in which case we assume concatenating individual signatures.</p>

    <p class="text-gray-300">[18] R. G. Brown, J. Carlyle, I. Grigg, and M. Hearn. Corda: an introduction. <em>R3 CEV</em>, August, 1:15, 2016. [19] J. Buchmann, E. Dahmen, S. Ereth, A. Hülsing, and M. Rückert. On the security of the winternitz one-time signature scheme. In International Conference on Cryptology in Africa, pages 363-378. Springer, 2011. [20] J. Buchmann, E. Dahmen, and A. Hülsing. Xmss-a practical forward secure signature scheme based on minimal security assumptions. In International Workshop on Post-Quantum Cryptography, pages 117-129. Springer, 2011. [21] K. Chalkias, M. Baudet, Y. Sun, and D. Wong. Hash-based signatures for blockchains. Applied Crypto Symposium, 2020. https://drive.google.com/file/d/1pPdJhThmJCnTKBqbEE32G31TSELsG19. [22] K. Chalkias, J. Brown, M. Hearn, T. Lillehagen, I. Nitto, and T. Schroeter. Blockchained post-quantum signatures. In IEEE Blockchain Conference, 2018. [23] K. Chalkias, F. Garillot, Y. Kondi, and V. Nikolaenko. Non-interactive half-aggregation of EdDSA and variants of Schnorr signatures. In CT-RSA, 2021. [24] A. Chiesa, P. Manohar, and N. Spooner. Succinct arguments in the quantum random oracle model. In Theory of Cryptography Conference. Springer, 2019. [25] A. Chiesa, D. Ojha, and N. Spooner. Fractal: Post-quantum and transparent recursive proofs from holography. In Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages 769-793. Springer, 2020. [26] D. A. Cooper, D. C. Apon, Q. H. Dang, M. S. Davidson, M. J. Dworkin, and C. A. Miller. Recommendation for stateful hash-based signature schemes. NIST Special Publication, 800:208, 2020. [27] D. Derler, C. Hanser, and D. Slamanig. Revisiting cryptographic accumulators, additional properties and relations to other primitives. In Cryptographers' track at the rsa conference, pages 127-144. Springer, 2015. [28] Y. Doróz, J. Hoffstein, J. H. Silverman, and B. Sunar. Mmsat: A scheme for multimessage multiuser signature aggregation. IACR Cryptol. ePrint Arch., 2020. [29] J. Drake. Pragmatic signature aggregation with bls, May 2018.</p>

    <p class="text-gray-300">[30] R. El Bansarkhani and J. Sturm. An efficient lattice-based multisignature scheme with applications to bitcoins. In International Conference on Cryptology and Network Security, pages 140-155. Springer, 2016. [31] T. M. Fernández-Caramés and P. Fraga-Lamas. Towards post-quantum blockchain: A review on blockchain cryptography resistant to quantum computing attacks. IEEE Access, 8:21091-21116, 2020. [32] A. Gabizon, K. Gurkan, P. Jovanovic, G. Konstantopoulos, A. Oines, M. Olszewski, M. Straka, E. Tromer, and P. Vesely. Plumo: Towards scalable interoperable blockchains using ultra light validation systems, 2020. [33] L. Goldberg, S. Papini, and M. Riabzev. Cairo-a turing-complete stark-friendly cpu architecture. Cryptology ePrint Archive, 2021. [34] L. Grassi, D. Khovratovich, C. Rechberger, A. Roy, and M. Schofnegger. Poseidon: A new hash function for zero-knowledge proof systems. In Proceedings of the 30th USENIX Security Symposium. USENIX Association, 2020. [35] A. Hülsing. W-ots+-shorter signatures for hash-based signature schemes. In International Conference on Cryptology in Africa, pages 173-188. Springer, 2013. [36] J. Katz, V. Kolesnikov, and X. Wang. Improved non-interactive zero knowledge with applications to post-quantum signatures. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, 2018. [37] C. Komlo and I. Goldberg. Frost: Flexible round-optimized Schnorr threshold signatures. 2020. [38] A. Kosba, Z. Zhao, A. Miller, Y. Qian, H. Chan, C. Papamanthou, R. Pass, abhi shelat, and E. Shi. CBeB: A framework for building composable zero-knowledge proofs. Cryptology ePrint Archive, 2015. https://eprint.iacr.org/2015/1093. [39] H. Krawczyk. Cryptographic extraction and key derivation: The hkdf scheme. In Annual Cryptology Conference, pages 631-648. Springer, 2010. [40] M. Labs. Matter labs announces $50m in new funding for zksync. https://blog.matter-labs.io/funding-ea89c1fa731e, 2021. [41] G. Maxwell, A. Poelstra, Y. Seurin, and P. Wuille. Simple schnorr multi-signatures with applications to bitcoin. Cryptology ePrint Archive, Report 2018/068, 2018. https://eprint.iacr.org/2018/068.</p>

    <p class="text-gray-300">ASIA CCS '22, May 30-June 3, 2022, Nagasaki, Japan</p>

    <p class="text-gray-300">Irakliy Khaburzaniya, Kostantinos Chalkias, Kevin Lewi, and Harjasleen Malvai</p>

    <p class="text-gray-300">[42] R. C. Merkle. A certified digital signature. In Conference on the Theory and Application of Cryptology, pages 218-238. Springer, 1989. [43] S. Micali. Algorand 2021 Performance. https://www.algorand.com/resources/blog/algorand-2021-performance, 2021. [44] J. Nick, T. Buffing, and Y. Seurin. Musig2: Simple two-round Schnorr multi-signatures. 2020. [45] H. Pilaram, T. Eghlidos, and R. Toluee. An efficient lattice-based threshold signature scheme using multi-stage secret sharing. IET Information Security, 2021. [46] S. Popov. The tangle. White paper, 1:3, 2018. [47] S. Reynolds. Starkware launches layer 2 product starknet on ethereum. https://www.coindesk.com/business/2022/02/23/starkware-launches-layer-2-product-starknet-on-ethereum/, 2022. [48] StarkWare. Ziggy signature. https://github.com/starkware-libs/ethSTARK/tree/ziggy#Glossary, 2020. [49] T. A. Team. Aleo raises $200m in series b to expand private-by-default, blockchain platform. https://www.aleo.org/post/aleo-raises-series-b, 2022. [50] W. A. Torres, R. Steinfeld, A. Sakzad, and V. Kuchta. Post-quantum linkable ring signature enabling distributed authorised ring confidential transactions in blockchain. Technical report, Cryptology ePrint Archive, Report 2020/1121, 2020. https://eprint.iacr.org, 2020. [51] P. Waterland. The QRL Whitepaper. Technical report, Quantum Resistant Ledger. [52] Y. Zhao. Aggregation of gamma-signatures and applications to bitcoin. IACR Cryptol. ePrint Arch., 2018:414, 2018.</p>

    <p class="text-gray-300">Selection of a hash function for the hash-based signature scheme is critical as it directly impacts design complexity and prover performance. To be efficient within a STARK, a hash function must have simple algebraic representation, and unfortunately, traditional hash functions such as SHA and BLAKE do not fit the bill. This is primarily because these hash functions make extensive use of bit operations (e.g. XOR, bit shifts) which are cheap in modern CPUs, but are very expensive within STARKs and other ZKP systems.</p>

    <p class="text-gray-300">To address these shortcomings a number of arithmetization-friendly hash functions have been developed recently [2, 3, 34]. These new constructions are several orders of magnitude more efficient inside ZKP circuits as compared to their traditional analogues [10]. The main drawbacks of these new constructions is their relative recency, and poor performance outside of ZKP circuits.</p>

    <p class="text-gray-300">For our aggregated signature schemes we have selected Rescue-Prime hash function [5], primarily for simplicity of its AIR. Rescue-Prime employs Rescue-XLIX permutation in a sponge construction to hash strings of arbitrary lengths. Each permutation consists of a number of rounds operating over a state of  <span class="math">m</span>  field elements. As illustrated on Fig. 4, a single round of Rescue-XLIX permutation consists of the following steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Apply the power map to each element of the state.</li>

      <li>Apply the MDS matrix to the state, through matrix-vector multiplication.</li>

      <li>Add the next  <span class="math">m</span>  round constants into the state.</li>

      <li>Apply the inverse power map to each element of the state.</li>

      <li>Apply the MDS matrix to the state, through matrix-vector multiplication.</li>

      <li>Add the next  <span class="math">m</span>  round constants into the state.</li>

    </ul>

    <p class="text-gray-300">Denoting the state before the round function is applied by  <span class="math">S</span> , and the state resulting from the application of the round function by  <span class="math">S&#x27;</span> , we can describe a single Rescue-XLIX permutation round by the following AIR constraints:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\sum_ {j = 1} ^ {m} M [ i, j ] \\left(S [ j ] ^ {\\alpha} + C _ {2 i m} [ j ] ^ {\\alpha}\\right) \\\\ - \\left(\\sum_ {j = 1} ^ {m} M ^ {- 1} [ i, j ] \\left(S ^ {\\prime} [ j ] - C _ {2 i m} [ m + j ]\\right)\\right) ^ {\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i \\in [ m ] \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 4: Round  <span class="math">i</span>  of Rescue Prime permutation with  <span class="math">m = 3</span> .</p>

    <p class="text-gray-300">The above expression evaluates to 0 for all  <span class="math">i</span> , if and only if  <span class="math">S&#x27;</span>  state results from applying a single round of Rescue-XLIX permutation to state  <span class="math">S</span> . It is important to note that we connect  <span class="math">S</span>  and  <span class="math">S&#x27;</span>  from the middle of the round, and therefore we can replace the inverse power map with a simple power map. Thus, the degree of these constraints is  <span class="math">\\alpha</span> .</p>

    <p class="text-gray-300">For our specific instantiation of Rescue-Prime we selected a 128-bit prime field, and set  <span class="math">m = 6</span>  and  <span class="math">\\alpha = 5</span> . We also set the number of rounds to 7 to target 128-bit PQ-security against pre-image, second pre-image and collision attacks with an additional  <span class="math">40\\%</span>  security margin. The  <span class="math">40\\%</span>  margin was selected to make the number of rounds be one less than a power of two, which simplifies AIR design for the overall system.</p>

    <p class="text-gray-300">With the above parameters, to hash a 512-bit value into a 256-bit value, we can use a trace table of 6 registers wide and 8 steps long (see Fig. 5). At the initial step  <span class="math">S_0</span> , we populate the rate portion of the state (registers  <span class="math">m_0..m_3</span> ), with the value to be hashed, and set the capacity portion of the state (registers  <span class="math">m_4, m_5</span> ) to 0. We then apply Rescue-XLIX round function 7 times, each time recording the state of the sponge in a separate row. At step  <span class="math">S_7</span> , the permutation is complete, so the hashed value can be read from registers  <span class="math">m_0, m_1</span> .</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 5: A trace table for one invocation of Rescue-XLIX permutation (7 rounds).</p>

    <p class="text-gray-300">We define Merkle path verification procedure merkle_path as a procedure which takes two parameters: an index of a leaf in a Merkle tree and a Merkle path to the leaf at the specified index, and outputs the root of the Merkle tree as described in Alg. 2.</p>

    <p class="text-gray-300">An AIR-friendly variant of merkle_path has the following differences from the generic procedure:</p>

    <p class="text-gray-300">Aggregating and thresholdizing hash-based signatures using STARKs</p>

    <p class="text-gray-300">ASIA CCS '22, May 30-June 3, 2022, Nagasaki, Japan</p>

    <p class="text-gray-300">Algorithm 2 merkle_path procedure</p>

    <pre><code class="language-txt">inputs: index, path[]
$r \\gets$  hash(path[0], 0)
for i in 1..path.length do
if get_bit(index, i - 1) == 0 then
$r \\gets$  hash(r, path[i])
else
$r \\gets$  hash(path[i], r)
end if
end for
return  $r$</code></pre>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 6: Execution trace for merkle_path procedure for  <span class="math">n = 3</span>  and index  <span class="math">= 3</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Leaf index is passed into the procedure as a private witness in the form of a bit vector (in little-endian order) and the procedure outputs the index value as a single element.</li>

      <li>In our context, nodes of a Merkle tree are represented by tuples of elements in a 128-bit field. Thus, Merkle path is passed into the procedure as two arrays each containing a single element of a tuple at a corresponding index.</li>

      <li>We use the Rescue-Prime hash function (see App. A), which operates over a state of 6 field elements and requires 7 rounds to compute a hash. After 7 rounds are applied to the state, the resulting hash is located in elements 0 and 1 of the state.</li>

    </ul>

    <p class="text-gray-300">In our implementation, AIR for Merkle path verification works over an execution trace of 8 registers and  <span class="math">8 * n</span>  steps, where  <span class="math">n</span>  is the depth of the Merkle tree. A simplified schematic of a trace for  <span class="math">n = 3</span>  is shown in Fig. 6.</p>

    <p class="text-gray-300">Out of 8 registers, 6 are used for hash computations, and the remaining two are used to bind the execution trace to a leaf index. We also rely on two periodic columns  <span class="math">m_h</span>  and  <span class="math">m_p</span>  which are identical to the columns described in Sec. 3.2.</p>

    <p class="text-gray-300">Registers  <span class="math">r_0</span>  and  <span class="math">r_1</span>  are used to bind the execution trace to a leaf index. Register  <span class="math">r_1</span>  contains binary decomposition of the leaf index in little-endian byte order, while register  <span class="math">r_0</span>  contains accumulated</p>

    <p class="text-gray-300">value of the index at a given step of the trace, such that at the end of the trace,  <span class="math">r_0</span>  contains the full value of the index.</p>

    <p class="text-gray-300">Denote the value of register  <span class="math">i</span>  at the current step of the computation, as  <span class="math">r_i</span>  and the value of register  <span class="math">i</span>  at the next step of the computation as  <span class="math">r_i&#x27;</span> . Transition constraints for registers  <span class="math">r_0</span>  and  <span class="math">r_1</span>  are:</p>

    <div class="my-4 text-center"><span class="math-block">r _ {1} ^ {2} - r _ {1} = 0 \\tag {1}</span></div>

    <div class="my-4 text-center"><span class="math-block">r _ {0} ^ {\\prime} - r _ {0} - r _ {1} \\cdot m _ {h} \\cdot m _ {p} = 0 \\tag {2}</span></div>

    <p class="text-gray-300">Constraint 1 enforces that values in register  <span class="math">r_1</span>  must be binary (0 or 1). Constraint 2 enforces that on every  <span class="math">8^{th}</span>  step (i.e. when  <span class="math">m_h = 1</span> ), the next bit of the index is accumulated into register  <span class="math">r_0</span> . Otherwise, the value of  <span class="math">r_0</span>  is copied over to the next step unchanged.</p>

    <p class="text-gray-300">Registers  <span class="math">\\{r_2, \\dots, r_7\\}</span>  are used to compute hashes of nodes in the Merkle path. The hashing is performed as follows: on every  <span class="math">8^{th}</span>  step of the execution trace, starting with step 7 (i.e. when  <span class="math">m_h = 1</span> ), when the index bit is 1 (i.e. when  <span class="math">r_1 = 1</span> ) values from registers  <span class="math">\\{r_2, r_3\\}</span>  are moved into registers  <span class="math">\\{r_4, r_5\\}</span> , and the values corresponding to the next node in the Merkle path are inserted into registers  <span class="math">\\{r_2, r_3\\}</span> . However, when  <span class="math">r_1 = 0</span> , the next node in the path is inserted into registers  <span class="math">\\{r_4, r_5\\}</span> , while values of registers  <span class="math">\\{r_2, r_3\\}</span>  are copied over to the next step. On all other steps (i.e. when  <span class="math">m_h = 0</span> ), Rescue-Prime round function is applied.</p>

    <p class="text-gray-300">The effect of the above logic is that depending on the value of the index bit, we compute either  <span class="math">\\mathrm{hash}(\\{r_2,r_3\\} ,\\{r_4,r_5\\})</span>  or  <span class="math">\\mathrm{hash}(\\{r_4,r_5\\} ,</span> <span class="math">\\{r_2,r_3\\})</span>  in registers  <span class="math">\\{r_2,\\dots ,r_7\\}</span> , and by the end of the execution trace, registers  <span class="math">\\{r_2,r_3\\}</span>  will contain the root of the Merkle tree implied by the path and the index parameters.</p>

    <p class="text-gray-300">Using  <span class="math">r_i</span>  and  <span class="math">r_i&#x27;</span>  notation as in the previous section, and denoting  <span class="math">resc_i</span>  to be a function which computes transition constraints for a single round for Rescue-XLIX permutation for hash state element  <span class="math">i</span> , we define transition constraints for registers  <span class="math">\\{r_2, \\dots, r_7\\}</span>  as follows:</p>

    <div class="my-4 text-center"><span class="math-block">m _ {h} \\cdot \\left(r _ {2} ^ {\\prime} - r _ {1} \\cdot r _ {4} - \\left(1 - r _ {1}\\right) \\cdot r _ {2}\\right) + \\left(1 - m _ {h}\\right) \\cdot r e s c _ {0} \\left(r _ {2}, r _ {2} ^ {\\prime}\\right) = 0 \\tag {3}</span></div>

    <div class="my-4 text-center"><span class="math-block">m _ {h} \\cdot \\left(r _ {3} ^ {\\prime} - r _ {1} \\cdot r _ {5} - \\left(1 - r _ {1}\\right) \\cdot r _ {3}\\right) + \\left(1 - m _ {h}\\right) \\cdot r e s c _ {1} \\left(r _ {3}, r _ {3} ^ {\\prime}\\right) = 0 \\tag {4}</span></div>

    <div class="my-4 text-center"><span class="math-block">m _ {h} \\cdot \\left(r _ {4} ^ {\\prime} - r _ {1} \\cdot r _ {2} - \\left(1 - r _ {1}\\right) \\cdot r _ {4}\\right) + \\left(1 - m _ {h}\\right) \\cdot r e s c _ {2} \\left(r _ {4}, r _ {4} ^ {\\prime}\\right) = 0 \\tag {5}</span></div>

    <div class="my-4 text-center"><span class="math-block">m _ {h} \\cdot \\left(r _ {5} ^ {\\prime} - r _ {1} \\cdot r _ {3} - \\left(1 - r _ {1}\\right) \\cdot r _ {5}\\right) + \\left(1 - m _ {h}\\right) \\cdot r e s c _ {3} \\left(r _ {5}, r _ {5} ^ {\\prime}\\right) = 0 \\tag {6}</span></div>

    <div class="my-4 text-center"><span class="math-block">m _ {h} * r _ {6} ^ {\\prime} + (1 - m _ {h}) * r e s c _ {4} \\left(r _ {6}, r _ {6} ^ {\\prime}\\right) = 0 \\tag {7}</span></div>

    <div class="my-4 text-center"><span class="math-block">m _ {h} * r _ {7} ^ {\\prime} + (1 - m _ {h}) * r e s c _ {5} \\left(r _ {7}, r _ {7} ^ {\\prime}\\right) = 0 \\tag {8}</span></div>

    <p class="text-gray-300">In addition to the logic described previously, constraints (7) and (8) also enforce that when  <span class="math">m_h = 1</span> , the capacity portion of the hash state (registers  <span class="math">r_6</span>  and  <span class="math">r_7</span> ) must be cleared, to prepare the state for the next round of hashing.</p>

    <p class="text-gray-300">In addition to the transition constraints described above, for Merkle path computation to be valid, we need to ensure that the correct binary decomposition of the leaf index was used. We do this by enforcing the following boundary constraints:</p>

    <p class="text-gray-300">(1) Value in register  <span class="math">r_0</span>  at step 0 must be set to 0. (2) Value in register  <span class="math">r_0</span>  at the last step must equal the leaf index.</p>`;
---

<BaseLayout title="Aggregating and thresholdizing hash-based signatures using S... (2021/1048)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/1048
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
