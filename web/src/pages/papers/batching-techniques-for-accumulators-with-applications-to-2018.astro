---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/1188';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Batching Techniques for Accumulators with Applications to IOPs and Stateless Blockchains';
const AUTHORS_HTML = 'Dan Boneh, Benedikt Bünz, Ben Fisch';

const CONTENT = `    <p class="text-gray-300">Dan Boneh, Benedikt Bünz, Ben Fisch Stanford University</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We present batching techniques for cryptographic accumulators and vector commitments in groups of unknown order. Our techniques are tailored for distributed settings where no trusted accumulator manager exists and updates to the accumulator are processed in batches. We develop techniques for non-interactively aggregating membership proofs that can be verified with a constant number of group operations. We also provide a constant sized batch non-membership proof for a large number of elements. These proofs can be used to build the first positional vector commitment (VC) with constant sized openings and constant sized public parameters. As a core building block for our batching techniques we develop several succinct proof systems in groups of unknown order. These extend a recent construction of a succinct proof of correct exponentiation, and include a succinct proof of knowledge of an integer discrete logarithm between two group elements. We circumvent an impossibility result for Sigma-protocols in these groups by using a short trapdoor-free CRS. We use these new accumulator and vector commitment constructions to design a stateless blockchain, where nodes only need a constant amount of storage in order to participate in consensus. Further, we show how to use these techniques to reduce the size of IOP instantiations, such as STARKs.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">A cryptographic accumulator <em>[x1]</em> is a primitive that produces a short binding commitment to a set of elements together with short membership and/or non-membership proofs for any element in the set. These proofs can be publicly verified against the commitment. The simplest accumulator is the Merkle tree <em>[x10]</em>, but several other accumulators are known, as discussed below. An accumulator is said to be <em>dynamic</em> if the commitment and membership proofs can be updated efficiently as elements are added or removed from the set, at unit cost independent of the number of accumulated elements. Otherwise we say that the accumulator is <em>static</em>. A <em>universal</em> accumulator is dynamic and supports both membership and non-membership proofs.</p>

    <p class="text-gray-300">A <em>vector commitment</em> (VC) is a closely related primitive <em>[x4]</em>. It provides the same functionality as an accumulator, but for an ordered list of elements. A VC is a <em>position binding</em> commitment and can be opened at any position to a unique value with a short proof (sublinear in the length of the vector). The Merkle tree is a VC with logarithmic size openings. Subvector commitments <em>[x11]</em> are VCs where a subset of the vector positions can be opened in a single short proof (sublinear in the size of the subset).</p>

    <p class="text-gray-300">The typical way in which an accumulator or VC is used is as a communication-efficient authenticated data structure (ADS) for a remotely stored database where users can retrieve individual items along with their membership proofs in the data structure. Accumulators have been used for many applications within this realm, including accountable certificate management <em>[x2, x16]</em>, timestamping <em>[x3]</em>, group signatures and anonymous credentials <em>[x5]</em>, computations on authenticated data <em>[ABC^{+}12]</em>, anonymous e-cash <em>[x17, x13]</em>, privacy-preserving data outsourcing <em>[x15]</em>, updatable signatures <em>[x14, x6]</em>, and decentralized bulletin boards <em>[x7, x8]</em>.</p>

    <p class="text-gray-300">Our present work is motivated by two particular applications of accumulators and vector commitments: stateless transaction validation in blockchains, or “stateless blockchains” and short interactive oracle proofs (IOPs) <em>[x10]</em>.</p>

    <p class="text-gray-300">“Stateless” blockchains. A <em>blockchain</em> has become the popular term for a ledger-based payment system, in which peer-to-peer payment transactions are asynchronously broadcasted and recorded in an ordered ledger that is replicated across nodes in the network. Bitcoin and Ethereum are two famous examples. Verifying the validity of a transaction requires querying the ledger <em>state</em>. The state can be computed uniquely from the ordered log of transactions, but provides a more compact index to the information required for transaction validation.</p>

    <p class="text-gray-300">For example, in Ethereum the state is a key/value store of account balances where account keys are the public key addresses of users. In Bitcoin, the state is the set of <em>unspent transaction outputs</em> (UTXOs). In Bitcoin, every transaction completely transfers all the funds associated with a set of source addresses to a set of target addresses. It is only valid if every source address is the output of a previous transaction that has not yet been consumed (i.e. “spent”). It is important that all nodes agree on the ledger state.</p>

    <p class="text-gray-300">Currently, in Bitcoin, every node in the system stores the entire UTXO set in order to verify incoming transactions. This has become cumbersome as the size of UTXO set has grown to gigabytes. An accumulator commitment to the UTXO set would alleviate this need. Transactions would include membership proofs for all its inputs. A node would only need to store the current state of the accumulator and verify transactions by checking membership proofs against the UTXO accumulator state. In fact, with dynamic accumulators, no single node in the network would be required to maintain the entire UTXO set. Only the individual nodes who are interested in a set of UTXOs (e.g. the users who can spend these outputs) would need to store them along with their membership proofs. Every node can efficiently update the UTXO set commitment and membership proofs for individual UTXOs with every new batch of transactions. The same idea can be applied to the Ethereum key-value store using a VC instead of an accumulator.</p>

    <p class="text-gray-300">This design concept is referred to as a “stateless blockchain” <em>[x27]</em> because nodes may participate in transaction validation without storing the entire state of the ledger, but rather only a short commitment to the state. The idea of committing to a ledgers state was introduced long before Bitcoin by Sanders and Ta-Shma for E-Cash<em>[x26]</em>. While the stateless blockchain design reduces the storage burden of node performing transaction validation, it increases the network communication due to the addition of membership proofs to each transaction payload. A design goal is to minimize the communication impact. Therefore, stateless blockchains would benefit from an accumulator with smaller membership proofs, or the ability to aggregate many membership proofs for a batch of transactions into a single constant-size proof.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Interactive oracle proofs (IOPs).</h4>

    <p class="text-gray-300">Micali <em>[x21]</em> showed how <em>probabilistically checkable proofs</em> (PCPs) can be used to construct succinct non-interactive arguments. In this construction the prover commits to a long PCP using a Merkle tree and then uses a random oracle to generate a few random query positions. The prover then verifiably opens the proof at the queried positions by providing Merkle inclusion paths.</p>

    <p class="text-gray-300">This technique has been generalized to the broader class of <em>interactive oracle proofs</em> (IOPs)<em>[x10]</em>. In an IOP the prover sends multiple proof oracles to a verifier. The verifier uses these oracles to query a small subsets of the proof, and afterwards accepts or rejects the proof. If the proof oracle is instantiated with a Merkle tree commitment and the verifier is public coin, then an IOP can be compiled into a non-interactive proof secure in the random oracle model <em>[x10]</em>. In particular, this compiler is used to build short non-interactive (zero-knowledge) proof of knowledge with a quasilinear prover and polylogarithmic verifier. Recent practical instantiations of proof systems from IOPs include Ligero <em>[x2]</em>, STARKs <em>[x5]</em>, and Aurora <em>[BSCR^{+}18]</em>.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">IOPs use Merkle trees as a vector commitment. Merkle trees have two significant drawbacks for this application: first, position openings are not constant size, and second, the openings of several positions cannot be compressed into a single constant size proof (i.e. it is not a subvector commitment). A vector commitment with these properties would have dramatic benefits for reducing the communication of an IOP (or size of the non-interactive proof compiled from an IOP).</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.1 Summary of contributions</h3>

    <p class="text-gray-300">Our technical contributions consist of a set of batching and aggregation techniques for accumulators. The results of these techniques have a wide range of implications, from concrete practical improvements in the proof-size of IOP-based succinct arguments (e.g. STARKS) and minimizing the network communication blowup of stateless blockchains to theoretical achievements in VCs and IOPs.</p>

    <p class="text-gray-300">To summarize the theoretical achievements first, we show that it is possible to construct a VC with constant size subvector openings and constant size public parameters. Previously, it was only known how to construct a VC with constant size subvector openings and public parameters <em>linear</em> in the length of the vector. This has immediate implications for IOP compilers. The Merkle-tree IOP compiler outputs a non-interactive proof that is <span class="math">O(\\lambda q\\log n)</span> larger (additive blowup) than the original IOP communication, where <span class="math">q</span> is the number of oracle queries, <span class="math">n</span> is the maximum length of the IOP proof oracles, and <span class="math">\\lambda</span> is the Merkle tree security parameter. When replacing the Merkle-tree in the IOP compiler with our new VC, we achieve only <span class="math">O(r\\lambda)</span> blowup in proof size, independent of <span class="math">q</span> and <span class="math">n</span>, but dependent on the number of IOP rounds <span class="math">r</span>. In the special case of a PCP there is a single round (i.e. <span class="math">r=1</span>). A similar result was recently demonstrated <em>[x14]</em> using the vector commitments of Catalano and Fiore (CF) <em>[x5]</em>, but the construction requires the verifier to access public parameters linear in <span class="math">n</span>. It was not previously known how to achieve this with constant size public parameters.</p>

    <p class="text-gray-300">Lai and Malavolta apply the CF vector commitments to “CS-proofs”, a special case of a compiled IOP where the IOP is a single round PCP. Instantiated with theoretical PCPs <em>[x10, x16]</em>, this results in the shortest known setup-free non-interactive arguments (for NP) with random oracles consisting of just 2 elements in a hidden order group and 240 additional bits of the PCP proof for 80-bit statistical security. Instantiating the group with class groups and targeting 100-bit security yields a proof of <span class="math">\\approx 540</span> bytes. However, the verifier must either use linear storage or perform linear work for each proof verification to generate the public proof parameters. In similar vein, we can use our new VCs to build the same non-interactive argument system, but with sublinear size parameters (in fact constant size). Under the same parameters our proofs are slightly larger, consisting of 5 group elements, a 128-bit integer, and the 240 bits of the PCP proof (<span class="math">\\approx 1.3KB</span>).</p>

    <p class="text-gray-300">Our VCs also make concrete improvements to practical IOPs. Targeting 100-bit security with class groups, replacing Merkle trees with our VCs would incur only 1 KB per round of the IOP. In Aurora <em>[BSCR^{+}18]</em>, it was reported that Merkle proofs take up 154 KB of the 222 KB proof for a circuit of size <span class="math">2^{20}</span>. Our VCs would reduce the size of the proof to less than 100 KB, a 54% reduction. For STARKs, a recent benchmark indicates that the Merkle paths make up over 400 KB of the 600 KB proof for a circuit of <span class="math">2^{52}</span> gates <em>[x2]</em>. With our VCs, under the same parameters the membership proofs would take up roughly 22 KB, reducing the overall proof size to approximately 222 KB, nearly a 63% reduction.</p>

    <p class="text-gray-300">Furthermore, replacing Merkle trees with our new VCs maintains good performance for proof verification. Roughly, each Merkle path verification of a <span class="math">k</span>-bit block is substituted with <span class="math">k</span> modular multiplications of <span class="math">\\lambda</span>-bit integers. The performance comparison is thus <span class="math">\\log n</span> hashes vs <span class="math">k</span> multiplications, which is even an improvement for <span class="math">k&lt;\\log n</span>. In the benchmarked STARK example, Merkle path verification comprises roughly 80% of the verification time.</p>

    <p class="text-gray-300">1.2 Overview of techniques</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Batching and aggregation.</h4>

    <p class="text-gray-300">We use the term <em>batching</em> to describe a single action applied to <span class="math">n</span> items instead of one action per item. For example a verifier can batch verify <span class="math">n</span> proofs faster than <span class="math">n</span> times verifying a single membership proof. <em>Aggregation</em> is a batching technique that is used when non-interactively combining <span class="math">n</span> items to a single item. For example, a prover can aggregate <span class="math">n</span> membership proofs to a single constant size proof.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Succinct proofs for hidden order groups.</h4>

    <p class="text-gray-300">Wesolowski <em>[x23]</em> recently introduced a constant sized and efficient to verify proof that a triple <span class="math">(u,w,t)</span> satisfies <span class="math">w=u^{2^{t}}</span>, where <span class="math">u</span> and <span class="math">w</span> are elements in a group <span class="math">\\mathbb{G}</span> of unknown order. The proof extends to exponents that are not a power of two and still provides significant efficiency gains over direct verification by computation.</p>

    <p class="text-gray-300">We expand on this technique to provide a new proof of knowledge of an exponent, which we call a <em>PoKE</em> proof. It is a proof that a computationally bounded prover knows the discrete logarithm between two elements in a group of unknown order. The proof is succinct in that the proof size and verification time is independent of the size of the discrete-log and has good soundness. We also generalize the technique to pre-images of homomorphisms from <span class="math">\\mathbb{Z}^{q}</span> to <span class="math">\\mathbb{G}</span> of unknown order. We prove security in the generic group model, where an adversarial prover operates over a generic group. Nevertheless, our extractor is classical and does not get to see the adversary’s queries to the generic group oracles. We also rely on a short unstructured common reference string (CRS). Using the generic group model for extraction and relying on a CRS is necessary to bypass certain impossibility results for proofs of knowledge in groups of unknown order <em>[x1, x27]</em>.</p>

    <p class="text-gray-300">We also extend the protocol to obtain a (honest verifier zero-knowledge) <span class="math">\\Sigma</span>-Protocol of DLOG in <span class="math">\\mathbb{G}</span>. This protocol is the first succinct <span class="math">\\Sigma</span>-protocol of this kind.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Distributed accumulator with batching.</h4>

    <p class="text-gray-300">Next, we extend current RSA-based accumulators <em>[x10, x16]</em> to create a universal accumulator for a distributed/decentralized setting where no single trusted accumulator manager exists and where updates are processed in batches. Despite this we show how membership and non-membership proofs can be efficiently aggregated. Moreover, items can efficiently be removed from the accumulator without a trapdoor or even knowledge of the accumulated set. Since the trapdoor is not required for our construction we can extend Lipmaa’s <em>[x18]</em> work on accumulators in groups of unknown order without a trusted setup by adding dynamic additions and deletions to the accumulator’s functionality. Class groups of imaginary quadratic order are a candidate group of unknown order without a trusted setup<em>[x4]</em>.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Batching non-membership proofs.</h4>

    <p class="text-gray-300">We next show how our techniques can be amplified to create a succinct and efficiently verifiable batch membership and batch non-membership proofs. We then use these batch proofs to create the first vector commitment construction with constant sized batch openings (recently called subvector commitments <em>[x15]</em>) and <span class="math">O(1)</span> setup. This improves on previous work <em>[x7, x14]</em> which required superlinear setup time and linear public parameter size. It also improves on Merkle tree constructions which have logarithmic sized non-batchable openings. The efficient setup also allows us to create sparse vector commitments which can be used as a key-value map commitment.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Soundness lower bounds in hidden order groups.</h4>

    <p class="text-gray-300">Certain families of sigma protocols for a relation in a generic group of unknown order can achieve at most soundness <span class="math">1/2</span> per challenge <em>[x1, x27]</em>. Yet, our work gives sigma protocols in a generic group of unknown order that have negligible soundness error. This does not contradict the known impossibility result because our protocols involve a CRS, whereas the family of sigma protocols to which the <span class="math">1/2</span> soundness lower bound applies do not have a CRS. Our results are significant as we show that it suffices</p>

    <p class="text-gray-300">to have a CRS containing two fresh random generic group generators to circumvent the soundness lower bound.</p>

    <p class="text-gray-300">Note that we only prove how to extract a witness from a successful prover that is restricted to the generic group model. Proving extraction from an arbitrary prover under a falsifiable assumption is preferable and remains an open problem.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">1.3 Additional related work</h3>

    <p class="text-gray-300">Dynamic accumulators can be constructed from the strong RSA assumption in groups of unknown order (such as an RSA group or the class group) <em>[x1, x12, x13, x14]</em>, from bilinear maps <em>[x10, x12, x26]</em>, and from Merkle hash trees <em>[x22, x11]</em>. These accumulators (with the exception of Merkle trees) naturally support batching of membership proofs, but not batching of non-membership proofs. Vector commitments based on similar techniques <em>[x23, x15, x24]</em> have constant size openings, but large setup parameters.</p>

    <p class="text-gray-300">Accumulators traditionally utilize a trusted <em>accumulator manager</em> which possesses a trapdoor to efficiently delete elements from the accumulator. This trapdoor also allows the manager to create membership witnesses for arbitrary elements. Lipmaa <em>[x16]</em> was the first to construct a static accumulator without a trusted setup from hidden order groups.</p>

    <p class="text-gray-300">In concurrent work, Chepurnoy et. al. <em>[x12]</em> also note that accumulators and vector commitments can be used to build stateless blockchains. The work proposes a new homomorphic vector commitment based on bilinear maps and multivariate polynomials. This is applied to a blockchain design where each account stores a balance, and balances can be updated homomorphically knowing only the vector commitment to the current blockchain balances. However, the construction requires linear public parameters, does not have a trustless setup, and does not support batching of inclusion proofs. The linear public parameter imply that a bound on the total number of accounts needs to be known at setup time.</p>

    <h2 id="sec-12" class="text-2xl font-bold">2 Preliminaries</h2>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">Notation.</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">a\\parallel b</span> is the concatenation of two lists <span class="math">a,b</span></li>

      <li><span class="math">\\bm{a}</span> is a vector of elements and <span class="math">a_{i}</span> is the <span class="math">i</span>th component</li>

      <li><span class="math">[\\ell]</span> denotes the set of integers <span class="math">\\{0,1,\\ldots,\\ell-1\\}</span>.</li>

      <li><span class="math">\\mathsf{negl}(\\lambda)</span> is a negligible function of the security parameter <span class="math">\\lambda</span></li>

      <li><span class="math">\\mathsf{Primes}(\\lambda)</span> is the set of integer primes less than <span class="math">2^{\\lambda}</span></li>

      <li><span class="math">x\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}S<span class="math"> denotes sampling a uniformly random element </span>x\\in S$.</li>

    </ul>

    <p class="text-gray-300"><span class="math">x\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathcal{A}(\\cdot)<span class="math"> denotes the random variable that is the output of a randomized algorithm </span>\\mathcal{A}$.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">GGen(\\lambda)</span> is a randomized algorithm that generates a group of unknown order in a range <span class="math">[a,b]</span> such that <span class="math">a</span>, <span class="math">b</span>, and <span class="math">a-b</span> are all integers exponential in <span class="math">\\lambda</span>.</li>

    </ul>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">2.1 Assumptions</h3>

    <p class="text-gray-300">The adaptive root assumption, introduced in <em>[x27]</em>, is as follows.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">We say that the adaptive root assumption holds for GGen if there is no efficient adversary <span class="math">(\\mathcal{A}_{0},\\mathcal{A}_{1})</span> that succeeds in the following task. First, <span class="math">\\mathcal{A}_{0}</span></p>

    <p class="text-gray-300">outputs an element <span class="math">w \\in \\mathbb{G}</span> and some state. Then, a random prime <span class="math">\\ell</span> in <span class="math">\\text{Primes}(\\lambda)</span> is chosen and <span class="math">\\mathcal{A}_1(\\ell, \\text{state})</span> outputs <span class="math">w^{1/\\ell} \\in \\mathbb{G}</span>. More precisely, for all efficient <span class="math">(\\mathcal{A}_0, \\mathcal{A}_1)</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Adv}_{\\left(\\mathcal{A}_{0}, \\mathcal{A}_{1}\\right)}^{\\mathrm{AR}}(\\lambda) := \\Pr \\left[ \\begin{array}{l l} &amp;amp; \\mathbb{G} \\stackrel {\\S} {\\leftarrow} GGen(\\lambda) \\\\ u^{\\ell} = w \\neq 1 : &amp;amp; (w, \\text{state}) \\stackrel {\\S} {\\leftarrow} \\mathcal{A}_{0}(\\mathbb{G}) \\\\ &amp;amp; \\ell \\stackrel {\\S} {\\leftarrow} \\text{Primes}(\\lambda) \\\\ &amp;amp; u \\stackrel {\\S} {\\leftarrow} \\mathcal{A}_{1}(\\ell, \\text{state}) \\end{array} \\right] \\leq \\operatorname{negl}(\\lambda).</span></div>

    <p class="text-gray-300">The adaptive root assumption implies that the adversary can't compute the order of any non-trivial element. For any element with known order the adversary can compute arbitrary roots that are co-prime to the order. This immediately allows the adversary to win the adaptive root game. For the group <span class="math">Z_{N}</span> this means that we need to exclude <span class="math">\\{-1,1\\}</span></p>

    <p class="text-gray-300">We will also need the strong RSA assumption for general groups of unknown order. The adaptive root and strong RSA assumptions are incomparable. The former states that it is hard to take a random root of a chosen group element, while the latter says that it is hard to take a chosen root of a random group element. In groups of unknown order that do not require a trusted setup the adversary <span class="math">A</span> additionally gets access to <span class="math">GGen</span>'s random coins.</p>

    <p class="text-gray-300"><strong>Definition 2 (Strong RSA assumption).</strong> <span class="math">GGen</span> satisfies the strong RSA assumption if for all efficient <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ u^{\\ell} = g \\text{ and } \\ell \\text{ is an odd prime: } \\begin{array}{l} \\mathbb{G} \\stackrel {\\S} {\\leftarrow} GGen(\\lambda), \\; g \\stackrel {\\S} {\\leftarrow} \\mathbb{G}, \\\\ (u, \\ell) \\in \\mathbb{G} \\times \\mathbb{Z} \\stackrel {\\S} {\\leftarrow} \\mathcal{A}(\\mathbb{G}, g) \\end{array} \\right] \\leq \\operatorname{negl}(\\lambda).</span></div>

    <h2 id="sec-16" class="text-2xl font-bold">2.2 Generic group model for groups of unknown order</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We will use the generic group model for groups of unknown order as defined by Damgard and Koprowski [DK02]. The group is parameterized by two integer public parameters <span class="math">A, B</span>. The order of the group is sampled uniformly from <span class="math">[A, B]</span>. The group <span class="math">\\mathbb{G}</span> is defined by a random injective function $\\sigma: \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\to \\{0,1\\}^{\\ell}<span class="math">, for some </span>\\ell<span class="math"> where </span>2^{\\ell} \\gg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The group elements are </span>\\sigma(0), \\sigma(1), \\ldots, \\sigma(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1)<span class="math">. A generic group algorithm </span>\\mathcal{A}<span class="math"> is a probabilistic algorithm. Let </span>\\mathcal{L}<span class="math"> be a list that is initialized with the encodings given to </span>\\mathcal{A}$ as input. The algorithm can query two generic group oracles:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathcal{O}_1</span> samples a random $r \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and returns </span>\\sigma(r)<span class="math">, which is appended to the list of encodings </span>\\mathcal{L}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When <span class="math">\\mathcal{L}</span> has size <span class="math">q</span>, the second oracle <span class="math">\\mathcal{O}_2(i,j,\\pm)</span> takes two indices <span class="math">i,j \\in \\{1,\\dots,q\\}</span> and a sign bit, and returns <span class="math">\\sigma(x_i \\pm x_j)</span>, which is appended to <span class="math">\\mathcal{L}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that unlike Shoup's generic group model [Sho97], the algorithm is not given $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, the order of the group </span>\\mathbb{G}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-17" class="text-2xl font-bold">2.3 Argument systems</h2>

    <p class="text-gray-300">An argument system for a relation <span class="math">\\mathcal{R} \\subset \\mathcal{X} \\times \\mathcal{W}</span> is a triple of randomized polynomial time algorithms <span class="math">(\\mathsf{Pgen}, \\mathsf{P}, \\mathsf{V})</span>, where <span class="math">\\mathsf{Pgen}</span> takes an (implicit) security parameter <span class="math">\\lambda</span> and outputs a common reference string (crs) <span class="math">\\mathsf{pp}</span>. If the setup algorithm uses only public randomness we say that the setup is transparent and that the crs is unstructured. The prover <span class="math">\\mathsf{P}</span> takes as input a statement <span class="math">x \\in \\mathcal{X}</span>, a witness <span class="math">w \\in \\mathcal{W}</span>, and the crs <span class="math">\\mathsf{pp}</span>. The verifier <span class="math">\\mathsf{V}</span> takes as input <span class="math">\\mathsf{pp}</span> and <span class="math">x</span> and after interaction with <span class="math">\\mathsf{P}</span> outputs 0 or 1. We denote the transcript between the prover and verifier by <span class="math">\\langle \\mathsf{V}(\\mathsf{pp}, x), \\mathsf{P}(\\mathsf{pp}, x, w) \\rangle</span> and write <span class="math">\\langle \\mathsf{V}(\\mathsf{pp}, x), \\mathsf{P}(\\mathsf{pp}, x, w) \\rangle = 1</span> to indicate that the verifier accepted the transcript. If <span class="math">\\mathsf{V}</span> uses only public randomness we say that the protocol is public coin.</p>

    <p class="text-gray-300"><strong>Definition 3 (Completeness).</strong> We say that an argument system <span class="math">(\\mathsf{Pgen}, \\mathsf{P}, \\mathsf{V})</span> for a relation <span class="math">\\mathcal{R}</span> is <strong>complete</strong> if for all <span class="math">(x, w) \\in \\mathcal{R}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\langle \\mathsf{V}(\\mathsf{pp}, x), \\mathsf{P}(\\mathsf{pp}, x, w) \\rangle = 1: \\mathsf{pp} \\stackrel {\\S} {\\leftarrow} \\mathsf{Pgen}(\\lambda) \\right] = 1.</span></div>

    <p class="text-gray-300">We now define soundness and knowledge extraction for our protocols. The adversary is modeled as two algorithms <span class="math">\\mathcal{A}_{0}</span> and <span class="math">\\mathcal{A}_{1}</span>, where <span class="math">\\mathcal{A}_{0}</span> outputs the instance <span class="math">x\\in\\mathcal{X}</span> <em>after</em> <span class="math">\\mathsf{Pgen}</span> is run, and <span class="math">\\mathcal{A}_{1}</span> runs the interactive protocol with the verifier using a state output by <span class="math">\\mathcal{A}_{0}</span>. In slight deviation from the soundness definition used in statistically sound proof systems, we do not universally quantify over the instance <span class="math">x</span> (i.e. we do not require security to hold for all input instances <span class="math">x</span>). This is due to the fact that in the computationally-sound setting the instance itself may encode a trapdoor of the crs pp (e.g. the order of a group of unknown order), which can enable the adversary to fool a verifier. Requiring that an efficient adversary outputs the instance <span class="math">x</span> prevents this. In our soundness definition the adversary <span class="math">\\mathcal{A}_{1}</span> succeeds if he can make the verifier accept when no witness for <span class="math">x</span> exists. For the stronger <em>argument of knowledge</em> definition we require that an extractor with access to <span class="math">\\mathcal{A}_{1}</span>’s internal state can extract a valid witness whenever <span class="math">\\mathcal{A}_{1}</span> is convincing. We model this by enabling the extractor to rewind <span class="math">\\mathcal{A}_{1}</span> and reinitialize the verifier’s randomness.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 4 (Arguments (of Knowledge)).</h6>

    <p class="text-gray-300">We say that an argument system <span class="math">(\\mathsf{Pgen},\\mathsf{P},\\mathsf{V})</span> is sound if for all poly-time adversaries <span class="math">\\mathcal{A}=(\\mathcal{A}_{0},\\mathcal{A}_{1})</span>:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{ll}\\langle\\mathsf{V}(pp,x),\\mathcal{A}_{1}(pp,x,\\textsf{state})\\rangle=1&\\mbox{pp}\\stackrel{{\\scriptstyle\\mathfrak{S}}}{{\\leftarrow}}\\mathsf{Pgen}(1^{\\lambda})\\\\ \\mbox{and }\\nexists w\\ \\ (x,w)\\in\\mathcal{R}:&\\mbox{<span class="math">(x,\\textsf{state})</span>}\\leftarrow\\mathcal{A}_{0}(pp)\\end{array}\\right]=\\mathsf{negl}(\\lambda). \\]</p>

    <p class="text-gray-300">Additionally, the argument system is an argument of knowledge if for all poly-time adversaries <span class="math">\\mathcal{A}_{1}</span> there exists a poly-time extractor <span class="math">\\mathsf{Ext}</span> such that for all poly-time adversaries <span class="math">\\mathcal{A}_{0}</span>:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{ll}\\langle\\mathsf{V}(pp,x),\\mathcal{A}_{1}(pp,x,\\textsf{state})\\rangle=1&\\mbox{pp}\\stackrel{{\\scriptstyle\\mathfrak{S}}}{{\\leftarrow}}\\mathsf{Pgen}(1^{\\lambda})\\\\ \\mbox{and }(x,w^{\\prime})\\not\\in\\mathcal{R}:&\\mbox{<span class="math">(x,\\textsf{state})</span>}\\leftarrow\\mathcal{A}_{0}(pp)\\\\ \\end{array}\\right]=\\mathsf{negl}(\\lambda). \\]</p>

    <p class="text-gray-300">Any argument of knowledge is also sound. In some cases we may further restrict <span class="math">\\mathcal{A}</span> in the security analysis, in which case we would say the system is an argument of knowledge for a restricted class of adversaries. For example, in this work we construct argument systems for relations that depend on a group <span class="math">\\mathbb{G}</span> of unknown order. In the analysis we replace <span class="math">\\mathbb{G}</span> with a generic group and restrict <span class="math">\\mathcal{A}</span> to a generic group algorithm that interacts with the oracles for this group. For simplicity, although slightly imprecise, we say the protocol is an <em>argument of knowledge in the generic group model</em>. Groth <em>[x13]</em> recently proposed a SNARK system for arbitrary relations that is an argument of knowledge in the generic group model in a slightly different sense, where the generic group is used as part of the construction rather than the relation and the adversary is a generic group algorithm with respect to this group generated by the setup.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 5 (Non interactive arguments).</h6>

    <p class="text-gray-300">A non-interactive argument system is an argument system where the interaction between <span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> consists of only a single round. We then write the prover <span class="math">\\mathsf{P}</span> as <span class="math">\\pi\\stackrel{{\\scriptstyle\\mathfrak{S}}}{{\\leftarrow}}\\mathsf{Prove}(pp,x,w)</span> and the verifier as <span class="math">\\{0,1\\}\\leftarrow\\mathsf{Vf}(pp,x,\\pi)</span>.</p>

    <p class="text-gray-300">The Fiat-Shamir heuristic <em>[x10]</em> and its generalization to multi-round protocols <em>[x4]</em> can be used to transform public coin argument systems to non-interactive systems.</p>

    <h2 id="sec-20" class="text-2xl font-bold">3 Succinct proofs for hidden order groups</h2>

    <p class="text-gray-300">In this section we present several new succinct proofs in groups of unknown order. The proofs build on a proof of exponentiation recently proposed by Wesolowski <em>[x23]</em> in the context of verifiable delay functions <em>[x11]</em>. We show that the Wesolowski proof is a <em>succinct</em> proof of knowledge of a discrete-log in a group of unknown order. We then derive a <em>succinct</em> zero-knowledge argument of</p>

    <p class="text-gray-300">knowledge for a discrete-log relation, and more generally for knowledge of the inverse of a homomorphism <span class="math">h:\\mathbb{Z}^{n}\\to\\mathbb{G}</span>, where <span class="math">\\mathbb{G}</span> is a group of unknown order. Using the Fiat-Shamir heuristic, the non-interactive version of this protocol is a special purpose SNARK for the pre-image of a homomorphism.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">3.1 A succinct proof of exponentiation</h3>

    <p class="text-gray-300">Let <span class="math">\\mathbb{G}</span> be a group of unknown order. Let <span class="math">[\\ell]:=\\{0,1,\\ldots,\\ell-1\\}</span> and let <span class="math">\\mathsf{Primes}(\\lambda)</span> denote the set of odd prime numbers in <span class="math">[0,2^{\\lambda}]</span>. We begin by reviewing Wesolowski’s (non-ZK) proof of exponentiation <em>[x23]</em> in the group <span class="math">\\mathbb{G}</span>. Here both the prover and verifier are given <span class="math">(u,w,x)</span> and the prover wants to convince the verifier that <span class="math">w=u^{x}</span> holds in <span class="math">\\mathbb{G}</span>. That is, the protocol is an argument system for the relation</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{\\mathsf{PoE}}=\\big{\\{}\\big{(}(u,w\\in\\mathbb{G},x\\in\\mathbb{Z});\\ \\bot\\big{)}\\ :\\ w=u^{x}\\in\\mathbb{G}\\big{\\}}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The verifier’s work should be much less than computing <span class="math">u^{x}</span> by itself. Note that <span class="math">x\\in\\mathbb{Z}</span> can be much larger than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, which is where the protocol is most useful. The protocol works as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Protocol PoE (Proof of exponentiation) for <span class="math">\\mathcal{R}_{\\mathsf{PoE}}</span> <em>[x23]</em> Params: <span class="math">\\mathbb{G}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}GGen(\\lambda)<span class="math">; Inputs: </span>u,w\\in\\mathbb{G},\\ x\\in\\mathbb{Z}<span class="math">; Claim: </span>u^{x}=w$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier sends <span class="math">\\ell\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathsf{Primes}(\\lambda)$ to prover.</li>

      <li>Prover computes the quotient <span class="math">q=\\lfloor x/\\ell\\rfloor\\in\\mathbb{Z}</span> and residue <span class="math">r\\in[\\ell]</span> such that <span class="math">x=q\\ell+r</span>.</li>

    </ol>

    <p class="text-gray-300">Prover sends <span class="math">Q\\leftarrow u^{q}\\in\\mathbb{G}</span> to the Verifier.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier computes <span class="math">r\\leftarrow(x\\bmod\\ell)\\in[\\ell]</span> and accepts if <span class="math">Q^{\\ell}u^{r}=w</span> holds in <span class="math">\\mathbb{G}</span>.</li>

    </ol>

    <p class="text-gray-300">The protocol above is a minor generalization of the protocol from <em>[x23]</em> in that we allow an arbitrary exponent <span class="math">x\\in\\mathbb{Z}</span>, where as in <em>[x23]</em> the exponent was restricted to be a power of two. This does not change the soundness property captured in the following theorem, whose proof is given in <em>[x23, Prop. 2]</em> (see also <em>[x1, Thm. 2]</em>) and relies on the adaptive root assumption for GGen.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Theorem 1 (Soundness PoE <em>[x23]</em>).</h6>

    <p class="text-gray-300">Protocol PoE is an argument system for Relation <span class="math">\\mathcal{R}_{\\mathsf{PoE}}</span> with negligible soundness error, assuming the adaptive root assumption holds for GGen.</p>

    <p class="text-gray-300">For the protocol to be useful the verifier must be able to compute <span class="math">r=x\\bmod\\ell</span> faster than computing <span class="math">u^{x}\\in\\mathbb{G}</span>. The original protocol presented by Wesolowski assumed that <span class="math">x=2^{T}</span> is a power of two, so that computing <span class="math">x\\bmod\\ell</span> requires only <span class="math">\\log(T)</span> multiplications in <span class="math">\\mathbb{Z}_{\\ell}</span> whereas computing <span class="math">u^{x}</span> requires <span class="math">T</span> group operations.</p>

    <p class="text-gray-300">For a general exponent <span class="math">x\\in\\mathbb{Z}</span>, computing <span class="math">x\\bmod\\ell</span> takes <span class="math">O((\\log x)/\\lambda)</span> multiplications in <span class="math">\\mathbb{Z}_{\\ell}</span>. In contrast, computing <span class="math">u^{x}\\in\\mathbb{G}</span> takes <span class="math">O(\\log x)</span> group operations in <span class="math">\\mathbb{G}</span>. Hence, for the current groups of unknown order, computing <span class="math">u^{x}</span> takes <span class="math">\\lambda^{3}</span> times as long as computing <span class="math">x\\bmod\\ell</span>. Concretely, when <span class="math">\\ell</span> is a 128 bit integer, a multiplication in <span class="math">\\mathbb{Z}_{\\ell}</span> is approximately 5000 time faster than a group operation in a 2048-bit RSA group. Hence, the verifier’s work is much less than computing <span class="math">w=u^{x}</span> in <span class="math">\\mathbb{G}</span> on its own.</p>

    <p class="text-gray-300">Note that the adaptive root assumption is not only a sufficient security requirement but also necessary. In particular it is important that no known order elements are in the group <span class="math">\\mathbb{G}</span>. Assume for example that <span class="math">-1\\in\\mathbb{G}</span> such that <span class="math">(-1)^{2}=1\\in\\mathbb{G}</span>. If <span class="math">g^{x}=y</span> then an adversary can succeed in <span class="math">\\mathsf{PoE}(g,-y,x)</span> by setting <span class="math">Q^{\\prime}\\leftarrow-1\\cdot g^{\\lfloor x/\\ell\\rfloor}</span>. It is, therefore, important to not directly use the multiplicative RSA group <span class="math">\\mathbb{G}:=(\\mathbb{Z}/N)^{<em>}</span> but rather <span class="math">\\mathbb{G}^{+}:=\\mathbb{G}/\\{-1,1\\}</span> as described in </em>[x1]*.</p>

    <p class="text-gray-300">The PoE protocol can be generalized to a relation involving any homomorphism <span class="math">\\phi:\\mathbb{Z}^{n}\\to\\mathbb{G}</span> for which the adaptive root assumption holds in <span class="math">\\mathbb{G}</span>. The details of this generalization are discussed in Appendix A.1.</p>

    <p class="text-gray-300">3.2 A succinct proof of knowledge of a discrete-log</p>

    <p class="text-gray-300">We next show how the protocol PoE can be adapted to provide an argument of knowledge of discrete-log, namely an argument of knowledge for the relation:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{\\mathsf{PoKE}}=\\big{\\{}\\big{(}(u,w\\in\\mathbb{G});\\ x\\in\\mathbb{Z}\\big{)}\\ :\\ w=u^{x}\\in\\mathbb{G}\\big{\\}}.</span></p>

    <p class="text-gray-300">The goal is to construct a protocol that has communication complexity that is much lower than simply sending <span class="math">x</span> to the verifier. As a stepping stone we first provide an argument of knowledge for a modified PoKE relation, where the base <span class="math">u\\in\\mathbb{G}</span> is fixed and encoded in a CRS. Concretely let CRS consist of the unknown-order group <span class="math">\\mathbb{G}</span> and the generator <span class="math">g</span>. We construct an argument of knowledge for the following relation:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{\\mathsf{PoKE}^{*}}=\\big{\\{}\\big{(}w\\in\\mathbb{G};\\ x\\in\\mathbb{Z}\\big{)}\\ :\\ w=g^{x}\\in\\mathbb{G}\\big{\\}}.</span></p>

    <p class="text-gray-300">The argument modifies the PoE Protocol in that <span class="math">x</span> is not given to the verifier, and the remainder <span class="math">r\\in[\\ell]</span> is sent from the prover to the verifier:</p>

    <p class="text-gray-300">Protocol PoKE^{∗} (Proof of knowledge of exponent) for Relation <span class="math">\\mathcal{R}_{\\mathsf{PoKE}^{*}}</span>. Params: <span class="math">\\mathbb{G}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}GGen(\\lambda)<span class="math">, </span>g\\in\\mathbb{G}<span class="math">; Inputs: </span>w\\in\\mathbb{G}<span class="math">; Witness: </span>x\\in\\mathbb{Z}<span class="math">; Claim: </span>g^{x}=w$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier sends <span class="math">\\ell\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathsf{Primes}(\\lambda)$.</li>

      <li>Prover computes the quotient <span class="math">q\\in\\mathbb{Z}</span> and residue <span class="math">r\\in[\\ell]</span> such that <span class="math">x=q\\ell+r</span>. Prover sends the pair <span class="math">(Q\\leftarrow g^{q},\\ r)</span> to the Verifier.</li>

      <li>Verifier accepts if <span class="math">r\\in[\\ell]</span> and <span class="math">Q^{\\ell}g^{r}=w</span> holds in <span class="math">\\mathbb{G}</span>.</li>

    </ol>

    <p class="text-gray-300">Here the verifier does not have the witness <span class="math">x</span>, but the prover additionally sends <span class="math">r:=(x\\bmod\\ell)</span> along with <span class="math">Q</span> in its response to the verifier’s challenge. Note that the verifier no longer computes <span class="math">r</span> on its own, but instead relies on the value from the prover. We will demonstrate an extractor that extracts the witness <span class="math">x\\in\\mathbb{Z}</span> from a successful prover, and prove that this extractor succeeds with overwhelming probability against a generic group prover. In fact, in the next section we will present a generalization of Protocol PoKE^{∗} to group representations in terms of bases <span class="math">\\{g_{i}\\}_{i=1}^{n}</span> included in the CRS, i.e. a proof of knowledge of an integer vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}^{n}</span> such that <span class="math">\\prod_{i}g_{i}^{x_{i}}=w</span>. We will prove that this protocol is an argument of knowledge against a generic group adversary. The security of Protocol PoKE^{∗} above follows as a special case. Hence, the following theorem is a special case of Theorem 7 below.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">Protocol PoKE^{∗} is an argument of knowledge for relation <span class="math">\\mathcal{R}_{\\mathsf{PoKE}^{*}}</span> in the generic group model.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">An attack.</h4>

    <p class="text-gray-300">Protocol PoKE^{∗} requires the discrete logarithm base <span class="math">g</span> to be encoded in the CRS. When this protocol is applied to a base freely chosen by the adversary it becomes insecure. In other words, Protocol PoKE^{∗} is not a secure protocol for the relation <span class="math">\\mathcal{R}_{\\mathsf{PoKE}}</span>.</p>

    <p class="text-gray-300">To describe the attack, let <span class="math">g</span> be a generator of <span class="math">\\mathbb{G}</span> and let <span class="math">u=g^{x}</span> and <span class="math">w=g^{y}</span> where <span class="math">y\\neq 1</span> and <span class="math">x</span> does not divide <span class="math">y</span>. Suppose that the adversary knows both <span class="math">x</span> and <span class="math">y</span> but not the discrete log of <span class="math">w</span> base <span class="math">u</span>. Computing an integer discrete logarithm of <span class="math">w</span> base <span class="math">u</span> is still difficult in a generic group (as follows from Lemma 3), however an efficient adversary can nonetheless succeed in fooling the verifier as follows. Since the challenge <span class="math">\\ell</span> is co-prime with <span class="math">x</span> with overwhelming probability, the adversary can compute <span class="math">q,r\\in\\mathbb{Z}</span> such that <span class="math">q\\ell+rx=y</span>. The adversary sends <span class="math">(Q=g^{q},\\ r)</span> to the verifier, and the verifier checks that indeed <span class="math">Q^{\\ell}u^{r}=w</span>. Hence, the verifier accepts despite the adversary not knowing the discrete log of <span class="math">w</span> base <span class="math">u</span>.</p>

    <p class="text-gray-300">This does not qualify as an “attack” when <span class="math">x=1</span>, or more generally when <span class="math">x</span> divides <span class="math">y</span>, since then the adversary does know the discrete logarithm <span class="math">y/x</span> such that <span class="math">u^{y/x}=w</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Extending PoKE for general bases. To obtain a protocol for the relation <span class="math">\\mathcal{R}_{\\mathsf{PoKE}}</span> we start by modifying protocol <span class="math">\\mathsf{PoKE}^<em></span> so that the prover first sends <span class="math">z = g^x</span>, for a fixed base <span class="math">g</span>, and then executes two <span class="math">\\mathsf{PoKE}^</em></span> style protocols, one base <span class="math">g</span> and one base <span class="math">u</span>, in parallel, showing that the discrete logarithm of <span class="math">w</span> base <span class="math">u</span> equals the one of <span class="math">z</span> base <span class="math">g</span>. We show that the resulting protocol is a secure argument of knowledge (in the generic group model) for the relation <span class="math">\\mathcal{R}_{\\mathsf{PoKE}}</span>. The transcript of this modified protocol now consists of two group elements instead of one.</p>

    <p class="text-gray-300">Protocol PoKE (Proof of knowledge of exponent) Params: <span class="math">\\mathbb{G} \\stackrel{\\S}{\\leftarrow} GGen(\\lambda)</span>, <span class="math">g \\in \\mathbb{G}</span>; Inputs: <span class="math">u, w \\in \\mathbb{G}</span>; Witness: <span class="math">x \\in \\mathbb{Z}</span>; Claim: <span class="math">u^x = w</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prover sends <span class="math">z = g^x \\in \\mathbb{G}</span> to the verifier.</li>

      <li>Verifier sends <span class="math">\\ell \\stackrel{\\S}{\\leftarrow} \\mathsf{Primes}(\\lambda)</span>.</li>

      <li>Prover finds the quotient <span class="math">q \\in \\mathbb{Z}</span> and residue <span class="math">r \\in [\\ell]</span> such that <span class="math">x = q\\ell + r</span>. Prover sends <span class="math">Q = u^q</span> and <span class="math">Q&#x27; = g^q</span> and <span class="math">r</span> to the Verifier.</li>

      <li>Verifier accepts if <span class="math">r \\in [\\ell]</span>, <span class="math">Q^\\ell u^r = w</span>, and <span class="math">Q&#x27;^q g^r = z</span>.</li>

    </ol>

    <p class="text-gray-300">The intuition for the security proof is as follows. The extractor first uses the same extractor for Protocol PoKE* (specified in Theorem 7) to extract the discrete logarithm <span class="math">x</span> of <span class="math">z</span> base <span class="math">g</span>. It then suffices to argue that this extracted discrete logarithm <span class="math">x</span> is a correct discrete logarithm of <span class="math">w</span> base <span class="math">u</span>. We use the adaptive root assumption to argue that the extracted <span class="math">x</span> is a correct discrete logarithm of <span class="math">w</span> base <span class="math">u</span>.</p>

    <p class="text-gray-300">We can optimize the protocol to bring down the proof size back to a single group element. We do so in the protocol PoKE2 below by adding one round of interaction. The additional round has no effect on proof size after making the protocol non-interactive using Fiat-Shamir.</p>

    <p class="text-gray-300">Protocol PoKE2 (Proof of knowledge of exponent) Params: <span class="math">\\mathbb{G} \\stackrel{\\S}{\\leftarrow} GGen(\\lambda)</span>; Inputs: <span class="math">u, w \\in \\mathbb{G}</span>; Witness: <span class="math">x \\in \\mathbb{Z}</span>; Claim: <span class="math">u^x = w</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier sends <span class="math">g \\stackrel{\\S}{\\leftarrow} \\mathbb{G}</span> to the Prover.</li>

      <li>Prover sends <span class="math">z \\leftarrow g^x \\in \\mathbb{G}</span> to the verifier.</li>

      <li>Verifier sends <span class="math">\\ell \\stackrel{\\S}{\\leftarrow} \\mathsf{Primes}(\\lambda)</span> and <span class="math">\\alpha \\stackrel{\\S}{\\leftarrow} [0, 2^{\\lambda})</span>.</li>

      <li>Prover finds the quotient <span class="math">q \\in \\mathbb{Z}</span> and residue <span class="math">r \\in [\\ell]</span> such that <span class="math">x = q\\ell + r</span>. Prover sends <span class="math">Q = u^{q}g^{\\alpha q}</span> and <span class="math">r</span> to the Verifier.</li>

      <li>Verifier accepts if <span class="math">r \\in [\\ell]</span> and <span class="math">Q^{\\ell}u^{r}g^{\\alpha r} = wz^{\\alpha}</span>.</li>

    </ol>

    <p class="text-gray-300">The intuition for the security proof is the same as for Protocol PoKE, but we additionally show that (in the generic group model) a similar extraction argument holds when the prover instead sends <span class="math">Q \\gets u^{q}g^{q}</span> and <span class="math">r</span> such that <span class="math">Q^{\\ell}u^{r}g^{r} = wz</span>. The extraction argument uses the fact that with overwhelming probability the generic adversary did not obtain <span class="math">g</span> from any of its group oracle queries prior to forming <span class="math">w</span> and therefore the adversary's representation of <span class="math">w</span> does not contain <span class="math">g</span> as a base with a non-zero exponent. The extractor is able to obtain an exponent <span class="math">x</span> such that <span class="math">(gu)^{x} = wz</span>. This alone does not yet imply that <span class="math">u^{x} = w</span>, however if the prover sends <span class="math">Q, r</span> such that <span class="math">Q^{\\ell}u^{r}g^{\\alpha r} = wz^{\\alpha}</span>, then the extractor obtains a fixed <span class="math">x</span> such that <span class="math">(g^{\\alpha}u)^{x} = wz^{\\alpha}</span> with high probability over the random choice of <span class="math">\\alpha</span>. This implies that either <span class="math">u^{x} = w</span> or <span class="math">w / u^{x}</span> is an element of low order, which breaks the adaptive root assumption. We summarize this in the following theorem. See Appendix C for the proof.</p>

    <p class="text-gray-300">Theorem 3 (PoKE Argument of Knowledge). Protocol PoKE and Protocol PoKE2 are arguments of knowledge for relation <span class="math">\\mathcal{R}_{\\mathsf{PoKE}}</span> in the generic group model.</p>

    <p class="text-gray-300">The PoKE argument of knowledge can be extended to an argument of knowledge for the pre-image of a homomorphism <span class="math">\\phi : \\mathbb{Z}^n \\to \\mathbb{G}</span>. This is included in Appendix A.2.</p>

    <p class="text-gray-300">10</p>

    <p class="text-gray-300">We can also construct a (honest-verifier) zero-knowledge version of the PoKE argument of knowledge protocol using a method similar to the classic Schnorr <span class="math">\\Sigma</span>-protocol for hidden order groups. This is covered in Appendix A.4.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">3.3 Aggregating Knowledge of Co-prime Roots</h3>

    <p class="text-gray-300">Unlike exponents, providing a root of an element in a hidden order group is already succinct (it is simply a group element). There is a simple aggregation technique for providing a succinct proof of knowledge for multiple <em>co-prime</em> roots <span class="math">x_{1},...,x_{n}</span> simultaneously. This is useful for aggregating PoKE proofs.</p>

    <p class="text-gray-300">When the roots are all for the same element <span class="math">\\alpha</span> then the witness is trivially a root <span class="math">\\alpha^{1/x^{<em>}}</span> where <span class="math">x^{</em>}=x_{1}\\cdots x_{n}</span>. From this witness one can publicly extract the <span class="math">x_{i}</span>th root of <span class="math">\\alpha</span> for each <span class="math">i</span>. We show a method where the elements need not be the same, i.e. the witness is a list of elements <span class="math">w_{1},...,w_{n}</span> for public elements <span class="math">\\alpha_{1},...,\\alpha_{n}</span> and public integers <span class="math">x_{1},...,x_{n}</span> such that <span class="math">w_{i}^{x_{i}}=\\alpha_{i}</span> for each <span class="math">i</span> and <span class="math">gcd(x_{i},x_{j})=1\\forall i,j\\in[1,n],i\\neq j</span>. The size of the proof is still a single element.</p>

    <p class="text-gray-300">Concretely the PoKCR protocol is a proof for the relation:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{\\textsf{PoKCR}}=\\big{\\{}\\big{(}\\alpha\\in\\mathbb{G}^{n};\\ \\mathbf{x}\\in\\mathbb{Z}^{n}\\big{)}\\ :\\ w=\\phi(\\mathbf{x})\\in\\mathbb{G}\\big{\\}}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The proof is the product of witnesses, <span class="math">w\\leftarrow w_{1}\\cdots w_{n}</span>. From this product and the public <span class="math">x_{i}</span>’s and <span class="math">\\alpha_{i}</span>’s it is possible to extract an <span class="math">x_{i}</span>th root of each <span class="math">\\alpha_{i}</span>. (This is not necessarily the same as <span class="math">w_{i}</span> as roots are not unique). Moreover, the verification algorithm does not need to run this extraction procedure in full, it only needs to check that <span class="math">w^{x^{<em>}}=\\prod_{i}\\alpha_{i}^{x^{</em>}/x_{i}}</span>. This equation can be verifier with <span class="math">O(n\\log n)</span> group exponentiations with exponents of size at most $\\max_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ using the optimized recursive MultiExp algorithm shown below.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Protocol PoKCR for Relation <span class="math">\\mathcal{R}_{\\textsf{PoKCR}}</span> Input: <span class="math">\\mathbb{G}</span>, <span class="math">\\alpha_{1},...,\\alpha_{n}\\in\\mathbb{G}</span>, <span class="math">x_{1},...,x_{n}\\in\\mathbb{Z}</span> s.t. <span class="math">gcd(x_{1},...,x_{n})=1</span>; Witness: <span class="math">\\mathbf{w}\\in\\mathbb{G}^{n}</span> s.t. <span class="math">w_{i}^{x_{i}}=\\alpha_{i}</span> 1. Prover sends <span class="math">w\\leftarrow\\prod_{i=1}^{n}w_{i}</span> to the Verifier. 2. Verifier computes <span class="math">x^{<em>}\\leftarrow\\prod_{i=1}^{n}x_{i}</span>, and <span class="math">y\\leftarrow\\prod_{i=1}^{n}\\alpha_{i}^{x^{</em>}/x_{i}}</span> using <span class="math">\\textbf{MultiExp}(n,\\bm{\\alpha},\\bm{x})</span>. Verifier accepts if <span class="math">w^{x^{*}}=y</span>.</p>

    <p class="text-gray-300">MultiExp<span class="math">(n,\\bm{\\alpha},\\bm{x})</span>: 1. if <span class="math">n=1</span> return <span class="math">\\alpha</span> 2. <span class="math">\\bm{\\alpha_{L}}\\leftarrow(\\alpha_{1},...,\\alpha_{n/2})</span>; <span class="math">\\bm{\\alpha_{R}}\\leftarrow(\\alpha_{n/2+1},...,\\alpha_{n})</span> 3. <span class="math">\\bm{x_{L}}\\leftarrow(x_{1},...,x_{n/2})</span>; <span class="math">\\bm{x_{R}}\\leftarrow(x_{n/2+1},...,x_{n})</span> 4. <span class="math">x^{<em>}_{L}\\leftarrow x_{1}\\cdots x_{n/2}</span>; <span class="math">x^{</em>}_{R}\\leftarrow x_{n/2+1}\\cdots x_{n}</span> 5. <span class="math">L\\leftarrow\\textbf{MultiExp}(n/2,\\bm{\\alpha_{L}},\\bm{x_{L}})</span>; <span class="math">R\\leftarrow\\textbf{MultiExp}(n/2,\\bm{\\alpha_{R}},\\bm{x_{R}})</span> 6. return <span class="math">L^{x^{<em>}_{R}}\\cdot R^{x^{</em>}_{L}}</span></p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Protocol PoKCR is an argument of knowledge for Relation <span class="math">\\mathcal{R}_{\\textsf{PoKCR}}</span>.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We show that given any <span class="math">w</span> such that <span class="math">w^{x^{<em>}}=y=\\prod_{i=1}^{n}\\alpha_{i}^{x^{</em>}/x_{i}}</span> it is possible to compute directly an <span class="math">x_{i}</span>th root of <span class="math">\\alpha_{i}</span> for all <span class="math">i</span>. For each <span class="math">i</span> and <span class="math">j\\neq i</span> let <span class="math">z_{ij}=x^{<em>}/(x_{i}x_{j})</span>. For each <span class="math">i</span>, let <span class="math">A_{j}=\\prod_{i\\neq j}\\alpha_{i}^{z_{ij}}</span>, then we can express <span class="math">y=A_{j}^{x_{i}}\\alpha_{i}^{x^{</em>}/x_{i}}</span>. This shows that the element <span class="math">u=w^{(x^{<em>}/x_{i})}A_{j}^{-1}</span> is an <span class="math">x_{i}</span>th root of <span class="math">\\alpha_{i}^{x^{</em>}/x_{i}}</span>. Since <span class="math">gcd(x^{<em>}/x_{i},x_{i})=1</span>, there exist Bezout coefficients <span class="math">a,b</span> such that <span class="math">a(x^{</em>}/x_{i})+bx_{i}=1</span>. Finally, <span class="math">u^{a}\\alpha_{i}^{b}</span> is an <span class="math">x_{i}</span>th root of <span class="math">\\alpha_{i}</span> as <span class="math">(u^{a}\\alpha_{i}^{b})^{x_{i}}=\\alpha_{i}^{(ax^{*}/x_{i})+bx_{i}}=\\alpha_{i}</span>. ∎</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">Non-interactive proofs</h4>

    <p class="text-gray-300">All of the protocols can be made non-interactive using the standard Fiat-Shamir transform. In the Fiat-Shamir transform, the prover non-interactively builds a simulated transcript of the protocol by replacing each of the verifier’s challenges with a hash of the protocol transcript preceding the challenge</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: A trapdoorless universal accumulator.</p>

    <p class="text-gray-300">using a collision-resistant hash function  <span class="math">H</span>  as a heuristic substitute for a random oracle. In our protocols, the verifier's challenges are sampled from  <span class="math">\\mathsf{Primes}(\\lambda)</span>  and  <span class="math">\\mathbb{G}</span> . Therefore, the non-interactive version must involve a canonical mapping of the output seed  <span class="math">\\sigma</span>  of the random oracle to a random prime or element of  <span class="math">\\mathbb{G}</span> . Furthermore, it is important that hashing to an element  <span class="math">g \\in \\mathbb{G}</span>  does not reveal the discrete log relation between  <span class="math">g</span>  and any another element (i.e.  <span class="math">g \\gets u^{\\sigma}</span>  is not secure). The simplest way to map  <span class="math">\\sigma</span>  to a prime in  <span class="math">\\mathsf{Primes}(\\lambda)</span>  is to find the smallest integer  <span class="math">i</span>  such that the first  <span class="math">\\lambda</span>  bits of  <span class="math">H(\\sigma, i)</span>  is prime. More efficient methods are described in Section 7. It is these non-interactive, succinct, and efficiently verifiable proofs that are most useful for the applications discussed later in this paper. Appendix D summarizes the non-interactive proofs that will be used later.</p>

    <p class="text-gray-300">Aggregating PoKE proofs Several non-interactive PoE/PoKE/PoKE2 proofs can be aggregated using the PoKCR protocol. The value  <span class="math">Q</span>  sent to the verifier in this proof is the  <span class="math">\\ell</span> th root of  <span class="math">yg^{-\\sigma}</span> . As long as the primes sampled in each proof instance are distinct then these proofs (specifically the values  <span class="math">Q_{i}</span> ) are a witness for an instance of PoKCR. Since the primes are generated by hashing the inputs to the proof they need not be included in the proof.</p>

    <p class="text-gray-300">In this section we describe a number of new techniques for manipulating accumulators built from the strong RSA assumption in a group of unknown order. We show how to efficiently remove elements from the accumulator, how to use the proof techniques from Section 3 to give short membership proofs for multiple elements, and how to non-interactively aggregate inclusion and exclusion proofs. All our techniques are geared towards the setting where there is no trusted setup. We begin by defining what an accumulator is and what it means for an accumulator to be secure.</p>

    <p class="text-gray-300">Our presentation of a trapdoorless universal accumulator mostly follows the definitions and naming conventions of  <span class="math">\\left[\\mathrm{BCD}^{+}17\\right]</span> . Figure 1 summarizes the accumulator syntax and list of associated operations. One notable difference in our syntax is the presence of a common reference string pp generated by the Setup algorithm in place of private/public keys.</p>

    <p class="text-gray-300">The security definition we follow [Lip12] formulates an undeniability property for accumulators. For background on how this definition relates to others that have been proposed see  <span class="math">\\left[\\mathrm{BCD}^{+}17\\right]</span> , which gives generic transformations between different accumulators with different properties and at different security levels.</p>

    <p class="text-gray-300">The following definition states that an accumulator is secure if an adversary cannot construct an accumulator, an element  <span class="math">x</span>  and a valid membership witness  <span class="math">w_{x}^{t}</span></p>

    <p class="text-gray-300">and a non-membership witness  <span class="math">u_x^t</span>  where  <span class="math">w_x^t</span>  shows that  <span class="math">x</span>  is in the accumulator and  <span class="math">u_x^t</span>  shows that it is not. Lipmaa [Lip12] also defines undeniability without a trusted setup. In that definition the adversary has access to the random coins used by Setup.</p>

    <p class="text-gray-300">Definition 6 (Accumulator Security (Undeniability)).</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l} \\rho \\rho , A _ {0} \\in \\mathbb {G} \\stackrel {{\\S}} {{\\leftarrow}} \\text {S e t u p} (\\lambda) \\\\ (A, x, w _ {x}, u _ {x}) \\stackrel {{\\S}} {{\\leftarrow}} \\mathcal {A} (\\rho \\rho , A _ {0}) \\\\ \\text {V e r M e m} (A, x, w _ {x} ^ {t}) \\wedge \\text {V e r N o n M e m} (A, x, u _ {x} ^ {t}) \\end{array} \\right] = \\operatorname {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">Several sub-procedures that are used heavily in the construction are summarized below. Bezout(x,y) refers to a sub-procedure that outputs Bezout coefficients  <span class="math">a, b \\in \\mathbb{Z}</span>  for a pair of co-prime integers  <span class="math">x, y</span>  (i.e. satisfying the relation  <span class="math">ax + by = 1</span> ). ShamirTrick uses Bezout coefficient's to compute an  <span class="math">(xy)</span> -th root of a group element  <span class="math">g</span>  from an  <span class="math">x</span> -th root of  <span class="math">g</span>  and a  <span class="math">y</span> th root of  <span class="math">g</span> . RootFactor is a procedure that given an element  <span class="math">y = g^x</span>  and the factorization of the exponent  <span class="math">x = x_1 \\cdots x_n</span>  computes an  <span class="math">x_i</span> -th root of  <span class="math">y</span>  for all  <span class="math">i = 1, \\ldots, n</span>  in total time  <span class="math">O(n \\log(n))</span> . Naively this procedure would take time  <span class="math">O(n^2)</span> . It is related to the MultiExp algorithm described earlier and was originally described by [STSY01].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ShamirTrick(w1, w2, x, y): [Sha83]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RootFactor(g, x1, ...,xn):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1. if w1x ≠ w2g return ⊥</td>

            <td class="px-3 py-2 border-b border-gray-700">1. if n = 1 return g</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2. a, b ← Bezout(x, y)</td>

            <td class="px-3 py-2 border-b border-gray-700">2. n' ← [n/2]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. return w1b w2g</td>

            <td class="px-3 py-2 border-b border-gray-700">3. gL ← gΠi=1xj</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hprime(x):</td>

            <td class="px-3 py-2 border-b border-gray-700">4. gR ← gΠi=n'+1xj</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1. y ← H(x)</td>

            <td class="px-3 py-2 border-b border-gray-700">5. L ← RootFactor(gR, x1, ...,xn')</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2. while y is not odd prime:</td>

            <td class="px-3 py-2 border-b border-gray-700">6. R ← RootFactor(gL, xn'+1, ...,xn)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. y ← H(y)</td>

            <td class="px-3 py-2 border-b border-gray-700">7. return L</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">R</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  4. return y |   |</p>

    <p class="text-gray-300">Groups of unknown order The accumulator requires a procedure  <span class="math">GGen(\\lambda)</span>  which samples a group of unknown order in which the strong root assumption (Definition 2) holds. One can use the quotient group  <span class="math">(\\mathbb{Z} / N)^{<em>} / \\{-1,1\\}</span> , where  <span class="math">N</span>  is an RSA modulus, which may require a trusted setup to generate the modulus  <span class="math">N</span> . Alternatively, one can use a class group which eliminates the trusted setup. Note that the adaptive root assumption requires that these groups have no known elements of low order, and hence the group  <span class="math">(\\mathbb{Z} / N)^{</em>}</span>  is not suitable because  <span class="math">(-1) \\in (\\mathbb{Z} / N)^{*}</span>  has order two [BBF18]. Given an element of order two it is possible to convince a PoE-verifier that  <span class="math">g^{x} = -y</span>  when in fact  <span class="math">g^{x} = y</span> .</p>

    <p class="text-gray-300">The basic RSA accumulator. We review the classic RSA accumulator [CL02, Lip12] below, omitting all the procedures that require trapdoor information. All accumulated values are odd primes. If the strong RSA assumption (Definition 2) holds in  <span class="math">\\mathbb{G}</span> , then the accumulator satisfies the undeniability definition [Lip12].</p>

    <p class="text-gray-300">The core procedures for the basic dynamic accumulator are the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup generates a group of unknown order and initializes the group with a generator of that group.</li>

      <li>Add takes the current accumulator  <span class="math">A_{t}</span> , an element from the odd primes domain, and computes  <span class="math">A_{t + 1} = A_{t}</span> .</li>

      <li>Del does not have such a trapdoor and therefore needs to reconstruct the set from scratch. The RootFactor algorithm can be used for pre-computation. Storing  <span class="math">2^k</span>  elements and doing  <span class="math">n \\cdot k</span>  work, the online removal will only take  <span class="math">(1 - \\frac{1}{2}^k) \\cdot n</span>  steps.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A membership witness is simply the accumulator without the aggregated item.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- A membership non-witness, proposed by [LLX07], uses the fact that for any  <span class="math">x \\notin S</span> ,  <span class="math">\\gcd(x, \\prod_{s \\in S} s) = 1</span> . The Bezout coefficients  <span class="math">(a, b) \\gets \\mathbf{Bezout}(x, \\prod_{s \\in S} s)</span>  are therefore a valid membership witness. The actual witness is the pair  <span class="math">(a, g^b)</span>  which is short because  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Membership and non-membership witnesses can be efficiently updated as in [LLX07]</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setup(λ):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">MemWitCreate(A,S,x):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1. G←GGen(λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">1. wk←gΠs∈S,x≠x s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2. g←G</td>

            <td class="px-3 py-2 border-b border-gray-700">2. return wk</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. return G,g</td>

            <td class="px-3 py-2 border-b border-gray-700">NonMemWitCreate(A,S,x):</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Add(At,S,x):</td>

            <td class="px-3 py-2 border-b border-gray-700">1. s*←Πs∈S s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1. if x∈S: return At</td>

            <td class="px-3 py-2 border-b border-gray-700">2. a,b←Bezout(s*,x)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2. else :</td>

            <td class="px-3 py-2 border-b border-gray-700">3. B←gb</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. S←S∪{x}</td>

            <td class="px-3 py-2 border-b border-gray-700">4. return uk←{a,B}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4. upmsg←x</td>

            <td class="px-3 py-2 border-b border-gray-700">VerMem(A,wx,x):</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5. return At,upmsg</td>

            <td class="px-3 py-2 border-b border-gray-700">1. return 1 if (wx)x=A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Del(At,S,x):</td>

            <td class="px-3 py-2 border-b border-gray-700">VerNonMem(A,ux,x):</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1. if :x∉S: return At</td>

            <td class="px-3 py-2 border-b border-gray-700">1. {a,B}←ux</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2. else :</td>

            <td class="px-3 py-2 border-b border-gray-700">2. return 1 if A^aB^x=g</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  3. S←S\\{x} |   |</p>

    <p class="text-gray-300">|  4. At+1←gΠs∈S s |   |</p>

    <p class="text-gray-300">|  5. upmsg←{x,At,At+1} |   |</p>

    <p class="text-gray-300">|  6. return At+1,upmsg |   |</p>

    <p class="text-gray-300">Theorem 4 (Security accumulator [Lip12]). Assume that the strong RSA assumption (Definition 2) holds in  <span class="math">\\mathbb{G}</span> . Then the accumulator satisfies undeniability (Definition 6) and is therefore secure.</p>

    <p class="text-gray-300">Proof. We construct an  <span class="math">\\mathcal{A}_{RSA}</span>  that given an  <span class="math">\\mathcal{A}_{Acc}</span>  for the accumulator breaks the strong RSA assumption.  <span class="math">\\mathcal{A}_{RSA}</span>  receives a group  <span class="math">\\mathbb{G} \\gets GGen(\\lambda)</span>  and a challenge  <span class="math">g \\stackrel{\\</span>}{\\leftarrow} \\mathbb{G}<span class="math"> . We now run  </span>\\mathcal{A}_{Acc}<span class="math">  on input  </span>\\mathbb{G}<span class="math">  and  </span>A_0 = g<span class="math"> .  </span>\\mathcal{A}_{Acc}<span class="math">  returns a tuple  </span>(A, x, w_x, u_x)<span class="math">  such that  </span>\\mathbf{VerMem}(A, x, w_x) = 1<span class="math">  and  </span>\\mathbf{VerNonMem}(A, x, u_x) = 1<span class="math"> .  </span>\\mathcal{A}_{RSA}<span class="math">  parses  </span>(a, B) = u_x<span class="math">  and computes  </span>B \\cdot (w_x)^a<span class="math">  as the  </span>x<span class="math"> th root of  </span>g<span class="math"> .  </span>x<span class="math">  is an odd prime by definition and  </span>(B \\cdot w_x^a)^x = B^x \\cdot A^b = g$ . This contradicts the strong RSA assumption and thus shows that the accumulator construction satisfies undeniability.</p>

    <p class="text-gray-300">Updating membership witnesses [CL02, LLX07] Updating membership witnesses when an item is added simply consists of adding the item to the witness which itself is an accumulator. The membership witness is an  <span class="math">x</span> th root of the accumulator  <span class="math">A_{t}</span> . After removal of  <span class="math">\\hat{x}</span> ,  <span class="math">A_{t+1}</span>  is an  <span class="math">\\hat{x}</span> th root of  <span class="math">A_{t}</span> . We can use the ShamirTrick to compute an  <span class="math">x \\cdot \\hat{x}</span> th root of  <span class="math">A_{t}</span>  which corresponds to the updated witness. Updating the non-membership witnesses is done by computing the Bezout coefficients between  <span class="math">x</span>  and the newly added/deleted item  <span class="math">\\hat{x}</span>  and then updating non-membership witness such that it represents the Bezout coefficient's between  <span class="math">x</span>  and the product of the accumulated elements. For a complete description and correctness proof see [LLX07].</p>

    <p class="text-gray-300">Aggregating membership witnesses Aggregating membership witnesses for many elements into a single membership witness for the set is straightforward using ShamirTrick. However, verification of this membership witness is linear in the number of group operations. Note that the individual membership witnesses can still be extracted from the aggregated witness as  <span class="math">w_{x} = w_{xy}^{S}</span> . Security, therefore, still</p>

    <p class="text-gray-300">holds for an accumulator construction with aggregated membership witnesses. The succinct proof of exponentiation (NI-PoE) enables us to produce a single membership witness that can be verified in constant time. The verification VerAggMemWit simply checks the proof of exponentiation.</p>

    <p class="text-gray-300">Aggregating existing membership witnesses for elements in several distinct accumulators (that use the same setup parameters) can be done as well. The algorithm MemWitX simply multiplies together the witnesses  <span class="math">w_{x}</span>  for an element  <span class="math">x \\in A_{1}</span>  and  <span class="math">w_{y}</span>  for  <span class="math">y \\in A_{2}</span>  to create an inclusion proof  <span class="math">w_{xy}</span>  for  <span class="math">x</span>  and  <span class="math">y</span> . The verification checks  <span class="math">w_{xy}^{x,y} = A_1^y A_2^x</span> . If  <span class="math">x</span>  and  <span class="math">y</span>  are co-prime then we can directly recover  <span class="math">w_{x}</span>  and  <span class="math">w_{y}</span>  from the proof  <span class="math">w_{xy}</span> . In particular  <span class="math">w_{x} = \\text{ShamirTrick}(A_{1}^{y}, A_{1}, w_{xy}^{y}A_{2}^{-1}, y, x)</span>  and  <span class="math">w_{y} = \\text{ShamirTrick}(A_{2}^{x}, A_{2}, w_{xy}^{x}A_{1}^{-1}, x, y)</span> .</p>

    <p class="text-gray-300">|  AggMemWit(A,wx,wy,x,y):  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2. returnwx·y,NI-PoE(wx·y,x·y,A)</td>

            <td class="px-3 py-2 border-b border-gray-700">1. returnwx·y←wx·wy</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MemWitCreate*(A,{x1,...,xn}):</td>

            <td class="px-3 py-2 border-b border-gray-700">VerMemWitX(A1,A2,wx,y,x,y):</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1. x* = ∏i=1n xi</td>

            <td class="px-3 py-2 border-b border-gray-700">1. if gcd(x,y) ≠ 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2.wx<em>← MemWitCreate(A,x</em>)</td>

            <td class="px-3 py-2 border-b border-gray-700">2. return⊥</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. returnwx<em>,NI-PoE(x,wx</em>,A)</td>

            <td class="px-3 py-2 border-b border-gray-700">3. else</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VerMem*(A,{x1,...,xn},w={wx,π}):</td>

            <td class="px-3 py-2 border-b border-gray-700">4. returnwx·y←A1yA2x</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  1. return NI-PoEverify(∏i=1n xi, w,A,π) |   |</p>

    <p class="text-gray-300">Distributed accumulator updates In the decentralized/distributed setting, the accumulator is managed by a distributed network of participants who only store the accumulator state and a subset of the accumulator elements along with their membership witnesses. These participants broadcast their own updates and listen for updates from other participants, updating their local state and membership witnesses appropriately when needed.</p>

    <p class="text-gray-300">We observe that the basic accumulator functions do not require a trapdoor or knowledge of the entire state, summarized in Figure 2. In particular, deleting an item requires knowledge of the item's current membership witness (the accumulator state after deletion is this witness). Moreover, operations can be performed in batches as follows:</p>

    <p class="text-gray-300">The techniques are summarized as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>BatchAdd An NI-PoE proof can be used to improve the amortized verification efficiency of a batch of updates that add elements  <span class="math">x_{1}, \\ldots, x_{m}</span>  at once and update the accumulator to  <span class="math">A_{t+1} \\gets A_{t}^{x^{<em>}}</span> . A network participant would check that  <span class="math">x^{</em>} = \\prod_{i} x_{i}</span>  and verify the proof rather than compute the  <span class="math">m</span>  exponentiations.</li>

      <li>BatchDel Deleting elements in a batch uses the AggMemWit function to a compute the aggregate membership witness from the individual membership witnesses of each element. This is the new state of the accumulator. A NI-PoE proof improves the verification efficiency of this batch update.</li>

      <li>CreateAllMemWit It is possible for users to update membership and non-membership witnesses [LLX07]. The updates do not require knowledge of the accumulated set  <span class="math">S</span>  but do require that every accumulator update is processed. Since this is cumbersome some users may rely on service providers for maintaining the witness. The service provider may store the entire state or just the users witnesses. Creating all users witnesses naively requires  <span class="math">O(n^{2})</span>  operations. Using the RootFactor algorithm this time can be reduced to  <span class="math">O(n\\log (n))</span>  operations or amortized  <span class="math">O(\\log (n))</span>  operations per witness.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CreateManyNonMemWit Similarly to CreateAllMemWit it is possible to create  <span class="math">m</span>  non-membership witness using  <span class="math">O(\\max(n, m) + m \\log(m))</span>  operations. This stands in contrast to the naive algorithm that would take  <span class="math">O(m \\cdot n)</span>  operations. The algorithm is in Figure 4.2.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Add(At,x):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BatchDel(At,(x1,wx1),..., (xm,wxm)):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1. return Ax</td>

            <td class="px-3 py-2 border-b border-gray-700">1. At+1←wx1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BatchAdd(At,{x1,...,xm}):</td>

            <td class="px-3 py-2 border-b border-gray-700">2. x*←x1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1. x*←Πm1x1</td>

            <td class="px-3 py-2 border-b border-gray-700">3. for i←2,i≤m</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2. At+1←At</td>

            <td class="px-3 py-2 border-b border-gray-700">4. At+1←ShamirTrick(At+1,wx1, x, x)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. return At+1, NI-PoE(x*,At,At+1)</td>

            <td class="px-3 py-2 border-b border-gray-700">5. x<em>←x</em>·x1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DelWMem(At,wx1, x):</td>

            <td class="px-3 py-2 border-b border-gray-700">6. return At+1, NI-PoE(x*,At+1,At)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1. if VerMem(At,wx1, x)=1</td>

            <td class="px-3 py-2 border-b border-gray-700">CreateAllMemWit(S):</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2. returnwx</td>

            <td class="px-3 py-2 border-b border-gray-700">1. return RootFactor(g,S)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 2: Distributed and stateless accumulator functions.</p>

    <p class="text-gray-300">Batching non-membership witnesses A non-membership witness  <span class="math">u_{x}</span>  for  <span class="math">x</span>  in an accumulator with state  <span class="math">A</span>  for a set  <span class="math">S</span>  is  <span class="math">u_{x} = \\{a, g^{b}\\}</span>  such that  <span class="math">as^{<em>} + bx = 1</span>  for  <span class="math">s^{</em>} \\gets \\prod_{s \\in S} s</span> . The verification checks  <span class="math">A^{a}g^{bx} = g</span> . Since  <span class="math">gcd(s^{<em>}, x) = 1</span>  and  <span class="math">gcd(s^{</em>}, y) = 1</span>  if and only if  <span class="math">gcd(s^{<em>}, xy) = 1</span> , to batch non-membership witnesses we could simply construct a non-membership witness for  <span class="math">x \\cdot y</span> . A prover computes  <span class="math">a&#x27;, b&#x27; \\gets \\text{Bezout}(s^{</em>}, xy)</span>  and sets  <span class="math">u_{xy} \\gets a&#x27;, g^{b&#x27;}</span> . This is still secure as a non-membership witness for both  <span class="math">x</span>  and  <span class="math">y</span>  because we can easily extract a non-membership witness for  <span class="math">x</span>  as well as for  <span class="math">y</span>  from the combined witness  <span class="math">(a&#x27;, B&#x27;)</span>  by setting  <span class="math">u_{x} = (a&#x27;, (B&#x27;)^{y})</span>  and  <span class="math">u_{y} = (a&#x27;, (B&#x27;)^{x})</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Unfortunately,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">xy</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  so the size of this batched non-membership witness is linear in the number of elements included in the batch. A natural idea is to set  </span>u_{xy} = (V, B) \\gets (A^{a'}, g^{b'}) \\in \\mathbb{G}^2<span class="math">  instead of  </span>(a', B) \\in \\mathbb{Z} \\times \\mathbb{G}<span class="math">  as the former has constant size. The verification would check that  </span>VB^{xy} = g<span class="math"> . This idea doesn&#x27;t quite work as an adversary can simply set  </span>V = gB^{-xy}<span class="math">  without knowing a discrete logarithm between  </span>A<span class="math">  and  </span>V<span class="math"> . Our solution is to use the NI-PoKE2 protocol to ensure that  </span>V<span class="math">  was created honestly. Intuitively, soundness is achieved because the knowledge extractor for the NI-PoKE2 can extract  </span>a'<span class="math">  such that  </span>(a', B)<span class="math">  is a standard non-membership witness for  </span>xy$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The new membership witness is  <span class="math">V, B, \\pi \\gets \\mathsf{NI - PoKE}(\\mathsf{A},\\mathsf{v};\\mathsf{b})</span> . The size of this witness is independent of the size of the statement. We can further improve the verification by adding a proof of exponentiation that the verification equation holds:  <span class="math">\\mathsf{NI - PoE}(x \\cdot y, B, g \\cdot V^{-1})</span> . Lastly, recall from Section 3 that the two independent</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 3: Algorithm for creating multiple non membership witnesses</p>

    <p class="text-gray-300">NI-PoKE2 and NI-PoE proofs can be aggregated into a single group element.</p>

    <p class="text-gray-300">We present the non-membership protocol bellow as NonMemWitCreate<em>. The verification algorithm VerNonMem</em> simply verifies the NI-PoKE2 and NI-PoE.</p>

    <p class="text-gray-300">NonMemWitCreate\\<em>(A, s</em>, x<em>): // A = g</em>, s* = Πs∈S s, x = Πxi, xi ∈ Primes(λ)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">a,b\\gets \\mathbf{Bezout}(s^{<em>},x^{</em>})</span></li>

      <li><span class="math">V\\gets A^a,B\\gets g^b</span></li>

      <li><span class="math">\\pi_V\\gets \\mathsf{NI - PoKE2}(A,V;a)</span>  //  <span class="math">V = A^{a}</span></li>

      <li><span class="math">\\pi_g\\gets \\mathsf{NI - PoE}(x^*,B,g\\cdot V^{-1})</span>  //  <span class="math">B^{x} = g\\cdot V^{-1}</span></li>

      <li>return  <span class="math">\\{V,B,\\pi_V,\\pi_g\\}</span></li>

    </ol>

    <p class="text-gray-300">VerNonMem\\*(A, u = {V, B, πV, πg}, {x1, ..., xu}):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>return NI-PoKE2. verify(A, V, πV) ∧ NI-PoE. verify(Πi=1n xi, B, g · V-1, πg)</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness of batch non-membership witnesses Using the knowledge extractor for NI-PoKE2 and relying on the soundness of NI-PoE, and given an adversary who outputs a valid batch non-membership witness  <span class="math">(V,B,\\pi_V,\\pi_g)</span>  for a set of odd prime elements  <span class="math">x_{1},\\ldots ,x_{k}</span>  with respect to an accumulator state  <span class="math">A</span>  we can extract individual non-membership witnesses for each  <span class="math">x_{i}</span> . The knowledge extractor for NI-PoKE2 (Theorem 3) obtains  <span class="math">a</span>  such that  <span class="math">V = A^{a}</span>  and the soundness of NI-PoE (Theorem 1) guarantees that  <span class="math">B^{x^{<em>}}\\cdot V = g</span>  where  <span class="math">x^{</em>} = \\prod_{i}x_{i}</span> . Given  <span class="math">a</span>  and  <span class="math">B</span>  we can compute a non-membership witness for  $x_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{<em>}<span class="math">  as  </span>B^{\\frac{x^{</em>}}{x_{i}}},a<span class="math">  because  </span>(B^{\\frac{x^{<em>}}{x_{i}}})^{x_{i}}A^{a} = B^{x^{</em>}}V = g$  Recall that we proved the existence of a knowledge extractor only for the interactive form of PoKE2 and soundness for the interactive form of PoE, relying on the generic group model. The existence of a knowledge extractor for NI-PoKE2 and soundness of NI-PoE are derived from the Fiat-Shamir heuristic.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Batch accumulator security We now formally define security for an accumulator with batch membership and non-membership witnesses. The definition naturally generalizes Definition 6. We omit a correctness definition as it follows directly from the definition of the batch witnesses. We assume that correctness holds perfectly.</p>

    <p class="text-gray-300">Definition 7 (Batch Accumulator Security (Undeniability)).</p>

    <p class="text-gray-300"><span class="math">\\operatorname<em>{Pr}\\left[\\begin{array}{l}\\mathsf{pp},A_0\\in \\mathbb{G}\\stackrel {\\S}{\\leftarrow}\\mathbf{Setup}(\\lambda)\\\\ (A,I,E,w_I,u_E)\\stackrel {\\S}{\\leftarrow}\\mathcal{A}(\\mathsf{pp},A_0):\\\\ \\mathbf{VerMem}^</em> (A,I,w_I)\\wedge \\mathbf{VerNonMem}^* (A,S,u_S)\\wedge I\\cap S\\neq \\emptyset\\end{array}\\right] = \\mathsf{negl}(\\lambda)</span></p>

    <p class="text-gray-300">From the batch witnesses  <span class="math">w_{I}</span>  and  <span class="math">u_{S}</span>  we can extract individual accumulator witnesses for each element in  <span class="math">I</span>  and  <span class="math">S</span> . Since the intersection of the two sets is not empty we have an element  <span class="math">x</span>  and extracted witnesses  <span class="math">w_{x}</span>  and  <span class="math">u_{x}</span>  for that element. As in the proof of Theorem 4 this lets us compute and  <span class="math">x</span> th root of  <span class="math">g</span>  which directly contradicts the strong RSA assumption. Our security proof will be in the generic group model as it implies the strong RSA assumption, the adaptive root assumption and can be used to formulate extraction for the PoKE2 protocol. Our security proof uses the interactive versions of PoKE2 and PoE protocols but extraction/soundness holds for their non-interactive variants as well.</p>

    <p class="text-gray-300">Theorem 5. The batch accumulator construction presented in Section 4.2 is secure (Definition 7) in the generic group model.</p>

    <p class="text-gray-300">Proof. We will prove security by showing that given an adversary that can break the accumulator security we can construct an efficient extractor that will break the strong RSA assumption (Definition 2). This, however, contradicts the generic group model in which strong RSA holds [DK02]. Given a strong RSA challenge  <span class="math">g \\in \\mathbb{G}</span>  we set  <span class="math">A_0</span>  the accumulator base value to  <span class="math">g</span> . Now assume there exists such an adversary  <span class="math">\\mathcal{A}</span>  that on input  <span class="math">(\\mathbb{G}, g)</span>  with non-negligible probability outputs  <span class="math">(A, I, E, w_I, u_E)</span>  such that  <span class="math">w_I</span>  and  <span class="math">u_E</span>  are valid witnesses for the accumulator  <span class="math">A</span>  and the inclusion proof elements  <span class="math">I</span>  intersect with the exclusion proof elements  <span class="math">E</span> . Let  <span class="math">x \\in I \\cap S</span>  be in the intersection. The batch membership witness  <span class="math">w_I</span>  is such that  <span class="math">w_I^{\\prod_{x_i \\in I} x_i} = A</span></p>

    <p class="text-gray-300">with overwhelming probability. This follows directly from the soundness of the accompanying PoE proof (Theorem 1). We can directly compute  <span class="math">w_{x} = w_{I}^{\\prod x_{i}\\in I,x_{i}\\neq x}</span> , i.e. a membership witness for  <span class="math">x</span> .</p>

    <p class="text-gray-300">The batch non-membership witness  <span class="math">u_{E}</span>  consists of  <span class="math">B, V \\in G</span>  as well as a PoKE2 and a PoE. We now use the PoKE2 extractor to compute  <span class="math">a \\in \\mathbb{Z}, B \\in \\mathbb{G}</span> . Given that the extractor succeeds with overwhelming probability (Theorem 3) and the overwhelming soundness of PoE (Theorem 1),  <span class="math">a, B</span>  satisfy  <span class="math">A^{a}B^{\\prod_{x_{i} \\in E} x_{i}} = g</span> . From this we can compute  <span class="math">B&#x27; = B^{\\prod_{x_{i} \\in E, x_{i} \\neq x} x_{i}}</span>  such that  <span class="math">A^{a}B&#x27;^{x} = g</span> . As in the proof of Theorem 4 we can now compute  <span class="math">B&#x27;w_{x}^{a}</span>  as an  <span class="math">x</span> th root of  <span class="math">g</span> . This is because  <span class="math">B&#x27;^{x}(w_{x}^{a})^{x} = B&#x27;^{x}A^{a} = g</span> . This, however, contradicts the strong RSA assumption.</p>

    <p class="text-gray-300">Aggregating non-membership witnesses We have shown how to create a constant sized batch non-membership witness for arbitrary many witnesses. However this process required knowledge of the accumulated set  <span class="math">S</span> . Is it possible to aggregate multiple independent non-membership witnesses into a single constant size witness? We show that we can aggregate unbatched witnesses and the apply the same batching technique to the aggregated witness. This is useful in the stateless blockchain setting where a node may want to aggregate non-membership witnesses created by independent actors. Additionally it will allow us to aggregate vector commitment openings for our novel construction presented in Section 5.</p>

    <p class="text-gray-300">Given two non-membership witness  <span class="math">u_{x} = \\{a_{x}, B_{x}\\}</span>  and  <span class="math">u_{y} = \\{a_{y}, B_{y}\\}</span>  for two distinct elements  <span class="math">x</span>  and  <span class="math">y</span>  and accumulator  <span class="math">A</span>  we want to create a witness for  <span class="math">x \\cdot y</span> . As shown for batch non-membership witnesses a non-membership witness for  <span class="math">x \\cdot y</span>  is equivalent to a witness for  <span class="math">x</span>  and  <span class="math">y</span>  if  <span class="math">x</span>  and  <span class="math">y</span>  are co-prime.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Concretely we will compute  <span class="math">a_{xy} \\in \\mathbb{Z}</span>  and  <span class="math">B_{xy} \\in \\mathbb{G}</span>  such that  <span class="math">A^{a_{xy}}B_{xy}^{xy} = g</span> . First we compute  <span class="math">\\alpha, \\beta \\gets \\mathbf{Bezout}(x,y)</span> . Then we set  <span class="math">B&#x27; \\gets B_x^\\beta B_y^\\alpha</span>  and set  <span class="math">a&#x27; \\gets \\beta a_x y + \\alpha a_y x</span> . Note that  <span class="math">B&#x27; \\in \\mathbb{G}</span> ,  <span class="math">a&#x27; \\in \\mathbb{Z}</span>  already satisfy  <span class="math">A^{a&#x27;}B^{txy} = (A^{a_x}B_x^x)^{\\beta y}(A^{a_y}B_y^y)^{\\alpha x} = g^{\\beta y + \\alpha x} = g</span>  but that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is not necessarily less than  </span>xy<span class="math"> . To enforce this we simply reduce  </span>a' \\mod xy<span class="math"> , setting  </span>a_{xy} \\gets a' \\mod xy<span class="math">  and  </span>B_{xy} \\gets B'A^{\\lfloor \\frac{a'}{xy} \\rfloor}<span class="math"> . The verification equation  </span>A^{a_{xy}}B_{xy}^{xy} = A^{a'}B^{txy} = g$  is still satisfied.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The full protocol is presented below:</p>

    <p class="text-gray-300">|  AggNonMemWit(A, x, y, ux = (ax ∈ [x], Bx ∈ G), uy = (ay, By)):  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  1. α, β ← Bezout(x, y)  |</p>

    <p class="text-gray-300">|  2. B' ← BxβByy  |</p>

    <p class="text-gray-300">|  3. a' ← βaxy + αayx  |</p>

    <p class="text-gray-300">|  4. axy ← a' mod xy  |</p>

    <p class="text-gray-300">|  5. Bxy ← B'A[ x/y]  |</p>

    <p class="text-gray-300">|  6. return {axy, Bxy}  |</p>

    <p class="text-gray-300">As in Theorem 5, non-membership witnesses for  <span class="math">x</span>  and  <span class="math">y</span>  individually can be computed from an aggregated non-membership witness for  <span class="math">x</span>  and  <span class="math">y</span> . Note that we can also use a PoKE proof and apply the non-membership batching technique presented above to make the proof constant size. The final witness can be verified using the VerNonMem* algorithm.</p>

    <p class="text-gray-300">Unions and Multiset accumulators Our succinct proofs can be used to prove that an accumulator is the union of two other accumulators. This uses a succinct proof of a DDH tuple, another special case of a homomorphism preimage. Further details are given in Appendix B.1. In the distributed accumulator setting, it is necessary to assume that no item is added twice to the accumulator. Otherwise, the distributed delete operation will fail. Alternatively, the construction can be viewed as a multi-set accumulator, where every element has a counter. Generating a valid membership witness for an element requires knowing the count of that element in the accumulator multi-set. Further details on this construction are given in Appendix B.2.</p>

    <p class="text-gray-300">19</p>

    <h2 id="sec-33" class="text-2xl font-bold">5.1 VC Definitions</h2>

    <p class="text-gray-300">We review briefly the formal definition of a vector commitment. We only consider static commitments that do not allow updates, but our scheme can naturally be modified to be dynamic.</p>

    <p class="text-gray-300"><strong>Vector commitment syntax</strong> A VC is a tuple of four algorithms: VC.Setup, VC.Com, VC.Open, VC.Verify.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{VC.Setup}(\\lambda ,n,\\mathcal{M})\\to \\mathsf{pp}</span>  Given security parameter  <span class="math">\\lambda</span>  , length  <span class="math">n</span>  of the vector, and message space of vector components  <span class="math">\\mathcal{M}</span>  , output public parameters  <span class="math">\\mathsf{pp}</span>  which are implicit inputs to all the following algorithms.</li>

      <li><span class="math">\\mathsf{VC.Com}(\\pmb {m})\\to \\tau ,com</span>  Given an input  <span class="math">\\pmb {m} = (m_{1},\\dots,m_{n})</span>  output a commitment com and advice  <span class="math">\\tau</span></li>

      <li><span class="math">\\mathsf{VC.Update}(com, m, i, \\tau) \\to \\tau, com</span>  Given an input message  <span class="math">m</span>  and position  <span class="math">i</span>  output a commitment  <span class="math">com</span>  and advice  <span class="math">\\tau</span> .</li>

      <li><span class="math">\\mathsf{VC.Open}(com, m, i, \\tau) \\to \\pi</span>  On input  <span class="math">m \\in \\mathcal{M}</span>  and  <span class="math">i \\in [1, n]</span> , the commitment com, and advice  <span class="math">\\tau</span>  output an opening  <span class="math">\\pi</span>  that proves  <span class="math">m</span>  is the  <span class="math">i</span> th committed element of com.</li>

      <li><span class="math">\\mathsf{VC.Verify}(com, m, i, \\pi) \\to 0/1</span>  On input commitment com, an index  <span class="math">i \\in [n]</span> , and an opening proof  <span class="math">\\pi</span>  output 1 (accept) or 0 (reject).</li>

    </ol>

    <p class="text-gray-300">If the vector commitment does not have an VC.Update functionality we call it a static vector commitment.</p>

    <p class="text-gray-300"><strong>Definition 8 (Static Correctness).</strong> A static vector commitment scheme VC is correct if for all  <span class="math">\\mathbf{m} \\in \\mathcal{M}^n</span>  and  <span class="math">i \\in [1, n]</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {V C . S e t u p} (\\lambda , n, \\mathcal {M}) \\\\ \\mathsf {V C . V e r i f y} (c o m, m _ {i}, i, \\pi) = 1: &amp;amp; \\tau , c o m \\leftarrow \\mathsf {V C . C o m} (\\boldsymbol {m}) \\\\ &amp;amp; \\pi \\leftarrow V C. O p e n (c o m, m _ {i}, i, \\tau) \\end{array} \\right] = 1</span></div>

    <p class="text-gray-300">The correctness definition for dynamic vector commitments also incorporates updates. Concretely whenever VC.Update is invoked the underlying committed vector  <span class="math">\\pmb{m}</span>  is updated correctly.</p>

    <p class="text-gray-300"><strong>Binding commitments</strong> The main security property of vector commitments (of interest in the present work) is position binding. The security game augments the standard binding commitment game</p>

    <p class="text-gray-300"><strong>Definition 9 (Binding).</strong> A vector commitment scheme VC is position binding if for all  <span class="math">O(\\mathsf{poly}(\\lambda))</span> -time adversaries  <span class="math">\\mathcal{A}</span>  the probability over  <span class="math">\\mathsf{pp} \\gets \\mathsf{VC.Setup}(\\lambda, n, \\mathcal{M})</span>  and  <span class="math">(com, i, m, m&#x27;, \\pi, \\pi&#x27;) \\gets \\mathcal{A}(\\mathsf{pp})</span>  the probability that VC.Verify  <span class="math">(com, m, i, \\pi) = \\mathsf{VC.Verify}(com, m&#x27;, i, \\pi&#x27;) = 1</span>  and  <span class="math">m \\neq m&#x27;</span>  is negligible in  <span class="math">\\lambda</span> .</p>

    <h2 id="sec-34" class="text-2xl font-bold">5.2 VC construction</h2>

    <p class="text-gray-300">We first present a VC construction for bit vectors, i.e. using the message space  <span class="math">\\mathcal{M} = \\{0,1\\}</span> . We then explain how this can be easily adapted for a message space of arbitrary bit length.</p>

    <p class="text-gray-300">Our VC construction associates a unique prime² integer  <span class="math">p_i</span>  with each  <span class="math">i</span> th index of the bitvector  <span class="math">\\mathbf{m}</span>  and uses an accumulator to commit to the set of all primes</p>

    <p class="text-gray-300">²Examples include  <span class="math">\\mathsf{H}_{\\mathsf{prime}}</span>  (described earlier), or alternatively the function that maps  <span class="math">i</span>  to the next prime after  <span class="math">f(i) = 2(i + 2)\\cdot \\log_2(i + 2)^2</span> , which maps the integers  <span class="math">[0,N)</span>  to smaller primes than  <span class="math">\\mathsf{H}_{\\mathsf{prime}}</span>  (in expectation).</p>

    <p class="text-gray-300">corresponding to indices where  <span class="math">m_i = 1</span> . The opening of the  <span class="math">i</span> th index to  <span class="math">m_i = 1</span>  is an inclusion proof of  <span class="math">p_i</span>  and the opening to  <span class="math">m_i = 0</span>  is an exclusion proof of  <span class="math">p_i</span> . By using our accumulator from Section 4, the opening of each index is constant-size. Moreover, the opening of several indices can be batched into a constant-size proof by aggregating all the membership witnesses for primes on the indices opened to 1 and batching all the non-membership witnesses for primes on the indices opened to 0.</p>

    <p class="text-gray-300">The VC for vectors on a message space of arbitrary bit length is exactly the same, interpreting the input vector as a bit vector. Opening a  <span class="math">\\lambda</span> -bit component is then just a special case of batch opening several indices of a VC to a bit vector. The full details are in Figure 4.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VC.Setup(λ): • A ← Accumulator.Setup(λ) • return pp ← (A, n)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VC.BatchOpen(b ∈ {0,1}m, i ∈ [1,n]m): • Ones ← {j ∈ [1,m]: bj = 1} • Zeros ← {j ∈ [1,m]: bj = 0} • p+ ← ∏j∈Ones pi[j]: p- ← ∏j∈Zeros pi[j]</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VC.Com(m, pp): • P ← {pi</td>

            <td class="px-3 py-2 border-b border-gray-700">i ∈ [1,n] ∧ mi = 1} • A.BatchAdd(P) • return A</td>

            <td class="px-3 py-2 border-b border-gray-700">• πI ← A.MemWitCreate*(p-) • return {πI, πE} VC.BatchVerify(A, b, i, πI, πE): • Ones ← {j ∈ [1,m]: bj = 1} • Zeros ← {j ∈ [1,m]: bj = 0} • p+ ← ∏j∈Ones pi[j]: p- ← ∏j∈Zeros pi[j]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VC.Update(b, b' ∈ {0,1}, i ∈ [1,n]): • if b = b' return A • elseif b = 1 • return A.Add(pi) • else • return A.Del(pi)</td>

            <td class="px-3 py-2 border-b border-gray-700">• return A.VerMem(p+, πI) ∧ A.VerNonMem*(p-, πE) VC.BatchOpen'(b ∈ {0,1}m, i ∈ [1,n]m): • Ones ← {j ∈ [1,m]: bj = 1} • Zeros ← {j ∈ [1,m]: bj = 0} • p+ ← ∏j∈Ones pi[j]: p- ← ∏j∈Zeros pi[j]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VC.Open(b ∈ {0,1}, i ∈ [1,n]): • if b = 1 • return A.MemWitCreate(pi) • else • return A.NonMemWitCreate(pi)</td>

            <td class="px-3 py-2 border-b border-gray-700">• πI ← A.MemWitCreate<em>(p-) • return {πI, πE} VC.BatchVerify</em>(A, b, i, πI, πE): • Ones ← {j ∈ [1,m]: bj = 1} • Zeros ← {j ∈ [1,m]: bj = 0} • p+ ← ∏j∈Ones pi[j]: p- ← ∏j∈Zeros pi[j]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VC.Verify(A, b ∈ {0,1}, i, π): • if b = 1: • return A.VerMem(π, pi) • else: • return A.VerNonMem(π, pi)</td>

            <td class="px-3 py-2 border-b border-gray-700">• return A.VerMem(p+, πI) ∧ A.VerNonMem(p-, πE)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 4: Vector commitment scheme from accumulator with batchable membership and non-membership witnesses.</p>

    <p class="text-gray-300">Both the accumulator's CRS as well as PrimeGen can be represented in constant space independent of  <span class="math">n</span> . This means that the public parameters for the vector commitment are also constant-size and independent of  <span class="math">n</span> , unlike all previous vector commitments with  <span class="math">O(1)</span>  size openings [CF13, LRY16, LM18]. The batch opening of several (mixed value) indices consists of 2 elements in  <span class="math">\\mathbb{G}</span>  for the aggregate membership-witness and an additional 5 elements in  <span class="math">\\mathbb{G}</span>  for the batch non-membership witness, plus one  <span class="math">\\lambda</span> -bit integer.</p>

    <p class="text-gray-300">Aggregating Openings Just as for our accumulator construction we can aggregate vector commitment openings. The aggregation does not require knowledge of the vector contents and the running time of the aggregation is independent of the length of the vector. The opening of a bit in the vector commitment consists of an accumulator inclusion proof and an exclusion proof, both of which we can aggregate as shown in Section 4.2.</p>

    <p class="text-gray-300">This aggregation protocol works for outputs of VC.Open, but unfortunately it does not extend to outputs of VC.BatchOpen. The latter contain PoKE proofs created by VerNonMem*, which would somehow need to be aggregated as well along with their inputs. When opening only a small number of bit indices, say in a 256-</p>

    <p class="text-gray-300">bit component of the vector, VC.BatchOpen<em> could be used instead so that these openings can be later aggregated. While the output size of VC.BatchOpen</em> grows linearly in  <span class="math">m</span> , the number of batched indices, it still contains only three group elements and an integer whose size is proportional to the product of at most  <span class="math">m</span> <span class="math">\\lambda</span> -bit primes. These are the unique primes associated with indices of the vector and heuristically can be chosen to be much smaller than  <span class="math">\\lambda</span>  bits, i.e. closer to  <span class="math">\\log n</span>  bits. After the aggregation step is completed, the aggregate non-membership witness can be further compressed with a PoKE proof.</p>

    <p class="text-gray-300">This aggregation protocol is important for the account-based stateless blockchain application, described in more detail in Section 6. In this application, there is a distributed network of participants who who each hold openings for only a partial number of the vector components (e.g. every user knows the value corresponding to their own account data). A batch of transactions will typically contain many openings (of small values) produced by many different participants in the network. In this case, it makes sense for the participants to each produce an opening of the form VC.BatchOpen* so that after the individual participants post all the openings they can be aggregated into a single constant size value that is persisted in the transaction log.</p>

    <p class="text-gray-300">Optimization The number of group elements can be reduced by utilizing a PoKCR for all of the PoE and PoKE roots involved in the membership/non-membership witness generation. It is important that all PoE and PoKE protocols use different challenges. These challenges are then guaranteed to be co-prime. This reduces the number of opening proof elements to  <span class="math">4 \\in \\mathbb{G}</span>  and  <span class="math">1 \\lambda</span> -bit integer.</p>

    <p class="text-gray-300">Table 5.3 compares the performance of our new VC scheme, the Catalano-Fiore (CF)[CF13] RSA-based VC scheme, and Merkle trees. The table assumes the VC input is a length  <span class="math">n</span>  vector of  <span class="math">k</span>  bit elements with security parameter  <span class="math">\\lambda</span> . The performance for the CF scheme includes batch openings which were introduced by Lai and Malatova[LM18]. We note that the MultiExp algorithm from Section 3.3 also applies to the CF scheme. In particular it can improve the Setup and Open time. The comparison reflects these improvements.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Metric</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This Work</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Catalano-Fiore [CF13, LM18]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Merkle Tree</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Setup  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(n·log(n)·λ) G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(1)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Com(m) → c</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n·log(n)·k) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n·k) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) H</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">c</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Proofs  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Open(mi,i) → π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(k·n log n) G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(n·(k+λ)) G.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(log n) H</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Open(m,i) → πi</td>

            <td class="px-3 py-2 border-b border-gray-700">O(k·n log n) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n log n·(k+λ)) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n log n) H</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify(m,i,πi)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ) G + O(k·n log n) F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(nk) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n log n) H</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">πi</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">+ λ</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(n log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Aggregatable</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 1: Comparison between Merkle trees, Catalano-Fiore RSA VCs and the new VCs presented in this work. The input  <span class="math">\\pmb{m}</span>  is a vector of  <span class="math">n</span> .  <span class="math">\\mathbb{G}</span>  refers to a group operation in  <span class="math">\\mathbb{G}</span> ,  <span class="math">\\mathbb{F}</span>  to a multiplication in a field of size roughly  <span class="math">2^{\\lambda}</span> , and  <span class="math">\\mathsf{H}</span>  to a hash operation. Group operations are generally far more expensive than hashes which are more expensive than multiplication in  <span class="math">\\mathbb{F}</span> .  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the size of a hidden order group element and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  is the size of a hash output.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">5.4 Key-Value Map Commitment</p>

    <p class="text-gray-300">Our vector-commitment can be used to build a commitment to a key-value map. A key-value map can be built from a sparse vector. The key-space is represented by positions in the vector and the associated value is the data at the keys position. The vector length is exponential in the key length and most positions are zero (null). Our VC commitment naturally supports sparse vectors because the complexity of the commitment is proportional to the number of bit indices that are set to 1, and otherwise independent of the vector length.</p>

    <h5 id="sec-36" class="text-base font-semibold mt-4">Optimization with honest updates</h5>

    <p class="text-gray-300">In order to commit to arbitrary length values we can hash the value and then commit to the resulting hash. Unfortunately this still requires setting <span class="math">\\lambda</span> bits in the vector commitment which corresponds to adding <span class="math">\\lambda</span>, <span class="math">\\lambda</span>-bit primes to the underlying accumulator. This can make updating the commitment computationally quite expensive. In some settings we can do better than this. Note that the VC and the accumulator definitions (Definition 6) assume that the adversary outputs the commitment. This requirement is too strong for settings where every update follows the rules of the system, i.e. is performed by the challenger. In this case we can implement a key-value map commitment by storing in the VC which keys exist and storing in the accumulator a key, value tuple. If the key already exists then an update will update the entry in the accumulator. Otherwise it will add an entry to the accumulator and set the corresponding VC bit to 1. The construction requires only 1 bit to be stored per key in the VC and 1 entry in the accumulator. The construction also is not secure if the adversary can output an accumulator value as it could contain multiple entries for the same key. We omit a formal security definition and proof but note that security follows directly from the binding guarantees of the underlying accumulator and vector commitment constructions. The VC ensures that each key appears at most ones in the accumulator and the accumulator ensures the integrity of the committed data.</p>

    <h2 id="sec-37" class="text-2xl font-bold">6 Applications</h2>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">6.1 Stateless Blockchains</h3>

    <h5 id="sec-39" class="text-base font-semibold mt-4">UTXO commitment</h5>

    <p class="text-gray-300">We first consider a simplified blockchain design which closely corresponds to Bitcoin’s UTXO design where users own coins and issue transaction by spending old coins and creating new coins. We call the set of unspent coins the UTXO set. Updates to the blockchain can be viewed as asynchronous updates to the UTXO set. In most current blockchain designs (with some exceptions<em>[x13, BCG^{+}14]</em>) nodes participating in transaction validation store the whole UTXO set and use it to verify whether a coin was unspent. Instead, we consider a blockchain design where the network maintains the UTXO set in a dynamic accumulator <em>[x27, x28, x29, x10]</em>. We instantiate this accumulator with our new construction from Section 4.1, taking advantage of our distributed batch updates and aggregate membership proofs.</p>

    <p class="text-gray-300">Each transaction block will contain an accumulator state, which is a commitment to the current UTXO set. To spend a coin, a user provides a membership witness for the coin (UTXO) that is being spent inside a transaction. Any validator (aka miner) may verify the transactions against the latest accumulator state and also uses BatchDel to delete all spent coins from the accumulator, derive its new state, and output a proof of correctness for the deletions. The proof is propagated to other validators in the network. For the newly minted coins, the validator uses BatchAdd to add them to the accumulator and produce a second proof of correctness to propagate. Other validators are able to verify that the accumulator was updated correctly using only a constant number of group operations and highly efficient arithmetic over <span class="math">\\lambda</span>-bit integers.</p>

    <p class="text-gray-300">In this design, users store the membership witnesses for their own coins and are required to update their witnesses with every block of transactions. It is plausible that users use third-party services to help with this maintenance. These services</p>

    <p class="text-gray-300">are not trusted for integrity, but only for availability. Note that a may produce many (e.g. <span class="math">n</span>) membership witnesses at once in <span class="math">O(n\\log(n))</span> time using the CreateAllMemWit algorithm</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">Accounts commitment</h4>

    <p class="text-gray-300">Some currencies such as Ethereum <em>[x20]</em> or Stellar <em>[x18]</em> use an account-based system where the state is a key-value map. A transaction updates the balances of the sending and the receiving accounts. To enable stateless validation in this setting, a user can provide proofs of the balances of the sending and receiving accounts in the current ledger state. Instead of using an accumulator to commit to this state, we use the new key-value map commitment from Section 5.4. This commitment supports batch distributed updates, similar to our new accumulator. Using the aggregation of vector commitment openings a miner or validator can perform the aggregation and batching operations without storing the state providing efficient proofs that the openings are correct. Other nodes can verify these opening proofs efficiently requiring only a constant number of group operations.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">6.2 Short IOPs</h3>

    <p class="text-gray-300">Merkle tree paths contribute significant overhead to both the proof size of a compiled IOP proof and its verification time. Vector commitments with smaller openings than Merkle trees, or batchable openings (i.e. subvector commitments), can help reduce this overhead <em>[x13]</em>. Using our new VCs, the opening proof for each round of the compiled IOP is just 4 group elements in <span class="math">\\mathbb{G}</span> and a <span class="math">\\lambda</span>-bit integer (plus one additional element for the VC commitment itself). Instantiating <span class="math">\\mathbb{G}</span> with a class group of quadratic imaginary order and tuning security to 128-bits requires elements of size approximately 2048-bits <em>[x10]</em>. Thus, the VC openings contribute 8320 bits to the proof size per IOP round. When applied to the “CS-proof” SNARK considered by Lai and Malavolta, which is based on a theoretical PCP that checks 3 bits per query and has 80 queries, the proof size is <span class="math">5\\cdot 2048+128+3\\cdot 80=10608</span> bits, or 1.3 KB. This is the shortest (theoretical) setup-free SNARK with sublinear public parameters to date.</p>

    <p class="text-gray-300">Our VCs also achieve concrete improvements to practical IOPs. Targeting 100-bit security in the VC component and otherwise apples-to-apples comparisons with benchmarks for Aurora <em>[BSCR^{+}18]</em> and STARKS <em>[x2]</em>, we can conservatively use 2048-bit class group elements. With these parameters, our VCs reduce the size of the Aurora proofs on a <span class="math">2^{20}</span> size circuit from 222 KB to less than 100 KB, a 54% reduction, and the size of STARK proofs for a circuit of <span class="math">2^{52}</span> gates from 600 KB to approximately 222 KB, a 63% reduction. This rough estimate is based on the Merkle path length 42 and round number 21 extrapolated from the most recent STARK benchmarks for this size circuit <em>[x2]</em>.</p>

    <p class="text-gray-300">Replacing Merkle trees with our VCs does not significantly impact the verification cost, and in some cases it may even improve verification time. Recall that verifying a batch VC proof costs approximately one <span class="math">landba</span>-bit integer multiplication and a primality check per bit. Furthermore, using the optimization described in Section 7 eliminates the primality checks for the verifier (at a slight cost to the prover). Computing a SHA256 hash function (whether SHA256 or AES with Davies-Meyer) is comparable to the cost of a <span class="math">\\lambda</span>-bit integer multiplication. Thus, as a loose estimate, replacing each Merkle path per query with a single <span class="math">\\lambda</span>-bit multiplication would achieve a factor <span class="math">\\log n=36</span> reduction. In STARKS, Merkle paths are constructed over 256-bit blocks of the proof rather than bits, thus the comparison is 36 hashes vs 256 modular multiplications. The Merkle path validation accounts for 80% of the verification time.</p>

    <p class="text-gray-300">While using our vector commitment has many benefits for IOPs, there are several sever downsides. Our vector commitment is not quantum secure as a quantum computer can find the order of the group and break the Strong-RSA assumption. Merkle trees are more plausibly quantum secure. Additionally, the prover for an IOP instantiated with our vector commitment would be significantly slower than</p>

    <p class="text-gray-300">one with a Merkle tree.</p>

    <h2 id="sec-42" class="text-2xl font-bold">7 Hashing To Primes</h2>

    <p class="text-gray-300">Our constructions use a hash-function with prime domains in several places: Elements in the accumulator are mapped to primes, using a collision resistant hash function with prime domain. The vector commitment associates a unique prime with each index. All of the proofs presented in Section 3 use a random prime as a challenge. When the proofs are made non-interactive, using the Fiat-Shamir heuristic the challenge is generated by hashing the previous transcript.</p>

    <p class="text-gray-300">In Section 4.1 we present a simple algorithm for a collision-resistant hash function <span class="math">\\mathsf{H_{prime}}</span> with prime-domain built from a collision resistant hash function <span class="math">\\mathsf{H}</span> with domain <span class="math">\\mathbb{Z}_{2^{3}}</span>. The hash function iteratively hashes a message and a counter, increasing the counter until the output is prime. If we model <span class="math">\\mathsf{H}</span> as a random function with then the expected running time of <span class="math">\\mathsf{H_{prime}}</span> is <span class="math">O(\\lambda)</span>. This is because there are <span class="math">O(\\frac{n}{\\log(n)})</span> primes below <span class="math">n</span>.</p>

    <p class="text-gray-300">The problem of hashing to primes has been studied in several contexts: Cramer and Shoup <em>[x10]</em> provide a way to generate primes with efficiently checkable certificates. Fouque and Tibouchi<em>[x16]</em> showed how to quickly generate random primes. Seeding the random generation with a collision resistant hash function can be used to generate an efficient hash function with prime domain. Despite these improvements, the hash function actually introduces a significant overhead for verification and in this section we present several techniques how the hashing can be further sped up.</p>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">PoE,PoKE proofs</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We first investigate the PoE,PoKE family of protocols. In the non-interactive variant the challenge <span class="math">\\ell</span> is generated by hashing the previous transcript to a prime. The protocol can be modified by having the prover provide a short nonce such that $\\ell\\leftarrow H(transcript</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">nonce)<span class="math"> with </span>\\ell\\in\\mathsf{Primes}(\\lambda)<span class="math">. In expectation the nonce is just </span>\\log(\\lambda)<span class="math"> bits and with overwhelming probability it is less than </span>2\\log(\\lambda)<span class="math"> bits. This modification allows the adversary to produce different challenges for the same transcript. However it does not increase an adversary’s advantage. The prover can always alter the input to generate new challenges. By changing the nonce the prover can grind a polynomial number of challenges but the soundness error in all of our protocols is negligible. The change improves the verification as the verifier only needs to do a single primality check instead of </span>\\lambda$. The change is particularly interesting if proof verification is done in a circuit model of computation, where variable time operations are difficult and costly to handle. Circuit computations have become increasingly popular for general purpose zero-knowledge proofs<em>[x12, BBB^{+}18, BSCR^{+}18]</em>. Using the adapted protocol verification becomes a constant time operation which uses only a single primality check.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">Accumulator</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A similar improvement can be applied to accumulators. The users can provide a nonce such that $element</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">nonce<span class="math"> is accumulated instead of just the element. This of course allows an adversary to accumulate the same element twice. In some applications this is acceptable. In other applications such as stateless blockchains it is guaranteed that no element is accumulated twice(see Section 6). One way to guarantee uniqueness is to commit to the current state of the accumulator for every added element. In an inclusion proof, the prover would provide the nonce as part of the proof. The verifier now only does a single primality check to ensure that </span>\\mathsf{H}(element</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">nonce)<span class="math"> is indeed prime. This stands in contrast to </span>O(\\lambda)<span class="math"> primality checks if </span>\\mathsf{H_{prime}}$ is used. The nonce construction prohibits efficient exclusion proofs but these are not required in some applications, such as the blockchain application.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-45" class="text-lg font-semibold mt-6">Vector Commitments</h4>

    <p class="text-gray-300">The vector commitment construction uses one prime per index to indicate whether the vector is <span class="math">1</span> at that index or <span class="math">0</span>. The security definition for a vector commitment states that a secure vector commitment cannot be opened</p>

    <p class="text-gray-300">to two different openings at the same index. In our construction this would involve giving both an inclusion as well as an exclusion proof for a prime in an accumulator, which is impossible if the accumulator itself is secure. Using a prime for each index again requires using a collision resistant hash function with prime domain which uses <span class="math">O(\\lambda)</span> primality checks or an injective function which runs in time <span class="math">O(\\log(n)^{2})</span>, where <span class="math">n</span> is the length of the vector. What if instead of accumulating a prime for each index we accumulate a random <span class="math">\\lambda</span> bit number at each index? The random number could simply be the hash of the index. Is this construction still secure? First consider the case where each index’s number has a unique prime factor. This adapted construction is trivially still secure. What, however, if <span class="math">x_{k}</span>, associated with index <span class="math">k</span>, is the product of <span class="math">x_{i}</span> and <span class="math">x_{j}</span>. Then accumulating <span class="math">x_{i}</span> and <span class="math">x_{j}</span> lets an adversary also give an inclusion proof for <span class="math">x_{k}</span>. Surprisingly, this does still not break security. While it is possible to give an inclusion proof for <span class="math">x_{k}</span>, i.e. open the vector at index <span class="math">k</span> to 1 it is suddenly impossible to give an exclusion proof for <span class="math">x_{k}</span>, i.e. open the vector at index <span class="math">k</span> to 0. The scenario only breaks the correctness property of the scheme, in that it is impossible to commit to a vector that is 1 at <span class="math">i</span> and <span class="math">j</span> but 0 at <span class="math">k</span>. In a setting, where the vector commitment is used as a static commitment to a vector, correctness only needs to hold for the particular vector that is being committed to. In the IOP application, described in Section 6.2, the prover commits to a long proof using a vector commitment. If these correctness failures only happen for few vectors, it may still be possible to use the scheme. This is especially true because in the IOP application the proof and also the proof elements can be modified by hashing the proof elements along with a nonce. A prover would modify the nonces until he finds a proof, i.e. a vector that he can commit to. To analyze the number of correctness failures we can compute the probability that a <span class="math">k</span>-bit element divides the product of <span class="math">n</span> <span class="math">k</span>-bit random elements. Fortunately, this question has been analyzed by Coron and Naccache<em>[x10]</em> with respect to the Gennaro-Halevi-Rabin Signature Scheme<em>[x12]</em>. They find that for 50 Million integers and 256-bit numbers the probability that even just a single correctness failure occurs is 1%. Furthermore we find experimentally that for <span class="math">2^{20}</span> integers and 80-bit numbers only about <span class="math">8,000</span> integers do not have a unique prime factor. Thus, any vector that is 1 at these <span class="math">8,000</span> positions can be committed to using just 80-bit integers. Our results suggest that using random integer indices instead of prime indices can be useful, if a) perfect completeness is not required b) primality checks are a major cost to the verifier.</p>

    <h2 id="sec-46" class="text-2xl font-bold">8 Conclusion</h2>

    <p class="text-gray-300">We expect that our techniques and constructions will have more applications beyond what was discussed. Several interesting open questions remain: What practical limitations occur when deploying the scheme? Is it possible to efficiently compute unions of accumulators? This is certainly true for Merkle trees but these do not have the batching properties and constant size of RSA accumulators. Similarly can one build an accumulator with constant sized witnesses from a quantum resistant assumption? Additionally, we hope that this research motivates further study of class groups as a group of unknown order.</p>

    <h2 id="sec-47" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">This work was partially supported by NSF, ONR, the Simons Foundation and the ZCash foundation. We thank Dario Fiore and Oliver Tran for pointing out typos and small errors.</p>

    <h2 id="sec-48" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ABC^{+}12] Jae Hyun Ahn, Dan Boneh, Jan Camenisch, Susan Hohenberger, abhi shelat, and Brent Waters. Computing on authenticated data. In</li>

    </ul>

    <p class="text-gray-300">Ronald Cramer, editor, TCC 2012, volume 7194 of LNCS, pages 1–20. Springer, Heidelberg, March 2012.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AHIV17] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, editors, ACM CCS 17, pages 2087–2104. ACM Press, October / November 2017.</li>

      <li>[BBB^{+}18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In 2018 IEEE Symposium on Security and Privacy, pages 315–334. IEEE Computer Society Press, May 2018.</li>

      <li>[BBBF18] Dan Boneh, Joseph Bonneau, Benedikt Bünz, and Ben Fisch. Verifiable delay functions. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part I, volume 10991 of LNCS, pages 757–788. Springer, Heidelberg, August 2018.</li>

      <li>[BBF18] Dan Boneh, Benedikt Bünz, and Ben Fisch. A survey of two verifiable delay functions. Cryptology ePrint Archive, Report 2018/712, 2018. https://eprint.iacr.org/2018/712.</li>

      <li>[BBHR18] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046, 2018. https://eprint.iacr.org/2018/046.</li>

      <li>[BCD^{+}17] Foteini Baldimtsi, Jan Camenisch, Maria Dubovitskaya, Anna Lysyanskaya, Leonid Reyzin, Kai Samelin, and Sophia Yakoubov. Accumulators with applications to anonymity-preserving revocation. Cryptology ePrint Archive, Report 2017/043, 2017. http://eprint.iacr.org/2017/043.</li>

      <li>[BCG^{+}14] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from bitcoin. In 2014 IEEE Symposium on Security and Privacy, pages 459–474. IEEE Computer Society Press, May 2014.</li>

      <li>[BCK10] Endre Bangerter, Jan Camenisch, and Stephan Krenn. Efficiency limitations for S-protocols for group homomorphisms. In Daniele Micciancio, editor, TCC 2010, volume 5978 of LNCS, pages 553–571. Springer, Heidelberg, February 2010.</li>

      <li>[BCM05] Endre Bangerter, Jan Camenisch, and Ueli Maurer. Efficient proofs of knowledge of discrete logarithms and representations in groups with hidden order. In Serge Vaudenay, editor, PKC 2005, volume 3386 of LNCS, pages 154–171. Springer, Heidelberg, January 2005.</li>

      <li>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Martin Hirt and Adam D. Smith, editors, TCC 2016-B, Part II, volume 9986 of LNCS, pages 31–60. Springer, Heidelberg, October / November 2016.</li>

      <li>[Bd94] Josh Cohen Benaloh and Michael de Mare. One-way accumulators: A decentralized alternative to digital sinatures (extended abstract). In Tor Helleseth, editor, EUROCRYPT’93, volume 765 of LNCS, pages 274–285. Springer, Heidelberg, May 1994.</li>

      <li>[BH01] Johannes Buchmann and Safuat Hamdy. A survey on iq cryptography. In Public-Key Cryptography and Computational Number Theory, pages 1–15, 2001.</li>

    </ul>

    <p class="text-gray-300">[BLL00] Ahto Buldas, Peeter Laud, and Helger Lipmaa. Accountable certificate management using undeniable attestations. In S. Jajodia and P. Samarati, editors, ACM CCS 00, pages 9–17. ACM Press, November 2000.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BP97] Niko Bari and Birgit Pfitzmann. Collision-free accumulators and fail-stop signature schemes without trees. In Walter Fumy, editor, EUROCRYPT’97, volume 1233 of LNCS, pages 480–494. Springer, Heidelberg, May 1997.</li>

      <li>[BSCG^{+}14] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from Bitcoin. In IEEE Symposium on Security and Privacy, 2014.</li>

      <li>[BSCR^{+}18] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for r1cs. Cryptology ePrint Archive, Report 2018/828, 2018. https://eprint.iacr.org/2018/828.</li>

      <li>[CF13] Dario Catalano and Dario Fiore. Vector commitments and their applications. In Kaoru Kurosawa and Goichiro Hanaoka, editors, PKC 2013, volume 7778 of LNCS, pages 55–72. Springer, Heidelberg, February / March 2013.</li>

      <li>[CHKO08] Philippe Camacho, Alejandro Hevia, Marcos A. Kiwi, and Roberto Opazo. Strong accumulators from collision-resistant hashing. In Tzong-Chen Wu, Chin-Laung Lei, Vincent Rijmen, and Der-Tsai Lee, editors, ISC 2008, volume 5222 of LNCS, pages 471–486. Springer, Heidelberg, September 2008.</li>

      <li>[CJ10] Sébastien Canard and Amandine Jambert. On extended sanitizable signature schemes. In Josef Pieprzyk, editor, CT-RSA 2010, volume 5985 of LNCS, pages 179–194. Springer, Heidelberg, March 2010.</li>

      <li>[CKS09] Jan Camenisch, Markulf Kohlweiss, and Claudio Soriente. An accumulator based on bilinear maps and efficient revocation for anonymous credentials. In Stanislaw Jarecki and Gene Tsudik, editors, PKC 2009, volume 5443 of LNCS, pages 481–500. Springer, Heidelberg, March 2009.</li>

      <li>[CL02] Jan Camenisch and Anna Lysyanskaya. Dynamic accumulators and application to efficient revocation of anonymous credentials. In Moti Yung, editor, CRYPTO 2002, volume 2442 of LNCS, pages 61–76. Springer, Heidelberg, August 2002.</li>

      <li>[CN00] Jean-Sébastien Coron and David Naccache. Security analysis of the Gennaro-Halevi-Rabin signature scheme. In Bart Preneel, editor, EUROCRYPT 2000, volume 1807 of LNCS, pages 91–101. Springer, Heidelberg, May 2000.</li>

      <li>[CPZ18] Alexander Chepurnoy, Charalampos Papamanthou, and Yupeng Zhang. Edrax: A cryptocurrency with stateless transaction validation. Cryptology ePrint Archive, Report 2018/968, 2018. https://eprint.iacr.org/2018/968.</li>

      <li>[CS99] Ronald Cramer and Victor Shoup. Signature schemes based on the strong RSA assumption. Cryptology ePrint Archive, Report 1999/001, 1999. http://eprint.iacr.org/1999/001.</li>

      <li>[DK02] Ivan Damgård and Maciej Koprowski. Generic lower bounds for root extraction and signature schemes in general groups. In Lars R. Knudsen, editor, EUROCRYPT 2002, volume 2332 of LNCS, pages 256–271. Springer, Heidelberg, April / May 2002.</li>

    </ul>

    <p class="text-gray-300">[Dra] Justin Drake. Accumulators, scalability of utxo blockchains, and data availability. https://ethresear.ch/t/accumulators-scalability-of-utxo-blockchains-and-data-availability/176.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[DT08] Ivan Damgård and Nikos Triandopoulos. Supporting non-membership proofs with bilinear-map accumulators. Cryptology ePrint Archive, Report 2008/538, 2008. http://eprint.iacr.org/2008/538.</li>

      <li>[FS87] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Andrew M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 186–194. Springer, Heidelberg, August 1987.</li>

      <li>[FT14] Pierre-Alain Fouque and Mehdi Tibouchi. Close to uniform prime number generation with fewer random bits. In Javier Esparza, Pierre Fraigniaud, Thore Husfeldt, and Elias Koutsoupias, editors, ICALP 2014, Part I, volume 8572 of LNCS, pages 991–1002. Springer, Heidelberg, July 2014.</li>

      <li>[FVY14] Conner Fromknecht, Dragos Velicanu, and Sophia Yakoubov. A decentralized public key infrastructure with identity retention. Cryptology ePrint Archive, Report 2014/803, 2014. http://eprint.iacr.org/2014/803.</li>

      <li>[GGM14] Christina Garman, Matthew Green, and Ian Miers. Decentralized anonymous credentials. In NDSS 2014. The Internet Society, February 2014.</li>

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 626–645. Springer, Heidelberg, May 2013.</li>

      <li>[GHR99] Rosario Gennaro, Shai Halevi, and Tal Rabin. Secure hash-and-sign signatures without the random oracle. In Jacques Stern, editor, EUROCRYPT’99, volume 1592 of LNCS, pages 123–139. Springer, Heidelberg, May 1999.</li>

      <li>[Gro16] Jens Groth. On the size of pairing-based non-interactive arguments. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 305–326. Springer, Heidelberg, May 2016.</li>

      <li>[HM00] Safuat Hamdy and Bodo Möller. Security of cryptosystems based on class groups of imaginary quadratic orders. In Tatsuaki Okamoto, editor, ASIACRYPT 2000, volume 1976 of LNCS, pages 234–247. Springer, Heidelberg, December 2000.</li>

      <li>[Kil92] Joe Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In 24th ACM STOC, pages 723–732. ACM Press, May 1992.</li>

      <li>[Lip12] Helger Lipmaa. Secure accumulators from euclidean rings without trusted setup. In Feng Bao, Pierangela Samarati, and Jianying Zhou, editors, ACNS 12, volume 7341 of LNCS, pages 224–240. Springer, Heidelberg, June 2012.</li>

      <li>[LLX07] Jiangtao Li, Ninghui Li, and Rui Xue. Universal accumulators with efficient nonmembership proofs. In Jonathan Katz and Moti Yung, editors, ACNS 07, volume 4521 of LNCS, pages 253–269. Springer, Heidelberg, June 2007.</li>

    </ul>

    <p class="text-gray-300">[LM18] Russell W.F. Lai and Giulio Malavolta. Optimal succinct arguments via hidden order groups. Cryptology ePrint Archive, Report 2018/705, 2018. https://eprint.iacr.org/2018/705.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[LRY16] Benoit Libert, Somindu C. Ramanna, and Moti Yung. Functional commitment schemes: From polynomial commitments to pairing-based accumulators from simple assumptions. In Ioannis Chatzigiannakis, Michael Mitzenmacher, Yuval Rabani, and Davide Sangiorgi, editors, ICALP 2016, volume 55 of LIPIcs, pages 30:1–30:14. Schloss Dagstuhl, July 2016.</li>

      <li>[LY10] Benoit Libert and Moti Yung. Concise mercurial vector commitments and independent zero-knowledge sets with short proofs. In Daniele Micciancio, editor, TCC 2010, volume 5978 of LNCS, pages 499–517. Springer, Heidelberg, February 2010.</li>

      <li>[Mer88] Ralph C. Merkle. A digital signature based on a conventional encryption function. In Carl Pomerance, editor, CRYPTO’87, volume 293 of LNCS, pages 369–378. Springer, Heidelberg, August 1988.</li>

      <li>[MGGR13a] Ian Miers, Christina Garman, Matthew Green, and Aviel D. Rubin. Zerocoin: Anonymous distributed E-cash from Bitcoin. In 2013 IEEE Symposium on Security and Privacy, pages 397–411. IEEE Computer Society Press, May 2013.</li>

      <li>[MGGR13b] Ian Miers, Christina Garman, Matthew Green, and Aviel D Rubin. Zerocoin: Anonymous Distributed E-Cash from Bitcoin. In IEEE Symposium on Security and Privacy, 2013.</li>

      <li>[Mic94] Silvio Micali. CS proofs (extended abstracts). In 35th FOCS, pages 436–453. IEEE Computer Society Press, November 1994.</li>

      <li>[Ngu05] L. Nguyen. Accumulators from bilinear maps and applications. CT-RSA, 3376:275–292, 2005.</li>

      <li>[NN98] Kobbi Nissim and Moni Naor. Certificate revocation and certificate update. In Usenix, 1998.</li>

      <li>[PS14] Henrich Christopher Pöhls and Kai Samelin. On updatable redactable signatures. In Ioana Boureanu, Philippe Owesarski, and Serge Vaudenay, editors, ACNS 14, volume 8479 of LNCS, pages 457–475. Springer, Heidelberg, June 2014.</li>

      <li>[Sha83] Adi Shamir. On the generation of cryptographically strong pseudorandom sequences. ACM Transactions on Computer Systems (TOCS), 1(1):38–44, 1983.</li>

      <li>[Sho97] Victor Shoup. Lower bounds for discrete logarithms and related problems. In Walter Fumy, editor, EUROCRYPT’97, volume 1233 of LNCS, pages 256–266. Springer, Heidelberg, May 1997.</li>

      <li>[Sla12] Daniel Slamanig. Dynamic accumulator based discretionary access control for outsourced storage with unlinkable access - (short paper). In Angelos D. Keromytis, editor, FC 2012, volume 7397 of LNCS, pages 215–222. Springer, Heidelberg, February / March 2012.</li>

      <li>[STS99a] Tomas Sander and Amnon Ta-Shma. Auditable, anonymous electronic cash. In Michael J. Wiener, editor, CRYPTO’99, volume 1666 of LNCS, pages 555–572. Springer, Heidelberg, August 1999.</li>

      <li>[STS99b] Tomas Sander and Amnon Ta-Shma. Flow control: A new approach for anonymity control in electronic cash systems. In Matthew Franklin, editor, FC’99, volume 1648 of LNCS, pages 46–61. Springer, Heidelberg, February 1999.</li>

    </ul>

    <p class="text-gray-300">[STSY01] Tomas Sander, Amnon Ta-Shma, and Moti Yung. Blind, auditable membership proofs. In Yair Frankel, editor, FC 2000, volume 1962 of LNCS, pages 53–71. Springer, Heidelberg, February 2001.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[SYB14] David Schwartz, Noah Youngs, and Arthur Britto. The Ripple Protocol Consensus Algorithm, September 2014.</li>

      <li>[TMA13] Peter Todd, Gregory Maxwell, and Oleg Andreev. Reducing UTXO: users send parent transactions with their merkle branches. bitcointalk.org, October 2013.</li>

      <li>[Tod16] Peter Todd. Making UTXO Set Growth Irrelevant With Low-Latency Delayed TXO Commitments . https://petertodd.org/2016/delayed-txo-commitments, May 2016.</li>

      <li>[TW12] Björn Terelius and Douglas Wikström. Efficiency limitations of S-protocols for group homomorphisms revisited. In Ivan Visconti and Roberto De Prisco, editors, SCN 12, volume 7485 of LNCS, pages 461–476. Springer, Heidelberg, September 2012.</li>

      <li>[Wes18] Benjamin Wesolowski. Efficient verifiable delay functions. Cryptology ePrint Archive, Report 2018/623, 2018. https://eprint.iacr.org/2018/623.</li>

      <li>[Woo14] Gavin Wood. Ethereum: A secure decentralized transaction ledger. http://gavwood.com/paper.pdf, 2014.</li>

    </ul>

    <p class="text-gray-300">We observe that the protocol PoE can be generalized to a relation for any homomorphism  <span class="math">\\phi : \\mathbb{Z}^n \\to \\mathbb{G}</span>  for which the adaptive root assumption holds in  <span class="math">\\mathbb{G}</span> . Specifically, Protocol PoHP below is a protocol for the relation:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\phi , \\mathrm {P o H P}} = \\left\\{\\left(\\left(w \\in \\mathbb {G}, \\mathbf {x} \\in \\mathbb {Z} ^ {n}\\right); \\perp\\right): w = \\phi (\\mathbf {x}) \\in \\mathbb {G} \\right\\}.</span></div>

    <p class="text-gray-300">This generalization will be useful in our applications.</p>

    <p class="text-gray-300">Protocol PoHP (Proof of homomorphism preimage) for  <span class="math">\\mathcal{R}_{\\phi, \\mathrm{PoHP}}</span></p>

    <p class="text-gray-300">Params:  <span class="math">\\mathbb{G} \\stackrel{\\S}{\\leftarrow} GGen(\\lambda)</span> ,  <span class="math">\\phi : \\mathbb{Z}^n \\to \\mathbb{G}</span> ; Inputs:  <span class="math">\\mathbf{x} \\in \\mathbb{Z}^n</span> ,  <span class="math">w \\in \\mathbb{G}</span> ; Claim:  <span class="math">\\phi(\\mathbf{x}) = w</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier sends  <span class="math">\\ell \\stackrel{\\S}{\\leftarrow}</span>  Primes(λ).</li>

      <li>For  <span class="math">i = 1,\\dots ,n</span>  : Prover finds integers  <span class="math">q_{i}</span>  and  <span class="math">r_i\\in [\\ell ]</span>  s.t.  <span class="math">x_{i} = q_{i}\\ell +r_{i}</span></li>

    </ol>

    <p class="text-gray-300">Let  <span class="math">\\mathbf{q} \\gets (q_1, \\dots, q_n) \\in \\mathbb{Z}^n</span>  and  <span class="math">\\mathbf{r} \\gets (r_1, \\dots, r_n) \\in [\\ell]^n</span> .</p>

    <p class="text-gray-300">Prover sends  <span class="math">Q \\gets \\phi(\\mathbf{q}) \\in \\mathbb{G}</span>  to Verifier.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier computes  <span class="math">r_i = (x_i \\bmod \\ell) \\in [\\ell]</span>  for all  <span class="math">i = 1, \\dots, n</span> , sets  <span class="math">\\mathbf{r} = (r_1, \\dots, r_n)</span> , and accepts if  <span class="math">Q^\\ell \\phi(\\mathbf{r}) = w</span>  holds in  <span class="math">\\mathbb{G}</span> .</li>

    </ol>

    <p class="text-gray-300">Theorem 6 (Soundness PoHP). Protocol PoHP is an argument system for Relation  <span class="math">\\mathcal{R}_{\\phi, \\mathrm{PoHP}}</span>  with negligible soundness error, assuming the adaptive root assumption holds for GGen.</p>

    <p class="text-gray-300">Proof. Suppose that  <span class="math">\\phi(\\mathbf{x}) \\neq w</span> , but the adversary succeeds in making the verifier accept with non-negligible probability. Let  <span class="math">\\mathbf{q}</span>  and  <span class="math">\\mathbf{r}</span>  be as defined in step (2) of the protocol and let  <span class="math">Q</span>  be the prover's message to the verifier. Then  <span class="math">[Q / \\phi(\\mathbf{q})]^{\\ell} = [w / \\phi(\\mathbf{r})] / [\\phi(\\mathbf{x}) / \\phi(\\mathbf{r})] = w / \\phi(\\mathbf{x}) \\neq 1</span> . We thus obtain an algorithm to break the adaptive root assumption for the instance  <span class="math">\\hat{w} := w / \\phi(\\mathbf{x})</span>  by interacting with the adversary, giving it the adaptive root challenge  <span class="math">\\ell</span> , and outputting  <span class="math">\\hat{u} := Q / \\phi(\\mathbf{q}) \\in \\mathbb{G}</span> , where  <span class="math">Q</span>  is the value output by the adversary.</p>

    <p class="text-gray-300">The PoKE argument of knowledge can be extended to an argument of knowledge for the pre-image of a homomorphism  <span class="math">\\phi : \\mathbb{Z}^n \\to \\mathbb{G}</span> .</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\phi} = \\left\\{\\left(w \\in \\mathbb {G}; \\mathbf {x} \\in \\mathbb {Z} ^ {n}\\right): w = \\phi (\\mathbf {x}) \\in \\mathbb {G} \\right\\}.</span></div>

    <p class="text-gray-300">For a general homomorphism  <span class="math">\\phi</span>  we run into the same extraction challenge that we encountered in extending Protocol PoKE* to work for general bases. The solution for Protocol PoKE was to additionally send  <span class="math">g^x</span>  where  <span class="math">g</span>  is either a base in the CRS or chosen randomly by the verifier and execute a parallel PoKE for  <span class="math">g \\mapsto g^x</span> . We can apply exactly the same technique here on each component  <span class="math">x_i</span>  of the witness, i.e. send  <span class="math">g^{x_i}</span>  to the verifier and execute a parallel PoKE that  <span class="math">g \\mapsto g^{x_i}</span> . This allows the extractor to obtain the witness  <span class="math">x</span> , and the soundness of the protocol then follows from the soundness of Protocol PoHP. However, as an optimization to reduce the communication we can instead use the group representation homomorphism  <span class="math">Rep: \\mathbb{Z}^n \\to \\mathbb{G}</span>  defined as</p>

    <div class="my-4 text-center"><span class="math-block">R e p (\\mathbf {x}) = \\prod_ {i = 1} ^ {n} g _ {i} ^ {x _ {i}}</span></div>

    <p class="text-gray-300">for base elements  <span class="math">g_{i}</span>  defined in the CRS. The prover sends  <span class="math">Rep(\\mathbf{x})</span>  in its first message, which is a single group element independent of  <span class="math">n</span> .</p>

    <p class="text-gray-300">Protocol PoKHP (Proof of knowledge of homomorphism preimage)</p>

    <p class="text-gray-300">Params:  <span class="math">\\mathbb{G} \\stackrel{\\S}{\\leftarrow} GGen(\\lambda)</span> ,  <span class="math">(g_1, \\dots, g_n) \\in \\mathbb{G}^n</span> ,  <span class="math">\\phi : \\mathbb{Z}^n \\to \\mathbb{G}</span> ; Inputs:  <span class="math">w \\in \\mathbb{G}</span> ; Witness:  <span class="math">\\mathbf{x} \\in \\mathbb{Z}</span> ; Claim:  <span class="math">\\phi(\\mathbf{x}) = w</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prover sends <span class="math">z = Rep(\\mathbf{x}) = \\prod_{i} g_{i}^{x_{i}} \\in \\mathbb{G}</span> to the verifier.</li>

      <li>Verifier sends <span class="math">\\ell \\stackrel{\\</span>}{\\leftarrow} \\mathrm{Primes}(\\lambda)$.</li>

      <li>For each <span class="math">x_i</span>, Prover computes <span class="math">q_i, r_i</span> s.t. <span class="math">x_i = q_i \\ell + r_i</span>, sets <span class="math">\\mathbf{q} \\gets (q_1, \\dots, q_n) \\in \\mathbb{Z}^n</span> and <span class="math">\\mathbf{r} \\gets (r_1, \\dots, r_n) \\in [\\ell]^n</span>. Prover sends <span class="math">Q_\\phi \\gets \\phi(\\mathbf{q}) \\in \\mathbb{G}</span>, <span class="math">Q_{Rep} \\gets Rep(\\mathbf{q}) \\in \\mathbb{G}</span>, and <span class="math">\\mathbf{r}</span> to Verifier.</li>

      <li>Verifier accepts if <span class="math">\\mathbf{r} \\in [\\ell]^n</span>, <span class="math">Q_{\\phi}^{\\ell} \\phi(\\mathbf{r}) = w</span>, and <span class="math">Q_{Rep}^{\\ell} \\text{Rep}(\\mathbf{r}) = z</span>.</li>

    </ol>

    <p class="text-gray-300">In order to analyze the security of this protocol, it is helpful to first consider a special case of Protocol PoKHP protocol for the homomorphism <span class="math">Rep: \\mathbb{Z}^n \\to \\mathbb{G}</span>, which is a generalization of Protocol PoKE*. In this case the prover of course does not need to separately send <span class="math">Rep(\\mathbf{x})</span> in the first message. The protocol is as follows:</p>

    <p class="text-gray-300"><strong>Protocol PoKRep (Proof of knowledge of representation)</strong></p>

    <p class="text-gray-300">Params: <span class="math">\\mathbb{G} \\stackrel{\\</span>}{\\leftarrow} GGen(\\lambda), (g_1, \\dots, g_n) \\in \\mathbb{G}^n<span class="math">; Inputs: </span>w \\in \\mathbb{G}<span class="math">; Witness: </span>\\mathbf{x} \\in \\mathbb{Z}<span class="math">; Claim: </span>Rep(\\mathbf{x}) = \\prod_{i=1}^{n} g_i^{x_i} = w$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier sends <span class="math">\\ell \\stackrel{\\</span>}{\\leftarrow} \\mathrm{Primes}(\\lambda)$.</li>

      <li>For each <span class="math">x_i</span>, Prover finds <span class="math">q_i, r_i</span> s.t. <span class="math">x_i = q_i \\ell + r_i</span>, sets <span class="math">\\mathbf{q} \\gets (q_1, \\dots, q_n) \\in \\mathbb{Z}^n</span> and <span class="math">\\mathbf{r} \\gets (r_1, \\dots, r_n) \\in [\\ell]^n</span>. Prover sends <span class="math">Q \\gets \\text{Rep}(\\mathbf{q}) = \\prod_i g_i^{q_i} \\in \\mathbb{G}</span> and <span class="math">\\mathbf{r}</span> to Verifier.</li>

      <li>Verifier accepts if <span class="math">\\mathbf{r} \\in [\\ell]^n</span>, <span class="math">Q^\\ell \\text{Rep}(\\mathbf{r}) = w</span>.</li>

    </ol>

    <p class="text-gray-300">The following theorems prove security of the two protocols above.</p>

    <p class="text-gray-300"><strong>Theorem 7 (PoKRep Argument of Knowledge).</strong> Protocol PoKRep is an argument of knowledge for relation <span class="math">\\mathcal{R}_{\\mathrm{Rep}}</span> in the generic group model.</p>

    <p class="text-gray-300"><strong>Proof.</strong> See Appendix C.</p>

    <p class="text-gray-300"><strong>Theorem 8 (PoKHP Argument of Knowledge).</strong> Protocol PoKHP is an argument of knowledge for the relation <span class="math">\\mathcal{R}_{\\phi}</span> in the generic group model.</p>

    <p class="text-gray-300"><strong>Proof.</strong> See Appendix C.</p>

    <h2 id="sec-52" class="text-2xl font-bold">A.3 A succinct proof of integer exponent mod <span class="math">n</span></h2>

    <p class="text-gray-300">There are several applications of accumulators that require proving complex statements about integer values committed in an accumulator (e.g. [BSCG+14, MGGR13b]). Practical succinct argument systems (SNARGs/SNARKs/STARKs) operate on statements defined as an arithmetic circuit, and the prover efficiency scales with the multiplication complexity of the statement. Since RSA accumulators are an algebraic accumulator, in contrast to Merkle trees, one would hope that the arithmetic complexity of statements involving RSA accumulator elements would be much lower than those involving Merkle tree elements. Unfortunately, this is not the case because RSA accumulator operations are in <span class="math">\\mathbb{Z}_N</span> for composite <span class="math">N</span> with unknown factorization, whereas arithmetic circuits for SNARGs are always defined over finite fields <span class="math">\\mathbb{Z}_p</span>. Finding ways to combine RSA accumulators with SNARKs more efficiently is an interesting research direction.</p>

    <p class="text-gray-300">We present a variant of <span class="math">\\mathsf{PoKE}^*</span> for a group of unknown order <span class="math">\\mathbb{G}</span>, which is an argument of knowledge that the integer discrete log <span class="math">x</span> of an element <span class="math">y \\in \\mathbb{G}</span> is equivalent to <span class="math">\\hat{x}</span> modulo a public odd prime integer <span class="math">n</span>. Concretely, the new protocol <span class="math">\\mathsf{PoKEMon}</span> is for the following relation:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\mathrm{PoKEMon}} = \\left\\{ \\left( w \\in \\mathbb{G}, \\hat{x} \\in [n]; x \\in \\mathbb{Z} \\right) : w = g^x \\in \\mathbb{G}, x \\bmod n = \\hat{x} \\right\\}.</span></div>

    <p class="text-gray-300">As with <span class="math">\\mathsf{PoKE}^<em></span>, the base element <span class="math">g</span> and the unknown order group <span class="math">\\mathbb{G}</span> are fixed public parameters. <span class="math">\\mathsf{PoKEMon}</span> modifies <span class="math">\\mathsf{PoKE}^</em></span> by setting the challenge to be <span class="math">\\ell \\cdot n</span> where <span class="math">\\ell \\stackrel{\\</span>}{\\leftarrow} \\mathsf{Primes}(\\lambda)$.</p>

    <p class="text-gray-300">32</p>

    <p class="text-gray-300">Protocol PoKEMon (Proof of equality mod <span class="math">n</span>) for Relation <span class="math">\\mathcal{R}_{\\text{PoKEMon}}</span> Params: <span class="math">\\mathbb{G}\\stackrel{\\</span>}{\\leftarrow}G\\text{Gen}(\\lambda),\\ g\\in\\mathbb{G}<span class="math">; Inputs: Odd prime </span>n,w\\in\\mathbb{G},\\hat{x}\\in[n]<span class="math">; Witness: </span>x\\in\\mathbb{Z}<span class="math">; Claim: </span>g^{x}=w<span class="math"> and </span>x<span class="math"> mod </span>n=\\hat{x}$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier sends <span class="math">\\ell\\stackrel{\\</span>}{\\leftarrow}\\text{Primes}(\\lambda)$.</li>

      <li>Prover computes the quotient <span class="math">q\\in\\mathbb{Z}</span> and residue <span class="math">r\\in[\\ell\\cdot n]</span> such that <span class="math">x=q(\\ell\\cdot n)+r</span>. Prover sends the pair <span class="math">(Q\\leftarrow g^{q},\\ r)</span> to the Verifier.</li>

      <li>Verifier accepts if <span class="math">r\\in[\\ell\\cdot n]</span> and <span class="math">Q^{\\ell\\cdot n}g^{r}=w</span> holds in <span class="math">\\mathbb{G}</span> and <span class="math">r</span> mod <span class="math">n=\\hat{x}</span>.</li>

    </ol>

    <p class="text-gray-300">The same technique can be applied to PoKE, where the base element can be freely chosen by the prover.</p>

    <p class="text-gray-300">We can prove security by directly reducing it to the security of the <span class="math">\\text{PoKE}^{*}</span> protocol and additionally the strong RSA assumption, which assumes it is hard to compute an <span class="math">\\ell</span>th root of a random group element <span class="math">g</span> for odd prime <span class="math">\\ell</span>.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Theorem 9 (PoKEMon Argument of Knowledge).</h6>

    <p class="text-gray-300">Protocol PoKEMon is an argument of knowledge for the relation <span class="math">\\mathcal{R}_{\\text{PoKEMon}}</span> if Protocol PoKE^{∗} is an argument of knowledge for the relation <span class="math">\\mathcal{R}_{\\text{PoKE}^{*}}</span> and the strong RSA assumption holds for GGen.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We use the extractor <span class="math">\\text{Ext}^{<em>}</span> of the <span class="math">\\text{PoKE}^{</em>}</span> protocol to build an extractor <span class="math">\\text{Ext}</span> for PoKEMon, which succeeds with overwhelming probability in extracting <span class="math">x</span> such that <span class="math">g^{x}=w</span> and <span class="math">x=\\hat{x}\\bmod n</span> from any PoKEMon adversary that has a non-negligible success rate.</p>

    <p class="text-gray-300">Ext runs a copy of <span class="math">\\text{Ext}^{<em>}</span> and simulates both the <span class="math">\\text{PoKE}^{</em>}</span> challenges and a <span class="math">\\text{PoKE}^{<em>}</span> adversary’s response. When Ext receives the challenge <span class="math">\\ell</span> and the PoKEMon adversary’s response <span class="math">(Q,r)</span>, it computes <span class="math">q^{\\prime}=[r/\\ell]</span> and <span class="math">r^{\\prime}=r\\bmod\\ell</span> so that <span class="math">r=q^{\\prime}\\ell+r^{\\prime}</span> and sets <span class="math">Q^{\\prime}\\leftarrow Q^{n}g^{q^{\\prime}}</span>. It forwards <span class="math">(\\ell,Q^{\\prime},r^{\\prime})</span> to <span class="math">\\text{Ext}^{</em>}</span>. If the PoKEMon adversary’s response is valid then <span class="math">Q^{\\ell n}g^{r}=w</span>, implying that <span class="math">Q^{\\prime\\ell}g^{r^{\\prime}}=w</span>. Thus, Ext simulates for <span class="math">\\text{Ext}^{<em>}</span> a transcript of the <span class="math">\\text{PoKE}^{</em>}</span> protocol for a <span class="math">\\text{PoKE}^{<em>}</span> adversary that succeeds with the same rate as the PoKEMon adversary. By hypothesis, <span class="math">\\text{Ext}^{</em>}</span> succeeds with overwhelming probability to output <span class="math">x</span> such that <span class="math">g^{x}=w</span>.</p>

    <p class="text-gray-300">Consider any iteration in which Ext had received an accepting PoKEMon transcript <span class="math">(\\ell,Q,r)</span>. We claim that <span class="math">x=r\\bmod\\ell\\cdot n</span> with overwhelming probability, by the strong RSA assumption.</p>

    <p class="text-gray-300">Suppose that <span class="math">x-r\\neq 0\\bmod\\ell\\cdot n</span> then given that <span class="math">\\ell</span> and <span class="math">n</span> are prime we have that either <span class="math">\\gcd(\\ell,x-r)=1</span> or <span class="math">\\gcd(n,x-r)=1</span>. Without loss of generality we assume the latter. Let <span class="math">Q^{\\prime}=Q^{\\ell}</span> then <span class="math">Q^{\\prime n}=g^{x-r}</span> and <span class="math">\\gcd(n,x-r)=1</span>. Now using Shamir’s trick we can compute an <span class="math">n</span>th root of <span class="math">g</span>. Let <span class="math">a,b=\\text{\\bf Bezout}(n,x-r)</span> such that <span class="math">an+b(x-r)=1</span>. Then <span class="math">u=Q^{\\prime b}g^{a}</span> is an <span class="math">n</span>th root of <span class="math">g</span> as <span class="math">u^{n}=Q^{\\prime bn}g^{an}=g^{b\\cdot(x-r)}g^{an}=g</span>. This shows that <span class="math">(u,n)</span> breaks the strong RSA assumption for <span class="math">\\mathbb{G}\\stackrel{\\</span>}{\\leftarrow}G\\text{Gen}(\\lambda)$.</p>

    <p class="text-gray-300">This contradicts the hypothesis and we, therefore, have that <span class="math">r=x\\bmod\\ell\\cdot n</span> which implies that <span class="math">r=x\\bmod n</span> for an overwhelming number of accepting transcripts. And since in any accepting transcript <span class="math">\\hat{x}=r\\bmod n</span> we have that <span class="math">x=\\hat{x}\\bmod n</span> with overwhelming probability.</p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-55" class="text-xl font-semibold mt-8">A.4 A succinct zero-knowledge proof of discrete-log</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The PoKE protocol for succinctly proving knowledge of an exponent can further be made zero-knowledge using a method similar to the classic Schnorr <span class="math">\\Sigma</span>-protocol for hidden order groups. The Schnorr protocol for hidden order groups has the same structure as the standard Schnorr protocol for proving knowledge of a discrete logarithm <span class="math">x</span> such that <span class="math">u^{x}=w</span> in a group of known order. Here, the prover first samples a blinding factor <span class="math">k\\in[-B,B]</span> and sends <span class="math">A=u^{k}</span>, obtains a challenge <span class="math">c</span>, and returns <span class="math">s=k+cx</span>. The verifier checks that <span class="math">u^{z}=aw^{c}</span>. In hidden order groups, <span class="math">k</span> must be sampled from a range of integers <span class="math">[-B,B]</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/B$ is negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The classical Schnorr protocol for hidden order groups is an honest verifier statistical zero-knowledge (HVSZK) protocol and has soundness error of only 1/2 against a classical adversary <em>[x10]</em>. Only for a small subclass of homomorphisms better</p>

    <p class="text-gray-300">soundness can be proven <em>[x1]</em>. Unfortunately, <em>[x2]</em> proved that the soundness limitation is fundamental and cannot be improved against a classical adversary, and therefore requires many rounds of repetition. However, we are able to show that we can prove much tighter soundness if the adversary is restricted to operating in a generic group.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Definition 10 (Zero Knowledge).</h6>

    <p class="text-gray-300">We say an argument system <span class="math">(\\mathsf{Pgen},\\mathsf{P},\\mathsf{V})</span> for <span class="math">\\mathcal{R}</span> has statistical zero-knowledge if there exists a poly-time simulator <span class="math">\\mathsf{Sim}</span> such that for <span class="math">(x,w)\\in\\mathcal{R}</span> the following two distribution are statistically indistinguishable:</p>

    <p class="text-gray-300"><span class="math">D_{1}=</span> <span class="math">\\Big{\\{}\\langle\\mathsf{P}(pp,x,w),\\mathsf{V}(pp,x)\\rangle,\\;\\;pp\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathsf{Pgen}(\\lambda)\\Big{\\}}<span class="math"> </span>D_{2}=<span class="math"> </span>\\Big{\\{}\\mathsf{Sim}(pp,x,\\mathsf{V}(pp,x)),\\;pp\\stackrel{{\\scriptstyle\\<span class="math">}}{{\\leftarrow}}\\mathsf{Pgen}(\\lambda)\\Big{\\}}</span></p>

    <h4 id="sec-57" class="text-lg font-semibold mt-6">The protocol.</h4>

    <p class="text-gray-300">Our ZK protocol applies Protocol PoKE to the last step of the Schnorr protocol, which greatly improves the communication efficiency of the classical protocol when the witness is large. In fact, we can interleave the first step of Protocol PoKE where the verifier sends a random prime <span class="math">\\ell</span> with the second step of the Schnorr protocol where the verifier sends a challenge <span class="math">c</span>. This works for the case when <span class="math">u</span> is a base specified in the CRS, i.e. it is the output of a query to the generic group oracle <span class="math">\\mathcal{O}_{1}</span>, however a subtlety arises when <span class="math">u</span> is selected by the prover. In fact, we cannot even prove that the Schnorr protocol itself is secure (with negligible soundness error) when <span class="math">u</span> is selected by the prover. The method we used for PoKE on general bases involved sending <span class="math">g^{x}</span> for <span class="math">g</span> specified in the CRS. This would immediately break ZK since the simulator cannot simulate <span class="math">g^{x}</span> without knowing the witness <span class="math">x</span>. Instead, in the first step the prover will send a Pedersen commitment <span class="math">g^{x}h^{\\rho}</span> where <span class="math">\\rho</span> is sampled randomly in some interval and <span class="math">h</span> is another base specified in the CRS.</p>

    <p class="text-gray-300">We will first present a ZK proof of knowledge of a representation in terms of bases specified in the CRS and show that there is an extractor that can extract the witness. We then use this as a building block for constructing a ZK protocol for the relation <span class="math">\\mathcal{R}_{\\mathsf{PoKE}}</span>.</p>

    <p class="text-gray-300">Protocol ZKPoKRep for Relation <span class="math">\\mathcal{R}_{\\phi}</span> where <span class="math">\\phi:=Rep</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Params: <span class="math">(g_{1},\\ldots g_{n})\\in\\mathbb{G},\\;\\;\\mathbb{G}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\text{GGen}(\\lambda),B>2^{2\\lambda}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; Inputs: </span>w\\in\\mathbb{G}$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Witness: <span class="math">\\bm{x}=(x_{1},\\ldots,x_{n})\\in\\mathbb{Z}^{n}</span>; Claim: <span class="math">\\text{Rep}(\\bm{x})=\\prod_{i=1}^{n}g_{i}^{x_{i}}=w</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prover chooses random <span class="math">k_{1},\\ldots,k_{n}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}[-B,B]<span class="math">, sends </span>A=\\prod_{i=1}^{n}g_{i}^{k_{i}}$ to Verifier.</li>

      <li>Verifier sends <span class="math">c\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}[0,2^{\\lambda}],\\ell\\stackrel{{\\scriptstyle\\<span class="math">}}{{\\leftarrow}}\\text{Primes}(\\lambda)</span>.</li>

      <li>Prover computes <span class="math">s_{i}=k_{i}+c\\cdot x_{i}\\forall i\\in[1,n]</span> and then derives quotients <span class="math">\\bm{q}\\in\\mathbb{Z}^{n}</span> and residues <span class="math">\\bm{r}\\in[\\ell]^{n}</span> such that <span class="math">q_{i}\\cdot\\ell+r_{i}=s_{i}</span> for all <span class="math">1\\leq i\\leq n</span>. Prover sends <span class="math">Q=\\prod_{i=1}^{n}g_{i}^{q_{i}}</span> and <span class="math">\\bm{r}</span> to the Verifier.</li>

      <li>Verifier accepts if <span class="math">r_{i}\\in[\\ell]</span> for all <span class="math">1\\leq i\\leq n</span> and that <span class="math">Q^{\\ell}\\prod_{i=1}^{n}g_{i}^{r_{i}}=Aw^{c}</span>.</li>

    </ol>

    <h6 id="sec-58" class="text-base font-medium mt-4">Theorem 10 (Protocol ZKPoKRep).</h6>

    <p class="text-gray-300">Protocol ZKPoKRep is an honest-verifier statistically zero-knowledge argument of knowledge for relation <span class="math">\\mathcal{R}_{\\text{Rep}}</span> in the generic group model.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">See Appendix C. ∎</p>

    <p class="text-gray-300">Finally, we use the protocol above to obtain a ZK protocol for the relation <span class="math">\\mathcal{R}_{\\mathsf{PoKE}}</span>. The protocol applies (in parallel) the <span class="math">\\Sigma</span>-protocol for PoKRep to a Pedersen commitment <span class="math">g^{x}h^{\\rho}</span> for <span class="math">g</span> and <span class="math">h</span> specified in the CRS. In order to achieve statistical zero-knowledge we require that <span class="math">g</span> and <span class="math">h</span> generate the same subgroup of <span class="math">\\mathbb{G}</span>. This requirement can be lifted when computation zero-knowledge suffices. The extractor for this protocol will invoke the PoKRep extractor to open the commitment. The protocol works as follows:</p>

    <p class="text-gray-300">Protocol ZKPoKE for <span class="math">\\mathcal{R}_{\\mathsf{PoKE}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Params: <span class="math">(g,h)\\in \\mathbb{G}</span> s.t. <span class="math">\\langle g\\rangle = \\langle h\\rangle</span>, <span class="math">\\mathbb{G}\\stackrel {\\S}{\\leftarrow}GGen(\\lambda)</span>; Inputs: <span class="math">u,w\\in \\mathbb{G}</span>, $B &gt; 2^{2\\lambda}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Witness: <span class="math">x\\in \\mathbb{Z}</span>; Claim: <span class="math">u^{x} = w</span></p>

    <p class="text-gray-300">Let <span class="math">Com(x;r)\\coloneqq g^{x}h^{r}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prover chooses random <span class="math">k,\\rho_{x},\\rho_{k}\\stackrel {\\S}{\\leftarrow}[-B,B]</span> and sends <span class="math">(z,A_g,A_u)</span> to the verifier where <span class="math">z = Com(x;\\rho_x)</span>, <span class="math">A_{g} = Com(k;\\rho_{k})</span>, <span class="math">A_{u} = u^{k}</span>.</li>

      <li>Verifier sends <span class="math">c \\stackrel{\\S}{\\leftarrow} [0, 2^{\\lambda}], \\ell \\stackrel{\\S}{\\leftarrow} \\text{Primes}(\\lambda)</span>.</li>

      <li>Prover computes <span class="math">s_x = k + c \\cdot x</span> and <span class="math">s_\\rho = \\rho_k + c \\cdot \\rho_x</span> and then derives quotients <span class="math">q_1, q_2 \\in \\mathbb{Z}</span> and residues <span class="math">r_x, r_\\rho \\in [\\ell]</span> such that <span class="math">q_x \\cdot \\ell + r_x = s_x</span> and <span class="math">q_\\rho \\cdot \\ell + r_\\rho = s_\\rho</span>.</li>

    </ol>

    <p class="text-gray-300">Prover sends <span class="math">Q_{g} = Com(q_{x};q_{\\rho})</span>, <span class="math">Q_{u} = u^{q_{x}}</span> and <span class="math">r_x, r_\\rho</span> to the Verifier.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier accepts if <span class="math">r_x, r_\\rho \\in [\\ell]</span> and</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">Q _ {g} ^ {\\ell} \\cdot C o m (r _ {x}; r _ {\\rho}) = A _ {g} z ^ {c} \\quad \\text{and} \\quad Q _ {u} ^ {\\ell} \\cdot u ^ {r _ {x}} = A _ {u} w ^ {c}.</span></div>

    <p class="text-gray-300">Theorem 11 (Protocol ZKPoKE). Protocol ZKPoKE is an honest verifier statistically zero-knowledge argument of knowledge for relation <span class="math">\\mathcal{R}_{\\text{PoKE}}</span> in the generic group model.</p>

    <p class="text-gray-300">Proof. See Appendix C.</p>

    <h2 id="sec-60" class="text-2xl font-bold">B More Accumulator techniques</h2>

    <h3 id="sec-61" class="text-xl font-semibold mt-8">B.1 Accumulator unions</h3>

    <p class="text-gray-300">Yet another application of our succinct proofs to accumulators is the ability to prove that an accumulator is the union of two other accumulators. Given three accumulators <span class="math">A_{1} = g_{1}^{\\prod_{s\\in S_{1}}s}</span>, <span class="math">A_{2} = g_{2}^{\\prod_{s\\in S_{2}}s}</span> and <span class="math">A_{3} = A_{3}^{\\prod_{s\\in S_{1}}s}</span> a prover can use the NI-PoDDH protocol to convince a verifier that <span class="math">(A_{1},A_{2},A_{3})</span> forms a valid DDH tuple. If <span class="math">S_{1}</span> and <span class="math">S_{2}</span> are guaranteed to be disjoint, then <span class="math">A_{3}</span> will be an accumulator of <span class="math">S_{1} \\cup S_{2}</span>. If they are not disjoint, then resulting accumulator will be an accumulator for a multi-set as described in the next paragraph. The NI-PoDDH is independent of the size of <span class="math">S_{1}</span> and <span class="math">S_{2}</span> in both the proof size and the verification time. This union proof can be used to batch exclusion proofs over multiple accumulators. The prover verifiably combines the accumulators and then creates a single aggregate non-membership proof in the union of the accumulators. This is sound but only works if the domains of the accumulators are separate.</p>

    <h3 id="sec-62" class="text-xl font-semibold mt-8">B.2 Multiset accumulator</h3>

    <p class="text-gray-300">A dynamic multiset accumulator is an accumulator where items can be added and deleted more than once, and every element has a count. In other words, it is a commitment to a mapping from items to non-negative integer counters. It has the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each element in the domain is implicitly in the mapping with a counter of 0.</li>

      <li>Add increments the counter of the added element by 1</li>

      <li>Del decrements the counter of the added element by 1</li>

      <li>A membership witness for an element <span class="math">x</span> and a counter <span class="math">k</span> proves that the counter of <span class="math">x</span> is at least <span class="math">k</span></li>

      <li>A membership witness for <span class="math">x^{k}</span> and a non-membership witness for <span class="math">A^{x^{-}k}</span> proves that the counter for <span class="math">x</span> is exactly <span class="math">k</span>. Note that <span class="math">A^{x^{-k}}</span> is exactly the membership witness for <span class="math">x^{k}</span>.</li>

    </ul>

    <p class="text-gray-300">35</p>

    <p class="text-gray-300">To build the multi-set accumulator we again employ a hash function mapping an arbitrary domain to an exponentially large set of primes. The Add and Del algorithms are as described in Section 4.2. The membership witness change in that they now also contain a counter of how many times a certain element has been added. That is if an element <span class="math">x</span> is <span class="math">k</span> times in the accumulator the membership witness is the <span class="math">x^{k}</span>th root of the accumulator as well as <span class="math">k</span>. VerMem, MemWitCreate, MemWitUpAdd, MemWitUpDel are changed accordingly. The completeness definition also needs to be updated to reflect the new multi-set functionalities.</p>

    <h2 id="sec-63" class="text-2xl font-bold">Appendix C Security Proofs</h2>

    <h3 id="sec-64" class="text-xl font-semibold mt-8">C.1 Preliminary lemmas</h3>

    <p class="text-gray-300">In the following lemmas, which all concern the generic group model, we restrict ourselves to adversaries that do not receive any group elements as input. This is sufficient to prove our theorems. For our proof protocols we require that the adversary itself outputs the instance after receiving a description of the group. We require this in order to prevent that the instance itself encodes a trapdoor, such as the order of the group.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Lemma 2 (Element representation <em>[x20]</em>).</h6>

    <p class="text-gray-300">Using the notation of Section 2.2, let <span class="math">\\mathbb{G}</span> be a generic group and <span class="math">\\mathcal{A}</span> a generic algorithm making <span class="math">q_{1}</span> queries to <span class="math">\\mathcal{O}_{1}</span> and <span class="math">q_{2}</span> queries to <span class="math">\\mathcal{O}_{2}</span>. Let <span class="math">\\{g_{1},\\ldots,g_{m}\\}</span> be the outputs of <span class="math">\\mathcal{O}_{1}</span>. There is an efficient algorithm Ext that given as input the transcript of <span class="math">\\mathcal{A}</span>’s interaction with the generic group oracles, produces for every element <span class="math">u\\in\\mathbb{G}</span> that <span class="math">\\mathcal{A}</span> outputs, a tuple <span class="math">(\\alpha_{1},\\ldots,\\alpha_{m})\\in\\mathbb{Z}^{m}</span> such that <span class="math">u=\\prod_{i=1}^{m}g_{i}^{\\alpha_{i}}</span> and <span class="math">\\alpha_{i}\\leq 2^{q+2}</span>.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Lemma 3 (Computing multiple of orders of random elements).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{G}</span> be a generic group where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is a uniformly chosen integer in </span>[A,B]<span class="math">. Let </span>\\mathcal{A}<span class="math"> be a generic algorithm making </span>q_{1}<span class="math"> queries to </span>\\mathcal{O}_{1}<span class="math"> and </span>q_{2}<span class="math"> queries to </span>\\mathcal{O}_{2}<span class="math">. The probability that </span>\\mathcal{A}<span class="math"> succeeds in computing </span>0\\neq k\\in\\mathbb{N}<span class="math"> such that for a </span>g<span class="math"> which is a response to an </span>\\mathcal{O}_{1}<span class="math"> query </span>g^{k}=1<span class="math"> is at most </span>\\frac{(q_{1}+q_{2})^{3}}{M}<span class="math">, where </span>1/M<span class="math"> is negligible whenever </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B-A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\exp(\\lambda)<span class="math">. When </span>\\mathcal{A}<span class="math"> succeeds we say that event </span>\\mathsf{Root}$ happened.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We denote <span class="math">\\mathrm{ord}_{\\mathbb{G}}(g)</span> as the order of <span class="math">g\\in\\mathbb{G}</span>. By definition <span class="math">g^{k}=1\\wedge 0\\neq k\\in\\mathbb{Z}\\leftrightarrow k\\bmod\\mathrm{ord}_{\\mathbb{G}}(g)=0</span>.</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This lemma is a direct corollary of Theorem 1 from <em>[x11]</em>. That theorem shows that an adversary that interacts with the two generic group oracles cannot solve the strong RSA problem with probability greater than <span class="math">(q_{1}+q_{2})^{3}/M</span>, where <span class="math">M</span> is as in the statement of the lemma. Recall that a strong RSA adversary takes as input a random <span class="math">g\\in\\mathbb{G}</span> and outputs <span class="math">(u,x)</span> where <span class="math">u^{x}=g</span> and <span class="math">x</span> is an odd prime. Let <span class="math">\\mathcal{A}</span> be an adversary from the statement of the lemma, that is, <span class="math">\\mathcal{A}</span> outputs <span class="math">0&lt;k\\in\\mathbb{Z}</span> where $k\\equiv 0\\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> with some probability </span>\\epsilon<span class="math">. This </span>\\mathcal{A}<span class="math"> immediately gives a strong RSA adversary that also succeeds with probability </span>\\epsilon<span class="math">: run </span>\\mathcal{A}<span class="math"> to get </span>k<span class="math"> and </span>g<span class="math"> such that </span>g^{k}=1\\in\\mathbb{G}<span class="math">. Then find an odd prime </span>x<span class="math"> that does not divide </span>k<span class="math">, and output </span>(u,x)<span class="math"> where </span>u=g^{(x^{-1}\\bmod k)}<span class="math">. Clearly </span>u^{x}=g<span class="math"> which is a solution to the given strong RSA challenge. It follows by Theorem 1 from <em>[x11]</em> that </span>\\epsilon\\leq(q_{1}+q_{2})^{3}/M$, as required. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-68" class="text-base font-medium mt-4">Lemma 4 (Discrete Logarithm).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{G}</span> be a generic group where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is a uniformly chosen integer in </span>[A,B]<span class="math">, where </span>1/A<span class="math"> and </span>1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B-A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> are negligible in </span>\\lambda<span class="math">. Let </span>\\mathcal{A}<span class="math"> be a generic algorithm and let </span>\\{g_{1},\\ldots,g_{m}\\}<span class="math"> be the outputs of </span>\\mathcal{O}_{1}<span class="math">. Then if </span>\\mathcal{A}<span class="math"> runs in polynomial time, it succeeds with at most negligible probability in outputting </span>\\alpha_{1},\\ldots,\\alpha_{m},\\beta_{1},\\ldots,\\beta_{m}\\in\\mathbb{Z}<span class="math"> such that </span>\\prod_{i=1}^{m}g_{i}^{\\alpha_{i}}=\\prod_{i=1}^{m}g_{i}^{\\beta_{i}}<span class="math"> and </span>\\alpha_{i}\\neq\\beta_{i}<span class="math"> for some </span>i<span class="math">. We call this event </span>\\mathsf{DLOG}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-69" class="text-base font-medium mt-4">Proof sketch.</h6>

    <p class="text-gray-300">We follow the structure of Shoup’s argument <em>[x20]</em>. By Lemma 2 every group element <span class="math">u\\in\\mathbb{G}</span> that the adversary obtains in response to an <span class="math">\\mathcal{O}_{2}</span> query can be written as <span class="math">u=\\prod_{i=1}^{m}g_{i}^{\\alpha_{i}}</span> for some known <span class="math">\\alpha_{i}\\in\\mathbb{Z}</span>. Let <span class="math">g=\\prod_{i=1}^{m}g_{i}^{\\alpha_{i}}</span> and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">h = \\prod_{i=1}^{m} g_i^{\\beta_i}</span> be two such group elements. If there is some <span class="math">i</span> for which <span class="math">\\alpha_i \\not\\equiv \\beta_i</span> (mod <span class="math">\\operatorname{ord}_{\\mathbb{G}}(g_i)</span>) then the probability that <span class="math">g = h</span> is at most negligible, as shown in [DK02]. Hence, if <span class="math">g = h</span> then with overwhelming probability we have that <span class="math">\\alpha_i \\equiv \\beta_i</span> (mod <span class="math">\\operatorname{ord}_{\\mathbb{G}}(g_i)</span>) for all <span class="math">i</span>. From this it follows by Lemma 3 that <span class="math">\\alpha_i = \\beta_i \\in \\mathbb{Z}</span> with overwhelming probability, since otherwise one obtains a multiple of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Since </span>\\mathcal{A}$ constructs at most polynomially many group elements, there are at most polynomially many pairs of such elements. Therefore, a union bound over all pairs shows that the probability that event DLOG happens is at most negligible, as required.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 5 (Dlog extraction). Let <span class="math">\\mathbb{G}</span> be a generic group where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is a uniformly chosen integer in </span>[A, B]<span class="math"> and </span>g<span class="math"> an output of a query to </span>\\mathcal{O}_1<span class="math">. Let </span>\\mathcal{A}<span class="math"> be a generic algorithm that outputs </span>w \\in \\mathbb{G}<span class="math"> and then runs the interactive protocol Protocol PoKE<em> with </span>g<span class="math"> in the CRS. Let </span>(\\ell_1, Q_1, r_1)<span class="math"> and </span>(\\ell_2, Q_2, r_2)<span class="math"> two accepting transcripts for Protocol PoKE</em> generated one after the other. If </span>1/A<span class="math"> and </span>1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B - A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> are negligible in </span>\\lambda<span class="math">, then with overwhelming probability there exist integers </span>\\alpha<span class="math"> and </span>\\beta<span class="math"> such that </span>\\alpha \\cdot l_1 + r_1 = \\beta \\cdot l_2 + r_2<span class="math"> and </span>g^{\\alpha \\cdot l_1 + r_1} = w<span class="math">. Further if </span>\\mathcal{A}<span class="math"> makes </span>q<span class="math"> queries to </span>\\mathcal{O}_2<span class="math"> then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> are bounded by </span>2^q$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. W.l.o.g. let <span class="math">g_1 = g</span> be encoded in the PoKE<em> CRS. The PoKE</em> verification equations give us <span class="math">w = Q_1^{\\ell_1} g^{r_1} = Q_2^{\\ell_2} g^{r_2}</span>. We can write <span class="math">Q_1 = \\prod_{i=1}^{m} g_i^{\\alpha_i}</span> and <span class="math">Q_2 = \\prod_{i=1}^{m} g_i^{\\beta_i}</span>. This implies that <span class="math">Q_1^{\\ell_1} g^{r_1} = g^{\\alpha_1 \\cdot \\ell_1 + r_1} \\prod_{i=2}^{m} g_i^{\\alpha_i \\cdot \\ell_1} = g^{\\beta_1 \\cdot \\ell_2 + r_2} \\prod_{i=2}^{m} g_i^{\\beta_i \\cdot \\ell_2}</span>. By Lemma 4, <span class="math">\\alpha_i \\ell_1 = \\beta_i \\ell_2 \\in \\mathbb{Z}</span> for all <span class="math">i \\neq 1</span> with overwhelming probability (i.e. unless event DLOG occurs), and therefore $\\ell_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_i \\ell_1<span class="math">. The primes </span>\\ell_1<span class="math"> and </span>\\ell_2<span class="math"> are co-prime unless </span>\\ell_1 = \\ell_2<span class="math">, which happens with probability </span>\\frac{\\ln(2) \\lambda}{2^q}<span class="math">. Thus, with overwhelming probability </span>\\ell_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_i<span class="math">. However, </span>\\alpha_i \\leq 2^{q_2}<span class="math"> and </span>\\alpha_i<span class="math"> is chosen before </span>\\ell_2<span class="math"> is sampled, hence the probability that </span>\\ell_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_i<span class="math"> for </span>\\alpha_i \\neq 0<span class="math"> is at most </span>\\frac{q_2 \\lambda \\ln(2)}{2^q}<span class="math">. We conclude that with overwhelming probability </span>\\alpha_i = \\beta_i = 0<span class="math"> for all </span>i \\neq 1<span class="math">. It follows that except with probability </span>\\operatorname{Pr}[\\mathsf{DLOG}] + \\frac{2 q_2 \\lambda \\ln(2)}{2^q}<span class="math">, we can express </span>w = g^{\\alpha_1 \\ell_1 + r_1} = g^{\\beta_1 \\ell_2 + r_2}<span class="math"> for integers </span>\\alpha_1, r_1, \\beta_1, r_2<span class="math"> such that </span>\\alpha_1 \\ell_1 + r_1 = \\beta_1 \\ell_2 + r_2$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In what follows we will use the following notation already introduced in Section 3: for generators <span class="math">g_1, \\ldots, g_n \\in \\mathbb{G}</span> we let <span class="math">Rep: \\mathbb{Z}^n \\to \\mathbb{G}</span> be the homomorphism</p>

    <div class="my-4 text-center"><span class="math-block">Rep(\\boldsymbol{x}) = \\prod_{i=1}^{n} g_i^{x_i}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 6 (Representation extraction). Let <span class="math">\\mathbb{G}</span> be a generic group where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is a uniformly chosen integer in </span>[A, B]<span class="math"> and let </span>g_1, \\ldots, g_n \\in \\mathbb{G}<span class="math"> be responses to queries to oracle </span>\\mathcal{O}_1<span class="math">. Let </span>\\mathcal{A}<span class="math"> be a generic algorithm that outputs </span>w \\in \\mathbb{G}<span class="math"> and then runs the interactive protocol Protocol PoKRep on input </span>w<span class="math"> with </span>g_1, \\ldots, g_n<span class="math"> in the CRS. Let </span>(\\ell_1, Q_1, \\mathbf{r}_1)<span class="math"> and </span>(\\ell_2, Q_2, \\mathbf{r}_2)<span class="math"> be two accepting transcripts for Protocol PoKRep. If </span>1/A<span class="math"> and </span>1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B - A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> are negligible in </span>\\lambda<span class="math">, then with overwhelming probability there exist integer vectors </span>\\alpha, \\beta \\in \\mathbb{Z}^n<span class="math"> such that </span>\\alpha l_1 + r_1 = \\beta l_2 + r_2<span class="math"> and </span>Rep(\\alpha l_1 + r_1) = w<span class="math">. Further if </span>\\mathcal{A}<span class="math"> makes </span>q<span class="math"> queries to </span>\\mathcal{O}_2<span class="math"> then each component </span>\\alpha_j<span class="math"> and </span>\\beta_j<span class="math"> of </span>\\alpha<span class="math"> and </span>\\beta<span class="math"> are bounded by </span>2^q$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. The proof is a direct generalization of the argument in Lemma 5 above. From the verification equations of the protocol we have <span class="math">Q_1^{\\ell_1}Rep(\\boldsymbol{r}_1) = Q_2^{\\ell_2}Rep(\\boldsymbol{r}_2) = w</span>. With overwhelming probability, the generic group adversary knows <span class="math">\\alpha_1, \\ldots, \\alpha_m</span> and <span class="math">\\beta_1, \\ldots, \\beta_m</span> for <span class="math">m &amp;gt; n</span> such that it can write <span class="math">Q_1 = \\prod_{i=1}^{m} g_i^{\\alpha_i}</span> and <span class="math">Q_2 = \\prod_{i=1}^{m} g_i^{\\beta_i}</span>. From the verification equation and Lemma 4, with overwhelming probability <span class="math">\\alpha_i \\ell_1 + r_1[i] = \\beta_i \\ell_2 + r_2[i]</span> for each <span class="math">i \\leq n</span> and <span class="math">\\alpha_i \\ell_1 = \\beta_i \\ell_2</span> for each <span class="math">i &amp;gt; n</span>. As explained in the proof of Lemma 5, this implies that with overwhelming probability <span class="math">\\alpha_i = \\beta_i = 0</span> for each <span class="math">i &amp;gt; n</span>, in which case <span class="math">w = \\prod_{i=1}^{n} g_i^{\\alpha_i \\ell_1 + r_1[i]} = \\prod_{i=1}^{n} g_i^{\\beta_i \\ell_2 + r_2[i]}</span>. Setting <span class="math">\\boldsymbol{\\alpha} := (\\alpha_1, \\ldots, \\alpha_n)</span> and <span class="math">\\boldsymbol{\\beta} := (\\beta_1, \\ldots, \\beta_n)</span>, we conclude that with overwhelming probability <span class="math">w = Rep(\\boldsymbol{\\alpha} \\ell_1 + \\boldsymbol{r}_1) = Rep(\\boldsymbol{\\beta} \\ell_2 + \\boldsymbol{r}_2)</span> and <span class="math">\\boldsymbol{\\alpha} \\ell_1 + \\boldsymbol{r}_1 = \\boldsymbol{\\alpha} \\ell_2 + \\boldsymbol{r}_2</span>. Finally, if <span class="math">\\mathcal{A}</span> has made at most <span class="math">q</span> queries to <span class="math">\\mathcal{O}_2</span> then <span class="math">\\alpha_i &amp;lt; 2^q</span> and <span class="math">\\beta_i &amp;lt; 2^q</span> for each <span class="math">i</span>.</p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">The next two corollaries show that the adaptive root problem and the known order element problem are intractable in a generic group.</p>

    <p class="text-gray-300">37</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Corollary 1 (Adaptive root hardness). Let <span class="math">\\mathbb{G}</span> be a generic group where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is a uniformly chosen integer in </span>[A,B]<span class="math"> such that </span>1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B - A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> are negligible in </span>\\lambda<span class="math">. Any generic adversary </span>\\mathcal{A}<span class="math"> that performs a polynomial number of queries to oracle </span>\\mathcal{O}_2<span class="math"> succeeds in breaking the adaptive root assumption on </span>\\mathbb{G}<span class="math"> with at most negligible probability in </span>\\lambda$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Recall that in the adaptive root game the adversary outputs <span class="math">w \\in \\mathbb{G}</span>, the challenger then responds with a prime <span class="math">\\ell \\in [2, 2^{\\lambda}]</span>, and the adversary succeeds if it outputs <span class="math">u</span> such that <span class="math">u^{\\ell} = w</span>. According to Lemma 2 we can write <span class="math">u = \\prod_{i=1}^{m} g_i^{\\alpha_i}</span> and <span class="math">w = \\prod_{i=1}^{m} g_i^{\\beta_i}</span>, where <span class="math">g_1, \\ldots, g_m</span> are the responses to oracle <span class="math">\\mathcal{O}_1</span> queries. By Lemma 4 we know that $\\alpha_i \\ell = \\beta_i \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for all </span>i = 1, \\ldots, m<span class="math"> with overwhelming probability, namely </span>1 - \\operatorname{Pr}[\\mathrm{DLOG}]<span class="math">. Therefore, </span>\\alpha_i \\ell = \\beta_i + k \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for some </span>k \\in \\mathbb{Z}<span class="math">. By Lemma 3, an efficient adversary can compute a multiple of the order of the group with at most negligible probability </span>\\operatorname{Pr}[\\mathrm{Root}]<span class="math">. It follows that </span>k = 0<span class="math"> and </span>\\alpha_i \\ell = \\beta_i \\in \\mathbb{Z}<span class="math"> with probability greater than </span>1 - \\operatorname{Pr}[\\mathrm{DLOG}] - \\operatorname{Pr}[\\mathrm{Root}]<span class="math">, since otherwise </span>\\alpha_i \\ell - \\beta_i<span class="math"> is a multiple of </span>\\mathbb{G}<span class="math">. Now, because </span>\\alpha_i \\ell = \\beta_i<span class="math"> we know that </span>\\ell<span class="math"> must divide </span>\\beta_i<span class="math">. However, </span>\\beta_i<span class="math"> is chosen before </span>\\ell<span class="math"> and if </span>\\mathcal{A}<span class="math"> makes </span>q_2<span class="math"> generic group queries then </span>\\beta_i \\leq 2^{q_2}<span class="math">. The probability that </span>\\ell<span class="math"> divides </span>\\beta_i<span class="math">, for </span>\\beta_i \\neq 0<span class="math">, is bounded by the probability that a random prime in </span>\\mathrm{Primes}(\\lambda)<span class="math"> divides a number less than </span>2^{q_2}<span class="math">. Any such number has less than </span>q_2<span class="math"> distinct prime factors and there are more than </span>2^{\\lambda} / \\lambda<span class="math"> primes in </span>\\mathrm{Primes}(\\lambda)<span class="math">. Therefore, the probability that </span>\\ell<span class="math"> divides </span>\\beta_i \\neq 0<span class="math"> is at most </span>\\frac{q_2 \\cdot \\lambda}{2^{\\lambda}}<span class="math">. Overall, we obtain that a generic adversary can break the adaptive root assumption with probability at most </span>\\frac{(q_1 + q_2)^2}{A} + 2 \\cdot \\frac{(q_1 + q_2)^2}{2\\ell} + \\frac{q_2 \\cdot \\lambda}{2^{\\lambda}}<span class="math">, which is negligible if </span>A<span class="math"> and </span>B - A<span class="math"> are exponential in </span>\\lambda<span class="math"> and </span>q_1, q_2<span class="math"> are bounded by some polynomial in </span>\\lambda$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Corollary 2 (Non-trivial order hardness). Let <span class="math">\\mathbb{G}</span> be a generic group where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is a uniformly chosen integer in </span>[A, B]<span class="math"> such that </span>1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B - A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> are negligible in </span>\\lambda<span class="math">. Any generic adversary </span>\\mathcal{A}<span class="math"> that performs a polynomial number of queries to oracle </span>\\mathcal{O}_2<span class="math"> succeeds in finding an element </span>h \\neq 1 \\in \\mathbb{G}<span class="math"> and an integer </span>d<span class="math"> such that </span>h^d = 1<span class="math"> with at most negligible probability in </span>\\lambda$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. We can construct an adaptive root adversary that first uses <span class="math">\\mathcal{A}</span> to obtain <span class="math">h</span> and <span class="math">d</span>, and then computes the <span class="math">\\ell</span>th root of <span class="math">h</span> by computing <span class="math">c = \\ell^{-1} \\bmod d</span> and <span class="math">h^c = h^{1/\\ell}</span>. Since the adaptive root assumption holds true in the generic group model (Corollary 1), we can conclude that <span class="math">\\mathcal{A}</span> succeeds with negligible probability.</p>

    <p class="text-gray-300">Fact 1 (Chinese Remainder Theorem (CRT)). Let <span class="math">\\ell_1, \\ldots, \\ell_n</span> be coprime integers and let <span class="math">r_1, \\ldots, r_n \\in \\mathbb{Z}</span>, then there exists a unique <span class="math">0 \\leq x &amp;lt; \\prod_{i=1}^{n} \\ell_i</span> such that <span class="math">x = r_i \\bmod \\ell_i</span> and there is an efficient algorithm for computing <span class="math">x</span>.</p>

    <h2 id="sec-70" class="text-2xl font-bold">C.2 Proofs of the main theorems</h2>

    <h3 id="sec-71" class="text-xl font-semibold mt-8">Proof of Theorem 7.</h3>

    <p class="text-gray-300">Protocol PoKRep is an argument of knowledge for the relation <span class="math">\\mathcal{R}_{\\phi}</span> where <span class="math">\\phi := \\text{Rep}</span>, in the generic group model.</p>

    <p class="text-gray-300">Fix <span class="math">\\mathbb{G} \\stackrel{\\S}{\\leftarrow} GGen(\\lambda)</span> and <span class="math">\\mathbf{g} = (g_1, \\dots, g_n) \\in \\mathbb{G}</span>. Let <span class="math">\\mathcal{A}_0, \\mathcal{A}_1</span> be poly-time generic adversaries where <span class="math">(w, \\text{state}) \\stackrel{\\S}{\\leftarrow} A_0(\\mathbf{g})</span> and <span class="math">\\mathcal{A}_1(\\text{state})</span> runs Protocol PoKRep with a verifier <span class="math">V(\\mathbf{g}, w)</span>. We need to show that for all <span class="math">\\mathcal{A}_1</span> there exists a poly-time Ext such that for all <span class="math">\\mathcal{A}_0</span> the following holds: if <span class="math">\\mathcal{A}_1</span> convinces <span class="math">V(\\mathbf{g}, w)</span> to accept with probability <span class="math">\\epsilon \\geq 1 / \\text{poly}(\\lambda)</span>, then Ext outputs a vector <span class="math">\\boldsymbol{x} \\in \\mathbb{Z}^n</span> such that <span class="math">\\text{Rep}(\\boldsymbol{x}) = w</span> with overwhelming probability.</p>

    <p class="text-gray-300">Subclaim In Protocol PoKRep, for any polynomial number of accepting transcripts <span class="math">\\{(\\ell_i, Q_i, \\boldsymbol{r}_i)\\}_{i=1}^{\\text{poly}(\\lambda)}</span> obtained by rewinding <span class="math">\\mathcal{A}_1</span> on the same input <span class="math">(w, \\text{state})</span>, with overwhelming probability there exists <span class="math">\\boldsymbol{x} \\in \\mathbb{Z}^n</span> such that <span class="math">\\boldsymbol{x} = \\boldsymbol{r}_i \\bmod \\ell_i</span> for each <span class="math">i</span> and <span class="math">\\text{Rep}(\\boldsymbol{x}) = w</span>. Furthermore, <span class="math">x_j \\leq 2^q</span> for each <span class="math">j</span>th component <span class="math">x_j</span> of <span class="math">\\boldsymbol{x}</span>, where <span class="math">q</span> is the total number of queries that <span class="math">\\mathcal{A}</span> makes to the group oracle.</p>

    <p class="text-gray-300">38</p>

    <p class="text-gray-300">The subclaim follows from Lemma 6. With overwhelming probability there exists <span class="math">\\alpha, \\beta</span>, and <span class="math">\\pmb{x}</span> in <span class="math">\\mathbb{Z}^n</span> such that <span class="math">\\pmb{x} = \\pmb{\\alpha}\\ell_1 + \\pmb{r}_1 = \\beta\\ell_2 + \\pmb{r}_2</span> and <span class="math">Rep(\\pmb{x}) = w</span>, and each component of <span class="math">\\pmb{x}</span> is bounded by <span class="math">2^q</span>. Consider any third transcript, w.l.o.g. <span class="math">(\\ell_3, Q_3, \\pmb{r}_3)</span>. Invoking the lemma again, there exists <span class="math">\\pmb{\\alpha}&#x27;</span>, <span class="math">\\pmb{\\beta}&#x27;</span>, and <span class="math">\\pmb{x}&#x27;</span> such that <span class="math">\\pmb{x}&#x27; = \\pmb{\\alpha}&#x27;\\ell_2 + \\pmb{r}_2 = \\pmb{\\beta}&#x27;\\ell_3 + \\pmb{r}_3</span>. Thus, with overwhelming probability, <span class="math">\\pmb{x}&#x27; - \\pmb{x} = (\\pmb{\\alpha}&#x27; - \\pmb{\\beta})\\ell_2</span>. However, since <span class="math">\\ell_2</span> is sampled randomly from an exponentially large set of primes independently from <span class="math">\\pmb{r}_1, \\pmb{r}_3, \\ell_1</span>, and <span class="math">\\ell_3</span> (which fix the value of <span class="math">\\pmb{x}&#x27; - \\pmb{x}</span>) there is a negligible probability that <span class="math">\\pmb{x}&#x27; - \\pmb{x} \\equiv 0 \\pmod{\\ell_2}</span>, unless <span class="math">\\pmb{x}&#x27; = \\pmb{x}</span>. By a simple union bound over the poly(λ) number of transcripts, there exists a single <span class="math">\\pmb{x}</span> such that <span class="math">\\pmb{x} = \\pmb{r}_i \\bmod \\ell_i</span> for all <span class="math">i</span>.</p>

    <p class="text-gray-300">To complete the proof of Theorem 7 we describe the extractor Ext:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>run <span class="math">\\mathcal{A}_0</span> to get output <span class="math">(w, \\text{state})</span></li>

      <li>let <span class="math">R\\gets \\{\\}</span></li>

      <li>run Protocol PoKRep with <span class="math">\\mathcal{A}_1</span> on input <span class="math">(w, \\text{state})</span>, sampling fresh randomness for the verifier</li>

      <li>if the transcript <span class="math">(\\ell, Q, \\boldsymbol{r})</span> is accepting set <span class="math">R \\gets R \\cup \\{(\\boldsymbol{r}, \\ell)\\}</span>, and otherwise return to Step 3</li>

      <li>use the CRT algorithm to compute <span class="math">\\pmb{x}</span> such that <span class="math">\\pmb{x} = \\pmb{r}_i \\bmod \\ell_i</span> for each <span class="math">(\\pmb{r}_i, \\ell_i) \\in R</span></li>

      <li>if <span class="math">Rep(\\pmb{x}) = w</span> output <span class="math">\\pmb{x}</span> and stop</li>

      <li>return to Step 3</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It remains to argue that Ext succeeds with overwhelming probability in a poly(λ) number of rounds. Suppose that after some polynomial number of rounds the extractor has obtained <span class="math">M</span> accepting transcripts <span class="math">\\{\\ell_i, Q_i, \\pmb{r}_i\\}</span> for independent values of <span class="math">\\ell_i \\in \\mathsf{Primes}(\\lambda)</span>. By the subclaim above, with overwhelming probability there exists <span class="math">\\pmb{x} \\in \\mathbb{Z}^n</span> such that <span class="math">\\pmb{x} = \\pmb{r}_i \\bmod \\ell_i</span> and <span class="math">Rep(\\pmb{x}) = w</span> and <span class="math">x_j &amp;lt; 2^q</span> for each component of <span class="math">\\pmb{x}</span>. Hence, the CRT algorithm used in Step 5 will recover the required vector <span class="math">\\pmb{x}</span> once $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; q$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since a single round of interaction with <span class="math">\\mathcal{A}_1</span> results in an accepting transcript with probability <span class="math">\\epsilon \\geq 1 / \\mathrm{poly}(\\lambda)</span>, in expectation the extractor obtains $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; q<span class="math"> accepting transcripts for independent primes </span>\\ell_i<span class="math"> after </span>q \\cdot \\mathrm{poly}(\\lambda)<span class="math"> rounds. Hence, Ext outputs a vector </span>\\pmb{x}<span class="math"> such that </span>Rep(\\pmb{x}) = w$ in expected polynomial time, as required.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-72" class="text-2xl font-bold">Proof of Theorem 3.</h2>

    <p class="text-gray-300">Protocol PoKE and Protocol PoKE2 are arguments of knowledge for relation <span class="math">\\mathcal{R}_{\\mathrm{PoKE}}</span> in the generic group model.</p>

    <p class="text-gray-300">Fix <span class="math">\\mathbb{G} \\stackrel{\\S}{\\leftarrow} GGen(\\lambda)</span> and <span class="math">g \\in \\mathbb{G}</span>. Let <span class="math">\\mathcal{A}_0, \\mathcal{A}_1</span> be poly-time adversaries where <span class="math">(u, w, \\text{state}) \\stackrel{\\S}{\\leftarrow} \\mathcal{A}_0(g)</span> and <span class="math">\\mathcal{A}_1</span> runs Protocol PoKE or Protocol PoKE2 with the verifier <span class="math">\\mathsf{V}(g, u, w)</span>. We need to show that for all <span class="math">\\mathcal{A}_1</span> there exists a poly-time Ext such that for all <span class="math">\\mathcal{A}_0</span> the following holds: if <span class="math">\\mathsf{V}(g, u, w)</span> outputs 1 with non-negligible probability on interaction with <span class="math">\\mathcal{A}_1(g, u, w, \\text{state})</span> then Ext outputs an integer <span class="math">x</span> such that <span class="math">u^x = w</span> in <span class="math">\\mathbb{G}</span> with overwhelming probability.</p>

    <p class="text-gray-300">Proof for Protocol PoKE. Protocol PoKE includes an execution of Protocol <span class="math">\\mathsf{PoKE}^<em></span> on <span class="math">g \\in \\mathbb{G}</span> and input <span class="math">z</span> (the first message sent by the prover to the verifier), and the prover succeeds in Protocol PoKE only if it succeeds in this subprotocol for Protocol <span class="math">\\mathsf{PoKE}^</em></span>. Since Protocol <span class="math">\\mathsf{PoKE}^<em></span> is a special case of Protocol PoKRep, by Theorem 7 there exists <span class="math">\\mathsf{Ext}^</em></span> for <span class="math">\\mathcal{A}_1</span> that outputs <span class="math">x^<em> \\in \\mathbb{Z}</span> such that <span class="math">g^{(x^</em>)} = z</span>. Furthermore, as already shown in the analysis of Theorem 7, once <span class="math">\\mathsf{Ext}^<em></span> has obtained <span class="math">x^</em></span> it can continue to replay the protocol, sampling a fresh prime <span class="math">\\ell \\stackrel{\\S}{\\leftarrow} \\mathsf{Primes}(\\lambda)</span>, and in each fresh round that produces an accepting transcript it obtains from the Prover a triple <span class="math">(Q, Q&#x27;, r)</span> such that <span class="math">r = x^<em> \\bmod \\ell</span> with overwhelming probability. This is due to the fact that the adversary outputs <span class="math">Q&#x27;</span> such that <span class="math">Q&#x27;^q g^r = z = g^{x^</em>}</span>, and the generic group adversary can write <span class="math">Q&#x27; = g^q \\prod_{i &amp;gt; 1} g_i^{q_i}</span> (Lemma 2) such that <span class="math">q\\ell + r = x^*</span> with overwhelming probability (Lemma 4).</p>

    <p class="text-gray-300">The extractor <span class="math">\\mathsf{Ext}</span> will simply run <span class="math">\\mathsf{Ext}^<em></span> to obtain <span class="math">x^</em></span>. Now we will show that either <span class="math">u^{x^<em>} = w</span>, i.e. <span class="math">\\mathsf{Ext}^</em></span> extracted a valid witness, or otherwise the adaptive root assumption would be broken, which is impossible in the generic group model (Corollary 1). To see this, we construct an adaptive root adversary <span class="math">\\mathcal{A}_{AR}</span> that first runs <span class="math">\\mathsf{Ext}^<em></span> with <span class="math">\\mathcal{A}_0, \\mathcal{A}_1</span> to obtain <span class="math">x^</em></span> and provides <span class="math">h = w / u^{x^<em>} \\in \\mathbb{G}</span> to the challenger. When provided with <span class="math">\\ell \\stackrel{\\</span>}{\\leftarrow} \\mathsf{Primes}(\\lambda)<span class="math"> from the challenger, </span>\\mathcal{A}_{AR}<span class="math"> rewinds </span>\\mathcal{A}_1<span class="math">, passes </span>\\ell<span class="math"> to </span>\\mathcal{A}_1<span class="math">, and with overwhelming probability obtains </span>Q, r<span class="math"> such that </span>x^</em> = r \\bmod \\ell<span class="math"> and </span>Q^\\ell u^r = w<span class="math">. Finally, </span>\\mathcal{A}_{AR}<span class="math"> outputs </span>v = \\frac{Q}{u^{\\lfloor\\frac{2\\lambda}{T}\\rfloor}}<span class="math">, which is an </span>\\ell<span class="math">th root of </span>h$:</p>

    <div class="my-4 text-center"><span class="math-block">v^{\\ell} = \\left(\\frac{Q}{u^{\\lfloor \\frac{2\\lambda}{T}\\rfloor}}\\right)^{\\ell} = \\left(\\frac{Q}{u^{\\lfloor \\frac{r^{\\ell}}{T}\\rfloor}}\\right)^{\\ell} \\frac{u^{r}}{u^{r}} = \\frac{w}{u^{x^{*}}} = h</span></div>

    <p class="text-gray-300">If <span class="math">w \\neq u^{x^<em>}</span> so that <span class="math">h \\neq 1</span>, then <span class="math">\\mathcal{A}_{AR}</span> succeeds in the adaptive root game. In conclusion, the value <span class="math">x^</em></span> output by <span class="math">\\mathsf{Ext}</span> satisfies <span class="math">w = u^{x^*}</span> with overwhelming probability.</p>

    <h2 id="sec-73" class="text-2xl font-bold">Proof for protocol PoKE2</h2>

    <p class="text-gray-300">Showing that Protocol PoKE2 requires a fresh argument (similar to the analysis in Theorem 7) since the protocol no longer directly contains Protocol PoKE* as a subprotocol. Ext first obtains <span class="math">u, w</span> from <span class="math">\\mathcal{A}_0</span> and runs the first two steps of Protocol PoKE2 with <span class="math">\\mathcal{A}_1</span> playing the role of the verifier, sampling <span class="math">g \\stackrel{\\</span>}{\\leftarrow} \\mathbb{G}<span class="math"> and receiving </span>z \\in \\mathbb{G}<span class="math"> from </span>\\mathcal{A}_1$. Ext is a simple modification of the extractor for Protocol PoKE:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">R \\gets \\{\\}</span> and sample <span class="math">\\alpha \\stackrel{\\</span>}{\\leftarrow} [0, 2^{\\lambda}]$.</li>

      <li>Sample <span class="math">\\ell \\stackrel{\\</span>}{\\leftarrow} \\mathsf{Primes}(\\lambda)<span class="math"> and send </span>\\alpha, \\ell<span class="math"> to </span>\\mathcal{A}_1$.</li>

      <li>Obtain output <span class="math">Q, r</span> from <span class="math">\\mathcal{A}_0</span>. If <span class="math">Q^\\ell u^r g^{\\alpha r} = wz^\\alpha</span> (i.e. the transcript is accepting) then update <span class="math">R \\gets R \\cup \\{(r, \\ell)\\}</span>. Otherwise return to step 2.</li>

      <li>Use CRT to compute <span class="math">x = r_i \\mod \\ell_i</span> for each <span class="math">(r_i, \\ell_i) \\in R</span>. If <span class="math">u^x = w</span> then output <span class="math">x</span>, otherwise return to step 2.</li>

    </ol>

    <p class="text-gray-300">Note that the extractor samples a fresh prime challenge <span class="math">\\ell</span> each time it rewinds the adversary but keeps the challenge <span class="math">\\alpha</span> fixed each time. Since these are independently sampled in the real protocol, keeping <span class="math">\\alpha</span> fixed while sampling a fresh prime does not change the output distribution of the adversary. This subtle point of the rewinding strategy is important.</p>

    <p class="text-gray-300">There is a negligible probability that the random <span class="math">g</span> sampled by the extractor was contained in the group oracle queries from <span class="math">\\mathcal{A}_0</span> to <span class="math">\\mathcal{O}_1</span>. Thus, by Lemma 2, <span class="math">\\mathcal{A}_0</span> knows representations <span class="math">w = \\prod_{i} g_i^{\\omega_i}</span> and <span class="math">u = \\prod_{i} g_i^{\\mu_i}</span> such that <span class="math">g_i \\neq g</span> for all <span class="math">i</span>. <span class="math">\\mathcal{A}_0</span> also knows a representation <span class="math">z = g^{\\zeta} \\prod_{i} g_i^{\\zeta_i}</span> and for each <span class="math">Q</span> obtained <span class="math">\\mathcal{A}_0</span> knows a representation <span class="math">Q = g^q \\prod_{i} g_i^{q_i}</span>, which it can pass in state to <span class="math">\\mathcal{A}_1</span>. If <span class="math">Q^\\ell u^r g^{\\alpha r} = wz^\\alpha</span>, then <span class="math">\\mathcal{A}_1</span> obtains an equation <span class="math">g^{q\\ell + \\alpha r} \\prod_{i} g_i^{q_i \\ell + \\mu_i r} = g^{\\zeta \\alpha} \\prod_{i} g_i^{\\zeta_i \\alpha + \\omega_i}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By Lemma 4, with overwhelming probability <span class="math">q\\ell + \\alpha r = \\zeta \\alpha</span>, which implies $\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q\\ell<span class="math">. Since </span>gcd(\\alpha, \\ell) = 1<span class="math"> with overwhelming probability, it follows that </span>\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q<span class="math"> and setting </span>a = q / \\alpha<span class="math"> shows that </span>\\zeta = a\\ell + r<span class="math">, i.e. </span>\\zeta = r \\bmod \\ell<span class="math">. Also for the same reasoning </span>q_i \\ell + \\mu_i r = \\zeta_i \\alpha + \\omega_i<span class="math"> with overwhelming probability. Repeating the argument for a different </span>\\ell'<span class="math"> sampled by the extractor yields a similar equation </span>\\zeta = a' \\ell' + r'<span class="math">, hence </span>a\\ell + r = a' \\ell' + r'<span class="math"> for some </span>a' = q' / \\alpha<span class="math">. Also </span>q_i \\ell + \\mu_i r - \\zeta_i \\alpha = q_i' \\ell' + \\mu_i r' - \\zeta_i \\alpha<span class="math">. Substituting for </span>r<span class="math"> and </span>r'<span class="math"> gives </span>q_i \\ell + \\mu_i (\\zeta - a\\ell) = q_i' \\ell' + \\mu_i (\\zeta - a' \\ell')$ implying:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">(q_i - \\mu_i a) \\ell = (q_i&#x27; - \\mu_i a&#x27;) \\ell&#x27;</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(This is where it was important that <span class="math">\\alpha</span> is fixed by the extractor, as otherwise we could not cancel the <span class="math">\\zeta_i \\alpha</span> term on each side of the equation). Now since <span class="math">\\ell \\neq \\ell&#x27; \\neq 0</span> with overwhelming probability, it follows that $\\ell</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q_i' - \\mu_i a'<span class="math"> and </span>\\ell'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q_i - \\mu_i a<span class="math">. However, </span>q_i - \\mu_i a<span class="math"> was fixed independently before </span>\\ell'<span class="math"> was sampled, hence there is a negligible probability that it has </span>\\ell'<span class="math"> as a factor unless </span>q_i - \\mu_i a = 0<span class="math">, in which case </span>q_i' - \\mu_i a' = 0<span class="math"> as well. We conclude that with overwhelming probability </span>q_i \\ell + \\mu_i r = q_i' \\ell' + \\mu_i r' = 0$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mu_{i}\\zeta</span>. In other words, for each <span class="math">\\ell</span> sampled, as long as <span class="math">Q^{\\ell}u^{r}g^{\\alpha r}=wz^{\\alpha}</span> then with overwhelming probability:</p>

    <p class="text-gray-300"><span class="math">wz^{\\alpha}=g^{q\\ell+\\alpha r}\\prod_{i}g_{i}^{q_{i}\\ell+\\mu_{i}r}=g^{\\zeta\\alpha}\\prod_{i}g_{i}^{\\mu_{i}\\zeta}=g^{\\zeta\\alpha}u^{\\zeta}</span></p>

    <p class="text-gray-300">Finally, if <span class="math">u^{\\zeta}\\neq w</span> then <span class="math">g^{\\zeta}/z\\neq 1</span> and yet <span class="math">(g^{\\zeta}/z)^{\\alpha}=u^{\\zeta}/w</span>. Since <span class="math">\\alpha</span> is sampled independently from <span class="math">u,w,g</span>, and <span class="math">\\zeta</span>, this relation can only hold true with non-negligible probability over the choice of <span class="math">\\alpha</span> if both <span class="math">g^{\\zeta}/z</span> and <span class="math">u^{\\zeta}/w</span> are elements of a small (i.e. <span class="math">\\mathsf{poly}(\\lambda)</span> size) subgroup generated by <span class="math">g^{\\zeta}/z</span>. In other words, <span class="math">g^{\\zeta}/z</span> is an element of low order, and it is possible to compute its order in polynomial time. This would be a contradiction in the generic group model since it is hard to find a non-trivial element and its order (Corollary 2). In conclusion, with overwhelming probability <span class="math">u^{\\zeta}=w</span>.</p>

    <p class="text-gray-300">Repeating this analysis for each accepting transcript <span class="math">(\\ell_{i},Q_{i},r_{i})</span> shows that <span class="math">\\zeta=r_{i}\\bmod\\ell_{i}</span> with overwhelming probability. The remainder of the analysis is identical to the last part of the proof of Theorem 7. Namely, since <span class="math">\\zeta&lt;2^{q}</span> where <span class="math">q&lt;\\mathsf{poly}(\\lambda)</span> is an upper bound on the number of queries the adversary makes to the group oracle, we can show there exists a polynomial number of rounds after which <span class="math">\\mathsf{Ext}</span> would succeed in extracting <span class="math">\\zeta</span> with overwhelming probability.</p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Proof of Theorem 8.</h6>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>For any homomorphism <span class="math">\\phi:\\mathbb{Z}^{n}\\to\\mathbb{G}</span>, <span class="math">\\mathsf{Protocol\\ PoKHP}</span> for relation <span class="math">\\mathcal{R}_{\\phi}=\\{(w;\\bm{x}):\\phi(\\bm{x})=w\\}</span> is an argument of knowledge in the generic group model.</p>
    </blockquote>

    <p class="text-gray-300">The proof is a direct generalization of the proof of Theorem 3 for <span class="math">\\mathsf{Protocol\\ PoKE}</span>. As usual, fix <span class="math">\\mathbb{G}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}GGen(\\lambda)<span class="math"> and </span>\\mathbf{g}=(g_{1},...,g_{n})\\in\\mathbb{G}<span class="math">. Let </span>\\mathcal{A}_{0},\\mathcal{A}_{1}<span class="math"> be poly-time generic adversaries where </span>(w,\\mathsf{state})\\stackrel{{\\scriptstyle\\<span class="math">}}{{\\leftarrow}}A_{0}(\\mathbf{g})</span> and <span class="math">\\mathcal{A}_{1}(\\mathsf{state})</span> runs <span class="math">\\mathsf{Protocol\\ PoKHP}</span> with the verifier <span class="math">V(\\mathbf{g},w)</span>. We need to show that for all <span class="math">\\mathcal{A}_{1}</span> there exists a poly-time <span class="math">\\mathsf{Ext}</span> such that for all <span class="math">\\mathcal{A}_{0}</span> the following holds: if <span class="math">\\mathcal{A}_{1}</span> convinces <span class="math">V(\\mathbf{g},w)</span> to accept with probability at least <span class="math">1/\\mathrm{poly}(\\lambda)</span> then <span class="math">\\mathsf{Ext}</span> outputs <span class="math">\\bm{x}\\in\\mathbb{Z}^{n}</span> such that <span class="math">\\phi(\\bm{x})=w</span> with overwhelming probability.</p>

    <p class="text-gray-300">Protocol <span class="math">\\mathsf{PoKHP}</span> includes an execution of <span class="math">\\mathsf{Protocol\\ PoKRep}</span> on <span class="math">g_{1},...,g_{n}\\in\\mathbb{G}</span> and input <span class="math">z</span> (the first message sent by the prover to the verifier), and the prover succeeds in <span class="math">\\mathsf{Protocol\\ PoKHP}</span> only if it succeeds in this subprotocol for <span class="math">\\mathsf{Protocol\\ PoKRep}</span>. By Theorem 7 there exists <span class="math">\\mathsf{Ext}^{<em>}</span> for each <span class="math">\\mathcal{A}_{1}</span> that outputs <span class="math">\\bm{x}^{</em>}</span> such that <span class="math">Rep(\\bm{x}^{<em>})=z</span>. Furthermore, as shown in the analysis of Theorem 7, once <span class="math">\\mathsf{Ext}^{</em>}</span> has obtained <span class="math">\\bm{x}^{<em>}</span> it can continue to replay the protocol, sampling a fresh prime <span class="math">\\ell\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathsf{Primes}(\\lambda)<span class="math">, and in each fresh round that produces an accepting transcript it obtains from the Prover values </span>Q,Q^{\\prime}<span class="math"> and </span>\\bm{r}<span class="math"> such that </span>\\bm{r}=x^{</em>}\\bmod\\ell$ with overwhelming probability.</p>

    <p class="text-gray-300">The extractor <span class="math">\\mathsf{Ext}</span> simply runs <span class="math">\\mathsf{Ext}^{<em>}</span> to obtain <span class="math">\\bm{x}^{</em>}</span>. Now we will show that either <span class="math">\\phi(\\bm{x}^{<em>})=w</span>, i.e. <span class="math">\\mathsf{Ext}^{</em>}</span> extracted a valid witness, or otherwise the adaptive root assumption would be broken, which is impossible in the generic group model (Corollary 1). To see this, we construct an adaptive root adversary <span class="math">\\mathcal{A}_{AR}</span> that first runs <span class="math">\\mathsf{Ext}^{<em>}</span> with <span class="math">\\mathcal{A}_{0},\\mathcal{A}_{1}</span> to obtain <span class="math">\\bm{x}^{</em>}</span> and provides <span class="math">h=w/\\phi(\\bm{x}^{<em>})\\in\\mathbb{G}</span> to the challenger. When provided with <span class="math">\\ell\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathsf{Primes}(\\lambda)<span class="math"> from the challenger, </span>\\mathcal{A}_{AR}<span class="math"> rewinds </span>\\mathcal{A}_{1}<span class="math">, passes </span>\\ell<span class="math"> to </span>\\mathcal{A}_{1}<span class="math">, and with overwhelming probability obtains </span>Q,\\bm{r}<span class="math"> such that </span>\\bm{x}^{</em>}=\\bm{r}\\bmod\\ell<span class="math"> and </span>Q^{\\ell}\\phi(\\bm{r})=w<span class="math">. Finally, define </span>\\lfloor\\bm{x}^{<em>}/\\ell\\rfloor<span class="math"> to be the vector obtained by replacing each component </span>x_{i}<span class="math"> with the quotient </span>\\lfloor x_{i}/\\ell\\rfloor<span class="math">. </span>\\mathcal{A}_{AR}<span class="math"> outputs </span>v=\\frac{Q}{\\phi(\\lfloor\\bm{x}^{</em>}/\\ell\\rfloor)}<span class="math">. Using the fact that </span>\\phi<span class="math"> is a group homomorphism we can show that this is an </span>\\ell<span class="math">th root of </span>h$:</p>

    <p class="text-gray-300"><span class="math">v^{\\ell}=\\big{(}\\frac{Q}{\\phi(\\lfloor\\frac{\\bm{x}^{<em>}}{\\ell}\\rfloor)}\\big{)}^{\\ell}=\\frac{Q^{\\ell}}{\\phi(\\ell\\cdot\\lfloor\\frac{\\bm{x}^{</em>}}{\\ell}\\rfloor)}=\\frac{Q^{\\ell}}{\\phi(\\bm{x}^{<em>}-\\bm{r})}\\frac{\\phi(\\bm{r})}{\\phi(\\bm{r})}=\\frac{w}{\\phi(\\bm{x}^{</em>})}=h</span></p>

    <p class="text-gray-300">If <span class="math">w\\neq\\phi(\\bm{x}^{<em>})</span> so that <span class="math">h\\neq 1</span>, then <span class="math">\\mathcal{A}_{AR}</span> succeeds in the adaptive root game. In conclusion, the value <span class="math">\\bm{x}^{</em>}</span> output by <span class="math">\\mathsf{Ext}</span> satisfies <span class="math">w=\\phi(\\bm{x}^{*})</span> with overwhelming probability.</p>

    <p class="text-gray-300">Proof of Theorem 10.</p>

    <p class="text-gray-300">Protocol ZKPoKRep is an honest-verifier statistical zero-knowledge argument of knowledge for relation <span class="math">\\mathcal{R}_{\\mathrm{Rep}}</span> in the generic group model.</p>

    <p class="text-gray-300">Part 1: HVZK To show that the protocol is honest-verifier zero-knowledge we build a simulator Sim. Sim samples <span class="math">(\\tilde{A},\\tilde{c},\\tilde{\\ell},\\tilde{r},\\tilde{Q})</span> as follows. Let <span class="math">\\mathbb{G}_i</span> denote the subgroup of <span class="math">\\mathbb{G}</span> generated by the base <span class="math">g_i</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\tilde{c} \\stackrel{\\mathbb{S}}{\\leftarrow} [0, 2^{\\lambda}]</span>, <span class="math">\\tilde{\\ell} \\stackrel{\\mathbb{S}}{\\leftarrow} \\text{Primes}(\\lambda)</span></li>

      <li><span class="math">\\tilde{\\pmb{q}} \\stackrel{\\mathbb{S}}{\\leftarrow} [B]^n</span></li>

      <li><span class="math">\\tilde{\\pmb{r}} \\stackrel{\\mathbb{S}}{\\leftarrow} [\\ell]^n</span></li>

      <li><span class="math">\\tilde{Q} \\gets \\prod_{i=1}^{n} g_i^{\\tilde{q}_i}</span></li>

      <li><span class="math">\\tilde{A} \\gets \\tilde{Q}^{\\tilde{\\ell}}(\\prod_{i=1}^{n} g_i^{\\tilde{r}_i})^{-1} w^{-\\tilde{c}}</span>.</li>

    </ol>

    <p class="text-gray-300">We now argue that <span class="math">(\\tilde{A}, \\tilde{c}, \\tilde{\\ell}, \\tilde{r}, \\tilde{Q})</span> is statistically indistinguishable from a transcript between an honest prover and verifier: <span class="math">(A, c, \\ell, r, Q)</span>. Sim chooses <span class="math">\\tilde{\\ell}</span> and <span class="math">\\tilde{c}</span> identically to the honest verifier in the real protocol. It also solves for <span class="math">\\tilde{A}</span> uniquely from the other values such that the verification holds. Therefore, it remains only to show that <span class="math">\\tilde{r}</span> and <span class="math">\\tilde{Q}</span> have the correct distribution. We must show that in the real protocol, independent of <span class="math">\\ell</span> and <span class="math">c</span>, <span class="math">r</span> has statistical distance less than <span class="math">2^{-\\lambda}</span> from the uniform distribution over <span class="math">[\\ell]^n</span> and each <span class="math">g_i^{q_i}</span> has statistical distance less than <span class="math">2^{-\\lambda}</span> from uniform over <span class="math">\\mathbb{G}_i</span> (recall that <span class="math">Q = \\prod_{i} g_i^{q_i}</span>). In addition we must argue that <span class="math">Q</span> and <span class="math">r</span> are independent.</p>

    <p class="text-gray-300">For this we use the following facts, which are easy to verify:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fact 1: If <span class="math">Z</span> is uniform random variable over <span class="math">N</span> consecutive integers and <span class="math">m &amp;lt; N</span> then <span class="math">Z \\mod m</span> has statistical distance at most <span class="math">m/N</span> from the uniform distribution over <span class="math">[m]</span>.</li>

      <li>Fact 2: For independent random variables <span class="math">X_{1}, X_{2}, Y_{1}, Y_{2}</span>, the distance between the joint distributions <span class="math">(X_{1}, X_{2})</span> and <span class="math">(Y_{1}, Y_{2})</span> is at most the sum of statistical distances of <span class="math">X_{1}</span> from <span class="math">Y_{1}</span> and <span class="math">X_{2}</span> from <span class="math">Y_{2}</span>. Similarly, if these variables are group elements in <span class="math">\\mathbb{G}</span>, the statistical distance between <span class="math">X_{1} \\cdot X_{2}</span> and <span class="math">Y_{1} \\cdot Y_{2}</span> is no greater than the sum of statistical distances of <span class="math">X_{1}</span> from <span class="math">Y_{1}</span> and <span class="math">X_{2}</span> from <span class="math">Y_{2}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Fact 3: Consider random variables <span class="math">X_{1}, X_{2}, Y_{1}, Y_{2}</span> with statistical distances <span class="math">s_{1} = \\Delta(X_{1}, X_{2})</span> and <span class="math">s_{2} = \\Delta(Y_{1}, Y_{2})</span>, where $Pr(X_{1} = x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{1} = y) &lt; Pr(X_{1} = x) + \\epsilon_{1}<span class="math"> and </span>Pr(X_{2} = x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{2} = y) &lt; Pr(X_{1} = x) + \\epsilon_{2}<span class="math"> for all values </span>x, y<span class="math">. Then the joint distributions </span>(X_{1}, X_{2})<span class="math"> and </span>(Y_{1}, Y_{2})<span class="math"> have statistical distance at most </span>s_{1} + s_{2} + \\epsilon_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">supp(X_{1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\epsilon_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">supp(Y_{1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span>supp$ is the support.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Consider fixed values of <span class="math">c, x_i</span> and <span class="math">\\ell</span>. In the real protocol, for each <span class="math">i \\in [n]</span> the prover computes <span class="math">s_i = cx_i + k_i</span> where <span class="math">k_i</span> is uniform in <span class="math">[-B, B]</span> and sets <span class="math">r_i = s_i \\bmod \\ell</span> and <span class="math">q_i = \\lfloor \\frac{s_i}{\\ell} \\rfloor</span>. The value of <span class="math">s_i</span> is distributed uniformly over a range of <span class="math">2B + 1</span> consecutive integers, thus <span class="math">r_i</span> has statistical distance at most <span class="math">\\ell / (2B + 1)</span> from uniform over <span class="math">[\\ell]</span>. This bounds the distance between <span class="math">r_i</span> and the simulated <span class="math">\\tilde{r}_i</span>, which is uniform over <span class="math">[\\ell]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next we show that each <span class="math">g_i^{q_i}</span> is statistically indistinguishable from uniform in <span class="math">\\mathbb{G}_i</span>. Consider the distribution of <span class="math">\\lfloor \\frac{s_i}{\\ell} \\rfloor</span> over the consecutive integers in <span class="math">[\\lfloor \\frac{cx_i - B}{\\ell} \\rfloor, \\lfloor \\frac{cx_i + B}{\\ell} \\rfloor]</span>. Denote this by the random variable <span class="math">Z_i</span>. The distribution of <span class="math">g_i^{q_i}</span> over <span class="math">\\mathbb{G}_i</span> is determined by the distribution of $q_i \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The probability that </span>q_i = z<span class="math"> is the probability that </span>s_i<span class="math"> falls in the interval </span>[z\\ell, (z + 1)\\ell - 1]<span class="math">. This probability is </span>\\ell / (2B + 1)<span class="math"> for all points where </span>z\\ell \\geq cx_i - B<span class="math"> and </span>(z + 1)\\ell \\leq cx_i + B<span class="math">, which includes all points except possibly the two endpoints </span>z = \\lfloor \\frac{cx_i - B}{\\ell} \\rfloor<span class="math"> and </span>z = \\lfloor \\frac{cx_i + B}{\\ell} \\rfloor<span class="math">. Call this set of points </span>Y<span class="math">. The distance of </span>q_i<span class="math"> from a uniform random variable </span>U_Y<span class="math"> over </span>Y<span class="math"> is largest when </span>cx_i - B = 1 \\bmod \\ell<span class="math"> and </span>cx_i + B = 0 \\bmod \\ell<span class="math">. In this case, </span>q_i<span class="math"> is one of the two endpoints outside </span>Y<span class="math"> with probability </span>1 / B<span class="math">. For each </span>z \\in Y<span class="math">, </span>Pr[q_i = z] = \\ell / (2B + 1)<span class="math">. As </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2(B - 1) / \\ell<span class="math">, the statistical distance of </span>q_i<span class="math"> from </span>U_Y<span class="math"> is at most: </span>\\frac{1}{2}[Y(\\frac{1}{Y} - \\frac{\\ell}{2B}) + \\frac{1}{B}] = \\frac{1}{2}(1 - \\frac{B - 1}{B} + \\frac{1}{B}) = \\frac{1}{B}<span class="math">. Moreover, the statistical distance of </span>q_i \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> from </span>U_Y<span class="math"> mod </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is no larger.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">42</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As noted in the Fact 1 above, $U_{Y} \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> has statistical distance at most </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\ell</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ 2(B - 1) &lt; 1 / (n2^{\\lambda + 1})<span class="math"> for </span>B &gt; n2^{2\\lambda}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. By the triangle inequality, the statistical distance of </span>q_{i} \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> from uniform is at most </span>1 / B + 1 / n2^{\\lambda + 1} &lt; 1 / (n2^{\\lambda})<span class="math">. This also bounds the distance of </span>g_{i}^{q_{i}}<span class="math"> from uniform in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_i<span class="math">. The simulated </span>g_{i}^{\\tilde{q}_{i}}<span class="math"> has distance at most </span>1 / (n2^{2\\lambda})<span class="math"> from uniform in </span>G_{i}<span class="math"> since </span>\\tilde{q}_i \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_i<span class="math"> has distance </span>B /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_i &lt; 1 / (n2^{2\\lambda})<span class="math"> from uniform (again by the Fact 1 above). By the triangle inequality, the distance between </span>g_{i}^{\\tilde{q}_{i}}<span class="math"> and </span>g_{i}^{q_{i}}<span class="math"> is at most </span>1 / B + 1 / (n2^{\\lambda + 1}) + 1 / (n2^{2\\lambda}) &lt; (1 / 2^{\\lambda} + 1 / 2 + 1 / 2^{\\lambda})1 / (n2^{\\lambda}) &lt; 1 / (n2^{\\lambda})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We have shown that each <span class="math">r_i</span> is statistically indistinguishable from the simulated <span class="math">\\tilde{r}_i</span> and each <span class="math">g^{q_i}</span> is statistically indistinguishable from the simulated <span class="math">g^{\\tilde{q}_i}</span>. However, we must consider the distances between the joint distributions. Since <span class="math">q_i</span> and <span class="math">r_i</span> are not independently distributed, arguing about the joint distributions requires more work. The simulated <span class="math">\\tilde{q}_i</span> and <span class="math">\\tilde{r}_i</span> are independent on the other hand.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider the conditional distribution of $q_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_{i}<span class="math"> (i.e. the distribution of the random variable for </span>q_{i}<span class="math"> conditioned the value of </span>r_i<span class="math">). Note that </span>q_{i} = z<span class="math"> if </span>(s_i - r_i) / \\ell = z<span class="math">. We repeat a similar argument as above for bounding the distribution of </span>q_{i}<span class="math"> from uniform. For each possible value of </span>z<span class="math">, there always exists a unique value of </span>s_i<span class="math"> such that </span>s_i / / \\ell = z<span class="math"> and </span>s_i = 0\\bmod \\ell<span class="math">, except possibly at the two endpoints of the range of </span>q_{i}<span class="math"> (i.e. </span>e_1 = \\lfloor \\frac{c s_i - B}{\\ell} \\rfloor<span class="math"> and </span>e_2 = \\lfloor \\frac{c s_i + B}{\\ell} \\rfloor<span class="math">). When </span>r_i<span class="math"> disqualifies the two points </span>e_1<span class="math"> and </span>e_2<span class="math">, then each of the remaining points </span>z\\notin \\{e_1,e_2\\}<span class="math"> still have equal probability mass, and thus the probability </span>Pr(q_{i} = z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_{i})<span class="math"> increases by at most </span>[Pr(q_{i} = e_{1}) + Pr(q_{i} = e_{2})] / (2\\lfloor \\frac{B}{\\ell} \\rfloor) &lt; 1 / B^{2}<span class="math">. The same applies to the variable </span>q_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_{i}<span class="math"> mod </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_i<span class="math"> and hence the variable </span>g^{q_i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_i$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We can compare the joint distribution <span class="math">X_{i} = (g^{q_{i}},r_{i})</span> to the simulated <span class="math">Y_{i}(g^{\\tilde{q}_{i}},\\tilde{r}_{i})</span> using Fact 3 above. Setting <span class="math">\\epsilon_{1} = 1 / B^{2}</span> and <span class="math">\\epsilon_{2} = 0</span>, the distance between these joint distributions is at most <span class="math">1 / (n2^{\\lambda}) + \\ell /(2B + 1) + \\ell /B^{2}</span>. Moreover, as each <span class="math">X_{i} = (g^{q_{i}},r_{i})</span> is independent from <span class="math">X_{j} = (g^{q_{j}},r_{j})</span> for <span class="math">i\\neq j</span>, we use Fact 2 to bound the distances between the joint distributions <span class="math">(g^{q_1},\\dots,g^{q_n},r_1,\\dots,r_n)</span> and <span class="math">(g^{\\tilde{q}_1},\\dots,g^{\\tilde{q}_n},\\tilde{r}_1,\\dots,\\tilde{r}_n)</span> by the sum of individual distances between each <span class="math">X_{i}</span> and <span class="math">Y_{i}</span>, which is at most <span class="math">1 / 2^{\\lambda} + n\\ell /(2B + 1) + n\\ell /B^{2} &amp;lt; 2^{-\\lambda +1}</span>. Finally, this also bounds the distance between <span class="math">(Q,\\boldsymbol {r})</span> and <span class="math">(\\tilde{Q},\\tilde{\\boldsymbol{r}})</span> where <span class="math">Q = \\prod_{i}g^{q_{i}}</span> and <span class="math">\\tilde{Q} = \\prod_{i}g^{\\tilde{q}_{i}}</span>.</p>

    <p class="text-gray-300"><strong>Part 2: PoK</strong> For extraction we describe an efficient extractor Ext. Ext randomly samples two random challenges <span class="math">c</span> and <span class="math">c&#x27;</span>, and <span class="math">c \\neq c&#x27;</span> with probability <span class="math">\\frac{1}{2^c}</span>. Ext then uses the extractor from Theorem 7 to extract <span class="math">\\boldsymbol{s}</span> and <span class="math">\\boldsymbol{s}&#x27;</span> such that <span class="math">\\prod_{i=1}^{n^2} g_i^{s_i} = A w^c</span> and <span class="math">\\prod_{i=1}^{n} g_i^{s_i&#x27;} = A w^{c&#x27;}</span>. We now compute <span class="math">\\Delta s_i = s_i - s_i&#x27;</span> for all <span class="math">i \\in [1, n]</span> and <span class="math">\\Delta c = c - c&#x27;</span>. This gives us <span class="math">\\prod_{i=1}^{n} g_i^{\\Delta s_i} = w^{\\Delta c}</span>. We now claim that <span class="math">\\Delta c \\in \\mathbb{Z}</span> divides <span class="math">\\Delta s_i \\in \\mathbb{Z}</span> for each <span class="math">i \\in [1, n]</span> with overwhelming probability and that <span class="math">\\prod_{i=1}^{n} g_i^{\\Delta s_i / \\Delta c} = w</span>. By Lemma 2, we can write <span class="math">w = \\prod_{i=1}^{m} g_i^{s_i}</span>, for integers <span class="math">\\alpha_i \\in \\mathbb{Z}</span> that can be efficiently computed from <span class="math">\\mathcal{A}</span>'s queries to the generic group oracle. Since <span class="math">\\prod_{i=1}^{n} g_i^{\\Delta s_i} = w^{\\Delta c}</span> it follows by Lemma 4 that, with overwhelming probability, <span class="math">\\alpha_j = 0</span> for all <span class="math">j &amp;gt; n</span> and <span class="math">\\Delta s_i = \\alpha_i \\Delta c</span> for all <span class="math">i \\in [1, n]</span>.</p>

    <p class="text-gray-300">Furthermore, if <span class="math">\\mu = \\prod_{i=1}^{n} g_i^{\\Delta s_i / \\Delta c} \\neq w</span>, then since <span class="math">\\mu^{\\Delta c} = \\prod_{i=1}^{n} g_i^{\\Delta s_i} = w^{\\Delta c}</span> it would follow that <span class="math">\\mu / w</span> is an element of order <span class="math">\\Delta c &amp;gt; 1</span>. As <span class="math">\\Delta c</span> is easy to compute this would contradict the hardness of computing a non-trivial element and its order in the generic group model (Corollary 2). We can conclude that <span class="math">\\mu = w</span> with overwhelming probability. The extractor outputs <span class="math">\\alpha = (\\alpha_1, \\dots, \\alpha_n)</span> where <span class="math">\\alpha_i = \\Delta s_i / \\Delta c</span>.</p>

    <p class="text-gray-300"><strong>Proof of Theorem 11.</strong></p>

    <p class="text-gray-300">Protocol ZKPoKE is an honest-verifier statistically zero-knowledge argument of knowledge for relation <span class="math">\\mathcal{R}_{\\mathrm{PoKE}}</span> in the generic group model.</p>

    <p class="text-gray-300">To prove that the protocol is honest-verifier zero-knowledge we build a simulator Sim which generates valid transcripts that are statistically indistinguishable from honestly generated ones. The simulator generates a transcript as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\tilde{c} \\stackrel{\\</span>}{\\leftarrow} [0,2^{\\lambda}], \\tilde{\\ell} \\stackrel{\\<span class="math">}{\\leftarrow} \\mathrm{Primes}(\\lambda)</span></li>

      <li><span class="math">\\tilde{z} \\gets h^{\\tilde{\\rho}}, \\rho \\stackrel{\\</span>}{\\leftarrow} [B]$</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\tilde{q}_x,\\tilde{q}_r\\stackrel {\\mathrm{A}}{\\leftarrow}[B]^2</span></li>

      <li><span class="math">\\tilde{r}_x,\\tilde{r}_{\\rho}\\in [\\ell ]^2</span></li>

      <li><span class="math">\\tilde{Q}_g\\gets g^{\\tilde{q}_x}h^{\\tilde{q}_\\rho},\\tilde{Q}_u\\gets u^{\\tilde{q}_x}</span></li>

      <li><span class="math">\\tilde{A}_g\\gets \\tilde{Q}_g^\\ell g^{\\ell \\times}h^{\\ell \\rho}z^{-\\tilde{c}},\\tilde{A}_u\\gets \\tilde{Q}_u^\\ell u^{\\ell \\times}w^{-\\tilde{c}}</span></li>

    </ol>

    <p class="text-gray-300">We now argue that the transcript  <span class="math">(\\tilde{z},\\tilde{A}_g,\\tilde{A}_u,\\tilde{c},\\tilde{\\ell},\\tilde{Q}_g,\\tilde{Q}_u,\\tilde{r}_x,\\tilde{r}_{\\rho})</span>  is statistically indistinguishable from a transcript between an honest prover and verifier:  <span class="math">(z,A_{g},A_{u},c,\\ell ,Q_{g},Q,u,r_{x},r_{\\rho})</span> <span class="math">\\tilde{\\ell},\\tilde{c}</span>  are identically chosen as by the random verifier and  <span class="math">\\tilde{A}_g,\\tilde{A}_u</span>  are uniquely defined by the rest of the transcript and the verification equations. It thus suffices to argue that  <span class="math">\\tilde{z},\\tilde{Q}_g,\\tilde{Q}_u,\\tilde{r}_x,\\tilde{r}_{\\rho}</span>  as well as  <span class="math">z,Q_{g},Q_{u},r_{x},r_{\\rho}</span>  are statistically indistinguishable from uniform in their respective domain.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using Fact 1 stated in the proof of Theorem 10 and that  $B &gt; 2^{h}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  we can see that  </span>\\tilde{z}<span class="math">  is indistinguishable from a uniform element in the subgroup of  </span>\\mathbb{G}<span class="math">  generated by  </span>h<span class="math"> . Since  </span>g<span class="math">  and  </span>h<span class="math">  generate the same subgroup the same argument applies to  </span>z<span class="math"> . For  </span>\\tilde{Q}_g, \\tilde{Q}_u, \\tilde{r}_x, \\tilde{r}_{\\rho}<span class="math">  and  </span>Q_g, Q_u, r_x, r_{\\rho}<span class="math">  the same argument as in the proof of Theorem 10 apply, showing that all values are nearly uniform. The simulation therefore produces valid, statistically indistinguishable transcripts. Note that the requirement that  </span>g, h<span class="math">  generate the same group can be relaxed under computational assumptions. The assumption states that it is difficult to distinguish between  </span>g, h<span class="math">  which generate the same subgroup and  </span>g', h'<span class="math">  which don&#x27;t. Given this we can use a hybrid argument which replaces  </span>g', h'<span class="math">  with  </span>g, h$  and the applies the same simulation argument as above.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For extraction, note that the protocol contains Protocol ZKPoKRep as a subprotocol on input  <span class="math">A_{g}</span>  and bases  <span class="math">g,h</span>  in the CRS, and therefore we can use the ZKPoKReP and PoKRep extractors to extract  <span class="math">x,\\rho</span>  such that  <span class="math">z = g^{x}h^{\\rho}</span>  and  <span class="math">s_1,s_2</span>  such that  <span class="math">g^{s_1}h^{s_2} = A_gz^c</span>  with overwhelming probability. Moreover, as shown in the analysis for the PoKRep extractor, we can rewind the adversary on fresh challenges so that each accepting transcript outputs an  <span class="math">r_1,\\ell</span>  where  <span class="math">s_1 = r_1\\bmod \\ell</span>  with overwhelming probability. If  <span class="math">u^{s_1}\\neq A_uw^c = Q_u^\\ell u^{r_1}</span>  then  <span class="math">\\gamma = (r_{1} - s_{1}) / \\ell</span>  is an integer and  <span class="math">Q_{u}u^{\\gamma}</span>  is an  <span class="math">\\ell</span> th root of  <span class="math">A_{u}w^{c} / u^{s_{1}}\\neq 1</span> . This would break the adaptive root assumption, hence by Corollary 1 it follows that  <span class="math">u^{s_1} = A_uw^c</span>  with overwhelming probability.</p>

    <p class="text-gray-300">Recall from the analysis of Theorem 10 that the extractor obtains a pair of accepting transcripts with  <span class="math">s_1, s_2, s_1&#x27;, s_2&#x27;, c, c&#x27;</span>  so that  <span class="math">x = \\Delta s_1 / \\Delta c = (s_1 - s_1&#x27;) / (c - c&#x27;)</span>  and  <span class="math">\\rho = \\Delta s_2 / \\Delta c = (s_2 - s_2&#x27;) / (c - c&#x27;)</span> . Since  <span class="math">u^{s_1} = A_u w^c</span>  and  <span class="math">u^{s_1&#x27;} = A_u w^{c&#x27;}</span>  with overwhelming probability, we obtain  <span class="math">u^{\\Delta s_1} = w^{\\Delta c}</span>  with overwhelming probability. Finally, this implies  <span class="math">(u^x)^{\\Delta c} = w^{\\Delta c}</span> . If  <span class="math">u^x \\neq w</span> , then  <span class="math">u^x / w</span>  is a non-trivial element of order  <span class="math">\\Delta c</span> , which would contradict the hardness of computing a non-trivial element and its order in the generic group model (Corollary 2). Hence, we conclude that  <span class="math">u^x = w</span>  with overwhelming probability.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">NI-PoE {x,u,w:ux=w} Prove(x,u,w): ℓ←Hprime(x,u,w) q←[x/ℓ] Q←uq Verify(x,u,w,Q): ℓ←Hprime(x,u,w) r←x mod ℓ Check:Qℓur=w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">NI-PoKE2 { (u,w;x):ux=w} Prove(x,u,w): g←HG(u,w),z=gx ℓ←Hprime(u,w,z),α=H(u,w,z,ℓ) q←[x/ℓ],r←x mod ℓ π←{z,(ugα)q,r} Verify(u,w,z,Q,r): g←HG(u,w) ℓ←Hprime(u,w,z),α←H(u,w,z,ℓ) Check:Qℓ(ugα)r=wzα</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  NI-PoDDH  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  {(y1,y2,y3); (x1,x2): gx1=y1 ∧ gx2=y2 ∧ y1x2=y3  |</p>

    <p class="text-gray-300">|  Prove(x=(x1,x2), y=(y1,y2,y3)):  |</p>

    <p class="text-gray-300">|  l← Hprime(y)  |</p>

    <p class="text-gray-300">|  (q1,q2)← ([x1/ℓ], [x2/ℓ])  |</p>

    <p class="text-gray-300">|  (r1,r2)← (x1 mod ℓ, x2 mod ℓ)  |</p>

    <p class="text-gray-300">|  π← {(gq1,gq2,y1q2), r1,r2}  |</p>

    <p class="text-gray-300">|  Verify(y,π):  |</p>

    <p class="text-gray-300">|  l← Hprime(y)  |</p>

    <p class="text-gray-300">|  {Qy1, Qy2, Qy3, r1,r2}← π  |</p>

    <p class="text-gray-300">|  Check:  |</p>

    <p class="text-gray-300">|  r∈[ℓ]2 ∧ Qℓgx1=y1 ∧ Qℓgx2=y2 ∧ Qℓg3y1x2=y3  |</p>

    <p class="text-gray-300">|  NI-ZKPoKE  |</p>

    <p class="text-gray-300">|  {(u,w;x): ux=w}  |</p>

    <p class="text-gray-300">|  Prove(x,u,w):  |</p>

    <p class="text-gray-300">|  k, ρx, ρk← [−B,B]; z=gxhρx; Ag=gkhρk; Au=uk;  |</p>

    <p class="text-gray-300">|  l← Hprime(u,w,z,Ag,Au); c← H(ℓ);  |</p>

    <p class="text-gray-300">|  qx← [(k+c·x)/ℓ]; qρ← [(ρk+c·ρx)/ℓ];  |</p>

    <p class="text-gray-300">|  rx← (k+c·x) mod ℓ; rρ← (ρk+c·ρx) mod ℓ;  |</p>

    <p class="text-gray-300">|  π← {ℓ,z,gqzhqx,uqz,rx,rρ}  |</p>

    <p class="text-gray-300">|  Verify():  |</p>

    <p class="text-gray-300">|  {c,z,Qg,Qu,rx,rρ}← π  |</p>

    <p class="text-gray-300">|  c=H(ℓ) Ag← Qℓgxrhxrz-c; Au← Qℓu rxw-c  |</p>

    <p class="text-gray-300">|  Check: rx,rρ∈[ℓ]; ℓ= Hprime(u,w,z,Ag,Au)  |</p>`;
---

<BaseLayout title="Batching Techniques for Accumulators with Applications to IO... (2018/1188)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/1188
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
