---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/185';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Vortex: A List Polynomial Commitment and its Application to Arguments of Knowledge';
const AUTHORS_HTML = 'Alexandre Belling, Azam Soleimanian, Bogdan Ursu';

const CONTENT = `    <p class="text-gray-300">Vortex: A List Polynomial Commitment and its Application to Arguments of Knowledge</p>

    <p class="text-gray-300">Alexandre Belling, Azam Soleimanian, and Bogdan Ursu</p>

    <p class="text-gray-300">Linea, Prover Team</p>

    <p class="text-gray-300">{firstname.lastname}@consensys.net</p>

    <p class="text-gray-300">Abstract. A list polynomial commitment scheme (LPC) is a polynomial commitment scheme with a relaxed binding property. Namely, in an LPC setting, a commitment to a function <span class="math">f(X)</span> can be opened to a list of low-degree polynomials close to <span class="math">f(X)</span> (w.r.t. the relative Hamming distance and over a domain <span class="math">D</span>). The scheme also allows opening one of the polynomials of the list at an arbitrary point <span class="math">x</span> and convincing a verifier that one of the polynomials in the list evaluates to the purported value.</p>

    <p class="text-gray-300">Vortex is a list polynomial commitment, obtained through a modification of Ligero (CCS 2017), inspired by the schemes of Brakedown (Crypto 2023), batch-FRI (FOCS 2020), and RedShift (CCS 2022). Concerning one application of Vortex, for a witness of size <span class="math">N</span>, the messages between the prover and the verifier are of size <span class="math">O(N^{1/2})</span>. Vortex is a core component of the SNARK used by the prover of Linea (Consensys). This paper provides a complete security analysis for Vortex. We use a general compiler to build an Argument of Knowledge (AoK) by combining our list polynomial commitment and a polynomial-IOP (PIOP).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The approach is similar to combining a PIOP with a polynomial commitment scheme and has a soundness loss only linear in the list size. This overcomes a previous limitation in the standard compiler from a generic PIOP and a list polynomial commitment scheme to an interactive argument of knowledge, which suffers from a soundness loss of $\\mathcal{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^r)<span class="math"> (where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the list size and </span>r$ is the number of interactions between the prover and the verifier in the PIOP).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Keywords: List Decoding Regime, Polynomial Commitment, List Polynomial Commitment, Reed-Solomon Codes, SNARK, PIOP, Linea.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Polynomial Commitments A polynomial commitment scheme (PCS) [24] is a cryptographic primitive in which a prover commits to a polynomial <span class="math">P(X)</span> and later proves the evaluation of <span class="math">P(X)</span> at a given point <span class="math">x</span>.</p>

    <p class="text-gray-300">List Polynomial Commitments (LPC) An LPC is a polynomial commitment with a relaxed security requirement: the commitment is not associated with a single polynomial but with a list of polynomials, where the prover can open the commitment to any polynomial from the list. In other words, the commitment is not binding to one polynomial but to a list of polynomials.</p>

    <p class="text-gray-300">Succinct Non-Interactive Arguments of Knowledge (SNARKs) Given a binary relation <span class="math">\\mathcal{R}(x,w)</span>, SNARKs allow proving knowledge of a witness <span class="math">w</span> such that the relation <span class="math">\\mathcal{R}</span> (usually drawn from a large family) is satisfied for a public input <span class="math">x</span>. In particular, the verifier needs less time to verify the proof, generated by the SNARK, rather than to perform again all the computations. In the last few years, an ever-growing number of SNARK constructions have emerged, including Groth16 [20], Plonk [4], Halo [13], Halo2 [17], Marlin [16], Spartan [28], Virgo [35], Brakedown [19], Orion [33], Libra [32], Aurora [7], Fractal [15], Sonic [26], Nova [23], and Lasso [29] to cite a fraction of the existing works.</p>

    <p class="text-gray-300">zk-VMs and zk-EVMs In a state machine, a transition is the process of moving from an old state to a new state by reading a series of inputs and performing sets of opcodes which are a limited and low-level set of instructions. Ethereum is, in essence, a transaction-based state machine, where the state contains all account addresses and their mapped account states. The Ethereum Virtual Machine (EVM) is the mechanism</p>

    <p class="text-gray-300">responsible for performing the transitions as a succession of opcodes. zk-VMs (zk-Virtual Machines) and, more specifically, zk-EVM (Ethereum Virtual Machine) are complex cryptographic systems that allow one party to generate proofs assessing the correct execution of a Virtual Machine using a SNARK scheme. The proofs can be as short as a few hundred bytes and be verified in a few milliseconds on any platform (Groth16 <em>[20]</em>). For these reasons, zk-VMs have important applications in blockchain scalability and interoperability and have seen tremendous activty in research and development: Linea <em>[5]</em>, Cairo <em>[18]</em>, Polygon-zkEVM <em>[30]</em>, RISC0 <em>[34]</em>, Scroll <em>[1]</em>. However, building a system capable of proving arbitrary executions of the Ethereum Virtual Machine is no easy task. At a high level, the zk-EVM of Consensys <em>[5]</em> models execution traces of the Ethereum Virtual Machine using hundreds of polynomials and thousands of arithmetic constraints of various types. In this setting, the total witness size for proving the execution of a regular block consists of hundreds of millions of field elements.</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">1.0.1 Interactive Oracle Proofs</h4>

    <p class="text-gray-300">Interactive Oracle Proofs (IOP) are a family of abstract ideal protocols in which the verifier is not required to read the prover’s messages in full. Instead, the verifier has oracle access to the prover’s messages and may probabilistically query them at any positions <em>[6]</em>. IOP protocols can be transformed into concrete secure argument systems using a Merkle tree. Later works have introduced several variants of IOP such as polynomial-IOP (PIOP) or tensor-IOP, where the prover can perform polynomial evaluation queries <em>[4]</em> or tensor queries <em>[12]</em>. Similarly, these protocols can be converted into concrete argument systems (including SNARK) using functional commitments. This type of approach for building argument systems has now become a standard <em>[4]</em>.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">1.0.2 Reed-Solomon Encoding and Decoding Regimes</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Generally speaking, the Reed-Solomon encoding receives the evaluations of a function over <span class="math">k</span> points, considers them as the coefficients (or evaluations) of a polynomial <span class="math">P(X)</span>, and then outputs the evaluation of such a <span class="math">P(X)</span> over a fixed set <span class="math">D</span> (usually the set of roots of unity over the finite field <span class="math">\\mathbb{F}_{q}</span>). The output is called a codeword of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Considering the relative Hamming distance as the measure, a decoding algorithm receives the vector <span class="math">w</span> over <span class="math">D</span> and outputs codewords close to <span class="math">w</span>. For the Reed-Solomon code, one considers the unique decoding regime and list decoding regime. In the unique decoding regime, the radius of the ball around <span class="math">w</span> (w.r.t. the relative Hamming distance) is small and there is only one codeword that can be that close to <span class="math">w</span>, while in the list decoding regime the radius is bigger and there are many codewords that fall in the ball around <span class="math">w</span>.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Our Contributions and Techniques</h3>

    <p class="text-gray-300">Here we summarize our contributions.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">1.1.1 A Compilation Framework from PIOP to UniEval PIOP</h4>

    <p class="text-gray-300">We introduce a compiler (adapted from <em>[11]</em>) that allows transforming any secure PIOP into one where the verifier sends oracles queries on a single opening point for all polynomials (while it may have sent queries directly to the prover before this step). As the original goal of our work is to build a succinct proof system for the zk-EVM specified by Linea <em>[5]</em>, this compiler approach has numerous benefits. An important one is that it allows specifying and implementing batching and optimization techniques that would be a lot more complex otherwise. The main feature of this compilation is that it yields a single-point evaluation PIOP, allowing us to use it alongside a non-homomorphic polynomial commitment (i.e., Vortex) to create an efficient argument system. Indeed since Vortex is not a homomorphic commitment scheme, the well-known batching techniques based on random linear combinations are not readily applicable, but with UniEval PIOP we only require the possibility of batching over the same point. This batching feature is supported by Vortex.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">1.1.2 Vortex, a Batchable Polynomial Commitment (BPC)</h4>

    <p class="text-gray-300">A polynomial commitment allows a prover to open the committed polynomial over a given point. A Batchable Polynomial Commitment (BPC) allows the same type of opening for a batch of committed polynomials on the same point.</p>

    <p class="text-gray-300">In Section 5, we present Vortex, an adaptation of Ligero <em>[3]</em> into an BPC scheme inspired by the works of Brakedown <em>[19]</em>, batch-FRI <em>[10]</em>, and RedShift <em>[22]</em>.</p>

    <p class="text-gray-300">As Brakedown, our BPC does not rely on FRI protocol and it has a proximity check and an evaluation check where the proximity check is indeed the Ligero test. The main difference from Brakedown is the security regime we are dealing with. Based on encoding schemes, one can imagine two security regimes: the unique decoding regime that is the counterpart for the standard binding and the list decoding regime leading to a relaxed binding property where the commitment can be opened to a fixed list.</p>

    <p class="text-gray-300">Working in the list decoding regime requires a new design. Indeed, the evaluation protocol of Vortex is different from the one in Brakedown, where we combine the proximity check and evaluation check as the evaluation protocol. More precisely, in Brakedown, the proximity check can be run independently of the evaluation point, while in Vortex the proximity check is run after seeing the evaluation point.</p>

    <p class="text-gray-300">We show that a polynomial commitment scheme in the list decoding regime (Vortex LPC) is enough for the compilation of PIOP to an argument of knowledge (AoK).</p>

    <p class="text-gray-300">From the instantiation point of view, for hashing the columns, our Vortex scheme relies on a hash function based on the Ring-SIS assumption <em>[25]</em> where we also apply an MIMC hash over the output of the SIS-hash. The first instance of Ring-SIS-based hash functions was introduced in <em>[25]</em>. It is a SNARK-friendly hash function with a linear structure defined over the ring of polynomials of degree less than <span class="math">d</span>, as <span class="math">H_{a}(s)=\\sum a_{i}(x)s_{i}(x)\\in\\mathcal{R}</span> for <span class="math">\\mathcal{R}=\\mathbb{Z}_{q}(X)/X^{d}+1</span>. Another advantage of using such a hash function is the possibility of using lookup arguments if the hash computation is not done on the verifier side. To encode the rows, we use (systematic) Reed-Solomon encoding <em>[27]</em>.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">1.1.2 Overview of Vortex</h4>

    <h5 id="sec-7" class="text-base font-semibold mt-4">Vortex</h5>

    <p class="text-gray-300">As for Brakedown <em>[19]</em> and <em>[33]</em>, the Vortex construction is simple and constitutes a modification of Ligero <em>[3]</em>. Assume that <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> are the prover and the verifier. First, we elaborate on the commitment procedure. The prover commits to a matrix <span class="math">W</span> of size <span class="math">m\\times k</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Row-Encoding: <span class="math">\\mathcal{P}</span> starts by encoding the matrix rows to obtain a new matrix <span class="math">W^{\\prime}</span> of size <span class="math">m\\times n</span>.</li>

      <li>Column-Hashing: The prover then hashes each column of <span class="math">W^{\\prime}</span> and sends them to the verifier as a commitment</li>

    </ul>

    <p class="text-gray-300">For the evaluation, the verifier wishes to know if there exists a matrix-codeword <span class="math">G</span> (whose extension over <span class="math">D</span> is) close to <span class="math">W^{\\prime}</span> such that <span class="math">G\\cdot l=y</span> with <span class="math">l=(1,x,\\cdots,x^{k})</span>. For this, first, they follow the Ligero test as follows:</p>

    <h5 id="sec-8" class="text-base font-semibold mt-4">Proximity Check:</h5>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for some vector <span class="math">\\mathcal{B}</span> drawn at random by the verifier, the prover sends a vector <span class="math">u</span>.</li>

      <li>the verifier encodes <span class="math">u</span> to <span class="math">u^{\\prime}</span> using the Reed-Solomon code.</li>

      <li>it queries the openings of <span class="math">t</span> random columns of <span class="math">W^{\\prime}</span>, where the prover sends the columns in response.</li>

      <li>For the opened columns, the verifier checks;</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>whether the alleged column openings are consistent with the corresponding hash values from the commitment.</li>

      <li>whether the scalar-products of <span class="math">\\mathcal{B}</span> and the chosen columns are consistent with <span class="math">u^{\\prime}</span>.</li>

    </ol>

    <p class="text-gray-300">The test ensures that <span class="math">W^{\\prime}</span> is close to a Matrix-codeword (i.e., a matrix whose rows are codewords). Namely, that there exists a list <span class="math">L</span> of Matrix-codewords close to <span class="math">W^{\\prime}</span>.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Evaluation Check:</h6>

    <p class="text-gray-300">Finally, by checking <span class="math">u\\cdot l=\\mathbf{B}\\cdot y</span>, one of the matrices in <span class="math">L</span> has to evaluate to <span class="math">y</span> over <span class="math">l</span>.</p>

    <p class="text-gray-300">One difference from Brakedown is in the evaluation phase which allows us to support batching separate polynomials in the same committed matrix. More importantly, we analyze the security in the list-decoding regime and prove that Vortex is an LPC scheme. Working in this regime brings some subtlety to the compilation of PIOP to AoK. We also present a compiler compatible with LPC (rather than PC).</p>

    <p class="text-gray-300">Our compiler has several important properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>it uses an LPC rather than a (binding) polynomial commitment.</li>

      <li>the soundness error increases only by a factor <span class="math">L</span> (comparing to the compilation via polynomial commitment or the schemes in the unique decoding regime).</li>

    </ul>

    <h2 id="sec-10" class="text-2xl font-bold">2 Related Works: Ligero-Based Polynomial Commitments</h2>

    <p class="text-gray-300">One can analyze the soundness of Vortex in two different regimes: “unique decoding regime” and “list decoding regime”. Intuitively, in the unique decoding regime the commitment is guaranteed to be binding. In the list decoding, the commitment satisfies a relaxed binding property where the commitment can be opened to any polynomial close to the committed one. This technically means that the polynomial commitment is not knowledge-sound with respect to the standard relation. In <em>[22]</em>, such a polynomial commitment scheme is called a list polynomial commitment (LPC).</p>

    <p class="text-gray-300">In the list decoding regime (for Vortex), the efficiency improvement comes from the verifier opening fewer columns compared to the unique decoding regime.</p>

    <p class="text-gray-300">Following the strategy in DEEP-FRI <em>[8]</em> and RedShift <em>[22]</em>, we discuss the knowledge-soundness of Vortex in the list decoding regime.</p>

    <p class="text-gray-300">Both Breakdown and Orion follow the unique decoding regime. Theoretically, to guarantee that binding holds, one just needs to set the distance on the unique decoding radius (the parameter setting of the unique decoding regime), but as already mentioned, this requires opening more matrix columns.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.1 Interactive Oracle Proof (IOP) of Proximity</h3>

    <p class="text-gray-300">A Fast Reed-Solomon Interactive Oracle Proof (FRI) <em>[9]</em> is an IOP for testing the proximity to a codeword.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Namely, given a function <span class="math">f:D\\to\\mathbb{F}</span>, the aim in FRI is to prove that <span class="math">f</span> corresponds to a low-degree polynomial with respect to the size of <span class="math">D</span>. The oracle provided by the FRI prover is the function <span class="math">f</span>, and the verifier queries the values at points from <span class="math">D</span>. Due to the small size of <span class="math">D</span> (compared to the finite field <span class="math">\\mathbb{F}</span>), the key tool for distinguishing if <span class="math">f</span> is a codeword is statistical sampling <em>[21]</em>. However, a statistical test can only ensure proximity, which we measure by the relative Hamming distance <span class="math">\\delta(f,g)</span>. Thus, in FRI the prover convinces the verifier that a given function <span class="math">f:D\\to\\mathbb{F}</span> is close (and not necessarily equal) to a low-degree polynomial, i.e. <span class="math">\\delta(f,P)\\leq\\theta</span> for some polynomial <span class="math">p(X)</span> of specified maximum degree. In other words, <span class="math">f</span> agrees with <span class="math">p(X)</span> on a set <span class="math">A\\subset D</span> of density $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 1-\\theta<span class="math">. In applications, the agreement set </span>A$ is chosen to be large enough to infer global properties on the low-degree polynomial.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.2 Ligero Testing and the Correlated Agreement Theorem</h3>

    <p class="text-gray-300">The Ligero test <em>[3]</em> checks the proximity of a batch holding a known codeword. Consider the batch <span class="math">\\{f_{i}\\}_{i\\in[m]}</span>. In the Ligero test, the verifier sends a random <span class="math">\\lambda\\leftarrow\\mathbb{F}</span>, and the prover provides oracle access to the linear combination <span class="math">f:=\\sum\\lambda^{i}f_{i}</span>. The verifier then samples some columns and checks the consistency for the linear combination. Finally. the test ensures that each <span class="math">f_{i}</span> is close to a codeword, “If <span class="math">f</span> is close to a codeword”.</p>

    <p class="text-gray-300">The soundness of the Ligero test is argued based on the Correlated Agreement Theorem, which informally says that if the linear combination is at distance <span class="math">\\leq\\theta</span> from a codeword, then each <span class="math">f_{i}</span> must follow a similar proximity property.</p>

    <p class="text-gray-300">2.3 Brakedown versus batch-FRI.</p>

    <p class="text-gray-300">The Proximity Check of the “batch” in Brakedown and Batch-FRI <em>[10]</em> is their common point which is indeed the Ligero test <em>[3]</em>. The difference is how the “if” statement of Ligero is satisfied (remember that “if” <span class="math">f</span> is close to a codeword then each element of the batch is close to a codeword).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In batch-FRI, the verifier has oracle-access to each function <span class="math">f_{i}</span> and to the linear combination over <span class="math">D</span> (i.e., $f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{D}<span class="math">), while in Brakedown the verifier has oracle-access to the functions </span>f_{i}<span class="math"> over the domain </span>D<span class="math">, and “full”-access to </span>f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{D}<span class="math"> where it actively participates in building </span>f<span class="math"> as a codeword (In Vortex, similarly to Brakedown and Orion, this is done by giving full access to </span>u<span class="math"> when the verifier expands it to </span>u^{\\prime}<span class="math">. The vector </span>u^{\\prime}<span class="math"> is then the equivalent of </span>f<span class="math"> described above). From this point, Brakedown and batch-FRI act differently: batch-FRI applies FRI over the result of the linear combination </span>f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{D}<span class="math"> to check that </span>f<span class="math"> is close to a codeword, while in Brakedown (and also in Vortex), the verifier knows the codeword </span>f<span class="math">. The fact that the verifier knows the codeword </span>f<span class="math"> makes Brakedown simpler and improves the proof-time, while it increases the proof size to </span>k<span class="math"> (the size of </span>u$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Relying on the Ligero test in all these schemes (Brakedown, Orion, batch-FRI) the soundness is based on the Correlated Agreement Theorem. Brakedown and Orion follow the unique decoding regime, while batch-FRI works in different regimes. For Vortex, we present the soundness analysis in the list-decoding regime (which requires the opening of fewer random columns). The compilation of PIOP to AOK via Vortex is simple and efficient, albeit at the cost of losing a small factor in the soundness error. We borrow the idea of the DEEP query of Deep-ALI (this is what we call the Grail query in UniEval compilation) to improve the soundness of the compilation in the list-decoding regime while keeping the simplicity of Brakedown.</p>

    <h2 id="sec-13" class="text-2xl font-bold">3 Preliminaries</h2>

    <p class="text-gray-300">Here we define the syntax of our main primitives: polynomial commitments, list polynomial commitments, IOPs and arguments of knowledge.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.1 Interactive Protocols and Arguments of Knowledge (AoKs)</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this subsection, we roughly follow the definitions of <em>[14]</em>. An NP relation <span class="math">\\mathcal{R}\\subseteq\\{0,1\\}^{*}</span> is a set of binary-string tuples <span class="math">(x,w)</span> for which there exists a polynomial-time algorithm that on input <span class="math">(x,w)</span>, determines whether <span class="math">(x,w)\\in\\mathcal{R}</span> (the polynomial runtime is w.r.t. $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">). The NP language </span>\\mathcal{L}_{\\mathcal{R}}<span class="math"> associated to </span>\\mathcal{R}<span class="math"> is defined as: </span>\\mathcal{L}_{\\mathcal{R}}:=\\{x:\\exists w\\ \\text{s.t.}\\mathcal{R}(x,w)=1\\}<span class="math">. The string </span>x<span class="math"> is called the statement, and it is called valid when </span>x\\in\\mathcal{L}_{\\mathcal{R}}<span class="math">. The string </span>w<span class="math"> is the witness of </span>x<span class="math">, allowing to efficiently check membership of </span>x$ to the language.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Interactive Proofs of Knowledge</h4>

    <p class="text-gray-300">Interactive proofs of knowledge are a particular case of two-party protocols between a prover <span class="math">\\mathcal{P}</span> and a verifier <span class="math">\\mathcal{V}</span>. Both parties have access to an NP statement <span class="math">x</span>, and the prover is given access to a witness <span class="math">w</span> for the statement. The protocol is complete if the interaction between <span class="math">P(x,w)</span> and verifier <span class="math">V(x)</span> always results in the verifier accepting.</p>

    <p class="text-gray-300">Consider an arbitrary (potentially malicious) prover <span class="math">P^{<em>}</span> for which the verifier <span class="math">V(x)</span> accepts with non-negligible probability. Knowledge-soundness is satisfied if there exists an extraction algorithm <span class="math">E</span> (called the extractor) that given access to the arbitrary prover <span class="math">P^{</em>}</span> will output a valid witness <span class="math">w</span> with overwhelming probability. The extractor can inspect the internal state of <span class="math">P^{*}</span>, run it for any number of steps and rewind it to any previous state.</p>

    <p class="text-gray-300">We denote the random variable which constitutes the output of a verifier on a run of an interactive protocol on a statement <span class="math">x</span> as <span class="math">\\langle P(x;r_{P})\\leftrightarrow V(x;(r_{1}\\ldots r_{n}))\\rangle</span>, where <span class="math">r_{P}</span> is the randomness of the prover and <span class="math">r_{1}\\ldots r_{n}</span> are the public coins which constitute the verifier messages in verifier rounds 1 to <span class="math">n</span>. When we do not need to specify the exact random coins used, we resort to the shorthand notation <span class="math">\\langle P(x)\\leftrightarrow V(x)\\rangle</span>.</p>

    <p class="text-gray-300">In cases where the relation <span class="math">R</span> is defined w.r.t. parameters relevant to other protocols, we consider a PPT relation generator <span class="math">\\mathcal{R}_{\\lambda}</span>, namely <span class="math">\\mathcal{R}\\leftarrow\\mathcal{R}_{\\lambda}</span>.</p>

    <p class="text-gray-300">####</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 1 (Interactive Arguments of Knowledge)</h6>

    <p class="text-gray-300">We consider interactive protocols in which both the prover and the verifier are provided access to a common reference string, generated in an offline setup phase (the reference string will be implicitly assumed to be given as input to all the following algorithms). Such an interactive protocol <span class="math">(P,V)</span> between a prover <span class="math">P</span> and a verifier <span class="math">V</span> is an argument of knowledge for an NP relation <span class="math">\\mathcal{R}</span> if it satisfies the following two properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Perfect Completeness: for all <span class="math">(x,w)\\in\\mathcal{R}</span>, it holds that:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr[\\langle P(x,w)\\leftrightarrow V(x)\\rangle=1]=1.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness: this property states that it is not feasible to convince the verifier of a wrong statement. More formally, for any non-uniform PPT adversarial <span class="math">P^{\\prime}=(\\mathcal{A},P^{*})</span> we have,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr[\\langle P^{*}(x)\\leftrightarrow V(x)\\rangle=1\\ \\land\\ x\\notin\\mathcal{L}_{\\mathcal{R}}:\\ \\mathcal{R}\\leftarrow\\mathcal{R}_{\\lambda},x\\leftarrow\\mathcal{A}(\\mathcal{R})]\\approx 0</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Knowledge Soundness in the random oracle model: there exists an algorithm <span class="math">E</span> that given oracle access to the adversarial prover <span class="math">P^{<em>}</span> (along with access to the statement, all adversarial queries to the random oracle, the possibility to inspect the adversarial state, rewind and execute for a specified number of steps) satisfies that: <span class="math">E^{P^{</em>}(x)}</span> runs in probabilistic polynomial-time and moreover $\\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=\\mathrm{negl}(\\lambda)<span class="math">, where </span>\\delta$ is defined as:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=\\Pr\\left[\\langle P(x)\\leftrightarrow V(x)\\rangle=1\\ \\land\\mathcal{R}(x;w)=0:\\begin{array}[]{c}\\mathcal{R}\\leftarrow\\mathcal{R}_{\\lambda},\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(x,w)\\leftarrow E^{P^{*}}(\\mathcal{R})\\end{array}\\right] \\]</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Succinctness</h4>

    <p class="text-gray-300">Our focus is on succinct interactive protocols. Informally, both the prover and the verifier time, as well as the size of the messages sent between the two parties must be small compared with the witness of the relation being proven.</p>

    <p class="text-gray-300">.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">3.2 (Batched) Polynomial Commitments</h3>

    <p class="text-gray-300">The definitions in this section follow the presentation from <em>[11]</em>. Similarly to <em>[11]</em>, we considered batched openings of multiple polynomials. One difference is that we only consider openings of all these polynomials at the same evaluation point.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 2</h6>

    <p class="text-gray-300">A (batched) polynomial commitment scheme (PCS) is a triplet <span class="math">(\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Open})</span> that satisfy:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(1^{\\lambda},k)</span> generates public parameters <span class="math">\\mathsf{pp}</span> (a structured reference string) suitable to commit to polynomials of degree <span class="math">&lt;k</span>.</li>

      <li><span class="math">\\mathsf{Commit}(\\mathsf{pp},P_{1}(X)\\ldots P_{n}(X))</span> outputs a commitment <span class="math">C</span> to <span class="math">n</span> polynomials <span class="math">(P_{1}(X)\\ldots P_{n}(X))</span> of degree <span class="math">&lt;k</span> using <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">\\mathsf{OpenEval}</span> is a (public-coin) protocol between two parties, a prover <span class="math">P_{\\mathrm{PC}}</span> and a verifier <span class="math">V_{\\mathrm{PC}}</span> that either accepts or rejects. The prover is given <span class="math">n</span> polynomials <span class="math">P_{1}(X)\\ldots P_{n}(X)\\in\\mathbb{F}_{&lt;k}[X]</span>. Both parties receive the following:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>security parameter <span class="math">\\lambda</span>, degree bound <span class="math">k</span> and batch size <span class="math">n</span>, such that <span class="math">k,n=\\text{poly}(\\lambda)</span>.</li>

      <li>The public parameters <span class="math">\\mathsf{pp}</span>, where <span class="math">\\mathsf{pp}=\\mathsf{Setup}(1^{\\lambda},k)</span>.</li>

      <li>An evaluation point <span class="math">x</span> and alleged openings <span class="math">y=(y_{1}\\ldots y_{n})</span>.</li>

      <li>Alleged commitment <span class="math">C</span> for polynomials <span class="math">P_{1}(X)\\ldots P_{n}(X)</span>.</li>

    </ul>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 3 (Completeness of an Batched Polynomial Commitment Scheme)</h6>

    <p class="text-gray-300">We say that a batched polynomial commitment scheme has perfect completeness if for any security parameter <span class="math">\\lambda</span>, any integers <span class="math">k,n=\\mathrm{poly}(\\lambda)</span>, any polynomials <span class="math">P_{1}(X)\\ldots P_{n}(X)\\in\\mathbb{F}_{&lt;k}[X]</span>, arbitrary evaluation point <span class="math">x</span> and alleged opening <span class="math">y</span>, if <span class="math">C=\\mathsf{Commit}(\\mathsf{pp},P_{1}(X)\\ldots P_{n}(X))</span> and <span class="math">P_{i}(x)=y_{i}</span> for all <span class="math">i\\in[n]</span> then an interaction of <span class="math">(P_{\\mathrm{PC}},V_{\\mathrm{PC}})</span> where <span class="math">P_{\\mathrm{PC}}</span> runs on the aforementioned parameters will result in the verifier accepting with probability one.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Definition 4 (Knowledge Soundness in the Random Oracle Model).</h6>

    <p class="text-gray-300">There must exist a <em>PPT</em> extractor <span class="math">E</span> such that for every <em>PPT</em> adversary <span class="math">\\mathcal{A}</span> and arbitrary degree <span class="math">k=\\operatorname{poly}(\\lambda)</span>, the probability that <span class="math">\\mathcal{A}</span> wins the following game is negligible, where the probability is taken over the coins of <span class="math">\\mathsf{Setup}</span>, <span class="math">\\mathcal{A}</span> and <span class="math">V_{\\mathrm{PC}}</span>. Moreover, the extractor has access to the random oracle queries of <span class="math">\\mathcal{A}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> receives degree <span class="math">k</span> and <span class="math">\\mathsf{pp}=\\mathsf{Setup}(1^{\\lambda},k)</span>. <span class="math">\\mathcal{A}</span> outputs <span class="math">C</span>.</li>

      <li><span class="math">E</span> receives the commitments <span class="math">C</span>, inspects the random oracle queries made by <span class="math">A</span> in the previous step and outputs <span class="math">P_{1}(X)\\ldots P_{n}(X)\\in\\mathbb{F}_{&lt;k}[X]</span>.</li>

      <li><span class="math">\\mathcal{A}</span> outputs an evaluation point <span class="math">x</span> and claimed openings <span class="math">y</span>.</li>

      <li><span class="math">\\mathcal{A}</span> interacts with the <span class="math">V_{\\mathrm{PC}}</span> verifier of the <span class="math">\\mathsf{OpenEval}</span> algorithm. The inputs of <span class="math">\\mathcal{A}</span> for this subprotocol are <span class="math">C_{1}\\ldots C_{n}</span>, <span class="math">x</span> and <span class="math">y</span>.</li>

      <li><span class="math">\\mathcal{A}</span> succeeds if <span class="math">V_{\\mathrm{PC}}</span> accepts but <span class="math">P_{i}(x)\\neq y_{i}</span> for some <span class="math">i\\in[n]</span>.</li>

    </ul>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">3.3 IOP and Polynomial-IOP</h3>

    <p class="text-gray-300">An interactive oracle proof (IOP) for a relation <span class="math">\\mathcal{R}(x,w)</span> is an interactive proof in which the verifier is not required to read the prover’s messages in their entirety; rather, the verifier has oracle access to the prover’s messages, and may probabilistically query them. In Polynomial IOP, the messages are polynomials and the verifier has oracle access to the evaluation of polynomials on the queried points.</p>

    <p class="text-gray-300">The following lemma is very useful in the PIOP context.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Lemma 1 (Schwartz-Zippel Lemma).</h6>

    <p class="text-gray-300">Let <span class="math">P(X)</span> be a non-zero polynomial of degree <span class="math">d</span> over a field <span class="math">\\mathbb{F}</span>. Let <span class="math">S</span> be a finite subset of <span class="math">\\mathbb{F}</span> and let <span class="math">r</span> be selected randomly from <span class="math">S</span>. Then:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[P(r)=0]\\leq d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We also require the following claim, which complements the Schwarz-Zippel lemma as a technical tool in one of our proofs.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Lemma 2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(PLONK <em>[4]</em>, Claim 4.6) Fix <span class="math">F_{1},\\cdots,F_{k}\\in F^{&lt;n}[X]</span>, and <span class="math">Z\\in F^{&lt;n}[X]</span>. Suppose that for some <span class="math">i\\in[k]</span>, <span class="math">Z\\nmid F_{i}</span>. Assuming <span class="math">Z</span> decomposes to distinct linear factors over <span class="math">\\mathbb{F}</span>, then except with probability $k/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over uniform </span>\\alpha\\in\\mathbb{F}<span class="math">, </span>Z<span class="math"> doesn’t divide </span>G:=\\sum_{i=1}^{k}\\alpha^{i-1}F_{i}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">3.4 Roots of Unity and Lagrange Polynomials</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}_{q}</span> be a finite field of prime order <span class="math">q</span>. We call the roots of the polynomials <span class="math">Z_{k}(X)=X^{k}-1</span> the <span class="math">k</span>-th roots of unity. Together, they form a multiplicative subgroup <span class="math">\\Omega_{k}</span> of <span class="math">\\mathbb{F}_{q}^{*}</span>, provided that $k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(q-1)<span class="math">. We say that </span>Z_{k}(X)=X^{k}-1<span class="math"> is the vanishing polynomial of </span>\\Omega_{k}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We assume that <span class="math">k</span> is a power of <span class="math">2</span>, for each subgroup <span class="math">\\Omega_{k^{\\prime}}</span> of <span class="math">\\Omega_{k}</span> (thus, $k^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k<span class="math">), we have </span>\\omega^{\\prime}=\\omega^{k/k^{\\prime}}<span class="math"> where </span>\\omega<span class="math"> and </span>\\omega^{\\prime}<span class="math"> are the generators of </span>\\Omega_{k}<span class="math"> and </span>\\Omega_{k^{\\prime}}$ (res.).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For any subgroup <span class="math">\\Omega_{k}</span>, the collection of polynomials given by <span class="math">(\\mathcal{L}_{u,\\Omega_{k}}(X))_{u\\in\\Omega_{k}}</span> forms the Lagrange basis for polynomials of degree <span class="math">k-1</span> where,</p>

    <p class="text-gray-300"><span class="math">\\forall u\\in\\Omega_{k}:\\mathcal{L}_{u,\\Omega_{k}}(X)=\\frac{u(X^{k}-1)}{k(X-u)}</span></p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">3.5 Reed-Solomon Codes</h3>

    <h6 id="sec-27" class="text-base font-medium mt-4">Definition 5 (Linear Code <em>[33]</em>).</h6>

    <p class="text-gray-300">A linear error-correcting code with message length <span class="math">k</span> and codeword length <span class="math">n</span> with <span class="math">k&lt;n</span> is a linear subspace <span class="math">C\\subset\\mathbb{F}^{n}</span>, such that there exists an injective mapping from message to codeword <span class="math">EC:\\mathbb{F}^{k}\\to C</span> which is called the encoder of the code. Any linear combination of codewords is also a codeword. The rate of the code is defined as <span class="math">\\rho:=k/n</span>. The distance between two codewords <span class="math">u,v</span> is the number of coordinates on which they differ, denoted as the Hamming distance <span class="math">\\Delta(u,v)</span>. The relative (or fractional Hamming distance) is defined as <span class="math">\\delta(u,v)=\\Delta(u,v)/n</span>. The minimum distance is <span class="math">d:=\\min_{u,v}\\Delta(u,v)</span>.</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Definition 6 (Reed-Solomon Code)</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider positive integers <span class="math">n,k</span>, a finite field <span class="math">\\mathbb{F}</span>, and a set <span class="math">D\\subseteq\\mathbb{F}^{*}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n<span class="math"> (the set </span>D<span class="math"> will be referred to as the domain). The Reed-Solomon code over </span>\\mathbb{F}<span class="math"> with domain </span>D<span class="math"> and the message space of size </span>k$ is defined as:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{RS}[\\mathbb{F},D,k]:=\\{p(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x\\in D}:p(X)\\in\\mathbb{F}[X],\\deg(p)\\leq k\\},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By $p(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x\\in D}<span class="math">, we denote the set of evaluations of </span>p<span class="math"> over the set </span>D<span class="math"> and </span>n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is called the codeword size. For </span>v\\in D<span class="math"> and </span>p\\in\\mathsf{RS}[\\mathbb{F},D,k]<span class="math">, we will also use the notation </span>p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{v}<span class="math"> to refer to </span>p(v)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By <span class="math">F^{&lt;n}[X]</span>, we denote the set of polynomials of degree less than or equal to <span class="math">k</span>, i.e.</p>

    <p class="text-gray-300"><span class="math">\\mathbb{F}_{&lt;k}:=\\{p(X)\\in\\mathbb{F}[X]:\\deg(p)\\leq k\\},</span></p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">Distance to a Reed-Solomon Code</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider arbitrary $f\\in\\mathbb{F}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. The distance of </span>f<span class="math"> from the set </span>V=\\mathsf{RS}[\\mathbb{F},D,k]<span class="math"> is defined as </span>\\Delta(f,V):=\\min_{v\\in V}\\Delta(f,v)$ (and similarly for relative distance).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">3.5.1. Reed-Solomon Codes over Roots of Unity</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this work, we choose the domain set <span class="math">D=\\Omega_{n}</span> as the set of <span class="math">n^{\\text{th}}</span> roots of unity. Consider a fixed generator <span class="math">\\omega</span> of <span class="math">\\Omega_{k}</span>. Then <span class="math">D=\\{\\omega^{i}\\}_{i=0}^{n-1}</span> and we will associate polynomial evaluations $p(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{D}<span class="math">, called codeword space, with vectors </span>(p(\\omega^{0}),p(\\omega^{1})\\dots p(\\omega^{n-1}))<span class="math">, ordered by the natural ordering induced by the exponents of generator </span>\\omega$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">3.5.2. Interpolation</h4>

    <p class="text-gray-300">By <span class="math">\\mathsf{Int}_{c}(X)</span> we denote the interpolated polynomial corresponding to a Reed-Solomon codeword <span class="math">c</span>, and by <span class="math">\\mathsf{Int}_{c}(x)</span> the evaluation of the interpolated polynomial at point <span class="math">x</span>. Using the notation introduced in Definition 6, note that for a low-degree polynomial <span class="math">p(X)</span>, a codeword was defined as <span class="math">c=p(x)_{x\\in D}</span>. Conversely, <span class="math">p(X)=\\mathsf{Int}_{c}(X)</span>.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">3.5.3. Quotienting</h4>

    <p class="text-gray-300">For a word <span class="math">f\\in\\mathbb{F}^{n}</span>, the quotient function <span class="math">\\mathsf{Quot}_{x,y}:\\mathbb{F}^{n}\\to\\mathbb{F}^{k}</span> is defined as:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Quot}_{x,y}(f_{1}\\dots f_{n}):=\\Big{(}\\mathsf{Quot}_{x,y,1}(f_{1})\\dots\\mathsf{Quot}_{x,y,n}(f_{n})\\Big{)},</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{Quot}_{x,y,i}:\\mathbb{F}\\to\\mathbb{F}</span> and:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Quot}_{x,y,i}(f)=\\frac{f_{i}-y}{w^{i}-x}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that for any <span class="math">v\\in\\mathbb{F}\\setminus D</span> and any codeword <span class="math">c</span>, if it holds that $c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{v}=y<span class="math"> (i.e. </span>\\mathsf{Int}_{c}(v)=y<span class="math">) then </span>\\mathsf{Quot}_{v,y}(c)<span class="math"> is well defined. Moreover, if for a codeword </span>c<span class="math"> we have that </span>\\mathsf{Quot}_{v,y}(c)<span class="math"> is well defined, then it must be that </span>\\mathsf{Int}_{c}(v)=y$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-33" class="text-base font-medium mt-4">Lemma 3 (Quotienting Lemma)</h6>

    <p class="text-gray-300">Consider arbitrary <span class="math">x\\in\\mathbb{F}\\setminus D</span> and the function <span class="math">\\mathsf{Quot}_{x,y}:\\mathbb{F}^{n}\\to\\mathbb{F}^{k}</span> as defined directly above.</p>

    <p class="text-gray-300">For any <span class="math">c\\in\\mathbb{F}^{n}</span> and arbitrary proximity parameter <span class="math">\\theta\\in(0,1)</span>, it holds that:</p>

    <p class="text-gray-300"><span class="math">\\delta(c,\\mathsf{RS}[\\mathbb{F},D,k])\\leq\\theta</span>, <span class="math">\\mathsf{Int}_{c}(x)=y</span> if and only if <span class="math">\\delta(\\mathsf{Quot}_{x,y}(c),\\mathsf{RS}[\\mathbb{F},D,k-1])\\leq\\theta.</span></p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">3.5.4. Quotienting Matrices</h4>

    <p class="text-gray-300">Consider <span class="math">y\\in\\mathbb{F}^{m}</span>. The quotienting function can be extended to any matrix <span class="math">M\\in\\mathbb{F}^{m\\times n}</span> by considering every row <span class="math">m_{i}</span> of <span class="math">M</span> to be a word in <span class="math">\\mathbb{F}^{n}</span>. The quotient is applied on each row separately to obtain quotient matrix <span class="math">Q</span>, where the <span class="math">(i,j)</span> entry <span class="math">Q_{i,j}</span> is defined as:</p>

    <p class="text-gray-300"><span class="math">Q_{i,j}=\\mathsf{Quot}_{x,y_{i},j}(M_{i,j})=\\frac{M_{i,j}-y_{i}}{w^{j}-x}</span></p>

    <p class="text-gray-300">3.6 List Polynomial Commitments</p>

    <p class="text-gray-300">The following theorem is widely used to justify the proximity of a batch of vectors to the codewords. It informally says that if the linear combination <span class="math">f:=\\sum\\lambda^{i}f_{i}</span> has relative distance at most <span class="math">\\theta</span> from a codeword, then each <span class="math">f_{i}</span> follows a similar proximity property.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">(Correlated Agreement Theorem (CAT) full version of <em>[10]</em>, Theorem 6.1 and 6.2) Let the Reed-Solomon code <span class="math">\\mathsf{RS}[\\mathbb{F},D,k]</span> have the rate <span class="math">\\rho</span>. Given the proximity parameter <span class="math">\\theta</span> and the words <span class="math">f_{0},\\ldots,f_{N-1}\\in\\mathbb{F}^{D}</span> for which:</p>

    <p class="text-gray-300"><span class="math">\\Pr_{\\lambda\\in\\mathbb{F}}\\left[\\delta(\\sum_{i}\\lambda^{i}f_{i},\\mathsf{RS})\\leq\\theta\\right]&gt;\\epsilon</span></p>

    <p class="text-gray-300">where <span class="math">\\theta,\\epsilon</span> are from a chosen decoding regime Definition 7</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then there exist the polynomials <span class="math">p_{i}(X)\\in\\mathsf{RS}[\\mathbb{F},D,k]</span>, and a (agreement) set <span class="math">A\\subset D</span> of density $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 1-\\theta<span class="math"> on which </span>f_{0},\\ldots,f_{N-1}<span class="math"> jointly coincide with </span>p_{0}(X),\\ldots,p_{N-1}(X)$ respectively. In particular,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\forall\\lambda\\in\\mathbb{F}\\ :\\ \\delta(\\sum_{i}\\lambda^{i}f_{i},\\mathsf{RS})\\leq\\theta</span></p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Definition 7.</h6>

    <p class="text-gray-300">(Decoding Regime <em>[10]</em>) Theorem 1 holds in the following decoding regimes</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Unique Decoding Regime: for <span class="math">\\theta\\in(0,\\frac{1-\\rho}{2})</span>, Theorem 1 holds for $\\epsilon=(N-1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>List Decoding Regime: For <span class="math">\\theta\\in(\\frac{1-\\rho}{2},1-\\sqrt{\\rho})</span> and setting <span class="math">\\theta=1-\\sqrt{\\rho}\\cdot(1+1/2m)</span> with <span class="math">m\\geq 3</span>, Theorem 1 holds for:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon=(N-1)\\frac{(m+1/2)^{7}}{3\\rho^{3/2}}\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ (1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Capacity Regime: for <span class="math">\\theta\\in(1-\\sqrt{\\rho},1-\\rho)</span>, the error <span class="math">\\epsilon</span> is conjectured to satisfy,</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon\\leq\\frac{1}{(\\tau\\rho)^{c_{1}}}\\cdot\\frac{(N\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{c_{2}}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for <span class="math">\\tau=1-\\rho-\\theta</span> and <span class="math">c_{1},c_{2}</span> constants.</p>

    <p class="text-gray-300">As a small remark, the last case is currently a conjecture and will not be addressed in this paper.</p>

    <p class="text-gray-300">We say that the Reed-Solomon code <span class="math">V:=R[\\mathbb{F},D,k]</span> is <span class="math">(\\theta,L)</span>-list-decodable if for every <span class="math">u\\in\\mathbb{F}^{n}</span>, there are no more than <span class="math">L</span> codewords of <span class="math">V</span> that are within relative Hamming distance at most <span class="math">\\theta</span> from <span class="math">u</span>.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">(Johnson bound <em>[8]</em>) For every <span class="math">\\tau\\in(0,1-\\sqrt{\\rho})</span>, the code <span class="math">V</span> is <span class="math">(1-\\sqrt{\\rho},1/2\\tau\\sqrt{\\rho})</span>-list-decodable.</p>

    <p class="text-gray-300">We are now ready to present the syntax and security of the list polynomial commitment. The definitions here follow the ones from Redshift (<em>[22]</em>) but extended to a batched setting. Our presentation closely follows the formalization of <em>[11, 4]</em>. We considered batched openings of multiple polynomials. One difference is that we only consider openings of all these polynomials at the same evaluation point.</p>

    <p class="text-gray-300">The list polynomial commitment has a relaxed binding property, each commitment corresponding to a list of polynomials that is determined by a distance parameter. The commitment can be opened to any of the polynomials belonging to the list. Moreover, the polynomials in the list will jointly agree on the same agreement set, similarly to Theorem 1.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Definition 8 ((Batched) List Polynomial Commitment).</h6>

    <p class="text-gray-300">A list polynomial commitment scheme is a triplet <span class="math">(\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Open})</span> that is defined w.r.t. a linear code, distance parameter <span class="math">\\theta</span> and domain <span class="math">D</span>. It satisfies:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(1^{\\lambda},k)</span> generates public parameters <span class="math">\\mathsf{pp}</span> (a structured reference string) suitable to commit to polynomials of degree <span class="math">&lt;k</span>. Implicitly, the parameters for encoding are included in <span class="math">\\mathsf{pp}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Commit}(\\mathsf{pp},f_{1}(X)\\ldots f_{n}(X))</span> outputs a commitment <span class="math">C</span> to functions <span class="math">f_{1}(X)\\ldots f_{n}(X)\\in\\mathbb{F}[X]</span></li>

      <li><span class="math">\\mathsf{OpenEval}</span> is an IOP between a prover <span class="math">P_{\\mathrm{PC}}</span> and a verifier <span class="math">V_{\\mathrm{PC}}</span>, where the prover is given <span class="math">n</span> functions <span class="math">f_{1}(X)\\ldots f_{n}(X)\\in\\mathbb{F}[X]</span> and attempts to convince the verifier of the following relation:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\exists A\\subset D\\ \\mathrm{s.t}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(1-\\theta)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\mathrm{and}\\ \\exists(P_{1}\\ldots P_{n})\\in(\\mathbb{F}^{<k}[X])^{n}\\ \\mathrm{s.t}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\wedge\\ C=\\mathsf{Commit}(\\mathsf{pp},f_{1}\\ldots f_{n})</span></p>

    <p class="text-gray-300">where both parties receive the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>security parameter <span class="math">\\lambda</span>, degree bound <span class="math">k</span> and batch size <span class="math">n</span>, such that <span class="math">k,n=\\text{poly}(\\lambda)</span>.</li>

      <li>The public parameters <span class="math">\\mathsf{pp}</span>, where <span class="math">\\mathsf{pp}=\\mathsf{Setup}(1^{\\lambda},k)</span>.</li>

      <li>An evaluation point <span class="math">x</span> and alleged openings <span class="math">y=(y_{1}\\ldots y_{n})</span>.</li>

      <li>Alleged commitment <span class="math">C</span> for functions <span class="math">f_{1}(X)\\ldots f_{n}(X)</span>.</li>

    </ul>

    <p class="text-gray-300">In addition, the verifier receives oracle access to evaluations of <span class="math">f_{i}</span> over <span class="math">D</span>.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Definition 9 (Completeness of a List Polynomial Commitment Scheme)</h6>

    <p class="text-gray-300">We say that a polynomial commitment scheme has (perfect) completeness if for any security parameter <span class="math">\\lambda</span>, any integers <span class="math">k,n=\\text{poly}(\\lambda)</span>, any polynomials <span class="math">P_{1}(X)\\ldots P_{n}(X)\\in\\mathbb{F}_{&lt;k}[X]</span>, arbitrary evaluation point <span class="math">x</span> and alleged opening <span class="math">y</span>, if <span class="math">C=\\mathsf{Commit}(\\mathsf{pp},P_{1}(X)\\ldots P_{n}(X))</span> and <span class="math">P_{i}(x)=y_{i}</span> for all <span class="math">i\\in[n]</span> then an interaction of <span class="math">(P_{\\mathrm{PC}},V_{\\mathrm{PC}})</span> where <span class="math">P_{\\mathrm{PC}}</span> runs on the aforementioned parameters will result in the verifier accepting with probability one.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Definition 10 (Knowledge Soundness in the Random Oracle Model)</h6>

    <p class="text-gray-300">There must exist a <span class="math">\\mathrm{PPT}</span> extractor <span class="math">E</span> such that for every <span class="math">\\mathrm{PPT}</span> adversary <span class="math">\\mathcal{A}</span> and arbitrary degree <span class="math">k=\\text{poly}(\\lambda)</span>, the probability that <span class="math">\\mathcal{A}</span> wins the following game is negligible, where the probability is taken over the coins of <span class="math">\\mathsf{Setup}</span>, <span class="math">\\mathcal{A}</span> and <span class="math">V_{\\mathrm{PC}}</span>. Moreover, the extractor has access to the random oracle queries of <span class="math">\\mathcal{A}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> receives degree <span class="math">k</span> and <span class="math">\\mathsf{pp}=\\mathsf{Setup}(1^{\\lambda},k)</span>. <span class="math">\\mathcal{A}</span> outputs <span class="math">C</span>.</li>

      <li><span class="math">E</span> receives the commitment <span class="math">C</span> and inspects the random oracle queries made by <span class="math">A</span> in the previous step and recovers <span class="math">f_{1}(X)\\ldots f_{n}(X)\\in[X]</span>.</li>

      <li><span class="math">E</span> applies the efficient list-decoding algorithm on all <span class="math">f_{i}</span> simultaneously to obtain list <span class="math">L</span>, defined as:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$L=\\{(P_{1}(X),\\ldots,P_{n}(X))\\in(\\mathbb{F}^{<k}[X])^{n}\\ \\mathrm{s.t.}\\ \\exists A\\subset D,\\ \\mathrm{s.t.}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot(1-\\theta)\\ \\mathrm{and}\\ f_{i}(a)=P_{i}(a)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{a\\in A}\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> outputs an evaluation point <span class="math">x</span> and claimed openings <span class="math">y:=(y_{i})_{i}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> interacts with the <span class="math">V_{\\mathrm{PC}}</span> verifier of the <span class="math">\\mathsf{OpenEval}</span> algorithm. The inputs of <span class="math">\\mathcal{A}</span> for this subprotocol are <span class="math">C</span>, <span class="math">x</span> and <span class="math">y</span>.</li>

      <li>The extractor may check consistency and output a set <span class="math">S</span> of witnesses, where <span class="math">S\\subseteq L</span>.</li>

      <li><span class="math">\\mathcal{A}</span> succeeds if <span class="math">V_{\\mathrm{PC}}</span> accepts and there exists no tuple <span class="math">(P_{1}(X)\\ldots P_{n}(X))\\in L</span> such that <span class="math">P_{i}(x)=y_{i}</span> for all <span class="math">i\\in[n]</span>.</li>

    </ul>

    <h2 id="sec-41" class="text-2xl font-bold">4 UniEval Compiler: from PIOP to UniEval PIOP</h2>

    <p class="text-gray-300">Let <span class="math">\\mathcal{P}</span> be a PIOP protocol, where for <span class="math">i\\in[n],j\\in S_{i}</span>, the verifier queries a polynomial <span class="math">P_{i}</span> over a point <span class="math">x_{j}</span>.</p>

    <p class="text-gray-300">The aim of the compiler, presented here, is to reduce the initial PIOP to a PIOP where the oracle-given polynomials are all queried at a single random point. We will call such a PIOP scheme a UniEval PIOP, and the single query is denoted “Grail query”. For any evaluation <span class="math">P_{i}(x)</span> where <span class="math">x</span> is not the Grail query, the verifier gets <span class="math">P_{i}(x)</span> directly from the prover.</p>

    <p class="text-gray-300">In this model, replacing the oracle with a polynomial commitment scheme requires a proof of the evaluation for all the polynomials at the same point i.e., over the Grail query. The positive point is that batching</p>

    <p class="text-gray-300">at the polynomial commitment level is now more straightforward as all the polynomials are queried on the same evaluation point.</p>

    <p class="text-gray-300">Indeed, due to this compiler, the batching over different points is done at the PIOP level. At the polynomial commitment level, we only need batching over the same point.</p>

    <p class="text-gray-300">To build our compiler, we first present a batching technique of multiple polynomials over multiple points. We then use this protocol to compile any PIOP into a UniEval PIOP.</p>

    <h2 id="sec-42" class="text-2xl font-bold">4.1 Multiple-Point to Single-Point Reduction</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We assume a set of points <span class="math">T</span> and a set of <span class="math">n</span> polynomials <span class="math">\\{i \\in [n] : P_i(X)\\}</span>, each of degree <span class="math">d_i \\leq d</span>. Each <span class="math">P_i(X)</span> is queried on a set of evaluation points <span class="math">S_i \\subset T</span>. Define <span class="math">R_i(X)</span> as the alleged evaluations of <span class="math">P_i(X)</span> over the set <span class="math">S_i</span>, namely, <span class="math">R_i(X)</span> agrees with purported <span class="math">P_i(X)</span> over <span class="math">S_i</span> (and <span class="math">R_i(X)</span> is of degree $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$). The aim is to present a protocol for the relation;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R := \\left\\{\\left(S_i, R_i(X); P_i(X)\\right)_i \\quad \\forall i \\quad P_i(X)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{S_i} = R_i(X)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{S_i} \\right\\} \\tag{2}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Claim.</strong> The relation <span class="math">R</span> holds if and only if:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in [n] : \\left(P_i(X) - R_i(X)\\right) \\prod_{x \\in T \\setminus S_i} (X - x) \\text{ is divided by } \\prod_{x \\in T} (X - x). \\tag{3}</span></div>

    <p class="text-gray-300">Knowing this fact, in Fig. 1 we present our batching protocol for the relation Eq. (2). The protocol is inspired by the batching approach presented in [11].</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{MPSP}(S_1, \\dots, S_n, R_1, \\dots, R_n; P_1, \\dots, P_n)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the prover sends oracle access to <span class="math">P_i</span>.</li>

      <li>The verifier samples <span class="math">\\alpha \\leftarrow \\# \\mathbb{F}</span>.</li>

      <li>The prover computes and sends oracle-access to:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">Q(X) = \\sum_{i \\in [n]} \\alpha^i \\frac{P_i(X) - R_i(X)}{\\prod_{x \\in S_i} (X - x)}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier samples <span class="math">z \\leftarrow \\# \\mathbb{F}</span> and queries <span class="math">P_1(z), \\dots, P_n(z), Q(z)</span>.</li>

      <li>Finally, the verifier checks that: relation in 3 is satisfied for <span class="math">X = z</span> i.e.,</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">Q(z) \\prod_{x&#x27; \\in T} (z - x&#x27;) = \\sum_{i \\in [n]} \\left(\\alpha^i (P_i(z) - R_i(z)) \\prod_{x&#x27;&#x27; \\notin S_i} (z - x&#x27;&#x27;)\\right)</span></div>

    <p class="text-gray-300">Fig. 1. Multi-point to single-point reduction procedure.</p>

    <h2 id="sec-43" class="text-2xl font-bold">4.2 Security analysis</h2>

    <p class="text-gray-300">Here we prove that the protocol Fig. 1 is knowledge-sound for the relation Eq. (2). We show that if the verifier checks pass, the relation <span class="math">R</span> holds with overwhelming probability. The following security proof is adjusted from [11].</p>

    <p class="text-gray-300">Denote <span class="math">Z_H(X) \\coloneqq \\prod_H (X - x)</span> for an arbitrary set <span class="math">H \\subset \\mathbb{F}</span>, and we define also:</p>

    <div class="my-4 text-center"><span class="math-block">P(X) := \\sum_{i=1}^{n} \\alpha^{i-1} (P_i(X) - R_i(X)) Z_{T \\setminus S_i}</span></div>

    <p class="text-gray-300">By contradiction, assume that the relation <span class="math">R</span> (from Eq. (3)) does not hold. Then there exists <span class="math">i\\in[n]</span> and some <span class="math">x\\in S_{i}</span>, such that <span class="math">P_{i}(x)\\neq R_{i}(x)</span>, which means that <span class="math">x</span> is not a root of <span class="math">P_{i}(X)-R_{i}(X)</span>. This implies that we have:</p>

    <p class="text-gray-300"><span class="math">\\exists\\ i\\ \\text{s.t.}\\ Z_{S_{i}}\\nmid(P_{i}(X)-R_{i}(X))</span> (4)</p>

    <p class="text-gray-300">From Eq. (3), this is equivalent with:</p>

    <p class="text-gray-300"><span class="math">Z_{T}(X)\\nmid(P_{i}(X)-R_{i}(X))\\cdot Z_{T\\setminus S_{i}}</span></p>

    <p class="text-gray-300">Therefore, by Lemma 2, we know that with overwhelming probability:</p>

    <p class="text-gray-300"><span class="math">Z_{T}(X)\\nmid P(X)</span></p>

    <p class="text-gray-300">On the other hand, if the verification check passes, we have using the definiton of <span class="math">P(X)</span> that,</p>

    <p class="text-gray-300"><span class="math">Q(z)\\cdot Z_{T}(z)=P(z).</span></p>

    <p class="text-gray-300">Therefore, by the Schwartz-Zippel lemma w.r.t the variable <span class="math">X=z</span>, we know that with overwhelming probability <span class="math">Q(X)\\cdot Z_{T}(X)=P(X)</span> everywhere, which contradicts <span class="math">Z_{T}(X)\\nmid P(X)</span>.</p>

    <h3 id="sec-44" class="text-xl font-semibold mt-8">4.3 Compiler: PIOP to UniEval PIOP</h3>

    <p class="text-gray-300">We are now ready to compile a PIOP to its UniEval version.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any PIOP, define its associated protocol PIOP^{′} as follows; we let all the queries in PIOP be sent directly to the prover, and let the prover respond to these queries (the prover replies with alleged values for the evaluations, without providing a proof at this stage, as that would be handled later in the protocol). Indeed PIOP^{′} is the same as PIOP where the prover also plays the role of the oracle by itself.</li>

      <li>By the end of an execution of PIOP^{′}, we get the trace of the polynomial queries issued during PIOP^{′}; the set of polynomials <span class="math">P_{i}</span>, the points <span class="math">S_{i}</span>, and the alleged evaluations of <span class="math">P_{i}(X)</span> over <span class="math">S_{i}</span> which we denote by <span class="math">R_{i}(X)</span> (prover’s responses).</li>

      <li>Now, we consider our multi-point to the single-point protocol in Fig. 1, for the statement <span class="math">(R_{i},S_{i})</span> and the witness <span class="math">P_{i}(X)</span> from the trace. Call this protocol <span class="math">\\text{MPSP}(R_{i},S_{i};P_{i}(X))_{i}</span>.</li>

    </ul>

    <p class="text-gray-300">The compiler first runs PIOP^{′}, get the trace, and then runs <span class="math">\\text{MPSP}(R_{i},S_{i};P_{i}(X))_{i}</span>. The resulting PIOP is what we call UniEval-PIOP, denoted by UniEval-PIOP.</p>

    <p class="text-gray-300">Knowledge-Soundness. Let <span class="math">\\epsilon_{\\text{UniEval}}</span>, <span class="math">\\epsilon_{\\text{PIOP^{\\prime}}}</span> and <span class="math">\\epsilon_{\\text{MPSP}}</span> be, respectively, the soundness-error of protocols UniEval-PIOP, protocol PIOP^{′} and <span class="math">\\text{MPSP}(R_{i},S_{i};P_{i}(X))_{i}</span>. Then, we have, <span class="math">\\epsilon_{\\text{UniEval}}\\leq\\epsilon_{\\text{PIOP^{\\prime}}}+\\epsilon_{\\text{MPSP}}</span>.</p>

    <h2 id="sec-45" class="text-2xl font-bold">5 Vortex, A (Batchable) Polynomial Commitment</h2>

    <p class="text-gray-300">Vortex is a variant of the commitment scheme proposed in Orion <em>[33]</em>, Brakedown <em>[19]</em>, and Ligero <em>[3]</em>. Vortex allows performing a batched argument of multiple committed polynomials evaluated over the same given point <span class="math">x</span>. The main difference is that we discuss the security not in a standard binding model (relevant to the “unique decoding regime” in the coding literature) but rather in a more relaxed model (relevant to the “list decoding regime”). This point helps us improve the scheme’s efficiency but brings some challenges for the PIOP transformation into AoK via Vortex, which we will address later. Vortex is described in Section 5.1.</p>

    <p class="text-gray-300">For a matrix of size <span class="math">m\\cdot n=N</span>, the Vortex commitments and opening arguments have size <span class="math">O(\\sqrt{N})</span>. Moreover, the opening arguments have verification time <span class="math">O(\\sqrt{N})</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">5.1 Description of Vortex</p>

    <p class="text-gray-300">In this subsection, we expand on the details of Vortex. We will first assume two integers <span class="math">m</span> and <span class="math">k</span>, denoting the number of rows and columns. Vortex allows committing to <span class="math">m</span> vectors <span class="math">w_{i}\\in\\mathbb{F}^{k}</span> in a single commitment and opening them simultaneously for scalar products with a common public vector.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{H}</span> be a hash function parameterized to be able to hash vectors of size (at least) <span class="math">m</span> (For the instantiation we use MIMC <em>[2]</em> over SIS-hash<em>[25]</em>). We also use a <em>systematic</em> Reed-Solomon <span class="math">\\mathcal{L}</span> with message size <span class="math">k</span> and codeword-size <span class="math">n&gt;k</span>. We denote its distance by <span class="math">d</span>, its rate by <span class="math">\\rho=k/n</span> and we name its encoding algorithm <span class="math">\\mathsf{Encode}_{\\mathcal{C}}</span>. The Reed-Solomon encoding has <span class="math">O(n\\log n)</span> encoding time and benefits from Maximal Distance Separability.</p>

    <p class="text-gray-300">Vortex is a polynomial commitment scheme that efficiently opens multiple committed polynomials at the same point <span class="math">x</span>. The protocol consists of four algorithms: Setup, Commit and OpenEval.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup is a transparent offline phase run by both the prover and verifier. During this phase, they perform precomputations involving sampling the parameters for the hash and the encoding scheme used as the <em>public parameters</em>.</li>

      <li>The Commit algorithm: Let <span class="math">W</span>, be the matrix whose <span class="math">i^{\\text{th}}</span> row is <span class="math">w_{i}\\in\\mathbb{F}^{k}</span>. Thus, <span class="math">W</span> has <span class="math">m</span> rows and <span class="math">k</span> columns. The prover encodes each row of <span class="math">W</span> (noted by <span class="math">w_{i}</span>) using the encoding function and obtains <span class="math">W^{\\prime}</span> (which has <span class="math">n</span> columns). The prover then computes the hash of the columns. The value <span class="math">H=h_{1},\\cdots,h_{n}</span> forms the <em>commitment</em>.</li>

      <li>The batch-opening phase or OpenEval is an interactive protocol where the prover runs the ProveOpening algorithm and the verifier runs the VerifyOpening. At the beginning of this phase, the prover holds <span class="math">W,W^{\\prime}</span> and the verifier holds the <em>final commitment</em> as input. Both hold the statement <span class="math">x,y</span>, with the restriction that <span class="math">x\\in\\mathbb{F}\\setminus D</span>.</li>

    </ol>

    <p class="text-gray-300">The prover’s goal is to convince the verifier that <span class="math">\\forall i&lt;m,\\mathsf{Int}_{w_{i}}(x)=y_{i}</span> if <span class="math">W</span> is a batch of codewords <span class="math">w_{i}</span>. The verifier then sends the random scalar <span class="math">\\beta</span>, and the prover responds with <span class="math">u</span> claimed to be <span class="math">u:=\\mathcal{B}^{\\top}W</span>, if <span class="math">W</span> is polynomial, where <span class="math">\\mathcal{B}=(1,\\beta,\\beta^{2},\\ldots,\\beta^{m-1})</span>. Then, the verifier samples <span class="math">t</span> columns <span class="math">q_{1},\\cdots q_{t}</span> (<span class="math">q_{i}\\leq n</span>) uniformly at random, and the prover responds with <span class="math">(s_{1}\\cdots s_{t})</span> chosen columns of <span class="math">W^{\\prime}</span>. The verifier computes <span class="math">u^{\\prime}</span> as the Reed-Solomon encoding of <span class="math">u</span> and performs the following checks for all opened columns:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proximity Check: the scalar-product <span class="math">\\mathcal{B}^{\\top}s_{i}\\stackrel{{\\scriptstyle?}}{{=}}u^{\\prime}_{q_{i}}</span></li>

      <li>the hash of <span class="math">s_{i}</span> is correct and consistent with <span class="math">h_{q_{i}}</span>.</li>

      <li>Evaluation Check: the relation <span class="math">\\mathsf{Int}_{u}(x)\\stackrel{{\\scriptstyle?}}{{=}}\\mathcal{B}^{\\top}\\cdot y</span> where <span class="math">\\mathsf{Int}_{u}(X)</span> is the polynomial with the coefficients given in the vector <span class="math">u</span> (see Section 3.5.2).</li>

    </ul>

    <p class="text-gray-300">The first check (the random combination over random columns), is used for checking the proximity of a batch in <em>[3]</em>. Fig. 2 sums up the above.</p>

    <p class="text-gray-300">Constant Size Commitment. As a simple optimization over the commitment size, we apply a SNARK-friendly hash function (e.g., MiMC hash or Poseidon) over each <span class="math">h_{i}</span> and then compute a Merkle tree over the results.</p>

    <p class="text-gray-300">This is particularly useful for compiling PIOP to AoK via Vortex since the Vortex commitment phase will not be offline anymore and will be part of the proof. It is important to note, however, that the hash function used in the construction of the Merkle tree needs to be modeled as a random oracle for the scheme to retain extractability.</p>

    <p class="text-gray-300">Setup(n,m, \\mathcal{L},\\lambda)\\to \\mathsf{pp}</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup an instance of hash, Hash, corresponding to the security level  <span class="math">\\lambda</span></li>

      <li>Choose  <span class="math">t</span>  (the number of columns that should be opened later) to reach the security level  <span class="math">\\lambda</span></li>

      <li>Runs pre-computations relative to  <span class="math">\\mathsf{Encode}_{\\mathcal{C}}</span>  (e.g., finding  <span class="math">D \\subset \\mathbb{F}_q</span>  and relevant parameters for the security level  <span class="math">\\lambda</span> )</li>

      <li>Collect all the computed parameters in pp and return it.</li>

    </ol>

    <p class="text-gray-300">Commit(pp,W)  <span class="math">\\rightarrow</span> <span class="math">(h_1\\dots h_n)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Encode each row of  <span class="math">W</span>  and obtain  <span class="math">W^{\\prime}</span></li>

      <li>Hash each column of  <span class="math">W^{\\prime}</span>  to obtain  <span class="math">(h_1\\cdots h_n)</span></li>

      <li>Return  <span class="math">(h_1\\cdots h_n)</span></li>

    </ol>

    <p class="text-gray-300">Open(pp, C, P(X)) → 1/0</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>run  <span class="math">C&#x27; = \\operatorname{Commit}(\\mathsf{pp}, W)</span></li>

      <li>If  <span class="math">C&#x27; = C</span>  output 1 else output 0.</li>

    </ol>

    <p class="text-gray-300">OpenEval with statement  <span class="math">(l = (1, x \\dots x^{n-1}), y)</span> , where  <span class="math">x \\in \\mathbb{F} \\setminus D</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ProveOpening(pp, W', l, y)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VerifyOpening(pp, H, l, y)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | ← β  |</p>

    <p class="text-gray-300">|  B = (1, β, β2...βm-1) |   |</p>

    <p class="text-gray-300">|  u = B? W |   |</p>

    <p class="text-gray-300">|   | u →  |</p>

    <p class="text-gray-300">|   | q ←$[n]t  |</p>

    <p class="text-gray-300">|   | ← q  |</p>

    <p class="text-gray-300">|   | (s1, ..., st) →  |</p>

    <p class="text-gray-300">|   | u' ← EncodeC(u)  |</p>

    <p class="text-gray-300">|   | for 0 < i ≤ t:  |</p>

    <p class="text-gray-300">|  W' = EncodeC(W) |   |</p>

    <p class="text-gray-300">|  Denote the columns of W' as (s1...sn') |   |</p>

    <p class="text-gray-300">|   | {si, B} = u'qi  |</p>

    <p class="text-gray-300">|   | Hash(si) = hqi  |</p>

    <p class="text-gray-300">|   | Intu(x) = B · y.  |</p>

    <p class="text-gray-300">Fig. 2. The Vortex polynomial commitment.</p>

    <p class="text-gray-300">Here we show how to deal with the long polynomials.</p>

    <p class="text-gray-300">The prover  <span class="math">\\mathcal{P}</span>  can send a polynomial  <span class="math">P</span>  whose degree is larger than the number of columns in  <span class="math">W</span> . The polynomial can be folded in several chunks  <span class="math">P(X) = P_0(X) + X^n P_1(X) + \\dots</span> . Each one of the chunks  <span class="math">P_i(X)</span>  is then inserted into  <span class="math">W</span>  as an entire row.</p>

    <p class="text-gray-300">To commit and open the polynomials  <span class="math">P(X)</span>  via Vortex, set  <span class="math">W</span>  as above. The verifier can then recombine the  <span class="math">P_{i}(X)</span>  evaluations to obtain the  <span class="math">P(X)</span>  evaluation. This provides us with a way to switch between the definitions of batched polynomial commitments Definition 2 to a version that only commits to one polynomial.</p>

    <p class="text-gray-300">If the prover is honest and  <span class="math">P(X)</span>  is indeed a polynomial, then the proof of correctness is straightforward. Thus, we discuss soundness. We discuss the soundness of Vortex (as an LPC) based on the Correlated Agreement Theorem and in the list decoding regime.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We denote the rows of matrix <span class="math">W^{\\prime}</span> by <span class="math">w_{i}^{\\prime}</span>. Vortex aims to prove that there exist codewords <span class="math">g_{i}</span> corresponding to low-degree polynomials <span class="math">\\mathsf{Int}_{g_{i}}(X)</span> for every index <span class="math">i=1,\\ldots,m</span>, such that $\\delta(g_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{D},w_{i}^{\\prime})\\leq\\theta<span class="math"> (over the domain </span>D<span class="math">) and all the </span>g_{i}<span class="math"> jointly agree with </span>w_{i}<span class="math"> on agreement sets </span>A<span class="math"> of size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(1-\\theta)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Moreover, we ask that for a given evaluation point </span>x<span class="math">, we have </span>y_{i}=\\mathsf{Int}_{g_{i}}(x)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-48" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">Consider the Vortex protocol, as described in Fig. 2. The protocol satisfies knowledge soundness in the random oracle model, in the sense of Definition 10.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">First, we consider a hybrid game in which the responses of the random oracle never contain a collision. The random oracle is programmed so that on every new random oracle query it will sample a uniform output that has not been chosen before. The view of the adversary in this game is statistically close to the one in the original game, and we denote this statistical gap by <span class="math">\\epsilon_{\\text{collision}}</span>.</p>

    <p class="text-gray-300">With this simplification, for the purposes of this proof sketch, we now consider that the prover knows a matrix <span class="math">W^{\\prime}</span> that is committed inside the hash (if it knew more preimages, that would imply that the mallicious prover can find collisions in the hash function).</p>

    <p class="text-gray-300">By the definition of <span class="math">\\mathcal{R}_{LPC}</span>, the relation returns <span class="math">0</span> if <span class="math">W^{\\prime}</span> is far from any codeword, or no close codeword evaluates to the claimed <span class="math">y</span> at point <span class="math">x</span>.</p>

    <p class="text-gray-300">Define the two following cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case A: Matrix <span class="math">W^{\\prime}</span> is far from any matrix of codewords.</li>

      <li>Case B: Matrix <span class="math">W^{\\prime}</span> is close to at least one matrix of codewords, but no such codeword matrix evaluates to <span class="math">y</span> at point <span class="math">x</span>.</li>

    </ul>

    <p class="text-gray-300">The structure of the matrix is not directly apparent to the verifier. We will bound the probability of success for a malicious prover that has committed to matrix <span class="math">W^{\\prime}</span> in each of the two cases, and then explain how the two probabilities relate to the overall knowledge soundness of the protocol.</p>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">6.1 Bounding on Case A</h3>

    <p class="text-gray-300">Define <span class="math">w</span> as the linear combination over the rows of <span class="math">W^{\\prime}</span> i.e., <span class="math">w:=\\sum\\beta^{i}W_{i}^{\\prime}</span>. We denote by <span class="math">r_{\\mathcal{A}}</span> the random coins of the adversarial prover, and <span class="math">r_{V}</span> the coins of the verifier. To bound soundness in Case A, define by <span class="math">E_{\\text{KS}}</span> the event that <span class="math">\\mathcal{A}</span> wins in the knowledge-soundness game of Definition 10. Then, we have:</p>

    <p class="text-gray-300"><span class="math">\\Pr_{r_{P},r_{V}}(E_{\\text{KS}})</span> <span class="math">\\leq\\Pr_{r_{P},r_{V}}(E_{\\text{KS}}\\mid(\\delta(w,\\mathsf{RS})&gt;\\theta))</span> <span class="math">+\\Pr_{r_{P},r_{V}}(\\delta(w,\\mathsf{RS})\\leq\\theta)</span></p>

    <p class="text-gray-300">From the Correlated Agreement Theorem, we know that the second term happens with probability <span class="math">\\epsilon</span>, where <span class="math">\\theta</span> and <span class="math">\\epsilon</span> are from Correlated Agreement Theorem.</p>

    <p class="text-gray-300">Regarding the first term, there are two cases that the test may pass;</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The (honest) value <span class="math">w</span> would be different from the codeword <span class="math">u</span>, and then the prover tries to change the value of the opened column by finding a collision on the RO responses. However, recall that we work in a hybrid game in which the random oracle is programmed in such a way as to never produce collisions.</li>

      <li>The prover is just lucky and the chosen columns are the one that matches the codeword. This happens with probability <span class="math">(1-\\theta)^{t}</span>.</li>

    </ul>

    <p class="text-gray-300">Therefore,</p>

    <p class="text-gray-300"><span class="math">\\Pr_{r_{P},r_{V}}(E_{\\text{KS}})</span> <span class="math">\\leq\\Pr_{r_{P},r_{V}}(E_{\\text{KS}}\\mid(\\delta(w,\\mathsf{RS})&gt;\\theta))+\\Pr_{r_{P},r_{V}}(\\delta(w,\\mathsf{RS})\\leq\\theta)\\leq</span> <span class="math">\\leq(1-\\theta)^{t}+\\epsilon</span></p>

    <p class="text-gray-300">6.2 Bounding on Case B</p>

    <p class="text-gray-300">Here we bound the soundness error conditioned on Case B. Here, matrix <span class="math">W^{\\prime}</span> is close to at least one matrix of codewords, but no such codeword matrix evaluates to <span class="math">y</span> at point <span class="math">x</span>.</p>

    <p class="text-gray-300">We define the list <span class="math">L</span> as the set of matrix <span class="math">G^{\\prime}</span> where <span class="math">i</span>-th row of <span class="math">G^{\\prime}</span> is at most <span class="math">\\theta</span>-far from the <span class="math">i</span>-th row of <span class="math">W^{\\prime}</span>. Thus,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$L:=\\{G^{\\prime}\\ :\\ \\exists A\\subset D,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(1-\\theta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ s.t.\\ w^{\\prime}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{A}=g^{\\prime}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{A}\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For a matrix <span class="math">M=(m_{i})_{i}</span> of size <span class="math">m\\cdot n</span>, we use functions <span class="math">\\mathsf{Quot}_{x,y,j}</span> (see Section 3.5.4) to define the quotient matrix <span class="math">Q</span> w.r.t the point <span class="math">x\\in\\mathbb{F}</span> and the vector <span class="math">y=(y_{i})_{i}</span> of length <span class="math">m</span> as:</p>

    <p class="text-gray-300"><span class="math">Q_{i,j}=\\mathsf{Quot}_{x,y_{i},j}(M_{i,j})=\\frac{M_{i,j}-y_{i}}{w^{j}-x}</span></p>

    <p class="text-gray-300">Remark: When arguing that the quotients are well defined, we use that <span class="math">x\\in\\mathbb{F}\\setminus D</span>.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">If the proximity test passes with probability more than <span class="math">\\epsilon^{*}:=(1-\\theta)^{t}+\\epsilon</span>, and the evaluation check on <span class="math">u^{\\prime}</span> passes, then there is a codeword <span class="math">G\\in L</span> such that <span class="math">g_{i}(x)=y_{i}</span>. Define by <span class="math">E_{\\textup{KS}}</span> the event that <span class="math">\\mathcal{A}</span> wins the knowledge soundness game of Definition 10, and by <span class="math">r_{P},r_{V}</span> the random coins of the prover and verifier. Consequently, in case <span class="math">B</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr_{r_{P},r_{V}}(E_{\\textup{KS}})=0</span></p>

    <p class="text-gray-300">.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Recall that <span class="math">\\beta</span> is the coin used to compute the linear combination and <span class="math">\\mathbf{q}</span> is the vector sent by the verifier in order to specify which columns to open. The probability bound of the hypothesis is equivalent to:</p>

    <p class="text-gray-300"><span class="math">\\Pr_{\\beta\\in\\mathbb{F}}[\\ \\Pr_{\\mathbf{q}\\in[n]^{t}}[u^{\\prime}_{q_{j}}=(\\mathcal{B}\\cdot W^{\\prime})_{q_{j}}\\text{ for all }j\\in[t]]\\geq(1-\\theta)^{t}]\\geq\\epsilon</span> (5)</p>

    <p class="text-gray-300">Now, we note that the verifier accepts only if the evaluation check is successful, therefore we have that <span class="math">\\mathsf{Int}_{u^{\\prime}}(x)=\\mathcal{B}y</span>, which means that we can define the following quotient vector <span class="math">q_{u}=\\mathsf{Quot}_{x,\\mathcal{B}\\cdot y}(u^{\\prime})</span> (the quotient is well defined due to the evaluation check and the fact that <span class="math">x\\in\\mathbb{F}\\setminus D</span>). Equivalently, <span class="math">q_{u}</span> is such that:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Int}_{q_{u}}(X):=\\frac{\\mathsf{Int}_{u^{\\prime}}(X)-\\mathcal{B}y}{X-x}</span></p>

    <p class="text-gray-300">The vector <span class="math">q_{u}</span> thus corresponds to the quotienting of the vector <span class="math">u^{\\prime}</span> (and recall that <span class="math">u^{\\prime}</span> was obtained on the verifier side as the encoding of the vector <span class="math">u</span> sent by the prover during the protocol). Therefore, since <span class="math">u^{\\prime}\\in\\mathsf{RS}[\\mathbb{F},D,k]</span>:</p>

    <p class="text-gray-300"><span class="math">q_{u}:=\\mathsf{Quot}_{x,\\mathcal{B}\\cdot y}(u^{\\prime})\\in\\mathsf{RS}[\\mathbb{F},D,k-1]</span></p>

    <p class="text-gray-300">.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using Eq. (5), recall that in this sub-case, we know that the proximity check over <span class="math">W^{\\prime}</span> passes with probability more than <span class="math">\\epsilon^{*}</span> (the proximity check ensured that the columns of <span class="math">W^{\\prime}</span> queried by the verifier correspond to <span class="math">u^{\\prime}</span>). Therefore, we have that <span class="math">\\delta(u^{\\prime},\\mathcal{B}\\cdot W^{\\prime})\\leq\\theta</span> for an $\\epsilon\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> portion of </span>\\beta$. More precisely,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\beta\\in\\mathbb{F}}[\\mathcal{B}\\cdot W^{\\prime}=u^{\\prime}\\text{ over some set }A,\\quad</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>(1-\\theta)^{t}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]\\geq\\epsilon$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">From the two above equations, we conclude that for an $\\epsilon\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> portion of </span>\\beta$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\exists q_{u}\\in\\mathsf{RS}[\\mathbb{F},D,k-1]\\text{ s.t. }\\mathsf{Quot}_{x,\\mathcal{B}\\cdot Y}(\\mathcal{B}\\cdot W^{\\prime})=q_{u},\\text{ over }A\\text{ where }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(1-\\theta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The key observation now concerns the role played by <span class="math">\\mathcal{B}</span> in the computation of the quotient, by noting that <span class="math">\\mathsf{Quot}_{x,\\mathcal{B}\\cdot Y}(\\mathcal{B}\\cdot W^{\\prime})=\\mathcal{B}\\cdot\\mathsf{Quot}_{x,Y}(W^{\\prime})</span> to rewrite the probability as:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\beta\\in\\mathbb{F}}\\Big{(}\\exists q_{u}\\in\\mathsf{RS}[\\mathbb{F},D,k-1]\\text{ s.t. }\\mathcal{B}\\cdot\\mathsf{Quot}_{x,y}(W^{\\prime})=q_{u}\\text{ over }A,\\text{ where }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(1-\\theta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Big{)}\\geq\\epsilon$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}\\cdot\\mathsf{Quot}_{x,y}(W^{\\prime})</span> is the random linear combination over the rows of quotient matrix <span class="math">\\mathsf{Quot}_{x,y}(W^{\\prime})</span>, the condition of the correlated agreement theorem (CAT, Theorem 1) over <span class="math">\\mathsf{Quot}_{x,y}(W^{\\prime})</span> is satisfied. Namely, the random linear combination over the rows of the quotient matrix is close to a codeword. Therefore by CAT, we have that each row <span class="math">q_{i}</span> of <span class="math">\\mathsf{Quot}_{x,y}(W^{\\prime})</span> satisfies that <span class="math">\\delta(q_{i},\\mathsf{RS}[\\mathbb{F},D,k-1])&lt;\\theta</span>, and consequently by Lemma 3 each row of <span class="math">W^{\\prime}</span> is close to a codeword <span class="math">g_{i}\\in\\mathsf{RS}[\\mathbb{F},D,k-1]</span> such that <span class="math">\\mathsf{Int}_{g_{i}}(x)=y_{i}</span>.</p>

    <p class="text-gray-300">Taking into account all the terms, for the soundness-error of Vortex we have that for <span class="math">m^{\\prime}\\geq 3</span>.</p>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\text{soundness}}</span> <span class="math">\\leq\\epsilon_{\\text{collision}}+(1-\\theta)^{t}+\\epsilon</span> (6) <span class="math">\\theta</span> <span class="math">=1-\\sqrt{\\rho}-\\frac{\\sqrt{\\rho}}{2m^{\\prime}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\epsilon</span> $\\leq(m-1)\\frac{(m^{\\prime}+1/2)^{7}}{3\\rho^{3/2}}\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">m,k</span> are the number of rows and columns of <span class="math">W</span> (choice of <span class="math">m</span> also depends on the security level of the hash function, and the choice of <span class="math">k</span> depends on the message space of Reed-Solomon code).</p>

    <h4 id="sec-53" class="text-lg font-semibold mt-6">Knowledge extraction of Vortex</h4>

    <p class="text-gray-300">We first recap the following lemma showing an efficient decoding algorithm for the Reed-Solomon code.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">(Guruswami-Sudan) For the Reed-Solomon code <span class="math">\\mathsf{RS}[\\mathbb{F},D,k]</span> with rate <span class="math">\\rho</span> and proximity parameter <span class="math">\\theta&lt;1-\\sqrt{\\rho}</span>, the Guruswami-Sudan algorithm can recover from <span class="math">w\\in\\mathbb{F}^{n}</span> all the codewords <span class="math">c</span> such that <span class="math">\\delta(w,c)\\leq\\theta</span> from <span class="math">w</span> in time <span class="math">O(n^{3})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">P</span> be a prover that suceeds in the interaction with the Vortex verifier with non-negligible probability. The extractor uses this prover to extract the witness <span class="math">W^{\\prime}</span>, in the following manner: it runs the prover in the ROM model. By this, the extractor will get access to <span class="math">W^{\\prime}</span>. To extract the matrices <span class="math">G</span>, we use the approach of <em>[31, Lemma 1]</em> that uses the Guruswami-Sudan list decoding repeatedly over the rows of <span class="math">W^{\\prime}</span> and for every row, it intersects the result with the agreement sets that have already been computed, such that the intersection is of size $\\geq(1-\\theta)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. By this, it extracts all the codeword matrices close to </span>W^{\\prime}<span class="math">. Then we can find the one consistent with </span>u,x,y$ (e.g., by brute force, since the list size is polynomial).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-55" class="text-2xl font-bold">7 Soundness of AoK from PIOP and LPC</h2>

    <p class="text-gray-300">In <em>[14]</em>, the authors show that combining a knowledge-sound polynomial commitment with knowledge-sound PIOP results in a knowledge-sound argument system. This cannot be applied directly to our setting. Particularly, since we are working with polynomial commitments in the list decoding regime (LPC), the knowledge-soundness of Vortex is not defined w.r.t a standard relation for a PC scheme.</p>

    <p class="text-gray-300">In <em>[22]</em>, they show that Batch-FRI in the list-decoding regime (as an LPC) can be combined with PLONK-PIOP resulting in an argument system.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">There is some evidence that shows that such a transformation can still be possible for special PIOP and with the cost of losing a factor $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ of the soundness of PIOP <em>[22, 8]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Here we generalize these results and show that any PIOP can be combined with an LPC to give a secure AoK.</p>

    <p class="text-gray-300">Slightly more formal, let <span class="math">(P_{O},V_{O})</span> be a PIOP for the relation <span class="math">\\mathcal{R}</span> that is transformed to a AoK <span class="math">(P,V)</span> via a list polynomial commitment <span class="math">(P_{c},V_{c})</span>. Then it is conjectured that the soundness-error of AoK follows from,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\epsilon_{\\text{PIOP}}+\\epsilon_{\\text{LPC}}\\approx O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot k/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\epsilon_{\\text{LPC}})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">k</span> is the degree of polynomials involved in the PIOP and <span class="math">L</span> is the maximum size of the list associated with the LPC. If the size of the field is big compared to $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, working in the list decoding regime could provide useful tradeoffs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Section 7.2, we present a proof and bounds for the compilation to AoK from PIOP and list polynomial commitments.</p>

    <p class="text-gray-300">7.1 Aggregatable LPC</p>

    <p class="text-gray-300">An aggregatable LPC scheme is a LPC equipped with a batch opening algorithm. The batch opening algorithm can prove the correct evaluation of polynomials (at the same point) committed separately. Note the difference between batching the polynomials under the same commitment (Vortex as a batch polynomial commitment) and batching under different commitments which we call aggregation here.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Apart from the batching property, what makes aggregatable-LPC interesting is the fact that it imposes the same agreement set (out of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> sets) for all the polynomials committed separately (e.g., committed in different rounds of PIOP). This will allow us to avoid a soundness loss of </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{r}<span class="math">, where </span>r<span class="math"> is the number of rounds in the PIOP. Instead, the soundness loss will be </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Aggregation of Vortex. Regarding Vortex, its Aggregation is similar to the original Vortex scheme. Let <span class="math">W_{i}</span> denote the matrices committed separately. Generally speaking, the witness matrix <span class="math">W</span> is built by putting the matrices <span class="math">W_{i}</span> one over the other and then applying the Vortex over <span class="math">W</span>. The differences and the details are described in the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>set the parameters for Vortex.</li>

      <li>commit to each matrix <span class="math">W_{i}</span> separately by Vortex commitment and denote it as <span class="math">c_{i}</span>.</li>

      <li>to open all the polynomials at point <span class="math">x</span>, Set <span class="math">l=(1,x,x^{2},\\ldots,x^{n})</span> and let <span class="math">W</span> be the stacking of the matrices <span class="math">W_{i}</span> over each other.</li>

      <li>the verifier sends the randomness <span class="math">\\beta</span> where it receives <span class="math">u</span> as the response from the prover.</li>

      <li>the verifier sends the random list of columns <span class="math">\\mathbf{q}</span>.</li>

      <li>the prover opens the chosen columns of <span class="math">W</span>, it also sends <span class="math">u=\\bar{\\mathcal{B}}\\cdot W</span> where <span class="math">\\bar{\\mathcal{B}}=(\\mathcal{B},\\beta^{m}\\mathcal{B},\\beta^{2m}\\mathcal{B},\\ldots)</span> and <span class="math">\\mathcal{B}</span> is as in the Vortex.</li>

      <li>the verifier extends <span class="math">u</span> to its Reed-Solomon encoding and obtains <span class="math">u^{\\prime}</span>. It then proceeds similarly to the original Vortex protocol and performs the checks as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for the chosen columns, it breaks them into sub-columns of <span class="math">W_{i}</span> and checks the hash consistency separately with each <span class="math">c_{i}</span>.</li>

      <li>checks <span class="math">u\\cdot l=\\sum_{i}\\beta^{im}\\mathcal{B}\\cdot\\vec{y}_{i}</span> where <span class="math">\\vec{y}_{i}</span> represent the evaluation values associated with <span class="math">W_{i}</span> (this check is equivalent to <span class="math">\\mathsf{Int}_{u}(x)=\\sum_{i}\\beta^{im}\\mathcal{B}\\cdot\\vec{y}_{i}</span>).</li>

      <li><span class="math">\\sum\\bar{\\mathcal{B}}\\cdot s_{(i)}\\stackrel{{\\scriptstyle?}}{{=}}u^{\\prime}_{q_{i}}</span> for the chosen columns <span class="math">\\{s_{(i)}\\}_{i\\in\\mathbf{q}}</span> of <span class="math">W</span>.</li>

    </ul>

    <p class="text-gray-300">Note that the aggregatable version of Vortex is equivalent to an application of Vortex over the big matrix <span class="math">W</span> (described above). Therefore, the transformation preserves its knowledge soundness where in the soundness formula Eq. (6) the number of rows <span class="math">m</span> in the last term and in <span class="math">\\epsilon</span> is the number of rows of <span class="math">W</span>, i.e., the big matrix (note that <span class="math">\\epsilon_{\\text{collision}}</span> does not change).</p>

    <p class="text-gray-300">We emphasize that for optimizing the proof size during the compilation of PIOP to AoK, each Vortex commitment <span class="math">c_{i}</span> is of constant size via MiMC hashing and the Merkle-Tree structure as explained in the description of Vortex.</p>

    <h3 id="sec-56" class="text-xl font-semibold mt-8">7.2 AoK from UniEval PIOP and Aggregatable-LPC</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As mentioned in the description of Vortex, a commitment can be opened to a list of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. In order to replace the oracle of UniEval PIOP with aggregatable-LPC, one replaces the oracle with the </span>i^{\\text{th}}$ element of the lists. We show that aggregatable-LPC can simulate the oracle of UniEval-PIOP.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Regarding the security of such a compiler, we prove that if UniEval-PIOP and aggregatable-LPC are knowledge-sound, then the resulting AoK is knowledge-sound. Before going to the security proof, let us clarify how we combine an LPC with an UniEval-PIOP to have a more efficient AoK.</p>

    <h4 id="sec-57" class="text-lg font-semibold mt-6">AoK Construction</h4>

    <p class="text-gray-300">Here we assume that PIOP has several polynomials for the same round <span class="math">i</span> which we embed in matrix <span class="math">W_{i}</span>. For a batch of matrices <span class="math">W_{i}</span> from different rounds, we have to commit to each matrix separately at the associated</p>

    <p class="text-gray-300">round but can defer the batch opening (aggregation step) once at the end. Without loss of generality, we assume the matrices <span class="math">W_{i}</span> are all of the same size. We also assume that UniEval-PIOP has been processed through the compiler in Fig. 1, and now its verifier sends only a single query (at point <span class="math">z</span> as in Section 4.1). The query is for all the polynomials at the same point, and this allows us to benefit from batching properties of Vortex over the same point (for both cases; polynomials committed at the same round, or in different rounds).</p>

    <h3 id="sec-58" class="text-xl font-semibold mt-8">7.3 Soundness of AoK</h3>

    <h6 id="sec-59" class="text-base font-medium mt-4">Theorem 6.</h6>

    <p class="text-gray-300">Let aLPC be an aggregated LPC and Prot be an UniEval PIOP for a relation <span class="math">R</span>. Consider the interactive argument of knowledge protocol Prot^{′} for the same relation <span class="math">R</span>, obtained in the following way:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>every time a polynomial is sent to an oracle in Prot, the operation is replaced by sending an aLPC commitment in Prot^{′}.</li>

      <li>Prot contains rounds in which the prover sends alleged evaluations of polynomials without an accompanying proof (as in Section 4). The same rounds are carried out identically in Prot^{′}.</li>

      <li>The final round of Prot represents an opening of all polynomials at the same point <span class="math">z</span>. In Prot^{′}, this is replaced by an opening of all the polynomials committed using the aLPC protocol at point <span class="math">z</span>.</li>

      <li>All other rounds of Prot are reproduced identically in Prot^{′}.</li>

      <li>The verifier <span class="math">V_{\\textsf{Prot}^{\\prime}}</span> acts in the same way as <span class="math">V_{\\textsf{Prot}}</span> but it also runs <span class="math">V_{\\textsf{aLPC}}</span> in order to check the claimed openings at the end of the protocol.</li>

    </ul>

    <p class="text-gray-300">We require that the aLPC commitment is knowledge-sound in the random oracle model and Prot is a knowledge-sound UniEval PIOP for <span class="math">R</span>. Moreover, both aLPC and Prot have straight-line extractors and the list of polynomial candidates can be extracted using only the commitments and the random oracle queries. Then, it holds that Prot^{′} is a knowledge-sound interactive argument of knowledge for <span class="math">R</span> in the random oracle model.</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We first exhibit an extractor <span class="math">E_{\\text{AOK}}</span> for the relation R. <span class="math">E_{\\text{AOK}}</span> uses the aLPC extractor <span class="math">E_{\\text{aLPC}}</span> and the UniEval PIOP extractor <span class="math">E_{\\text{PIOP}}</span>. <span class="math">E_{\\text{AOK}}</span> interacts with an adversary <span class="math">P^{*}</span> against the knowledge-soundness of Prot^{′} and proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">E_{\\text{AOK}}</span> will interact with adversary <span class="math">P^{*}</span> and make several changes in order to construct on-the-fly an adversary <span class="math">P_{\\text{PIOP}}</span> against the UniEval PIOP protocol. The constructed adversary <span class="math">P_{\\text{PIOP}}</span> will make use of access to random oracle queries and run the extractor <span class="math">E_{\\text{aLPC}}</span> as a subroutine.</li>

      <li><span class="math">E_{\\text{AOK}}</span> will run the extractor <span class="math">E_{\\text{PIOP}}</span> on an interaction with adversary <span class="math">P_{\\text{PIOP}}</span> which is built on-the-fly from the interaction with <span class="math">P^{*}</span>. <span class="math">E_{\\text{PIOP}}</span> will output a witness if the interaction resulted in an accepting transcript, and <span class="math">E_{\\text{AOK}}</span> outputs the same witness as its result.</li>

    </ul>

    <p class="text-gray-300">We show how to start from adversary <span class="math">P^{*}</span> against the knowledge soundness of the argument of knowledge Prot^{′}, and construct an adversary <span class="math">P_{\\text{PIOP}}</span> against the UniEval PIOP Prot. the Adversary <span class="math">P_{\\text{PIOP}}</span> proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It receives a statement <span class="math">\\textsf{stm}_{\\text{AOK}}</span> from <span class="math">P^{*}</span>, and sets it as its own statement <span class="math">\\textsf{stm}_{\\text{PIOP}}</span> by forwarding it to its challenger (i.e. <span class="math">\\textsf{stm}_{\\text{AOK}}=\\textsf{stm}_{\\text{PIOP}}</span>).</li>

      <li>It then honestly generates the parameters for aLPC and sends them to <span class="math">P^{*}</span>.</li>

      <li>The first time <span class="math">P^{*}</span> commits to a polynomial, <span class="math">P_{\\text{PIOP}}</span> uses the aLPC extractor to obtain the list of polynomials that correspond to the commitment. It aborts if the extraction fails.</li>

    </ul>

    <p class="text-gray-300">Since <span class="math">P^{<em>}</span> will be able to later open to any of the polynomials in the list, <span class="math">P_{\\text{PIOP}}</span> guesses an index <span class="math">i^{</em>}</span> that corresponds to the <span class="math">i^{\\text{th}}</span> polynomial in the list.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Guessed index <span class="math">i^{<em>}</span> is kept hidden from <span class="math">P^{</em>}</span>. <span class="math">P_{\\text{PIOP}}</span> forwards the <span class="math">i^{\\text{th}}</span> polynomial to the PIOP oracle.</li>

      <li>All subsequent rounds in which <span class="math">P^{<em>}</span> commitms to more polynomials require that <span class="math">P_{\\text{PIOP}}</span> extracts using the aLPC extractor and forwards the polynomial at index <span class="math">i^{</em>}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier queries are sent to <span class="math">P^{<em>}</span>. If the responses are not consistent with guess <span class="math">i^{</em>}</span>, <span class="math">P_{\\text{PIOP}}</span> aborts. Otherwise, it forwards the responses back to the verifier.</li>

      <li>Finally, as in Section 4, an oracle query on point <span class="math">z</span> is received from the verifier. If <span class="math">z \\in D</span>, then since the security of our aLPC is not guaranteed in this case, it aborts.</li>

    </ul>

    <p class="text-gray-300">Otherwise, <span class="math">P_{\\text{PIOP}}</span> forwards <span class="math">z \\notin D</span> to <span class="math">P^{<em>}</span>, which replies with an aggregated aLPC proof that certifies openings for all polynomials on <span class="math">z</span>. <span class="math">P_{\\text{PIOP}}</span> aborts if there are inconsistencies with the guessed index <span class="math">i^{</em>}</span>. Otherwise, it forwards the responses to the verifier.</p>

    <p class="text-gray-300">The prover <span class="math">P^{<em>}</span> has the freedom to open to any polynomial belonging to the decoding list. However, once <span class="math">P^{</em>}</span> chooses an index, it has to open any further aggregated commitments to the same index (the index corresponds to choosing an agreement set in Theorem 1). If it did not open further indices consistently, this would be detectable by the fact that a verifying aLPC opening can only be performed with respect to the same index.</p>

    <p class="text-gray-300">There is partial leakage on index <span class="math">i^{<em>}</span> from the point of view of <span class="math">P^{</em>}</span>. By the fact that an abort has not yet been initiated by <span class="math">P_{\\text{PIOP}}</span>, <span class="math">P^{<em>}</span> infers only that index <span class="math">i^{</em>}</span> is consistent with its own choices of how to respond with claimed evaluations to polynomials (without an aLPC proof, which is sent only at the end). However, these choices are also enforced to be consistent with the aLPC opening in the last round.</p>

    <p class="text-gray-300">We define the following events:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Ev}_{\\mathrm{KS},P_{\\mathrm{PIOP}}}^{\\mathrm{PIOP}}</span> is the event that <span class="math">P_{\\mathrm{PIOP}}</span> wins its knowledge soundness game. This means that <span class="math">\\langle P_{\\mathrm{PIOP}} \\leftrightarrow V_{\\mathrm{PIOP}} \\rangle = 1</span> for an invalid <span class="math">\\mathsf{stm}_{\\mathrm{PIOP}}</span>. Verifier <span class="math">V_{\\mathrm{PIOP}}</span> plays the role of the external challenger.</li>

      <li><span class="math">\\mathsf{Ev}_{\\mathrm{KS},P^{<em>}}^{\\mathrm{AOK}}</span> is the event that <span class="math">\\langle P^{</em>} \\leftrightarrow V_{\\mathsf{Prot}^{\\prime}} \\rangle = 1</span> in the context of <span class="math">P^{*}</span> winning the knowledge-soundness game in Definition 1.</li>

      <li><span class="math">\\mathsf{Ev}_{\\mathrm{KS},P^{<em>}}^{\\mathrm{aLPC}}</span> is the event that <span class="math">P^{</em>}</span> breaks the security of the aLPC commitment, as defined in Definition 10.</li>

      <li><span class="math">\\mathsf{Ev}_{P_{\\mathrm{PIOP}}}^{\\mathrm{index}}</span> is the event that <span class="math">P_{\\mathrm{PIOP}}</span> guesses the index <span class="math">i^{*}</span> correctly.</li>

    </ul>

    <p class="text-gray-300">From the manner in which we defined <span class="math">P_{\\mathrm{PIOP}}</span>, and <span class="math">\\mathsf{Prot}^{\\prime}</span>, we have:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left(\\mathsf{Ev}_{\\mathrm{KS},P_{\\mathrm{PIOP}}}^{\\mathrm{PIOP}}\\right) = \\Pr \\left(\\mathsf{Ev}_{\\mathrm{KS},P^{*}}^{\\mathrm{AOK}} \\wedge \\overline{\\mathsf{Ev}_{\\mathrm{KS},P^{*}}^{\\mathrm{aLPC}}} \\wedge \\mathsf{Ev}_{P_{\\mathrm{PIOP}}}^{\\mathrm{index}} \\wedge z \\notin D\\right)</span></div>

    <p class="text-gray-300">Since the choice of the index is independent of the success probabilities, we then have:</p>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left(\\mathsf{Ev}_{\\mathrm{KS},P_{\\mathrm{PIOP}}}^{\\mathrm{PIOP}}\\right) &amp;= 1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\Pr \\left(\\mathsf{Ev}_{\\mathrm{KS},P^{<em>}}^{\\mathrm{AOK}} \\wedge (\\overline{\\mathsf{Ev}_{\\mathrm{KS},P^{</em>}}^{\\mathrm{aLPC}} \\vee z \\in D})\\right) \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">&amp;\\geq 1 /</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">\\cdot \\left(\\left(\\Pr \\left(\\mathsf{Ev}_{\\mathrm{KS},P^{<em>}}^{\\mathrm{AOK}}\\right) - \\Pr \\left(\\mathsf{Ev}_{\\mathrm{KS},P^{</em>}}^{\\mathrm{aLPC}}\\right) - \\Pr(z \\in D\\right)\\right)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{aligned} $$</p>

    <p class="text-gray-300">Therefore, we equivalently have:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left(\\mathsf{Ev}_{\\mathrm{KS},P^{*}}^{\\mathrm{AOK}}\\right) \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\Pr \\left(\\mathsf{Ev}_{\\mathrm{KS},P_{\\mathrm{PIOP}}}^{\\mathrm{PIOP}}\\right) + \\Pr \\left(\\mathsf{Ev}_{\\mathrm{KS},P^{*}}^{\\mathrm{aLPC}}\\right) + \\Pr(z \\in D)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Since all the probabilities on the right are negligible, <span class="math">\\Pr(\\mathsf{Ev}_{\\mathrm{KS},P^{*}}^{\\mathrm{AOK}})</span> is negligible.</p>

    <h2 id="sec-61" class="text-2xl font-bold">Future Work</h2>

    <p class="text-gray-300">We plan to add an analysis of the transformation to non-interactive argument of knowledge, concrete parameter choices for the entire scheme and benchmarks in future versions of this document.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] <em>A native zkEVM Layer 2 Solution for Ethereum</em>. url: https://scroll.io/.</li>

      <li>[2] Martin R. Albrecht et al. “MiMC: Efficient Encryption and Cryptographic Hashing with Minimal Multiplicative Complexity”. In: <em>ASIACRYPT</em>. Vol. 10031. LNCS. 2016, pp. 191–219.</li>

      <li>[3] Scott Ames et al. “Ligero: Lightweight Sublinear Arguments Without a Trusted Setup”. In: <em>Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security</em> (2017).</li>

      <li>[4] Zachary Ariel Gabizon, J. Williamson, and Oana Ciobotaru. “PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge”. In: <em>IACR Cryptol. ePrint Arch.</em> (2019), p. 953.</li>

      <li>[5] Olivier Bégassat et al. <em>A ZK-EVM specification</em>. 2022.</li>

      <li>[6] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. “Interactive Oracle Proofs”. In: <em>Theory of Cryptography - 14th International Conference, TCC 2016-B, Beijing, China, October 31 - November 3, 2016, Proceedings, Part II</em>. Ed. by Martin Hirt and Adam D. Smith. Vol. 9986. Lecture Notes in Computer Science. 2016, pp. 31–60. doi: 10.1007/978-3-662-53644-5\\_2. url: https://doi.org/10.1007/978-3-662-53644-5%5C_2.</li>

      <li>[7] Eli Ben-Sasson et al. “Aurora: Transparent Succinct Arguments for R1CS”. In: <em>IACR Cryptol. ePrint Arch.</em> 2018.</li>

      <li>[8] Eli Ben-Sasson et al. “DEEP-FRI: Sampling Outside the Box Improves Soundness”. In: <em>11th Innovations in Theoretical Computer Science Conference, ITCS 2020, January 12-14, 2020, Seattle, Washington, USA</em>. Vol. 151. LIPIcs. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2020, 5:1–5:32. doi: 10.4230/LIPICS.ITCS.2020.5. url: https://doi.org/10.4230/LIPIcs.ITCS.2020.5.</li>

      <li>[9] Eli Ben-Sasson et al. “Fast Reed-Solomon Interactive Oracle Proofs of Proximity”. In: <em>45th International Colloquium on Automata, Languages, and Programming, ICALP 2018</em>. Vol. 107. LIPIcs. 2018, 14:1–14:17.</li>

      <li>[10] Eli Ben-Sasson et al. “Proximity Gaps for Reed-Solomon Codes”. In: <em>61st IEEE Annual Symposium on Foundations of Computer Science, FOCS 2020, Durham, NC, USA, November 16-19, 2020</em>. Ed. by Sandy Irani. IEEE, 2020, pp. 900–909. doi: 10.1109/FOCS46700.2020.00088.</li>

      <li>[11] Dan Boneh et al. “Efficient polynomial commitment schemes for multiple points and polynomials”. In: <em>IACR Cryptol. ePrint Arch.</em> (2020), p. 81.</li>

      <li>[12] Jonathan Bootle, Alessandro Chiesa, and Jens Groth. “Linear-Time Arguments with Sublinear Verification from Tensor Codes”. In: <em>IACR Cryptol. ePrint Arch.</em> 2020 (2020), p. 1426.</li>

      <li>[13] Sean Bowe, Jack Grigg, and Daira Hopwood. <em>Recursive Proof Composition without a Trusted Setup</em>. Cryptology ePrint Archive, Report 2019/1021. 2019.</li>

      <li>[14] Benedikt Bünz, Ben Fisch, and Alan Szepieniec. “Transparent SNARKs from DARK Compilers”. In: <em>Advances in Cryptology - EUROCRYPT 2020 - 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zagreb, Croatia, May 10-14, 2020, Proceedings, Part I</em>. Ed. by Anne Canteaut and Yuval Ishai. Vol. 12105. Lecture Notes in Computer Science. Springer, 2020, pp. 677–706.</li>

      <li>[15] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. “Fractal: Post-quantum and Transparent Recursive Proofs from Holography”. In: <em>LNSC</em>. Vol. 12105. May 2020, pp. 769–793.</li>

      <li>[16] Alessandro Chiesa et al. “Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS”. In: <em>Advances in Cryptology EUROCRYPT</em>. Vol. 12105. LNCS. Springer, 2020, pp. 738–768.</li>

      <li>[17] the Electric Coin Company. <em>The Halo 2 book</em>. url: https://zcash.github.io/halo2/.</li>

      <li>[18] Lior Goldberg, Shahar Papini, and Michael Riabzev. “Cairo - a Turing-complete STARK-friendly CPU architecture”. In: <em>IACR Cryptol. ePrint Arch.</em> 2021 (2021), p. 1063.</li>

      <li>[19] Alexander Golovnev et al. “Brakedown: Linear-time and post-quantum SNARKs for R1CS”. In: <em>IACR Cryptol. ePrint Arch.</em> 2021 (2021), p. 1043.</li>

      <li>[20] Jens Groth. “On the Size of Pairing-Based Non-interactive Arguments”. In: <em>Advances in Cryptology - EUROCRYPT</em>. Vol. 9666. LNCS. Springer, 2016, pp. 305–326.</li>

      <li>[21] Ulrich Haböck. <em>A summary on the FRI low degree test</em>. Cryptology ePrint Archive, Paper 2022/1216. https://eprint.iacr.org/2022/1216. 2022. url: https://eprint.iacr.org/2022/1216.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[22] Assimakis Kattis, Konstantin Panarin, and Alexander Vlasov. “RedShift: Transparent SNARKs from List Polynomial Commitment IOPs”. In: IACR Cryptol. ePrint Arch. (2019), p. 1400.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[23] Abhiram Kothapalli, Srinath T. V. Setty, and Ioanna Tzialla. “Nova: Recursive Zero-Knowledge Arguments from Folding Schemes”. In: Advances in Cryptology - CRYPTO 2022 - 42nd Annual International Cryptology Conference, CRYPTO 2022, Santa Barbara, CA, USA, August 15-18, 2022, Proceedings, Part IV. Vol. 13510. Lecture Notes in Computer Science. Springer, 2022, pp. 359–388. url: https://doi.org/10.1007/978-3-031-15985-5%5C_13.</li>

      <li>[24] Benoît Libert, Somindu C. Ramanna, and Moti Yung. Functional Commitment Schemes: From Polynomial Commitments to Pairing-Based Accumulators from Simple Assumptions. 2016.</li>

      <li>[25] Vadim Lyubashevsky et al. “SWIFFT: A Modest Proposal for FFT Hashing”. In: Fast Software Encryption, 15th International Workshop, FSE 2008. Vol. 5086. Lecture Notes in Computer Science. Springer, 2008, pp. 54–72. doi: 10.1007/978-3-540-71039-4\\_4. url: https://doi.org/10.1007/978-3-540-71039-4%5C_4.</li>

      <li>[26] Mary Maller et al. “Sonic: Zero-Knowledge SNARKs from Linear-Size Universal and Updatable Structured Reference Strings”. In: ACM SIGSAC -CCS. ACM, 2019, pp. 2111–2128.</li>

      <li>[27] I. S. Reed and G. Solomon. “Polynomial Codes Over Certain Finite Fields”. In: Journal of the Society for Industrial and Applied Mathematics 8.2 (1960), pp. 300–304. doi: 10 . 1137 / 0108018. eprint: https://doi.org/10.1137/0108018. url: https://doi.org/10 . 1137/0108018.</li>

      <li>[28] Srinath Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. CRYPTO. 2020.</li>

      <li>[29] Srinath T. V. Setty, Justin Thaler, and Riad S. Wahby. “Unlocking the lookup singularity with Lasso”. In: IACR Cryptol. ePrint Arch. (2023), p. 1216. url: https://eprint.iacr.org/2023/1216.</li>

      <li>[30] Polygon Hermez Team. Scalable payments. Decentralised by design, open for everyone. https://hermez.io.</li>

      <li>[31] StarkWare Team. “ethSTARK Documentation”. In: IACR Cryptol. ePrint Arch. (2021), p. 582.</li>

      <li>[32] Tiacheng Xie et al. “Libra: Succinct Zero-Knowledge Proofs with Optimal Prover Computation”. In: Advances in Cryptology - CRYPTO. Vol. 11694. LNCS. Springer, 2019, pp. 733–764.</li>

      <li>[33] Tiancheng Xie, Yupeng Zhang, and Dawn Xiaodong Song. “Orion: Zero Knowledge Proof with Linear Prover Time”. In: IACR Cryptol. ePrint Arch. 2022.</li>

      <li>[34] Risc Zero. https://github.com/risc0/risc0. 2022.</li>

      <li>[35] Jiaheng Zhang et al. Transparent Polynomial Delegation and Its Applications to Zero Knowledge Proof. 2020 IEEE Symposium on Security and Privacy (SP). 2019.</li>

    </ul>`;
---

<BaseLayout title="Vortex: A List Polynomial Commitment and its Application to ... (2024/185)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/185
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
