---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/919';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Snow White: Robustly Reconfigurable Consensus and Applications to Provably Secure Proof of Stake';
const AUTHORS_HTML = 'Phil Daian, Rafael Pass, Elaine Shi';

const CONTENT = `    <p class="text-gray-300">Phil Daian Rafael Pass Elaine Shi Cornell/CornellTech</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We present the a provably secure proof-of-stake protocol called Snow White. The primary application of Snow White is to be used as a “green” consensus alternative for a decentralized cryptocurrency system with open enrollement. We break down the task of designing Snow White into the following core challenges:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>identify a core “permissioned” consensus protocol suitable for proof-of-stake; specifically the core consensus protocol should offer robustness in an Internet-scale, heterogeneous deployment;</li>

      <li>propose a robust committee re-election mechanism such that as stake switches hands in the cryptocurrency system, the consensus committee can evolve in a timely manner and always reflect the most recent stake distribution; and</li>

      <li>relying on the formal security of the underlying consensus protocol, prove the full end-to-end protocol to be secure — more specifically, we show that that any consensus protocol satisfying the desired robustness properties can be used to construct proofs-of-stake consensus, as long as money does not switch hands too quickly.</li>

    </ol>

    <p class="text-gray-300">Snow White was publicly released in September 2016. It provides the first formal, end-to-end proof of a proof-of-stake system in a truly decentralized, open-participation network, where nodes can join at any time (not necessarily at the creation of the system). We also give the first formal treatment of a well-known issue called “costless simulation” in our paper, proving both upper- and lower-bounds that characterize exactly what setup assumptions are needed to defend against costless simulation attacks. We refer the reader to our detailed chronological notes on a detailed comparison of Snow White and other prior and concurrent works, as well as how subsequent works (including Ethereum’s proof-of-stake design) have since extended and improved our ideas.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Although consensus protocols have been investigated by the distributed systems community for 30 years, in the past decade a new breakthrough called Bitcoin established a new, blockchain-based paradigm for reaching consensus in a distributed system. Relying on proof-of-work, Bitcoin’s consensus protocol (often called Nakamoto consensus), for the first time, enabled consensus in an open, unauthenticated environment where nodes do not share any pre-established public keys *[28,</p>

    <p class="text-gray-300">44, 45, 49]*. One commonly known painpoint with this approach is the enormous energy waste. Motivated by the need for a green alternative, the community searched for a paradigm shift, and hoped to obtain a consensus paradigm, commonly called “proof-of-stake”, that is based on the idea of “one vote per unit of stake” (as opposed to “one vote per unit of hash-power”).</p>

    <p class="text-gray-300">The design of proof-of-stake protocols was first initiated in online forums and blog-posts and subsequently considered by the academic community <em>[6, 7, 18, 35, 36, 42, 51, 53, 54]</em>. Prior to our work, we were not aware of any candidate protocol that offered provable guarantees.</p>

    <p class="text-gray-300">Snow White is the first work to provide end-to-end, formal proofs of security of a full proof-of-stake protocol. Security is proven in a truly decentralized, open-participation environment where honest nodes can join the protocol late in time (and not necessarily at the system’s creation). We give the first formal treatment of the well-known “costless simulation” problem (also called posterior corruption in this paper) pertaining to proof-of-stake, proving upper- and lower-bounds that precisely characterize under what assumptions it is possible to defend against costless simulation.</p>

    <p class="text-gray-300">In the remainder of the introduction, we first present an informal technical overview of our results. We then provide detailed chronological notes that position our work in light of other concurrent and subsequent works, and summarize our work’s contributions and impact.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Robustly Reconfigurable Consensus</h3>

    <p class="text-gray-300">We ask the question: what is a suitable consensus protocol for a proof-of-stake system? In a proof-of-stake system, at any point of time, we would like the present stake-holders to have voting rights that are weighed by their respective stake amount. Thus if we examine any single snapshot in the system, proof-of-stake in fact requires a “permissioned” core consensus protocol, since the set of public-keys owning stake is publicly known. However, proof-of-stake systems aim to support open participation — and this can be enabled through periodic committee reconfiguration. Suppose that the system starts with a well-known set of stake-holders who form the initial consensus committee. As stake switches hands in the system, the consensus committee should be updated in a timely manner to track the present (and not the past) stake distribution. This is important for the security of a proof-of-stake system, since users who no longer hold stake in the system may be incentivized to deviate, e.g., to launch a double-spending attack.</p>

    <p class="text-gray-300">We formulate the task of designing “a consensus protocol suitable for proof-of-stake” as “robustly reconfigurable consensus”. A robustly reconfiguration consensus protocol should have the following desirable properties.</p>

    <p class="text-gray-300">Robustness in the presence of sporadic participation. In a large-scale, decentralized environment, users tend to have sporadic participation, and it may be difficult to anticipate how many users will be online at any point of time. Almost all classical-style consensus protocols rely on tallying sufficiently many votes to make progress. If fewer than the anticipated number of users actually show up to vote, the consensus protocol may get stuck.</p>

    <p class="text-gray-300">To address this challenge, Snow White employs the recently proposed “sleepy consensus” <em>[48]</em> paradigm as its core permissioned consensus building block. Sleepy consensus <em>[48]</em> is inspired by the beautiful “longest-chain” idea behind Nakamoto’s consensus <em>[44]</em>, but the idea is instead applied to a non-proof-of-work, permissioned setting with a public-key infrastructure (PKI). Pass and Shi prove that the resulting consensus protocol is robust in the presence of sporadic participation: concretely, the protocol need not be parametrized with an a-priori fixed number of players that are expected to show up. As long as the majority of online players are honest, the protocol guarantees</p>

    <p class="text-gray-300">consistency and liveness.</p>

    <p class="text-gray-300">Robust committee reconfiguration. Roughly speaking, our system proceeds in epochs. In each epoch, a most recent set of stake-holders are elected as committee and may be randomly chosen to generate blocks. We argue that committee reconfiguration and random block-proposer selection are challenging and subtle due to the following two possible attacks.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Adaptive key selection attacks. Since proof-of-stake systems admit open participation, anyone can buy up stake in the system and participate. This also means anyone can (possibly maliciously) choose their public-keys through which they participate in the consensus. A possible attack, therefore, is to adaptively choose public-keys, after gathering partial information about the randomness seed used for block-proposer selection, such that corrupt nodes are elected more often as block-proposer than their fair chance.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Randomness-biasing attacks (commonly known as the "grinding attack"). Another important question is: how do we obtain the randomness needed for block proposer selection? A most straightforward idea is to use the hash of past blocks — but as several works have shown [10], the blocks' hashes can be subject to adversarial influence, and it is unclear what security can be guaranteed when we use such randomness sources with adversarial bias for block proposer selection. For example, the adversary can bias the randomness in a way that allows corrupt nodes to be selected more often.</li>

    </ol>

    <p class="text-gray-300">In the worst case, if through possibly a combination of the attacks, the adversary can control the majority of the block-proposer slots, consistency of the underlying consensus (in our case, sleepy consensus) can be broken.</p>

    <p class="text-gray-300">Snow White proposes a novel "two-lookback" mechanism that addresses the above two challenges simultaneously¹. We determine each epoch's new consensus committee and randomness seed in a two-phase process, where each phase spans roughly <span class="math">\\kappa</span> blocks of time for some appropriate security parameter² <span class="math">\\kappa</span>. This two-phase process is enabled by two look-back parameters as we describe informally below (a formal description is deferred to the technical sections) — henceforth suppose that chain is the current longest chain.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We look back <span class="math">2\\kappa</span> blocks, and use the prefix chain[: <span class="math">-2\\kappa</span>] (i.e., the prefix of chain removing the trailing <span class="math">2\\kappa</span> blocks) to determine the new consensus committee.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We look back <span class="math">\\kappa</span> blocks, and extract the randomness contained in the blocks chain[-2<span class="math">\\kappa</span>: <span class="math">-\\kappa</span>] (i.e., the part of chain from <span class="math">2\\kappa</span> blocks ago to <span class="math">\\kappa</span> blocks ago) to form a randomness seed — this seed then seeds a random oracle used for block-proposer selection in the current epoch.</li>

    </ol>

    <p class="text-gray-300">Roughly speaking, we defeat the adaptively chosen key attack by determining the consensus committee <span class="math">\\kappa</span> blocks earlier than the randomness seed, such that when corrupt nodes choose their public keys, they cannot predict the randomness seed, which will be generated much later in time and with sufficient entropy contributed by honest nodes as we explain below. We argue that due</p>

    <p class="text-gray-300">¹Subsequent works, including newer versions of Algorand [17] released after our publication, Ouroboros Praos [19], and the latest Ethereum's proof-of-stake proposal [2] incorporated elements of this design and suggested improvements, e.g., for concrete security. See Section 1.3 for more discussions.</p>

    <p class="text-gray-300">² Suppose that except with negligible in <span class="math">\\kappa</span> probability, the underlying sleepy consensus guarantees consistency by chopping off the trailing <span class="math">\\kappa</span> blocks, and guarantees the existence of an honest block in every consecutive window of <span class="math">\\kappa</span> blocks.</p>

    <p class="text-gray-300">3</p>

    <p class="text-gray-300">to chain quality of the underlying sleepy consensus, the blocks chain<span class="math">[-2\\kappa:-\\kappa]</span> must contain an honest block. Since honest nodes embed a sufficiently long uniform random seed in its block, we can extract sufficiently high-entropy randomness from chain<span class="math">[-2\\kappa:-\\kappa]</span> which is then used to seed the block-proposer-selection random oracle. Even though the extracted randomness is subject to adversarial bias, as long as it is high-entropy, and importantly, as long as the same randomness is used to seed the block-proposer selection sufficiently many times, we can achieve the desired measure concentration properties. More specifically, although indeed, the adversary can bias the random seed to allow corrupt nodes to be selected (as block-proposers) quite surely for a few number of slots; the adversary is not able to consistently gain advantage over a sufficiently large number of slots, i.e., corrupt nodes cannot own noticeably more block-proposer slots than its fair share.</p>

    <p class="text-gray-300">We stress that turning the above intuitive argument into a formal proof requires significant and non-trivial effort which is part our main contributions. In our technical sections, we formally prove security of this approach under a mildly adaptive adversary, i.e., when the adversary is subject to a mild corruption delay and as long as nodes remain honest till shortly after they stop serving on a consensus committee, our robustly reconfigurable consensus protocol is secure. Subsequent works (including newer versions of the Algorand paper that are published after the release of Snow White, as well as the subsequent work Ourboros Praos <em>[19]</em>) have suggested approaches for achieving fully adaptive security, but relying on the fact that the majority of nodes will erase secret signing keys from memory after signing a block (and by introducing mild additional complexity in the cryptographic schemes employed) — see Section 1.3 for a more detailed comparison.</p>

    <p class="text-gray-300">Understanding posterior corruption, i.e., “costless simulation” attacks. A oft-cited attack for proof-of-stake systems is the so-called “costless simulation” attack (also referred to as a posterior corruption attack in this paper). The idea is that when stake-holders have sold their stake in the system, nothing prevents them from performing a history-rewrite attack. Specifically, suppose that a set of nodes denoted <span class="math">C</span> control the majority stake in some past committee. These nodes can collude to fork the history from the point in the past when they control majority — and in this alternate history money can transfer in a way such that <span class="math">C</span> continues to hold majority stake (possibly transferred to other pseudonyms of the corrupt nodes) such that the attack can be sustained.</p>

    <p class="text-gray-300">In this paper, we formally prove that under a mild setup assumption — when nodes join the system they can access a set of online nodes the majority of whom are honest — we can provably defend against such a posterior corruption attack. This is achieved by having the newly joining user obtain a somewhat recent checkpoint from the set of nodes it can access upon joining.</p>

    <p class="text-gray-300">We also prove a corresponding lower bound, that absent this setup assumption, defense against such posterior corruption attacks is impossible — to the best of our knowledge, ours is the first formal treatment of this well-known costless simulation attack in the context of proof-of-stake.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 From Robustly Reconfigurable Consensus to Proof-of-Stake</h3>

    <p class="text-gray-300">Application to proof-of-stake and achieving incentive compatibility. We show how to apply such a “robustly reconfigurable consensus” protocol to realize proof-of-stake (the resulting protocol called Snow White), such that nodes obtain voting power roughly proportional to their stake in the cryptocurrency system. As long as money does not switch hands too fast (which is enforceable by the cryptocurrency layer), we show that the resulting proof-of-stake protocol can attain security when the adversary controls only a minority of the stake in the system. Further,</p>

    <p class="text-gray-300">borrowing ideas from the recent Fruitchain work <em>[46]</em>, we suggest incentive compatible mechanisms for distributing rewards and transaction fees, such that the resulting protocol achieves a coalition-resistant <span class="math">\\epsilon</span>-Nash equilibrium, i.e., roughly speaking, as long as the adversary controls a minority of the stake, it cannot obtain more than <span class="math">\\epsilon</span> fraction more than its fair share of payout, even when it has full control of network transmission and can deviate arbitrarily from the protocol specification.</p>

    <p class="text-gray-300">Preventing nothing-at-stake attacks. Later in Section 3, we will also discuss how to leverage guarantees provided by our core consensus protocol, and build additional mechanisms that not only discourage nothing-at-stake attackers, but in fact penalize them.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.3 Chronological Notes, Closely Related, and Subsequent Works</h3>

    <p class="text-gray-300">Comparison with Algorand. The first manuscript of Algorand <em>[17]</em> was published prior to our work. Algorand also proposes a proof-of-stake system. Their core consensus protocol is a newly designed classical-style consensus protocol, and therefore they cannot guarantee progress under sporadic participation — instead, Algorand proposes a notion of “lazy participation”, where users know when they are needed to vote in the consensus and they only need to be online when they are needed. However, if many users who are anticipated to show up failed to do so, progress will be hampered. Algorand employs a Verifiable Random Function (VRF) to perform random leader/committee election.</p>

    <p class="text-gray-300">Algorand’s algorithm has been improved for several iterations. The version of Algorand that existed before the publication of Snow White gave proofs of their core consensus protocol but did not provide end-to-end proofs for the full proof-of-stake system. In particular, the version of Algorand that existed prior to Snow White’s publication did not discuss the well-known issue of costless simulation or clearly state the implicit assumptions they make to circumvent the lower bound we prove in this paper.</p>

    <p class="text-gray-300">In their subsequent versions, they adopted the erasure model and rely on honest nodes’ capability to safely erase secrets from memory to achieve adaptive security (and implicitly, by adopting erasures one could defend against the costless simulation). The newer versions of Algorand (released after the Snow White) also started to adopt a similar look-back idea (first described by Snow White) to secure against the adaptive chosen-key attack mentioned earlier. The recent versions also provided more thorough mathematical proofs of this approach.</p>

    <p class="text-gray-300">Comparison with Ouroboros and Ouroboros Praos. Snow White was publicly released in September 2016. A closely related work (independent and concurrent from our effort) known as Ouroboros <em>[34]</em> was release about 10 days prior to Snow White. Ouroboros Praos is an improvement over Ouroboros published in 2017 <em>[19]</em>.</p>

    <p class="text-gray-300">The Ouroboros version that was released around the same time as Snow White focused on proving the underlying permissioned consensus building block secure, and there is only a short paragraph containing a proof sketch of their full proof-of-stake system (and this proof sketch has been somewhat expanded to a few paragraphs in later versions). In comparison, our Snow White paper adopts a permissioned consensus building block whose security was formally proven secure in a related paper <em>[48]</em> — the full-length of our technical sections are dedicated to a thorough treatment of the security of the end-to-end proof-of-stake system.</p>

    <p class="text-gray-300">A notable difference between Snow White and Ouroboros seems to be that their formal treatment does not seem to capture a truly decentralized environment (necessary for decentralized cryptocurrency applications) where nodes may join the system late and not from the very start — had</p>

    <p class="text-gray-300">they done so, they would have encountered the well-known costless simulation issue, which, as we show, is impossible to defend against without extra setup assumptions (and indeed, we introduce a reasonable setup assumption to circumvent this lower bound).</p>

    <p class="text-gray-300">A subsequently improved work, called Ouroboros Praos <em>[19]</em>, extends the VRF approach described first by Algorand <em>[17]</em> and Dfinity <em>[30]</em> for random block-proposer election. Similar to the newer versions of Algorand, Ouroboros Praos <em>[19]</em> also started adopting an erasure model to achieve adaptive security (and implicitly, defend against costless simulation).</p>

    <p class="text-gray-300">Neither Ouroboros nor Ouroboros Praos adopts an underlying consensus mechanism that provably provides support for sporadic participation. Finally, the improved version Ouroboros Praos <em>[19]</em> started adopting a look-back mechanism that appears to be inspired by Snow White to for committee rotation and random block-proposer selection.</p>

    <p class="text-gray-300">Comparison with Ethereum’s proof-of-stake design. Ethereum began proof-of-stake explorations several years ago. Their design has undergone several versions. At the time of the writing, Ethereum was aiming to do “hybrid proof-of-stake”, i.e., use Casper as a finality gadget on top of their existing proof-of-work blockchain.</p>

    <p class="text-gray-300">In the past year 2018, conversations with Ethereum core researchers suggest that Ethereum is considering replacing their proof-of-work blockchain with a proof-of-stake blockchain similar to Snow White. Their committee election and random block proposer selection algorithm seems to be improvement of Snow White. Specifically, they would like to adopt an economically secure coin toss protocol for randomness generation (commonly known as RANDAO). This specific protocol is also subject to adversarial bias much like our randomness seed generation (although biasing attacks may lead to economic loss). Thus they rely on exactly the same observation that was proposed in our paper: although the adversary can bias the randomness sufficiently to control a few block proposer slots, he cannot consistently get an advantage over a large number of slots. Interestingly, Ethereum has several practical optimizations that improve the concrete security parameters of the above analysis <em>[2]</em>.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2 Snow White’s Core Consensus Protocol</h2>

    <p class="text-gray-300">We focus on an intuitive exposition of our scheme in the main body. In the appendices, we present formal definitions, a formal description of the protocol, as well as the full proofs. We stress that formalizing the end-to-end security of a proof-of-stake system is a significant effort and this leads to our choice of presentation.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.1 Background: Sleepy Consensus and Sleepy Execution Model</h3>

    <p class="text-gray-300">Sleepy execution model and terminology. We would like to adopt an execution model that captures a decentralized environment where nodes can spawn late in time, and can go to sleep and later wake up. In such a model, the protocol may not have a way to anticipate the number of players at any time.</p>

    <p class="text-gray-300">We thus adopt the sleepy model of execution proposed by Pass and Shi <em>[48]</em>. Nodes are either sleepy (i.e., offline) or awake (i.e., online and actively participating). For simplicity, we also refer to nodes that are awake and honest as alert; and all corrupt nodes are assumed to be awake by convention.</p>

    <p class="text-gray-300">Messages delivered by an alert node is guaranteed to arrive at all other alert nodes within a maximum delay of <span class="math">\\Delta</span>, where <span class="math">\\Delta</span> is an input parameter to the protocol. A sleepy node captures any node that is either offline or suffering a slower than <span class="math">\\Delta</span> network connection. A sleepy node can later wake up, and upon waking at time <span class="math">t</span>, all pending messages sent by alert nodes before <span class="math">t-\\Delta</span> will be immediately delivered to the waking node.</p>

    <p class="text-gray-300">We allow the adversary to dynamically spawn new nodes, and newly spawned nodes can either be honest or corrupt. Further, as we discuss later, we allow the adversary to declare corruptions and put alert nodes to sleep in a mildly adaptive fashion.</p>

    <p class="text-gray-300">For readability, we defer a detailed presentation of the formal model to Appendix A.1.</p>

    <p class="text-gray-300">The Sleepy protocol as a starting point. Classical consensus protocols must count sufficiently many votes to make progress and thus the protocol must know a-priori roughly how many nodes will show up to vote. Since Pass and Shi’s Sleepy consensus protocol is the only protocol known to provide consensus under sporadic participation, i.e., the protocol need not have a-priori knowledge of the number of players at any time. We thus consider Sleepy as a starting point for constructing our notion of robustly reconfigurable consensus. We now briefly review the Sleepy consensus protocol as necessary background.</p>

    <p class="text-gray-300">Sleepy is a blockchain-style protocol but without proof-of-work. For practical considerations, below we describe the version of Sleepy instantiated with a random oracle (although Pass and Shi <em>[48]</em> also describe techniques for removing the random oracle). Sleepy relies on a random oracle to elect a leader in every time step. The elected leader is allowed to extend a blockchain with a new block, by signing a tuple that includes its own identity, the transactions to be confirm, the current time, and the previous block’s hash. Like in the Nakamoto consensus, nodes always choose the longest chain if they receive multiple different ones. To make this protocol fully work, Sleepy <em>[48]</em> proposes new techniques to timestamp blocks to constrain the possible behaviors of an adversary. Specifically, there are two important blockchain timestamp rules:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a valid blockchain must have strictly increasing timestamps; and</li>

      <li>honest nodes always reject a chain with future timestamps.</li>

    </ol>

    <p class="text-gray-300">All aforementioned timestamps can be adjusted to account for possible clock offsets among nodes by applying a generic protocol transformation <em>[48]</em>.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.2 Handling Committee Reconfiguration</h3>

    <p class="text-gray-300">As mentioned, our starting point is the Sleepy consensus protocol, which assumes that all consensus nodes know each other’s public keys; although it may not be known a-priori how many consensus nodes will show up and participate.</p>

    <p class="text-gray-300">We now discuss how to perform committee reconfiguration such that the consensus committee tracks the latest stake distribution. To support a wide range of applications, our Snow White protocol does not stipulate how applications should select the committee over time. Roughly speaking, we wish to guarantee security as long as the application-specific committee selection algorithm respects the constraint that there is honest majority among all awake nodes. Therefore,</p>

    <p class="text-gray-300">we assume that there is some application-specific function elect_cmt(<em>chain</em>) that examines the state of the blockchain and outputs a new committee over time. In a proof-of-stake context, for example, this function can roughly speaking, output one public key for each currency unit owned by the user. In Section 3, we discuss in a proof-of-stake context, how one might possibly translate assumptions on the distribution of stake to the the formal requirements expected by the consensus protocol.</p>

    <p class="text-gray-300">Strawman scheme: epoch-based committee selection. Snow White provides an epoch-based protocol for committee reconfiguration. To aid understanding, we begin by describing a strawman solution. Each <span class="math">T_{\\text{epoch}}</span> time, a new epoch starts, and the beginning of each epoch provides a committee reconfiguration opportunity. Let <span class="math">\\mathsf{start}(e)</span> and <span class="math">\\mathsf{end}(e)</span> denote the beginning and ending times of the <span class="math">e</span>-th committee. Every block in a valid blockchain whose time stamp is between <span class="math">[\\mathsf{start}(e),\\mathsf{end}(e))</span> is associated with the <span class="math">e</span>-th committee.</p>

    <p class="text-gray-300">It is important that all honest nodes agree on what the committee is for each epoch. To achieve this, our idea is for honest nodes to determine the new committee by looking at a stabilized part of the chain. Therefore, a straightforward idea is to make the following modifications to the basic Sleepy consensus protocol:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">2\\omega</span> be a look-back parameter.</li>

      <li>At any time <span class="math">t\\in[\\mathsf{start}(e),\\mathsf{end}(e))</span> that is in the <span class="math">e</span>-th epoch, an alert node determines the <span class="math">e</span>-th committee in the following manner: find the latest block in its local chain whose timestamp is no greater than <span class="math">\\mathsf{start}(e)-2\\omega</span>, and suppose this block resides at index <span class="math">\\ell</span>.</li>

      <li>Now, output <span class="math">\\mathsf{extractpks}(chain[:\\ell])</span> as the new committee.</li>

    </ul>

    <p class="text-gray-300">In general, the look-back parameter <span class="math">2\\omega</span> must be sufficiently large such that all alert nodes have the same prefix chain<span class="math">[:\\ell]</span> in their local chains by time <span class="math">\\mathsf{start}(e)</span>. On the other hand, from an application’s perspective, <span class="math">2\\omega</span> should also be recent enough such that the committee composition does not lag significantly behind.</p>

    <p class="text-gray-300">Preventing an adaptive key selection attack. Unfortunately, the above scheme is prone to an adaptive key selection attack where an adversary can break consistency with constant probability. Specifically, as the random oracle <span class="math">\\mathsf{H}</span> is chosen prior to protocol start, the adversary can make arbitrary queries to <span class="math">\\mathsf{H}</span>. Therefore, the adversary can spawn corrupt nodes and seed them with public keys that causes them to be elected leader at desirable points of time. For example, since the adversary can query <span class="math">\\mathsf{H}</span>, it is able to infer exactly in which time steps honest nodes are elected leader. Now, the adversary can pick corrupt nodes’ public keys, such that every time an honest node is leader, a corrupt node is leader too — and he can sustain this attack till he runs out of corrupt nodes. Since the adversary may control up to <span class="math">\\Theta(n)</span> nodes, he can thus break consistency for <span class="math">\\Omega(n)</span> number of blocks.</p>

    <p class="text-gray-300">Our idea is to have nodes determine the next epoch’s committee first, and then select the next epoch’s hash — in this way, the adversary will be unaware of next epoch’s hash until well after the next committee is determined. More specifically, we can make the following changes to the Sleepy protocol:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">2\\omega</span> and <span class="math">\\omega</span> be two look-back parameters, for determining the next committee and next hash respectively.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At any time <span class="math">t\\in[\\mathsf{start}(e),\\mathsf{end}(e))</span> that is in the <span class="math">e</span>-th epoch, an alert node determines the <span class="math">e</span>-th committee in the following manner: find the latest block its local <em>chain</em> whose timestamp is no greater than <span class="math">\\mathsf{start}(e)-2\\omega</span>, and suppose this block resides at index <span class="math">\\ell_{0}</span>. Now, output <span class="math">\\mathsf{extractpks}(</span>chain<span class="math">[:\\ell_{0}])</span> as the new committee.</li>

      <li>At any time <span class="math">t\\in[\\mathsf{start}(e),\\mathsf{end}(e))</span> an alert node determines the <span class="math">e</span>-th hash in the following manner: find the latest block its local <em>chain</em> whose timestamp is no greater than <span class="math">\\mathsf{start}(e)-\\omega</span>, and suppose this block resides at index <span class="math">\\ell_{1}</span>. Now, output <span class="math">\\mathsf{extractnonce}(</span>chain<span class="math">[:\\ell_{1}])</span> as a nonce to seed the new hash.</li>

      <li>We augment the protocol such that alert nodes always embed a random seed in any block they mine, and <span class="math">\\mathsf{extractnonce}(</span>chain<span class="math">[:\\ell_{1}])</span> can simply use the seeds in the prefix of the chain as a nonce to seed the random oracle <span class="math">\\mathsf{H}</span>.</li>

    </ul>

    <p class="text-gray-300">For security, we require that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The two look-back parameters <span class="math">2\\omega</span> and <span class="math">\\omega</span> are both sufficiently long ago, such that all alert nodes will have agreement on <em>chain</em><span class="math">[:\\ell_{0}]</span> and <em>chain</em><span class="math">[:\\ell_{1}]</span> by the time <span class="math">\\mathsf{start}(e)</span>; and</li>

      <li>The two look-back parameters <span class="math">2\\omega</span> and <span class="math">\\omega</span> must be sufficiently far part, such that the adversary cannot predict <span class="math">\\mathsf{extractnonce}(</span>chain<span class="math">[:\\ell_{1}])</span> until well after the next committee is determined.</li>

    </ol>

    <p class="text-gray-300">Achieving security under adversarially biased hashes. It is not hard to see that the adversary can bias the nonce used to seed the hash, since the adversary can place arbitrary seeds in the blocks it contributes. In particular, suppose that the nonce is extracted from the prefix <em>chain</em><span class="math">[:\\ell_{1}]</span>. Obviously, with at least constant probability, the adversary may control the ending block in this prefix. By querying <span class="math">\\mathsf{H}</span> polynomially many times, the adversary can influence the seed in the last block <em>chain</em><span class="math">[\\ell_{1}]</span> of the prefix, until it finds one that it likes.</p>

    <p class="text-gray-300">Indeed, if each nonce is used only to select the leader in a small number of time steps (say, <span class="math">O(1)</span> time steps), such adversarial bias would indeed have been detrimental — in particular, by enumerating polynomially many possibilities, the adversary can cause itself to be elected with probability almost <span class="math">1</span> (assuming that the adversary controls the last block of the prefix).</p>

    <p class="text-gray-300">However, we observe that as long as the same nonce is used sufficiently many times, the adversary cannot consistently cause corrupt nodes to be elected in many time steps. Specifically, suppose each nonce is used to elect at least <span class="math">\\Omega(\\kappa)</span> leaders, then except with <span class="math">\\mathsf{negl}(\\kappa)</span> probability, the adversary cannot increase its share by more than an <span class="math">\\epsilon</span> fraction — for an arbitrarily small constant <span class="math">\\epsilon&gt;0</span>. Therefore, to prove our scheme secure, it is important that each epoch’s length (henceforth denoted <span class="math">T_{\\text{epoch}}</span>) be sufficiently long, such that once a new nonce is determined, it is used to elect sufficiently many leaders.</p>

    <p class="text-gray-300">Reasoning about security under adversarially biased hashes. Formalizing this above intuition is somewhat more involved. Specifically, our proof needs to reason about the probability of bad events (related to chain growth, chain quality, and consistency) over <em>medium-sized</em> windows such that the bad events depend only on <span class="math">O(1)</span> number of hashes (determined by the nonces used to seed them). This way, we can apply a union bound that results in polynomial security loss. If the window size is too small, it would not be enough to make the failure probability negligible; on the other hand, if the window were too big, the blowup of the union bound would be exponential. Finally, we argue if no bad events occur for every medium-sized window, then no bad events happen</p>

    <p class="text-gray-300">for every window (as long as the window is not too small). We defer the detailed discussions and formal proofs to Sections E and G.1</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.3 Handling Mildly Adaptive and Posterior Corruptions</h3>

    <p class="text-gray-300">We now consider how to defend against an adversary that can adaptively corrupt nodes after they are spawned. In this paper, we will aim to achieve security against a mildly adaptive adversary. Specifically, a mildly adaptive adversary is allowed to dynamically corrupt nodes or make them sleep, but such corrupt or sleep instructions take a while to be effective. For example, in practice, it may take some time to infect a machine with malware. Such a “mildly adaptive” corruption model has been formally defined in earlier works <em>[47]</em>, where they call it the <span class="math">\\tau</span>-agile corruption model, where <span class="math">\\tau</span> denotes the delay parameter till corrupt or sleep instructions take effect. Intuitively, as long as <span class="math">\\tau</span> is sufficiently large, it will be too late for an adversary to corrupt a node or make the node sleep upon seeing the next epoch’s hash. By the time the corrupt or sleep instruction takes effect, it will already be well past the epoch.</p>

    <p class="text-gray-300">The main challenge in handling mildly adaptive corruptions is the threat of a history rewriting attack when posterior corruption is possible: members of past committees may, at some point, have sold their stake in the system, and thus they have nothing to lose to create an alternative version of history.</p>

    <p class="text-gray-300">We rely on a checkpointing idea to provide resilience to such posterior corruption — as long as there is no late joining or rejoining (we will discuss how to handle late joining or rejoining later). Checkpointing is a technique that has been explored in the classical distributed systems literature <em>[16]</em> but typically for different purposes, e.g., in the case of PBFT <em>[16]</em> it was used as an efficiency mechanism. Suppose that we can already prove the consistency property as long as there is no majority posterior corruption. Now, to additionally handle majority posterior corruption, we can have alert nodes always reject any chain that diverges from its current longest chain at a point sufficiently far back in the past (say, at least <span class="math">W</span> time steps ago). In this way, old committee members that have since become corrupt cannot convince alert nodes to revise history that is too far back — in other words, the confirmed transaction log stabilizes and becomes immutable after a while.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.4 Late Joining in the Presence of Posterior Corruption</h3>

    <p class="text-gray-300">Indeed, the above approach almost would work, if there are no late spawning nodes, and if there are no nodes who wake up after sleeping for a long time. However, as mentioned earlier, handling late joining is important for a decentralized network.</p>

    <p class="text-gray-300">Recall that we described a history revision attack earlier, where if the majority of an old committee become corrupt at a later point of time, they can simulate an alternate past, and convince a newly joining node believe in the alternate past. Therefore, it seems that the crux is the following question:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>How can a node joining the protocol correctly identify the true version of history?</p>
    </blockquote>

    <p class="text-gray-300">Unfortunately, it turns out that this is impossible without additional trust — in fact, we can formalize the aforementioned attack and prove a lower bound (Section D) which essentially shows that in the presence of majority posterior corruption, a newly joining node has no means of discerning a real history from a simulated one:</p>

    <p class="text-gray-300">[Lower bound for posterior corruption]: Absent any additional trust, it is impossible to achieve consensus under sporadic participation, if the majority of an old committee can become corrupt later in time.</p>

    <p class="text-gray-300">We therefore ask the following question: what minimal, additional trust assumptions can we make such that we can defend against majority posterior corruption? Informally speaking, we show that all we need is a secure bootstrapping process for newly joining nodes as described below. We assume that a newly joining node is provided with a list of nodes <span class="math">L</span> the majority of whom must be alert — if so, the new node can ask the list of nodes in <span class="math">L</span> to vote on the current state of the system, and thus it will not be mislead to choose a “simulated” version of the history.</p>

    <h2 id="sec-12" class="text-2xl font-bold">2.5 Putting it Altogether: Informal Overview of Snow White</h2>

    <p class="text-gray-300">In summary, our protocol, roughly speaking, works as follows. A formal description of the protocol, the parameter choices and their relations, and proofs of security are deferred to Section C.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, there is a random oracle <span class="math">\\mathsf{H}</span> that determines if a member of the present committee is a leader in each time step. If a node is leader in a time step <span class="math">t</span>, he can extend the blockchain with a block of the format <span class="math">(h_{-1}, \\text{txs}, \\text{time}, \\text{nocce}, \\text{pk}, \\sigma)</span>, where <span class="math">h_{-1}</span> is the previous block’s hash, <span class="math">\\text{txs}</span> is a set of transactions to be confirmed, <span class="math">\\text{nocce}</span> is a random seed that will be useful later, <span class="math">\\text{pk}</span> is the node’s public key, and <span class="math">\\sigma</span> is a signature under <span class="math">\\text{pk}</span> on the entire contents of the block. A node can verify the validity of the block by checking that 1) <span class="math">\\mathsf{H}^{\\text{nocce}_e}(\\text{pk}, \\text{time}) &amp;lt; D_p</span> where <span class="math">D_p</span> is a difficulty parameter<span class="math">^4</span> such that the hash outcome is smaller than <span class="math">D_p</span> with probability <span class="math">p</span>, and <span class="math">\\text{nocce}_e</span> is a nonce that is reselected every epoch (we will describe how the nonce is selected later); 2) the signature <span class="math">\\sigma</span> verifies under <span class="math">\\text{pk}</span>; and 3) <span class="math">\\text{pk}</span> is a member of the present committee as defined by the prefix of the blockchain.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A valid blockchain’s timestamps must respect two constraints: 1) all timestamps must strictly increase; and 2) any timestamp in the future will cause a chain to be rejected.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Next, to defend against old committees that have since become corrupt from rewriting history, whenever an alert node receives a valid chain that is longer than his own, he only accepts the incoming chain if the incoming chain does not modify blocks too far in the past, where “too far back” is defined by the parameter <span class="math">\\kappa_0</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Next, a newly joining node or a node waking up from long sleep must invoke a secure bootstrapping mechanism such that it can identify the correct version of the history to believe in. One mechanism to achieve this is for the (re)spawning node to contact a list of nodes the majority of whom are alert.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally, our protocol defines each contiguous <span class="math">T_{\\mathrm{epoch}}</span> time steps to be an epoch. At the beginning of each epoch, committee reconfiguration is performed in the following manner. First, nodes find</li>

    </ul>

    <p class="text-gray-300"><span class="math">^4</span>As we discuss Remark 1 in the formal sections, in practice, the next committee is read from a stabilized prefix of the blockchain and we know its total size a-priori. Therefore, assuming that an upper bound on the fraction of awake nodes (out of each committee) is known a-priori, we can set the difficulty parameter <span class="math">D_p</span> accordingly to ensure that the expected block interval is sufficiently large w.r.t. to the maximum network delay (and if the upper bound is loose, then the confirmation time is proportionally slower). Although on the surface our analysis assumes a fixed expected block interval throughout, it easily generalizes to the case when the expected block interval varies by a known constant factor throughout (and is sufficiently large w.r.t. to the maximum network delay).</p>

    <p class="text-gray-300">11</p>

    <p class="text-gray-300">the latest prefix (henceforth denoted <span class="math">chain_{-2\\omega}</span>) in their local chain whose timestamp is at least <span class="math">2\\omega</span> steps ago. This prefix <span class="math">chain_{-2\\omega}</span> will be used to determine the next committee — and Snow White defers to the application-layer to define how specifically to extract the next committee from the state defined by <span class="math">chain_{-2\\omega}</span>. Next, nodes find the latest prefix (denoted <span class="math">chain_{-\\omega}</span>) in their local chain whose timestamp is at least <span class="math">\\omega</span> steps ago. Given this prefix <span class="math">chain_{-\\omega}</span>, we extract the nonces contained in all blocks, the resulting concatenated nonce will be used to seed the hash function H for the next epoch.</p>

    <p class="text-gray-300">Resilience condition. In the appendices, we will give a formal presentation of our protocol and prove it secure under the following resilience condition. We require that the majority of the committee remain honest not only during the time it is active, but also for a short duration (e.g., a handoff period) afterwards. In particular, even if the entire committee becomes corrupt after this handoff period, it should not matter to security.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In other words, we require that for any committee, the number of alert committee members that remain honest for a window of <span class="math">W</span> outnumber the number of committee members that become corrupt during the same window. In particular, we will parametrize the window <span class="math">W</span> such that it incorporates this short handoff period after the committee becomes inactive. Somewhat more formally, we require that there exists a constant <span class="math">\\psi&gt;0</span> such that for every possible execution trace view, for every $t\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, let </span>r=\\min(t+W,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\frac{\\textsf{alert}^{t}(\\textsf{cmt}^{t}(\\textsf{view}),\\textsf{view})\\cap\\textsf{honest}^{r}(\\textsf{cmt}^{t}(\\textsf{view}),\\textsf{view})}{\\textsf{corrupt}^{r}(\\textsf{cmt}^{t}(\\textsf{view}),\\textsf{view})}\\geq 1+\\psi</span> (1)</p>

    <p class="text-gray-300">where <span class="math">\\textsf{alert}^{t}(\\textsf{cmt}^{s}(\\textsf{view}),\\textsf{view})</span>, <span class="math">\\textsf{honest}^{t}(\\textsf{cmt}^{s}(\\textsf{view}),\\textsf{view})</span>, and <span class="math">\\textsf{corrupt}^{t}(\\textsf{cmt}^{s}(\\textsf{view}),\\textsf{view})</span> output the number of nodes in the committee of time <span class="math">s</span> that are alert (or honest, corrupt, resp.) at time <span class="math">t</span>.</p>

    <h2 id="sec-13" class="text-2xl font-bold">3 From Robustly Reconfigurable Consensus to PoS</h2>

    <p class="text-gray-300">We now discuss how to apply our core consensus protocol in a proof-of-stake (PoS) application. There are two challenges: 1) in a system where money can switch hands, how to make the committee composition closely track the stake distribution over time; and 2) how to distribute fees and rewards to ensure incentive compatibility.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.1 Base Security on Distribution of Stake</h3>

    <p class="text-gray-300">Roughly speaking, our core consensus protocol expects the following assumption for security: at any point of time, there are more alert committee members that will remain honest sufficiently long than there are corrupt committee members. In a proof-of-stake setting, we would like to articulate assumptions regarding the distribution of stake among stake-holders, and state the protocol’s security in terms of such assumptions.</p>

    <p class="text-gray-300">Since our core consensus protocol allows a committee reelection opportunity once every epoch, it is possible that the distribution of the stake in the system lags behind the committee election. However, suppose that this is not the case, e.g., pretend for now that there is no money transfer, then it is simple to translate the assumptions to distribution on stake. Imagine that the application-defined <span class="math">\\textsf{elect\\_cmt}(chain)</span> function will output one public key for each unit of currency as expressed by the state of <span class="math">chain</span>. If a public key has many units of coin, one could simply output the public</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">key pk along with its multiplicity <span class="math">m</span> — and the strings pk$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1,\\ldots,\\textsf{pk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m$ may be used in the hash query for determining the leader. Snow White’s core consensus protocol does not care about the implementation details of elect_cmt(<em>chain</em>), and in fact that is an advantage of our modular composition approach. In this way, our Snow White protocol retains security as long as the at any point of time, more stake is alert and will remain honest sufficiently long than the stake that is corrupt. Here when we say “a unit of stake is alert (or honest, corrupt, resp.)”, we mean that the node that owns this unit of stake is alert (or honest, corrupt, resp.).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the real world, however, there is money transfer — after all that is the entire point of having cryptocurrencies — therefore the committee election lags behind the redistribution of stake. This may give rise to the following attack: once a next committee is elected, the majority of the stake in the committee can now sell their currency units and perform an attack on the cryptocurrency (since they now no longer have stake). For example, the corrupt coalition can perform a double-spending attack where they spend their stake but attempt to fork a history where they did not spend the money.</p>

    <p class="text-gray-300">The limited liquidity assumption. One approach to thwart such an attack is to limit the liquidity in the system — in fact, Snow White expects that the cryptocurrency layer enforces that money will not switch hands too quickly. For example, imagine that at any point of time, <span class="math">a=30\\%</span> of the stake is alert and will remain honest sufficiently long, <span class="math">c=20\\%</span> is corrupt, and the rest are sleepy. We can have the cryptocurrency layer enforce the following rule: only <span class="math">\\frac{a-c}{2}-\\epsilon=5\\%-\\epsilon</span> of the stake can switch hands during every window of size <span class="math">2\\omega+T_{\\text{epoch}}+W</span>. In other words, if in any appropriately long window, only <span class="math">l</span> fraction of money in the system can move, it holds that as long as at any time, <span class="math">2l+\\epsilon</span> more stake is alert and remain honest sufficiently long than the stake that is corrupt, we can guarantee that the conditions expected by the consensus protocol, that is, at any time, more committee members are alert and remain honest sufficiently long, than the committee members that are corrupt.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.2 Fair Reward Scheme</h3>

    <p class="text-gray-300">In a practical deployment, an important desideratum is incentive compatibility. Roughly speaking, we hope that each node will earn a “fair share” of rewards and transaction fees — and in a proof-of-stake system, fairness is defined as being proportional to the amount of stake a node has. In particular, any minority coalition of nodes should not be able to obtain an unfair share of the rewards by deviating from the protocol — in this way, rational nodes should not be incentivized to deviate.</p>

    <p class="text-gray-300">Since Snow White is a blockchain-style protocol, we also inherit the well-known selfish mining attack <em>[24, 45]</em> where a minority coalition can increase its rewards by a factor of nearly 2 in the worst case. Fortunately, inspired by the recent work Fruitchains <em>[46]</em> we provide a solution to <em>provably</em> defend against any form of selfish mining attacks, and ensure that the honest protocol is a coalition-safe <span class="math">\\epsilon</span>-Nash equilibrium. At a high level, Fruitchains provides a mechanism to <em>transform any (possibly unfair) blockchain that achieves consistency and liveness into an approximately fair blockchain in a blackbox manner</em>. Our key observation is that this transformation is also applicable to our non-proof-of-work blockchain — since we realize the same abstraction as a proof-of-work blockchain. Since we apply the essentially same techniques below as Fruitchains, we give an overview of the mechanisms below for completeness and refer the reader to Fruitchains <em>[46]</em> for full details.</p>

    <p class="text-gray-300">Two mining processes. Like in Fruitchains <em>[46]</em>, we propose to have two “mining” processes</p>

    <p class="text-gray-300">piggybacked atop each other. Recall that earlier each node invokes the hash function H in every time step to determine whether it is a leader in this time step. Now, we will use the first half of H to determine leadership, and use the second half to determine if the user mines a “fruit” in this time step. Additionally, we will add to the input of H the digest of a recently stablized block such that any fruit mined will “hang” from a recently stablized block — which block a fruit hangs from indicates the roughly when the fruit was “mined”, i.e., the freshness of the fruit. Whenever an honest node finds a fruit, it broadcasts the fruit to all peers, and honest nodes will incorporate all outstanding and fresh fruits in any block that it “mines”. Note that fruits incorporated in blocks are only considered valid if they are sufficiently fresh. Finally, all valid fruits contained in the blockchain can be linearized, resulting in an ordered “fruit chain”.</p>

    <p class="text-gray-300">The formal analysis conducted in Fruitchains <em>[46]</em> can be adapted to our setting in a straightforward manner, giving rise to the following informal claim:</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Claim 1 (Approximate fairness <em>[46]</em>).</h6>

    <p class="text-gray-300">Assume appropriate parameters. Then for any (arbitrarily small) constant <span class="math">\\epsilon</span>, in any <span class="math">\\frac{\\kappa}{\\epsilon}</span> number of consecutive fruits, the fraction of fruits belonging to an adversarial coalition is at most <span class="math">\\epsilon</span> fraction more than its fair share, as long as, informally speaking, in any committee, alert committee members that remain honest by the posterior corruption window outnumber members that become corrupt by the same window.</p>

    <p class="text-gray-300">We refer the reader to Fruitchains <em>[46]</em> for a formal proof of this claim. Intuitively, this claim holds because the underlying blockchain’s liveness property ensures that no honest fruits will ever be lost (i.e., the adversary cannot “erase” honest nodes’ work in mining fruits like what happens in a selfish mining attack); and moreover, in any sufficiently long window, the adversary can incorporate only legitimate fruits belonging to this window (and not any fruits <span class="math">\\epsilon</span>-far into the past or future).</p>

    <p class="text-gray-300">Payout distribution. Based on the above claim of approximate fairness, we devise the following payout mechanism following the approach of Fruitchain <em>[46]</em>. We will distribute all forms of payout, including mining rewards and transaction fees to fruits rather than blocks. Furthermore, every time payout is issued, it will be distributed equally among a recent segment of roughly <span class="math">\\Omega(\\frac{\\kappa}{\\epsilon})</span> fruits. Like in Fruitchains, this guarantees that as long as at any time, there are more alert committee members that remain honest sufficiently long than corrupt committee members, the corrupt coalition cannot increase its share by more than <span class="math">\\epsilon</span> no matter how it deviates from the prescribed protocol — in other words, the honest protocol is a coalition-safe <span class="math">\\epsilon</span>-Nash equilibrium.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">3.3 Thwarting Nothing-at-Stake Attacks</h3>

    <p class="text-gray-300">Nothing-at-stake refers to a class of well-known attacks in the proof-of-stake context <em>[50]</em>, where participants have nothing to lose for signing multiple forked histories. We describe how Snow White defends against such attacks. Nothing-at-stake attacks apply to both signing forked chains in the past and in the present — since the former refers to posterior corruption style attacks which we already addressed earlier, in the discussion below, we focus on signing forked chains in the present.</p>

    <p class="text-gray-300">First, as long as the adversary does not control the majority, our core consensus protocol formally guarantees that signing forked chains does not break consistency. In fact, we incentivize honest behavior by proving that the adversary cannot increase its rewards by an arbitrarily small <span class="math">\\epsilon</span> fraction, no matter how it deviates from honest behavior which includes signing forked chains.</p>

    <p class="text-gray-300">With <span class="math">\\epsilon</span>-Nash equilibrium, one limitation is that players can still do a small <span class="math">\\epsilon</span> fraction better by deviating, and it would be desirable to enforce a stronger notion where players do strictly worse</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> (a) corrupt  <span class="math">= 16.5\\%</span></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (b) corrupt  <span class="math">= 30\\%</span></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> (c) corrupt  <span class="math">= 40\\%</span> Figure 1: How many blocks to wait for a desired probability of consistency failure. Network delay = 10 seconds, expected block interval = 10 minutes, Snow White's leader election interval = 1 second. The largest mining pool at the time of writing has  <span class="math">16.5\\%</span>  hashpower. In all configurations, Snow White needs to wait for  <span class="math">34\\%</span>  to  <span class="math">43\\%</span>  more blocks than Bitcoin for the same consistency failure probability. Note that all subfigures have different  <span class="math">y</span> -axes.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> (d) corrupt  <span class="math">= 45\\%</span></p>

    <p class="text-gray-300">by deviating. We can make sure that nothing-at-stake attackers do strictly worse by introducing a penalty mechanism in the cryptocurrency layer: by having players that sign multiple blocks with the same timestamp lose an appropriate amount of collateral — to achieve this we need that the underlying core consensus protocol achieves consistency, when roughly speaking, the adversary controls only the minority. Even absent such a penalty mechanism, players currently serving on a committee likely care about the overall health of the cryptocurrency system where they still hold stake due to the limited liquidity assumption — this also provides disincentives for deviating.</p>

    <p class="text-gray-300">The holy grail, of course, is to design a provably secure protocol where any deviation, not just nothing-at-stake attacks, cause the player to do strictly worse. We leave this as an exciting open question. It would also be interesting to consider security when the attack controls the majority — however, if such a majority attacker can behave arbitrarily, consistency was shown to be impossible [48]. Therefore, it thus remains an open question even what meaningful notions of security one can hope for under possibly majority corruption.</p>

    <p class="text-gray-300">As mentioned earlier, in blockchain-style consensus (including Nakamoto's proof-of-work blockchain [44] as well as Snow White), the probability of a consistency failure (which, in practice, can lead to a double-spending attack) drops as one waits for more blocks to be confirmed. Therefore, one interesting and highly relevant question is the following: how many blocks must I wait till I can be sure that my transaction will not be double-spent with all but  <span class="math">X\\%</span>  failure probability? To the best of our knowledge, so far, no results of this nature have been reported even for Nakamoto's proof-of-work blockchain protocol that is widely deployed. For this reason, we believe that our blockchain stochastic simulator can be of independent interest to the community, and we plan to open source the code in the near future.</p>

    <p class="text-gray-300">The simulator. Our blockchain simulator has been implemented in two languages, namely, C++</p>

    <p class="text-gray-300">and Python, such that we could corroborate the correctness of the results. For both Nakamoto’s blockchain and Snow White, our simulator simulates the stochastic block mining process for both honest and corrupt nodes.</p>

    <p class="text-gray-300">Stochastic simulation methodology. For each configuration, we simulate 12.7 million to 13.3 million runs. For each run, we first run the blockchain simulation for sufficiently long such that the stochastic process enters steady state. Then, we choose a block and simulate the “optimal attack” on this block where adversary aims to maintain divergence for as long as possible. The maximum number of blocks for which the adversary can maintain divergence before a forced convergence occurs is henceforth referred to as the maximum divergence length, and this is equivalent to the number of blocks one must wait before this given transaction becomes stable. We then plot the fraction of runs during which this maximum divergence length exceeds <span class="math">Y</span> for different choices of <span class="math">Y</span>. The simulation considers the hash function to be a perfect random oracle, and for Snow White, at the moment the simulation does not consider the effects of attacks where the adversary biases the hashes.</p>

    <p class="text-gray-300">Parameter configurations. We plot our results for the following typical setting. For Bitcoin, we choose a network delay of 10 seconds as Decker and Wattenhofer’s excellent measurement result suggests <em>[20]</em>; and we adopt an average inter-block time of 10 minutes as in Bitcoin. To be fair in the comparison, we choose the same network delay for Snow White, and we perform leader election per second (i.e., each node only computes one hash function per second).</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">4.2 Simulation Results</h3>

    <p class="text-gray-300">Our results are shown in Figure 1, where the <span class="math">x</span>-axis denotes the security parameter, and the <span class="math">y</span>-axis is the maximum divergence length (i.e., the number of blocks to wait till convergence). A specific data point <span class="math">(x,y)</span> can be read as:</p>

    <p class="text-gray-300">For any given transaction that I care about, if I waited for at least <span class="math">y</span> blocks, the probability that my transaction will be double-spent is less than <span class="math">2^{-x}</span>.</p>

    <p class="text-gray-300">We highlight a couple interesting findings:</p>

    <p class="text-gray-300">Comparison of Snow White and Bitcoin. Our result shows that for a fixed network delay, and suppose that the expected block interval is set to be 60 times the network delay (as is the case with Bitcoin), to achieve a desired probability of consistency failure, Snow White needs to wait for 34% to 43% more blocks than Bitcoin — this can be regarded as a reasonable price one pays for removing the proof-of-work and the enormous energy waste. As explain earlier, this slowdown stems from the fact that the Snow White adversary can reuse an earned time slot which gives the adversary additional advantage in a consistency attack. Further, the result (particularly, the fact that all are straight lines) shows that in both Bitcoin and Snow White, the probability of divergence drops exponentially in terms of the number of blocks one waits.</p>

    <p class="text-gray-300">Concrete parameters. At the time of the writing, the largest mining pool, AntPool, controls about 16.5% of the hashpower; and the second largest pool, F2Pool, controls about 12.5% of the hashpower <em>[1]</em>. Our results show the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To defend against a 16.5% adversary (comparable to Bitcoin’s largest mining pool), one needs to wait for roughly 7 blocks for Bitcoin, and roughly 10 blocks for Snow White, to get 99% assurance that any given transaction will not be double-spent — note that there is no proof-of-work in Snow White, but we still use Bitcoin’s pool size as an interesting data point to compare with Bitcoin.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To defend against a 30% adversary (e.g., comparable to the sum of the largest two Bitcoin pools), one needs to wait for roughly 23 blocks in Bitcoin and 33 blocks for Snow White, to obtain a 99% assurance.</li>

      <li>As is theoretically proven <em>[45]</em>, Bitcoin can resist a 49% attack under these parametrizations (10-second network delay and 10-minute block interval). However, our simulation shows that the concrete parameters needed for consistency may not be as optimistic as some might have imagined — even when the adversary controls only 45% of the hashpower, one must wait for 81 blocks to obtain only 75% assurance. Similarly, Snow White can also resist a 49% percent attack if one waited sufficiently long, but the concrete wait time needed for consistency are rather large (assuming optimal attack conditions).</li>

    </ol>

    <p class="text-gray-300">Our simulation assumes optimal attack conditions for the adversary, i.e., the adversary has full control over the network as long as honest nodes’ messages are delayed by at most 10 seconds — specifically, this means that the adversary can perform a network rushing attack such that adversarial blocks on the fly can arrive at honest nodes earlier. In practice, when the condition is not so ideal for the adversary, the practical parameter needed for consistency can be smaller.</p>

    <h2 id="sec-21" class="text-2xl font-bold">5 Implementation and Evaluation</h2>

    <p class="text-gray-300">To further prove the efficacy of Snow White in production environments, we implemented the Snow White protocol. It would have been ideal to deploy Snow White on a wide scale in a production setting and perform a more realistic evaluation — but we leave this as future work. Instead we evaluate the throughput of Snow White in a 40-node deployment, under a high-bandwidth and low latency environment. We focus on reporting best-case throughput results through comparison with a crash-fault resilient Proof-of-Stake solution implemented by Parity, called Authority chains <em>[29]</em>. Specifically, we compare with the “Authority Round” protocol, the default recommendation for Parity Authority chains. Since the latter does not support committee reconfiguration at this moment, we compare both schemes’ throughput under a static committee. Our throughput experiments are conducted in a benign environment absent any attacks. Note that “Authority Round” does not have provable security: our evaluation results will show comparable performance of both schemes, with Snow White providing the added benefits of rigorous security guarantees.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">5.1 Design</h3>

    <p class="text-gray-300">We start with the Parity, the Rust-based Ethereum client <em>[23]</em>. During recent stress tests and attacks on the Ethereum network, the Parity client has proved by far the most robust and fastest client available <em>[9]</em>. We choose this client exclusively for its speed; because our evaluation attempts to establish performance bounds for Snow White, choosing a base client for its speed (transaction throughput and block processing time) is the only logical criterion. Other available Ethereum clients include pyethereum (in Python) and geth (in Go). We intend the combination of our reference implementation for Parity and the specification in this work to be sufficient to port Snow White to these clients if desired.</p>

    <p class="text-gray-300">Also beneficial in Parity is the ability to define modules with “puzzle engines”, or replacements for the proof of work mechanism underlying Ethereum, as plugins <em>[29]</em>. This allowed us to cleanly define Snow White as a plugin to Parity, making it compatible with Parity’s full infrastructure and any tools developed for Ethereum (including contract languages, compilers, blockchain explorers,</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 2: Best-case performance evaluation</p>

    <p class="text-gray-300">and many more). This also allows us to easily leverage Parity's rapid pace of development (with dozens of commit per day typically) without large refactors.</p>

    <p class="text-gray-300">We base our prototype on Parity's "Basic Authority" chain security algorithm, in which a static set of authorities is specified in a chain specification file, and these authorities are allowed to sign blocks with no further restrictions. Adding in the restrictions required for Snow White results in our functional implementation.</p>

    <p class="text-gray-300">We manually configured the network such that each node was fully peered, ensuring a fully connected network graph. We also took advantage of Amazon's relatively low latency connections between regions to push our parameters beyond normal operation, establishing an upper bound for our system and a reasonable performance estimate on well connected infrastructure (such as in a private deployment at a bank). Obviously, requiring performance across a wide variety of lower quality Internet connections would decrease throughput substantially. We also used a minimum time interval (time between blocks) of 5 seconds in both security algorithms; minimum times lower than this lead to excess on-chain contention and thus decreased throughput.</p>

    <p class="text-gray-300">To measure the throughput, we took the longest blockchain generated by our experiment and took a moving average of number of transactions processed per second over 60 seconds. This is because blocks are generated in discrete intervals, which cause unreadable throughput spikes.</p>

    <p class="text-gray-300">The results are shown in Figure 2. The two upper lines represent the observed performance of both Snow White and Parity’s Authority chain over a fifteen minute run, in which all nodes were submitting the maximum amount of possible transactions through the Parity RPC interface. This mimics real-world deployments of such chains, in which users (and other software components) submit transactions through RPC.</p>

    <p class="text-gray-300">The performance of Snow White and Parity is so close as to be virtually indistinguishable, demonstrating that Snow White is able to hit the theoretical upper bound of the Ethereum software’s performance without hitting any mining-related bottlenecks. Both Snow White and Parity’s Authority chains operate in a range between 100 and 150 transactions per second, which with an average observed transaction size of 111 bytes, corresponds to under 16kB of block space per second and is obviously nowhere near saturating the bandwidth or block latency bottlenecks we describe in this work.</p>

    <p class="text-gray-300">We also graph the capacities of the permissionless Bitcoin and Ethereum networks in the same figure, showing that they are approximately 1 and 2 orders of magnitude lower than our system’s empirical upper bound. While obviously a tit-for-tat comparison is disingenuous, as both Bitcoin and Ethereum use significantly lower quality network links on a wider variety of machines, this does show that adoption of Snow White by the permissionless blockchain community is feasible today without approaching the upper-bound capacity of Snow White.</p>

    <p class="text-gray-300">We thus conclude that Snow White is a useful replacement for Authority chains today. As tested, Authority chains are not Byzantine fault tolerant, making it a significantly weaker protocol than Snow White. Additionally, claims of BFT operation modes in Authority chains are not accompanied by proof or justification as found in this paper, making the claims highly dubious. It is thus our recommendation that the Ethereum community switch to Snow White for Authority chains, at a significant security gain with zero performance penalty.</p>

    <p class="text-gray-300">This CPU bottleneck demonstrated by the performance of our widely distributed network approaches the performance of a single node which engages in no network communication, which we measured at approximately 125 tx/s. As we have shown, our theoretical upper bound on performance in the current prototype is already an order of magnitude higher than the maximum throughput of the decentralized Bitcoin network. As the permissionless algorithm adds little to no additional computational overhead, we expect Snow White to fully satisfy the performance requirements of securing a distributed and permissionless ledger.</p>

    <p class="text-gray-300">We hope to continue developing and refining this prototype into a robust implementation usable by both permissioned and permissionless blockchains, providing the ultimate in provable security, performance, and simplicity for future blockchain deployments.</p>

    <h2 id="sec-24" class="text-2xl font-bold">Full Formalism and Proofs</h2>

    <p class="text-gray-300">We present the full formalism and proofs in the appendices.</p>

    <h2 id="sec-25" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We gratefully acknowledge Siqiu Yao and Yuncong Hu for lending criticial help in building the simulator. We thank Lorenzo Alvisi for suggesting the name Snow White. We also thank Rachit Agarwal, Kai-Min Chung, and Ittay Eyal for helpful and supportive discussions. This work is in part supported by NSF under grant number CNS-1561209.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Hashrate distribution. https://blockchain.info/pools.</li>

      <li>[2] Personal communication with Vitalik Buterin, and public talks on sharding by Vitalik Buterin, 2018.</li>

      <li>[3] B. Barak, R. Canetti, Y. Lindell, R. Pass, and T. Rabin. Secure computation without authentication. In CRYPTO, pages 361–377, 2005.</li>

      <li>[4] S. Barber, X. Boyen, E. Shi, and E. Uzun. Bitter to betterhow to make bitcoin a better currency. In Financial cryptography and data security, pages 399–414. Springer, 2012.</li>

      <li>[5] M. Ben-Or. Another advantage of free choice (extended abstract): Completely asynchronous agreement protocols. In Proceedings of the Second Annual ACM Symposium on Principles of Distributed Computing, PODC ’83, pages 27–30, New York, NY, USA, 1983. ACM.</li>

      <li>[6] I. Bentov, A. Gabizon, and A. Mizrahi. Cryptocurrencies without proof of work. In Financial Cryptography Bitcoin Workshop, 2016.</li>

      <li>[7] I. Bentov, C. Lee, A. Mizrahi, and M. Rosenfeld. Proof of activity: Extending bitcoin’s proof of work via proof of stake. In Proceedings of the ACM SIGMETRICS 2014 Workshop on Economics of Networked Systems, NetEcon, 2014.</li>

      <li>[8] A. N. Bessani, J. Sousa, and E. A. P. Alchieri. State machine replication for the masses with BFT-SMART. In DSN, pages 355–362, 2014.</li>

      <li>[9] E. Blog. Performance analysis. https://blog.ethcore.io/performance-analysis/, 2016. Accessed: 2016-11-01.</li>

      <li>[10] J. Bonneau, J. Clark, and S. Goldfeder. On bitcoin as a public randomness source. IACR Cryptology ePrint Archive, 2015:1015, 2015.</li>

      <li>[11] G. Bracha and S. Toueg. Asynchronous consensus and broadcast protocols. J. ACM, 32(4):824–840, Oct. 1985.</li>

      <li>[12] C. Cachin, K. Kursawe, F. Petzold, and V. Shoup. Secure and efficient asynchronous broadcast protocols. In Advances in Cryptology - CRYPTO 2001, 21st Annual International Cryptology Conference, Santa Barbara, California, USA, August 19-23, 2001, Proceedings, pages 524–541, 2001.</li>

      <li>[13] R. Canetti. Universally composable security: A new paradigm for cryptographic protocols. In FOCS, 2001.</li>

      <li>[14] R. Canetti, Y. Dodis, R. Pass, and S. Walfish. Universally composable security with global setup. In Theory of Cryptography, pages 61–85. Springer, 2007.</li>

      <li>[15] R. Canetti and T. Rabin. Universal composition with joint state. In CRYPTO, 2003.</li>

      <li>[16] M. Castro and B. Liskov. Practical byzantine fault tolerance. In OSDI, 1999.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[17] J. Chen and S. Micali. Algorand: The efficient and democratic ledger. https://arxiv.org/abs/1607.01341, 2016.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[18] U. ”cunicula” and M. Rosenfeld. Proof of stake brainstorming. https://bitcointalk.org/index.php?topic=37194.0, August 2011.</li>

      <li>[19] B. David, P. Gaži, A. Kiayias, and A. Russell. Ouroboros praos: An adaptively-secure, semi-synchronous proof-of-stake protocol. Cryptology ePrint Archive, Report 2017/573, 2017. http://eprint.iacr.org/2017/573.</li>

      <li>[20] C. Decker and R. Wattenhofer. Information propagation in the bitcoin network. In IEEE P2P, 2013.</li>

      <li>[21] D. Dolev and H. R. Strong. Authenticated algorithms for byzantine agreement. Siam Journal on Computing - SIAMCOMP, 12(4):656–666, 1983.</li>

      <li>[22] C. Dwork, N. Lynch, and L. Stockmeyer. Consensus in the presence of partial synchrony. J. ACM, 1988.</li>

      <li>[23] Ethcore. Parity. https://ethcore.io/parity.html, 2016. Accessed: 2016-11-01.</li>

      <li>[24] I. Eyal and E. G. Sirer. Majority is not enough: Bitcoin mining is vulnerable. In FC, 2014.</li>

      <li>[25] P. Feldman and S. Micali. An optimal probabilistic protocol for synchronous byzantine agreement. In SIAM Journal of Computing, 1997.</li>

      <li>[26] M. J. Fischer, N. A. Lynch, and M. S. Paterson. Impossibility of distributed consensus with one faulty process. J. ACM, 32(2):374–382, Apr. 1985.</li>

      <li>[27] R. Friedman, A. Mostefaoui, and M. Raynal. Simple and efficient oracle-based consensus protocols for asynchronous byzantine systems. IEEE Trans. Dependable Secur. Comput., 2(1):46–56, Jan. 2005.</li>

      <li>[28] J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol: Analysis and applications. In Eurocrypt, 2015.</li>

      <li>[29] P. Github. Proof of Authority Chains. https://github.com/ethcore/parity/wiki/Proof-of-Authority-Chains. Accessed: 2016-12-08.</li>

      <li>[30] T. Hanke, M. Movahedi, and D. Williams. Dfinity technology overview series: Consensus system. https://dfinity.org/tech.</li>

      <li>[31] H. Howard, D. Malkhi, and A. Spiegelman. Flexible paxos: Quorum intersection revisited. https://arxiv.org/abs/1608.06696.</li>

      <li>[32] J. Katz and C.-Y. Koo. On expected constant-round protocols for byzantine agreement. J. Comput. Syst. Sci., 75(2):91–112, Feb. 2009.</li>

      <li>[33] A. Kiayias and G. Panagiotakos. Speed-security tradeoffs in blockchain protocols. IACR Cryptology ePrint Archive, 2015:1019, 2015.</li>

    </ul>

    <p class="text-gray-300">[34] A. Kiayias, A. Russell, B. David, and R. Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain protocol. In Crypto, 2017.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[35] S. King and S. Nadal. Ppcoin: Peer-to-peer crypto-currency with proof-of-stake. https://peercoin.net/assets/paper/peercoin-paper.pdf, 2012.</li>

      <li>[36] J. Kwon. Tendermint: Consensus without mining. http://tendermint.com/docs/tendermint.pdf, 2014.</li>

      <li>[37] L. Lamport. The weak byzantine generals problem. J. ACM, 30(3):668–676, 1983.</li>

      <li>[38] L. Lamport. Fast paxos. Distributed Computing, 19(2):79–103, 2006.</li>

      <li>[39] L. Lamport, D. Malkhi, and L. Zhou. Vertical paxos and primary-backup replication. In PODC, pages 312–313, 2009.</li>

      <li>[40] L. Lamport, R. Shostak, and M. Pease. The byzantine generals problem. ACM Trans. Program. Lang. Syst., 4(3):382–401, July 1982.</li>

      <li>[41] J.-P. Martin and L. Alvisi. Fast byzantine consensus. IEEE Trans. Dependable Secur. Comput., 3(3), 2006.</li>

      <li>[42] G. Maxwell and A. Poelstra. Distributed consensus from proof of stake is impossible, 2014. https://download.wpsoftware.net/bitcoin/pos.pdf.</li>

      <li>[43] A. Miller, Y. Xia, K. Croman, E. Shi, and D. Song. The honey badger of BFT protocols. Cryptology ePrint Archive, Report 2016/199, 2016. http://eprint.iacr.org/.</li>

      <li>[44] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system. 2008.</li>

      <li>[45] R. Pass, L. Seeman, and A. Shelat. Analysis of the blockchain protocol in asynchronous networks. In Eurocrypt, 2017.</li>

      <li>[46] R. Pass and E. Shi. Fruitchains: A fair blockchain. Manuscript, 2016.</li>

      <li>[47] R. Pass and E. Shi. Hybrid consensus: Efficient consensus in the permissionless model. Manuscript, 2016.</li>

      <li>[48] R. Pass and E. Shi. The sleepy model of consensus. http://eprint.iacr.org/2016/918, 2016.</li>

      <li>[49] R. Pass and E. Shi. Rethinking large-scale consensus. In CSF, 2017.</li>

      <li>[50] A. Poelstra. Distributed consensus from proof of stake is impossible. https://download.wpsoftware.net/bitcoin/alts.pdf.</li>

      <li>[51] U. ”QuantumMechanic”. Proof of stake instead of proof of work. https://bitcointalk.org/index.php?topic=27787.0, July 2011.</li>

      <li>[52] Y. J. Song and R. van Renesse. Bosco: One-step byzantine asynchronous consensus. In DISC, pages 438–450, 2008.</li>

    </ul>

    <p class="text-gray-300">[53] U. ”tacotime”. Netcoin proof-of-work and proof-of-stake hybrid design, 2013. https://web.archive.org/web/20131213085759/http://www.netcoin.io/wiki/Netcoin_Proof-of-Work_and_Proof-of-Stake_Hybrid_Design.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[54] V. G. Vitalik Buterin. Casper the friendly finality gadget. https://arxiv.org/abs/1710.09437.</li>

    </ul>

    <h2 id="sec-26" class="text-2xl font-bold">Appendix A Definitions</h2>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">A.1 Protocol Execution Model</h3>

    <p class="text-gray-300">Our protocol execution model extends and enriches the sleepy model <em>[48]</em>. To capture a more powerful adversary, we make the following notable changes in modeling in comparison with sleepy <em>[48]</em>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We allow dynamic node spawning whereas the basic sleepy model <em>[48]</em> requires that all nodes (including honest and corrupt ones) be spawned prior to protocol start.</li>

      <li>We allow the adversary to issue corrupt and sleep instructions after protocol execution starts, whereas in the basic sleepy model <em>[48]</em>, all corrupt and sleep instructions must be declared upfront prior to protocol start. Later when we describe our protocol, we will specify further constraints on the adversary, in particular, under what conditions the adversary can corrupt nodes or make them sleep.</li>

      <li>Our model distinguishes between a light sleeper and a deep sleeper and treats them differently. As explained in Sections 2 and C, such a distinction is necessary so as not to tread on theoretical impossibility.</li>

    </ul>

    <p class="text-gray-300">Below we elaborate on our execution model in detail. We note that this section focuses on describe the basic execution model. We defer it to later sections to specify precise constraints (e.g., how long it takes for corruption to take effect, what parameters are admissible, etc.) that must be placed on the adversary to prove our protocol secure.</p>

    <p class="text-gray-300">We assume a standard Interactive Turing Machine (ITM) model <em>[13, 14, 15]</em> often adopted in the cryptography literature.</p>

    <p class="text-gray-300">(Weakly) synchronized clocks. We assume that nodes have a globally synchronized clock. In fact, with our network model (to be explained later), we can, without loss of generality, relax this assumption to weakly synchronized, where honest nodes clocks are offset by some a-priori known upper bound <span class="math">\\Delta_{\\text{clock}}</span>, basically by absorbing the clock offset <span class="math">\\Delta_{\\text{clock}}</span> into the maximum network delay parameter <span class="math">\\Delta</span> (see earlier work <em>[48]</em> for a more detailed explanation).</p>

    <p class="text-gray-300">Corruption model. At any point of time, the environment <span class="math">\\mathcal{Z}</span> can communicate with corrupt nodes in arbitrary manners. This also implies that the environment can see the internal state of corrupt nodes. Corrupt nodes can deviate from the prescribed protocol arbitrarily, i.e., exhibit byzantine faults. All corrupt nodes are controlled by a probabilistic polynomial-time adversary denoted <span class="math">\\mathcal{A}</span>, and the adversary can see the internal states of corrupt nodes. For honest nodes, the environment cannot observe their internal state, but can observe any information honest nodes output to the environment by the protocol definition. Specifically, we assume the following corruption model.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Spawn. At any time, <span class="math">\\mathcal{Z}</span> can spawn fresh nodes, either alert or corrupt ones.</li>

    </ul>

    <p class="text-gray-300">We assume that upon spawning an alert node <span class="math">i</span> at (the beginning of) time <span class="math">t</span>, <span class="math">(\\mathcal{A},\\mathcal{Z})</span> must deliver an initialization message to node <span class="math">i</span>. Our protocols later will impose further constraints on this initialization message, and these constraints may imply additional trust assumptions necessary for a node to securely join the protocol. Therefore we defer requirements for the initialization message to protocol-specific compliance rules.</p>

    <p class="text-gray-300">We allow the adversary <span class="math">\\mathcal{A}</span> to spawn corrupt nodes on its own without informing <span class="math">\\mathcal{Z}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Corrupt. At any time <span class="math">t</span>, <span class="math">\\mathcal{A}</span> can issue to <span class="math">\\mathcal{Z}</span> a corruption instruction of the form:</li>

    </ul>

    <p class="text-gray-300"><span class="math">(\\texttt{corrupt},i,t^{\\prime})\\text{ where }t^{\\prime}\\geq t</span></p>

    <p class="text-gray-300">A <span class="math">(\\texttt{corrupt},i,t^{\\prime})</span> instruction causes node <span class="math">i</span> to become corrupt at time <span class="math">t^{\\prime}\\geq t</span> (if it did not already become corrupt earlier).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sleep. At any time <span class="math">t</span>, <span class="math">\\mathcal{A}</span> can issue to <span class="math">\\mathcal{Z}</span> a sleep instruction of the form:</li>

    </ul>

    <p class="text-gray-300"><span class="math">(\\texttt{sleep},i,t_{0},t_{1})\\text{ where }t_{0}\\leq t\\leq t_{1}</span></p>

    <p class="text-gray-300">A <span class="math">(\\texttt{sleep},i,t_{0},t_{1})</span> instruction causes node <span class="math">i</span> to be asleep (or sleeping/sleepy) between time <span class="math">[t_{0},t_{1}]</span> — as long as it did not already become corrupt earlier. A sleeping honest node (also called a sleeper) stops receiving or sending messages. If a sleeper does not become corrupt during the time it is asleep, it may wake up later again.</p>

    <p class="text-gray-300">Our model distinguishes between a deep sleeper and a light sleeper. A sleeper that sleeps for a long time before waking up is called a deep sleeper and one that wakes up soon is called a light sleeper. The definition of long and short depends on the protocol, and therefore we defer the concrete parameter specifications to protocol-specific compliance rules.</p>

    <p class="text-gray-300">When a light sleeper wakes up, <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is required to deliver a wakeup message that is an unordered set containing</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>all the pending messages that node <span class="math">i</span> would have received (but did not receive) had it not slept; and</li>

      <li>any polynomial number of adversarially inserted messages of <span class="math">(\\mathcal{A},\\mathcal{Z})</span>’s choice.</li>

    </ul>

    <p class="text-gray-300">By contrast, a deep sleeper waking up is treated the same way as node respawning. Specifically, <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is required to resend the node an initialization message which must satisfy the same requirement of an initialization message for a newly spawning node.</p>

    <p class="text-gray-300">To summarize, a node can be in one of the following states:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Honest. An honest node can either be awake or asleep (or sleeping/sleepy). Henceforth we say that a node is alert if it is honest and awake. When we say that a node is asleep (or sleeping/sleepy), it means that the node is honest and asleep.</li>

      <li>Corrupt. Without loss of generality, we assume that all corrupt nodes are awake.</li>

    </ol>

    <p class="text-gray-300">Network delivery. The adversary is responsible for delivering messages between nodes. We assume that the adversary <span class="math">\\mathcal{A}</span> can delay or reorder messages arbitrarily, as long as it respects the constraint that all messages sent from alert nodes must be received by all alert nodes in at most <span class="math">\\Delta</span> time steps.</p>

    <p class="text-gray-300">A.2 Notational Conventions</p>

    <p class="text-gray-300">Negligible functions. A function <span class="math">\\mathsf{negl}(\\cdot)</span> is said to be negligible if for every polynomial <span class="math">p(\\cdot)</span>, there exists some <span class="math">\\kappa_{0}</span> such that <span class="math">\\mathsf{negl}(\\kappa)\\leq\\frac{1}{p(\\kappa)}</span> for all <span class="math">\\kappa\\geq\\kappa_{0}</span>.</p>

    <p class="text-gray-300">Convention for parameters. In this paper, unless otherwise noted, all variables are by default (polynomially bounded) functions of the security parameter <span class="math">\\kappa</span>. Whenever we say <span class="math">\\mathsf{var}_{0}&gt;\\mathsf{var}_{1}</span>, this means that <span class="math">\\mathsf{var}_{0}(\\kappa)&gt;\\mathsf{var}_{1}(\\kappa)</span> for every <span class="math">\\kappa\\in\\mathbb{N}</span>. Variables may also be functions of each other. How various variables are related will become obvious when we define derived variables and when we state parameters’ admissible rules for each protocol.</p>

    <p class="text-gray-300">Importantly, whenever a parameter does not depend on <span class="math">\\kappa</span>, we shall explicitly state it by calling it a constant.</p>

    <p class="text-gray-300">Compliant executions. In this paper, for each protocol we introduce (including intermediate ones used in the proofs), we will define compliant executions by specifying a set of constraints on the p.p.t. pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>. Roughly speaking, our theorems will state that desirable security properties are respected except with negligible probability in any compliant execution. Since compliance is defined per protocol, we will often use the notation <span class="math">\\Pi</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span> to mean that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> must respect the constraints expected by the <span class="math">\\Pi</span> protocol.</p>

    <h2 id="sec-28" class="text-2xl font-bold">Appendix B Preliminaries: Blockchain Formal Abstraction</h2>

    <p class="text-gray-300">In this section, we define the formal abstraction and security properties of a blockchain. Our definitions follow the approach of Pass et al. <em>[45]</em>, which in turn are based on earlier definitions from Garay et al. <em>[28]</em>, and Kiayias and Panagiotakos <em>[33]</em>.</p>

    <p class="text-gray-300">Since our model distinguishes between two types of honest nodes, alert and sleepy ones, we define chain growth, chain quality, and consistency for alert nodes. However, we point out the following: 1) if chain quality holds for alert nodes, it would also hold for sleepy nodes (since sleepy nodes stop receiving new messages); 2) if consistency holds for alert nodes, then sleep nodes’ chains should also satisfy common prefix and future self-consistency, although obviously sleepy nodes’ chains can be much shorter than alert ones.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notations. For some <span class="math">\\mathcal{A},\\mathcal{Z}</span>, consider some view in the support of <span class="math">\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>; we use the notation $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ to denote the number of time steps in the execution.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We assume that in every time step, the environment <span class="math">\\mathcal{Z}</span> provides a possibly empty input to every honest node. Further, in every time step, an alert node sends an output to the environment <span class="math">\\mathcal{Z}</span>. Given a specific execution trace view with non-zero support where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq t<span class="math">, let </span>i<span class="math"> denote a node that is alert at time </span>t<span class="math"> in view, we use the following notation to denote the output of node </span>i<span class="math"> to the environment </span>\\mathcal{Z}<span class="math"> at time step </span>t$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\text{output to }\\mathcal{Z}\\text{ by node }i\\text{ at time }t\\text{ in view: }\\quad\\mathsf{chain}_{i}^{t}(\\mathsf{view})</span></p>

    <p class="text-gray-300">where chain denotes an extracted ideal blockchain where each block contains an ordered list of transactions. Sleepy nodes stop outputting to the environment until they wake up again.</p>

    <p class="text-gray-300">Later in the text, if the context is clear, we sometimes omit writing a subset of the sub- or super-scripts and/or the view — for example, sometimes we simply write chain if the context is clear.</p>

    <p class="text-gray-300">B.1 Chain Growth</p>

    <p class="text-gray-300">The first desideratum is that the chain grows steadily over time, not too slow, not too fast.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{growth}^{t_{0},t_{1}}(\\mathsf{view},\\Delta,T)=1</span> iff the following holds:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (consistent length) for all time steps $t\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\Delta<span class="math">, </span>t+\\Delta\\leq t^{\\prime}\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, for every two players </span>i,j<span class="math"> such that in </span>\\mathsf{view}<span class="math"> </span>i<span class="math"> is alert at </span>t<span class="math"> and </span>j<span class="math"> is alert at </span>t^{\\prime}$, we have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}_{j}^{t^{\\prime}}(\\mathsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}_{i}^{t}(\\mathsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}_{j}^{t+t_{0}}(\\mathsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}_{i}^{t}(\\mathsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq T.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}_{j}^{t+t_{1}}(\\mathsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}_{i}^{t}(\\mathsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq T.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In other words, <span class="math">\\mathsf{growth}^{t_{0},t_{1}}</span> is a predicate which tests that a) alert parties have chains of roughly the same length, and b) during any <span class="math">t_{0}</span> time steps in the execution, all alert parties’ chains increase by at least <span class="math">T</span>, and c) during any <span class="math">t_{1}</span> time steps in the execution, alert parties’ chains increase by at most <span class="math">T</span>.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Definition 1 (Chain growth).</h6>

    <p class="text-gray-300">A blockchain protocol <span class="math">\\Pi</span> satisfies <span class="math">(T_{0},g_{0},g_{1})</span>-chain growth, if for all <span class="math">\\Pi</span>-compliant p.p.t. pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, there exists some negligible function <span class="math">\\mathsf{negl}</span> such that for every <span class="math">\\kappa\\in\\mathbb{N}</span>, <span class="math">T\\geq T_{0}</span>, <span class="math">t_{0}\\geq\\frac{T}{g_{0}}</span> and <span class="math">t_{1}\\leq\\frac{T}{g_{1}}</span> the following holds:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow_{\\S}\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\kappa):\\mathsf{growth}^{t_{0},t_{1}}(\\mathsf{view},\\Delta,\\kappa)=1\\right]\\geq 1-\\mathsf{negl}(\\kappa)</span></p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">B.2 Chain Quality</h3>

    <p class="text-gray-300">The second desideratum is that the number of blocks contributed by the adversary is not too large.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a <span class="math">\\mathsf{chain}</span>, we say that a block <span class="math">B:=\\mathsf{chain}[j]</span> is honest w.r.t. <span class="math">\\mathsf{view}</span> and prefix <span class="math">\\mathsf{chain}[:j^{\\prime}]</span> where <span class="math">j^{\\prime}&lt;j</span> if in <span class="math">\\mathsf{view}</span> there exists some node <span class="math">i</span> alert at some time $t\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, such that 1) </span>\\mathsf{chain}[:j^{\\prime}]\\prec\\mathsf{chain}_{i}^{t}(\\mathsf{view})<span class="math">, and 2) </span>\\mathcal{Z}<span class="math"> input </span>B<span class="math"> to node </span>i<span class="math"> at time </span>t<span class="math">. Informally, for an honest node’s chain denoted </span>\\mathsf{chain}<span class="math">, a block </span>B:=\\mathsf{chain}[j]<span class="math"> is honest w.r.t. a prefix </span>\\mathsf{chain}[:j^{\\prime}]<span class="math"> where </span>j^{\\prime}<j<span class="math">, if earlier there is some alert node who received </span>B<span class="math"> as input when its local chain contains the prefix </span>\\mathsf{chain}[:j^{\\prime}]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">\\mathsf{quality}^{T}(\\mathsf{view},\\mu)=1</span> iff for every time <span class="math">t</span> and every player <span class="math">i</span> such that <span class="math">i</span> is alert at <span class="math">t</span> in <span class="math">\\mathsf{view}</span>, among any consecutive sequence of <span class="math">T</span> blocks <span class="math">\\mathsf{chain}[j+1..j+T]\\subseteq\\mathsf{chain}_{i}^{t}(\\mathsf{view})</span>, the fraction of blocks that are honest w.r.t. <span class="math">\\mathsf{view}</span> and <span class="math">\\mathsf{chain}[:j]</span> is at least <span class="math">\\mu</span>.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Definition 2 (Chain quality).</h6>

    <p class="text-gray-300">A blockchain protocol <span class="math">\\Pi</span> has <span class="math">(T_{0},\\mu)-\\mathit{chain}</span> <em>quality</em>, if for all <span class="math">\\Pi</span>-compliant p.p.t. pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, there exists some negligible function <span class="math">\\mathsf{negl}</span> such that for every <span class="math">\\kappa\\in\\mathbb{N}</span> and every <span class="math">T\\geq T_{0}</span> the following holds:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow_{\\S}\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\kappa):\\mathsf{quality}^{T}(\\mathsf{view},\\mu)=1\\right]\\geq 1-\\mathsf{negl}(\\kappa)</span></p>

    <p class="text-gray-300">Global  <span class="math">\\mathcal{G}_{\\mathrm{sign}}^{\\Sigma}</span>  functionality (possibly shared with other protocols)</p>

    <p class="text-gray-300">On initialization:  <span class="math">\\Gamma = \\emptyset</span></p>

    <p class="text-gray-300">On receive gen from  <span class="math">\\mathcal{P}</span> :</p>

    <p class="text-gray-300">(pk,sk)  <span class="math">\\leftarrow \\Sigma .\\mathsf{gen}(1^{\\kappa})</span>  , and add the tuple  <span class="math">(\\mathcal{P},\\mathsf{pk},\\mathsf{sk})</span>  to table  <span class="math">\\Gamma</span></p>

    <p class="text-gray-300">Notify  <span class="math">\\mathcal{A}</span>  of  <span class="math">(\\mathcal{P},\\mathsf{pk})</span>  , and return pk</p>

    <p class="text-gray-300">On receive sign(pk, msg) from  <span class="math">\\mathcal{P}</span>  in protocol sid:</p>

    <p class="text-gray-300">assert that a tuple of the form  <span class="math">(\\mathcal{P},\\mathsf{pk},\\mathsf{sk})\\in \\Gamma</span>  exists for some sk</p>

    <p class="text-gray-300">return  <span class="math">\\Sigma .\\mathrm{Sign}_{\\mathbf{sk},sid}(\\mathbf{msg})</span></p>

    <p class="text-gray-300">On receive getkey  <span class="math">(\\mathcal{P})</span>  from  <span class="math">\\mathcal{A}</span> : if  <span class="math">\\mathcal{P}</span>  is corrupt, return all tuples in  <span class="math">\\Gamma</span>  of the form  <span class="math">(\\mathcal{P},\\neg ,\\neg)</span>  to  <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300">Figure 3: Global signing functionality, parametrized by a signature scheme denoted  <span class="math">\\Sigma = (\\mathsf{Sign},\\mathsf{Ver})</span> . We use the shorthand  <span class="math">\\mathsf{Sign}_{\\mathsf{sk},sid}</span>  and  <span class="math">\\mathsf{Ver}_{\\mathsf{pk},sid}</span>  to denote that the message is prefixed with the protocol's session identifier  <span class="math">sid</span> .</p>

    <p class="text-gray-300">Roughly speaking, consistency stipulates common prefix and future self-consistency. Common prefix requires that all honest nodes' chains, except for roughly  <span class="math">O(\\kappa)</span>  number of trailing blocks that have not stabilized, must all agree. Future self-consistency requires that an honest node's present chain, except for roughly  <span class="math">O(\\kappa)</span>  number of trailing blocks that have not stabilized, should persist into its own future. These properties can be unified in the following formal definition (which additionally requires that at any time, two alert nodes' chains must be of similar length).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">\\text{consistent}^T(\\text{view}) = 1</span>  iff for all times  <span class="math">t \\leq t&#x27;</span> , and all players  <span class="math">i, j</span>  (potentially the same) such that  <span class="math">i</span>  is alert at  <span class="math">t</span>  and  <span class="math">j</span>  is alert at  <span class="math">t&#x27;</span>  in view, we have that the prefixes of  <span class="math">\\text{chain}_i^t(\\text{view})</span>  and  <span class="math">\\text{chain}_j^{t&#x27;}(\\text{view})</span>  consisting of the first  $\\ell =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{chain}_i^t(\\text{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- T<span class="math">  records are identical — this also implies that the following must be true:  </span>\\text{chain}_j^{t'}(\\text{view}) &gt; \\ell<span class="math"> , i.e.,  </span>\\text{chain}_j^{t'}(\\text{view})<span class="math">  cannot be too much shorter than  </span>\\text{chain}_i^t(\\text{view})<span class="math">  given that  </span>t' \\geq t$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 3 (Consistency). A blockchain protocol  <span class="math">\\Pi</span>  satisfies  <span class="math">T_0</span> -consistency, if for all  <span class="math">\\Pi</span> -compliant p.p.t. pair  <span class="math">(\\mathcal{A},\\mathcal{Z})</span> , there exists some negligible function  <span class="math">\\mathrm{negl}</span>  such that for every  <span class="math">\\kappa \\in \\mathbb{N}</span>  and every  <span class="math">T \\geq T_0</span>  the following holds:</p>

    <p class="text-gray-300"><span class="math">\\operatorname*{Pr}\\left[\\mathsf{view}\\leftarrow_{\\mathfrak{S}}\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\kappa):\\mathsf{consistent}^{T}(\\mathsf{view}) = 1\\right]\\geq 1 - \\mathsf{negl}(\\kappa)</span></p>

    <p class="text-gray-300">Note that a direct consequence of consistency is that at any time, the chain lengths of any two alert players can differ by at most  <span class="math">T</span>  (except with negligible probability).</p>

    <p class="text-gray-300">Our protocol makes use of digital signatures. We model digital signatures in a way such that the signature keys can be shared between our consensus protocol and any application-level protocol. For</p>

    <p class="text-gray-300">example, imagine that the cryptocurrency layer uses the same signing keys to sign transactions. Our modeling approach guarantees that the security of our <span class="math">\\Pi_{\\text{sleepy}}</span> protocol is retained when composed with arbitrary application-level protocols, as long as the application-level protocols respect the compliance rules expected by <span class="math">\\Pi_{\\text{sleepy}}</span>.</p>

    <p class="text-gray-300">Specifically, we follow the GUC paradigm <em>[14]</em> and model the signature as a signing functionality shared across protocols. Figure 3 illustrates this signature functionality denoted <span class="math">\\mathcal{G}^{\\Sigma}_{\\text{sign}}</span>, which is parametrized by a signature scheme denoted <span class="math">\\Sigma</span>. We often omit writing the superscript <span class="math">\\Sigma</span> without risk of ambiguity. We now explain the <span class="math">\\mathcal{G}_{\\text{sign}}</span> functionality. <span class="math">\\mathcal{G}_{\\text{sign}}</span> generates and remembers a new signature key pair for a party upon the gen call; and signs messages for parties upon the sign call using any of the party’s signing keys. Finally upon a getkey query, <span class="math">\\mathcal{G}_{\\text{sign}}</span> discloses the secret signing keys of corrupt parties to the adversary <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">Note that in practice, such a functionality is actually realized in the following way: every honest node implements a trusted signing wrapper that is shared across all protocols instances executed by the honest node. This trusted signing wrapper is in charge of generating signature keys and perform signing operations. Following the GUC modeling paradigm <em>[14]</em>, the union of the trusted signing wrappers across all honest nodes is considered as the trusted computing base (TCB), and therefore conceptually grouped into this single functionality <span class="math">\\mathcal{G}_{\\text{sign}}</span>. When a node becomes corrupt, its signing wrapper is then controlled by the adversary, therefore the secret signing keys get disclosed to the adversary.</p>

    <p class="text-gray-300">Like in the standard GUC paradigm, we assume that the environment <span class="math">\\mathcal{Z}</span> can interact with <span class="math">\\mathcal{G}_{\\text{sign}}</span> in the following ways:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{Z}</span> can interact with <span class="math">\\mathcal{G}_{\\text{sign}}</span> <em>acting as an honest party</em> executing other (possibly rogue) protocols. Since other protocols have different session identifiers, <span class="math">\\mathcal{Z}</span> cannot ask <span class="math">\\mathcal{G}_{\\text{sign}}</span> to sign messages pertaining to the challenge session identifier, which is the protocol instance that we are proving security for.</li>

      <li><span class="math">\\mathcal{Z}</span> can interact with <span class="math">\\mathcal{G}_{\\text{sign}}</span> <em>acting as a corrupt party or <span class="math">\\mathcal{A}</span></em> by routing messages through the adversary <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <p class="text-gray-300">Mapping from public keys to nodes. In addition to defining honest, alert, and corrupt for nodes, it will be convenient later for us to refer to public keys as being honest, alert, or corrupt. This is defined in the most natural manner.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given an execution trace denoted view, a public key pk is said to be honest (or alert resp.) at time $t\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> in view, if some tuple of the form </span>(\\mathcal{P},\\textsf{pk},\\_)\\in\\mathcal{G}_{\\text{sign}}.\\Gamma<span class="math"> at time </span>t<span class="math"> in view, and further, </span>\\mathcal{P}<span class="math"> is honest (or alert resp.) at time </span>t<span class="math"> in view. If a public key pk is not honest at </span>t<span class="math">, we say that it is corrupt at </span>t<span class="math">. Note that a corrupt pk may not exist in </span>\\mathcal{G}_{\\text{sign}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">C.2 Format of Real-World Blocks</h3>

    <p class="text-gray-300">We use the notation <em>chain</em> to denote a real-world blockchain. Our protocol also defines an extract function that outputs an ordered list of transactions from a blockchain. A real-world blockchain is a chain of real-world blocks. We now define a valid block and a valid blockchain.</p>

    <p class="text-gray-300">Valid blocks. We say that a tuple</p>

    <p class="text-gray-300"><span class="math">B:=(h_{-1},\\textsf{txs},\\textsf{time},\\textsf{nonce},\\textsf{pk},\\sigma,h)</span></p>

    <p class="text-gray-300">is a valid block iff</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Sigma.\\mathsf{Ver}_{\\mathsf{pk},sid}((\\mathsf{h}_{-1},\\mathsf{txs},\\mathsf{time},\\mathsf{nonce});\\sigma)=1</span> where <span class="math">sid</span> is the session identifier of the proof-of-stake protocol — as mentioned earlier, we use the notation <span class="math">\\mathsf{Ver}_{\\mathsf{pk},sid}</span> to indicate that the message is prefixed with the protocol’s session identifier <span class="math">sid</span>; and</li>

      <li><span class="math">h=\\mathsf{d}(h_{-1},\\mathsf{txs},\\mathsf{time},\\mathsf{nonce},\\mathsf{pk},\\sigma)</span>, where <span class="math">\\mathsf{d}:\\{0,1\\}^{*}\\to\\{0,1\\}^{\\kappa}</span> is a collision-resistant hash function — technically collision resistant hash functions must be defined for a family, but here for simplicity we pretend that the sampling from the family has already been done before protocol start, and therefore <span class="math">\\mathsf{d}</span> is a single function.</li>

    </ol>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">Valid blockchain.</h4>

    <p class="text-gray-300">Let <span class="math">\\mathsf{eligible}^{t}(chain,\\mathsf{pk})</span> be a function that given the current state of <span class="math">chain</span>, determines whether <span class="math">\\mathsf{pk}</span> is elected as a leader in time step <span class="math">t</span>, by making calls to a random oracle <span class="math">\\mathsf{H}</span>. We defer the concrete specification of <span class="math">\\mathsf{eligible}^{t}(chain,\\mathsf{pk})</span> to Figure 4.</p>

    <p class="text-gray-300">Let <span class="math">chain</span> denote an ordered chain of real-world blocks, we say that <span class="math">chain</span> is a valid blockchain w.r.t. <span class="math">\\mathsf{eligible}</span> and time <span class="math">t</span> iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">chain[0]=genesis:=(\\bot,\\bot,\\mathsf{time}=0,\\mathsf{nonce}_{0},\\bot,\\bot,h=\\vec{0})</span> where <span class="math">\\mathsf{nonce}_{0}</span> is a nonce randomly generated prior to protocol start;</li>

      <li><span class="math">chain[-1].\\mathsf{time}\\leq t</span>; and</li>

      <li>for all <span class="math">i\\in[1..\\ell]</span>, the following holds:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">chain[i]</span> is a valid block;</li>

      <li><span class="math">chain[i].h_{-1}=chain[i-1].h</span>;</li>

      <li><span class="math">chain[i].\\mathsf{time}&gt;chain[i-1].\\mathsf{time}</span>, i.e., timestamps are strictly increasing; and</li>

      <li>let <span class="math">t:=chain[i].\\mathsf{time}</span>, <span class="math">\\mathsf{pk}:=chain[i].\\mathsf{pk}</span>, it holds that <span class="math">\\mathsf{eligible}^{t}(chain[:i-1],\\mathsf{pk})=1</span>.</li>

    </ol>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">C.3 Epoch-Based Committee Election</h3>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">Epochs.</h4>

    <p class="text-gray-300">Our protocol proceeds in epochs, where in each epoch, a different committee will be elected and will be eligible to mine blocks. Let <span class="math">T_{\\text{epoch}}</span> be a protocol parameter that denotes the length of each epoch. We define a round-down function</p>

    <p class="text-gray-300"><span class="math">\\mathsf{rnddown}(t):=\\lfloor\\frac{t}{T_{\\text{epoch}}}\\rfloor\\cdot T_{\\text{epoch}}</span></p>

    <p class="text-gray-300">to denote the starting time of the epoch that time <span class="math">t</span> belongs to.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">Per-epoch committee election.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathsf{view}</span> be an execution trace where the current time $t:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Let </span>i<span class="math"> denote a node that is honest at time </span>t<span class="math"> in </span>\\mathsf{view}<span class="math">. Let </span>chain:=chain_{t}^{i}(\\mathsf{view})<span class="math"> be node’s </span>i<span class="math">’s chain at time </span>t<span class="math"> in </span>\\mathsf{view}<span class="math">. At this point of time, node </span>i<span class="math"> will apply an election function to decide the set of public keys eligible in the current time step </span>t<span class="math">. To this end, node </span>i<span class="math"> will examine its local </span>chain<span class="math">, and select a block that is sufficiently far back — the set of public keys contained in the prefix up to this block will be eligible to mine in time </span>t$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We have yet to define what it means to be “sufficiently far back”. To this end, we define a look-back parameter denoted <span class="math">\\omega</span>. An honest node <span class="math">i</span> will select the largest index <span class="math">j</span> such that <span class="math">chain[j].\\mathsf{time}+2\\omega\\leq\\mathsf{rnddown}(t)</span>. Then the public keys extracted by calling <span class="math">\\mathsf{extractpks}(chain[:j])</span> will be the committee for time <span class="math">t</span>. Later, we will choose the parameter <span class="math">\\omega</span> to be reasonably large</p>

    <p class="text-gray-300">(and yet not too long ago) such that all honest nodes will agree on committee at time <span class="math">t</span> with overwhelming probability.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{elect\\_cmt}^{t}(chain):=</span> <span class="math">\\mathsf{extractpks}(chain[:j])</span> where <span class="math">j</span> is the largest index s.t. <span class="math">chain[j].\\mathsf{time}+2\\omega\\leq\\mathsf{rnddown}(t)</span></p>

    <p class="text-gray-300">Per-epoch hash reseeding. Given a set of eligible committee members, a hash function will be applied to choose a leader for each time step. We now define a rule for selecting this hash function. Let <span class="math">\\mathsf{H}</span> denote a globally known hash function modeled as a random oracle. We henceforth use the notation</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{H}^{\\mathsf{nonce}}(x):=\\mathsf{H}(\\mathsf{nonce}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In other words, we elect a hash by choosing a <span class="math">\\mathsf{nonce}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{elect\\_h}^{t}(chain):=chain[j].\\mathsf{nonce}</span> where <span class="math">j</span> is the largest index s.t. <span class="math">chain[j].\\mathsf{time}+\\omega\\leq\\mathsf{rnddown}(t)</span></p>

    <p class="text-gray-300">Later, we will choose an appropriate parameter <span class="math">\\omega</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\omega</span> is reasonably large (and yet not too long ago) such that all honest nodes will agree on the hash function elected at time <span class="math">t</span> with overwhelming probability; and</li>

      <li><span class="math">\\omega</span> is smaller than <span class="math">2\\omega</span> by a reasonable margin, such that the hash will be selected sufficiently long after the committee is determined by the blockchain.</li>

    </ol>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">C.4 Protocol Overview</h3>

    <p class="text-gray-300">We describe our Snow White protocol in Figure 4. The protocol proceeds in epochs whose length is determined by the parameter <span class="math">T_{\\text{epoch}}</span>. At the start of each epoch, the protocol switches to a new committee that can be determined by examining the current state of the blockchain. Further, a new hash is used for each different epoch, and the hash is selected by computing a new nonce from the current state of the blockchain.</p>

    <p class="text-gray-300">Once a committee and a hash is determined for an epoch, we can now describe the “mining” process. Let <span class="math">\\mathsf{pks}_{e}</span> denote the <span class="math">e</span>-th committee. In every time step during the <span class="math">e</span>-th epoch, if a node <span class="math">i</span>is in the <span class="math">e</span>-th committee, it will compute <span class="math">\\mathsf{H}(\\mathsf{pk},t)</span> and if the outcome is smaller than <span class="math">D_{p}</span>, then node <span class="math">i</span> is a leader in time <span class="math">t</span>. In this case, node <span class="math">i</span> will extend its current chain by signing a new block containing the following: 1) the previous block’s hash, 2) a set of transactions to be confirmed, 3) the current time, 4) a freshly generated nonce, and 5) its own public key. The node then announces the new chain to the network.</p>

    <p class="text-gray-300">In each time step, regardless of whether a node is in the present committee, a node receives chains from the network and verify their validity. If a received chain is valid but deviates from a node’s current chain too far in the past, such a chain is not punctual and will be rejected. Nodes always choose the longest chain among all chains it did not reject.</p>

    <p class="text-gray-300">Finally, when a node spawns or wakes up from deep sleep (henceforth referred to as respawning), an initialization procedure is invoked. At this moment, <span class="math">\\mathcal{A}</span> must deliver to the node an initialization message containing a list of chains denoted <span class="math">\\{chain_{i}\\}_{i\\in L}</span> such that the majority of these chains reflect the true state of an alert node at time <span class="math">t-1</span> (see protocol compliance rules defined in Section C.6). If this is the protocol start, this list can simply be the genesis block. As mentioned earlier, this</p>

    <p class="text-gray-300">Protocol  <span class="math">\\Pi_{\\mathrm{snowwhite}}(\\kappa_0,p,\\omega ,T_{\\mathrm{epoch}},\\mathrm{extractpks})</span> On input init() from  <span class="math">\\mathcal{Z}</span>  .. let pk  <span class="math">= = \\mathcal{G}_{\\mathrm{sign}.}</span>  gen(), output pk to  <span class="math">\\mathcal{Z}</span>  , wait to receive  <span class="math">(\\mathsf{pks}_0,\\{chain_i\\}_{i\\in L})</span>  find the longest valid chain that is a prefix of the majority of chains in  <span class="math">\\{chain_i\\}_{i\\in L}</span>  find the longest valid chain  <span class="math">\\in \\{chain_i\\}_{i\\in L}</span>  such that chain  <span class="math">\\prec</span>  chain record chain and pk</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">On receive chain': assert  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">chain^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">chain</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and chain&#x27; is valid w.r.t. the current time t assert chain[:  </span>-\\kappa_0]\\prec<span class="math">  chain&#x27; chain  </span>= =$  chain' and gossip chain</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>output extract(chain) to  <span class="math">\\mathcal{Z}</span>  where extract is the function outputs an ordered list containing the txs extracted from each block in chain</li>

    </ul>

    <p class="text-gray-300">Subroutine eligible <span class="math">^t</span>  (chain, pk) Assume: chain[0].nonce = nonce0, extractpks(chain[: 0]) = pks0 Let elect_cmt <span class="math">^t</span>  (chain) be a function that returns extractpks(chain[: j]) s.t.  <span class="math">j</span>  is the largest index satisfying chain[j].time + 2ω ≤ rnddown(t) Let elect_h <span class="math">^t</span>  (chain) be a function that returns extractnonce(chain[: j]) s.t.  <span class="math">j</span>  is the largest index satisfying chain[j].time + ω ≤ rnddown(t) Let pks<em> := elect_cmt <span class="math">^t</span>  (chain), let nonce</em> := elect_h <span class="math">^t</span>  (chain) Return 1 if H <span class="math">^{\\text{nonce}}</span>  (pk, t) &lt; Dp and pk ∈ pks*; else return 0 extractnonce(chain): output the concatenation of the nonces in all blocks in chain</p>

    <p class="text-gray-300">Figure 4: The Snow White consensus protocol. The difficulty parameter  <span class="math">D_{p}</span>  is set such that a committee member is elected leader with probability  <span class="math">p</span>  in a single time step.  <span class="math">\\mathsf{pks}_0</span>  denotes the initial committee. Chain validity is stated w.r.t. eligible although we omit writing w.r.t. eligible for simplicity.</p>

    <p class="text-gray-300">reflects the fact that a spawning (or respawning) node can contact a list of nodes in the network the majority of whom must be alert. As we argue in Sections 2 and D, this process allows a spawning or respawning node to determine the correct version of history to believe in. Without this additional trust assumption, consensus would have been impossible in the presence of majority posterior corruption. Now the spawning/respawning node computes its state as follows: First, it computes the longest valid <span class="math">chain_{0}</span> that is a prefix of the majority of chains in the list. Next, it finds the longest <span class="math">chain</span> in the list that contains <span class="math">chain_{0}</span>. This <span class="math">chain</span> now becomes the internal state of the spawning/respawning node.</p>

    <p class="text-gray-300">Remark: committee members and non-members. We remark that in each epoch, there are two types of nodes in the system, the current committee members and committee non-members. Although only committee members are contributing blocks, our consistency and liveness guarantees extend to all nodes, including members and non-members.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">C.5 Theorem Statement</h3>

    <p class="text-gray-300">Additional useful notations. Before we state our theorem, we will need to define some additional notations. Recall that <span class="math">p</span> is the probability that a node is elected leader in a given time step. <span class="math">1+\\phi</span> is the minimum ratio of alert nodes over corrupt ones across time. <span class="math">n</span> is the total number of awake nodes at any given time (see also Remark 1). We define a set of intermediate variables <span class="math">\\alpha,\\beta,</span> and <span class="math">\\gamma</span> which are defined as functions of <span class="math">p,n</span>, <span class="math">\\phi</span>, and possibly <span class="math">\\Delta</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\alpha:=1-(1-p)^{\\frac{n(1+\\phi)}{2+\\phi}}</span> be the probability that some alert node is elected leader in one round; and</li>

      <li>Let <span class="math">\\beta:=1-(1-p)^{\\frac{\\alpha}{2+\\phi}}</span> be the probability that some corrupt node is elected leader in one round;</li>

      <li>Let <span class="math">\\gamma:=\\frac{\\alpha}{1+\\Delta\\alpha}</span>. <span class="math">\\gamma</span> is a “discounted” version of <span class="math">\\alpha</span> which takes into account the fact that messages sent by alert nodes can be delayed by <span class="math">\\Delta</span> time steps; <span class="math">\\gamma</span> corresponds to alert nodes’ “effective” proportion among all awake nodes.</li>

    </ol>

    <p class="text-gray-300">Theorem 1. For any constant <span class="math">\\epsilon_{0},\\epsilon&gt;0,</span> any <span class="math">T_{0}\\geq\\epsilon_{0}\\kappa</span>, <span class="math">\\Pi_{\\text{snowwhite}}</span> satisfies <span class="math">(T_{0},g_{0},g_{1})</span>-chain growth, <span class="math">(T_{0},\\mu)</span>-chain quality, and <span class="math">T_{0}</span>-consistency against any <span class="math">\\Pi_{\\text{snowwhite}}</span>-compliant p.p.t. pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, with the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>chain growth lower bound parameter <span class="math">g_{0}=(1-\\epsilon)\\gamma</span>;</li>

      <li>chain growth upper bound parameter <span class="math">g_{1}=(1+\\epsilon)np</span>; and</li>

      <li>chain quality parameter <span class="math">\\mu=(1-\\epsilon)(1-\\frac{\\beta}{\\gamma})</span>;</li>

    </ul>

    <p class="text-gray-300">where <span class="math">\\alpha,\\beta,\\gamma</span> are defined earlier.</p>

    <p class="text-gray-300">The proof of this theorem will be provided in Sections F, G, and H. The theorem requires that the parameters of the scheme, including <span class="math">\\kappa_{0},p,\\omega,</span> and <span class="math">T_{\\text{epoch}}</span>, be set appropriately in relation to the parameters of <span class="math">(\\mathcal{A},\\mathcal{Z})</span>. We describe the parameter constraints and intuitively explain why the constraints are necessary in Section C.6.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Table 1: Notations</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">κ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">security parameter</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">chaini</td>

            <td class="px-3 py-2 border-b border-gray-700">extracted ideal-world chain for node i honest at time t</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">chaini</td>

            <td class="px-3 py-2 border-b border-gray-700">real-world formatted chain for node i honest at time t</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">W</td>

            <td class="px-3 py-2 border-b border-gray-700">posterior corruption window</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">φ</td>

            <td class="px-3 py-2 border-b border-gray-700">φ fraction more must be alert and remain honest for W more steps than those corrupt within W steps</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">τ</td>

            <td class="px-3 py-2 border-b border-gray-700">agility parameter, time till corruption/sleep operations take effect</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">maximum network delay for alert nodes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">maximum duration of a light sleep</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2ω, ω</td>

            <td class="px-3 py-2 border-b border-gray-700">time to look back to decide committee/hash respectively</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">κ0 := κ/2</td>

            <td class="px-3 py-2 border-b border-gray-700">incoming chain must agree with all but the last κ0 blocks</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">probability that a node gets elected leader in any time step</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Tepoch</td>

            <td class="px-3 py-2 border-b border-gray-700">length of an epoch</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now articulate a set of constraints that  <span class="math">(\\mathcal{A},\\mathcal{Z})</span>  must respect for our protocol to guarantee security. For convenience, we summarize our notations and parameters in Table 1.</p>

    <p class="text-gray-300">Admissible parameters. Without loss of generality due to rescaling of  <span class="math">\\kappa</span> , we shall henceforth assume that</p>

    <div class="my-4 text-center"><span class="math-block">\\kappa_ {0} = \\frac {\\kappa}{2}</span></div>

    <p class="text-gray-300">We say that the parameters  <span class="math">(p, \\kappa_0, T_{\\mathrm{epoch}}, \\omega; n, \\phi, \\Delta, \\tau, \\widetilde{\\Delta}, W)</span>  are  <span class="math">\\Pi_{\\mathrm{snowwhite}}</span> -admissible iff the following constraints hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">np\\Delta &amp;lt; 1</span>  and moreover, there exists a constant  <span class="math">\\psi &amp;gt; 0</span>  such that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">(1 - 2 \\alpha (\\Delta + 1)) \\alpha &amp;gt; (1 + \\psi) \\beta</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">W &amp;gt; \\omega \\geq \\frac{2\\kappa}{\\gamma} + \\widetilde{\\Delta}</span> ;</li>

      <li><span class="math">T_{\\mathrm{epoch}} \\geq 3\\omega</span></li>

      <li><span class="math">\\tau &amp;gt; W + T_{\\mathrm{epoch}} + 2\\omega</span></li>

    </ul>

    <p class="text-gray-300">Intuitions for admissible parameters. We now given an intuitive explanation for these parameters. All these intuitions will later arise as technicalities in our proof.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, the requirement  <span class="math">(1 - 2\\alpha (\\Delta + 1))\\alpha &amp;gt; (1 + \\psi)\\beta</span>  roughly says that the alert committee members that remain honest till the near future, even when discounted by a parameter related to the network delay, must outnumber the committee members that are corrupt or to become corrupt in the near future — where “near future” is characterized by the posterior corruption window  <span class="math">W</span> . Specifically, the discount factor  <span class="math">(1 - 2\\alpha (\\Delta + 1))</span>  arises due to technicalities that arise in the consistency proof.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Second, the look-back parameters <span class="math">2\\omega</span> and <span class="math">\\omega</span> must be reasonably large, such that</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prefix of the chain that is used to decide the next epoch’s committee and hash has stabilized, such that all nodes will agree on the next epoch’s committee and hash;</li>

      <li>The two look-back parameters are spaced out far enough such that when the committee is determined, the adversary cannot predict the nonce that determines the next hash; and</li>

      <li>Further, the parameters <span class="math">\\omega</span> and <span class="math">2\\omega</span> are related to the light sleep bound <span class="math">\\widetilde{\\Delta}</span> and the punctuality parameter <span class="math">\\kappa_{0}=\\frac{\\kappa}{2}</span>, ensuring that even when a light sleeper wakes up, it suffices to use its old chain (before going to sleep) with the last <span class="math">\\kappa_{0}</span> blocks removed — henceforth denoted <span class="math">chain^{s}[:-\\kappa_{0}]</span> where <span class="math">s</span> is the time the node last went to sleep — to decide the next committee and hash. Specifically, this requires that <span class="math">chain^{s}[:-\\kappa_{0}]</span> must have a block with a recent enough timestamp relative to <span class="math">\\omega</span> and <span class="math">2\\omega</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Next, nodes reject blocks that modify <span class="math">\\kappa_{0}</span> blocks back into their past, and for light sleepers this is adjusted by another <span class="math">\\widetilde{\\Delta}</span> parameter — therefore the posterior corruption window <span class="math">W</span> has to be reasonably large to be commensurate with these two parameters.</li>

      <li>Next, the epoch length <span class="math">T_{\\text{epoch}}</span> has to be reasonably large, since as we mention in Section 2.2 and Section G.1, once a random oracle is chosen, it must be used sufficiently many times to prove security. Also in our current parameterization, we do not treat the first epoch specially, so <span class="math">T_{\\text{epoch}}</span> must also be large enough for the protocol to warm up — roughly speaking, the blockchain must be at least <span class="math">2\\omega</span> time long for a committee (that is not the initial committee) to be determined.</li>

      <li>Finally, the agility parameter <span class="math">\\tau</span>, which stipulates how long it takes for corrupt and sleep instructions to take effect, must be reasonably large to eliminate possible “adaptive” corruption behaviors, where the adversary first sees the next committee and hash, and then decides who to corrupt or make sleep. If <span class="math">\\tau</span> is sufficiently large, such an attack will not succeed. Specifically, if an adversary attempts to corrupt a node (or make it sleep) after seeing the next hash, then when the corrupt or sleep instruction takes effect, it will already be well after this epoch for such “adaptivity” to be effective, where the notion of “well after” is related to the posterior corruption parameter <span class="math">W</span>. Roughly speaking, from the time the adversary sees the next hash till “well after” the next epoch takes a total of <span class="math">W+T_{\\text{epoch}}+c\\cdot\\omega</span> time; therefore, the requirement that <span class="math">\\tau&gt;W+T_{\\text{epoch}}+2\\omega</span> is easy to understand.</li>

    </ul>

    <p class="text-gray-300">Compliant executions. We say that the pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is <span class="math">\\Pi_{\\text{snowwhite}}</span>-compliant if the following holds for any view with non-zero support:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialization. At the start of the execution, the following happens. First, <span class="math">\\mathcal{Z}</span> can spawn a set of either honest or corrupt nodes. <span class="math">\\mathcal{Z}</span> learns the honest nodes’ public keys after calling their init() procedure. Next, <span class="math">\\mathcal{Z}</span> provides the inputs (<span class="math">\\texttt{pks}_{0}</span>, <span class="math">\\{</span>genesis<span class="math">\\}</span>) to all honest nodes.</li>

    </ul>

    <p class="text-gray-300">At this point, protocol execution starts. <span class="math">\\mathcal{A}</span> is not allowed to query the random oracle <span class="math">\\mathsf{H}</span> prior to protocol start.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\tau</span>-agility. Whenever <span class="math">\\mathcal{A}</span> issues a <span class="math">(\\texttt{corrupt},t)</span> or a <span class="math">(\\texttt{sleep},t,t^{\\prime})</span> instruction at time <span class="math">r</span>, it must hold that <span class="math">t-r\\geq\\tau</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sleeping. If a sleeper wakes up within <span class="math">\\widetilde{\\Delta}</span> time since it last went to sleep, it is considered a light sleeper. Otherwise, if it sleeps for more than <span class="math">\\widetilde{\\Delta}</span> time before waking up it is considered a deep sleeper and must reinitialize as if it is re-spawning (see below).</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Spawning. When a new node spawns or a deep sleeper wakes up, <span class="math">(\\mathcal{A},\\mathcal{Z})</span> must deliver the same <span class="math">\\mathsf{pks}_0</span> to this node, and further <span class="math">(\\mathcal{A},\\mathcal{Z})</span> must deliver to this node a message <span class="math">\\{chain_i^{t-1}\\}_{i\\in L}</span> that contains the internal chains of a set of nodes (denoted <span class="math">L</span>) the majority of whom are alert at <span class="math">t-1</span>. If a node <span class="math">i\\in L</span> is corrupt<span class="math">^5</span>, it can provide an arbitrarily <span class="math">chain_i^{t-1}</span>.</li>

    </ul>

    <p class="text-gray-300">Intuitively, this captures the requirement that a newly spawning node must be able to connect to a subset of nodes the majority of which are alert.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Resilience. Let $t \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and let </span>i<span class="math"> be a node that is honest at time </span>t<span class="math"> in view. Let </span>chain_i^t(\\text{view})<span class="math"> denote node </span>i<span class="math">&#x27;s protocol internal state at time </span>t$ in view, and define</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{cmt}_i^t(\\text{view}) := \\operatorname{elect\\_cmt}^t(chain_i^t(\\text{view}))</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We require that for every $t \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, for every honest node </span>i<span class="math"> that is honest at </span>t<span class="math"> in view, let </span>r = \\min(t + W,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\frac{\\operatorname{alert}^t(\\operatorname{cmt}_i^t(\\text{view}), \\text{view}) \\cap \\operatorname{honest}^r(\\operatorname{cmt}_i^t(\\text{view}), \\text{view})}{\\operatorname{corrupt}^r(\\operatorname{cmt}_i^t(\\text{view}), \\text{view})} \\geq 1 + \\phi \\tag{2}</span></div>

    <p class="text-gray-300">where <span class="math">\\text{alert}^t</span>, <span class="math">\\text{honest}^r</span>, <span class="math">\\text{corrupt}^r</span> are defined as below:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{alert}^t(S, \\text{view})</span> outputs those in <span class="math">S</span> that are alert at time <span class="math">t</span> in view.</li>

      <li><span class="math">\\text{honest}^r(S, \\text{view})</span> outputs those in <span class="math">S</span> that are honest at time <span class="math">r</span>.</li>

      <li><span class="math">\\text{corrupt}^r(S, \\text{view})</span> outputs those in <span class="math">S</span> that are corrupt at time <span class="math">r</span>.</li>

    </ul>

    <p class="text-gray-300">Informally, we require that among committee of time <span class="math">t</span> (as perceived by any node honest at time <span class="math">t</span>), more are alert at time <span class="math">t</span> and remain honest till <span class="math">r</span> (but possibly can go to sleep), than those corrupt at time <span class="math">r</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Number of awake nodes. For every honest node <span class="math">i</span> that is honest at time <span class="math">t</span> in view, let $r = \\min(t + W,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, we have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">(\\text{alert}^t(\\operatorname{cmt}_i^t(\\text{view}), \\text{view}) \\cap \\operatorname{honest}^r(\\operatorname{cmt}_i^t(\\text{view}), \\text{view})) + \\operatorname{corrupt}^r(\\operatorname{cmt}_i^t(\\text{view}), \\text{view}) = n</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Admissible parameters. The parameters <span class="math">(p, \\kappa_0, T_{\\mathrm{epoch}}, \\omega; n, \\phi, \\Delta, \\tau, \\widetilde{\\Delta}, W)</span> are <span class="math">\\Pi_{\\mathrm{snowwhite}}</span>-admissible, where <span class="math">p, \\kappa_0, T_{\\mathrm{epoch}}, \\omega</span> are input parameters to the <span class="math">\\Pi_{\\mathrm{snowwhite}}</span> protocol, and <span class="math">(n, \\phi, \\Delta, \\tau, \\widetilde{\\Delta}, W)</span> are parameters related to <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>.</li>

    </ul>

    <p class="text-gray-300">35</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Remark 1 (Clarifications on <span class="math">n</span> and difficulty parameter).</h6>

    <p class="text-gray-300">For notational simplicity, our analysis assumes that (imprecisely speaking) the number of awake nodes is <span class="math">n</span> throughout. We assume that some upper bound on <span class="math">n</span> is a-priori known so we can choose the protocol’s difficult parameter <span class="math">D_{p}</span> to satisfy the complicance rules — note that if the upper bound on <span class="math">n</span> is loose, then the expected block interval will be proportionally larger and thus transaction confirmation is slower (but all of our proofs still hold).</p>

    <p class="text-gray-300">It is not difficult to see that our analysis holds not only for fixed <span class="math">n</span>, the requirement we actually rely on is for the expected block interval (had all awake nodes been honest) to stay fixed throughout. In practice, the protocol is reading the next committee from a stabilized prefix of the blockchain itself, at any time we actually know the total committee size a-priori. Assuming that the fraction of awake nodes (out of each committee) is fixed, we can simply set each committee’s <span class="math">D_{p}</span> such that the expected block interval is fixed. Finally, it is easy to generalize our analysis to further relax the above requirement — we only need that the expected block interval varies by a known constant factor (rather than staying fixed throughout).</p>

    <h2 id="sec-44" class="text-2xl font-bold">Appendix D Lower Bounds</h2>

    <p class="text-gray-300">Recall that in our protocol, when a node first spawns or after a deep sleeper wakes up, the node must perform an initialization procedure where it contacts a list of nodes the majority of whom are alert. We show that this additional trust assumption is necessary if one wishes to tolerate majority posterior corruption.</p>

    <p class="text-gray-300">We state our lower bound for a blockchain protocol, but it is not hard to see that the same lower bound proof holds for any consensus protocol (often referred to as state machine replication in the classical distributed systems literature) as defined by Pass and Shi <em>[47]</em>. Note that Pass and Shi also show that a formal blockchain abstraction implies a classical consensus (i.e., state machine replication) abstraction.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Theorem 2 (Access to a majority honest set for (re)spawning nodes is necessary).</h6>

    <p class="text-gray-300">Assuming common knowledge of the initial committee <span class="math">\\mathsf{cmt}_{0}</span>, and absent any additional trust assumptions, it is impossible to realize a secure blockchain protocol in our execution model if there exists <span class="math">\\frac{1}{\\mathsf{poly}(\\kappa)}</span> fraction of views such that no node ever sleeps, and at some time <span class="math">T</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{corrupt}^{T}(\\mathsf{cmt}_{0},\\mathsf{view})&gt;\\mathsf{alert}^{1}(\\mathsf{cmt}_{0},\\mathsf{view})\\cap\\mathsf{honest}^{T}(\\mathsf{cmt}_{0},\\mathsf{view})</span></p>

    <p class="text-gray-300">The lower bound holds even if at any time, there are more alert present committee members than corrupt ones, even if all corruptions are declared statically upfront, and even if assuming a PKI.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider the following <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathcal{A},\\mathcal{Z})</span> first provides an initial committee <span class="math">\\mathsf{cmt}_{0}</span> consisting of <span class="math">n=2f+1</span> nodes, where <span class="math">f</span> of them are corrupt, and the remaining are alert. Then at time <span class="math">T</span>, one additional node among <span class="math">\\mathsf{cmt}_{0}</span> becomes corrupt — at this moment, <span class="math">f+1</span> among <span class="math">\\mathsf{cmt}_{0}</span> are corrupt, and <span class="math">f</span> are still alert.</li>

      <li><span class="math">(\\mathcal{A},\\mathcal{Z})</span> constructs appropriate transactional inputs such that this will cause the committee to switch completely at some time <span class="math">t^{*}&lt;T</span>, such that the new committee, denoted <span class="math">\\mathsf{cmt}_{1}</span>, does not intersect with <span class="math">\\mathsf{cmt}_{0}</span>. Further, <span class="math">(\\mathcal{A},\\mathcal{Z})</span> makes sure that all nodes in <span class="math">\\mathsf{cmt}_{1}</span> are alert all the time.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At time <span class="math">T</span>, when the majority of <span class="math">\\mathsf{cmt}_{0}</span> become corrupt, <span class="math">(\\mathcal{A},\\mathcal{Z})</span> creates a simulated execution in its head with the <span class="math">f+1</span> corrupt <span class="math">\\mathsf{cmt}_{0}</span> members that he has: in the simulated execution, a different set of transactions are provided to the initial committee <span class="math">\\mathsf{cmt}_{0}</span>, such that at time <span class="math">t^{*}</span> the simulated execution switches to a new committee <span class="math">\\mathsf{cmt}_{1}^{\\prime}</span> consisting only of corrupt nodes. In this way, <span class="math">(\\mathcal{A},\\mathcal{Z})</span> can continue with the simulation after the committee switch. Further, <span class="math">S_{1}^{\\prime}</span> also does not intersect with <span class="math">\\mathsf{cmt}_{0}</span> just like the real execution.</li>

      <li><span class="math">(\\mathcal{A},\\mathcal{Z})</span> spawns a new alert node <span class="math">i</span> after time <span class="math">T</span>, and delivers messages from both the simulated and the real executions to node <span class="math">i</span>.</li>

    </ul>

    <p class="text-gray-300">Since the simulated execution and the real one are identically distributed, the newly joining node <span class="math">i</span> cannot output the correct log with probability more than <span class="math">\\frac{1}{2}</span>. ∎</p>

    <p class="text-gray-300">We note that the same lower bound proof holds for a deep sleeper that sleeps for a long time and then wakes up. In other words, if we changed our model to prevent dynamic spawning of nodes, but still allow sleeping, the same lower bound would still hold if majority posterior corruption can happen.</p>

    <h2 id="sec-47" class="text-2xl font-bold">Appendix E Proof Roadmap</h2>

    <p class="text-gray-300">In this section, we give an intuitive overview of the proof roadmap; highlighting key elements of the proof without going into formal details. The full proof is provide in Sections F, G, and H.</p>

    <p class="text-gray-300">We will describe our proof roadmap in a roughly temporal order, but note that the most non-trivial technical steps are the following: 1) how we prove security when rotating hash functions are used and when the adversary can potentially bias the choice of the hash function; 2) how the proof handles posterior corruption; and 3) the simulation proof that the real-world protocol emulates the ideal-world protocol (and particularly, how this proof breaks circularity).</p>

    <p class="text-gray-300">Ideal-world protocol: <span class="math">\\Pi_{\\mathsf{ideal}}</span>. We first consider a simple ideal-world protocol denoted <span class="math">\\Pi_{\\mathrm{ideal}}</span>. In this ideal-world protocol, we consider an ideal mining process where an ideal functionality <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span> performs leader election and keeps track of all valid chains during the course of the protocol execution. We assume that there is no posterior corruption in the ideal world, and slightly imprecisely, for any committee during the entire course of execution, the majority of its members will remain honest (and possibly sleepy) forever.</p>

    <p class="text-gray-300">Such an ideal-world protocol is quite similar to the ideal-world protocol of Sleepy <em>[48]</em> but with a few notable differences. Most notably, our ideal protocol allows the adversary to rotate the consensus committee over time (where as Sleepy’s ideal protocol assumes a fixed committee), as long as for every committee, the majority remains honest forever (imprecisely speaking). We will argue that these changes are inconsequential to the proofs for Sleepy’s ideal protocol; and thus chain growth, chain quality, and consistency hold for our <span class="math">\\Pi_{\\mathrm{ideal}}</span>.</p>

    <p class="text-gray-300">This ideal-world protocol <span class="math">\\Pi_{\\mathrm{ideal}}</span> is rather far removed from the real-world execution; and thus in the remainder of the proof, we will need to gradually augment the protocol to more and more closely capture the real-world execution. In each step, we will need to argue that the augmentation, roughly speaking, preserves the properties we desire, including chain growth, chain quality, and consistency.</p>

    <p class="text-gray-300">Handling adversarially biased hashes: <span class="math">\\Pi_{\\mathsf{bias}}</span>. Our next step is to augment the ideal-world protocol to capture the rotating hashes that happens in the real-world protocol <span class="math">\\Pi_{\\mathrm{snowwhite}}</span>. Notice that in the real-world protocol, there is a new hash function for each epoch (as determined by a</p>

    <p class="text-gray-300">nonce that seeds the random oracle). More importantly, the adversary can bias the choice of the new hash function.</p>

    <p class="text-gray-300">We therefore consider a hybrid protocol called <span class="math">\\Pi_{\\text{bias}}</span>. <span class="math">\\Pi_{\\text{bias}}</span> is similarly defined as <span class="math">\\Pi_{\\text{ideal}}</span>, except that now the new ideal functionality <span class="math">\\mathcal{F}_{\\text{bias}}</span> would allow the adversary to influence the choice of the hash function by allowing the adversary to pick a nonce that seeds the random oracle. Further, this nonce must be chosen after the adversary chooses the public keys of the next consensus committee to avoid an adpative key selection attack.</p>

    <p class="text-gray-300">In our proof, we will argue that as long as each hash function is used for sufficiently long and to elect at least <span class="math">\\Omega(\\kappa)</span> leaders where <span class="math">\\kappa</span> is the security parameter, despite the adversary’s influence over the choice of the hash function, it cannot increase the probability of bad events by more than a polynomial amount. To formalize this intuition turns out to be somewhat subtle, and requires us to open up the stochastic analysis of the ideal protocol <span class="math">\\Pi_{\\text{ideal}}</span> in a somewhat non-blackbox manner. Specifically, <span class="math">\\Pi_{\\text{ideal}}</span>’s stochastic analysis for chain growth, chain quality, and consistency works for any long enough window. Unfortunately, we cannot adopt the same strategy in the proof of <span class="math">\\Pi_{\\text{bias}}</span>. Instead, we constrain our analysis to each medium-sized window consisting of <span class="math">O(1)</span> number of epochs — and we argue that the bad events we care about during a medium-sized window depends on only <span class="math">O(1)</span> number of hashes. When this is true, we can apply a union bound with polynomial security loss to argue that no bad event will happen over any medium-sized window except with negligible probability — note that when the window is too long, such a union bound would cease to work since the security loss can be exponential in the number of hashes the bad event depends on. On the other hand, if the window is too short, it would not be enough to attain a negligible failure probability. This explains why the window must be medium-sized.</p>

    <p class="text-gray-300">Finally, we argue that if chain growth, chain quality, and consistency hold for every medium-sized window, these properties hold for any window (as long as the window is not too small).</p>

    <p class="text-gray-300">Handling posterior corruption: <span class="math">\\Pi_{\\text{punctual}}</span>. So far, our proof has focused on an ideal or hybrid execution where we assumed that no posterior corruption takes place. To handle posterior corruption, we introduce yet another intermediate hybrid protocol called <span class="math">\\Pi_{\\text{punctual}}</span>. <span class="math">\\Pi_{\\text{punctual}}</span> is very similar to <span class="math">\\Pi_{\\text{bias}}</span>; however, the new ideal functionality denoted <span class="math">\\mathcal{F}_{\\text{punctual}}</span> would simply reject any chain that arrives too late (i.e., <span class="math">\\mathcal{F}_{\\text{punctual}}</span> enforces punctuality).</p>

    <p class="text-gray-300">Specifically, <span class="math">\\mathcal{F}_{\\text{punctual}}</span> would reject a chain if the suffix of the chain that has not been observed before has a timestamp that is too far back in the past. To argue that this modification does not affect our desired security properties, we first argue that our earlier <span class="math">\\Pi_{\\text{bias}}</span> protocol satisfies a “no long block withholding” lemma: honest nodes in <span class="math">\\Pi_{\\text{bias}}</span> will never accept a new chain that arrived too late, i.e., if the suffix of the chain that has not been observed before has a timestamp too far back in the past. Therefore, if there were no posterior corruption, then making this modification to our ideal functionality would not have mattered to security.</p>

    <p class="text-gray-300">Next, we argue that with this new ideal functionality <span class="math">\\mathcal{F}_{\\text{punctual}}</span> that rejects blocks that arrive too late, then we can actually prove the desired properties under a stronger adversarial model that allows posterior corruption! This is achieved through a somewhat involved simulation proof where we construct a simulator that does not have to rely on the ability to perform posterior corruption to simulate any attack that relies on corrupting committees in the past.</p>

    <p class="text-gray-300">Hybrid protocol with real-world block format: <span class="math">\\Pi_{\\text{hyb}}</span>. For technical reasons that are somewhat tedious but necessary, before we conduct a simulation proof, we have to introduce a hybrid protocol <span class="math">\\Pi_{\\text{hyb}}</span> that is almost the same as <span class="math">\\Pi_{\\text{punctual}}</span>, but in <span class="math">\\Pi_{\\text{hyb}}</span> we use the real-world block format. We defer the reader to the full proof for details of this hybrid step.</p>

    <h5 id="sec-48" class="text-base font-semibold mt-4">Real-world protocol emulates <span class="math">\\Pi_{\\text{hyb}}</span>.</h5>

    <p class="text-gray-300">Finally, in a rather sophisticated simulation proof, we will show that 1) the real-world protocol <span class="math">\\Pi_{\\text{snowwhite}}</span> emulates the hybrid protocol <span class="math">\\Pi_{\\text{hyb}}</span>; and 2) if the real-world <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects the constraints expected by <span class="math">\\Pi_{\\text{snowwhite}}</span>, then <span class="math">(\\mathcal{S}^{\\mathcal{A}},\\,\\mathcal{Z})</span> respects the constraints expected by <span class="math">\\Pi_{\\text{hyb}}</span> where <span class="math">\\mathcal{S}^{\\mathcal{A}}</span> denotes the the simulator.</p>

    <p class="text-gray-300">This proof is somewhat tricky because it would seem at first sight that there is a circularity: in order to reason that <span class="math">(\\mathcal{S}^{\\mathcal{A}},\\,\\mathcal{Z})</span> respects <span class="math">\\Pi_{\\text{hyb}}</span>’s compliance rules, we would have to rely on that chain growth, chain quality, and/or consistency hold in the simulated execution; but then to obtain those properties in the simulated execution, we would have to rely on the fact that <span class="math">(\\mathcal{S}^{\\mathcal{A}},\\,\\mathcal{Z})</span> respects <span class="math">\\Pi_{\\text{hyb}}</span>’s compliance rules. As an example, our simulator <span class="math">\\mathcal{S}^{\\mathcal{A}}</span> needs to inform the ideal functionality <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span> about the next committee and the nonce to seed the next hash function. In the real-world protocol <span class="math">\\Pi_{\\text{snowwhite}}</span>, the next committee and next nonce are extracted by an early enough prefix of the current blockchain. Therefore, naturally <span class="math">\\mathcal{S}^{\\mathcal{A}}</span> would inform <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span> of the next committee or next hash when it has seen a long enough chain in the real-world execution. We now have to argue that the time at which <span class="math">\\mathcal{S}^{\\mathcal{A}}</span> would chooses the next committee or hash satisfies <span class="math">\\Pi_{\\text{hyb}}</span>’s compliance rules — but to make such an argument, we would have to rely on properties such as chain growth to both upper- and lower-bound the times when such choices are made by <span class="math">\\mathcal{S}^{\\mathcal{A}}</span>.</p>

    <p class="text-gray-300">To break the circularity in the argument, we construct a self-checking simulator: whenever the simulator is about to break <span class="math">\\Pi_{\\text{hyb}}</span>’s compliance rules, it simply aborts. Therefore, as long as the simulation does not abort, we can rely on the desired properties such as chain growth, chain quality, and consistency in our proof. We then argue that as long all of these properties hold till any time <span class="math">t</span>, the simulator’s internal compliance checks are not going to fail at the beginning of the time step <span class="math">t+1</span>.</p>

    <h2 id="sec-49" class="text-2xl font-bold">Appendix F Proofs: Analyzing A Simplified Ideal Protocol</h2>

    <h5 id="sec-50" class="text-base font-semibold mt-4">Proof roadmap.</h5>

    <p class="text-gray-300">Instead of directly analyzing the real-world protocol which is rather complex, we first describe some ideal protocols where nodes interact with each other, and an ideal functionality will act as as a trusted third party and keep track of all legitimate chains. The ideal protocols are much simpler to analyze in comparison with the real-world protocol. Further, the ideal protocols are meant to capture of the essence of the real-world protocol in some way, such that analyzing possible attacks in the ideal protocols will be indicative of the possible attacks in the real-world protocol.</p>

    <p class="text-gray-300">In this section, we start by analyzing a very simple ideal protocol denoted <span class="math">\\Pi_{\\text{ideal}}</span>, and then through a sequence of hybrid steps. In the next section, we gradually augment the ideal protocol such that it becomes increasingly closer to the real-world protocol. At the end of this section, we will arrive at a hybrid protocol called <span class="math">\\Pi_{\\text{hyb}}</span>, which captures ideal-world attack behavior but sends messages that contain real-world formatted chains. Finally, in Section H, we will show that the real-world protocol <span class="math">\\Pi_{\\text{snowwhite}}</span> is as secure as the hybrid protocol <span class="math">\\Pi_{\\text{hyb}}</span>.</p>

    <h3 id="sec-51" class="text-xl font-semibold mt-8">F.1 Simplified Ideal Protocol <span class="math">\\Pi_{\\text{ideal}}</span></h3>

    <p class="text-gray-300">We first define a simplified protocol <span class="math">\\Pi_{\\text{ideal}}</span> parametrized with an ideal functionality <span class="math">\\mathcal{F}_{\\text{tree}}</span> — see Figures 5 and 6. The ideal functionality <span class="math">\\mathcal{F}_{\\text{tree}}</span> allows the adversary <span class="math">\\mathcal{A}</span> to choose the committee for every time step separately, specifically, by calling <span class="math">\\mathcal{F}_{\\text{tree}}.\\texttt{setpids}(t,\\texttt{pids}_{t})</span>. <span class="math">\\mathcal{F}_{\\text{tree}}</span> flips random coins to decide whether a committee member is the elected leader for every time step. Once the <span class="math">\\mathcal{A}</span> commits</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 5: Ideal functionality  <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span> . The ideal functionality allows  <span class="math">\\mathcal{A}</span>  to choose a committee on a time-based granularity.  <span class="math">\\mathcal{A}</span>  is not able to query the leader entry point for time  <span class="math">t</span>  until it has chosen a committee for time  <span class="math">t</span> .</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Figure 6: Ideal protocol  <span class="math">\\Pi_{\\mathrm{ideal}}</span></p>

    <p class="text-gray-300">to a committee for a specific time step <span class="math">t</span>, it is now allowed to query a function called <span class="math">\\mathcal{F}_{\\text{tree}.}\\texttt{leader}</span> that tells <span class="math">\\mathcal{A}</span> which committee member is elected as the leader in time <span class="math">t</span> (if any at all). However, <span class="math">\\mathcal{A}</span> cannot query <span class="math">\\mathcal{F}_{\\text{tree}.}\\texttt{leader}(.,t)</span> for time <span class="math">t</span> function before committing to the <span class="math">t</span>-th committee (since otherwise <span class="math">\\mathcal{A}</span> could adaptively choose a committee such that honest nodes never get elected as leaders). Further, we require that the adversary <span class="math">\\mathcal{A}</span> follow a somewhat static corruption model: once it chooses a node <span class="math">i</span> as a member of any committee, it is not allowed to corrupt node <span class="math">i</span> any more — since otherwise <span class="math">\\mathcal{A}</span> could simply query <span class="math">\\mathcal{F}_{\\text{tree}.}\\texttt{leader}</span> and adaptively corrupt those that have been elected as leaders. Finally, alert and corrupt nodes can call <span class="math">\\mathcal{F}_{\\text{tree}.}\\texttt{extend}</span> to extend known chains with new blocks if they are the elected leader for a specific time step. <span class="math">\\mathcal{F}_{\\text{tree}}</span> keeps track of all valid chains, such that alert nodes will call <span class="math">\\mathcal{F}_{\\text{tree}.}\\texttt{verify}</span> to decide if any chain they receive is valid. Alert nodes always store the longest valid chains they have received, and try to extend it.</p>

    <p class="text-gray-300">Given some view sampled from <span class="math">\\texttt{EXEC}^{\\Pi_{\\text{ideal}}}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, we say that a <span class="math">\\texttt{chain}\\in\\mathcal{F}_{\\text{tree}}(\\texttt{view}).\\texttt{tree}</span> has an <span class="math">\\mathcal{F}_{\\text{tree}}</span>-timestamp of <span class="math">t</span> if <span class="math">\\mathcal{F}_{\\text{tree}}(\\texttt{view}).\\texttt{time}(\\texttt{chain})=t</span>.</p>

    <p class="text-gray-300">Compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span>. A compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair for protocol <span class="math">\\Pi_{\\text{ideal}}</span> is defined as a pair of p.p.t. algorithms such that every view of non-zero support satisfies the following constraints:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sleeping. No matter how long a node sleeps till it wakes up, it is treated as a light sleeper (as long as the node has not become corrupt during its sleep).</li>

      <li>Spawning. When a new, alert node spawns at time <span class="math">t</span>, <span class="math">(\\mathcal{A},\\mathcal{Z})</span> must deliver to it an initialization message <span class="math">\\texttt{chain}_{0}</span> such that <span class="math">\\texttt{chain}_{0}\\in\\mathcal{F}_{\\text{tree}}</span> and <span class="math">\\texttt{chain}_{0}</span> is no shorter than the shortest chain of any alert node at time <span class="math">t-1</span>. If this is the protocol start, then <span class="math">\\texttt{chain}_{0}</span> is simply genesis. All spawned nodes must have distinct party identifiers.</li>

      <li>A-priori commitment of future committee. <span class="math">\\mathcal{A}</span> must have called <span class="math">\\mathcal{F}_{\\text{tree}.}\\texttt{setpids}(t,\\texttt{pids}_{t})</span> before <span class="math">t</span>. In other words, <span class="math">\\mathcal{A}</span> must choose the committee <span class="math">\\texttt{pids}_{t}</span> before time <span class="math">t</span>.</li>

      <li>Epoch-wise somewhat static corruption. Instead of delayed corruption/sleep, we consider a more permissive but easier to analyze corruption model. Roughly speaking, we require that <span class="math">\\mathcal{A}</span> cannot adaptively corrupt a node after examining whether it is elected a leader in any time step. Further, <span class="math">\\mathcal{A}</span> cannot adaptively make a node sleep for the duration <span class="math">[t_{0},t_{1}]</span> after observing whether the node is elected leader during <span class="math">[t_{0},t_{1}]</span>. We formalize this intuition below.</li>

    </ul>

    <p class="text-gray-300">At any time <span class="math">t\\leq t^{\\prime}</span>, <span class="math">\\mathcal{A}</span> is allowed to issue <span class="math">(\\texttt{corrupt},i,t^{\\prime})</span> iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> has not called <span class="math">\\mathcal{F}_{\\text{tree}.}\\texttt{setpids}(r,\\texttt{pids}_{r})</span> for any <span class="math">r</span> such that <span class="math">i\\in\\texttt{pids}_{r}</span>;</li>

    </ul>

    <p class="text-gray-300">At time <span class="math">t\\leq t_{0}\\leq t_{1}</span>, <span class="math">\\mathcal{A}</span> is allowed to issue <span class="math">(\\texttt{sleep},i,t_{0},t_{1})</span> iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for every <span class="math">r\\in[t_{0},t_{1}]</span>, <span class="math">\\mathcal{A}</span> has not called <span class="math">\\mathcal{F}_{\\text{tree}.}\\texttt{setpids}(r,\\texttt{pids}_{r})</span> such that <span class="math">i\\in\\texttt{pids}_{r}</span>.</li>

    </ul>

    <p class="text-gray-300">In other words, after a node <span class="math">i</span> has been selected for any committee, <span class="math">\\mathcal{A}</span> can no longer corrupt it — this also means that if a node is honest when it is chosen into the committee, it will remain honest forever. Further, before choosing the <span class="math">e</span>-th committee, <span class="math">\\mathcal{A}</span> must commit to which nodes will be asleep and exactly when during epoch <span class="math">e</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Resilience. At any time step <span class="math">t</span>, let <span class="math">\\texttt{cmt}^{t}(\\texttt{view})</span> be the <span class="math">(t,\\texttt{pids}_{t})</span> committee set that <span class="math">\\mathcal{A}</span> sends to <span class="math">\\mathcal{F}_{\\text{tree}}</span> in view. It must hold that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\frac{\\texttt{alert}^{t}(\\texttt{cmt}^{t}(\\texttt{view}),\\texttt{view})\\cap\\texttt{honest}(\\texttt{cmt}^{t}(\\texttt{view}),\\texttt{view})}{\\texttt{corrupt}(\\texttt{cmt}^{t}(\\texttt{view}),\\texttt{view})}\\geq 1+\\phi</span></p>

    <p class="text-gray-300"><span class="math">=(\\mathbf{a}\\mathbf{l}\\mathbf{r}\\mathbf{t}^{t}(S,\\mathbf{v}\\mathbf{i}\\mathbf{e}\\mathbf{w}))</span> denotes those among <span class="math">S</span> are alert at time <span class="math">t</span>; <span class="math">\\mathsf{honest}(S,\\mathsf{v}\\mathbf{i}\\mathbf{e}\\mathbf{w})</span> denotes those among <span class="math">S</span> remain honest forever; and and <span class="math">\\mathsf{corrupt}(S,\\mathsf{v}\\mathbf{i}\\mathbf{e}\\mathbf{w})</span> denotes those among <span class="math">S</span> are ever corrupt in <span class="math">\\mathsf{v}\\mathbf{i}\\mathbf{e}\\mathbf{w}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Number of awake nodes. Let <span class="math">\\mathsf{cmt}^{t}(\\mathsf{v}\\mathbf{i}\\mathbf{e}\\mathbf{w})</span> be the <span class="math">(t,\\mathsf{p}\\mathsf{i}\\mathsf{d}\\mathsf{s}_{t})</span> committee set that <span class="math">\\mathcal{A}</span> sends to <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span> in <span class="math">\\mathsf{v}\\mathbf{i}\\mathbf{e}\\mathbf{w}</span>. It must hold that for every $t\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{v}\\mathbf{i}\\mathbf{e}\\mathbf{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">(\\mathsf{alert}^{t}(\\mathsf{cmt}^{t}(\\mathsf{v}\\mathbf{i}\\mathbf{e}\\mathbf{w}),\\mathsf{v}\\mathbf{i}\\mathbf{e}\\mathbf{w})\\cap\\mathsf{honest}(\\mathsf{cmt}^{t}(\\mathsf{v}\\mathbf{i}\\mathbf{e}\\mathbf{w}),\\mathsf{v}\\mathbf{i}\\mathbf{e}\\mathbf{w}))+\\mathsf{corrupt}(\\mathsf{cmt}^{t}(\\mathsf{v}\\mathbf{i}\\mathbf{e}\\mathbf{w}),\\mathsf{v}\\mathbf{i}\\mathbf{e}\\mathbf{w})=n</span></p>

    <p class="text-gray-300">In other words, at every time step <span class="math">t</span>, the number of alert committee members and the number of corrupt committee members must sum up to <span class="math">n</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Admissible parameters. The parameters <span class="math">(p,n,\\phi,\\Delta)</span> satisfy the following constraints: <span class="math">np\\Delta&lt;1</span> and moreover, there exists a constant <span class="math">\\psi&gt;0</span> such that</li>

    </ul>

    <p class="text-gray-300"><span class="math">(1-2\\alpha(\\Delta+1))\\alpha&gt;(1+\\psi)\\beta</span></p>

    <p class="text-gray-300">where <span class="math">\\alpha</span> and <span class="math">\\beta</span> are derived variables whose definitions were presented in Section C.5.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Theorem 3 (Security of <span class="math">\\Pi_{\\mathrm{ideal}}</span>).</h6>

    <p class="text-gray-300">For any constant <span class="math">\\epsilon_{0},\\epsilon&gt;0</span>, any <span class="math">T_{0}\\geq\\epsilon_{0}\\kappa</span>, <span class="math">\\Pi_{\\mathrm{snowwhite}}</span> satisfies <span class="math">(T_{0},g_{0},g_{1})</span>-chain growth, <span class="math">(T_{0},\\mu)</span>-chain quality, and <span class="math">T_{0}</span> consistency against any <span class="math">\\Pi_{\\mathrm{ideal}}</span>-compliant p.p.t. pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, with the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>chain growth lower bound parameter <span class="math">g_{0}=(1-\\epsilon)\\gamma</span>;</li>

      <li>chain growth upper bound parameter <span class="math">g_{1}=(1+\\epsilon)np</span>; and</li>

      <li>chain quality parameter <span class="math">\\mu=(1-\\epsilon)(1-\\frac{\\beta}{\\gamma})</span>;</li>

    </ul>

    <p class="text-gray-300">where <span class="math">\\alpha,\\beta,\\gamma</span> are defined as in Section C.5.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Although our ideal protocol <span class="math">\\Pi_{\\mathrm{ideal}}</span> is different from the ideal protocol for Sleepy <em>[48]</em>, we stress that the differences are inconsequential to the induced stochastic process. We claim that the proof follows in the same manner as that of Sleepy <em>[48]</em>, by pointing out the differences between our ideal protocol and that of Sleepy <em>[48]</em>.</p>

    <p class="text-gray-300">Recall that Sleepy <em>[48]</em> defines an ideal protocol where they assume that there is a fixed committee known upfront. All nodes are spawned upfront, and all corrupt and sleep instructions are declared upfront. Our <span class="math">\\Pi_{\\mathrm{ideal}}</span> is more fine-grained: First, each time step can have a different committee. Second, nodes can get spawned dynamically, and corrupt and sleep instructions need not be declared at the time of spawning. However, it is important to observe that the compliance rule for our <span class="math">\\Pi_{\\mathrm{ideal}}</span> basically stipulates that from the perspective of every committee: 1) if the adversary wants a committee member to ever be corrupt, he must commit to this decision before seeing random coins that decide if the committee member gets elected as leader; and 2) if the adversary wants a committee member at <span class="math">t</span> to be asleep at <span class="math">t</span>, he also must commit to this decision before seeing the random coins that decide if this committee member is elected leader at <span class="math">t</span>. ∎</p>

    <p class="text-gray-300">G Proofs: Intermediate Hybrid Protocols</p>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">G.1 Ideal Protocol with Adversarially Biased Hashes</h3>

    <p class="text-gray-300">We now consider a hybrid protocol denoted <span class="math">\\Pi_{\\text{bias}}</span> that effectively allows the adversary to bias the hash functions. The definition of <span class="math">\\Pi_{\\text{bias}}</span> is almost identical to <span class="math">\\Pi_{\\text{ideal}}</span>, except that all honest nodes’ interactions with <span class="math">\\mathcal{F}_{\\text{tree}}</span> are now replaced with <span class="math">\\mathcal{F}_{\\text{bias}}</span>.</p>

    <p class="text-gray-300">Compliant executions. A compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair for <span class="math">\\Pi_{\\text{bias}}</span> is defined in almost the same way as a compliant environment for <span class="math">\\Pi_{\\text{ideal}}</span>, except now we additionally require that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> must have <span class="math">\\mathcal{F}_{\\text{bias}.}\\texttt{sethash}(e,\\texttt{nonce}_{e})</span> before epoch <span class="math">e</span> starts. In other words, <span class="math">\\mathcal{A}</span> must choose the next hash function before the next epoch begins.</li>

      <li>We additionally require that <span class="math">T_{\\text{epoch}}\\geq\\frac{\\kappa}{\\gamma}</span>.</li>

    </ul>

    <p class="text-gray-300">A useful lemma. Henceforth we will sometimes use the terminology “hash for an epoch” to refer to the randomness used by <span class="math">\\mathcal{F}_{\\text{bias}}</span> (or <span class="math">\\mathcal{F}_{\\text{tree}}</span>) for the epoch. Recall that the only difference between <span class="math">\\Pi_{\\text{bias}}</span> and <span class="math">\\Pi_{\\text{ideal}}</span> is that in <span class="math">\\Pi_{\\text{bias}}</span>, when <span class="math">\\mathcal{F}_{\\text{bias}}</span> picks the hash for an epoch, the adversary is allowed to look at polynomially many choices for each epoch’s hashes, and then instruct <span class="math">\\mathcal{F}_{\\text{bias}}</span> which hash to use. In particular, the adversary can choose the worst-case combination of different epochs’ hashes to maximize its own advantage.</p>

    <p class="text-gray-300">Given a view, we say that <span class="math">\\mathcal{A}</span> looks at <span class="math">q</span> hashes for an epoch in view, if all of its queries to <span class="math">\\mathcal{F}_{\\text{bias}.}\\texttt{leader}</span> for a given epoch has <span class="math">q</span> distinct nonces. Further, let <span class="math">\\texttt{view}\\leftarrow_{\\S}\\texttt{EXEC}^{\\Pi_{\\text{ideal}}}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, and let <span class="math">\\texttt{bad-event}(\\texttt{view})</span> be a random variable defined over view. We now define the same <span class="math">\\texttt{bad-event}(\\texttt{view}^{\\prime})</span> over an execution trace <span class="math">\\texttt{view}^{\\prime}\\leftarrow_{\\S}\\texttt{EXEC}^{\\Pi_{\\text{bias}}}(\\mathcal{A},\\mathcal{Z},\\kappa)</span> in the most natural manner. In particular, <span class="math">\\texttt{view}^{\\prime}</span> can be thought of as a superset of the bits in view. We can define a function <span class="math">\\texttt{compress}(\\texttt{view}^{\\prime})</span> which removes all additional bits that are in <span class="math">\\texttt{view}^{\\prime}</span> but not in view, such as the <span class="math">\\mathcal{F}_{\\text{bias}.}\\texttt{sethash}</span> calls made by <span class="math">\\mathcal{A}</span>; and moreover only the hashes chosen by <span class="math">\\mathcal{A}</span> are preserved in <span class="math">\\texttt{compress}(\\texttt{view}^{\\prime})</span>, the remaining hashes are thrown away in <span class="math">\\texttt{compress}(\\texttt{view}^{\\prime})</span>. In this way we can define <span class="math">\\texttt{bad-event}(\\texttt{view}^{\\prime}):=\\texttt{bad-event}(\\texttt{compress}(\\texttt{view}^{\\prime}))</span>.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Lemma 1 (Union bound over small number of hashes).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\texttt{bad-event}(\\texttt{view})\\in\\{0,1\\}</span> be a random variable that depends only on the randomness for <span class="math">c</span> epochs, i.e., there exists <span class="math">E\\subset\\mathbb{N}</span> where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=c<span class="math">, such that for any </span>\\Pi_{\\text{ideal}}<span class="math">-compliant p.p.t. pair </span>(\\mathcal{A},\\mathcal{Z})<span class="math">, the following holds where </span>\\vec{v}(\\texttt{view})<span class="math"> returns all the randomness </span>\\mathcal{F}_{\\text{tree}}<span class="math"> generated for all epochs in view, and </span>\\upsilon_{e}(\\texttt{view})<span class="math"> denotes the randomness generated by </span>\\mathcal{F}_{\\text{tree}}<span class="math"> corresponding to the </span>e$-th epoch:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\texttt{view}\\leftarrow_{\\S}\\texttt{EXEC}^{\\Pi_{\\text{ideal}}}(\\mathcal{A},\\mathcal{Z},\\kappa):\\texttt{bad-event}(\\texttt{view})=1\\ \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\vec{v}(\\texttt{view})\\right]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We have that any p.p.t. pair <span class="math">\\Pi_{\\text{bias}}</span>-compliant p.p.t. pair <span class="math">(\\mathcal{A}^{\\prime},\\mathcal{Z}^{\\prime})</span> such that <span class="math">\\mathcal{A}^{\\prime}</span> looks at no more than <span class="math">q</span> hashes for each epoch in any <span class="math">\\texttt{view}\\leftarrow\\texttt{EXEC}^{\\Pi_{\\text{bias}}}(\\mathcal{A}^{\\prime},\\mathcal{Z}^{\\prime},\\kappa)</span> of non-zero support, there exists a <span class="math">\\Pi_{\\text{ideal}}</span>-compliant p.p.t. pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, the following holds:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\texttt{view}\\leftarrow_{\\S}\\texttt{EXEC}^{\\Pi_{\\text{bias}}}(\\mathcal{A}^{\\prime},\\mathcal{Z}^{\\prime},\\kappa):\\texttt{bad-event}(\\texttt{view})=1\\right]</span> <span class="math">\\leq</span> <span class="math">\\Pr\\left[\\texttt{view}\\leftarrow_{\\S}\\texttt{EXEC}^{\\Pi_{\\text{ideal}}}(\\mathcal{A},\\mathcal{Z},\\kappa):\\texttt{bad-event}(\\texttt{view})=1\\right]\\cdot q^{c}</span></p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Figure 7: Ideal functionality  <span class="math">\\mathcal{F}_{\\mathrm{bias}}</span> , allowing adversarially biased hash functions.</p>

    <p class="text-gray-300">Proof. By a straightforward union bound. More specifically, for any p.p.t. pair  <span class="math">\\Pi_{\\mathrm{bias}}</span> -compliant p.p.t. pair  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  that attacks  <span class="math">\\Pi_{\\mathrm{bias}}</span> , we can construct a  <span class="math">\\Pi_{\\mathrm{ideal}}</span> -compliant p.p.t. pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  and an execution of  <span class="math">\\Pi_{\\mathrm{ideal}}</span> , where  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is allowed to choose the random bits of  <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span>  for epochs not in  <span class="math">E</span> , i.e., epochs that bad-event does not depend on; however for epochs in  <span class="math">E</span> ,  <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span>  gets to choose the randomness.</p>

    <p class="text-gray-300"><span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  calls  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  as a blackbox. Whenever  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  makes leader queries on a future time step  <span class="math">t</span>  that is not in any of the epochs in  <span class="math">E</span> ,  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  generates the answer at random. Whenever  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  calls sethash for an epoch in  <span class="math">E</span> ,  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  asks  <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span>  to use the same random bits as what  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  has chosen for the corresponding epoch. Whenever  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  makes leader queries on a future time step  <span class="math">t</span>  that is in an epoch in  <span class="math">E</span> , and the query contains a nonce that has not been seen, at this moment,  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  flips a random coin with probability  <span class="math">\\frac{1}{q}</span>  and guesses whether the nonce queried will be chosen by  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span> . If the coin turns up heads,  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  returns answers to  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  consistent with its  <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span> . Otherwise,  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  returns fresh random answers. If the choice later turns out to be</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}^{\\prime}</span>, <span class="math">\\mathcal{Z}^{\\prime}</span>) simply aborts. If eventually <span class="math">(\\mathcal{A}^{\\prime},\\mathcal{Z}^{\\prime})</span> calls sethash for a challenge nonce it has never queried (for an epoch in <span class="math">E</span>), for any future leader query related to this challenge nonce, <span class="math">(\\mathcal{A},\\mathcal{Z})</span> returns answers consistent with its own <span class="math">\\mathcal{F}_{\\text{tree}}</span>. Finally, whatever other actions <span class="math">(\\mathcal{A}^{\\prime},\\mathcal{Z}^{\\prime})</span> outputs, <span class="math">(\\mathcal{A},\\mathcal{Z})</span> replays it in the execution of <span class="math">\\Pi_{\\text{ideal}}</span>. It is not hard to see that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> will not abort with <span class="math">\\frac{1}{q^{e}}</span> probability. If <span class="math">(\\mathcal{A},\\mathcal{Z})</span> does not abort, then bad-event happens in the execution of <span class="math">\\Pi_{\\text{bias}}</span> iff it happens in the execution of <span class="math">\\Pi_{\\text{ideal}}</span>. Due to the definition of conditional independence, the probability of bad-event happening in <span class="math">\\Pi_{\\text{ideal}}</span> does not depend on the randomness of any other epoch not in <span class="math">E</span> (recall that we had <span class="math">(\\mathcal{A},\\mathcal{Z})</span> fix the randomness of <span class="math">\\mathcal{F}_{\\text{tree}}</span> for any epoch not in <span class="math">E</span>). ∎</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Theorem 4 (Security of <span class="math">\\Pi_{\\text{bias}}</span>).</h6>

    <p class="text-gray-300"><span class="math">\\Pi_{\\text{bias}}</span> satisfies <span class="math">T_{0}</span>-consistency, <span class="math">(T_{0},\\mu)</span>-chain quality, and <span class="math">(T_{0},g_{0},g_{1})</span>-chain growth against any <span class="math">\\Pi_{\\text{bias}}</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span> for the same parameters <span class="math">T_{0},\\mu,g_{0},g_{1}</span> as defined in Theorem 3.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We now prove the above Theorem 4. Due to Lemma 1, it suffices to show that every bad event we care about bounding is a subset of the union of <span class="math">\\poly(\\kappa)</span> bad events each of which depends only on a constant number of hashes. Recall that the proof of Theorem 3 essentially follows the proof in the Sleepy paper <em>[48]</em> — as mentioned earlier even though our ideal protocol is different from that of Sleepy <em>[48]</em>, the differences are inconsequential and does not alter the induced stochastic process.</p>

    <p class="text-gray-300">In the remainder of the proof, we will revisit Sleepy’s proof <em>[48]</em>. Instead of presenting the full proof again from scratch, we focus on pointing out how to express every bad event as the union of polynomially many bad events each of which depends only on a constant number of hashes.</p>

    <p class="text-gray-300">Chain growth lower bound. It is easy to see that the consistent length property still holds with our new <span class="math">\\Pi_{\\text{bias}}</span>.</p>

    <p class="text-gray-300">We now prove chain growth lower bound. We will show that and every window of medium length, i.e., for every <span class="math">\\frac{T_{0}}{g_{0}}\\leq t_{0}\\leq\\frac{2T_{0}}{g_{0}}</span>, the chain growth lower bound holds for the parameter <span class="math">t_{0}</span> over views sampled from <span class="math">\\EXEC^{\\Pi_{\\text{bias}}}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>. It is not hard to see that if the chain growth lower bound holds for every window of medium length <span class="math">\\frac{T_{0}}{g_{0}}\\leq t_{0}\\leq\\frac{2T_{0}}{g_{0}}</span>, then it also holds for every <span class="math">T\\geq T_{0}</span> and every <span class="math">t_{0}\\geq\\frac{T}{g_{0}}</span>, since every longer window can be broken up into disjoint windows of medium lengths, and we simply have to take a union bound over these windows.</p>

    <p class="text-gray-300">To complete the proof, it suffices to observe the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In Sleepy’s chain growth lower bound proof <em>[48]</em> which in turn follows that of Pass et al. <em>[45]</em>, for any window <span class="math">[t,t^{\\prime}]</span>, conditioned on any execution trace <span class="math">\\view^{t}</span> up till time <span class="math">t</span>, the minimum chain growth during the window <span class="math">[t,t^{\\prime}]</span> is upper bounded by a random variable that depends only on the randomness generated by <span class="math">\\mathcal{F}_{\\text{tree}}</span> corresponding to the time window <span class="math">[t,t^{\\prime}]</span>, but does not depend on any other random bits generated by <span class="math">\\mathcal{F}_{\\text{tree}}</span>. Our chain growth lower bound proof then goes to show that conditioned on any <span class="math">\\view^{t}</span>, the minimum chain growth during the window <span class="math">[t,t^{\\prime}]</span> has to be large. Note that the minimum chain growth during the window <span class="math">[t,t^{\\prime}]</span> may depend on random bits before this window, but the proof lower bounds the minimum chain growth during <span class="math">[t,t^{\\prime}]</span> with another (implicitly defined) random variable that does not depend on any randomness before <span class="math">t</span>.</li>

      <li>Since <span class="math">T_{\\text{epoch}}\\geq\\frac{\\kappa}{\\gamma}</span>, it holds that every window of medium length (where medium length is as defined above) involves only <span class="math">O(1)</span> number of epochs.</li>

    </ul>

    <p class="text-gray-300">However, as mentioned earlier, since the chain growth lower bound for a medium sized window is lower bounded by a random variable that depends only on <span class="math">c=O(1)</span> hashes, by Lemma 1, chain</p>

    <p class="text-gray-300">growth lower bound holds except with negligible probability over <span class="math">\\mathsf{view}\\leftarrow_{\\S}\\mathsf{EXEC}^{\\Pi_{\\mathrm{bias}}}(\\mathcal{A},\\mathcal{Z},\\kappa)</span> for any medium sized window.</p>

    <p class="text-gray-300">Chain quality. We examine the chain quality proof of Sleepy <em>[48]</em>. Below we use the same notations as in Sleepy <em>[48]</em>.</p>

    <p class="text-gray-300">If <span class="math">t\\leq 2T_{\\mathrm{epoch}}</span> is small, then the random variable <span class="math">\\mathbf{Q}(\\mathsf{view})[r:r+t]</span> depends on only <span class="math">c=O(1)</span> number of hashes. Similarly, the random variable <span class="math">\\mathbf{A}(\\mathsf{view})[r:r+t]</span> also depends only on <span class="math">c=O(1)</span> number of hashes for <span class="math">t\\leq 2T_{\\mathrm{epoch}}</span>.</p>

    <p class="text-gray-300">Applying Lemma 1, for fixed <span class="math">[r,r+t]</span> such that <span class="math">t\\leq 2T_{\\mathrm{epoch}}</span> is small, we have that for any <span class="math">\\epsilon&gt;0</span>, any p.p.t. pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span> compliant for <span class="math">\\Pi_{\\mathrm{bias}}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow_{\\S}\\mathsf{EXEC}^{\\Pi_{\\mathrm{bias}}}(\\mathcal{A},\\mathcal{Z},\\kappa):\\mathbf{Q}(\\mathsf{view})[r:r+t]&gt;(1+\\epsilon)np\\cdot t\\right]&lt;\\mathsf{negl}(npt)\\cdot q(\\kappa)^{c}</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow_{\\S}\\mathsf{EXEC}^{\\Pi_{\\mathrm{bias}}}(\\mathcal{A},\\mathcal{Z},\\kappa):\\mathbf{A}(\\mathsf{view})[r:r+t]&gt;(1+\\epsilon)\\beta t\\right]&lt;\\mathsf{negl}(\\beta t)\\cdot q(\\kappa)^{c}</span></p>

    <p class="text-gray-300">where <span class="math">q(\\kappa)</span> denotes the maximum number of hash queries made by <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">Now, taking a union bound, we can upper bound <span class="math">Q_{t}(\\mathsf{view})</span> and <span class="math">A_{t}(\\mathsf{view})</span> for any <span class="math">t\\leq 2T_{\\mathrm{epoch}}</span> — see the Sleepy work <em>[48]</em> for definitions of <span class="math">Q_{t}</span> and <span class="math">A_{t}</span>. Specifically, for any <span class="math">t\\leq 2T_{\\mathrm{epoch}}</span>, any <span class="math">\\epsilon&gt;0</span>, any <span class="math">\\Pi_{\\mathrm{bias}}</span>-compliant p.p.t. pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, there exists a negligible function <span class="math">\\mathsf{negl}(\\cdot)</span> and a polynomial function <span class="math">\\mathsf{poly}(\\cdot)</span> such that for all <span class="math">\\kappa</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow_{\\S}\\mathsf{EXEC}^{\\Pi_{\\mathrm{bias}}}(\\mathcal{A},\\mathcal{Z},\\kappa):Q_{t}(\\mathsf{view})&gt;(1+\\epsilon)np\\cdot t\\right]&lt;\\mathsf{negl}(npt)\\cdot\\mathsf{poly}(\\kappa)</span> <span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow_{\\S}\\mathsf{EXEC}^{\\Pi_{\\mathrm{bias}}}(\\mathcal{A},\\mathcal{Z},\\kappa):A_{t}(\\mathsf{view})&gt;(1+\\epsilon)\\beta t\\right]&lt;\\mathsf{negl}(\\beta t)\\cdot\\mathsf{poly}(\\kappa)</span></p>

    <p class="text-gray-300">The above proved bounds for <span class="math">Q_{t}(\\mathsf{view})</span> and <span class="math">A_{t}(\\mathsf{view})</span> for small values of <span class="math">t</span>, assuming <span class="math">t\\leq 2T_{\\mathrm{epoch}}</span>. We now consider large windows. Similarly as before, we can break up large windows into medium-sized windows of lengths <span class="math">[T_{\\mathrm{epoch}},2T_{\\mathrm{epoch}}]</span>. By taking a union bound over all windows, we easily get the following fact.</p>

    <p class="text-gray-300">Fact 1. For any <span class="math">t&gt;0</span>, any <span class="math">\\epsilon&gt;0</span>, any p.p.t. pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span> compliant for <span class="math">\\Pi_{\\mathrm{bias}}</span>, there exists a negligible function <span class="math">\\mathsf{negl}(\\cdot)</span> and a polynomial <span class="math">\\mathsf{poly}(\\cdot)</span> such that for all <span class="math">\\kappa</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow_{\\S}\\mathsf{EXEC}^{\\Pi_{\\mathrm{bias}}}(\\mathcal{A},\\mathcal{Z},\\kappa):Q_{t}(\\mathsf{view})&gt;(1+\\epsilon)np\\cdot t\\right]&lt;\\mathsf{negl}(np\\cdot\\min(t,T_{\\mathrm{epoch}}))\\cdot\\mathsf{poly}(\\kappa)</span> <span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow_{\\S}\\mathsf{EXEC}^{\\Pi_{\\mathrm{bias}}}(\\mathcal{A},\\mathcal{Z},\\kappa):A_{t}(\\mathsf{view})&gt;(1+\\epsilon)\\beta t\\right]&lt;\\mathsf{negl}(\\beta\\cdot\\min(t,T_{\\mathrm{epoch}}))\\cdot\\mathsf{poly}(\\kappa)</span></p>

    <p class="text-gray-300">The remainder of the chain quality proof can then be completed following exactly the same recipe as Sleepy <em>[48]</em>, plugging in our new Fact 1 to bound the random variables <span class="math">A_{t}</span> and <span class="math">Q_{t}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consistency. In Sleepy’s consistency proof <em>[48]</em>, they define a <span class="math">\\mathsf{view}</span> to be bad if there exists $t_{0}\\leq t_{1}\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> where </span>t_{1}-t_{0}\\geq\\frac{\\sqrt{\\kappa}}{\\beta}$, such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathbf{A}(\\mathsf{view})[t_{0}:t_{1}]\\geq\\mathsf{chain}(\\mathsf{view})[t_{0}:t_{1}]</span></p>

    <p class="text-gray-300">They show that there are <span class="math">\\mathsf{negl}(\\kappa)</span> fraction of such bad views — note that the same holds in our case, simply plugging in our new Fact 1. Conditioned on <span class="math">\\mathsf{views}</span> that are not bad, the Sleepy work <em>[48]</em> then argue that for every window of length <span class="math">\\frac{2\\kappa}{\\beta}</span>, there has to exist a pivot point except with negligible</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Figure 8: Ideal functionality  <span class="math">\\mathcal{F}_{\\mathrm{punctual}}</span> .  <span class="math">\\mathcal{F}_{\\mathrm{punctual}}</span>  enforces punctuality, and rejects stale blocks that arrive too late. Blue denotes the difference from  <span class="math">\\mathcal{F}_{\\mathrm{bias}}</span> .</p>

    <p class="text-gray-300">probability. Note that for any window of length  <span class="math">\\frac{2\\kappa}{\\beta}</span> , and ignoring views that are not bad, the bad event that a pivot point does not exist within the window depends on randomness that are at most  <span class="math">\\Delta</span>  far from boundaries of the window — this means that the bad event depends on  <span class="math">O(1)</span>  number of hashes given that  <span class="math">T_{\\mathrm{epoch}} \\geq \\frac{\\kappa}{\\gamma}</span> . Now by Lemma 1, the bad event that there does not exist a pivot within a window of length  <span class="math">\\frac{2\\kappa}{\\beta}</span>  is  <span class="math">\\mathsf{negl}(\\kappa)</span> . The remainder of the proof follows in the same way as Sleepy [48].</p>

    <p class="text-gray-300">Chain growth upper bound. First, given that we have already proved chain growth lower bound and a bound for the random variable  <span class="math">A_{t}</span> , we can prove a "no long block withholding" lemma in exactly the same way as Sleepy [48], where for a withholding time of  <span class="math">\\epsilon t</span> , the failure probability is replaced with  <span class="math">\\mathsf{negl}(\\min (\\beta \\cdot \\min (t,T_{\\mathrm{epoch}})))\\cdot \\mathsf{poly}(\\kappa)</span>  instead of  <span class="math">\\mathsf{negl}(\\beta t)\\mathsf{poly}(\\kappa)</span> . For completeness, we state this lemma below since it will be used later in the proof as well.</p>

    <p class="text-gray-300">Let withhold-time(view) be the longest number of time steps  <span class="math">t</span>  such that in view: 1) at some time in view, the adversary mines a chain with purported  <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span> -timestamp  <span class="math">r</span> ; and 2) chain is first accepted by honest nodes at time  <span class="math">r + t</span>  in view.</p>

    <p class="text-gray-300">Lemma 2 (No long block withholding). For every  <span class="math">\\Pi_{\\mathrm{bias}}</span> -compliant p.p.t.  <span class="math">(\\mathcal{A},\\mathcal{Z})</span>  pair, for every constant  <span class="math">0 &amp;lt; \\epsilon &amp;lt; 1</span> , there exists a negligible function  <span class="math">\\mathrm{negl}(\\cdot)</span>  such that</p>

    <p class="text-gray-300"><span class="math">\\operatorname*{Pr}\\left[\\text{view} \\leftarrow_{\\S} \\mathsf{EXEC}^{\\Pi_{\\text{bias}}}(\\mathcal{A}, \\mathcal{Z}, \\kappa): \\text{withhold-time}(\\text{view}) &amp;gt; \\epsilon t\\right] \\leq \\mathsf{negl}(\\beta \\min(t, T_{\\text{epoch}})) \\cdot \\mathsf{poly}(\\kappa)</span></p>

    <p class="text-gray-300">We can now prove chain growth upper bound exactly in the same way as Sleepy [48], relying on our bound on  <span class="math">Q_{t}</span>  as well as the new "no long block withholding" lemma.</p>

    <p class="text-gray-300">The "no long block withholding" lemma (see Lemma 2) states that if there is a chain  <span class="math">\\in \\mathcal{F}_{\\mathrm{punctual}}</span> . tree with a sufficiently old timestamp, then if an honest node never accepted chain as its prefix earlier, it is not going to ever accept chain as its prefix. This implies that even if the adversary  <span class="math">\\mathcal{A}</span>  successfully asks  <span class="math">\\mathcal{F}_{\\mathrm{punctual}}</span>  to extend a chain with a sufficiently stale timestamp, this action is useless because</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span> cannot ever persuade any honest node to ever accept this chain (or any longer chain containing it). In this section, we will augment our ideal functionality to simply reject <span class="math">\\mathcal{A}</span>’s requests to extend a chain with a sufficiently stale timestamp — see <span class="math">\\mathcal{F}_{\\text{punctual}}</span> in Figure 8. It is not hard to show that this modification does not affect the security of our ideal protocol.</p>

    <p class="text-gray-300">Protocol <span class="math">\\Pi_{\\text{punctual}}</span>. We define <span class="math">\\Pi_{\\text{punctual}}</span> in exactly the same manner as <span class="math">\\Pi_{\\text{bias}}</span>, except that calls to <span class="math">\\mathcal{F}_{\\text{bias}}</span> are now replaced with calls to <span class="math">\\mathcal{F}_{\\text{punctual}}</span>.</p>

    <p class="text-gray-300">Compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span>. We now consider a model where <span class="math">\\mathcal{Z}</span> can corrupt committee members sufficiently ancient in the past, as long as <span class="math">\\mathcal{Z}</span> has not committed these nodes to serve on committees in recent, present, or future epochs. We show that because <span class="math">\\mathcal{F}_{\\text{punctual}}</span> rejects blocks with stale timestamps anyway, corruption into the past does not allow the adversary to do anything interesting additionally. As a result, we prove that <span class="math">\\Pi_{\\text{punctual}}</span> is actually secure in this stronger corruption model.</p>

    <p class="text-gray-300">More formally, we say that a p.p.t. pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is compliant for <span class="math">\\Pi_{\\text{punctual}}</span> iff the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A-priori commitment of committees and hashes. Same as <span class="math">\\Pi_{\\text{bias}}</span>.</li>

      <li>Spawning and sleeping. Same as the compliance rules for <span class="math">\\Pi_{\\text{bias}}</span>.</li>

      <li>Corruption model. At time <span class="math">t\\leq t^{\\prime}</span>, <span class="math">\\mathcal{A}</span> is allowed to issue <span class="math">(\\texttt{corrupt},i,t^{\\prime})</span> iff</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there does not exist <span class="math">r\\geq t^{\\prime}-W</span> such that <span class="math">\\mathcal{A}</span> has called <span class="math">\\mathcal{F}_{\\text{punctual}}.\\texttt{setpids}(r,\\texttt{pids}_{r})</span> where <span class="math">i\\in\\texttt{pids}_{r}</span>;</li>

    </ul>

    <p class="text-gray-300">At time <span class="math">t\\leq t_{0}\\leq t_{1}</span>, <span class="math">\\mathcal{A}</span> is allowed to issue <span class="math">(\\texttt{sleep},i,t_{0},t_{1})</span> if</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for every <span class="math">r\\in[t_{0},t_{1}]</span>, <span class="math">\\mathcal{A}</span> has not called <span class="math">\\mathcal{F}_{\\text{punctual}}.\\texttt{setpids}(r,\\texttt{pids}_{r})</span> such that <span class="math">i\\in\\texttt{pids}_{r}</span>.</li>

    </ul>

    <p class="text-gray-300">In other words, <span class="math">\\mathcal{A}</span> can only ask a node <span class="math">i</span> to become corrupt at time <span class="math">t^{\\prime}</span>, if <span class="math">\\mathcal{A}</span> has not committed <span class="math">i</span> to be on a committee any time at <span class="math">t^{\\prime}-W</span> or later. However, it is possible that after <span class="math">\\mathcal{A}</span> asks a node <span class="math">i</span> to become corrupt at a future time, <span class="math">\\mathcal{A}</span> can then commit it to some committee. It is also possible for <span class="math">\\mathcal{A}</span> to ask a node to be corrupt at a future time if the node served on some very old committee, but has not been committed to any committee since. Note that this “posterior corruption” ability was not allowed for our earlier corruption model (i.e., <span class="math">(\\mathcal{A},\\mathcal{Z})</span> compliant for <span class="math">\\Pi_{\\text{bias}}</span>).</p>

    <p class="text-gray-300">Further, similar as before, before <span class="math">\\mathcal{A}</span> commits to a committee for time <span class="math">t</span>, <span class="math">\\mathcal{A}</span> must commit to which set of honest nodes will become asleep at time <span class="math">t</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Resilience. For any time step <span class="math">t</span>, let <span class="math">\\texttt{cmt}^{t}(\\texttt{view})</span> be the <span class="math">(t,\\texttt{pids}_{t})</span> committee set that <span class="math">\\mathcal{A}</span> sends to <span class="math">\\mathcal{F}_{\\text{punctual}}</span> in view, let $r=\\min(t+W,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\texttt{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, it must hold that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\frac{\\texttt{alert}^{t}(\\texttt{cmt}^{t}(\\texttt{view}),\\texttt{view})\\cap\\texttt{honest}^{r}(\\texttt{cmt}^{t}(\\texttt{view}),\\texttt{view})}{\\texttt{corrupt}^{r}(\\texttt{cmt}^{t}(\\texttt{view}),\\texttt{view})}\\geq 1+\\phi</span></p>

    <p class="text-gray-300">where <span class="math">\\texttt{alert}^{s}(S,\\texttt{view})</span>, <span class="math">\\texttt{honest}^{s}(S,\\texttt{view})</span>, and <span class="math">\\texttt{corrupt}^{s}(S,\\texttt{view})</span> denote those among <span class="math">S</span> are alert, honest, and corrupt at time <span class="math">s</span> respectively.</p>

    <p class="text-gray-300">Notice that our new resilience rule is weaker now, it only requires at any time <span class="math">t</span>, alert committee members who remain honest for <span class="math">W</span> more steps outnumber committee members who become corrupt by <span class="math">t+W</span>. Before in <span class="math">\\Pi_{\\text{ideal}}</span> and <span class="math">\\Pi_{\\text{bias}}</span>, we essentially required <span class="math">W</span> to be infinity.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Number of awake nodes. Let <span class="math">\\mathsf{cmt}^t(\\mathsf{view})</span> be the <span class="math">(t, \\mathsf{pids}_t)</span> committee set that <span class="math">\\mathcal{A}</span> sends to <span class="math">\\mathcal{F}_{\\mathrm{punctual}}</span> in <span class="math">\\mathsf{view}</span>. It holds that for every $t \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, let </span>r = \\min(t + W,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf{alert}^t(\\mathsf{cmt}^t(\\mathsf{view}), \\mathsf{view}) \\cap \\mathsf{honest}^r(\\mathsf{cmt}^t(\\mathsf{view}), \\mathsf{view})) + \\mathsf{corrupt}^r(\\mathsf{cmt}^t(\\mathsf{view}), \\mathsf{view}) = n</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Admissible parameters. Same as in <span class="math">\\Pi_{\\mathrm{bias}}</span> with the additional requirement that <span class="math">W \\geq \\frac{\\kappa}{\\gamma}</span>.</li>

    </ul>

    <p class="text-gray-300">Theorem 5 (Security of <span class="math">\\Pi_{\\mathrm{punctual}}</span>). <span class="math">\\Pi_{\\mathrm{punctual}}</span> satisfies <span class="math">T_0</span>-consistency, <span class="math">(T_0, \\mu)</span>-chain quality, and <span class="math">(T_0, g_0, g_1)</span>-chain growth against any <span class="math">\\Pi_{\\mathrm{punctual}}</span>-compliant <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> for the same parameters <span class="math">T_0, \\mu, g_0, g_1</span> as defined in Theorem 3.</p>

    <p class="text-gray-300">Proof. First, it is not hard to see that <span class="math">\\Pi_{\\mathrm{punctual}}</span> satisfies consistency, <span class="math">\\mu</span>-chain quality, and <span class="math">(g_0, g_1)</span>-chain growth for a weaker corruption model, i.e., against any a p.p.t. pair <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> compliant w.r.t. <span class="math">\\Pi_{\\mathrm{bias}}</span> (rather than w.r.t. <span class="math">\\Pi_{\\mathrm{punctual}}</span>). Recall that a <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> pair compliant w.r.t. <span class="math">\\Pi_{\\mathrm{bias}}</span> is not allowed posterior corruption. To see this, consider a compliant execution of <span class="math">\\Pi_{\\mathrm{bias}}</span>. Due to the "no long block withholding" lemma, a block with an old timestamp will never be first accepted by honest nodes with <span class="math">1 - \\mathsf{negl}(\\beta W) = 1 - \\mathsf{negl}\\left(\\frac{\\beta\\kappa}{\\gamma}\\right) = 1 - \\mathsf{negl}(\\kappa)</span> probability, where <span class="math">W</span> denotes how old the block is.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Below we simply ignore the negligible fraction of bad views where the "no long block withholding" lemma fails. This means that in any good view, if <span class="math">\\mathcal{A}</span> tries to call <span class="math">\\mathcal{F}_{\\mathrm{bias}}.\\mathrm{extend}(\\mathrm{chain},\\mathsf{B},t^{\\prime})</span> at time <span class="math">t</span>, where <span class="math">t^{\\prime} &amp;lt; t - W</span> and suppose that chain</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B is not already in <span class="math">\\mathcal{F}_{\\mathrm{bias}}</span>, then no honest will later ever call <span class="math">\\mathcal{F}_{\\mathrm{bias}}.\\mathrm{verify}(\\mathrm{chain}^{\\prime})</span> where chain</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B <span class="math">\\prec</span> chain'. For this reason, it is equivalent if <span class="math">\\mathcal{F}_{\\mathrm{bias}}</span> simply ignored such adversarial requests to <span class="math">\\mathcal{F}_{\\mathrm{bias}}.\\mathrm{extend}(-, -, t&#x27;)</span> at time <span class="math">t</span>, where <span class="math">t&#x27; &amp;lt; t - W</span>. And the only difference between <span class="math">\\Pi_{\\mathrm{bias}}</span> and <span class="math">\\Pi_{\\mathrm{punctual}}</span> is precisely this: in <span class="math">\\Pi_{\\mathrm{punctual}}</span>, <span class="math">\\mathcal{F}_{\\mathrm{punctual}}</span> ignores such adversarial requests to extend a chain with very old timestamps.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">\\mathsf{allchains}^t(\\mathsf{view})</span> denote the set that includes an ordered list of the output chains of all nodes alert at time <span class="math">t</span>. To complete the proof, it suffices to show the following lemma.</p>

    <p class="text-gray-300">Lemma 3 (Posterior corruption does not matter). For any <span class="math">\\Pi_{\\mathrm{punctual}}</span>-compliant p.p.t. <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>, there exists <span class="math">\\Pi_{\\mathrm{bias}}</span>-compliant p.p.t. <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>, and a function <span class="math">\\mathsf{somechains}^t(\\mathsf{view})</span> that selects an appropriate subset of alert nodes' output chains in view and at time <span class="math">t</span>, such that the following distributions are identical:</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{view} \\leftarrow_{\\S} \\text{EXEC}^{\\Pi_{\\text{punctual}}}(\\mathcal{A}, \\mathcal{Z}, \\kappa): \\{\\text{allchains}^t(\\text{view})\\}_{t \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]} \\text{ and} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Proof. <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span> runs <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> in a sandbox and intercepts <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>'s communications with outside. At a high level, whenever <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> wants to corrupt a node, <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span> will spawn a sybil of the node and corrupt the sybil instead. This will allow <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span> to respect <span class="math">\\Pi_{\\mathrm{bias}}</span>'s compliance rules and yet be able to emulate <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>'s attack. As pointed out earlier, if <span class="math">\\Pi_{\\mathrm{punctual}}</span> is run with such a weaker, <span class="math">\\Pi_{\\mathrm{bias}}</span>-compliant attacker, then the execution respects all the desired properties including chain growth, chain quality, and consistency. Since <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span> can emulate attacks by <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>, we can then infer that <span class="math">\\Pi_{\\mathrm{punctual}}</span> retains these properties in the presence of a stronger, <span class="math">\\Pi_{\\mathrm{punctual}}</span>-compliant attacker too.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If at some time <span class="math">t \\leq t&#x27;</span>, <span class="math">\\mathcal{A}</span> issues <span class="math">(\\text{corrupt}, i, t&#x27;)</span>: if <span class="math">\\mathcal{A}</span> has issued <span class="math">(\\text{corrupt}, i, r)</span> for <span class="math">r \\leq t&#x27;</span> earlier, this request is ignored. Otherwise, <span class="math">i</span> must not been chosen as a committee member for <span class="math">[t&#x27; - W, \\infty]</span> since <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> is <span class="math">\\Pi_{\\text{punctual}}</span>-compliant. Now <span class="math">\\mathcal{Z}&#x27;</span> spawns a sybil <span class="math">i^<em></span> immediately (if no sybil of <span class="math">i</span> has been spawned earlier) and provides it with <span class="math">i</span>'s internal state as input. Let <span class="math">i^</em></span> be the sybil of</li>

    </ul>

    <p class="text-gray-300"><span class="math">i</span> spawned either at the current time <span class="math">t</span> or earlier. Further, <span class="math">\\mathcal{A}&#x27;</span> issues <span class="math">(\\texttt{corrupt}, i^<em>, t&#x27;)</span>. <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span> remembers (or updates) the mapping <span class="math">\\texttt{ sybil}[i] = (i^</em>, t&#x27; - W)</span>. We also say that <span class="math">t&#x27; - W</span> is sybil node <span class="math">i^<em></span>'s effective time. Intuitively, <span class="math">i^</em></span> will act as a defunct copy of <span class="math">i</span> before its effective time; and afterwards <span class="math">i^*</span> will act on behalf of <span class="math">i</span> and then <span class="math">i</span> will effectively become the defunct copy.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Whenever <span class="math">\\mathcal{A}</span> calls <span class="math">\\mathcal{F}_{\\mathrm{punctual}.setpids}(t, \\mathsf{pids}_t)</span> and this is the first time <span class="math">\\mathcal{A}</span> calls <span class="math">\\mathcal{F}_{\\mathrm{punctual}.setpids}(t, \\_)</span>, <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span> will inspect <span class="math">\\mathsf{pids}_t</span>. If <span class="math">i \\in \\mathsf{pids}_t</span> and some tuple <span class="math">\\mathsf{ sybil}[i] = (i^<em>, s)</span> has been stored for some <span class="math">s \\leq t</span>, replace node <span class="math">i</span>'s occurrence in <span class="math">\\mathsf{pids}_t</span> with <span class="math">i^</em></span>.</li>

    </ul>

    <p class="text-gray-300">Whenever <span class="math">\\mathcal{A}</span> calls <span class="math">\\mathcal{F}_{\\mathrm{punctual}. \\text{extend}}(\\_ , \\_ , \\_)</span> or <span class="math">\\mathcal{F}_{\\mathrm{punctual}. \\text{verify}}(\\_)</span> acting as node <span class="math">i</span> at time <span class="math">t</span>, <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span> finds the stored sybil identity <span class="math">i^<em></span> for <span class="math">i</span> — note that such a sybil identity <span class="math">i^</em></span> has to exist and <span class="math">i^<em></span> has to be already corrupt at <span class="math">t</span> if <span class="math">\\mathcal{A}</span> is acting as <span class="math">i</span> at <span class="math">t</span>. Now <span class="math">\\mathcal{A}&#x27;</span> rewrites the call acting as <span class="math">i^</em></span> instead.</p>

    <p class="text-gray-300">Similarly, whenever <span class="math">\\mathcal{A}</span> calls <span class="math">\\mathcal{F}_{\\mathrm{punctual}. \\text{leader}}(\\_, i, t)</span>, <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span> makes the following check: if <span class="math">i</span> has a stored sybil identity <span class="math">i^<em></span> and moreover <span class="math">i^</em></span> is effective at time <span class="math">t</span>, then <span class="math">\\mathcal{A}&#x27;</span> rewrites the call replacing <span class="math">i</span> with <span class="math">i^*</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Whenever <span class="math">\\mathcal{A}</span> or <span class="math">\\mathcal{Z}</span> sends a message to an honest node <span class="math">i</span>, <span class="math">\\mathcal{A}&#x27;</span> or <span class="math">\\mathcal{Z}&#x27;</span> sends a duplicate of this message to <span class="math">i</span>'s sybil <span class="math">i^*</span> if one exists.</li>

      <li>Whenever a sybil node <span class="math">i^<em></span> sends a message to <span class="math">\\mathcal{A}</span> or <span class="math">\\mathcal{Z}</span> at time <span class="math">t</span> (this means that the sybil node <span class="math">i^</em></span> has not become corrupt yet, and is still honest), simply drop the message.</li>

      <li>For every other message sent by <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>, <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span> directly passes through them.</li>

    </ul>

    <p class="text-gray-300">If <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> is <span class="math">\\Pi_{\\mathrm{punctual}}</span>-compliant, and let <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span> be defined as above, then the following facts must hold: in any <span class="math">\\mathsf{view}&#x27; \\gets \\mathsf{EXEC}^{\\Pi_{\\mathrm{punctual}}}(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;, \\kappa)</span> of non-zero support, for any pair of nodes <span class="math">(i, i^<em>)</span> where <span class="math">i^</em></span> is <span class="math">i</span>'s sybil whose effective time is <span class="math">r</span>, <span class="math">i^<em></span> is never on any committee for any <span class="math">t \\leq r</span>; and <span class="math">i</span> is never on any committee for any <span class="math">t &amp;gt; r</span>. Further, for every sybil <span class="math">i^</em></span> in <span class="math">\\mathsf{view}&#x27;</span>, <span class="math">\\mathcal{A}&#x27;</span> has to issue <span class="math">(\\texttt{corrupt}, i^<em>, \\_)</span> instructions prior to any <span class="math">\\mathcal{F}_{\\mathrm{punctual}. \\text{setpids}}</span> calls that commit <span class="math">i^</em></span> to being a committee member.</p>

    <p class="text-gray-300"><strong>Claim 2.</strong> If <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is <span class="math">\\Pi_{\\mathrm{punctual}}</span>-compliant, then <span class="math">(\\mathcal{A}&#x27;,\\mathcal{Z}&#x27;)</span> must be <span class="math">\\Pi_{\\mathrm{bias}}</span>-compliant.</p>

    <p class="text-gray-300"><strong>Proof.</strong> - <strong>Corruption model.</strong> Observe that a <span class="math">\\Pi_{\\mathrm{punctual}}</span>-compliant <span class="math">\\mathcal{A}</span> will never issue <span class="math">(\\texttt{corrupt}, i, t&#x27;)</span> at time <span class="math">t \\leq t&#x27;</span>, if node <span class="math">i</span> has already been committed to as a committee member for time <span class="math">t&#x27; - W</span> of after. If <span class="math">\\mathcal{A}</span> issues <span class="math">(\\texttt{corrupt}, i, t&#x27;)</span> at time <span class="math">t \\leq t&#x27;</span> for some node <span class="math">i</span> that was on a committee before <span class="math">t&#x27; - W</span> but has not been committed to as a committee member since, then <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span> captures this request and rewrites it with a spawn and a corrupt request for a different node <span class="math">i^*</span>. In this way, it is not hard to see that <span class="math">\\mathcal{A}&#x27;</span> will never issue <span class="math">(\\texttt{corrupt}, i, t&#x27;)</span> at time <span class="math">t \\leq t&#x27;</span> if node <span class="math">i</span> has ever been committed to as any (past or future) committee member by time <span class="math">t</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Resilience and correct parametrization.</strong> For any fixed sequence of random bits <span class="math">\\vec{v}</span> consumed by all ITMs in the execution, we consider the pair of execution traces defined by <span class="math">\\vec{v}</span>, denoted <span class="math">\\mathsf{view}(\\vec{v})</span> and <span class="math">\\mathsf{view}&#x27;(\\vec{v})</span> in the support of <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathrm{punctual}}}(\\mathcal{A}, \\mathcal{Z}, \\kappa)</span> and <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathrm{punctual}}}(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;, \\kappa)</span> respectively.</li>

    </ul>

    <p class="text-gray-300">It is not hard to see that for every pair <span class="math">\\mathsf{view}(\\vec{v})</span> and <span class="math">\\mathsf{view}&#x27;(\\vec{v})</span> defined by randomness <span class="math">\\vec{v}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\forall t: \\mathsf{alert}^t(\\mathsf{cmt}^t(\\mathsf{view}&#x27;), \\mathsf{view}&#x27;) = \\mathsf{alert}^t(\\mathsf{cmt}^t(\\mathsf{view}), \\mathsf{view})</span></div>

    <p class="text-gray-300">We now show that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\forall t:\\text{\\tt corrupt}(\\text{\\tt cmt}^{t}(\\text{\\tt view}^{\\prime}),\\text{\\tt view}^{\\prime})=\\text{\\tt corrupt}^{\\min(t+W,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{\\tt view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}(\\text{\\tt cmt}^{t}(\\text{\\tt view}),\\text{\\tt view})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">which would also imply</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\forall t:\\text{\\tt honest}(\\text{\\tt cmt}^{t}(\\text{\\tt view}^{\\prime}),\\text{\\tt view}^{\\prime})=\\text{\\tt honest}^{\\min(t+W,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{\\tt view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}(\\text{\\tt cmt}^{t}(\\text{\\tt view}),\\text{\\tt view})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. For every node <span class="math">j</span> that is on the committee of time <span class="math">t</span> in view and is ever corrupt, <span class="math">j</span> must be the sybil of some node henceforth denoted <span class="math">i</span>. Clearly <span class="math">i</span> must be on the committee for time <span class="math">t</span> in view, therefore it suffices to show that <span class="math">i</span> is corrupt by time $\\min(t+W,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{\\tt view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> in view. Notice that if </span>j<span class="math"> on the committee at time </span>t<span class="math"> and is ever corrupt in view, let </span>r<span class="math"> denote the time that </span>j<span class="math"> becomes corrupt. It must be the case that </span>(\\text{\\tt corrupt},j,r)<span class="math"> is issued and afterwards </span>\\mathcal{A}^{\\prime}<span class="math"> commits </span>j<span class="math"> to being a committee member at </span>t<span class="math">. We now show </span>r\\leq t+W<span class="math">. Notice that if </span>\\mathcal{A}^{\\prime}<span class="math"> issues </span>(\\text{\\tt corrupt},j,r)<span class="math">, then </span>j<span class="math"> must be a sybil node whose effective time starts at </span>r-W<span class="math"> — before </span>r-W<span class="math"> even though </span>j<span class="math"> has been spawned, it does not do anything interesting such as being added to committees. Therefore </span>t\\geq r-W$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To complete the proof, it is not hard to observe that <span class="math">(\\text{\\tt corrupt},i,r)</span> must be in view and further in view <span class="math">\\mathcal{A}</span> must commit <span class="math">i</span> to being a committee member at <span class="math">t</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. For every <span class="math">i</span> on the committee at <span class="math">t</span> in view and is ever corrupt in $[t,\\min(t+W,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{\\tt view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, it must be the case that in view, </span>\\mathcal{A}<span class="math"> issues </span>(\\text{\\tt corrupt},i,r)<span class="math"> for some </span>r\\leq\\min(t+W,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{\\tt view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> first, and then </span>\\mathcal{A}<span class="math"> commits </span>i<span class="math"> to the </span>t<span class="math">-th committee. Therefore, in the corresponding view, </span>\\mathcal{A}^{\\prime}<span class="math"> will issue </span>(\\text{\\tt corrupt},i^{<em>},r)<span class="math"> where </span>i^{</em>}<span class="math"> is the sybil of </span>i<span class="math"> in view. Further, </span>\\mathcal{A}^{\\prime}<span class="math"> will commit </span>i^{*}<span class="math"> to the </span>t$-th committee.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It is easy to verify that <span class="math">(\\mathcal{A}^{\\prime},\\mathcal{Z}^{\\prime})</span> satisfies the remaining compliance rules. ∎</p>

    <p class="text-gray-300">We now consider the most natural selection function somechains that selects a subset of alert nodes’ output chains at every time <span class="math">t</span> given view <span class="math">\\text{\\tt{view}}^{\\prime}\\leftarrow\\text{\\tt{EXEC}}^{\\Pi_{\\text{\\scriptsize punctual}}}(\\mathcal{A}^{\\prime},\\mathcal{Z}^{\\prime},\\kappa)</span>. Specifically, for each pair <span class="math">(i,i^{<em>})</span> such that both are alert at time <span class="math">t</span>, <span class="math">\\text{\\tt{somechains}}^{t}</span> would select <span class="math">i^{</em>}</span> at time <span class="math">t</span> if <span class="math">t</span> is at or after <span class="math">i^{*}</span>’s effective time. Otherwise, <span class="math">\\text{\\tt{somechains}}^{t}</span> would select <span class="math">i</span>.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Claim 3.</h6>

    <p class="text-gray-300">Under the aforementioned selection function <span class="math">\\text{\\tt{somechains}}^{t}</span>, for every pair view<span class="math">(\\vec{v})</span> and view<span class="math">(\\vec{v})</span> defined by randomness <span class="math">\\vec{v}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\{\\text{\\tt allchains}}^{t}(\\text{\\tt view})\\}_{t\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{\\tt view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}=\\{\\text{\\tt somechains}}^{t}(\\text{\\tt view}^{\\prime})\\}_{t\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{\\tt view}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-60" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">To see this, notice that all <span class="math">(\\mathcal{A}^{\\prime},\\mathcal{Z}^{\\prime})</span> does is renaming nodes — therefore it is not hard to see that the only way that the two can differ is if at some time <span class="math">t\\geq t^{\\prime}</span>, <span class="math">\\mathcal{A}</span> calls $\\mathcal{F}_{\\text{\\scriptsize punctual}}.\\text{\\tt extend}(\\mbox{\\tiny{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox{\\tiny{\\mbox</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> Figure 9: A hybrid protocol carrying real-world blocks.</p>

    <p class="text-gray-300">We are almost ready to show that our real-world protocol emulates the ideal-world one which we know how to analyze. But before that, we have to go through one more intermediate step that correct the protocol's interfaces to the environment  <span class="math">\\mathcal{Z}</span>  such that the interfaces will type check by the real-world protocol's type definitions.</p>

    <p class="text-gray-300">In this section, we will define a hybrid protocol  <span class="math">\\Pi_{\\mathrm{hyb}}</span>  that carries real-world interfaces to the environment  <span class="math">\\mathcal{Z}</span>  — see Figure 9. We will show that all the properties we care about (including consistency, chain growth, and chain quality) hold for  <span class="math">\\Pi_{\\mathrm{hyb}}</span>  in exactly the same way they hold for  <span class="math">\\Pi_{\\mathrm{punctual}}</span> . Since  <span class="math">\\Pi_{\\mathrm{hyb}}</span>  carries real-world interfaces, we can later show that our real-world protocol  <span class="math">\\Pi_{\\mathrm{snowwhite}}</span>  emulates  <span class="math">\\Pi_{\\mathrm{hyb}}</span> ; and therefore the real-world protocol satisfies all these properties as well.</p>

    <p class="text-gray-300">Compliant  <span class="math">(\\mathcal{A},\\mathcal{Z})</span> . We say that  <span class="math">(\\mathcal{A},\\mathcal{Z})</span> <span class="math">\\Pi_{\\mathrm{hyb}}</span> -compliant if the following holds for any view with non-zero support:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialization. At the start of the execution, the following happens. First,  <span class="math">\\mathcal{Z}</span>  can spawn a set of either honest or corrupt nodes.  <span class="math">\\mathcal{Z}</span>  learns the honest nodes' public keys after calling their init()</li>

    </ul>

    <p class="text-gray-300">procedure. Next, <span class="math">\\mathcal{A}</span> provides the inputs <span class="math">\\{</span>genesis<span class="math">\\}</span> to all honest nodes. At this point, protocol execution starts.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sleeping. All sleepers are treated as light sleepers. Upon waking, all pending messages it should have received but did not receive are delivered, plus adversarially inserted messages.</li>

      <li>Spawning. When a new, alert node spawns at time <span class="math">t</span>, <span class="math">(\\mathcal{A},\\mathcal{Z})</span> must deliver to it an initialization message <span class="math">chain_{0}</span> such that <span class="math">chain_{0}\\in\\mathcal{F}_{\\text{punctual}}</span> and <span class="math">chain_{0}</span> is no shorter than the shortest chain of any alert node at time <span class="math">t-1</span>.</li>

      <li>A-prior commitment. <span class="math">\\mathcal{A}</span> must have called <span class="math">\\mathcal{F}_{\\text{punctual}}.\\texttt{setpids}(t,\\texttt{pids}_{t})</span> before <span class="math">t</span>. Similarly, <span class="math">\\mathcal{A}</span> must have called <span class="math">\\mathcal{F}_{\\text{punctual}}.\\texttt{sethash}(e,\\texttt{pids}_{e})</span> before <span class="math">\\texttt{start}(e)</span>.</li>

      <li>Corruption model, resilience, number of awake nodes, admissible parameters. Same as in <span class="math">\\Pi_{\\text{punctual}}</span>.</li>

    </ul>

    <h6 id="sec-62" class="text-base font-medium mt-4">Theorem 6 (Security of <span class="math">\\Pi_{\\text{hyb}}</span>).</h6>

    <p class="text-gray-300"><span class="math">\\Pi_{\\text{hyb}}</span> satisfies <span class="math">T_{0}</span>-consistency, <span class="math">(T_{0},\\mu)</span>-chain quality, and <span class="math">(T_{0},g_{0},g_{1})</span>-chain growth against any <span class="math">\\Pi_{\\text{hyb}}</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span> for the same parameters <span class="math">T_{0},\\mu,g_{0},g_{1}</span> as defined in Theorem 3.</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Follows in a straightforward manner from the security of <span class="math">\\Pi_{\\text{punctual}}</span>. ∎</p>

    <p class="text-gray-300">Remark: Agreement of <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span> timestamp and blockchain timestamp. We note that <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span> checks that the claimed timestamp agrees with the timestamp in the block <span class="math">B</span> when an adversary calls extend. Observe also that alert nodes always use truthful timestamps when calling <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}.\\texttt{extend}</span>. Due to this reason, henceforth, for any <span class="math">chain\\in\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span>, we may use its <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span>-timestamp and <span class="math">chain[-1].\\texttt{time}</span> interchangeably.</p>

    <h3 id="sec-64" class="text-xl font-semibold mt-8">G.4 Timestamp Freshness Lemma</h3>

    <p class="text-gray-300">We prove a useful property about timestamp freshness in any alert node’s chain. This will be useful in the next section when we prove that the real-world protocol emulates the hybrid-world. Roughly speaking, the timestamp freshness property says that in any alert node’s chain, the timestamp of any block cannot be too early relative to the position of the block in the chain. This will later be useful in Section H in proving that in a simulated execution, certain good events (whose occurrence depends on the existence of large timestamps in alert nodes’ chains) happen early enough.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Formally, we define a property <span class="math">\\texttt{freshtime}^{\\ell,r}(\\texttt{view})=1</span> iff the following holds for <span class="math">\\texttt{view}</span>: at any time <span class="math">t</span>, for any node <span class="math">i</span> alert at <span class="math">t</span> and suppose $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">chain_{i}^{t}(\\texttt{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\ell<span class="math">, then </span>chain_{i}^{t}(\\texttt{view})[-\\ell].\\texttt{time}>t-r$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-65" class="text-base font-medium mt-4">Claim 4 (Freshness of timestamp in stablized chain).</h6>

    <p class="text-gray-300">For any <span class="math">\\Pi_{\\text{hyb}}</span>-compliant p.p.t. pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, there exists a negligible function <span class="math">\\texttt{negl}(\\cdot)</span> such that for every <span class="math">\\kappa</span>, every <span class="math">\\epsilon,\\epsilon_{0}&gt;0</span>, every <span class="math">\\ell&gt;0</span>, let <span class="math">r=\\frac{\\ell+\\epsilon\\kappa}{g_{0}}</span> where <span class="math">g_{0}=(1-\\epsilon_{0})\\gamma</span>, it holds that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\texttt{view}\\leftarrow_{\\S}\\texttt{EXEC}^{\\Pi_{\\text{hyb}}}(\\mathcal{A},\\mathcal{Z},\\kappa):\\texttt{freshtime}^{\\ell,r}(\\texttt{view})=1\\right]\\geq 1-\\texttt{negl}(\\kappa)</span></p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">Below we ignore the negligible fraction of views where bad events such as failure of chain quality or chain growth happen.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">t&lt;r</span>, the claim trivially holds. We focus on proving the case where <span class="math">t\\geq r</span>. In this case, by chain growth, every node alert at time <span class="math">t</span> must have chain length at least <span class="math">\\ell+\\epsilon\\kappa</span>. By chain quality, in <span class="math">\\mathit{chain}^{t}_{i}[-(\\ell+\\epsilon\\kappa):-\\ell]</span> there must be a block mined by node <span class="math">j</span> honest at time <span class="math">t^{\\prime}</span> in view — by definition this means that node <span class="math">j</span> has chain length at least $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathit{chain}^{t}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-(\\ell+\\epsilon\\kappa)<span class="math"> at time </span>t^{\\prime}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By chain growth, we have that at most <span class="math">t-t^{\\prime}\\leq\\frac{\\ell+\\epsilon\\kappa}{g_{0}}=r</span> time has elapsed between <span class="math">t^{\\prime}</span> and <span class="math">t</span>. Since honest blocks contain true timestamps reflecting when the block is mined, there exists a block in <span class="math">B\\in\\mathit{chain}^{t}_{i}[-\\ell+\\epsilon\\kappa:-\\ell]</span> such that <span class="math">B.\\mathsf{time}\\geq t-r</span>. The rest of the proof is obvious by observing that timestamps must be strictly increasing in <span class="math">\\mathit{chain}^{t}_{i}</span> assuming <span class="math">i</span> is alert at <span class="math">t</span>.</p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Remark.</h6>

    <p class="text-gray-300">Henceforth, whenever we apply Claim 4 in our proofs, we will assume that <span class="math">g_{0}=(1-\\epsilon_{0})\\gamma</span> for an <span class="math">\\epsilon_{0}</span> that is appropriately small — it is not hard to identify such a <span class="math">\\epsilon_{0}</span> for all proofs that rely on Claim 4 henceforth — we therefore often omit spelling out <span class="math">g_{0}</span> as <span class="math">g_{0}=(1-\\epsilon_{0})\\gamma</span> for simplity.</p>

    <h2 id="sec-67" class="text-2xl font-bold">Appendix H Proofs: Real World is as Secure as the Hybrid World</h2>

    <h3 id="sec-68" class="text-xl font-semibold mt-8">H.1 Theorem Statement</h3>

    <h6 id="sec-69" class="text-base font-medium mt-4">Theorem 7 (<span class="math">\\Pi_{\\text{snowwhite}}</span> emulates <span class="math">\\Pi_{\\text{hyb}}</span> while preserving compliance).</h6>

    <p class="text-gray-300">For any real-world p.p.t. adversary <span class="math">\\mathcal{A}</span> for <span class="math">\\Pi_{\\text{snowwhite}}</span>, there exists a p.p.t. adversary (also called the simulator) <span class="math">\\mathcal{S}</span> for <span class="math">\\Pi_{\\text{hyb}}</span>, such that for any p.p.t. <span class="math">\\mathcal{Z}</span> satisfying the condition that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is <span class="math">\\Pi_{\\text{snowwhite}}</span>-compliant, we have that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathcal{S},\\mathcal{Z})</span> is <span class="math">\\Pi_{\\text{hyb}}</span>-compliant; and</li>

      <li><span class="math">\\mathsf{EXEC}^{\\Pi_{\\text{snowwhite}}}(\\mathcal{A},\\mathcal{Z},\\kappa)\\stackrel{{\\scriptstyle c}}{{=}}\\mathsf{EXEC}^{\\Pi_{\\text{hyb}}}(\\mathcal{S},\\mathcal{Z},\\kappa)</span></li>

    </ul>

    <p class="text-gray-300">In the above, both <span class="math">\\Pi_{\\text{snowwhite}}</span> and <span class="math">\\Pi_{\\text{hyb}}</span> (and specifically <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span>) are instantiated with “matching” parameters. More specifically, the following must be hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Both <span class="math">\\Pi_{\\text{snowwhite}}</span> and <span class="math">\\Pi_{\\text{hyb}}</span> (or more specifically <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span>) are instantiated with the same <span class="math">(p,T_{\\text{epoch}})</span>.</li>

      <li>Suppose <span class="math">W</span> is the posterior corruption parameter respected by the real-world adversary <span class="math">\\mathcal{A}</span>, it holds that in protocol <span class="math">\\Pi_{\\text{hyb}}</span>, <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span> is instantiated with the parameter <span class="math">W</span>.</li>

    </ul>

    <p class="text-gray-300">In this section, we prove the above Theorem 7.</p>

    <h3 id="sec-70" class="text-xl font-semibold mt-8">H.2 Simulator Construction</h3>

    <p class="text-gray-300">We first describe the construction of <span class="math">\\mathcal{S}</span>, which interacts in a blackbox manner with <span class="math">\\mathcal{A}</span>.</p>

    <h4 id="sec-71" class="text-lg font-semibold mt-6">Intended invariants by construction.</h4>

    <p class="text-gray-300">By construction, the simulator is meant to maintain the following invariants:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> keeps performing internal checks in every time step, and aborts whenever <span class="math">(\\mathcal{S},\\mathcal{Z})</span> is about to violate <span class="math">\\Pi_{\\text{hyb}}</span>’s compliance rules. In this way, as long as the simulation has not aborted, <span class="math">(\\mathcal{S},\\mathcal{Z})</span> is by construction <span class="math">\\Pi_{\\text{hyb}}</span>-compliant, and therefore we can use the security properties of <span class="math">\\Pi_{\\text{hyb}}</span> to reason about the simulated execution. Later, we will also show aborts will not happen except with negligible probability.</li>

    </ol>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Figure 10: AddtoTree subroutine internally called by  <span class="math">\\mathcal{S}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span>  always makes sure that any chain sent to alert nodes that would have been accepted by alert nodes in the real world must be in  <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}}</span> . In other words, if  <span class="math">\\mathcal{A}</span>  tries to send a chain to an alert node  <span class="math">i</span> ,  <span class="math">\\mathcal{S}</span>  will first emulate node  <span class="math">i</span> 's  <span class="math">\\Pi_{\\mathrm{snowwhite}}</span> -behavior to see if node  <span class="math">i</span>  might have accepted chain in the real-world protocol  <span class="math">\\Pi_{\\mathrm{snowwhite}}</span> . If so, then  <span class="math">\\mathcal{S}</span>  will make sure that chain is indeed in  <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}}</span>  before forwarding chain to  <span class="math">i</span> . This may mean that  <span class="math">\\mathcal{S}</span>  will need to call  <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}}.\\mathrm{extend}</span>  to insert new chains before forwarding chain to  <span class="math">i</span> .</li>

    </ol>

    <p class="text-gray-300">In this way, an essential step in showing the indistinguishability of the real-world and simulated executions is to argue that  <span class="math">\\mathcal{S}</span>  can always succeed in adding a chain to  <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}}</span>  if chain would have been accepted in the real-world by alert nodes (see Section H.4).</p>

    <p class="text-gray-300">Simulator description. For convenience, we introduce the syntactic sugar</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {\\mathcal {F}} _ {\\text {p u n c t u a l . s e t p i d s}} (e, \\operatorname {p i d s} _ {e})</span></div>

    <p class="text-gray-300">to allow  <span class="math">\\mathcal{S}</span>  to set the committee for each time step  <span class="math">t</span>  that is in epoch  <span class="math">e</span> , all with the same committee  <span class="math">\\mathsf{pids}_e</span> . Clearly  <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}}.\\mathsf{setpids}(e,\\mathsf{pids}_e)</span>  can be implemented by multiple calls to  <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}}.\\mathsf{setpids}(t,\\mathsf{pids}_t)</span> .</p>

    <p class="text-gray-300">Our simulator  <span class="math">\\mathcal{S}</span>  relies on a parameter  <span class="math">\\epsilon^{<em>} &amp;gt; 0</span> . Our proof will hold as long as  <span class="math">\\epsilon^{</em>}</span>  is sufficiently small, e.g., less than  <span class="math">\\frac{1}{4}</span> . Henceforth without loss of generality, the reader can assume that  <span class="math">\\epsilon^{<em>} = \\frac{1}{4}</span> . The security failure probability will be related to  <span class="math">\\epsilon^{</em>}</span> , e.g., in the form of  <span class="math">\\mathrm{negl}(\\mathrm{poly}(\\epsilon^{*},\\kappa))</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Whenever a party calls  <span class="math">\\mathcal{G}_{\\mathrm{sign}}</span> -gen, the adversary is notified of the pair  <span class="math">(\\mathcal{P}, \\mathsf{pk})</span> . It stores this party identifier and public key mapping. If an honest node's public key ever collides with a key that is already stored in the mapping, abort outputting duplicate-key-failure.</li>

      <li>Since  <span class="math">\\mathcal{S}</span>  sees all messages sent to and from honest nodes,  <span class="math">\\mathcal{S}</span>  can simulate the internal longest chain kept by all honest nodes in the most natural manner. Henceforth we assume that for any  <span class="math">t</span> , any  <span class="math">i</span>  honest at time  <span class="math">t</span> ,  <span class="math">\\mathcal{S}</span>  knows  <span class="math">\\text{chain}_i^t</span> .</li>

      <li>Whenever  <span class="math">\\mathcal{A}</span>  asks hash queries: if this query has been seen before,  <span class="math">\\mathcal{S}</span>  returns the same answer as before.</li>

    </ul>

    <p class="text-gray-300">se, suppose that the query is of the form <span class="math">\\mathsf{H}^{\\mathsf{nonce}}(\\mathsf{pk},t)</span>, let <span class="math">e=\\mathsf{epoch}(t)</span>: if <span class="math">\\mathcal{S}</span> has not yet committed to <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}}</span> the <span class="math">e</span>-th committee, then <span class="math">\\mathcal{S}</span> simply generates a random number of appropriate length, and returns it to <span class="math">\\mathcal{A}</span>. Else if <span class="math">\\mathcal{S}</span> has committed to <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}}</span> the <span class="math">e</span>-th committee, then <span class="math">\\mathcal{S}</span> generates a random number that agrees with <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}}</span>. Note that due to our simulator description later, if <span class="math">\\mathcal{S}</span> has committed to the <span class="math">e</span>-th committee, then there is a spawned party (either honest or corrupt) for each public keys in the <span class="math">e</span>-th committee, and the simulator <span class="math">\\mathcal{S}</span> must have this mapping stored.</p>

    <p class="text-gray-300">More specifically, <span class="math">\\mathcal{S}</span> first looks up the party identifier <span class="math">\\mathcal{P}</span> that corresponds to <span class="math">\\mathsf{pk}</span>. If such a party identifier is not found, <span class="math">\\mathcal{S}</span> samples a random number of appropriate length and returns it to <span class="math">\\mathcal{A}</span>. Else, <span class="math">\\mathcal{S}</span> calls <span class="math">b=\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}.}\\mathsf{leader}(\\mathsf{nonce},\\mathcal{P},t)</span>. If <span class="math">b=1</span>, it rejection samples an <span class="math">h</span> until <span class="math">h&lt;D_{p}</span>, and then returns <span class="math">h</span>. Else, it it rejection samples an <span class="math">h</span> until <span class="math">h\\geq D_{p}</span>, and then returns <span class="math">h</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Whenever <span class="math">\\mathcal{A}</span> sends a protocol message <em>chain</em> to an honest party <span class="math">i</span>, the simulator <span class="math">\\mathcal{S}</span> checks the validity of <em>chain</em> simulating node <span class="math">i</span> running the real-world protocol’s checks — here the hash function <span class="math">\\mathsf{H}</span> is implemented with <span class="math">\\mathcal{S}</span>’s own table. Specifically, <span class="math">\\mathcal{S}</span> answers its own <span class="math">\\mathsf{H}</span> queries in the same way that it answers <span class="math">\\mathcal{A}</span>’s <span class="math">\\mathsf{H}</span> queries. If these real-world checks pass, the simulator <span class="math">\\mathcal{S}</span> calls <span class="math">\\mathsf{AddtoTree}(chain)</span> as described in Figure 10. If the call does not abort outputting <span class="math">\\mathsf{signature}</span>-failure or <span class="math">\\mathsf{extend}</span>-failure, <span class="math">\\mathcal{S}</span> forwards <em>chain</em> to node <span class="math">i</span>.</li>

    </ul>

    <p class="text-gray-300">If the real-world checks fail, <span class="math">\\mathcal{S}</span> drops the message <em>chain</em> and does not forward <em>chain</em> to node <span class="math">i</span> — note that this may cause <span class="math">\\mathcal{S}</span> to violate the <span class="math">\\Delta</span> network delivery requirement. Therefore, as we describe later, <span class="math">\\mathcal{S}</span> will perform internal consistency checks, and if it ever violates the <span class="math">\\Delta</span> network delivery requirement, it simply aborts outputting <span class="math">\\Delta</span>-failure.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Whenever <span class="math">\\mathcal{A}</span> sends an initialization message <span class="math">\\{chain_{i}\\}_{i\\in L}</span> to an honest party <span class="math">i</span> that has just spawned or waken up from deep sleep: the simulator <span class="math">\\mathcal{S}</span> runs the real-world algorithm to compute an initial <em>chain</em> — as before, here the hash <span class="math">\\mathsf{H}</span> is implemented by <span class="math">\\mathcal{S}</span> itself. <span class="math">\\mathcal{S}</span> then calls <span class="math">\\mathsf{AddtoTree}(chain)</span>, and if the call did not abort with either <span class="math">\\mathsf{signature}</span>-failure or <span class="math">\\mathsf{extend}</span>-failure, <span class="math">\\mathcal{S}</span> sends <em>chain</em> to node <span class="math">i</span>.</li>

      <li>At the beginning of every time step <span class="math">t</span>, the simulator <span class="math">\\mathcal{S}</span> performs the following verification. First, if <span class="math">\\mathcal{S}</span> has not called <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}.}\\mathsf{setpids}(e,\\_)</span> or <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}.}\\mathsf{sethash}(e,\\_)</span> where <span class="math">e:=\\mathsf{epoch}(t)</span>, abort outputting <span class="math">\\mathsf{late}</span>-failure. The simulator additionally checks the resilience, number of awake nodes, and admissible parameter conditions for time step <span class="math">t</span>, and if the checks fail, abort outputting <span class="math">\\mathsf{param}</span>-failure.</li>

    </ul>

    <p class="text-gray-300">For each honest node <span class="math">i</span>, the simulator finds <span class="math">chain_{i}^{t}</span> henceforth denoted <span class="math">chain_{i}</span> for short. Recall that the simulator keeps track of the longest chain each honest node has.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Consistency checks</em>. For every node <span class="math">i</span> alert at time <span class="math">t</span>, <span class="math">\\mathcal{S}</span> computes <span class="math">\\mathsf{pks}_{i}:=\\mathsf{elect\\_cmt}^{t}(chain_{i})</span>. If both <span class="math">i</span> and <span class="math">j</span> are alert at <span class="math">t</span> but <span class="math">\\mathsf{pks}_{i}\\neq\\mathsf{pks}_{j}</span> abort outputting <span class="math">\\mathsf{consistency}</span>-failure. If <span class="math">\\mathsf{pks}_{i}</span> does not agree with the committee at <span class="math">t</span> which <span class="math">\\mathcal{S}</span> previously committed to <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}}</span>, abort outputting <span class="math">\\mathsf{consistency}</span>-failure. Here consistency is defined by <span class="math">\\mathcal{S}</span>’s internal public key to party identifier mapping.</li>

    </ul>

    <p class="text-gray-300">For every node <span class="math">i</span> alert at time <span class="math">t</span>, <span class="math">\\mathcal{S}</span> computes <span class="math">\\mathsf{nonce}_{i}:=\\mathsf{elect\\_h}^{t}(chain_{i})</span>. If <span class="math">\\mathsf{nonce}_{i}</span> does not agree with what <span class="math">\\mathcal{S}</span> previously committed to <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}}</span>, abort outputting <span class="math">\\mathsf{consistency}</span>-failure.</p>

    <p class="text-gray-300">###</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose next committee or hash when necessary. Henceforth let chain := chain<span class="math">{}_{i}^{t}</span>, note that <span class="math">\\mathcal{S}</span> checks all alert nodes' chains to see if it needs to choose the next committee or hash.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">chain</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\epsilon^{*}\\kappa + 2<span class="math">, </span>\\mathcal{S}<span class="math"> will check to see if it needs to commit to the next epoch&#x27;s committee and/or hash. Let </span>\\text{start}(e) := e \\cdot T_{\\text{epoch}}<span class="math"> denote the start of epoch </span>e \\in \\mathbb{N}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For any <span class="math">e \\in \\mathbb{N}</span>, if there exists consecutive blocks <span class="math">(B_0, B_1) \\in \\text{chain}[: -\\epsilon^*\\kappa]</span> such that <span class="math">B_1.\\text{time} + 2\\omega &amp;gt; \\text{start}(e)</span> but <span class="math">B_0.\\text{time} + 2\\omega \\leq \\text{start}(e)</span>, <span class="math">\\mathcal{S}</span> calls</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\widetilde{\\mathcal{F}}_{\\text{punctual.\\verb</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">setpids</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}(e, \\text{extractpids}(\\text{chain}_0)) \\text{ where } \\text{chain}_0 := \\text{chain}[: \\text{index}(B_0)]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">if it has not already called $\\widetilde{\\mathcal{F}}_{\\text{punctual.\\verb</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">setpids</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}(e, -)<span class="math"> earlier. Here extractpids(chain) first calls </span>\\mathsf{pks}^* := \\text{extractpks}(\\text{chain})$ and then maps the public keys to their party identifiers in the following way:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathcal{S}</span> has recorded <span class="math">(\\mathcal{P}, \\mathsf{pk})</span> then map <span class="math">\\mathsf{pk}</span> to <span class="math">\\mathcal{P}</span>. Recall that <span class="math">\\mathcal{S}</span> should have recorded such a mapping for all honest nodes' public keys.</li>

      <li>If <span class="math">\\mathcal{S}</span> has not recorded a mapping for <span class="math">\\mathsf{pk}</span>, spawn a corrupt node with party identifier <span class="math">j</span>, and map <span class="math">\\mathsf{pk}</span> to <span class="math">j</span>. Recall that our execution model allows <span class="math">\\mathcal{S}</span> to spawn corrupt nodes without <span class="math">\\mathcal{Z}</span>'s knowledge. Further <span class="math">\\mathcal{S}</span> stores the mapping from the party identifier <span class="math">j</span> to the public key <span class="math">\\mathsf{pk}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similarly, for any <span class="math">e \\in \\mathbb{N}</span>, if there exists consecutive blocks <span class="math">(B_0, B_1) \\prec \\text{chain}[: -\\epsilon^*\\kappa]</span> such that <span class="math">B_1.\\text{time} + \\omega &amp;gt; \\text{start}(e)</span> but <span class="math">B_0.\\text{time} + \\omega \\leq \\text{start}(e)</span>, <span class="math">\\mathcal{S}</span> calls $\\widetilde{\\mathcal{F}}_{\\text{punctual.\\verb</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sethash</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}(e, \\text{extractnonce}(\\text{chain}_0))<span class="math"> where </span>\\text{chain}_0 := \\text{chain}[: \\text{index}(B_0)]<span class="math"> if it has not already called </span>\\widetilde{\\mathcal{F}}_{\\text{punctual.\\verb</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sethash</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}(e, -)$ earlier.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At the end of every time step <span class="math">t</span>, <span class="math">\\mathcal{S}</span> performs a network delivery check. If it has ever received a message from some alert node by <span class="math">t - \\Delta</span>, but the message did not get delivered to any node alert at <span class="math">t</span>, then <span class="math">\\mathcal{S}</span> aborts outputting <span class="math">\\Delta</span>-failure.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Whenever <span class="math">\\mathcal{S}</span> calls $\\widetilde{\\mathcal{F}}_{\\text{punctual.\\verb</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sethash</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}(e, \\text{nonce}_e)<span class="math">, if </span>\\mathcal{A}<span class="math"> (or any internal call) has made a hash query of the form </span>\\mathsf{H}^{\\text{nonce}_e}(_{-}, -)<span class="math"> before </span>\\mathcal{S}<span class="math"> called </span>\\widetilde{\\mathcal{F}}_{\\text{punctual.\\verb</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">setpids</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}(e, -)$, abort outputting predict-failure.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathcal{A}</span> ever issues a <span class="math">(\\text{corrupt}, i, t&#x27;)</span> instruction to <span class="math">\\mathcal{Z}</span> at time <span class="math">t \\leq t&#x27;</span>, the simulator <span class="math">\\mathcal{S}</span> checks that it has not committed node <span class="math">i</span> to any committee at time <span class="math">t&#x27; - W</span> or later. If the check fails, <span class="math">\\mathcal{S}</span> aborts outputting corruption-failure. Else, <span class="math">\\mathcal{S}</span> passes through the instruction to <span class="math">\\mathcal{Z}</span>; further, <span class="math">\\mathcal{S}</span> queries <span class="math">\\mathcal{G}_{\\text{sign}}</span> to obtain the secret signing keys of party <span class="math">i</span>, and exposes them to <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <p class="text-gray-300">If <span class="math">\\mathcal{A}</span> ever issues a <span class="math">(\\text{sleep}, i, t_0, t_1)</span> instruction to <span class="math">\\mathcal{Z}</span> at time <span class="math">t \\leq t_0 \\leq t_1</span>, the simulator <span class="math">\\mathcal{S}</span> checks that it has not committed node <span class="math">i</span> to any committee between <span class="math">[t_0, t_1]</span>. If the check fails, <span class="math">\\mathcal{S}</span> aborts outputting corruption-failure; else, pass through the instruction to <span class="math">\\mathcal{Z}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> directly passes through all other messages between <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{G}_{\\mathrm{sign}}</span>. Similarly, <span class="math">\\mathcal{S}</span> directly passes through all other messages between <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{Z}</span>.</li>

      <li>At the protocol start, whenever <span class="math">\\mathcal{A}</span> sends <span class="math">\\mathsf{pks}_0</span> to a spawning node as part of the initialization message, <span class="math">\\mathcal{S}</span> registers the first epoch's committee with <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span>. Before doing so, if there is any public key in <span class="math">\\mathsf{pks}_0</span> that does not have a party identifier mapping, <span class="math">\\mathcal{S}</span> spawns a corrupt node that corresponds to this public key, and stores the mapping. <span class="math">\\mathcal{S}</span> also registers <span class="math">\\text{nonce}_0</span> with <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span> as the nonce for the first epoch at protocol start.</li>

      <li>If <span class="math">\\mathcal{S}</span> ever observes that two honest nodes have different chains with the same block hash, abort outputting hash-failure.</li>

    </ul>

    <p class="text-gray-300">57</p>

    <p class="text-gray-300">We can now immediately state a few simple facts.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Fact 2 (Compliant execution).</h6>

    <p class="text-gray-300">In the above simulation, for any p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> <span class="math">\\Pi_{\\text{snowwhite}}</span>-compliant, the pair <span class="math">(\\mathcal{S}^{\\mathcal{A}},\\mathcal{Z})</span> is <span class="math">\\Pi_{\\text{hyb}}</span>-compliant.</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By definition, notice that the construction of the simulator <span class="math">\\mathcal{S}</span> performed internal checks and always aborts outputting failure before it ever has a chance of being non-compliant. ∎</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Fact 3 (No hash collision).</h6>

    <p class="text-gray-300"><span class="math">\\mathcal{S}</span> does not abort with hash-failure except with negligible probability.</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Straightforward due to the collision resistance of the digest function d. ∎</p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Fact 4 (No honest key collision).</h6>

    <p class="text-gray-300"><span class="math">\\mathcal{S}</span> does not abort with duplicate-key-failure except with negligible probability.</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Straightforward due to the security of the signature scheme. ∎</p>

    <p class="text-gray-300">Due to the above facts, henceforth we will ignore the negligible fraction of views that have hash or honest key collisions.</p>

    <h3 id="sec-78" class="text-xl font-semibold mt-8">H.3 Consistency and Compliance of the Simulated Execution</h3>

    <p class="text-gray-300">In this section, we focus on showing that if <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is <span class="math">\\Pi_{\\text{snowwhite}}</span>-compliant, then the simulated execution has nice properties regarding consistency and the relative timing of events.</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Lemma 4 (Consistency and a-priori commitment).</h6>

    <p class="text-gray-300">For any compliant p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair, there exists a negligible function negl such that for every <span class="math">\\kappa</span></p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\texttt{view}\\leftarrow{}_{\\#}\\texttt{EXEC}^{\\Pi_{\\text{hyb}}}(\\mathcal{S}^{\\mathcal{A}},\\mathcal{Z},\\kappa):\\texttt{view}\\text{ aborts due to late-failure or consistency-failure}\\right]\\leq\\textsf{negl}(\\kappa)</span></p>

    <h6 id="sec-80" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We consider any view for <span class="math">\\texttt{EXEC}^{\\Pi_{\\text{hyb}}}(\\mathcal{S},\\mathcal{Z},\\kappa)</span> where none of the bad events related to chain quality, growth, and consistency happen.</p>

    <p class="text-gray-300">We prove the lemma for hashes, and the argument for the committee goes in the same way. It suffices to prove the following: For any <span class="math">e\\in\\mathbb{N}</span> in view, let <span class="math">t=\\texttt{start}(e)</span>, it holds that for every node <span class="math">i</span> honest at time <span class="math">t-1</span>, there exists</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>an honest block <span class="math">B\\in\\text{chain}_{i}^{t-1}[:-\\epsilon^{*}\\kappa]</span> with <span class="math">B.\\texttt{time}&gt;t-\\omega</span>; and</li>

      <li>an honest block <span class="math">B^{\\prime}\\in\\text{chain}_{i}^{t-1}[:-\\epsilon^{*}\\kappa]</span> with <span class="math">B^{\\prime}.\\texttt{time}\\leq t-\\omega</span>.</li>

    </ol>

    <p class="text-gray-300">where <span class="math">\\text{chain}_{i}^{t-1}(\\texttt{view})</span> denotes the internal chain maintained by node <span class="math">i</span> at time <span class="math">t-1</span> in view. We often write <span class="math">\\text{chain}_{i}^{t-1}</span> in place of <span class="math">\\text{chain}_{i}^{t-1}(\\texttt{view})</span> without risk of ambiguity.</p>

    <p class="text-gray-300">Notice that due to the definition of <span class="math">\\mathcal{S}</span> which runs the real-world checks on any <em>chain</em> received from <span class="math">\\mathcal{A}</span> before forwarding them onto honest nodes, and due to the definition of <span class="math">\\Pi_{\\text{hyb}}</span>, <span class="math">\\text{chain}_{i}^{t-1}</span> must have strictly increasing timestamps. Therefore if the above conditions regarding the existence of <span class="math">B</span> and <span class="math">B^{\\prime}</span> in <span class="math">\\text{chain}_{i}^{t-1}</span> are satisfied then</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> will have called <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}.\\texttt{sethash}(e,\\_)</span> before time <span class="math">t</span>;</li>

      <li>Due to consistency and definition of <span class="math">\\mathcal{S}</span>, <span class="math">\\mathcal{S}</span> will not abort with consistency-failure due to disagreement on the hash for epoch <span class="math">e</span> in view.</li>

    </ul>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Notice that the existence of the block <span class="math">B&#x27;</span> trivially holds since the genesis block is defined to have a timestamp of 0. The existence of a block <span class="math">B</span> is proved in Claim 4 given that <span class="math">\\omega \\geq \\frac{2\\kappa}{\\gamma} + \\widetilde{\\Delta}</span>. This completes our proof.</p>

    <p class="text-gray-300">Lemma 5 (Unpredictability of future hashes). For any compliant p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair, there exists a negligible function <span class="math">\\mathrm{negl}</span> such that for every <span class="math">\\kappa</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\text{view} \\leftarrow_ {\\S} \\text{EXEC}^{\\Pi_{\\mathrm{hyb}}} \\left(\\mathcal{S}^{\\mathcal{A}}, \\mathcal{Z}, \\kappa\\right): \\text{view aborts due to predict-failure} \\right] \\leq \\operatorname{negl} (\\kappa)</span></div>

    <p class="text-gray-300">Proof. Given a view <span class="math">\\leftarrow</span> EXEC<span class="math">^{\\Pi_{\\mathrm{hyb}}}</span> <span class="math">(\\mathcal{S}^{\\mathcal{A}},\\mathcal{Z})</span> where none of the bad events related to chain quality, growth, consistency happen. Let <span class="math">e\\in \\mathbb{N}</span> denote an epoch in view such that <span class="math">\\mathcal{S}</span> has called <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}}.\\mathrm{sethash}(e, - )</span>. Note that by definition, <span class="math">\\mathcal{S}</span> must have called <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}}.\\mathrm{setpids}(e, - )</span> too. Let <span class="math">T = \\mathrm{start}(e)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Henceforth in this proof we shall adopt small enough constants <span class="math">\\epsilon_0</span> and <span class="math">\\epsilon&#x27;</span>. The proof holds for any constant small enough. For example, one may assume <span class="math">\\epsilon_0 = \\epsilon&#x27; = 1/8</span>.</li>

      <li>Let <span class="math">chain_i^t(\\text{view})</span> be the chain that triggered <span class="math">\\mathcal{S}</span> to call <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}.\\text{sethash}(e, -)</span>, where <span class="math">i</span> is a node honest at time <span class="math">t</span>. Let <span class="math">(B_{-1}^<em>, B^</em>)</span> be two consecutive blocks in <span class="math">chain_i^t[: -\\epsilon^<em>\\kappa]</span>, where <span class="math">B^</em>.\\text{time} &amp;gt; T - \\omega</span> and <span class="math">B_{-1}^* \\leq T - \\omega</span>.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">B_{l}</span> denote the last honest block to the left of <span class="math">B^{<em>}</span> in <span class="math">chain_{i}^{t}</span> that is not genesis. We will first pretend that such a block <span class="math">B_{l}</span> exists, and later we will prove that indeed it does. Let <span class="math">B_{r} \\in chain_{i}^{t}[\\mathrm{index}(B^{</em>}):]</span> be the first honest block to the right of <span class="math">B^{<em>}</span> — such a block must exist due to chain quality, and that there are at least <span class="math">\\epsilon^{</em>}\\kappa</span> blocks to the right of <span class="math">B^{<em>}</span>. By chain quality, <span class="math">\\mathrm{index}(B_{r}) - \\mathrm{index}(B^{</em>}) \\leq \\epsilon_{0}\\kappa</span> in <span class="math">chain_{i}^{t}</span>, and <span class="math">\\mathrm{index}(B^{<em>}) - \\mathrm{index}(B_{l}) \\leq \\epsilon_{0}\\kappa</span> in <span class="math">chain_{i}^{t}</span>. Therefore, <span class="math">\\mathrm{index}(B_{r}) - \\mathrm{index}(B_{l}) \\leq 2\\epsilon_{0}\\kappa</span>. Further, since <span class="math">B_{l}</span> is honest, <span class="math">T_{1} := B_{l}</span>. time is the time when an honest node first mines <span class="math">B_{l}</span>. Similarly, <span class="math">T_{2} := B_{r}</span>. time is the time when an honest node first mines <span class="math">B_{r}</span>. By chain growth, <span class="math">T_{2} - T_{1} \\leq \\frac{2\\epsilon_{0}\\kappa}{g_{0}}</span>. By definition, we also know that <span class="math">T_{1} \\leq B^{</em>}</span>. time <span class="math">\\leq T_{2}</span>, and therefore <span class="math">B^{<em>}</span>. time <span class="math">-T_{1} \\leq \\frac{2\\epsilon_{0}\\kappa}{g_{0}}</span>, i.e., <span class="math">T_{1} \\geq B^{</em>}</span>. time <span class="math">-\\frac{2\\epsilon_{0}\\kappa}{g_{0}} &amp;gt; T - \\omega - \\frac{2\\epsilon_{0}\\kappa}{g_{0}}</span>.</p>

    <p class="text-gray-300">For the above bound on <span class="math">T_{1}</span> to hold, it remains to show that such a <span class="math">B_{l}</span> exists. To show this, we prove that there is a constant <span class="math">\\epsilon&#x27; &amp;gt; 0</span> such that <span class="math">\\mathrm{index}(B^{<em>})</span> (w.r.t. <span class="math">chain_{i}^{t}</span>) is greater than <span class="math">\\epsilon&#x27; \\kappa</span>, since then <span class="math">B_{l}</span> must exist by chain quality. Suppose for the sake of contradiction that <span class="math">\\mathrm{index}(B^{</em>}) &amp;lt; \\epsilon&#x27; \\kappa</span>. As before, let <span class="math">B_{r}</span> be the first honest block to the right of <span class="math">B^{<em>}</span> in <span class="math">chain_{i}^{t}</span>. Such a <span class="math">B_{r}</span> must exist within at most <span class="math">\\epsilon_{0} \\kappa</span> blocks from <span class="math">B^{</em>}</span>. Therefore <span class="math">\\mathrm{index}(B_{r}) &amp;lt; (\\epsilon&#x27; + \\epsilon_{0}) \\kappa</span>. Since <span class="math">B_{r}</span> is an honest block, <span class="math">B_{r}</span>. time denotes the time <span class="math">B_{r}</span> was first mined by an honest node. By chain growth, <span class="math">B_{r}</span>. time <span class="math">\\leq \\frac{(\\epsilon&#x27; + \\epsilon_{0}) \\kappa}{g_{0}}</span>. Since <span class="math">T \\geq T_{\\mathrm{epoch}} \\geq 3\\omega \\geq \\frac{3\\kappa}{g_{0}}</span>, it holds that for sufficiently small constants <span class="math">\\epsilon&#x27;, \\epsilon_{0} &amp;gt; 0</span>,</p>

    <div class="my-4 text-center"><span class="math-block">B^{*}. \\text{time} \\leq B_{r}. \\text{time} \\leq \\frac{(\\epsilon&#x27; + \\epsilon_{0}) \\kappa}{g_{0}} \\leq T - \\omega</span></div>

    <p class="text-gray-300">Therefore we reach a contradiction.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">T_0</span> be the time in view that <span class="math">\\mathcal{S}</span> called <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}}.\\mathrm{setpids}(e, -)</span>. We now show that <span class="math">T_0 \\leq T - 1.5\\omega</span>. It is not hard to see that <span class="math">\\mathcal{S}</span> will definitely have called <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}}.\\mathrm{setpids}(e, -)</span> by time <span class="math">t</span>, if there is a node <span class="math">i</span> honest at <span class="math">t - 1</span>, such that <span class="math">chain_i^{t-1}[: -\\epsilon^*\\kappa]</span> contains a block whose timestamp is greater than <span class="math">T - 2\\omega</span> where <span class="math">T = \\mathrm{start}(e)</span>.</li>

    </ul>

    <p class="text-gray-300">59</p>

    <p class="text-gray-300">By Claim 4, let <span class="math"> r = T - 1.5\\omega \\geq 1.5\\omega </span>, for every node <span class="math"> i </span> honest at <span class="math"> r - 1 </span>, chain_{t}^{r-1}[: -\\epsilon^{<em>}\\kappa] <span class="math"> must contain a block whose timestamp is greater than </span> r - \\frac{\\omega}{2} = T - 2\\omega <span class="math"> — notice that this relies on our choice of </span> \\epsilon^{</em>} <span class="math"> being sufficiently small. This suffices for showing that </span> T_0 \\leq T - 1.5\\omega $.</p>

    <p class="text-gray-300">Given our <strong>extractnonce</strong> definition, it suffices to prove that <span class="math"> T_{1} &amp;gt; T_{0} </span>. Recall that <span class="math"> T_{1} </span> is the time the honest block <span class="math"> B_{l} </span> is mined, and the block <span class="math"> B_{l} </span> contains a random string that is unpredictable any time before <span class="math"> T_{1} </span>. We now show that indeed <span class="math"> T_{1} &amp;gt; T_{0} </span>. Observe that since <span class="math"> T \\geq T_{\\mathrm{epoch}} </span> and <span class="math"> T_{\\mathrm{epoch}} \\geq 3\\omega </span>, and that for small enough <span class="math"> \\epsilon_0 </span>, <span class="math"> \\frac{2\\epsilon_0\\kappa}{g_0} &amp;lt; 0.5\\omega </span>, it clearly holds that <span class="math"> T_{1} &amp;gt; T_{0} </span>.</p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300"><strong>Lemma 6</strong> (Simulator respects <span class="math"> \\Delta </span>-network delivery). For any compliant p.p.t. <span class="math"> (\\mathcal{A}, \\mathcal{Z}) </span> pair, there exists a negligible function <strong>negl</strong> such that for every <span class="math"> \\kappa </span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\text{view} \\leftarrow_{\\S} \\text{EXEC}^{\\Pi_{\\text{hyb}}} \\left(\\mathcal{S}^{\\mathcal{A}}, \\mathcal{Z}, \\kappa\\right): \\text{view aborts due to } \\Delta - \\text{failure} \\right] \\leq \\text{negl}(\\kappa)</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> Fix some view <span class="math">\\leftarrow</span> EXEC <span class="math">^{\\Pi_{\\mathrm{hyb}}}(\\mathcal{S}^{\\mathcal{A}},\\mathcal{Z},\\kappa)</span> where none of the bad events related to chain growth, chain quality, and consistency happen. Suppose that a node <span class="math"> i </span> alert at <span class="math"> t </span> sends a <span class="math"> chain_{i}^{t} </span> at time <span class="math"> t </span> in view. Due to the <span class="math"> \\Pi_{\\mathrm{snowwhite}} </span>-compliance of <span class="math"> (\\mathcal{A},\\mathcal{Z}) </span>, for every node that is alert at <span class="math"> t + \\Delta </span>, <span class="math"> \\mathcal{A} </span> will ask <span class="math"> \\mathcal{S} </span> to deliver <span class="math"> chain_{i}^{t} </span> to node <span class="math"> j </span> at some <span class="math"> t_{j}\\in [t,t + \\Delta] </span>.</p>

    <p class="text-gray-300">Clearly, <span class="math"> chain_{i}^{t} \\in \\widetilde{\\mathcal{F}}_{\\mathrm{punctual}} </span> starting at time <span class="math"> t </span> in view. Due to consistency, for any node <span class="math"> j </span> that is alert at sometime <span class="math"> s \\in [t,t + \\Delta] </span>, including ones that might have just waken up from a light sleep, it must hold that <span class="math"> chain_{j}^{s}[: -\\kappa_{0}] \\prec chain_{i}^{t} </span>. Therefore, <span class="math"> j </span>'s real-world checks will not cause <span class="math"> j </span> to reject <span class="math"> chain_{i}^{t} </span> had <span class="math"> j </span> received <span class="math"> chain_{i}^{t} </span> at any <span class="math"> s \\in [t,t + \\Delta] </span>. As a result, <span class="math"> \\mathcal{S} </span> will not drop this message <span class="math"> chain_{i}^{t} </span>.</p>

    <p class="text-gray-300"><strong>Lemma 7</strong> (Compliant corruptions). For any compliant p.p.t. <span class="math"> (\\mathcal{A}, \\mathcal{Z}) </span> pair, there exists a negligible function <strong>negl</strong> such that for every <span class="math"> \\kappa </span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\text{view} \\leftarrow_{\\S} \\text{EXEC}^{\\Pi_{\\text{hyb}}} \\left(\\mathcal{S}^{\\mathcal{A}}, \\mathcal{Z}, \\kappa\\right): \\text{view aborts due to corruption-failure} \\right] \\leq \\text{negl}(\\kappa)</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> Suppose that <span class="math"> \\mathcal{A} </span> issues <span class="math"> (\\text{corrupt}, i, t&#x27;) </span> at some time <span class="math"> t </span>. Since <span class="math"> (\\mathcal{A}, \\mathcal{Z}) </span> is <span class="math"> \\Pi_{\\text{snowwhite}} </span>-compliant <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span></p>

    <p class="text-gray-300">Notice that the only way <span class="math"> \\mathcal{S} </span> could have called <span class="math"> \\widetilde{\\mathcal{F}}_{\\text{punctual}}.\\text{setpids}(s, -) </span> by time <span class="math"> t </span> is if there is a node <span class="math"> i </span> honest at <span class="math"> t </span> such that <span class="math"> chain_{i}^{t}[: -\\epsilon^{*}\\kappa] </span> contains a block <span class="math"> B </span> such that <span class="math"> B.\\text{time} &amp;gt; \\text{rnddown}(s) - 2\\omega &amp;gt; s - T_{\\text{epoch}} - 2\\omega </span>. This means that <span class="math"> \\mathcal{S} </span> can only have called <span class="math"> \\widetilde{\\mathcal{F}}_{\\text{punctual}}.\\text{setpids}(s, -) </span> by time <span class="math"> t </span> if <span class="math"> t \\geq s - T_{\\text{epoch}} - 2\\omega </span>. If <span class="math"> s \\geq t&#x27; - W </span>, this means that <span class="math"> t \\geq t&#x27; - W - T_{\\text{epoch}} - 2\\omega </span>. However, we also know that <span class="math"> t &amp;lt; t&#x27; - \\tau </span>. Since <span class="math"> \\tau &amp;gt; W + T_{\\text{epoch}} + 2\\omega </span>, it cannot be the case that <span class="math"> t \\geq t&#x27; - W - T_{\\text{epoch}} - 2\\omega </span>; and therefore <span class="math"> \\mathcal{S} </span> cannot have called <span class="math"> \\widetilde{\\mathcal{F}}_{\\text{punctual}}.\\text{setpids}(s, -) </span> for any time <span class="math"> s \\in [t&#x27; - W, \\infty] </span>.</p>

    <p class="text-gray-300">Similarly, suppose that <span class="math"> \\mathcal{A} </span> issues <span class="math"> (\\text{sleep}, i, t&#x27;) </span> at some time <span class="math"> t </span>. Since <span class="math"> (\\mathcal{A}, \\mathcal{Z}) </span> is <span class="math"> \\Pi_{\\text{snowwhite}} </span>-compliant <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span> <span class="math"> </span></p>

    <p class="text-gray-300">[ \\text{snowwhite} ] \\leq \\text{negl}(\\kappa) ]</p>

    <p class="text-gray-300"><strong>Proof.</strong> Straightforward to verify.</p>

    <p class="text-gray-300">H.4 All Real-World Valid Chains are in <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span></p>

    <p class="text-gray-300">In this section, we show that for any chain that would have been accepted by an honest node by the real-world verification algorithm, <span class="math">\\mathcal{S}</span> must succeed in adding it to <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span> if the chain does not exist in <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span> already.</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Lemma 9 (Unforgeability of signatures).</h6>

    <p class="text-gray-300">For any compliant p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair, there exists a negligible function <span class="math">\\mathsf{negl}</span> such that for every <span class="math">\\kappa</span></p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow_{\\S}\\mathsf{EXEC}^{\\Pi_{\\text{hyb}}}(\\mathcal{S}^{\\mathcal{A}},\\mathcal{Z},\\kappa):\\mathsf{view}\\text{ aborts due to signature-failure}\\right]\\leq\\mathsf{negl}(\\kappa)</span></p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Straightforward reduction to the security of the signature scheme. Conditioned on no hash collision, if there is ever <span class="math">\\mathsf{signature}\\text{-}\\mathsf{failure}</span>, the adversary <span class="math">\\mathcal{A}</span> must have forged a signature on a new message that the simulator <span class="math">\\mathcal{S}</span> has not sent <span class="math">\\mathcal{A}</span>. We can easily leverage such an adversary <span class="math">\\mathcal{A}</span> to build a reduction to break signature security. More specifically, the reduction will simulate <span class="math">\\mathcal{G}_{\\text{sign}}</span>, honest parties, and <span class="math">\\mathcal{S}</span> and interact with <span class="math">(\\mathcal{A},\\mathcal{Z})</span>. The reduction will guess at random which honest party’s which signature key the adversary will break, and embed the instance from the signature challenger there. Note also that <span class="math">\\mathcal{G}_{\\text{sign}}</span> is a global functionality, however, the environment <span class="math">\\mathcal{Z}</span> cannot query <span class="math">\\mathcal{G}_{\\text{sign}}</span> for signatures pertaining to the challenge session identifier — this is important for the reduction to work. ∎</p>

    <h4 id="sec-83" class="text-lg font-semibold mt-6">Simulation valid chains.</h4>

    <p class="text-gray-300">Given a <span class="math">\\mathsf{view}</span> of the simulated execution, we say that a <em>chain</em> is <em>simulation valid</em> w.r.t. time <span class="math">t</span> in <span class="math">\\mathsf{view}</span> if it is valid as defined in the real-world protocol, but where the hash function <span class="math">\\mathsf{H}</span> is replaced by hash queries to the simulator <span class="math">\\mathcal{S}</span>. The simulator <span class="math">\\mathcal{S}</span> answers these hash queries in the same way it answers <span class="math">\\mathcal{A}</span>’s hash queries.</p>

    <h4 id="sec-84" class="text-lg font-semibold mt-6">Sufficiently long honest prefix.</h4>

    <p class="text-gray-300">Given a <span class="math">\\mathsf{view}</span> of the simulated execution, we say that a simulation valid <em>chain</em> (w.r.t. <span class="math">t</span>) has a sufficiently long honest prefix at time <span class="math">t</span> in <span class="math">\\mathsf{view}</span>, iff</p>

    <p class="text-gray-300"><span class="math">\\text{There exists a prefix }chain_{0}\\prec chain\\text{ such that }chain_{0}[-1].\\mathsf{time}&gt;t-\\omega\\text{, and moreover, there exists }s\\leq t\\text{ and a node }i\\text{ alert at time }s\\text{, such that }chain_{0}\\prec chain_{i}^{s}[:-\\epsilon^{*}\\kappa].</span></p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Claim 5.</h6>

    <p class="text-gray-300">Let <em>chain</em> be simulation valid in <span class="math">\\mathsf{view}</span> at time <span class="math">t</span>, and suppose that <em>chain</em> has a sufficiently long honest prefix at <span class="math">t</span>. It holds that the following two ways for determining whether a public key <span class="math">\\mathsf{pk}</span> is a leader in any time <span class="math">r\\leq t</span> are equivalent in the simulated execution:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Using the real-world <span class="math">\\mathsf{eligible}^{r}(chain,\\mathsf{pk})</span> function where <span class="math">\\mathsf{H}</span> is implemented by <span class="math">\\mathcal{S}</span>; and</li>

      <li>Calling <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}.}\\mathsf{leader}(\\mathsf{nonce}^{r},\\mathcal{P},r)</span> where <span class="math">\\mathsf{nonce}^{r}</span> denotes the nonce previously chosen by <span class="math">\\mathcal{S}</span> for time step <span class="math">r</span>, and <span class="math">\\mathcal{P}</span> is the party identifier corresponding to <span class="math">\\mathsf{pk}</span> (as determined by <span class="math">\\mathcal{S}</span>’s stored mapping) — if no such mapping is found, then <span class="math">\\mathcal{P}</span> is simply <span class="math">\\bot</span>.</li>

    </ol>

    <h6 id="sec-86" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Recall that if the simulation does not abort, there is no <span class="math">\\mathsf{duplicate}\\text{-}\\mathsf{key}\\text{-}\\mathsf{failure}</span>. If <span class="math">r&lt;T_{\\text{epoch}}</span>, <span class="math">\\mathsf{pks}_{0}</span> will be selected as the committee by the real-world algorithm, and recall that <span class="math">\\mathcal{S}</span> has registered with <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span> the party identifiers for <span class="math">\\mathsf{pks}_{0}</span> as the initial committee.</p>

    <p class="text-gray-300">The more interesting case is when <span class="math">r\\geq T_{\\text{epoch}}\\geq 3\\omega</span>. In this case, since <span class="math">chain_{0}[-1].\\mathsf{time}&gt;t-\\omega</span>, the prefix that determines the committee or hash for any <span class="math">r\\leq t</span> must be contained in <span class="math">chain_{0}</span>. Due to consistency and the definition of <span class="math">\\mathcal{S}</span>, it holds that the committee for any <span class="math">r\\leq t</span> determined by the</p>

    <p class="text-gray-300">real-world algorithm based on <em>chain</em> must agree with what <span class="math">\\mathcal{S}</span> committed to <span class="math">\\widetilde{\\mathcal{F}}_{\\textup{punctual}}</span>. Similarly, <span class="math">\\mathcal{S}</span> must have committed to <span class="math">\\widetilde{\\mathcal{F}}_{\\textup{punctual}}</span> the same nonce for each <span class="math">r\\leq t</span> as what the real-world algorithm would output as the nonce for each <span class="math">r\\leq t</span> based on <em>chain</em>.</p>

    <p class="text-gray-300">Further, due to no predict-failure, consistency, and the way <span class="math">\\mathcal{S}</span> answers H queries, it holds that using H to elect leaders agrees with the random coins used by <span class="math">\\widetilde{\\mathcal{F}}_{\\textup{punctual}}</span> for electing leaders. ∎</p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Claim 6.</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathcal{A},\\mathcal{Z})</span> be <span class="math">\\Pi_{\\textup{snowwhite}}</span>-compliant. Given any view of <span class="math">\\mathsf{EXEC}^{\\Pi_{\\textup{hyb}}}(\\mathcal{S}^{\\mathcal{A}},\\mathcal{Z},\\kappa)</span>, let <em>chain</em> be a simulation valid chain w.r.t. time <span class="math">t</span> in view, and suppose that <em>chain</em> has a sufficiently long honest prefix at <span class="math">t</span> in view. Then if <span class="math">\\mathcal{S}^{\\mathcal{A}}</span> calls <span class="math">\\mathsf{AddtoTree}(\\mathit{chain})</span> at time <span class="math">t</span> in view, the call must succeed.</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">First, since <span class="math">\\mathit{chain}_{0}[-1].\\mathsf{time}&gt;t-\\omega</span>, and <span class="math">W&gt;\\omega</span>, and since timestamps must strictly increase for a simulation valid chain, it is clear that none of the adversarial blocks at the end will be rejected by <span class="math">\\widetilde{\\mathcal{F}}_{\\textup{punctual}}</span> due to staleness. The rest of proof follows in a straightforward manner due to Claim 5 and no signature-failure.</p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-89" class="text-base font-medium mt-4">Claim 7.</h6>

    <p class="text-gray-300">In the simulated execution, if <span class="math">\\mathcal{S}</span> sends a <em>chain</em> to an alert node, then <em>chain</em> must be simulation valid at <span class="math">t</span> and have a sufficiently long prefix at <span class="math">t</span>.</p>

    <h6 id="sec-90" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We now prove the above lemma. Recall that <span class="math">\\mathcal{S}</span> simulates the real-world verification algorithm for node <span class="math">i</span>, and only forwards a <em>chain</em> to alert node <span class="math">i</span> if the real-world checks succeed. It suffices to prove that if the real-world checks pass, then the chain has a sufficiently long prefix.</p>

    <p class="text-gray-300">There are three possible scenarios, and we analyze them one by one.</p>

    <p class="text-gray-300">Case 1: <span class="math">\\mathcal{A}</span> sends <em>chain</em> to a node <span class="math">i</span> that has been alert. This case is very similar to Case 2, except that the <span class="math">\\widetilde{\\Delta}</span> in Case 2 is now replaced with <span class="math">\\Delta</span>. By our parameter admissible rules, it is not hard to see that <span class="math">\\Delta\\leq\\frac{1}{2\\gamma}</span>. The rest of the proof follows in the same way as Case 2.</p>

    <p class="text-gray-300">Case 2: <span class="math">\\mathcal{A}</span> sends <em>chain</em> to node <span class="math">i</span> that has just waken up after a light sleep. Suppose that at time <span class="math">t</span>, <span class="math">\\mathcal{A}</span> wants to send <em>chain</em> to honest node <span class="math">i</span> who has waken up at time <span class="math">t</span> after a short sleep, and let <span class="math">s</span> denote the most recent time node <span class="math">i</span> went to sleep before <span class="math">t</span>. By <span class="math">\\Pi_{\\textup{snowwhite}}</span>-compliance, we know that <span class="math">t-s\\leq\\widetilde{\\Delta}</span>.</p>

    <p class="text-gray-300">We know that it must be the case <span class="math">\\mathit{chain}_{i}^{s}[:-\\kappa_{0}]\\prec\\mathit{chain}</span> for <em>chain</em> to be accepted by node <span class="math">i</span>’s real-world checks. Also observe that by Claim 4, <span class="math">\\mathit{chain}_{i}^{s}[-\\kappa_{0}].\\mathsf{time}&gt;s-\\frac{\\kappa}{g_{0}}\\geq t-\\widetilde{\\Delta}-\\frac{\\kappa}{g_{0}}\\geq t-\\omega</span>.</p>

    <p class="text-gray-300">Case 3: <span class="math">\\mathcal{A}</span> sends a newly spawned node <span class="math">i</span> an initialization message. Fix any view of non-zero support in the execution <span class="math">\\mathsf{EXEC}^{\\Pi_{\\textup{hyb}}}(\\mathcal{S}^{\\mathcal{A}},\\mathcal{Z},\\kappa)</span>. All of the following statements are with respect to this view. Given a set <span class="math">S_{L}:=\\{chain_{i}\\}_{i\\in L}</span>, we say that a <em>chain</em> is real-world admissible w.r.t. <span class="math">S_{L}</span> if 1) <em>chain</em> is simulation valid; 2) <em>chain</em> <span class="math">\\prec</span> <em>chain_{i}</em> for some <span class="math">i\\in L</span>; and 3) let <em>chain^{′}</em> be the longest common prefix of any majority subset of <span class="math">S</span>, it holds that <em>chain^{′}</em> <span class="math">\\prec</span> <em>chain</em>.</p>

    <p class="text-gray-300">Suppose <span class="math">L</span> is a node set the majority of whom are alert at time <span class="math">t</span>. Suppose that <em>chain</em> is real-world admissible w.r.t. <span class="math">S_{L}</span>. Now we take the set of honest nodes in <span class="math">L</span> and compute the longest prefix of their chains; and <em>chain_{h}</em> denote this longest prefix. Suppose the aforementioned <em>chain^{′}</em> is computed by taking a subset <span class="math">S^{\\prime}\\subseteq S_{L}</span> that comprise majority. Since the majority are alert at time <span class="math">t</span> in <span class="math">L</span>, one alert node must exist in <span class="math">S^{\\prime}</span>. Clearly <em>chain^{′}</em> should be at least as long as <em>chain_{h}</em>. Therefore we conclude that <em>chain_{h}</em> <span class="math">\\prec</span> <em>chain^{′}</em>.</p>

    <p class="text-gray-300">It suffices to argue that <span class="math">\\mathit{chain}_{h}[-\\epsilon^{<em>}\\kappa].\\mathsf{time}&gt;t-\\omega</span>. Let <span class="math">i\\in L</span> be a node alert at time <span class="math">t</span>, we know that <span class="math">\\mathit{chain}_{h}\\prec\\mathit{chain}_{i}^{t}</span>. Due to consistency, there cannot be more than <span class="math">\\epsilon_{1}\\kappa</span> blocks after </em>chain_{h}<em> in </em>chain<span class="math">{}_{i}^{t}</span><em>. Now the fact that <span class="math">\\mathit{chain}_{h}[-\\epsilon^{</em>}\\kappa].\\mathsf{time}&gt;t-\\omega</span> follows from Claim 4.</p>

    <p class="text-gray-300"><span class="math">\\Box</span></p>

    <h6 id="sec-91" class="text-base font-medium mt-4">Lemma 10 (Success of AddtoTree).</h6>

    <p class="text-gray-300">For any compliant p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair, there exists a negligible function <span class="math">\\mathsf{negl}</span> such that for every <span class="math">\\kappa</span></p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow_{\\S}\\mathsf{EXEC}^{\\Pi_{\\mathrm{hyb}}}(\\mathcal{S}^{\\mathcal{A}},\\mathcal{Z},\\kappa):\\mathsf{view}\\text{ aborts due to extend-failure}\\right]\\leq\\mathsf{negl}(\\kappa)</span></p>

    <h6 id="sec-92" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Straightforward by Claim 6, Claim 7, and the definition of <span class="math">\\mathcal{S}</span>. ∎</p>

    <h3 id="sec-93" class="text-xl font-semibold mt-8">H.5 Indistinguishability of the Real-World and Simulated Executions</h3>

    <h6 id="sec-94" class="text-base font-medium mt-4">Lemma 11 (Indistinguishability of the real-world and simulated executions).</h6>

    <p class="text-gray-300">For any <span class="math">\\Pi_{\\mathrm{snowwhite}}</span>-compliant p.p.t. pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, conditioned on the simulated execution not aborting, then <span class="math">\\mathcal{Z}</span>’s view in the simulated execution and real execution are identically distributed.</p>

    <h6 id="sec-95" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We now prove this lemma.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hybrid 1. Same as the simulated execution, but with the following modification: when the an honest node needs to call the ideal-world <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}.\\mathsf{extend}}(chain,B)</span>, a real-world algorithm is adopted for extending the chain: the honest node calls <span class="math">\\mathsf{eligible}^{t}(chain,\\mathsf{pk})</span> where <span class="math">\\mathsf{H}</span> is implemented by <span class="math">\\mathcal{S}</span>. If the outcome is 1, add <em>chain</em>$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B<span class="math"> to </span>\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}.\\mathsf{tree}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Claim 8. No p.p.t. <span class="math">\\mathcal{Z}</span> can distinguish the simulated execution and Hybrid 1 except with negligible probability.</p>

    <h6 id="sec-96" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">It suffices to show that if an alert node tries to extend a <em>chain</em> at time <span class="math">t</span>, then <em>chain</em> is simulation valid and has a sufficiently long prefix at <span class="math">t</span>. If this is true, then by Claim 5, using the real-world algorithm to decide whether a node is leader is equivalent to what <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}}</span> thinks. Therefore, using the real-world algorithm to extend the chain rather than calling <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}.\\mathsf{extend}}</span> would be equivalent. Given Claim 7 and the definition of the simulated execution, it is not hard to see that every <em>chain</em> an alert node tries to extend is simulation valid and has a sufficiently long prefix.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">Hybrid 2. Same as Hybrid 1, but with the following modification: whenever an honest node receives a <em>chain^{′}</em> whose length is longer than its own <em>chain</em>, do real-world checks instead of calling <span class="math">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}.\\mathsf{verify}}</span>.</p>

    <p class="text-gray-300">Claim 9. No p.p.t. <span class="math">\\mathcal{Z}</span> can distinguish Hybrid 1 and Hybrid 2 except with negligible probability.</p>

    <h6 id="sec-97" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Notice that <span class="math">\\mathcal{S}</span> always performs real-world checks on behalf of an alert node <span class="math">i</span> before forwarding any <em>chain</em> to an alert node <span class="math">i</span>. Therefore, it is easy to see that the claim is true given that we have proved Lemma 10. ∎</p>

    <p class="text-gray-300">Finally, to prove Lemma 11, it suffices to observe that Hybrid 2 is equivalent to the real-world execution by a standard argument of redrawing algorithm boundaries.</p>

    <p class="text-gray-300">I Additional Related Work</p>

    <p class="text-gray-300">We briefly review the rich body of literature on consensus protocols including permissioned and permissionless consensus. Part of this section borrows from an earlier work <em>[48]</em>.</p>

    <p class="text-gray-300">Models for permissioned consensus protocols. Consensus in the permissioned setting <em>[5, 8, 11, 12, 16, 21, 22, 25, 26, 27, 31, 32, 37, 38, 39, 40, 41, 52]</em> has been actively studied for the past three decades; and we can roughly classify these protocols based on their network synchrony, their cryptographic assumptions, and various other dimensions.</p>

    <p class="text-gray-300">Roughly speaking, two types of network models are typically considered, the synchronous model, where messages sent by honest nodes are guaranteed to be delivered to all other honest nodes in the next round; and partially synchronous or asynchronous protocols where message delays may be unbounded, and the protocol must nonetheless achieve consistency and liveness despite not knowing any a-priori upper bound on the networks’ delay. In terms of cryptographic assumptions, two main models have been of interest, the “unauthenticated Byzantine” model <em>[40]</em> where nodes are interconnected with authenticated channels; and the “authenticated Byzantine” model <em>[21]</em>, where a public-key infrastructure exists, such that nodes can sign messages and such digital signatures can then be transferred.</p>

    <p class="text-gray-300">Permissioned, synchronous protocols. Many feasibility and infeasibility results have been shown. Notably, Lamport et al. <em>[40]</em> show that it is impossible to achieve secure consensus in the presence of a <span class="math">\\frac{1}{3}</span> coalition in the “unauthenticated Byzantine” model (even when assuming synchrony). However, as Dolev and Strong show <em>[21]</em>, in a synchronous, authenticated Byzantine model, it is possible to design protocols that tolerate an arbitrary number of corruptions. It is also understood that no deterministic protocol fewer than <span class="math">f</span> rounds can tolerate <span class="math">f</span> faulty nodes <em>[21]</em> — however, if randomness is allowed, existing works have demonstrated expected constant round protocols that can tolerate up to a half corruptions <em>[25, 32]</em>.</p>

    <p class="text-gray-300">Permissioned, asynchronous protocols. A well-known lower bound by Fischer, Lynch, and Paterson <em>[26]</em> shows if we restrict ourselves to protocols that are deterministic and where nodes do not read clocks, then consensus would be impossible even when only a single node may be corrupt. Known feasibility results typically circumvent this well-known lower bound by making two types of assumptions: 1) randomness assumptions, where randomness may come from various sources, e.g., a common coin in the sky <em>[12, 27, 43]</em>, nodes’ local randomness <em>[5, 52]</em>, or randomness in network delivery <em>[11]</em>; and 2) clocks and timeouts, where nodes are allowed to read a clock and make actions based on the clock’s value. This approach has been taken by well-known protocols such as PBFT <em>[16]</em> and FaB <em>[41]</em> that use timeouts to re-elect leaders and thus ensure liveness even when the previous leader may be corrupt.</p>

    <p class="text-gray-300">Another well-known lower bound in the partially synchronous or asynchronous setting is due to Dwork et al. <em>[22]</em>, who showed that no protocol (even when allowing randomness or clocks) can achieve security in the presence of a <span class="math">\\frac{1}{3}</span> corrupt coalition.</p>

    <p class="text-gray-300">Permissionless consensus. The permissionless model did not receive sufficient academic attention, perhaps partly due to the existence of strong lower bounds such as what Canetti et al. showed <em>[3]</em>. Roughly speaking, we understand that without making additional trust assumptions, not many interesting tasks can be achieved in the permissionless model where authenticated chan</p>

    <p class="text-gray-300">nels do not exist between nodes.</p>

    <p class="text-gray-300">Amazingly, cryptocurrencies such as Bitcoin and Ethereum have popularized the permissionless setting, and have demonstrated to us, that perhaps contrary to the common belief, highly interesting and non-trivial tasks can be attained in the permissionless setting. Underlying these cryptocurrency systems is a fundamentally new type of consensus protocols commonly referred to as proof-of-work blockchains <em>[44]</em>. Upon closer examination, these protocols circumvent known lower bounds such as those by Canetti et al. <em>[3]</em> and Lamport et al. <em>[40]</em> since they rely on a new trust assumption, namely, proofs-of-work, that was not considered in traditional models.</p>

    <p class="text-gray-300">Formal understanding of the permissionless model has just begun <em>[45, 46, 47, 28]</em>. Notably, Garay et al. <em>[28]</em> formally analyze the Nakamoto blockchain protocol in synchronous networks. Pass et al. <em>[45]</em> extend their analysis to asynchronous networks. More recently, Pass and Shi <em>[47]</em> show how to perform committee election using permissionless consensus and then bootstrap instances of permissioned consensus — in this way, they show how to asymptotically improve the response time for permissionless consensus.</p>

    <p class="text-gray-300">Finally, existing blockchains are known to suffer from a selfish mining attack <em>[24]</em>, where a coalition wielding <span class="math">\\frac{1}{3}</span> of the computation power can reap up to a half of the rewards. Pass and Shi <em>[46]</em> recently show how to design a fair blockchain (called Fruitchains) from any blockchain protocol with positive chain quality. Since our Snow White consensus protocol is a blockchain-style protocol, we also inherit the same selfish mining attack. Fortunately, Snow White can leverage the same techniques as Pass and Shi <em>[46]</em> to achieve incentive compatibility (see Section 3).</p>

    <p class="text-gray-300">Dynamic reconfiguration for consensus protocols. Dynamic reconfiguration has been studied in the classical setting for permissioned consensus. For example, Vertical Paxos <em>[39]</em> and BFT-SMART <em>[8]</em> allow nodes to be reconfigured in a dynamic fashion. The more recent Hybrid Consensus protocol by Pass and Shi <em>[47]</em> also performs committee reconfiguration over time, however, their protocol requires that in some transient windows, multiple instances of the permissioned consensus protocol are run concurrently.</p>

    <p class="text-gray-300">In this paper, we also consider dynamic reconfiguration, but we consider it for blockchain-style protocols and rely on new techniques. One compelling advantage of our approach is that group reconfiguration is seamless in our protocol and does not need to introduce special execution paths. We also do not need to invoke multiple concurrent consensus instances.</p>`;
---

<BaseLayout title="Snow White: Robustly Reconfigurable Consensus and Applicatio... (2016/919)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/919
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
