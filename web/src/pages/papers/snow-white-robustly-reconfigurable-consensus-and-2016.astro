---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/919';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-21';
const TITLE_HTML = 'Snow White: Robustly Reconfigurable Consensus and Applications to Provably Secure Proof of Stake';
const AUTHORS_HTML = 'Phil Daian, Rafael Pass, Elaine Shi';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Decentralized cryptocurrencies have pushed deployments of distributed consensus to more stringent environments than ever before. Most existing protocols rely on proofs-of-work which require expensive computational puzzles to enforce, imprecisely speaking, &ldquo;one vote per unit of computation&rdquo;. The enormous amount of energy wasted by these protocols has been a topic of central debate, and well-known cryptocurrencies have announced it a top priority to alternative
paradigms. Among the proposed alternative solutions, proofs-of-stake protocols have been of particular interest, where roughly speaking, the idea is to enforce &ldquo;one vote per unit of stake&rdquo;.
Although the community have rushed to propose numerous candidates for proofs-of-stake, no existing protocol has offered formal proofs of security, which we believe to be a critical, indispensible ingredient of a distributed consensus protocol, particularly one that is to underly a high-value cryptocurrency system.

In this work, we seek to address the following basic questions:

&bull; What kind of functionalities and robustness requirements should a consensus candidate offer
to be suitable in a proof-of-stake application?

&bull; Can we design a provably secure protocol that satisfies these requirements?

To the best of our knowledge, we are the first to formally articulate a set of requirements for consensus candidates for proofs-of-stake. We argue that any consensus protocol satisfying these properties can be used for proofs-of-stake, as long as money does not switch hands too quickly. Moreover, we provide the first consensus candidate that provably satisfies the desired robustness properties.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> consensus &middot; blockchains &middot; cryptocurrency &middot; distributed systems &middot; proofs-of-stake</p>
    </section>

    <p class="text-gray-300">Although consensus protocols have been investigated by the distributed systems community for 30 years, in the past decade a new breakthrough called Bitcoin established a new, blockchainbased paradigm for reaching consensus in a distributed system. Relying on proof-of-work, Bitcoin's consensus protocol (often called Nakamoto consensus), for the first time, enabled consensus in an open, unauthenticated environment where nodes do not share any pre-established public keys <a href="#page-20-0">[28,</a> <a href="#page-21-0">44,</a> <a href="#page-21-1">45,</a> <a href="#page-21-2">49]</a>. One commonly known painpoint with this approach is the enormous energy waste. Motivated by the need for a green alternative, the community searched for a paradigm shift, and hoped to obtain a consensus paradigm, commonly called &quot;proof-of-stake&quot;, that is based on the idea of &quot;one vote per unit of stake&quot; (as opposed to &quot;one vote per unit of hash-power&quot;).</p>

    <p class="text-gray-300">The design of proof-of-stake protocols was first initiated in online forums and blog-posts and subsequently considered by the academic community <a href="#page-19-0">[6,</a><a href="#page-19-1">7,</a><a href="#page-20-1">18,</a><a href="#page-21-3">35,</a><a href="#page-21-4">36,</a><a href="#page-21-5">42,</a><a href="#page-21-6">51,</a><a href="#page-22-0">53,</a><a href="#page-22-1">54]</a>. Prior to our work, we were not aware of any candidate protocol that offered provable guarantees.</p>

    <p class="text-gray-300">Snow White is the first work to provide end-to-end, formal proofs of security of a full proof-ofstake protocol. Security is proven in a truly decentralized, open-participation environment where honest nodes can join the protocol late in time (and not necessarily at the system's creation). We give the first formal treatment of the well-known &quot;costless simulation&quot; problem (also called posterior corruption in this paper) pertaining to proof-of-stake, proving upper- and lower-bounds that precisely characterize under what assumptions it is possible to defend against costless simulation.</p>

    <p class="text-gray-300">In the remainder of the introduction, we first present an informal technical overview of our results. We then provide detailed chronological notes that position our work in light of other concurrent and subsequent works, and summarize our work's contributions and impact.</p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8">1.1 Robustly Reconfigurable Consensus</h3>

    <p class="text-gray-300">We ask the question: what is a suitable consensus protocol for a proof-of-stake system? In a proofof-stake system, at any point of time, we would like the present stake-holders to have voting rights that are weighed by their respective stake amount. Thus if we examine any single snapshot in the system, proof-of-stake in fact requires a &quot;permissioned&quot; core consensus protocol, since the set of public-keys owning stake is publicly known. However, proof-of-stake systems aim to support open participation &mdash; and this can be enabled through periodic committee reconfiguration. Suppose that the system starts with a well-known set of stake-holders who form the initial consensus committee. As stake switches hands in the system, the consensus committee should be updated in a timely manner to track the present (and not the past) stake distribution. This is important for the security of a proof-of-stake system, since users who no longer hold stake in the system may be incentivized to deviate, e.g., to launch a double-spending attack.</p>

    <p class="text-gray-300">We formulate the task of designing &quot;a consensus protocol suitable for proof-of-stake&quot; as &quot;robustly reconfigurable consensus&quot;. A robustly reconfiguration consensus protocol should have the following desirable properties.</p>

    <p class="text-gray-300">Robustness in the presence of sporadic participation. In a large-scale, decentralized environment, users tend to have sporadic participation, and it may be difficult to anticipate how many users will be online at any point of time. Almost all classical-style consensus protocols rely on tallying sufficiently many votes to make progress. If fewer than the anticipated number of users actually show up to vote, the consensus protocol may get stuck.</p>

    <p class="text-gray-300">To address this challenge, Snow White employs the recently proposed &quot;sleepy consensus&quot; <a href="#page-21-7">[48]</a> paradigm as its core permissioned consensus building block. Sleepy consensus <a href="#page-21-7">[48]</a> is inspired by the beautiful &quot;longest-chain&quot; idea behind Nakamoto's consensus <a href="#page-21-0">[44]</a>, but the idea is instead applied to a non-proof-of-work, permissioned setting with a public-key infrastructure (PKI). Pass and Shi prove that the resulting consensus protocol is robust in the presence of sporadic participation: concretely, the protocol need not be parametrized with an a-priori fixed number of players that are expected to show up. As long as the majority of online players are honest, the protocol guarantees consistency and liveness.</p>

    <p class="text-gray-300">Robust committee reconfiguration. Roughly speaking, our system proceeds in epochs. In each epoch, a most recent set of stake-holders are elected as committee and may be randomly chosen to generate blocks. We argue that committee reconfiguration and random block-proposer selection are challenging and subtle due to the following two possible attacks.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Adaptive key selection attacks. Since proof-of-stake systems admit open participation, anyone can buy up stake in the system and participate. This also means anyone can (possibly maliciously) choose their public-keys through which they participate in the consensus. A possible attack, therefore, is to adaptively choose public-keys, after gathering partial information about the randomness seed used for block-proposer selection, such that corrupt nodes are elected more often as block-proposer than their fair chance.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Randomness-biasing attacks (commonly known as the &quot;grinding attack&quot;). Another important question is: how do we obtain the randomness needed for block proposer selection? A most straightforward idea is to use the hash of past blocks &mdash; but as several works have shown <a href="#page-19-2">[10]</a>, the blocks' hashes can be subject to adversarial influence, and it is unclear what security can be guaranteed when we use such randomness sources with adversarial bias for block proposer selection. For example, the adversary can bias the randomness in a way that allows corrupt nodes to be selected more often.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">In the worst case, if through possibly a combination of the attacks, the adversary can control the majority of the block-proposer slots, consistency of the underlying consensus (in our case, sleepy consensus) can be broken.</p>

    <p class="text-gray-300">Snow White proposes a novel &quot;two-lookback&quot; mechanism that addresses the above two challenges simultaneously<a href="#page-2-0">1</a> . We determine each epoch's new consensus committee and randomness seed in a two-phase process, where each phase spans roughly &kappa; blocks of time for some appropriate security parameter<a href="#page-2-1">2</a> &kappa;. This two-phase process is enabled by two look-back parameters as we describe informally below (a formal description is deferred to the technical sections) &mdash; henceforth suppose that chain is the current longest chain.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We look back 2&kappa; blocks, and use the prefix chain[: &minus;2&kappa;] (i.e., the prefix of chain removing the trailing 2&kappa; blocks) to determine the new consensus committee.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We look back &kappa; blocks, and extract the randomness contained in the blocks chain[&minus;2&kappa; : &minus;&kappa;] (i.e., the part of chain from 2&kappa; blocks ago to &kappa; blocks ago) to form a randomness seed &mdash; this seed then seeds a random oracle used for block-proposer selection in the current epoch.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Roughly speaking, we defeat the adaptively chosen key attack by determining the consensus committee &kappa; blocks earlier than the randomness seed, such that when corrupt nodes choose their public keys, they cannot predict the randomness seed, which will be generated much later in time and with sufficient entropy contributed by honest nodes as we explain below. We argue that due</p>

    <p class="text-gray-300"><sup>1</sup>Subsequent works, including newer versions of Algorand <a href="#page-20-2">[17]</a> released after our publication, Ouroboros Praos <a href="#page-20-3">[19]</a>, and the latest Ethereum's proof-of-stake proposal <a href="#page-19-3">[2]</a> incorporated elements of this design and suggested improvements, e.g., for concrete security. See Section <a href="#page-4-0">1.3</a> for more discussions.</p>

    <p class="text-gray-300"><sup>2</sup> Suppose that except with negligible in &kappa; probability, the underlying sleepy consensus guarantees consistency by chopping off the trailing &kappa; blocks, and guarantees the existence of an honest block in every consecutive window of &kappa; blocks.</p>

    <p class="text-gray-300">to chain quality of the underlying sleepy consensus, the blocks chain[&minus;2&kappa; : &minus;&kappa;] must contain an honest block. Since honest nodes embed a sufficiently long uniform random seed in its block, we can extract sufficiently high-entropy randomness from chain[&minus;2&kappa; : &minus;&kappa;] which is then used to seed the block-proposer-selection random oracle. Even though the extracted randomness is subject to adversarial bias, as long as it is high-entropy, and importantly, as long as the same randomness is used to seed the block-proposer selection sufficiently many times, we can achieve the desired measure concentration properties. More specifically, although indeed, the adversary can bias the random seed to allow corrupt nodes to be selected (as block-proposers) quite surely for a few number of slots; the adversary is not able to consistently gain advantage over a sufficiently large number of slots, i.e., corrupt nodes cannot own noticeably more block-proposer slots than its fair share.</p>

    <p class="text-gray-300">We stress that turning the above intuitive argument into a formal proof requires significant and non-trivial effort which is part our main contributions. In our technical sections, we formally prove security of this approach under a mildly adaptive adversary, i.e., when the adversary is subject to a mild corruption delay and as long as nodes remain honest till shortly after they stop serving on a consensus committee, our robustly reconfigurable consensus protocol is secure. Subsequent works (including newer versions of the Algorand paper that are published after the release of Snow White, as well as the subsequent work Ourboros Praos <a href="#page-20-3">[19]</a>) have suggested approaches for achieving fully adaptive security, but relying on the fact that the majority of nodes will erase secret signing keys from memory after signing a block (and by introducing mild additional complexity in the cryptographic schemes employed) &mdash; see Section <a href="#page-4-0">1.3</a> for a more detailed comparison.</p>

    <p class="text-gray-300">Understanding posterior corruption, i.e., &quot;costless simulation&quot; attacks. A oft-cited attack for proof-of-stake systems is the so-called &quot;costless simulation&quot; attack (also referred to as a posterior corruption attack in this paper). The idea is that when stake-holders have sold their stake in the system, nothing prevents them from performing a history-rewrite attack. Specifically, suppose that a set of nodes denoted C control the majority stake in some past committee. These nodes can collude to fork the history from the point in the past when they control majority and in this alternate history money can transfer in a way such that C continues to hold majority stake (possibly transferred to other pseudonyms of the corrupt nodes) such that the attack can be sustained.</p>

    <p class="text-gray-300">In this paper, we formally prove that under a mild setup assumption &mdash; when nodes join the system they can access a set of online nodes the majority of whom are honest &mdash; we can provably defend against such a posterior corruption attack. This is achieved by having the newly joining user obtain a somewhat recent checkpoint from the set of nodes it can access upon joining.</p>

    <p class="text-gray-300">We also prove a corresponding lower bound, that absent this setup assumption, defense against such posterior corruption attacks is impossible &mdash; to the best of our knowledge, ours is the first formal treatment of this well-known costless simulation attack in the context of proof-of-stake.</p>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8">1.2 From Robustly Reconfigurable Consensus to Proof-of-Stake</h3>

    <p class="text-gray-300">Application to proof-of-stake and achieving incentive compatibility. We show how to apply such a &quot;robustly reconfigurable consensus&quot; protocol to realize proof-of-stake (the resulting protocol called Snow White), such that nodes obtain voting power roughly proportional to their stake in the cryptocurrency system. As long as money does not switch hands too fast (which is enforceable by the cryptocurrency layer), we show that the resulting proof-of-stake protocol can attain security when the adversary controls only a minority of the stake in the system. Further, borrowing ideas from the recent Fruitchain work <a href="#page-21-8">[46]</a>, we suggest incentive compatible mechanisms for distributing rewards and transaction fees, such that the resulting protocol achieves a coalitionresistant -Nash equilibrium, i.e., roughly speaking, as long as the adversary controls a minority of the stake, it cannot obtain more than fraction more than its fair share of payout, even when it has full control of network transmission and can deviate arbitrarily from the protocol specification.</p>

    <p class="text-gray-300">Preventing nothing-at-stake attacks. Later in Section <a href="#page-11-0">3,</a> we will also discuss how to leverage guarantees provided by our core consensus protocol, and build additional mechanisms that not only discourage nothing-at-stake attackers, but in fact penalize them.</p>

      <h3 id="sec-1.3" class="text-xl font-semibold mt-8">1.3 Chronological Notes, Closely Related, and Subsequent Works</h3>

    <p class="text-gray-300">Comparison with Algorand. The first manuscript of Algorand <a href="#page-20-2">[17]</a> was published prior to our work. Algorand also proposes a proof-of-stake system. Their core consensus protocol is a newly designed classical-style consensus protocol, and therefore they cannot guarantee progress under sporadic participation &mdash; instead, Algorand proposes a notion of &quot;lazy participation&quot;, where users know when they are needed to vote in the consensus and they only need to be online when they are needed. However, if many users who are anticipated to show up failed to do so, progress will be hampered. Algorand employs a Verifiable Random Function (VRF) to perform random leader/committee election.</p>

    <p class="text-gray-300">Algorand's algorithm has been improved for several iterations. The version of Algorand that existed before the publication of Snow White gave proofs of their core consensus protocol but did not provide end-to-end proofs for the full proof-of-stake system. In particular, the version of Algorand that existed prior to Snow White's publication did not discuss the well-known issue of costless simulation or clearly state the implicit assumptions they make to circumvent the lower bound we prove in this paper.</p>

    <p class="text-gray-300">In their subsequent versions, they adopted the erasure model and rely on honest nodes' capability to safely erase secrets from memory to achieve adaptive security (and implicitly, by adopting erasures one could defend against the costless simulation). The newer versions of Algorand (released after the Snow White) also started to adopt a similar look-back idea (first described by Snow White) to secure against the adaptive chosen-key attack mentioned earlier. The recent versions also provided more thorough mathematical proofs of this approach.</p>

    <p class="text-gray-300">Comparison with Ouroboros and Ouroboros Praos. Snow White was publicly released in September 2016. A closely related work (independent and concurrent from our effort) known as Ouroboros <a href="#page-21-9">[34]</a> was release about 10 days prior to Snow White. Ouroboros Praos is an improvement over Ouroboros published in 2017 <a href="#page-20-3">[19]</a>.</p>

    <p class="text-gray-300">The Ouroboros version that was released around the same time as Snow White focused on proving the underlying permissioned consensus building block secure, and there is only a short paragraph containing a proof sketch of their full proof-of-stake system (and this proof sketch has been somewhat expanded to a few paragraphs in later versions). In comparison, our Snow White paper adopts a permissioned consensus building block whose security was formally proven secure in a related paper <a href="#page-21-7">[48]</a> &mdash; the full-length of our technical sections are dedicated to a thorough treatment of the security of the end-to-end proof-of-stake system.</p>

    <p class="text-gray-300">A notable difference between Snow White and Ouroboros seems to be that their formal treatment does not seem to capture a truly decentralized environment (necessary for decentralized cryptocurrency applications) where nodes may join the system late and not from the very start &mdash; had they done so, they would have encountered the well-known costless simulation issue, which, as we show, is impossible to defend against without extra setup assumptions (and indeed, we introduce a reasonable setup assumption to circumvent this lower bound).</p>

    <p class="text-gray-300">A subsequently improved work, called Ouroboros Praos <a href="#page-20-3">[19]</a>, extends the VRF approach described first by Algorand <a href="#page-20-2">[17]</a> and Dfinity <a href="#page-20-4">[30]</a> for random block-proposer election. Similar to the newer versions of Algorand, Ouroboros Praos <a href="#page-20-3">[19]</a> also started adopting an erasure model to achieve adaptive security (and implicitly, defend against costless simulation<a href="#page-5-0">3</a> ).</p>

    <p class="text-gray-300">Neither Ouroboros nor Ouroboros Praos adopts an underlying consensus mechanism that provably provides support for sporadic participation. Finally, the improved version Ouroboros Praos <a href="#page-20-3">[19]</a> started adopting a look-back mechanism that appears to be inspired by Snow White to for committee rotation and random block-proposer selection.</p>

    <p class="text-gray-300">Comparison with Ethereum's proof-of-stake design. Ethereum began proof-of-stake explorations several years ago. Their design has undergone several versions. At the time of the writing, Ethereum was aiming to do &quot;hybrid proof-of-stake&quot;, i.e., use Casper as a finality gadget on top of their existing proof-of-work blockchain.</p>

    <p class="text-gray-300">In the past year 2018, conversations with Ethereum core researchers suggest that Ethereum is considering replacing their proof-of-work blockchain with a proof-of-stake blockchain similar to Snow White. Their committee election and random block proposer selection algorithm seems to be improvement of Snow White. Specifically, they would like to adopt an economically secure coin toss protocol for randomness generation (commonly known as RANDAO). This specific protocol is also subject to adversarial bias much like our randomness seed generation (although biasing attacks may lead to economic loss). Thus they rely on exactly the same observation that was proposed in our paper: although the adversary can bias the randomness sufficiently to control a few block proposer slots, he cannot consistently get an advantage over a large number of slots. Interestingly, Ethereum has several practical optimizations that improve the concrete security parameters of the above analysis <a href="#page-19-3">[2]</a>.</p>

    <p class="text-gray-300">We focus on an intuitive exposition of our scheme in the main body. In the appendices, we present formal definitions, a formal description of the protocol, as well as the full proofs. We stress that formalizing the end-to-end security of a proof-of-stake system is a significant effort and this leads to our choice of presentation.</p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Background: Sleepy Consensus and Sleepy Execution Model</h3>

    <p class="text-gray-300">Sleepy execution model and terminology. We would like to adopt an execution model that captures a decentralized environment where nodes can spawn late in time, and can go to sleep and later wake up. In such a model, the protocol may not have a way to anticipate the number of players at any time.</p>

    <p class="text-gray-300"><sup>3</sup>Snow White's approach of combining checkpointing and &quot;bootstrapping through social consensus&quot; to defend against costless simulation is simpler and more practical in real-world implementations (than relying on VRFs and erasure <a href="#page-20-2">[17,</a> <a href="#page-20-3">19]</a>). Notably, our usage of checkpointing and &quot;bootstrapping through social consensus&quot; already exists in real-world cryptocurrencies. To the best of our knowledge, checkpointing was first suggested by Barber, Boyen, Shi, and Uzun <a href="#page-19-4">[4]</a> as a way to defend against history revisioning attacks in Bitcoin.</p>

    <p class="text-gray-300">We thus adopt the sleepy model of execution proposed by Pass and Shi <a href="#page-21-7">[48]</a>. Nodes are either sleepy (i.e., offline) or awake (i.e., online and actively participating). For simplicity, we also refer to nodes that are awake and honest as alert; and all corrupt nodes are assumed to be awake by convention.</p>

    <p class="text-gray-300">Messages delivered by an alert node is guaranteed to arrive at all other alert nodes within a maximum delay of &#8710;, where &#8710; is an input parameter to the protocol. A sleepy node captures any node that is either offline or suffering a slower than &#8710; network connection. A sleepy node can later wake up, and upon waking at time t, all pending messages sent by alert nodes before t &minus; &#8710; will be immediately delivered to the waking node.</p>

    <p class="text-gray-300">We allow the adversary to dynamically spawn new nodes, and newly spawned nodes can either be honest or corrupt. Further, as we discuss later, we allow the adversary to declare corruptions and put alert nodes to sleep in a mildly adaptive fashion.</p>

    <p class="text-gray-300">For readability, we defer a detailed presentation of the formal model to Appendix <a href="#page-22-2">A.1.</a></p>

    <p class="text-gray-300">The Sleepy protocol as a starting point. Classical consensus protocols must count sufficiently many votes to make progress and thus the protocol must know a-priori roughly how many nodes will show up to vote. Since Pass and Shi's Sleepy consensus protocol is the only protocol known to provide consensus under sporadic participation, i.e., the protocol need not have a-priori knowledge of the number of players at any time. We thus consider Sleepy as a starting point for constructing our notion of robustly reconfigurable consensus. We now briefly review the Sleepy consensus protocol as necessary background.</p>

    <p class="text-gray-300">Sleepy is a blockchain-style protocol but without proof-of-work. For practical considerations, below we describe the version of Sleepy instantiated with a random oracle (although Pass and Shi <a href="#page-21-7">[48]</a> also describe techniques for removing the random oracle). Sleepy relies on a random oracle to elect a leader in every time step. The elected leader is allowed to extend a blockchain with a new block, by signing a tuple that includes its own identity, the transactions to be confirm, the current time, and the previous block's hash. Like in the Nakamoto consensus, nodes always choose the longest chain if they receive multiple different ones. To make this protocol fully work, Sleepy <a href="#page-21-7">[48]</a> proposes new techniques to timestamp blocks to constrain the possible behaviors of an adversary. Specifically, there are two important blockchain timestamp rules:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>a valid blockchain must have strictly increasing timestamps; and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>honest nodes always reject a chain with future timestamps.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">All aforementioned timestamps can be adjusted to account for possible clock offsets among nodes by applying a generic protocol transformation <a href="#page-21-7">[48]</a>.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Handling Committee Reconfiguration</h3>

    <p class="text-gray-300">As mentioned, our starting point is the Sleepy consensus protocol, which assumes that all consensus nodes know each other's public keys; although it may not be known a-priori how many consensus nodes will show up and participate.</p>

    <p class="text-gray-300">We now discuss how to perform committee reconfiguration such that the consensus committee tracks the latest stake distribution. To support a wide range of applications, our Snow White protocol does not stipulate how applications should select the committee over time. Roughly speaking, we wish to guarantee security as long as the application-specific committee selection algorithm respects the constraint that there is honest majority among all awake nodes. Therefore, we assume that there is some application-specific function elect cmt(chain) that examines the state of the blockchain and outputs a new committee over time. In a proof-of-stake context, for example, this function can roughly speaking, output one public key for each currency unit owned by the user. In Section <a href="#page-11-0">3,</a> we discuss in a proof-of-stake context, how one might possibly translate assumptions on the distribution of stake to the the formal requirements expected by the consensus protocol.</p>

    <p class="text-gray-300">Strawman scheme: epoch-based committee selection. Snow White provides an epoch-based protocol for committee reconfiguration. To aid understanding, we begin by describing a strawman solution. Each Tepoch time, a new epoch starts, and the beginning of each epoch provides a committee reconfiguration opportunity. Let start(e) and end(e) denote the beginning and ending times of the e-th committee. Every block in a valid blockchain whose time stamp is between [start(e), end(e)) is associated with the e-th committee.</p>

    <p class="text-gray-300">It is important that all honest nodes agree on what the committee is for each epoch. To achieve this, our idea is for honest nodes to determine the new committee by looking at a stabilized part of the chain. Therefore, a straightforward idea is to make the following modifications to the basic Sleepy consensus protocol:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let 2&omega; be a look-back parameter.</li>
      <li>At any time t &isin; [start(e), end(e)) that is in the e-th epoch, an alert node determines the e-th committee in the following manner: find the latest block in its local chain whose timestamp is no greater than start(e) &minus; 2&omega;, and suppose this block resides at index \`.</li>
      <li>Now, output extractpks(chain[: \`]) as the new committee.</li>
    </ul>

    <p class="text-gray-300">In general, the look-back parameter 2&omega; must be sufficiently large such that all alert nodes have the same prefix chain[: \`] in their local chains by time start(e). On the other hand, from an application's perspective, 2&omega; should also be recent enough such that the committee composition does not lag significantly behind.</p>

    <p class="text-gray-300">Preventing an adaptive key selection attack. Unfortunately, the above scheme is prone to an adaptive key selection attack where an adversary can break consistency with constant probability. Specifically, as the random oracle H is chosen prior to protocol start, the adversary can make arbitrary queries to H. Therefore, the adversary can spawn corrupt nodes and seed them with public keys that causes them to be elected leader at desirable points of time. For example, since the adversary can query H, it is able to infer exactly in which time steps honest nodes are elected leader. Now, the adversary can pick corrupt nodes' public keys, such that every time an honest node is leader, a corrupt node is leader too &mdash; and he can sustain this attack till he runs out of corrupt nodes. Since the adversary may control up to &Theta;(n) nodes, he can thus break consistency for &Omega;(n) number of blocks.</p>

    <p class="text-gray-300">Our idea is to have nodes determine the next epoch's committee first, and then select the next epoch's hash &mdash; in this way, the adversary will be unaware of next epoch's hash until well after the next committee is determined. More specifically, we can make the following changes to the Sleepy protocol:</p>

    <p class="text-gray-300">&bull; Let 2&omega; and &omega; be two look-back parameters, for determining the next committee and next hash respectively.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>At any time t &isin; [start(e), end(e)) that is in the e-th epoch, an alert node determines the eth committee in the following manner: find the latest block its local chain whose timestamp is no greater than start(e) &minus; 2&omega;, and suppose this block resides at index <code>0. Now, output extractpks(chain[: </code>0]) as the new committee.</li>
      <li>At any time t &isin; [start(e), end(e)) an alert node determines the e-th hash in the following manner: find the latest block its local chain whose timestamp is no greater than start(e)&minus;&omega;, and suppose this block resides at index <code>1. Now, output extractnonce(chain[: </code>1]) as a nonce to seed the new hash.</li>
      <li>We augment the protocol such that alert nodes always embed a random seed in any block they mine, and extractnonce(chain[: \`1]) can simply use the seeds in the prefix of the chain as a nonce to seed the random oracle H.</li>
    </ul>

    <p class="text-gray-300">For security, we require that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The two look-back parameters 2&omega; and &omega; are both sufficiently long ago, such that all alert nodes will have agreement on chain[: <code>0] and chain[: </code>1] by the time start(e); and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The two look-back parameters 2&omega; and &omega; must be sufficiently far part, such that the adversary cannot predict extractnonce(chain[: \`1]) until well after the next committee is determined.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Achieving security under adversarially biased hashes. It is not hard to see that the adversary can bias the nonce used to seed the hash, since the adversary can place arbitrary seeds in the blocks it contributes. In particular, suppose that the nonce is extracted from the prefix chain[: <code>1]. Obviously, with at least constant probability, the adversary may control the ending block in this prefix. By querying H polynomially many times, the adversary can influence the seed in the last block chain[</code>1] of the prefix, until it finds one that it likes.</p>

    <p class="text-gray-300">Indeed, if each nonce is used only to select the leader in a small number of time steps (say, O(1) time steps), such adversarial bias would indeed have been detrimental &mdash; in particular, by enumerating polynomially many possibilities, the adversary can cause itself to be elected with probability almost 1 (assuming that the adversary controls the last block of the prefix).</p>

    <p class="text-gray-300">However, we observe that as long as the same nonce is used sufficiently many times, the adversary cannot consistently cause corrupt nodes to be elected in many time steps. Specifically, suppose each nonce is used to elect at least &Omega;(&kappa;) leaders, then except with negl(&kappa;) probability, the adversary cannot increase its share by more than an fraction &mdash; for an arbitrarily small constant &gt; 0. Therefore, to prove our scheme secure, it is important that each epoch's length (henceforth denoted Tepoch) be sufficiently long, such that once a new nonce is determined, it is used to elect sufficiently many leaders.</p>

    <p class="text-gray-300">Reasoning about security under adversarially biased hashes. Formalizing this above intuition is somewhat more involved. Specifically, our proof needs to reason about the probability of bad events (related to chain growth, chain quality, and consistency) over medium-sized windows such that the bad events depend only on O(1) number of hashes (determined by the nonces used to seed them). This way, we can apply a union bound that results in polynomial security loss. If the window size is too small, it would not be enough to make the failure probability negligible; on the other hand, if the window were too big, the blowup of the union bound would be exponential. Finally, we argue if no bad events occur for every medium-sized window, then no bad events happen for every window (as long as the window is not too small). We defer the detailed discussions and formal proofs to Sections <a href="#page-36-0">E</a> and <a href="#page-42-0">G.1</a></p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 Handling Mildly Adaptive and Posterior Corruptions</h3>

    <p class="text-gray-300">We now consider how to defend against an adversary that can adaptively corrupt nodes after they are spawned. In this paper, we will aim to achieve security against a mildly adaptive adversary. Specifically, a mildly adaptive adversary is allowed to dynamically corrupt nodes or make them sleep, but such corrupt or sleep instructions take a while to be effective. For example, in practice, it may take some time to infect a machine with malware. Such a &quot;mildly adaptive&quot; corruption model has been formally defined in earlier works <a href="#page-21-10">[47]</a>, where they call it the &tau; -agile corruption model, where &tau; denotes the delay parameter till corrupt or sleep instructions take effect. Intuitively, as long as &tau; is sufficiently large, it will be too late for an adversary to corrupt a node or make the node sleep upon seeing the next epoch's hash. By the time the corrupt or sleep instruction takes effect, it will already be well past the epoch.</p>

    <p class="text-gray-300">The main challenge in handling mildly adaptive corruptions is the threat of a history rewriting attack when posterior corruption is possible: members of past committees may, at some point, have sold their stake in the system, and thus they have nothing to lose to create an alternative version of history.</p>

    <p class="text-gray-300">We rely on a checkpointing idea to provide resilience to such posterior corruption &mdash; as long as there is no late joining or rejoining (we will discuss how to handle late joining or rejoining later). Checkpointing is a technique that has been explored in the classical distributed systems literature <a href="#page-19-5">[16]</a> but typically for different purposes, e.g., in the case of PBFT <a href="#page-19-5">[16]</a> it was used as an efficiency mechanism. Suppose that we can already prove the consistency property as long as there is no majority posterior corruption. Now, to additionally handle majority posterior corruption, we can have alert nodes always reject any chain that diverges from its current longest chain at a point sufficiently far back in the past (say, at least W time steps ago). In this way, old committee members that have since become corrupt cannot convince alert nodes to revise history that is too far back &mdash; in other words, the confirmed transaction log stabilizes and becomes immutable after a while.</p>

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8">2.4 Late Joining in the Presence of Posterior Corruption</h3>

    <p class="text-gray-300">Indeed, the above approach almost would work, if there are no late spawning nodes, and if there are no nodes who wake up after sleeping for a long time. However, as mentioned earlier, handling late joining is important for a decentralized network.</p>

    <p class="text-gray-300">Recall that we described a history revision attack earlier, where if the majority of an old committee become corrupt at a later point of time, they can simulate an alternate past, and convince a newly joining node believe in the alternate past. Therefore, it seems that the crux is the following question:</p>

    <p class="text-gray-300">How can a node joining the protocol correctly identify the true version of history?</p>

    <p class="text-gray-300">Unfortunately, it turns out that this is impossible without additional trust &mdash; in fact, we can formalize the aforementioned attack and prove a lower bound (Section <a href="#page-35-0">D)</a> which essentially shows that in the presence of majority posterior corruption, a newly joining node has no means of discerning a real history from a simulated one:</p>

    <p class="text-gray-300">[Lower bound for posterior corruption]: Absent any additional trust, it is impossible to achieve consensus under sporadic participation, if the majority of an old committee can become corrupt later in time.</p>

    <p class="text-gray-300">We therefore ask the following question: what minimal, additional trust assumptions can we make such that we can defend against majority posterior corruption? Informally speaking, we show that all we need is a secure bootstrapping process for newly joining nodes as described below. We assume that a newly joining node is provided with a list of nodes L the majority of whom must be alert &mdash; if so, the new node can ask the list of nodes in L to vote on the current state of the system, and thus it will not be mislead to choose a &quot;simulated&quot; version of the history.</p>

      <h3 id="sec-2.5" class="text-xl font-semibold mt-8">2.5 Putting it Altogether: Informal Overview of Snow White</h3>

    <p class="text-gray-300">In summary, our protocol, roughly speaking, works as follows. A formal description of the protocol, the parameter choices and their relations, and proofs of security are deferred to Section <a href="#page-26-0">C.</a></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>First, there is a random oracle H that determines if a member of the present committee is a leader in each time step. If a node is leader in a time step t, he can extend the blockchain with a block of the format (h&minus;1,txs,time, nonce, pk, &sigma;), where h&minus;<sup>1</sup> is the previous block's hash, txs is a set of transactions to be confirmed, nonce is a random seed that will be useful later, pk is the node's public key, and &sigma; is a signature under pk on the entire contents of the block. A node can verify the validity of the block by checking that 1) H nonce<sup>e</sup> (pk,time) &lt; D<sup>p</sup> where D<sup>p</sup> is a difficulty parameter<a href="#page-10-0">4</a> such that the hash outcome is smaller than D<sup>p</sup> with probability p, and nonce<sup>e</sup> is a nonce that is reselected every epoch (we will describe how the nonce is selected later); 2) the signature &sigma; verifies under pk; and 3) pk is a member of the present committee as defined by the prefix of the blockchain.</li>
      <li>A valid blockchain's timestamps must respect two constraints: 1) all timestamps must strictly increase; and 2) any timestamp in the future will cause a chain to be rejected.</li>
      <li>Next, to defend against old committees that have since become corrupt from rewriting history, whenever an alert node receives a valid chain that is longer than his own, he only accepts the incoming chain if the incoming chain does not modify blocks too far in the past, where &quot;too far back&quot; is defined by the parameter &kappa;0.</li>
      <li>Next, a newly joining node or a node waking up from long sleep must invoke a secure bootstrapping mechanism such that it can identify the correct version of the history to believe in. One mechanism to achieve this is for the (re)spawning node to contact a list of nodes the majority of whom are alert.</li>
      <li>Finally, our protocol defines each contiguous Tepoch time steps to be an epoch. At the beginning of each epoch, committee reconfiguration is performed in the following manner. First, nodes find</li>
    </ul>

    <p class="text-gray-300"><sup>4</sup>As we discuss Remark <a href="#page-35-1">1</a> in the formal sections, in practice, the next committee is read from a stabilized prefix of the blockchain and we know its total size a-priori. Therefore, assuming that an upper bound on the fraction of awake nodes (out of each committee) is known a-priori, we can set the difficulty parameter D<sup>p</sup> accordingly to ensure that the expected block interval is sufficiently large w.r.t. to the maximum network delay (and if the upper bound is loose, then the confirmation time is proportionally slower). Although on the surface our analysis assumes a fixed expected block interval throughout, it easily generalizes to the case when the expected block interval varies by a known constant factor throughout (and is sufficiently large w.r.t. to the maximum network delay).</p>

    <p class="text-gray-300">the latest prefix (henceforth denoted chain&minus;2&omega;) in their local chain whose timestamp is at least 2&omega; steps ago. This prefix chain&minus;2<sup>&omega;</sup> will be used to determine the next committee &mdash; and Snow White defers to the application-layer to define how specifically to extract the next committee from the state defined by chain&minus;2&omega;. Next, nodes find the latest prefix (denoted chain&minus;&omega;) in their local chain whose timestamp is at least &omega; steps ago. Given this prefix chain&minus;&omega;, we extract the nonces contained in all blocks, the resulting concatenated nonce will be used to seed the hash function H for the next epoch.</p>

    <p class="text-gray-300">Resilience condition. In the appendices, we will give a formal presentation of our protocol and prove it secure under the following resilience condition. We require that the majority of the committee remain honest not only during the time it is active, but also for a short duration (e.g., a handoff period) afterwards. In particular, even if the entire committee becomes corrupt after this handoff period, it should not matter to security.</p>

    <p class="text-gray-300">In other words, we require that for any committee, the number of alert committee members that remain honest for a window of W outnumber the number of committee members that become corrupt during the same window. In particular, we will parametrize the window W such that it incorporates this short handoff period after the committee becomes inactive. Somewhat more formally, we require that there exists a constant &psi; &gt; 0 such that for every possible execution trace view, for every t &le; |view|, let r = min(t + W, |view|),</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\mathsf{alert}^t(\\mathsf{cmt}^t(\\mathsf{view}),\\mathsf{view}) \\cap \\mathsf{honest}^r(\\mathsf{cmt}^t(\\mathsf{view}),\\mathsf{view})}{\\mathsf{corrupt}^r(\\mathsf{cmt}^t(\\mathsf{view}),\\mathsf{view})} \\geq 1 + \\psi \\tag{1}</span>$</p>

    <p class="text-gray-300">where alert<sup>t</sup> (cmt<sup>s</sup> (view), view), honest<sup>t</sup> (cmt<sup>s</sup> (view), view), and corrupt<sup>t</sup> (cmt<sup>s</sup> (view), view) output the number of nodes in the committee of time s that are alert (or honest, corrupt, resp.) at time t.</p>

    <p class="text-gray-300">We now discuss how to apply our core consensus protocol in a proof-of-stake (PoS) application. There are two challenges: 1) in a system where money can switch hands, how to make the committee composition closely track the stake distribution over time; and 2) how to distribute fees and rewards to ensure incentive compatibility.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Base Security on Distribution of Stake</h3>

    <p class="text-gray-300">Roughly speaking, our core consensus protocol expects the following assumption for security: at any point of time, there are more alert committee members that will remain honest sufficiently long than there are corrupt committee members. In a proof-of-stake setting, we would like to articulate assumptions regarding the distribution of stake among stake-holders, and state the protocol's security in terms of such assumptions.</p>

    <p class="text-gray-300">Since our core consensus protocol allows a committee reelection opportunity once every epoch, it is possible that the distribution of the stake in the system lags behind the committee election. However, suppose that this is not the case, e.g., pretend for now that there is no money transfer, then it is simple to translate the assumptions to distribution on stake. Imagine that the applicationdefined elect cmt(chain) function will output one public key for each unit of currency as expressed by the state of chain. If a public key has many units of coin, one could simply output the public key pk along with its multiplicity m &mdash; and the strings pk||1,...,pk||m may be used in the hash query for determining the leader. Snow White's core consensus protocol does not care about the implementation details of  <span class="math">elect\\_cmt(chain)</span> , and in fact that is an advantage of our modular composition approach. In this way, our Snow White protocol retains security as long as the at any point of time, more stake is alert and will remain honest sufficiently long than the stake that is corrupt. Here when we say &quot;a unit of stake is alert (or honest, corrupt, resp.)&quot;, we mean that the node that owns this unit of stake is alert (or honest, corrupt, resp.).</p>

    <p class="text-gray-300">In the real world, however, there is money transfer &mdash; after all that is the entire point of having cryptocurrencies &mdash; therefore the committee election lags behind the redistribution of stake. This may give rise to the following attack: once a next committee is elected, the majority of the stake in the committee can now sell their currency units and perform an attack on the cryptocurrency (since they now no longer have stake). For example, the corrupt coalition can perform a double-spending attack where they spend their stake but attempt to fork a history where they did not spend the money.</p>

    <p class="text-gray-300">The limited liquidity assumption. One approach to thwart such an attack is to limit the liquidity in the system &mdash; in fact, Snow White expects that the cryptocurrency layer enforces that money will not switch hands too quickly. For example, imagine that at any point of time, a=30% of the stake is alert and will remain honest sufficiently long, c=20% is corrupt, and the rest are sleepy. We can have the cryptocurrency layer enforce the following rule: only  <span class="math">\\frac{a-c}{2}-\\epsilon=5\\%-\\epsilon</span>  of the stake can switch hands during every window of size  <span class="math">2\\omega+T_{\\rm epoch}+W</span> . In other words, if in any appropriately long window, only l fraction of money in the system can move, it holds that as long as at any time,  <span class="math">2l+\\epsilon</span>  more stake is alert and remain honest sufficiently long than the stake that is corrupt, we can guarantee that the conditions expected by the consensus protocol, that is, at any time, more committee members are alert and remain honest sufficiently long, than the committee members that are corrupt.</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Fair Reward Scheme</h3>

    <p class="text-gray-300">In a practical deployment, an important desideratum is incentive compatibility. Roughly speaking, we hope that each node will earn a &quot;fair share&quot; of rewards and transaction fees &mdash; and in a proof-of-stake system, fairness is defined as being proportional to the amount of stake a node has. In particular, any minority coalition of nodes should not be able to obtain an unfair share of the rewards by deviating from the protocol &mdash; in this way, rational nodes should not be incentivized to deviate.</p>

    <p class="text-gray-300">Since Snow White is a blockchain-style protocol, we also inherit the well-known selfish mining attack [24, 45] where a minority coalition can increase its rewards by a factor of nearly 2 in the worst case. Fortunately, inspired by the recent work Fruitchains [46] we provide a solution to provably defend against any form of selfish mining attacks, and ensure that the honest protocol is a coalition-safe  <span class="math">\\epsilon</span> -Nash equilibrium. At a high level, Fruitchains provides a mechanism to transform any (possibly unfair) blockchain that achieves consistency and liveness into an approximately fair blockchain in a blackbox manner. Our key observation is that this transformation is also applicable to our non-proof-of-work blockchain &mdash; since we realize the same abstraction as a proof-of-work blockchain. Since we apply the essentially same techniques below as Fruitchains, we give an overview of the mechanisms below for completeness and refer the reader to Fruitchains [46] for full details.</p>

    <p class="text-gray-300">Two mining processes. Like in Fruitchains [46], we propose to have two &quot;mining&quot; processes</p>

    <p class="text-gray-300">piggybacked atop each other. Recall that earlier each node invokes the hash function H in every time step to determine whether it is a leader in this time step. Now, we will use the first half of H to determine leadership, and use the second half to determine if the user mines a &quot;fruit&quot; in this time step. Additionally, we will add to the input of H the digest of a recently stablized block such that any fruit mined will &quot;hang&quot; from a recently stablized block &mdash; which block a fruit hangs from indicates the roughly when the fruit was &quot;mined&quot;, i.e., the <em>freshness</em> of the fruit. Whenever an honest node finds a fruit, it broadcasts the fruit to all peers, and honest nodes will incorporate all outstanding and fresh fruits in any block that it &quot;mines&quot;. Note that fruits incorporated in blocks are only considered valid if they are sufficiently fresh. Finally, all valid fruits contained in the blockchain can be linearized, resulting in an ordered &quot;fruit chain&quot;.</p>

    <p class="text-gray-300">The formal analysis conducted in Fruitchains [46] can be adapted to our setting in a straightforward manner, giving rise to the following informal claim:</p>

    <p class="text-gray-300">Claim 1 (Approximate fairness [46]). Assume appropriate parameters. Then for any (arbitrarily small) constant  <span class="math">\\epsilon</span> , in any  <span class="math">\\frac{\\kappa}{\\epsilon}</span>  number of consecutive fruits, the fraction of fruits belonging to an adversarial coalition is at most  <span class="math">\\epsilon</span>  fraction more than its fair share, as long as, informally speaking, in any committee, alert committee members that remain honest by the posterior corruption window outnumber members that become corrupt by the same window.</p>

    <p class="text-gray-300">We refer the reader to Fruitchains [46] for a formal proof of this claim. Intuitively, this claim holds because the underlying blockchain's liveness property ensures that no honest fruits will ever be lost (i.e., the adversary cannot &quot;erase&quot; honest nodes' work in mining fruits like what happens in a selfish mining attack); and moreover, in any sufficiently long window, the adversary can incorporate only legitimate fruits belonging to this window (and not any fruits  <span class="math">\\epsilon</span> -far into the past or future).</p>

    <p class="text-gray-300"><strong>Payout distribution.</strong> Based on the above claim of approximate fairness, we devise the following payout mechanism following the approach of Fruitchain [46]. We will distribute all forms of payout, including mining rewards and transaction fees to fruits rather than blocks. Furthermore, every time payout is issued, it will be distributed equally among a recent segment of roughly  <span class="math">\\Omega(\\frac{\\kappa}{\\epsilon})</span>  fruits. Like in Fruitchains, this guarantees that as long as at any time, there are more alert committee members that remain honest sufficiently long than corrupt committee members, the corrupt coalition cannot increase its share by more than  <span class="math">\\epsilon</span>  no matter how it deviates from the prescribed protocol &mdash; in other words, the honest protocol is a coalition-safe  <span class="math">\\epsilon</span> -Nash equilibrium.</p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 Thwarting Nothing-at-Stake Attacks</h3>

    <p class="text-gray-300">Nothing-at-stake refers to a class of well-known attacks in the proof-of-stake context [50], where participants have nothing to lose for signing multiple forked histories. We describe how Snow White defends against such attacks. Nothing-at-stake attacks apply to both signing forked chains in the past and in the present &mdash; since the former refers to posterior corruption style attacks which we already addressed earlier, in the discussion below, we focus on signing forked chains in the present.</p>

    <p class="text-gray-300">First, as long as the adversary does not control the majority, our core consensus protocol formally guarantees that signing forked chains does not break consistency. In fact, we incentivize honest behavior by proving that the adversary cannot increase its rewards by an arbitrarily small  <span class="math">\\epsilon</span>  fraction, no matter how it deviates from honest behavior which includes signing forked chains.</p>

    <p class="text-gray-300">With  <span class="math">\\epsilon</span> -Nash equilibrium, one limitation is that players can still do a small  <span class="math">\\epsilon</span>  fraction better by deviating, and it would be desirable to enforce a stronger notion where players do strictly worse</p>

    <p class="text-gray-300">    <img src="_page_14_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 1: How many blocks to wait for a desired probability of consistency failure. Network delay = 10 seconds, expected block interval = 10 minutes, Snow White's leader election interval = 1 second. The largest mining pool at the time of writing has 16.5% hashpower. In all configurations, Snow White needs to wait for 34% to 43% more blocks than Bitcoin for the same consistency failure probability. Note that all subfigures have different y-axes.</p>

    <p class="text-gray-300">by deviating. We can make sure that nothing-at-stake attackers do strictly worse by introducing a penalty mechanism in the cryptocurrency layer: by having players that sign multiple blocks with the same timestamp lose an appropriate amount of collateral &mdash; to achieve this we need that the underlying core consensus protocol achieves consistency, when roughly speaking, the adversary controls only the minority. Even absent such a penalty mechanism, players currently serving on a committee likely care about the overall health of the cryptocurrency system where they still hold stake due to the limited liquidity assumption &mdash; this also provides disincentives for deviating.</p>

    <p class="text-gray-300">The holy grail, of course, is to design a provably secure protocol where <em>any</em> deviation, not just nothing-at-stake attacks, cause the player to do strictly worse. We leave this as an exciting open question. It would also be interesting to consider security when the attack controls the majority &mdash; however, if such a majority attacker can behave arbitrarily, consistency was shown to be impossible [48]. Therefore, it thus remains an open question even what meaningful notions of security one can hope for under possibly majority corruption.</p>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Simulation and Concrete Parameters</h2>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Simulation Methodology</h3>

    <p class="text-gray-300">As mentioned earlier, in blockchain-style consensus (including Nakamoto's proof-of-work blockchain [44] as well as Snow White), the probability of a consistency failure (which, in practice, can lead to a double-spending attack) drops as one waits for more blocks to be confirmed. Therefore, one interesting and highly relevant question is the following: how many blocks must I wait till I can be sure that my transaction will not be double-spent with all but X% failure probability? To the best of our knowledge, so far, no results of this nature have been reported even for Nakamoto's proof-of-work blockchain protocol that is widely deployed. For this reason, we believe that our blockchain stochastic simulator can be of independent interest to the community, and we plan to open source the code in the near future.</p>

    <p class="text-gray-300">The simulator. Our blockchain simulator has been implemented in two languages, namely, C++</p>

    <p class="text-gray-300">and Python, such that we could corroborate the correctness of the results. For both Nakamoto's blockchain and Snow White, our simulator simulates the stochastic block mining process for both honest and corrupt nodes.</p>

    <p class="text-gray-300">Stochastic simulation methodology. For each configuration, we simulate 12.7 million to 13.3 million runs. For each run, we first run the blockchain simulation for sufficiently long such that the stochastic process enters steady state. Then, we choose a block and simulate the &quot;optimal attack&quot; on this block where adversary aims to maintain divergence for as long as possible. The maximum number of blocks for which the adversary can maintain divergence before a forced convergence occurs is henceforth referred to as the maximum divergence length, and this is equivalent to the number of blocks one must wait before this given transaction becomes stable. We then plot the fraction of runs during which this maximum divergence length exceeds Y for different choices of Y . The simulation considers the hash function to be a perfect random oracle, and for Snow White, at the moment the simulation does not consider the effects of attacks where the adversary biases the hashes.</p>

    <p class="text-gray-300">Parameter configurations. We plot our results for the following typical setting. For Bitcoin, we choose a network delay of 10 seconds as Decker and Wattenhofer's excellent measurement result suggests <a href="#page-20-6">[20]</a>; and we adopt an average inter-block time of 10 minutes as in Bitcoin. To be fair in the comparison, we choose the same network delay for Snow White, and we perform leader election per second (i.e., each node only computes one hash function per second).</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Simulation Results</h3>

    <p class="text-gray-300">Our results are shown in Figure <a href="#page-14-0">1,</a> where the x-axis denotes the security parameter, and the y-axis is the maximum divergence length (i.e., the number of blocks to wait till convergence). A specific data point (x, y) can be read as:</p>

    <p class="text-gray-300">For any given transaction that I care about, if I waited for at least y blocks, the probability that my transaction will be double-spent is less than 2&minus;<sup>x</sup> .</p>

    <p class="text-gray-300">We highlight a couple interesting findings:</p>

    <p class="text-gray-300">Comparison of Snow White and Bitcoin. Our result shows that for a fixed network delay, and suppose that the expected block interval is set to be 60 times the network delay (as is the case with Bitcoin), to achieve a desired probability of consistency failure, Snow White needs to wait for 34% to 43% more blocks than Bitcoin &mdash; this can be regarded as a reasonable price one pays for removing the proof-of-work and the enormous energy waste. As explain earlier, this slowdown stems from the fact that the Snow White adversary can reuse an earned time slot which gives the adversary additional advantage in a consistency attack. Further, the result (particularly, the fact that all are straight lines) shows that in both Bitcoin and Snow White, the probability of divergence drops exponentially in terms of the number of blocks one waits.</p>

    <p class="text-gray-300">Concrete parameters. At the time of the writing, the largest mining pool, AntPool, controls about 16.5% of the hashpower; and the second largest pool, F2Pool, controls about 12.5% of the hashpower <a href="#page-19-6">[1]</a>. Our results show the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>To defend against a 16.5% adversary (comparable to Bitcoin's largest mining pool), one needs to wait for roughly 7 blocks for Bitcoin, and roughly 10 blocks for Snow White, to get 99% assurance that any given transaction will not be double-spent &mdash; note that there is no proof-of-work in Snow White, but we still use Bitcoin's pool size as an interesting data point to compare with Bitcoin.</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>To defend against a 30% adversary (e.g., comparable to the sum of the largest two Bitcoin pools), one needs to wait for roughly 23 blocks in Bitcoin and 33 blocks for Snow White, to obtain a 99% assurance.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>As is theoretically proven <a href="#page-21-1">[45]</a>, Bitcoin can resist a 49% attack under these parametrizations (10-second network delay and 10-minute block interval). However, our simulation shows that the concrete parameters needed for consistency may not be as optimistic as some might have imagined &mdash; even when the adversary controls only 45% of the hashpower, one must wait for 81 blocks to obtain only 75% assurance. Similarly, Snow White can also resist a 49% percent attack if one waited sufficiently long, but the concrete wait time needed for consistency are rather large (assuming optimal attack conditions).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Our simulation assumes optimal attack conditions for the adversary, i.e., the adversary has full control over the network as long as honest nodes' messages are delayed by at most 10 seconds &mdash; specifically, this means that the adversary can perform a network rushing attack such that adversarial blocks on the fly can arrive at honest nodes earlier. In practice, when the condition is not so ideal for the adversary, the practical parameter needed for consistency can be smaller.</p>

    <p class="text-gray-300">To further prove the efficacy of Snow White in production environments, we implemented the Snow White protocol. It would have been ideal to deploy Snow White on a wide scale in a production setting and perform a more realistic evaluation &mdash; but we leave this as future work. Instead we evaluate the throughput of Snow White in a 40-node deployment, under a high-bandwidth and low latency environment. We focus on reporting best-case throughput results through comparison with a crash-fault resilient Proof-of-Stake solution implemented by Parity, called Authority chains <a href="#page-20-7">[29]</a>. Specifically, we compare with the &quot;Authority Round&quot; protocol, the default recommendation for Parity Authority chains. Since the latter does not support committee reconfiguration at this moment, we compare both schemes' throughput under a static committee. Our throughput experiments are conducted in a benign environment absent any attacks. Note that &quot;Authority Round&quot; does not have provable security: our evaluation results will show comparable performance of both schemes, with Snow White providing the added benefits of rigorous security guarantees.</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 Design</h3>

    <p class="text-gray-300">We start with the Parity, the Rust-based Ethereum client <a href="#page-20-8">[23]</a>. During recent stress tests and attacks on the Ethereum network, the Parity client has proved by far the most robust and fastest client available <a href="#page-19-7">[9]</a>. We choose this client exclusively for its speed; because our evaluation attempts to establish performance bounds for Snow White, choosing a base client for its speed (transaction throughput and block processing time) is the only logical criterion. Other available Ethereum clients include pyethereum (in Python) and geth (in Go). We intend the combination of our reference implementation for Parity and the specification in this work to be sufficient to port Snow White to these clients if desired.</p>

    <p class="text-gray-300">Also beneficial in Parity is the ability to define modules with &quot;puzzle engines&quot;, or replacements for the proof of work mechanism underlying Ethereum, as plugins <a href="#page-20-7">[29]</a>. This allowed us to cleanly define Snow White as a plugin to Parity, making it compatible with Parity's full infrastructure and any tools developed for Ethereum (including contract languages, compilers, blockchain explorers,</p>

    <p class="text-gray-300">    <img src="_page_17_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 2: Best-case performance evaluation</p>

    <p class="text-gray-300">and many more). This also allows us to easily leverage Parity's rapid pace of development (with dozens of commit per day typically) without large refactors.</p>

    <p class="text-gray-300">We base our prototype on Parity's &quot;Basic Authority&quot; chain security algorithm, in which a static set of authorities is specified in a chain specification file, and these authorities are allowed to sign blocks with no further restrictions. Adding in the restrictions required for Snow White results in our functional implementation.</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Evaluation</h3>

    <p class="text-gray-300">We manually configured the network such that each node was fully peered, ensuring a fully connected network graph. We also took advantage of Amazon's relatively low latency connections between regions to push our parameters beyond normal operation, establishing an upper bound for our system and a reasonable performance estimate on well connected infrastructure (such as in a private deployment at a bank). Obviously, requiring performance across a wide variety of lower quality Internet connections would decrease throughput substantially. We also used a minimum time interval (time between blocks) of 5 seconds in both security algorithms; minimum times lower than this lead to excess on-chain contention and thus decreased throughput.</p>

    <p class="text-gray-300">To measure the throughput, we took the longest blockchain generated by our experiment and took a moving average of number of transactions processed per second over 60 seconds. This is because blocks are generated in discrete intervals, which cause unreadable throughput spikes.</p>

    <p class="text-gray-300">The results are shown in Figure <a href="#page-17-0">2.</a> The two upper lines represent the observed performance of both Snow White and Parity's Authority chain over a fifteen minute run, in which all nodes were submitting the maximum amount of possible transactions through the Parity RPC interface. This mimics real-world deployments of such chains, in which users (and other software components) submit transactions through RPC.</p>

    <p class="text-gray-300">The performance of Snow White and Parity is so close as to be virtually indistinguishable, demonstrating that Snow White is able to hit the theoretical upper bound of the Ethereum software's performance without hitting any mining-related bottlenecks. Both Snow White and Parity's Authority chains operate in a range between 100 and 150 transactions per second, which with an average observed transaction size of 111 bytes, corresponds to under 16kB of block space per second and is obviously nowhere near saturating the bandwidth or block latency bottlenecks we describe in this work.</p>

    <p class="text-gray-300">We also graph the capacities of the permissionless Bitcoin and Ethereum networks in the same figure, showing that they are approximately 1 and 2 orders of magnitude lower than our system's empirical upper bound. While obviously a tit-for-tat comparison is disingenuous, as both Bitcoin and Ethereum use significantly lower quality network links on a wider variety of machines, this does show that adoption of Snow White by the permissionless blockchain community is feasible today without approaching the upper-bound capacity of Snow White.</p>

    <p class="text-gray-300">We thus conclude that Snow White is a useful replacement for Authority chains today. As tested, Authority chains are not Byzantine fault tolerant, making it a significantly weaker protocol than Snow White. Additionally, claims of BFT operation modes in Authority chains are not accompanied by proof or justification as found in this paper, making the claims highly dubious. It is thus our recommendation that the Ethereum community switch to Snow White for Authority chains, at a significant security gain with zero performance penalty.</p>

    <p class="text-gray-300">This CPU bottleneck demonstrated by the performance of our widely distributed network approaches the performance of a single node which engages in no network communication, which we measured at approximately 125 tx/s. As we have shown, our theoretical upper bound on performance in the current prototype is already an order of magnitude higher than the maximum throughput of the decentralized Bitcoin network. As the permissionless algorithm adds little to no additional computational overhead, we expect Snow White to fully satisfy the performance requirements of securing a distributed and permissionless ledger.</p>

    <p class="text-gray-300">We hope to continue developing and refining this prototype into a robust implementation usable by both permissioned and permissionless blockchains, providing the ultimate in provable security, performance, and simplicity for future blockchain deployments.</p>

    <p class="text-gray-300">We present the full formalism and proofs in the appendices.</p>

    <p class="text-gray-300">We gratefully acknowledge Siqiu Yao and Yuncong Hu for lending criticial help in building the simulator. We thank Lorenzo Alvisi for suggesting the name Snow White. We also thank Rachit Agarwal, Kai-Min Chung, and Ittay Eyal for helpful and supportive discussions. This work is in part supported by NSF under grant number CNS-1561209.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[1] Hashrate distribution. <a href="https://blockchain.info/pools" target="_blank" rel="noopener noreferrer">https://blockchain.info/pools</a>.</p></li>
      <li><p class="text-gray-300">[2] Personal communication with Vitalik Buterin, and public talks on sharding by Vitalik Buterin, 2018.</p></li>
      <li><p class="text-gray-300">[3] B. Barak, R. Canetti, Y. Lindell, R. Pass, and T. Rabin. Secure computation without authentication. In CRYPTO, pages 361&ndash;377, 2005.</p></li>
      <li><p class="text-gray-300">[4] S. Barber, X. Boyen, E. Shi, and E. Uzun. Bitter to betterhow to make bitcoin a better currency. In Financial cryptography and data security, pages 399&ndash;414. Springer, 2012.</p></li>
      <li><p class="text-gray-300">[5] M. Ben-Or. Another advantage of free choice (extended abstract): Completely asynchronous agreement protocols. In Proceedings of the Second Annual ACM Symposium on Principles of Distributed Computing, PODC '83, pages 27&ndash;30, New York, NY, USA, 1983. ACM.</p></li>
      <li><p class="text-gray-300">[6] I. Bentov, A. Gabizon, and A. Mizrahi. Cryptocurrencies without proof of work. In Financial Cryptography Bitcoin Workshop, 2016.</p></li>
      <li><p class="text-gray-300">[7] I. Bentov, C. Lee, A. Mizrahi, and M. Rosenfeld. Proof of activity: Extending bitcoin's proof of work via proof of stake. In Proceedings of the ACM SIGMETRICS 2014 Workshop on Economics of Networked Systems, NetEcon, 2014.</p></li>
      <li><p class="text-gray-300">[8] A. N. Bessani, J. Sousa, and E. A. P. Alchieri. State machine replication for the masses with BFT-SMART. In DSN, pages 355&ndash;362, 2014.</p></li>
      <li><p class="text-gray-300">[9] E. Blog. Performance analysis. <a href="https://blog.ethcore.io/performance-analysis/" target="_blank" rel="noopener noreferrer">https://blog.ethcore.io/performance-analysis/</a>, 2016. Accessed: 2016-11-01.</p></li>
      <li><p class="text-gray-300">[10] J. Bonneau, J. Clark, and S. Goldfeder. On bitcoin as a public randomness source. IACR Cryptology ePrint Archive, 2015:1015, 2015.</p></li>
      <li><p class="text-gray-300">[11] G. Bracha and S. Toueg. Asynchronous consensus and broadcast protocols. J. ACM, 32(4):824&ndash; 840, Oct. 1985.</p></li>
      <li><p class="text-gray-300">[12] C. Cachin, K. Kursawe, F. Petzold, and V. Shoup. Secure and efficient asynchronous broadcast protocols. In Advances in Cryptology - CRYPTO 2001, 21st Annual International Cryptology Conference, Santa Barbara, California, USA, August 19-23, 2001, Proceedings, pages 524&ndash;541, 2001.</p></li>
      <li><p class="text-gray-300">[13] R. Canetti. Universally composable security: A new paradigm for cryptographic protocols. In FOCS, 2001.</p></li>
      <li><p class="text-gray-300">[14] R. Canetti, Y. Dodis, R. Pass, and S. Walfish. Universally composable security with global setup. In Theory of Cryptography, pages 61&ndash;85. Springer, 2007.</p></li>
      <li><p class="text-gray-300">[15] R. Canetti and T. Rabin. Universal composition with joint state. In CRYPTO, 2003.</p></li>
      <li><p class="text-gray-300">[16] M. Castro and B. Liskov. Practical byzantine fault tolerance. In OSDI, 1999.</p></li>
      <li><p class="text-gray-300">[17] J. Chen and S. Micali. Algorand: The efficient and democratic ledger. https://arxiv.org/abs/1607.01341, 2016.</p></li>
      <li><p class="text-gray-300">[18] U. &quot;cunicula&quot; and M. Rosenfeld. Proof of stake brainstorming. <a href="https://bitcointalk.org/index.php?topic=37194.0" target="_blank" rel="noopener noreferrer">https://bitcointalk.org/</a> <a href="https://bitcointalk.org/index.php?topic=37194.0" target="_blank" rel="noopener noreferrer">index.php?topic=37194.0</a>, August 2011.</p></li>
      <li><p class="text-gray-300">[19] B. David, P. Ga&#711;zi, A. Kiayias, and A. Russell. Ouroboros praos: An adaptively-secure, semisynchronous proof-of-stake protocol. Cryptology ePrint Archive, Report 2017/573, 2017. <a href="http://eprint.iacr.org/2017/573" target="_blank" rel="noopener noreferrer">http:</a> <a href="http://eprint.iacr.org/2017/573" target="_blank" rel="noopener noreferrer">//eprint.iacr.org/2017/573</a>.</p></li>
      <li><p class="text-gray-300">[20] C. Decker and R. Wattenhofer. Information propagation in the bitcoin network. In IEEE P2P, 2013.</p></li>
      <li><p class="text-gray-300">[21] D. Dolev and H. R. Strong. Authenticated algorithms for byzantine agreement. Siam Journal on Computing - SIAMCOMP, 12(4):656&ndash;666, 1983.</p></li>
      <li><p class="text-gray-300">[22] C. Dwork, N. Lynch, and L. Stockmeyer. Consensus in the presence of partial synchrony. J. ACM, 1988.</p></li>
      <li><p class="text-gray-300">[23] Ethcore. Parity. <a href="https://ethcore.io/parity.html" target="_blank" rel="noopener noreferrer">https://ethcore.io/parity.html</a>, 2016. Accessed: 2016-11-01.</p></li>
      <li><p class="text-gray-300">[24] I. Eyal and E. G. Sirer. Majority is not enough: Bitcoin mining is vulnerable. In FC, 2014.</p></li>
      <li><p class="text-gray-300">[25] P. Feldman and S. Micali. An optimal probabilistic protocol for synchronous byzantine agreement. In SIAM Journal of Computing, 1997.</p></li>
      <li><p class="text-gray-300">[26] M. J. Fischer, N. A. Lynch, and M. S. Paterson. Impossibility of distributed consensus with one faulty process. J. ACM, 32(2):374&ndash;382, Apr. 1985.</p></li>
      <li><p class="text-gray-300">[27] R. Friedman, A. Mostefaoui, and M. Raynal. Simple and efficient oracle-based consensus protocols for asynchronous byzantine systems. IEEE Trans. Dependable Secur. Comput., 2(1):46&ndash;56, Jan. 2005.</p></li>
      <li><p class="text-gray-300">[28] J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol: Analysis and applications. In Eurocrypt, 2015.</p></li>
      <li><p class="text-gray-300">[29] P. Github. Proof of Authority Chains. <a href="https://github.com/ethcore/parity/wiki/Proof-of-Authority-Chains" target="_blank" rel="noopener noreferrer">https://github.com/ethcore/parity/wiki/</a> <a href="https://github.com/ethcore/parity/wiki/Proof-of-Authority-Chains" target="_blank" rel="noopener noreferrer">Proof-of-Authority-Chains</a>. Accessed: 2016-12-08.</p></li>
      <li><p class="text-gray-300">[30] T. Hanke, M. Movahedi, and D. Williams. Dfinity technology overview series: Consensus system. <a href="https://dfinity.org/tech" target="_blank" rel="noopener noreferrer">https://dfinity.org/tech</a>.</p></li>
      <li><p class="text-gray-300">[31] H. Howard, D. Malkhi, and A. Spiegelman. Flexible paxos: Quorum intersection revisited. <a href="https://arxiv.org/abs/1608.06696" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1608.06696</a>.</p></li>
      <li><p class="text-gray-300">[32] J. Katz and C.-Y. Koo. On expected constant-round protocols for byzantine agreement. J. Comput. Syst. Sci., 75(2):91&ndash;112, Feb. 2009.</p></li>
      <li><p class="text-gray-300">[33] A. Kiayias and G. Panagiotakos. Speed-security tradeoffs in blockchain protocols. IACR Cryptology ePrint Archive, 2015:1019, 2015.</p></li>
      <li><p class="text-gray-300">[34] A. Kiayias, A. Russell, B. David, and R. Oliynykov. Ouroboros: A provably secure proof-ofstake blockchain protocol. In Crypto, 2017.</p></li>
      <li><p class="text-gray-300">[35] S. King and S. Nadal. Ppcoin: Peer-to-peer crypto-currency with proof-of-stake. <a href="https://peercoin.net/assets/paper/peercoin-paper.pdf" target="_blank" rel="noopener noreferrer">https:</a> <a href="https://peercoin.net/assets/paper/peercoin-paper.pdf" target="_blank" rel="noopener noreferrer">//peercoin.net/assets/paper/peercoin-paper.pdf</a>, 2012.</p></li>
      <li><p class="text-gray-300">[36] J. Kwon. Tendermint: Consensus without mining. <a href="http://tendermint.com/docs/tendermint.pdf" target="_blank" rel="noopener noreferrer">http://tendermint.com/docs/</a> <a href="http://tendermint.com/docs/tendermint.pdf" target="_blank" rel="noopener noreferrer">tendermint.pdf</a>, 2014.</p></li>
      <li><p class="text-gray-300">[37] L. Lamport. The weak byzantine generals problem. J. ACM, 30(3):668&ndash;676, 1983.</p></li>
      <li><p class="text-gray-300">[38] L. Lamport. Fast paxos. Distributed Computing, 19(2):79&ndash;103, 2006.</p></li>
      <li><p class="text-gray-300">[39] L. Lamport, D. Malkhi, and L. Zhou. Vertical paxos and primary-backup replication. In PODC, pages 312&ndash;313, 2009.</p></li>
      <li><p class="text-gray-300">[40] L. Lamport, R. Shostak, and M. Pease. The byzantine generals problem. ACM Trans. Program. Lang. Syst., 4(3):382&ndash;401, July 1982.</p></li>
      <li><p class="text-gray-300">[41] J.-P. Martin and L. Alvisi. Fast byzantine consensus. IEEE Trans. Dependable Secur. Comput., 3(3), 2006.</p></li>
      <li><p class="text-gray-300">[42] G. Maxwell and A. Poelstra. Distributed consensus from proof of stake is impossible, 2014. <a href="https://download.wpsoftware.net/bitcoin/pos.pdf" target="_blank" rel="noopener noreferrer">https://download.wpsoftware.net/bitcoin/pos.pdf</a>.</p></li>
      <li><p class="text-gray-300">[43] A. Miller, Y. Xia, K. Croman, E. Shi, and D. Song. The honey badger of BFT protocols. Cryptology ePrint Archive, Report 2016/199, 2016. <a href="http://eprint.iacr.org/" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/</a>.</p></li>
      <li><p class="text-gray-300">[44] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system. 2008.</p></li>
      <li><p class="text-gray-300">[45] R. Pass, L. Seeman, and A. Shelat. Analysis of the blockchain protocol in asynchronous networks. In Eurocrypt, 2017.</p></li>
      <li><p class="text-gray-300">[46] R. Pass and E. Shi. Fruitchains: A fair blockchain. Manuscript, 2016.</p></li>
      <li><p class="text-gray-300">[47] R. Pass and E. Shi. Hybrid consensus: Efficient consensus in the permissionless model. Manuscript, 2016.</p></li>
      <li><p class="text-gray-300">[48] R. Pass and E. Shi. The sleepy model of consensus. <a href="http://eprint.iacr.org/2016/918" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2016/918</a>, 2016.</p></li>
      <li><p class="text-gray-300">[49] R. Pass and E. Shi. Rethinking large-scale consensus. In CSF, 2017.</p></li>
      <li><p class="text-gray-300">[50] A. Poelstra. Distributed consensus from proof of stake is impossible. <a href="https://download.wpsoftware.net/bitcoin/alts.pdf" target="_blank" rel="noopener noreferrer">https://download.</a> <a href="https://download.wpsoftware.net/bitcoin/alts.pdf" target="_blank" rel="noopener noreferrer">wpsoftware.net/bitcoin/alts.pdf</a>.</p></li>
      <li><p class="text-gray-300">[51] U. &quot;QuantumMechanic&quot;. Proof of stake instead of proof of work. <a href="https://bitcointalk.org/index.php?topic=27787.0" target="_blank" rel="noopener noreferrer">https://bitcointalk.org/</a> <a href="https://bitcointalk.org/index.php?topic=27787.0" target="_blank" rel="noopener noreferrer">index.php?topic=27787.0</a>, July 2011.</p></li>
      <li><p class="text-gray-300">[52] Y. J. Song and R. van Renesse. Bosco: One-step byzantine asynchronous consensus. In DISC, pages 438&ndash;450, 2008.</p></li>
      <li><p class="text-gray-300">[53] U. &quot;tacotime&quot;. Netcoin proof-of-work and proof-of-stake hybrid design, 2013. <a href="https://web.archive.org/web/20131213085759/http://www.netcoin.io/wiki/Netcoin_Proof-of-Work_and_Proof-of-Stake_Hybrid_Design" target="_blank" rel="noopener noreferrer">https://web.archive.org/web/20131213085759/http://www.netcoin.io/wiki/</a> <a href="https://web.archive.org/web/20131213085759/http://www.netcoin.io/wiki/Netcoin_Proof-of-Work_and_Proof-of-Stake_Hybrid_Design" target="_blank" rel="noopener noreferrer">Netcoin\\_Proof-of-Work\\_and\\_Proof-of-Stake\\_Hybrid\\_Design</a>.</p></li>
      <li><p class="text-gray-300">[54] V. G. Vitalik Buterin. Casper the friendly finality gadget. <a href="https://arxiv.org/abs/1710.09437" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1710.</a> <a href="https://arxiv.org/abs/1710.09437" target="_blank" rel="noopener noreferrer">09437</a>.</p></li>
    </ul>

      <h3 id="app-a.1" class="text-xl font-semibold mt-8">A.1 Protocol Execution Model</h3>

    <p class="text-gray-300">Our protocol execution model extends and enriches the sleepy model <a href="#page-21-7">[48]</a>. To capture a more powerful adversary, we make the following notable changes in modeling in comparison with sleepy <a href="#page-21-7">[48]</a>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We allow dynamic node spawning whereas the basic sleepy model <a href="#page-21-7">[48]</a> requires that all nodes (including honest and corrupt ones) be spawned prior to protocol start.</li>
      <li>We allow the adversary to issue corrupt and sleep instructions after protocol execution starts, whereas in the basic sleepy model <a href="#page-21-7">[48]</a>, all corrupt and sleep instructions must be declared upfront prior to protocol start. Later when we describe our protocol, we will specify further constraints on the adversary, in particular, under what conditions the adversary can corrupt nodes or make them sleep.</li>
      <li>Our model distinguishes between a light sleeper and a deep sleeper and treats them differently. As explained in Sections <a href="#page-5-1">2</a> and <a href="#page-26-0">C,</a> such a distinction is necessary so as not to tread on theoretical impossibility.</li>
    </ul>

    <p class="text-gray-300">Below we elaborate on our execution model in detail. We note that this section focuses on describe the basic execution model. We defer it to later sections to specify precise constraints (e.g., how long it takes for corruption to take effect, what parameters are admissible, etc.) that must be placed on the adversary to prove our protocol secure.</p>

    <p class="text-gray-300">We assume a standard Interactive Turing Machine (ITM) model <a href="#page-19-8">[13&ndash;</a><a href="#page-19-9">15]</a> often adopted in the cryptography literature.</p>

    <p class="text-gray-300">(Weakly) synchronized clocks. We assume that nodes have a globally synchronized clock. In fact, with our network model (to be explained later), we can, without loss of generality, relax this assumption to weakly synchronized, where honest nodes clocks are offset by some a-priori known upper bound &#8710;clock, basically by absorbing the clock offset &#8710;clock into the maximum network delay parameter &#8710; (see earlier work <a href="#page-21-7">[48]</a> for a more detailed explanation).</p>

    <p class="text-gray-300">Corruption model. At any point of time, the environment Z can communicate with corrupt nodes in arbitrary manners. This also implies that the environment can see the internal state of corrupt nodes. Corrupt nodes can deviate from the prescribed protocol arbitrarily, i.e., exhibit byzantine faults. All corrupt nodes are controlled by a probabilistic polynomial-time adversary denoted A, and the adversary can see the internal states of corrupt nodes. For honest nodes, the environment cannot observe their internal state, but can observe any information honest nodes output to the environment by the protocol definition. Specifically, we assume the following corruption model.</p>

    <p class="text-gray-300">&bull; Spawn. At any time, Z can spawn fresh nodes, either alert or corrupt ones.</p>

    <p class="text-gray-300">We assume that upon spawning an alert node i at (the beginning of) time t, (A, Z) must deliver an initialization message to node i. Our protocols later will impose further constraints on this initialization message, and these constraints may imply additional trust assumptions necessary for a node to securely join the protocol. Therefore we defer requirements for the initialization message to protocol-specific compliance rules.</p>

    <p class="text-gray-300">We allow the adversary A to spawn corrupt nodes on its own without informing Z.</p>

    <p class="text-gray-300">&bull; Corrupt. At any time t, A can issue to Z a corruption instruction of the form:</p>

    <p class="text-gray-300"><span class="math">$(\\mathtt{corrupt}, i, t&#x27;) \\text{ where } t&#x27; \\geq t</span>$</p>

    <p class="text-gray-300">A (corrupt, i, t<sup>0</sup> ) instruction causes node i to become corrupt at time t <sup>0</sup> &ge; t (if it did not already become corrupt earlier).</p>

    <p class="text-gray-300">&bull; Sleep. At any time t, A can issue to Z a sleep instruction of the form:</p>

    <p class="text-gray-300">(sleep,
<span class="math">$i, t_0, t_1</span>$
) where  <span class="math">t_0 \\le t \\le t_1</span></p>

    <p class="text-gray-300">A (sleep, i, t0, t1) instruction causes node i to be asleep (or sleeping/sleepy) between time [t0, t1] &mdash; as long as it did not already become corrupt earlier. A sleeping honest node (also called a sleeper) stops receiving or sending messages. If a sleeper does not become corrupt during the time it is asleep, it may wake up later again.</p>

    <p class="text-gray-300">Our model distinguishes between a deep sleeper and a light sleeper. A sleeper that sleeps for a long time before waking up is called a deep sleeper and one that wakes up soon is called a light sleeper. The definition of long and short depends on the protocol, and therefore we defer the concrete parameter specifications to protocol-specific compliance rules.</p>

    <p class="text-gray-300">When a light sleeper wakes up, (A, Z) is required to deliver a wakeup message that is an unordered set containing</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>all the pending messages that node i would have received (but did not receive) had it not slept; and</li>
      <li>any polynomial number of adversarially inserted messages of (A, Z)'s choice.</li>
    </ul>

    <p class="text-gray-300">By contrast, a deep sleeper waking up is treated the same way as node respawning. Specifically, (A, Z) is required to resend the node an initialization message which must satisfy the same requirement of an initialization message for a newly spawning node.</p>

    <p class="text-gray-300">To summarize, a node can be in one of the following states:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Honest. An honest node can either be awake or asleep (or sleeping/sleepy). Henceforth we say that a node is alert if it is honest and awake. When we say that a node is asleep (or sleeping/sleepy), it means that the node is honest and asleep.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Corrupt. Without loss of generality, we assume that all corrupt nodes are awake.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Network delivery. The adversary is responsible for delivering messages between nodes. We assume that the adversary A can delay or reorder messages arbitrarily, as long as it respects the constraint that all messages sent from alert nodes must be received by all alert nodes in at most &#8710; time steps.</p>

      <h3 id="app-a.2" class="text-xl font-semibold mt-8">A.2 Notational Conventions</h3>

    <p class="text-gray-300">Negligible functions. A function negl(&middot;) is said to be negligible if for every polynomial p(&middot;), there exists some &kappa;<sup>0</sup> such that negl(&kappa;) &le; 1 p(&kappa;) for all &kappa; &ge; &kappa;0.</p>

    <p class="text-gray-300">Convention for parameters. In this paper, unless otherwise noted, all variables are by default (polynomially bounded) functions of the security parameter &kappa;. Whenever we say var<sup>0</sup> &gt; var1, this means that var0(&kappa;) &gt; var1(&kappa;) for every &kappa; &isin; N. Variables may also be functions of each other. How various variables are related will become obvious when we define derived variables and when we state parameters' admissible rules for each protocol.</p>

    <p class="text-gray-300">Importantly, whenever a parameter does not depend on &kappa;, we shall explicitly state it by calling it a constant.</p>

    <p class="text-gray-300">Compliant executions. In this paper, for each protocol we introduce (including intermediate ones used in the proofs), we will define compliant executions by specifying a set of constraints on the p.p.t. pair (A, Z). Roughly speaking, our theorems will state that desirable security properties are respected except with negligible probability in any compliant execution. Since compliance is defined per protocol, we will often use the notation &Pi;-compliant (A, Z) to mean that (A, Z) must respect the constraints expected by the &Pi; protocol.</p>

    <p class="text-gray-300">In this section, we define the formal abstraction and security properties of a blockchain. Our definitions follow the approach of Pass et al. <a href="#page-21-1">[45]</a>, which in turn are based on earlier definitions from Garay et al. <a href="#page-20-0">[28]</a>, and Kiayias and Panagiotakos <a href="#page-20-9">[33]</a>.</p>

    <p class="text-gray-300">Since our model distinguishes between two types of honest nodes, alert and sleepy ones, we define chain growth, chain quality, and consistency for alert nodes. However, we point out the following: 1) if chain quality holds for alert nodes, it would also hold for sleepy nodes (since sleepy nodes stop receiving new messages); 2) if consistency holds for alert nodes, then sleep nodes' chains should also satisfy common prefix and future self-consistency, although obviously sleepy nodes' chains can be much shorter than alert ones.</p>

    <p class="text-gray-300">Notations. For some A, Z, consider some view in the support of EXEC&Pi;(A, Z, &kappa;); we use the notation |view| to denote the number of time steps in the execution.</p>

    <p class="text-gray-300">We assume that in every time step, the environment Z provides a possibly empty input to every honest node. Further, in every time step, an alert node sends an output to the environment Z. Given a specific execution trace view with non-zero support where |view| &ge; t, let i denote a node that is alert at time t in view, we use the following notation to denote the output of node i to the environment Z at time step t,</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
    <p class="text-gray-300">output to Z by node i at time t in view: chain<sup>t</sup> i (view)</p>

    </blockquote>

    <p class="text-gray-300">where chain denotes an extracted ideal blockchain where each block contains an ordered list of transactions. Sleepy nodes stop outputting to the environment until they wake up again.</p>

    <p class="text-gray-300">Later in the text, if the context is clear, we sometimes omit writing a subset of the sub- or super-scripts and/or the view &mdash; for example, sometimes we simply write chain if the context is clear.</p>

      <h3 id="app-b.1" class="text-xl font-semibold mt-8">B.1 Chain Growth</h3>

    <p class="text-gray-300">The first desideratum is that the chain grows steadily over time, not too slow, not too fast. Let growtht0,t<sup>1</sup> (view, &#8710;, T) = 1 iff the following holds:</p>

    <p class="text-gray-300">&bull; (consistent length) for all time steps t &le; |view| &minus; &#8710;, t + &#8710; &le; t <sup>0</sup> &le; |view|, for every two players i, j such that in view i is alert at t and j is alert at t 0 , we have that</p>

    <p class="text-gray-300"><span class="math">$|\\mathsf{chain}_j^{t&#x27;}(\\mathsf{view})| \\geq |\\mathsf{chain}_i^t(\\mathsf{view})|</span>$</p>

    <p class="text-gray-300">&bull; (chain growth lower bound) for every time step t &le; |view| &minus; t0, for any node i alert at t and any j alert at t + t0, it holds that</p>

    <p class="text-gray-300"><span class="math">$|\\mathsf{chain}_{j}^{t+t_0}(\\mathsf{view})| - |\\mathsf{chain}_{i}^{t}(\\mathsf{view})| \\geq T.</span>$</p>

    <p class="text-gray-300">&bull; (chain growth upper bound) for every time step t &le; |view| &minus; t1, for any node i alert at t and any j alert at t + t1, it holds that</p>

    <p class="text-gray-300"><span class="math">$|\\mathsf{chain}_j^{t+t_1}(\\mathsf{view})| - |\\mathsf{chain}_i^t(\\mathsf{view})| \\leq T.</span>$</p>

    <p class="text-gray-300">In other words, growtht0,t<sup>1</sup> is a predicate which tests that a) alert parties have chains of roughly the same length, and b) during any t<sup>0</sup> time steps in the execution, all alert parties' chains increase by at least T, and c) during any t<sup>1</sup> time steps in the execution, alert parties' chains increase by at most T.</p>

    <p class="text-gray-300">Definition 1 (Chain growth). A blockchain protocol &Pi; satisfies (T0, g0, g1)-chain growth, if for all &Pi;-compliant p.p.t. pair (A, Z), there exists some negligible function negl such that for every &kappa; &isin; N, T &ge; T0, t<sup>0</sup> &ge; T g0 and t<sup>1</sup> &le; T g1 the following holds:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi}(\\mathcal{A}, \\mathcal{Z}, \\kappa) : \\mathsf{growth}^{t_0, t_1}(\\mathsf{view}, \\Delta, \\kappa) = 1\\right] \\geq 1 - \\mathsf{negl}(\\kappa)$$</p>

      <h3 id="app-b.2" class="text-xl font-semibold mt-8">B.2 Chain Quality</h3>

    <p class="text-gray-300">The second desideratum is that the number of blocks contributed by the adversary is not too large. Given a chain, we say that a block B := chain[j] is honest w.r.t. view and prefix chain[: j 0 ] where j <sup>0</sup> &lt; j if in view there exists some node i alert at some time t &le; |view|, such that 1) chain[: j 0 ] &#8826; chain<sup>t</sup> i (view), and 2) Z input B to node i at time t. Informally, for an honest node's chain denoted chain, a block B := chain[j] is honest w.r.t. a prefix chain[: j 0 ] where j <sup>0</sup> &lt; j, if earlier there is some alert node who received B as input when its local chain contains the prefix chain[: j 0 ].</p>

    <p class="text-gray-300">Let quality<sup>T</sup> (view, &micro;) = 1 iff for every time t and every player i such that i is alert at t in view, among any consecutive sequence of T blocks chain[j + 1..j +T] &sube; chain<sup>t</sup> i (view), the fraction of blocks that are honest w.r.t. view and chain[: j] is at least &micro;.</p>

    <p class="text-gray-300">Definition 2 (Chain quality). A blockchain protocol &Pi; has (T0, &micro;)&minus;chain quality, if for all &Pi;compliant p.p.t. pair (A, Z), there exists some negligible function negl such that for every &kappa; &isin; N and every T &ge; T<sup>0</sup> the following holds:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi}(\\mathcal{A}, \\mathcal{Z}, \\kappa) : \\mathsf{quality}^T(\\mathsf{view}, \\mu) = 1\\right] \\geq 1 - \\mathsf{negl}(\\kappa)$$</p>

    <pre><code class="language-text">Global G
                         &Sigma;
                         sign functionality (possibly shared with other protocols)
On initialization: &Gamma; = &empty;
On receive gen from P:
   (pk,sk) &larr; &Sigma;.gen(1&kappa;
                       ), and add the tuple (P, pk,sk) to table &Gamma;
   Notify A of (P, pk), and return pk
On receive sign(pk, msg) from P in protocol sid:
   assert that a tuple of the form (P, pk,sk) &isin; &Gamma; exists for some sk
   return &Sigma;.Signsk,sid (msg)
On receive getkey(P) from A: if P is corrupt, return all tuples in &Gamma; of the form (P, , ) to A
</code></pre>

    <p class="text-gray-300">Figure 3: Global signing functionality, parametrized by a signature scheme denoted &Sigma; = (Sign, Ver). We use the shorthand Signsk,sid and Verpk,sid to denote that the message is prefixed with the protocol's session identifier sid.</p>

      <h3 id="app-b.3" class="text-xl font-semibold mt-8">B.3 Consistency</h3>

    <p class="text-gray-300">Roughly speaking, consistency stipulates common prefix and future self-consistency. Common prefix requires that all honest nodes' chains, except for roughly O(&kappa;) number of trailing blocks that have not stabilized, must all agree. Future self-consistency requires that an honest node's present chain, except for roughly O(&kappa;) number of trailing blocks that have not stabilized, should persist into its own future. These properties can be unified in the following formal definition (which additionally requires that at any time, two alert nodes' chains must be of similar length).</p>

    <p class="text-gray-300">Let consistent<sup>T</sup> (view) = 1 iff for all times t &le; t 0 , and all players i, j (potentially the same) such that i is alert at t and j is alert at t 0 in view, we have that the prefixes of chain<sup>t</sup> i (view) and chain<sup>t</sup> 0 j (view) consisting of the first <code>= |chain&lt;sup&gt;t&lt;/sup&gt; i (view)| &minus; T records are identical &mdash; this also implies that the following must be true: chain&lt;sup&gt;t&lt;/sup&gt; 0 j (view) &gt;</code>, i.e., chain<sup>t</sup> 0 j (view) cannot be too much shorter than chain<sup>t</sup> i (view) given that t <sup>0</sup> &ge; t.</p>

    <p class="text-gray-300">Definition 3 (Consistency). A blockchain protocol &Pi; satisfies T0-consistency, if for all &Pi;-compliant p.p.t. pair (A, Z), there exists some negligible function negl such that for every &kappa; &isin; N and every T &ge; T<sup>0</sup> the following holds:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi}(\\mathcal{A}, \\mathcal{Z}, \\kappa) : \\mathsf{consistent}^T(\\mathsf{view}) = 1\\right] \\geq 1 - \\mathsf{negl}(\\kappa)$$</p>

    <p class="text-gray-300">Note that a direct consequence of consistency is that at any time, the chain lengths of any two alert players can differ by at most T (except with negligible probability).</p>

      <h3 id="app-c.1" class="text-xl font-semibold mt-8">C.1 Modeling Digital Signatures</h3>

    <p class="text-gray-300">Our protocol makes use of digital signatures. We model digital signatures in a way such that the signature keys can be shared between our consensus protocol and any application-level protocol. For example, imagine that the cryptocurrency layer uses the same signing keys to sign transactions. Our modeling approach guarantees that the security of our &Pi;sleepy protocol is retained when composed with arbitrary application-level protocols, as long as the application-level protocols respect the compliance rules expected by &Pi;sleepy.</p>

    <p class="text-gray-300">Specifically, we follow the GUC paradigm <a href="#page-19-10">[14]</a> and model the signature as a signing functionality shared across protocols. Figure <a href="#page-26-1">3</a> illustrates this signature functionality denoted G &Sigma; sign, which is parametrized by a signature scheme denoted &Sigma;. We often omit writing the superscript &Sigma; without risk of ambiguity. We now explain the Gsign functionality. Gsign generates and remembers a new signature key pair for a party upon the gen call; and signs messages for parties upon the sign call using any of the party's signing keys. Finally upon a getkey query, Gsign discloses the secret signing keys of corrupt parties to the adversary A.</p>

    <p class="text-gray-300">Note that in practice, such a functionality is actually realized in the following way: every honest node implements a trusted signing wrapper that is shared across all protocols instances executed by the honest node. This trusted signing wrapper is in charge of generating signature keys and perform signing operations. Following the GUC modeling paradigm <a href="#page-19-10">[14]</a>, the union of the trusted signing wrappers across all honest nodes is considered as the trusted computing base (TCB), and therefore conceptually grouped into this single functionality Gsign. When a node becomes corrupt, its signing wrapper is then controlled by the adversary, therefore the secret signing keys get disclosed to the adversary.</p>

    <p class="text-gray-300">Like in the standard GUC paradigm, we assume that the environment Z can interact with Gsign in the following ways:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Z can interact with Gsign acting as an honest party executing other (possibly rogue) protocols. Since other protocols have different session identifiers, Z cannot ask Gsign to sign messages pertaining to the challenge session identifier, which is the protocol instance that we are proving security for.</li>
      <li>Z can interact with Gsign acting as a corrupt party or A by routing messages through the adversary A.</li>
    </ul>

    <p class="text-gray-300">Mapping from public keys to nodes. In addition to defining honest, alert, and corrupt for nodes, it will be convenient later for us to refer to public keys as being honest, alert, or corrupt. This is defined in the most natural manner.</p>

    <p class="text-gray-300">Given an execution trace denoted view, a public key pk is said to be honest (or alert resp.) at time t &le; |view| in view, if some tuple of the form (P, pk, ) &isin; Gsign.&Gamma; at time t in view, and further, P is honest (or alert resp.) at time t in view. If a public key pk is not honest at t, we say that it is corrupt at t. Note that a corrupt pk may not exist in Gsign.</p>

      <h3 id="app-c.2" class="text-xl font-semibold mt-8">C.2 Format of Real-World Blocks</h3>

    <p class="text-gray-300">We use the notation chain to denote a real-world blockchain. Our protocol also defines an extract function that outputs an ordered list of transactions from a blockchain. A real-world blockchain is a chain of real-world blocks. We now define a valid block and a valid blockchain.</p>

    <p class="text-gray-300">Valid blocks. We say that a tuple</p>

    <p class="text-gray-300"><span class="math">$B := (h_{-1}, \\mathsf{txs}, \\mathsf{time}, \\mathsf{nonce}, \\mathsf{pk}, \\sigma, h)</span>$</p>

    <p class="text-gray-300">is a valid block iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&Sigma;.Verpk,sid ((h&minus;1,txs,time, nonce); &sigma;) = 1 where sid is the session identifier of the proof-of-stake protocol &mdash; as mentioned earlier, we use the notation Verpk,sid to indicate that the message is prefixed with the protocol's session identifier sid; and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>h = d(h&minus;1,txs,time, nonce, pk, &sigma;), where d : {0, 1} <sup>&lowast;</sup> &rarr; {0, 1} &kappa; is a collision-resistant hash function &mdash; technically collision resistant hash functions must be defined for a family, but here for simplicity we pretend that the sampling from the family has already been done before protocol start, and therefore d is a single function.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Valid blockchain. Let eligible<sup>t</sup> (chain, pk) be a function that given the current state of chain, determines whether pk is elected as a leader in time step t, by making calls to a random oracle H. We defer the concrete specification of eligible<sup>t</sup> (chain, pk) to Figure <a href="#page-30-0">4.</a></p>

    <p class="text-gray-300">Let chain denote an ordered chain of real-world blocks, we say that chain is a valid blockchain w.r.t. eligible and time t iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>chain[0] = genesis := (&perp;, &perp;,time = 0, nonce0, &perp;, &perp;, h = ~0) where nonce<sup>0</sup> is a nonce randomly generated prior to protocol start;</li>
      <li>chain[&minus;1].time &le; t; and</li>
      <li>for all i &isin; [1..\`], the following holds:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>chain[i] is a valid block;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>chain[i].h&minus;<sup>1</sup> = chain[i &minus; 1].h;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>chain[i].time &gt; chain[i &minus; 1].time, i.e., timestamps are strictly increasing; and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>let t := chain[i].time, pk := chain[i].pk, it holds that eligible<sup>t</sup> (chain[: i &minus; 1], pk) = 1.</li>
    </ol></li>
    </ul></li>
    </ul>

      <h3 id="app-c.3" class="text-xl font-semibold mt-8">C.3 Epoch-Based Committee Election</h3>

    <p class="text-gray-300">Epochs. Our protocol proceeds in epochs, where in each epoch, a different committee will be elected and will be eligible to mine blocks. Let Tepoch be a protocol parameter that denotes the length of each epoch. We define a round-down function</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{rnddown}(t) := \\lfloor \\frac{t}{T_{\\mathrm{epoch}}} \\rfloor \\cdot T_{\\mathrm{epoch}}</span>$</p>

    <p class="text-gray-300">to denote the starting time of the epoch that time t belongs to.</p>

    <p class="text-gray-300">Per-epoch committee election. Let view be an execution trace where the current time t := |view|. Let i denote a node that is honest at time t in view. Let chain := chain<sup>i</sup> t (view) be node's i's chain at time t in view. At this point of time, node i will apply an election function to decide the set of public keys eligible in the current time step t. To this end, node i will examine its local chain, and select a block that is sufficiently far back &mdash; the set of public keys contained in the prefix up to this block will be eligible to mine in time t.</p>

    <p class="text-gray-300">We have yet to define what it means to be &quot;sufficiently far back&quot;. To this end, we define a look-back parameter denoted &omega;. An honest node i will select the largest index j such that chain[j].time + 2&omega; &le; rnddown(t). Then the public keys extracted by calling extractpks(chain[: j]) will be the committee for time t. Later, we will choose the parameter &omega; to be reasonably large (and yet not too long ago) such that all honest nodes will agree on committee at time t with overwhelming probability.</p>

    <pre><code class="language-text">elect cmtt
          (chain) :=
    extractpks(chain[: j]) where j is the largest index s.t. chain[j].time + 2&omega; &le; rnddown(t)
</code></pre>

    <p class="text-gray-300">Per-epoch hash reseeding. Given a set of eligible committee members, a hash function will be applied to choose a leader for each time step. We now define a rule for selecting this hash function. Let H denote a globally known hash function modeled as a random oracle. We henceforth use the notation</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{H}^{\\mathsf{nonce}}(x) := \\mathsf{H}(\\mathsf{nonce}||x)</span>$</p>

    <p class="text-gray-300">In other words, we elect a hash by choosing a nonce.</p>

    <pre><code class="language-text">elect h
      t
       (chain) := chain[j].nonce where j is the largest index s.t. chain[j].time + &omega; &le; rnddown(t)
</code></pre>

    <p class="text-gray-300">Later, we will choose an appropriate parameter &omega; such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&omega; is reasonably large (and yet not too long ago) such that all honest nodes will agree on the hash function elected at time t with overwhelming probability; and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&omega; is smaller than 2&omega; by a reasonable margin, such that the hash will be selected sufficiently long after the committee is determined by the blockchain.</li>
    </ol></li>
    </ul>

      <h3 id="app-c.4" class="text-xl font-semibold mt-8">C.4 Protocol Overview</h3>

    <p class="text-gray-300">We describe our Snow White protocol in Figure <a href="#page-30-0">4.</a> The protocol proceeds in epochs whose length is determined by the parameter Tepoch. At the start of each epoch, the protocol switches to a new committee that can be determined by examining the current state of the blockchain. Further, a new hash is used for each different epoch, and the hash is selected by computing a new nonce from the current state of the blockchain.</p>

    <p class="text-gray-300">Once a committee and a hash is determined for an epoch, we can now describe the &quot;mining&quot; process. Let pks<sup>e</sup> denote the e-th committee. In every time step during the e-th epoch, if a node iis in the e-th committee, it will compute H(pk, t) and if the outcome is smaller than Dp, then node i is a leader in time t. In this case, node i will extend its current chain by signing a new block containing the following: 1) the previous block's hash, 2) a set of transactions to be confirmed, 3) the current time, 4) a freshly generated nonce, and 5) its own public key. The node then announces the new chain to the network.</p>

    <p class="text-gray-300">In each time step, regardless of whether a node is in the present committee, a node receives chains from the network and verify their validity. If a received chain is valid but deviates from a node's current chain too far in the past, such a chain is not punctual and will be rejected. Nodes always choose the longest chain among all chains it did not reject.</p>

    <p class="text-gray-300">Finally, when a node spawns or wakes up from deep sleep (henceforth referred to as respawning), an initialization procedure is invoked. At this moment, A must deliver to the node an initialization message containing a list of chains denoted {chaini}i&isin;<sup>L</sup> such that the majority of these chains reflect the true state of an alert node at time t &minus; 1 (see protocol compliance rules defined in Section <a href="#page-32-0">C.6)</a>. If this is the protocol start, this list can simply be the genesis block. As mentioned earlier, this</p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6">Protocol &Pi;snowwhite(&kappa;0, p, &omega;, Tepoch, extractpks) On input init() from Z: let pk := Gsign.gen(), output pk to Z, wait to receive (pks<sup>0</sup> , {chaini}i&isin;L) find the longest valid chain<sup>0</sup> that is a prefix of the majority of chains in {chaini}i&isin;<sup>L</sup> find the longest valid chain &isin; {chaini}i&isin;<sup>L</sup> such that chain<sup>0</sup> &#8826; chain record chain and pk On receive chain<sup>0</sup> : assert |chain<sup>0</sup> | &gt; |chain| and chain<sup>0</sup> is valid w.r.t. the current time t assert chain[: &minus;&kappa;0] &#8826; chain<sup>0</sup> chain := chain<sup>0</sup> and gossip chain Every time step: &bull; receive input transactions(txs) from Z, and pick nonce&larr;\${0, 1} &kappa; &bull; let t be the current time, if eligible<sup>t</sup> (chain, pk): let &sigma; := Gsign.sign(pk, chain[&minus;1].h,txs, t, nonce), h 0 := d(chain[&minus;1].h,txs, t, nonce, pk, &sigma;), let B := (chain[&minus;1].h,txs, t, nonce, pk, &sigma;, h<sup>0</sup> ), let chain := chain||B and gossip chain &bull; output extract(chain) to Z where extract is the function outputs an ordered list containing the txs extracted from each block in chain Subroutine eligible<sup>t</sup> (chain, pk) Assume: chain[0].nonce = nonce0, extractpks(chain[: 0]) = pks<sup>0</sup> Let elect cmt<sup>t</sup> (chain) be a function that returns extractpks(chain[: j]) s.t. j is the largest index satisfying chain[j].time + 2&omega; &le; rnddown(t) Let elect h t (chain) be a function that returns extractnonce(chain[: j]) s.t. j is the largest index satisfying chain[j].time + &omega; &le; rnddown(t) Let pks<sup>&lowast;</sup> := elect cmt<sup>t</sup> (chain), let nonce<sup>&lowast;</sup> := elect h t (chain) Return 1 if H nonce<sup>&lowast;</sup> (pk, t) &lt; D<sup>p</sup> and pk &isin; pks<sup>&lowast;</sup> ; else return 0</h4>

    <p class="text-gray-300">Figure 4: The Snow White consensus protocol. The difficulty parameter D<sup>p</sup> is set such that a committee member is elected leader with probability p in a single time step. pks<sup>0</sup> denotes the initial committee. Chain validity is stated w.r.t. eligible although we omit writing w.r.t. eligible for simplicity.</p>

    <p class="text-gray-300">extractnonce(chain): output the concatenation of the nonces in all blocks in chain</p>

    <p class="text-gray-300">reflects the fact that a spawning (or respawning) node can contact a list of nodes in the network the majority of whom must be alert. As we argue in Sections 2 and D, this process allows a spawning or respawning node to determine the correct version of history to believe in. Without this additional trust assumption, consensus would have been impossible in the presence of majority posterior corruption. Now the spawning/respawning node computes its state as follows: First, it computes the longest valid  <span class="math">chain_0</span>  that is a prefix of the majority of chains in the list. Next, it finds the longest chain in the list that contains  <span class="math">chain_0</span> . This chain now becomes the internal state of the spawning/respawning node.</p>

    <p class="text-gray-300"><strong>Remark:</strong> committee members and non-members. We remark that in each epoch, there are two types of nodes in the system, the current committee members and committee non-members. Although only committee members are contributing blocks, our consistency and liveness guarantees extend to all nodes, including members and non-members.</p>

      <h3 id="app-c.5" class="text-xl font-semibold mt-8">C.5 Theorem Statement</h3>

    <p class="text-gray-300">Additional useful notations. Before we state our theorem, we will need to define some additional notations. Recall that p is the probability that a node is elected leader in a given time step.  <span class="math">1+\\phi</span>  is the minimum ratio of alert nodes over corrupt ones across time. n is the total number of awake nodes at any given time (see also Remark 1). We define a set of intermediate variables  <span class="math">\\alpha, \\beta</span> , and  <span class="math">\\gamma</span>  which are defined as functions of  <span class="math">p, n, \\phi</span> , and possibly  <span class="math">\\Delta</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">\\alpha := 1 (1-p)^{\\frac{n(1+\\phi)}{2+\\phi}}</span>  be the probability that some alert node is elected leader in one round; and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">\\beta := 1 (1-p)^{\\frac{n}{2+\\phi}}</span>  be the probability that some corrupt node is elected leader in one round;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">\\gamma := \\frac{\\alpha}{1+\\Delta\\alpha}</span> .  <span class="math">\\gamma</span>  is a &quot;discounted&quot; version of  <span class="math">\\alpha</span>  which takes into account the fact that messages sent by alert nodes can be delayed by  <span class="math">\\Delta</span>  time steps;  <span class="math">\\gamma</span>  corresponds to alert nodes' &quot;effective&quot; proportion among all awake nodes.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><strong>Theorem 1.</strong> For any constant  <span class="math">\\epsilon_0</span> ,  <span class="math">\\epsilon &gt; 0</span> , any  <span class="math">T_0 \\ge \\epsilon_0 \\kappa</span> ,  <span class="math">\\Pi_{\\text{snowwhite}}</span>  satisfies  <span class="math">(T_0, g_0, g_1)</span> -chain growth,  <span class="math">(T_0, \\mu)</span> -chain quality, and  <span class="math">T_0</span> -consistency against any  <span class="math">\\Pi_{\\text{snowwhite}}</span> -compliant p.p.t. pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , with the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>chain growth lower bound parameter  <span class="math">g_0 = (1 \\epsilon)\\gamma</span> ;</li>
      <li>chain growth upper bound parameter  <span class="math">g_1 = (1 + \\epsilon)np</span> ; and</li>
      <li>chain quality parameter  <span class="math">\\mu = (1 \\epsilon)(1 \\frac{\\beta}{\\gamma});</span></li>
    </ul>

    <p class="text-gray-300">where  <span class="math">\\alpha, \\beta, \\gamma</span>  are defined earlier.</p>

    <p class="text-gray-300">The proof of this theorem will be provided in Sections F, G, and H. The theorem requires that the parameters of the scheme, including  <span class="math">\\kappa_0, p, \\omega</span> , and  <span class="math">T_{\\text{epoch}}</span> , be set appropriately in relation to the parameters of  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> . We describe the parameter constraints and intuitively explain why the constraints are necessary in Section C.6.</p>

    <p class="text-gray-300">Table 1: Notations</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\kappa</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">security parameter</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">chain_i^t</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">extracted ideal-world chain for node <span class="math">i</span> honest at time <span class="math">t</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">chain_i^t</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">real-world formatted chain for node <span class="math">i</span> honest at time <span class="math">t</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">W</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">posterior corruption window</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\phi</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\phi</span> fraction more must be a<br>lert and remain honest for <span class="math">W</span> more steps than those corrupt within<br>W steps</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\tau</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">agility parameter, time till corruption/sleep operations take effect</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\Delta</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">maximum network delay for alert nodes</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\widetilde{\\Delta}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">maximum duration of a light sleep</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2\\omega, \\omega</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">time to look back to decide committee/hash respectively</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\kappa_0 := \\frac{\\kappa}{2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">incoming chain must agree with all but the last <span class="math">\\kappa_0</span> blocks</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">probability that a node gets elected leader in any time step</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">T_{\\mathrm{epoch}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">length of an epoch</td>
          </tr>
        </tbody>
      </table>
    </div>

      <h3 id="app-c.6" class="text-xl font-semibold mt-8">C.6 Compliant Execution</h3>

    <p class="text-gray-300">We now articulate a set of constraints that (A, Z) must respect for our protocol to guarantee security. For convenience, we summarize our notations and parameters in Table 1.</p>

    <p class="text-gray-300"><strong>Admissible parameters.</strong> Without loss of generality due to rescaling of  <span class="math">\\kappa</span> , we shall henceforth assume that</p>

    <p class="text-gray-300"><span class="math">$\\kappa_0 = \\frac{\\kappa}{2}</span>$</p>

    <p class="text-gray-300">We say that the parameters  <span class="math">(p, \\kappa_0, T_{\\text{epoch}}, \\omega; n, \\phi, \\Delta, \\tau, \\widetilde{\\Delta}, W)</span>  are  <span class="math">\\Pi_{\\text{snowwhite}}</span> -admissible iff the following constraints hold:</p>

    <p class="text-gray-300">&bull;  <span class="math">np\\Delta &lt; 1</span>  and moreover, there exists a constant  <span class="math">\\psi &gt; 0</span>  such that</p>

    <p class="text-gray-300"><span class="math">$(1 - 2\\alpha(\\Delta + 1))\\alpha &gt; (1 + \\psi)\\beta</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">W &gt; \\omega \\ge \\frac{2\\kappa}{\\gamma} + \\widetilde{\\Delta};</span></li>
      <li><span class="math">T_{\\text{epoch}} \\geq 3\\omega</span> ;</li>
      <li><span class="math">\\tau &gt; W + T_{\\text{epoch}} + 2\\omega;</span></li>
    </ul>

    <p class="text-gray-300"><strong>Intuitions for admissible parameters.</strong> We now given an intuitive explanation for these parameters. All these intuitions will later arise as technicalities in our proof.</p>

    <p class="text-gray-300">&bull; First, the requirement  <span class="math">(1 - 2\\alpha(\\Delta + 1))\\alpha &gt; (1 + \\psi)\\beta</span>  roughly says that the alert committee members that remain honest till the near future, even when discounted by a parameter related to the network delay, must outnumber the committee members that are corrupt or to become corrupt in the near future &mdash; where &quot;near future&quot; is characterized by the posterior corruption window W. Specifically, the discount factor  <span class="math">(1 - 2\\alpha(\\Delta + 1))</span>  arise due to technicalities that arise in the consistency proof.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Second, the look-back parameters  <span class="math">2\\omega</span>  and  <span class="math">\\omega</span>  must be reasonably large, such that    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The prefix of the chain that is used to decide the next epoch's committee and hash has stabilized, such that all nodes will agree on the next epoch's committee and hash;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The two look-back parameters are spaced out far enough such that when the committee is determined, the adversary cannot predict the nonce that determines the next hash; and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Further, the parameters  <span class="math">\\omega</span>  and  <span class="math">2\\omega</span>  are related to the light sleep bound  <span class="math">\\widetilde{\\Delta}</span>  and the punctuality parameter  <span class="math">\\kappa_0 = \\frac{\\kappa}{2}</span> , ensuring that even when a light sleeper wakes up, it suffices to use its old chain (before going to sleep) with the last  <span class="math">\\kappa_0</span>  blocks removed henceforth denoted  <span class="math">chain^s[:-\\kappa_0]</span>  where s is the time the node last went to sleep to decide the next committee and hash. Specifically, this requires that  <span class="math">chain^s[:-\\kappa_0]</span>  must have a block with a recent enough timestamp relative to  <span class="math">\\omega</span>  and  <span class="math">2\\omega</span> .</li>
    </ol></li>
    </ul></li>
      <li>Next, nodes reject blocks that modify  <span class="math">\\kappa_0</span>  blocks back into their past, and for light sleepers this is adjusted by another  <span class="math">\\widetilde{\\Delta}</span>  parameter therefore the posterior corruption window W has to be reasonably large to be commensurate with these two parameters.</li>
      <li>Next, the epoch length  <span class="math">T_{\\rm epoch}</span>  has to be reasonably large, since as we mention in Section 2.2 and Section G.1, once a random oracle is chosen, it must be used sufficiently many times to prove security. Also in our current parameterization, we do not treat the first epoch specially, so  <span class="math">T_{\\rm epoch}</span>  must also be large enough for the protocol to warm up roughly speaking, the blockchain must be at least  <span class="math">2\\omega</span>  time long for a committee (that is not the initial committee) to be determined.</li>
      <li>Finally, the agility parameter  <span class="math">\\tau</span> , which stipulates how long it takes for corrupt and sleep instructions to take effect, must be reasonably large to eliminate possible &quot;adaptive&quot; corruption behaviors, where the adversary first sees the next committee and hash, and then decides who to corrupt or make sleep. If  <span class="math">\\tau</span>  is sufficiently large, such an attack will not succeed. Specifically, if an adversary attempts to corrupt a node (or make it sleep) after seeing the next hash, then when the corrupt or sleep instruction takes effect, it will already be well after this epoch for such &quot;adaptivity&quot; to be effective, where the notion of &quot;well after&quot; is related to the posterior corruption parameter W. Roughly speaking, from the time the adversary sees the next hash till &quot;well after&quot; the next epoch takes a total of  <span class="math">W + T_{\\rm epoch} + c \\cdot \\omega</span>  time; therefore, the requirement that  <span class="math">\\tau &gt; W + T_{\\rm epoch} + 2\\omega</span>  is easy to understand.</li>
    </ul>

    <p class="text-gray-300">Compliant executions. We say that the pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is  <span class="math">\\Pi_{\\text{snowwhite}}</span> -compliant if the following holds for any view with non-zero support:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">Initialization. At the start of the execution, the following happens. First,  <span class="math">\\mathcal{Z}</span>  can spawn a set of either honest or corrupt nodes.  <span class="math">\\mathcal{Z}</span>  learns the honest nodes' public keys after calling their init() procedure. Next,  <span class="math">\\mathcal{Z}</span>  provides the inputs (pks<sub>0</sub>, {genesis}) to all honest nodes. At this point, protocol execution starts.  <span class="math">\\mathcal{A}</span>  is not allowed to query the random oracle H prior to protocol start.</p></li>
      <li><p class="text-gray-300"><span class="math">\\tau</span> -agility. Whenever  <span class="math">\\mathcal{A}</span>  issues a (corrupt, t) or a (sleep, t, t') instruction at time r, it must hold that  <span class="math">t r \\ge \\tau</span> .</p></li>
      <li><p class="text-gray-300">Sleeping. If a sleeper wakes up within  <span class="math">\\widetilde{\\Delta}</span>  time since it last went to sleep, it is considered a light sleeper. Otherwise, if it sleeps for more than  <span class="math">\\widetilde{\\Delta}</span>  time before waking up it is considered a deep sleeper and must reinitialize as if it is re-spawning (see below).</p></li>
      <li><p class="text-gray-300"><strong>Spawning.</strong> When a new node spawns or a deep sleeper wakes up,  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  must deliver the same  <span class="math">\\mathsf{pks}_0</span>  to this node, and further  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  must deliver to this node a message  <span class="math">\\{chain_i^{t-1}\\}_{i\\in L}</span>  that contains the internal chains of a set of nodes (denoted L) the majority of whom are alert at t-1. If a node  <span class="math">i \\in L</span>  is corrupt<sup>5</sup>, it can provide an arbitrarily  <span class="math">chain_i^{t-1}</span> .</p></li>
    </ul>

    <p class="text-gray-300">Intuitively, this captures the requirement that a newly spawning node must be able to connect to a subset of nodes the majority of which are alert.</p>

    <p class="text-gray-300">&bull; Resilience. Let  <span class="math">t \\leq |\\text{view}|</span> , and let i be a node that is honest at time t in view. Let  <span class="math">chain_i^t(\\text{view})</span>  denote node i's protocol internal state at time t in view, and define</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{cmt}_i^t(\\mathsf{view}) := \\mathsf{elect\\_cmt}^t(\\mathit{chain}_i^t(\\mathsf{view}))</span>$</p>

    <p class="text-gray-300">We require that for every  <span class="math">t \\leq |\\mathsf{view}|</span> , for every honest node i that is honest at t in  <span class="math">\\mathsf{view}</span> , let  <span class="math">r = \\min(t + W, |\\mathsf{view}|)</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\mathsf{alert}^t(\\mathsf{cmt}_i^t(\\mathsf{view}),\\mathsf{view}) \\cap \\mathsf{honest}^r(\\mathsf{cmt}_i^t(\\mathsf{view}),\\mathsf{view})}{\\mathsf{corrupt}^r(\\mathsf{cmt}_i^t(\\mathsf{view}),\\mathsf{view})} \\geq 1 + \\phi \\tag{2}</span>$</p>

    <p class="text-gray-300">where  <span class="math">alert^t</span> ,  <span class="math">honest^r</span> ,  <span class="math">corrupt^r</span>  are defined as below:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\operatorname{alert}^t(S, \\operatorname{view})</span>  outputs those in S that are alert at time t in view.</li>
      <li>honest  <span class="math">^r(S, \\text{view})</span>  outputs those in S that are honest at time r.</li>
      <li><span class="math">\\mathsf{corrupt}^r(S,\\mathsf{view})</span>  outputs those in S that are corrupt at time r.</li>
    </ul>

    <p class="text-gray-300">Informally, we require that among committee of time t (as perceived by any node honest at time t), more are alert at time t and remain honest till r (but possibly can go to sleep), than those corrupt at time r.</p>

    <p class="text-gray-300">&bull; Number of awake nodes. For every honest node i that is honest at time t in view, let  <span class="math">r = \\min(t + W, |\\text{view}|)</span> , we have that</p>

    <p class="text-gray-300"><span class="math">$(\\mathsf{alert}^t(\\mathsf{cmt}_i^t(\\mathsf{view}),\\mathsf{view}) \\cap \\mathsf{honest}^r(\\mathsf{cmt}_i^t(\\mathsf{view}),\\mathsf{view})) + \\mathsf{corrupt}^r(\\mathsf{cmt}_i^t(\\mathsf{view}),\\mathsf{view}) = n</span>$</p>

    <p class="text-gray-300">&bull; Admissible parameters. The parameters  <span class="math">(p, \\kappa_0, T_{\\text{epoch}}, \\omega; n, \\phi, \\Delta, \\tau, \\widetilde{\\Delta}, W)</span>  are  <span class="math">\\Pi_{\\text{snowwhite}}</span> admissible, where  <span class="math">p, \\kappa_0, T_{\\text{epoch}}, \\omega</span>  are input parameters to the  <span class="math">\\Pi_{\\text{snowwhite}}</span>  protocol, and  <span class="math">(n, \\phi, \\Delta, \\tau, \\widetilde{\\Delta}, W)</span> are parameters related to  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup>Considering that in practice, it may take  <span class="math">\\Delta</span>  time for messages to be transmitted to the newly spawned node, it is possible to relax this condition where  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is only required to deliver to a spawning node a message  <span class="math">\\{chain_i^{t_i}\\}_{i\\in L}</span>  where for more than majority of L, it must hold that i is alert at  <span class="math">t_i \\in [t - \\Delta, t]</span> . It is not hard to adjust the proofs of our theorems to this relaxed case.</p>

    <p class="text-gray-300"><strong>Remark 1</strong> (Clarifications on n and difficulty parameter). For notational simplicity, our analysis assumes that (imprecisely speaking) the number of awake nodes is n throughout. We assume that some upper bound on n is a-priori known so we can choose the protocol's difficult parameter  <span class="math">D_p</span>  to satisfy the complicance rules &mdash; note that if the upper bound on n is loose, then the expected block interval will be proportionally larger and thus transaction confirmation is slower (but all of our proofs still hold).</p>

    <p class="text-gray-300">It is not difficult to see that our analysis holds not only for fixed n, the requirement we actually rely on is for the expected block interval (had all awake nodes been honest) to stay fixed throughout. In practice, the protocol is reading the next committee from a stabilized prefix of the blockchain itself, at any time we actually know the total committee size a-priori. Assuming that the fraction of awake nodes (out of each committee) is fixed, we can simply set each committee's  <span class="math">D_p</span>  such that the expected block interval is fixed. Finally, it is easy to generalize our analysis to further relax the above requirement &mdash; we only need that the expected block interval varies by a known constant factor (rather than staying fixed throughout).</p>

    </section>

    <section id="app-d" class="mb-10">
      <h2 class="text-2xl font-bold">D Lower Bounds</h2>

    <p class="text-gray-300">Recall that in our protocol, when a node first spawns or after a deep sleeper wakes up, the node must perform an initialization procedure where it contacts a list of nodes the majority of whom are alert. We show that this additional trust assumption is necessary if one wishes to tolerate majority posterior corruption.</p>

    <p class="text-gray-300">We state our lower bound for a blockchain protocol, but it is not hard to see that the same lower bound proof holds for any consensus protocol (often referred to as state machine replication in the classical distributed systems literature) as defined by Pass and Shi [47]. Note that Pass and Shi also show that a formal blockchain abstraction implies a classical consensus (i.e., state machine replication) abstraction.</p>

    <p class="text-gray-300"><strong>Theorem 2</strong> (Access to a majority honest set for (re)spawning nodes is necessary). Assuming common knowledge of the initial committee  <span class="math">\\mathsf{cmt}_0</span> , and absent any additional trust assumptions, it is impossible to realize a secure blockchain protocol in our execution model if there exists  <span class="math">\\frac{1}{\\mathsf{poly}(\\kappa)}</span>  fraction of views such that no node ever sleeps, and at some time T,</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{corrupt}^T(\\mathsf{cmt}_0,\\mathsf{view}) &gt; \\mathsf{alert}^1(\\mathsf{cmt}_0,\\mathsf{view}) \\cap \\mathsf{honest}^T(\\mathsf{cmt}_0,\\mathsf{view})</span>$</p>

    <p class="text-gray-300">The lower bound holds even if at any time, there are more alert present committee members than corrupt ones, even if all corruptions are declared statically upfront, and even if assuming a PKI.</p>

    <p class="text-gray-300"><em>Proof.</em> Consider the following (A, Z) pair:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300"><span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  first provides an initial committee cmt<sub>0</sub> consisting of n = 2f + 1 nodes, where f of them are corrupt, and the remaining are alert. Then at time T, one additional node among cmt<sub>0</sub> becomes corrupt at this moment, f + 1 among cmt<sub>0</sub> are corrupt, and f are still alert.</p></li>
      <li><p class="text-gray-300"><span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  constructs appropriate transactional inputs such that this will cause the committee to switch completely at some time  <span class="math">t^* &lt; T</span> , such that the new committee, denoted  <span class="math">\\mathsf{cmt}_1</span> , does not intersect with  <span class="math">\\mathsf{cmt}_0</span> . Further,  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  makes sure that all nodes in  <span class="math">\\mathsf{cmt}_1</span>  are alert all the time.</p></li>
      <li><p class="text-gray-300">At time T, when the majority of  <span class="math">\\mathsf{cmt}_0</span>  become corrupt,  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  creates a simulated execution in its head with the f+1 corrupt  <span class="math">\\mathsf{cmt}_0</span>  members that he has: in the simulated execution, a different set of transactions are provided to the initial committee  <span class="math">\\mathsf{cmt}_0</span> , such that at time  <span class="math">t^*</span>  the simulated execution switches to a new committee  <span class="math">\\mathsf{cmt}_1&#x27;</span>  consisting only of corrupt nodes. In this way,  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  can continue with the simulation after the committee switch. Further,  <span class="math">S_1&#x27;</span>  also does not intersect with  <span class="math">\\mathsf{cmt}_0</span>  just like the real execution.</p></li>
      <li><p class="text-gray-300">(A, Z) spawns a new alert node <em>i</em> after time <em>T</em>, and delivers messages from both the simulated and the real executions to node <em>i</em>.</p></li>
    </ul>

    <p class="text-gray-300">Since the simulated execution and the real one are identically distributed, the newly joining node i cannot output the correct log with probability more than  <span class="math">\\frac{1}{2}</span> .</p>

    <p class="text-gray-300">We note that the same lower bound proof holds for a deep sleeper that sleeps for a long time and then wakes up. In other words, if we changed our model to prevent dynamic spawning of nodes, but still allow sleeping, the same lower bound would still hold if majority posterior corruption can happen.</p>

    <p class="text-gray-300">In this section, we give an intuitive overview of the proof roadmap; highlighting key elements of the proof without going into formal details. The full proof is provide in Sections F, G, and H.</p>

    <p class="text-gray-300">We will describe our proof roadmap in a roughly temporal order, but note that the most non-trivial technical steps are the following: 1) how we prove security when rotating hash functions are used and when the adversary can potentially bias the choice of the hash function; 2) how the proof handles posterior corruption; and 3) the simulation proof that the real-world protocol emulates the ideal-world protocol (and particularly, how this proof breaks circularity).</p>

    <p class="text-gray-300">Ideal-world protocol:  <span class="math">\\Pi_{ideal}</span> . We first consider a simple ideal-world protocol denoted  <span class="math">\\Pi_{ideal}</span> . In this ideal-world protocol, we consider an ideal mining process where an ideal functionality  <span class="math">\\mathcal{F}_{tree}</span>  performs leader election and keeps track of all valid chains during the course of the protocol execution. We assume that there is no posterior corruption in the ideal world, and slightly imprecisely, for any committee during the entire course of execution, the majority of its members will remain honest (and possibly sleepy) forever.</p>

    <p class="text-gray-300">Such an ideal-world protocol is quite similar to the ideal-world protocol of Sleepy [48] but with a few notable differences. Most notably, our ideal protocol allows the adversary to rotate the consensus committee over time (where as Sleepy's ideal protocol assumes a fixed committee), as long as for every committee, the majority remains honest forever (imprecisely speaking). We will argue that these changes are inconsequential to the proofs for Sleepy's ideal protocol; and thus chain growth, chain quality, and consistency hold for our  <span class="math">\\Pi_{\\rm ideal}</span> .</p>

    <p class="text-gray-300">This ideal-world protocol  <span class="math">\\Pi_{ideal}</span>  is rather far removed from the real-world execution; and thus in the remainder of the proof, we will need to gradually augment the protocol to more and more closely capture the real-world execution. In each step, we will need to argue that the augmentation, roughly speaking, preserves the properties we desire, including chain growth, chain quality, and consistency.</p>

    <p class="text-gray-300">Handling adversarially biased hashes:  <span class="math">\\Pi_{\\text{bias}}</span> . Our next step is to augment the ideal-world protocol to capture the rotating hashes that happens in the real-world protocol  <span class="math">\\Pi_{\\text{snowwhite}}</span> . Notice that in the real-world protocol, there is a new hash function for each epoch (as determined by a</p>

    <p class="text-gray-300">nonce that seeds the random oracle). More importantly, the adversary can bias the choice of the new hash function.</p>

    <p class="text-gray-300">We therefore consider a hybrid protocol called &Pi;bias. &Pi;bias is similarly defined as &Pi;ideal, except that now the new ideal functionality Fbias would allow the adversary to influence the choice of the hash function by allowing the adversary to pick a nonce that seeds the random oracle. Further, this nonce must be chosen after the adversary chooses the public keys of the next consensus committee to avoid an adpative key selection attack.</p>

    <p class="text-gray-300">In our proof, we will argue that as long as each hash function is used for sufficiently long and to elect at least &Omega;(&kappa;) leaders where &kappa; is the security parameter, despite the adversary's influence over the choice of the hash function, it cannot increase the probability of bad events by more than a polynomial amount. To formalize this intuition turns out to be somewhat subtle, and requires us to open up the stochastic analysis of the ideal protocol &Pi;ideal in a somewhat non-blackbox manner. Specifically, &Pi;ideal's stochastic analysis for chain growth, chain quality, and consistency works for any long enough window. Unfortunately, we cannot adopt the same strategy in the proof of &Pi;bias. Instead, we constrain our analysis to each medium-sized window consisting of O(1) number of epochs &mdash; and we argue that the bad events we care about during a medium-sized window depends on only O(1) number of hashes. When this is true, we can apply a union bound with polynomial security loss to argue that no bad event will happen over any medium-sized window except with negligible probability &mdash; note that when the window is too long, such a union bound would cease to work since the security loss can be exponential in the number of hashes the bad event depends on. On the other hand, if the window is too short, it would not be enough to attain a negligible failure probability. This explains why the window must be medium-sized.</p>

    <p class="text-gray-300">Finally, we argue that if chain growth, chain quality, and consistency hold for every mediumsized window, these properties hold for any window (as long as the window is not too small).</p>

    <p class="text-gray-300">Handling posterior corruption: &Pi;punctual. So far, our proof has focused on an ideal or hybrid execution where we assumed that no posterior corruption takes place. To handle posterior corruption, we introduce yet another intermediate hybrid protocol called &Pi;punctual. &Pi;punctual is very similar to &Pi;bias; however, the new ideal functionality denoted Fpunctual would simply reject any chain that arrives too late (i.e., Fpunctual enforces punctuality).</p>

    <p class="text-gray-300">Specifically, Fpunctual would reject a chain if the suffix of the chain that has not been observed before has a timestamp that is too far back in the past. To argue that this modification does not affect our desired security properties, we first argue that our earlier &Pi;bias protocol satisfies a &quot;no long block withholding&quot; lemma: honest nodes in &Pi;bias will never accept a new chain that arrived too late, i.e., if the suffix of the chain that has not been observed before has a timestamp too far back in the past. Therefore, if there were no posterior corruption, then making this modification to our ideal functionality would not have mattered to security.</p>

    <p class="text-gray-300">Next, we argue that with this new ideal functionality Fpunctual that rejects blocks that arrive too late, then we can actually prove the desired properties under a stronger adversarial model that allows posterior corruption! This is achieved through a somewhat involved simulation proof where we construct a simulator that does not have to rely on the ability to perform posterior corruption to simulate any attack that relies on corrupting committees in the past.</p>

    <p class="text-gray-300">Hybrid protocol with real-world block format: &Pi;hyb. For technical reasons that are somewhat tedious but necessary, before we conduct a simulation proof, we have to introduce a hybrid protocol &Pi;hyb that is almost the same as &Pi;punctual, but in &Pi;hyb we use the real-world block format. We defer the reader to the full proof for details of this hybrid step.</p>

    <p class="text-gray-300">Real-world protocol emulates  <span class="math">\\Pi_{hyb}</span> . Finally, in a rather sophisticated simulation proof, we will show that 1) the real-world protocol  <span class="math">\\Pi_{snowwhite}</span>  emulates the hybrid protocol  <span class="math">\\Pi_{hyb}</span> ; and 2) if the real-world  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  respects the constraints expected by  <span class="math">\\Pi_{snowwhite}</span> , then  <span class="math">(\\mathcal{S}^{\\mathcal{A}}, \\mathcal{Z})</span>  respects the constraints expected by  <span class="math">\\Pi_{hyb}</span>  where  <span class="math">\\mathcal{S}^{\\mathcal{A}}</span>  denotes the the simulator.</p>

    <p class="text-gray-300">This proof is somewhat tricky because it would seem at first sight that there is a circularity: in order to reason that  <span class="math">(S^A, \\mathcal{Z})</span>  respects  <span class="math">\\Pi_{hyb}</span> 's compliance rules, we would have to rely on that chain growth, chain quality, and/or consistency hold in the simulated execution; but then to obtain those properties in the simulated execution, we would have to rely on the fact that  <span class="math">(S^A, \\mathcal{Z})</span>  respects  <span class="math">\\Pi_{hyb}</span> 's compliance rules. As an example, our simulator  <span class="math">S^A</span>  needs to inform the ideal functionality  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span>  about the next committee and the nonce to seed the next hash function. In the real-world protocol  <span class="math">\\Pi_{snowwhite}</span> , the next committee and next nonce are extracted by an early enough prefix of the current blockchain. Therefore, naturally  <span class="math">S^A</span>  would inform  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span>  of the next committee or next hash when it has seen a long enough chain in the real-world execution. We now have to argue that the time at which  <span class="math">S^A</span>  would chooses the next committee or hash satisfies  <span class="math">\\Pi_{hyb}</span> 's compliance rules &mdash; but to make such an argument, we would have to rely on properties such as chain growth to both upper- and lower-bound the times when such choices are made by  <span class="math">S^A</span> .</p>

    <p class="text-gray-300">To break the circularity in the argument, we construct a self-checking simulator: whenever the simulator is about to break  <span class="math">\\Pi_{\\text{hyb}}</span> 's compliance rules, it simply aborts. Therefore, as long as the simulation does not abort, we can rely on the desired properties such as chain growth, chain quality, and consistency in our proof. We then argue that as long all of these properties hold till any time t, the simulator's internal compliance checks are not going to fail at the beginning of the time step t+1.</p>

    <p class="text-gray-300"><strong>Proof roadmap.</strong> Instead of directly analyzing the real-world protocol which is rather complex, we first describe some ideal protocols where nodes interact with each other, and an ideal functionality will act as as a trusted third party and keep track of all legitimate chains. The ideal protocols are much simpler to analyze in comparison with the real-world protocol. Further, the ideal protocols are meant to capture of the essence of the real-world protocol in some way, such that analyzing possible attacks in the ideal protocols will be indicative of the possible attacks in the real-world protocol.</p>

    <p class="text-gray-300">In this section, we start by analyzing a very simple ideal protocol denoted  <span class="math">\\Pi_{ideal}</span> , and then through a sequence of hybrid steps. In the next section, we gradually augment the ideal protocol such that it becomes increasingly closer to the real-world protocol. At the end of this section, we will arrive at a hybrid protocol called  <span class="math">\\Pi_{hyb}</span> , which captures ideal-world attack behavior but sends messages that contain real-world formatted chains. Finally, in Section H, we will show that the real-world protocol  <span class="math">\\Pi_{snowwhite}</span>  is as secure as the hybrid protocol  <span class="math">\\Pi_{hyb}</span> .</p>

      <h3 id="app-f.1" class="text-xl font-semibold mt-8">F.1 Simplified Ideal Protocol <span class="math">\\Pi_{ideal}</span></h3>

    <p class="text-gray-300">We first define a simplified protocol  <span class="math">\\Pi_{\\text{ideal}}</span>  parametrized with an ideal functionality  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  &mdash; see Figures 5 and 6. The ideal functionality  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  allows the adversary  <span class="math">\\mathcal{A}</span>  to choose the committee for every time step separately, specifically, by calling  <span class="math">\\mathcal{F}_{\\text{tree}}</span> .setpids <span class="math">(t, \\text{pids}_t)</span> .  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  flips random coins to decide whether a committee member is the elected leader for every time step. Once the  <span class="math">\\mathcal{A}</span>  commits</p>

    <pre><code class="language-text">Ftree(Tepoch, p)
On init: tree := genesis
On receive setpids(t, pidst) from A:
   assert no tuple of the form (t, ) has been recorded
   assert pidst contain only parties that have been spawned
   record (t, pidst)
On receive leader(P, t) from A or internally:
   assert (t, pidst) has been recorded, and P &isin; pidst
   if &Gamma;[P, t] has not been set, let &Gamma;[P, t] := (
                                               1 with probability p
                                               0 o.w.
   return &Gamma;[P, t]
On receive extend(chain, B) from P: let t be the current time:
   assert chain &isin; tree, chain||B &isin;/ tree, and leader(P, t) outputs 1
   append B to chain in tree, record time(chain||B) := t, and return &quot;succ&quot;
On receive extend(chain, B, t0
                              ) from corrupt party P
                                                      &lowast;
                                                       : let t be the current time
   assert chain &isin; tree, chain||B &isin;/ tree, leader(P
                                                  &lowast;
                                                   , t0
                                                      ) outputs 1, and time(chain) &lt; t0 &le; t
   append B to chain in tree, record time(chain||B) = t
                                                         0
                                                         , and return &quot;succ&quot;
On receive verify(chain) from P: return (chain &isin; tree)
</code></pre>

    <p class="text-gray-300">Figure 5: Ideal functionality Ftree. The ideal functionality allows A to choose a committee on a time-based granularity. A is not able to query the leader entry point for time t until it has chosen a committee for time t.</p>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">Protocol &Pi;ideal</h4>

    <p class="text-gray-300">On receive init(chain0): record chain := chain<sup>0</sup></p>

    <p class="text-gray-300">On receive chain<sup>0</sup> : if |chain<sup>0</sup> | &gt; |chain| and Ftree.verify(chain<sup>0</sup> ) = 1: chain := chain<sup>0</sup> , gossip chain Every time step:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>receive input B from Z</li>
      <li>if Ftree.extend(chain, B) outputs &quot;succ&quot;: chain := chain||B and gossip chain</li>
      <li>output chain to Z</li>
    </ul>

    <p class="text-gray-300">Figure 6: Ideal protocol &Pi;ideal</p>

    <p class="text-gray-300">to a committee for a specific time step t, it is now allowed to query a function called Ftree.leader that tells A which committee member is elected as the leader in time t (if any at all). However, A cannot query Ftree.leader( , t) for time t function before committing to the t-th committee (since otherwise A could adaptively choose a committee such that honest nodes never get elected as leaders). Further, we require that the adversary A follow a somewhat static corruption model: once it chooses a node i as a member of any committee, it is not allowed to corrupt node i any more &mdash; since otherwise A could simply query Ftree.leader and adaptively corrupt those that have been elected as leaders. Finally, alert and corrupt nodes can call Ftree.extend to extend known chains with new blocks if they are the elected leader for a specific time step. Ftree keeps track of all valid chains, such that alert nodes will call Ftree.verify to decide if any chain they receive is valid. Alert nodes always store the longest valid chains they have received, and try to extend it.</p>

    <p class="text-gray-300">Given some view sampled from EXEC&Pi;ideal(A, Z, &kappa;), we say that a chain &isin; Ftree(view).tree has an Ftree-timestamp of t if Ftree(view).time(chain) = t.</p>

    <p class="text-gray-300">Compliant (A, Z). A compliant (A, Z) pair for protocol &Pi;ideal is defined as a pair of p.p.t. algorithms such that every view of non-zero support satisfies the following constraints:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sleeping. No matter how long a node sleeps till it wakes up, it is treated as a light sleeper (as long as the node has not become corrupt during its sleep).</li>
      <li>Spawning. When a new, alert node spawns at time t, (A, Z) must deliver to it an initialization message chain<sup>0</sup> such that chain<sup>0</sup> &isin; Ftree and chain<sup>0</sup> is no shorter than the shortest chain of any alert node at time t &minus; 1. If this is the protocol start, then chain<sup>0</sup> is simply genesis. All spawned nodes must have distinct party identifiers.</li>
      <li>A-priori commitment of future committee. A must have called Ftree.setpids(t, pidst) before t. In other words, A must choose the committee pids<sup>t</sup> before time t.</li>
      <li>Epoch-wise somewhat static corruption. Instead of delayed corruption/sleep, we consider a more permissive but easier to analyze corruption model. Roughly speaking, we require that A cannot adaptively corrupt a node after examining whether it is elected a leader in any time step. Further, A cannot adaptively make a node sleep for the duration [t0, t1] after observing whether the node is elected leader during [t0, t1]. We formalize this intuition below.</li>
    </ul>

    <p class="text-gray-300">At any time t &le; t 0 , A is allowed to issue (corrupt, i, t<sup>0</sup> ) iff</p>

    <p class="text-gray-300">&ndash; A has not called Ftree.setpids(r, pidsr) for any r such that i &isin; pidsr;</p>

    <p class="text-gray-300">At time t &le; t<sup>0</sup> &le; t1, A is allowed to issue (sleep, i, t0, t1) iff</p>

    <p class="text-gray-300">&ndash; for every r &isin; [t0, t1], A has not called Ftree.setpids(r, pidsr) such that i &isin; pidsr.</p>

    <p class="text-gray-300">In other words, after a node i has been selected for any committee, A can no longer corrupt it &mdash; this also means that if a node is honest when it is chosen into the committee, it will remain honest forever. Further, before choosing the e-th committee, A must commit to which nodes will be asleep and exactly when during epoch e.</p>

    <p class="text-gray-300">&bull; Resilience. At any time step t, let cmt<sup>t</sup> (view) be the (t, pidst) committee set that A sends to Ftree in view. It must hold that</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\mathsf{alert}^t(\\mathsf{cmt}^t(\\mathsf{view}),\\mathsf{view}) \\cap \\mathsf{honest}(\\mathsf{cmt}^t(\\mathsf{view}),\\mathsf{view})}{\\mathsf{corrupt}(\\mathsf{cmt}^t(\\mathsf{view}),\\mathsf{view})} \\geq 1 + \\phi</span>$</p>

    <p class="text-gray-300">where alert<sup>t</sup> (S, view) denotes those among S are alert at time t; honest(S, view) denotes those among S remain honest forever; and and corrupt(S, view) denotes those among S are ever corrupt in view.</p>

    <p class="text-gray-300">&bull; Number of awake nodes. Let cmt<sup>t</sup> (view) be the (t, pidst) committee set that A sends to Ftree in view. It must hold that for every t &le; |view|,</p>

    <p class="text-gray-300"><span class="math">$(\\mathsf{alert}^t(\\mathsf{cmt}^t(\\mathsf{view}),\\mathsf{view}) \\cap \\mathsf{honest}(\\mathsf{cmt}^t(\\mathsf{view}),\\mathsf{view})) + \\mathsf{corrupt}(\\mathsf{cmt}^t(\\mathsf{view}),\\mathsf{view}) = n</span>$</p>

    <p class="text-gray-300">In other words, at every time step t, the number of alert committee members and the number of corrupt committee members must sum up to n.</p>

    <p class="text-gray-300">&bull; Admissible parameters. The parameters (p, n, &phi;, &#8710;) satisfy the following constraints: np&#8710; &lt; 1 and moreover, there exists a constant &psi; &gt; 0 such that</p>

    <p class="text-gray-300"><span class="math">$(1 - 2\\alpha(\\Delta + 1))\\alpha &gt; (1 + \\psi)\\beta</span>$</p>

    <p class="text-gray-300">where &alpha; and &beta; are derived variables whose definitions were presented in Section <a href="#page-31-0">C.5.</a></p>

    <p class="text-gray-300">Theorem 3 (Security of &Pi;ideal). For any constant 0, &gt; 0, any T<sup>0</sup> &ge; 0&kappa;, &Pi;snowwhite satisfies (T0, g0, g1)-chain growth, (T0, &micro;)-chain quality, and T<sup>0</sup> consistency against any &Pi;ideal-compliant p.p.t. pair (A, Z), with the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>chain growth lower bound parameter g<sup>0</sup> = (1 &minus; )&gamma;;</li>
      <li>chain growth upper bound parameter g<sup>1</sup> = (1 + )np; and</li>
      <li>chain quality parameter &micro; = (1 &minus; )(1 &minus; &beta; &gamma; );</li>
    </ul>

    <p class="text-gray-300">where &alpha;, &beta;, &gamma; are defined as in Section <a href="#page-31-0">C.5.</a></p>

    <p class="text-gray-300">Proof. Although our ideal protocol &Pi;ideal is different from the ideal protocol for Sleepy <a href="#page-21-7">[48]</a>, we stress that the differences are inconsequential to the induced stochastic process. We claim that the proof follows in the same manner as that of Sleepy <a href="#page-21-7">[48]</a>, by pointing out the differences between our ideal protocol and that of Sleepy <a href="#page-21-7">[48]</a>.</p>

    <p class="text-gray-300">Recall that Sleepy <a href="#page-21-7">[48]</a> defines an ideal protocol where they assume that there is a fixed committee known upfront. All nodes are spawned upfront, and all corrupt and sleep instructions are declared upfront. Our &Pi;ideal is more fine-grained: First, each time step can have a different committee. Second, nodes can get spawned dynamically, and corrupt and sleep instructions need not be declared at the time of spawning. However, it is important to observe that the compliance rule for our &Pi;ideal basically stipulates that from the perspective of every committee: 1) if the adversary wants a committee member to ever be corrupt, he must commit to this decision before seeing random coins that decide if the committee member gets elected as leader; and 2) if the adversary wants a committee member at t to be asleep at t, he also must commit to this decision before seeing the random coins that decide if this committee member is elected leader at t.</p>

    </section>

    <section id="app-g" class="mb-10">
      <h2 class="text-2xl font-bold">G Proofs: Intermediate Hybrid Protocols</h2>

      <h3 id="app-g.1" class="text-xl font-semibold mt-8">G.1 Ideal Protocol with Adversarially Biased Hashes</h3>

    <p class="text-gray-300">We now consider a hybrid protocol denoted  <span class="math">\\Pi_{\\text{bias}}</span>  that effectively allows the adversary to bias the hash functions. The definition of  <span class="math">\\Pi_{\\text{bias}}</span>  is almost identical to  <span class="math">\\Pi_{\\text{ideal}}</span> , except that all honest nodes' interactions with  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  are now replaced with  <span class="math">\\mathcal{F}_{\\text{bias}}</span> .</p>

    <p class="text-gray-300">Compliant executions. A compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  pair for  <span class="math">\\Pi_{\\text{bias}}</span>  is defined in almost the same way as a compliant environment for  <span class="math">\\Pi_{\\text{ideal}}</span> , except now we additionally require that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathcal{A}</span>  must have  <span class="math">\\mathcal{F}_{\\text{bias}}.\\mathtt{sethash}(e, \\mathsf{nonce}_e)</span>  before epoch e starts. In other words,  <span class="math">\\mathcal{A}</span>  must choose the next hash function before the next epoch begins.</li>
      <li>We additionally require that  <span class="math">T_{\\text{epoch}} \\geq \\frac{\\kappa}{\\gamma}</span> .</li>
    </ul>

    <p class="text-gray-300">A useful lemma. Henceforth we will sometimes use the terminology &quot;hash for an epoch&quot; to refer to the randomness used by  <span class="math">\\mathcal{F}_{bias}</span>  (or  <span class="math">\\mathcal{F}_{tree}</span> ) for the epoch. Recall that the only difference between  <span class="math">\\Pi_{bias}</span>  and  <span class="math">\\Pi_{ideal}</span>  is that in  <span class="math">\\Pi_{bias}</span> , when  <span class="math">\\mathcal{F}_{bias}</span>  picks the hash for an epoch, the adversary is allowed to look at polynomially many choices for each epoch's hashes, and then instruct  <span class="math">\\mathcal{F}_{bias}</span>  which hash to use. In particular, the adversary can choose the worst-case combination of different epochs' hashes to maximize its own advantage.</p>

    <p class="text-gray-300">Given a view, we say that  <span class="math">\\mathcal{A}</span>  looks at q hashes for an epoch in view, if all of its queries to  <span class="math">\\mathcal{F}_{\\text{bias}}</span> .leader for a given epoch has q distinct nonces. Further, let  <span class="math">\\text{view} \\leftarrow_{\\</span>} \\text{EXEC}^{\\Pi_{\\text{ideal}}}(\\mathcal{A}, \\mathcal{Z}, \\kappa)$ , and let bad-event(view) be a random variable defined over view. We now define the same bad-event(view') over an execution trace  <span class="math">\\text{view}&#x27; \\leftarrow_{\\</span>} \\text{EXEC}^{\\Pi_{\\text{bias}}}(\\mathcal{A}, \\mathcal{Z}, \\kappa)$  in the most natural manner. In particular, view' can be thought of as a superset of the bits in view. We can define a function compress(view') which removes all additional bits that are in view' but not in view, such as the  <span class="math">\\mathcal{F}_{\\text{bias}}</span> .sethash calls made by  <span class="math">\\mathcal{A}</span> ; and moreover only the hashes chosen by  <span class="math">\\mathcal{A}</span>  are preserved in compress(view'), the remaining hashes are thrown away in compress(view'). In this way we can define bad-event(view') := bad-event(compress(view')).</p>

    <p class="text-gray-300">Lemma 1 (Union bound over small number of hashes). Let bad-event(view)  <span class="math">\\in \\{0,1\\}</span>  be a random variable that depends only on the randomness for c epochs, i.e., there exists  <span class="math">E \\subset \\mathbb{N}</span>  where |E| = c, such that for any  <span class="math">\\Pi_{\\text{ideal}}</span> -compliant p.p.t. pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , the following holds where  <span class="math">\\vec{v}(\\text{view})</span>  returns all the randomness  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  generated for all epochs in view, and  <span class="math">v_e(\\text{view})</span>  denotes the randomness generated by  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  corresponding to the e-th epoch:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp; \\Pr\\left[\\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi_{\\mathrm{ideal}}}(\\mathcal{A}, \\mathcal{Z}, \\kappa) : \\mathsf{bad-event}(\\mathsf{view}) = 1 ; \\middle| ; \\vec{v}(\\mathsf{view}) \\right] \\ &amp; = &amp; \\Pr\\left[\\mathsf{view} \\leftarrow_{$} \\mathsf{EXEC}^{\\Pi_{\\mathrm{ideal}}}(\\mathcal{A}, \\mathcal{Z}, \\kappa) : \\mathsf{bad-event}(\\mathsf{view}) = 1 ; \\middle| ; {v_e(\\mathsf{view})}_{e \\in E} \\right] \\end{split}$$</p>

    <p class="text-gray-300">We have that any p.p.t. pair  <span class="math">\\Pi_{\\text{bias}}</span> -compliant p.p.t. pair  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  such that  <span class="math">\\mathcal{A}&#x27;</span>  looks at no more than q hashes for each epoch in any view  <span class="math">\\leftarrow \\mathsf{EXEC}^{\\Pi_{\\text{bias}}}(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;, \\kappa)</span>  of non-zero support, there exists a  <span class="math">\\Pi_{\\text{ideal}}</span> -compliant p.p.t. pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , the following holds:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp; \\Pr\\left[\\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi_{\\mathrm{bias}}}(\\mathcal{A}', \\mathcal{Z}', \\kappa) : \\mathsf{bad-event}(\\mathsf{view}) = 1\\right] \\ \\leq &amp; \\Pr\\left[\\mathsf{view} \\leftarrow_{$} \\mathsf{EXEC}^{\\Pi_{\\mathrm{ideal}}}(\\mathcal{A}, \\mathcal{Z}, \\kappa) : \\mathsf{bad-event}(\\mathsf{view}) = 1\\right] \\cdot q^c \\end{split}$$</p>

    <pre><code class="language-text">\\mathcal{F}_{\\text{bias}}(T_{\\text{epoch}}, p)
On init: tree := genesis
On receive setpids(t, pids_t) from A:
    assert no tuple of the form (t, \\_) has been recorded,
    assert pids_t contain only parties that have been spawned
    record (t, pids_t)
On receive leader(nonce, \\mathcal{P}, t) from \\mathcal{A} or internally:
    assert (t, pids_t) has been recorded, and \\mathcal{P} \\in pids_t
    if \\Gamma[\\mathsf{nonce}, \\mathcal{P}, t] has not been set, let \\Gamma[\\mathsf{nonce}, \\mathcal{P}, t] := \\begin{cases} 1 &amp; \\text{with probability } p \\\\ 0 &amp; \\text{o.w.} \\end{cases}
    return \\Gamma[\\mathsf{nonce}, \\mathcal{P}, t]
On receive sethash(e, nonce_e) from A: record (e, nonce_e)
On receive extend(chain, B) from \\mathcal{P}: let e = \\mathsf{epoch}(t) where t denotes the current time
    assert chain \\in tree, chain ||B \\notin tree, and a pair (e, \\mathsf{nonce}_e) was recorded
    assert leader(nonce&lt;sub&gt;e&lt;/sub&gt;, \\mathcal{P}, t) outputs 1
    append B to chain in tree, record time(chain||B) = t, and return &quot;succ&quot;
On receive extend(chain, B, t&#x27;) from corrupt party \\mathcal{P}^*: let e = \\operatorname{\\mathsf{epoch}}(t&#x27;):
    assert chain \\in tree, and chain ||B \\notin tree,
    assert a pair (e, \\mathsf{nonce}_e) was recorded, and \\mathsf{leader}(\\mathsf{nonce}_e, \\mathcal{P}^*, t&#x27;) outputs 1
    assert time(chain) &lt; t&#x27; \\le t where t is current time
    append B to chain in tree, record time(chain||B) = t&#x27;, and return &quot;succ&quot;
On receive verify(chain) from \\mathcal{P}: return (chain \\in tree)
</code></pre>

    <p class="text-gray-300">Figure 7: Ideal functionality  <span class="math">\\mathcal{F}_{\\text{bias}}</span> , allowing adversarially biased hash functions.</p>

    <p class="text-gray-300"><em>Proof.</em> By a straightforward union bound. More specifically, for any p.p.t. pair  <span class="math">\\Pi_{\\text{bias}}</span> -compliant p.p.t. pair  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  that attacks  <span class="math">\\Pi_{\\text{bias}}</span> , we can construct a  <span class="math">\\Pi_{\\text{ideal}}</span> -compliant p.p.t. pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  and an execution of  <span class="math">\\Pi_{\\text{ideal}}</span> , where  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is allowed to choose the random bits of  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  for epochs not in E, i.e., epochs that bad-event does not depend on; however for epochs in E,  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  gets to choose the randomness.</p>

    <p class="text-gray-300"><span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  calls  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  as a blackbox. Whenever  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  makes leader queries on a future time step t that is not in any of the epochs in E,  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  generates the answer at random. Whenever  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  calls sethash for an epoch in E,  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  asks  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  to use the same random bits as what  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  has chosen for the corresponding epoch. Whenever  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  makes leader queries on a future time step t that is in an epoch in E, and the query contains a nonce that has not been seen, at this moment,  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  flips a random coin with probability  <span class="math">\\frac{1}{q}</span>  and guesses whether the nonce queried will be chosen by  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span> . If the coin turns up heads,  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  returns answers to  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  consistent with its  <span class="math">\\mathcal{F}_{\\text{tree}}</span> . Otherwise,  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  returns fresh random answers. If the choice later turns out to be</p>

    <p class="text-gray-300">wrong,  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  simply aborts. If eventually  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  calls <strong>sethash</strong> for a challenge nonce it has never queried (for an epoch in E), for any future <strong>leader</strong> query related to this challenge nonce,  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  returns answers consistent with its own  <span class="math">\\mathcal{F}_{\\text{tree}}</span> . Finally, whatever other actions  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  outputs,  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  replays it in the execution of  <span class="math">\\Pi_{\\text{ideal}}</span> . It is not hard to see that  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  will not abort with  <span class="math">\\frac{1}{q^c}</span>  probability. If  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  does not abort, then bad-event happens in the execution of  <span class="math">\\Pi_{\\text{bias}}</span>  iff it happens in the execution of  <span class="math">\\Pi_{\\text{ideal}}</span> . Due to the definition of conditional independence, the probability of bad-event happening in  <span class="math">\\Pi_{\\text{ideal}}</span>  does not depend on the randomness of any other epoch not in E (recall that we had  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  fix the randomness of  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  for any epoch not in E).</p>

    <p class="text-gray-300"><strong>Theorem 4</strong> (Security of  <span class="math">\\Pi_{\\text{bias}}</span> ).  <span class="math">\\Pi_{\\text{bias}}</span>  satisfies  <span class="math">T_0</span> -consistency,  <span class="math">(T_0, \\mu)</span> -chain quality, and  <span class="math">(T_0, g_0, g_1)</span> -chain growth against any  <span class="math">\\Pi_{\\text{bias}}</span> -compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  for the same parameters  <span class="math">T_0, \\mu, g_0, g_1</span>  as defined in Theorem 3.</p>

    <p class="text-gray-300"><em>Proof.</em> We now prove the above Theorem 4. Due to Lemma 1, it suffices to show that every bad event we care about bounding is a subset of the union of  <span class="math">poly(\\kappa)</span>  bad events each of which depends only on a constant number of hashes. Recall that the proof of Theorem 3 essentially follows the proof in the Sleepy paper [48] &mdash; as mentioned earlier even though our ideal protocol is different from that of Sleepy [48], the differences are inconsequential and does not alter the induced stochastic process.</p>

    <p class="text-gray-300">In the remainder of the proof, we will revisit Sleepy's proof [48]. Instead of presenting the full proof again from scratch, we focus on pointing out how to express every bad event as the union of polynomially many bad events each of which depends only on a constant number of hashes.</p>

    <p class="text-gray-300">Chain growth lower bound. It is easy to see that the consistent length property still holds with our new  <span class="math">\\Pi_{\\text{bias}}</span> .</p>

    <p class="text-gray-300">We now prove chain growth lower bound. We will show that and every window of medium length, i.e., for every  <span class="math">\\frac{T_0}{g_0} \\leq t_0 \\leq \\frac{2T_0}{g_0}</span> , the chain growth lower bound holds for the parameter  <span class="math">t_0</span>  over views sampled from  <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathrm{bias}}}(\\mathcal{A},\\mathcal{Z},\\kappa)</span> . It is not hard to see that if the chain growth lower bound holds for every window of medium length  <span class="math">\\frac{T_0}{g_0} \\leq t_0 \\leq \\frac{2T_0}{g_0}</span> , then it also holds for every  <span class="math">T \\geq T_0</span>  and every  <span class="math">t_0 \\geq \\frac{T}{g_0}</span> , since every longer window can be broken up into disjoint windows of medium lengths, and we simply have to take a union bound over these windows.</p>

    <p class="text-gray-300">To complete the proof, it suffices to observe the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In Sleepy's chain growth lower bound proof [48] which in turn follows that of Pass et al. [45], for any window [t,t'], conditioned on any execution trace view<sup>t</sup> up till time t, the minimum chain growth during the window [t,t'] is upper bounded by a random variable that depends only on the randomness generated by  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  corresponding to the time window [t,t'], but does not depend on any other random bits generated by  <span class="math">\\mathcal{F}_{\\text{tree}}</span> . Our chain growth lower bound proof then goes to show that conditioned on any view<sup>t</sup>, the minimum chain growth during the window [t,t'] has to be large. Note that the minimum chain growth during the window [t,t'] may depend on random bits before this window, but the proof lower bounds the minimum chain growth during [t,t'] with another (implicitly defined) random variable that does not depend on any randomness before t.</li>
      <li>Since  <span class="math">T_{\\text{epoch}} \\geq \\frac{\\kappa}{\\gamma}</span> , it holds that every window of medium length (where medium length is as defined above) involves only O(1) number of epochs.</li>
    </ul>

    <p class="text-gray-300">However, as mentioned earlier, since the chain growth lower bound for a medium sized window is lower bounded by a random variable that depends only on c = O(1) hashes, by Lemma 1, chain</p>

    <p class="text-gray-300">growth lower bound holds except with negligible probability over view&larr;$EXEC&Pi;bias (A, Z, &kappa;) for any medium sized window.</p>

    <p class="text-gray-300">Chain quality. We examine the chain quality proof of Sleepy <a href="#page-21-7">[48]</a>. Below we use the same notations as in Sleepy <a href="#page-21-7">[48]</a>.</p>

    <p class="text-gray-300">If t &le; 2Tepoch is small, then the random variable Q(view)[r : r + t] depends on only c = O(1) number of hashes. Similarly, the random variable A(view)[r : r + t] also depends only on c = O(1) number of hashes for t &le; 2Tepoch.</p>

    <p class="text-gray-300">Applying Lemma <a href="#page-42-2">1,</a> for fixed [r, r +t] such that t &le; 2Tepoch is small, we have that for any &gt; 0, any p.p.t. pair (A, Z) compliant for &Pi;bias,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi_{\\mathrm{bias}}}(\\mathcal{A}, \\mathcal{Z}, \\kappa) : \\mathbf{Q}(\\mathsf{view})[r:r+t] &gt; (1+\\epsilon)np \\cdot t\\right] &lt; \\mathsf{negl}(npt) \\cdot q(\\kappa)^c$$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi_{\\mathrm{bias}}}(\\mathcal{A}, \\mathcal{Z}, \\kappa) : \\mathbf{A}(\\mathsf{view})[r:r+t] &gt; (1+\\epsilon)\\beta t\\right] &lt; \\mathsf{negl}(\\beta t) \\cdot q(\\kappa)^c$$</p>

    <p class="text-gray-300">where q(&kappa;) denotes the maximum number of hash queries made by A.</p>

    <p class="text-gray-300">Now, taking a union bound, we can upper bound Qt(view) and At(view) for any t &le; 2Tepoch see the Sleepy work <a href="#page-21-7">[48]</a> for definitions of Q<sup>t</sup> and A<sup>t</sup> . Specifically, for any t &le; 2Tepoch, any &gt; 0, any &Pi;bias-compliant p.p.t. pair (A, Z), there exists a negligible function negl(&middot;) and a polynomial function poly(&middot;) such that for all &kappa;,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\Pr\\left[\\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi_{\\mathrm{bias}}}(\\mathcal{A}, \\mathcal{Z}, \\kappa) : Q_t(\\mathsf{view}) &gt; (1+\\epsilon)np \\cdot t\\right] &lt; \\mathsf{negl}(npt) \\cdot \\mathsf{poly}(\\kappa) \\ &amp;\\Pr\\left[\\mathsf{view} \\leftarrow_{$} \\mathsf{EXEC}^{\\Pi_{\\mathrm{bias}}}(\\mathcal{A}, \\mathcal{Z}, \\kappa) : A_t(\\mathsf{view}) &gt; (1+\\epsilon)\\beta t\\right] &lt; \\mathsf{negl}(\\beta t) \\cdot \\mathsf{poly}(\\kappa) \\end{split}$$</p>

    <p class="text-gray-300">The above proved bounds for Qt(view) and At(view) for small values of t, assuming t &le; 2Tepoch. We now consider large windows. Similarly as before, we can break up large windows into mediumsized windows of lengths [Tepoch, 2Tepoch]. By taking a union bound over all windows, we easily get the following fact.</p>

    <p class="text-gray-300">Fact 1. For any t &gt; 0, any &gt; 0, any p.p.t. pair (A, Z) compliant for &Pi;bias, there exists a negligible function negl(&middot;) and a polynomial poly(&middot;) such that for all &kappa;,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi_{\\mathrm{bias}}}(\\mathcal{A}, \\mathcal{Z}, \\kappa) : Q_t(\\mathsf{view}) &gt; (1+\\epsilon)np \\cdot t\\right] &lt; \\mathsf{negl}(np \\cdot \\min(t, T_{\\mathrm{epoch}})) \\cdot \\mathsf{poly}(\\kappa)$$</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi_{\\mathrm{bias}}}(\\mathcal{A}, \\mathcal{Z}, \\kappa) : A_t(\\mathsf{view}) &gt; (1+\\epsilon)\\beta t\\right] &lt; \\mathsf{negI}(\\beta \\cdot \\min(t, T_{\\mathrm{epoch}})) \\cdot \\mathsf{poly}(\\kappa)$$</p>

    <p class="text-gray-300">The remainder of the chain quality proof can then be completed following exactly the same recipe as Sleepy <a href="#page-21-7">[48]</a>, plugging in our new Fact <a href="#page-45-0">1</a> to bound the random variables A<sup>t</sup> and Q<sup>t</sup> .</p>

    <p class="text-gray-300">Consistency. In Sleepy's consistency proof <a href="#page-21-7">[48]</a>, they define a view to be bad if there exists t<sup>0</sup> &le; t<sup>1</sup> &le; |view| where t<sup>1</sup> &minus; t<sup>0</sup> &ge; &radic; &kappa; &beta; , such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{A}(\\mathsf{view})[t_0:t_1] \\geq \\mathsf{chain}(\\mathsf{view})[t_0:t_1]</span>$</p>

    <p class="text-gray-300">They show that there are negl(&kappa;) fraction of such bad views &mdash; note that the same holds in our case, simply plugging in our new Fact <a href="#page-45-0">1.</a> Conditioned on views that are not bad, the Sleepy work <a href="#page-21-7">[48]</a> then argue that for every window of length <sup>2</sup><sup>&kappa;</sup> &beta; , there has to exist a pivot point except with negligible</p>

    <pre><code class="language-text">\\mathcal{F}_{\\text{punctual}}(T_{\\text{epoch}}, p, W) Almost the same as \\mathcal{F}_{\\text{bias}}, except with the following change highlighted in blue: On receive extend(chain, B, t&#x27;) from corrupt party \\mathcal{P}^*: let e = \\text{epoch}(t&#x27;): assert chain \\in tree, and chain||B \\notin \\text{tree} assert a pair (e, \\text{nonce}_e) was recorded, and leader(nonce&lt;sub&gt;e&lt;/sub&gt;, \\mathcal{P}^*, t&#x27;) outputs 1 assert time(chain) &lt; t&#x27; \\le t where t is current time assert t&#x27; \\ge t - W append B to chain in tree, record time(chain||B) = t&#x27;, and return &quot;succ&quot;
</code></pre>

    <p class="text-gray-300">Figure 8: Ideal functionality  <span class="math">\\mathcal{F}_{punctual}</span> .  <span class="math">\\mathcal{F}_{punctual}</span>  enforces punctuality, and rejects stale blocks that arrive too late. Blue denotes the difference from  <span class="math">\\mathcal{F}_{bias}</span> .</p>

    <p class="text-gray-300">probability. Note that for any window of length  <span class="math">\\frac{2\\kappa}{\\beta}</span> , and ignoring views that are not bad, the bad event that a pivot point does not exist within the window depends on randomness that are at most  <span class="math">\\Delta</span>  far from boundaries of the window &mdash; this means that the bad event depends on O(1) number of hashes given that  <span class="math">T_{\\rm epoch} \\geq \\frac{\\kappa}{\\gamma}</span> . Now by Lemma 1, the bad event that there does not exist a pivot within a window of length  <span class="math">\\frac{2\\kappa}{\\beta}</span>  is  <span class="math">{\\rm negl}(\\kappa)</span> . The remainder of the proof follows in the same way as Sleepy [48].</p>

    <p class="text-gray-300">Chain growth upper bound. First, given that we have already proved chain growth lower bound and a bound for the random variable  <span class="math">A_t</span> , we can prove a &quot;no long block withholding&quot; lemma in exactly the same way as Sleepy [48], where for a withholding time of  <span class="math">\\epsilon t</span> , the failure probability is replaced with  <span class="math">\\operatorname{negl}(\\min(\\beta \\cdot \\min(t, T_{\\operatorname{epoch}}))) \\cdot \\operatorname{poly}(\\kappa)</span>  instead of  <span class="math">\\operatorname{negl}(\\beta t)\\operatorname{poly}(\\kappa)</span> . For completeness, we state this lemma below since it will be used later in the proof as well.</p>

    <p class="text-gray-300">Let withhold-time(view) be the longest number of time steps t such that in view: 1) at some time in view, the adversary mines a chain with purported  <span class="math">\\mathcal{F}_{\\text{tree}}</span> -timestamp r; and 2) chain is first accepted by honest nodes at time r+t in view.</p>

    <p class="text-gray-300"><strong>Lemma 2</strong> (No long block withholding). For every  <span class="math">\\Pi_{\\text{bias}}</span> -compliant p.p.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  pair, for every constant  <span class="math">0 &lt; \\epsilon &lt; 1</span> , there exists a negligible function  <span class="math">\\text{negl}(\\cdot)</span>  such that</p>

    <pre><code class="language-text">\\Pr\\left[\\mathsf{view} \\leftarrow_{\\$} \\mathsf{EXEC}^{\\Pi_{\\mathrm{bias}}}(\\mathcal{A}, \\mathcal{Z}, \\kappa) : \\mathsf{withhold-time}(\\mathsf{view}) &gt; \\epsilon t\\right] \\leq \\mathsf{negl}(\\beta \\min(t, T_{\\mathrm{epoch}})) \\cdot \\mathsf{poly}(\\kappa)
</code></pre>

    <p class="text-gray-300">We can now prove chain growth upper bound exactly in the same way as Sleepy [48], relying on our bound on  <span class="math">Q_t</span>  as well as the new &quot;no long block withholding&quot; lemma.</p>

      <h3 id="app-g.2" class="text-xl font-semibold mt-8">G.2 Allowing Posterior Corruption</h3>

    <p class="text-gray-300">The &quot;no long block withholding&quot; lemma (see Lemma 2) states that if there is a chain  <span class="math">\\in \\mathcal{F}_{punctual}</span>  tree with a sufficiently old timestamp, then if an honest node never accepted chain as its prefix earlier, it is not going to ever accept chain as its prefix. This implies that even if the adversary  <span class="math">\\mathcal{A}</span>  successfully asks  <span class="math">\\mathcal{F}_{punctual}</span>  to extend a chain with a sufficiently stale timestamp, this action is useless because</p>

    <p class="text-gray-300">A cannot ever persuade any honest node to ever accept this chain (or any longer chain containing it). In this section, we will augment our ideal functionality to simply reject A's requests to extend a chain with a sufficiently stale timestamp &mdash; see Fpunctual in Figure <a href="#page-46-1">8.</a> It is not hard to show that this modification does not affect the security of our ideal protocol.</p>

    <p class="text-gray-300">Protocol &Pi;punctual. We define &Pi;punctual in exactly the same manner as &Pi;bias, except that calls to Fbias are now replaced with calls to Fpunctual.</p>

    <p class="text-gray-300">Compliant (A, Z). We now consider a model where Z can corrupt committee members sufficiently ancient in the past, as long as Z has not committed these nodes to serve on committees in recent, present, or future epochs. We show that because Fpunctual rejects blocks with stale timestamps anyway, corruption into the past does not allow the adversary to do anything interesting additionally. As a result, we prove that &Pi;punctual is actually secure in this stronger corruption model.</p>

    <p class="text-gray-300">More formally, we say that a p.p.t. pair (A, Z) is compliant for &Pi;punctual iff the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A-priori commitment of committees and hashes. Same as &Pi;bias.</li>
      <li>Spawning and sleeping. Same as the compliance rules for &Pi;bias.</li>
      <li>Corruption model. At time t &le; t 0 , A is allowed to issue (corrupt, i, t<sup>0</sup> ) iff    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>there does not exist r &ge; t <sup>0</sup> &minus; W such that A has called Fpunctual.setpids(r, pidsr) where i &isin; pidsr;</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">At time t &le; t<sup>0</sup> &le; t1, A is allowed to issue (sleep, i, t0, t1) if</p>

    <p class="text-gray-300">&ndash; for every r &isin; [t0, t1], A has not called Fpunctual.setpids(r, pidsr) such that i &isin; pidsr.</p>

    <p class="text-gray-300">In other words, A can only ask a node i to become corrupt at time t 0 , if A has not committed i to be on a committee any time at t <sup>0</sup> &minus; W or later. However, it is possible that after A asks a node i to become corrupt at a future time, A can then commit it to some committee. It is also possible for A to ask a node to be corrupt at a future time if the node served on some very old committee, but has not been committed to any committee since. Note that this &quot;posterior corruption&quot; ability was not allowed for our earlier corruption model (i.e., (A, Z) compliant for &Pi;bias).</p>

    <p class="text-gray-300">Further, similar as before, before A commits to a committee for time t, A must commit to which set of honest nodes will become asleep at time t.</p>

    <p class="text-gray-300">&bull; Resilience. For any time step t, let cmt<sup>t</sup> (view) be the (t, pidst) committee set that A sends to Fpunctual in view, let r = min(t + W, |view|), it must hold that</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\mathsf{alert}^t(\\mathsf{cmt}^t(\\mathsf{view}),\\mathsf{view}) \\cap \\mathsf{honest}^r(\\mathsf{cmt}^t(\\mathsf{view}),\\mathsf{view})}{\\mathsf{corrupt}^r(\\mathsf{cmt}^t(\\mathsf{view}),\\mathsf{view})} \\geq 1 + \\phi</span>$</p>

    <p class="text-gray-300">where alert<sup>s</sup> (S, view), honest<sup>s</sup> (S, view), and corrupt<sup>s</sup> (S, view) denote those among S are alert, honest, and corrupt at time s respectively.</p>

    <p class="text-gray-300">Notice that our new resilience rule is weaker now, it only requires at any time t, alert committee members who remain honest for W more steps outnumber committee members who become corrupt by t + W. Before in &Pi;ideal and &Pi;bias, we essentially required W to be infinity.</p>

    <p class="text-gray-300">&bull; Number of awake nodes. Let  <span class="math">\\mathsf{cmt}^t(\\mathsf{view})</span>  be the  <span class="math">(t,\\mathsf{pids}_t)</span>  committee set that  <span class="math">\\mathcal{A}</span>  sends to  <span class="math">\\mathcal{F}_{\\mathsf{punctual}}</span>  in view. It holds that for every  <span class="math">t \\leq |\\mathsf{view}|</span> , let  <span class="math">r = \\min(t + W, |\\mathsf{view}|)</span> ,</p>

    <p class="text-gray-300"><span class="math">$(\\mathsf{alert}^t(\\mathsf{cmt}^t(\\mathsf{view}), \\mathsf{view}) \\cap \\mathsf{honest}^r(\\mathsf{cmt}^t(\\mathsf{view}), \\mathsf{view})) + \\mathsf{corrupt}^r(\\mathsf{cmt}^t(\\mathsf{view}), \\mathsf{view}) = n</span>$</p>

    <p class="text-gray-300">&bull; Admissible parameters. Same as in  <span class="math">\\Pi_{\\text{bias}}</span>  with the additional requirement that  <span class="math">W \\geq \\frac{\\kappa}{\\gamma}</span> .</p>

    <p class="text-gray-300"><strong>Theorem 5</strong> (Security of  <span class="math">\\Pi_{\\text{punctual}}</span> ).  <span class="math">\\Pi_{\\text{punctual}}</span>  satisfies  <span class="math">T_0</span> -consistency,  <span class="math">(T_0, \\mu)</span> -chain quality, and  <span class="math">(T_0, g_0, g_1)</span> -chain growth against any  <span class="math">\\Pi_{\\text{punctual}}</span> -compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  for the same parameters  <span class="math">T_0, \\mu, g_0, g_1</span>  as defined in Theorem 3.</p>

    <p class="text-gray-300">Proof. First, it is not hard to see that  <span class="math">\\Pi_{\\text{punctual}}</span>  satisfies consistency,  <span class="math">\\mu</span> -chain quality, and  <span class="math">(g_0, g_1)</span> -chain growth for a weaker corruption model, i.e., against any any p.p.t. pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  compliant w.r.t.  <span class="math">\\Pi_{\\text{bias}}</span>  (rather than w.r.t.  <span class="math">\\Pi_{\\text{punctual}}</span> ). Recall that a  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  pair compliant w.r.t.  <span class="math">\\Pi_{\\text{bias}}</span>  is not allowed posterior corruption. To see this, consider a compliant execution of  <span class="math">\\Pi_{\\text{bias}}</span> . Due to the &quot;no long block withholding&quot; lemma, a block with an old timestamp will never be first accepted by honest nodes with  <span class="math">1 - \\text{negl}(\\beta W) = 1 - \\text{negl}(\\frac{\\beta \\kappa}{\\gamma}) = 1 - \\text{negl}(\\kappa)</span>  probability, where W denotes how old the block is.</p>

    <p class="text-gray-300">Below we simply ignore the negligible fraction of bad views where the &quot;no long block withholding&quot; lemma fails. This means that in any good view, if  <span class="math">\\mathcal{A}</span>  tries to call  <span class="math">\\mathcal{F}_{\\text{bias}}</span> .extend(chain,  <span class="math">\\mathcal{B}, t&#x27;</span> ) at time t, where t' &lt; t - W and suppose that chain|| <span class="math">\\mathcal{B}</span>  is not already in  <span class="math">\\mathcal{F}_{\\text{bias}}</span> , then no honest will later ever call  <span class="math">\\mathcal{F}_{\\text{bias}}</span> .verify(chain') where chain|| <span class="math">\\mathcal{B} \\prec \\text{chain&#x27;}</span> . For this reason, it is equivalent if  <span class="math">\\mathcal{F}_{\\text{bias}}</span>  simply ignored such adversarial requests to  <span class="math">\\mathcal{F}_{\\text{bias}}</span> .extend( <span class="math">_{-}</span> ,  <span class="math">_{-}</span> ,  <span class="math">_{-}</span> ) at time t, where t' &lt; t - W. And the only difference between  <span class="math">\\Pi_{\\text{bias}}</span>  and  <span class="math">\\Pi_{\\text{punctual}}</span>  is precisely this: in  <span class="math">\\Pi_{\\text{punctual}}</span> ,  <span class="math">\\mathcal{F}_{\\text{punctual}}</span>  ignores such adversarial requests to extend a chain with very old timestamps.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathsf{allchains}^t(\\mathsf{view})</span>  denote the set that includes an ordered list of the output chains of all nodes alert at time t. To complete the proof, it suffices to show the following lemma.</p>

    <p class="text-gray-300"><strong>Lemma 3</strong> (Posterior corruption does not matter). For any  <span class="math">\\Pi_{\\text{punctual}}</span> -compliant p.p.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , there exists  <span class="math">\\Pi_{\\text{bias}}</span> -compliant p.p.t.  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span> , and a function somechains<sup>t</sup>(view) that selects an appropriate subset of alert nodes' output chains in view and at time t, such that the following distributions are identical:</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{l} \\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi_{\\mathrm{punctual}}}(\\mathcal{A}, \\mathcal{Z}, \\kappa) : {\\mathsf{allchains}^t(\\mathsf{view})}<em>{t \\in [|\\mathsf{view}|]} \\text{ and } \\ \\mathsf{view}' \\leftarrow</em>{$} \\mathsf{EXEC}^{\\Pi_{\\mathrm{punctual}}}(\\mathcal{A}', \\mathcal{Z}', \\kappa) : {\\mathsf{somechains}^t(\\mathsf{view}')}_{t \\in [|\\mathsf{view}'|]} \\end{array}$$</p>

    <p class="text-gray-300">Proof. (A', Z') runs (A, Z) in a sandbox and intercepts (A, Z)'s communications with outside. At a high level, whenever (A, Z) wants to corrupt a node, (A', Z') will spawn a sybil of the node and corrupt the sybil instead. This will allow (A', Z') to respect  <span class="math">\\Pi_{\\text{bias}}</span> 's compliance rules and yet be able to emulate (A, Z)'s attack. As pointed out earlier, if  <span class="math">\\Pi_{\\text{punctual}}</span>  is run with such a weaker,  <span class="math">\\Pi_{\\text{bias}}</span> -compliant attacker, then the execution respects all the desired properties including chain growth, chain quality, and consistency. Since (A', Z') can emulate attacks by (A, Z), we can then infer that  <span class="math">\\Pi_{\\text{punctual}}</span>  retains these properties in the presence of a stronger,  <span class="math">\\Pi_{\\text{punctual}}</span> -compliant attacker too.</p>

    <p class="text-gray-300">&bull; If at some time  <span class="math">t \\leq t&#x27;</span> ,  <span class="math">\\mathcal{A}</span>  issues (corrupt, i, t'): if  <span class="math">\\mathcal{A}</span>  has issued (corrupt, i, r) for  <span class="math">r \\leq t&#x27;</span>  earlier, this request is ignored. Otherwise, i must not been chosen as a committee member for  <span class="math">[t&#x27;-W, \\infty]</span>  since  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is  <span class="math">\\Pi_{\\text{punctual}}</span> -compliant. Now  <span class="math">\\mathcal{Z}&#x27;</span>  spawns a sybil  <span class="math">i^*</span>  immediately (if no sybil of i has been spawned earlier) and provides it with i's internal state as input. Let  <span class="math">i^*</span>  be the sybil of</p>

    <p class="text-gray-300">i spawned either at the current time t or earlier. Further,  <span class="math">\\mathcal{A}&#x27;</span>  issues (corrupt,  <span class="math">i^*, t&#x27;</span> ).  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  remembers (or updates) the mapping sybil[i] =  <span class="math">(i^*, t&#x27; - W)</span> . We also say that t' - W is sybil node  <span class="math">i^*</span> 's effective time. Intuitively,  <span class="math">i^*</span>  will act as a defunct copy of i before its effective time; and afterwards  <span class="math">i^*</span>  will act on behalf of i and then i will effectively become the defunct copy.</p>

    <p class="text-gray-300">&bull; Whenever  <span class="math">\\mathcal{A}</span>  calls  <span class="math">\\mathcal{F}_{punctual}.setpids(t, pids_t)</span>  and this is the first time  <span class="math">\\mathcal{A}</span>  calls  <span class="math">\\mathcal{F}_{punctual}.setpids(t, _),</span>   <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  will inspect pids <span class="math">_t</span> . If  <span class="math">i \\in pids_t</span>  and some tuple sybil[i] =  <span class="math">(i^*, s)</span>  has been stored for some  <span class="math">s \\leq t</span> , replace node i's occurrence in pids <span class="math">_t</span>  with  <span class="math">i^*</span> .</p>

    <p class="text-gray-300">Whenever  <span class="math">\\mathcal{A}</span>  calls  <span class="math">\\mathcal{F}_{\\text{punctual}}.\\mathtt{extend}(\\_,\\_,\\_)</span>  or  <span class="math">\\mathcal{F}_{\\text{punctual}}.\\mathtt{verify}(\\_)</span>  acting as node i at time t,  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  finds the stored sybil identity  <span class="math">i^*</span>  for i&mdash; note that such a sybil identity  <span class="math">i^*</span>  has to exist and  <span class="math">i^*</span>  has to be already corrupt at t if  <span class="math">\\mathcal{A}</span>  is acting as i at t. Now  <span class="math">\\mathcal{A}&#x27;</span>  rewrites the call acting as  <span class="math">i^*</span>  instead.</p>

    <p class="text-gray-300">Similarly, whenever  <span class="math">\\mathcal{A}</span>  calls  <span class="math">\\mathcal{F}_{\\text{punctual}}.leader(_,i,t)</span> ,  <span class="math">(\\mathcal{A}&#x27;,\\mathcal{Z}&#x27;)</span>  makes the following check: if i has a stored sybil identity  <span class="math">i^*</span>  and moreover  <span class="math">i^*</span>  is effective at time t, then  <span class="math">\\mathcal{A}&#x27;</span>  rewrites the call replacing i with  <span class="math">i^*</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Whenever  <span class="math">\\mathcal{A}</span>  or  <span class="math">\\mathcal{Z}</span>  sends a message to an honest node i,  <span class="math">\\mathcal{A}&#x27;</span>  or  <span class="math">\\mathcal{Z}&#x27;</span>  sends a duplicate of this message to i's sybil  <span class="math">i^*</span>  if one exists.</li>
      <li>Whenever a sybil node  <span class="math">i^*</span>  sends a message to  <span class="math">\\mathcal{A}</span>  or  <span class="math">\\mathcal{Z}</span>  at time t (this means that the sybil node  <span class="math">i^*</span>  has not become corrupt yet, and is still honest), simply drop the message.</li>
      <li>For every other message sent by  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> ,  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  directly passes through them.</li>
    </ul>

    <p class="text-gray-300">If  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is  <span class="math">\\Pi_{\\text{punctual}}</span> -compliant, and let  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  be defined as above, then the following facts must hold: in any view  <span class="math">\\leftarrow \\mathsf{EXEC}^{\\Pi_{\\text{punctual}}}(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;, \\kappa)</span>  of non-zero support, for any pair of nodes  <span class="math">(i, i^*)</span>  where  <span class="math">i^*</span>  is i's sybil whose effective time is  <span class="math">r, i^*</span>  is never on any committee for any  <span class="math">t \\leq r</span> ; and i is never on any committee for any t &gt; r. Further, for every sybil  <span class="math">i^*</span>  in view,  <span class="math">\\mathcal{A}&#x27;</span>  has to issue (corrupt,  <span class="math">i^*</span> , _) instructions prior to any  <span class="math">\\mathcal{F}_{\\text{punctual}}</span> .setpids calls that commit  <span class="math">i^*</span>  to being a committee member.</p>

    <p class="text-gray-300">Claim 2. If  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is  <span class="math">\\Pi_{\\text{punctual}}</span> -compliant, then  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  must be  <span class="math">\\Pi_{\\text{bias}}</span> -compliant.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Proof. Corruption model. Observe that a  <span class="math">\\Pi_{\\text{punctual}}</span> -compliant  <span class="math">\\mathcal{A}</span>  will never issue (corrupt, i, t') at time  <span class="math">t \\leq t&#x27;</span> , if node i has already been committed to as a committee member for time t' W of after. If  <span class="math">\\mathcal{A}</span>  issues (corrupt, i, t') at time  <span class="math">t \\leq t&#x27;</span>  for some node i that was on a committee before t' W but has not been committed to as a committee member since, then  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  captures this request and rewrites it with a spawn and a corrupt request for a different node  <span class="math">i^*</span> . In this way, it is not hard to see that  <span class="math">\\mathcal{A}&#x27;</span>  will never issue (corrupt, i, t') at time  <span class="math">t \\leq t&#x27;</span>  if node i has ever been committed to as any (past or future) committee member by time t.</li>
      <li>Resilience and correct parametrization. For any fixed sequence of random bits  <span class="math">\\vec{v}</span>  consumed by all ITMs in the execution, we consider the pair of execution traces defined by  <span class="math">\\vec{v}</span> , denoted view( <span class="math">\\vec{v}</span> ) and view'( <span class="math">\\vec{v}</span> ) in the support of  <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathrm{punctual}}}(\\mathcal{A}, \\mathcal{Z}, \\kappa)</span>  and  <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathrm{punctual}}}(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;, \\kappa)</span>  respectively.</li>
    </ul>

    <p class="text-gray-300">It is not hard to see that for every pair  <span class="math">view(\\vec{v})</span>  and  <span class="math">view&#x27;(\\vec{v})</span>  defined by randomness  <span class="math">\\vec{v}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\forall t: \\mathsf{alert}^t(\\mathsf{cmt}^t(\\mathsf{view}&#x27;), \\mathsf{view}&#x27;) = \\mathsf{alert}^t(\\mathsf{cmt}^t(\\mathsf{view}), \\mathsf{view})</span>$</p>

    <p class="text-gray-300">We now show that</p>

    <p class="text-gray-300"><span class="math">$\\forall t : \\mathsf{corrupt}(\\mathsf{cmt}^t(\\mathsf{view}&#x27;), \\mathsf{view}&#x27;) = \\mathsf{corrupt}^{\\min(t+W, |\\mathsf{view}|)}(\\mathsf{cmt}^t(\\mathsf{view}), \\mathsf{view})</span>$</p>

    <p class="text-gray-300">which would also imply</p>

    <p class="text-gray-300"><span class="math">$\\forall t : \\mathsf{honest}(\\mathsf{cmt}^t(\\mathsf{view}&#x27;), \\mathsf{view}&#x27;) = \\mathsf{honest}^{\\min(t+W, |\\mathsf{view}|)}(\\mathsf{cmt}^t(\\mathsf{view}), \\mathsf{view})</span>$</p>

    <p class="text-gray-300">&le;: For every node j that is on the committee of time t in view<sup>0</sup> and is ever corrupt, j must be the sybil of some node henceforth denoted i. Clearly i must be on the committee for time t in view, therefore it suffices to show that i is corrupt by time min(t + W, |view|) in view. Notice that if j on the committee at time t and is ever corrupt in view<sup>0</sup> , let r denote the time that j becomes corrupt. It must be the case that (corrupt, j, r) is issued and afterwards A<sup>0</sup> commits j to being a committee member at t. We now show r &le; t + W. Notice that if A<sup>0</sup> issues (corrupt, j, r), then j must be a sybil node whose effective time starts at r &minus; W before r &minus; W even though j has been spawned, it does not do anything interesting such as being added to committees. Therefore t &ge; r &minus; W.</p>

    <p class="text-gray-300">To complete the proof, it is not hard to observe that (corrupt, i, r) must be in view and further in view A must commit i to being a committee member at t.</p>

    <p class="text-gray-300">&ge;: For every i on the committee at t in view and is ever corrupt in [t, min(t+W, |view|), it must be the case that in view, A issues (corrupt, i, r) for some r &le; min(t + W, |view|) first, and then A commits i to the t-th committee. Therefore, in the corresponding view<sup>0</sup> , A<sup>0</sup> will issue (corrupt, i<sup>&lowast;</sup> , r) where i &lowast; is the sybil of i in view<sup>0</sup> . Further, A<sup>0</sup> will commit i &lowast; to the t-th committee.</p>

    <p class="text-gray-300">It is easy to verify that (A<sup>0</sup> , Z 0 ) satisfies the remaining compliance rules.</p>

    <p class="text-gray-300">We now consider the most natural selection function somechains that selects a subset of alert nodes' output chains at every time t given view<sup>0</sup> &larr; EXEC&Pi;punctual(A<sup>0</sup> , Z 0 , &kappa;). Specifically, for each pair (i, i<sup>&lowast;</sup> ) such that both are alert at time t, somechains<sup>t</sup> would select i <sup>&lowast;</sup> at time t if t is at or after i &lowast; 's effective time. Otherwise, somechains<sup>t</sup> would select i.</p>

    <p class="text-gray-300">Claim 3. Under the aforementioned selection function somechains<sup>t</sup> , for every pair view(~&upsilon;) and view<sup>0</sup> (~&upsilon;) defined by randomness ~&upsilon;,</p>

    <p class="text-gray-300"><span class="math">$\\{\\mathsf{allchains}^t(\\mathsf{view})\\}_{t \\in [|\\mathsf{view}|]} = \\{\\mathsf{somechains}^t(\\mathsf{view}&#x27;)\\}_{t \\in [|\\mathsf{view}&#x27;|]}</span>$</p>

    <p class="text-gray-300">Proof. To see this, notice that all (A<sup>0</sup> , Z 0 ) does is renaming nodes &mdash; therefore it is not hard to see that the only way that the two can differ is if at some time t &ge; t 0 , A calls Fpunctual.extend( , , t<sup>0</sup> ) acting as some corrupt node i, such that i is leader for t 0 in view, but i is no longer effective at time t in view<sup>0</sup> because its sybil node i <sup>&lowast;</sup> has taken over.</p>

    <p class="text-gray-300">Now suppose that at t &ge; t 0 , A calls Fpunctual.extend( , , t<sup>0</sup> ) acting as some corrupt node i. There are two cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>t <sup>0</sup> &lt; t &minus; W: In this case, Fpunctual would have ignored the request in view since the timestamp t 0 is too old.</li>
      <li>t <sup>0</sup> &ge; t &minus; W: Since we know that in view, i is corrupt at time t, it has to be the case that i &lowast; is already effective at time t 0 .</li>
    </ul>

    <pre><code class="language-text"> \\begin{aligned} &amp; \\textbf{Protocol} \\ \\Pi_{hyb} \\\\ &amp; \\textbf{On input init() from } \\mathcal{Z}: \\\\ &amp; \\textbf{let pk} := \\mathcal{G}_{sign}.\\text{gen}(), \\ \\text{output pk to } \\mathcal{Z}, \\ \\text{wait to receive } \\textit{chain}, \\ \\text{record } \\textit{chain} \\ \\text{ and pk} \\\\ &amp; \\textbf{On receive } \\textit{chain&#x27;}: \\\\ &amp; \\textbf{assert } |\\textit{chain&#x27;}| &gt; |\\textit{chain}| \\ \\text{and } \\widetilde{\\mathcal{F}}_{punctual}.\\text{verify}(\\textit{chain&#x27;}) = 1 \\\\ &amp; \\textit{chain} := \\textit{chain&#x27;} \\ \\text{and gossip } \\textit{chain} \\\\ &amp; \\textbf{Every time step:} \\\\ &amp; \\textbf{e receive input transactions(txs) from } \\mathcal{Z} \\\\ &amp; \\textbf{e pick random fresh nonce, and let } t \\ \\text{be the current time} \\\\ &amp; \\textbf{e let } \\sigma := \\mathcal{G}_{sign}.\\text{sign(pk, } \\textit{chain}[-1].h, \\text{txs, } t, \\text{nonce}), \\ h&#x27; := \\text{d}(\\textit{chain}[-1].h, \\text{txs, } t, \\text{nonce, pk, } \\sigma) \\\\ &amp; \\textbf{e let } B := (\\textit{chain}[-1].h, \\text{txs, } t, \\text{nonce, pk, } \\sigma, h&#x27;) \\\\ &amp; \\textbf{e if } \\widetilde{\\mathcal{F}}_{punctual}.\\text{extend}(\\textit{chain, } B) \\ \\text{outputs &quot;succ&quot;: let } \\textit{chain := chain} || B \\ \\text{and gossip } \\textit{chain} \\\\ &amp; \\textbf{e output extract}(\\textit{chain}) \\ \\text{to } \\mathcal{Z} \\\\ &amp; \\overline{\\mathcal{F}}_{punctual}: \\ \\text{Same as } \\overline{\\mathcal{F}}_{punctual} \\ \\text{except that the extend}(-, B, t&#x27;) \\ \\text{entry point now additionally asserts that } t&#x27; = B. \\text{time} \\end{aligned}
</code></pre>

    <p class="text-gray-300">Figure 9: A hybrid protocol carrying real-world blocks.</p>

      <h3 id="app-g.3" class="text-xl font-semibold mt-8">G.3 Hybrid Protocol: Ideal Protocol with Real-World Blocks</h3>

    <p class="text-gray-300">We are almost ready to show that our real-world protocol emulates the ideal-world one which we know how to analyze. But before that, we have to go through one more intermediate step that correct the protocol's interfaces to the environment  <span class="math">\\mathcal{Z}</span>  such that the interfaces will type check by the real-world protocol's type definitions.</p>

    <p class="text-gray-300">In this section, we will define a hybrid protocol  <span class="math">\\Pi_{hyb}</span>  that carries real-world interfaces to the environment  <span class="math">\\mathcal{Z}</span>  &mdash; see Figure 9. We will show that all the properties we care about (including consistency, chain growth, and chain quality) hold for  <span class="math">\\Pi_{hyb}</span>  in exactly the same way they hold for  <span class="math">\\Pi_{punctual}</span> . Since  <span class="math">\\Pi_{hyb}</span>  carries real-world interfaces, we can later show that our real-world protocol  <span class="math">\\Pi_{snowwhite}</span>  emulates  <span class="math">\\Pi_{hyb}</span> ; and therefore the real-world protocol satisfies all these properties as well.</p>

    <p class="text-gray-300">Compliant (A, Z). We say that (A, Z)  <span class="math">\\Pi_{hyb}</span> -compliant if the following holds for any view with non-zero support:</p>

    <p class="text-gray-300">&bull; Initialization. At the start of the execution, the following happens. First,  <span class="math">\\mathcal{Z}</span>  can spawn a set of either honest or corrupt nodes.  <span class="math">\\mathcal{Z}</span>  learns the honest nodes' public keys after calling their init()</p>

    <p class="text-gray-300">procedure. Next, A provides the inputs  <span class="math">\\{genesis\\}</span>  to all honest nodes. At this point, protocol execution starts.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Sleeping.</strong> All sleepers are treated as light sleepers. Upon waking, all pending messages it should have received but did not receive are delivered, plus adversarially inserted messages.</li>
      <li>Spawning. When a new, alert node spawns at time t,  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  must deliver to it an initialization message  <span class="math">chain_0</span>  such that  <span class="math">chain_0 \\in \\mathcal{F}_{punctual}</span>  and  <span class="math">chain_0</span>  is no shorter than the shortest chain of any alert node at time t-1.</li>
      <li>A-prior commitment.  <span class="math">\\mathcal{A}</span>  must have called  <span class="math">\\mathcal{F}_{punctual}.setpids(t, pids_t)</span>  before t. Similarly,  <span class="math">\\mathcal{A}</span>  must have called  <span class="math">\\mathcal{F}_{punctual}.sethash(e, pids_e)</span>  before start(e).</li>
      <li>Corruption model, resilience, number of awake nodes, admissible parameters. Same as in  <span class="math">\\Pi_{\\text{punctual}}</span> .</li>
    </ul>

    <p class="text-gray-300"><strong>Theorem 6</strong> (Security of  <span class="math">\\Pi_{\\text{hyb}}</span> ).  <span class="math">\\Pi_{\\text{hyb}}</span>  satisfies  <span class="math">T_0</span> -consistency,  <span class="math">(T_0, \\mu)</span> -chain quality, and  <span class="math">(T_0, g_0, g_1)</span> -chain growth against any  <span class="math">\\Pi_{\\text{hyb}}</span> -compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  for the same parameters  <span class="math">T_0, \\mu, g_0, g_1</span>  as defined in Theorem 3.</p>

    <p class="text-gray-300"><em>Proof.</em> Follows in a straightforward manner from the security of  <span class="math">\\Pi_{\\text{punctual}}</span> .</p>

    <p class="text-gray-300">Remark: Agreement of  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span>  timestamp and blockchain timestamp. We note that  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span>  checks that the claimed timestamp agrees with the timestamp in the block B when an adversary calls extend. Observe also that alert nodes always use truthful timestamps when calling  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span>  extend. Due to this reason, henceforth, for any  <span class="math">chain \\in \\widetilde{\\mathcal{F}}_{punctual}</span> , we may use its  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span> -timestamp and chain[-1].time interchangeably.</p>

      <h3 id="app-g.4" class="text-xl font-semibold mt-8">G.4 Timestamp Freshness Lemma</h3>

    <p class="text-gray-300">We prove a useful property about timestamp freshness in any alert node's chain. This will be useful in the next section when we prove that the real-world protocol emulates the hybrid-world. Roughly speaking, the timestamp freshness property says that in any alert node's chain, the timestamp of any block cannot be too early relative to the position of the block in the chain. This will later be useful in Section H in proving that in a simulated execution, certain good events (whose occurrence depends on the existence of large timestamps in alert nodes' chains) happen early enough.</p>

    <p class="text-gray-300">Formally, we define a property freshtime  <span class="math">\\ell, r(\\text{view}) = 1</span>  iff the following holds for view: at any time t, for any node i alert at t and suppose  <span class="math">|chain_i^t(\\text{view})| \\ge \\ell</span> , then  <span class="math">chain_i^t(\\text{view})[-\\ell]</span> .time &gt; t - r.</p>

    <p class="text-gray-300">Claim 4 (Freshness of timestamp in stablized chain). For any  <span class="math">\\Pi_{\\text{hyb}}</span> -compliant p.p.t. pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , there exists a negligible function  <span class="math">\\text{negl}(\\cdot)</span>  such that for every  <span class="math">\\kappa</span> , every  <span class="math">\\epsilon, \\epsilon_0 &gt; 0</span> , every  <span class="math">\\ell &gt; 0</span> , let  <span class="math">r = \\frac{\\ell + \\epsilon \\kappa}{g_0}</span>  where  <span class="math">g_0 = (1 - \\epsilon_0)\\gamma</span> , it holds that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi_{\\mathrm{hyb}}}(\\mathcal{A}, \\mathcal{Z}, \\kappa) : \\mathsf{freshtime}^{\\ell, r}(\\mathsf{view}) = 1\\right] \\geq 1 - \\mathsf{negl}(\\kappa)$$</p>

    <p class="text-gray-300"><em>Proof.</em> Below we ignore the negligible fraction of views where bad events such as failure of chain quality or chain growth happen.</p>

    <p class="text-gray-300">If t &lt; r, the claim trivially holds. We focus on proving the case where  <span class="math">t \\ge r</span> . In this case, by chain growth, every node alert at time t must have chain length at least  <span class="math">\\ell + \\epsilon \\kappa</span> . By chain quality, in  <span class="math">chain_i^t[-(\\ell + \\epsilon \\kappa) : -\\ell]</span>  there must be a block mined by node j honest at time t' in view &mdash; by definition this means that node j has chain length at least  <span class="math">|chain_i^t| - (\\ell + \\epsilon \\kappa)</span>  at time t'.</p>

    <p class="text-gray-300">By chain growth, we have that at most  <span class="math">t-t&#x27; \\leq \\frac{\\ell+\\epsilon\\kappa}{g_0} = r</span>  time has elapsed between t' and t. Since honest blocks contain true timestamps reflecting when the block is mined, there exists a block in  <span class="math">B \\in chain_i^t[-\\ell+\\epsilon\\kappa:-\\ell]</span>  such that  <span class="math">B.\\mathsf{time} \\geq t-r</span> . The rest of the proof is obvious by observing that timestamps must be strictly increasing in  <span class="math">chain_i^t</span>  assuming i is alert at t.</p>

    <p class="text-gray-300"><strong>Remark.</strong> Henceforth, whenever we apply Claim 4 in our proofs, we will assume that  <span class="math">g_0 = (1 - \\epsilon_0)\\gamma</span>  for an  <span class="math">\\epsilon_0</span>  that is appropriately small &mdash; it is not hard to identify such a  <span class="math">\\epsilon_0</span>  for all proofs that rely on Claim 4 henceforth &mdash; we therefore often omit spelling out  <span class="math">g_0</span>  as  <span class="math">g_0 = (1 - \\epsilon_0)\\gamma</span>  for simplity.</p>

      <h3 id="app-h.1" class="text-xl font-semibold mt-8">H.1 Theorem Statement</h3>

    <p class="text-gray-300"><strong>Theorem 7</strong> ( <span class="math">\\Pi_{\\text{snowwhite}}</span>  emulates  <span class="math">\\Pi_{\\text{hyb}}</span>  while preserving compliance). For any real-world p.p.t. adversary  <span class="math">\\mathcal{A}</span>  for  <span class="math">\\Pi_{\\text{snowwhite}}</span> , there exists a p.p.t. adversary (also called the simulator)  <span class="math">\\mathcal{S}</span>  for  <span class="math">\\Pi_{\\text{hyb}}</span> , such that for any p.p.t.  <span class="math">\\mathcal{Z}</span>  satisfying the condition that  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is  <span class="math">\\Pi_{\\text{snowwhite}}</span> -compliant, we have that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(S, Z) is  <span class="math">\\Pi_{hyb}</span> -compliant; and</li>
      <li><span class="math">\\bullet \\ \\ \\mathsf{EXEC}^{\\Pi_{\\mathrm{snowwhite}}}(\\mathcal{A},\\mathcal{Z},\\kappa) \\stackrel{c}{\\equiv} \\mathsf{EXEC}^{\\Pi_{\\mathrm{hyb}}}(\\mathcal{S},\\mathcal{Z},\\kappa)</span></li>
    </ul>

    <p class="text-gray-300">In the above, both  <span class="math">\\Pi_{\\text{snowwhite}}</span>  and  <span class="math">\\Pi_{\\text{hyb}}</span>  (and specifically  <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span> ) are instantiated with &quot;matching&quot; parameters. More specifically, the following must be hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Both  <span class="math">\\Pi_{\\text{snowwhite}}</span>  and  <span class="math">\\Pi_{\\text{hyb}}</span>  (or more specifically  <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span> ) are instantiated with the same  <span class="math">(p, T_{\\text{epoch}})</span> .</li>
      <li>Suppose W is the posterior corruption parameter respected by the real-world adversary  <span class="math">\\mathcal{A}</span> , it holds that in protocol  <span class="math">\\Pi_{\\text{hyb}}</span> ,  <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span>  is instantiated with the parameter W.</li>
    </ul>

    <p class="text-gray-300">In this section, we prove the above Theorem 7.</p>

      <h3 id="app-h.2" class="text-xl font-semibold mt-8">H.2 Simulator Construction</h3>

    <p class="text-gray-300">We first describe the construction of S, which interacts in a blackbox manner with A.</p>

    <p class="text-gray-300"><strong>Intended invariants by construction.</strong> By construction, the simulator is meant to maintain the following invariants:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>S keeps performing internal checks in every time step, and aborts whenever (S, Z) is about to violate  <span class="math">\\Pi_{hyb}</span> 's compliance rules. In this way, as long as the simulation has not aborted, (S, Z) is by construction  <span class="math">\\Pi_{hyb}</span> -compliant, and therefore we can use the security properties of  <span class="math">\\Pi_{hyb}</span>  to reason about the simulated execution. Later, we will also show aborts will not happen except with negligible probability.</li>
    </ol>

    <h4 id="sec-misc-3" class="text-lg font-semibold mt-6">AddtoTree(chain)</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&bull; Computes  <span class="math">\\ell</span>  such that  <span class="math">chain[: \\ell - 1]</span>  is the longest prefix of chain such that  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span> .verify  <span class="math">(chain[: \\ell - 1]) = 1</span> .</li>
      <li>If any block in  <span class="math">chain[\\ell:]</span>  is signed by a public key that does not correspond to a corrupt node, abort outputting signature-failure.</li>
      <li>Else, for each  <span class="math">\\ell&#x27; \\in [\\ell, |chain|]</span> : call  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}.extend(chain[: \\ell&#x27; 1], chain[\\ell&#x27;], chain[\\ell&#x27;].time)</span>  acting as the corrupt node that corresponds to  <span class="math">chain[\\ell&#x27;].pk</span>  at time  <span class="math">chain[\\ell&#x27;].time</span> .</li>
      <li>If  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}.verify(chain)</span>  does not return true at this point, abort outputting extend-failure.</li>
    </ul>

    <p class="text-gray-300">Figure 10: AddtoTree subroutine internally called by S.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>S always makes sure that any <em>chain</em> sent to alert nodes that would have been accepted by alert nodes in the real world must be in  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span> . In other words, if A tries to send a <em>chain</em> to an alert node i, S will first emulate node i's  <span class="math">\\Pi_{snowwhite}</span> -behavior to see if node i might have accepted <em>chain</em> in the real-world protocol  <span class="math">\\Pi_{snowwhite}</span> . If so, then S will make sure that <em>chain</em> is indeed in  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span>  before forwarding <em>chain</em> to i. This may mean that S will need to call  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span> .extend to insert new chains before forwarding <em>chain</em> to i.</li>
    </ol>

    <p class="text-gray-300">In this way, an essential step in showing the indistinguishability of the real-world and simulated executions is to argue that S can always succeed in adding a <em>chain</em> to  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span>  if <em>chain</em> would have been accepted in the real-world by alert nodes (see Section H.4).</p>

    <p class="text-gray-300">Simulator description. For convenience, we introduce the syntactic sugar</p>

    <p class="text-gray-300"><span class="math">$\\widetilde{\\mathcal{F}}_{\\text{punctual}}.\\mathtt{setpids}(e,\\mathsf{pids}_e)</span>$</p>

    <p class="text-gray-300">to allow  <span class="math">\\mathcal{S}</span>  to set the committee for each time step t that is in epoch e, all with the same committee  <span class="math">\\mathsf{pids}_e</span> . Clearly  <span class="math">\\widetilde{\\mathcal{F}}_{\\mathsf{punctual}}.\\mathsf{setpids}(e,\\mathsf{pids}_e)</span>  can be implemented by multiple calls to  <span class="math">\\widetilde{\\mathcal{F}}_{\\mathsf{punctual}}.\\mathsf{setpids}(t,\\mathsf{pids}_t)</span> .</p>

    <p class="text-gray-300">Our simulator S relies on a parameter  <span class="math">\\epsilon^* &gt; 0</span> . Our proof will hold as long as  <span class="math">\\epsilon^*</span>  is sufficiently small, e.g., less than  <span class="math">\\frac{1}{4}</span> . Henceforth without loss of generality, the reader can assume that  <span class="math">\\epsilon^* = \\frac{1}{4}</span> . The security failure probability will be related to  <span class="math">\\epsilon^*</span> , e.g., in the form of  <span class="math">\\mathsf{negl}(\\mathsf{poly}(\\epsilon^*, \\kappa))</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Whenever a party calls  <span class="math">\\mathcal{G}_{sign}</span> .gen, the adversary is notified of the pair  <span class="math">(\\mathcal{P}, pk)</span> . It stores this party identifier and public key mapping. If an honest node's public key ever collides with a key that is already stored in the mapping, abort outputting duplicate-key-failure.</li>
      <li>Since S sees all messages sent to and from honest nodes, S can simulate the internal longest <em>chain</em> kept by all honest nodes in the most natural manner. Henceforth we assume that for any t, any i honest at time t, S knows  <span class="math">chain_i^t</span> .</li>
      <li>Whenever  <span class="math">\\mathcal{A}</span>  asks hash queries: if this query has been seen before,  <span class="math">\\mathcal{S}</span>  returns the same answer as before.</li>
    </ul>

    <p class="text-gray-300">Else, suppose that the query is of the form  <span class="math">\\mathsf{H}^\\mathsf{nonce}(\\mathsf{pk},t)</span> , let  <span class="math">e = \\mathsf{epoch}(t)</span> : if  <span class="math">\\mathcal{S}</span>  has not yet committed to  <span class="math">\\widetilde{\\mathcal{F}}_\\mathsf{punctual}</span>  the e-th committee, then  <span class="math">\\mathcal{S}</span>  simply generates a random number of appropriate length, and returns it to  <span class="math">\\mathcal{A}</span> . Else if  <span class="math">\\mathcal{S}</span>  has committed to  <span class="math">\\widetilde{\\mathcal{F}}_\\mathsf{punctual}</span>  the e-th committee, then  <span class="math">\\mathcal{S}</span>  generates a random number that agrees with  <span class="math">\\widetilde{\\mathcal{F}}_\\mathsf{punctual}</span> . Note that due to our simulator description later, if  <span class="math">\\mathcal{S}</span>  has committed to the e-th committee, then there is a spawned party (either honest or corrupt) for each public keys in the e-th committee, and the simulator  <span class="math">\\mathcal{S}</span>  must have this mapping stored.</p>

    <p class="text-gray-300">More specifically, S first looks up the party identifier P that corresponds to pk. If such a party identifier is not found, S samples a random number of appropriate length and returns it to A. Else, S calls  <span class="math">b = \\widetilde{\\mathcal{F}}_{punctual}.leader(nonce, &lt;math&gt;P</span> , t). If b = 1, it rejection samples an t until t and then returns t. Else, it it rejection samples an t until t and then returns t.</p>

    <p class="text-gray-300">&bull; Whenever  <span class="math">\\mathcal{A}</span>  sends a protocol message <em>chain</em> to an honest party i, the simulator  <span class="math">\\mathcal{S}</span>  checks the validity of <em>chain</em> simulating node i running the real-world protocol's checks &mdash; here the hash function H is implemented with  <span class="math">\\mathcal{S}</span> 's own table. Specifically,  <span class="math">\\mathcal{S}</span>  answers its own H queries in the same way that it answers  <span class="math">\\mathcal{A}</span> 's H queries. If these real-world checks pass, the simulator  <span class="math">\\mathcal{S}</span>  calls AddtoTree(chain) as described in Figure 10. If the call does not abort outputting signature-failure or extend-failure,  <span class="math">\\mathcal{S}</span>  forwards chain to node i.</p>

    <p class="text-gray-300">If the real-world checks fail,  <span class="math">\\mathcal{S}</span>  drops the message <em>chain</em> and does not forward <em>chain</em> to node i&mdash;note that this may cause  <span class="math">\\mathcal{S}</span>  to violate the  <span class="math">\\Delta</span>  network delivery requirement. Therefore, as we describe later,  <span class="math">\\mathcal{S}</span>  will perform internal consistency checks, and if it ever violates the  <span class="math">\\Delta</span>  network delivery requirement, it simply aborts outputting  <span class="math">\\Delta</span> -failure.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Whenever  <span class="math">\\mathcal{A}</span>  sends an initialization message  <span class="math">\\{chain_i\\}_{i\\in L}</span>  to an honest party i that has just spawned or waken up from deep sleep: the simulator  <span class="math">\\mathcal{S}</span>  runs the real-world algorithm to compute an initial chain as before, here the hash H is implemented by  <span class="math">\\mathcal{S}</span>  itself.  <span class="math">\\mathcal{S}</span>  then calls AddtoTree(chain), and if the call did not abort with either signature-failure or extend-failure,  <span class="math">\\mathcal{S}</span>  sends chain to node i.</li>
      <li>At the beginning of every time step t, the simulator S performs the following verification. First, if S has not called  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}.setpids(e, \\_)</span>  or  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}.sethash(e, \\_)</span>  where e := epoch(t), abort outputting late-failure. The simulator additionally checks the resilience, number of awake nodes, and admissible parameter conditions for time step t, and if the checks fail, abort outputting param-failure.</li>
    </ul>

    <p class="text-gray-300">For each honest node i, the simulator finds  <span class="math">chain_i^t</span>  henceforth denoted  <span class="math">chain_i</span>  for short. Recall that the simulator keeps track of the longest chain each honest node has.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Consistency checks. For every node i alert at time t,  <span class="math">\\mathcal{S}</span>  computes  <span class="math">\\mathsf{pks}_i := \\mathsf{elect\\_cmt}^t(chain_i)</span> . If both i and j are alert at t but  <span class="math">\\mathsf{pks}_i \\neq \\mathsf{pks}_j</span>  abort outputting consistency-failure. If  <span class="math">\\mathsf{pks}_i</span>  does not agree with the committee at t which  <span class="math">\\mathcal{S}</span>  previously committed to  <span class="math">\\widetilde{\\mathcal{F}}_{\\mathsf{punctual}}</span> , abort outputting consistency-failure. Here consistency is defined by  <span class="math">\\mathcal{S}</span> 's internal public key to party identifier mapping.</li>
    </ul>

    <p class="text-gray-300">For every node i alert at time t, S computes  <span class="math">\\mathsf{nonce}_i := \\mathsf{elect\\_h}^t(\\mathit{chain}_i)</span> . If  <span class="math">\\mathsf{nonce}_i</span>  does not agree with what S previously committed to  <span class="math">\\widetilde{\\mathcal{F}}_{\\mathsf{punctual}}</span> , abort outputting consistency-failure.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Choose next committee or hash when necessary. Henceforth let  <span class="math">chain := chain_i^t</span> , note that S checks all alert nodes' chains to see if it needs to choose the next committee or hash.</li>
    </ul>

    <p class="text-gray-300">If  <span class="math">|chain| \\ge \\epsilon^* \\kappa + 2</span> ,  <span class="math">\\mathcal{S}</span>  will check to see if it needs to commit to the next epoch's committee and/or hash. Let  <span class="math">\\mathsf{start}(e) := e \\cdot T_{\\mathsf{epoch}}</span>  denote the start of epoch  <span class="math">e \\in \\mathbb{N}</span> .</p>

    <p class="text-gray-300">For any  <span class="math">e \\in \\mathbb{N}</span> , if there exists consecutive blocks  <span class="math">(B_0, B_1) \\in chain[: -\\epsilon^* \\kappa]</span>  such that  <span class="math">B_1</span> .time +  <span class="math">2\\omega &gt; \\text{start}(e)</span>  but  <span class="math">B_0</span> .time +  <span class="math">2\\omega \\leq \\text{start}(e)</span> ,  <span class="math">\\mathcal{S}</span>  calls</p>

    <pre><code class="language-text">\\widetilde{\\mathcal{F}}_{\\mathrm{punctual}}.\\mathtt{setpids}(e,\\mathtt{extractpids}(\\mathit{chain}_0)) \\text{ where } \\mathit{chain}_0 := \\mathit{chain}[: \\mathsf{index}(B_0)]
</code></pre>

    <p class="text-gray-300">if it has not already called  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}.setpids(e, _-)</span>  earlier. Here  <span class="math">extractpids(chain_0)</span>  first calls  <span class="math">pks^* := extractpks(chain_0)</span>  and then maps the public keys to their party identifiers in the following way:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If S has recorded (P, pk) then map pk to P. Recall that S should have recorded such a mapping for all honest nodes' public keys.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If S has not recorded a mapping for pk, spawn a corrupt node with party identifier j, and map pk to j. Recall that our execution model allows S to spawn corrupt nodes without Z's knowledge. Further S stores the mapping from the party identifier j to the public key pk.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Similarly, for any  <span class="math">e \\in \\mathbb{N}</span> , if there exists consecutive blocks  <span class="math">(B_0, B_1) \\prec chain[: -\\epsilon^*\\kappa]</span>  such that  <span class="math">B_1.\\mathsf{time} + \\omega &gt; \\mathsf{start}(e)</span>  but  <span class="math">B_0.\\mathsf{time} + \\omega \\leq \\mathsf{start}(e)</span> ,  <span class="math">\\mathcal{S}</span>  calls  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}.\\mathsf{sethash}(e, \\mathsf{extractnonce}(chain_0))</span>  where  <span class="math">chain_0 := chain[: \\mathsf{index}(B_0)]</span>  if it has not already called  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}.\\mathsf{sethash}(e, \\square)</span>  earlier.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>At the end of every time step t, S performs a network delivery check. If it has ever received a message from some alert node by  <span class="math">t \\Delta</span> , but the message did not get delivered to any node alert at t, then S aborts outputting  <span class="math">\\Delta</span> -failure.</li>
      <li>Whenever  <span class="math">\\mathcal{S}</span>  calls  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span> .sethash <span class="math">(e, \\mathsf{nonce}_e)</span> , if  <span class="math">\\mathcal{A}</span>  (or any internal call) has made a hash query of the form  <span class="math">\\mathsf{H}^{\\mathsf{nonce}_e}(\\_,\\_)</span>  before  <span class="math">\\mathcal{S}</span>  called  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span> .setpids <span class="math">(e,\\_)</span> , abort outputting predict-failure.</li>
      <li>If  <span class="math">\\mathcal{A}</span>  ever issues a (corrupt, i, t') instruction to  <span class="math">\\mathcal{Z}</span>  at time  <span class="math">t \\leq t&#x27;</span> , the simulator  <span class="math">\\mathcal{S}</span>  checks that it has not committed node i to any committee at time t' W or later. If the check fails,  <span class="math">\\mathcal{S}</span>  aborts outputting corruption-failure. Else,  <span class="math">\\mathcal{S}</span>  passes through the instruction to  <span class="math">\\mathcal{Z}</span> ; further,  <span class="math">\\mathcal{S}</span>  queries  <span class="math">\\mathcal{G}_{\\text{sign}}</span>  to obtain the secret signing keys of party i, and exposes them to  <span class="math">\\mathcal{A}</span> .</li>
    </ul>

    <p class="text-gray-300">If  <span class="math">\\mathcal{A}</span>  ever issues a (sleep,  <span class="math">i, t_0, t_1</span> ) instruction to  <span class="math">\\mathcal{Z}</span>  at time  <span class="math">t \\leq t_0 \\leq t_1</span> , the simulator  <span class="math">\\mathcal{S}</span>  checks that it has not committed node i to any committee between  <span class="math">[t_0, t_1]</span> . If the check fails,  <span class="math">\\mathcal{S}</span>  aborts outputting corruption-failure; else, pass through the instruction to  <span class="math">\\mathcal{Z}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathcal{S}</span>  directly passes through all other messages between  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{G}_{sign}</span> . Similarly,  <span class="math">\\mathcal{S}</span>  directly passes through all other messages between  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span> .</li>
      <li>At the protocol start, whenever  <span class="math">\\mathcal{A}</span>  sends  <span class="math">\\mathsf{pks}_0</span>  to a spawning node as part of the initialization message,  <span class="math">\\mathcal{S}</span>  registers the first epoch's committee with  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span> . Before doing so, if there is any public key in  <span class="math">\\mathsf{pks}_0</span>  that does not have a party identifier mapping,  <span class="math">\\mathcal{S}</span>  spawns a corrupt node that corresponds to this public key, and stores the mapping.  <span class="math">\\mathcal{S}</span>  also registers  <span class="math">\\mathsf{nonce}_0</span>  with  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span>  as the nonce for the first epoch at protocol start.</li>
      <li><span class="math">\\bullet</span>  If S ever observes that two honest nodes have different chains with the same block hash, abort outputting hash-failure.</li>
    </ul>

    <p class="text-gray-300">We can now immediately state a few simple facts.</p>

    <p class="text-gray-300">Fact 2 (Compliant execution). In the above simulation, for any p.p.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>   <span class="math">\\Pi_{\\text{snowwhite}}</span> -compliant, the pair  <span class="math">(\\mathcal{S}^{\\mathcal{A}}, \\mathcal{Z})</span>  is  <span class="math">\\Pi_{\\text{hyb}}</span> -compliant.</p>

    <p class="text-gray-300"><em>Proof.</em> By definition, notice that the construction of the simulator S performed internal checks and always aborts outputting failure before it ever has a chance of being non-compliant.</p>

    <p class="text-gray-300">Fact 3 (No hash collision). S does not abort with hash-failure except with negligible probability.</p>

    <p class="text-gray-300"><em>Proof.</em> Straightforward due to the collision resistance of the digest function d.</p>

    <p class="text-gray-300">Fact 4 (No honest key collision). S does not abort with duplicate-key-failure except with negligible probability.</p>

    <p class="text-gray-300"><em>Proof.</em> Straightforward due to the security of the signature scheme.</p>

    <p class="text-gray-300">Due to the above facts, henceforth we will ignore the negligible fraction of views that have hash or honest key collisions.</p>

      <h3 id="app-h.3" class="text-xl font-semibold mt-8">H.3 Consistency and Compliance of the Simulated Execution</h3>

    <p class="text-gray-300">In this section, we focus on showing that if  <span class="math">(A, \\mathbb{Z})</span>  is  <span class="math">\\Pi_{\\text{snowwhite}}</span> -compliant, then the simulated execution has nice properties regarding consistency and the relative timing of events.</p>

    <p class="text-gray-300"><strong>Lemma 4</strong> (Consistency and a-priori commitment). For any compliant p.p.t. (A, Z) pair, there exists a negligible function negl such that for every  <span class="math">\\kappa</span></p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view}\\leftarrow_{\\</span>}\\mathsf{EXEC}^{\\Pi_{\\mathrm{hyb}}}(\\mathcal{S}^{\\mathcal{A}},\\mathcal{Z},\\kappa):\\mathsf{view}\\ \\mathrm{aborts}\\ \\mathrm{due}\\ \\mathrm{to}\\ \\mathsf{late-failure}\\ \\mathrm{or}\\ \\mathsf{consistency-failure}\\right]\\leq \\mathsf{negl}(\\kappa)$$</p>

    <p class="text-gray-300"><em>Proof.</em> We consider any view for  <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathsf{hyb}}}(\\mathcal{S}, \\mathcal{Z}, \\kappa)</span>  where none of the bad events related to chain quality, growth, and consistency happen.</p>

    <p class="text-gray-300">We prove the lemma for hashes, and the argument for the committee goes in the same way. It suffices to prove the following: For any  <span class="math">e \\in \\mathbb{N}</span>  in view, let  <span class="math">t = \\mathsf{start}(e)</span> , it holds that for every node i honest at time t-1, there exists</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>an honest block  <span class="math">B \\in chain_i^{t-1}[:-\\epsilon^*\\kappa]</span>  with  <span class="math">B.\\mathsf{time} &gt; t \\omega</span> ; and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>an honest block  <span class="math">B&#x27; \\in chain_i^{t-1}[:-\\epsilon^*\\kappa]</span>  with B'.time  <span class="math">\\leq t \\omega</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">where  <span class="math">chain_i^{t-1}(\\text{view})</span>  denotes the internal chain maintained by node i at time t-1 in view. We often write  <span class="math">chain_i^{t-1}</span>  in place of  <span class="math">chain_i^{t-1}(\\text{view})</span>  without risk of ambiguity.</p>

    <p class="text-gray-300">Notice that due to the definition of S which runs the real-world checks on any <em>chain</em> received from A before forwarding them onto honest nodes, and due to the definition of  <span class="math">\\Pi_{\\text{hyb}}</span> ,  <span class="math">chain_i^{t-1}</span>  must have strictly increasing timestamps. Therefore if the above conditions regarding the existence of B and B' in  <span class="math">chain_i^{t-1}</span>  are satisfied then</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathcal{S}</span>  will have called  <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}.\\mathtt{sethash}(e, \\_)</span>  before time t;</li>
      <li>Due to consistency and definition of S, S will not abort with consistency-failure due to disagreement on the hash for epoch e in view.</li>
    </ul>

    <p class="text-gray-300">Notice that the existence of the block B' trivially holds since the genesis block is defined to have a timestamp of 0. The existence of a block B is proved in Claim 4 given that  <span class="math">\\omega \\geq \\frac{2\\kappa}{\\gamma} + \\widetilde{\\Delta}</span> . This completes our proof.</p>

    <p class="text-gray-300"><strong>Lemma 5</strong> (Unpredictability of future hashes). For any compliant p.p.t.  <span class="math">(A, \\mathbb{Z})</span>  pair, there exists a negligible function negl such that for every  <span class="math">\\kappa</span></p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi_{\\mathrm{hyb}}}(\\mathcal{S}^{\\mathcal{A}}, \\mathcal{Z}, \\kappa) : \\mathsf{view} \\text{ aborts due to predict-failure}\\right] \\leq \\mathsf{negl}(\\kappa)$$</p>

    <p class="text-gray-300"><em>Proof.</em> Given a view  <span class="math">\\leftarrow \\mathsf{EXEC}^{\\Pi_{\\mathsf{hyb}}}(\\mathcal{S}^{\\mathcal{A}}, \\mathcal{Z})</span>  where none of the bad events related to chain quality, growth, consistency happen. Let  <span class="math">e \\in \\mathbb{N}</span>  denote an epoch in view such that  <span class="math">\\mathcal{S}</span>  has called  <span class="math">\\widetilde{\\mathcal{F}}_{\\mathsf{punctual}}.\\mathtt{sethash}(e, \\_)</span> . Note that by definition,  <span class="math">\\mathcal{S}</span>  must have called  <span class="math">\\widetilde{\\mathcal{F}}_{\\mathsf{punctual}}.\\mathtt{setpids}(e, \\_)</span>  too. Let  <span class="math">T = \\mathsf{start}(e)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Henceforth in this proof we shall adopt small enough constants  <span class="math">\\epsilon_0</span>  and  <span class="math">\\epsilon&#x27;</span> . The proof holds for any constant small enough. For example, one may assume  <span class="math">\\epsilon_0 = \\epsilon&#x27; = 1/8</span> .</li>
      <li>Let  <span class="math">chain_i^t(\\text{view})</span>  be the chain that triggered  <span class="math">\\mathcal{S}</span>  to call  <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}.\\text{sethash}(e, \\cdot)</span> , where i is a node honest at time t. Let  <span class="math">(B_{-1}^*, B^*)</span>  be two consecutive blocks in  <span class="math">chain_i^t[: -\\epsilon^*\\kappa]</span> , where  <span class="math">B^*.\\text{time} &gt; T \\omega</span>  and  <span class="math">B_{-1}^* \\leq T \\omega</span> .</li>
    </ul>

    <p class="text-gray-300">Let  <span class="math">B_l</span>  denote the last honest block to the left of  <span class="math">B^*</span>  in  <span class="math">chain_i^t</span>  that is not genesis. We will first pretend that such a block  <span class="math">B_l</span>  exists, and later we will prove that indeed it does. Let  <span class="math">B_r \\in chain_i^t[\\mathsf{index}(B^*):]</span>  be the first honest block to the right of  <span class="math">B^*</span> &mdash; such a block must exist due to chain quality, and that there are at least  <span class="math">\\epsilon^*\\kappa</span>  blocks to the right of  <span class="math">B^*</span> . By chain quality,  <span class="math">\\mathsf{index}(B_r) - \\mathsf{index}(B^*) \\le \\epsilon_0 \\kappa</span>  in  <span class="math">chain_i^t</span> , and  <span class="math">\\mathsf{index}(B^*) - \\mathsf{index}(B_l) \\le \\epsilon_0 \\kappa</span>  in  <span class="math">chain_i^t</span> . Therefore,  <span class="math">\\mathsf{index}(B_r) - \\mathsf{index}(B_l) \\le 2\\epsilon_0 \\kappa</span> . Further, since  <span class="math">B_l</span>  is honest,  <span class="math">T_1 := B_l</span> .time is the time when an honest node first mines  <span class="math">B_l</span> . Similarly,  <span class="math">T_2 := B_r</span> .time is the time when an honest node first mines  <span class="math">B_r</span> . By chain growth,  <span class="math">T_2 - T_1 \\le \\frac{2\\epsilon_0 \\kappa}{g_0}</span> . By definition, we also know that  <span class="math">T_1 \\le B^*</span> .time  <span class="math">\\le T_2</span> , and therefore  <span class="math">B^*</span> .time  <span class="math">-T_1 \\le \\frac{2\\epsilon_0 \\kappa}{g_0}</span> , i.e.,  <span class="math">T_1 \\ge B^*</span> .time  <span class="math">-\\frac{2\\epsilon_0 \\kappa}{g_0} &gt; T - \\omega - \\frac{2\\epsilon_0 \\kappa}{g_0}</span> .</p>

    <p class="text-gray-300">For the above bound on  <span class="math">T_1</span>  to hold, it remains to show that such a  <span class="math">B_l</span>  exists. To show this, we prove that there is a constant  <span class="math">\\epsilon&#x27;&gt;0</span>  such that  <span class="math">\\operatorname{index}(B^*)</span>  (w.r.t.  <span class="math">\\operatorname{chain}_i^t</span> ) is greater than  <span class="math">\\epsilon&#x27;\\kappa</span> , since then  <span class="math">B_l</span>  must exist by chain quality. Suppose for the sake of contradiction that  <span class="math">\\operatorname{index}(B^*)&lt;\\epsilon&#x27;\\kappa</span> . As before, let  <span class="math">B_r</span>  be the first honest block to the right of  <span class="math">B^*</span>  in  <span class="math">\\operatorname{chain}_i^t</span> . Such a  <span class="math">B_r</span>  must exist within at most  <span class="math">\\epsilon_0\\kappa</span>  blocks from  <span class="math">B^*</span> . Therefore  <span class="math">\\operatorname{index}(B_r)&lt;(\\epsilon&#x27;+\\epsilon_0)\\kappa</span> . Since  <span class="math">B_r</span>  is an honest block,  <span class="math">B_r</span> .time denotes the time  <span class="math">B_r</span>  was first mined by an honest node. By chain growth,  <span class="math">B_r</span> .time  <span class="math">\\leq \\frac{(\\epsilon&#x27;+\\epsilon_0)\\kappa}{g_0}</span> . Since  <span class="math">T\\geq T_{\\mathrm{epoch}}\\geq 3\\omega\\geq \\frac{3\\kappa}{g_0}</span> , it holds that for sufficiently small constants  <span class="math">\\epsilon&#x27;,\\epsilon_0&gt;0</span> ,</p>

    <p class="text-gray-300"><span class="math">$B^*</span>$
.time  <span class="math">\\leq B_r</span> .time  <span class="math">\\leq \\frac{(\\epsilon&#x27; + \\epsilon_0)\\kappa}{g_0} \\leq T - \\omega</span></p>

    <p class="text-gray-300">Therefore we reach a contradiction.</p>

    <p class="text-gray-300">&bull; Let  <span class="math">T_0</span>  be the time in view that  <span class="math">\\mathcal{S}</span>  called  <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}.\\mathtt{setpids}(e, \\_)</span> . We now show that  <span class="math">T_0 \\leq T - 1.5\\omega</span> . It is not hard to see that  <span class="math">\\mathcal{S}</span>  will definitely have called  <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}.\\mathtt{setpids}(e, \\_)</span>  by time t, if there is a node i honest at t-1, such that  <span class="math">chain_i^{t-1}[:-\\epsilon^*\\kappa]</span>  contains a block whose timestamp is greater than  <span class="math">T-2\\omega</span>  where  <span class="math">T=\\mathtt{start}(e)</span> .</p>

    <p class="text-gray-300">By Claim 4, let  <span class="math">r = T - 1.5\\omega \\ge 1.5\\omega</span> , for every node i honest at r - 1,  <span class="math">chain_i^{r-1}[:-\\epsilon^*\\kappa]</span>  must contain a block whose timestamp is greater than  <span class="math">r - \\frac{\\omega}{2} = T - 2\\omega</span>  &mdash; notice that this relies on our choice of  <span class="math">\\epsilon^*</span>  being sufficiently small. This suffices for showing that  <span class="math">T_0 \\le T - 1.5\\omega</span> .</p>

    <p class="text-gray-300">Given our extractnonce definition, it suffices to prove that  <span class="math">T_1 &gt; T_0</span> . Recall that  <span class="math">T_1</span>  is the time the honest block  <span class="math">B_l</span>  is mined, and the block  <span class="math">B_l</span>  contains a random string that is unpredictable any time before  <span class="math">T_1</span> . We now show that indeed  <span class="math">T_1 &gt; T_0</span> . Observe that since  <span class="math">T \\ge T_{\\rm epoch}</span>  and  <span class="math">T_{\\rm epoch} \\ge 3\\omega</span> , and that for small enough  <span class="math">\\epsilon_0</span> ,  <span class="math">\\frac{2\\epsilon_0\\kappa}{g_0} &lt; 0.5\\omega</span> , it clearly holds that  <span class="math">T_1 &gt; T_0</span> .</p>

    <p class="text-gray-300"><strong>Lemma 6</strong> (Simulator respects  <span class="math">\\Delta</span> -network delivery). For any compliant p.p.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  pair, there exists a negligible function negl such that for every  <span class="math">\\kappa</span></p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi_{\\mathrm{hyb}}}(\\mathcal{S}^{\\mathcal{A}}, \\mathcal{Z}, \\kappa) : \\mathsf{view} \\text{ aborts due to } \\Delta\\text{-failure}\\right] \\leq \\mathsf{negl}(\\kappa)$$</p>

    <p class="text-gray-300"><em>Proof.</em> Fix some view  <span class="math">\\leftarrow \\mathsf{EXEC}^{\\Pi_{\\mathsf{hyb}}}(\\mathcal{S}^{\\mathcal{A}}, \\mathcal{Z}, \\kappa)</span>  where none of the bad events related to chain growth, chain quality, and consistency happen. Suppose that a node i alert at t sends a  <span class="math">chain_i^t</span>  at time t in view. Due to the  <span class="math">\\Pi_{\\mathsf{snowwhite}}</span> -compliance of  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , for every node that is alert at  <span class="math">t + \\Delta</span> ,  <span class="math">\\mathcal{A}</span>  will ask  <span class="math">\\mathcal{S}</span>  to deliver  <span class="math">chain_i^t</span>  to node j at some  <span class="math">t_j \\in [t, t + \\Delta]</span> .</p>

    <p class="text-gray-300">Clearly,  <span class="math">chain_i^t \\in \\mathcal{F}_{\\text{punctual}}</span>  starting at time t in view. Due to consistency, for any node j that is alert at sometime  <span class="math">s \\in [t, t + \\Delta]</span> , including ones that might have just waken up from a light sleep, it must hold that  <span class="math">chain_j^s[: -\\kappa_0] \\prec chain_i^t</span> . Therefore, j's real-world checks will not cause j to reject  <span class="math">chain_i^t</span>  had j received  <span class="math">chain_i^t</span>  at any  <span class="math">s \\in [t, t + \\Delta]</span> . As a result,  <span class="math">\\mathcal{S}</span>  will not drop this message  <span class="math">chain_i^t</span> .</p>

    <p class="text-gray-300"><strong>Lemma 7</strong> (Compliant corruptions). For any compliant p.p.t. (A, Z) pair, there exists a negligible function negl such that for every  <span class="math">\\kappa</span></p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi_{\\mathrm{hyb}}}(\\mathcal{S}^{\\mathcal{A}}, \\mathcal{Z}, \\kappa) : \\mathsf{view} \\text{ aborts due to corruption-failure}\\right] \\leq \\mathsf{negl}(\\kappa)$$</p>

    <p class="text-gray-300"><em>Proof.</em> Suppose that  <span class="math">\\mathcal{A}</span>  issues (corrupt, i, t') at some time t. Since  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is  <span class="math">\\Pi_{\\text{snowwhite}}</span> -compliant, it must hold that  <span class="math">t&#x27; - t &gt; \\tau</span> . We now show that by time t,  <span class="math">\\mathcal{S}</span>  cannot have called  <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span> .setpids for any time during  <span class="math">[t&#x27; - W, \\infty]</span> .</p>

    <p class="text-gray-300">Notice that the only way  <span class="math">\\mathcal S</span>  could have called  <span class="math">\\widetilde{\\mathcal F}_{\\mathrm{punctual}}.\\mathtt{setpids}(s,\\_)</span>  by time t is if there is a node i honest at t such that  <span class="math">chain_i^t[:-\\epsilon^*\\kappa]</span>  contains a block B such that  <span class="math">B.\\mathsf{time} &gt; \\mathsf{rnddown}(s) - 2\\omega &gt; s - T_{\\mathrm{epoch}} - 2\\omega</span> . This means that  <span class="math">\\mathcal S</span>  can only have called  <span class="math">\\widetilde{\\mathcal F}_{\\mathrm{punctual}}.\\mathtt{setpids}(s,\\_)</span>  by time t if  <span class="math">t \\geq s - T_{\\mathrm{epoch}} - 2\\omega</span> . If  <span class="math">s \\geq t&#x27; - W</span> , this means that  <span class="math">t \\geq t&#x27; - W - T_{\\mathrm{epoch}} - 2\\omega</span> . However, we also know that  <span class="math">t &lt; t&#x27; - \\tau</span> . Since  <span class="math">\\tau &gt; W + T_{\\mathrm{epoch}} + 2\\omega</span> , it cannot be the case that  <span class="math">t \\geq t&#x27; - W - T_{\\mathrm{epoch}} - 2\\omega</span> ; and therefore  <span class="math">\\mathcal S</span>  cannot have called  <span class="math">\\widetilde{\\mathcal F}_{\\mathrm{punctual}}.\\mathtt{setpids}(s,\\_)</span>  for any time  <span class="math">s \\in [t&#x27; - W, \\infty]</span> .</p>

    <p class="text-gray-300">Similarly, suppose that  <span class="math">\\mathcal{A}</span>  issues (sleep, i,t') at some time t. Since  <span class="math">(\\mathcal{A},\\mathcal{Z})</span>  is  <span class="math">\\Pi_{\\text{snowwhite-compliant}}</span> , it must hold that  <span class="math">t&#x27;-t&gt;\\tau</span> . we can similarly show that  <span class="math">\\mathcal{S}</span>  cannot have called  <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span> .setpids for any time during  <span class="math">[t&#x27;,\\infty]</span> .</p>

    <p class="text-gray-300"><strong>Lemma 8</strong> (Parameter preservation). For any compliant p.p.t. (A, Z) pair, there exists a negligible function negl such that for every  <span class="math">\\kappa</span></p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi_{\\mathrm{hyb}}}(\\mathcal{S}^{\\mathcal{A}}, \\mathcal{Z}, \\kappa) : \\mathsf{view} \\text{ aborts due to param-failure}\\right] \\leq \\mathsf{negl}(\\kappa)$$</p>

    <p class="text-gray-300"><em>Proof.</em> Straightforward to verify.</p>

    <p class="text-gray-300">In this section, we show that for any chain that would have been accepted by an honest node by the real-world verification algorithm, S must succeed in adding it to  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span>  if the chain does not exist in  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span>  already.</p>

    <p class="text-gray-300"><strong>Lemma 9</strong> (Unforgeability of signatures). For any compliant p.p.t. (A, Z) pair, there exists a negligible function negl such that for every  <span class="math">\\kappa</span></p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view}\\leftarrow_{\\</span>}\\mathsf{EXEC}^{\\Pi_{\\mathrm{hyb}}}(\\mathcal{S}^{\\mathcal{A}},\\mathcal{Z},\\kappa):\\mathsf{view}\\ \\mathrm{aborts}\\ \\mathrm{due}\\ \\mathrm{to}\\ \\mathsf{signature-failure}\\right]\\leq \\mathsf{negl}(\\kappa)$$</p>

    <p class="text-gray-300">Proof. Straightforward reduction to the security of the signature scheme. Conditioned on no hash collision, if there is ever signature-failure, the adversary  <span class="math">\\mathcal{A}</span>  must have forged a signature on a new message that the simulator  <span class="math">\\mathcal{S}</span>  has not sent  <span class="math">\\mathcal{A}</span> . We can easily leverage such an adversary  <span class="math">\\mathcal{A}</span>  to build a reduction to break signature security. More specifically, the reduction will simulate  <span class="math">\\mathcal{G}_{\\text{sign}}</span> , honest parties, and  <span class="math">\\mathcal{S}</span>  and interact with  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> . The reduction will guess at random which honest party's which signature key the adversary will break, and embed the instance from the signature challenger there. Note also that  <span class="math">\\mathcal{G}_{\\text{sign}}</span>  is a global functionality, however, the environment  <span class="math">\\mathcal{Z}</span>  cannot query  <span class="math">\\mathcal{G}_{\\text{sign}}</span>  for signatures pertaining to the challenge session identifier &mdash; this is important for the reduction to work.</p>

    <p class="text-gray-300">Simulation valid chains. Given a view of the simulated execution, we say that a <em>chain</em> is <em>simulation valid</em> w.r.t. time t in view if it is valid as defined in the real-world protocol, but where the hash function H is replaced by hash queries to the simulator S. The simulator S answers these hash queries in the same way it answers A's hash queries.</p>

    <p class="text-gray-300">Sufficiently long honest prefix. Given a view of the simulated execution, we say that a simulation valid chain (w.r.t. t) has a sufficiently long honest prefix at time t in view, iff</p>

    <p class="text-gray-300">There exists a prefix  <span class="math">chain_0 \\prec chain</span>  such that  <span class="math">chain_0[-1]</span> .time  <span class="math">&gt; t - \\omega</span> , and moreover, there exists  <span class="math">s \\leq t</span>  and a node i alert at time s, such that  <span class="math">chain_0 \\prec chain_i^s[:-\\epsilon^*\\kappa]</span> .</p>

    <p class="text-gray-300">Claim 5. Let <em>chain</em> be simulation valid in view at time t, and suppose that <em>chain</em> has a sufficiently long honest prefix at t. It holds that the following two ways for determining whether a public key pk is a leader in any time  <span class="math">r \\leq t</span>  are equivalent in the simulated execution:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Using the real-world eligible (chain, pk) function where H is implemented by S; and</li>
    </ol></li>
      <li>2. Calling  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span> .leader(nonce<sup>r</sup>,  <span class="math">\\mathcal{P}, r</span> ) where nonce<sup>r</sup> denotes the nonce previously chosen by  <span class="math">\\mathcal{S}</span>  for time step r, and  <span class="math">\\mathcal{P}</span>  is the party identifier corresponding to pk (as determined by  <span class="math">\\mathcal{S}</span> 's stored mapping) &mdash; if no such mapping is found, then  <span class="math">\\mathcal{P}</span>  is simply  <span class="math">\\bot</span> .</li>
    </ul>

    <p class="text-gray-300"><em>Proof.</em> Recall that if the simulation does not abort, there is no duplicate-key-failure. If  <span class="math">r &lt; T_{\\rm epoch}</span> , pks<sub>0</sub> will be selected as the committee by the real-world algorithm, and recall that  <span class="math">\\mathcal{S}</span>  has registered with  <span class="math">\\widetilde{\\mathcal{F}}_{\\rm punctual}</span>  the party identifiers for pks<sub>0</sub> as the initial committee.</p>

    <p class="text-gray-300">The more interesting case is when  <span class="math">r \\geq T_{\\text{epoch}} \\geq 3\\omega</span> . In this case, since  <span class="math">chain_0[-1]</span> .time  <span class="math">&gt; t - \\omega</span> , the prefix that determines the committee or hash for any  <span class="math">r \\leq t</span>  must be contained in  <span class="math">chain_0</span> . Due to consistency and the definition of  <span class="math">\\mathcal{S}</span> , it holds that the committee for any  <span class="math">r \\leq t</span>  determined by the</p>

    <p class="text-gray-300">real-world algorithm based on <em>chain</em> must agree with what  <span class="math">\\mathcal{S}</span>  committed to  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span> . Similarly,  <span class="math">\\mathcal{S}</span>  must have committed to  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span>  the same nonce for each  <span class="math">r \\leq t</span>  as what the real-world algorithm would output as the nonce for each  <span class="math">r \\leq t</span>  based on <em>chain</em>.</p>

    <p class="text-gray-300">Further, due to no predict-failure, consistency, and the way  <span class="math">\\mathcal{S}</span>  answers H queries, it holds that using H to elect leaders agrees with the random coins used by  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span>  for electing leaders.</p>

    <p class="text-gray-300">Claim 6. Let  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  be  <span class="math">\\Pi_{\\text{snowwhite}}</span> -compliant. Given any view of  <span class="math">\\mathsf{EXEC}^{\\Pi_{\\text{hyb}}}(\\mathcal{S}^{\\mathcal{A}}, \\mathcal{Z}, \\kappa)</span> , let <em>chain</em> be a simulation valid chain w.r.t. time t in view, and suppose that <em>chain</em> has a sufficiently long honest prefix at t in view. Then if  <span class="math">\\mathcal{S}^{\\mathcal{A}}</span>  calls  <span class="math">\\mathsf{AddtoTree}(\\mathit{chain})</span>  at time t in view, the call must succeed.</p>

    <p class="text-gray-300"><em>Proof.</em> First, since  <span class="math">chain_0[-1]</span> .time  <span class="math">&gt; t-\\omega</span> , and  <span class="math">W&gt;\\omega</span> , and since timestamps must strictly increase for a simulation valid chain, it is clear that none of the adversarial blocks at the end will be rejected by  <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}</span>  due to staleness. The rest of proof follows in a straightforward manner due to Claim 5 and no signature-failure.</p>

    <p class="text-gray-300">Claim 7. In the simulated execution, if S sends a <em>chain</em> to an alert node, then <em>chain</em> must be simulation valid at t and have a sufficiently long prefix at t.</p>

    <p class="text-gray-300"><em>Proof.</em> We now prove the above lemma. Recall that S simulates the real-world verification algorithm for node i, and only forwards a <em>chain</em> to alert node i if the real-world checks succeed. It suffices to prove that if the real-world checks pass, then the chain has a sufficiently long prefix.</p>

    <p class="text-gray-300">There are three possible scenarios, and we analyze them one by one.</p>

    <p class="text-gray-300">Case 1: A sends chain to a node i that has been alert. This case is very similar to Case 2, except that the  <span class="math">\\widetilde{\\Delta}</span>  in Case 2 is now replaced with  <span class="math">\\Delta</span> . By our parameter admissible rules, it is not hard to see that  <span class="math">\\Delta \\leq \\frac{1}{2\\gamma}</span> . The rest of the proof follows in the same way as Case 2.</p>

    <p class="text-gray-300">Case 2:  <span class="math">\\mathcal{A}</span>  sends chain to node i that has just waken up after a light sleep. Suppose that at time t,  <span class="math">\\mathcal{A}</span>  wants to send chain to honest node i who has waken up at time t after a short sleep, and let s denote the most recent time node i went to sleep before t. By  <span class="math">\\Pi_{\\text{snowwhite}}</span> -compliance, we know that  <span class="math">t-s \\leq \\widetilde{\\Delta}</span> .</p>

    <p class="text-gray-300">We know that it must be the case  <span class="math">chain_i^s[:-\\kappa_0] \\prec chain</span>  for chain to be accepted by node i's real-world checks. Also observe that by Claim 4,  <span class="math">chain_i^s[-\\kappa_0]</span> .time  <span class="math">&gt; s - \\frac{\\kappa}{g_0} \\ge t - \\widetilde{\\Delta} - \\frac{\\kappa}{g_0} \\ge t - \\omega</span> .</p>

    <p class="text-gray-300">Case 3:  <span class="math">\\mathcal{A}</span>  sends a newly spawned node i an initialization message. Fix any view of non-zero support in the execution  <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathsf{hyb}}}(\\mathcal{S}^A, \\mathcal{Z}, \\kappa)</span> . All of the following statements are with respect to this view. Given a set  <span class="math">S_L := \\{chain_i\\}_{i \\in L}</span> , we say that a <em>chain</em> is real-world admissible w.r.t.  <span class="math">S_L</span>  if 1) <em>chain</em> is simulation valid; 2)  <span class="math">chain \\prec chain_i</span>  for some  <span class="math">i \\in L</span> ; and 3) let chain' be the longest common prefix of any majority subset of S, it holds that  <span class="math">chain&#x27; \\prec chain</span> .</p>

    <p class="text-gray-300">Suppose L is a node set the majority of whom are alert at time t. Suppose that chain is real-world admissible w.r.t.  <span class="math">S_L</span> . Now we take the set of honest nodes in L and compute the longest prefix of their chains; and  <span class="math">chain_h</span>  denote this longest prefix. Suppose the aforementioned chain' is computed by taking a subset  <span class="math">S&#x27; \\subseteq S_L</span>  that comprise majority. Since the majority are alert at time t in L, one alert node must exist in S'. Clearly chain' should be at least as long as  <span class="math">chain_h</span> . Therefore we conclude that  <span class="math">chain_h \\prec chain&#x27;</span> .</p>

    <p class="text-gray-300">It suffices to argue that  <span class="math">chain_h[-\\epsilon^*\\kappa]</span> .time  <span class="math">&gt; t - \\omega</span> . Let  <span class="math">i \\in L</span>  be a node alert at time t, we know that  <span class="math">chain_h \\prec chain_i^t</span> . Due to consistency, there cannot be more than  <span class="math">\\epsilon_1 \\kappa</span>  blocks after  <span class="math">chain_h</span>  in  <span class="math">chain_i^t</span> . Now the fact that  <span class="math">chain_h[-\\epsilon^*\\kappa]</span> .time  <span class="math">&gt; t - \\omega</span>  follows from Claim 4.</p>

    <p class="text-gray-300"><strong>Lemma 10</strong> (Success of AddtoTree). For any compliant p.p.t. (A, Z) pair, there exists a negligible function negl such that for every  <span class="math">\\kappa</span></p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi_{\\mathrm{hyb}}}(\\mathcal{S}^{\\mathcal{A}}, \\mathcal{Z}, \\kappa) : \\mathsf{view} \\ \\mathrm{aborts} \\ \\mathrm{due} \\ \\mathrm{to} \\ \\mathsf{extend-failure}\\right] \\leq \\mathsf{negl}(\\kappa)$</p>

    <p class="text-gray-300"><em>Proof.</em> Straightforward by Claim 6, Claim 7, and the definition of  <span class="math">\\mathcal{S}</span> .</p>

      <h3 id="app-h.5" class="text-xl font-semibold mt-8">H.5 Indistinguishability of the Real-World and Simulated Executions</h3>

    <p class="text-gray-300"><strong>Lemma 11</strong> (Indistinguishability of the real-world and simulated executions). For any  <span class="math">\\Pi_{\\text{snowwhite}}</span> -compliant p.p.t. pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , conditioned on the simulated execution not aborting, then  <span class="math">\\mathcal{Z}</span> 's view in the simulated execution and real execution are identically distributed.</p>

    <p class="text-gray-300"><em>Proof.</em> We now prove this lemma.</p>

    <p class="text-gray-300"><strong>Hybrid 1.</strong> Same as the simulated execution, but with the following modification: when the an honest node needs to call the ideal-world  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}.extend(chain, B)</span> , a real-world algorithm is adopted for extending the chain: the honest node calls  <span class="math">eligible^t(chain, pk)</span>  where H is implemented by  <span class="math">\\mathcal{S}</span> . If the outcome is 1, add chain||B| to  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}.tree</span> .</p>

    <p class="text-gray-300">Claim 8. No p.p.t. Z can distinguish the simulated execution and Hybrid 1 except with negligible probability.</p>

    <p class="text-gray-300"><em>Proof.</em> It suffices to show that if an alert node tries to extend a <em>chain</em> at time t, then <em>chain</em> is simulation valid and has a sufficiently long prefix at t. If this is true, then by Claim 5, using the real-world algorithm to decide whether a node is leader is equivalent to what  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span>  thinks. Therefore, using the real-world algorithm to extend the chain rather than calling  <span class="math">\\widetilde{\\mathcal{F}}_{punctual}</span> .extend would be equivalent. Given Claim 7 and the definition of the simulated execution, it is not hard to see that every <em>chain</em> an alert node tries to extend is simulation valid and has a sufficiently long prefix.</p>

    <p class="text-gray-300"><strong>Hybrid 2.</strong> Same as Hybrid 1, but with the following modification: whenever an honest node receives a chain' whose length is longer than its own chain, do real-world checks instead of calling  <span class="math">\\widetilde{\\mathcal{F}}_{\\text{punctual}}.\\text{verify}</span> .</p>

    <p class="text-gray-300">Claim 9. No p.p.t.  <span class="math">\\mathcal{Z}</span>  can distinguish Hybrid 1 and Hybrid 2 except with negligible probability.</p>

    <p class="text-gray-300"><em>Proof.</em> Notice that S always performs real-world checks on behalf of an alert node i before forwarding any <em>chain</em> to an alert node i. Therefore, it is easy to see that the claim is true given that we have proved Lemma 10.</p>

    <p class="text-gray-300">Finally, to prove Lemma 11, it suffices to observe that Hybrid 2 is equivalent to the real-world execution by a standard argument of redrawing algorithm boundaries.  <span class="math">\\Box</span></p>

    </section>

    <section id="app-i" class="mb-10">
      <h2 class="text-2xl font-bold">I Additional Related Work</h2>

    <p class="text-gray-300">We briefly review the rich body of literature on consensus protocols including permissioned and permissionless consensus. Part of this section borrows from an earlier work [48].</p>

    <p class="text-gray-300">Models for permissioned consensus protocols. Consensus in the permissioned setting [5,8,11, 12,16,21,22,25&ndash;27,31,32,37&ndash;41,52] has been actively studied for the past three decades; and we can roughly classify these protocols based on their network synchrony, their cryptographic assumptions, and various other dimensions.</p>

    <p class="text-gray-300">Roughly speaking, two types of network models are typically considered, the <em>synchronous</em> model, where messages sent by honest nodes are guaranteed to be delivered to all other honest nodes in the next round; and <em>partially synchronous</em> or <em>asynchronous</em> protocols where message delays may be unbounded, and the protocol must nonetheless achieve consistency and liveness despite not knowing any a-priori upper bound on the networks' delay. In terms of cryptographic assumptions, two main models have been of interest, the &quot;<em>unauthenticated Byzantine</em>&quot; model [40] where nodes are interconnected with authenticated channels<sup>6</sup>; and the &quot;<em>authenticated Byzantine</em>&quot; model [21], where a public-key infrastructure exists, such that nodes can sign messages and such digital signatures can then be transferred.</p>

    <p class="text-gray-300"><strong>Permissioned, synchronous protocols.</strong> Many feasibility and infeasibility results have been shown. Notably, Lamport et al. [40] show that it is impossible to achieve secure consensus in the presence of a  <span class="math">\\frac{1}{3}</span>  coalition in the &quot;unauthenticated Byzantine&quot; model (even when assuming synchrony). However, as Dolev and Strong show [21], in a synchronous, authenticated Byzantine model, it is possible to design protocols that tolerate an arbitrary number of corruptions. It is also understood that no deterministic protocol fewer than f rounds can tolerate f faulty nodes [21] &mdash; however, if randomness is allowed, existing works have demonstrated expected constant round protocols that can tolerate up to a half corruptions [25,32].</p>

    <p class="text-gray-300">Permissioned, asynchronous protocols. A well-known lower bound by Fischer, Lynch, and Paterson [26] shows if we restrict ourselves to protocols that are deterministic and where nodes do not read clocks, then consensus would be impossible even when only a single node may be corrupt. Known feasibility results typically circumvent this well-known lower bound by making two types of assumptions: 1) randomness assumptions, where randomness may come from various sources, e.g., a common coin in the sky [12,27,43], nodes' local randomness [5,52], or randomness in network delivery [11]; and 2) clocks and timeouts, where nodes are allowed to read a clock and make actions based on the clock's value. This approach has been taken by well-known protocols such as PBFT [16] and FaB [41] that use timeouts to re-elect leaders and thus ensure liveness even when the previous leader may be corrupt.</p>

    <p class="text-gray-300">Another well-known lower bound in the partially synchronous or asynchronous setting is due to Dwork et al. [22], who showed that no protocol (even when allowing randomness or clocks) can achieve security in the presence of a  <span class="math">\\frac{1}{3}</span>  corrupt coalition.</p>

    <p class="text-gray-300"><strong>Permissionless consensus.</strong> The permissionless model did not receive sufficient academic attention, perhaps partly due to the existence of strong lower bounds such as what Canetti et al. showed [3]. Roughly speaking, we understand that without making additional trust assumptions, not many interesting tasks can be achieved in the permissionless model where authenticated chan-</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^6&lt;/sup&gt;</span> This terminology clash stems from different terminology adopted by the distributed systems and cryptography communities.</p>

    <p class="text-gray-300">nels do not exist between nodes.</p>

    <p class="text-gray-300">Amazingly, cryptocurrencies such as Bitcoin and Ethereum have popularized the permissionless setting, and have demonstrated to us, that perhaps contrary to the common belief, highly interesting and non-trivial tasks can be attained in the permissionless setting. Underlying these cryptocurrency systems is a fundamentally new type of consensus protocols commonly referred to as proof-of-work blockchains [44]. Upon closer examination, these protocols circumvent known lower bounds such as those by Canetti et al. [3] and Lamport et al. [40] since they rely on a new trust assumption, namely, proofs-of-work, that was not considered in traditional models.</p>

    <p class="text-gray-300">Formal understanding of the permissionless model has just begun [28,45&ndash;47]. Notably, Garay et al. [28] formally analyze the Nakamoto blockchain protocol in synchronous networks. Pass et al. [45] extend their analysis to asynchronous networks. More recently, Pass and Shi [47] show how to perform committee election using permissionless consensus and then bootstrap instances of permissioned consensus &mdash; in this way, they show how to asymptotically improve the response time for permissionless consensus.</p>

    <p class="text-gray-300">Finally, existing blockchains are known to suffer from a selfish mining attack [24], where a coalition wielding  <span class="math">\\frac{1}{3}</span>  of the computation power can reap up to a half of the rewards. Pass and Shi [46] recently show how to design a fair blockchain (called Fruitchains) from any blockchain protocol with positive chain quality. Since our Snow White consensus protocol is a blockchain-style protocol, we also inherit the same selfish mining attack. Fortunately, Snow White can leverage the same techniques as Pass and Shi [46] to achieve incentive compatibility (see Section 3).</p>

    <p class="text-gray-300">Dynamic reconfiguration for consensus protocols. Dynamic reconfiguration has been studied in the classical setting for permissioned consensus. For example, Vertical Paxos [39] and BFT-SMART [8] allow nodes to be reconfigured in a dynamic fashion. The more recent Hybrid Consensus protocol by Pass and Shi [47] also performs committee reconfiguration over time, however, their protocol requires that in some transient windows, multiple instances of the permissioned consensus protocol are run concurrently.</p>

    <p class="text-gray-300">In this paper, we also consider dynamic reconfiguration, but we consider it for blockchain-style protocols and rely on new techniques. One compelling advantage of our approach is that group reconfiguration is seamless in our protocol and does not need to introduce special execution paths. We also do not need to invoke multiple concurrent consensus instances.</p>

    </section>
`;
---

<BaseLayout title="Snow White: Robustly Reconfigurable Consensus and Applicatio... (2016/919)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/919
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">Robustly Reconfigurable Consensus</a></li>
            <li><a href="#sec-1.2" class="hover:text-white">From Robustly Reconfigurable Consensus to Proof-of-Stake</a></li>
            <li><a href="#sec-1.3" class="hover:text-white">Chronological Notes, Closely Related, and Subsequent Works</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-2" class="hover:text-white">Snow White&#x27;s Core Consensus Protocol</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Background: Sleepy Consensus and Sleepy Execution Model</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Handling Committee Reconfiguration</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">Handling Mildly Adaptive and Posterior Corruptions</a></li>
            <li><a href="#sec-2.4" class="hover:text-white">Late Joining in the Presence of Posterior Corruption</a></li>
            <li><a href="#sec-2.5" class="hover:text-white">Putting it Altogether: Informal Overview of Snow White</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">From Robustly Reconfigurable Consensus to PoS</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">Base Security on Distribution of Stake</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Fair Reward Scheme</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">Thwarting Nothing-at-Stake Attacks</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">Simulation and Concrete Parameters</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Simulation Methodology</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">Simulation Results</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">Implementation and Evaluation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">Design</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">Evaluation</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a" class="hover:text-white">Definitions</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-a.1" class="hover:text-white">Protocol Execution Model</a></li>
            <li><a href="#app-a.2" class="hover:text-white">Notational Conventions</a></li>
          </ol>
        </li>
        <li>
          <a href="#app-b" class="hover:text-white">Preliminaries: Blockchain Formal Abstraction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-b.1" class="hover:text-white">Chain Growth</a></li>
            <li><a href="#app-b.2" class="hover:text-white">Chain Quality</a></li>
            <li><a href="#app-b.3" class="hover:text-white">Consistency</a></li>
          </ol>
        </li>
        <li>
          <a href="#app-c" class="hover:text-white">The Snow White Protocol</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-c.1" class="hover:text-white">Modeling Digital Signatures</a></li>
            <li><a href="#app-c.2" class="hover:text-white">Format of Real-World Blocks</a></li>
            <li><a href="#app-c.3" class="hover:text-white">Epoch-Based Committee Election</a></li>
            <li><a href="#app-c.4" class="hover:text-white">Protocol Overview</a></li>
            <li><a href="#app-c.5" class="hover:text-white">Theorem Statement</a></li>
            <li><a href="#app-c.6" class="hover:text-white">Compliant Execution</a></li>
          </ol>
        </li>
        <li><a href="#app-d" class="hover:text-white">Lower Bounds</a></li>
        <li><a href="#app-e" class="hover:text-white">Proof Roadmap</a></li>
        <li>
          <a href="#app-f" class="hover:text-white">Proofs: Analyzing A Simplified Ideal Protocol</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-f.1" class="hover:text-white">Simplified Ideal Protocol \Pi_&#123;ideal&#125;</a></li>
          </ol>
        </li>
        <li>
          <a href="#app-g" class="hover:text-white">Proofs: Intermediate Hybrid Protocols</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-g.1" class="hover:text-white">Ideal Protocol with Adversarially Biased Hashes</a></li>
            <li><a href="#app-g.2" class="hover:text-white">Allowing Posterior Corruption</a></li>
            <li><a href="#app-g.4" class="hover:text-white">Timestamp Freshness Lemma</a></li>
            <li><a href="#app-h.1" class="hover:text-white">Theorem Statement</a></li>
            <li><a href="#app-h.2" class="hover:text-white">Simulator Construction</a></li>
            <li><a href="#app-h.3" class="hover:text-white">Consistency and Compliance of the Simulated Execution</a></li>
            <li><a href="#app-h.4" class="hover:text-white">All Real-World Valid Chains are in \widetilde&#123;\mathcal&#123;F&#125;&#125;_&#123;\text&#123;punctual&#125;&#125;</a></li>
            <li><a href="#app-h.5" class="hover:text-white">Indistinguishability of the Real-World and Simulated Executions</a></li>
          </ol>
        </li>
        <li><a href="#app-i" class="hover:text-white">Additional Related Work</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#acknowledgements" class="hover:text-white">Acknowledgements</a></li>
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="snow-white-robustly-reconfigurable-consensus-and-2016" />
  </article>
</BaseLayout>
