---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2005/252';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Faster Pairings using an Elliptic Curve with an Efficient Endomorphism';
const AUTHORS_HTML = 'Michael Scott';

const CONTENT = `    <p class="text-gray-300">Michael Scott</p>

    <p class="text-gray-300">School of Computing Dublin City University Ballymun, Dublin 9, Ireland. mike@computing.dcu.ie</p>

    <p class="text-gray-300">Abstract. The most significant pairing-based cryptographic protocol to be proposed so far is undoubtedly the Identity-Based Encryption (IBE) protocol of Boneh and Franklin. In their paper [6] they give details of how their scheme might be implemented in practise on certain supersingular elliptic curves of prime characteristic. They also point out that the scheme could as easily be implemented on certain special non-supersingular curves for the same level of security. An obvious question to be answered is – which is most efficient? Motivated by the work of Gallant, Lambert and Vanstone [12] we demonstrate that, perhaps counter to intuition, certain ordinary curves closely related to the supersingular curves originally recommended by Boneh and Franklin, provide better performance. We illustrate our technique by implementing the fastest pairing algorithm to date (on elliptic curves of prime characteristic) for contemporary levels of security. We also point out that many of the non-supersingular families of curves recently discovered and proposed for use in pairing-based cryptography can also benefit (to an extent) from the same technique.</p>

    <p class="text-gray-300">Keywords: Tate pairing implementation, pairing-based cryptosystems.</p>

    <p class="text-gray-300">If it is to be successful in the long term, pairing-based cryptography needs efficient algorithms for the calculation of the Weil or Tate pairing. In his early text book Menezes [15] mentions an implementation of the Weil pairing which "reported running times of just a few minutes" on a SUN-2 SPARC-station. However this is more than a little unfair – at the time there was no real incentive to try and optimise the standard technique, based on Miller's algorithm [16]. The development of protocols that require fast pairings has produced a series of improvements and tricks which have drastically reduced this running time down to just a few milliseconds.</p>

    <p class="text-gray-300">One target might be that the pairing calculation should take as long as an RSA decryption, for the same level of security, and as pointed out by Scott [18], this target has already almost been reached. However more improvements may be possible, and it is the purpose of this paper to illustrate a new method which</p>

    <p class="text-gray-300">can either produce a further speed-up of up to 20%, or half the amount of storage required, depending on the context in which the pairing is to be calculated.</p>

    <p class="text-gray-300">The development of fast pairings has advanced on two fronts. The first has concentrated on optimising algorithms for the Tate pairing on elliptic curves of prime characteristic, both supersingular and ordinary. The second has focused on algorithms for supersingular curves of small characteristic, typically of characteristic 2 and 3. The former approach is epitomised by the work of Barreto, Kim, Lynn and Scott <em>[2]</em> and Galbraith, Harris and Soldera <em>[11]</em>. For an easy-to-read description of the so-called BKLS-GHS algorithm, with timings, see <em>[18]</em>. While the BKLS-GHS algorithm is also suitable for use over small characteristic curves, the work of Duursma and Lee <em>[10]</em> made it clear that a more efficient algorithm was possible in this context. This approach culminated in the work of Barreto, Galbraith, O’hEigeartaigh and Scott <em>[1]</em>, which introduced the primitive <span class="math">\\eta_{T}</span> pairing, and showed how the Tate pairing could be calculated from it using an iterative loop only half the size of that required by Duursma and Lee. They also raise the possibility that pairings over characteristic 2 supersingular hyperelliptic curves may also be competitive.</p>

    <p class="text-gray-300">However comparing the two types of fast pairings is difficult, as it amounts to comparing the difficulty of the discrete logarithm problem in fields of prime characteristic, with that in fields of small characteristic. In our view this comparison has not been adequately experimentally investigated. However the most authoritative comparison that we have found is due to Lenstra <em>[14]</em>. From this, and using the timings from <em>[1]</em>, it would appear that the <span class="math">\\eta_{T}</span> approach may in fact be the fastest. However since there is still some concern that the discrete logarithm problem in fields of low characteristic may be easier than we currently think, in this paper we will concentrate exclusively on the prime characteristic case.</p>

    <p class="text-gray-300">It has been suggested that pairings might be speeded up by using a prime modulus <span class="math">p</span> of low Hamming weight <em>[13]</em>. This idea can be used with both supersingular and non-supersingular curves. However this also raises legitimate concerns about a possible lowering of discrete-logarithm security. We will not consider the use of a prime modulus of low Hamming weight here.</p>

    <p class="text-gray-300">A critical parameter of any pairing implementation is the embedding degree, or “security multiplier”, denoted <span class="math">k</span>. For reasons of efficiency it is usually recommended that <span class="math">k</span> be even <em>[2]</em> . The security multiplier relates the size of the base field over which points on the elliptic curve are manipulated, with the discrete-logarithm security of the pairing. For example on a particular supersingular hyperelliptic curve of characteristic 2, a value of <span class="math">k=12</span> is possible <em>[1]</em>, and so a hyperelliptic curve over the field <span class="math">\\mathbb{F}_{2^{113}}</span> would result in a pairing with the discrete logarithm security of a 12<em>113=1356 bit binary extension field, which by reference to </em>[14]* might be considered to be adequately secure. So a large security multiplier implies that we can work on an elliptic or hyperelliptic curves over a smaller base field, with efficiency advantages. However the advantage of a large security multiplier is perhaps not as great as one might think, as the major part</p>

    <p class="text-gray-300">of the pairing calculation involves manipulations over the extension field (of size 1356 bits in our example), rather than over the smaller base field.</p>

    <p class="text-gray-300">In the case of prime characteristic fields, the use of a security multiplier of <span class="math">k=2</span> has proven to be surprisingly efficient for contemporary levels of security <em>[18]</em>. Note that for supersingular elliptic curves of prime characteristic, <span class="math">k=2</span> is the maximum possible. The issue of how to scale security in pairing based protocols has been considered by both Koblitz and Menezes <em>[13]</em>, and by Scott <em>[19]</em>. The consenus is that the appropriate way to scale security is to increase the security multiplier rather than increase the size of the prime modulus.</p>

    <p class="text-gray-300">Note that by “contemporary levels of security”, we mean a 1024-bit prime extension field size, and a group size of 160-bits. This implies roughly the same security as 1024-bit RSA <em>[19]</em>.</p>

    <p class="text-gray-300">Here we are concerned with the calculation of the Tate pairing, denoted <span class="math">e(P,Q)</span>, which evaluates as an element of order <span class="math">r</span> in <span class="math">\\mathbb{F}_{p^{k}}</span> where <span class="math">P</span> is a point of order <span class="math">r</span> on <span class="math">E(\\mathbb{F}_{p})</span> and <span class="math">Q</span> is a point on <span class="math">E(\\mathbb{F}_{p^{k}})</span>.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 Supersingular Curves</h2>

    <p class="text-gray-300">In their original paper <em>[6]</em>, Boneh and Franklin recommend the use of either of these supersingular curves over <span class="math">\\mathbb{F}_{p}</span></p>

    <p class="text-gray-300"><span class="math">y^{2}=x^{3}+Ax\\text{, where }p\\equiv 3\\text{ mod }4</span> (1) <span class="math">y^{2}=x^{3}+B\\text{, where }p\\equiv 2\\text{ mod }3</span> (2)</p>

    <p class="text-gray-300">On supersingular curves the modified pairing is calculated as <span class="math">\\hat{e}(P,Q)=e(P,\\psi(Q))</span>, where <span class="math">e(P,Q)</span> denotes the Tate pairing, and <span class="math">\\psi(.)</span> denotes the distortion map. For the first curve an appropriate distortion map is defined as <span class="math">\\psi_{1}:(x,y)\\rightarrow(-x,\\alpha y)</span> where <span class="math">\\alpha=\\sqrt{-1}</span>, and for second curve the distortion map is <span class="math">\\psi_{2}:(x,y)\\rightarrow(\\beta x,y)</span> where <span class="math">\\beta</span> is a non-trivial cube root of unity. Note that both <span class="math">\\alpha</span> and <span class="math">\\beta</span> are elements of the extension field <span class="math">\\mathbb{F}_{p^{2}}</span>, corresponding to the security multiplier value of <span class="math">k=2</span>.</p>

    <p class="text-gray-300">In the Boneh and Franklin IBE scheme there is a necessity to hash identities to curve points. For the second curve this can be done by hashing the identity string to the <span class="math">y</span> coordinate, and then solving the modular cubic equation for <span class="math">x</span>. Since <span class="math">p\\equiv 2\\text{ mod }3</span>, this will always be possible. For the first curve one could hash the identity to <span class="math">x</span> and test if <span class="math">x^{3}+ax</span> is a quadratic residue. If it is not then negate <span class="math">x</span>. Then solve the modular quadratic for <span class="math">y</span>, and choose one of the two solutions according to some convention. This will always work as <span class="math">p\\equiv 3\\text{ mod }4</span> implies that -1 is a quadratic non-residue.</p>

    <h2 id="sec-4" class="text-2xl font-bold">3 Not Supersingular Curves</h2>

    <p class="text-gray-300">Consider now these non-supersingular curves over <span class="math">\\mathbb{F}_{p}</span></p>

    <p class="text-gray-300"><span class="math">y^{2}=x^{3}+Ax</span>, where <span class="math">p\\equiv 1\\bmod 4</span> (3) <span class="math">y^{2}=x^{3}+B</span>, where <span class="math">p\\equiv 1\\bmod 3</span> (4)</p>

    <p class="text-gray-300">Recall that IBE can equally well be implemented on these curves, using the Tate pairing <span class="math">e(P,Q)</span> directly. Suitable curves can be found with <span class="math">k=2</span>, but of course we are no longer restricted to this value alone – larger values of <span class="math">k</span> are also possible (see below).</p>

    <p class="text-gray-300">Note that all that has been changed is the congruence conditions applying to <span class="math">p</span>. For our convenience here we will describe these curves as the not-supersingular (NSS) curves to distinguish them from the generality of ordinary curves. Under these circumstances what becomes of the distortion maps? Well of course they are no longer distortion maps, as now <span class="math">\\alpha,\\beta\\in F_{p}</span>. However these mappings continue to be useful, as we will see, not as distortion maps, but rather as efficient endomorphisms.</p>

    <p class="text-gray-300">What about hashing identities to curve points on these curves? One interesting feature of <span class="math">k=2</span> curves is that both the curve and its quadratic twist have the same embedding degree of <span class="math">k=2</span>. This arises from the condition <em>[2]</em> that the group order <span class="math">r</span> divides both <span class="math">p+1</span> and <span class="math">p+1-t</span> (the number of points on the curve), where <span class="math">t</span> is the trace of the Frobenius for the particular curve. Therefore it follows that <span class="math">r</span> also divides <span class="math">p+1+t</span>, the number of points on the quadratic twist of the curve, and either curve is a suitable vehicle for IBE.</p>

    <p class="text-gray-300">To be concrete we will from this point on concentrate our attention to the curve of equation (4), although all our results apply equally to the other curve. For simplicity choose <span class="math">p=7\\bmod 12</span>, so that -1 is a quadratic non-residue, and a quadratic twist of the original curve is given by <span class="math">y^{2}=x^{3}-B</span>. Then if an identity is hashed to a value <span class="math">x</span>, if <span class="math">x^{3}+B</span> is not a quadratic residue, then <span class="math">(-x)^{3}-B</span> will be. So the trick is to hash to either the original curve or to the twisted curve, depending on the identity. IBE public parameters for both the curve and its twist must be maintained, but other than that the IBE implementation will proceed smoothly with negligible additional overhead.</p>

    <h2 id="sec-5" class="text-2xl font-bold">4 Curve generation</h2>

    <p class="text-gray-300">While generating suitable parameters for supersingular curves is easy, it is much more challenging to generate suitable non-supersingular curves. However a lot of progress has been made. Just as pairing-based cryptography was getting started, Miyaji, Nakabayashi and Takano <em>[17]</em> described a method for generating non-supersingular curves with embedding degrees of 3, 4 and 6. Barreto, Lynn and Scott <em>[3]</em> were the first to provide simple formulae for generating whole families of curves with useful embedding degrees. Their results were extended by Brezing and Weng <em>[7]</em>, and later by Barreto and Naehrig <em>[4]</em> who came up with formulae which allow the generation of ideal <span class="math">k=12</span> curves with many useful properties.</p>

    <p class="text-gray-300">We will return to these curves later, but for now will just make the observation that the majority of such curves are of the not-supersingular form.</p>

    <p class="text-gray-300">By far the most general method for generating pairing-friendly non-supersingular curves in that due to Cocks and Pinch <em>[5]</em>, and this is the method that we shall use to generate <span class="math">k=2</span> not-supersingular curves suitable as replacements for the standard supersingular curves described above, for use with Boneh and Franklin IBE. Crucially (for us) the Cocks-Pinch algorithm allows a free choice of the group order <span class="math">r</span>. It is well known that a choice of a low Hamming weight <span class="math">r</span> speeds up the Tate pairing calculation <em>[2]</em>, <em>[11]</em>, <em>[18]</em>. Alternatively it suffices if a small multiple of <span class="math">r</span> has a low Hamming weight.</p>

    <p class="text-gray-300">While these methods provide formulae for determining the prime modulus <span class="math">p</span> and the trace of the Frobenius <span class="math">t</span> of the desired curve, they do not generate the curve parameters directly. For this the method of Complex Multiplication must be used <em>[9]</em>. Note that the not-supersingular curves are associated with a CM discriminant of <span class="math">D=-4</span> and <span class="math">D=-3</span> respectively. In these cases determining the curve parameters is particularly simple, as for example demonstrated in <em>[4]</em>.</p>

    <p class="text-gray-300">For our NSS curve (4), the Cocks-Pinch algorithm can be described very simply: Select a suitable <span class="math">r</span> of low Hamming weight (or a small multiple of which has low hamming weight). Calculate <span class="math">v=\\sqrt{-4/3}</span> mod <span class="math">r</span>. Set <span class="math">t=\\omega r</span>. Keep adding <span class="math">r</span> to <span class="math">v</span> until <span class="math">p=(3v^{2}+t^{2})/4</span> is prime. (Choose <span class="math">\\omega</span> so that <span class="math">p</span> is 512 bits). Note that <span class="math">r\\mid p+1-t</span>. Finally use the CM method to find the curve parameter <span class="math">B</span> associated with the curve of order <span class="math">p+1-t</span>. (There are 6 possible group orders generated by the CM method in this case <em>[9]</em>, so care must be taken to choose the right one).</p>

    <h2 id="sec-6" class="text-2xl font-bold">5 Efficient pairings on NSS curves</h2>

    <p class="text-gray-300">In their paper Gallant, Lambert and Vanstone <em>[12]</em> describe an efficient method for point multiplication, that applies to NSS curves, and indeed this paper is the main source of inspiration for the current work, although we exploit the endomorphism in a completely different way. Another motivation comes from consideration of the <span class="math">\\eta_{T}</span> pairing as described in <em>[1]</em>.</p>

    <p class="text-gray-300">In the course of calculating the Tate pairing <span class="math">e(P,Q)</span> the first parameter, the point <span class="math">P</span>, is multiplied by its order. Of course this results in the point-at-infinity. In the course of this process the intermediate values of this point, as it typically follows a simple double-and-add trajectory to its pre-ordained destination, along with the second parameter <span class="math">Q</span>, are used to accumulate the pairing value. In some contexts the value of <span class="math">P</span> may be fixed and known in advance (for example it may be a public parameter, or a private key). In this case these intermediate values can be precalculated and stored, with some performance benefit <em>[18]</em>.</p>

    <p class="text-gray-300">Choosing as a parameter a group order <span class="math">r</span> of low Hamming weight drastically reduces the number of expensive add steps, and hence speeds the algorithm. However does this process take full advantage of our ability to choose <span class="math">r</span>? The intuition that led to the discovery of the <span class="math">\\eta_{T}</span> pairing was that the multiplication by the group order could perhaps be divided into two parts. At the “half-way”</p>

    <p class="text-gray-300">stage, the point <span class="math">P</span> might be “close” to where it started. Therefore the second half of the iteration would hopefully be a simple function of the first part, and so only half the number of iterations might be required. Here we demonstrate that something similar can be achieved for NSS curves.</p>

    <p class="text-gray-300">Gallant, Lambert and Vanstone <em>[12]</em> have pointed out the following useful facts about NSS curves, and the efficient endomorphisms that they support.</p>

    <p class="text-gray-300">For the curve (3) let <span class="math">P</span> be a point of prime order <span class="math">r</span>, with coordinates <span class="math">(x,y)</span>, such that <span class="math">\\lambda^{2}+1=0</span> mod <span class="math">r</span>. Then the point <span class="math">\\lambda P</span> has coordinates <span class="math">(-x,\\alpha y)</span>, where <span class="math">\\alpha</span> is a square root of -1 mod <span class="math">p</span>. Note that there are two possibilities for <span class="math">\\alpha</span>, depending on the two possible solutions of the quadratic equation for <span class="math">\\lambda</span>. The endomorphism is defined as <span class="math">\\phi_{1}:(x,y)\\rightarrow(-x,\\alpha y)</span></p>

    <p class="text-gray-300">For the curve (4) let <span class="math">P</span> be a point of prime order <span class="math">r</span>, with coordinates <span class="math">(x,y)</span>, such that <span class="math">\\lambda^{2}+\\lambda+1=0</span> mod <span class="math">r</span>. Then the point <span class="math">\\lambda P</span> has coordinates <span class="math">(\\beta x,y)</span>, where <span class="math">\\beta</span> is a non-trivial cube root of unity mod <span class="math">p</span>. Note that there are two possibilities for <span class="math">\\beta</span>, depending on the two possible solutions of the quadratic equation for <span class="math">\\lambda</span>. The endomorphism is this case is defined as <span class="math">\\phi_{2}:(x,y)\\rightarrow(\\beta x,y)</span></p>

    <p class="text-gray-300">This imples that given a point <span class="math">P</span> on one of these curves, one can immediately determine a fixed multiple of the point, with a single field multiplication. In <em>[12]</em> this is exploited to develope a fast point multiplication algorithm.</p>

    <p class="text-gray-300">Focusing on the latter curve, our idea is that <span class="math">\\lambda</span> should be chosen in advance, of low Hamming weight. For example we might choose <span class="math">\\lambda=2^{n}</span>. Then select as <span class="math">r</span> a large prime divisor of <span class="math">\\lambda^{2}+\\lambda+1</span>. For example <span class="math">n=87</span>, and <span class="math">r=(2^{174}+2^{87}+1)/73</span> (a 168-bit prime) would seem to be a suitable choice. Using a double and add algorithm for the calculation of the Tate pairing would require the calculation of <span class="math">2^{n}(2^{n}P+P)+P</span> . However using the endomorphism we can immediately know the value of <span class="math">2^{n}P+P</span>. And this implies that we know the sequence of points that will occur during the final <span class="math">2^{n}</span> doublings, without having to explicitly calculate them (exploiting the well-known commutativity of the endomorphism with point multiplication: <span class="math">a\\phi(P)=\\phi(aP)</span>). This results in significant computational savings.</p>

    <p class="text-gray-300">Now we explain our technique in a little more detail. Given the point <span class="math">P</span> with coordinates <span class="math">(x,y)</span>, and using the endomorphism, it is easy to calculate <span class="math">2^{n}P+P</span> as the point <span class="math">(-(\\beta+1)x,-y)</span>. Clearly if the values of the initial <span class="math">2^{n}</span> point doublings were stored, the values of the final <span class="math">2^{n}</span> doublings can be found at the cost of a single field multiplication, resulting in a faster algorithm. Alternatively if the value of <span class="math">P</span> is fixed, only half the storage would be required. Either way the result is a more efficient algorithm. However it is possible to do a little better than this.</p>

    <p class="text-gray-300">For the first <span class="math">n</span> iterations of Miller’s algorithm the contribution to the pairing value is <span class="math">(y_{Q}-y_{i})-m_{i}(x_{Q}-x_{i})</span>, where <span class="math">(x_{i},y_{i})</span> is the point <span class="math">2^{i}P</span>, <span class="math">m_{i}</span> is the line slope resulting from the current point doubling, and <span class="math">(x_{Q},y_{Q})</span> is the point <span class="math">Q</span>. This value can be multiplied at will by any element of <span class="math">\\mathbb{F}_{p}</span>, as the effect of any such multiplication will be wiped out by the final exponentiation. For the final <span class="math">n</span> iterations the contribution will be <span class="math">(y_{Q}+y_{i})+(\\beta^{2}+1)m_{i}(x_{Q}+(\\beta+1)x_{i})</span></p>

    <p class="text-gray-300">note the adjusted value of the slope. But since <span class="math">\\beta</span> is a non-trivial cube root of unity, we know that <span class="math">\\beta^2 + \\beta + 1 = 0 \\mod p</span>. Substituting and simplifying we have <span class="math">(y_Q + y_i) + (\\beta^2 + 1)m_i(x_Q + (\\beta + 1)x_i) = (y_Q + y_i) + m_i(\\beta x_Q - x_i)</span>. Now multiply by -1 to obtain the equivalent contribution of <span class="math">(-y_Q - y_i) - m_i(\\beta x_Q - x_i)</span>.</p>

    <p class="text-gray-300">Observe therefore that we can obtain the same values by switching the point <span class="math">Q</span> to <span class="math">\\bar{Q}</span> for the final <span class="math">n</span> iterations, where <span class="math">\\bar{Q} = (\\beta x_Q, -y_Q)</span>, and using exactly the same sequence of <span class="math">(x_i, y_i)</span> as we did for the first <span class="math">n</span> iterations.</p>

    <h2 id="sec-7" class="text-2xl font-bold">5.1 A basic algorithm</h2>

    <p class="text-gray-300">We are now ready to bring these ideas together and describe our modified BKLS-GHS algorithm in detail. First we equip ourselves with a library which can add or double points on an elliptic curves by means of a function <span class="math">A.add(B)</span> which adds <span class="math">B</span> to <span class="math">A</span>, and returns the line slope <span class="math">m</span>.</p>

    <p class="text-gray-300">Next we need a function <span class="math">g(.)</span> to calculate the contribution of the current iteration to the pairing value. The returned value is used for the first <span class="math">n</span> iterations, and the values for the final <span class="math">n</span> iterations are calculated at the same time (at very little extra cost) and stored for later use.</p>

    <p class="text-gray-300"><strong>Algorithm 1</strong> Function <span class="math">g(.)</span></p>

    <pre><code class="language-txt">INPUT: $A, B, Q, i$
1: $x_i, y_i \\gets A$
2: $x_Q, y_Q \\gets Q$
3: $m_i = A.add(B)$
4: store $-y_Q - y_i - m_i(\\beta x_Q - x_i)$ in an array element $s[i]$
5: return $y_Q - y_i - m_i(x_Q - x_i)$</code></pre>

    <p class="text-gray-300">In practise the function <span class="math">A.add(B)</span> will be faster if the point <span class="math">A</span> is represented in projective coordinates, which makes for a somewhat more complex <span class="math">g(.)</span> function. We omit the details, except to point out that much of the calculation is shared between the stored point and the returned point, with further savings.</p>

    <p class="text-gray-300">For optimal performance the point <span class="math">Q</span> is deliberately placed into the trace-zero subgroup, which means that only the variable <span class="math">y_{Q}</span> is in <span class="math">\\mathbb{F}_{p^2}</span>. The variables <span class="math">x_{i}, y_{i}, x_{Q}, m_{i}</span> are all in <span class="math">\\mathbb{F}_{p}</span>. See [18] for details. The returned and stored values are in <span class="math">\\mathbb{F}_{p^2}</span>.</p>

    <p class="text-gray-300">Care must be taken to ensure that correct non-trivial cube root of unity for <span class="math">\\beta</span> is chosen, as there are two possibilities associated with the two solutions for <span class="math">\\lambda^2 + \\lambda + 1 = 0 \\mod r</span>. The right value can easily be found by trial and error, and the value of <span class="math">\\beta x_Q</span> can then be precalculated and stored.</p>

    <p class="text-gray-300">For the particular case <span class="math">n = 87</span> the full Tate pairing algorithm is given in Algorithm 2. This algorithm will also work for any choice of <span class="math">\\lambda = 2^n</span> which leads to a near-prime value of <span class="math">r = \\lambda^2 + \\lambda + 1</span>. However in practise, and in the range of useful values, good values for <span class="math">n</span> are hard to find.</p>

    <p class="text-gray-300">|  Algorithm 2 Computation of e(P,Q) on NSS curve (4), k = 2, λ = 287, r = (λ2 + λ + 1)/73  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  INPUT: P,Q  |   |</p>

    <p class="text-gray-300">|  OUTPUT: e(P,Q)  |   |</p>

    <p class="text-gray-300">|  1: A ← P, f ← 1  |   |</p>

    <p class="text-gray-300">|  2: for i ← 1 to 87 do  |   |</p>

    <p class="text-gray-300">|  3: f ← f2.g(A,A,Q,i)  |   |</p>

    <p class="text-gray-300">|  4: end for  |   |</p>

    <p class="text-gray-300">|  5: f ← f.g(A,P,Q,-)  |   |</p>

    <p class="text-gray-300">|  6: for i ← 1 to 87 do  |   |</p>

    <p class="text-gray-300">|  7: f ← f2.s[i]  |   |</p>

    <p class="text-gray-300">|  8: end for  |   |</p>

    <p class="text-gray-300">|  9: return f(p-1)(p+1)/r  |   |</p>

    <p class="text-gray-300">Consider now the slightly more complicated choice of  <span class="math">\\lambda = 2^a + 2^b</span> . In this case we have much greater control of  <span class="math">r</span> , and it is much easier to find a prime value which still has a very low Hamming weight. For example choosing  <span class="math">\\lambda = 2^{80} + 2^{16}</span>  gives a prime  <span class="math">r = \\lambda^2 + \\lambda + 1</span>  of 161 bits. A slight complication arises in this case, as the multiplication of the point  <span class="math">P</span>  by  <span class="math">r</span>  no longer follows a purely double-and-add algorithm, and so Miller's algorithm needs to be slightly modified to accommodate this. In the following algorithm 3, the variable  <span class="math">h</span>  is used to handle this modification.</p>

    <p class="text-gray-300">The extra storage requirement for the array  <span class="math">s</span>  is not very large, but in some circumstances it may become an issue. An alternative version of the algorithm requires no storage, for a little extra work. See algorithm 4.</p>

    <p class="text-gray-300">An important first step in an implementation is to use the Cocks and Pinch algorithm to generate a suitable 512-bit,  <span class="math">k = 2</span>  NSS elliptic curve. The curve  <span class="math">y^{2} = x^{3} + 5 \\mod p</span> , for the 512-bit prime  <span class="math">p</span> , where</p>

    <p class="text-gray-300"><span class="math">p = 11457475683995493806353174186205825314535461236767597441115533728505070527823</span>  154532657656991234473986641703193940343559823628668878734326909502089393493643</p>

    <p class="text-gray-300">was quickly found. The Tate pairing was calculated on this curve using algorithms 3 and 4 with  <span class="math">a = 80</span>  and  <span class="math">b = 16</span> , and compared with the pairing calculated on the original Boneh and Franklin supersingular curve. As anticipated, the NSS curve pairings are significantly faster.</p>

    <p class="text-gray-300">We provide both timings and a count of the total number of  <span class="math">\\mathbb{F}_p</span>  modular multiplications and squarings required. In the implementation we used a final exponentiation based on the calculation of a Lucas sequence, which allows easy times-two compression of the output, as described in [18] and [20].</p>

    <p class="text-gray-300">|  Algorithm 3 Computation of e(P,Q) on NSS curve (4), k = 2, λ = 2a + 2b, a > b, r = λ2 + λ + 1. Requires an array s of length a.  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  INPUT: P,Q  |   |</p>

    <p class="text-gray-300">|  OUTPUT: e(P,Q)  |   |</p>

    <p class="text-gray-300">|  1: A ← P, f ← 1, j ← 1  |   |</p>

    <p class="text-gray-300">|  2: for i ← 1 to a - b do  |   |</p>

    <p class="text-gray-300">|  3: f ← f2.g(A,A,Q,j++)  |   |</p>

    <p class="text-gray-300">|  4: end for  |   |</p>

    <p class="text-gray-300">|  5: f ← f.g(A,P,Q,j++)  |   |</p>

    <p class="text-gray-300">|  6: for i ← 1 to b do  |   |</p>

    <p class="text-gray-300">|  7: f ← f2.g(A,A,Q,j++)  |   |</p>

    <p class="text-gray-300">|  8: end for  |   |</p>

    <p class="text-gray-300">|  9: f ← f.g(A,P,Q,-)  |   |</p>

    <p class="text-gray-300">|  10: h ← f, j ← 1  |   |</p>

    <p class="text-gray-300">|  11: for i ← 1 to a - b do  |   |</p>

    <p class="text-gray-300">|  12: f ← f2.s[j++]  |   |</p>

    <p class="text-gray-300">|  13: end for  |   |</p>

    <p class="text-gray-300">|  14: f ← f.s[j++]  |   |</p>

    <p class="text-gray-300">|  15: f ← f.h  |   |</p>

    <p class="text-gray-300">|  16: for i ← 1 to b do  |   |</p>

    <p class="text-gray-300">|  17: f ← f2.s[j++]  |   |</p>

    <p class="text-gray-300">|  18: end for  |   |</p>

    <p class="text-gray-300">|  19: return f(p-1)(p+1)/r  |   |</p>

    <p class="text-gray-300">|  Algorithm 4 Computation of e(P,Q) on NSS curve (4), k = 2, λ = 2a + 2b, a > b, r = λ2 + λ + 1. No extra storage requirement.  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  INPUT: P,Q  |   |</p>

    <p class="text-gray-300">|  OUTPUT: e(P,Q)  |   |</p>

    <p class="text-gray-300">|  1: A ← P, f1 ← 1, f2 ← 1, j ← 1  |   |</p>

    <p class="text-gray-300">|  2: for i ← 1 to a - b do  |   |</p>

    <p class="text-gray-300">|  3: f1 ← f12.g(A,A,Q,0)  |   |</p>

    <p class="text-gray-300">|  4: f2 ← f22.s[0]  |   |</p>

    <p class="text-gray-300">|  5: end for  |   |</p>

    <p class="text-gray-300">|  6: f1 ← f1.g(A,P,Q,0)  |   |</p>

    <p class="text-gray-300">|  7: f2 ← f2.s[0]  |   |</p>

    <p class="text-gray-300">|  8: for i ← 1 to b do  |   |</p>

    <p class="text-gray-300">|  9: f1 ← f12.g(A,A,Q,0)  |   |</p>

    <p class="text-gray-300">|  10: f2 ← f22.s[0]  |   |</p>

    <p class="text-gray-300">|  11: end for  |   |</p>

    <p class="text-gray-300">|  12: f1 ← f1.g(A,P,Q,-)  |   |</p>

    <p class="text-gray-300">|  13: f ← f13.f2  |   |</p>

    <p class="text-gray-300">|  14: return f(p-1)(p+1)/r  |   |</p>

    <p class="text-gray-300">Table 1. NSS vs Supersingular Tate Pairing - 3GHz Intel PIV.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Curve type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fp muls</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time (ms)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">512-bit, k = 2 Supersingular curve</td>

            <td class="px-3 py-2 border-b border-gray-700">4070</td>

            <td class="px-3 py-2 border-b border-gray-700">8.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">512-bit, k = 2 NSS curve, with storage</td>

            <td class="px-3 py-2 border-b border-gray-700">3163</td>

            <td class="px-3 py-2 border-b border-gray-700">7.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">512-bit, k = 2 NSS curve, no storage</td>

            <td class="px-3 py-2 border-b border-gray-700">3329</td>

            <td class="px-3 py-2 border-b border-gray-700">7.5</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The basic idea can be extended in a few directions. Firstly the same basic technique will also work for the "other" NSS curve of equation (3). The idea could also be applied to the non-supersingular curves with CM discriminants of  <span class="math">D = -7</span>  and  <span class="math">D = -8</span> , as described in [12], although in these cases the savings would be much less significant as the endomorphisms are much more complex to calculate. In fact it would be more correct to refer to the class of exploitable curves as "small discriminant CM curves".</p>

    <p class="text-gray-300">If the first parameter  <span class="math">P</span>  is fixed, then no savings will be realised in terms of computation using this method as all the multiples of  <span class="math">P</span>  can be precalculated and stored. However using NSS curves only half the storage will be required, which leads to greater efficiency, and which might be significant in a constrained environment.</p>

    <p class="text-gray-300">The method has been described in the context of a security multiplier of  <span class="math">k = 2</span> , but it also applies immediately to higher values of  <span class="math">k</span> . In these cases the computational time savings will be smaller, as the implicit point multiplication of  <span class="math">P</span>  by  <span class="math">r</span>  becomes a less significant part of the overall calculation [19].</p>

    <p class="text-gray-300">We note in passing that the method of Gallant, Lambert and Vanstone [12] also has direct application to pairing-based protocols which require point multiplication, such as the Boneh and Franklin IBE, if they are implemented on NSS curves. With our choice of group order the deployment of this scheme becomes particularly simple: Calculate  <span class="math">kP</span>  as  <span class="math">k_{1}P + k_{2}\\phi (P</span> , where  <span class="math">k_{2} = k / \\lambda ,k_{1} = k\\bmod \\lambda</span> . See [12] for details..</p>

    <p class="text-gray-300">Finally we point out that many curves that have been suggested as suitable for use in pairing-based cryptography are in fact already of the NSS form [3], [7], and furthermore have a group order of the required form. For example the  <span class="math">k = 12</span>  curve suggested in Appendix A of [3] is of this form, as is the nice  <span class="math">k = 8</span>  curve suggested by Brezing and Weng [7] and implemented in [19]. This is facilitated by the group order of these curves being derived from a cyclotomic polynomial which, as luck would have it, is of the same form as  <span class="math">r = \\lambda^2 + \\lambda + 1</span> .</p>

    <p class="text-gray-300">Are NSS curves any less secure than supersingular curves or indeed general pairing-friendly non-supersingular curves? There is no reason to think so. In standard elliptic curve cryptography some classes of curves are considered as weaker than others, although sometimes the reasons are not well supported by any hard evidence. For example it is considered in certain quarters (for example the German National Security Agency), that curves with smaller CM discrimin-</p>

    <p class="text-gray-300">inants are in some sense weaker than others <em>[8]</em>. Whatever the merits of such judgements, they do not apply in the pairing context, where it is already known that there is an index calculus attack on the extension field <span class="math">\\mathbb{F}_{p^{k}}</span>, which arises as a direct consequence of having a small embedding degree <span class="math">k</span>. Of course by choosing <span class="math">p</span> and <span class="math">k</span> wisely this index calculus attack becomes infeasible. It remains an interesting open question whether or not there are any weak classes of pairing-suitable curves, supersingular or non-supersingular.</p>

    <h2 id="sec-11" class="text-2xl font-bold">8 Conclusions</h2>

    <p class="text-gray-300">We have described a method of calculating pairings on certain non-supersingular curves, which is faster than using the equivalent supersingular curve, as originally recommended by Boneh and Franklin <em>[6]</em> for use in Identity Based Encryption. The proposed method is more efficient in terms of time or of space than any other method so far proposed for prime characteristic fields and at contemporary levels of security.</p>

    <h2 id="sec-12" class="text-2xl font-bold">9 Acknowledgement</h2>

    <p class="text-gray-300">Thanks to Steven Galbraith for his comments on an early draft of this paper.</p>

    <h2 id="sec-13" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Paulo S. L. M. Barreto, Steven Galbraith, Colm O hEigeartaigh, and Michael Scott. Efficient pairing computation on supersingular abelian varieties. Cryptology ePrint Archive, Report 2004/375, 2004. http://eprint.iacr.org/.</li>

      <li>[2] P.S.L.M. Barreto, H.Y. Kim, B. Lynn, and M. Scott. Efficient algorithms for pairing-based cryptosystems. In Advances in Cryptology – Crypto’2002, volume 2442 of Lecture Notes in Computer Science, pages 354–68. Springer-Verlag, 2002.</li>

      <li>[3] P.S.L.M. Barreto, B. Lynn, and M. Scott. Constructing elliptic curves with prescribed embedding degrees. In Security in Communication Networks – SCN’2002, volume 2576 of Lecture Notes in Computer Science, pages 263–273. Springer-Verlag, 2002.</li>

      <li>[4] P.S.L.M. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. Cryptology ePrint Archive, Report 2005/133, 2005. http://eprint.iacr.org/.</li>

      <li>[5] I. F. Blake, G. Seroussi, and N. P. Smart, editors. Advances in Elliptic Curve Cryptography, Volume 2. Cambridge University Press, 2005.</li>

      <li>[6] D. Boneh and M. Franklin. Identity-based encryption from the Weil pairing. SIAM Journal of Computing, 32(3):586–615, 2003.</li>

      <li>[7] F. Brezing and A. Weng. Elliptic curves suitable for pairing based cryptography. Cryptology ePrint Archive, Report 2003/143, 2003. Available from http://eprint.iacr.org/2003/143.</li>

      <li>[8] Johannes Buchmann and Harald Baier. Efficient construction of cryptographically strong elliptic curves. In INDOCRYPT, pages 191–202, 2000.</li>

      <li>[9] R. Crandall and C. Pomerance. Prime Numbers: a Computational Perspective. Springer-Verlag, Berlin, 2001.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[10] I. Duursma and H. S. Lee. Tate-pairing implementations for tripartite key agreement. In Advances in Cryptology – Asiacrypt 2003, volume 2894 of Lecture Notes in Computer Science, pages 111–123. Springer-Verlag, 2003.</li>

      <li>[11] S. Galbraith, K. Harrison, and D. Soldera. Implementing the Tate pairing. In Algorithm Number Theory Symposium – ANTS V, volume 2369 of Lecture Notes in Computer Science, pages 324–337. Springer-Verlag, 2002.</li>

      <li>[12] R.P. Gallant, R.J. Lambert, and S.A. Vanstone. Faster point multiplication on elliptic curves with efficient endomorphisms. In Advances in Cryptology – Crypto 2001, volume 2139 of Lecture Notes in Computer Science, pages 190–200. Springer-Verlag, 2001.</li>

      <li>[13] Neal Koblitz and Alfred Menezes. Pairing-based cryptography at high security levels. Cryptology ePrint Archive, Report 2005/076, 2005. http://eprint.iacr.org/.</li>

      <li>[14] Arjen K. Lenstra. Unbelievable security. Matching AES security using public key systems. In Advances in Cryptology – Asiacrypt 2001, volume 2248, pages 67–86. Springer-Verlag, 2001.</li>

      <li>[15] A. Menezes. Elliptic Curve Public Key Cryptosystems. Kluwer Academic Publishers, 1993.</li>

      <li>[16] V. Miller. Short programs for functions on curves. unpublished manuscript, 1986.</li>

      <li>[17] A. Miyaji, M. Nakabayashi, and S. Takano. New explicit conditions of elliptic curve traces for FR-reduction. IEICE Transactions on Fundamentals, E84-A(5):1234–1243, 2001.</li>

      <li>[18] M. Scott. Computing the Tate pairing. In CT-RSA, volume 3376 of Lecture Notes in Computer Science, pages 293–304. Springer-Verlag, 2005.</li>

      <li>[19] M. Scott. Scaling security in pairing-based protocols. Cryptology ePrint Archive, Report 2005/139, 2005. http://eprint.iacr.org/.</li>

      <li>[20] M. Scott and P. Barreto. Compressed pairings. In Advances in Cryptology – Crypto’ 2004, volume 3152 of Lecture Notes in Computer Science, pages 140–156. Springer-Verlag, 2004. Also available from http://eprint.iacr.org/2004/032/.</li>

    </ul>`;
---

<BaseLayout title="Faster Pairings using an Elliptic Curve with an Efficient En... (2005/252)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2005 &middot; eprint 2005/252
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
