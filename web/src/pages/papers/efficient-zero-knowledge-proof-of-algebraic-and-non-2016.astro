---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/583';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Efficient Zero-Knowledge Proof of Algebraic and Non-Algebraic Statements with Applications to Privacy Preserving Credentials';
const AUTHORS_HTML = 'Melissa Chase, Chaya Ganesh, Payman Mohassel';

const CONTENT = `    <p class="text-gray-300">Melissa Chase^{1}, Chaya Ganesh^{2}, and Payman Mohassel^{3} ^{1} Microsoft Research, USA ^{2} Department of Computer Science, New York University ^{3} Visa Research, USA</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Practical anonymous credential systems are generally built around sigma-protocol ZK proofs. This requires that credentials be based on specially formed signatures. Here we ask whether we can instead use a standard (say, RSA, or (EC)DSA) signature that includes formatting and hashing messages, as a credential, and still provide privacy. Existing techniques do not provide efficient solutions for proving knowledge of such a signature: On the one hand, ZK proofs based on garbled circuits <em>[Jawurek et al.2013]</em> give efficient proofs for checking formatting of messages and evaluating hash functions. On the other hand they are expensive for checking algebraic relations such as RSA or discrete-log, which can be done efficiently with sigma protocols.</p>

    <p class="text-gray-300">We design new constructions obtaining the best of both worlds: combining the efficiency of the garbled circuit approach for non-algebraic statements and that of sigma protocols for algebraic ones. We then discuss how to use these as building-blocks to construct privacy-preserving credential systems based on standard RSA and (EC)DSA signatures.</p>

    <p class="text-gray-300">Other applications of our techniques include anonymous credentials with more complex policies, the ability to efficiently switch between commitments (and signatures) in different groups, and secure two-party computation on committed/signed inputs.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Efficient proofs</h4>

    <p class="text-gray-300">Zero knowledge proofs <em>[x13]</em> provide an extremely powerful tool, which allows a prover to convince a verifier that a statement is true without revealing any further information. Moreover, it has been shown that every NP language has a zero knowledge proof system<em>[x12]</em>, opening up the possibility for a vast range of privacy preserving applications. However, while this is true in theory, designing proof systems that are efficient enough to be used is significantly more challenging. In reality, we only have a few techniques for efficient proofs, and those only apply to a restricted set of languages.</p>

    <p class="text-gray-300">Almost exclusively, these proof systems focus on proving algebraic statements, i.e. statements about discrete logarithms, roots, or polynomial relationships between values <em>[x30, x14, x15, x16, x17]</em>. The most common and most efficient of these systems fall into a class known as sigma protocols. Of course we could express any NP relation as a</p>

    <p class="text-gray-300">combination of algebraic statements, for example by expressing the relation as a circuit, and expressing each gate as an algebraic relation between input and output wires. But if we were to take this approach to prove a statement using sigma protocols we would need several exponentiations per gate in the circuit. This becomes prohibitively expensive for large circuits (for example a circuit computing a cryptographic hash function or block cipher).</p>

    <p class="text-gray-300">Recently, <em>[x11]</em> introduced a new approach for proving statements phrased as boolean circuits, based on garbled circuits. Their construction has the advantage that it only requires a few symmetric key operations per gate, making it dramatically more efficient than a sigma-protocol-based solution for non-algebraic statements. This means that it is finally practical to prove statements about complex operations such as hash functions or block ciphers. For instance, zero knowledge proofs for an AES circuit or a SHA256 circuit can be done in miliseconds on standard PCs using state of the art implementations for garbled circuits. On the other hand, expressing many public key operations as a circuit is still extremely expensive. (Consider for example a circuit computing modular exponentiation on a cryptographic group - the result would be much larger than the circuit computing a hash function, and computing a garbled circuit for such a computation would be too expensive to be practical.)</p>

    <p class="text-gray-300">Now we have two very different techniques for achieving zero knowledge proofs for algebraic and non-algebraic statements. But in some applications, one is interested in proving statements that combine the two. For example, what if we want an efficient protocol for proving knowledge of a DSA or RSA signature, whose verification requires computing both a hash function and several exponentiations?</p>

    <p class="text-gray-300">The state of the art fails to take advantage of the best of both worlds and has to forgo the efficiency of one approach to obtain the other’s. One might consider directly combining both protocols, but a naive solution would allow a cheating prover to use a different witness for the algebraic and non-algebraic components of the computation and produce a convincing proof for a statement for which there is no single valid witness. Thus, one of the basic challenges is to bind the values committed to in the sigma protocols to the prover’s inputs in the GC-based zero knowledge proof, without having to perform expensive group operations (e.g. exponentiation) inside the garbled circuit, and without proving large-circuit statements using sigma protocols.</p>

    <h5 id="sec-5" class="text-base font-semibold mt-4">Anonymous Credentials.</h5>

    <p class="text-gray-300">Here, we primarily focus on the case of anonymous credentials, introduced by Chaum <em>[x4]</em>, although we believe our results will be applicable to many other privacy protocols. A credential system allows a user to obtain credentials from an organization and at some later point prove to a verifier (either the same organization or some other party) that she has been given appropriate credentials. More specifically, the user’s credentials will contain a set of attributes, and the verifier will require that the user prove that the attributes in his credential satisfy some policy. We say the system is anonymous if this proof does not reveal anything beyond this fact.</p>

    <p class="text-gray-300">4 SNARKs [Gro10,GGPR13] allow for very efficient verification and short proofs, but have similar shortcomings in prover efficiency as the prover performs public-key operations proportional to the size of the arithmetic circuit representing the statement.</p>

    <p class="text-gray-300">There have been several proposals for constructions of anonymous credential systems [CL01,CL04,BCKL08,Bra99,BL13]. In general, they all follow a similar approach: the credential is a signature from the organization on the user's attributes. To prove possession of valid credentials, the user will first commit to her attributes, then prove, in zero knowledge, knowledge of a signature on the committed attributes, and finally prove, again in zero knowledge, that the committed attributes satisfy the policy. To make these zero knowledge proofs efficient, most of the proposed credential systems are based on sigma protocols, which as described above give efficient proofs of knowledge for certain algebraic statements. This in turn means that the signatures used must be specially designed so that a sigma protocol can be used to prove knowledge of a signature on a committed message.⁵</p>

    <p class="text-gray-300">But what if we want to base our credentials on a standard signature such as FDH-RSA or DSA which includes hashing the message? Or what if we want the user to be able to prove a statement about his attributes that is not easily expressible as an algebraic relation?</p>

    <p class="text-gray-300">Our Results. We study the problem of combining proof systems for algebraic and non-algebraic statements, and obtain the following results.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given an algebraic commitment <span class="math">C</span>, we propose two protocols for proving that <span class="math">C</span> is a commitment to <span class="math">x</span> such that <span class="math">f(x) = 1</span> where <span class="math">f</span> is expressed as a boolean circuit. Both constructions have the desired property that the GC-based component is dominated by the cost of garbling <span class="math">f</span> (i.e. not garbling expensive group operations), and the total number of public-key operations is independent of the size of <span class="math">f</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">More specifically, our first solution has public key operations proportional to the maximum bit length of the input $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, and symmetric-key operations proportional to the number of gates in </span>f<span class="math">. The second has public-key operations proportional to the statistical security parameter </span>s<span class="math"> and symmetric-key operations proportional to the number of gates in </span>f +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Existing solutions either require public-key operations proportional to the size of <span class="math">f</span>, or need to garble circuits for expensive group operations such as exponentiations in large groups.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Building directly on these protocols, we show how to implement a proof that one committed message is the hash of another, and a proof that two commitments in different groups commit to the same value.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally, we show how we can combine all of these protocols to obtain an efficient proof of knowledge of a signature on a committed message for RSA-FDH⁶, DSA, and EC-DSA signatures.</li>

    </ul>

    <p class="text-gray-300">⁵ Technically, [Bra99,BL13] work slightly differently in that the user and organization jointly compute the proof of knowledge of a signature as part of the credential issuance. However they still use a customized issuing protocol which would not be compatible with standardized signatures, and they use sigma protocols exactly as described here to prove that the committed attributes satisfy the policy.</p>

    <p class="text-gray-300">⁶ This easily extends to standardized variants of RSA like RSA-PSS.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Anonymous Credentials based on RSA, DSA, EC-DSA signatures. The most direct application in the context of anonymous credentials would be to use RSA, DSA, or EC-DSA signatures directly as credentials but still allow for privacy preserving presentation protocols. This would be slower than existing credential systems, but it would have the advantage that the issuer would not have to perform a complex protocol, but would only have to issue standardized signatures. It further enables interoperability with existing libraries and non-private credential applications.</li>

    </ul>

    <p class="text-gray-300">Alternatively, we could construct a service which allows users to convert their non-private credentials (based on RSA/DSA/EC-DSA signatures) into traditional anonymous credentials (e.g. Idemix [ide10] or UProve [PZ13] tokens, or keyed-verification credentials[CMZ14]). Using our new protocol, the service could perform that conversion without knowing the user's attributes: the user would commit to his attributes, prove using our protocol that they have been signed, and then obtain from the service an anonymous credential encoding the same attributes. (All of these anonymous credential systems allow for issuing credentials on committed attributes.)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Anonymous Credentials with more general policies. Even if we consider a system based on traditional anonymous credentials, we might use the <span class="math">\\Pi_{\\mathsf{Com},f}</span> protocol (which we will describe in section 3) to allow the user to prove that his attributes satisfy a more complicated policy. For example, he might want to release the hash of one of his attributes and prove that that has been done correctly, or prove that an attribute has been encrypted using a standard encryption scheme like RSA-OAEP.</li>

    </ul>

    <p class="text-gray-300">Our protocols could also be used to prove that a user's attributes fall in a given range, or to prove statements about comparisons between attributes. If the range of values possible for each attribute is small, we already have reasonably efficient solutions - the user can just commit to each bit of the value, and do a straightforward proof. However this becomes expensive when the range gets larger, in which case the most efficient known approach is based on integer commitments [FO97] and requires several exponentiations with an RSA modulus where the exponent is larger than the group order (e.g. a roughly 2000 bit exponentiation with a 2000 bit modulus for reasonable security parameters). Alternatively we can use our second scheme, which only requires a number of public-key operations linear in the security parameter (e.g. 60), and allows those operations to use much more efficient elliptic curve groups.</p>

    <p class="text-gray-300">We note that the independent and concurrent work of <span class="math">\\left[\\mathrm{KKL}^{+}16\\right]</span> provides an alternative solution to the problem of anonymous credentials for general policies, using different techniques.</p>

    <p class="text-gray-300">7 Delignat-Lavaud et al [DLFKP16] achieve a similar result using SNARKs, but with very different tradeoffs: their approach results in much shorter, non-interactive proofs, but much more expensive proof generation. They also explore several applications in more detail; in some of these applications, those which allow for interactive proofs, our protocols could be used to achieve these different tradeoffs.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Converting between different commitment schemes. There are many protocols based around commitments, and ideally we would be able to combine these protocols arbitrarily. For example, if we have an efficient protocol for proving that a committed tag matches one of the attributes in a user’s credential, and another protocol for proving that a committed tag is not on a list of revoked values, then we would be able to combine the two protocols to prove that the user’s credential has not been revoked. However, often the protocols will be based on different commitment schemes, or even worse, on schemes that operate in different sized groups. (For example UProve credentials can be instantiated in standardized elliptic curve groups like those used for EC-DSA, while revocation systems like that in <em>[x13]</em> require pairing groups; to combine the two we would need to find a pairing group whose group order matches one of the standardized curves. Finding a pairing group to match a specific group order often incurs a significant cost in efficiency.) With our protocol for converting between commitment schemes we could choose the most efficient groups for each, and then the user would merely prove that he has used the same attributes in each. Before our work, the only known approach to convert between groups of different sizes was to use integer commitments, which as described above can be quite expensive.</li>

      <li>Other privacy-preserving protocols. We note that while anonymous credentials make a good motivating application, these problems (converting between commitments schemes, comparing committed values, or proving other non-algebraic statements) come up in many other privacy/anonymity scenarios.</li>

      <li>2PC with authenticated input. As input to a secure computation protocol, sometimes it is desirable to use previously committed <em>[x10]</em> or signed <em>[x5]</em> inputs. In our constructions, we show how to commit to an input <span class="math">x</span> and prove knowledge of <span class="math">x</span> (or prove knowledge of a signature on <span class="math">x</span>) and a non-algebraic statement <span class="math">f(x)=1</span> using garbled circuits. As we discuss in section 3.4, it is relatively easy to extend our construction to also allow secure two-party computation of <span class="math">g(x,y)</span> where <span class="math">x</span> is the prover’s input and <span class="math">y</span> the verifier’s, hence obtaining secure two-party computation on signed/committed inputs. The benefit of this approach is that checking the signature takes place outside the secure two-party computation and can be significantly more efficient.</li>

    </ul>

    <h2 id="sec-7" class="text-2xl font-bold">2 Preliminaries</h2>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.1 Simulation-based Security</h3>

    <p class="text-gray-300">We use a simulation-based definition of security in the ideal/real world paradigm, which is formulated by specifying an ideal functionality. A protocol is secure if it “emulates” this ideal functionality in the presence of any adversary. Our definitions are in the stand-alone setting (as opposed to the UC framework). We formulate the simulation-based definitions by defining a functionality <span class="math">\\mathcal{F}</span> in the ideal world. In the ideal world, all parties and the adversary <span class="math">\\mathcal{A}</span> interact via <span class="math">\\mathcal{F}</span>. Let <span class="math">IDEAL_{\\mathcal{F},\\mathcal{A}}(x_{1},x_{2})</span> denote the output vector of the adversary and the honest party from the execution in the ideal world. In the real world, a protocol <span class="math">\\pi</span> is executed among the parties, and let <span class="math">REAL_{\\pi,\\mathcal{A}}(x_{1},x_{2})</span> denote the output of the adversary and the honest party from the execution of <span class="math">\\pi</span>. A two party</p>

    <p class="text-gray-300">protocol <span class="math">\\pi</span> securely realizes the functionality <span class="math">\\mathcal{F}</span> if for any PPT adversary <span class="math">\\mathcal{A}</span> in the real world, there exists a PPT adversary <span class="math">\\mathcal{S}</span> in the ideal-world, such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\{IDEAL_{\\mathcal{F},\\mathcal{S}}(x_{1},x_{2})\\}_{x_{1},x_{2}s.t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\overset{\\varepsilon}{=}\\{REAL_{\\pi,\\mathcal{A}}(x_{1},x_{2})\\}_{x_{1},x_{2}s.t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">that is, the two distributions are computationally indistinguishable.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.2 Commitment Scheme</h3>

    <p class="text-gray-300">A commitment protocol involves two parties: the committer and the receiver. At a high level, it consists of two stages, a commitment phase and a de-commitment phase. In the commitment stage, the committer with a secret input <span class="math">m</span> engages in a protocol with the receiver. At the end of this protocol, receiver does not know what <span class="math">m</span> is (hiding property), and at the same time, the committer, can subsequently in the de-commitment phase, open only one possible value of <span class="math">m</span> (binding property). Throughout the paper, we use algebraic commitment schemes that allow proving linear relationships among committed values. An example of such a scheme with computational binding and unconditional hiding properties based on the discrete logarithm problem is the one due to Pedersen <em>[x20]</em>. It works in a group <span class="math">G</span> of prime order <span class="math">q</span>. Given two random generators <span class="math">g</span> and <span class="math">h</span> such that <span class="math">\\log_{g}h</span> is unknown, a value <span class="math">x\\in\\mathbb{Z}_{q}</span> is committed to by choosing <span class="math">r</span> randomly from <span class="math">\\mathbb{Z}_{q}</span>, and computing <span class="math">C_{x}=g^{x}h^{r}</span>. Protocols are known in literature to prove knowledge of a committed value, equality of two committed values, and so on, and the protocols can be combined in natural ways. In particular, Pedersen commitments allows proving linear relationships among committed values: Given <span class="math">C_{x}</span> and <span class="math">C_{y}</span>, prove that <span class="math">y=ax+b</span> for some public values <span class="math">a</span> and <span class="math">b</span>.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.3 Committing OT</h3>

    <p class="text-gray-300">Similar to <em>[x12]</em> we need to need an OT protocol with a sender verifiability property- i.e. that at the end of the OTs, the sender is committed to its messages, and can be asked to reveal all its input messages to the receiver. This is closely related to the notion of committing OT <em>[x13]</em>, but can be achieved even more generally since we do not require individual commitments to sender’s messages. In particular, as discussed in <em>[x12]</em> it can be satisfied by a protocol where the sender commits to a seed in the beginning of the protocol, and then runs any secure OT protocol using the output of a pseudorandom generator on the seed as its random tape. Then the open phase can be realized by letting the sender reveal the seed and all the input messages. The ideal functionality <span class="math">\\mathcal{F}_{COT}</span> is defined in Figure 1.</p>

    <p class="text-gray-300">Fig. 1. The ideal functionality <span class="math">\\mathcal{F}_{COT}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The receiver inputs <span class="math">(choose,b),b\\in\\{0,1\\}</span>, and the sender inputs <span class="math">(m_{0},m_{1})</span>.</li>

      <li>Output <span class="math">m_{b}</span> to the receiver.</li>

      <li>On input open from the sender, send <span class="math">(m_{0},m_{1})</span> to the receiver.</li>

    </ul>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2.4 Garbled Circuits</p>

    <p class="text-gray-300">We assume some familiarity with standard constructions of garbled circuits. We employ the abstraction of garbling schemes <em>[x1]</em> introduced by Bellare et al., but similar to <em>[x13]</em> we add a verification algorithm that can check correctness of the garbled circuit given all input labels to the circuit.</p>

    <p class="text-gray-300">A garbling scheme is defined by a tuple of algorithms <span class="math">\\mathcal{G}=(\\mathsf{Gb},\\mathsf{En},\\mathsf{De},\\mathsf{Eval},\\mathsf{Ve})</span> such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Gb}</span> is a randomized garbled circuit generation function that takes a security parameter, and the description of a boolean circuit <span class="math">f</span> and outputs a garbled circuit <span class="math">GC</span> and the encoding and decoding information <span class="math">e</span> and <span class="math">d</span>, respectively.</li>

      <li>The <span class="math">\\mathsf{En}</span> algorithm takes the encoding information <span class="math">e</span> output by <span class="math">\\mathsf{Gb}</span>, and an input <span class="math">x</span> to <span class="math">f</span>, and outputs the garbled input corresponding to <span class="math">x</span>.</li>

      <li>The <span class="math">\\mathsf{Eval}</span> algorithm takes the garbled circuit <span class="math">GC</span> and the garbled input, and outputs an encoded output.</li>

      <li>The <span class="math">\\mathsf{De}</span> algorithm gets the encoded output and the decoding information <span class="math">d</span> as input and returns a decoded output.</li>

      <li>The <span class="math">\\mathsf{Ve}</span> algorithm gets as input a garbled circuit <span class="math">GC</span>, the encoding information <span class="math">e</span>, and a boolean function <span class="math">f</span>, and outputs <span class="math">d</span> or <span class="math">\\bot</span>.</li>

    </ul>

    <p class="text-gray-300">In our constructions, we assume that the encoding information <span class="math">e</span> is a vector of pairs of input labels, where the pair <span class="math">(K_{i}^{0},K_{i}^{1})</span> denotes the input labels for <span class="math">0</span> and <span class="math">1</span> for input wire <span class="math">i</span> in the circuit. Similarly, we assume that the decoding information <span class="math">d</span> is a vector of pairs of output labels.</p>

    <p class="text-gray-300">A garbling scheme may satisfy several properties such as correctness, authenticity and privacy. We review these notions next.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">A garbling scheme satisfies <em>correctness</em> if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for all boolean circuits <span class="math">f</span> and all input <span class="math">x</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{De}(d,\\mathsf{Eval}(GC,\\mathsf{En}(e,x)))=f(x)\\text{ whenever }(GC,e,d)\\leftarrow\\mathsf{Gb}(f,1^{\\kappa})</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for all boolean circuits <span class="math">f</span> and all (possibly malicious) garbled circuits <span class="math">GC</span> and encoding information <span class="math">e</span>, decoding information <span class="math">d</span>, and all input <span class="math">x</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\text{if }d\\leftarrow\\mathsf{Ve}(GC,e,f)\\text{ and }d\\neq\\bot\\text{ then }\\mathsf{De}(d,\\mathsf{Eval}(GC,\\mathsf{En}(e,x)))=f(x)</span></p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">A garbling scheme has <em>authenticity</em> if for every circuit <span class="math">f</span>, input <span class="math">x</span>, and PPT algorithm <span class="math">\\mathcal{A}</span>, the following probability</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\exists y\\neq f(x),y=\\mathsf{De}(d,d^{\\prime}):(GC,e,d)\\leftarrow\\mathsf{Gb}(f,1^{\\kappa}),d^{\\prime}\\leftarrow\\mathcal{A}(GC,\\mathsf{En}(e,x))]</span></p>

    <p class="text-gray-300">is negligible in <span class="math">\\kappa</span>.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 3.</h6>

    <p class="text-gray-300">A garbling scheme has <em>privacy</em> if there exists a PPT simulator <span class="math">\\mathcal{S}</span> such that the following two distributions are indistinguishable:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Real(f,x):</span> run <span class="math">(GC,e,d)\\leftarrow\\mathsf{Gb}(f,1^{\\kappa})</span>, and output <span class="math">(GC,\\mathsf{En}(e,x),d)</span>.</li>

      <li><span class="math">Ideal_{\\mathcal{S}}(f,f(x))</span>: output <span class="math">\\mathcal{S}(f,f(x))</span></li>

    </ul>

    <p class="text-gray-300">2.5 Zero-knowledge Proofs</p>

    <p class="text-gray-300">A Zero-knowledge (ZK) proof allows a prover to convince a verifier of the validity of a statement, without revealing any other information. Let <span class="math">\\mathcal{L}</span> be the language associated with an NP relation <span class="math">R</span>: <span class="math">\\mathcal{L}=\\{x\\mid\\exists w:R(x,w)=1\\}</span>. A zero-knowledge proof for <span class="math">\\mathcal{L}</span> lets the prover convince a verifier that <span class="math">x\\in\\mathcal{L}</span> for a common input <span class="math">x</span>. A proof of knowledge captures not only the truth of a statement <span class="math">x\\in\\mathcal{L}</span>, but also that the prover “possesses” a witness <span class="math">w</span> to this fact. A proof of knowledge for a relation <span class="math">R(\\cdot,\\cdot)</span> is an interactive protocol where a prover <span class="math">P</span> convinces a verifier <span class="math">V</span> that <span class="math">P</span> knows a <span class="math">w</span> such that <span class="math">R(x,y)=1</span>, where <span class="math">x</span> is a common input to <span class="math">P</span> and <span class="math">V</span>. The prover can always successfully convince the verifier if indeed <span class="math">P</span> knows such a <span class="math">w</span>. Conversely, if <span class="math">P</span> can convince the verifier with reasonably high probability, then it “knows” such a <span class="math">w</span>, that is, such a <span class="math">w</span> can be efficiently computed given <span class="math">x</span> and the code of <span class="math">P</span>. The formal definition follows. In the following, <span class="math">view_{V}</span> is the “view” of the verifier in the interaction, consisting of its input <span class="math">x</span>, its random coins, and the sequence of the prover’s messages.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 4</h6>

    <p class="text-gray-300">(ZK proof of knowledge). An interactive protocol <span class="math">\\langle P,V\\rangle</span> is a zero-knowledge proof of knowledge for an NP relation <span class="math">R</span> if the following properties are satisfied.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: <span class="math">\\forall x,y</span> such that <span class="math">R(x,y)=1</span>,</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\Pr[\\langle P(x,w),V(x)\\rangle=1]=1</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proof of Knowledge: For every polynomial time prover strategy <span class="math">P^{<em>},\\exists</span> an oracle PPT machine <span class="math">K</span> called the extractor such that <span class="math">K^{P^{</em>}}(x)</span> outputs <span class="math">w^{\\prime}</span> and</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\Pr[\\langle P^{*}(x,w),V(x)\\rangle=1\\wedge R(x,w^{\\prime})=0]</span></p>

    <p class="text-gray-300">is negligible in <span class="math">\\kappa</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Zero-knowledge: For every polynomial time verifier <span class="math">V^{*}</span>, there is a PPT algorithm <span class="math">\\mathcal{S}</span> called the simulator such that for every <span class="math">x\\in\\mathcal{L}</span>, the following two distributions are indistinguishable:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">view_{V^{<em>}}(\\langle P(x,w),V^{</em>}(x)\\rangle)</span></li>

      <li><span class="math">\\mathcal{S}(x)</span></li>

    </ul>

    <p class="text-gray-300">Honest-verifier zero-knowledge: An interactive proof system <span class="math">(P,V)</span> for a language <span class="math">\\mathcal{L}</span> is said to be honest-verifier zero knowledge if there exists a PPT algorithm <span class="math">\\mathcal{S}</span> called the simulator such that for all <span class="math">x\\in\\mathcal{L}</span>, <span class="math">view_{V}(\\langle P(x,w),V(x)\\rangle)</span> and <span class="math">\\mathcal{S}(x)</span> are indistinguishable. This definition says that the verifier gains no knowledge from the interaction, as long as it runs the prescribed algorithm <span class="math">V</span>. If the verifier tries to gain some knowledge from its interaction with the prover by deviating from the prescribed protocol, we should consider an arbitrary (but efficient) cheating verifier <span class="math">V^{*}</span> as in the property 3 of the above definition which is full zero-knowledge. Efficient zero knowledge proofs are known which are based on sigma protocols. Sigma protocols are three round public-coin protocols and are honest-verifier zero-knowledge proof systems. There exist sigma protocols for various tasks like proving knowledge of discrete logarithm of a value, that a tuple is of the Diffie-Hellman type etc., and it is also possible to efficiently combine sigma protocols to prove compound statements. It is</p>

    <p class="text-gray-300">possible to efficiently compile a sigma protocol (which is honest-verifier ZK) into a zero-knowledge proof of knowledge. The Fiat-Shamir transform <em>[x10]</em> converts any public-coin zero-knowledge proof into a zero-knowledge proof of knowledge and removes interaction, and is secure in the random oracle model <em>[x23]</em>. Transformations in the common reference string model <em>[x11, x14]</em> are also known. The transformation of <em>[x11]</em> gives a 3-round concurrent zero-knowledge protocol in the CRS model, whereas <em>[x14]</em> is non-interactive.</p>

    <p class="text-gray-300">In our constructions and protocols, we make use of interactive zero knowledge proofs of knowledge of discrete logarithms and relations between discrete logarithms. We use the following notation:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{PK}\\{(x,y,\\cdots):\\text{ statements about }x,y,\\cdots\\}</span></p>

    <p class="text-gray-300">In the above, <span class="math">x,y,\\cdots</span> are secrets (discrete logarithms), the prover asserts knowledge of <span class="math">x,y,\\cdots</span>, and that they satisfy statements. The other values in the protocol are public.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">2.6 ZK Proof Based on Garbled Circuits</h3>

    <p class="text-gray-300">Here, we review an important building block for our construction, i.e., the garbled-circuit-based ZK protocol of <em>[x16]</em>. To prove a statement <span class="math">\\exists w:R(x,w)=1</span> (for public <span class="math">R</span> and <span class="math">x</span>), the protocol proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier generates a garbled circuit computing <span class="math">R(x,\\cdot)</span>. Using a committing oblivious transfer, the prover obtains the wire labels corresponding to his private input <span class="math">w</span>. Then the verifier sends the garbled circuit to the prover.</li>

      <li>The prover evaluates the garbled circuit, obtaining a single garbled output (wire label). He commits to this garbled output.</li>

      <li>The verifier opens his inputs to the committing oblivious transfer, giving the prover all garbled inputs. From this, the prover can check whether the garbled circuit was generated correctly. If so, the prover opens his commitment to the garbled output; if not, the prover aborts.</li>

      <li>The verifier accepts the proof if the prover’s commitment holds the output wire label corresponding to true.</li>

    </ol>

    <p class="text-gray-300">Security against a cheating prover follows from the properties of the circuit garbling scheme. Namely, the prover commits to the output wire label before the circuit is opened, so the authenticity property of the garbling scheme ensures that he cannot predict the true output wire label unless he knows a <span class="math">w</span> with <span class="math">R(x,w)=\\text{\\tt true}</span>. Security against a cheating verifier follows from correctness of the garbling scheme. The garbled output of a correctly generated garbled circuit reveals only the output of the (plain) circuit, and this garbled output is not revealed until the garbled circuit was shown to be correctly generated.</p>

    <p class="text-gray-300">Note that in this protocol, the prover evaluates the garbled circuit on an input which is completely known to him. This is the main reason that the garbled circuit used for evaluation can also be later opened and checked for correctness, unlike in the setting of cut-and-choose for general 2PC. Along the same lines, it was further pointed out in <em>[x12]</em> that the circuit garbling scheme need not satisfy the privacy requirement of</p>

    <p class="text-gray-300"><em>[x1]</em>, only the <em>authenticity</em> requirement. Removing the privacy requirement from the garbling scheme leads to a non-trivial reduction in garbled circuit size.</p>

    <p class="text-gray-300">In one of our constructions (section 3.2), the verifier does have a private input, but its input only needs to be kept private until the circuit is evaluated and the prover has committed to the output. In that scenario, we also invoke the <em>privacy</em> property of the garbling scheme as defined above.</p>

    <h5 id="sec-16" class="text-base font-semibold mt-4">Efficiency of Garbling Schemes.</h5>

    <p class="text-gray-300">The state of the art garbling scheme uses the free-XOR technique <em>[x12]</em> to garble XOR gates and the half-gate technique to garble AND gates <em>[x21]</em>. For a circuit with <span class="math">g</span> non-XOR gates, the total number of ciphertexts is <span class="math">2g</span>, and the number of hash invocations is <span class="math">4g</span> for the garbler and <span class="math">2g</span> for the evaluator.</p>

    <p class="text-gray-300">For <em>privacy-free</em> garbling, the costs are reduced by factor of two (see <em>[x11, x21]</em>). In particular, for a circuit with <span class="math">g</span> non-XOR gates, the total number of ciphertexts is <span class="math">g</span>, and the number of hash invocations is <span class="math">2g</span> for the garbler and <span class="math">g</span> for the evaluator.</p>

    <p class="text-gray-300">We need to garble a few common building-block circuits in our constructions. It is helpful to review the size of these circuits based on the concrete constructions given in <em>[x12]</em>. The circuit for comparing <span class="math">\\ell</span> bit integers requires <span class="math">4\\ell</span> non-XOR gates. The circuit for testing equality of <span class="math">\\ell</span> bit integers also requires <span class="math">4\\ell</span> non-XOR gates. The circuit for adding two <span class="math">\\ell</span> bit integers requires <span class="math">4\\ell</span> non-XOR gates, while the circuit for multiplying two <span class="math">\\ell</span> bit integers requires <span class="math">8\\ell^{2}-4\\ell</span> non-XOR gates.</p>

    <h2 id="sec-17" class="text-2xl font-bold">3 Proving non-Algebraic Statements on Algebraic Commitments</h2>

    <p class="text-gray-300">An important sub-protocol used in our constructions, is to commit to an input <span class="math">x</span> using an algebraic commitment <span class="math">\\mathsf{Com}(x)</span> (e.g. pedersen commitment), and perform a zero-knowledge proof of a non-algebraic statement about <span class="math">x</span>, i.e. that <span class="math">f(x)=1</span> for a boolean circuit <span class="math">f</span>.</p>

    <p class="text-gray-300">Such a protocol allows one to efficiently switch between proving algebraic statements on a committed input (e.g. proof of knowledge of a signature on a committed input) and non-algebraic statement (e.g. hashing, comparison, equality testing and more).</p>

    <p class="text-gray-300">All our protocols are defined in terms of an ideal functionality, and are proven secure in the ideal/real world paradigm. We start by defining this task in terms of an ideal functionality in Figure 2. We provide two instantiations for this functionality that provide different efficiency trade-offs depending on the input size and the algebraic commitment scheme used.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Com}_{f}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier inputs <span class="math">\\mathsf{Com}(x)</span> and prover inputs the opening information <span class="math">x</span> and the randomness.</li>

      <li>If <span class="math">f(x)=1</span> and the opening to the commitment verifies, output accept to the verifier.</li>

    </ul>

    <p class="text-gray-300">The starting point for both instantiations is the ZK-proof of non-algebraic statements based on garbled circuits <em>[x10]</em> (see section 2.6). As the naive solution we</p>

    <p class="text-gray-300">could garble a circuit that takes <span class="math">x</span> and the opening of <span class="math">\\mathsf{Com}(x)</span> as prover’s input and outputs <span class="math">1</span> if <span class="math">f(x)=1</span> and <span class="math">\\mathsf{Com}(x)</span> correctly opens to <span class="math">x</span>. The main drawback of this solution is that checking correctness of opening for an algebraic commitment requires performing expensive group operations (e.g. exponentiation) inside the garbled circuit which would dominate the computation/communication cost. Our two instantiations show how to avoid these costs and perform all algebraic operations outside the garbled circuit.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">3.1 First Instantiation</h3>

    <p class="text-gray-300">In our first construction, we have the prover commit to each bit of <span class="math">x</span>, i.e. <span class="math">\\mathsf{Com}(x_{i})</span> for all <span class="math">i\\in[n]</span>, and prove that when combined they yield <span class="math">x</span>.</p>

    <p class="text-gray-300">Then, following the GC-based approach, the verifier constructs a garbled circuit that computes <span class="math">f(x)</span>, parties go through the steps of the GC-based ZK proof for the prover to prove knowledge of a value <span class="math">x^{\\prime}</span> such that <span class="math">f(x^{\\prime})=1</span>. The main issue is that a malicious prover may use a different input <span class="math">x^{\\prime}\\neq x</span> in the circuit than what he committed to.</p>

    <p class="text-gray-300">But we observe that the input keys associated with <span class="math">x^{\\prime}</span> in the GC (which are obtained through the COT), can function as one-time MACs on each bit of <span class="math">x^{\\prime}</span> and can be used to enforce that <span class="math">x^{\\prime}=x</span> using efficient algebraic ZK proofs that take place outside the garbled circuit. In particular, immediately after the COTs, the prover commits to its input keys i.e. <span class="math">K_{i}^{x_{i}^{\\prime}}</span> for the <span class="math">i</span>th bit of <span class="math">x^{\\prime}</span>. When the GC is opened and both input keys <span class="math">K_{i}^{0},K_{i}^{1}</span> are opened, the prover can provide ZK proofs that <span class="math">K_{i}^{x_{i}^{\\prime}}=x_{i}K_{i}^{1}+(1-x_{i})K_{i}^{0}</span> if the commitment scheme provides efficient proofs of linear relations.</p>

    <p class="text-gray-300">The complete protocol description in the COT-hybrid model is given in Figure 3. We point out that steps 1, 6 and 13 are additions compared to the protocol of <em>[x10]</em>.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Theorem 3.1</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{G}</span> be a garbling scheme satisfying correctness and authenticity properties as defined in 2.4. Let <span class="math">\\mathsf{Com}</span> be a secure commitment scheme, and let the proofs <span class="math">PK</span> be implemented with a zero knowledge proof of knowledge. Then, the protocol <span class="math">\\Pi_{\\mathsf{Com},f}</span> in Figure 3 securely implements <span class="math">\\mathcal{F}_{\\mathsf{Com},f}</span> in the presence of malicious adversaries in the <span class="math">\\mathcal{F}_{COT}</span>-hybrid model.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">Corrupt Prover.</p>

    <p class="text-gray-300">The simulator works as follows: It uses the OT simulator to extract the prover’s input <span class="math">x^{\\prime}</span> to the OT. It then plays the role of the honest verifier in the rest of the simulation - it constructs the garbled circuit honestly and uses its input keys as verifier’s inputs to the COT functionality. The simulator then extracts the value <span class="math">Z^{\\prime}</span> committed to by the prover from the proofs of knowledge of opening in step 8. It also extracts prover’s committed input <span class="math">x</span> and the values <span class="math">K_{i}^{\\prime}</span> that prover committed to in the protocol, using the extractor for the ZK proof of knowledge in step 13. The simulator finally outputs <span class="math">x</span> and the opening extracted from the ZK proofs, iff all the following hold: <span class="math">x=x^{\\prime}</span>, <span class="math">f(x)=1,Z</span> is the one-key of the output wire, <span class="math">K_{i}^{\\prime}=K_{i}^{x_{i}}</span> for all <span class="math">i</span>, the commitment in step 8 is opened to <span class="math">Z</span>, and the ZK proofs of step 13 verifies. Note that in the ideal model the functionality will always output accept when the simulator sends this witness.</p>

    <p class="text-gray-300">We now prove that a corrupt prover’s view in the real protocol is indistinguishable from his view with the simulator via a series of intermediate games.</p>

    <p class="text-gray-300">Fig. 3. The Protocol  <span class="math">\\Pi_{\\mathrm{Com},f}</span></p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{G} = (\\mathsf{Gb},\\mathsf{En},\\mathsf{De},\\mathsf{Eval},\\mathsf{Ve})</span>  be a verifiable garbling scheme. Let  <span class="math">F</span>  be the following functionality: it takes as input  <span class="math">x</span> , and outputs  <span class="math">v</span>  such that  <span class="math">v = 1</span>  if  <span class="math">f(x) = 1</span>  and 0 otherwise. The prover has input  <span class="math">x</span> , the verifier is in possession of  <span class="math">C_x = \\mathsf{Com}(x)</span>  and both parties have as input the security parameter  <span class="math">\\kappa</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover commits to the bits of  <span class="math">x</span>  by sending bit-wise commitment to  <span class="math">x</span> :  <span class="math">C_i = \\operatorname{Com}(x_i), \\forall 1 \\leq i \\leq n</span> .</li>

      <li>The verifier constructs a garbled circuit for  <span class="math">F</span> .</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">(G C, e, d) \\leftarrow \\mathbf {G b} (1 ^ {\\kappa}, F)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover inputs his choice bits by sending  <span class="math">(i, x_i)</span>  for all  <span class="math">i \\in [n]</span>  to  <span class="math">\\mathcal{F}_{COT}</span> .</li>

      <li>The verifier inputs the wire labels corresponding to the prover's input by sending  <span class="math">(i, K_i^0, K_i^1)</span>  for all  <span class="math">i \\in [n]</span>  to  <span class="math">\\mathcal{F}_{COT}</span> .</li>

      <li><span class="math">\\mathcal{F}_{COT}</span>  outputs  <span class="math">K_{i}^{\\prime}</span>  for all  <span class="math">i\\in [n]</span>  to the prover where  <span class="math">K_{i}^{\\prime} = K_{i}^{x_{i}}</span></li>

      <li>The prover commits to the received input wire labels by sending  <span class="math">C_{K_i} = \\mathsf{Com}(K_i&#x27;)</span>  for all  <span class="math">i</span> .</li>

      <li>The prover evaluates the garbled circuit</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">Z \\leftarrow \\operatorname {E v a l} \\left(G C, \\left\\{K _ {i} ^ {\\prime} \\right\\} _ {i \\in [ n ]}\\right)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prover commits to the garbled output  <span class="math">Z</span>  by sending  <span class="math">\\operatorname{Com}(Z)</span>  to the verifier and proves knowledge of opening.</li>

      <li>Verifier sends open to  <span class="math">\\mathcal{F}_{COT}</span> .</li>

      <li><span class="math">\\mathcal{F}_{COT}</span>  sends  <span class="math">(K_i^0, K_i^1)</span>  to the prover for all  <span class="math">i \\in [n]</span> .</li>

      <li>Prover verifies that the correct circuit was garbled by running  <span class="math">\\mathsf{Ve}(GC, \\{K_i^0, K_i^1\\}_{i \\in [n]})</span> . If the output is not accept, the prover terminates. Otherwise if  <span class="math">\\mathsf{Ve}</span>  outputs accept, he opens the commitment to the output  <span class="math">Z</span>  by sending  <span class="math">Z</span>  and the randomness used in  <span class="math">\\mathsf{Com}(Z)</span> .</li>

      <li>Verifier checks that the opening is correct and that  <span class="math">\\mathsf{De}(d,Z) = 1</span> . If the opening is not correct or if  <span class="math">\\mathsf{De}(d,Z)\\neq 1</span> , the verifier outputs reject and terminates.</li>

      <li>If the verifier did not terminate, the prover and the verifier engage in a Zero-knowledge protocol to prove the following:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{PK}\\{(x_i,K_i&#x27;,r,R):C_i = \\mathsf{Com}(x_i)\\wedge C_{K_i} = \\mathsf{Com}(K_i&#x27;)\\wedge K_i&#x27; = x_iK_i^1 +(1 - x_i)K_i^0\\}</span> ,  <span class="math">\\forall 1\\leq i\\leq n</span></li>

      <li><span class="math">\\mathsf{PK}\\{(x,x_1,\\dots ,x_n,r,r_1,\\dots r_n):C_x = \\mathsf{Com}(x)\\wedge C_i = \\mathsf{Com}(x_i)\\wedge x = \\sum 2^ix_i\\}</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the zero-knowledge proof verifies, the verifier outputs accept.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game Ideal: This is the interaction of the corrupt prover with the simulator and functionality as described above.</li>

      <li>Game  <span class="math">G_0</span> : This is the interaction of the corrupt prover with the simulator as described above, with the exception that instead of the simulator sending  <span class="math">x</span>  and the opening to  <span class="math">F</span> , which outputs accept iff  <span class="math">f(x) = 1</span> , the game will output accept iff  <span class="math">f(x&#x27;) = 1</span>  for the  <span class="math">x&#x27;</span>  extracted from the OT (and all the other conditions listed hold). Since one of the conditions checks  <span class="math">x = x&#x27;</span> , this is identical.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game G_{1}: This game, behaves exactly as in G_{0} except for a slight change in the accept condition. It outputs accept if <span class="math">f(x^{\\prime})=1</span> and <span class="math">K_{i}^{\\prime}=K_{i}^{x_{i}}</span> for all <span class="math">i</span> and <span class="math">Z</span> is the one-key of the output wire and the commitment in step 8 is correctly opened to <span class="math">Z</span>, and all the ZK proofs verify (i.e. no <span class="math">x=x^{\\prime}</span> check).</li>

    </ul>

    <p class="text-gray-300">Indistinguishability:</p>

    <p class="text-gray-300">Define the event Bad as the event that <span class="math">x\\neq x^{\\prime},f(x^{\\prime})=1,Z</span> is the one-key of the output wire, <span class="math">K_{i}^{\\prime}=K_{i}^{x_{i}}</span> for all <span class="math">i</span>, and the opening to <span class="math">Z</span> is correct and the ZK proofs of step 13 verify.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Observe that G_{0} is identical to G_{1} conditioned on <span class="math">\\overline{\\textsf{Bad}}</span>. We now argue that <span class="math">\\Pr[\\textsf{Bad}]</span> is negligible, by observing that an adversary who makes us reject G_{0} but accept in G_{1}, can only succeed with probability <span class="math">1/2^{s}</span> where <span class="math">s</span> is a statistical security parameter, given the COT hybrid model. Without loss of generality lets assume the <span class="math">i</span>th bit of <span class="math">x</span> is <span class="math">0</span> and <span class="math">i</span>th bit of <span class="math">x^{\\prime}</span> is <span class="math">1</span>. Then, the probability of the adversary guessing <span class="math">K_{i}^{0}</span> given only <span class="math">K_{i}^{1}</span> is less than $1/2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K_{i}^{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Note that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K_{i}^{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the computational security parameter, which is </span>128<span class="math"> bits for an AES key. But without loss of security we can used a truncated </span>K_{i}^{0}<span class="math"> (to its least significant </span>s$ bits) in the ZK proofs of step 13.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Hence Games G_{0} and G_{1} are indistinguishable except with negligible probability in <span class="math">s</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game G_{2}: This game behaves as in G_{1} except for another change in the accept condition. We accept if <span class="math">f(x^{\\prime})=1</span> and ZK proofs of step 13 verifies and <span class="math">Z</span> is the one-key of the output wire, and the commitment in step 8 is correctly opened to <span class="math">Z</span> (i.e. no <span class="math">K_{i}^{\\prime}=K_{i}^{x_{i}}</span> check).</li>

    </ul>

    <p class="text-gray-300">If an adversary can distinguish between Games G_{1} and G_{2}, we can break the <em>soundness of the ZK proof</em> of step 13. Therefore, G_{1} and G_{2} are indistinguishable.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game G_{3}: This game behaves as in G_{2} except for a small change in accept condition. We accept if ZK proofs of step 13 verifies and <span class="math">Z</span> is the one-key of the output wire, and the commitment in step 8 is correctly opened to <span class="math">Z</span> (i.e. no <span class="math">f(x^{\\prime})=1</span> check).</li>

    </ul>

    <p class="text-gray-300">Games G_{2} and G_{3} are identical, except when the following event occurs: <span class="math">f(x^{\\prime})\\neq 1</span> and ZK proof of step 13 passes, and <span class="math">Z</span> is the one-key of the output wire. When this event occurs, we accept in G_{3} and rejects in G_{2}. We now argue that the probability of this event is negligible. For the sake of contradiction, assume the prover’s input to OT is <span class="math">x^{\\prime}</span> such that <span class="math">f(x^{\\prime})\\neq 1</span>, but the value committed to is the correct one-key <span class="math">Z</span> for the output wire. We can use such a prover to break the authenticity of the garbling scheme (See definition 2).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game G_{4}: This game behaves as in G_{3} except for the accept condition. We accept if the ZK proofs of step 13 verifies and the the commitment in step 8 opens correctly (i.e. no check that it is the same as extracted <span class="math">Z</span>).</li>

    </ul>

    <p class="text-gray-300">An adversary who can distinguish between G_{3} and G_{4} can be used to violate the binding property of the commitment scheme.</p>

    <p class="text-gray-300">G_{4} is identical to the real world game with an honest verifier.</p>

    <p class="text-gray-300">Corrupt Verifier. The simulator commits to bits of a random value. It also uses a random value as prover’s inputs to the COT, and receives the verifier’s inputs to the COT functionality <span class="math">(K_{i}^{0},K_{i}^{1})</span> for all <span class="math">i</span>, i.e. the input keys to the verifier <span class="math">GC</span>. The simulator then commits to the keys corresponding to the random input it used in the OTs.</p>

    <p class="text-gray-300">It then runs <span class="math">\\mathsf{Ve}(GC,(K_{i}^{0},K_{i}^{1}),f)</span> to either obtain reject, or the decoding information <span class="math">d</span>. If the output is reject it commits to a dummy value, else it commits to the one-key for the output wire, denoted by <span class="math">Z</span>.</p>

    <p class="text-gray-300">It then receives the ”open” message from the verifier. If <span class="math">\\mathsf{Ve}</span> had not output reject earlier, the simulator opens the commitment to <span class="math">Z</span> and uses the simulator for the ZK proof to simulate the proofs of step 13. Otherwise, the simulator aborts.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game <span class="math">\\mathsf{G}_{0}</span>: This is the interaction of the corrupt verifier with the simulator as described above.</li>

      <li>Game <span class="math">\\mathsf{G}_{1}</span>: Is similar to game <span class="math">\\mathsf{G}_{0}</span> except that the real input <span class="math">x</span> of prover is committed to.</li>

    </ul>

    <p class="text-gray-300">The two games are indistinguishable due to the hiding property of the commitment scheme.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game <span class="math">\\mathsf{G}_{2}</span>: Is similar to <span class="math">\\mathsf{G}_{1}</span> except that instead of computing <span class="math">Z</span> by running <span class="math">\\mathsf{Ve}</span>, we run <span class="math">\\mathsf{Eval}(GC,K_{i}^{x_{i}})</span> to compute and commit to <span class="math">Z</span>.</li>

    </ul>

    <p class="text-gray-300">The two games are indistinguishable due to the second condition in the correctness property of the garbling scheme. Note that we are also implicitly using the committing OT property (the protocol described in the COT hybrid model) as the keys extracted in the OTs and what the functionality sends to the honest prover are the same.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game <span class="math">\\mathsf{G}_{3}</span>: Is similar to <span class="math">\\mathsf{G}_{2}</span> except that the honest input <span class="math">x</span> of the prover is used in the OTs.</li>

    </ul>

    <p class="text-gray-300">The two games are identical in the OT hybrid model.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game <span class="math">\\mathsf{G}_{4}</span>: Is similar to <span class="math">\\mathsf{G}_{3}</span> except that the simulator commits to inputs keys associated with the real input <span class="math">x</span>.</li>

    </ul>

    <p class="text-gray-300">The two games are identical due to the hiding property of the commitment scheme.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game <span class="math">\\mathsf{G}_{5}</span>: Is similar to <span class="math">\\mathsf{G}_{4}</span> except that in step 13, the simulator performs the proofs, honestly.</li>

    </ul>

    <p class="text-gray-300">The two games are indistinguishable due to zero-knowledge property of the ZK proof.</p>

    <p class="text-gray-300">Note that <span class="math">\\mathsf{G}_{5}</span> is the real game with the honest prover.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">3.2 Second Instantiation</h3>

    <p class="text-gray-300">We now give an alternative construction that implements the functionality in Figure 2. In particular, we avoid the bit-wise commitments to each bit of <span class="math">x_{i}</span>, and the associated bit-wise ZK proofs, and hence require fewer public-key operations (exponentiations) in the construction. On the other hand, the garbled circuit is augmented and hence a larger number of symmetric-key operations are needed.</p>

    <p class="text-gray-300">The idea is as follows. In order to ensure that the prover uses the same input <span class="math">x</span> in the GC, we have the circuit not only compute <span class="math">f(x)</span> but also a one-time MAC of <span class="math">x</span>, i.e. <span class="math">t=ax+b</span> for random <span class="math">a</span> and <span class="math">b</span> of the verifier’s choice. <span class="math">a</span> and <span class="math">b</span> are initially unknown to the prover, but are opened along with the <span class="math">GC</span> after the prover has committed to <span class="math">t</span>. Given <span class="math">a</span> and <span class="math">b</span>, the prover then provides a ZK proof that <span class="math">\\mathsf{Com}(t)</span> is indeed the one-time MAC of <span class="math">x</span> (using efficient proofs of linear relations). We note that the <span class="math">t=ax+b</span> operation performed in the circuit is on integers.</p>

    <p class="text-gray-300">We note that our construction deviates from the standard construction of GC-based ZK where the verifier has no input, and privacy-free garbling is sufficient. In particular, we do invoke the privacy property of the garbling scheme in our construction to ensure that the prover does not learn <span class="math">a</span> and <span class="math">b</span>, until the opening stage.</p>

    <p class="text-gray-300">The complete protocol description in the COT-hybrid model is given in Figure 4.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Theorem 2</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{G}</span> be a garbling scheme satisfying correctness, authenticity, and privacy properties as defined in section 2.4. Let <span class="math">\\mathsf{Com}</span> be a secure commitment scheme, and let the proofs <span class="math">PK</span> be implemented with a zero knowledge proof of knowledge. Then, the protocol <span class="math">\\Pi_{\\mathsf{MAC},f}</span> in figure 4 securely implements <span class="math">\\mathcal{F}_{\\mathsf{Com},f}</span> in the presence of malicious adversaries in the <span class="math">\\mathcal{F}_{COT}</span>-hybrid model.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">Corrupt Prover.</p>

    <p class="text-gray-300">The simulator works as follows: It uses the OT simulator to extract the prover’s input <span class="math">x^{\\prime}</span> to the OT. It then plays the role of the honest verifier in the rest of the simulation - it chooses <span class="math">a,b</span> randomly as the honest verifier would, constructs the garbled circuit honestly and uses its input keys as verifier’s inputs to the COT functionality. The simulator then extracts the value <span class="math">Z^{\\prime}</span> committed to by the prover from the proofs of knowledge of opening in step 8. It also extracts prover’s committed input <span class="math">x</span> and the tag <span class="math">t^{\\prime}</span> that the prover committed to in the protocol, using the extractor for the ZK proof of knowledge in step 16. The simulator finally outputs <span class="math">x</span> and the opening extracted from the ZK proofs, iff all the following hold: <span class="math">x=x^{\\prime}</span>, <span class="math">f(x)=1,Z</span> is the one-key of the output wire, <span class="math">t^{\\prime}=ax+b</span>, the commitment in step 8 is opened to <span class="math">Z</span>, and the ZK proof of step 16 verifies. Note that in the ideal model the functionality will always output accept when the simulator sends this witness.</p>

    <p class="text-gray-300">We now prove that a corrupt prover’s view in the real protocol is indistinguishable from his view with the simulator by a series of intermediate games.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game Ideal: This is the interaction of the corrupt prover with the simulator and functionality as described above.</li>

      <li>Game <span class="math">\\mathsf{G}_{0}</span>: This is the interaction of the corrupt prover with the simulator as described above, with the exception that instead of the simulator sending x and the opening to F, which outputs accept iff f(x)=1, the game will output accept iff <span class="math">f(x^{\\prime})=1</span> for the <span class="math">x^{\\prime}</span> extracted from the OT (and all the other conditions listed hold). Since one of the conditions checks <span class="math">x=x^{\\prime}</span>, this is identical.</li>

      <li>Game <span class="math">\\mathsf{G}_{1}</span>: In this game, the simulator behaves exactly as in <span class="math">G_{0}</span> except that it does not check the <span class="math">x=x^{\\prime}</span> condition.</li>

    </ul>

    <p class="text-gray-300">Define the event <span class="math">\\mathsf{Bad}</span> as the event that <span class="math">x\\neq x^{\\prime}</span> but <span class="math">t=ax+b</span>. Observe that <span class="math">\\mathsf{G}_{0}</span> is identical to <span class="math">\\mathsf{G}_{1}</span> conditioned on <span class="math">\\overline{\\mathsf{Bad}}</span>. We argue that <span class="math">\\Pr[\\mathsf{Bad}]</span> is negligible due to the unforgeability property of the one-time MAC, the hiding property of the commitment scheme, and the privacy of the garbled circuit.</p>

    <p class="text-gray-300">Consider a game where we run as in <span class="math">\\mathsf{G}_{1}</span> but stop after step 10, and look at the probability that in this game <span class="math">t^{\\prime}=ax+b</span> but <span class="math">x\\neq x^{\\prime}</span>; if <span class="math">\\Pr[\\mathsf{Bad}]</span> is nonnegligible, this will be nonnegligible as well. Now, by the privacy of the garbled circuit, this is indistinguishable from a game where the verifier computes a tag <span class="math">t</span> on <span class="math">x^{\\prime}</span>, and then constructs <span class="math">(GC,e,d)</span> using the privacy simulator: <span class="math">\\mathcal{S}(F,(t,1))</span>. Similarly, by the hiding of the commitment scheme this is still indistinguishable from a game where</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the verifier commits to random values instead of <span class="math">a,b</span>. But if in this final game we get <span class="math">t^{\\prime}=ax+b</span> and <span class="math">x\\neq x^{\\prime}</span> with non-negligible probability, then we can break the unforgeability of the MAC. The probability of forgery is bounded by $1/2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, and hence exponentially small in the statistical security parameter </span>s=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game G_{2}: In this game, the simulator behaves as in G_{1} except that it does not check the condition <span class="math">t=ax+b</span>.</li>

    </ul>

    <p class="text-gray-300">If an adversary can distinguish between Games G_{2} and G_{1}, we can break the soundness of the ZK proof of step 16.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game G_{3}: In this game, the simulator behaves as in G_{2} except that we do not check the condition <span class="math">f(x^{\\prime})=1</span>.</li>

    </ul>

    <p class="text-gray-300">Games G_{2} and G_{3} are identical, except when the following event occurs: <span class="math">f(x^{\\prime})\\neq 1</span> and ZK proof of tag verifies and <span class="math">Z</span> is the one-key of the output wire. We now argue that the probability of this event is negligible. For the sake of contradiction, assume the prover’s input to OT is <span class="math">x^{\\prime}</span> such that <span class="math">f(x^{\\prime})\\neq 1</span>, but the value committed to is the correct one-key <span class="math">Z</span> for the output wire. We can use such a prover to break the authenticity of the garbling scheme (See definition 2).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game G_{4}: In this game, the simulator behaves as in G_{3} except for the accept condition. The simulator accepts if the ZK proofs of step 16 verifies and the commitment in step 8 opens correctly (i.e. no check that it is the same as extracted <span class="math">Z</span>).</li>

    </ul>

    <p class="text-gray-300">An adversary who can distinguish between G_{4} and G_{3} can be used to violate the binding property of the commitment scheme.</p>

    <p class="text-gray-300">G_{4} is identical to the real world game with an honest verifier.</p>

    <p class="text-gray-300">Corrupt Verifier. The simulator extracts <span class="math">a</span> and <span class="math">b</span> from the proofs of knowledge of their openings by verifier. It uses a random value as prover’s inputs to the COT, and receives the verifier’s inputs to the COT functionality <span class="math">(K^{0}_{i},K^{1}_{i})</span> for all <span class="math">i</span>, i.e. the input keys to the verifier <span class="math">GC</span>.</p>

    <p class="text-gray-300">It then runs <span class="math">\\mathsf{Ve}(GC,(K^{0}_{i},K^{1}_{i}),F)</span> (and checks against the extracted <span class="math">a,b</span>) to either obtain reject, or the decoding information <span class="math">d</span>. If the output is reject it commits to dummy values for <span class="math">Z</span> and <span class="math">t</span>, else it commits to the one-key for the output wire denoted by <span class="math">Z</span>, and dummy <span class="math">t</span>.</p>

    <p class="text-gray-300">The simulator receives the openings of <span class="math">\\mathsf{Com}(a)</span> and <span class="math">\\mathsf{Com}(b)</span>. If the openings are not what it extracted earlier, or if Ve had output reject earlier, it aborts. Else, the simulator opens the commitment to <span class="math">Z</span> and uses the simulator for the ZK proof to simulate the proofs of step 16.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game G_{0}: This is the interaction of the corrupt verifier with the simulator as described above.</li>

      <li>Game G_{1}: Is similar to game G_{0} except that <span class="math">t=ax+b</span> for the real input <span class="math">x</span> of prover is committed to.</li>

    </ul>

    <p class="text-gray-300">The two games are indistinguishable due to the hiding property of the commitment scheme.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game G_{2}: Is similar to G_{1} except that instead of computing <span class="math">Z</span> and <span class="math">t</span> by running Ve, we run <span class="math">\\mathsf{Eval}(GC,K^{x_{i}}_{i})</span> to compute and commit to <span class="math">Z</span> and <span class="math">t</span>.</li>

    </ul>

    <p class="text-gray-300">The two games are indistinguishable due to the second condition in the correctness property of the garbling scheme, and binding property of commitments <span class="math">\\mathsf{Com}(a)</span></p>

    <p class="text-gray-300">and <span class="math">\\mathsf{Com}(b)</span>. Note that we are also implicitly using the committing OT property (the protocol described in the COT hybrid model) as the keys extracted in the OTs and what the functionality sends to the honest prover are the same.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game <span class="math">\\mathsf{G}_{3}</span>: Is similar to <span class="math">\\mathsf{G}_{2}</span> except that the honest input <span class="math">x</span> of the prover is used in the OTs.</li>

    </ul>

    <p class="text-gray-300">The two games are identical in the OT hybrid model.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game <span class="math">\\mathsf{G}_{4}</span>: Is similar to <span class="math">\\mathsf{G}_{3}</span> except that in step 13, the simulator performs the proofs honestly.</li>

    </ul>

    <p class="text-gray-300">The two games are indistinguishable due to zero-knowledge property of the ZK proof.</p>

    <p class="text-gray-300">Note that <span class="math">\\mathsf{G}_{4}</span> is the real game with the honest prover.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">3.3 Efficiency Comparison and Optimizations</h3>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Efficiency Comparison</h4>

    <p class="text-gray-300">In our first instantiation, in addition to the cost associated with the GC-based ZK, i.e. the oblivious transfer for <span class="math">x</span> and the cost of garbling <span class="math">f</span>, <span class="math">O(n)</span> exponentiations are necessary to commit to each bit of input <span class="math">x</span> and to perform the bitwise ZK proofs associated with them in the last step.</p>

    <p class="text-gray-300">In our second instantiation, the bitwise commitments/proofs are eliminated (i.e. only a constant number of exponentiations) but instead the circuit for <span class="math">ax+b</span> needs to be garbled which requires <span class="math">O(ns+s^{2})</span> additional symmetric-key operations when using textbook multiplication (we discuss range of values for <span class="math">s</span> shortly). Using Karatsuba’s multiplication algorithm <em>[x14]</em>, this can potentially be further reduced.</p>

    <p class="text-gray-300">The round complexity of both protocols is essentially the same as the GC-based ZK proof of <em>[x11]</em> (5 rounds), as the extra messages can be sent within the same rounds. (To simplify presentation, we used a separate step for each operation in our protocol description, but many of these can be combined.) A more round-efficient GC-based ZK proof would make our constructions more round efficient as well.</p>

    <p class="text-gray-300">The first instantiation requires more exponentiations which are significantly costlier than their symmetric-key counterpart, but the total number of symmetric-key operations in the second instantiation is higher. Hence, when <span class="math">n</span> is small, the first instantiation is likely more efficient, while when <span class="math">n</span> is larger, the second instantiation will be the better option. Furthermore, if bit-wise commitment to the input is already necessary as part of the bigger protocol (as is the case in some of our constructions), the first instantiation may be the better choice. In the case where a comparison circuit <span class="math">x&lt;q</span> is also computed, an additional <span class="math">O(n)</span> symmetric-key operations suffices.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">Optimizations</h4>

    <p class="text-gray-300">Next we review a few other optimizations that improve efficiency of our instantiations.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Reducing exponentiations. We consider the following optimization for the protocol <span class="math">\\Pi_{\\mathsf{Com},f}</span> in Fig. 3 which reduces the number of exponentiations necessary for the ZK proofs significantly. In step 6, the prover commits to the sum of the keys received instead of individually to each wire key. The prover sends <span class="math">\\mathsf{Com}(S)=\\mathsf{Com}\\left(\\sum_{i=1}^{n}K_{i}^{\\prime}\\right)</span> in step 6. We assume that the bit commitment scheme <span class="math">\\mathsf{Com}</span> is homomorphic, and each wire key <span class="math">K_{i}</span> is truncated to <span class="math">s</span> bits and interpreted as a group</li>

    </ul>

    <p class="text-gray-300">element. Now, in the zero knowledge proofs of step 13, the prover proves the following statements which can be performed with fewer exponentiations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{PK}\\{(x_{i},S,r,R):\\mathsf{Com}(x_{i})=g^{x_{i}}h^{r}\\wedge\\mathsf{Com}(S)=g^{S}h^{R}</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">\\wedge S=\\sum_{i=1}^{n}\\big{(}x_{i}K_{i}^{1}+(1-x_{i})K_{i}^{0}\\big{)}\\}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{PK}\\{(x,x_{1},\\cdots,x_{n},r,r_{1},\\cdots r_{n}):\\mathsf{Com}(x)=g^{x}h^{r}\\wedge\\mathsf{Com}(x_{i})=g^{x_{i}}h^{r_{i}}\\wedge x=g^{\\sum 2^{i}x_{i}}h^{r}\\}</span></li>

    </ul>

    <p class="text-gray-300">We can show that if the sum extracted by the simulator from the commitment in step 6 is not equal to the sum of keys corresponding to the input <span class="math">x^{\\prime}</span> extracted from COT, but the ZK proofs verify, then for some <span class="math">i</span>, the prover must have correctly guessed <span class="math">K_{i}^{b}</span> such that <span class="math">b\\neq x^{\\prime}_{i}</span>. The probability of this is negligible by the security of the COT protocol.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Privacy-free garbling. As discussed earlier, in <em>[x11]</em> it is observed that privacy-free garbling is sufficient for GC-based ZK proofs of non-algebraic statements. This improves the communication/computation cost of garbled circuits in our first instantiation by a factor of two. But as mentioned earlier, the same cannot be said about our second construction since the privacy property of garbling is required to hide <span class="math">a</span> and <span class="math">b</span> in the earlier stage of the construction.</li>

    </ul>

    <p class="text-gray-300">But we can think of bigger circuit as consisting of two smaller circuits: one computing the function <span class="math">f</span> and the other computing <span class="math">ax+b</span>. If we split the computation into two garbled circuits with shared OT, then we can use the privacy free garbling scheme of <em>[x11, x24]</em> for the first circuit as the verifier has no input, and use a standard garbling scheme for the <span class="math">ax+b</span> circuit.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Smaller multiplication circuit. For the one-time MAC in the second protocol, a small <span class="math">a</span> is sufficient for security - if the security (unforgeability) desired is <span class="math">2^{-s}</span>, it suffices for <span class="math">a</span> to be <span class="math">s</span> bits long. Hence, for a <span class="math">512</span>-bit input, a <span class="math">40-80</span>-bit <span class="math">a</span> is sufficient to compute <span class="math">ax+b</span> which reduces the size of the multiplication circuit significantly.</li>

    </ul>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">3.4 Secure computation on committed/signed inputs</h3>

    <p class="text-gray-300">In the protocols described above, we have shown how to commit to a value <span class="math">\\mathsf{Com}(x)</span> and then use a GC-based ZK proof to prove non-algebraic statements about <span class="math">x</span>.</p>

    <p class="text-gray-300">It is not hard to show that one can extend this approach, to a full-fledged secure two-party computation (2PC) of any function <span class="math">g(x,y)</span> where <span class="math">x</span> is the committed input of the prover. In particular, note that in the ZK proof, the prover feeds its input <span class="math">x</span> into the COTs in order to obtain its inputs keys to the GC of the ZK proof. In order to extend this to a secure 2PC based on garbled circuits, we let the prover play the role of the evaluator in a cut-and-choose 2PC based on garbled circuits, and use the same COT as above for the prover to obtain the garbled inputs for <span class="math">x</span> in the 2PC. This would ensure that the same <span class="math">x</span> that was used in the ZK proof is also used in the 2PC, and the ZK proof already ensures that this is the same input committed to in <span class="math">\\mathsf{Com}(x)</span>.</p>

    <p class="text-gray-300">A subtle point here is that we need to open the sender’s input to the COTs for the GC for the ZK but not for the GCs for the 2PC. This is supported by the committing OT of [S^{+}11] (also see the discussion on COTs in <em>[x22]</em>). It is interesting to explore the use of OT extension in such COTs where some sender inputs are opened while others are not.</p>

    <p class="text-gray-300">We emphasize that the GCs for the 2PC only garble the desired function <span class="math">g</span>, and hence the GC for the ZK proof is not part of any cut-and-choose. However, we note that the above technique is currently limited to the evaluator’s input since the OTs for evaluator’s input enable an almost-free check of equality of inputs in the 2PC and the ZK. Extending the ideas to both party’s inputs is an interesting future direction.</p>

    <p class="text-gray-300">This approach can be easily extended to prove other statements about <span class="math">x</span>, such as proof of knowledge of a signature on <span class="math">x</span> (hence signed-input 2PC) either using the techniques we give below in the case of RSA/DSA signatures, or using previous techniques to give a proof of knowledge of a CL signature<em>[x10]</em>.</p>

    <h2 id="sec-28" class="text-2xl font-bold">4 Building Blocks for Privacy-Preserving Signature Verification</h2>

    <p class="text-gray-300">We introduce three important building blocks for our privacy-preserving signature verification protocols. Two of them can be directly instantiated using our <span class="math">\\mathcal{F}_{\\mathsf{Com},f}</span> functionality introduced in section 3, while for the third one we provide a customized construction.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">4.1 Proving that a committed value is the hash of another committed value</h3>

    <p class="text-gray-300">Here, the goal is to commit to a message <span class="math">m</span> and its hash <span class="math">\\mathcal{H}(m)</span> and prove in zero-knowledge that one committed value is the hash of the other. We define the task in terms of an ideal functionality in Figure 5.</p>

    <p class="text-gray-300">Fig. 5. The ideal functionality <span class="math">\\mathcal{F}_{Hash}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier inputs <span class="math">\\mathsf{Com}(m),\\mathsf{Com}(M)</span> and the prover inputs the opening information <span class="math">(m,M)</span> and the randomness.</li>

      <li>If <span class="math">\\mathcal{H}(m)=M</span> and the openings to the commitments verify, output accept to the verifier.</li>

    </ul>

    <p class="text-gray-300">We now use the abstract functionality <span class="math">\\mathcal{F}_{\\mathsf{Com},f}</span> from Fig 2 with a commitment scheme <span class="math">\\mathsf{Com}_{h}</span> to instantiate a protocol that implements <span class="math">\\mathcal{F}_{Hash}</span>. Here, the input is <span class="math">x=(m,M=\\mathcal{H}(m))</span> and the <span class="math">\\mathsf{Com}_{h}</span> is defined as <span class="math">\\mathsf{Com}_{h}(x=(m,M))=(\\mathsf{Com}(m),\\mathsf{Com}(M))</span>. To commit to bits of <span class="math">x</span>, one can commit to bits of <span class="math">m</span> and <span class="math">M</span> individually. <span class="math">\\mathsf{Com}_{h}</span> inherits efficient proofs of linear relations from <span class="math">\\mathsf{Com}</span> as long as the proofs on <span class="math">m</span> and <span class="math">M</span> are performed separately. Given these, we show in Figure 6 how to implement <span class="math">\\mathcal{F}_{Hash}</span> by defining the right function <span class="math">f</span> for the ideal functionality <span class="math">\\mathcal{F}_{\\mathsf{Com},f}</span>.</p>

    <p class="text-gray-300">Fig. 6. The Protocol <span class="math">\\Pi_{Hash}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover commits to <span class="math">x=(m,M)</span> by sending <span class="math">\\mathsf{Com}_{h}(x)=\\mathsf{Com}(m),\\mathsf{Com}(M)</span> to the verifier.</li>

      <li>The prover and the verifier run <span class="math">\\Pi_{\\mathsf{Com},f}</span> where <span class="math">f</span> is the following functionality: <span class="math">f</span> takes <span class="math">m</span> and <span class="math">M</span> as inputs and outputs <span class="math">v</span> such that <span class="math">v=1</span> if <span class="math">\\mathcal{H}(m)=M</span> and <span class="math">0</span> otherwise.</li>

    </ol>

    <p class="text-gray-300">Theorem 3. The protocol  <span class="math">\\Pi_{Hash}</span>  in figure 6 securely implements  <span class="math">\\mathcal{F}_{Hash}</span> , given the ideal functionality  <span class="math">\\mathcal{F}_{\\mathrm{Com},f}</span> , in the presence of malicious adversaries.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The goal is to prove that the value committed to in different prime groups of size  <span class="math">p</span>  and  <span class="math">q</span>  are the same. We define the task in terms of an ideal functionality, defined in Figure 7. This can be achieved using standard techniques which involve using the integer commitment scheme by Damgard and Fujisaki [DF02] to prove properties about the discrete logarithms in  <span class="math">\\mathbb{Z}</span>  (instead of modulo the order of the group). This requires that the verifier choose an RSA modulus  <span class="math">\\widetilde{N}</span>  such that the factorization is unknown to the prover, and prove that it is chosen correctly in an initial set-up phase. The prover also has to compute exponentiations in an RSA group where the exponents are  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\widetilde{N}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\kappa$  bits long. Since the group order is hidden, chinese remaindering cannot be used to speed up the exponentiations, and therefore the approach is fairly expensive. We give a protocol that avoids the integer commitment technique.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 7. The ideal functionality  <span class="math">\\mathcal{F}_{Eq}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier inputs  <span class="math">\\mathsf{Com}_p(x), \\mathsf{Com}_q(y)</span>  and the prover inputs  <span class="math">(x, y)</span>  and the opening information.  <span class="math">p</span>  and  <span class="math">q</span>  are public primes and  <span class="math">q &amp;lt; p</span> .</li>

      <li>If  <span class="math">0 \\leq x &amp;lt; p, 0 \\leq y &amp;lt; p, x \\equiv y \\mod q</span> , and the openings to the commitments verify, output accept to the verifier.</li>

    </ul>

    <p class="text-gray-300">In Figure 8, we use the ideal functionality  <span class="math">\\mathcal{F}_{\\mathrm{Com},f}</span>  from Fig 2 with a commitment scheme  <span class="math">\\mathrm{Com}_{pq}</span>  to instantiate a protocol that implements  <span class="math">\\mathcal{F}_{Eq}</span> . The scheme is defined as  <span class="math">\\mathrm{Com}_{pq}(x) = (\\mathrm{Com}_p(x),\\mathrm{Com}_q(x))</span> , where it is assumed that  <span class="math">\\mathrm{Com}_p</span>  and  <span class="math">\\mathrm{Com}_q</span>  allow for proving linear relationships among committed values.</p>

    <p class="text-gray-300">Fig. 8. The Protocol  <span class="math">\\Pi_{Eq}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover commits to  <span class="math">x</span>  and  <span class="math">y</span>  by sending  <span class="math">\\mathsf{Com}_p(x), \\mathsf{Com}_q(y)</span>  to the verifier.</li>

      <li>The prover and the verifier run  <span class="math">\\Pi_{\\mathrm{Com},f}</span>  where  <span class="math">f</span>  is the following functionality:  <span class="math">f</span>  takes  <span class="math">x</span>  and checks that it is upper bounded by  <span class="math">p</span>  and outputs  <span class="math">v</span>  such that  <span class="math">v = 1</span>  if  <span class="math">x \\leq p</span>  and 0 otherwise.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">\\mathbb{G}_1 = \\langle G_1\\rangle</span>  and  <span class="math">\\mathbb{G}_2 = \\langle G_2\\rangle</span>  be two groups of order  <span class="math">p</span>  and  <span class="math">q</span>  respectively with  $q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p - 1<span class="math">  and let  </span>g\\in \\mathbb{G}_2<span class="math">  be an element of order  </span>q<span class="math"> . Given  </span>y_{1} = G_{1}^{g^{x}}H_{1}^{R_{1}}<span class="math">  and  </span>y_{2} = G_{2}^{x}H_{2}^{R_{2}}<span class="math"> , we want to prove that the discrete logarithm w.r.t to base  </span>g<span class="math">  of the value committed to in  </span>y_{1}<span class="math">  is equal to the value committed to in  </span>y_{2}<span class="math"> . Let  </span>k$  be a security parameter. Following</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">standard notation, we denote the protocol by <span class="math">\\mathsf{PK}\\{(x,R_1,R_2):y_1 = G_1^{g^x}H_1^{R_1}\\wedge y_2 = G_2^x H_2^{R_2}\\}</span>. The technique of our protocol is similar to [Sta96], [CS97a], and is a variant of [MGGR13]. Our protocol is only honest verifier zero-knowledge. This HVZK protocol can be compiled into a full zero-knowledge proof of knowledge in the auxiliary string model using the technique of [Dam00].</p>

    <p class="text-gray-300">Fig. 9. PK<span class="math">\\{(x,R_1,R_2):y_1 = G_1^{g^x}H_1^{R_1}\\wedge y_2 = G_2^x H_2^{R_2}\\}</span></p>

    <p class="text-gray-300">Given <span class="math">y_{1} = G_{1}^{g^{x}}H_{1}^{R_{1}}</span> and <span class="math">y_{2} = G_{2}^{x}H_{2}^{R_{2}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover computes the following <span class="math">2k</span> values: <span class="math">u_{i} = G_{1}^{q^{\\alpha_{i}}}H_{1}^{\\beta_{i}}</span> and <span class="math">v_{i} = G_{2}^{\\alpha_{i}}H_{2}^{\\gamma_{i}}</span> for <span class="math">1\\leq i\\leq k</span>, for randomly chosen <span class="math">\\alpha_{i},\\gamma_{i}\\in \\mathbb{Z}_{q}</span> and <span class="math">\\beta_{i}\\in \\mathbb{Z}_{p}</span>, and sends <span class="math">u_{i},v_{i}</span> to the verifier.</li>

      <li>The verifier chooses a random string <span class="math">c</span> of length <span class="math">k</span> as the challenge, and sends it to the prover.</li>

      <li>For a challenge string <span class="math">c = c_{1}\\ldots c_{k}</span>, compute and send the tuple <span class="math">(r_i,s_i,t_i)</span></li>

    </ol>

    <p class="text-gray-300">If <span class="math">c_{i} = 0</span></p>

    <div class="my-4 text-center"><span class="math-block">r _ {i} = \\alpha_ {i}, s _ {i} = \\beta_ {i}, t _ {i} = \\gamma_ {i}</span></div>

    <p class="text-gray-300">If <span class="math">c_{i} = 1</span></p>

    <div class="my-4 text-center"><span class="math-block">r _ {i} = \\alpha_ {i} - x \\quad (\\mathrm {m o d} q), s _ {i} = \\beta_ {i} - R _ {1} g ^ {r _ {i}} \\quad (\\mathrm {m o d} p), t _ {i} = \\gamma_ {i} - R _ {2} \\quad (\\mathrm {m o d} q)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verification:</li>

    </ol>

    <p class="text-gray-300">If <span class="math">c_{i} = 0</span>, check whether <span class="math">u_{i} = G_{1}^{q^{r_{i}}}H_{1}^{s_{i}}</span> and <span class="math">v_{i} = G_{2}^{r_{i}}H_{2}^{t_{i}}</span></p>

    <p class="text-gray-300">If <span class="math">c_{i} = 1</span>, check if <span class="math">u_{i} = y_{1}^{q^{r_{i}}}H_{1}^{s_{i}}</span> and <span class="math">v_{i} = y_{2}G_{2}^{r_{i}}H_{2}^{t_{i}}</span>. The verifier accepts if Verification succeeds for all <span class="math">i</span>.</p>

    <p class="text-gray-300">We will show that the protocol in Figure 9 is correct, has a soundness error of <span class="math">1 / 2^{k}</span>, and is honest verifier zero knowledge.</p>

    <p class="text-gray-300">Proof. - Completeness: If the prover and the verifier behave honestly, it is easy to see that verification conditions hold.</p>

    <p class="text-gray-300">If <span class="math">c_{i} = 0</span>:</p>

    <div class="my-4 text-center"><span class="math-block">G _ {1} ^ {g _ {i} ^ {r}} H _ {1} ^ {s _ {i}} = G _ {1} ^ {q ^ {\\alpha_ {i}}} H _ {1} ^ {\\beta_ {i}} = u _ {i} \\text {a n d} G _ {2} ^ {r _ {i}} H _ {2} ^ {t _ {i}} = G _ {2} ^ {\\alpha_ {i}} H _ {2} ^ {\\gamma_ {i}} = v _ {i}</span></div>

    <p class="text-gray-300">If <span class="math">c_{i} = 1</span>:</p>

    <div class="my-4 text-center"><span class="math-block">y _ {1} ^ {q ^ {r _ {i}}} H _ {1} ^ {s _ {i}} = \\left(G _ {1} ^ {g ^ {s}}\\right) ^ {g ^ {r _ {i}}} \\left(H _ {1} ^ {R _ {1}}\\right) ^ {g ^ {r _ {i}}} H _ {1} ^ {s _ {i}} = G _ {1} ^ {q ^ {\\alpha_ {i}}} H _ {1} ^ {\\beta_ {i}} = u _ {i} \\text {a n d}</span></div>

    <div class="my-4 text-center"><span class="math-block">y _ {2} G _ {2} ^ {r _ {i}} H _ {2} ^ {t _ {i}} = G _ {2} ^ {x} H _ {2} ^ {R _ {2}} G _ {2} ^ {r _ {i}} H _ {2} ^ {t _ {i}} = v _ {i}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness: We show an extractor that computes <span class="math">x, R_1, R_2</span> given two different accepting views with same commitments but different challenge strings. Say, we have two accepting views for challenges <span class="math">c</span> and <span class="math">\\hat{c} \\neq c</span>. Without loss of generality, let us assume that they differ in the <span class="math">j</span>th position, and <span class="math">c_j = 0</span>. We have,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">u _ {j} = G _ {1} ^ {q ^ {r _ {j}}} H _ {1} ^ {s _ {j}} = y _ {1} ^ {q ^ {c _ {j}}} H _ {1} ^ {\\hat {s} _ {j}}</span></div>

    <div class="my-4 text-center"><span class="math-block">G _ {1} ^ {g ^ {r _ {j}}} H _ {1} ^ {s _ {j}} = G _ {1} ^ {g ^ {s} g ^ {\\hat {r _ {j}}}} H _ {1} ^ {R g ^ {\\hat {r _ {j}}} + \\hat {s _ {j}}}</span></div>

    <div class="my-4 text-center"><span class="math-block">g ^ {x} = g ^ {r _ {j} - r _ {j}}</span></div>

    <p class="text-gray-300">We can compute (in  <span class="math">\\mathbb{Z}_q</span> ),</p>

    <div class="my-4 text-center"><span class="math-block">x = r _ {j} - \\hat {r _ {j}}</span></div>

    <p class="text-gray-300">We have,</p>

    <div class="my-4 text-center"><span class="math-block">s _ {j} = R _ {1} g ^ {\\hat {r _ {j}}} + \\hat {s _ {j}}</span></div>

    <p class="text-gray-300">and thus,</p>

    <div class="my-4 text-center"><span class="math-block">R _ {1} = \\frac {s _ {j} - \\hat {s _ {j}}}{g ^ {\\hat {r _ {j}}}}</span></div>

    <p class="text-gray-300">We also have</p>

    <div class="my-4 text-center"><span class="math-block">v _ {j} = G _ {2} ^ {r _ {j}} H _ {2} ^ {t _ {j}} = y _ {2} G _ {2} ^ {r _ {j}} H _ {2} ^ {\\hat {t _ {j}}}</span></div>

    <div class="my-4 text-center"><span class="math-block">G _ {2} ^ {r _ {j}} H _ {2} ^ {t _ {j}} = G _ {2} ^ {x + r _ {j}} H _ {2} ^ {\\hat {t _ {j}} + R _ {2}}</span></div>

    <p class="text-gray-300">and thus,</p>

    <div class="my-4 text-center"><span class="math-block">R _ {2} = t _ {j} - \\hat {t _ {j}}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Honest Verifier Zero Knowledge</strong>: We show a simulator such that the output of the simulator is statistically indistinguishable from the transcript of the protocol with a prover. The simulator on input  <span class="math">c</span> , randomly chooses  <span class="math">\\alpha_{i} = r_{i} \\in \\mathbb{Z}_{q}, \\beta_{i} = s_{i} \\in \\mathbb{Z}_{p}, \\gamma_{i} = t_{i} \\in \\mathbb{Z}_{q}</span>  and computes for  <span class="math">1 \\leq i \\leq k</span> :</li>

    </ul>

    <p class="text-gray-300">If  <span class="math">c_{i} = 0</span></p>

    <div class="my-4 text-center"><span class="math-block">u _ {i} = G _ {1} ^ {g ^ {r _ {i}}} H _ {1} ^ {s _ {i}} \\text { and } v _ {i} = G _ {2} ^ {r _ {i}} H _ {2} ^ {t _ {i}}</span></div>

    <p class="text-gray-300">if  <span class="math">c_{i} = 1</span></p>

    <div class="my-4 text-center"><span class="math-block">u _ {i} = y _ {1} ^ {g ^ {r _ {i}}} H _ {1} ^ {s _ {i}} \\text { and } v _ {i} = y _ {2} G _ {2} ^ {r _ {i}} H _ {2} ^ {t _ {i}}</span></div>

    <h2 id="sec-32" class="text-2xl font-bold">5 Privacy-Preserving FDH-RSA Signature Verification</h2>

    <p class="text-gray-300"><strong>The FDH-RSA Scheme.</strong> The Full Domain Hash RSA signature scheme  <span class="math">\\mathsf{FDH} = (\\mathsf{KeyGen}, \\mathsf{Sign}, \\mathsf{Verify})</span>  is defined as follows [BR93]. The KeyGen algorithm on input the security parameter  <span class="math">k</span> , selects two  <span class="math">k/2</span> -bit primes  <span class="math">p</span>  and  <span class="math">q</span>  and computes the modulus  <span class="math">N = pq</span> . It then chooses an exponent  <span class="math">e \\in \\mathbb{Z}_{\\phi(N)}^{<em>}</span> , and computes  <span class="math">d</span>  such that  <span class="math">ed = 1 \\mod \\phi(N)</span> . Return  <span class="math">(pk, sk)</span> , where  <span class="math">pk = (N, e)</span>  and  <span class="math">sk = (N, d)</span> . The signature generation and verification are as follows and use a hash function  <span class="math">\\mathcal{H}: \\{0, 1\\} \\to \\mathbb{Z}_N^</em></span> .</p>

    <p class="text-gray-300">Sign <span class="math">_{N,d}(M)</span></p>

    <p class="text-gray-300"><span class="math">x = \\mathcal{H}(M)</span></p>

    <p class="text-gray-300"><span class="math">\\sigma = x^{d} \\mod N</span></p>

    <p class="text-gray-300">return  <span class="math">\\sigma</span></p>

    <p class="text-gray-300">Verify <span class="math">_{N,e}(M,\\sigma)</span></p>

    <p class="text-gray-300"><span class="math">y = \\sigma^{e} \\mod N</span></p>

    <p class="text-gray-300"><span class="math">y&#x27; = \\mathcal{H}(M)</span></p>

    <p class="text-gray-300">if  <span class="math">(y = y&#x27;)</span>  then return 1;</p>

    <p class="text-gray-300">else return 0;</p>

    <p class="text-gray-300">5.1 Proof of Knowledge of RSA Signatures</p>

    <p class="text-gray-300">Given <span class="math">\\mathsf{Com}_{N}(m)</span>, a commitment to <span class="math">m</span> in a group of order <span class="math">N</span>, the following protocol is a zero knowledge proof of knowledge of a valid RSA signature on <span class="math">m</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover has input <span class="math">(m,\\sigma)</span> and the verifier is in possession of <span class="math">\\mathsf{Com}_{N}(m)=C_{1}=g^{m}h^{r_{1}}</span></li>

      <li>The prover commits to <span class="math">M=\\mathcal{H}(m)</span>, that is, <span class="math">M\\in\\mathbb{Z}_{N}</span>, compute <span class="math">\\mathsf{Com}_{N}(M)=C_{2}=g^{M}h^{r_{2}}</span>, for randomly chosen <span class="math">r_{2}\\in Z_{N}^{*}</span>. Send <span class="math">C_{2}</span> to the verifier and prove knowledge of opening.</li>

      <li>The prover and verifier engage in the protocol <span class="math">\\Pi_{Hash}</span> with inputs <span class="math">(m,M)</span> and <span class="math">(C_{1},C_{2})</span> respectively.</li>

      <li>The prover proves knowledge of <span class="math">e</span>-th root of a committed value( [CS97a]). Given <span class="math">y=C_{2}=g^{M}h^{r}</span>, prover proves knowledge of <span class="math">\\sigma</span>, such that, <span class="math">y=g^{\\sigma^{e}}h^{r}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover computes the following tuple:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(y_{1},\\cdots,y_{e-1})\\text{ where }y_{i}=g^{\\sigma^{i}}h^{r_{i}}</span></p>

    <p class="text-gray-300">for randomly chosen <span class="math">r_{i}\\in\\mathbb{Z}_{N}</span>, for <span class="math">i=1</span> to <span class="math">e-1</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover and the verifier run the following proof of knowledge:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{PK}\\{(\\alpha,(\\beta_{1},\\cdots,\\beta_{e})):y_{1}=g^{\\alpha}h^{\\beta_{1}}\\wedge y_{2}=y_{1}^{\\alpha}h^{\\beta_{2}}\\wedge\\cdots\\wedge y=y_{e-1}^{\\alpha}h^{\\beta_{e}}\\}</span></p>

    <p class="text-gray-300">When <span class="math">e</span> is one greater than a power of <span class="math">2</span>, we can employ optimizations like repeated squaring to prove knowledge of <span class="math">e</span>-th root. Given <span class="math">y=g^{\\sigma^{e}}h^{r}</span>, for <span class="math">e=2^{k}+1</span>, step 4 in the verification protocol can be now be realized as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover computes the following tuple:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(y_{0},y_{1},\\cdots,y_{k})\\text{ where }y_{i}=g^{\\sigma^{2^{i}}}h^{r_{i}}</span></p>

    <p class="text-gray-300">for randomly chosen <span class="math">r_{i}\\in\\mathbb{Z}_{N}</span>, for <span class="math">i=1</span> to <span class="math">k</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover and the verifier run the following proof of knowledge:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{PK}\\{(\\alpha,\\alpha_{1},\\cdots,\\alpha_{k},\\beta,\\beta_{0},\\cdots,\\beta_{k},R_{0},\\cdots,R_{k}):</span> <span class="math">y_{0}=g^{\\alpha}h^{\\beta}\\wedge y_{1}=y_{0}^{\\alpha}h^{\\beta_{0}}\\wedge y_{1}=g^{\\alpha_{1}}h^{R_{0}}\\wedge y_{2}=y_{1}^{\\alpha_{1}}h^{\\beta_{1}}</span> <span class="math">\\wedge y_{2}=g^{\\alpha_{2}}h^{R_{1}}\\cdots\\wedge y_{k}=y_{k-1}^{\\alpha_{k-1}}h^{\\beta_{k-1}}\\wedge y_{k}=g^{\\alpha_{k}}h^{R_{k-1}}\\wedge y=y_{k}^{\\alpha}h^{\\beta_{k}}\\}</span></p>

    <p class="text-gray-300">It might be possible to improve the efficiency for some <span class="math">e</span>’s by using addition chains for the integer <span class="math">e</span>. An addition chain for integer <span class="math">e</span> is an ascending sequence <span class="math">1=e_{0}&lt;e_{1}&lt;\\cdots e_{r}=e</span> such that for <span class="math">1\\leq i\\leq r</span>, we have <span class="math">e_{i}=e_{j}+e_{k}</span>. The prover, now, would have to provide only the <span class="math">y_{i}</span>’s for which <span class="math">i</span> is an element of the addition chain for <span class="math">e</span>. The relations among the <span class="math">y_{i}</span>’s will be sightly different, but can be proved in a similar way.</p>

    <p class="text-gray-300">The above verification protocol can also be adapted to support variants of RSA-based signatures, like the probabilistic signature scheme (PSS) from [BR96]. PSS is a probabilistic generalization of FDH which uses two hash functions and more complicated padding. We can instantiate protocol <span class="math">\\Pi_{\\mathsf{Com},f}</span> with an <span class="math">f</span> that verifies the additional checks of PSS to achieve privacy preserving verification of a PSS signature.</p>

    <p class="text-gray-300">5.2 Proof of security</p>

    <p class="text-gray-300">We sketch a proof that the above protocol is a zero-knowledge proof of knowledge of an RSA signature on a committed message. The completeness follows easily from the security of protocol <span class="math">\\Pi_{Hash}</span>, and from the observation that</p>

    <div class="my-4 text-center"><span class="math-block">y = \\left(y_{e-1}^{\\alpha}\\right) h^{\\beta_e} = \\left(\\left(\\cdots \\left(g^{\\alpha} h^{\\beta_1}\\right)^{\\alpha} h^{\\beta_2} \\cdots\\right)^{\\alpha} h^{\\beta_{e-1}}\\right)^{\\alpha} h^{\\beta_e}</span></div>

    <div class="my-4 text-center"><span class="math-block">= g^{\\alpha^e} h^{\\beta_e + \\alpha \\beta_{e-1} + \\cdots + \\alpha^{e-1} \\beta_1}</span></div>

    <p class="text-gray-300">in step 4.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness: We show an extractor, that, given access to the prover, extracts <span class="math">(m, \\sigma)</span> such that <span class="math">\\mathsf{Verify}_{N,e}(m, \\sigma) = 1</span>. The extractor invokes the simulator for the corrupt prover of protocol <span class="math">\\Pi_{Hash}</span> to extract <span class="math">m</span> and <span class="math">M</span>. It then runs the extractor corresponding to the proof in step 4b to extract <span class="math">\\alpha</span>. By the security of <span class="math">\\Pi_{Hash}</span> and the binding property of <span class="math">\\mathsf{Com}</span>, it follows that <span class="math">\\alpha^e \\mod N = M = \\mathcal{H}(m)</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Zero-knowledge: We sketch a simulator that simulates the verifier's view in the protocol. The simulator commits to a random value on behalf of the prover in step 2 by computing <span class="math">C_2^r = \\mathsf{Com}(M&#x27;)</span>. It sends <span class="math">C_2^r</span> to the verifier, proves knowledge of opening and invokes the simulator for the corrupt verifier of protocol <span class="math">\\Pi_{Hash}</span>. It then chooses <span class="math">y_1, \\dots, y_{e-1} \\in Z_N</span> at random, and runs the simulator corresponding to the proof in step 4b. We can show that the view of the verifier in the protocol is indistinguishable from the view with the simulator.</li>

    </ul>

    <p class="text-gray-300">6 Privacy-Preserving (EC)DSA Signature Verification</p>

    <p class="text-gray-300">The DSA Scheme. The Digital Signature Algorithm (DSA) is a variant of the Elgamal signature scheme. The key generation, signature generation and verification algorithms are given next. The KeyGen algorithm chooses two primes <span class="math">p</span> and <span class="math">q</span> such that <span class="math">q \\mid p - 1</span>. Let <span class="math">g</span> be an element of order <span class="math">q</span> in <span class="math">\\mathbb{Z}_p^*</span>. It then chooses <span class="math">x</span> randomly from <span class="math">\\{1, \\dots, q - 1\\}</span>. The private key is set to be <span class="math">x</span> and the public key is <span class="math">(g, p, q, y), y = g^x \\mod p</span>.</p>

    <p class="text-gray-300">Sign(m) <span class="math">M \\leftarrow \\mathcal{H}(m)</span></p>

    <p class="text-gray-300">Pick a random <span class="math">k, 1 \\leq k &amp;lt; q</span></p>

    <p class="text-gray-300"><span class="math">r = (g^k \\mod p) \\mod q</span></p>

    <p class="text-gray-300"><span class="math">s = k^{-1}(M + rx) \\mod q</span></p>

    <p class="text-gray-300">return <span class="math">(r, s)</span></p>

    <p class="text-gray-300">Verify <span class="math">(m, (r, s))</span></p>

    <p class="text-gray-300"><span class="math">M \\leftarrow \\mathcal{H}(m)</span></p>

    <p class="text-gray-300"><span class="math">w = s^{-1} \\mod q</span></p>

    <p class="text-gray-300"><span class="math">u_1 = Mw \\mod q</span></p>

    <p class="text-gray-300"><span class="math">u_2 = rw \\mod q</span></p>

    <p class="text-gray-300">if <span class="math">r = (g^{u_1}y^{u_2} \\mod p) \\mod q</span> then</p>

    <p class="text-gray-300">return;</p>

    <p class="text-gray-300">1 else return 0;</p>

    <p class="text-gray-300">The ECDSA Scheme. ECDSA is the elliptic curve analogue of DSA. It works in an elliptic curve group <span class="math">E(\\mathbb{Z}_p)</span>. The ECDSA Key generation, signature and verification algorithms are given below. The KeyGen algorithm chooses an elliptic curve <span class="math">E</span> defined over <span class="math">\\mathbb{Z}_p</span> such that the number of points in <span class="math">E(\\mathbb{Z}_p)</span> is divisible by a large prime <span class="math">n</span>. Pick</p>

    <p class="text-gray-300">a point <span class="math">P \\in E(\\mathbb{Z}_p)</span> of order <span class="math">n</span>. Let <span class="math">d \\in [1, n-1]</span> be a randomly chosen integer. Set <span class="math">Q = dP</span>. The public key is <span class="math">(E, P, Q, n)</span> and the private key is <span class="math">d</span>.</p>

    <p class="text-gray-300">Sign(m) Verify <span class="math">(m, (r, s))</span></p>

    <p class="text-gray-300"><span class="math">M \\gets \\mathcal{H}(m)</span> <span class="math">M \\gets \\mathcal{H}(m)</span></p>

    <p class="text-gray-300">Pick a random <span class="math">k \\in [1, n - 1]</span></p>

    <p class="text-gray-300"><span class="math">kP = (x_0, y_0)</span></p>

    <p class="text-gray-300"><span class="math">r = x_0 \\mod n</span></p>

    <p class="text-gray-300"><span class="math">s = k^{-1}(M + rd) \\mod n</span></p>

    <p class="text-gray-300">return <span class="math">(r,s)</span></p>

    <p class="text-gray-300"><span class="math">\\begin{array}{l} \\text{Verify}(m, (r, s)) \\\\ M \\gets \\mathcal{H}(m) \\\\ \\text{if } r, s \\notin [1, n - 1] \\text{ then return;} \\\\ 0 \\\\ w = s^{-1} \\mod n \\\\ u_1 = Mw \\mod n \\\\ u_2 = rw \\mod n \\\\ (x_1, y_1) = u_1P + u_2Q \\\\ v = x_1 \\mod n \\\\ \\text{if } r = v \\text{ then return } 1; \\\\ \\text{else return } 0; \\end{array}</span></p>

    <h2 id="sec-33" class="text-2xl font-bold">6.1 Proof of Knowledge of DSA Signatures</h2>

    <p class="text-gray-300">Let <span class="math">(r,s)</span> be the DSA signature on <span class="math">m</span>. Let <span class="math">\\mathbb{G}_1 = \\langle G_1\\rangle</span> and <span class="math">\\mathbb{G}_2 = \\langle G_2\\rangle</span> be two distinct groups of order <span class="math">p</span> and <span class="math">q</span> respectively where <span class="math">p</span> and <span class="math">q</span> are the parameters of the DSA signature algorithm. One technical difficulty is that we have to show <span class="math">r</span> in <span class="math">G_{1}</span> and <span class="math">G_{2}</span> is equal modulo <span class="math">q</span>. For that purpose, we use our protocol <span class="math">\\Pi_{Eq}</span> from Figure 8 to prove equality across groups. We also employ our protocol from Fig. 9 to prove equality of discrete logarithm of a committed value and another committed value. We now describe the DSA verification protocol in detail. Given a commitment to <span class="math">m</span>, the following protocol is a zero-knowledge proof of knowledge of a valid DSA signature on <span class="math">m</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier is in possession of <span class="math">C_1 = \\mathsf{Com}_q(m)</span>, and the prover has as input message <span class="math">(m, (r, s))</span> and the opening information of <span class="math">C_1</span> to <span class="math">m</span>.</li>

      <li>The prover commits to <span class="math">M = \\mathcal{H}(m)</span>, that is, <span class="math">M \\in \\mathbb{Z}_q</span>, compute <span class="math">C_2 = \\mathsf{Com}_q(M)</span>. Send <span class="math">C_2</span> to the verifier and prove knowledge of opening.</li>

      <li>Now the prover and verifier engage in the protocol <span class="math">\\Pi_{Hash}</span> to prove that <span class="math">M = \\mathcal{H}(m)</span>.</li>

      <li>The prover commits to the signature <span class="math">(r,s)</span> by sending <span class="math">\\mathsf{Com}_{pq}(r) = (\\mathsf{Com}_p(r),\\mathsf{Com}_q(r))</span> and <span class="math">\\mathsf{Com}_q(s)</span>. The prover also commits to the following values: <span class="math">u_{1} = \\mathcal{H}(m)s^{-1},u_{2} = rs^{-1},\\alpha = g^{u_{1}},\\beta = y^{u_{2}}</span>, where <span class="math">g</span> is the generator of a cyclic group of order <span class="math">q</span> in <span class="math">\\mathbb{Z}_p^*</span> used in DSA signing, and <span class="math">y</span> is the DSA public key. Prover sends <span class="math">\\mathsf{Com}_q(u_1)</span>, <span class="math">\\mathsf{Com}_q(u_2)</span>, <span class="math">\\mathsf{Com}_p(\\alpha)</span>, <span class="math">\\mathsf{Com}_p(\\beta)</span>.</li>

      <li>The prover and the verifier carry out the following <span class="math">\\Sigma</span>-protocol zero-knowledge proofs of knowledge:</li>

    </ol>

    <p class="text-gray-300">(a) <span class="math">\\mathsf{PK}\\{(u_1,R_1,R_2):\\mathsf{Com}_p(\\alpha) = G_1^{g^{u_1}}H_1^{R_1}\\wedge \\mathsf{Com}_q(u_1) = G_2^{u_1}H_1^{R_2}\\}</span></p>

    <p class="text-gray-300">(b) <span class="math">\\mathsf{PK}\\{(u_2,R_1,R_2):\\mathsf{Com}_p(\\beta) = G_1^{g^{u_2}}H_1^{R_1}\\wedge \\mathsf{Com}_q(u_2) = G_2^{u_2}H_1^{R_2}\\}</span></p>

    <p class="text-gray-300">(c) <span class="math">\\mathsf{PK}\\{(r,\\alpha ,\\beta ,R_1,R_2,R_3):\\mathsf{Com}_p(\\beta) = G_1^\\beta H_1^{R_1}\\wedge \\mathsf{Com}_p(\\alpha) = G_1^\\alpha H_1^{R_2}\\wedge \\mathsf{Com}_p(r) = G_1^r H_1^{R_3}\\wedge r = \\alpha \\beta \\}</span></p>

    <p class="text-gray-300">(d) <span class="math">\\mathsf{PK}\\{(M,u_1,s,R_1,R_2,R_3):\\mathsf{Com}_q(M) = G_2^M H_2^{R_1}\\wedge \\mathsf{Com}_q(u_1) = G_2^{u_1}H_2^{R_2}\\wedge \\mathsf{Com}_q(s) = G_2^s H_2^{R_3}\\wedge M = u_1s\\}</span></p>

    <p class="text-gray-300">(e) <span class="math">\\mathsf{PK}\\{(r,u_2,s,R_1,R_2,R_3):\\mathsf{Com}_q(r) = G_2^r H_2^{R_1}\\wedge \\mathsf{Com}_q(u_2) = G_2^{u_2}H_2^{R_2}\\wedge \\mathsf{Com}_q(s) = G_2^s H_2^{R_3}\\wedge r = u_2s\\}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover and verifier engage in <span class="math">\\Pi_{Eq}</span> with input <span class="math">\\mathsf{Com}_{pq}(r)</span>.</li>

    </ol>

    <p class="text-gray-300">6.2 Proof of security</p>

    <p class="text-gray-300">We sketch a proof of the soundness and zero-knowledge properties of the above protocol. The completeness follows from security of <span class="math">\\Pi_{Hash}</span> and completeness of the proofs of knowledge in step 5.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proof of Knowledge: We show an extractor, that, given access to the prover, extracts <span class="math">(m,(r,s))</span> such that <span class="math">\\mathsf{Verify}(m,(r,s))=1</span>. The extractor invokes the simulator for the corrupt prover of protocol <span class="math">\\Pi_{Hash}</span> to extract <span class="math">m</span> and <span class="math">M</span> and the opening information for <span class="math">C_{1}</span>.</li>

    </ul>

    <p class="text-gray-300">It then runs the extractor guaranteed by the proof of knowledge property of the proofs in step 5 to extract <span class="math">u_{1},u_{2},\\alpha,\\beta,s,r</span>. Finally it returns <span class="math">(m,(r,s))</span> and the opening information. By security of <span class="math">\\Pi_{Hash}</span>, <span class="math">\\Pi_{Eq}</span> and the binding property of the commitment scheme <span class="math">\\mathsf{Com}</span>, it follows that <span class="math">r=g^{Ms^{-1}}y^{rs^{-1}}</span> and <span class="math">M=\\mathcal{H}(m)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Zero-knowledge: We sketch a simulator that simulates the verifier’s view in the protocol. The simulator commits to a random value on behalf of the prover in step 2 by computing <span class="math">C_{2}^{\\prime}=\\mathsf{Com}(M^{\\prime})</span>. It sends <span class="math">C_{2}^{\\prime}</span> to the verifier, proves knowledge of the opening and invokes the simulator for the corrupt verifier of protocol <span class="math">\\Pi_{Hash}</span>. It then commits to random values in step 4, and runs the simulator corresponding to the proofs of knowledge in step 5. Finally in step 6, the simulator invokes the simulator for protocol <span class="math">\\Pi_{Eq}</span>. We can show that the view of the verifier in the protocol is indistinguishable from the view with the simulator.</li>

    </ul>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">6.3 Proof of Knowledge of ECDSA Signatures</h3>

    <p class="text-gray-300">Let <span class="math">(r,s)</span> be the ECDSA signature on <span class="math">m</span>. Let <span class="math">\\mathbb{G}_{1}=\\langle G_{1}\\rangle</span> and <span class="math">\\mathbb{G}_{2}=\\langle G_{2}\\rangle</span> be two distinct groups of order <span class="math">p</span> and <span class="math">n</span> respectively where <span class="math">p</span> is the order of the field of the curve and <span class="math">n</span> is the order of point <span class="math">P</span>. Addition of elliptic curve points which is the group operation requires arithmetic operations in the underlying finite field <span class="math">\\mathbb{Z}_{p}</span> of the curve <span class="math">E</span>. We use a straight forward variant of the protocol in Fig. 9 to prove statements about multiples of an elliptic curve point (elliptic curve analogue of exponentiation) inside commitments.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier is in possession of <span class="math">C_{1}=\\mathsf{Com}_{p}(m)</span> and the prover has as input <span class="math">(m,\\sigma)</span> and the opening of <span class="math">C_{1}</span> to <span class="math">m</span>.</li>

      <li>The prover commits to <span class="math">M=\\mathcal{H}(m)</span>, by computing <span class="math">C_{2}=\\mathsf{Com}_{p}(M)</span>. Send <span class="math">C_{2}</span> to the verifier and prove knowledge of opening.</li>

      <li>The prover and verifier engage in the protocol <span class="math">\\Pi_{Hash}</span> with inputs <span class="math">(m,M)</span> and <span class="math">(C_{1},C_{2})</span> respectively.</li>

      <li>The prover commits to the signature <span class="math">(r,s)</span> and proves knowledge of an opening. The prover sends <span class="math">\\mathsf{Com}_{pn}(r)=(\\mathsf{Com}_{p}(r),\\mathsf{Com}_{n}(r))</span> and <span class="math">\\mathsf{Com}_{n}(s)</span>. The prover also commits to the following values: <span class="math">u_{1}=\\mathcal{H}(m)s^{-1},u_{2}=rs^{-1}</span>, and the coordinates of the points <span class="math">u_{1}P=(\\alpha_{x},\\alpha_{y}),u_{2}Q=(\\beta_{x},\\beta_{y})</span>, where <span class="math">P</span> is the point of order <span class="math">n</span> in <span class="math">E(\\mathbb{Z}_{p})</span> used in ECDSA signing, and <span class="math">Q</span> is the ECDSA public key. The prover sends <span class="math">\\mathsf{Com}_{n}(u_{1})</span>, <span class="math">\\mathsf{Com}_{n}(u_{2})</span>, <span class="math">\\mathsf{Com}_{p}(\\alpha_{x})</span>,<span class="math">\\mathsf{Com}_{p}(\\alpha_{y})</span>, <span class="math">\\mathsf{Com}_{p}(\\beta_{x})</span>, <span class="math">\\mathsf{Com}_{p}(\\beta_{y})</span>.</li>

      <li>The prover and the verifier carry out the following <span class="math">\\Sigma</span>-protocol zero-knowledge proofs of knowledge:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PK<span class="math">\\{(u_{1},\\alpha_{x},\\alpha_{y},R_{1},R_{2},R_{3}):\\mathsf{Com}_{p}(\\alpha_{x})=G_{1}^{\\alpha_{x}}H_{1}^{R_{1}}\\wedge\\mathsf{Com}_{p}(\\alpha_{y})=G_{1}^{\\alpha_{y}}H_{1}^{R_{2}}\\wedge\\mathsf{Com}_{n}(u_{1})=G_{2}^{u_{1}}H_{1}^{R_{3}}\\wedge(\\alpha_{x},\\alpha_{y})=u_{1}P\\}</span></li>

      <li>PK<span class="math">\\{(u_{2},\\beta_{x},\\beta_{y},R_{1},R_{2},R_{3}):\\mathsf{Com}_{p}(\\beta_{x})=G_{1}^{\\beta_{x}}H_{1}^{R_{1}}\\wedge\\mathsf{Com}_{p}(\\beta_{y})=G_{1}^{\\beta_{y}}H_{1}^{R_{2}}\\wedge\\mathsf{Com}_{n}(u_{2})=G_{2}^{u_{2}}H_{1}^{R_{3}}\\wedge(\\beta_{x},\\beta_{y})=u_{2}Q\\}</span></li>

      <li>PK<span class="math">\\{(r,\\alpha_{x},\\alpha_{y},\\beta_{x},\\beta_{y},R_{1},R_{2},R_{3},R_{4},R_{5}):\\mathsf{Com}_{p}(\\beta_{x})=G_{1}^{\\beta_{x}}H_{1}^{R_{1}}\\wedge\\mathsf{Com}_{p}(\\beta_{y})=G_{1}^{\\beta_{y}}H_{1}^{R_{2}}\\wedge\\mathsf{Com}_{p}(\\alpha_{x})=G_{1}^{\\alpha_{x}}H_{1}^{R_{3}}\\wedge\\mathsf{Com}_{p}(\\alpha_{y})=G_{1}^{\\alpha_{y}}H_{1}^{R_{4}}\\wedge\\mathsf{Com}_{p}(r)=G_{1}^{r}H_{1}^{R_{5}}\\wedge r=((\\alpha_{x},\\alpha_{y})+(\\beta_{x},\\beta_{y}))_{x}\\}</span></li>

      <li>PK<span class="math">\\{(M,u_{1},s,R_{1},R_{2},R_{3}):\\mathsf{Com}_{n}(M)=G_{2}^{M}H_{2}^{R_{1}}\\wedge\\mathsf{Com}_{n}(u_{1})=G_{2}^{u_{1}}H_{2}^{R_{2}}\\wedge\\mathsf{Com}_{n}(s)=G_{2}^{s}H_{2}^{R_{3}}\\wedge M=u_{1}s\\}</span></li>

      <li>PK<span class="math">\\{(r,u_{2},s,R_{1},R_{2},R_{3}):\\mathsf{Com}_{n}(r)=G_{2}^{r}H_{2}^{R_{1}}\\wedge\\mathsf{Com}_{n}(u_{2})=G_{2}^{u_{2}}H_{2}^{R_{2}}\\wedge\\mathsf{Com}_{n}(s)=G_{2}^{s}H_{2}^{R_{3}}\\wedge r=u_{2}s\\}</span></li>

      <li>The prover and verifier engage in <span class="math">\\Pi_{Eq}</span> with input <span class="math">\\mathsf{Com}_{pn}(r)</span>.</li>

    </ul>

    <p class="text-gray-300">The above protocol can be proven to be a zero knowledge proof of knowledge of ECDSA signature. The proofs for correctness, soundness and zero-knowledge are similar to the proofs of the protocol for the DSA signature.</p>

    <h2 id="sec-35" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCKL08] Mira Belenkiy, Melissa Chase, Markulf Kohlweiss, and Anna Lysyanskaya. P-signatures and noninteractive anonymous credentials. In Ran Canetti, editor, TCC 2008, volume 4948 of LNCS, pages 356–374. Springer, Heidelberg, March 2008.</li>

      <li>[BHR12] Mihir Bellare, Viet Tung Hoang, and Phillip Rogaway. Foundations of garbled circuits. In Proceedings of the 2012 ACM conference on Computer and communications security, pages 784–796. ACM, 2012.</li>

      <li>[BL13] Foteini Baldimtsi and Anna Lysyanskaya. Anonymous credentials light. In Ahmad-Reza Sadeghi, Virgil D. Gligor, and Moti Yung, editors, ACM CCS 13, pages 1087–1098. ACM Press, November 2013.</li>

      <li>[BR93] Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In Proceedings of the 1st ACM conference on Computer and communications security, pages 62–73. ACM, 1993.</li>

      <li>[BR96] Mihir Bellare and Phillip Rogaway. The exact security of digital signatures-how to sign with rsa and rabin. In Advances in Cryptology-Eurocrypt’96, pages 399–416. Springer, 1996.</li>

      <li>[Bra99] Stefan Brands. Rethinking Public Key Infrastructure and Digital Certificates—Building in Privacy. PhD thesis, Eindhoven Institute of Technology, Eindhoven, The Netherlands, 1999.</li>

      <li>[Cha86] David Chaum. Showing credentials without identification: Signatures transferred between unconditionally unlinkable pseudonyms. In Franz Pichler, editor, EUROCRYPT’85, volume 219 of LNCS, pages 241–244. Springer, Heidelberg, April 1986.</li>

      <li>[CL01] Jan Camenisch and Anna Lysyanskaya. An efficient system for non-transferable anonymous credentials with optional anonymity revocation. In Birgit Pfitzmann, editor, EUROCRYPT 2001, volume 2045 of LNCS, pages 93–118. Springer, Heidelberg, May 2001.</li>

      <li>[CL04] Jan Camenisch and Anna Lysyanskaya. Signature schemes and anonymous credentials from bilinear maps. In Matthew Franklin, editor, CRYPTO 2004, volume 3152 of LNCS, pages 56–72. Springer, Heidelberg, August 2004.</li>

    </ul>

    <p class="text-gray-300">[CMZ14] Melissa Chase, Sarah Meiklejohn, and Greg Zaverucha. Algebraic MACs and keyed-verification anonymous credentials. In Gail-Joon Ahn, Moti Yung, and Ninghui Li, editors, ACM CCS 14, pages 1205–1216. ACM Press, November 2014.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CS97a] Jan Camenisch and Markus Stadler. Efficient group signature schemes for large groups. In Advances in Cryptology-CRYPTO’97, pages 410–424. Springer, 1997.</li>

      <li>[CS97b] Jan Camenisch and Markus Stadler. Efficient group signature schemes for large groups (extended abstract). In Burton S. Kaliski Jr., editor, CRYPTO’97, volume 1294 of LNCS, pages 410–424. Springer, Heidelberg, August 1997.</li>

      <li>[CZ09] Jan Camenisch and Gregory M Zaverucha. Private intersection of certified sets. In Financial Cryptography and Data Security, pages 108–127. Springer, 2009.</li>

      <li>[Dam00] Ivan Damgård. Efficient concurrent zero-knowledge in the auxiliary string model. In Advances in Cryptology-EUROCRYPT 2000, pages 418–430. Springer, 2000.</li>

      <li>[DF02] Ivan Damgård and Eiichiro Fujisaki. A statistically-hiding integer commitment scheme based on groups with hidden order. In Advances in Cryptology-ASIACRYPT 2002, pages 125–142. Springer, 2002.</li>

      <li>[DLFKP16] Antoine Delignat-Lavaud, Cédric Fournet, Markulf Kohlweiss, and Bryan Parno. Cinderella: Turning shabby X.509 certificates into elegant anonymous credentials with the magic of verifiable computation. In IEEE Symposium on Security & Privacy 2016 (Oakland’16). IEEE, 2016.</li>

      <li>[FNO15] Tore Kasper Frederiksen, Jesper Buus Nielsen, and Claudio Orlandi. Privacy-free garbled circuits with applications to efficient zero-knowledge. In Advances in Cryptology-EUROCRYPT 2015, pages 191–219. Springer, 2015.</li>

      <li>[FO97] Eiichiro Fujisaki and Tatsuaki Okamoto. Statistical zero knowledge protocols to prove modular polynomial relations. In Burton S. Kaliski Jr., editor, CRYPTO’97, volume 1294 of LNCS, pages 16–30. Springer, Heidelberg, August 1997.</li>

      <li>[FS86] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Advances in CryptologyCRYPTO86, pages 186–194. Springer, 1986.</li>

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 626–645. Springer, Heidelberg, May 2013.</li>

      <li>[GMR85] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof-systems (extended abstract). In Proceedings of the 17th Annual ACM Symposium on Theory of Computing, May 6-8, 1985, Providence, Rhode Island, USA, pages 291–304, 1985.</li>

      <li>[GMW87] Oded Goldreich, Silvio Micali, and Avi Wigderson. How to prove all NP-statements in zero-knowledge, and a methodology of cryptographic protocol design. In Andrew M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 171–185. Springer, Heidelberg, August 1987.</li>

      <li>[GQ88] Louis C. Guillou and Jean-Jacques Quisquater. A practical zero-knowledge protocol fitted to security microprocessor minimizing both trasmission and memory. In C. G. Günther, editor, EUROCRYPT’88, volume 330 of LNCS, pages 123–128. Springer, Heidelberg, May 1988.</li>

      <li>[Gro10] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 321–340. Springer, Heidelberg, December 2010.</li>

      <li>[GS08] Jens Groth and Amit Sahai. Efficient non-interactive proof systems for bilinear groups. In Nigel P. Smart, editor, EUROCRYPT 2008, volume 4965 of LNCS, pages 415–432. Springer, Heidelberg, April 2008.</li>

    </ul>

    <p class="text-gray-300">[ide10] Specification of the identity mixer cryptographic library (revised version 2.3.0). Technical Report RZ 3730, IBM Research, April 2010.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[JKO13] Marek Jawurek, Florian Kerschbaum, and Claudio Orlandi. Zero-knowledge using garbled circuits: how to prove non-algebraic statements efficiently. In Ahmad-Reza Sadeghi, Virgil D. Gligor, and Moti Yung, editors, ACM CCS 13, pages 955–966. ACM Press, November 2013.</li>

      <li>[JS07] Stanisław Jarecki and Vitaly Shmatikov. Efficient two-party secure computation on committed inputs. In Advances in Cryptology-EUROCRYPT 2007, pages 97–114. Springer, 2007.</li>

      <li>[KKL^{+}16] Vladimir Kolesnikov, Hugo Krawczyk, Yehuda Lindell, Alex J. Malozemoff, and Tal Rabin. Attribute-based key exchange with general policies. Cryptology ePrint Archive, Report 2016/518, 2016. http://eprint.iacr.org/.</li>

      <li>[Knu69] Donald E Knuth. The art of computer programming. vol. 2: Seminumerical algorithms. addisonwesley. Reading, MA, pages 229–279, 1969.</li>

      <li>[KS06] Mehmet Kiraz and Berry Schoenmakers. A protocol issue for the malicious case of yaos garbled circuit construction. In 27th Symposium on Information Theory in the Benelux, pages 283–290, 2006.</li>

      <li>[KS08] Vladimir Kolesnikov and Thomas Schneider. Improved garbled circuit: Free xor gates and applications. In Automata, Languages and Programming, pages 486–498. Springer, 2008.</li>

      <li>[KSS09] Vladimir Kolesnikov, Ahmad-Reza Sadeghi, and Thomas Schneider. Improved garbled circuit building blocks and applications to auctions and computing minima. In Cryptology and Network Security, pages 1–20. Springer, 2009.</li>

      <li>[Lin15] Yehuda Lindell. An efficient transform from sigma protocols to nizk with a crs and non-programmable random oracle. In Theory of Cryptography, pages 93–109. Springer, 2015.</li>

      <li>[MGGR13] Ian Miers, Christina Garman, Matthew Green, and Aviel D Rubin. Zerocoin: Anonymous distributed e-cash from bitcoin. In Security and Privacy (SP), 2013 IEEE Symposium on, pages 397–411. IEEE, 2013.</li>

      <li>[MR13] Payman Mohassel and Ben Riva. Garbled circuits checking garbled circuits: More efficient and secure two-party computation. In Advances in Cryptology–CRYPTO 2013, pages 36–53. Springer, 2013.</li>

      <li>[Ngu05] Lan Nguyen. Accumulators from bilinear pairings and applications. In Topics in Cryptology - CT-RSA 2005, The Cryptographers’ Track at the RSA Conference 2005, San Francisco, CA, USA, February 14-18, 2005, Proceedings, pages 275–292, 2005.</li>

      <li>[Ped91] Torben Pryds Pedersen. Non-interactive and information-theoretic secure verifiable secret sharing. In Advances in CryptologyCRYPTO91, pages 129–140. Springer, 1991.</li>

      <li>[PS96] David Pointcheval and Jacques Stern. Security proofs for signature schemes. In Advances in CryptologyEUROCRYPT96, pages 387–398. Springer, 1996.</li>

      <li>[PZ13] C. Paquin and G. Zaverucha. U-prove cryptographic specification v1.1 (revision 2). Available online: www.microsoft.com/uprove, 2013.</li>

      <li>[S^{+}11] Chih-hao Shen et al. Two-output secure computation with malicious adversaries. In Advances in Cryptology–EUROCRYPT 2011, pages 386–405. Springer, 2011.</li>

      <li>[Sch90] Claus-Peter Schnorr. Efficient identification and signatures for smart cards. In Gilles Brassard, editor, CRYPTO’89, volume 435 of LNCS, pages 239–252. Springer, Heidelberg, August 1990.</li>

      <li>[Sta96] Markus Stadler. Publicly verifiable secret sharing. In Advances in Cryptology-EUROCRYPT96, pages 190–199. Springer, 1996.</li>

      <li>[ZRE15] Samee Zahur, Mike Rosulek, and David Evans. Two halves make a whole. In Advances in Cryptology-EUROCRYPT 2015, pages 220–250. Springer, 2015.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">\\mathcal{G} = (\\mathsf{Gb}, \\mathsf{En}, \\mathsf{De}, \\mathsf{Eval}, \\mathsf{Ve})</span> be a garbling scheme. Let <span class="math">F</span> be the following functionality: it takes as inputs <span class="math">x, a, b</span> and outputs <span class="math">v, t</span> such that <span class="math">v = 1</span> if <span class="math">f(x) = 1</span> and 0 otherwise, and <span class="math">t = ax + b</span>. The prover has input <span class="math">x</span>, the verifier is in possession of <span class="math">C_x = \\mathsf{Com}(x)</span>. Both parties have as input the security parameter <span class="math">\\kappa</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier generates uniformly random integers <span class="math">a</span> and <span class="math">b</span> of length <span class="math">s</span> and <span class="math">n + s</span> respectively. It commits to them by sending <span class="math">C_a = \\mathsf{Com}(a)</span>, <span class="math">C_b = \\mathsf{Com}(b)</span> and proves knowledge of their opening.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier constructs a garbled circuit for <span class="math">F</span>.</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">(G C, e, d) \\leftarrow \\mathrm {G b} \\left(1 ^ {\\kappa}, F (x, a, b) = (f (x), a x + b)\\right)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover inputs his choice bits by sending <span class="math">(i, x_i)</span> for all <span class="math">i \\in [n]</span> to <span class="math">\\mathcal{F}_{COT}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier inputs the wire keys corresponding to the prover's input by sending <span class="math">(i, K_i^0, K_i^1)</span> for all <span class="math">i \\in [n]</span> to <span class="math">\\mathcal{F}_{COT}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{F}_{COT}</span> outputs <span class="math">K_{i}^{\\prime}</span> for all <span class="math">i\\in [n]</span> to the prover where <span class="math">K_{i}^{\\prime} = K_{i}^{x_{i}}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier sends the garbled circuit <span class="math">GC</span> to the prover. Note that in what follows, for simplicity, we consider the input keys for <span class="math">a</span> and <span class="math">b</span> to be part of the <span class="math">GC</span> itself, and hence not sent separately.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover evaluates the garbled circuit</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(t ^ {\\prime}, Z\\right) \\leftarrow \\operatorname {E v a l} \\left(G C, \\left\\{K _ {i} ^ {\\prime} \\right\\} _ {i \\in [ n ]}\\right)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prover commits to the garbled output <span class="math">Z</span> by sending <span class="math">\\operatorname{Com}(Z)</span> to the verifier and proves knowledge of opening.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier sends the decoding information <span class="math">d_{t}</span> for <span class="math">t</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prover decodes</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">t = \\operatorname {D e} \\left(d _ {t}, t ^ {\\prime}\\right)</span></div>

    <p class="text-gray-300">and commits to the decoded output by sending <span class="math">C_t = \\mathsf{Com}(t)</span>, and proves knowledge of opening.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier sends open to <span class="math">\\mathcal{F}_{COT}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{F}_{COT}</span> sends <span class="math">(K_{i}^{0}, K_{i}^{1})</span> to the prover for all <span class="math">i \\in [n]</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier opens <span class="math">\\mathsf{Com}(a)</span> and <span class="math">\\mathsf{Com}(b)</span>. Prover checks the openings and aborts if they fail.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prover verifies that the correct circuit was garbled by running <span class="math">\\mathsf{Ve}(GC, \\{K_i^0, K_i^1\\}_{i \\in [n]}, F)</span>. It also checks that garbled inputs for <span class="math">x, a, b</span> are the correct one. If any of checks fail, the prover terminates. Otherwise, it receives the decoding vector <span class="math">d</span>, and he opens the commitment to the output <span class="math">Z</span> by sending <span class="math">Z</span> and randomness.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier checks that the opening is correct and that <span class="math">\\mathsf{De}(d,Z) = 1</span>. If the opening is not correct or if <span class="math">\\mathsf{De}(d,Z)\\neq 1</span>, the verifier outputs reject and terminates.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the verifier did not terminate, the prover and the verifier engage in a Zero-knowledge protocol to prove the following:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {P K} \\{(x, t, r, R): C _ {x} = \\mathsf {C o m} (x) \\wedge C _ {t} = \\mathsf {C o m} (t) \\wedge t = a x + b \\}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the zero-knowledge proof verifies, the verifier outputs accept.</li>

    </ol>`;
---

<BaseLayout title="Efficient Zero-Knowledge Proof of Algebraic and Non-Algebrai... (2016/583)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/583
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
