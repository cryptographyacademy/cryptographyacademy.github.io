---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/1282';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Proof-Carrying Data from Multi-folding Schemes';
const AUTHORS_HTML = 'Zibo Zhou, Zongyang Zhang, Zhiyu Zhang, Jin Dong';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Proof-carrying data (PCD) is a cryptographic primitive enabling mutually distrustful parties to perform distributed computations on directed acyclic graphs with efficient and incremental verification. Key performance metrics include the prover cost at each step and the recursion overhead, which measures the additional cost beyond proving the original computation. Despite substantial advancements in constructing efficient PCD schemes, these metrics continue to be bottlenecks hindering their widespread application.

In this paper, we advance the research by constructing a new PCD scheme based on a new generalized construction of multi-folding schemes. Compared with the state-of-the-art PCD scheme by B&uuml;nz et al. (CRYPTO&#x27;21), our scheme reduces the prover cost at each step from $4r+6$ multi-scalar multiplications (MSMs) of size $O(|C|)$ to $1$ MSM of the same size, and the recursion overhead from $6$ MSMs of size $2r-1$, $1$ MSM of size $6r-3$ to $1$ MSM of size $2r-1$, where $r$ is the number of incoming edges at certain step and $|C|$ is the proving computation size. Additionally, our PCD scheme supports a more expressive constraint system for encoding computations, namely the customizable constraint system, which supports high-degree constraints, in contrast to the rank-1 constraint system adopted by existing PCD schemes that only supports quadratic constraints.

We implement our PCD scheme and report the concrete recursion overhead and practical efficiency for different values of $r$ and $|C|$. Compared with B&uuml;nz et al. (CRYPTO&#x27;21), our PCD scheme achieves a $2.5$ times lower recursion overhead when $r=2$ and $|C|=2^{20}$. Additionally, when $r=2$ and a proving computation size (excluding recursion overhead) of $2^{24}$, it takes $49$ seconds to generate a PCD proof at each step. Using a SNARK to compress the proof reduces the proof size from $1031$ MB to $13$ KB, with a tradeoff in the verifier time, which increases from $11$ seconds to $22$ seconds.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> proof-carrying data &middot; recursive proof composition &middot; folding schemes</p>
    </section>

    <h2 id="sec-misc-1" class="text-2xl font-bold">V. IMPLEMENTATION AND EVALUATION</h2>

    <p class="text-gray-300">We have implemented our multi-folding scheme and PCD scheme to evaluate their practical efficiency. We present the implementation details and evaluation results in this section.</p>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">A. Implementation Methodology</h4>

    <p class="text-gray-300">Given an elliptic curve group  <span class="math">\\mathbb{G}</span> , denote the <em>scalar field</em> of  <span class="math">\\mathbb{G}</span>  as the field  <span class="math">\\mathbb{F}_1</span>  whose order is  <span class="math">|\\mathbb{G}|</span> , and the <em>base field</em> of  <span class="math">\\mathbb{G}</span></p>

    <p class="text-gray-300">as the field  <span class="math">\\mathbb{F}_2</span>  over which the elliptic curve group is defined. Typically,  <span class="math">\\mathbb{F}_1</span>  and  <span class="math">\\mathbb{F}_2</span>  are distinct; otherwise, the discrete logarithm assumption would not hold [38]. To implement our PCD scheme, we need to implement the circuit  <span class="math">R_{\\varphi}</span>  defined over the scalar field  <span class="math">\\mathbb{F}_1</span> . However, since NIMFS. <span class="math">\\mathcal{V}&#x27;</span>  involves group operations over  <span class="math">\\mathbb{F}_2</span> , directly encoding them within the circuit  <span class="math">R_{\\varphi}</span>  would require emulating  <span class="math">\\mathbb{F}_2</span>  operations via  <span class="math">\\mathbb{F}_1</span>  operations, which would significantly increase the circuit size.</p>

    <p class="text-gray-300">To avoid a blowup in the circuit size, existing implementations of recursive arguments based on groups [2], [9], [29], [32] utilize a 2-cycle of elliptic curves  <span class="math">(E_1, E_2)</span> . This cycle induces a pair of elliptic curve groups  <span class="math">(\\mathbb{G}_1,\\mathbb{G}_2)</span> , where  <span class="math">\\mathbb{G}_1</span>  has scalar field  <span class="math">\\mathbb{F}_1</span>  and base field  <span class="math">\\mathbb{F}_2</span>  while  <span class="math">\\mathbb{G}_2</span>  has scalar field  <span class="math">\\mathbb{F}_2</span>  and base field  <span class="math">\\mathbb{F}_1</span> . Kothapalli and Setty [27] introduced CycleFold, a conceptually simple approach to instantiate folding-schemebased recursive arguments over a cycle of elliptic curves for realizing IVC schemes. Instead of emulating non-native field operations within a primary circuit defined over  <span class="math">E_1</span> , CycleFold outsources these operations to a secondary circuit defined over  <span class="math">E_2</span> , generates an instance-witness pair to represent the correct execution of the secondary circuit, and then folds this instance along with some running instances within the primary circuit. Due to the properties of the 2-cycle of elliptic curves, the emulation overhead is significantly reduced.</p>

    <p class="text-gray-300">We adapt CycleFold to implement our PCD scheme and provide an overview of the circuit implementation in Fig. 1, where superscripts (1) and (2) denote the elements defined over the elliptic curve  <span class="math">E_1</span>  and  <span class="math">E_2</span> , respectively.</p>

    <p class="text-gray-300">    <img src="_page_8_Figure_12.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 1: PCD circuit implementation overview</p>

    <p class="text-gray-300">We use a primary circuit defined over the scalar field  <span class="math">\\mathbb{F}_1</span>  of  <span class="math">E_1</span>  to encode all parts of  <span class="math">R_{\\varphi}</span>  except for the group operation  <span class="math">C&#x27;^{(1)} := \\sum_{k=1}^r \\rho^{k-1} \\cdot \\mathsf{U}_k^{(1)}.C_1 + \\sum_{k&#x27;=1}^r \\rho^{r-1+k&#x27;} \\cdot \\mathsf{u}_{k&#x27;}^{(1)}.C_2</span>  in NIMFS. <span class="math">\\mathcal{V}&#x27;</span> . This operation is defined over  <span class="math">\\mathbb{F}_2</span>  and is thus nonnative to the primary circuit. Instead, we use a secondary circuit  <span class="math">C_{\\mathsf{EC}}</span>  defined over the scalar field  <span class="math">\\mathbb{F}_2</span>  of  <span class="math">E_2</span>  to encode this group operation, which eliminates the need for field emulation. To complete NIMFS. <span class="math">\\mathcal{V}&#x27;</span>  in the primary circuit, we represent the secondary circuit as a R1CS structure and generate a satisfied instance-witness pair  <span class="math">\\left(\\mathsf{u}_{\\mathsf{EC},r+1}^{(2)},\\mathsf{w}_{\\mathsf{EC},r+1}^{(2)}\\right)</span>  with the public IO  <span class="math">\\left\\{\\mathsf{U}_i^{(1)}.C_1,\\mathsf{u}_i^{(1)}.C_2\\right\\}_{i=1}^r,\\rho,C&#x27;^{(1)}</span> . The primary circuit reads  <span class="math">\\mathsf{u}_{\\mathsf{EC},r+1}^{(2)}</span>  and, after checking that the public IO in  <span class="math">\\mathsf{u}_{\\mathsf{EC},r+1}^{(2)}</span></p>

    <p class="text-gray-300">matches the desired inputs, adds  <span class="math">C&#x27;^{(1)}</span>  to  <span class="math">\\mathsf{U}^{(1)}</span> .</p>

    <p class="text-gray-300">Then different from Construction 2, the verifier now should additionally check the satisfiability of  <span class="math">(\\mathsf{u}_{\\mathsf{EC},r+1}^{(2)},\\mathsf{w}_{\\mathsf{EC},r+1}^{(2)})</span> , making the PCD proof  <span class="math">\\Pi_i^{(1)}</span>  for  <span class="math">z_i^{(1)}</span>  now consist of  <span class="math">(\\mathsf{U}_i^{(1)},\\mathsf{W}_i^{(1)}),(\\mathsf{u}_i^{(1)},\\mathsf{w}_i^{(1)}),(\\mathsf{U}_{\\mathsf{EC},i}^{(2)},\\mathsf{W}_{\\mathsf{EC},i}^{(2)})</span> . The prover should additionally fold the inputs  <span class="math">(\\mathsf{U}_{\\mathsf{EC},i}^{(2)},\\mathsf{W}_{\\mathsf{EC},i}^{(2)})</span>  and newly generated  <span class="math">(\\mathsf{u}_{\\mathsf{EC},r+1}^{(2)},\\mathsf{w}_{\\mathsf{EC},r+1}^{(2)})</span>  into a single instance-witness pair  <span class="math">(U_{EC}^{(2)},W_{EC}^{(2)})</span> . Intuitively, this scenario aligns well with our multi-folding scheme. However, in this case, encoding the multi-folding scheme's verification in a circuit inevitably requires emulating the logarithmic field operations or the constant group operations within the verification algorithm, both of which are unacceptable. Instead, we turn our attention to the folding scheme in Nova [29]. While it is designed to fold two instances, it can be invoked multiple times to fold multiple instances. More importantly, since the folding scheme is invoked to fold instances from the secondary circuit, its verification is native to the primary circuit except for a few field operations. Thus, we could encode the folding scheme's verification within the primary circuit. Furthermore, the number of field operations in the verification that are nonnative to the primary circuit is roughly linear to the number of public IO of the secondary circuit. Notably, the public IO mainly consists of elliptic curve group elements. To reduce the emulation overhead, we adopt a compressed format to store these elements and decompress them when used in the circuit. This approach roughly halves the emulation overhead.</p>

    <p class="text-gray-300">We implement our proposed schemes in Rust based on the Nova library [34]. While our multi-folding scheme and PCD scheme support CCS, we limit our attention to R1CS, a specific instantiation of CCS, for a fair comparison with existing works. The experiments are conducted on Ubuntu 22.04 with an X86 architecture, equipped with a 12-core AMD Ryzen 9 5900X CPU running at 3.70GHz and 128GB of memory. We evaluate the following typical performance metrics of our PCD scheme.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The concrete recursion overhead. We measure the recursion overhead with the number of R1CS constraints over the scalar field of both primary curve  <span class="math">(E_1)</span>  and secondary curve  <span class="math">(E_2)</span>  across various arity parameters and proving circuit sizes <sup>4</sup>. We compare the results with existing works to demonstrate the advantages.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The prover time at each step, as well as the proof size and verifier time without compression. We measure these performance metrics across various arity parameters and predicate sizes to illustrate the trends.</li>
    </ol></li>
      <li>The proof size and verifier time after compression. We apply a specific SNARK to compress the PCD proof and compare the proof size and verifier time before and after compression.</li>
    </ul>

    <p class="text-gray-300">Similar to the Nova library, our implementation supports three typical cycles of elliptic curves: 1) Pallas/Vesta, 2) BN254/Grumpkin, and 3) secp/secq. We choose the Pallas/Vesta cycle of curves [35] as used in BCLMS21 [9] when reporting our evaluation results.</p>

    <h3 id="sec-misc-3" class="text-xl font-semibold mt-8">C. Evaluation Results</h3>

    <p class="text-gray-300">Concrete recursion overhead. In Table II, we compare our recursion overhead with COS20 [16] and BCLMS21 [9] in detail for different r and a fixed proving circuit size of  <span class="math">2^{20}</span> . Note that COS20 and BCLMS21 both only report their recursion overheads for r = 1. For comparison, we estimate their recursion overheads for larger r based on the theoretical complexity analysis in Table I. Additionally, COS20 relies solely on symmetric primitives and thereby its recursion overhead is evaluated in a field independent of elliptic curves. Table II shows that our PCD scheme achieves the lowest recursion overhead. Although COS20 does not require cycles of elliptic curves, its recursion overhead is still approximately 20 times greater than ours summed on both the primary and secondary curves. BCLMS21 has slightly lower recursion overhead on the primary curve for r = 1, but the total overhead from both curves is still higher than ours. In other cases, our recursion overhead is approximately 1.5 times smaller on the primary curve and 9.8 times smaller on the secondary curve.</p>

    <p class="text-gray-300">TABLE II: Comparison of concrete recursion overhead with proving circuit size of  <span class="math">2^{20}</span></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Schemes</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Arity <span class="math">(r)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Primary curve/field<br>(# constraints)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Secondary curve<br>(# constraints)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1,132,666</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N/A</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">COS20 [16]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2,265,332</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N/A</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3,397,998</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N/A</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4,530,664</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N/A</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BCLMS21 [9]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">52,000</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">52,000</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">137,428</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">137,428</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">222,857</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">222,857</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">308,285</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">308,285</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">68,017</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5,429</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">This work</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">96,202</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14,011</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">139,573</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22,593</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">191,916</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31,175</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">In Fig. 2, we depict the variations in recursion overhead on the primary curve/field<sup>5</sup> across proving circuit sizes reported in COS20 and different arity r. The figure shows that the recursion overhead for COS20 is significantly higher than those for BCLMS21 and ours. The recursion overheads for COS20 and ours increase slowly as the proving circuit size increases, while that for BCLMS21 remains constant. However, BCLMS21's recursion overhead remains higher than ours except when r=1, and as r continues to increase, this gap gradually widens.</p>

    <p class="text-gray-300"><strong>Efficiency without compression.</strong> In Fig. 3, we report the efficiency of our PCD scheme for different arity r and pred-</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;4</sup>The proving circuit is actually the primary circuit in our benchmark.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup>The recursion overheads for BCLMS21 and our scheme on the secondary curve are independent of the proving circuit size.</p>

    <p class="text-gray-300">    <img src="_page_10_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 2: Comparison of recursion overhead on the primary curve for different arities and proving circuit sizes</p>

    <p class="text-gray-300">icate sizes<sup>6</sup>. According to our benchmark, when the predicate size is below a certain threshold, the recursion overhead on the primary curve will exceed the predicate size<sup>7</sup>. Specifically, for r=1,2,3,4, the thresholds are roughly 61474, 91836, 137388, 189729, respectively. The prover time, proof size, and verifier time all depend on both the predicate size and the recursion overhead. Therefore, when the predicate size is near the threshold, these metrics scale sublinearly with the predicate size. When the predicate size significantly exceeds the threshold, they scale almost linearly.</p>

    <p class="text-gray-300">Fig. 3a shows that the prover time increases with arity r when the predicate is fixed. For example, fixing the predicate size as  <span class="math">2^{24}</span> , the prover time is 28s, 49s, 71s, and 94s for r=1,2,3,4, respectively. This is because higher r requires the prover to fold more instance-witness pairs. Additionally, the folding cost is almost linear in the predicate size when the size is much larger than the corresponding threshold. Thus, as shown in Fig. 3a, the gap between different r nearly doubles as the predicate size doubles.</p>

    <p class="text-gray-300">The proof size and verifier time depend on the sizes of the primary and secondary circuits. They also increase with r because a larger r leads to higher recursion overhead which in turn implies larger primary and secondary circuits. However, the increase in recursion overhead is minor compared to a large predicate size. As shown in Fig. 3b and Fig. 3c, when the</p>

    <p class="text-gray-300">predicate size is doubled, the gap between different r remains almost the same, and the curves for different r gradually tend to overlap. We conclude that as the predicate circuit size increases, the impact of increasing r on proof size and verifier time diminishes.</p>

    <p class="text-gray-300">Efficiency with compression. When instantiating our PCD scheme over a cycle of elliptic curves, the PCD proof consists of a LCCCS instance-witness pair  <span class="math">(U^{(1)},W^{(1)})</span> , a CCCS instance-witness pair  <span class="math">(u^{(1)},w^{(1)})</span>  and a committed relaxed R1CS instance-witness pair  <span class="math">(U_{EC}^{(2)},W_{EC}^{(2)})</span> . To compress this proof, we first invoke the multi-folding scheme to fold  <span class="math">(U^{(1)},W^{(1)}),(u^{(1)},w^{(1)})</span>  into a new LCCCS instance-witness pair  <span class="math">(U&#x27;^{(1)},W&#x27;^{(1)})</span> . We then invoke SuperSpartan [37] excluding the first sum-check invocation to prove the satisfiability of  <span class="math">(U&#x27;^{(1)},W&#x27;^{(1)})</span> . Next, we invoke the SNARK in Nova [29] to prove the satisfiability of  <span class="math">(U_{EC}^{(2)},W_{EC}^{(2)})</span> . In Fig. 4, we fix r=2 and compare the proof size and verifier time before and after compression.</p>

    <p class="text-gray-300">Fig. 4a shows that the proof size is significantly reduced after compression. For a predicate size of  <span class="math">2^{17}</span> , the proof size is reduced from 14MB to 11KB, and for a predicate size of  <span class="math">2^{24}</span> , it is reduced from 1031MB to 13KB. However, this reduction comes at the cost of increased verifier time, as shown in Fig. 4b. For a predicate size of  <span class="math">2^{17}</span> , the verifier time increases from 211ms to 508ms, and for a predicate size of  <span class="math">2^{24}</span> , it increases from 11s to 22s.</p>

    <p class="text-gray-300">Enforcing language semantics in distributed computations.</p>

    <p class="text-gray-300">Our PCD scheme can be naturally used in several scenarios.</p>

    <p class="text-gray-300">tiating our PCD compliance predicate  <span class="math">\\varphi</span>  with their predicate.</p>

    <p class="text-gray-300"><strong>Privacy pools.</strong> A privacy pool enables users to deposit funds into a shared pool, anonymously transfer funds within the pool, and later withdraw funds without linkage to their previous transactions. In August 2022, Tornado Cash, the largest Ethereum privacy pool, was sanctioned for purportedly laundering over $9 billion worth of cryptocurrency since 2019, making it illegal for entities to use its funds and sparking a global privacy rights debate. Beal and Fisch [1] presented a system that institutions could use to request cryptographic attestations of fund origins rather than naively rejecting all privacy pool funds. They utilized PCD to propagate allowlist membership proofs through a privacy pool's transaction graph and instantiated their system with the PCD construction of BCLMS21 [9], which incurs high overhead. In contrast, our</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;6</sup>We select the predicate as the <em>X</em>-axis since it represents the computations that the prover truly intends to prove. Moreover, since COS20 does not have open-source code and BCLMS21's library cannot be compiled due to lack of maintenance, we do not include a comparison with them.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;7</sup>The recursion overhead on the primary curve increases with the predicate size, though in a sublinear manner. This threshold is also called <em>recursion threshold</em> in [16], [9], [5].</p>

    <p class="text-gray-300">    <img src="_page_11_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">    <img src="_page_11_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">    <img src="_page_11_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Prover time at each step (b) Proof size without compression</li>
      <li>(c) Verifier time without compression</li>
    </ul>

    <p class="text-gray-300">Fig. 3: PCD efficiency for different arities and predicate sizes</p>

    <p class="text-gray-300">    <img src="_page_11_Figure_6.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 4: Comparison of the proof size and verifier time before and after compression</p>

    <p class="text-gray-300">PCD scheme has better efficiency and can be applied directly in this scenario.</p>

    <p class="text-gray-300">Scalable folding-based SNARKs. SNARKs allow a prover to generate short and efficiently verifiable proofs attesting to computation correctness. Most SNARK constructions require the prover to record the entire computation trace, resulting in high memory overhead and limited scalability. Nguyen et al. [33] proposed a framework for building folding-based SNARKs that achieves constant-size prover memory efficiency while maintaining linear prover computation efficiency. Their framework largely relies on PCD schemes. To estimate their SNARK's performance, they used a PCD scheme that combines the PCD compiler of BCLMS21 [9] with their folding scheme for polynomial relations. This PCD scheme supports degree-d gates, enabling succinct representation of high-degree computations. However, the number of group operations required by the prover and verifier scales linearly with d, nearly eliminating the benefits of high-degree gates. In contrast, our PCD scheme's group operations for the prover and verifier are independent of d, making it ideal for handling high-degree computations within their framework.</p>

    <p class="text-gray-300">PCD enables mutually distrustful parties to perform distributed computations on directed acyclic graphs in an efficiently verifiable manner. In this paper, we first construct a multi-folding scheme for an arbitrary number of instances,</p>

    <p class="text-gray-300">which could reduce the task of checking multiple instances into the task of checking one. We then construct and implement a new PCD scheme based on our multi-folding scheme. Theoretical analysis and experimental results demonstrate that our PCD scheme achieves significantly lower recursion overhead and better practical efficiency. Additionally, our PCD scheme supports the customizable constraint system with high expressivity and can be naturally applied in various scenarios, including enforcing language semantics, privacy pools, and scalable folding-based SNARKs.</p>

    <p class="text-gray-300">However, our PCD scheme does not currently achieve zero-knowledge. A recent update of HyperNova [28] introduced a new approach for randomizing IVC proofs with folding schemes to achieve zero-knowledge. We believe this approach can be applied to our PCD scheme and leave integrating it in future work.</p>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">REFERENCES</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[1] J. Beal and B. Fisch, &quot;Derecho: Privacy pools with proof-carrying disclosures,&quot; Cryptology ePrint Archive, Paper 2023/273, 2023.</p></li>
      <li><p class="text-gray-300">[2] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza, &quot;Scalable zero knowledge via cycles of elliptic curves,&quot; in <em>CRYPTO</em>, ser. LNCS, J. A. Garay and R. Gennaro, Eds., vol. 8617. Springer, 2014, pp. 276&ndash;294.</p></li>
      <li><p class="text-gray-300">[3] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer, &quot;Recursive composition and bootstrapping for SNARKS and proof-carrying data,&quot; in <em>Symposium on Theory of Computing Conference, STOC'13, Palo Alto, CA, USA, June 1-4, 2013</em>, D. Boneh, T. Roughgarden, and J. Feigenbaum, Eds. ACM, 2013, pp. 111&ndash;120.</p></li>
      <li><p class="text-gray-300">[4] D. Boneh and B. Chen, &quot;LatticeFold: A lattice-based folding scheme and its applications to succinct proof systems,&quot; Cryptology ePrint Archive, Paper 2024/257, 2024.</p></li>
      <li><p class="text-gray-300">[5] D. Boneh, J. Drake, B. Fisch, and A. Gabizon, &quot;Halo infinite: Proofcarrying data from additive polynomial commitments,&quot; in <em>CRYPTO</em>, ser. LNCS, T. Malkin and C. Peikert, Eds., vol. 12825. Springer, 2021, pp. 649&ndash;680.</p></li>
      <li><p class="text-gray-300">[6] J. Bonneau, I. Meckler, V. Rao, and E. Shapiro, &quot;Coda: Decentralized cryptocurrency at scale,&quot; Cryptology ePrint Archive, Paper 2020/352, 2020.</p></li>
      <li><p class="text-gray-300">[7] S. Bowe, J. Grigg, and D. Hopwood, &quot;Recursive proof composition without a trusted setup,&quot; Cryptology ePrint Archive, Paper 2019/1021, 2019.</p></li>
      <li><p class="text-gray-300">[8] B. B&uuml;nz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell, &quot;Bulletproofs: Short proofs for confidential transactions and more,&quot; in S&amp;P. IEEE Computer Society, 2018, pp. 315&ndash;334.</p></li>
      <li><p class="text-gray-300">[9] B. B&uuml;nz, A. Chiesa, W. Lin, P. Mishra, and N. Spooner, &quot;Proof-carrying data without succinct arguments,&quot; in <em>CRYPTO</em>, ser. LNCS, T. Malkin and C. Peikert, Eds., vol. 12825. Springer, 2021, pp. 681&ndash;710.</p></li>
      <li><p class="text-gray-300">[10] B. B&uuml;nz, A. Chiesa, P. Mishra, and N. Spooner, &quot;Recursive proof composition from accumulation schemes,&quot; in <em>TCC</em>, ser. LNCS, R. Pass and K. Pietrzak, Eds., vol. 12551. Springer, 2020, pp. 1&ndash;18.</p></li>
      <li><p class="text-gray-300">[11] B. B&uuml;nz, B. Fisch, and A. Szepieniec, &quot;Transparent snarks from DARK compilers,&quot; in <em>EUROCRYPT</em>, ser. LNCS, A. Canteaut and Y. Ishai, Eds., vol. 12105. Springer, 2020, pp. 677&ndash;706.</p></li>
      <li><p class="text-gray-300">[12] B. B&uuml;nz and B. Chen, &quot;Protostar: Generic efficient accumulation/folding for special sound protocols,&quot; Cryptology ePrint Archive, Paper 2023/620, 2023.</p></li>
      <li><p class="text-gray-300">[13] B. B&uuml;nz and J. Chen, &quot;Proofs for deep thought: Accumulation for large memories and deterministic computations,&quot; Cryptology ePrint Archive, Paper 2024/325, 2024.</p></li>
      <li><p class="text-gray-300">[14] B. B&uuml;nz, P. Mishra, W. Nguyen, and W. Wang, &quot;Accumulation without homomorphism,&quot; Cryptology ePrint Archive, Paper 2024/474, 2024.</p></li>
      <li><p class="text-gray-300">[15] W. Chen, A. Chiesa, E. Dauterman, and N. P. Ward, &quot;Reducing participation costs via incremental verification for ledger systems,&quot; Cryptology ePrint Archive, Paper 2020/1522, 2020.</p></li>
      <li><p class="text-gray-300">[16] A. Chiesa, D. Ojha, and N. Spooner, &quot;Fractal: Post-quantum and transparent recursive proofs from holography,&quot; in <em>EUROCRYPT</em>, ser. LNCS, A. Canteaut and Y. Ishai, Eds., vol. 12105. Springer, 2020, pp. 769&ndash;793.</p></li>
      <li><p class="text-gray-300">[17] A. Chiesa and E. Tromer, &quot;Proof-carrying data and hearsay arguments from signature cards,&quot; in <em>ICS</em>, A. C. Yao, Ed. Tsinghua University Press, 2010, pp. 310&ndash;331.</p></li>
      <li><p class="text-gray-300">[18] A. Chiesa, E. Tromer, and M. Virza, &quot;Cluster computing in zero knowledge,&quot; in <em>EUROCRYPT</em>, ser. LNCS, E. Oswald and M. Fischlin, Eds., vol. 9057. Springer, 2015, pp. 371&ndash;403.</p></li>
      <li><p class="text-gray-300">[19] S. Chong, E. Tromer, and J. A. Vaughan, &quot;Enforcing language semantics using proof-carrying data,&quot; Cryptology ePrint Archive, Paper 2013/513, 2013.</p></li>
      <li><p class="text-gray-300">[20] G. Cormode, M. Mitzenmacher, and J. Thaler, &quot;Practical verified computation with streaming interactive proofs,&quot; in <em>ITCS</em>, S. Goldwasser, Ed. ACM, 2012, pp. 90&ndash;112.</p></li>
      <li><p class="text-gray-300">[21] L. Eagen and A. Gabizon, &quot;Protogalaxy: Efficient protostar-style folding of multiple instances,&quot; Cryptology ePrint Archive, Paper 2023/1106, 2023.</p></li>
      <li><p class="text-gray-300">[22] A. Fiat and A. Shamir, &quot;How to prove yourself: Practical solutions to identification and signature problems,&quot; in <em>CRYPTO</em>, ser. LNCS, A. M. Odlyzko, Ed., vol. 263. Springer, 1986, pp. 186&ndash;194.</p></li>
      <li><p class="text-gray-300">[23] R. Gennaro, C. Gentry, B. Parno, and M. Raykova, &quot;Quadratic span programs and succinct nizks without pcps,&quot; in <em>EUROCRYPT</em>, ser. LNCS, T. Johansson and P. Q. Nguyen, Eds., vol. 7881. Springer, 2013, pp. 626&ndash;645.</p></li>
      <li><p class="text-gray-300">[24] J. Groth, &quot;On the size of pairing-based non-interactive arguments,&quot; in EUROCRYPT, ser. LNCS, M. Fischlin and J. Coron, Eds., vol. 9666. Springer, 2016, pp. 305&ndash;326.</p></li>
      <li><p class="text-gray-300">[25] A. Kattis and J. Bonneau, &quot;Proof of necessary work: Succinct state verification with fairness guarantees,&quot; in FC, ser. LNCS, F. Baldimtsi and C. Cachin, Eds., vol. 13951. Springer, 2023, pp. 18&ndash;35.</p></li>
      <li><p class="text-gray-300">[26] A. Kothapalli and S. Setty, &quot;Supernova: Proving universal machine executions without universal circuits,&quot; Cryptology ePrint Archive, Paper 2022/1758, 2022.</p></li>
      <li><p class="text-gray-300">[27] &mdash;, &quot;CycleFold: Folding-scheme-based recursive arguments over a cycle of elliptic curves,&quot; Cryptology ePrint Archive, Paper 2023/1192, 2023.</p></li>
      <li><p class="text-gray-300">[28] &mdash;, &quot;Hypernova: Recursive arguments for customizable constraint systems,&quot; Cryptology ePrint Archive, Paper 2023/573, 2023.</p></li>
      <li><p class="text-gray-300">[29] A. Kothapalli, S. T. V. Setty, and I. Tzialla, &quot;Nova: Recursive zero-knowledge arguments from folding schemes,&quot; in <em>CRYPTO</em>, ser. LNCS, Y. Dodis and T. Shrimpton, Eds., vol. 13510. Springer, 2022, pp. 359&ndash;388.</p></li>
      <li><p class="text-gray-300">[30] C. Lund, L. Fortnow, H. J. Karloff, and N. Nisan, &quot;Algebraic methods for interactive proof systems,&quot; in <em>FOCS</em>. IEEE Computer Society, 1990, pp. 2&ndash;10.</p></li>
      <li><p class="text-gray-300">[31] A. Naveh and E. Tromer, &quot;Photoproof: Cryptographic image authentication for any set of permissible transformations,&quot; in <em>S&amp;P</em>. IEEE Computer Society, 2016, pp. 255&ndash;271.</p></li>
      <li><p class="text-gray-300">[32] W. Nguyen, D. Boneh, and S. Setty, &quot;Revisiting the nova proof system on a cycle of curves,&quot; Cryptology ePrint Archive, Paper 2023/969, 2023.</p></li>
      <li><p class="text-gray-300">[33] W. Nguyen, T. Datta, B. Chen, N. Tyagi, and D. Boneh, &quot;Mangrove: A scalable framework for folding-based SNARKs,&quot; Cryptology ePrint Archive, Paper 2024/416, 2024.</p></li>
      <li><p class="text-gray-300">[34] Nova Contributors, &quot;Nova implementation.&quot; [Online]. Available: https://github.com/microsoft/Nova</p></li>
      <li><p class="text-gray-300">[35] Pasta Contributors, &quot;Pasta curves.&quot; [Online]. Available: https://github.com/zcash/pasta_curves</p></li>
      <li><p class="text-gray-300">[36] J. T. Schwartz, &quot;Fast probabilistic algorithms for verification of polynomial identities,&quot; <em>Journal of the ACM</em>, vol. 27, no. 4, pp. 701&ndash;717, 1980.</p></li>
      <li><p class="text-gray-300">[37] S. Setty, J. Thaler, and R. Wahby, &quot;Customizable constraint systems for succinct arguments,&quot; Cryptology ePrint Archive, Paper 2023/552, 2023.</p></li>
      <li><p class="text-gray-300">[38] N. P. Smart, &quot;The discrete logarithm problem on elliptic curves of trace one,&quot; <em>Journal of Cryptology</em>, vol. 12, no. 3, pp. 193&ndash;196, 1999.</p></li>
      <li><p class="text-gray-300">[39] J. Thaler, &quot;Proofs, arguments, and zero-knowledge,&quot; Foundations and Trends in Privacy and Security, vol. 4, no. 2-4, pp. 117&ndash;660, 2022.</p></li>
      <li><p class="text-gray-300">[40] N. Tyagi, B. Fisch, A. Zitek, J. Bonneau, and S. Tessaro, &quot;Versa: Verifiable registries with efficient client audits from RSA authenticated dictionaries,&quot; in CCS, H. Yin, A. Stavrou, C. Cremers, and E. Shi, Eds. ACM, 2022, pp. 2793&ndash;2807.</p></li>
      <li><p class="text-gray-300">[41] P. Valiant, &quot;Incrementally verifiable computation or proofs of knowledge imply time/space efficiency,&quot; in <em>TCC</em>, ser. LNCS, R. Canetti, Ed., vol. 4948. Springer, 2008, pp. 1&ndash;18.</p></li>
      <li><p class="text-gray-300">[42] V. Vu, S. T. V. Setty, A. J. Blumberg, and M. Walfish, &quot;A hybrid architecture for interactive verifiable computation,&quot; in S&amp;P. IEEE Computer Society, 2013, pp. 223&ndash;237.</p></li>
    </ul>

    <p class="text-gray-300"><strong>Theorem 1.</strong> Construction 1 is a public-coin multi-folding scheme for  <span class="math">(\\mathcal{R}_{LCCCS}, \\mathcal{R}_{CCCS}, \\mathsf{compat}, \\mu, \\nu)</span>  with perfect completeness and knowledge soundness.</p>

    <p class="text-gray-300">Proof: We now describe the proof of Theorem 1. <strong>Perfect completeness.</strong> For public parameters fpp =  <span class="math">(m, n, N, \\ell, t, q, d, \\mathsf{pp}_{\\mathsf{pcs}})</span>  and  <span class="math">s = \\log m, s&#x27; = \\log n, c</span>  consider arbitrary adversarially chosen structure  <span class="math">\\mathsf{s}_1 = \\mathsf{s}_2 = \\big((\\widetilde{M}_1, \\ldots, \\widetilde{M}_t), (S_1, \\ldots, S_q), (c_1, \\ldots, c_q)\\big), \\ \\mu</span>  satisfied  <span class="math">\\mathcal{R}_{\\mathsf{LCCCS}}</span>  instance-witness pairs  <span class="math">\\{\\phi_k\\}_{k \\in [\\mu]}</span>  and  <span class="math">\\nu</span>  satisfied  <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span>  instance-witness pairs  <span class="math">\\{\\psi_{k&#x27;}\\}_{k&#x27; \\in [\\nu]}</span> . We show  <span class="math">\\mathcal V</span>  will not abort and the folded  <span class="math">\\mathcal R_{\\mathsf{LCCCS}}</span>  instance  <span class="math">(C&#x27;, u&#x27;, \\mathbf{x}&#x27;, \\mathbf{r}&#x27;_x, v&#x27;_1, \\ldots, v&#x27;_t)</span>  is satisfied by the folded  <span class="math">\\mathcal R_{\\mathsf{LCCCS}}</span>  witness  <span class="math">\\widetilde{w&#x27;}</span> .</p>

    <p class="text-gray-300">Firstly, since  <span class="math">\\{\\phi_k\\}_{k\\in[\\mu]}</span>  are satisfied  <span class="math">\\mathcal{R}_{\\text{LCCCS}}</span>  instance-witness pairs, we have for  <span class="math">k\\in[\\mu], i\\in[t]</span>  and  <span class="math">\\phi_k.\\widetilde{z_1}=(\\phi_k.\\boldsymbol{w_1},\\phi_k.\\boldsymbol{u},\\phi_k.\\boldsymbol{x_1})</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\phi_k.v_i = \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\phi_k.\\boldsymbol{r}_x, \\boldsymbol{y}) \\cdot \\phi_k.\\widetilde{z}_1(\\boldsymbol{y})</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} \\widetilde{eq}(\\phi_k.\\boldsymbol{r}_x, \\boldsymbol{x}) \\cdot \\left(\\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{x}, \\boldsymbol{y}) \\cdot \\phi_k.\\widetilde{z}_1(\\boldsymbol{y})\\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} L_{k,i}(\\boldsymbol{x}).</span>$</p>

    <p class="text-gray-300">Furthermore, since  <span class="math">\\{\\psi_{k&#x27;}\\}_{k&#x27;\\in[\\nu]}</span>  are satisfied  <span class="math">\\mathcal{R}_{\\text{CCCS}}</span>  instance-witness pairs, we have for  <span class="math">k&#x27;\\in[\\nu]</span> ,  <span class="math">\\psi_{k&#x27;}.\\tilde{z_2}=(\\psi_{k&#x27;}.\\boldsymbol{w_2},1,\\psi_{k&#x27;}.\\mathbf{x_2})</span>  and  <span class="math">\\boldsymbol{x}\\in\\{0,1\\}^s</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{q} c_i \\cdot \\prod_{j \\in S_i} \\left( \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(\\boldsymbol{x}, \\boldsymbol{y}) \\cdot \\psi_{k&#x27;}.\\widetilde{z}_2(\\boldsymbol{y}) \\right) = 0.</span>$</p>

    <p class="text-gray-300">Denoting the left-hand side of the above equation as a polynomial  <span class="math">q_{k&#x27;}(\\boldsymbol{X})</span> , we have for  <span class="math">\\boldsymbol{x} \\in \\{0,1\\}^s</span> ,  <span class="math">q_{k&#x27;}(\\boldsymbol{x}) = 0</span> . Then the polynomial  <span class="math">G_{k&#x27;}(\\boldsymbol{X}) := \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} \\widetilde{eq}(\\boldsymbol{X}, \\boldsymbol{x}) \\cdot q_{k&#x27;}(\\boldsymbol{x})</span>  is multilinear and vanishes on all  <span class="math">\\boldsymbol{x} \\in \\{0,1\\}^s</span> . Hence, we have  <span class="math">G_{k&#x27;}(\\boldsymbol{X})</span>  is a zero polynomial. For  <span class="math">\\boldsymbol{\\beta} \\xleftarrow{\\</span>} \\mathbb{F}^s$ ,  <span class="math">G_{k&#x27;}(\\boldsymbol{\\beta}) = 0</span> . By construction, we have for  <span class="math">k&#x27; \\in [\\nu]</span> ,  <span class="math">\\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} Q_{k&#x27;}(\\boldsymbol{x}) = G_{k&#x27;}(\\boldsymbol{\\beta}) = 0</span> .</p>

    <p class="text-gray-300">Therefore, for  <span class="math">\\gamma \\stackrel{\\</span>}{\\leftarrow} \\mathbb{F}$ , we have</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\phi_{k}.v_{i} = \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\Big( \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s}} L_{k,i}(\\boldsymbol{x}) \\Big) \\\\ &amp;+ \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t+k&#x27;} \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s}} Q_{k&#x27;}(\\boldsymbol{x}) \\\\ &amp;= \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s}} \\Big( \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} L_{k,i}(\\boldsymbol{x}) + \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t+k&#x27;} Q_{k&#x27;}(\\boldsymbol{x}) \\Big) \\\\ &amp;= \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s}} g(\\boldsymbol{x}). \\end{split}</span>$</p>

    <p class="text-gray-300">Thus, by the completeness of the sum-check protocol,  <span class="math">\\mathcal V</span>  will not output &quot;reject&quot; inside it. Moreover, we have</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} c &amp;= g(\\mathbf{r}_x&#x27;) = \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} L_{k,i}(\\mathbf{r}_x&#x27;) + \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t + k&#x27;} Q_{k&#x27;}(\\mathbf{r}_x&#x27;) \\\\ &amp;= \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} e_{k,1} \\sigma_{k,i} + \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t + k&#x27;} e_2 \\Big( \\sum_{i=1}^{q} c_i \\prod_{j \\in S_i} \\theta_{k&#x27;,j} \\Big). \\end{split}</span>$</p>

    <p class="text-gray-300">We finally have that V will not abort.</p>

    <p class="text-gray-300">Secondly, by construction, we have for  <span class="math">k \\in [\\mu], k&#x27; \\in [\\nu]</span> ,</p>

    <p class="text-gray-300"><span class="math">$(\\phi_k.C_1, \\phi_k.u, \\phi_k.\\mathbf{x}_1, \\mathbf{r}&#x27;_x, \\sigma_{k,1}, \\dots, \\sigma_{k,t}; \\phi_k.\\widetilde{w_1}), (\\psi_{k&#x27;}.C_2, 1, \\psi_{k&#x27;}.\\mathbf{x}_2, \\mathbf{r}&#x27;_x, \\theta_{k&#x27;,1}, \\dots, \\theta_{k&#x27;,t}; \\psi_{k&#x27;}.\\widetilde{w_2})</span>$</p>

    <p class="text-gray-300">are all satisfied  <span class="math">\\mathcal{R}_{\\text{LCCCS}}</span>  instance-witness pairs. Therefore, for  <span class="math">\\widetilde{z&#x27;} = (\\overrightarrow{w&#x27;}, \\overrightarrow{u&#x27;}, \\mathbf{x&#x27;})</span>  and  <span class="math">i \\in [t]</span> , we have that</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} v_i&#x27; &amp;= \\sum_{k=1}^{\\mu} \\rho^{k-1} \\cdot \\sigma_{k,i} + \\sum_{k&#x27;=1}^{\\nu} \\rho^{\\mu-1+k&#x27;} \\cdot \\theta_{k&#x27;,i} \\\\ &amp;= \\sum_{k=1}^{\\mu} \\rho^{k-1} \\cdot \\left( \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}) \\cdot \\phi_k.\\widetilde{z}_1(\\boldsymbol{y}) \\right) \\\\ &amp;+ \\sum_{k&#x27;=1}^{\\nu} \\rho^{\\mu-1+k&#x27;} \\cdot \\left( \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}) \\cdot \\psi_{k&#x27;}.\\widetilde{z}_2(\\boldsymbol{y}) \\right) \\\\ &amp;= \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}) \\cdot \\left( \\sum_{k=1}^{\\mu} \\rho^{k-1} \\cdot \\phi_k.\\widetilde{z}_1(\\boldsymbol{y}) \\right) \\\\ &amp;+ \\sum_{k&#x27;=1}^{\\nu} \\rho^{\\mu-1+k&#x27;} \\cdot \\psi_{k&#x27;}.\\widetilde{z}_2(\\boldsymbol{y}) \\right) \\\\ &amp;= \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}) \\cdot \\widetilde{z}&#x27;(\\boldsymbol{y}). \\end{split}</span>$</p>

    <p class="text-gray-300">By the additive homomorphism property of the polynomial commitment scheme, we have that  <span class="math">C&#x27; = \\mathsf{Com}(\\mathsf{pp}_{\\mathsf{pcs}}, \\widetilde{w&#x27;})</span> .</p>

    <p class="text-gray-300">Therefore,  <span class="math">(C&#x27;, u&#x27;, \\mathbf{x}&#x27;, r&#x27;_x, v&#x27;_1, \\dots, v&#x27;_t)</span>  is a satisfied  <span class="math">\\mathcal{R}_{LCCCS}</span>  instance and  <span class="math">\\widetilde{w&#x27;}</span>  is the corresponding witness.</p>

    <p class="text-gray-300">We conclude that Construction 1 has perfect completeness.</p>

    <p class="text-gray-300">Knowledge soundness. Consider a malicious prover  <span class="math">\\mathcal{P}^*</span>  that succeeds with probability  <span class="math">\\epsilon</span> . For public parameters fpp =  <span class="math">(m, n, N, \\ell, t, q, d, \\mathsf{pp}_{\\mathsf{pcs}})</span>  and  <span class="math">s = \\log m, s&#x27; = \\log n</span> . Consider an adversary  <span class="math">\\mathcal{A}</span>  that adaptively picks structures  <span class="math">\\mathsf{s}_1 = \\mathsf{s}_2 = ((\\widetilde{M}_1, \\ldots, \\widetilde{M}_t), (S_1, \\ldots, S_q), (c_1, \\ldots, c_q))</span>  that satisfy compat,  <span class="math">\\mu</span>   <span class="math">\\mathcal{R}_{\\mathsf{LCCCS}}</span>  instances  <span class="math">\\{\\phi_k.\\mathsf{u}_1 := \\phi_k.(C_1, u, \\mathbf{x}_1, r_x, v_1, \\ldots, v_t)\\}_{k \\in [\\mu]}, \\ \\nu</span>   <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span>  instances  <span class="math">\\{\\psi_{k&#x27;}.\\mathsf{u}_2 := \\psi_{k&#x27;}.(C_2, \\mathbf{x}_2)\\}_{k&#x27; \\in [\\nu]}</span>  and some auxiliary state st. We construct an expected polynomial time extractor  <span class="math">\\mathcal{E}</span>  that succeeds with probability  <span class="math">\\epsilon - \\mathsf{negl}(\\lambda)</span>  in obtaining satisfied witnesses for the original instances as follows.</p>

    <p class="text-gray-300"><span class="math">$\\left(\\{\\phi_k.\\widetilde{w_1}\\}_{k\\in[\\mu]},\\{\\psi_{k&#x27;}.\\widetilde{w_2}\\}_{k&#x27;\\in[\\nu]}\\right)\\leftarrow \\mathcal{E}\\left(\\mathsf{fpp},\\rho\\right)</span>$
:</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Invoke  <span class="math">\\mathcal{A}</span>  to obtain the output tuple:  <span class="math">((s_1, s_2), \\{\\phi_k. u_1\\}_{k \\in [\\mu]}, \\{\\psi_{k&#x27;}. u_2\\}_{k&#x27; \\in [\\nu]}, st) \\leftarrow \\mathcal{A}(\\mathsf{fpp}, \\rho)</span> .</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Compute  <span class="math">(fpk, fvk) \\leftarrow \\mathcal{K}(fpp, (s_1, s_2))</span> .</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Run the interaction  <span class="math">(\\mathsf{u}^{(1)},\\widetilde{w}^{(1)}) \\leftarrow \\langle \\mathcal{P}^*(\\mathsf{fpk},\\mathsf{st}),\\mathcal{V}(\\mathsf{fvk})\\rangle (\\{\\phi_k.\\mathsf{u}_1\\}_{k\\in[\\mu]},\\{\\psi_{k&#x27;}.\\mathsf{u}_2\\}_{k&#x27;\\in[\\nu]})</span>  once with the final verifier challenge  <span class="math">\\rho^{(1)} \\stackrel{\\</span>}{\\leftarrow} \\mathbb{F}$ .</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Abort if  <span class="math">\\left(\\mathsf{fpp},\\mathsf{s}_1,\\mathsf{u}^{(1)},\\widetilde{w}^{(1)}\\right) \\notin \\mathcal{R}_{\\mathrm{LCCCS}}.</span></li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Rerun the interaction  <span class="math">(u^{(1)},\\widetilde{w}^{(1)}) \\leftarrow \\langle \\mathcal{P}^*(\\mathsf{fpk},\\mathsf{st}),\\mathcal{V}(\\mathsf{fvk}) \\rangle (\\{\\phi_k.\\mathsf{u}_1\\}_{k\\in[\\mu]},\\{\\psi_{k&#x27;}.\\mathsf{u}_2\\}_{k&#x27;\\in[\\nu]})</span>  with different verifier's final challenges while maintaining the same prior randomness. Keep doing so until it obtains  <span class="math">\\mu + \\nu 1</span>  folded  <span class="math">\\mathcal{R}_{\\mathrm{LCCCS}}</span>  instance-witness pairs  <span class="math">\\{(\\mathsf{u}^{(k&#x27;&#x27;)},\\widetilde{w}^{(k&#x27;&#x27;)})\\}_{k&#x27;&#x27;\\in[2,\\ldots,\\mu+\\nu]}</span>  such that  <span class="math">(\\mathsf{fpp},\\mathsf{s}_1,\\mathsf{u}^{(k&#x27;&#x27;)},\\widetilde{w}^{(k&#x27;&#x27;)}) \\in \\mathcal{R}_{\\mathrm{LCCS}}</span>  for all  <span class="math">k&#x27;&#x27; \\in [2,\\ldots,\\mu+\\nu]</span> . Let  <span class="math">\\{\\rho^{(k&#x27;&#x27;)}\\}</span>  denote the corresponding verifier's final challenges.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Abort if there exists a collision in the verifier's final challenges.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Interpolate points  <span class="math">\\{(\\rho^{(k&#x27;&#x27;)}, \\widetilde{w}^{(k&#x27;&#x27;)})\\}_{k&#x27;&#x27; \\in [\\mu+\\nu]}</span>  to retrieve witnesses  <span class="math">(\\{\\phi_k.\\widetilde{w_1}\\}_{k \\in [\\mu]}, \\{\\psi_{k&#x27;}.\\widetilde{w_2}\\}_{k&#x27; \\in [\\nu]})</span>  such that for  <span class="math">k&#x27;&#x27; \\in [\\mu+\\nu]</span> ,</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">
<span class="math">$\\sum_{k=1}^{\\mu} \\rho^{(k&#x27;&#x27;)k-1} \\cdot \\phi_k.\\widetilde{w_1} + \\sum_{k&#x27;=1}^{\\nu} \\rho^{(k&#x27;&#x27;)\\mu-1+k&#x27;} \\cdot \\psi_{k&#x27;}.\\widetilde{w_2} = \\widetilde{w}^{(k&#x27;&#x27;)}.</span>$
(3)</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Output  <span class="math">(\\{\\phi_k.\\widetilde{w_1}\\}_{k\\in[\\mu]}, \\{\\psi_{k&#x27;}.\\widetilde{w_2}\\}_{k&#x27;\\in[\\nu]})</span> .</li>
    </ul>

    <p class="text-gray-300">We now demonstrate that the extractor  <span class="math">\\mathcal{E}</span>  runs in expected polynomial time and succeeds with probability  <span class="math">\\epsilon - \\text{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Firstly, the extractor  <span class="math">\\mathcal E</span>  runs the interaction  <span class="math">\\langle \\mathcal P^*, \\mathcal V \\rangle</span>  once, and if it does not abort, keeps rerunning the interaction until it obtains  <span class="math">\\mu + \\nu - 1</span>  satisfied folded  <span class="math">\\mathcal R_{\\rm LCCCS}</span>  instancewitness pairs. Thus, the expected number of times  <span class="math">\\mathcal E</span>  runs the</p>

    <p class="text-gray-300">interaction is</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\text{First call to } \\langle \\mathcal{P}^*, \\mathcal{V} \\rangle \\text{ fails}] \\cdot 1 +</span></p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\text{First call to } \\langle \\mathcal{P}^*, \\mathcal{V} \\rangle \\text{ succeeds}] \\cdot \\left(1 + \\frac{\\mu + \\nu - 1}{\\Pr[\\langle \\mathcal{P}^*, \\mathcal{V} \\rangle \\text{ succeeds}]}\\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$= (1 - \\epsilon) \\cdot 1 + \\epsilon \\cdot \\left(1 + \\frac{\\mu + \\nu - 1}{\\epsilon}\\right) = \\mu + \\nu.</span>$</p>

    <p class="text-gray-300">Assuming that  <span class="math">\\mu</span> ,  <span class="math">\\nu</span>  are polynomial in the security parameter, we have that  <span class="math">\\mathcal{E}</span>  runs in expected polynomial time.</p>

    <p class="text-gray-300">Secondly, let  <span class="math">E_1</span>  denote the event that  <span class="math">\\mathcal{E}</span>  successfully produces some outputs in less than T times of running the interaction  <span class="math">\\langle \\mathcal{P}^*, \\mathcal{V} \\rangle</span> . Given  <span class="math">E_1</span> , let  <span class="math">E_2</span>  denote the event that the outputs of  <span class="math">\\mathcal{E}</span>  are satisfied witnesses. We have that  <span class="math">\\Pr[\\mathcal{E} \\text{ succeeds}] = \\Pr[E_1] \\cdot \\Pr[E_2]</span> .</p>

    <p class="text-gray-300">We now analyze  <span class="math">\\Pr[E_1]</span>  and  <span class="math">\\Pr[E_2]</span> . By the success probability of  <span class="math">\\mathcal{P}^*</span> , we have that  <span class="math">\\mathcal{E}</span>  does not abort in step (4) with probability  <span class="math">\\epsilon</span> . Given that  <span class="math">\\mathcal{E}</span>  does not abort in step (4), by Markov's inequality, we have that  <span class="math">\\mathcal{E}</span>  runs the interaction  <span class="math">\\langle \\mathcal{P}^*, \\mathcal{V} \\rangle</span>  more than T times with probability  <span class="math">\\frac{\\mu + \\nu}{T}</span> . Given that  <span class="math">\\mathcal{E}</span>  runs the interaction less than T times, which has probability  <span class="math">1 - \\frac{\\mu + \\nu}{T}</span> , we have  <span class="math">\\mathcal{E}</span>  tests at most T values for  <span class="math">\\rho</span> . Thus, the probability that  <span class="math">\\mathcal{E}</span>  does not abort in step (6) is  <span class="math">1 - \\frac{T^2}{|\\mathbb{F}|}</span> . Thus, we have</p>

    <p class="text-gray-300"><span class="math">$\\Pr[E_1] = \\left(1 - \\frac{\\mu + \\nu}{T}\\right) \\cdot \\epsilon \\cdot \\left(1 - \\frac{T^2}{|\\mathbb{F}|}\\right).</span>$</p>

    <p class="text-gray-300">Setting  <span class="math">T=\\sqrt[3]{|\\mathbb{F}|}</span>  and assuming  <span class="math">T\\geq \\mu+\\nu</span> , we have that  <span class="math">\\Pr[E_1]=\\epsilon-\\operatorname{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">To analyze  <span class="math">\\Pr[E_2]</span> , we first show that the retrieved witnesses are valid openings to the corresponding polynomial commitments in the instance, and then show that they satisfy the remaining algebraic relations with some probability. For  <span class="math">k&#x27;&#x27; \\in [\\mu + \\nu]</span> , let  <span class="math">\\mathbf{u}^{(k&#x27;&#x27;)} = (C^{(k&#x27;&#x27;)}, u^{(k&#x27;&#x27;)}, \\mathbf{x}^{(k&#x27;&#x27;)}, r_x&#x27;, v_1^{(k&#x27;&#x27;)}, \\ldots, v_t^{(k&#x27;&#x27;)})</span> . Since  <span class="math">\\widetilde{w}^{(k&#x27;&#x27;)}</span>  is a satisfied  <span class="math">\\mathcal{R}_{\\mathrm{LCCCS}}</span>  witness, we have that</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\sum_{k=1}^{\\mu} \\rho^{(k^{\\prime\\prime})k-1} \\cdot \\mathsf{Com} \\big( \\mathsf{pp}_{\\mathsf{pcs}}, \\phi_k.\\widetilde{w_1} \\big) \\\\ &amp;+ \\sum_{k^{\\prime}=1}^{\\nu} \\rho^{(k^{\\prime\\prime})\\mu-1+k^{\\prime}} \\cdot \\mathsf{Com} \\big( \\mathsf{pp}_{\\mathsf{pcs}}, \\psi_{k^{\\prime}}.\\widetilde{w_2} \\big) \\\\ &amp;= &amp;\\mathsf{Com} \\Big( \\mathsf{pp}_{\\mathsf{pcs}}, \\sum_{k=1}^{\\mu} \\rho^{(k^{\\prime\\prime})k-1} \\phi_k.\\widetilde{w_1} + \\sum_{k^{\\prime}=1}^{\\nu} \\rho^{(k^{\\prime\\prime})\\mu-1+k^{\\prime}} \\psi_{k^{\\prime}}.\\widetilde{w_2} \\big) \\\\ &amp;= &amp;\\mathsf{Com} \\big( \\mathsf{pp}_{\\mathsf{pcs}}, \\widetilde{w}^{(k^{\\prime\\prime})} \\big) \\\\ &amp;= &amp;C^{(k^{\\prime\\prime})} \\\\ &amp;= &amp;\\sum_{k=1}^{\\mu} \\rho^{(k^{\\prime\\prime})k-1} \\cdot \\phi_k.C_1 + \\sum_{k=1}^{\\nu} \\rho^{(k^{\\prime\\prime})\\mu-1+k^{\\prime}} \\cdot \\psi_{k^{\\prime}}.C_2 \\end{split}</span>$</p>

    <p class="text-gray-300">Treat the above equation as a univariate polynomial equation in  <span class="math">\\rho^{(k&#x27;&#x27;)}</span> . Since it holds for all  <span class="math">k&#x27;&#x27; \\in [\\mu + \\nu]</span> , we must have that for  <span class="math">k \\in [\\mu], k&#x27; \\in [\\nu]</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\phi_k.C_1 = \\mathsf{Com}\\big(\\mathsf{pp}_{\\mathsf{pcs}}, \\phi_k.\\widetilde{w_1}\\big), \\quad \\psi_{k&#x27;}.C_2 = \\mathsf{Com}\\big(\\mathsf{pp}_{\\mathsf{pcs}}, \\psi_{k&#x27;}.\\widetilde{w_2}\\big),</span>$</p>

    <p class="text-gray-300">which means that  <span class="math">\\left(\\{\\phi_k.\\widetilde{w_1}\\}_{k\\in[\\mu]},\\{\\psi_{k&#x27;}.\\widetilde{w_2}\\}_{k&#x27;\\in[\\nu]}\\right)</span>  are valid openings.</p>

    <p class="text-gray-300">Next, by the extractor's construction we have that  <span class="math">\\{\\sigma_{k,i},\\theta_{k&#x27;,i}\\}_{k\\in[\\mu],k&#x27;\\in[\\nu],i\\in[t]}</span>  sent by the prover are identical across all executions of the interaction  <span class="math">\\langle \\mathcal{P}^*,\\mathcal{V}\\rangle</span> . By the verifier's computation, we have that for  <span class="math">k&#x27;&#x27;\\in[\\mu+\\nu],i\\in[t]</span> ,</p>

    <p class="text-gray-300">
<span class="math">$v_i^{(k&#x27;&#x27;)} = \\sum_{k=1}^{\\mu} \\rho^{(k&#x27;&#x27;)k-1} \\cdot \\sigma_{k,i} + \\sum_{k&#x27;=1}^{\\nu} \\rho^{(k&#x27;&#x27;)\\mu-1+k&#x27;} \\cdot \\theta_{k&#x27;,i}. \\quad (4)</span>$</p>

    <p class="text-gray-300">Since  <span class="math">\\left\\{\\widetilde{w}^{(k&#x27;&#x27;)}\\right\\}_{k&#x27;&#x27;\\in[\\mu+\\nu]}</span>  are satisfied  <span class="math">\\mathcal{R}_{\\mathrm{LCCCS}}</span>  witnesses, we have that for  <span class="math">k&#x27;&#x27;\\in[\\mu+\\nu], i\\in[t]</span> ,</p>

    <p class="text-gray-300">
<span class="math">$v_i^{(k^{\\prime\\prime})} = \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s^\\prime}} \\widetilde{M}_i(\\boldsymbol{r}_x^\\prime, \\boldsymbol{y}) \\cdot \\widetilde{z}^{(k^{\\prime\\prime})}(\\boldsymbol{y}), \\tag{5}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\widetilde{z}^{(k&#x27;&#x27;)} = (w^{(k&#x27;&#x27;)}, \\widetilde{u^{(k&#x27;&#x27;)}}, \\mathbf{x}^{(k&#x27;&#x27;)})</span> . By Equations (3), (4), (5) and the verifier's computation, we have that for  <span class="math">k&#x27;&#x27; \\in [\\mu + \\nu], i \\in [t]</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\sum_{k=1}^{\\mu} \\rho^{(k&#x27;&#x27;)k-1} \\cdot \\sigma_{k,i} + \\sum_{k&#x27;=1}^{\\nu} \\rho^{(k&#x27;&#x27;)\\mu-1+k&#x27;} \\cdot \\theta_{k&#x27;,i} \\\\ &amp;= \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;,\\boldsymbol{y}) \\cdot \\widetilde{\\boldsymbol{z}}^{(k&#x27;&#x27;)}(\\boldsymbol{y}) \\\\ &amp;= \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;,\\boldsymbol{y}) \\cdot \\left(\\sum_{k=1}^{\\mu} \\rho^{(k&#x27;&#x27;)k-1} \\cdot \\phi_k.\\widetilde{\\boldsymbol{z}}_1(\\boldsymbol{y}) \\right. \\\\ &amp;+ \\sum_{k&#x27;=1}^{\\nu} \\rho^{(k&#x27;&#x27;)\\mu-1+k&#x27;} \\cdot \\psi_{k&#x27;}.\\widetilde{\\boldsymbol{z}}_2(\\boldsymbol{y}) \\right) \\\\ &amp;= \\sum_{k=1}^{\\mu} \\rho^{(k&#x27;&#x27;)k-1} \\cdot \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;,\\boldsymbol{y}) \\cdot \\phi_k.\\widetilde{\\boldsymbol{z}}_1(\\boldsymbol{y}) \\\\ &amp;+ \\sum_{k&#x27;=1}^{\\nu} \\rho^{(k&#x27;&#x27;)\\mu-1+k&#x27;} \\cdot \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;,\\boldsymbol{y}) \\cdot \\psi_{k&#x27;}.\\widetilde{\\boldsymbol{z}}_2(\\boldsymbol{y}), \\end{split}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\phi_k.\\widetilde{z_1} = (\\phi_k.w_1, \\phi_k.u, \\phi_k.x_1)</span>  and  <span class="math">\\psi_{k&#x27;}.\\widetilde{z_2} = (\\psi_{k&#x27;}.w_2, 1, \\psi_{k&#x27;}.x_2)</span> . Treat the above equation as a univariate polynomial equation in  <span class="math">\\rho^{(k&#x27;&#x27;)}</span> . Since it holds for all  <span class="math">k&#x27;&#x27; \\in [\\mu + \\nu]</span> , we must have that for  <span class="math">k \\in [\\mu], k&#x27; \\in [\\nu], i \\in [t]</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\sigma_{k,i} &amp;= \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}) \\cdot \\phi_k. \\widetilde{z}_1(\\boldsymbol{y}), \\ \\theta_{k&#x27;,i} &amp;= \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}) \\cdot \\psi_{k&#x27;}. \\widetilde{z}_2(\\boldsymbol{y}). \\end{aligned}</span>$</p>

    <p class="text-gray-300">Then since the verifier does not abort, we have that</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} c &amp;= \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\cdot e_{k,1} \\cdot \\sigma_{k,i} \\\\ &amp;+ \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t+k&#x27;} \\cdot e_{2} \\cdot \\left( \\sum_{i=1}^{q} c_{i} \\cdot \\prod_{j \\in S_{i}} \\theta_{k&#x27;,j} \\right) \\\\ &amp;= \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\cdot \\tilde{eq}(\\phi_{k}.\\boldsymbol{r}_{x}, \\boldsymbol{r}_{x}&#x27;) \\cdot \\sigma_{k,i} \\\\ &amp;+ \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t+k&#x27;} \\cdot \\tilde{eq}(\\boldsymbol{\\beta}, \\boldsymbol{r}_{x}&#x27;) \\cdot \\left( \\sum_{i=1}^{q} c_{i} \\cdot \\prod_{j \\in S_{i}} \\theta_{k&#x27;,j} \\right) \\\\ &amp;= \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\cdot L_{k,i}(\\boldsymbol{r}_{x}&#x27;) + \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t+k&#x27;} \\cdot Q_{k&#x27;}(\\boldsymbol{r}_{x}&#x27;) \\\\ &amp;= g(\\boldsymbol{r}_{x}&#x27;), \\end{split}</span>$</p>

    <p class="text-gray-300">which by the soundness of the sum-check protocol, implies that with probability  <span class="math">1 - O(s \\cdot d)/|\\mathbb{F}| = 1 - \\mathsf{negl}(\\lambda)</span>  over the choice of  <span class="math">r_x&#x27;</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\phi_{k}.v_{i} = \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s}} g(\\boldsymbol{x}) \\\\ &amp;= \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s}} \\left( \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} L_{k,i}(\\boldsymbol{x}) + \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t + k&#x27;} Q_{k&#x27;}(\\boldsymbol{x}) \\right) \\\\ &amp;= \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s}} L_{k,i}(\\boldsymbol{x}) \\\\ &amp;+ \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t + k&#x27;} \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s}} Q_{k&#x27;}(\\boldsymbol{x}). \\end{split}</span>$</p>

    <p class="text-gray-300">By the Schwartz-Zippel lemma [36], this implies that with probability  <span class="math">1 - O(\\mu \\cdot t + \\nu) / |\\mathbb{F}| = 1 - \\text{negl}(\\lambda)</span>  over the choice of  <span class="math">\\gamma</span> , we have for  <span class="math">k \\in [\\mu], i \\in [t]</span> ,</p>

    <p class="text-gray-300">
<span class="math">$\\phi_k.v_i = \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} L_{k,i}(\\boldsymbol{x}),\\tag{6}</span>$</p>

    <p class="text-gray-300">and for  <span class="math">k&#x27; \\in [\\nu]</span> ,</p>

    <p class="text-gray-300">
<span class="math">$0 = \\sum_{x \\in \\{0,1\\}^s} Q_{k&#x27;}(x). \\tag{7}</span>$</p>

    <p class="text-gray-300">Expanding Equation (6), we have that</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\phi_k.v_i &amp;= \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} L_{k,i}(\\boldsymbol{x}) \\\\ &amp;= \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} \\widetilde{eq}(\\phi_k.\\boldsymbol{r}_x,\\boldsymbol{x}) \\cdot \\Big(\\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{x},\\boldsymbol{y}) \\cdot \\phi_k.\\widetilde{z_1}(\\boldsymbol{y})\\Big) \\\\ &amp;= \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\phi_k.\\boldsymbol{r}_x,\\boldsymbol{y}) \\cdot \\phi_k.\\widetilde{z_1}(\\boldsymbol{y}). \\end{split}</span>$</p>

    <p class="text-gray-300">Since we have argued that  <span class="math">\\{\\phi_k.\\widetilde{w_1}\\}_{k\\in[\\mu]}</span>  are valid openings, we have that they are satisfied  <span class="math">\\mathcal{R}_{LCCCS}</span>  witnesses with probability  <span class="math">1-\\mathsf{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Expanding Equation (7), we have that</p>

    <p class="text-gray-300"><span class="math">$0 = \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} Q_{k&#x27;}(\\boldsymbol{x}) = \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} \\widetilde{eq}(\\boldsymbol{\\beta}, \\boldsymbol{x})</span>$</p>

    <p class="text-gray-300"><span class="math">$\\cdot \\left( \\sum_{i=1}^q c_i \\cdot \\prod_{j \\in S_i} \\left( \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(\\boldsymbol{x}, \\boldsymbol{y}) \\cdot \\psi_{k&#x27;}.\\widetilde{z}_2(\\boldsymbol{y}) \\right) \\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\sum_{i=1}^q c_i \\cdot \\prod_{j \\in S_i} \\left( \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(\\boldsymbol{\\beta}, \\boldsymbol{y}) \\cdot \\psi_{k&#x27;}.\\widetilde{z}_2\\boldsymbol{y} \\right).</span>$</p>

    <p class="text-gray-300">By the Schwartz-Zippel lemma, this implies that with probability  <span class="math">1 - O(s \\cdot d)/|\\mathbb{F}| = 1 - \\mathsf{negl}(\\lambda)</span>  over the choice of  <span class="math">\\beta</span> , we have that for all  <span class="math">x \\in \\{0,1\\}^s</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{q} c_i \\cdot \\prod_{j \\in S_i} \\left( \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(\\boldsymbol{x}, \\boldsymbol{y}) \\cdot \\psi_{k&#x27;}. \\widetilde{z}_2(\\boldsymbol{y}) \\right) = 0.</span>$</p>

    <p class="text-gray-300">Since we have argued that  <span class="math">\\{\\psi_{k&#x27;}.\\widetilde{w_2}\\}_{k&#x27;\\in[\\nu]}</span>  are valid openings, we have that they are satisfied  <span class="math">\\mathcal{R}_{\\text{CCCS}}</span>  witnesses with probability  <span class="math">1 - \\text{negl}(\\lambda)</span> . Hence, we have that  <span class="math">\\Pr[E_2] = 1 - \\text{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Therefore, we have that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathcal{E} \\text{ succeeds}] = \\Pr[E_1] \\cdot \\Pr[E_2]</span>$
<span class="math">$= (\\epsilon - \\mathsf{negl}(\\lambda)) \\cdot (1 - \\mathsf{negl}(\\lambda)) = \\epsilon - \\mathsf{negl}(\\lambda).</span>$</p>

    <p class="text-gray-300">We conclude that Construction 1 has knowledge soundness. &#9632;</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> Construction 2 is a PCD scheme with perfect completeness and knowledge soundness.</p>

    <p class="text-gray-300"><em>Proof:</em> We now describe the proof of Theorem 2.</p>

    <p class="text-gray-300"><strong>Perfect completeness.</strong> For public parameter pp, consider arbitrary adversarially chosen  <span class="math">(\\varphi, z, z_{\\text{loc}}, \\{z_i, \\Pi_i\\}_{i=1}^r)</span>  such that the perfect completeness precondition is satisfied. We show that given  <span class="math">\\Pi \\leftarrow \\mathsf{P}(\\mathsf{pk}, z, z_{\\text{loc}}, \\{z_i, \\Pi_i\\}_{i=1}^r), \\, \\mathsf{V}(\\mathsf{vk}, z, \\Pi) = 1</span>  with probability 1.</p>

    <p class="text-gray-300">If  <span class="math">z_i=\\perp</span>  for all  <span class="math">i\\in[r]</span> , by the construction of P, we have that  <span class="math">(\\mathsf{U},\\mathsf{W})=(\\mathsf{u}_\\perp,\\mathsf{w}_\\perp)</span>  is a trivially satisfied  <span class="math">\\mathcal{R}_{\\mathrm{LCCCS}}</span>  instance-witness pair, and  <span class="math">h=\\mathsf{hash}(\\mathsf{fvk},z,\\mathsf{U}).</span>  By the perfect completeness precondition, we have that  <span class="math">\\varphi(z,z_{\\mathrm{loc}},z_1,\\ldots,z_r)=1.</span>  Therefore, P could construct a satisfied  <span class="math">\\mathcal{R}_{\\mathrm{CCCS}}</span>  instance-witness pair  <span class="math">(\\mathsf{u},\\mathsf{w})</span>  that represents the correct computation of  <span class="math">R_\\varphi</span> . Moreover, by the construction of  <span class="math">R_\\varphi</span> , we have  <span class="math">\\mathsf{u}.\\mathsf{x}=\\mathsf{hash}(\\mathsf{fvk},z,\\mathsf{U}).</span>  Thus,  <span class="math">\\mathsf{V}(\\mathsf{vk},z,\\Pi)=1</span>  with probability 1.</p>

    <p class="text-gray-300">If  <span class="math">\\exists i \\in [r]</span>  such that  <span class="math">z_i \\neq \\bot</span> , by the perfect completeness precondition,  <span class="math">\\{(\\mathsf{U}_i,\\mathsf{W}_i)\\}_{i\\in[r]}</span>  included in  <span class="math">\\{\\Pi_i\\}_{i\\in[r]}</span>  are satisfied  <span class="math">\\mathcal{R}_{\\mathrm{LCCCS}}</span>  instance-witness pairs,  <span class="math">\\{(\\mathsf{u}_i,\\mathsf{w}_i)\\}_{i\\in[r]}</span>  included in  <span class="math">\\{\\Pi_i\\}_{i\\in[r]}</span>  are satisfied  <span class="math">\\mathcal{R}_{\\mathrm{CCCS}}</span>  instance-witness pairs, and  <span class="math">\\mathsf{u}_i.\\mathsf{x} = \\mathsf{hash}(\\mathsf{fvk},z_i,\\mathsf{U}_i).</span>  Then by the perfect completeness of the multi-folding scheme, we have that  <span class="math">(\\mathsf{U},\\mathsf{W})</span>  is a satisfied  <span class="math">\\mathcal{R}_{\\mathrm{LCCS}}</span>  intance-witness pair. Therefore, P could construct a satisfied  <span class="math">\\mathcal{R}_{\\mathrm{CCCS}}</span>  instance-witness pair  <span class="math">(\\mathsf{u},\\mathsf{w})</span>  that represents the correct computation of  <span class="math">R_\\varphi</span> . Additionally, by the construction of  <span class="math">R_\\varphi</span> , we have that  <span class="math">\\mathsf{u}.\\mathsf{x} = \\mathsf{hash}(\\mathsf{fvk},z,\\mathsf{U}).</span>  Therefore,  <span class="math">\\mathsf{V}(\\mathsf{vk},z,\\Pi) = 1</span>  with probability 1.</p>

    <p class="text-gray-300">We conclude that Construction 2 has perfect completeness.</p>

    <p class="text-gray-300"><strong>Knowledge soundness.</strong> We mainly refer to the proof of the PCD scheme of B&uuml;nz et al [9]. Fix a set Z, and for pp  <span class="math">\\leftarrow</span>  G  <span class="math">(1^{\\lambda})</span> , ai  <span class="math">\\leftarrow</span>   <span class="math">\\mathcal{D}(pp)</span> , consider an expected polynomial time adversary P* that succeeds with probability  <span class="math">\\epsilon</span> . We construct an expected polynomial time extractor  <span class="math">\\mathcal{E}_{P^*}</span>  that with input (pp, ai), outputs  <span class="math">(\\varphi, T, ao)</span>  such that  <span class="math">\\varphi \\in F</span> ,  <span class="math">(pp, ai, \\varphi, o(T), ao) \\in Z</span>  and T is  <span class="math">\\varphi</span> -compliant with probability  <span class="math">\\epsilon - \\text{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Referring to existing works [10], [9], we assume that every node has a unique outgoing edge. Thus, the extracted transcript T will be a tree. Let every node v be labeled with a local data  <span class="math">z_{\\text{loc}}^{(v)}</span> , the label  <span class="math">z^{(v)}</span>  of its unique outgoing edge and a proof  <span class="math">\\Pi^{(v)}</span>  that proves the correctness of  <span class="math">z^{(v)}</span> . We first present the construction of  <span class="math">\\mathcal{E}_{\\mathsf{P}^*}</span>  that extracts the labels of all the nodes in T, and then explain its correctness.</p>

    <p class="text-gray-300">We construct  <span class="math">\\mathcal{E}_{\\mathsf{P}^*}</span>  via an iterative process that constructs a sequence of extractors  <span class="math">\\mathcal{E}_0, \\mathcal{E}_1, \\dots, \\mathcal{E}_d</span> , where d is the depth of T and for  <span class="math">i \\in \\{0,1,\\dots,d\\}</span> ,  <span class="math">\\mathcal{E}_i</span>  outputs a tree  <span class="math">\\mathsf{T}_i</span>  of depth i+1. In particular, the nodes of  <span class="math">\\mathsf{T}_d</span>  at depth d+1 are all empty nodes. We argue later that the extractor  <span class="math">\\mathcal{E}_d</span>  is then equal to  <span class="math">\\mathcal{E}_{\\mathsf{P}^*}</span> .</p>

    <p class="text-gray-300">In the base case, we define  <span class="math">\\mathcal{E}_0(\\mathsf{pp},\\mathsf{ai})</span>  to compute  <span class="math">(\\varphi,\\mathsf{o},\\Pi,\\mathsf{ao})\\leftarrow\\mathsf{P}^*(\\mathsf{pp},\\mathsf{ai})</span>  and output  <span class="math">(\\varphi,\\mathsf{T}_0,\\mathsf{ao}),</span>  where  <span class="math">\\mathsf{T}_0</span>  is a single node labeled with  <span class="math">(\\mathsf{o},\\Pi).</span></p>

    <p class="text-gray-300">Next, we construct the extractor  <span class="math">\\mathcal{E}_i</span>  inductively for each  <span class="math">i \\in [d]</span> , given that we have already constructed  <span class="math">\\mathcal{E}_{i-1}</span> . We denote  <span class="math">S_{\\mathsf{T}}(i)</span>  as the set of nodes of T at depth i. We first construct an adversary  <span class="math">\\mathcal{P}_{i-1}^*</span>  for the non-interactive multi-folding scheme using  <span class="math">\\mathcal{E}_{i-1}</span> , which implies an extractor  <span class="math">\\mathcal{E}_{\\mathcal{P}_{i-1}^*}</span>  corresponding to  <span class="math">\\mathcal{P}_{i-1}^*</span>  by the knowledge soundness of the multi-folding scheme, and then construct  <span class="math">\\mathcal{E}_i</span>  using  <span class="math">\\mathcal{P}_{i-1}^*</span> ,  <span class="math">\\mathcal{E}_{\\mathcal{P}_{i-1}^*}</span> .</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Compute  <span class="math">(\\varphi, \\mathsf{T}_{i-1}, \\mathsf{ao}) \\leftarrow \\mathcal{E}_{i-1}(\\mathsf{pp}, \\mathsf{ai})</span> . If  <span class="math">\\mathsf{T}_{i-1}</span>  is not a tree of depth i, abort.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>For each node  <span class="math">v \\in S_{\\mathsf{T}_{i-1}}(i)</span> , denote its label as  <span class="math">(z^{(v)},\\Pi^{(v)})</span> .</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Parse  <span class="math">\\Pi^{(v)}</span>  as  <span class="math">((\\mathsf{U}^{(v)},\\mathsf{W}^{(v)}),(\\mathsf{u}^{(v)},\\mathsf{w}^{(v)}))</span> .</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Obtain  <span class="math">\\left\\{ \\mathsf{U}_{j}^{(v)}, \\mathsf{u}_{j}^{(v)}, z_{j}^{(v)} \\right\\}_{j \\in [r]}, \\pi^{(v)}</span>  from  <span class="math">\\mathsf{w}^{(v)}</span> .</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Let  <span class="math">S_{i-1} := \\{ v \\in S_{\\mathsf{T}_{i-1}}(i) \\mid \\exists j \\in [r], z_j^{(v)} \\neq \\perp \\}.</span></li>
    </ul></li>
      <li><span class="math">\\begin{aligned} &amp;\\text{6. Output } \\left( \\left\\{ \\left\\{ \\mathsf{U}_{j}^{(v)}, \\mathsf{u}_{j}^{(v)} \\right\\}_{j \\in [r]}, \\mathsf{U}^{(v)}, \\mathsf{W}^{(v)}, \\pi^{(v)} \\right\\}_{v \\in S_{i-1}}, \\\\ &amp; (\\varphi, \\mathsf{T}_{i-1}, \\mathsf{ao}) \\right). \\end{aligned}</span></li>
    </ul>

    <p class="text-gray-300">By the knowledge soundness of the multi-folding scheme, there exists an extractor  <span class="math">\\mathcal{E}_{\\mathcal{P}_{i-1}^*}</span>  that for  <span class="math">v \\in S_{i-1}</span> , outputs  <span class="math">\\left\\{\\mathsf{W}_j^{(v)}, \\mathsf{w}_j^{(v)}\\right\\}_{j \\in [r]}</span>  such that  <span class="math">\\left\\{\\left(\\mathsf{U}_j^{(v)}, \\mathsf{W}_j^{(v)}\\right)\\right\\}_{j \\in [r]}</span>  are satisfied  <span class="math">\\mathcal{R}_{\\mathrm{LCCS}}</span>  instance-witness pairs and  <span class="math">\\left\\{\\left(\\mathsf{u}_j^{(v)}, \\mathsf{w}_j^{(v)}\\right)\\right\\}_{j \\in [r]}</span>  are satisfied  <span class="math">\\mathcal{R}_{\\mathrm{CCCS}}</span>  instance-witness pairs.</p>

    <p class="text-gray-300">Given  <span class="math">\\mathcal{P}_{i-1}^*, \\mathcal{E}_{\\mathcal{P}_{i-1}^*}</span> , we construct  <span class="math">\\mathcal{E}_i</span>  as follows.</p>

    <p class="text-gray-300"><span class="math">$(\\varphi,\\mathsf{T}_i,\\mathsf{ao})\\leftarrow\\mathcal{E}_i(\\mathsf{pp},\\mathsf{ai})</span>$
:</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><span class="math">$\\begin{split} \\text{1. Compute } \\left( \\left\\{ \\left( \\mathsf{U}_{j}^{(v)}, \\mathsf{W}_{j}^{(v)} \\right), \\left( \\mathsf{u}_{j}^{(v)}, \\mathsf{w}_{j}^{(v)} \\right) \\right\\}_{j \\in [r], v \\in S_{i-1}}, \\\\ \\left( \\varphi, \\mathsf{T}_{i-1}, \\mathsf{ao} \\right) \\right) \\leftarrow \\mathcal{E}_{\\mathcal{P}_{i-1}^*}(\\mathsf{pp}, \\mathsf{ai}, \\rho). \\text{ If } \\mathsf{T}_{i-1} \\text{ is not a tree of depth } i, \\text{ abort.} \\end{split}</span>$</li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Retrieve  <span class="math">\\{\\mathbf{w}^{(v)}\\}_{v \\in S_{\\mathsf{T}_{i-1}}(i)}</span>  from the internal state of  <span class="math">\\mathcal{P}^*_{i-1}</span> , and obtain  <span class="math">z^{(v)}_{\\mathsf{loc}}, \\{z^{(v)}_j\\}_{j \\in [r]}</span>  from  <span class="math">\\mathbf{w}^{(v)}</span> .</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Append  <span class="math">z_{loc}^{(v)}</span>  to the label of  <span class="math">v \\in S_{\\mathsf{T}_{i-1}}(i)</span> .</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>For each node  <span class="math">v \\in S_{i-1}</span> , let  <span class="math">S_v \\coloneqq \\left\\{j \\in [r] \\mid z_j^{(v)} \\neq \\perp\\right\\}</span> . Construct  <span class="math">\\mathsf{T}_i</span>  of depth i+1 from  <span class="math">\\mathsf{T}_{i-1}</span>  by adding, for each node  <span class="math">v \\in S_{i-1}</span> ,  <span class="math">\\left(z_j^{(v)}, \\Pi_j^{(v)}\\right)</span>  to the label of its child  <span class="math">j \\in S_v</span> , where  <span class="math">\\Pi_j^{(v)} = \\left(\\left(\\mathsf{U}_j^{(v)}, \\mathsf{W}_j^{(v)}\\right), \\left(\\mathsf{u}_j^{(v)}, \\mathsf{w}_j^{(v)}\\right)\\right)</span> .</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Output  <span class="math">(\\varphi, \\mathsf{T}_i, \\mathsf{ao})</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">We now show inductively that the extractors are correct. We define the <em>inductive hypothesis</em> as that for  <span class="math">i \\in \\{0,1,\\ldots,d\\}</span> ,  <span class="math">\\mathcal{E}_i(\\mathsf{pp},\\mathsf{ai})</span>  outputs  <span class="math">(\\varphi,\\mathsf{T}_i,\\mathsf{ao})</span>  in expected polynomial time such that with probability  <span class="math">\\epsilon - \\mathsf{negl}(\\lambda)</span> , 1)  <span class="math">\\varphi \\in \\mathsf{F}, (\\mathsf{pp},\\mathsf{ai},\\varphi,\\mathsf{o}(\\mathsf{T}_i),\\mathsf{ao}) \\in Z</span> , 2)  <span class="math">\\mathsf{T}_i</span>  is  <span class="math">\\varphi</span> -compliant up to depth i, and 3) for all  <span class="math">v \\in S_{\\mathsf{T}_i}(i+1)</span> ,  <span class="math">\\mathsf{V}(\\mathsf{vk},z^{(v)},\\Pi^{(v)}) = 1</span> .</p>

    <p class="text-gray-300">In the base case, by the premise of  <span class="math">P^*</span> ,  <span class="math">\\mathcal{E}_0</span>  satisfies the inductive hypothesis.</p>

    <p class="text-gray-300">Next, supposing that  <span class="math">\\mathcal{E}_{i-1}</span>  satisfies the inductive hypothesis, we show that  <span class="math">\\mathcal{E}_i</span>  also satisfies the inductive hypothesis. By the premise of  <span class="math">\\mathcal{E}_{i-1}</span> , we have that with probability  <span class="math">\\epsilon - \\operatorname{negl}(\\lambda)</span> ,  <span class="math">\\varphi \\in \\mathsf{F}, (\\mathsf{pp}, \\mathsf{ai}, \\varphi, \\mathsf{o}(\\mathsf{T}_{i-1}), \\mathsf{ao}) \\in Z</span> ,  <span class="math">\\mathsf{T}_{i-1}</span>  is  <span class="math">\\varphi</span> -compliant up to depth i-1, and for all  <span class="math">v\\in S_{\\mathsf{T}_{i-1}}(i),\\;\\mathsf{V}\\big(\\mathsf{vk},z^{(v)},\\Pi^{(v)}\\big)=1.</span>  By the check of V, we have that (1)  <span class="math">\\{(\\mathsf{U}^{(v)}, \\mathsf{W}^{(v)}), (\\mathsf{u}^{(v)}, \\mathsf{w}^{(v)})\\}_{v \\in S_{\\mathsf{T}_{i-1}}(i)}</span> are satisfied instance-witness pairs. Additionally by the construction of  <span class="math">R_{\\varphi}</span>  and the collision-resistant property of the hash function, we have that (2) for  <span class="math">v \\in S_{\\mathsf{T}_{i-1}}(i)</span> ,  <span class="math">\\varphi(z^{(v)}, z_{\\text{loc}}^{(v)}, z_1^{(v)}, \\dots, z_r^{(v)})</span>  accepts, (3) for  <span class="math">v \\in S_{i-1}</span> ,  <span class="math">\\mathsf{U}^{(v)} =</span> NIMFS. <span class="math">\\mathcal{V}(\\mathsf{fvk}, \\{\\mathsf{U}_j^{(v)}\\}_{j \\in [r]}, \\{\\mathsf{u}_j^{(v)}\\}_{j \\in [r]}, \\pi^{(v)})</span> , and (4) for  <span class="math">v \\in S_{i-1}, j \\in [r]</span> ,  <span class="math">\\mathsf{u}_j^{(v)}</span> .<strong>x</strong> = hash(fvk,  <span class="math">z_j^{(v)}, \\mathsf{U}_j^{(v)}</span> ). Condition (2) implies that  <span class="math">\\mathsf{T}_i</span>  is  <span class="math">\\varphi</span> -compliant up to depth i, and  <span class="math">\\varphi \\in \\mathsf{U}_i</span>  <span class="math">\\mathsf{F}, (\\mathsf{pp}, \\mathsf{ai}, \\varphi, \\mathsf{o}(\\mathsf{T}_i), \\mathsf{ao}) \\in Z \\text{ with probability } \\epsilon - \\mathrm{negl}(\\lambda).</span> Conditions (1)(3) imply that  <span class="math">\\mathcal{P}_{i-1}^*</span>  succeeds in producing satisfied folded instance-witness pairs  <span class="math">\\left\\{\\mathsf{U}^{(v)},\\mathsf{W}^{(v)}\\right\\}_{v\\in S_{i-1}}</span>  for instances  <span class="math">\\left\\{\\mathsf{U}_{j}^{(v)},\\mathsf{u}_{j}^{(v)}\\right\\}_{j\\in[r],v\\in S_{i-1}}</span>  with probability  <span class="math">\\epsilon-\\mathrm{negl}(\\lambda)</span> . Then by the knowledge soundness of the multi-folding scheme, we have that  <span class="math">\\mathcal{E}_{\\mathcal{P}_{i-1}^*}</span>  succeeds in outputing satisfied witnesses  <span class="math">\\{\\mathsf{W}_{j}^{(v)},\\mathsf{w}_{j}^{(v)}\\}_{j\\in[r],v\\in S_{i-1}}</span>  with probability  <span class="math">\\epsilon-\\mathrm{negl}(\\lambda)</span> . Additionally by Condition (4), we have that  <span class="math">V(vk, z^{(v)}, \\Pi^{(v)}) = 1</span> for all  <span class="math">v \\in S_{\\mathsf{T}_i}(i+1)</span>  with probability  <span class="math">\\epsilon - \\operatorname{negl}(\\lambda)</span> . Since  <span class="math">\\mathcal{E}_{i-1}</span> runs in expected polynomial time,  <span class="math">\\mathcal{E}_{\\mathcal{P}_{i-1}^*}</span>  also runs in expected polynomial time, and thereby so does  <span class="math">\\mathcal{E}_i</span> . Therefore, we have that  <span class="math">\\mathcal{E}_i</span>  satisfies the inductive hypothesis.</p>

    <p class="text-gray-300">We conclude that Construction 2 has knowledge soundness.</p>

    </section>
`;
---

<BaseLayout title="Proof-Carrying Data from Multi-folding Schemes (2023/1282)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/1282
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="proof-carrying-data-from-multi-folding-schemes-2023" />
  </article>
</BaseLayout>
