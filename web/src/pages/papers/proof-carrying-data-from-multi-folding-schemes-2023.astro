---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/1282';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Proof-Carrying Data from Multi-folding Schemes';
const AUTHORS_HTML = 'Zibo Zhou, Zongyang Zhang, Zhiyu Zhang, Jin Dong';

const CONTENT = `    <p class="text-gray-300">Zibo Zhou Beihang University zbzhou@buaa.edu.cn Zongyang Zhang Beihang University zongyangzhang@buaa.edu.cn Zhiyu Zhang N Labs zknevermore@gmail.com Jin Dong BABEC dongjin@baec.org.cn</p>

    <p class="text-gray-300">Abstract—Proof-carrying data (PCD) is a cryptographic primitive enabling mutually distrustful parties to perform distributed computations on directed acyclic graphs with efficient and incremental verification. Key performance metrics include the prover cost at each step and the recursion overhead, which measures the additional cost beyond proving the original computation. Despite substantial advancements in constructing efficient PCD schemes, these metrics continue to be bottlenecks hindering their widespread application.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this paper, we advance the research by constructing a new PCD scheme based on a new generalized construction of multifolding schemes. Compared with the state-of-the-art PCD scheme by Bünz et al. (CRYPTO'21), our scheme reduces the prover cost at each step from 4r+6 multi-scalar multiplications (MSMs) of size O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) to 1 MSM of the same size, and the recursion overhead from 6 MSMs of size  <span class="math">2r-1,\\,1</span>  MSM of size 6r-3 to 1 MSM of size  <span class="math">2r-1,\\,</span>  where r is the number of incoming edges at certain step and</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is the proving computation size. Additionally, our PCD scheme supports a more expressive constraint system for encoding computations, namely the  <span class="math">customizable\\ constraint\\ system</span> , which supports high-degree constraints, in contrast to the  <span class="math">rank-1\\ constraint\\ system</span>  adopted by existing PCD schemes that only supports quadratic constraints.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We implement our PCD scheme and report the concrete recursion overhead and practical efficiency for different values of r and</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. Compared with Bünz et al. (CRYPTO'21), our PCD scheme achieves a 2.5 times lower recursion overhead when r=2 and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{20}<span class="math"> . Additionally, when r=2 and a proving computation size (excluding recursion overhead) of  </span>2^{24}$ , it takes 49 seconds to generate a PCD proof at each step. Using a SNARK to compress the proof reduces the proof size from 1031 MB to 13 KB, with a tradeoff in the verifier time, which increases from 10 seconds to 22 seconds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-2" class="text-2xl font-bold">I. INTRODUCTION</h2>

    <p class="text-gray-300">Proof-carrying data (PCD), introduced by Chiesa and Tromer [17], is a powerful cryptographic primitive that enables mutually distrustful parties to perform distributed computations on directed acyclic graphs, while every intermediate state of the computation can be verified efficiently. It generalizes incrementally verifiable computation (IVC) [41] which enables a possibly infinite computation on path graphs such that the correctness can be verified efficiently at any point. PCD has found numerous applications in enforcing language semantics [19], verifiable MapReduce computations [18], image authentication [31], verifiable registries [40], privacy pools [1] and blockchains [6], [15], [25].</p>

    <p class="text-gray-300">There has been tremendous interest and progress in designing efficient PCD schemes. A classic method for constructing PCD is via <em>recursive composition</em> of succinct non-interactive argument of knowledge (SNARK) [3], [2], [16]. Informally, at each step <em>i</em>, the prover uses a SNARK to prove that the <em>i</em>-th</p>

    <p class="text-gray-300">step of the computation is executed correctly and the SNARK verifier expressed as a circuit has accepted the SNARK proof from step i-1. The performance of PCD schemes is mainly measured by the prover cost at each step and the <em>recursion overhead</em>. In particular, the recursion overhead indicates the verifier's operations expressed as a circuit that the prover must prove at each step besides proving the original computation. The SNARK-based method yields a secure PCD construction. However, the concrete efficiency is limited by the use of cycles of expensive pairing-friendly elliptic curves for pairing-based SNARKs [2] or heavy use of cryptographic hash functions for hash-based SNARKs [16].</p>

    <p class="text-gray-300">Bünz et al. [10] introduced an alternative method for constructing PCD by formalizing a novel notion—atomic accumulation scheme from Halo [7]. Instead of expressing the entire SNARK verifier as a circuit, this approach requires only the verifier of the atomic accumulation scheme to be expressed as a circuit, significantly reducing its size. However, the prover at each step has to perform expensive fast Fourier transforms (FFTs) and the recursion overhead is still dominated by group operations that scale logarithmically with the computation size. Subsequently, Bünz et al. [9] extended the notion of atomic accumulation scheme to split accumulation scheme. By designing a non-interactive argument of knowledge (NARK) with a split accumulation scheme for rank-1 constraint system (R1CS) [23], they constructed a PCD scheme where the recursion overhead is dominated by a constant number of group operations. Despite this improvement, the prover at each step still has to generate a NARK proof, leading to relatively high prover cost and recursion overhead. Moreover, the computation at each step is encoded as R1CS which only supports degree-2 gates, limiting the PCD's capability to succinctly express complex computations.</p>

    <p class="text-gray-300">Following [10], [9], Kothapalli et al. [29] introduced an elegant notion—folding scheme to construct an IVC scheme called Nova. Due to the simplicity of the folding scheme, Nova has significantly low prover cost and recursion overhead. However, the folding scheme and consequently Nova are specifically tailored to R1CS, which has limited expressivity. Later, Kothapalli and Setty [28] generalized the folding scheme to a multi-folding scheme and then constructed an IVC scheme named HyperNova. In particular, the multi-folding scheme is designed for <em>customizable constraint system (CCS)</em> [37] that captures not only R1CS but also Plonkish<sup>1</sup>, which supports more expressive high-degree gates, thereby allowing certain computations to be expressed with smaller circuit sizes. Nevertheless, both Nova and HyperNova are IVC schemes, which are a specialized case of PCD. How to adapt them to construct</p>

    <p class="text-gray-300"><span id="page-0-0"></span><sup>&</sup>lt;sup>1</sup>https://zcash.github.io/halo2/concepts/arithmetization.html</p>

    <p class="text-gray-300">a PCD scheme with high performance and expressivity remains an unsolved problem.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">A. Our Contributions</h3>

    <p class="text-gray-300">In this paper, we construct and implement a PCD scheme from the multi-folding scheme. Our concrete contributions are elaborated below.</p>

    <p class="text-gray-300">A multi-folding scheme for an arbitrary number of instances. We extend the multi-folding scheme in Hyper-Nova [28], which originally folds two instances, to support folding an arbitrary number of instances. Our scheme could reduce the task of checking multiple instances to the task of checking a single instance. By using the Fiat-Shamir transformation [22] we could make it non-interactive, which is the basis of our PCD scheme.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An efficient PCD scheme supporting the customizable constraint system. We construct an efficient PCD scheme that supports the customizable constraint system with high expressivity. We provide a comparison of PCD schemes in Table I. For fairness, we treat CCS as R1CS here and report the corresponding efficiency measurements. The exact efficiency with CCS can be found in the efficiency analysis part in Section IV-B. For a proving computation of size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and PCD arity r (the number of incoming edges of a node), the recursion overhead of our PCD scheme is dominated by 1 multi-scalar multiplication (MSM)<sup>2</sup> of size 2r-1,  $O(r \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> field operations and  </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  hash operations. The prover cost at each step is dominated by 1 MSM of size O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">). Compared to the state-of-the-art PCD scheme BCLMS21 [9], these metrics are significantly improved<sup>3</sup>. Additionally, by using the SNARK called SuperSpartan [37] to compress the proof, our PCD scheme achieves a logarithmic proof size, with the verifier cost dominated by 1 MSM of size O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-1-0"></span>TABLE I: Comparison of proof-carrying data schemes</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BCTV14 [2]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">COS20 [16]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BCLMS21 [9]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This work</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Constraint<br>system</td>

            <td class="px-3 py-2 border-b border-gray-700">R1CS</td>

            <td class="px-3 py-2 border-b border-gray-700">R1CS</td>

            <td class="px-3 py-2 border-b border-gray-700">R1CS</td>

            <td class="px-3 py-2 border-b border-gray-700">CCS</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Recursion overhead</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">3r \\ \\mathbb{P}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O(r \\log^2  C ) \\mathbb{F}</span><br><span class="math">O(r \\log^2  C ) \\mathbb{H}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\begin{array}{c} 6~(2r-1)\\text{-MSM} \\\\ 1~(6r-3)\\text{-MSM} \\\\ 5r~\\mathbb{G} \\end{array}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\begin{array}{c} 1 \\; (2r-1)\\text{-MSM} \\\\ O(r \\log  C ) \\; \\mathbb{F} \\\\ O(\\log  C ) \\; \\mathbb{H} \\end{array}</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prover cost<br>(each step)</td>

            <td class="px-3 py-2 border-b border-gray-700">O( C )-FFT<br>O( C )-MSM</td>

            <td class="px-3 py-2 border-b border-gray-700">O( C )-FFT<br>O( C )-MHT</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">4r+6\\\\O( C )\\text{-MSM}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">0( C )-MSM</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof size</td>

            <td class="px-3 py-2 border-b border-gray-700">2 G <sub>1</sub><br>1 G <sub>2</sub></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O(\\log^2  C ) \\mathbb{F}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O( C ) \\mathbb{F}</span> 15 <span class="math">\\mathbb{G}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O(\\log  C ) \\mathbb{F}</span><br><span class="math">O(\\log  C ) \\mathbb{G}</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verifier cost</td>

            <td class="px-3 py-2 border-b border-gray-700">3 ₽</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O(\\log^2  C ) \\mathbb{F}</span><br><span class="math">O(\\log^2  C ) \\mathbb{H}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">O( C )-MSM</td>

            <td class="px-3 py-2 border-b border-gray-700">0( C )-MSM</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-1-2"></span>Notes: BCTV14 [2] is instantiated with [24]. R1CS denotes rank-1 constraint system. CCS denotes customizable constraint system. r denotes the PCD arity.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">denotes the proving computation size.  <span class="math">\\mathbb G</span>  denotes group scalar multiplications when measuring proof size. Similarly,  <span class="math">\\mathbb F</span>  denotes field operations or field elements.  <span class="math">\\mathbb G_1, \\mathbb G_2</span>  denote pairing-friendly group elements.  <span class="math">\\mathbb H</span>  denotes hash operations.  <span class="math">\\mathbb P</span>  denotes pairing operations. 1 O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)-MSM denotes one multi-scalar multiplication of size O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">). O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)-FFT denotes FFT over an O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)-sized vector. O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)-MHT denotes constructing Merkle tree over an O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)-sized vector.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An efficient implementation of a PCD scheme from the multi-folding scheme. We implement our multi-folding scheme and PCD scheme by adapting CycleFold [27], a conceptually simple approach to implement folding-schemebased recursive arguments. We report experimental results for the concrete recursion overhead and PCD's efficiency before and after compression across different arities r and proving computation sizes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. With r=2 and</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">of  <span class="math">2^{20}</span> R1CS constraints, the concrete recursion overhead of our PCD scheme is 110,213 R1CS constraints, significantly smaller than the 274, 856 constraints in BCLMS21. Furthermore, with r=2 and the proving computation size (excluding recursion overhead) of 2<sup>20</sup> R1CS constraints, it takes 3.3 seconds to generate a PCD proof at each step. Using SuperSpartan to compress the proof reduces the proof size from 70MB to 12KB, with a tradeoff in the verifier time, increasing from 0.8 seconds to 1.6 seconds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">B. Related Work</h4>

    <p class="text-gray-300">Valiant [41] introduced incrementally verifiable computation (IVC), which allows a computation defined on path graphs to be verified incrementally. Chiesa and Tromer [17] generalized IVC to proof-carrying data (PCD) by enabling computations to be defined on arbitrary directed acyclic graphs. Subsequently, numerous works have advanced the theoretical foundations of IVC and PCD and studied their practical constructions.</p>

    <p class="text-gray-300"><strong>IVC/PCD from SNARKs.</strong> Bitansky et al. [3] demonstrated that any SNARK for machine computation can be efficiently transformed into a PCD scheme via recursive composition. Ben-Sasson et al. [2] achieved the first implementation of PCD using pairing-based SNARKs instantiated with pairing-friendly cycles of elliptic curves. However, these curves require large fields due to their low embedding degrees, leading to poor concrete efficiency. Chiesa et al. [16] realized the first efficient post-quantum PCD, but its concrete efficiency is limited by the heavy use of hash functions in the circuit.</p>

    <p class="text-gray-300">IVC/PCD from accumulation/folding schemes. Bünz et al. [10] developed and formalized a novel approach from Bowe et al. [7] to construct PCD, known as PCD from atomic accumulation schemes. Bünz et al. [9] further improved this approach by introducing split accumulation schemes to enhance PCD construction. Meanwhile, Boneh et al. [5] formalized a method for constructing PCD using additive polynomial commitment schemes with an aggregation scheme. Their method is closely related to PCD from atomic/split accumulation schemes. Kothapalli et al. [29] introduced a conceptually simpler notion of folding schemes and used them to construct an IVC scheme. Compared to the SNARK-based method, the accumulation/folding-based method achieves significantly better prove efficiency and lower recursion overhead.</p>

    <p class="text-gray-300">To enhance IVC's support for expressive high-degree and lookup gates, Kothapalli and Setty [28] introduced the notion of multi-folding schemes designed for the customizable constraint system [37]. They also integrated SuperNova [26] to support non-uniform circuits and CycleFold [27] for efficient implementation. Bünz and Chen [12] introduced an approach for constructing accumulation and IVC schemes from any interactive public-coin protocol with an algebraic verifier,</p>

    <p class="text-gray-300"><span id="page-1-1"></span><sup>&</sup>lt;sup>2</sup>For field elements  <span class="math">a_1, \\ldots a_r</span>  and elliptic curve group elements  <span class="math">G_1, \\ldots, G_r</span> , the multi-scalar multiplication denotes the operation  <span class="math">a_1G_1 + \\cdots + a_rG_r</span> . The group scalar multiplication denotes the operation  <span class="math">a_1G_1</span> .</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>3</sup>The group operations are much more expensive than field or hash operations in the circuit.</p>

    <p class="text-gray-300">resulting in an IVC scheme that supports multiple non-uniform circuits and enables high-degree and lookup gates. However, their accumulation scheme only handles two instances at once. Trivially extending it to accumulate multiple instances at once causes an exponential increase in the polynomial degree with the number of instances, which is undesirable for a PCD construction. Eagen and Gabizon [21] reduced this exponential growth to linear by leveraging the Lagrange base and sumcheck protocol. However, they did not provide explicit PCD constructions, which may face efficiency limitations due to the worse constants in their accumulation scheme.</p>

    <p class="text-gray-300">Some recent works adapted accumulation/folding schemes to introduce new features and applications. Bünz and Chen [13] constructed an efficient memory-proving IVC scheme from accumulation schemes, which is particularly useful for machine computations with large memories and deterministic steps. Boneh and Chen [4] presented a lattice-based folding scheme based on the module short integer solution problem. Bünz et al. [14] constructed a bounded-depth accumulation scheme from non-homomorphic vector commitments and linear code, which implies a bounded-depth PCD and polynomial-depth IVC. However, their work is more focused on the theoretical aspect. Nguyen et al. [33] presented a framework for building efficient folding-based SNARKs. When estimating the performance of their SNARKs, they instantiated the generic PCD construction of [9] with their folding schemes for polynomial relations. The involved polynomial map has degree d, and thus the instantiated PCD supports degree-d gates. However, in their folding scheme, the number of group operations for the prover and verifier scales linearly with d, offering no significant benefits over using degree-2 gates. In contrast, the number of group operations for the prover and verifier in our PCD scheme is independent of d, making it more efficient when d is large.</p>

    <p class="text-gray-300">For  <span class="math">t \\in \\mathbb{N}</span> , let [t] denote the set  <span class="math">\\{1, 2, \\dots, t\\}</span> . We use  <span class="math">\\mathbb{F}</span>  to denote a finite field,  <span class="math">\\mathbb{F}^t</span>  to denote a vector space of dimension t over  <span class="math">\\mathbb{F}</span> , and  <span class="math">\\mathbb{F}[\\ell]</span>  to denote the family of  <span class="math">\\ell</span> -variate multilinear polynomials over  <span class="math">\\mathbb{F}</span> . For  <span class="math">x \\in \\mathbb{F}^t</span> , let  <span class="math">x_i</span>  denote the <em>i</em>-th element. We use  <span class="math">y \\stackrel{\\</span>}{\\leftarrow} S<span class="math">  to denote the assignment of a uniformly random element in set S to y. We use y := c to denote the assignment of the variable c to y. When A is an algorithm, we use  </span>y \\leftarrow<span class="math"> A(x) to denote the assignment of the output of A on input x to y. We use  </span>\\lambda<span class="math">  to denote the security parameter and will drop it from the notation when it is implicit. We use  </span>negl(\\lambda)<span class="math">  to denote a negligible function in  </span>\\lambda$ . Let PPT denote probabilistic polynomial time. A multiset is an extension of the concept of a set where every element has a positive multiplicity. All logarithms in this paper are to base 2. For a tuple containing a semicolon, those variables listed before the semicolon are public (known to both the prover and the verifier), and those listed after it are secret (known only to the prover).</p>

    <p class="text-gray-300"><strong>Lemma 1</strong> (Multilinear Extension [20]). For every function  <span class="math">f: \\{0,1\\}^{\\ell} \\to \\mathbb{F}</span> , there exists a unique  <span class="math">\\ell</span> -variate multilinear polynomial  <span class="math">\\widetilde{f}:\\mathbb{F}^\\ell \\to \\mathbb{F}</span>  such that  <span class="math">\\widetilde{f}(x)=f(x)</span>  for all  <span class="math">x\\in</span>  <span class="math">\\{0,1\\}^{\\ell}</span> . We call  <span class="math">\\widetilde{f}</span>  the multilinear extension (MLE) of function f, and  <span class="math">\\widetilde{f}</span>  can be expressed as</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{f}(\\boldsymbol{X}) = \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{\\ell}} f(\\boldsymbol{x}) \\cdot \\widetilde{eq}(\\boldsymbol{X}, \\boldsymbol{x}),</span></div>

    <p class="text-gray-300">where <span class="math-block">\\widetilde{eq}(X, x) = \\prod_{i=1}^{\\ell} (x_i X_i + (1 - x_i)(1 - X_i))</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 2</strong> (Schwartz-Zippel Lemma [36]). Let  <span class="math">\\widetilde{f}: \\mathbb{F}^{\\ell} \\to \\mathbb{F}</span>  be a non-zero  <span class="math">\\ell</span> -variate polynomial of total degree d. Let S be any finite subset of  <span class="math">\\mathbb{F}</span> . Then for  <span class="math">\\mathbf{r} \\stackrel{\\</span>}{\\leftarrow} S^{\\ell}<span class="math"> ,  </span>\\Pr[\\widetilde{f}(\\mathbf{r}) = 0] \\leq \\frac{d}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We adapt the description from Kothapalli and Setty [28]. The sum-check protocol [30] is an interactive protocol allowing a prover  <span class="math">\\mathcal{P}</span>  to convince a verier  <span class="math">\\mathcal{V}</span>  of the validity of the statement</p>

    <div class="my-4 text-center"><span class="math-block">T = \\sum_{x_1 \\in \\{0,1\\}} \\cdots \\sum_{x_{\\ell} \\in \\{0,1\\}} \\widetilde{f}(x_1, \\dots, x_{\\ell}),</span></div>

    <p class="text-gray-300">where  <span class="math">\\widetilde{f}: \\mathbb{F}^{\\ell} \\to \\mathbb{F}</span>  is an  <span class="math">\\ell</span> -variate polynomial over some finite field  <span class="math">\\mathbb{F}</span> , and the degree of each variable is at most d. While  <span class="math">\\mathcal{V}</span>  could directly compute T using  <span class="math">O(2^{\\ell})</span>  evaluation of f, the sum-check protocol reduces  <span class="math">\\mathcal{V}</span> 's complexity to be polynomial in  <span class="math">\\ell</span> . In the protocol,  <span class="math">\\mathcal V</span>  takes as input randomness  <span class="math">r\\in\\mathbb F^\\ell</span>  and interacts with  <span class="math">\\mathcal{P}</span>  over a sequence of  <span class="math">\\ell</span>  rounds. At the end of this interaction, V outputs a claim about the evaluation f(r). Let  <span class="math">\\langle \\mathcal{P}, \\mathcal{V}(r) \\rangle</span>  denote the interaction between  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  with  <span class="math">\\mathcal{V}</span> 's randomness r. We treat  <span class="math">\\langle \\mathcal{P}, \\mathcal{V}(r) \\rangle</span>  as a function that on input  <span class="math">(f, \\ell, d, T)</span>  outputs the claimed evaluation to be checked, i.e.,  <span class="math">c \\leftarrow \\langle \\mathcal{P}, \\mathcal{V}(\\boldsymbol{r}) \\rangle</span>   <span class="math">(f, \\ell, d, T)</span> . It satisfies the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. If  <span class="math">T = \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{\\ell}} \\widetilde{f}(\\boldsymbol{x})</span> , then for an honest  <span class="math">\\mathcal{P}</span>  and for all  <span class="math">\\boldsymbol{r} \\in \\mathbb{F}^{\\ell}</span> ,  <span class="math">\\Pr[c \\leftarrow \\langle \\mathcal{P}, \\mathcal{V}(\\boldsymbol{r}) \\rangle \\ (\\widetilde{f}, \\ell, d, T) \\wedge \\widetilde{f}(\\boldsymbol{r}) =</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Soundness. If  <span class="math">T \\neq \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{\\ell}} \\widetilde{f}(\\boldsymbol{x})</span> , then for any adversary  <span class="math">\\mathcal{P}^<em></span>  and for all  <span class="math">\\boldsymbol{r} \\in \\mathbb{F}^{\\ell}</span> ,  <span class="math">\\Pr[c \\leftarrow \\langle \\mathcal{P}^</em>, \\mathcal{V}(\\boldsymbol{r}) \\rangle (\\widetilde{f}, \\ell, d, T) \\wedge</span>  $\\widetilde{f}(r) = c ] \\le \\ell d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.<span class="math"> • Succinctness. The communication is  </span>O(\\ell d)<span class="math">   </span>\\mathbb{F}$  elements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">B. Polynomial Commitment Schemes</h4>

    <p class="text-gray-300"><strong>Definition 1</strong> (Polynomial Commitment Schemes [11]). A polynomial commitment scheme for multilinear polynomials is a tuple PCS = (Setup, Com, Open, Eval) where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">pp_{pcs} \\leftarrow Setup(1^{\\lambda}, \\ell)</span> : on input the security parameter  <span class="math">\\lambda</span> with the unary form and the number of variables  <span class="math">\\ell</span>  in a multilinear polynomial, outputs public parameters pppcs.</li>

      <li><span class="math">C \\leftarrow \\mathsf{Com}(\\mathsf{pp}_{\\mathsf{pcs}}, \\widetilde{f})</span> : on input  <span class="math">\\mathsf{pp}_{\\mathsf{pcs}}</span>  and an  <span class="math">\\ell</span> -variate multilinear polynomial  <span class="math">\\widetilde{f}</span> , outputs a commitment C.</li>

      <li><span class="math">-1/0 \\leftarrow \\mathsf{Open}(\\mathsf{pp}_{\\mathsf{pcs}}, C, \\widetilde{f})</span> : on input  <span class="math">\\mathsf{pp}_{\\mathsf{pcs}}, C, \\widetilde{f}</span> , outputs 1/0 to denote that C is indeed a commitment to  <span class="math">\\widetilde{f}</span>  or not.</li>

      <li><span class="math">-1/0 \\leftarrow \\text{Eval}(\\text{pp}_{\\text{pcs}}, \\ell, C, r, v; \\widetilde{f})</span> : an interactive protocol between a PPT prover P and a verifier V. Both input  <span class="math">\\mathsf{pp}_{\\mathsf{pcs}}, \\ell, C, r \\in \\hat{\\mathbb{F}}^{\\ell}, v \\in \\mathbb{F}.</span>   <span class="math">\\mathcal{P}</span>  additionally inputs  <span class="math">\\widetilde{f}</span>  and attempts to convince V that  <span class="math">\\widetilde{f}(\\mathbf{r}) = v</span> . The outputs 1/0 denote that V accepts or not.</li>

    </ul>

    <p class="text-gray-300">PCS is an extractable polynomial commitment scheme for multilinear polynomials if the following conditions hold.</p>

    <p class="text-gray-300">• Completeness. PCS has completeness if for any  <span class="math">\\ell</span> -variate multilinear polynomial  <span class="math">\\tilde{f} \\in \\mathbb{F}[\\ell]</span> ,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{split} \\Pr\\left[ \\begin{array}{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c} \\mathsf{Eval}(\\mathsf{pp}_{\\mathsf{pcs}},\\ell,C,\\pmb{r},v;\\widetilde{f}) = 1 & \\mathsf{pp}_{\\mathsf{pcs}} \\leftarrow \\mathsf{Setup}(1^{\\lambda},\\ell); \\\\ \\wedge \\widetilde{f}(\\pmb{r}) = v & C \\leftarrow \\mathsf{Com}(\\mathsf{pp}_{\\mathsf{pcs}},\\widetilde{f}) \\end{array} \\right] \\\\ \\geq 1 - \\mathsf{negl}(\\lambda). \\end{split}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> Binding. PCS has binding if for any PPT adversary A, size parameter ℓ ≥ 1,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\begin{array}{c}b_0 = b_1 \\neq 0\\\\ \\land \\widetilde{f}_0 \\neq \\widetilde{f}_1\\end{array}\\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c}\\mathsf{pp}_{\\mathsf{pcs}} \\leftarrow \\mathsf{Setup}(1^\\lambda, \\ell);\\\\ (C, \\widetilde{f}_0, \\widetilde{f}_1) \\leftarrow \\mathcal{A}(\\mathsf{pp}_{\\mathsf{pcs}});\\\\ b_0 \\leftarrow \\mathsf{Open}(\\mathsf{pp}_{\\mathsf{pcs}}, C, \\widetilde{f}_0);\\\\ b_1 \\leftarrow \\mathsf{Open}(\\mathsf{pp}_{\\mathsf{pcs}}, C, \\widetilde{f}_1)\\end{array}\\right] \\leq \\mathsf{negl}(\\lambda).$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">• <strong>Knowledge soundness.</strong> PCS has knowledge soundness if given  <span class="math">pp_{pcs} \\leftarrow Setup(1^{\\lambda}, \\ell)</span> , Eval is an argument of knowledge for NP relation  <span class="math">\\mathcal{R}_{Eval}(pp_{pcs})</span>  defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\big\\{(C, \\boldsymbol{r}, \\boldsymbol{v}; \\widetilde{f}): \\widetilde{f} \\in \\mathbb{F}[\\ell] \\wedge \\widetilde{f}(\\boldsymbol{r}) = \\boldsymbol{v} \\wedge \\mathsf{Open}(\\mathsf{pp}_{\\mathsf{pcs}}, C, \\widetilde{f}) = 1\\big\\}.</span></div>

    <p class="text-gray-300"> <span class="math">\\begin{array}{lll} \\operatorname{PCS} &amp; \\textit{is additively homomorphic} &amp; \\textit{if for all} &amp; \\ell, \\operatorname{pp_{pcs}} &amp; \\leftarrow \\\\ \\operatorname{Setup}(1^{\\lambda}, \\ell) &amp; \\textit{and any} &amp; \\widetilde{f}_1, \\widetilde{f}_2 &amp; \\in &amp; \\mathbb{F}[\\ell], &amp; \\operatorname{Com}(\\operatorname{pp_{pcs}}, \\widetilde{f}_1) &amp; + \\\\ \\operatorname{Com}(\\operatorname{pp_{pcs}}, \\widetilde{f}_2) &amp; = \\operatorname{Com}(\\operatorname{pp_{pcs}}, \\widetilde{f}_1 + \\widetilde{f}_2). \\end{array}</span></p>

    <p class="text-gray-300"><strong>Definition 2</strong> (Multi-folding Schemes [28]). <em>Consider relations</em>  <span class="math">\\mathcal{R}_1</span>  and  <span class="math">\\mathcal{R}_2</span>  over public parameters, structure, instance, and witness tuples, a predicate compat that structures for instances in  <span class="math">\\mathcal{R}_1</span>  and  <span class="math">\\mathcal{R}_2</span>  must satisfy, and size parameters  <span class="math">\\mu, \\nu \\in \\mathbb{N}</span> . A multi-folding scheme for  <span class="math">(\\mathcal{R}_1, \\mathcal{R}_2, \\mathsf{compat}, \\mu, \\nu)</span>  is a tuple of algorithms MFS =  <span class="math">(\\mathcal{G}, \\mathcal{K}, \\mathcal{P}, \\mathcal{V})</span>  where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>fpp  <span class="math">\\leftarrow \\mathcal{G}\\left(1^{\\lambda},N\\right)</span>  is a PPT generator algorithm. On input the security parameter  <span class="math">\\lambda</span>  with the unary form and size bounds N, it outputs public parameters fpp.</li>

      <li>(fpk, fvk)  <span class="math">\\leftarrow \\mathcal{K}(\\mathsf{fpp},(\\mathsf{s}_1,\\mathsf{s}_2))</span>  is a deterministic encoder algorithm. On input fpp and structures  <span class="math">\\mathsf{s}_1,\\mathsf{s}_2</span> , it outputs a prover key fpk and a verifier key fvk.</li>

      <li><span class="math">(u,w) \\leftarrow \\langle \\mathcal{P}(fpk,\\overrightarrow{w_1},\\overrightarrow{w_2}), \\mathcal{V}(fvk) \\rangle (\\overrightarrow{u_1},\\overrightarrow{u_2})</span>  denotes the interaction between a PPT prover  <span class="math">\\mathcal{P}</span>  and a PPT verifier  <span class="math">\\mathcal{V}</span> .  <span class="math">\\mathcal{P}</span>  inputs fpk, a vector of instances  <span class="math">\\overrightarrow{u_1}</span>  in  <span class="math">\\mathcal{R}_1</span>  of size  <span class="math">\\mu</span>  with structure  <span class="math">s_1</span> , a vector of instances  <span class="math">\\overrightarrow{u_2}</span>  in  <span class="math">\\mathcal{R}_2</span>  of size  <span class="math">\\nu</span>  with structure  <span class="math">s_2</span> , and corresponding witnesses  <span class="math">\\overrightarrow{w_1}, \\overrightarrow{w_2}</span> .  <span class="math">\\mathcal{V}</span>  inputs fvk,  <span class="math">\\overrightarrow{u_1}, \\overrightarrow{u_2}</span> . At the end of the interaction,  <span class="math">\\mathcal{P}</span>  outputs a folded instance-witness pair (u, w) in  <span class="math">\\mathcal{R}_1</span>  with structure  <span class="math">s_1</span> , and  <span class="math">\\mathcal{V}</span>  outputs a folded instance u in  <span class="math">\\mathcal{R}_1</span>  with structure  <span class="math">s_1</span> .</li>

    </ul>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{R}^{(n)}</span>  be the relation so that  <span class="math">(\\mathsf{fpp},\\mathsf{s},\\vec{\\mathsf{u}},\\vec{\\mathsf{w}}) \\in \\mathcal{R}^{(n)}</span>  if and only if  <span class="math">(\\mathsf{fpp},\\mathsf{s},\\vec{\\mathsf{u}}_i,\\vec{\\mathsf{w}}_i) \\in \\mathcal{R}</span>  for all  <span class="math">i \\in [n]</span> . A multifolding scheme MFS should sastisfy perfect completeness and knowledge soundness defined below.</p>

    <p class="text-gray-300">• <strong>Perfect completeness.</strong> MFS has perfect completeness if for all PPT adversaries A, the following probability is 1.</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr\\left[\\begin{array}{c} \\left\\{ \\mathsf{fpp} \\leftarrow \\mathcal{G}\\left(1^{\\lambda}, N\\right); \\\\ \\left((\\mathsf{s}_1, \\mathsf{s}_2), (\\overrightarrow{\\mathsf{u}_1}, \\overrightarrow{\\mathsf{w}_1}), (\\overrightarrow{\\mathsf{u}_2}, \\overrightarrow{\\mathsf{w}_2})\\right) \\\\ \\leftarrow \\mathcal{A}(\\mathsf{fpp}); \\\\ \\mathsf{compat}(\\mathsf{s}_1, \\mathsf{s}_2) = \\mathsf{true}; \\\\ \\left(\\mathsf{fpp}, \\mathsf{s}_1, \\overrightarrow{\\mathsf{u}_1}, \\overrightarrow{\\mathsf{w}_1}\\right) \\in \\mathcal{R}_1^{(\\mu)}; \\\\ \\left(\\mathsf{fpp}, \\mathsf{s}_2, \\overrightarrow{\\mathsf{u}_2}, \\overrightarrow{\\mathsf{w}_2}\\right) \\in \\mathcal{R}_2^{(\\nu)}; \\\\ \\left(\\mathsf{fpk}, \\mathsf{fvk}\\right) \\leftarrow \\mathcal{K}(\\mathsf{fpp}, (\\mathsf{s}_1, \\mathsf{s}_2)); \\\\ \\left(\\mathsf{u}, \\mathsf{w}\\right) \\\\ \\leftarrow \\left\\langle \\mathcal{P}(\\mathsf{fpk}, \\overrightarrow{\\mathsf{w}_1}, \\overrightarrow{\\mathsf{w}_2}), \\mathcal{V}(\\mathsf{fvk}) \\right\\rangle \\\\ \\left(\\overrightarrow{\\mathsf{u}_1}, \\overrightarrow{\\mathsf{u}_2}\\right) \\end{array}\\right]</span></div>

    <p class="text-gray-300">• <strong>Knowledge soundness.</strong> MFS has knowledge soundness if for any expected polynomial time adversary A and  <span class="math">P^*</span> , there exists an expected polynomial-time extractor E such that over all randomness  <span class="math">\\rho</span> ,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{split} \\Pr\\left[ \\begin{array}{c} \\left(\\mathsf{fpp},\\mathsf{s}_1,\\overrightarrow{\\mathsf{u}_1},\\overrightarrow{\\mathsf{w}_1}\\right) \\in \\mathcal{R}_1^{(\\mu)} \\\\ \\wedge \\\\ \\left(\\mathsf{fpp},\\mathsf{s}_2,\\overrightarrow{\\mathsf{u}_2},\\overrightarrow{\\mathsf{w}_2}\\right) \\in \\mathcal{R}_2^{(\\nu)} \\\\ \\end{array} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf{fpp} \\leftarrow \\mathcal{G}\\left(1^\\lambda,N\\right); \\\\ \\left((\\mathsf{s}_1,\\mathsf{s}_2),(\\overrightarrow{\\mathsf{u}_1},\\overrightarrow{\\mathsf{u}_2}),\\mathsf{st}\\right) \\\\ \\leftarrow \\mathcal{A}(\\mathsf{fpp},\\rho); \\\\ \\mathsf{compat}(\\mathsf{s}_1,\\mathsf{s}_2) = \\mathsf{true}; \\\\ (\\overrightarrow{\\mathsf{w}_1},\\overrightarrow{\\mathsf{w}_2}) \\leftarrow \\mathcal{E}(\\mathsf{fpp},\\rho) \\\\ \\end{array} \\right] \\geq \\\\ \\Pr\\left[ \\begin{array}{c} \\mathsf{fpp} \\leftarrow \\mathcal{G}\\left(1^\\lambda,N\\right); \\\\ \\left((\\mathsf{s}_1,\\mathsf{s}_2),(\\overrightarrow{\\mathsf{u}_1},\\overrightarrow{\\mathsf{u}_2}),\\mathsf{st}\\right) \\\\ \\leftarrow \\mathcal{A}(\\mathsf{fpp},\\rho); \\\\ \\mathsf{compat}(\\mathsf{s}_1,\\mathsf{s}_2) = \\mathsf{true}; \\\\ \\left(\\mathsf{fpk},\\mathsf{fvk}\\right) \\leftarrow \\mathcal{K}(\\mathsf{fpp},(\\mathsf{s}_1,\\mathsf{s}_2)); \\\\ \\left(\\mathsf{u},\\mathsf{w}\\right) \\\\ \\leftarrow \\left\\langle \\mathcal{P}^*(\\mathsf{fpk},\\mathsf{st}), \\mathcal{V}(\\mathsf{fvk}) \\right\\rangle \\\\ \\left(\\overrightarrow{\\mathsf{u}_1},\\overrightarrow{\\mathsf{u}_2}\\right) \\\\ - \\mathsf{negl}(\\lambda). \\end{array} \\right] \\\\ - \\mathsf{negl}(\\lambda). \\end{split}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Setty et al. [37] introduced customizable constraint systems (CCS), a new constraint system that generalizes arithmetic circuits. Later, Kothapalli and Setty [28] described two variants of CCS, i.e., committed customizable constraint systems (CCCS) and linearized committed customizable constraint systems (LCCCS), that are amenable to construct their multifolding schemes. In particular, they let  <span class="math">\\mathcal{R}_1</span>  be the LCCCS relation  <span class="math">\\mathcal{R}_{LCCCS}</span>  and  <span class="math">\\mathcal{R}_2</span>  be the CCCS relation  <span class="math">\\mathcal{R}_{CCCS}</span> , an NP-complete relation. We follow their work and adopt their definition of CCCS and LCCCS.</p>

    <p class="text-gray-300">For a matrice  <span class="math">M \\in \\mathbb{F}^{m \\times n}</span>  where  <span class="math">m, n \\in \\mathbb{N}</span>  and let  <span class="math">s = \\log m, s&#x27; = \\log n</span> , interpret it as a function  <span class="math">\\{0,1\\}^s \\times \\{0,1\\}^{s&#x27;} \\to \\mathbb{F}</span> . That is, an input in  <span class="math">\\{0,1\\}^s \\times \\{0,1\\}^{s&#x27;}</span>  is interpreted as the binary representation of an index  <span class="math">(i,j) \\in \\{0,\\ldots,m-1\\} \\times \\{0,\\ldots,n-1\\}</span> , and the function outputs the (i,j)'th entry of the matrix M. Then we could define its unique multilinear extension  <span class="math">\\widetilde{M}</span>  as a multilinear polynomial in s+s' variables. Similarly, for a vector  <span class="math">\\boldsymbol{w} \\in \\mathbb{F}^m</span> , interpret it as a function  <span class="math">\\{0,1\\}^s \\to \\mathbb{F}</span> . Then we let  <span class="math">\\widetilde{w}</span>  denote its unique multilinear extension.</p>

    <p class="text-gray-300"><strong>Definition 3</strong> (Committed Customizable Constraint System [28]). A CCCS relation  <span class="math">\\mathcal{R}_{CCCS}</span>  consists of tuples containing public parameters, structure, instance and witness where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>public parameters consist of size bounds  <span class="math">m, n, N, \\ell, t, q, d \\in \\mathbb{N}</span>  and  <span class="math">\\mathsf{pp}_{\\mathsf{pcs}}</span> , where assume that  <span class="math">n = 2 \\cdot (\\ell + 1)</span>  for simplicity,  <span class="math">\\mathsf{pp}_{\\mathsf{pcs}} \\leftarrow \\mathsf{Setup}(1^{\\lambda}, \\log n 1)</span> ;</li>

      <li>the structure consists of:</li>

      <li>a sequence of sparse multilinear polynomials in s+s' variables  <span class="math">\\widetilde{M}_1, \\ldots, \\widetilde{M}_t</span>  such that they evaluate to a nonzero value in at most  <span class="math">N = \\Omega(\\max(m,n))</span>  locations over the boolean hypercube  <span class="math">\\{0,1\\}^s \\times \\{0,1\\}^{s&#x27;}</span> , where assume that  <span class="math">s = \\log m, s&#x27; = \\log n</span> ;</li>

      <li>a sequence of q multisets  <span class="math">(S_1, \\ldots, S_q)</span> , where an element in each multiset is from the set [t] and the cardinality of each multiset is at most d;</li>

      <li>a sequence of q constants  <span class="math">(c_1, \\ldots, c_q)</span> , where each constant is from  <span class="math">\\mathbb{F}</span> ;</li>

      <li>the instance is  <span class="math">(C, \\mathbf{x})</span> , where C is a commitment to a multilinear polynomial in s'-1 variables and  <span class="math">\\mathbf{x} \\in \\mathbb{F}^{\\ell}</span> ;</li>

      <li>the witness is a multilinear polynomial  <span class="math">\\widetilde{w}</span>  in s'-1 variables.</li>

    </ul>

    <p class="text-gray-300">Given public parameters, a  <span class="math">\\mathcal{R}_{CCCS}</span>  structure-instance tuple is satisfied by a  <span class="math">\\mathcal{R}_{CCCS}</span>  witness if  <span class="math">C = \\mathsf{Com}(\\mathsf{pp}_{\\mathsf{pcs}}, \\widetilde{w})</span>  and for all  <span class="math">x \\in \\{0,1\\}^s</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{q} c_i \\cdot \\left( \\prod_{j \\in S_i} \\left( \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(\\boldsymbol{x}, \\boldsymbol{y}) \\cdot \\widetilde{z}(\\boldsymbol{y}) \\right) \\right) = 0,</span></div>

    <p class="text-gray-300">where  <span class="math">\\widetilde{z}</span>  is an s'-variate multilinear polynomial such that  <span class="math">\\widetilde{z}(\\mathbf{y}) = (\\widetilde{\\mathbf{w}}, u, \\mathbf{x})(\\mathbf{y})</span>  for all  <span class="math">\\mathbf{y} \\in \\{0, 1\\}^{s&#x27;}</span> .</p>

    <p class="text-gray-300"><strong>Definition 4</strong> (Linearized Committed Customizable Constraint System [28]). A LCCCS relation  <span class="math">\\mathcal{R}_{LCCCS}</span>  consists of tuples containing public parameters, structure, instance and witness where the public parameters and structure are the same as those in a CCCS relation. The instance and witness are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the instance is  <span class="math">(C, u, \\mathbf{x}, \\mathbf{r}, v_1, \\dots, v_t)</span> , where  <span class="math">u \\in \\mathbb{F}, \\mathbf{x} \\in \\mathbb{F}^{\\ell}, \\mathbf{r} \\in \\mathbb{F}^{s}, v_i \\in \\mathbb{F}</span>  for all  <span class="math">i \\in [t]</span> , and C is a commitment to a multilinear polynomial in s'-1 variables;</li>

      <li>the witness is a multilinear polynomial  <span class="math">\\widetilde{w}</span>  in s'-1 variables.</li>

    </ul>

    <p class="text-gray-300">Given public parameters, a  <span class="math">\\mathcal{R}_{LCCCS}</span>  structure-instance tuple is satisfied by a  <span class="math">\\mathcal{R}_{LCCCS}</span>  witness if  <span class="math">C = \\mathsf{Com}\\big(\\mathsf{pp}_{\\mathsf{pcs}}, \\widetilde{w}\\big)</span>  and for all  <span class="math">i \\in [t]</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">v_i = \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r},\\boldsymbol{y}) \\cdot \\widetilde{z}(\\boldsymbol{y}),</span></div>

    <p class="text-gray-300">where  <span class="math">\\widetilde{z}</span>  is an s'-variate multilinear polynomial such that  <span class="math">\\widetilde{z}(\\boldsymbol{y}) = (\\widetilde{\\boldsymbol{w},u,\\mathbf{x}})(\\boldsymbol{y})</span>  for all  <span class="math">\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}</span> .</p>

    <p class="text-gray-300">Define a transcript T as a directed acyclic graph where each vertex  <span class="math">v \\in V(\\mathsf{T})</span>  is labeled by local data  <span class="math">z_{\\mathsf{loc}}^{(v)}</span>  and each edge  <span class="math">e \\in E(\\mathsf{T})</span>  is labeled by a message  <span class="math">z^{(e)} \\neq \\perp</span> . The output  <span class="math">o(\\mathsf{T})</span>  of</p>

    <p class="text-gray-300">a transcript T is  <span class="math">z^{(e)}</span>  where e=(v,v') is the lexicographically-first edge such that v' is a sink. For a class of compliance predicates F, define that a vertex  <span class="math">v \\in V(\\mathsf{T})</span>  is  <span class="math">\\varphi</span> -compliant for  <span class="math">\\varphi \\in \\mathsf{F}</span>  if for all outgoing edges  <span class="math">e=(v,v&#x27;) \\in E(\\mathsf{T})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(base case) if v has no incoming edges,  <span class="math">\\varphi(z^{(e)}, z_{\\text{loc}}^{(v)}, \\perp, \\ldots, \\perp)</span>  accepts;</li>

      <li>(recursive case) if v has incoming edges  <span class="math">e_1,\\ldots,e_r</span> ,  <span class="math">\\varphi \\left(z^{(e)},z_{\\text{loc}}^{(v)},z^{(e_1)},\\ldots,z^{(e_r)}\\right)</span>  accepts.</li>

    </ul>

    <p class="text-gray-300">We say that T is  <span class="math">\\varphi</span> -compliant if all of its vertices are  <span class="math">\\varphi</span> -compliant.</p>

    <p class="text-gray-300"><strong>Definition 5</strong> (Proof-Carrying Data [9]). A proof-carrying data scheme for a class of compliance predicates F is a tuple of algorithms PCD = (G, K, P, V) where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>pp  <span class="math">\\leftarrow</span>  G  <span class="math">(1^{\\lambda})</span>  on input the security parameter  <span class="math">\\lambda</span>  with the unary form, outputs public parameters pp.</li>

      <li>(pk, vk) ← K(pp, φ) on input pp and a compliance predicate  <span class="math">\\varphi \\in F</span> , outputs a prover key pk and verifier key vk.</li>

      <li><span class="math">\\Pi \\leftarrow P(pk, z, z_{loc}, \\{z_i, \\Pi_i\\}_{i=1}^r)</span>  on input pk, message z of the outgoing edge, local data  <span class="math">z_{loc}</span> , messages  <span class="math">\\{z_i\\}_{i=1}^r</span>  of incoming edges and their corresponding proofs  <span class="math">\\{\\Pi_i\\}_{i=1}^r</span> , outputs a new proof  <span class="math">\\Pi</span>  that attests to the correctness of z.</li>

      <li><span class="math">-1/0 \\leftarrow V(vk, z, \\Pi)</span>  on input  <span class="math">vk, z, \\Pi</span> , outputs 1/0 to accept or reject.</li>

    </ul>

    <p class="text-gray-300">A proof-carrying data scheme PCD should sastify perfect completeness and knowledge soundness defined below.</p>

    <p class="text-gray-300">• <strong>Perfect completeness.</strong> PCD has perfect completeness if for every adversary A, the following probability is 1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[ \\begin{pmatrix} \\varphi \\in \\mathsf{F} \\land \\\\ \\varphi(z, z_{\\mathsf{loc}}, (z_i)_{i=1}^r) = 1 \\\\ \\land \\begin{pmatrix} \\forall i \\in [r], z_i = \\bot \\text{ or} \\\\ \\mathsf{V}(\\mathsf{vk}, z_i, \\Pi_i) = 1 \\end{pmatrix} \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{matrix} \\mathsf{pp} \\leftarrow \\mathsf{G}\\left(1^\\lambda\\right); \\\\ \\left(\\varphi, z, z_{\\mathsf{loc}}, \\{z_i, \\Pi_i\\}_{i=1}^r\\right) \\\\ \\leftarrow \\mathcal{A}(\\mathsf{pp}); \\\\ \\left(\\mathsf{pk}, \\mathsf{vk}\\right) \\leftarrow \\mathsf{K}(\\mathsf{pp}, \\varphi); \\\\ \\mathsf{pk}, \\mathsf{vk}\\right) \\leftarrow \\mathsf{F}(\\mathsf{pk}, z, z_{\\mathsf{loc}}, \\{z_i, \\Pi_i\\}_{i=1}^r) \\\\ \\mathsf{V}(\\mathsf{vk}, z, \\Pi) = 1 \\end{pmatrix} \\right].$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">• <strong>Knowledge soundness.</strong> PCD has knowledge soundness (w.r.t. an auxiliary input distribution  <span class="math">\\mathcal{D}</span> ) if for every expected polynomial time adversary  <span class="math">\\mathsf{P}^<em></span> , there exists an expected polynomial time extractor  <span class="math">\\mathcal{E}_{\\mathsf{P}^</em>}</span>  such that for every set Z,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{split} &\\Pr\\left[\\begin{array}{c} \\varphi \\in \\mathsf{F} \\ \\land \\\\ (\\mathsf{pp}, \\mathsf{ai}, \\varphi, \\mathsf{o}(\\mathsf{T}), \\mathsf{ao}) \\in Z \\\\ \\land \\mathsf{T} \\ \\mathsf{is} \\ \\varphi\\text{-compliant} \\end{array} \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf{pp} \\leftarrow \\mathsf{G}\\left(1^{\\lambda}\\right); \\\\ \\mathsf{ai} \\leftarrow \\mathcal{D}(\\mathsf{pp}); \\\\ (\\varphi, \\mathsf{T}, \\mathsf{ao}) \\\\ \\leftarrow \\mathcal{E}_{\\mathsf{P}^*}(\\mathsf{pp}, \\mathsf{ai}) \\end{array} \\right] \\geq \\\\ &\\Pr\\left[\\begin{array}{c} \\varphi \\in \\mathsf{F} \\ \\land \\\\ (\\mathsf{pp}, \\mathsf{ai}, \\varphi, \\mathsf{o}, \\mathsf{ao}) \\in Z \\\\ \\land \\mathsf{V}(\\mathsf{vk}, \\mathsf{o}, \\Pi) = 1 \\end{array} \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf{pp} \\leftarrow \\mathsf{G}\\left(1^{\\lambda}\\right); \\\\ \\mathsf{ai} \\leftarrow \\mathcal{D}(\\mathsf{pp}); \\\\ (\\varphi, \\mathsf{o}, \\Pi, \\mathsf{ao}) \\leftarrow \\mathsf{P}^*(\\mathsf{pp}, \\mathsf{ai}); \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathsf{K}(\\mathsf{pp}, \\varphi) \\end{array} \\right] \\\\ &- \\mathsf{negl}(\\lambda). \\end{split}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Recall a multi-folding scheme for  <span class="math">(\\mathcal{R}_1,\\mathcal{R}_2,\\mathsf{compat},\\mu,\\nu)</span>  allows a prover and a verifier to reduce the task of checking  <span class="math">\\mu</span>  instances in  <span class="math">\\mathcal{R}_1</span>  with structure  <span class="math">\\mathsf{s}_1</span>  and  <span class="math">\\nu</span>  instances in  <span class="math">\\mathcal{R}_2</span>  with structure  <span class="math">\\mathsf{s}_2</span>  into the task of checking a single instance in  <span class="math">\\mathcal{R}_1</span>  with structure  <span class="math">\\mathsf{s}_1</span> . In our case, we let  <span class="math">\\mathcal{R}_1 = \\mathcal{R}_{LCCCS}</span> ,  <span class="math">\\mathcal{R}_2 = \\mathcal{R}_{CCCS}</span> , and  <span class="math">\\mathsf{compat}(\\mathsf{s}_1,\\mathsf{s}_2)</span>  require  <span class="math">\\mathsf{s}_1 = \\mathsf{s}_2</span> . Kothapalli and Setty [28] constructed a multi-folding scheme for  <span class="math">(\\mathcal{R}_{LCCCS},\\mathcal{R}_{CCCS},\\mathsf{compat},1,1)</span> . We continue their work and construct a multi-folding scheme for arbitrary values of  <span class="math">\\mu,\\nu</span> , which is the basis of our proof-carrying data scheme.</p>

    <p class="text-gray-300">Supposing that there are  <span class="math">\\mu</span>   <span class="math">\\mathcal{R}_{\\mathrm{LCCCS}}</span>  instance-witness pairs  <span class="math">\\{\\phi_k\\}_{k\\in[\\mu]}</span> ,  <span class="math">\\nu</span>   <span class="math">\\mathcal{R}_{\\mathrm{CCCS}}</span>  instance-witness pairs  <span class="math">\\{\\psi_{k&#x27;}\\}_{k&#x27;\\in[\\nu]}</span> , where  <span class="math">\\phi_k \\coloneqq (C_1,u,\\mathbf{x}_1,\\underline{r}_x,v_1,\\ldots,v_t;\\widetilde{w}_1),\\psi_{k&#x27;}\\coloneqq (C_2,\\underline{\\mathbf{x}}_2;\\widetilde{w}_2)</span> . Let  <span class="math">\\phi_k.\\widetilde{z}_1 \\coloneqq (\\phi_k.w_1,\\phi_k.u,\\phi_k.\\mathbf{x}_1),\\ \\psi_{k&#x27;}.\\widetilde{z}_2 \\coloneqq (\\psi_{k&#x27;}.w_2,1,\\psi_{k&#x27;}.\\mathbf{x}_2)</span> . The prover  <span class="math">\\mathcal P</span>  and the verifier  <span class="math">\\mathcal V</span>  both input  <span class="math">\\mu</span>   <span class="math">\\mathcal R_{\\mathrm{LCCS}}</span>  instances  <span class="math">\\{\\phi_k.(C_1,u,\\mathbf{x}_1,r_x,\\ v_1,\\ldots,v_t)\\}_{k\\in[\\mu]}</span>  and  <span class="math">\\nu</span>   <span class="math">\\mathcal R_{\\mathrm{CCS}}</span>  instances  <span class="math">\\{\\psi_{k&#x27;}.(C_2,\\mathbf{x}_2)\\}_{k&#x27;\\in[\\nu]}</span> .  <span class="math">\\mathcal P</span>  additionally inputs the corresponding witnesses  <span class="math">\\{\\phi_k.\\widetilde{w}_1\\}_{k\\in[\\mu]},\\{\\psi_{k&#x27;}.\\widetilde{w}_2\\}_{k&#x27;\\in[\\nu]}</span> . To obtain the folded instance and witness, we rely on the random linear combination technique.</p>

    <p class="text-gray-300">For  <span class="math">k \\in [\\mu]</span> , according to  <span class="math">\\mathcal{R}_{LCCCS}</span> , for  <span class="math">i \\in [t]</span> , we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\phi_k.v_i &amp;= \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\phi_k.\\boldsymbol{r}_x,\\boldsymbol{y}) \\cdot \\phi_k.\\widetilde{z}_1(\\boldsymbol{y}) \\\\ &amp;= \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} \\widetilde{eq}(\\phi_k.\\boldsymbol{r}_x,\\boldsymbol{x}) \\cdot \\left(\\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{x},\\boldsymbol{y}) \\cdot \\phi_k.\\widetilde{z}_1(\\boldsymbol{y})\\right) \\end{split}</span></div>

    <p class="text-gray-300">We first perform a random linear combination of these values  <span class="math">\\{\\phi_k.v_i\\}_{k\\in[\\mu],i\\in[t]}</span> , i.e., for  <span class="math">\\gamma \\stackrel{\\</span>}{\\leftarrow} \\mathbb{F}$ ,</p>

    <p class="text-gray-300"><span class="math-block">\\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\phi_k \\cdot v_i = \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\cdot \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} L_{k,i}(\\boldsymbol{x}),</span> (1)</p>

    <p class="text-gray-300">where  <span class="math">L_{k,i}(\\boldsymbol{X}) := \\widetilde{eq}(\\phi_k.\\boldsymbol{r}_x,\\boldsymbol{X}) \\cdot \\left(\\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{X},\\boldsymbol{y}) \\cdot \\phi_k.\\widetilde{z}_1(\\boldsymbol{y})\\right)</span> .</p>

    <p class="text-gray-300">For  <span class="math">k&#x27; \\in [\\nu]</span> , according to  <span class="math">\\mathcal{R}_{\\text{CCCS}}</span> , we have for all  <span class="math">\\boldsymbol{x} \\in \\{0,1\\}^s</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^q c_i \\cdot \\prod_{j \\in S_i} \\left( \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(\\boldsymbol{x}, \\boldsymbol{y}) \\cdot \\psi_{k&#x27;}. \\widetilde{z}_2(\\boldsymbol{y}) \\right) = 0.</span></div>

    <p class="text-gray-300">Denoting the left-hand side of the above equation as a polynomial  <span class="math">q_{k&#x27;}(\\mathbf{X})</span> , we have for  <span class="math">\\mathbf{x} \\in \\{0,1\\}^s</span> ,  <span class="math">q_{k&#x27;}(\\mathbf{x}) = 0</span> . Then the polynomial</p>

    <div class="my-4 text-center"><span class="math-block">G_{k&#x27;}(\\boldsymbol{X})\\coloneqq\\sum_{\\boldsymbol{x}\\in\\{0,1\\}^s}\\widetilde{eq}(\\boldsymbol{X},\\boldsymbol{x})\\cdot q_{k&#x27;}(\\boldsymbol{x})</span></div>

    <p class="text-gray-300">is multilinear and vanishes on all  <span class="math">\\boldsymbol{x} \\in \\{0,1\\}^s</span> . Hence, we have  <span class="math">G_{k&#x27;}(\\boldsymbol{X})</span>  is a zero polynomial. For  <span class="math">\\boldsymbol{\\beta} \\xleftarrow{\\</span>} \\mathbb{F}^s<span class="math"> ,  </span>G_{k'}(\\boldsymbol{\\beta}) = 0<span class="math"> . Let  </span>Q_{k'}(\\boldsymbol{X}) := \\tilde{eq}(\\boldsymbol{\\beta}, \\boldsymbol{X}) \\cdot q_{k'}(\\boldsymbol{X})<span class="math"> . We have for  </span>k' \\in [\\nu]$ ,</p>

    <p class="text-gray-300"> <span class="math">\\sum_{x \\in \\{0,1\\}^s} Q_{k&#x27;}(x) = G_{k&#x27;}(\\beta) = 0</span> . Then based on Equation (1), we further perform a random linear combination that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\phi_k . v_i = \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\cdot \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} L_{k,i}(\\boldsymbol{x}) + \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t+k&#x27;} \\cdot \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} Q_{k&#x27;}(\\boldsymbol{x}).</span></div>

    <p class="text-gray-300">Let</p>

    <div class="my-4 text-center"><span class="math-block">g(X) := \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\cdot L_{k,i}(X) + \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t + k&#x27;} \\cdot Q_{k&#x27;}(X).</span></div>

    <p class="text-gray-300">We have</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} g(\\boldsymbol{x}) = \\sum_{k=1}^{\\mu} \\sum_{i=1}^t \\gamma^{(k-1)t+i} \\phi_k.v_i,</span></div>

    <p class="text-gray-300">which is exactly a statement that a sum-check protocol could prove. Therefore, the task of checking  <span class="math">\\mu</span>   <span class="math">\\mathcal{R}_{LCCCS}</span>  instances and  <span class="math">\\nu</span>   <span class="math">\\mathcal{R}_{CCCS}</span>  instances is reduced into the task of performing a sum-check protocol. With  <span class="math">\\mathbf{r}&#x27;_x \\overset{\\</span>}{\\leftarrow} \\mathbb{F}^s<span class="math"> ,  </span>\\mathcal{P}<span class="math">  and  </span>\\mathcal{V}<span class="math">  run  </span>c \\leftarrow \\langle \\mathcal{P}, \\mathcal{V}(\\mathbf{r}'_x) \\rangle<span class="math">   </span>(g, s, d+1, \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\phi_k.v_i)<span class="math"> . Now,  </span>\\mathcal{V}<span class="math">  has to check the equation  </span>g(\\mathbf{r}'_x) = c<span class="math"> . We let  </span>\\mathcal{P}<span class="math">  first compute some intermediate values and then  </span>\\mathcal{V}<span class="math">  compute  </span>g(\\mathbf{r}'_x)<span class="math">  using these values. Specifically,  </span>\\mathcal{P}<span class="math">  computes and sends  </span>\\{\\sigma_{k,i},\\theta_{k',i}\\}_{k\\in [\\mu],k'\\in [\\nu],i\\in [t]}<span class="math">  to  </span>\\mathcal{V}$ , where</p>

    <p class="text-gray-300"><span id="page-5-1"></span> <span class="math-block">\\sigma_{k,i} := \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}) \\cdot \\phi_k.\\widetilde{z}_1(\\boldsymbol{y}),</span></p>

    <p class="text-gray-300"><span class="math-block">\\theta_{k&#x27;,i} := \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}) \\cdot \\psi_{k&#x27;}.\\widetilde{z}_2(\\boldsymbol{y}).</span> (2)</p>

    <p class="text-gray-300">Then V computes</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} g(\\boldsymbol{r}_x&#x27;) \\coloneqq &amp; \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\cdot \\widetilde{eq}(\\phi_k.\\boldsymbol{r}_x, \\boldsymbol{r}_x&#x27;) \\cdot \\sigma_{k,i} \\\\ &amp; + \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t + k&#x27;} \\cdot \\widetilde{eq}(\\boldsymbol{\\beta}, \\boldsymbol{r}_x&#x27;) \\cdot \\left(\\sum_{i=1}^{q} c_i \\cdot \\prod_{j \\in S_i} \\theta_{k&#x27;,j}\\right) \\end{split}</span></div>

    <p class="text-gray-300"><span id="page-5-0"></span>and compares it with c. Nevertheless,  <span class="math">\\mathcal V</span>  still has to check the correctness of  <span class="math">\\{\\sigma_{k,i},\\theta_{k&#x27;,i}\\}_{k\\in[\\mu],k&#x27;\\in[\\nu],i\\in[t]}</span> . Observe that equations in (2) are exactly LCCS relations. Thus, for  <span class="math">i\\in[t]</span> , we could first perform a random linear combination of  <span class="math">\\{\\sigma_{k,i},\\theta_{k&#x27;,i}\\}_{k\\in[\\mu],k&#x27;\\in[\\nu]}</span>  and then prove the correctness of the folded  <span class="math">\\mathcal R_{\\mathrm{LCCCS}}</span>  instance. Now, the task of checking  <span class="math">\\mu</span>   <span class="math">\\mathcal R_{\\mathrm{LCCCS}}</span>  instances and  <span class="math">\\nu</span>   <span class="math">\\mathcal R_{\\mathrm{CCCS}}</span>  instances is reduced into the task of checking a single  <span class="math">\\mathcal R_{\\mathrm{LCCCS}}</span>  instance.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">B. Formal Description</h4>

    <p class="text-gray-300">Construction 1 (A Multi-folding Scheme for an Arbitrary Number of Instances). We formally present our multi-folding scheme as follows.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{fpp} \\leftarrow \\mathcal{G}\\left(1^{\\lambda}, (m, n, N, \\ell, t, q, d \\in \\mathbb{N})\\right) :</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Let  <span class="math">n = 2 \\cdot (\\ell + 1)</span> .</li>

      <li>2. Compute  <span class="math">\\mathsf{pp}_{\\mathsf{pcs}} \\leftarrow \\mathsf{Setup}(1^{\\lambda}, \\log n 1)</span> , and output  <span class="math">\\mathsf{fpp} \\coloneqq (m, n, N, \\ell, t, q, d, \\mathsf{pp}_{\\mathsf{pcs}})</span> .</li>

    </ul>

    <p class="text-gray-300"> <span class="math">(\\mathsf{fpk},\\mathsf{fvk}) \\leftarrow \\mathcal{K}(\\mathsf{fpp},(\\mathsf{s}_1,\\mathsf{s}_2)) \\text{:}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Parse  <span class="math">s_1 = s_2</span>  as  <span class="math">((\\widetilde{M}_1, \\dots, \\widetilde{M}_t), (S_1, \\dots, S_q), (c_1, \\dots, c_q))</span> .</li>

      <li>2. Output fpk := (fpp,  <span class="math">s_1</span> ), fvk := (fpp,  <span class="math">s_1</span> ).</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\underline{(\\mathsf{u},\\mathsf{w})} \\leftarrow \\big\\langle \\mathcal{P}(\\mathsf{fpk},\\overrightarrow{\\mathsf{w}_1},\\overrightarrow{\\mathsf{w}_2}), \\mathcal{V}(\\mathsf{fvk}) \\big\\rangle \\big(\\overrightarrow{\\mathsf{u}_1},\\overrightarrow{\\mathsf{u}_2}\\big)</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Parse  <span class="math">(\\overrightarrow{\\mathsf{u}_1}, \\overrightarrow{\\mathsf{w}_1})</span>  as  <span class="math">\\{\\phi_k\\}_{k \\in [\\mu]}, (\\overrightarrow{\\mathsf{u}_2}, \\overrightarrow{\\mathsf{w}_2})</span>  as  <span class="math">\\{\\psi_{k&#x27;}\\}_{k&#x27; \\in [\\nu]}</span> .</li>

      <li>2.  <span class="math">\\mathcal{V}</span>  samples  <span class="math">\\gamma \\overset{\\</span>}{\\leftarrow} \\mathbb{F}, \\boldsymbol{\\beta} \\overset{\\<span class="math">}{\\leftarrow} \\mathbb{F}^s</span>  and sends them to  <span class="math">\\mathcal{P}</span> .  <span class="math">\\mathcal{V}</span>  then samples  <span class="math">r_x&#x27; \\overset{\\</span>}{\\leftarrow} \\mathbb{F}^s$ .</li>

      <li>3.  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run the sum-check protocol</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">c \\leftarrow \\left\\langle \\mathcal{P}, \\mathcal{V}(\\boldsymbol{r}_x&#x27;) \\right\\rangle \\left(g, s, d+1, \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\phi_k.v_i \\right).</span></div>

    <p class="text-gray-300"> <span class="math">{\\cal V}</span>  aborts once he outputs "reject" in the sum-check.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>4.  <span class="math">\\mathcal{P}</span>  computes and sends  <span class="math">\\{\\sigma_{k,i}, \\theta_{k&#x27;,i}\\}_{k \\in [\\mu], k&#x27; \\in [\\nu], i \\in [t]}</span>  to  <span class="math">\\mathcal{V}</span> .</li>

      <li>5.  <span class="math">\\mathcal{V}</span>  computes  <span class="math">\\{e_{k,1} \\coloneqq \\widetilde{eq}(\\phi_k.r_x,r_x&#x27;)\\}_{k\\in[\\mu]}</span> ,  <span class="math">e_2 \\coloneqq \\widetilde{eq}(\\boldsymbol{\\beta},r_x&#x27;)</span> , and aborts if</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} c \\neq &amp; \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\cdot e_{k,1} \\cdot \\sigma_{k,i} \\\\ &amp; + \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t+k&#x27;} \\cdot e_2 \\cdot \\left( \\sum_{i=1}^{q} c_i \\cdot \\prod_{j \\in S_i} \\theta_{k&#x27;,j} \\right). \\end{split}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>6.  <span class="math">\\mathcal{V}</span>  samples  <span class="math">\\rho \\stackrel{\\</span>}{\\leftarrow} \\mathbb{F}<span class="math">  and sends it to  </span>\\mathcal{P}$ .</li>

      <li>7.  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  output the folded  <span class="math">\\mathcal{R}_{LCCCS}</span>  instance  <span class="math">u := (C&#x27;, u&#x27;, \\mathbf{x}&#x27;, \\mathbf{r}&#x27;_x, v&#x27;_1, \\dots, v&#x27;_t)</span> , where for all  <span class="math">i \\in [t]</span> ,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} C&#x27; &amp;\\coloneqq \\sum_{k=1}^{\\mu} \\rho^{k-1} \\cdot \\phi_k.C_1 + \\sum_{k&#x27;=1}^{\\nu} \\rho^{\\mu-1+k&#x27;} \\cdot \\psi_{k&#x27;}.C_2, \\\\ u&#x27; &amp;\\coloneqq \\sum_{k=1}^{\\mu} \\rho^{k-1} \\cdot \\phi_k.u + \\sum_{k&#x27;=1}^{\\nu} \\rho^{\\mu-1+k&#x27;} \\cdot 1, \\\\ \\mathbf{x}&#x27; &amp;\\coloneqq \\sum_{k=1}^{\\mu} \\rho^{k-1} \\cdot \\phi_k.\\mathbf{x}_1 + \\sum_{k&#x27;=1}^{\\nu} \\rho^{\\mu-1+k&#x27;} \\cdot \\psi_{k&#x27;}.\\mathbf{x}_2, \\\\ v_i&#x27; &amp;\\coloneqq \\sum_{k=1}^{\\mu} \\rho^{k-1} \\cdot \\sigma_{k,i} + \\sum_{k&#x27;=1}^{\\nu} \\rho^{\\mu-1+k&#x27;} \\cdot \\theta_{k&#x27;,i}. \\end{split}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  outputs the folded  <span class="math">\\mathcal{R}_{LCCCS}</span>  witness  <span class="math">w \\coloneqq \\widetilde{w&#x27;}</span> , where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{w&#x27;} \\coloneqq \\sum_{k=1}^{\\mu} \\rho^{k-1} \\cdot \\phi_k.\\widetilde{w_1} + \\sum_{k&#x27;=1}^{\\nu} \\rho^{\\mu-1+k&#x27;} \\cdot \\psi_{k&#x27;}.\\widetilde{w_2}.</span></div>

    <p class="text-gray-300"><span id="page-6-0"></span><strong>Theorem 1.</strong> Construction 1 is a public-coin multi-folding scheme for  <span class="math">(\\mathcal{R}_{LCCCS}, \\mathcal{R}_{CCCS}, \\mathsf{compat}, \\mu, \\nu)</span>  with perfect completeness and knowledge soundness.</p>

    <p class="text-gray-300"><em>Proof sketch:</em> For perfect completeness, supposing that the inputs are satisfied instance-witness pairs, then by the completeness of the sum-check protocol,  <span class="math">\\mathcal V</span>  will not abort. By construction and the additive homomorphism property of the polynomial commitment scheme, we have that the output is a satisfied  <span class="math">\\mathcal R_{\\mathrm{LCCCS}}</span>  instance-witness pair. For knowledge soundness, we construct an expected polynomial time extractor that rewinds the interaction between a malicious prover and a</p>

    <p class="text-gray-300">verifier with fresh challenges to interpolate witnesses. By the soundness of the sum-check protocol and the Schwartz-Zippel lemma, we demonstrate that the extractor succeeds in obtaining satisfied witnesses for the input instances with a non-negligible probability. The formal proof is deferred to Appendix A.</p>

    <p class="text-gray-300">A non-interactive multi-folding scheme. Since our multi-folding scheme is public-coin, we could transform it into a non-interactive multi-folding scheme NIMFS =  <span class="math">(\\mathcal{G}, \\mathcal{K}, \\mathcal{P}, \\mathcal{V})</span>  for the tuple  <span class="math">(\\mathcal{R}_{LCCCS}, \\mathcal{R}_{CCCS}, \\text{compat}, \\mu, \\nu)</span>  using the Fiat-Shamir transformation, according to the Lemma 1 of Hyper-Nova [28].</p>

    <p class="text-gray-300"><strong>Efficiency.</strong> Fot the prover's cost, the sum-check protocol requires the prover to generate some proof, which could be completed with  <span class="math">O(\\mu(N+tm)+\\nu(N+tm+qmd\\log^2d))</span>  field operations according to [37]. For  <span class="math">\\{\\sigma_{k,i},\\theta_{k&#x27;,i}\\}_{k\\in[\\mu],k&#x27;\\in[\\nu],i\\in[t]}</span> , we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\sigma_{k,i} &amp;\\coloneqq \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;,\\boldsymbol{y}) \\cdot \\phi_k.\\widetilde{z}_1(\\boldsymbol{y}) \\\\ &amp;= \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\left(\\sum_{\\boldsymbol{a} \\in \\{0,1\\}^s} \\sum_{\\boldsymbol{b} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{a},\\boldsymbol{b}) \\cdot \\widetilde{eq}\\left((\\boldsymbol{r}_x&#x27;,\\boldsymbol{y}),(\\boldsymbol{a},\\boldsymbol{b})\\right)\\right) \\\\ &amp;\\cdot \\phi_k.\\widetilde{z}_1(\\boldsymbol{y}) \\\\ &amp;= \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\left(\\sum_{\\boldsymbol{a} \\in \\{0,1\\}^s} \\widetilde{eq}(\\boldsymbol{r}_x&#x27;,\\boldsymbol{a}) \\sum_{\\boldsymbol{b} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{a},\\boldsymbol{b}) \\cdot \\widetilde{eq}(\\boldsymbol{y},\\boldsymbol{b})\\right) \\\\ &amp;\\cdot \\phi_k.\\widetilde{z}_1(\\boldsymbol{y}) \\\\ &amp;= \\sum_{\\boldsymbol{a} \\in \\{0,1\\}^s} \\widetilde{eq}(\\boldsymbol{r}_x&#x27;,\\boldsymbol{a}) \\cdot \\sum_{\\boldsymbol{b} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{a},\\boldsymbol{b}) \\cdot \\phi_k.\\widetilde{z}_1(\\boldsymbol{b}) \\end{split}</span></div>

    <p class="text-gray-300">According to [42],  <span class="math">\\left\\{\\widetilde{eq}(r&#x27;_x,a)\\right\\}_{a\\in\\{0,1\\}^s}</span>  could be computed with O(m) field operations. Based on these values, the computation of  <span class="math">\\{\\sigma_{k,i},\\theta_{k&#x27;,i}\\}_{k\\in[\\mu],k&#x27;\\in[\\nu],i\\in[t]}</span>  could be accomplished with  <span class="math">O(m+(\\mu+\\nu)\\cdot N)</span>  field operations. When instantiating the polynomial commitment scheme with Bulletproofs [8], the computation of C' and  <span class="math">\\widetilde{w&#x27;}</span>  requires one MSM of size  <span class="math">\\mu+\\nu-1</span>  and  <span class="math">O((\\mu+\\nu)\\cdot n)</span>  field operations, respectively. Thus, the total cost is dominated by  <span class="math">O(\\mu(N+tm+n)+\\nu(N+tm+n+qmd\\log^2d))</span>  field operations and one MSM of size  <span class="math">\\mu+\\nu-1</span> .</p>

    <p class="text-gray-300">For the verifier's cost, verification in the sum-check protocol requires  <span class="math">O(d\\log m)</span>  field operations [39]. The computation of  <span class="math">\\{e_{k,1}\\}_{k\\in [\\mu]}, e_2</span>  and checking c require  <span class="math">O(\\mu\\log m + \\mu t + \\nu dq)</span>  field operations. The computation of C' requires one MSM of size  <span class="math">\\mu + \\nu - 1</span> . Thus, the total cost is dominated by  <span class="math">O(d\\log m + \\mu\\log m + \\mu t + \\nu dq)</span>  field operations and one MSM of size  <span class="math">\\mu + \\nu - 1</span> .</p>

    <p class="text-gray-300">The communication consists of elements sent from  <span class="math">\\mathcal P</span>  to  <span class="math">\\mathcal V</span>  in the sum-check protocol and  <span class="math">\\{\\sigma_{k,i},\\theta_{k&#x27;,i}\\}_{k\\in[\\mu],k&#x27;\\in[\\nu],i\\in[t]}</span> , which sums up to  <span class="math">O(d\\log m)+t\\cdot(\\mu+\\nu)</span>  field elements.</p>

    <p class="text-gray-300">Recall that PCD enables a set of parties to carry out an indefinitely long distributed computation where every step along the way is accompanied by a proof of correctness. We rely on our non-interactive multi-folding scheme to construct a PCD scheme.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">A. Overview</h3>

    <p class="text-gray-300">At each step of the long distributed computation, the prover P will receive r previous outputs  <span class="math">\\{z_i\\}_{i\\in[r]}</span> , each accompanied by a proof  <span class="math">\\Pi_i</span>  that attests to its correctness. We define  <span class="math">\\Pi_i</span>  to contain a satisfied  <span class="math">\\mathcal{R}_{LCCCS}</span>  instance-witness pair  <span class="math">(U_i, W_i)</span>  and a satisfied  <span class="math">\\mathcal{R}_{CCCS}</span>  instance-witness pair  <span class="math">(u_i, w_i)</span> . In addition, P has some local input  <span class="math">z_{loc}</span> . With  <span class="math">z_{loc}, z_1, \\ldots, z_r</span> , P computes zsuch that  <span class="math">\\varphi(z, z_{loc}, z_1, \\dots, z_r)</span>  accepts. Then P should provide a proof to the next party that attests not only to the correctness of his local computation, but also to the correctness of all his inputs  <span class="math">\\{z_i\\}_{i\\in[r]}</span> . To this end, P first invokes the non-interactive multi-folding scheme to fold  <span class="math">\\{(U_i, W_i), (u_i, w_i)\\}_{i \\in [r]}</span>  into a single  <span class="math">\\mathcal{R}_{LCCS}</span>  instance-witness pair (U, W). To prove the correctness of the folding process, we define a circuit  <span class="math">R_{\\varphi}</span> that represents the compliance predicate  <span class="math">\\varphi</span>  as well as the verifier of the non-interactive multi-folding scheme, which could be expressed as a  <span class="math">\\mathcal{R}_{CCCS}</span>  structure. Then P generates a satisfied  <span class="math">\\mathcal{R}_{CCCS}</span>  instance-witness pair (u, w) by computing  <span class="math">R_{\\omega}</span> using the appropriate input values from his prior computations. Finally, P outputs a proof  <span class="math">\\Pi</span>  consisting of (U, W), (u, w).</p>

    <p class="text-gray-300">By checking (u,w), we have that  <span class="math">\\varphi(z,z_{loc},z_1,\\ldots,z_r)</span>  accepts and  <span class="math">\\{U_i,u_i\\}_{i\\in[r]}</span>  is correctly folded into U. By further checking (U,W) and the knowledge soundness of the multifolding scheme, we have that there exists satisfied witnesses  <span class="math">\\{W_i,w_i\\}_{i\\in[r]}</span>  for instances  <span class="math">\\{U_i,u_i\\}_{i\\in[r]}</span> , which attests to the correctness of  <span class="math">\\{z_i\\}_{i\\in[r]}</span> . Therefore, we maintain the invariant that if (U,W) is a satisfied  <span class="math">\\mathcal{R}_{LCCCS}</span>  instance-witness pair and (u,w) is a satisfied  <span class="math">\\mathcal{R}_{CCCS}</span>  instance-witness pair, then the distributed computation is correct up to this step.</p>

    <p class="text-gray-300">However, the above description elides some subtlety. Since the proof  <span class="math">\\Pi</span>  passed to the next party includes U, the public IO of the circuit  <span class="math">R_{\\varphi}</span> , i.e., u.x should include U. The next party will fold u, U into a new  <span class="math">\\mathcal{R}_{LCCCS}</span>  instance as described above. But now U is part of u, they can not be folded. To address this issue, inspired by Nova [29], we modify  <span class="math">R_{\\varphi}</span>  to additionally hash z, U and let the output be the circuit's public IO, which ensures that u.x does not contain U but still binds with it. To achieve recursion, we further modify  <span class="math">R_{\\varphi}</span>  to include the verifier's work of checking that the inputs satisfy the hash relation, i.e.,  <span class="math">u_i</span> .x is the hash of  <span class="math">z_i</span> ,  <span class="math">U_i</span>  for  <span class="math">i \\in [r]</span> .</p>

    <p class="text-gray-300">Note that since the PCD proof includes the entire witnesses W, w, its size is linear in the size of the circuit. However, as in HyperNova [28], we could use a general SNARK such as SuperSpartan [37] to prove the knowledge of a valid PCD proof, which could reduce the proof size exponentially.</p>

    <p class="text-gray-300">Construction 2 (A PCD Scheme from Non-interactive Multi-folding Schemes). We formally present our PCD scheme as follows. Let  <span class="math">(u_\\perp, w_\\perp)</span>  be a default trivially satisfied  <span class="math">\\mathcal{R}_{\\mathrm{LCCCS}}</span>  instance-witness pair. Let NIMFS  <span class="math">= (\\mathcal{G}, \\mathcal{K}, \\mathcal{P}, \\mathcal{V})</span>  denote the non-interactive multi-folding scheme transformed from our multi-folding scheme. Let hash be a collision-resistant hash function. Given a compliance predicate  <span class="math">\\varphi</span> , the circuit  <span class="math">R_\\varphi</span>  that realizes the recursion is as follows.</p>

    <div class="my-4 text-center"><span class="math-block">0/1 \\leftarrow R_{\\varphi}(h; (z, z_{\\mathsf{loc}}, \\{z_i, \\mathsf{U}_i, \\mathsf{u}_i\\}_{i=1}^r, \\mathsf{fvk}, \\mathsf{U}, \\pi)):</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Check that the compliance predicate  <span class="math">\\varphi(z,z_{\\text{loc}},z_1,\\ldots,z_r)</span>  accepts.</li>

      <li>2. If  <span class="math">z_i = \\perp</span>  for all  <span class="math">i \\in [r]</span> , then check that  <span class="math">h = \\mathsf{hash}(\\mathsf{fvk}, z, \\mathsf{u}_\\perp)</span> .</li>

    </ul>

    <p class="text-gray-300">Else, check that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a) for  <span class="math">i \\in [r]</span> ,  <span class="math">u_i.\\mathbf{x} = \\mathsf{hash}(\\mathsf{fvk}, z_i, \\mathsf{U}_i)</span> , where  <span class="math">u_i.\\mathbf{x}</span>  is the public IO of  <span class="math">u_i</span> .</li>

      <li>b)  <span class="math">U = NIMFS.\\mathcal{V}(fvk, \\{U_i\\}_{i \\in [r]}, \\{u_i\\}_{i \\in [r]}, \\pi).</span></li>

      <li>c)  <span class="math">h = \\mathsf{hash}(\\mathsf{fvk}, z, \\mathsf{U}).</span></li>

      <li>3. If the above checks hold, output 1; otherwise, output 0.</li>

    </ul>

    <p class="text-gray-300">Since  <span class="math">R_{\\varphi}</span>  can be computed in polynomial time, it can be represented as a  <span class="math">\\mathcal{R}_{CCCS}</span>  structure. Let</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf{u},\\mathsf{w}) \\leftarrow \\mathsf{trace}\\big(R_{\\varphi}, \\big(h, (z, z_{\\mathsf{loc}}, \\{z_i, \\mathsf{U}_i, \\mathsf{u}_i\\}_{i=1}^r, \\mathsf{fvk}, \\mathsf{U}, \\pi)\\big)\\big)</span></div>

    <p class="text-gray-300">denote the satisfied  <span class="math">\\mathcal{R}_{\\text{CCCS}}</span>  instance-witness pair for the execution of  <span class="math">R_{\\varphi}</span>  on input  <span class="math">(h, (z, z_{\\text{loc}}, \\{z_i, U_i, u_i\\}_{i=1}^r, \\text{ fvk}, U, \\pi))</span> .</p>

    <p class="text-gray-300">We construct our PCD scheme (G, K, P, V) as follows.</p>

    <p class="text-gray-300"><span class="math-block">\\mathsf{pp} \\leftarrow \\mathsf{G}\\left(1^{\\lambda}\\right)</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Sample size bounds  <span class="math">m, n, N, \\ell, t, q, d \\in \\mathbb{N}</span> .</li>

      <li>2. Compute fpp  <span class="math">\\leftarrow</span>  NIMFS. <span class="math">\\mathcal{G}\\left(1^{\\lambda}, (m, n, N, \\ell, t, q, d)\\right)</span> , and output pp  <span class="math">\\coloneqq</span>  fpp.</li>

    </ul>

    <p class="text-gray-300"><span class="math-block">(pk, vk) \\leftarrow K(pp, \\varphi)</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">(fpk, fvk) \\leftarrow NIMFS.\\mathcal{K}(fpp, R_{\\varphi})</span> , and output (pk, vk) := (fpk, fvk).</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\Pi \\leftarrow \\mathsf{P}\\big(\\mathsf{pk}, z, z_{\\mathsf{loc}}, \\{z_i, \\Pi_i\\}_{i=1}^r\\big) :</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. For  <span class="math">i \\in [r]</span> , parse  <span class="math">\\Pi_i</span>  as  <span class="math">((U_i, W_i), (u_i, w_i))</span> , where  <span class="math">(U_i, W_i)</span>  is a satisfied  <span class="math">\\mathcal{R}_{LCCCS}</span>  instance-witness pair and  <span class="math">(u_i, w_i)</span>  is a satisfied  <span class="math">\\mathcal{R}_{CCCS}</span>  instance-witness pair.</li>

      <li>2. If  <span class="math">z_i = \\perp</span>  for all  <span class="math">i \\in [r]</span> , then set  <span class="math">(\\mathsf{U}, \\mathsf{W}, \\pi) \\coloneqq (\\mathsf{u}_\\perp, \\mathsf{w}_\\perp, \\perp)</span> . Else, compute  <span class="math">(\\mathsf{U}, \\mathsf{W}, \\pi) \\leftarrow \\mathsf{NIMFS}.\\mathcal{P} \\big(\\mathsf{fpk}, \\{(\\mathsf{U}_i, \\mathsf{W}_i)\\}_{i \\in [r]}, \\{(\\mathsf{u}_i, \\mathsf{w}_i)\\}_{i \\in [r]} \\big)</span> .</li>

      <li>3. Compute  <span class="math">h \\leftarrow \\mathsf{hash}(\\mathsf{fvk}, z, \\mathsf{U})</span> .</li>

      <li>4.  <span class="math">(\\mathsf{u},\\mathsf{w}) \\leftarrow \\mathsf{trace}\\big(R_{\\varphi},\\big(h,(z,z_{\\mathsf{loc}},\\{z_i,\\mathsf{U}_i,\\mathsf{u}_i\\}_{i=1}^r,\\mathsf{fvk},\\mathsf{U},\\pi)\\big)\\big).</span></li>

      <li>5. Output  <span class="math">\\Pi := ((U, W), (u, w))</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Parse  <span class="math">\\Pi</span>  as ((U, W), (u, w)).</li>

      <li>2. Check that  <span class="math">u.\\mathbf{x} = \\mathsf{hash}(\\mathsf{fvk}, z, \\mathsf{U})</span> .</li>

      <li>3. Check that W is a satisfied  <span class="math">\\mathcal{R}_{\\rm LCCCS}</span>  witness to U and w is a satisfied  <span class="math">\\mathcal{R}_{\\rm CCCS}</span>  witness to u.</li>

      <li>4. If the above checks hold, output 1; otherwise, output 0.</li>

    </ul>

    <p class="text-gray-300"><span id="page-7-1"></span><strong>Theorem 2.</strong> Construction 2 is a PCD scheme with perfect completeness and knowledge soundness.</p>

    <p class="text-gray-300"><em>Proof sketch:</em> The perfect completeness follows from the perfect completeness of the multi-folding scheme and the construction of circuit  <span class="math">R_{\\varphi}</span> . For knowledge soundness, considering</p>

    <p class="text-gray-300">an expected polynomial time adversary  <span class="math">P^<em></span> , we construct an expected polynomial time extractor  <span class="math">\\mathcal{E}_{P^</em>}</span>  to extract the transcript T of depth d via an iterative process. In the base case, we use  <span class="math">P^<em></span>  to construct an extractor  <span class="math">\\mathcal{E}_0</span>  that extracts  <span class="math">T_0</span> , which consists of a single node. Then supposing the existence of  <span class="math">\\mathcal{E}_{i-1}</span>  that extracts  <span class="math">T_{i-1}</span> , we construct an adversary  <span class="math">\\mathcal{P}^</em>_{i-1}</span>  for the non-interactive multi-folding scheme. By the knowledge soundness of the multi-folding scheme, this implies the existence of an extractor  <span class="math">\\mathcal{E}_{\\mathcal{P}^<em>_{i-1}}</span>  corresponding to  <span class="math">\\mathcal{P}^</em>_{i-1}</span> . We then construct an extractor  <span class="math">\\mathcal{E}_i</span>  that extracts  <span class="math">T_i</span>  using  <span class="math">\\mathcal{P}^<em>_{i-1}</span> ,  <span class="math">\\mathcal{E}_{\\mathcal{P}^</em>_{i-1}}</span> . By repeating this iterative process, we construct an extractor  <span class="math">\\mathcal{E}_d</span>  that extracts  <span class="math">T_d</span> , which is exactly equal to  <span class="math">\\mathcal{E}_{P^*}</span> . Finally, we demonstrate inductively the correctness of these extractors. The formal proof is deferred to Appendix B.</p>

    <p class="text-gray-300"><strong>Efficiency.</strong> The recursion overhead, i.e., the computations that the prover must prove at each step in addition to proving the compliance predicate, involves r+1 calls to hash and one call to NIMFS. <span class="math">\\mathcal V</span> . The cost of NIMFS. <span class="math">\\mathcal V</span>  is dominated by  <span class="math">O\\left(d\\log m + r\\cdot(\\log m + t + dq)\\right)</span>  field operations, one MSM of size 2r-1 and  <span class="math">2\\log m+2</span>  calls to the random oracle RO to achieve non-interactivity, where RO could be instantiated with an appropriate cryptographic hash function.</p>

    <p class="text-gray-300">The prover's work at each step is dominated by invoking NIMFS.  <span class="math">\\mathcal{P}</span> , and computing the satisfied  <span class="math">\\mathcal{R}_{\\text{CCCS}}</span>  instancewitness pair  <span class="math">(\\mathbf{u},\\mathbf{w})</span>  for the execution of  <span class="math">R_{\\varphi}</span> . The cost of NIMFS.  <span class="math">\\mathcal{P}</span>  is dominated by  <span class="math">O\\left(r\\cdot(N+tm+n+qmd\\log^2d)\\right)</span>  field operations, one MSM of size 2r-1, and  <span class="math">2\\log m+2</span>  calls to RO to achieve non-interactivity. The cost of computing  <span class="math">(\\mathbf{u},\\mathbf{w})</span>  is dominated by computing the commitment C which requires one MSM of size O(n) when instantiating the polynomial commitment scheme with Bulletproofs [8].</p>

    <p class="text-gray-300">The size of proof  <span class="math">\\Pi = ((\\mathsf{U},\\mathsf{W}),(\\mathsf{u},\\mathsf{w}))</span>  is linear in the size of  <span class="math">R_\\varphi</span> . However, as in HyperNova [28], we could use a general SNARK to compress the proof. Specifically, the prover invokes  <span class="math">(\\mathsf{U}&#x27;,\\mathsf{W}&#x27;,\\pi&#x27;) \\leftarrow \\mathsf{NIMFS}.\\mathcal{P}(\\mathsf{fpk},(\\mathsf{U},\\mathsf{W}),(\\mathsf{u},\\mathsf{w}))</span> , and then uses a general SNARK to generate a proof  <span class="math">\\pi_{\\mathsf{U}&#x27;}</span>  that proves the knowledge of  <span class="math">\\mathsf{W}&#x27;</span> . Now  <span class="math">\\Pi</span>  consists of  <span class="math">(\\mathsf{U},\\mathsf{u},\\pi&#x27;,\\pi_{\\mathsf{U}&#x27;})</span> . When instantiating the SNARK with SuperSpartan [37] excluding the first sum-check invocation and using the polynomial commitment scheme based on Bulletproofs [8], the proof size is then dominated by  <span class="math">O(d\\log m + t + \\log n)</span>  field elements and  <span class="math">O(\\log n)</span>  group elements.</p>

    <p class="text-gray-300">The verifier's work is dominated by checking (U,W),(u,w) according to the CCCS and LCCCS relations. If the proof is compressed, then the verifier's work is dominated by performing  <span class="math">U&#x27; \\leftarrow \\mathsf{NIMFS.}\\mathcal{V}(\\mathsf{fvk},\\mathsf{U},\\mathsf{u},\\pi&#x27;)</span>  and verifying  <span class="math">\\pi_{\\mathsf{U&#x27;}}</span> , whose cost is dominated by  <span class="math">O(d\\log m + t + dq + \\log n + N)</span>  field operations,  <span class="math">O(\\log m + \\log n)</span>  calls to RO, and one MSM of size O(n).</p>

    <h2 id="sec-18" class="text-2xl font-bold">V. IMPLEMENTATION AND EVALUATION</h2>

    <p class="text-gray-300">We have implemented our multi-folding scheme and PCD scheme to evaluate their practical efficiency. We present the implementation details and evaluation results in this section.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">A. Implementation Methodology</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given an elliptic curve group  <span class="math">\\mathbb{G}</span> , denote the <em>scalar field</em> of  <span class="math">\\mathbb{G}</span>  as the field  <span class="math">\\mathbb{F}_1</span>  whose order is  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , and the <em>base field</em> of  </span>\\mathbb{G}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">as the field  <span class="math">\\mathbb{F}_2</span>  over which the elliptic curve group is defined. Typically,  <span class="math">\\mathbb{F}_1</span>  and  <span class="math">\\mathbb{F}_2</span>  are distinct; otherwise, the discrete logarithm assumption would not hold [38]. To implement our PCD scheme, we need to implement the circuit  <span class="math">R_{\\varphi}</span>  defined over the scalar field  <span class="math">\\mathbb{F}_1</span> . However, since NIMFS. <span class="math">\\mathcal{V}&#x27;</span>  involves group operations over  <span class="math">\\mathbb{F}_2</span> , directly encoding them within the circuit  <span class="math">R_{\\varphi}</span>  would require emulating  <span class="math">\\mathbb{F}_2</span>  operations via  <span class="math">\\mathbb{F}_1</span>  operations, which would significantly increase the circuit size.</p>

    <p class="text-gray-300">To avoid a blowup in the circuit size, existing implementations of recursive arguments based on groups [2], [9], [29], [32] utilize a 2-cycle of elliptic curves  <span class="math">(E_1, E_2)</span> . This cycle induces a pair of elliptic curve groups  <span class="math">(\\mathbb{G}_1,\\mathbb{G}_2)</span> , where  <span class="math">\\mathbb{G}_1</span>  has scalar field  <span class="math">\\mathbb{F}_1</span>  and base field  <span class="math">\\mathbb{F}_2</span>  while  <span class="math">\\mathbb{G}_2</span>  has scalar field  <span class="math">\\mathbb{F}_2</span>  and base field  <span class="math">\\mathbb{F}_1</span> . Kothapalli and Setty [27] introduced CycleFold, a conceptually simple approach to instantiate folding-schemebased recursive arguments over a cycle of elliptic curves for realizing IVC schemes. Instead of emulating non-native field operations within a primary circuit defined over  <span class="math">E_1</span> , CycleFold outsources these operations to a secondary circuit defined over  <span class="math">E_2</span> , generates an instance-witness pair to represent the correct execution of the secondary circuit, and then folds this instance along with some running instances within the primary circuit. Due to the properties of the 2-cycle of elliptic curves, the emulation overhead is significantly reduced.</p>

    <p class="text-gray-300">We adapt CycleFold to implement our PCD scheme and provide an overview of the circuit implementation in Fig. 1, where superscripts (1) and (2) denote the elements defined over the elliptic curve  <span class="math">E_1</span>  and  <span class="math">E_2</span> , respectively.</p>

    <p class="text-gray-300"><span id="page-8-0"></span><img src="_page_8_Figure_12.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 1: PCD circuit implementation overview</p>

    <p class="text-gray-300">We use a primary circuit defined over the scalar field  <span class="math">\\mathbb{F}_1</span>  of  <span class="math">E_1</span>  to encode all parts of  <span class="math">R_{\\varphi}</span>  except for the group operation  <span class="math">C&#x27;^{(1)} := \\sum_{k=1}^r \\rho^{k-1} \\cdot \\mathsf{U}_k^{(1)}.C_1 + \\sum_{k&#x27;=1}^r \\rho^{r-1+k&#x27;} \\cdot \\mathsf{u}_{k&#x27;}^{(1)}.C_2</span>  in NIMFS. <span class="math">\\mathcal{V}&#x27;</span> . This operation is defined over  <span class="math">\\mathbb{F}_2</span>  and is thus nonnative to the primary circuit. Instead, we use a secondary circuit  <span class="math">C_{\\mathsf{EC}}</span>  defined over the scalar field  <span class="math">\\mathbb{F}_2</span>  of  <span class="math">E_2</span>  to encode this group operation, which eliminates the need for field emulation. To complete NIMFS. <span class="math">\\mathcal{V}&#x27;</span>  in the primary circuit, we represent the secondary circuit as a R1CS structure and generate a satisfied instance-witness pair  <span class="math">\\left(\\mathsf{u}_{\\mathsf{EC},r+1}^{(2)},\\mathsf{w}_{\\mathsf{EC},r+1}^{(2)}\\right)</span>  with the public IO  <span class="math">\\left\\{\\mathsf{U}_i^{(1)}.C_1,\\mathsf{u}_i^{(1)}.C_2\\right\\}_{i=1}^r,\\rho,C&#x27;^{(1)}</span> . The primary circuit reads  <span class="math">\\mathsf{u}_{\\mathsf{EC},r+1}^{(2)}</span>  and, after checking that the public IO in  <span class="math">\\mathsf{u}_{\\mathsf{EC},r+1}^{(2)}</span></p>

    <p class="text-gray-300">matches the desired inputs, adds  <span class="math">C&#x27;^{(1)}</span>  to  <span class="math">\\mathsf{U}^{(1)}</span> .</p>

    <p class="text-gray-300">Then different from Construction 2, the verifier now should additionally check the satisfiability of  <span class="math">(\\mathsf{u}_{\\mathsf{EC},r+1}^{(2)},\\mathsf{w}_{\\mathsf{EC},r+1}^{(2)})</span> , making the PCD proof  <span class="math">\\Pi_i^{(1)}</span>  for  <span class="math">z_i^{(1)}</span>  now consist of  <span class="math">(\\mathsf{U}_i^{(1)},\\mathsf{W}_i^{(1)}),(\\mathsf{u}_i^{(1)},\\mathsf{w}_i^{(1)}),(\\mathsf{U}_{\\mathsf{EC},i}^{(2)},\\mathsf{W}_{\\mathsf{EC},i}^{(2)})</span> . The prover should additionally fold the inputs  <span class="math">(\\mathsf{U}_{\\mathsf{EC},i}^{(2)},\\mathsf{W}_{\\mathsf{EC},i}^{(2)})</span>  and newly generated  <span class="math">(\\mathsf{u}_{\\mathsf{EC},r+1}^{(2)},\\mathsf{w}_{\\mathsf{EC},r+1}^{(2)})</span>  into a single instance-witness pair  <span class="math">(U_{EC}^{(2)},W_{EC}^{(2)})</span> . Intuitively, this scenario aligns well with our multi-folding scheme. However, in this case, encoding the multi-folding scheme's verification in a circuit inevitably requires emulating the logarithmic field operations or the constant group operations within the verification algorithm, both of which are unacceptable. Instead, we turn our attention to the folding scheme in Nova [29]. While it is designed to fold two instances, it can be invoked multiple times to fold multiple instances. More importantly, since the folding scheme is invoked to fold instances from the secondary circuit, its verification is native to the primary circuit except for a few field operations. Thus, we could encode the folding scheme's verification within the primary circuit. Furthermore, the number of field operations in the verification that are nonnative to the primary circuit is roughly linear to the number of public IO of the secondary circuit. Notably, the public IO mainly consists of elliptic curve group elements. To reduce the emulation overhead, we adopt a compressed format to store these elements and decompress them when used in the circuit. This approach roughly halves the emulation overhead.</p>

    <p class="text-gray-300">We implement our proposed schemes in Rust based on the Nova library [34]. While our multi-folding scheme and PCD scheme support CCS, we limit our attention to R1CS, a specific instantiation of CCS, for a fair comparison with existing works. The experiments are conducted on Ubuntu 22.04 with an X86 architecture, equipped with a 12-core AMD Ryzen 9 5900X CPU running at 3.70GHz and 128GB of memory. We evaluate the following typical performance metrics of our PCD scheme.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. The concrete recursion overhead. We measure the recursion overhead with the number of R1CS constraints over the scalar field of both primary curve  <span class="math">(E_1)</span>  and secondary curve  <span class="math">(E_2)</span>  across various arity parameters and proving circuit sizes <sup>4</sup>. We compare the results with existing works to demonstrate the advantages.</li>

      <li>2. The prover time at each step, as well as the proof size and verifier time without compression. We measure these performance metrics across various arity parameters and predicate sizes to illustrate the trends.</li>

      <li>The proof size and verifier time after compression. We apply a specific SNARK to compress the PCD proof and compare the proof size and verifier time before and after compression.</li>

    </ul>

    <p class="text-gray-300">Similar to the Nova library, our implementation supports three typical cycles of elliptic curves: 1) Pallas/Vesta, 2) BN254/Grumpkin, and 3) secp/secq. We choose the Pallas/Vesta cycle of curves [35] as used in BCLMS21 [9] when reporting our evaluation results.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">C. Evaluation Results</h3>

    <p class="text-gray-300">Concrete recursion overhead. In Table II, we compare our recursion overhead with COS20 [16] and BCLMS21 [9] in detail for different r and a fixed proving circuit size of  <span class="math">2^{20}</span> . Note that COS20 and BCLMS21 both only report their recursion overheads for r = 1. For comparison, we estimate their recursion overheads for larger r based on the theoretical complexity analysis in Table I. Additionally, COS20 relies solely on symmetric primitives and thereby its recursion overhead is evaluated in a field independent of elliptic curves. Table II shows that our PCD scheme achieves the lowest recursion overhead. Although COS20 does not require cycles of elliptic curves, its recursion overhead is still approximately 20 times greater than ours summed on both the primary and secondary curves. BCLMS21 has slightly lower recursion overhead on the primary curve for r = 1, but the total overhead from both curves is still higher than ours. In other cases, our recursion overhead is approximately 1.5 times smaller on the primary curve and 9.8 times smaller on the secondary curve.</p>

    <p class="text-gray-300"><span id="page-9-1"></span>TABLE II: Comparison of concrete recursion overhead with proving circuit size of  <span class="math">2^{20}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Schemes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Arity <span class="math">(r)</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Primary curve/field<br>(# constraints)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Secondary curve<br>(# constraints)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1,132,666</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">COS20 [16]</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2,265,332</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">3,397,998</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">_</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">4,530,664</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BCLMS21 [9]</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">52,000</td>

            <td class="px-3 py-2 border-b border-gray-700">52,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">137,428</td>

            <td class="px-3 py-2 border-b border-gray-700">137,428</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">222,857</td>

            <td class="px-3 py-2 border-b border-gray-700">222,857</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">_</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">308,285</td>

            <td class="px-3 py-2 border-b border-gray-700">308,285</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">68,017</td>

            <td class="px-3 py-2 border-b border-gray-700">5,429</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">96,202</td>

            <td class="px-3 py-2 border-b border-gray-700">14,011</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">_</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">139,573</td>

            <td class="px-3 py-2 border-b border-gray-700">22,593</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">_</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">191,916</td>

            <td class="px-3 py-2 border-b border-gray-700">31,175</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Fig. 2, we depict the variations in recursion overhead on the primary curve/field<sup>5</sup> across proving circuit sizes reported in COS20 and different arity r. The figure shows that the recursion overhead for COS20 is significantly higher than those for BCLMS21 and ours. The recursion overheads for COS20 and ours increase slowly as the proving circuit size increases, while that for BCLMS21 remains constant. However, BCLMS21's recursion overhead remains higher than ours except when r=1, and as r continues to increase, this gap gradually widens.</p>

    <p class="text-gray-300"><strong>Efficiency without compression.</strong> In Fig. 3, we report the efficiency of our PCD scheme for different arity r and pred-</p>

    <p class="text-gray-300"><span id="page-9-0"></span><sup>&</sup>lt;sup>4</sup>The proving circuit is actually the primary circuit in our benchmark.</p>

    <p class="text-gray-300"><span id="page-9-2"></span><sup>&</sup>lt;sup>5</sup>The recursion overheads for BCLMS21 and our scheme on the secondary curve are independent of the proving circuit size.</p>

    <p class="text-gray-300"><span id="page-10-0"></span><img src="_page_10_Figure_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 2: Comparison of recursion overhead on the primary curve for different arities and proving circuit sizes</p>

    <p class="text-gray-300">icate sizes<sup>6</sup>. According to our benchmark, when the predicate size is below a certain threshold, the recursion overhead on the primary curve will exceed the predicate size<sup>7</sup>. Specifically, for r=1,2,3,4, the thresholds are roughly 61474, 91836, 137388, 189729, respectively. The prover time, proof size, and verifier time all depend on both the predicate size and the recursion overhead. Therefore, when the predicate size is near the threshold, these metrics scale sublinearly with the predicate size. When the predicate size significantly exceeds the threshold, they scale almost linearly.</p>

    <p class="text-gray-300">Fig. 3a shows that the prover time increases with arity r when the predicate is fixed. For example, fixing the predicate size as  <span class="math">2^{24}</span> , the prover time is 28s, 49s, 71s, and 94s for r=1,2,3,4, respectively. This is because higher r requires the prover to fold more instance-witness pairs. Additionally, the folding cost is almost linear in the predicate size when the size is much larger than the corresponding threshold. Thus, as shown in Fig. 3a, the gap between different r nearly doubles as the predicate size doubles.</p>

    <p class="text-gray-300">The proof size and verifier time depend on the sizes of the primary and secondary circuits. They also increase with r because a larger r leads to higher recursion overhead which in turn implies larger primary and secondary circuits. However, the increase in recursion overhead is minor compared to a large predicate size. As shown in Fig. 3b and Fig. 3c, when the</p>

    <p class="text-gray-300">predicate size is doubled, the gap between different r remains almost the same, and the curves for different r gradually tend to overlap. We conclude that as the predicate circuit size increases, the impact of increasing r on proof size and verifier time diminishes.</p>

    <p class="text-gray-300">Efficiency with compression. When instantiating our PCD scheme over a cycle of elliptic curves, the PCD proof consists of a LCCCS instance-witness pair  <span class="math">(U^{(1)},W^{(1)})</span> , a CCCS instance-witness pair  <span class="math">(u^{(1)},w^{(1)})</span>  and a committed relaxed R1CS instance-witness pair  <span class="math">(U_{EC}^{(2)},W_{EC}^{(2)})</span> . To compress this proof, we first invoke the multi-folding scheme to fold  <span class="math">(U^{(1)},W^{(1)}),(u^{(1)},w^{(1)})</span>  into a new LCCCS instance-witness pair  <span class="math">(U&#x27;^{(1)},W&#x27;^{(1)})</span> . We then invoke SuperSpartan [37] excluding the first sum-check invocation to prove the satisfiability of  <span class="math">(U&#x27;^{(1)},W&#x27;^{(1)})</span> . Next, we invoke the SNARK in Nova [29] to prove the satisfiability of  <span class="math">(U_{EC}^{(2)},W_{EC}^{(2)})</span> . In Fig. 4, we fix r=2 and compare the proof size and verifier time before and after compression.</p>

    <p class="text-gray-300">Fig. 4a shows that the proof size is significantly reduced after compression. For a predicate size of  <span class="math">2^{17}</span> , the proof size is reduced from 14MB to 11KB, and for a predicate size of  <span class="math">2^{24}</span> , it is reduced from 1031MB to 13KB. However, this reduction comes at the cost of increased verifier time, as shown in Fig. 4b. For a predicate size of  <span class="math">2^{17}</span> , the verifier time increases from 211ms to 508ms, and for a predicate size of  <span class="math">2^{24}</span> , it increases from 11s to 22s.</p>

    <p class="text-gray-300">Enforcing language semantics in distributed computations.</p>

    <p class="text-gray-300">Our PCD scheme can be naturally used in several scenarios.</p>

    <p class="text-gray-300">tiating our PCD compliance predicate  <span class="math">\\varphi</span>  with their predicate.</p>

    <p class="text-gray-300"><strong>Privacy pools.</strong> A privacy pool enables users to deposit funds into a shared pool, anonymously transfer funds within the pool, and later withdraw funds without linkage to their previous transactions. In August 2022, Tornado Cash, the largest Ethereum privacy pool, was sanctioned for purportedly laundering over \\$9 billion worth of cryptocurrency since 2019, making it illegal for entities to use its funds and sparking a global privacy rights debate. Beal and Fisch [1] presented a system that institutions could use to request cryptographic attestations of fund origins rather than naively rejecting all privacy pool funds. They utilized PCD to propagate allowlist membership proofs through a privacy pool's transaction graph and instantiated their system with the PCD construction of BCLMS21 [9], which incurs high overhead. In contrast, our</p>

    <p class="text-gray-300"><span id="page-10-1"></span><sup>&</sup>lt;sup>6</sup>We select the predicate as the <em>X</em>-axis since it represents the computations that the prover truly intends to prove. Moreover, since COS20 does not have open-source code and BCLMS21's library cannot be compiled due to lack of maintenance, we do not include a comparison with them.</p>

    <p class="text-gray-300"><span id="page-10-2"></span><sup>&</sup>lt;sup>7</sup>The recursion overhead on the primary curve increases with the predicate size, though in a sublinear manner. This threshold is also called <em>recursion threshold</em> in [16], [9], [5].</p>

    <p class="text-gray-300"><span id="page-11-9"></span><img src="_page_11_Figure_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><img src="_page_11_Figure_1.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><img src="_page_11_Figure_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(a) Prover time at each step (b) Proof size without compression</li>

      <li>(c) Verifier time without compression</li>

    </ul>

    <p class="text-gray-300">Fig. 3: PCD efficiency for different arities and predicate sizes</p>

    <p class="text-gray-300"><span id="page-11-10"></span><img src="_page_11_Figure_6.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 4: Comparison of the proof size and verifier time before and after compression</p>

    <p class="text-gray-300">PCD scheme has better efficiency and can be applied directly in this scenario.</p>

    <p class="text-gray-300">Scalable folding-based SNARKs. SNARKs allow a prover to generate short and efficiently verifiable proofs attesting to computation correctness. Most SNARK constructions require the prover to record the entire computation trace, resulting in high memory overhead and limited scalability. Nguyen et al. [33] proposed a framework for building folding-based SNARKs that achieves constant-size prover memory efficiency while maintaining linear prover computation efficiency. Their framework largely relies on PCD schemes. To estimate their SNARK's performance, they used a PCD scheme that combines the PCD compiler of BCLMS21 [9] with their folding scheme for polynomial relations. This PCD scheme supports degree-d gates, enabling succinct representation of high-degree computations. However, the number of group operations required by the prover and verifier scales linearly with d, nearly eliminating the benefits of high-degree gates. In contrast, our PCD scheme's group operations for the prover and verifier are independent of d, making it ideal for handling high-degree computations within their framework.</p>

    <p class="text-gray-300">PCD enables mutually distrustful parties to perform distributed computations on directed acyclic graphs in an efficiently verifiable manner. In this paper, we first construct a multi-folding scheme for an arbitrary number of instances,</p>

    <p class="text-gray-300">which could reduce the task of checking multiple instances into the task of checking one. We then construct and implement a new PCD scheme based on our multi-folding scheme. Theoretical analysis and experimental results demonstrate that our PCD scheme achieves significantly lower recursion overhead and better practical efficiency. Additionally, our PCD scheme supports the customizable constraint system with high expressivity and can be naturally applied in various scenarios, including enforcing language semantics, privacy pools, and scalable folding-based SNARKs.</p>

    <p class="text-gray-300">However, our PCD scheme does not currently achieve zero-knowledge. A recent update of HyperNova [28] introduced a new approach for randomizing IVC proofs with folding schemes to achieve zero-knowledge. We believe this approach can be applied to our PCD scheme and leave integrating it in future work.</p>

    <h2 id="sec-25" class="text-2xl font-bold">REFERENCES</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-11-0"></span>[1] J. Beal and B. Fisch, "Derecho: Privacy pools with proof-carrying disclosures," Cryptology ePrint Archive, Paper 2023/273, 2023.</li>

      <li><span id="page-11-3"></span>[2] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza, "Scalable zero knowledge via cycles of elliptic curves," in <em>CRYPTO</em>, ser. LNCS, J. A. Garay and R. Gennaro, Eds., vol. 8617. Springer, 2014, pp. 276–294.</li>

      <li><span id="page-11-2"></span>[3] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer, "Recursive composition and bootstrapping for SNARKS and proof-carrying data," in <em>Symposium on Theory of Computing Conference, STOC'13, Palo Alto, CA, USA, June 1-4, 2013</em>, D. Boneh, T. Roughgarden, and J. Feigenbaum, Eds. ACM, 2013, pp. 111–120.</li>

      <li><span id="page-11-7"></span>[4] D. Boneh and B. Chen, "LatticeFold: A lattice-based folding scheme and its applications to succinct proof systems," Cryptology ePrint Archive, Paper 2024/257, 2024.</li>

      <li><span id="page-11-6"></span>[5] D. Boneh, J. Drake, B. Fisch, and A. Gabizon, "Halo infinite: Proofcarrying data from additive polynomial commitments," in <em>CRYPTO</em>, ser. LNCS, T. Malkin and C. Peikert, Eds., vol. 12825. Springer, 2021, pp. 649–680.</li>

      <li><span id="page-11-1"></span>[6] J. Bonneau, I. Meckler, V. Rao, and E. Shapiro, "Coda: Decentralized cryptocurrency at scale," Cryptology ePrint Archive, Paper 2020/352, 2020.</li>

      <li><span id="page-11-4"></span>[7] S. Bowe, J. Grigg, and D. Hopwood, "Recursive proof composition without a trusted setup," Cryptology ePrint Archive, Paper 2019/1021, 2019.</li>

      <li><span id="page-11-8"></span>[8] B. Bünz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell, "Bulletproofs: Short proofs for confidential transactions and more," in S&P. IEEE Computer Society, 2018, pp. 315–334.</li>

      <li><span id="page-11-5"></span>[9] B. Bünz, A. Chiesa, W. Lin, P. Mishra, and N. Spooner, "Proof-carrying data without succinct arguments," in <em>CRYPTO</em>, ser. LNCS, T. Malkin and C. Peikert, Eds., vol. 12825. Springer, 2021, pp. 681–710.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-12-9"></span>[10] B. Bünz, A. Chiesa, P. Mishra, and N. Spooner, "Recursive proof composition from accumulation schemes," in <em>TCC</em>, ser. LNCS, R. Pass and K. Pietrzak, Eds., vol. 12551. Springer, 2020, pp. 1–18.</li>

      <li><span id="page-12-26"></span>[11] B. Bünz, B. Fisch, and A. Szepieniec, "Transparent snarks from DARK compilers," in <em>EUROCRYPT</em>, ser. LNCS, A. Canteaut and Y. Ishai, Eds., vol. 12105. Springer, 2020, pp. 677–706.</li>

      <li><span id="page-12-18"></span>[12] B. Bünz and B. Chen, "Protostar: Generic efficient accumulation/folding for special sound protocols," Cryptology ePrint Archive, Paper 2023/620, 2023.</li>

      <li><span id="page-12-20"></span>[13] B. Bünz and J. Chen, "Proofs for deep thought: Accumulation for large memories and deterministic computations," Cryptology ePrint Archive, Paper 2024/325, 2024.</li>

      <li><span id="page-12-21"></span>[14] B. Bünz, P. Mishra, W. Nguyen, and W. Wang, "Accumulation without homomorphism," Cryptology ePrint Archive, Paper 2024/474, 2024.</li>

      <li><span id="page-12-6"></span>[15] W. Chen, A. Chiesa, E. Dauterman, and N. P. Ward, "Reducing participation costs via incremental verification for ledger systems," Cryptology ePrint Archive, Paper 2020/1522, 2020.</li>

      <li><span id="page-12-8"></span>[16] A. Chiesa, D. Ojha, and N. Spooner, "Fractal: Post-quantum and transparent recursive proofs from holography," in <em>EUROCRYPT</em>, ser. LNCS, A. Canteaut and Y. Ishai, Eds., vol. 12105. Springer, 2020, pp. 769–793.</li>

      <li><span id="page-12-0"></span>[17] A. Chiesa and E. Tromer, "Proof-carrying data and hearsay arguments from signature cards," in <em>ICS</em>, A. C. Yao, Ed. Tsinghua University Press, 2010, pp. 310–331.</li>

      <li><span id="page-12-3"></span>[18] A. Chiesa, E. Tromer, and M. Virza, "Cluster computing in zero knowledge," in <em>EUROCRYPT</em>, ser. LNCS, E. Oswald and M. Fischlin, Eds., vol. 9057. Springer, 2015, pp. 371–403.</li>

      <li><span id="page-12-2"></span>[19] S. Chong, E. Tromer, and J. A. Vaughan, "Enforcing language semantics using proof-carrying data," Cryptology ePrint Archive, Paper 2013/513, 2013.</li>

      <li><span id="page-12-23"></span>[20] G. Cormode, M. Mitzenmacher, and J. Thaler, "Practical verified computation with streaming interactive proofs," in <em>ITCS</em>, S. Goldwasser, Ed. ACM, 2012, pp. 90–112.</li>

      <li><span id="page-12-19"></span>[21] L. Eagen and A. Gabizon, "Protogalaxy: Efficient protostar-style folding of multiple instances," Cryptology ePrint Archive, Paper 2023/1106, 2023.</li>

      <li><span id="page-12-14"></span>[22] A. Fiat and A. Shamir, "How to prove yourself: Practical solutions to identification and signature problems," in <em>CRYPTO</em>, ser. LNCS, A. M. Odlyzko, Ed., vol. 263. Springer, 1986, pp. 186–194.</li>

      <li><span id="page-12-10"></span>[23] R. Gennaro, C. Gentry, B. Parno, and M. Raykova, "Quadratic span programs and succinct nizks without pcps," in <em>EUROCRYPT</em>, ser. LNCS, T. Johansson and P. Q. Nguyen, Eds., vol. 7881. Springer, 2013, pp. 626–645.</li>

      <li><span id="page-12-15"></span>[24] J. Groth, "On the size of pairing-based non-interactive arguments," in EUROCRYPT, ser. LNCS, M. Fischlin and J. Coron, Eds., vol. 9666. Springer, 2016, pp. 305–326.</li>

      <li><span id="page-12-7"></span>[25] A. Kattis and J. Bonneau, "Proof of necessary work: Succinct state verification with fairness guarantees," in FC, ser. LNCS, F. Baldimtsi and C. Cachin, Eds., vol. 13951. Springer, 2023, pp. 18–35.</li>

      <li><span id="page-12-17"></span>[26] A. Kothapalli and S. Setty, "Supernova: Proving universal machine executions without universal circuits," Cryptology ePrint Archive, Paper 2022/1758, 2022.</li>

      <li><span id="page-12-16"></span>[27] —, "CycleFold: Folding-scheme-based recursive arguments over a cycle of elliptic curves," Cryptology ePrint Archive, Paper 2023/1192, 2023.</li>

      <li><span id="page-12-12"></span>[28] —, "Hypernova: Recursive arguments for customizable constraint systems," Cryptology ePrint Archive, Paper 2023/573, 2023.</li>

      <li><span id="page-12-11"></span>[29] A. Kothapalli, S. T. V. Setty, and I. Tzialla, "Nova: Recursive zero-knowledge arguments from folding schemes," in <em>CRYPTO</em>, ser. LNCS, Y. Dodis and T. Shrimpton, Eds., vol. 13510. Springer, 2022, pp. 359–388.</li>

      <li><span id="page-12-25"></span>[30] C. Lund, L. Fortnow, H. J. Karloff, and N. Nisan, "Algebraic methods for interactive proof systems," in <em>FOCS</em>. IEEE Computer Society, 1990, pp. 2–10.</li>

      <li><span id="page-12-4"></span>[31] A. Naveh and E. Tromer, "Photoproof: Cryptographic image authentication for any set of permissible transformations," in <em>S&P</em>. IEEE Computer Society, 2016, pp. 255–271.</li>

      <li><span id="page-12-31"></span>[32] W. Nguyen, D. Boneh, and S. Setty, "Revisiting the nova proof system on a cycle of curves," Cryptology ePrint Archive, Paper 2023/969, 2023.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-12-22"></span>[33] W. Nguyen, T. Datta, B. Chen, N. Tyagi, and D. Boneh, "Mangrove: A scalable framework for folding-based SNARKs," Cryptology ePrint Archive, Paper 2024/416, 2024.</li>

      <li><span id="page-12-32"></span>[34] Nova Contributors, "Nova implementation." [Online]. Available: https://github.com/microsoft/Nova</li>

      <li><span id="page-12-33"></span>[35] Pasta Contributors, "Pasta curves." [Online]. Available: https://github.com/zcash/pasta\\_curves</li>

      <li><span id="page-12-24"></span>[36] J. T. Schwartz, "Fast probabilistic algorithms for verification of polynomial identities," <em>Journal of the ACM</em>, vol. 27, no. 4, pp. 701–717, 1980.</li>

      <li><span id="page-12-13"></span>[37] S. Setty, J. Thaler, and R. Wahby, "Customizable constraint systems for succinct arguments," Cryptology ePrint Archive, Paper 2023/552, 2023.</li>

      <li><span id="page-12-30"></span>[38] N. P. Smart, "The discrete logarithm problem on elliptic curves of trace one," <em>Journal of Cryptology</em>, vol. 12, no. 3, pp. 193–196, 1999.</li>

      <li><span id="page-12-29"></span>[39] J. Thaler, "Proofs, arguments, and zero-knowledge," Foundations and Trends in Privacy and Security, vol. 4, no. 2-4, pp. 117–660, 2022.</li>

      <li><span id="page-12-5"></span>[40] N. Tyagi, B. Fisch, A. Zitek, J. Bonneau, and S. Tessaro, "Versa: Verifiable registries with efficient client audits from RSA authenticated dictionaries," in CCS, H. Yin, A. Stavrou, C. Cremers, and E. Shi, Eds. ACM, 2022, pp. 2793–2807.</li>

      <li><span id="page-12-1"></span>[41] P. Valiant, "Incrementally verifiable computation or proofs of knowledge imply time/space efficiency," in <em>TCC</em>, ser. LNCS, R. Canetti, Ed., vol. 4948. Springer, 2008, pp. 1–18.</li>

      <li><span id="page-12-28"></span>[42] V. Vu, S. T. V. Setty, A. J. Blumberg, and M. Walfish, "A hybrid architecture for interactive verifiable computation," in S&P. IEEE Computer Society, 2013, pp. 223–237.</li>

    </ul>

    <p class="text-gray-300"><strong>Theorem 1.</strong> Construction 1 is a public-coin multi-folding scheme for  <span class="math">(\\mathcal{R}_{LCCCS}, \\mathcal{R}_{CCCS}, \\mathsf{compat}, \\mu, \\nu)</span>  with perfect completeness and knowledge soundness.</p>

    <p class="text-gray-300">Proof: We now describe the proof of Theorem 1. <strong>Perfect completeness.</strong> For public parameters fpp =  <span class="math">(m, n, N, \\ell, t, q, d, \\mathsf{pp}_{\\mathsf{pcs}})</span>  and  <span class="math">s = \\log m, s&#x27; = \\log n, c</span>  consider arbitrary adversarially chosen structure  <span class="math">\\mathsf{s}_1 = \\mathsf{s}_2 = \\big((\\widetilde{M}_1, \\ldots, \\widetilde{M}_t), (S_1, \\ldots, S_q), (c_1, \\ldots, c_q)\\big), \\ \\mu</span>  satisfied  <span class="math">\\mathcal{R}_{\\mathsf{LCCCS}}</span>  instance-witness pairs  <span class="math">\\{\\phi_k\\}_{k \\in [\\mu]}</span>  and  <span class="math">\\nu</span>  satisfied  <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span>  instance-witness pairs  <span class="math">\\{\\psi_{k&#x27;}\\}_{k&#x27; \\in [\\nu]}</span> . We show  <span class="math">\\mathcal V</span>  will not abort and the folded  <span class="math">\\mathcal R_{\\mathsf{LCCCS}}</span>  instance  <span class="math">(C&#x27;, u&#x27;, \\mathbf{x}&#x27;, \\mathbf{r}&#x27;_x, v&#x27;_1, \\ldots, v&#x27;_t)</span>  is satisfied by the folded  <span class="math">\\mathcal R_{\\mathsf{LCCCS}}</span>  witness  <span class="math">\\widetilde{w&#x27;}</span> .</p>

    <p class="text-gray-300">Firstly, since  <span class="math">\\{\\phi_k\\}_{k\\in[\\mu]}</span>  are satisfied  <span class="math">\\mathcal{R}_{\\text{LCCCS}}</span>  instance-witness pairs, we have for  <span class="math">k\\in[\\mu], i\\in[t]</span>  and  <span class="math">\\phi_k.\\widetilde{z_1}=(\\phi_k.\\boldsymbol{w_1},\\phi_k.\\boldsymbol{u},\\phi_k.\\boldsymbol{x_1})</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\phi_k.v_i = \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\phi_k.\\boldsymbol{r}_x, \\boldsymbol{y}) \\cdot \\phi_k.\\widetilde{z}_1(\\boldsymbol{y})</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} \\widetilde{eq}(\\phi_k.\\boldsymbol{r}_x, \\boldsymbol{x}) \\cdot \\left(\\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{x}, \\boldsymbol{y}) \\cdot \\phi_k.\\widetilde{z}_1(\\boldsymbol{y})\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} L_{k,i}(\\boldsymbol{x}).</span></div>

    <p class="text-gray-300">Furthermore, since  <span class="math">\\{\\psi_{k&#x27;}\\}_{k&#x27;\\in[\\nu]}</span>  are satisfied  <span class="math">\\mathcal{R}_{\\text{CCCS}}</span>  instance-witness pairs, we have for  <span class="math">k&#x27;\\in[\\nu]</span> ,  <span class="math">\\psi_{k&#x27;}.\\tilde{z_2}=(\\psi_{k&#x27;}.\\boldsymbol{w_2},1,\\psi_{k&#x27;}.\\mathbf{x_2})</span>  and  <span class="math">\\boldsymbol{x}\\in\\{0,1\\}^s</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{q} c_i \\cdot \\prod_{j \\in S_i} \\left( \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(\\boldsymbol{x}, \\boldsymbol{y}) \\cdot \\psi_{k&#x27;}.\\widetilde{z}_2(\\boldsymbol{y}) \\right) = 0.</span></div>

    <p class="text-gray-300">Denoting the left-hand side of the above equation as a polynomial  <span class="math">q_{k&#x27;}(\\boldsymbol{X})</span> , we have for  <span class="math">\\boldsymbol{x} \\in \\{0,1\\}^s</span> ,  <span class="math">q_{k&#x27;}(\\boldsymbol{x}) = 0</span> . Then the polynomial  <span class="math">G_{k&#x27;}(\\boldsymbol{X}) := \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} \\widetilde{eq}(\\boldsymbol{X}, \\boldsymbol{x}) \\cdot q_{k&#x27;}(\\boldsymbol{x})</span>  is multilinear and vanishes on all  <span class="math">\\boldsymbol{x} \\in \\{0,1\\}^s</span> . Hence, we have  <span class="math">G_{k&#x27;}(\\boldsymbol{X})</span>  is a zero polynomial. For  <span class="math">\\boldsymbol{\\beta} \\xleftarrow{\\</span>} \\mathbb{F}^s<span class="math"> ,  </span>G_{k'}(\\boldsymbol{\\beta}) = 0<span class="math"> . By construction, we have for  </span>k' \\in [\\nu]<span class="math"> ,  </span>\\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} Q_{k'}(\\boldsymbol{x}) = G_{k'}(\\boldsymbol{\\beta}) = 0$ .</p>

    <p class="text-gray-300">Therefore, for  <span class="math">\\gamma \\stackrel{\\</span>}{\\leftarrow} \\mathbb{F}$ , we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} &amp;\\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\phi_{k}.v_{i} = \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\Big( \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s}} L_{k,i}(\\boldsymbol{x}) \\Big) \\\\ &amp;+ \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t+k&#x27;} \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s}} Q_{k&#x27;}(\\boldsymbol{x}) \\\\ &amp;= \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s}} \\Big( \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} L_{k,i}(\\boldsymbol{x}) + \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t+k&#x27;} Q_{k&#x27;}(\\boldsymbol{x}) \\Big) \\\\ &amp;= \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s}} g(\\boldsymbol{x}). \\end{split}</span></div>

    <p class="text-gray-300">Thus, by the completeness of the sum-check protocol,  <span class="math">\\mathcal V</span>  will not output "reject" inside it. Moreover, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} c &amp;= g(\\mathbf{r}_x&#x27;) = \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} L_{k,i}(\\mathbf{r}_x&#x27;) + \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t + k&#x27;} Q_{k&#x27;}(\\mathbf{r}_x&#x27;) \\\\ &amp;= \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} e_{k,1} \\sigma_{k,i} + \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t + k&#x27;} e_2 \\Big( \\sum_{i=1}^{q} c_i \\prod_{j \\in S_i} \\theta_{k&#x27;,j} \\Big). \\end{split}</span></div>

    <p class="text-gray-300">We finally have that V will not abort.</p>

    <p class="text-gray-300">Secondly, by construction, we have for  <span class="math">k \\in [\\mu], k&#x27; \\in [\\nu]</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">(\\phi_k.C_1, \\phi_k.u, \\phi_k.\\mathbf{x}_1, \\mathbf{r}&#x27;_x, \\sigma_{k,1}, \\dots, \\sigma_{k,t}; \\phi_k.\\widetilde{w_1}), (\\psi_{k&#x27;}.C_2, 1, \\psi_{k&#x27;}.\\mathbf{x}_2, \\mathbf{r}&#x27;_x, \\theta_{k&#x27;,1}, \\dots, \\theta_{k&#x27;,t}; \\psi_{k&#x27;}.\\widetilde{w_2})</span></div>

    <p class="text-gray-300">are all satisfied  <span class="math">\\mathcal{R}_{\\text{LCCCS}}</span>  instance-witness pairs. Therefore, for  <span class="math">\\widetilde{z&#x27;} = (\\overrightarrow{w&#x27;}, \\overrightarrow{u&#x27;}, \\mathbf{x&#x27;})</span>  and  <span class="math">i \\in [t]</span> , we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} v_i&#x27; &amp;= \\sum_{k=1}^{\\mu} \\rho^{k-1} \\cdot \\sigma_{k,i} + \\sum_{k&#x27;=1}^{\\nu} \\rho^{\\mu-1+k&#x27;} \\cdot \\theta_{k&#x27;,i} \\\\ &amp;= \\sum_{k=1}^{\\mu} \\rho^{k-1} \\cdot \\left( \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}) \\cdot \\phi_k.\\widetilde{z}_1(\\boldsymbol{y}) \\right) \\\\ &amp;+ \\sum_{k&#x27;=1}^{\\nu} \\rho^{\\mu-1+k&#x27;} \\cdot \\left( \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}) \\cdot \\psi_{k&#x27;}.\\widetilde{z}_2(\\boldsymbol{y}) \\right) \\\\ &amp;= \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}) \\cdot \\left( \\sum_{k=1}^{\\mu} \\rho^{k-1} \\cdot \\phi_k.\\widetilde{z}_1(\\boldsymbol{y}) \\right) \\\\ &amp;+ \\sum_{k&#x27;=1}^{\\nu} \\rho^{\\mu-1+k&#x27;} \\cdot \\psi_{k&#x27;}.\\widetilde{z}_2(\\boldsymbol{y}) \\right) \\\\ &amp;= \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}) \\cdot \\widetilde{z}&#x27;(\\boldsymbol{y}). \\end{split}</span></div>

    <p class="text-gray-300">By the additive homomorphism property of the polynomial commitment scheme, we have that  <span class="math">C&#x27; = \\mathsf{Com}(\\mathsf{pp}_{\\mathsf{pcs}}, \\widetilde{w&#x27;})</span> .</p>

    <p class="text-gray-300">Therefore,  <span class="math">(C&#x27;, u&#x27;, \\mathbf{x}&#x27;, r&#x27;_x, v&#x27;_1, \\dots, v&#x27;_t)</span>  is a satisfied  <span class="math">\\mathcal{R}_{LCCCS}</span>  instance and  <span class="math">\\widetilde{w&#x27;}</span>  is the corresponding witness.</p>

    <p class="text-gray-300">We conclude that Construction 1 has perfect completeness.</p>

    <p class="text-gray-300">Knowledge soundness. Consider a malicious prover  <span class="math">\\mathcal{P}^*</span>  that succeeds with probability  <span class="math">\\epsilon</span> . For public parameters fpp =  <span class="math">(m, n, N, \\ell, t, q, d, \\mathsf{pp}_{\\mathsf{pcs}})</span>  and  <span class="math">s = \\log m, s&#x27; = \\log n</span> . Consider an adversary  <span class="math">\\mathcal{A}</span>  that adaptively picks structures  <span class="math">\\mathsf{s}_1 = \\mathsf{s}_2 = ((\\widetilde{M}_1, \\ldots, \\widetilde{M}_t), (S_1, \\ldots, S_q), (c_1, \\ldots, c_q))</span>  that satisfy compat,  <span class="math">\\mu</span>   <span class="math">\\mathcal{R}_{\\mathsf{LCCCS}}</span>  instances  <span class="math">\\{\\phi_k.\\mathsf{u}_1 := \\phi_k.(C_1, u, \\mathbf{x}_1, r_x, v_1, \\ldots, v_t)\\}_{k \\in [\\mu]}, \\ \\nu</span>   <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span>  instances  <span class="math">\\{\\psi_{k&#x27;}.\\mathsf{u}_2 := \\psi_{k&#x27;}.(C_2, \\mathbf{x}_2)\\}_{k&#x27; \\in [\\nu]}</span>  and some auxiliary state st. We construct an expected polynomial time extractor  <span class="math">\\mathcal{E}</span>  that succeeds with probability  <span class="math">\\epsilon - \\mathsf{negl}(\\lambda)</span>  in obtaining satisfied witnesses for the original instances as follows.</p>

    <p class="text-gray-300"><span class="math-block">\\left(\\{\\phi_k.\\widetilde{w_1}\\}_{k\\in[\\mu]},\\{\\psi_{k&#x27;}.\\widetilde{w_2}\\}_{k&#x27;\\in[\\nu]}\\right)\\leftarrow \\mathcal{E}\\left(\\mathsf{fpp},\\rho\\right)</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Invoke  <span class="math">\\mathcal{A}</span>  to obtain the output tuple:  <span class="math">((s_1, s_2), \\{\\phi_k. u_1\\}_{k \\in [\\mu]}, \\{\\psi_{k&#x27;}. u_2\\}_{k&#x27; \\in [\\nu]}, st) \\leftarrow \\mathcal{A}(\\mathsf{fpp}, \\rho)</span> .</li>

      <li>2. Compute  <span class="math">(fpk, fvk) \\leftarrow \\mathcal{K}(fpp, (s_1, s_2))</span> .</li>

      <li>3. Run the interaction  <span class="math">(\\mathsf{u}^{(1)},\\widetilde{w}^{(1)}) \\leftarrow \\langle \\mathcal{P}^*(\\mathsf{fpk},\\mathsf{st}),\\mathcal{V}(\\mathsf{fvk})\\rangle (\\{\\phi_k.\\mathsf{u}_1\\}_{k\\in[\\mu]},\\{\\psi_{k&#x27;}.\\mathsf{u}_2\\}_{k&#x27;\\in[\\nu]})</span>  once with the final verifier challenge  <span class="math">\\rho^{(1)} \\stackrel{\\</span>}{\\leftarrow} \\mathbb{F}$ .</li>

      <li>4. Abort if  <span class="math">\\left(\\mathsf{fpp},\\mathsf{s}_1,\\mathsf{u}^{(1)},\\widetilde{w}^{(1)}\\right) \\notin \\mathcal{R}_{\\mathrm{LCCCS}}.</span></li>

      <li>5. Rerun the interaction  <span class="math">(u^{(1)},\\widetilde{w}^{(1)}) \\leftarrow \\langle \\mathcal{P}^*(\\mathsf{fpk},\\mathsf{st}),\\mathcal{V}(\\mathsf{fvk}) \\rangle (\\{\\phi_k.\\mathsf{u}_1\\}_{k\\in[\\mu]},\\{\\psi_{k&#x27;}.\\mathsf{u}_2\\}_{k&#x27;\\in[\\nu]})</span>  with different verifier's final challenges while maintaining the same prior randomness. Keep doing so until it obtains  <span class="math">\\mu + \\nu 1</span>  folded  <span class="math">\\mathcal{R}_{\\mathrm{LCCCS}}</span>  instance-witness pairs  <span class="math">\\{(\\mathsf{u}^{(k&#x27;&#x27;)},\\widetilde{w}^{(k&#x27;&#x27;)})\\}_{k&#x27;&#x27;\\in[2,\\ldots,\\mu+\\nu]}</span>  such that  <span class="math">(\\mathsf{fpp},\\mathsf{s}_1,\\mathsf{u}^{(k&#x27;&#x27;)},\\widetilde{w}^{(k&#x27;&#x27;)}) \\in \\mathcal{R}_{\\mathrm{LCCS}}</span>  for all  <span class="math">k&#x27;&#x27; \\in [2,\\ldots,\\mu+\\nu]</span> . Let  <span class="math">\\{\\rho^{(k&#x27;&#x27;)}\\}</span>  denote the corresponding verifier's final challenges.</li>

      <li>6. Abort if there exists a collision in the verifier's final challenges.</li>

      <li>7. Interpolate points  <span class="math">\\{(\\rho^{(k&#x27;&#x27;)}, \\widetilde{w}^{(k&#x27;&#x27;)})\\}_{k&#x27;&#x27; \\in [\\mu+\\nu]}</span>  to retrieve witnesses  <span class="math">(\\{\\phi_k.\\widetilde{w_1}\\}_{k \\in [\\mu]}, \\{\\psi_{k&#x27;}.\\widetilde{w_2}\\}_{k&#x27; \\in [\\nu]})</span>  such that for  <span class="math">k&#x27;&#x27; \\in [\\mu+\\nu]</span> ,</li>

    </ul>

    <p class="text-gray-300"><span id="page-13-0"></span> <span class="math-block">\\sum_{k=1}^{\\mu} \\rho^{(k&#x27;&#x27;)k-1} \\cdot \\phi_k.\\widetilde{w_1} + \\sum_{k&#x27;=1}^{\\nu} \\rho^{(k&#x27;&#x27;)\\mu-1+k&#x27;} \\cdot \\psi_{k&#x27;}.\\widetilde{w_2} = \\widetilde{w}^{(k&#x27;&#x27;)}.</span> (3)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">(\\{\\phi_k.\\widetilde{w_1}\\}_{k\\in[\\mu]}, \\{\\psi_{k&#x27;}.\\widetilde{w_2}\\}_{k&#x27;\\in[\\nu]})</span> .</li>

    </ol>

    <p class="text-gray-300">We now demonstrate that the extractor  <span class="math">\\mathcal{E}</span>  runs in expected polynomial time and succeeds with probability  <span class="math">\\epsilon - \\text{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Firstly, the extractor  <span class="math">\\mathcal E</span>  runs the interaction  <span class="math">\\langle \\mathcal P^*, \\mathcal V \\rangle</span>  once, and if it does not abort, keeps rerunning the interaction until it obtains  <span class="math">\\mu + \\nu - 1</span>  satisfied folded  <span class="math">\\mathcal R_{\\rm LCCCS}</span>  instancewitness pairs. Thus, the expected number of times  <span class="math">\\mathcal E</span>  runs the</p>

    <p class="text-gray-300">interaction is</p>

    <p class="text-gray-300"> <span class="math">\\Pr[\\text{First call to } \\langle \\mathcal{P}^*, \\mathcal{V} \\rangle \\text{ fails}] \\cdot 1 +</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr[\\text{First call to } \\langle \\mathcal{P}^*, \\mathcal{V} \\rangle \\text{ succeeds}] \\cdot \\left(1 + \\frac{\\mu + \\nu - 1}{\\Pr[\\langle \\mathcal{P}^*, \\mathcal{V} \\rangle \\text{ succeeds}]}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">= (1 - \\epsilon) \\cdot 1 + \\epsilon \\cdot \\left(1 + \\frac{\\mu + \\nu - 1}{\\epsilon}\\right) = \\mu + \\nu.</span></div>

    <p class="text-gray-300">Assuming that  <span class="math">\\mu</span> ,  <span class="math">\\nu</span>  are polynomial in the security parameter, we have that  <span class="math">\\mathcal{E}</span>  runs in expected polynomial time.</p>

    <p class="text-gray-300">Secondly, let  <span class="math">E_1</span>  denote the event that  <span class="math">\\mathcal{E}</span>  successfully produces some outputs in less than T times of running the interaction  <span class="math">\\langle \\mathcal{P}^*, \\mathcal{V} \\rangle</span> . Given  <span class="math">E_1</span> , let  <span class="math">E_2</span>  denote the event that the outputs of  <span class="math">\\mathcal{E}</span>  are satisfied witnesses. We have that  <span class="math">\\Pr[\\mathcal{E} \\text{ succeeds}] = \\Pr[E_1] \\cdot \\Pr[E_2]</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now analyze  <span class="math">\\Pr[E_1]</span>  and  <span class="math">\\Pr[E_2]</span> . By the success probability of  <span class="math">\\mathcal{P}^<em></span> , we have that  <span class="math">\\mathcal{E}</span>  does not abort in step (4) with probability  <span class="math">\\epsilon</span> . Given that  <span class="math">\\mathcal{E}</span>  does not abort in step (4), by Markov's inequality, we have that  <span class="math">\\mathcal{E}</span>  runs the interaction  <span class="math">\\langle \\mathcal{P}^</em>, \\mathcal{V} \\rangle</span>  more than T times with probability  <span class="math">\\frac{\\mu + \\nu}{T}</span> . Given that  <span class="math">\\mathcal{E}</span>  runs the interaction less than T times, which has probability  <span class="math">1 - \\frac{\\mu + \\nu}{T}</span> , we have  <span class="math">\\mathcal{E}</span>  tests at most T values for  <span class="math">\\rho</span> . Thus, the probability that  <span class="math">\\mathcal{E}</span>  does not abort in step (6) is  $1 - \\frac{T^2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ . Thus, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr[E_1] = \\left(1 - \\frac{\\mu + \\nu}{T}\\right) \\cdot \\epsilon \\cdot \\left(1 - \\frac{T^2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right).$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setting  $T=\\sqrt[3]{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  and assuming  </span>T\\geq \\mu+\\nu<span class="math"> , we have that  </span>\\Pr[E_1]=\\epsilon-\\operatorname{negl}(\\lambda)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To analyze  <span class="math">\\Pr[E_2]</span> , we first show that the retrieved witnesses are valid openings to the corresponding polynomial commitments in the instance, and then show that they satisfy the remaining algebraic relations with some probability. For  <span class="math">k&#x27;&#x27; \\in [\\mu + \\nu]</span> , let  <span class="math">\\mathbf{u}^{(k&#x27;&#x27;)} = (C^{(k&#x27;&#x27;)}, u^{(k&#x27;&#x27;)}, \\mathbf{x}^{(k&#x27;&#x27;)}, r_x&#x27;, v_1^{(k&#x27;&#x27;)}, \\ldots, v_t^{(k&#x27;&#x27;)})</span> . Since  <span class="math">\\widetilde{w}^{(k&#x27;&#x27;)}</span>  is a satisfied  <span class="math">\\mathcal{R}_{\\mathrm{LCCCS}}</span>  witness, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} &amp;\\sum_{k=1}^{\\mu} \\rho^{(k^{\\prime\\prime})k-1} \\cdot \\mathsf{Com} \\big( \\mathsf{pp}_{\\mathsf{pcs}}, \\phi_k.\\widetilde{w_1} \\big) \\\\ &amp;+ \\sum_{k^{\\prime}=1}^{\\nu} \\rho^{(k^{\\prime\\prime})\\mu-1+k^{\\prime}} \\cdot \\mathsf{Com} \\big( \\mathsf{pp}_{\\mathsf{pcs}}, \\psi_{k^{\\prime}}.\\widetilde{w_2} \\big) \\\\ &amp;= &amp;\\mathsf{Com} \\Big( \\mathsf{pp}_{\\mathsf{pcs}}, \\sum_{k=1}^{\\mu} \\rho^{(k^{\\prime\\prime})k-1} \\phi_k.\\widetilde{w_1} + \\sum_{k^{\\prime}=1}^{\\nu} \\rho^{(k^{\\prime\\prime})\\mu-1+k^{\\prime}} \\psi_{k^{\\prime}}.\\widetilde{w_2} \\big) \\\\ &amp;= &amp;\\mathsf{Com} \\big( \\mathsf{pp}_{\\mathsf{pcs}}, \\widetilde{w}^{(k^{\\prime\\prime})} \\big) \\\\ &amp;= &amp;C^{(k^{\\prime\\prime})} \\\\ &amp;= &amp;\\sum_{k=1}^{\\mu} \\rho^{(k^{\\prime\\prime})k-1} \\cdot \\phi_k.C_1 + \\sum_{k=1}^{\\nu} \\rho^{(k^{\\prime\\prime})\\mu-1+k^{\\prime}} \\cdot \\psi_{k^{\\prime}}.C_2 \\end{split}</span></div>

    <p class="text-gray-300">Treat the above equation as a univariate polynomial equation in  <span class="math">\\rho^{(k&#x27;&#x27;)}</span> . Since it holds for all  <span class="math">k&#x27;&#x27; \\in [\\mu + \\nu]</span> , we must have that for  <span class="math">k \\in [\\mu], k&#x27; \\in [\\nu]</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\phi_k.C_1 = \\mathsf{Com}\\big(\\mathsf{pp}_{\\mathsf{pcs}}, \\phi_k.\\widetilde{w_1}\\big), \\quad \\psi_{k&#x27;}.C_2 = \\mathsf{Com}\\big(\\mathsf{pp}_{\\mathsf{pcs}}, \\psi_{k&#x27;}.\\widetilde{w_2}\\big),</span></div>

    <p class="text-gray-300">which means that  <span class="math">\\left(\\{\\phi_k.\\widetilde{w_1}\\}_{k\\in[\\mu]},\\{\\psi_{k&#x27;}.\\widetilde{w_2}\\}_{k&#x27;\\in[\\nu]}\\right)</span>  are valid openings.</p>

    <p class="text-gray-300">Next, by the extractor's construction we have that  <span class="math">\\{\\sigma_{k,i},\\theta_{k&#x27;,i}\\}_{k\\in[\\mu],k&#x27;\\in[\\nu],i\\in[t]}</span>  sent by the prover are identical across all executions of the interaction  <span class="math">\\langle \\mathcal{P}^*,\\mathcal{V}\\rangle</span> . By the verifier's computation, we have that for  <span class="math">k&#x27;&#x27;\\in[\\mu+\\nu],i\\in[t]</span> ,</p>

    <p class="text-gray-300"><span id="page-14-0"></span> <span class="math-block">v_i^{(k&#x27;&#x27;)} = \\sum_{k=1}^{\\mu} \\rho^{(k&#x27;&#x27;)k-1} \\cdot \\sigma_{k,i} + \\sum_{k&#x27;=1}^{\\nu} \\rho^{(k&#x27;&#x27;)\\mu-1+k&#x27;} \\cdot \\theta_{k&#x27;,i}. \\quad (4)</span></p>

    <p class="text-gray-300">Since  <span class="math">\\left\\{\\widetilde{w}^{(k&#x27;&#x27;)}\\right\\}_{k&#x27;&#x27;\\in[\\mu+\\nu]}</span>  are satisfied  <span class="math">\\mathcal{R}_{\\mathrm{LCCCS}}</span>  witnesses, we have that for  <span class="math">k&#x27;&#x27;\\in[\\mu+\\nu], i\\in[t]</span> ,</p>

    <p class="text-gray-300"><span id="page-14-1"></span> <span class="math-block">v_i^{(k^{\\prime\\prime})} = \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s^\\prime}} \\widetilde{M}_i(\\boldsymbol{r}_x^\\prime, \\boldsymbol{y}) \\cdot \\widetilde{z}^{(k^{\\prime\\prime})}(\\boldsymbol{y}), \\tag{5}</span></p>

    <p class="text-gray-300">where  <span class="math">\\widetilde{z}^{(k&#x27;&#x27;)} = (w^{(k&#x27;&#x27;)}, \\widetilde{u^{(k&#x27;&#x27;)}}, \\mathbf{x}^{(k&#x27;&#x27;)})</span> . By Equations (3), (4), (5) and the verifier's computation, we have that for  <span class="math">k&#x27;&#x27; \\in [\\mu + \\nu], i \\in [t]</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} &amp;\\sum_{k=1}^{\\mu} \\rho^{(k&#x27;&#x27;)k-1} \\cdot \\sigma_{k,i} + \\sum_{k&#x27;=1}^{\\nu} \\rho^{(k&#x27;&#x27;)\\mu-1+k&#x27;} \\cdot \\theta_{k&#x27;,i} \\\\ &amp;= \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;,\\boldsymbol{y}) \\cdot \\widetilde{\\boldsymbol{z}}^{(k&#x27;&#x27;)}(\\boldsymbol{y}) \\\\ &amp;= \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;,\\boldsymbol{y}) \\cdot \\left(\\sum_{k=1}^{\\mu} \\rho^{(k&#x27;&#x27;)k-1} \\cdot \\phi_k.\\widetilde{\\boldsymbol{z}}_1(\\boldsymbol{y}) \\right. \\\\ &amp;+ \\sum_{k&#x27;=1}^{\\nu} \\rho^{(k&#x27;&#x27;)\\mu-1+k&#x27;} \\cdot \\psi_{k&#x27;}.\\widetilde{\\boldsymbol{z}}_2(\\boldsymbol{y}) \\right) \\\\ &amp;= \\sum_{k=1}^{\\mu} \\rho^{(k&#x27;&#x27;)k-1} \\cdot \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;,\\boldsymbol{y}) \\cdot \\phi_k.\\widetilde{\\boldsymbol{z}}_1(\\boldsymbol{y}) \\\\ &amp;+ \\sum_{k&#x27;=1}^{\\nu} \\rho^{(k&#x27;&#x27;)\\mu-1+k&#x27;} \\cdot \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;,\\boldsymbol{y}) \\cdot \\psi_{k&#x27;}.\\widetilde{\\boldsymbol{z}}_2(\\boldsymbol{y}), \\end{split}</span></div>

    <p class="text-gray-300">where  <span class="math">\\phi_k.\\widetilde{z_1} = (\\phi_k.w_1, \\phi_k.u, \\phi_k.x_1)</span>  and  <span class="math">\\psi_{k&#x27;}.\\widetilde{z_2} = (\\psi_{k&#x27;}.w_2, 1, \\psi_{k&#x27;}.x_2)</span> . Treat the above equation as a univariate polynomial equation in  <span class="math">\\rho^{(k&#x27;&#x27;)}</span> . Since it holds for all  <span class="math">k&#x27;&#x27; \\in [\\mu + \\nu]</span> , we must have that for  <span class="math">k \\in [\\mu], k&#x27; \\in [\\nu], i \\in [t]</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\sigma_{k,i} &amp;= \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}) \\cdot \\phi_k. \\widetilde{z}_1(\\boldsymbol{y}), \\ \\theta_{k&#x27;,i} &amp;= \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}) \\cdot \\psi_{k&#x27;}. \\widetilde{z}_2(\\boldsymbol{y}). \\end{aligned}</span></div>

    <p class="text-gray-300">Then since the verifier does not abort, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} c &amp;= \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\cdot e_{k,1} \\cdot \\sigma_{k,i} \\\\ &amp;+ \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t+k&#x27;} \\cdot e_{2} \\cdot \\left( \\sum_{i=1}^{q} c_{i} \\cdot \\prod_{j \\in S_{i}} \\theta_{k&#x27;,j} \\right) \\\\ &amp;= \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\cdot \\tilde{eq}(\\phi_{k}.\\boldsymbol{r}_{x}, \\boldsymbol{r}_{x}&#x27;) \\cdot \\sigma_{k,i} \\\\ &amp;+ \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t+k&#x27;} \\cdot \\tilde{eq}(\\boldsymbol{\\beta}, \\boldsymbol{r}_{x}&#x27;) \\cdot \\left( \\sum_{i=1}^{q} c_{i} \\cdot \\prod_{j \\in S_{i}} \\theta_{k&#x27;,j} \\right) \\\\ &amp;= \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\cdot L_{k,i}(\\boldsymbol{r}_{x}&#x27;) + \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t+k&#x27;} \\cdot Q_{k&#x27;}(\\boldsymbol{r}_{x}&#x27;) \\\\ &amp;= g(\\boldsymbol{r}_{x}&#x27;), \\end{split}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which by the soundness of the sum-check protocol, implies that with probability  $1 - O(s \\cdot d)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1 - \\mathsf{negl}(\\lambda)<span class="math">  over the choice of  </span>r_x'$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} &amp;\\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\phi_{k}.v_{i} = \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s}} g(\\boldsymbol{x}) \\\\ &amp;= \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s}} \\left( \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} L_{k,i}(\\boldsymbol{x}) + \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t + k&#x27;} Q_{k&#x27;}(\\boldsymbol{x}) \\right) \\\\ &amp;= \\sum_{k=1}^{\\mu} \\sum_{i=1}^{t} \\gamma^{(k-1)t+i} \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s}} L_{k,i}(\\boldsymbol{x}) \\\\ &amp;+ \\sum_{k&#x27;=1}^{\\nu} \\gamma^{\\mu t + k&#x27;} \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s}} Q_{k&#x27;}(\\boldsymbol{x}). \\end{split}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the Schwartz-Zippel lemma [36], this implies that with probability  $1 - O(\\mu \\cdot t + \\nu) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1 - \\text{negl}(\\lambda)<span class="math">  over the choice of  </span>\\gamma<span class="math"> , we have for  </span>k \\in [\\mu], i \\in [t]$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-15-1"></span> <span class="math-block">\\phi_k.v_i = \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} L_{k,i}(\\boldsymbol{x}),\\tag{6}</span></p>

    <p class="text-gray-300">and for  <span class="math">k&#x27; \\in [\\nu]</span> ,</p>

    <p class="text-gray-300"><span id="page-15-2"></span> <span class="math-block">0 = \\sum_{x \\in \\{0,1\\}^s} Q_{k&#x27;}(x). \\tag{7}</span></p>

    <p class="text-gray-300">Expanding Equation (6), we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\phi_k.v_i &amp;= \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} L_{k,i}(\\boldsymbol{x}) \\\\ &amp;= \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} \\widetilde{eq}(\\phi_k.\\boldsymbol{r}_x,\\boldsymbol{x}) \\cdot \\Big(\\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\boldsymbol{x},\\boldsymbol{y}) \\cdot \\phi_k.\\widetilde{z_1}(\\boldsymbol{y})\\Big) \\\\ &amp;= \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_i(\\phi_k.\\boldsymbol{r}_x,\\boldsymbol{y}) \\cdot \\phi_k.\\widetilde{z_1}(\\boldsymbol{y}). \\end{split}</span></div>

    <p class="text-gray-300">Since we have argued that  <span class="math">\\{\\phi_k.\\widetilde{w_1}\\}_{k\\in[\\mu]}</span>  are valid openings, we have that they are satisfied  <span class="math">\\mathcal{R}_{LCCCS}</span>  witnesses with probability  <span class="math">1-\\mathsf{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Expanding Equation (7), we have that</p>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} Q_{k&#x27;}(\\boldsymbol{x}) = \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^s} \\widetilde{eq}(\\boldsymbol{\\beta}, \\boldsymbol{x})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\cdot \\left( \\sum_{i=1}^q c_i \\cdot \\prod_{j \\in S_i} \\left( \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(\\boldsymbol{x}, \\boldsymbol{y}) \\cdot \\psi_{k&#x27;}.\\widetilde{z}_2(\\boldsymbol{y}) \\right) \\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\sum_{i=1}^q c_i \\cdot \\prod_{j \\in S_i} \\left( \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(\\boldsymbol{\\beta}, \\boldsymbol{y}) \\cdot \\psi_{k&#x27;}.\\widetilde{z}_2\\boldsymbol{y} \\right).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the Schwartz-Zippel lemma, this implies that with probability  $1 - O(s \\cdot d)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1 - \\mathsf{negl}(\\lambda)<span class="math">  over the choice of  </span>\\beta<span class="math"> , we have that for all  </span>x \\in \\{0,1\\}^s$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{q} c_i \\cdot \\prod_{j \\in S_i} \\left( \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(\\boldsymbol{x}, \\boldsymbol{y}) \\cdot \\psi_{k&#x27;}. \\widetilde{z}_2(\\boldsymbol{y}) \\right) = 0.</span></div>

    <p class="text-gray-300">Since we have argued that  <span class="math">\\{\\psi_{k&#x27;}.\\widetilde{w_2}\\}_{k&#x27;\\in[\\nu]}</span>  are valid openings, we have that they are satisfied  <span class="math">\\mathcal{R}_{\\text{CCCS}}</span>  witnesses with probability  <span class="math">1 - \\text{negl}(\\lambda)</span> . Hence, we have that  <span class="math">\\Pr[E_2] = 1 - \\text{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Therefore, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr[\\mathcal{E} \\text{ succeeds}] = \\Pr[E_1] \\cdot \\Pr[E_2]$$ $$= (\\epsilon - \\mathsf{negl}(\\lambda)) \\cdot (1 - \\mathsf{negl}(\\lambda)) = \\epsilon - \\mathsf{negl}(\\lambda).</span></div>

    <p class="text-gray-300">We conclude that Construction 1 has knowledge soundness. ■</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> Construction 2 is a PCD scheme with perfect completeness and knowledge soundness.</p>

    <p class="text-gray-300"><em>Proof:</em> We now describe the proof of Theorem 2.</p>

    <p class="text-gray-300"><strong>Perfect completeness.</strong> For public parameter pp, consider arbitrary adversarially chosen  <span class="math">(\\varphi, z, z_{\\text{loc}}, \\{z_i, \\Pi_i\\}_{i=1}^r)</span>  such that the perfect completeness precondition is satisfied. We show that given  <span class="math">\\Pi \\leftarrow \\mathsf{P}(\\mathsf{pk}, z, z_{\\text{loc}}, \\{z_i, \\Pi_i\\}_{i=1}^r), \\, \\mathsf{V}(\\mathsf{vk}, z, \\Pi) = 1</span>  with probability 1.</p>

    <p class="text-gray-300">If  <span class="math">z_i=\\perp</span>  for all  <span class="math">i\\in[r]</span> , by the construction of P, we have that  <span class="math">(\\mathsf{U},\\mathsf{W})=(\\mathsf{u}_\\perp,\\mathsf{w}_\\perp)</span>  is a trivially satisfied  <span class="math">\\mathcal{R}_{\\mathrm{LCCCS}}</span>  instance-witness pair, and  <span class="math">h=\\mathsf{hash}(\\mathsf{fvk},z,\\mathsf{U}).</span>  By the perfect completeness precondition, we have that  <span class="math">\\varphi(z,z_{\\mathrm{loc}},z_1,\\ldots,z_r)=1.</span>  Therefore, P could construct a satisfied  <span class="math">\\mathcal{R}_{\\mathrm{CCCS}}</span>  instance-witness pair  <span class="math">(\\mathsf{u},\\mathsf{w})</span>  that represents the correct computation of  <span class="math">R_\\varphi</span> . Moreover, by the construction of  <span class="math">R_\\varphi</span> , we have  <span class="math">\\mathsf{u}.\\mathsf{x}=\\mathsf{hash}(\\mathsf{fvk},z,\\mathsf{U}).</span>  Thus,  <span class="math">\\mathsf{V}(\\mathsf{vk},z,\\Pi)=1</span>  with probability 1.</p>

    <p class="text-gray-300">If  <span class="math">\\exists i \\in [r]</span>  such that  <span class="math">z_i \\neq \\bot</span> , by the perfect completeness precondition,  <span class="math">\\{(\\mathsf{U}_i,\\mathsf{W}_i)\\}_{i\\in[r]}</span>  included in  <span class="math">\\{\\Pi_i\\}_{i\\in[r]}</span>  are satisfied  <span class="math">\\mathcal{R}_{\\mathrm{LCCCS}}</span>  instance-witness pairs,  <span class="math">\\{(\\mathsf{u}_i,\\mathsf{w}_i)\\}_{i\\in[r]}</span>  included in  <span class="math">\\{\\Pi_i\\}_{i\\in[r]}</span>  are satisfied  <span class="math">\\mathcal{R}_{\\mathrm{CCCS}}</span>  instance-witness pairs, and  <span class="math">\\mathsf{u}_i.\\mathsf{x} = \\mathsf{hash}(\\mathsf{fvk},z_i,\\mathsf{U}_i).</span>  Then by the perfect completeness of the multi-folding scheme, we have that  <span class="math">(\\mathsf{U},\\mathsf{W})</span>  is a satisfied  <span class="math">\\mathcal{R}_{\\mathrm{LCCS}}</span>  intance-witness pair. Therefore, P could construct a satisfied  <span class="math">\\mathcal{R}_{\\mathrm{CCCS}}</span>  instance-witness pair  <span class="math">(\\mathsf{u},\\mathsf{w})</span>  that represents the correct computation of  <span class="math">R_\\varphi</span> . Additionally, by the construction of  <span class="math">R_\\varphi</span> , we have that  <span class="math">\\mathsf{u}.\\mathsf{x} = \\mathsf{hash}(\\mathsf{fvk},z,\\mathsf{U}).</span>  Therefore,  <span class="math">\\mathsf{V}(\\mathsf{vk},z,\\Pi) = 1</span>  with probability 1.</p>

    <p class="text-gray-300">We conclude that Construction 2 has perfect completeness.</p>

    <p class="text-gray-300"><strong>Knowledge soundness.</strong> We mainly refer to the proof of the PCD scheme of Bünz et al [9]. Fix a set Z, and for pp  <span class="math">\\leftarrow</span>  G  <span class="math">(1^{\\lambda})</span> , ai  <span class="math">\\leftarrow</span>   <span class="math">\\mathcal{D}(pp)</span> , consider an expected polynomial time adversary P\\<em> that succeeds with probability  <span class="math">\\epsilon</span> . We construct an expected polynomial time extractor  <span class="math">\\mathcal{E}_{P^</em>}</span>  that with input (pp, ai), outputs  <span class="math">(\\varphi, T, ao)</span>  such that  <span class="math">\\varphi \\in F</span> ,  <span class="math">(pp, ai, \\varphi, o(T), ao) \\in Z</span>  and T is  <span class="math">\\varphi</span> -compliant with probability  <span class="math">\\epsilon - \\text{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Referring to existing works [10], [9], we assume that every node has a unique outgoing edge. Thus, the extracted transcript T will be a tree. Let every node v be labeled with a local data  <span class="math">z_{\\text{loc}}^{(v)}</span> , the label  <span class="math">z^{(v)}</span>  of its unique outgoing edge and a proof  <span class="math">\\Pi^{(v)}</span>  that proves the correctness of  <span class="math">z^{(v)}</span> . We first present the construction of  <span class="math">\\mathcal{E}_{\\mathsf{P}^*}</span>  that extracts the labels of all the nodes in T, and then explain its correctness.</p>

    <p class="text-gray-300">We construct  <span class="math">\\mathcal{E}_{\\mathsf{P}^<em>}</span>  via an iterative process that constructs a sequence of extractors  <span class="math">\\mathcal{E}_0, \\mathcal{E}_1, \\dots, \\mathcal{E}_d</span> , where d is the depth of T and for  <span class="math">i \\in \\{0,1,\\dots,d\\}</span> ,  <span class="math">\\mathcal{E}_i</span>  outputs a tree  <span class="math">\\mathsf{T}_i</span>  of depth i+1. In particular, the nodes of  <span class="math">\\mathsf{T}_d</span>  at depth d+1 are all empty nodes. We argue later that the extractor  <span class="math">\\mathcal{E}_d</span>  is then equal to  <span class="math">\\mathcal{E}_{\\mathsf{P}^</em>}</span> .</p>

    <p class="text-gray-300">In the base case, we define  <span class="math">\\mathcal{E}_0(\\mathsf{pp},\\mathsf{ai})</span>  to compute  <span class="math">(\\varphi,\\mathsf{o},\\Pi,\\mathsf{ao})\\leftarrow\\mathsf{P}^*(\\mathsf{pp},\\mathsf{ai})</span>  and output  <span class="math">(\\varphi,\\mathsf{T}_0,\\mathsf{ao}),</span>  where  <span class="math">\\mathsf{T}_0</span>  is a single node labeled with  <span class="math">(\\mathsf{o},\\Pi).</span></p>

    <p class="text-gray-300">Next, we construct the extractor  <span class="math">\\mathcal{E}_i</span>  inductively for each  <span class="math">i \\in [d]</span> , given that we have already constructed  <span class="math">\\mathcal{E}_{i-1}</span> . We denote  <span class="math">S_{\\mathsf{T}}(i)</span>  as the set of nodes of T at depth i. We first construct an adversary  <span class="math">\\mathcal{P}_{i-1}^<em></span>  for the non-interactive multi-folding scheme using  <span class="math">\\mathcal{E}_{i-1}</span> , which implies an extractor  <span class="math">\\mathcal{E}_{\\mathcal{P}_{i-1}^</em>}</span>  corresponding to  <span class="math">\\mathcal{P}_{i-1}^<em></span>  by the knowledge soundness of the multi-folding scheme, and then construct  <span class="math">\\mathcal{E}_i</span>  using  <span class="math">\\mathcal{P}_{i-1}^</em></span> ,  <span class="math">\\mathcal{E}_{\\mathcal{P}_{i-1}^*}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Compute  <span class="math">(\\varphi, \\mathsf{T}_{i-1}, \\mathsf{ao}) \\leftarrow \\mathcal{E}_{i-1}(\\mathsf{pp}, \\mathsf{ai})</span> . If  <span class="math">\\mathsf{T}_{i-1}</span>  is not a tree of depth i, abort.</li>

      <li>2. For each node  <span class="math">v \\in S_{\\mathsf{T}_{i-1}}(i)</span> , denote its label as  <span class="math">(z^{(v)},\\Pi^{(v)})</span> .</li>

      <li>3. Parse  <span class="math">\\Pi^{(v)}</span>  as  <span class="math">((\\mathsf{U}^{(v)},\\mathsf{W}^{(v)}),(\\mathsf{u}^{(v)},\\mathsf{w}^{(v)}))</span> .</li>

      <li>4. Obtain  <span class="math">\\left\\{ \\mathsf{U}_{j}^{(v)}, \\mathsf{u}_{j}^{(v)}, z_{j}^{(v)} \\right\\}_{j \\in [r]}, \\pi^{(v)}</span>  from  <span class="math">\\mathsf{w}^{(v)}</span> .</li>

      <li>5. Let  <span class="math">S_{i-1} := \\{ v \\in S_{\\mathsf{T}_{i-1}}(i) \\mid \\exists j \\in [r], z_j^{(v)} \\neq \\perp \\}.</span></li>

      <li><span class="math">\\begin{aligned} &amp;\\text{6. Output } \\left( \\left\\{ \\left\\{ \\mathsf{U}_{j}^{(v)}, \\mathsf{u}_{j}^{(v)} \\right\\}_{j \\in [r]}, \\mathsf{U}^{(v)}, \\mathsf{W}^{(v)}, \\pi^{(v)} \\right\\}_{v \\in S_{i-1}}, \\\\ &amp; (\\varphi, \\mathsf{T}_{i-1}, \\mathsf{ao}) \\right). \\end{aligned}</span></li>

    </ul>

    <p class="text-gray-300">By the knowledge soundness of the multi-folding scheme, there exists an extractor  <span class="math">\\mathcal{E}_{\\mathcal{P}_{i-1}^*}</span>  that for  <span class="math">v \\in S_{i-1}</span> , outputs  <span class="math">\\left\\{\\mathsf{W}_j^{(v)}, \\mathsf{w}_j^{(v)}\\right\\}_{j \\in [r]}</span>  such that  <span class="math">\\left\\{\\left(\\mathsf{U}_j^{(v)}, \\mathsf{W}_j^{(v)}\\right)\\right\\}_{j \\in [r]}</span>  are satisfied  <span class="math">\\mathcal{R}_{\\mathrm{LCCS}}</span>  instance-witness pairs and  <span class="math">\\left\\{\\left(\\mathsf{u}_j^{(v)}, \\mathsf{w}_j^{(v)}\\right)\\right\\}_{j \\in [r]}</span>  are satisfied  <span class="math">\\mathcal{R}_{\\mathrm{CCCS}}</span>  instance-witness pairs.</p>

    <p class="text-gray-300">Given  <span class="math">\\mathcal{P}_{i-1}^<em>, \\mathcal{E}_{\\mathcal{P}_{i-1}^</em>}</span> , we construct  <span class="math">\\mathcal{E}_i</span>  as follows.</p>

    <p class="text-gray-300"><span class="math-block">(\\varphi,\\mathsf{T}_i,\\mathsf{ao})\\leftarrow\\mathcal{E}_i(\\mathsf{pp},\\mathsf{ai})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math-block">\\begin{split} \\text{1. Compute } \\left( \\left\\{ \\left( \\mathsf{U}_{j}^{(v)}, \\mathsf{W}_{j}^{(v)} \\right), \\left( \\mathsf{u}_{j}^{(v)}, \\mathsf{w}_{j}^{(v)} \\right) \\right\\}_{j \\in [r], v \\in S_{i-1}}, \\\\ \\left( \\varphi, \\mathsf{T}_{i-1}, \\mathsf{ao} \\right) \\right) \\leftarrow \\mathcal{E}_{\\mathcal{P}_{i-1}^*}(\\mathsf{pp}, \\mathsf{ai}, \\rho). \\text{ If } \\mathsf{T}_{i-1} \\text{ is not a tree of depth } i, \\text{ abort.} \\end{split}</span></li>

      <li>2. Retrieve  <span class="math">\\{\\mathbf{w}^{(v)}\\}_{v \\in S_{\\mathsf{T}_{i-1}}(i)}</span>  from the internal state of  <span class="math">\\mathcal{P}^*_{i-1}</span> , and obtain  <span class="math">z^{(v)}_{\\mathsf{loc}}, \\{z^{(v)}_j\\}_{j \\in [r]}</span>  from  <span class="math">\\mathbf{w}^{(v)}</span> .</li>

      <li>3. Append  <span class="math">z_{loc}^{(v)}</span>  to the label of  <span class="math">v \\in S_{\\mathsf{T}_{i-1}}(i)</span> .</li>

      <li>4. For each node  <span class="math">v \\in S_{i-1}</span> , let  <span class="math">S_v \\coloneqq \\left\\{j \\in [r] \\mid z_j^{(v)} \\neq \\perp\\right\\}</span> . Construct  <span class="math">\\mathsf{T}_i</span>  of depth i+1 from  <span class="math">\\mathsf{T}_{i-1}</span>  by adding, for each node  <span class="math">v \\in S_{i-1}</span> ,  <span class="math">\\left(z_j^{(v)}, \\Pi_j^{(v)}\\right)</span>  to the label of its child  <span class="math">j \\in S_v</span> , where  <span class="math">\\Pi_j^{(v)} = \\left(\\left(\\mathsf{U}_j^{(v)}, \\mathsf{W}_j^{(v)}\\right), \\left(\\mathsf{u}_j^{(v)}, \\mathsf{w}_j^{(v)}\\right)\\right)</span> .</li>

      <li>5. Output  <span class="math">(\\varphi, \\mathsf{T}_i, \\mathsf{ao})</span> .</li>

    </ul>

    <p class="text-gray-300">We now show inductively that the extractors are correct. We define the <em>inductive hypothesis</em> as that for  <span class="math">i \\in \\{0,1,\\ldots,d\\}</span> ,  <span class="math">\\mathcal{E}_i(\\mathsf{pp},\\mathsf{ai})</span>  outputs  <span class="math">(\\varphi,\\mathsf{T}_i,\\mathsf{ao})</span>  in expected polynomial time such that with probability  <span class="math">\\epsilon - \\mathsf{negl}(\\lambda)</span> , 1)  <span class="math">\\varphi \\in \\mathsf{F}, (\\mathsf{pp},\\mathsf{ai},\\varphi,\\mathsf{o}(\\mathsf{T}_i),\\mathsf{ao}) \\in Z</span> , 2)  <span class="math">\\mathsf{T}_i</span>  is  <span class="math">\\varphi</span> -compliant up to depth i, and 3) for all  <span class="math">v \\in S_{\\mathsf{T}_i}(i+1)</span> ,  <span class="math">\\mathsf{V}(\\mathsf{vk},z^{(v)},\\Pi^{(v)}) = 1</span> .</p>

    <p class="text-gray-300">In the base case, by the premise of  <span class="math">P^*</span> ,  <span class="math">\\mathcal{E}_0</span>  satisfies the inductive hypothesis.</p>

    <p class="text-gray-300">Next, supposing that  <span class="math">\\mathcal{E}_{i-1}</span>  satisfies the inductive hypothesis, we show that  <span class="math">\\mathcal{E}_i</span>  also satisfies the inductive hypothesis. By the premise of  <span class="math">\\mathcal{E}_{i-1}</span> , we have that with probability  <span class="math">\\epsilon - \\operatorname{negl}(\\lambda)</span> ,  <span class="math">\\varphi \\in \\mathsf{F}, (\\mathsf{pp}, \\mathsf{ai}, \\varphi, \\mathsf{o}(\\mathsf{T}_{i-1}), \\mathsf{ao}) \\in Z</span> ,  <span class="math">\\mathsf{T}_{i-1}</span>  is  <span class="math">\\varphi</span> -compliant up to depth i-1, and for all  <span class="math">v\\in S_{\\mathsf{T}_{i-1}}(i),\\;\\mathsf{V}\\big(\\mathsf{vk},z^{(v)},\\Pi^{(v)}\\big)=1.</span>  By the check of V, we have that (1)  <span class="math">\\{(\\mathsf{U}^{(v)}, \\mathsf{W}^{(v)}), (\\mathsf{u}^{(v)}, \\mathsf{w}^{(v)})\\}_{v \\in S_{\\mathsf{T}_{i-1}}(i)}</span> are satisfied instance-witness pairs. Additionally by the construction of  <span class="math">R_{\\varphi}</span>  and the collision-resistant property of the hash function, we have that (2) for  <span class="math">v \\in S_{\\mathsf{T}_{i-1}}(i)</span> ,  <span class="math">\\varphi(z^{(v)}, z_{\\text{loc}}^{(v)}, z_1^{(v)}, \\dots, z_r^{(v)})</span>  accepts, (3) for  <span class="math">v \\in S_{i-1}</span> ,  <span class="math">\\mathsf{U}^{(v)} =</span> NIMFS. <span class="math">\\mathcal{V}(\\mathsf{fvk}, \\{\\mathsf{U}_j^{(v)}\\}_{j \\in [r]}, \\{\\mathsf{u}_j^{(v)}\\}_{j \\in [r]}, \\pi^{(v)})</span> , and (4) for  <span class="math">v \\in S_{i-1}, j \\in [r]</span> ,  <span class="math">\\mathsf{u}_j^{(v)}</span> .<strong>x</strong> = hash(fvk,  <span class="math">z_j^{(v)}, \\mathsf{U}_j^{(v)}</span> ). Condition (2) implies that  <span class="math">\\mathsf{T}_i</span>  is  <span class="math">\\varphi</span> -compliant up to depth i, and  <span class="math">\\varphi \\in \\mathsf{U}_i</span>  <span class="math">\\mathsf{F}, (\\mathsf{pp}, \\mathsf{ai}, \\varphi, \\mathsf{o}(\\mathsf{T}_i), \\mathsf{ao}) \\in Z \\text{ with probability } \\epsilon - \\mathrm{negl}(\\lambda).</span> Conditions (1)(3) imply that  <span class="math">\\mathcal{P}_{i-1}^<em></span>  succeeds in producing satisfied folded instance-witness pairs  <span class="math">\\left\\{\\mathsf{U}^{(v)},\\mathsf{W}^{(v)}\\right\\}_{v\\in S_{i-1}}</span>  for instances  <span class="math">\\left\\{\\mathsf{U}_{j}^{(v)},\\mathsf{u}_{j}^{(v)}\\right\\}_{j\\in[r],v\\in S_{i-1}}</span>  with probability  <span class="math">\\epsilon-\\mathrm{negl}(\\lambda)</span> . Then by the knowledge soundness of the multi-folding scheme, we have that  <span class="math">\\mathcal{E}_{\\mathcal{P}_{i-1}^</em>}</span>  succeeds in outputing satisfied witnesses  <span class="math">\\{\\mathsf{W}_{j}^{(v)},\\mathsf{w}_{j}^{(v)}\\}_{j\\in[r],v\\in S_{i-1}}</span>  with probability  <span class="math">\\epsilon-\\mathrm{negl}(\\lambda)</span> . Additionally by Condition (4), we have that  <span class="math">V(vk, z^{(v)}, \\Pi^{(v)}) = 1</span> for all  <span class="math">v \\in S_{\\mathsf{T}_i}(i+1)</span>  with probability  <span class="math">\\epsilon - \\operatorname{negl}(\\lambda)</span> . Since  <span class="math">\\mathcal{E}_{i-1}</span> runs in expected polynomial time,  <span class="math">\\mathcal{E}_{\\mathcal{P}_{i-1}^*}</span>  also runs in expected polynomial time, and thereby so does  <span class="math">\\mathcal{E}_i</span> . Therefore, we have that  <span class="math">\\mathcal{E}_i</span>  satisfies the inductive hypothesis.</p>

    <p class="text-gray-300">We conclude that Construction 2 has knowledge soundness.</p>`;
---

<BaseLayout title="Proof-Carrying Data from Multi-folding Schemes (2023/1282)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/1282
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="proof-carrying-data-from-multi-folding-schemes-2023" />
  </article>
</BaseLayout>
