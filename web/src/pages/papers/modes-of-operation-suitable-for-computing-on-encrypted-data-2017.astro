---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/496';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-21';
const TITLE_HTML = '**Modes of Operation Suitable for Computing on Encrypted Data∗**';
const AUTHORS_HTML = 'Dragos Rotaru, Nigel P. Smart and Martijn Stam';

const CONTENT = `    <p class="text-gray-300">Dragos Rotaru, Nigel P. Smart and Martijn Stam</p>

    <p class="text-gray-300">University of Bristol, United Kingdom.</p>

    <p class="text-gray-300"><a href="mailto:dragos.rotaru@bristol.ac.uk,nigel@cs.bris.ac.uk,stam@cs.bris.ac.uk">dragos.rotaru@bristol.ac.uk,nigel@cs.bris.ac.uk,stam@cs.bris.ac.uk</a></p>

    <p class="text-gray-300"><strong>Abstract.</strong> We examine how two parallel modes of operation for Authenticated Encryption (namely CTR+PMAC and OTR mode) work when evaluated in a multiparty computation engine. These two modes are selected because they suit the PRFs examined in previous works. In particular the modes are highly parallel, and do not require evaluation of the inverse of the underlying PRF. In order to use these modes one needs to convert them from their original instantiation of being defined on binary blocks of data, to working on elememts in a large prime finite field. The latter fitting the use case of many secret-sharing based MPC engines. In doing this conversion we examine the associated security proofs of PMAC and OTR, and show that they carry over to this new setting.</p>

    <p class="text-gray-300"><strong>Keywords:</strong> Modes-of-Operation · Multi-Party Computation</p>

    <h2 id="sec-1" class="text-2xl font-bold"><strong>1 Introduction</strong></h2>

    <p class="text-gray-300">The development of low complexity blockciphers and pseudorandom functions (PRFs) has attracted considerable interest lately. The initial motivation was their suitability to low power devices, as used in IoT applications <a href="#page-29-0">[LK06,</a> <a href="#page-29-1">DPAR00,</a> <a href="#page-28-0">BCG</a>&lt;sup&gt;+&lt;/sup&gt;12]. Recently, these ciphers found a second application for use in systems which compute on encrypted data, such as Multi-Party Computation (MPC) systems and Fully Homomorphic Encryption (FHE) mechanisms. In these latter contexts, evaluating the AES function has long been a standard benchmark <a href="#page-30-0">[PSSW09,</a> <a href="#page-28-1">DK10,</a> <a href="#page-29-2">DKL</a>&lt;sup&gt;+&lt;/sup&gt;12, <a href="#page-30-1">NNOB12,</a> <a href="#page-29-3">LR15]</a>, however we contend that AES is unsuitable for many secure computation applications.</p>

    <p class="text-gray-300">Grassi et al. <a href="#page-29-4">[GRR</a>&lt;sup&gt;+&lt;/sup&gt;16] already make the case for using blockciphers and PRFs over finite fields of large prime characteristic in MPC applications, as especially MPC systems based on secret sharing typically provide efficient arithmetic operations over such prime fields<a href="#page-0-0">1</a> . A key application of blockciphers and PRFs is to authenticate and encrypt data. In an MPC context, the symmetric key and the data would typically reside in the MPC system, where encryption and decryption would take place to create ciphertexts for storage or transmission of sensitive information <em>outside</em> the MPC system. The trivial solution would be to encrypt parties shares separately in such applications, producing a linear (in the number of players) increase in the communication and/or storage of such encrypted data. The next (slightly less) trivial solution would be to use a standard mode-of-operation based on a standard PRF such as AES. But, continual conversion to and from a binary</p>

    <p class="text-gray-300">&lt;sup&gt;∗&lt;/sup&gt;The work in this paper was partially supported by ERC Advanced Grant ERC-2015-AdG-IMPaCT, by EPSRC via grant EP/N021940/1, and by the Defense Advanced Research Projects Agency (DARPA) and Space and Naval Warfare Systems Center, Pacific (SSC Pacific) under contract No. N66001-15-C-4070.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-0-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;1&lt;/sup&gt; In this work we focus exclusively on secret-sharing based MPC over large prime fields. It would be an interesting extension to examine what happens for binary field based secret-sharing based MPC, or garbled-circuit based MPC.</p>

    <p class="text-gray-300">field as required for say AES would be prohibitively expensive in this context. Thus, a mode of operation based on a PRF over the underlying finite field of the MPC system would seem to offer advantages.</p>

    <p class="text-gray-300">The usual modes of operation for authenticated encryption have a strong binary focus, moreover due to the different cost metrics for secret sharing based MPC, conventional wisdom on what makes for an efficient mode of operation no longer applies. Hence authenticated encryption (AE) suitable for MPC should be benchmarked directly; as the different environment is likely to produce different cost considerations.</p>

    <p class="text-gray-300">When benchmarking AE for MPC, the two main metrics of interest are the overall throughput and latency of what is called the online phase. Both metrics are driven primarily by communication between the various parties and much less by the local computation (which traditionally plays a dominant role). Our focus will be on the paradigm of secret sharing based MPC, as typified by the BDOZ <a href="#page-28-2">[BDOZ11]</a>, SPDZ <a href="#page-29-5">[DPSZ12,</a> <a href="#page-29-6">DKL</a>&lt;sup&gt;+&lt;/sup&gt;13], or VIFF <a href="#page-28-3">[DGKN09]</a> systems. In these systems, the data to be kept secure is secret shared amongst the parties. The computation itself is typically expressed as algebraic operations over a large finite field F<em>&lt;sup&gt;p&lt;/sup&gt;</em> where, loosely speaking, the secret shared values behave a little like vectors with any open values being treated as scalars. Consequently, additions of secret shared data and scalar multiplications are both cheap (can be performed locally), yet multiplication of secret shared data is expensive. Indeed, this last step requires communication and is often performed by consuming a so-called &quot;Beaver triple,&quot; which has been precomputed in an offline phase.</p>

    <p class="text-gray-300">As a crude estimate, the latency of an overall computation is then dominated by the multiplicative depth (of secret shared values), whereas the throughput is a function of the total number of such multiplications. However, the physical limitations of the network's bandwidth and latency also play a major part in determining overall throughput and latency. The differences in the computational model affect the design of PRFs and blockciphers in the MPC arena, as exemplified by the blockcipher MiMC <a href="#page-27-0">[AGR</a>&lt;sup&gt;+&lt;/sup&gt;16] and pseudorandom function Leg <a href="#page-29-4">[GRR</a>&lt;sup&gt;+&lt;/sup&gt;16]. However, the effect on possible modes of operation, to transform these primitives in practically more relevant authenticated encryption, has thus far not been explored in detail.</p>

    <p class="text-gray-300"><strong>Our Contribution</strong> We examine how the currently best PRFs for secret shared MPC over F<em>p</em>, namely MiMC and Leg, can be used to enable nonce-based authenticated encryption, where we benchmark a number of orthogonal options. As alluded to before, we are assuming that the key and the plaintext message are held in secret shared form, but that the nonce and the resulting ciphertext are in the clear. This assumption crucially informs our study.</p>

    <p class="text-gray-300">Our first step is to select potential modes of operation for secret-sharing based MPCdriven, nonce-based AE. In making such a selection there are a number of design desiderata to take into account the somewhat unusual computational model. Firstly, the underlying PRF is only ever evaluated in the forward direction, both during encryption and decryption (even though MiMC as a blockcipher does have an inverse, it is rather inefficient). Secondly, the mode should allow a high degree of parallelism of the PRF calls to take full advantage of the ability of secret-sharing based MPC engines to evaluate many operations in parallel. Finally, the further computational overhead (beyond PRF calls) may be complicated, provided it can be performed locally. To enable local computation, it can be worth opening secret shared elements, provided this opening does not negatively affect security.</p>

    <p class="text-gray-300">When examining various possible modes for authenticated encryption, we found two candidates that best met our overall design criteria: on the one hand, a single combined mode based on OTR <a href="#page-29-7">[Min14]</a>, and on the other an Encrypt-then-MAC methodology using either CTR-Mode plus PMAC <a href="#page-28-4">[BR02]</a>, or CTR-Mode plus Hash-then-Encrypt (where in both cases the CTR-Mode is nonce-based by exploiting a tweakable PRF). We converted the original PMAC and OTR algorithms (which use finite fields of characteristic two) into variants that process blocks consisting of finite field elements in  <span class="math">\\mathbb{F}_p</span> , where p is a large prime (say  <span class="math">p &gt; 2^{128}</span> ). The resulting algorithms we dub pPMAC and pOTR. Here we took care to ensure that the modifications made do not invalidate any of the original security proofs.</p>

    <p class="text-gray-300">Modern modes of operation, including PMAC and OTR, are usually cleanest described based on a tweakable primitive, and we follow suit. This obviously does necessitate the investigation of tweakable PRFs in our MPC context. Luckily, creating tweakable PRFs turns out much easier than in the traditional, binary field setting. In that latter setting, Rogaway's XE transform [Rog04] takes a PRF  <span class="math">\\mathsf{E}_{\\mathsf{k}}(m)</span>  and turns it into a tweakable PRF  <span class="math">\\mathsf{E}_{\\mathsf{k}}^{i,N}(m)</span>  with a tweak (i,N) using a sequence of constants  <span class="math">M_i</span>  in the following manner:</p>

    <p class="text-gray-300"><span class="math">$\\widetilde{\\mathsf{E}}_{\\mathsf{k}}^{i,N}(m) = \\mathsf{E}_{\\mathsf{k}}(m \\oplus (M_i \\cdot \\mathsf{E}_{\\mathsf{k}}(N)))</span>$
.</p>

    <p class="text-gray-300">It is important that the constants  <span class="math">M_i</span>  do not repeat, and be easy to compute. This led many authors to select  <span class="math">M_i = 2^{T_1} \\cdot 3^{T_2}</span>  for two functions  <span class="math">T_1, T_2</span>  depending on i. This choice is prompted by the characteristic two field, with the exact tweak applied depending on the field order. In our setting of large prime characteristic, we obtain a trivial schedule by using a standard integer representation of the field:</p>

    <p class="text-gray-300"><span class="math">$\\widetilde{\\mathsf{E}}_{\\mathsf{k}}^{i,N}(m) = \\mathsf{E}_{\\mathsf{k}}(m + (i \\cdot \\mathsf{E}_{\\mathsf{k}}(N))) \\ .</span>$</p>

    <p class="text-gray-300">With CTR-then-pPMAC as an encryption methodology on a message consisting of  <span class="math">\\ell</span>  finite field elements (i.e.  <span class="math">\\ell</span>  blocks in this context), we apply one round of  <span class="math">\\ell</span>  tweakable-PRF evaluations to encrypt the  <span class="math">\\ell</span>  message blocks, then another round of  <span class="math">\\ell-1</span>  tweakable-PRF evaluations to produce a final MAC block, to which a final tweakable-PRF evaluation is performed. Ignoring non-message dependent PRF evaluations this means we need to evaluate  <span class="math">2 \\cdot \\ell</span>  PRF evaluations in a total of three parallel rounds. For the CTR+Hash-then-MAC mode we apply one round of  <span class="math">\\ell</span>  tweakable-PRF evaluations to encrypt the  <span class="math">\\ell</span>  message blocks, then a hash function in the clear to produce an intermediate open value, to which a final tweakable-PRF evaluation is performed. This means we need to evaluate  <span class="math">\\ell+1</span>  PRF evaluations in a total of two parallel rounds. For the OTR mode we evaluate first a PRF on a nonce block, then apply  <span class="math">\\ell</span>  PRF calls in two rounds (essentially performing a two round Feistel network). A final PRF evaluation produces the tag. Overall, we require  <span class="math">\\ell+2</span>  PRF evaluations over four parallel rounds to evaluate OTR mode. Not surprisingly, we find that CTR+Hash-then-MAC turns out to be the most efficient of these modes of operation.</p>

    <p class="text-gray-300">In a second step we implemented the modes using the above two PRFs to see which performed better in practice. Our experiments are carried out using the publicly available SPDZ engine [DPSZ12, DKL <span class="math">^+</span> 13], though any classical protocol based on Shamir secret sharing could also be used. Previously, Grassi et al. [GRR <span class="math">^+</span> 16] conducted experiments under the assumptions that the input and the output to the PRF need to be kept in secret shared form. However, when used within one of the above modes of operation this may no longer true, enabling further optimizations to be made into precisely how the PRFs are evaluated within the MPC system. A topic which we explore in this paper.</p>

    <p class="text-gray-300">Grassi et al. furthermore imply that the Leg PRF is to be preferred over the MiMC PRF, as the Leg PRF (based on the Legendre symbol) had both a lower online round cost and lower offline pre-processing costs. Their experiments seemed to confirm this preference. Interestingly, when used within a mode of operation supporting parallel processing of the blocks, we find that the MiMC PRF performs much better. Though the Leg PRF has low round complexity and low computational cost (when computational cost is measured in an MPC environment), its per-round communication cost is high. Thus for each round of communication the number of bits sent between the MPC servers is much larger than that for MiMC. When many PRF applications are done in parallel this high per round communication cost causes network bottlenecks, resulting in a linear scaling in the runtime</p>

    <p class="text-gray-300">as the number of blocks processed increases. For MiMC, reaching network saturation takes longer and so, as the number of blocks processed is increased, the runtime only degrades sub-linearly. Hence, MiMC will often significantly outperform Leg.</p>

    <p class="text-gray-300"><strong>Related Work</strong> Several recent papers have examined new low complexity blockciphers and PRFs in the context of both MPC and FHE applications. For example, a blockcipher called LowMC [ARS+15] is suitable for both MPC and FHE applications, whereas a a stream cipher called Kreyvium [CCF+16], based on the Trivium stream cipher, is targeted at FHE applications. Another stream cipher, FLIP, was cryptanalysed shortly after it was presented [MJSC16, DLR16]. The blockcipher MiMC [AGR+16] was originally targeted at SNARK applications, but later found to have potential for MPC style applications: Grassi et al. [GRR+16] discuss the MiMC blockcipher and a new PRF based on the Legendre symbol in the context of the SPDZ MPC engine.</p>

    <p class="text-gray-300">As well as examining the basic PRF primitives, Grassi et al. [GRR&lt;sup&gt;+&lt;/sup&gt;16] also touched upon basic techniques to provide domain extension, concentrating on the established CBC-MAC construction and the Merkle–Damgård construction. However, both of these methods are sequential in nature, and hence are significantly less efficient in an MPC context than the highly parallel modes examined by us. Moreover, Grassi et al. [GRR&lt;sup&gt;+&lt;/sup&gt;16] neither address codomain extension (notwithstanding one of their section headings) nor authenticated encryption, even though both are crucial for encryption applications.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">2 Preliminaries</h4>

    <p class="text-gray-300">In this section we recall the basic notions of authenticated encryption (AE) and its constituent building block pseudorandom function (PRF), as well as generic design considerations in the context of multiparty computation (MPC), including details on the two existing PRFs designed for MPC that we will build upon. Throughout we will write  <span class="math">\\mathcal{A}^{O_1,\\ldots,O_c}</span>  for an algorithm  <span class="math">\\mathcal{A}</span>  with access to c oracles  <span class="math">O_1,\\ldots,O_c</span> . For a finite field  <span class="math">\\mathbb{F}_p</span>  we let  <span class="math">\\mathbb{F}_p^{\\times} = \\mathbb{F}_p \\setminus \\{0\\}</span> .</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">2.1 Tweakable Pseudorandom Functions</h4>

    <p class="text-gray-300">A Pseudo-Random Function (PRF) is a keyed function  <span class="math">F: \\mathcal{K} \\times \\mathcal{X} \\to \\mathcal{Y}</span> , where  <span class="math">\\mathcal{K}</span>  is called the key space. The key  <span class="math">k \\in \\mathcal{K}</span>  is typically chosen at random and the function keyed with k is denoted  <span class="math">F_k</span> .</p>

    <p class="text-gray-300">A PRF is pseudorandom if an adversary cannot tell the difference between oracle access to  <span class="math">F_k</span> , for undisclosed k uniformly chosen at random from  <span class="math">\\mathcal{K}</span> , on the one hand and oracle access to a function selected uniformly at random from the set  <span class="math">\\operatorname{Rand}(\\mathcal{X},\\mathcal{Y})</span>  of all functions which map  <span class="math">\\mathcal{X}</span>  to  <span class="math">\\mathcal{Y}</span> , on the other. More formally, for an adversary  <span class="math">\\mathcal{A}</span>  the PRF advantage against F (or  <span class="math">F_k(\\cdot)</span> ) is defined as</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}_F^{\\mathsf{prf}} \\stackrel{\\mathrm{def}}{=} \\left| \\Pr \\left[ \\ \\mathsf{k} \\stackrel{\\</span>}{\\leftarrow} \\mathcal{K} : \\mathcal{A}^{F_{\\mathsf{k}}(\\cdot)} \\Rightarrow 1 \\ \\right] - \\Pr \\left[ \\ \\rho \\stackrel{$}{\\leftarrow} \\mathrm{Rand}(\\mathcal{X}, \\mathcal{Y}) : \\mathcal{A}^{\\rho(\\cdot)} \\Rightarrow 1 \\ \\right] \\right|$$</p>

    <p class="text-gray-300">where we will informally say F is a PRF if this advantage is sufficiently small for all reasonably resourced adversaries. It is easy to formalize our work to an asymptotic setting where security equates to negligible advantages with respect to all probabilistic polynomial-time adversaries operating against function families (indexed by a security parameter).</p>

    <p class="text-gray-300">In analogy with tweakable blockciphers, we shall also consider PRFs. A tweakable PRF (tPRF) takes as additional input a tweak T chosen from a set of tweaks  <span class="math">\\mathcal{T}</span> , thus  <span class="math">\\tilde{F}: \\mathcal{K} \\times \\mathcal{T} \\times \\mathcal{X} \\to \\mathcal{Y}</span> . Security is defined in much the same way as for a PRF, except that the adversary can query the function on tweak–message pairs and the adversary's goal</p>

    <p class="text-gray-300">is to distinguish  <span class="math">\\tilde{F}_k</span>  from a random function  <span class="math">\\tilde{\\rho} \\in \\text{Rand}(\\mathcal{T} \\times \\mathcal{X}, \\mathcal{Y})</span> . More formally, for an adversary  <span class="math">\\mathcal{A}</span>  the tPRF advantage against  <span class="math">\\tilde{F}</span>  is defined as</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}^{\\mathsf{tprf}}_{\\tilde{F}} \\stackrel{\\mathrm{def}}{=} \\left| \\Pr \\left[ \\, \\mathsf{k} \\xleftarrow{\\</span>} \\mathcal{K} : \\mathcal{A}^{\\tilde{F}_{\\mathsf{k}}(\\cdot,\\cdot)} \\Rightarrow 1 , \\right] - \\Pr \\left[ , \\widetilde{\\rho} \\xleftarrow{$} \\mathrm{Rand}(\\mathcal{T} \\times \\mathcal{X}, \\mathcal{Y}) : \\mathcal{A}^{\\widetilde{\\rho}(\\cdot,\\cdot)} \\Rightarrow 1 , \\right] \\right|$$</p>

    <p class="text-gray-300">When considering PRFs with domain and co-domain such that  <span class="math">\\mathcal{X} = \\mathcal{Y} = \\mathbb{F}_p</span> , we shall write  <span class="math">\\mathsf{E}_\\mathsf{k}(m)</span> , without requiring  <span class="math">\\mathsf{E}_\\mathsf{k}(\\cdot)</span>  being a permutation. And in the tweakable setting, for the special case that  <span class="math">\\mathcal{X} = \\mathcal{Y} = \\mathbb{F}_p</span>  we introduce the notation  <span class="math">\\widetilde{\\mathsf{E}}_\\mathsf{k}^{i,N}(m)</span> , with the tweak  <span class="math">(i,N) \\in \\mathbb{F}_p^\\times \\times \\mathbb{F}_p = \\mathcal{T}</span> . Given a PRF  <span class="math">\\mathsf{E}_\\mathsf{k}(\\cdot)</span>  we can create a tweakable PRF  <span class="math">\\widetilde{\\mathsf{E}}_\\mathsf{k}^{i,N}(\\cdot)</span>  using Rogaway's XE framework [Rog04] adapted to  <span class="math">\\mathbb{F}_p</span>  by setting  <span class="math">\\widetilde{\\mathsf{E}}_\\mathsf{k}^{i,N}(m) = \\mathsf{E}_\\mathsf{k}(m+(i\\cdot\\mathsf{E}_\\mathsf{k}(N)))</span> , for  <span class="math">i\\neq 0</span> , as in Figure 1.</p>

    <pre><code class="language-text">Algorithm \\widetilde{\\mathsf{E}}_{\\mathsf{k}}^{i,N}(m):

1: L \\leftarrow \\mathsf{E}_{\\mathsf{k}}(N)

2: \\Delta \\leftarrow i \\cdot L

3: Y \\leftarrow \\mathsf{E}_{\\mathsf{k}}(\\Delta + m)

4: return Y
</code></pre>

    <p class="text-gray-300"><strong>Figure 1:</strong> XE-based tweakable pseudorandom function over  <span class="math">\\mathbb{F}_p</span></p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> Let  <span class="math">\\mathsf{E}</span>  be any PRF with  <span class="math">\\mathcal{X} = \\mathcal{Y} = \\mathbb{F}_p</span>  and let  <span class="math">\\widetilde{\\mathsf{E}}</span>  be the tweakable PRF with tweak space  <span class="math">\\mathbb{F}_p^\\times \\times \\mathbb{F}_p</span>  as defined in Figure 1. Let  <span class="math">\\mathcal{A}</span>  be an arbitrary adversary against the PRF advantage of  <span class="math">\\widetilde{\\mathsf{E}}</span>  making at most q queries to its oracle, then there exists a similarly resourced adversary  <span class="math">\\mathcal{B}</span>  against  <span class="math">\\mathsf{E}</span>  satisfying</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}^\\mathsf{tprf}_{\\widetilde{\\mathsf{E}}}(\\mathcal{A}) \\leq \\mathsf{Adv}^\\mathsf{prf}_{\\mathsf{E}}(\\mathcal{B}) + 3q^2/2p \\ .</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> We closely follow Rogaway's original proof for XE [Rog04, Theorem 7], making only minimal changes to adapt from the  <span class="math">\\mathbb{F}_2^n</span>  case to the more forgiving  <span class="math">\\mathbb{F}_p</span>  case and to take advantage of operating on functions, as opposed to permutations. The latter allows us to avoid two PRP–PRF switches in the proof, resulting in a slightly tighter bound as a result. As is customary, without loss of generality we assume the adversary does not repeat queries.</p>

    <p class="text-gray-300">Let game  <span class="math">G_0</span>  be the original game where an adversary has access to  <span class="math">\\widetilde{\\mathsf{E}}</span>  that calls  <span class="math">\\mathsf{E}</span>  in the background and let  <span class="math">G_1</span>  be the game where the internal calls to  <span class="math">\\mathsf{E}</span>  are replaced by calls to a random function. This standard hop incurs the tPRF advantage, that is</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[ \\ \\mathcal{A}^{G_0} \\Rightarrow 1 \\ \\right] - \\Pr\\left[ \\ \\mathcal{A}^{G_1} \\Rightarrow 1 \\ \\right] \\leq \\mathsf{Adv}^{\\mathsf{prf}}_{\\mathsf{E}}(\\mathcal{B}) \\ ,</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathcal{B}</span>  is the adversary that runs  <span class="math">\\mathcal{A}</span>  and answers the latter's queries by evaluating  <span class="math">\\widetilde{\\mathsf{E}}</span>  using calls to its own oracle. The number of queries  <span class="math">\\mathcal{B}</span>  makes is at most twice that of  <span class="math">\\mathcal{A}</span>  and the runtime overhead is limited to a few finite field operations per query.</p>

    <p class="text-gray-300">Next consider the games  <span class="math">G_2</span>  and  <span class="math">G_3</span>  as depicted in Figure 2. Game  <span class="math">G_2</span>  is identical to  <span class="math">G_1</span>  where the internal random function has been implemented using lazy sampling. By inspection, games  <span class="math">G_2</span>  and  <span class="math">G_3</span>  are identical until bad, and game  <span class="math">G_3</span>  is identical to providing access to a random tweakable function, hence</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathsf{Adv}^\\mathsf{tprf}_{\\widetilde{\\mathsf{E}}}(\\mathcal{A}) &amp; \\leq \\Pr\\left[ \\, \\mathcal{A}^{G_0} \\Rightarrow 1 \\, \\right] - \\Pr\\left[ \\, \\mathcal{A}^{G_3} \\Rightarrow 1 \\, \\right] \\\\ &amp; = \\Pr\\left[ \\, \\mathcal{A}^{G_0} \\Rightarrow 1 \\, \\right] - \\Pr\\left[ \\, \\mathcal{A}^{G_1} \\Rightarrow 1 \\, \\right] + \\Pr\\left[ \\, \\mathcal{A}^{G_2} \\Rightarrow 1 \\, \\right] - \\Pr\\left[ \\, \\mathcal{A}^{G_3} \\Rightarrow 1 \\, \\right] \\\\ &amp; = \\mathsf{Adv}^\\mathsf{prf}_{\\mathsf{E}}(\\mathcal{B}) + \\Pr\\left[ \\, \\mathcal{A} \\text{ sets bad in } G_3 \\, \\right] \\, . \\end{split}</span>$</p>

    <pre><code class="language-text">Oracle \\widetilde{\\mathbb{E}}_{k}^{i,N}(m):

1: if N \\not\\in \\mathcal{N} then

2: \\mathcal{N} \\stackrel{\\smile}{\\leftarrow} N

3: if N \\in \\mathcal{X} then

4: set \\operatorname{bad}_{xn}

5: L_{N} \\stackrel{\\$}{\\leftarrow} \\mathbb{F}_{p}

6: else

7: L_{N} \\stackrel{\\$}{\\leftarrow} \\mathbb{F}_{p}

8: X \\leftarrow m + i \\cdot L_{N}

9: if X \\in \\mathcal{X} then

10: set \\operatorname{bad}_{xx}

11: L_{X} \\stackrel{\\$}{\\leftarrow} \\mathbb{F}_{p}

12: else if X \\in \\mathcal{N} then

13: set \\operatorname{bad}_{nx}

14: L_{X} \\stackrel{\\$}{\\leftarrow} \\mathbb{F}_{p}

15: else

16: L_{X} \\stackrel{\\$}{\\leftarrow} \\mathbb{F}_{p}

17: \\mathcal{X} \\stackrel{\\smile}{\\leftarrow} X

18: return L_{X}
</code></pre>

    <p class="text-gray-300"><strong>Figure 2:</strong> Games  <span class="math">G_2</span>  and  <span class="math">G_3</span> , where only  <span class="math">G_3</span>  includes the boxed statements.</p>

    <p class="text-gray-300">What remains to bound is the probability  <span class="math">\\mathcal{A}</span>  sets bad in  <span class="math">G_3</span> . The first observation here is that in  <span class="math">G_3</span>  the oracle's output is independent of the input, which allows us to consider non-adaptive adversaries only: given a sequence of queries  <span class="math">(N_j, i_j, m_j)</span>  what is the probability that the lazy sampling results in bad being set?</p>

    <p class="text-gray-300">Without loss of generality, we assume that the queries are sorted on their first component. This allows us to track the probability that one of the bad events happens as  <span class="math">L_N</span>  gets sampled (see Figure 3). Furthermore, we rely on  <span class="math">i_j \\in \\mathbb{F}_p^{\\times}</span>  means it has a multiplicative inverse so that, for a given triple  <span class="math">(X, m_j, i_j)</span> , it holds that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[L_n \\stackrel{\\</span>}{\\leftarrow} \\mathbb{F}_p : X = m_j + i_j L_n\\right] = \\Pr\\left[L_n \\stackrel{$}{\\leftarrow} \\mathbb{F}_p : L_n = i_j^{-1}(X - m_j)\\right] = 1/p.$$</p>

    <p class="text-gray-300">Bounding the probability that in the <strong>for</strong> loop  <span class="math">\\mathsf{bad}_{\\mathsf{xx}}</span>  gets set is then easy: by using a union bound over  <span class="math">X \\in \\mathcal{X}</span>  this equals  <span class="math">|\\mathcal{X}|/p</span> . Similarly, the probability that  <span class="math">\\mathsf{bad}_{\\mathsf{xn/nx}}</span>  gets set is at most  <span class="math">|\\mathcal{N}|/p</span> . The overall probability can then be bounded by union bound by</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[ \\, \\mathcal{A} \\, \\operatorname{sets} \\, \\mathsf{bad} \\, \\right] \\leq \\sum_{l=1}^q (q+l-1)/p \\leq \\frac{3q^2}{2p} \\,\\, ,</span>$</p>

    <p class="text-gray-300">where we used  <span class="math">|\\mathcal{X}| \\leq l - 1</span>  and  <span class="math">\\mathcal{N} \\leq q</span> .</p>

    <p class="text-gray-300">Pseudorandom functions can double as message authentication codes (MACs). While it is possible to consider MACs in a more general context than PRFs (for instance allow probabilistic tagging and introduce a separate verification function) and with a weaker unforgeability security notion, we will treat MACs as a deterministic keyed function  <span class="math">\\mathsf{MacGen}: \\mathcal{K} \\times \\mathcal{X} \\to \\mathcal{Y}</span>  whose security notion coincides with that of a PRF.</p>

    <p class="text-gray-300">We are primarily interested in pPMAC, which is an adaptation of PMAC—or more accurately of PMAC1 [Rog04]—to  <span class="math">\\mathbb{F}_p</span> . It can be considered a domain extension of  <span class="math">\\mathsf{E}_\\mathsf{k}(\\cdot)</span></p>

    <pre><code class="language-text">Oracle (N, (i_j, m_j)_j):

1: L_N \\stackrel{\\$}{\\leftarrow} \\mathbb{F}_p

2: for j do

3: X \\leftarrow m_j + i_j L_N

4: if X \\in \\mathcal{X} then

5: set bad&lt;sub&gt;xx&lt;/sub&gt;

6: else if X \\in \\mathcal{N} then

7: set bad&lt;sub&gt;xn/nx&lt;/sub&gt;

8: \\mathcal{X} \\stackrel{\\cup}{\\leftarrow} X
</code></pre>

    <p class="text-gray-300"><strong>Figure 3:</strong> Bounding bad; here  <span class="math">\\mathcal{N}</span>  is initialized to contain all N to be queried.</p>

    <p class="text-gray-300">with domain (and codomain)  <span class="math">\\mathbb{F}_p</span>  to MacGen with domain  <span class="math">\\mathcal{X} = \\mathbb{F}_p^*</span>  and codomain  <span class="math">\\mathcal{Y} = \\mathbb{F}_p</span> , where  <span class="math">\\mathbb{F}_p^*</span>  denotes the arbitrary length strings of  <span class="math">\\mathbb{F}_p</span>  elements, though there will be an effective upper bound on the maximum length we can cope with.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">2.2 Authenticated Encryption</h3>

    <p class="text-gray-300">For simplicity, we only consider AE schemes without associated data, although we are confident that the techniques we develop in later sections apply in equal measure to AEAD schemes. An AE scheme is defined by two algorithms (AE- <span class="math">\\mathcal{E}_{\\mathbb{F}}</span> , AE- <span class="math">\\mathcal{D}_{\\mathbb{F}}</span> ), where we use the subscript  <span class="math">\\mathbb{F}</span>  to denote that both the input and output will be vectors of elements in a finite field (typically  <span class="math">\\mathbb{F} = \\mathbb{F}_p</span>  due to their relevance to MPC applications).</p>

    <p class="text-gray-300">The encryption  <span class="math">\\mathsf{AE}\\text{-}\\mathcal{E}_{\\mathbb{F}}</span>  always takes as input a key  <span class="math">\\mathbf{k}</span> , a message  <span class="math">\\mathbf{m} \\in \\mathbb{F}^*</span> , and an additional input  <span class="math">N \\in \\mathbb{F}</span>  or  <span class="math">\\mathsf{IV} \\in \\mathbb{F}</span> , where the difference in notation refers to the distinction between nonce-based security (N) versus IV-based security  <span class="math">(\\mathsf{IV})</span> . The output consists of a ciphertext  <span class="math">\\mathbf{c} \\in \\mathbb{F}^*</span>  and a separate tag  <span class="math">T \\in \\mathbb{F}</span> . Thus we have that</p>

    <p class="text-gray-300"><span class="math">$(\\mathbf{c}, T) \\leftarrow \\mathsf{AE}\\text{-}\\mathcal{E}_{\\mathbb{F}}(\\mathbf{k}, N, \\mathbf{m})</span>$</p>

    <p class="text-gray-300">with N possibly replaced by IV depending on the context. Henceforth we will assume that the scheme is length-preserving, meaning that  <span class="math">|\\mathbf{c}| = |\\mathbf{m}|</span>  irrespective of  <span class="math">\\mathsf{AE}\\text{-}\\mathcal{E}_\\mathbb{F}</span> 's inputs. The decryption function  <span class="math">\\mathsf{AE}\\text{-}\\mathcal{D}_\\mathbb{F}</span>  receives as input a key  <span class="math">\\mathbf{k}</span> , and  <span class="math">(N, \\mathbf{c}, T)</span>  (or  <span class="math">(\\mathsf{IV}, \\mathbf{c}, T)</span> ) and outputs a purported plaintext  <span class="math">\\mathbf{m} \\in \\mathbb{F}^*</span>  or  <span class="math">\\bot</span>  if the input is deemed invalid. We impose both correctness and tidiness [NRS14] on the pair  <span class="math">(\\mathsf{AE}\\text{-}\\mathcal{E}_\\mathbb{F}, \\mathsf{AE}\\text{-}\\mathcal{D}_\\mathbb{F})</span> , so that</p>

    <pre><code class="language-text">(correctness) for all inputs \\mathsf{AE-}\\mathcal{D}_{\\mathbb{F}}(\\mathbf{k},N,\\mathsf{AE-}\\mathcal{E}_{\\mathbb{F}}(\\mathbf{k},N,\\mathbf{m}))=\\mathbf{m} and (tidiness) for all inputs, if \\mathsf{AE-}\\mathcal{D}_{\\mathbb{F}}(\\mathbf{k},N,c)=m\\neq \\perp, then \\mathsf{AE-}\\mathcal{E}_{\\mathbb{F}}(\\mathbf{k},N,m)=c
</code></pre>

    <p class="text-gray-300">which implies that as functions  <span class="math">AE-\\mathcal{D}_{\\mathbb{F}}</span>  is completely defined by  <span class="math">AE-\\mathcal{E}_{\\mathbb{F}}</span> .</p>

    <p class="text-gray-300">Our choice for a separate tag in the syntax is customary in part of the literature and preempts later constructions where there is a clear authentication tag, although especially for encode-then-encipher constructions the split would be artificial.</p>

    <p class="text-gray-300">Security for an AE scheme is defined by two notions: <strong>PRIV</strong> and <strong>AUTH</strong>. Informally, the first property defines what it means for a ciphertext to keep the message hidden, whereas the second defines what it means for the ciphertext to be authenticated. The PRIV adversary works as a basic IND-CPA adversary against the encryption scheme. In particular the adversary AE has access to an encryption oracle implementing either AE- <span class="math">\\mathcal{E}_{\\mathbb{F}}</span>  for the underlying AE scheme, or an oracle $\\$ which just outputs random finite field elements of the correct length. The adversary will query this oracle with  <span class="math">(N_i, \\mathbf{m}_i)</span>  (resp. just  <span class="math">\\mathbf{m}_i</span> ) in the nonce-based (resp. IV-based) setting, to obtain tuple  <span class="math">(\\mathbf{c}_i, T_i)</span>  (resp.  <span class="math">(\\mathbf{c}_i, T_i)</span>  plus the  <span class="math">IV_i</span>  chosen by the experiment). The only constraint on the adversary's calls to this oracle come in the nonce-based setting, where the calls must be nonce-respecting, i.e. if  <span class="math">i \\neq j</span></p>

    <p class="text-gray-300">then  <span class="math">N_i \\neq N_j</span> . For an adversary  <span class="math">\\mathcal{A}</span>  we let q denote the number of queries and  <span class="math">\\sigma_M</span>  the total length of all messages queried to the oracle, so  <span class="math">\\sigma_M \\stackrel{\\text{def}}{=} \\sum_{i=1}^q |\\mathbf{m}_i|</span> .</p>

    <p class="text-gray-300">The adversary's goal is to distinguish between a genuine encryption oracle (which also outputs the IV) and one that just outputs random values  <span class="math">(\\mathbf{c}_i, T_i)</span>  (resp.  <span class="math">(\\mathsf{IV}_i, \\mathbf{c}_i, T_i)</span> ) of the corresponding length. Thus we define the advantage of an adversary as follows:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}^{\\mathsf{priv}}_{\\mathsf{AE}[\\mathbb{F}]}(\\mathcal{A}) \\stackrel{\\mathrm{def}}{=} \\left| \\Pr \\left[ \\left. \\mathbf{k} \\stackrel{\\</span>}{\\leftarrow} \\mathcal{K} : \\mathcal{A}^{\\mathsf{AE-}\\mathcal{E}_{\\mathbb{F}}} \\Rightarrow 1 \\right. \\right] - \\Pr \\left[ \\left. \\mathcal{A}^{$} \\Rightarrow 1 \\right. \\right] \\right| ,.$$</p>

    <p class="text-gray-300">An AUTH adversary  <span class="math">\\mathcal{A}</span>  can access both oracles  <span class="math">\\mathsf{AE-}\\mathcal{E}_{\\mathbb{F}}</span>  and  <span class="math">\\mathsf{AE-}\\mathcal{D}_{\\mathbb{F}}</span> , where it can make q encryption queries and  <span class="math">q_v</span>  decryption queries. The encryption queries we denote by  <span class="math">(N_1,\\mathbf{m}_1),\\ldots,(N_q,\\mathbf{m}_q)</span>  (resp.  <span class="math">\\mathbf{m}_1,\\ldots,\\mathbf{m}_q</span> ), and as above we require that, in the nonce-based setting, they are nonce-respecting. Decryption queries are denoted by  <span class="math">(N_1&#x27;,\\mathbf{c}_1&#x27;,T_1&#x27;),\\ldots,(N_{q_v}&#x27;,\\mathbf{c}_{q_v}&#x27;,T_{q_v}&#x27;)</span> , (resp.  <span class="math">(\\mathsf{IV}_1&#x27;,\\mathbf{c}_1&#x27;,T_1&#x27;),\\ldots,(\\mathsf{IV}_{q_v}&#x27;,\\mathbf{c}_{q_v}&#x27;,T_{q_v}&#x27;)</span> ); there are no restrictions on what can be passed to the decryption oracle by the adversary. We let  <span class="math">\\sigma_M</span>  be as above and additionally use  <span class="math">\\sigma_C</span>  to denote the total length of the ciphertexts passed to the decryption oracle, so  <span class="math">\\sigma_{C&#x27;} \\stackrel{\\mathrm{def}}{=} \\sum_{i=1}^{q_v} |\\mathbf{c}_i&#x27;|</span> . The adversary wins, or is said to have forged a message, if it passes a query to  <span class="math">\\mathsf{AE-}\\mathcal{D}_{\\mathbb{F}}</span>  which does not return  <span class="math">\\bot</span>  and which was not obtained from a query to  <span class="math">\\mathsf{AE-}\\mathcal{E}_{\\mathbb{F}}</span> . Let this query be denoted by  <span class="math">(N_{i^*}&#x27;,\\mathbf{c}_{i^*}&#x27;,T_{i^*}&#x27;)</span>  (resp.  <span class="math">(\\mathsf{IV}_{i^*}&#x27;,C_{i^*}&#x27;,T_{i^*}&#x27;)</span> ) for some  <span class="math">i^* \\in \\{1,\\ldots,q_v\\}</span> . In other words, the adversary wins if there is no  <span class="math">j \\in \\{1,\\ldots,q\\}</span>  for which  <span class="math">\\mathbf{c}_{i^*}&#x27; = \\mathbf{c}_j, T_{i^*}&#x27; = T_j</span>  and  <span class="math">N_{i^*}&#x27; = N_j</span>  (resp.  <span class="math">\\mathsf{IV}_{i^*}&#x27; = \\mathsf{IV}_j</span> ). We define the adversary's advantage by</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}^{\\mathsf{auth}}_{\\mathsf{AE}[\\mathbb{F}]}(\\mathcal{A}) \\stackrel{\\mathrm{def}}{=} \\Pr \\left[ \\ \\mathbf{k} \\stackrel{\\</span>}{\\leftarrow} \\mathcal{K} : \\mathcal{A}^{\\mathsf{AE-}\\mathcal{E}<em>{\\mathbb{F}},\\mathsf{AE-}\\mathcal{D}</em>{\\mathbb{F}}} \\ \\mathrm{forges} \\ \\right] \\ .$$</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">2.3 MPC Model</h4>

    <p class="text-gray-300">MPC systems ideally support an arbitrary number of players and various collusions of dishonest parties. The most efficient MPC systems of this type, such as BDOZ [BDOZ11], SPDZ [DPSZ12, DKL <span class="math">^+</span> 13], and VIFF [DGKN09], are based on secret sharing and are typified by a number of shared properties and constraints.</p>

    <p class="text-gray-300">The inputs to the computation are elements of a finite field  <span class="math">\\mathbb{F}_p</span> . Those elements x that have to be kept secret are held in secret shared form. To denote that a variable is held in secret shared form we shall write [x]. A variable which is not secret shared will be said to be in the <em>clear</em>. A secret shared value can be turned into a clear value at any point in the computation; such an operation is called an <em>opening</em>.</p>

    <p class="text-gray-300">Computation itself is split between a relatively inefficient pre-processing phase followed by a more efficient online phase. The pre-processing phase is often called the offline phase and is mostly independent of any inputs from the parties; it is mainly tasked with producing shared Beaver triples  <span class="math">([x], [y], [x \\cdot y])</span> . However, the offline phase can also produce other shared data that may depend on persistent user inputs, for instance we will assume that the sharing  <span class="math">[\\mathbf{k}]</span>  of some symmetric primitive's key will be available during the offline phase. Consequently, by producing more complex pre-processed data one can perform more complex operations in the online phase more cheaply. At a minimum, we also assume the pre-processing produces shared random bits [b] where  <span class="math">b \\in \\{0,1\\}</span>  and shared random squares  <span class="math">([r], [r^2])</span>  where  <span class="math">r \\in \\mathbb{F}_p</span> .</p>

    <p class="text-gray-300">To measure the MPC complexity of a function we concentrate on the online phase. The function evaluation will require parties to both perform local computations and to communicate with one another (this holds both for the offline and online phase by the way). The local computation is usually mostly ignored when considering MPC complexity, instead the focus is strongly on the communication. This communication is performed in rounds, where all parties can send as much data to any other party as they wish, based on the information they have received in previous rounds. The two main metrics for the communication are the round complexity and the number of openings (how many</p>

    <p class="text-gray-300">secret shared elements are opened to elements in the clear). Unless the amount of data communicated in a single round floods the network capacity, the round complexity strongly determines the latency required to compute the desired function securely. The number of openings is a strong indicator of throughput as it indicates how much data the network has to accommodate. Openings themselves take one round, but in one round many openings could potentially be performed in parallel.</p>

    <p class="text-gray-300">The main operations over F<em>&lt;sup&gt;p&lt;/sup&gt;</em> are addition and multiplication. Both addition of secret shared values and scalar multiplication by clear values can be performed locally (i.e. without interaction) and are deemed efficient: neither contributes to the number of rounds or openings of the overall computation. On the other hand, multiplication of secret shared values does require a round of interaction between the players: it requires two <em>openings</em>, which can be done in parallel thus consuming one round. Additionally, the multiplication will consume one of the pre-processed Beaver Triples. A value can also be squared by consuming a shared random square; this only requires one opening, yet still takes one round of interaction.</p>

    <p class="text-gray-300">To reduce the number of online rounds when optimizing MPC, the main techniques are moving input-independent computation to the pre-processing stage, parallelizing computations during the online stage, and performing early openings to allow cheaper, subsequent operations on clear instead of shared elements. We will see examples of all three techniques in what follows.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8"><strong>2.4 Two Candidate PRFs for MPC</strong></h3>

    <h4 id="sec-7" class="text-lg font-semibold mt-6"><strong>2.4.1 MiMC</strong></h4>

    <p class="text-gray-300">Minimal multiplicative depth cipher (MiMC) is a cipher which works in both binary and prime fields <a href="#page-27-0">[AGR</a>&lt;sup&gt;+&lt;/sup&gt;16, <a href="#page-29-4">GRR</a>&lt;sup&gt;+&lt;/sup&gt;16], though we will only consider the prime field variant MiMC : F<em>&lt;sup&gt;p&lt;/sup&gt;</em> × F<em>&lt;sup&gt;p&lt;/sup&gt;</em> → F<em>&lt;sup&gt;p&lt;/sup&gt;</em> with <em>p</em> ≡ 2 mod 3. The cipher is a classical iterated Even–Mansour cipher using a simple algebraic round permutation inspired by a cipher by Nyberg and Knudsen <a href="#page-30-5">[NK95]</a>. When incorporating the key addition prior to applying the permutation, the round function is defined by</p>

    <p class="text-gray-300"><span class="math">$F_i(x) = (x + \\mathbf{k} + c_i)^3 ,</span>$</p>

    <p class="text-gray-300">where the <em>c&lt;sup&gt;i&lt;/sup&gt;</em> ∈ F<em>&lt;sup&gt;p&lt;/sup&gt;</em> are randomly chosen round constants that &quot;are fixed once and can be hard-coded into the implementation&quot; <a href="#page-27-0">[AGR</a>&lt;sup&gt;+&lt;/sup&gt;16]. This round function is iterated <em>r</em> times, with a final key addition for whitening purposes:</p>

    <p class="text-gray-300"><span class="math">$F_{\\mathsf{MiMC}}(\\mathbf{k}, x) = (F_{r-1} \\circ F_{r-2} \\circ \\dots \\circ F_0)(x) + \\mathbf{k}</span>$
.</p>

    <p class="text-gray-300">Originally, <em>r</em> = dlog&lt;sup&gt;3&lt;/sup&gt; <em>p</em>e rounds were suggested for security <a href="#page-27-0">[AGR</a>&lt;sup&gt;+&lt;/sup&gt;16, Section 5]. For a prime <em>p</em> of 128 bits this would lead to <em>r</em> = 82 rounds for full keyed-permutation security. However, if the attacker only has access to a limited number <em>n</em> ≤ 2 &lt;sup&gt;115&lt;/sup&gt; of plaintext/ciphertext pairs then the number of rounds can be reduced to <em>r</em> = 73 <a href="#page-27-0">[AGR</a>&lt;sup&gt;+&lt;/sup&gt;16, Section 4.3].</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6"><strong>2.4.2 Legendre Symbol Leg</strong></h4>

    <p class="text-gray-300">In 1988 Damgård proposed the use of the Legendre symbol to yield a PRF with input and output in F<em>&lt;sup&gt;p&lt;/sup&gt;</em> <a href="#page-28-6">[Dam90]</a>. Although at that time there was no security proof that the resulting PRF is secure, several reductions were made later to the decision shifted Legendre symbol (DSLS) problem <a href="#page-30-6">[vDHI03,</a> <a href="#page-28-7">Cv07]</a>.</p>

    <p class="text-gray-300">The PRF Legbit : F<em>&lt;sup&gt;p&lt;/sup&gt;</em> × F ∗ <em>&lt;sup&gt;p&lt;/sup&gt;</em> −→ {0<em>,</em> 1} is initialized with a random key <em>k</em> $ ← F<em>p</em>. To evaluate it on input <em>x</em>, we simply call the Legendre symbol on <em>k</em> + <em>x</em> and normalise the output to be in {0<em>,</em> 1} as opposed to {−1<em>,</em> 1}. It is known that Legbit is a pseudorandom function if there is no probabilistic polynomial time adversary to solve DSLS efficiently [GRR+16].</p>

    <p class="text-gray-300">This function can be extended to produce a field element by selecting a vector of keys  <span class="math">\\mathbf{k} = (k_i) \\in \\mathbb{F}_p^L</span>  and by computing  <span class="math">\\mathrm{Leg}(x) = \\sum_{i=0}^{L-1} 2^i \\cdot \\mathrm{Leg_{bit}}(k_i, x) \\pmod{p}</span> , for some value L. Assuming Leg outputs an unbiased random bit, for general p one still needs to select  <span class="math">L = \\lceil 2 \\cdot \\log_2 p \\rceil</span>  to ensure statistical closeness to the uniform distribution over  <span class="math">\\mathbb{F}_p</span> , however if p is chosen sufficiently close to a power of two then one can relax to  <span class="math">L = \\lceil \\log_2 p \\rceil</span>  [GRR&lt;sup&gt;+&lt;/sup&gt;16].</p>

    <h2 id="sec-9" class="text-2xl font-bold">3 MPC Complexity of MiMC and Leg</h2>

    <p class="text-gray-300">When evaluating a tweakable PRF in an MPC setting, the key will always be secret and the tweak will always be in the clear, but whether the main input and output are held in the clear or are secret shared will depend on the application. Consequently, when optimizing MiMC and Leg we need to make a distinction between four cases, depending on whether the input and/or output is held in the clear or is secret shared. These four variants we will denote by the notation in Figure 4 in subsequent diagrams, with an opening operation denoted by a coloured circle (red denoting a shared data item, and blue a data item held in the clear).</p>

    <p class="text-gray-300">&lt;span id=&quot;page-9-0&quot;&gt;&lt;/span&gt;    <img src="_page_9_Picture_6.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 4: Pictorial notation to define processing of open versus shared data.</p>

    <p class="text-gray-300">In prior work on the MPC evaluation of MiMC and Leg, only the fourth and, for Leg only, the third variant were discussed [GRR&lt;sup&gt;+&lt;/sup&gt;16]. As we will see, the other variants are more useful when defining modes of operation, and they can have a remarkably reduced MPC complexity. Another major consideration is whether one is interested in online times subject to standard pre-processing (in which multiplication triples, random squares and random bits are prepared ahead of time), or whether one is interested in key dependent pre-processing for the specific PRF in question, or even tweak (and key) dependent pre-processing for the specific tweakable PRF in question.</p>

    <p class="text-gray-300">In the tweakable context, we can express the design in a similar pictorial way as in Figure 5. However, the distinction as to whether the actual message is in the clear disappears, as even in this case the input to the second PRF call is made on shared data due to the need to keep the output of the first PRF shared. Thus we really only have two cases to consider for general PRFs, although specific PRFs may have additional optimizations (see below for one such optimization in the case of the Leg PRF).</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">3.1 MiMC in MPC</h4>

    <p class="text-gray-300">Recall the MiMC PRF is defined by</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{E}_{\\mathsf{k}}(x) = F_{\\mathsf{MiMC}}(\\mathbf{k}, x) = (F_{r-1} \\circ F_{r-2} \\circ \\cdots \\circ F_0)(x) + \\mathbf{k}</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$F_i(x) = (x + k + c_i)^3</span>$
.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-10-0&quot;&gt;&lt;/span&gt;    <img src="_page_10_Picture_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 5:</strong> Composing a tweakable PRF from a non-tweakable PRF in the case of clear text message/shared output (resp. clear message and clear output)</p>

    <p class="text-gray-300">Grassi et al. [GRR&lt;sup&gt;+&lt;/sup&gt;16] consider two methods for computing MiMC in an MPC setting: MiMC&lt;sup&gt;basic&lt;/sup&gt; and MiMC&lt;sup&gt;cube&lt;/sup&gt;. Given our focus on online times for latency and throughput, only MiMC&lt;sup&gt;cube&lt;/sup&gt; is of interest to us; henceforth we'll simply call it MiMC.</p>

    <p class="text-gray-300">Using Standard Pre-Processing The computation of  <span class="math">[y] \\leftarrow [x] + [k] + c_i</span>  can always be performed locally, so of interest is the cubing  <span class="math">[y^3]</span> . The standard MPC method to compute MiMC uses a special pre-processed tuple  <span class="math">([v], [v^2], [v^3])</span>  for which  <span class="math">v \\stackrel{\\</span>}{\\leftarrow} \\mathbb{F}_p$ . This pre-processed tuple itself could be computed using squaring and multiplication during the offline phase, or it can be done in the online phase. Given this tuple, to obtain  <span class="math">[y^3]</span>  from [y] we open z = y - v to all parties and then compute locally:</p>

    <p class="text-gray-300"><span class="math">$[y^3] = 3 \\cdot z \\cdot [v^2] + 3 \\cdot z^2 \\cdot [v] + z^3 + [v^3] \\ .</span>$</p>

    <p class="text-gray-300">Assuming the required r tuples  <span class="math">([v], [v^2], [v^3])</span>  have been computed during the offline phase, the online phase reduces to one opening and one communication round per cipher round, for a total of r openings and r communication rounds for full evaluation of the cipher. If the tuple is produced in the online phase then we require  <span class="math">3 \\cdot r</span>  openings and r+1 rounds of communication (as all r tuples can be processed simultaneously). In the case where the output is in the clear we require an additional opening and round.</p>

    <p class="text-gray-300">Using Key Dependent Pre-Processing If the input to MiMC is in the clear then a marginal improvement in performance results from the local evaluation of the first round function  <span class="math">F_0([k],x)=(x+[k]+c_0)^3</span> , where we need the values  <span class="math">([k],[k^2],[k^3])</span>  to be precomputed. As the improvement is only minor over the general method above, we ignore this optimization in what follows.</p>

    <p class="text-gray-300"><strong>Using Tweak Dependent Pre-Processing</strong> When evaluating the tweakable-PRF on a fixed nonce N known at pre-processing time, say N=0 or N=1, we could precompute the value of  <span class="math">[M]=\\mathsf{E}_{[k]}(N)</span> . We treat this case as tweak dependent pre-processing, as opposed to key dependent pre-processing, as it assumes knowledge of the application usage of the PRF at pre-processing time.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">3.2 Leg in MPC</h4>

    <p class="text-gray-300">Recall the Leg PRF is defined by</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{E}_{\\mathsf{k}}(x) = \\mathsf{Leg}(x) = \\sum_{i=0}^{L-1} 2^{i} \\cdot \\mathsf{Leg}_{\\mathsf{bit}}(k_{i}, x) \\pmod{p}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathsf{k} = \\{k_i\\}_{i=0}^{L-1}</span> . When evaluating Leg it suffices to compute the L invocations of  <span class="math">\\mathsf{Leg}_\\mathsf{bit}</span>  in parallel, followed by local computations for the linear combination of the  <span class="math">\\mathsf{Leg}_\\mathsf{bit}</span>  outputs into  <span class="math">\\mathsf{Leg}(x)</span>  (after all, multiplications by public constants and additions can be done locally without any interaction between parties). If the final output of  <span class="math">\\mathsf{Leg}</span>  should be in the clear, then the  <span class="math">\\mathsf{Leg}_\\mathsf{bit}</span>  already may be in the clear (implicitly this observation uses that the indistinguishability of  <span class="math">\\mathsf{Leg}</span>  follows from that of  <span class="math">\\mathsf{Leg}_\\mathsf{bit}</span> ). Thus the MPC complexity of  <span class="math">\\mathsf{Leg}</span>  is equivalent to that of computing  <span class="math">\\mathsf{Leg}_\\mathsf{bit}</span>  in parallel.</p>

    <p class="text-gray-300">Note, we could use a tweak to also define the extra keys needed in the extension of  <span class="math">\\mathsf{Leg}_{\\mathsf{bit}}</span>  to  <span class="math">\\mathsf{Leg}</span> , thus saving storage at the expense of the evaluation of the tweak. Thus the tweakable  <span class="math">\\mathsf{Leg}</span> , would be built out of a tweakable  <span class="math">\\mathsf{Leg}_{\\mathsf{bit}}</span>  with two tweak inputs (one for the domain extension to  <span class="math">\\mathsf{Leg}</span>  and one for the actual tweak on the  <span class="math">\\mathsf{Leg}</span>  function itself).</p>

    <p class="text-gray-300">Using Standard Pre-Processing Grassi et al. [GRR&lt;sup&gt;+&lt;/sup&gt;16] present an efficient method to compute  <span class="math">\\mathsf{Leg_{bit}}</span>  (reproduced in Figure 6) when the input [x] and output [y] are both secret shared. Grassi et al. already observe that the two steps leading up to the computation of u can be pre-processed and that the step following the computation of u can be performed locally. The computation of u itself takes one round (containing two openings) to compute  <span class="math">[t] \\cdot ([k] + [x])</span>  and one to open the result. Thus if a fixed quadratic non-residue  <span class="math">\\alpha</span>  and the data tuples ([b], [t]) are produced during the offline phase, then the online computation of the PRF  <span class="math">\\mathsf{Leg_{bit}}([x])</span>  will require two rounds of communication and three openings. Without the special pre-processed tuples we would require an extra round and two extra openings.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-11-0&quot;&gt;&lt;/span&gt;Let  <span class="math">\\alpha</span>  be a fixed, quadratic non-residue modulo p and [k] the shared secret key.</p>

    <p class="text-gray-300"><strong>Eval:</strong> To evaluate  <span class="math">Leg_{bit}</span>  on input [x] with key [k]:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Take a random square  <span class="math">[s^2]</span>  and a random bit [b] from the offline phase.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">[t] \\leftarrow [s^2] \\cdot ([b] + \\alpha \\cdot (1 [b]))</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">u \\leftarrow \\mathsf{Open}([t] \\cdot ([k] + [x]))</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output  <span class="math">[y] \\leftarrow \\left( \\left( \\frac{u}{p} \\right) \\cdot (2 \\cdot [b] 1) + 1 \\right) / 2</span></li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><strong>Figure 6:</strong> Securely computing the Leg&lt;sub&gt;bit&lt;/sub&gt; PRF with secret-shared input and output (Redacted copy of [GRR&lt;sup&gt;+&lt;/sup&gt;16, Figure 7]).</p>

    <p class="text-gray-300">Grassi et al. additionally suggest an alternative, conceptually easier evaluation when the input is shared but the output should be in the clear: on input [x] take a preprocessed square  <span class="math">[s^2]</span> , evaluate  <span class="math">\\mathsf{Open}([s^2]\\cdot([k]+[x]))</span>  and output the Legendre symbol of the result. This version still requires two rounds of interaction and three openings, but it only consumes standard pre-processed data.</p>

    <p class="text-gray-300">Using Key Dependent Pre-Processing However, the implementation suggestions by Grassi et al. are not the end of the story. We first investigate what happens when the input x is provided in the clear, and we allow key dependent pre-processing.</p>

    <p class="text-gray-300">Our key observation is that if the input x is in the clear, then we can store  <span class="math">([b], [t], [t \\cdot k])</span>  in the offline phase. This allows simplification of Step 3 from Figure 6 to  <span class="math">u \\leftarrow \\mathsf{Open}([t \\cdot k] + x \\cdot [t])</span> , which requires only one round of interaction as multiplication by clear values is free. Step 4 proceeds (locally) as before, leading to a shared output.</p>

    <p class="text-gray-300">If both input and output are in the clear, the product  <span class="math">[s^2 \\cdot k]</span>  can be preprocessed and the only online communication remaining is for  <span class="math">\\mathsf{Open}([s^2 \\cdot k] + x \\cdot [s^2])</span> , namely one round and one opening. The advantage of this method over the one with shared output is a</p>

    <p class="text-gray-300">reduction in the consumption of offline material. However, in our tweakable PRF setting we see this optimization is never used.</p>

    <pre><code class="language-text">Let α be a fixed, quadratic non-residue modulo p and [ki] the shared secret key (for position i)
Preprocess: For each future evaluation prepare tuples as follows:
         1. For j ∈ {1, . . . , L}
                • Take random squares [s
                                              (n)
                                              j
                                                 2
                                                  ] and random bits [b
                                                                          (n)
                                                                          j
                                                                             ].
                • [t
                    (n)
                    j
                       ] ← [s
                              (n)
                              j
                                 2
                                  ] · ([b
                                        (n)
                                        j
                                           ] + α · (1 − [b
                                                          (n)
                                                          j
                                                             ]))
                • [(tk)
                        (n)
                           ] ← [t
                                 (n)
                                    ] · [ki]
</code></pre>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For <em>i</em> ∈ {1<em>, . . . , L</em>}</li>
    </ol>

    <p class="text-gray-300"><em>i</em></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Take random squares [<em>s</em> (<em>x</em>) <em>i</em> 2 ] and random bits [<em>b</em> (<em>x</em>) <em>i</em> ].</li>
      <li>[<em>t</em> (<em>x</em>) <em>i</em> ] ← [<em>s</em> (<em>x</em>) <em>i</em> 2 ] · ([<em>b</em> (<em>x</em>) <em>i</em> ] + <em>α</em> · (1 − [<em>b</em> (<em>x</em>) <em>i</em> ]))</li>
    </ul>

    <p class="text-gray-300"><em>i</em></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>[(<em>tk</em>) (<em>x</em>) <em>i</em> ] ← [<em>t</em> (<em>x</em>) <em>i</em> ] · [<em>ki</em>]</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For <em>i, j</em> ∈ {1<em>, . . . , L</em>}</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>[(<em>tb</em>)<em>ij</em> ] ← [<em>t</em> (<em>x</em>) <em>i</em> ] · [<em>b</em> (<em>n</em>) <em>j</em></li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output all the shares</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">&lt;span id=&quot;page-12-1&quot;&gt;&lt;/span&gt;3. For <em>i</em> ∈ {1<em>, . . . , L</em>}</p>

    <p class="text-gray-300"><strong>Eval:</strong> To evaluate Leg on input [<em>x</em>] with key [<em>k</em>] and tweaks <em>i</em> and <em>N</em>, leading to shared output.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Retrieve a preprocessed tuple.</li>
    </ol></li>
      <li>&lt;span id=&quot;page-12-2&quot;&gt;&lt;/span&gt;2. For <em>i</em> = <em>j</em> ∈ {1<em>, . . . , L</em>} (a) <em>v&lt;sup&gt;j&lt;/sup&gt;</em> ← Open([(<em>tk</em>) (<em>n</em>) <em>j</em> ] + <em>N</em> · [<em>t</em> (<em>n</em>) <em>j</em> ]) (b) [<em>xt</em>(<em>x</em>) <em>i</em> ] ← [<em>x</em>] · [<em>t</em> (<em>x</em>) <em>i</em>    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Locally compute [(<em>tL</em>)<em>i</em>] ← P<em>&lt;sup&gt;L&lt;/sup&gt; &lt;sup&gt;j&lt;/sup&gt;</em>=1 2 <em>j</em>−1 · <em>&lt;sup&gt;v&lt;/sup&gt;&lt;sup&gt;j&lt;/sup&gt; p</em> · (2 · [(<em>tb</em>)<em>ij</em> ] − [<em>t</em> (<em>x</em>) <em>i</em> ]) + [<em>t</em> (<em>x</em>) <em>i</em> ]</li>
      <li><em>u&lt;sup&gt;i&lt;/sup&gt;</em> ← Open([(<em>tk</em>) (<em>x</em>) <em>i</em> ] + [<em>xt</em>(<em>x</em>) <em>i</em> ] + <em>i</em> · [<em>tLi</em>])</li>
      <li>Locally compute [<em>yi</em>] ← <em>ui p</em> · (2 · [<em>b</em> (<em>x</em>) <em>i</em> ] &lt;sup&gt;−&lt;/sup&gt; 1) + 1 <em>/</em>2</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output [<em>y</em>] ← P<em>&lt;sup&gt;L&lt;/sup&gt; &lt;sup&gt;i&lt;/sup&gt;</em>=1 2 <em>i</em>−1 · [<em>yi</em>]</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><strong>Figure 7:</strong> Securely computing the tweakable Leg PRF with shared input, fresh <em>N</em>-tweak, and shared output.</p>

    <p class="text-gray-300"><a href="#page-12-0">Figure 7</a> presents a method to compute Leg as a whole for key dependent pre-processing of the tweakable cipher when presented with a fresh value <em>N</em>. The method presented works for a shared input [<em>x</em>], requiring multiplications in Step <a href="#page-12-1">2b.</a> These can be done in parallel with the openings of Step <a href="#page-12-2">2a,</a> thus for a shared input, the online costs amounts to two rounds of interaction and 3<em>L</em> + 1 openings. If <em>x</em> is clear, then Step <a href="#page-12-1">2b</a> can be performed locally, reducing the total number of openings to <em>L</em> + 1; the number of rounds remains 2.</p>

    <p class="text-gray-300">For more complicated calculations, such as re-use of the same <em>N</em> in a future <em>sequential</em> call to the tweakable PRF, some pipelining might be feasible. For instance, the respective Steps <a href="#page-12-2">2a</a> can still be performed in parallel. However, the gains over a straightforward approach—treating the sequential composition of two tweakable PRF calls as three sequential PRF calls—are not worth the significant increase in consumption of pre-processed data. Whereas standard pre-processing only precomputes <em>O</em>(<em>L</em>) elements, for <a href="#page-12-0">Figure 7</a> we need to pre-process <em>O</em>(<em>L</em> 2 ) elements instead. Due to the high pre-processing cost for</p>

    <p class="text-gray-300">relatively marginal on-line gains, we discard the method of <a href="#page-12-0">Figure 7</a> for the remainder of this paper.</p>

    <p class="text-gray-300"><strong>Using Tweak Dependent Pre-Processing</strong> Recall that we adapted XE-tweaking of the form</p>

    <p class="text-gray-300"><span class="math">$\\widetilde{\\mathsf{E}}_{\\mathsf{k}}^{i,N}(m) = \\mathsf{E}_{\\mathsf{k}}(m + (i \\cdot \\mathsf{E}_{\\mathsf{k}}(N)))</span>$
, for  <span class="math">i \\neq 0</span>  .</p>

    <p class="text-gray-300">Due to the linearity of Leg as a function of Legbit, we are essentially interested in the evaluation of</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Leg}_{\\mathsf{bit}}(m + (i \\cdot \\mathsf{E}_{\\mathsf{k}}(N))) \\ ,</span>$</p>

    <p class="text-gray-300">in a number of scenarios, depending on whether the input <em>m</em>, resp. output, are clear or shared, and whether <em>N</em> is fixed or fresh (we will always assume <em>i</em> to be fresh and in the clear, and <em>N</em> to be in the clear).</p>

    <p class="text-gray-300">For the scenario with a clear input <em>m</em> and a shared output, <a href="#page-13-0">Figure 8</a> presents a method to compute Legbit, when the <em>N</em> part of the tweak is fixed (and hence can be pre-processed). This method requires, in the online phase, only a single round of openings. In the case where <em>m</em> is shared, one can save pre-processing [<em>t</em> · <em>k</em>] and compute the second line of the Evaluation method by <em>u</em> ← Open([<em>t</em>] ·([<em>k</em>] + [<em>m</em>]) + <em>i</em> · [<em>t</em> · <em>M</em>])); which requires an additional round of interaction and an additional two openings.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-13-0&quot;&gt;&lt;/span&gt;Let <em>α</em> be a fixed, quadratic non-residue modulo <em>p</em> and [<em>k</em>] the shared secret key.</p>

    <p class="text-gray-300"><strong>Preprocess:</strong> Assume [<em>M</em>] ← E<a href="*N*">k</a> has already been computed. Then for each future evaluation prepare tuples as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Take a random square [<em>s</em> 2 ] and a random bit [<em>b</em>].</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>[<em>t</em>] ← [<em>s</em> 2 ] · ([<em>b</em>] + <em>α</em> · (1 − [<em>b</em>]))</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>[<em>t</em> · <em>k</em>] ← [<em>t</em>] · [<em>k</em>]</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>[<em>t</em> · <em>M</em>] ← [<em>t</em>] · [<em>M</em>]</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output ([<em>b</em>]<em>,</em> [<em>t</em>]<em>,</em> [<em>t</em> · <em>k</em>]<em>,</em> [<em>t</em> · <em>M</em>])</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><strong>Eval:</strong> To evaluate Legbit on input <em>m</em> with key [<em>k</em>] and tweaks <em>i</em> and <em>N</em>, leading to shared output.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Retrieve a preprocessed tuple ([<em>b</em>]<em>,</em> [<em>t</em> · <em>k</em>]<em>,</em> [<em>t</em> · <em>M</em>])</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>u</em> ← Open([<em>t</em> · <em>k</em>] + <em>m</em> · [<em>t</em>] + <em>i</em> · [<em>t</em> · <em>M</em>]))</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output [<em>y</em>] ← <em>u p</em> · (2 · [<em>b</em>] &lt;sup&gt;−&lt;/sup&gt; 1) + 1 <em>/</em>2</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><strong>Figure 8:</strong> Securely computing the tweakable Legbit PRF with clear input, fixed <em>N</em>-tweak, and shared output.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8"><strong>3.3 Summary</strong></h3>

    <p class="text-gray-300">It is clear the design choices for implementation depend very much on how much specialised pre-processing one wants to perform. In the rest of this paper we restrict ourselves to the case where we allow key-dependent, but not tweak dependent pre-processing. In this context our tweakable PRF this is then produced via our non-tweakable PRF via the methodology given in <a href="#page-10-0">Figure 5.</a> Note, when the message in this diagram is given in the clear, this makes <em>no difference</em> to the execution of the second PRF call, as the input is already in shared form.</p>

    <p class="text-gray-300">In addition, any second call to the tweakable PRF with the same value <em>N</em> in the tweak can be done without the need to call the first PRF again. When the output of the tweakable PRF is to be returned in an open form, the second PRF call can be performed more efficiently in the case of Leg by using the key-dependent pre-processing variant. This leads to the online costs given in <a href="#page-14-0">Table 1.</a></p>

    <p class="text-gray-300">&lt;span id=&quot;page-14-0&quot;&gt;&lt;/span&gt;<strong>Table 1:</strong> Summary of costs for our PRFs MiMC and Leg. The first line for each PRF is the cost of the first such tweakable PRF call, and the second is the cost of subsequent PRF tweakable calls with the same <em>N</em> component in the tweak (clearly their is no second line when we use tweakable pre-processing). The values SP, KP, and TP stand for standard pre-processing, key dependent pre-processing and tweak dependent pre-processing. Note the costs when the input message is in the clear are identical to when the input message is in shared form. The pre-processing costs are given in the number of data items needed to be preduced by the pre-preprocessing.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">i,N&lt;br&gt;Ee&lt;br&gt;k</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">i,N&lt;br&gt;Ee&lt;br&gt;k</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Rnds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Open</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Prep</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Rnds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Open</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Prep</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 · r + 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6 · r</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 · r</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 · r + 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6 · r + 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 · r</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MiMC (SP)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">r</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 · r</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 · r</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">r + 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 · r + 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 · r</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MiMC (TP)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">r</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 · r</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 · r</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">r + 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 · r + 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 · r</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10 · L</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8 · L</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8 · L</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6 · L</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Leg (SP)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5 · L</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 · L</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 · L</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 · L</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 · L</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8 · L</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 · L</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6 · L</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Leg (KP)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 · L</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 · L</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 · L</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 · L</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Leg (TP)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 · L</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 · L</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 · L + 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 · L</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2 id="sec-13" class="text-2xl font-bold"><strong>4 Encrypt-then-MAC in Characteristic</strong> <em>p</em></h2>

    <p class="text-gray-300">In this section we examine an Encrypt-then-MAC paradigm to obtain AE for messages/ciphertexts consisting of vectors in F<em>p</em>. To enable the efficient computation we select a nonce-based IND-CPA encryption mode which is highly parallel (specifically a modification of CTR mode). For the MAC algorithm we present two possibilities, a Hash-then-MAC method (which is suitable as we always MAC clear data), as well as a new MAC algorithm which we call pPMAC. Here pPMAC is the obvious port of PMAC from binary fields to the field F<em>p</em>, where we examine the PMAC proof to ensure that the scheme is still secure.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6"><strong>4.1 Encrypt-then-MAC</strong></h4>

    <p class="text-gray-300">The encrypt-then-MAC paradigm originally applied probabilistic encryption followed by authentication of the resulting ciphertext <a href="#page-28-8">[BN08]</a>. The probabilistic encryption itself only needs to be PRIV or IND-CPA secure. Moving to a nonce-setting is relatively straightforward <a href="#page-30-4">[NRS14]</a>: assuming one has a MAC function, one simply needs to combine a nonce based encryption (E<em>,</em> D) scheme which is just PRIV (i.e. IND-CPA) secure, and then authenticate the nonce and the obtained ciphertext with a tag generated from a secure MAC function MacGen. This composition corresponds to scheme 'N2' as studied by Namprempre et al. <a href="#page-30-4">[NRS14]</a>. This scheme is the only one of the four secure schemes (N1 up to N4) that feeds the ciphertext as opposed to the message to the MAC function. As in our context ciphertext is in the clear whereas messages is shared—and we do not</p>

    <p class="text-gray-300">believe that the slightly increased parallellism allowed by N1's encrypt-and-MAC approach outweighs this advantage—we opted for this N2 mode.</p>

    <p class="text-gray-300">To obtain a nonce based scheme two variants of CTR mode are possible, either</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} c_i \\leftarrow m_i + \\widetilde{\\mathsf{E}}_{\\mathsf{k}}^{1,N}(i) &amp;= m_i + \\mathsf{E}_{\\mathsf{k}}(i + \\mathsf{E}_{\\mathsf{k}}(N))), \\\\ c_i \\leftarrow m_i + \\widetilde{\\mathsf{E}}_{\\mathsf{k}}^{i,1}(N) &amp;= m_i + \\mathsf{E}_{\\mathsf{k}}(N + i \\cdot \\mathsf{E}_{\\mathsf{k}}(1))). \\end{split}</span>$</p>

    <p class="text-gray-300">The latter variants is preferred as  <span class="math">\\mathsf{E}_{\\mathsf{k}}(1)</span>  can be precomputed when allowing key dependent pre-processing; it corresponds to a simplified variant of CTR-in-Tweak [PS16].</p>

    <p class="text-gray-300">To this CTR mode nonce-based IND-CPA encryption we then add authentication via a MAC function. See Figure 9, where we use this CTR mode as the underlying encryption scheme and an arbitrary MAC function. In this figure we present the algorithm, making specific reference to what data is shared and what is open. The reader should note that in decryption we need to perform a secure comparison between the input tag (in the clear), and the computed tag (in shared form). This is easily accomplished, by opening the value  <span class="math">[r] \\cdot ([\\mathsf{Tag&#x27;}] - \\mathsf{Tag})</span> , for a random value r from the pre-processing, and comparing the value to zero.</p>

    <pre><code class="language-text">Given a message [\\mathbf{m}] = [m_1], \\ldots, [m_\\ell] for m_i \\in \\mathbb{F}_p and a pair of keys [\\mathbf{k}] = ([\\mathbf{k}], [\\mathbf{k}&#x27;]) for the PRF \\mathsf{E}_{[\\mathbf{k}]}(\\cdot) we define the AE mode CTR+MAC as:

 \\begin{aligned}
\\mathsf{AE-}\\mathcal{E}_{\\mathbb{F}}([\\mathbf{k}], N, [\\mathbf{m}]) &amp;: &amp; \\mathsf{AE-}\\mathcal{D}_{\\mathbb{F}}([\\mathbf{k}], N, \\mathbf{c}, \\mathsf{Tag}) \\\\
\\mathsf{1:} &amp; \\mathbf{for} \\ i = 1, \\ell \\ \\mathbf{do} \\\\
\\mathsf{2:} &amp; [c_i] \\leftarrow [m_i] + \\left[\\widetilde{\\mathsf{E}}_{\\mathsf{k}}^{i,1}(N)\\right] \\\\
\\mathsf{3:} &amp; \\mathsf{Open} \\ [c_i]. \\\\
\\mathsf{4:} &amp; \\mathsf{c} \\leftarrow c_1, \\ldots, c_\\ell. \\\\
\\mathsf{5:} &amp; \\mathsf{Tag} \\leftarrow \\mathsf{MacGen}([\\mathsf{k}&#x27;], N \\| \\mathbf{c}). \\\\
\\mathsf{6:} &amp; \\mathsf{Return} \\ (\\mathbf{c}, \\mathsf{Tag}). \\end{aligned} \\qquad \\begin{aligned}
\\mathsf{AE-}\\mathcal{D}_{\\mathbb{F}}([\\mathbf{k}], N, \\mathbf{c}, \\mathsf{Tag}) \\\\
\\mathsf{1:} &amp; \\mathsf{for} \\ i = 1, \\ell \\ \\mathbf{do} \\\\
\\mathsf{2:} &amp; [m_i] \\leftarrow c_i - \\left[\\widetilde{\\mathsf{E}}_{\\mathsf{k}}^{i,1}(N)\\right] \\\\
\\mathsf{3:} &amp; [\\mathbf{m}] \\leftarrow [m_1], \\ldots, [m_\\ell]. \\\\
\\mathsf{4:} &amp; [\\mathsf{Tag}&#x27;] \\leftarrow \\mathsf{MacGen}([\\mathsf{k}&#x27;], N \\| \\mathbf{c}). \\\\
\\mathsf{5:} &amp; \\mathsf{if} \\ [\\mathsf{Tag}&#x27;] \\neq \\mathsf{Tag} \\ \\mathsf{then} \\ \\mathsf{return} \\ \\bot. \\\\
\\mathsf{6:} &amp; \\mathsf{Return} \\ [\\mathbf{m}]. \\end{aligned}
</code></pre>

    <p class="text-gray-300">Figure 9: AE mode CTR+MAC in the nonce-based setting</p>

    <h2 id="sec-15" class="text-2xl font-bold">4.2 The PMAC Algorithm over <span class="math">\\mathbb{F}_p</span></h2>

    <p class="text-gray-300">The original PMAC algorithm [BR02] operates (after suitable padding) on elements in the finite field  <span class="math">\\mathbb{F}_{2^n}</span> . The algorithm makes use of various constants, which in the original PMAC are taken to be from a Gray code to enable efficient computation. In addition a &quot;large&quot; constant called Huge is defined, which is equal to 1/x for x being the formal root of the defining polynomial for the field. The tag is produced by utilizing an encryption function defined by  <span class="math">\\mathbb{E}_k(m): \\mathbb{F}_{2^n} \\longrightarrow \\mathbb{F}_{2^n}</span> .</p>

    <p class="text-gray-300">PMAC1 [Rog04] is a conceptually simpler version of PMAC that recasts the masked blockcipher calls as direct, tweakable blockcipher ones instead. This abstraction is especially potent when moving to  <span class="math">\\mathbb{F}_p</span>  and using a tweakable PRF. As we will be using  <span class="math">\\mathbb{F}_p^{\\times}</span>  as tweak space, we can set Huge = p-1 (to be used by the final  <span class="math">\\widetilde{\\mathsf{E}}</span>  call) and use tweak i to process message block  <span class="math">m_i</span> , for  <span class="math">i \\in \\{1, \\ldots, p-2\\}</span> . Hence our  <span class="math">\\mathbb{F}_p</span>  variant of PMAC1, henceforth referred to as pPMAC, takes in a message which is at most p-2 finite field elements long and produces an element of the finite field  <span class="math">\\mathbb{F}_p</span>  as final tag; the precise pPMAC algorithm is given in Figure 10.</p>

    <p class="text-gray-300">While the security of PMAC over  <span class="math">\\mathbb{F}_{2^n}</span>  has achieved ample attention [MM07, DY15, LPSY16], the security for our pPMAC version doesn't seem to follow directly from prior work. Hence we present Theorem 2 to bound an adversary's distinguishing advantage.</p>

    <pre><code class="language-text">The algorithm pPMAC-Gen(k, m) is defined by:

1: Write \\mathbf{m} as \\ell finite field elements m_1, \\ldots, m_\\ell where m_i \\in \\mathbb{F}_p.

2: if \\ell \\geq p then return \\perp.

3: for i = 1, \\ell - 1 do

4: Y_i \\leftarrow \\widetilde{\\mathsf{E}}_k^{i,0}(m_i)

5: \\Sigma \\leftarrow Y_1 + \\cdots + Y_{\\ell-1} + m_\\ell

6: \\mathsf{Tag} \\leftarrow \\widetilde{\\mathsf{E}}_k^{p-1,0}(\\Sigma).
</code></pre>

    <p class="text-gray-300"><strong>Figure 10:</strong> pPMAC in  <span class="math">\\mathbb{F}_p</span></p>

    <p class="text-gray-300">Luckily, the proof is a fairly straightforward adaptation of Rogaway's [Rog04, Section 11], where the use of a tweakable PRF instead of a tweakable blockcipher allows some simplifications and tightening of the bound.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-16-1&quot;&gt;&lt;/span&gt;<strong>Theorem 2.</strong> Let  <span class="math">\\mathcal{A}</span>  be a PRF-adversary against pPMAC making q queries having a total message length of  <span class="math">\\sigma</span>  finite field elements. Then there exists an adversary  <span class="math">\\mathcal{B}</span>  attacking  <span class="math">\\widetilde{\\mathsf{E}}</span>  making at most  <span class="math">\\sigma+q</span>  oracle queries and running in time comparable to that of  <span class="math">\\mathcal{A}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}^{\\mathsf{prf}}_{\\mathsf{pPMAC}[\\widetilde{\\mathsf{E}}]}(\\mathcal{A}) \\leq \\mathsf{Adv}^{\\mathsf{tprf}}_{\\widetilde{\\mathsf{E}}}(\\mathcal{B}) + \\frac{q(q-1)}{2p}.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">G_0</span>  be the original pPMAC game and let  <span class="math">G_1</span>  be the game with the keyed  <span class="math">\\widetilde{\\mathsf{E}}</span>  replaced by an ideal tweakable random function. Let  <span class="math">\\mathcal{B}</span>  be the adversary against  <span class="math">\\widetilde{\\mathsf{E}}</span>  that runs  <span class="math">\\mathcal{A}</span>  and uses its  <span class="math">\\widetilde{\\mathsf{E}}</span>  oracle to evaluate pPMAC for  <span class="math">\\mathcal{A}</span> , then</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\big[\\,\\mathcal{A}^{G_0} \\Rightarrow 1\\,\\big] - \\Pr\\big[\\,\\mathcal{A}^{G_1} \\Rightarrow 1\\,\\big] = \\mathsf{Adv}^{\\mathsf{tprf}}_{\\widetilde{\\mathsf{E}}}(\\mathcal{B}) \\;,</span>$</p>

    <p class="text-gray-300">where the number of  <span class="math">\\widetilde{\\mathsf{E}}</span>  calls induced by  <span class="math">\\mathcal{A}</span> 's queries is at most  <span class="math">\\sigma + q</span>  and  <span class="math">\\mathcal{B}</span> 's overhead otherwise is minimal.</p>

    <p class="text-gray-300">Let  <span class="math">G_2</span>  be the game where bad is set if two inputs cause colliding final  <span class="math">\\widetilde{\\mathbb{E}}</span>  calls (with tweak Huge). As the tweak Huge cannot be used for any other  <span class="math">\\widetilde{\\mathbb{E}}</span>  calls, if no such collisions appear we can replace the tag output by a freshly drawn  <span class="math">\\mathbb{F}_p</span>  elements in  <span class="math">G_2</span> . Then  <span class="math">G_1</span>  and  <span class="math">G_2</span>  are identical until bad. Morever, to analyse the probability that  <span class="math">\\mathcal{A}</span>  sets bad in  <span class="math">G_2</span>  we may restrict without loss of generality to non-adaptive adversaries.</p>

    <p class="text-gray-300">For any given pair of distinct queries, there has to be at least one  <span class="math">\\widetilde{E}</span>  call that is made with distinct inputs (if the messages are identical until the final message block, no collision is possible). For a collision to occur, fix the outputs for all the other message blocks (of this query pair) and one of the distinct message blocks of the colliding pair, then the  <span class="math">\\widetilde{E}</span>  value (for the corresponding distinct input) has to hit a specific value, which happens only with probability 1/p. A union bound over all  <span class="math">\\binom{q}{2}</span>  pairs results in the stated bound.</p>

    <p class="text-gray-300">In an MPC context, we are primarily interested in an implementation where both the message and the tag are available in the clear, as our use case concentrates on the Encrypt-then-MAC setting where pPMAC will be applied on an already opened ciphertext. Figure 11 shows the implications for the underlying tweakable PRF calls, in the key dependent pre-processing setting. Note that the 'N'-tweak is fixed to N=0 which allows preprocessing of  <span class="math">[M]=\\mathsf{E}_{[k]}(0)</span>  as required in each call to  <span class="math">\\widetilde{\\mathsf{E}}_{[k]}^{i,0}(m)</span> . Also, notice that a naive implementation of the tweakable PRF will result that the remaining PRF applications will be on shared inputs even if m itself is clear, courtesy of [M] being shared. When combined with our CTR mode encryption we obtain an AE method given in Figure 12.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-17-0&quot;&gt;&lt;/span&gt;    <img src="_page_17_Picture_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 11:</strong> Implementing pPMAC in MPC for clear inputs and clear outputs. The number of rounds of interaction for the Leg tweakable PRF using key dependent pre-processing are given to the left.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">4.3 Hash-then-MAC</h4>

    <p class="text-gray-300">Whilst having pPMAC as a general MAC function might be useful in some other contexts, in terms of creating a MAC for use in an Encrypt-then-MAC AE scheme the pPMAC function is overkill. A simpler alternative, described in Figure 13 is to simply hash the clear ciphertext values  <span class="math">c_i</span>  and then apply a single invocation of the PRF to the output Note, the tweak N value can be the same for this PRF call, as for the PRF calls in the CTR mode.</p>

    <p class="text-gray-300">One has to convert the output of the hash function function H into an element modulo p, so it can be passed into our PRF. We require that the value passed to the PRF satisfies the collision resistance property. If H is chosen to be a standard hash function such as SHA-256 or SHA-3, then simply truncating the hash value to  <span class="math">\\log_2 p</span>  bits and treating the result as an integer modulo p will suffice.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-18-0&quot;&gt;&lt;/span&gt;    <img src="_page_18_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 12:</strong> CTR+pPMAC Encryption Mode. The number of rounds of interaction for the Leg tweakable PRF using key dependent pre-processing are given to the left.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-18-1&quot;&gt;&lt;/span&gt;    <img src="_page_18_Figure_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 13:</strong> CTR and Hash-then-MAC Encryption Mode The number of rounds of interaction for the Leg tweakable PRF using key dependent pre-processing are given to the left.</p>

    <h2 id="sec-17" class="text-2xl font-bold">5 OTR in Characteristic p</h2>

    <p class="text-gray-300">OTR is a nonce-based AE mode of operation for blockciphers [Min14]. It has a number of advantages that make it eminently suitable for adaptation to an MPC context, in particular its use of the forward direction of the blockcipher only (even for decryption) and its high level of parallellization for both encryption and decryption. The original OTR mode allows the encryption of arbitrary length bitstrings using arbitrary length bitstrings of associated data. In this section we will adapt Minematsu's OTR to encrypt arbitrary vectors of  <span class="math">\\mathbb{F}_p</span>  elements based on a tweakable pseudorandom function, where we discard any associated data. Consequently, much of the complexity of the original OTR, for instance related to padding to some multiple of the blocklength, disappears. Although OTR strictly speaking is a blockcipher mode of operation, Minematsu already presents OTR as a tweakable blockcipher mode of operation instantiated with a specific tweakable blockcipher. Our version of  <span class="math">\\mathbb{F}_p</span>  will be based on this perspective, making use of an  <span class="math">\\mathbb{F}_p</span> tweakable PRF  <span class="math">\\tilde{E}</span>  (which need not need be invertible). The tweaks needed in our  <span class="math">\\mathbb{F}_n</span>  variant are fairly straightforward. This contrasts with a relatively complex tweak schedule in the original OTR to avoid colliding masks over the finite field  <span class="math">\\mathbb{F}_{2^n}</span>  (cf. [BS16]). Finally, in order to present a cleaner implementation we removed the final block switch.</p>

    <pre><code class="language-text">1: Write \\mathbf{m} as \\ell finite field elements m_1, \\dots, m_\\ell

2: if \\ell \\geq p/2 then return \\perp.

3: \\Sigma \\leftarrow 0 where m_i \\in \\mathbb{F}_p.

4: for i = 1, \\lfloor \\ell/2 \\rfloor do

5: c_{2 \\cdot i - 1} \\leftarrow \\widetilde{\\mathsf{E}}_k^{2 \\cdot i - 1, N}(m_{2 \\cdot i - 1}) + m_{2 \\cdot i}

6: c_{2 \\cdot i} \\leftarrow \\widetilde{\\mathsf{E}}_k^{2 \\cdot i, N}(c_{2 \\cdot i - 1}) + m_{2 \\cdot i - 1}

7: \\Sigma \\leftarrow \\Sigma + m_{2 \\cdot i}

8: if \\ell is odd then

9: c_{\\ell} \\leftarrow \\widetilde{\\mathsf{E}}_k^{\\ell, N}(0) + m_{\\ell}

10: \\Sigma \\leftarrow \\Sigma + m_{\\ell}

11: \\mathbf{c} \\leftarrow (c_1, \\dots, c_{\\ell})

12: \\mathsf{Tag} \\leftarrow \\widetilde{\\mathsf{E}}_k^{-\\ell, N}(\\Sigma)

13: return (\\mathbf{c}, \\mathsf{Tag})
</code></pre>

    <p class="text-gray-300"><strong>Figure 14:</strong> The Algorithm OTR-E <span class="math">(N, \\mathbf{m})</span></p>

    <p class="text-gray-300">Our modified construction is presented in Figure 14 and Figure 15: encryption takes the key k as well as a nonce  <span class="math">N \\in \\mathbb{F}_p</span>  and a message  <span class="math">\\mathbf{m} \\in \\mathbb{F}_p^*</span> , producing a ciphertext  <span class="math">\\mathbf{c} \\in \\mathbb{F}_p^*</span>  and a tag Tag  <span class="math">\\in \\mathbb{F}_p</span> , whereas decryption takes the key k as well as  <span class="math">N \\in \\mathbb{F}_p</span> , a ciphertext  <span class="math">\\mathbf{c}</span> , and a tag Tag to produce a message  <span class="math">\\mathbf{m}</span>  (or an invalid ciphertext symbol  <span class="math">\\bot</span> ). Encryption only works for messages with fewer than p/2 elements, with longer messages (and ciphertexts) rejected out of hand.</p>

    <p class="text-gray-300">A diagramatic representation of encryption is given in Figure 16, where we additionally highlight some MPC implementation details. OTR's core encryption component is a two-round Feistel structure, Here one cannot use an output in the clear for the PRF—which would potentially be faster, especially for Leg—as this would be tantamount to using a public string as one-time pad and hence woefully insecure.</p>

    <p class="text-gray-300">Decryption follows in a similar manner, see Figure 17. Note that, as for our previous MAC-then-Encrypt constructions, a secure comparison is needed to process the computed tag in the decryption algorithm.</p>

    <pre><code class="language-text">1: Write c as \\ell finite field elements c_1, \\ldots, c_\\ell where c_i \\in \\mathbb{F}_p.
   2: if \\ell \\geq p/2 then return \\perp.
   3: \\Sigma \\leftarrow 0
   4: for i = 1, \\lfloor \\ell/2 \\rfloor do
                    m_{2\\cdot i-1} \\leftarrow c_{2\\cdot i} - \\widetilde{\\mathsf{E}}_{\\mathsf{k}}^{2\\cdot i,N}(c_{2\\cdot i-1}) \\\\ m_{2\\cdot i} \\leftarrow c_{2\\cdot i-1} - \\widetilde{\\mathsf{E}}_{\\mathsf{k}}^{2\\cdot i-1,N}(m_{2\\cdot i-1})
                     \\Sigma \\leftarrow \\Sigma + m_{2\\cdot i}
   7:
   8: if \\ell is odd then
                     m_{\\ell} \\leftarrow c_{\\ell} - \\widetilde{\\mathsf{E}}_{\\mathsf{k}}^{\\ell,N}(0)
   9:
                     \\Sigma \\leftarrow \\Sigma + m_{\\ell}
 10:
11: \\mathbf{m} \\leftarrow (m_1, \\dots, m_\\ell)
12: \\mathsf{Tag}&#x27; \\leftarrow \\widetilde{\\mathsf{E}}_{\\mathsf{k}}^{-\\ell, N}(\\Sigma)
13: if \\mathsf{Tag}&#x27; = \\mathsf{Tag} then
14:
                     return m
 15: return \\perp
</code></pre>

    <p class="text-gray-300"><strong>Figure 15:</strong> The Algorithm OTR-D <span class="math">(N, \\mathbf{c}, \\mathsf{Tag})</span></p>

    <p class="text-gray-300">&lt;span id=&quot;page-20-1&quot;&gt;&lt;/span&gt;    <img src="_page_20_Figure_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 16:</strong> The OTR encryption mode. On the left hand side we present the number of rounds of interaction of each stage for the Leg PRF, assuming key dependent preprocessing.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">5.1 Security of pOTR</h4>

    <p class="text-gray-300">Minematsu proved that the original (bit-oriented) OTR is a secure AEAD scheme against nonce-respecting adversaries. Our modified  <span class="math">\\mathbb{F}_p</span>  largely inherits the original properties, but for completeness we provide the relevant theorems and proofs below, where we of course draw heavily on Minematsu's work. For OTR's security analysis Minematsu uses an alternative and conceptually cleaner mode, dubbed  <span class="math">\\mathbb{OTR}</span>  [Min14, Fig. 5], that is based on a tweakable n-bit URF. This mode already matches ours a lot closer, as we use a tweakable PRF and the switch from a tweakable PRF to a tweakable URF is standard (incurring precisely the tweakable PRF advantage). We will ignore the parameter  <span class="math">\\tau</span>  (in  <span class="math">\\mathbb{OTR}[\\tau]</span> ) for the length of tags, as it becomes moot in our  <span class="math">\\mathbb{F}_p</span>  setting. Minematsu additionally introduces  <span class="math">\\mathbb{OTR}&#x27;</span> , but in the absence of associated data this mode collapses to  <span class="math">\\mathbb{OTR}</span> . Thus we can safely refer to the security result for  <span class="math">\\mathbb{OTR}&#x27;</span>  [Min14, Theorem 3] and its proof [Min14, Appendix A]. The proof for privacy is essentially unchanged (and still straightforward),</p>

    <p class="text-gray-300">whereas for authenticity we can simplify the proof considerably as there are fewer cases to consider due to our switch from bitstrings to elements of  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300"><strong>Theorem 3.</strong> Let  <span class="math">\\mathcal{A}</span>  be a PRIV adversary against OTR making q queries having a total message length of  <span class="math">\\sigma</span>  finite field elements. Then there exists an adversary  <span class="math">\\mathcal{B}</span>  attacking  <span class="math">\\widetilde{\\mathsf{E}}</span>  making at most  <span class="math">\\sigma+q</span>  oracle queries and running in time comparable to that of  <span class="math">\\mathcal{A}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}^{\\mathsf{priv}}_{\\mathsf{OTR}}(\\mathcal{A}) \\leq \\mathsf{Adv}^{\\mathsf{tprf}}_{\\widetilde{\\mathsf{E}}}(\\mathcal{B})</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> The first, standard step is to substitute the tweakable PRF with its ideal cousin, the tweakable URF, throughout. An adversary  <span class="math">\\mathcal{A}</span>  that could distinguish between these two worlds can be turned into a reduction  <span class="math">\\mathcal{B}</span>  that wins the PRF's security game by explicitly evaluating the OTR construction using a tweakable PRF/URF oracle. A counting exercise will show that  <span class="math">\\mathcal{A}</span> 's queries to the construction induce exactly  <span class="math">\\sigma + q</span>  queries to the underlying tweakable primitive.</p>

    <p class="text-gray-300">With the tweakable URF in place, the key observation is that  <span class="math">\\mathcal{A}</span>  is nonce-respecting and that, for the encryption of a single message, the tweaks count from  <span class="math">1,\\ldots,\\ell</span>  and, as we enforce  <span class="math">\\ell &lt; p/2</span> , the tweak  <span class="math">-\\ell</span>  used for authentication will be distinct from these tweaks (modulo p). Consequently, each tweak (i,N) is used at most once and we can replace the outputs of the tweakable URF with independently and uniformly drawn  <span class="math">\\mathbb{F}_p</span>  elements, ignoring the input. These random  <span class="math">\\mathbb{F}_p</span>  elements act as a one-time pad; inspection shows that all ciphertext elements  <span class="math">c_i</span>  as well as the Tag are thus affected, making them perfectly indistinguishable from independently and uniformly drawn  <span class="math">\\mathbb{F}_p</span>  elements as desired.</p>

    <p class="text-gray-300"><strong>Theorem 4.</strong> Let  <span class="math">\\mathcal{A}</span>  be an AUTH adversary against OTR making  <span class="math">q_e</span>  encryption queries and  <span class="math">q_v</span>  decryption queries, jointly having a total message length of  <span class="math">\\sigma</span>  finite field elements. Then there exists an adversary  <span class="math">\\mathcal{B}</span>  attacking  <span class="math">\\widetilde{\\mathsf{E}}</span>  making at most  <span class="math">\\sigma + q_e + q_v</span>  oracle queries and running in time comparable to that of  <span class="math">\\mathcal{A}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}^{\\mathsf{auth}}_{\\mathsf{OTR}[\\widetilde{\\mathsf{E}}]}(\\mathcal{A}) \\leq \\mathsf{Adv}^{\\mathsf{tprf}}_{\\widetilde{\\mathsf{E}}}(\\mathcal{B}) + 3q_v/p</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Again, the first, standard step is to substitute the tweakable PRF with its ideal cousin, the tweakable URF  <span class="math">\\widetilde{\\mathsf{R}}</span> , throughout, incurring the same term as in the bound above.</p>

    <p class="text-gray-300">With the tweakable URF in place, Minematsu's original security proof consists of a number of steps. Firstly, we only need to consider an adversary making a single forgery attempt using the decryption oracle, so  <span class="math">q_v = 1</span> , and then extend it to an arbitrary number of decryptions using a standard guessing argument [BGM04]. Furthermore, without loss of generality, we may assume that  <span class="math">\\mathcal{A}</span>  makes all its encryption queries before the final decryption query.</p>

    <p class="text-gray-300">We denote the adversary's forgery attempt by  <span class="math">(N&#x27;, \\mathbf{c}&#x27;, \\mathsf{Tag}&#x27;)</span> . For the forgery to be counted, it needs to be fresh, that is  <span class="math">(N&#x27;, \\mathbf{c}&#x27;, \\mathsf{Tag}&#x27;) \\neq (N_j, \\mathbf{c}_j, \\mathsf{Tag}_j)</span>  for all encryption queries  <span class="math">j \\in [1, \\ldots, q]</span> . As for each nonce and ciphertext vector there is one unique valid tag (by inspection of the decryption algorithm), we in fact need that  <span class="math">(N&#x27;, \\mathbf{c}&#x27;) \\neq (N_j \\mathbf{c}_j)</span>  for all j. For the forgery attempt  <span class="math">(N&#x27;, \\mathbf{c}&#x27;)</span> , we will use  <span class="math">\\mathsf{Tag}^*</span>  to denote the unique valid tag corresponding to it, whereas for all internal variables related to  <span class="math">(N&#x27;, \\mathbf{c}&#x27;)</span>  we will use a prime, for instance  <span class="math">m_1&#x27;</span>  for the first tentative message block and  <span class="math">\\Sigma&#x27;</span>  for the unique input (used by decryption) to the tweakable URF that produces  <span class="math">\\mathsf{Tag}^*</span> .</p>

    <p class="text-gray-300">The adversary's advantage is upper bounded by the maximum probability it can find a forgery  <span class="math">(N&#x27;, \\mathbf{c}&#x27;, \\mathsf{Tag}&#x27;)</span>  given an transcript of encryption queries  <span class="math">\\{(N_j, \\mathbf{m}_j, \\mathbf{c}_j, T_j)\\}, j \\in [1, \\ldots, q]</span> . Here the maximum is over all possible transcript and the probability is over the 'residual' randomness of the tweakable URF, that is to sample the tweakable URF on values that are needed to evaluate  <span class="math">\\mathsf{Tag}^*</span>  and have not yet been sampled during the encryption queries. As is customary, at this stage we can restrict to deterministic, computationally unbounded adversaries.</p>

    <p class="text-gray-300">To upper bound this maximum probability  <span class="math">\\mathsf{FP}_{\\mathbf{z}}</span> , we will consider four cases (down from the original's 13): the forgery uses a fresh nonce; the forgery uses a nonce for an encryption query and matches the <em>even</em> message length; the forgery uses a past nonce and matches the <em>odd</em> message length; and finally the forgery uses a past nonce, but using a different message length.</p>

    <p class="text-gray-300">Case 1:  <span class="math">N&#x27; \\neq N_j</span>  for all  <span class="math">j \\in [1, ..., q]</span> .</p>

    <p class="text-gray-300">In this case, during decryption the tweak is fresh and hence the  <span class="math">\\mathsf{Tag}^*</span>  will be an independent, uniformly random value, so the probability that  <span class="math">\\mathsf{Tag}&#x27;</span>  is correct satisfies  <span class="math">\\mathsf{FP}_{\\mathbf{z}} = 1/p</span> .</p>

    <p class="text-gray-300">Case 2:  <span class="math">N&#x27; = N_j</span>  with  <span class="math">|\\mathbf{c}&#x27;| = |\\mathbf{c}_j|</span> , even, for some  <span class="math">j \\in [1, ..., q]</span> .</p>

    <p class="text-gray-300">Let's write  <span class="math">(c&#x27;_1, \\ldots, c&#x27;_\\ell)</span>  for  <span class="math">\\mathbf{c}&#x27;</span>  and  <span class="math">(c_1, \\ldots, c_\\ell)</span>  for  <span class="math">\\mathbf{c}_j</span> , so dropping the j index. As  <span class="math">\\mathbf{c}&#x27; \\neq \\mathbf{c}</span>  we know that for some i it holds that  <span class="math">c&#x27;_i \\neq c_i</span> , where we will concentrate on the largest such i. As  <span class="math">\\ell</span>  is even, all ciphertext blocks come with a 'twin' that is processed as part of the same Feistel structure. Let  <span class="math">h = \\lceil (i+1)/2 \\rceil</span> , then the indices of the two blocks (i.e. i and its twin) are 2h - 1 and 2h. For the remainder of this case analysis, we will deal with this structure only, ignoring whether both of only one (and which) of the ciphertext blocks differ between  <span class="math">\\mathbf{c}&#x27;</span>  and  <span class="math">\\mathbf{c}_j</span> .</p>

    <p class="text-gray-300">Figure 17 provides an overview of how decryption works, where we annotated three special collision events:  <span class="math">e_3</span>  corresponds to the event  <span class="math">\\mathsf{Tag}^* = \\mathsf{Tag}&#x27;</span> ,  <span class="math">e_2</span>  corresponds to the event that  <span class="math">\\Sigma&#x27; = \\Sigma_j</span> , and finally  <span class="math">e_1</span>  corresponds to the event that  <span class="math">m&#x27;_{2 \\cdot h - 1} = m_{2 \\cdot h - 1}</span> . Our overall strategy will be to bound</p>

    <p class="text-gray-300"><span class="math">$FP_{\\mathbf{z}} \\le Pr[e_3] \\le Pr[e_3|\\neg e_2] + Pr[e_2|\\neg e_1] + Pr[e_1]</span>$
,</p>

    <p class="text-gray-300">where all constituent three probabilities turn out to be at most 1/p, so the sum is at most 3/p.</p>

    <p class="text-gray-300">Let's start with  <span class="math">\\Pr[e_3|\\neg e_2]</span> . In this case,  <span class="math">\\mathsf{Tag}^*</span>  is the result of a fresh query  <span class="math">\\widetilde{\\mathsf{R}}^{\\langle \\mathsf{N}, -\\ell \\rangle}(\\Sigma&#x27;)</span> , so the probability that it hits the adversary's  <span class="math">\\mathsf{Tag}&#x27;</span>  is exactly 1/p.</p>

    <p class="text-gray-300">If on the other hand  <span class="math">e_2</span>  occurred, then  <span class="math">\\mathsf{Tag}^* = \\mathsf{Tag}_j</span>  so if the adversary had indeed set  <span class="math">\\mathsf{Tag}&#x27; = \\mathsf{Tag}_j</span> , the forgery attempt will be successful. To bound the probability of  <span class="math">e_2</span>  occurring, we go back to the point where  <span class="math">m&#x27;_{2\\cdot h}</span>  gets added to the checksum. Let's denote with  <span class="math">\\Sigma_{h-1}</span>  the checksum so far (for the j-the query) and with  <span class="math">\\Sigma_h</span>  the checksum after adding  <span class="math">m_{2\\cdot h}</span> , with similar primed notation for the values when running decryption on the forgery attempt. Then  <span class="math">e_2</span>  occurs iff  <span class="math">\\Sigma_h = \\Sigma&#x27;_h</span> .</p>

    <p class="text-gray-300">Tracing through the decryption algorithm (and see Figure 17) tells us that</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} m_{2\\cdot h-1}&#x27; &amp;= c_{2\\cdot h}&#x27; - \\widetilde{\\mathsf{R}}^{\\langle \\mathsf{N}, 2\\cdot \\mathsf{h}\\rangle}(m_{2\\cdot h}&#x27;) \\text{ and} \\\\ m_{2\\cdot h}&#x27; &amp;= c_{2\\cdot h-1}&#x27; - \\widetilde{\\mathsf{R}}^{\\langle \\mathsf{N}, 2\\cdot \\mathsf{h}-1\\rangle}(m_{2\\cdot h-1}&#x27;) \\end{split}</span>$</p>

    <p class="text-gray-300">and therefore that</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\Sigma_h &amp;= \\Sigma_h&#x27; \\\\ \\Sigma_{h-1} + m_{2 \\cdot h} &amp;= \\Sigma_{h-1}&#x27; + m_{2 \\cdot h}&#x27; \\\\ \\Sigma_{h_1} + m_{2 \\cdot h} &amp;= \\Sigma_{h-1}&#x27; + c_{2 \\cdot h-1}&#x27; - \\widetilde{\\mathsf{R}}^{\\langle \\mathsf{N}, 2 \\cdot \\mathsf{h} - 1 \\rangle} (m_{2 \\cdot h-1}&#x27;) \\\\ \\widetilde{\\mathsf{R}}^{\\langle \\mathsf{N}, 2 \\cdot \\mathsf{h} - 1 \\rangle} (m_{2 \\cdot h-1}&#x27;) &amp;= \\Sigma_{h-1}&#x27; - \\Sigma_{h_1} + c_{2 \\cdot h-1}&#x27; - m_{2 \\cdot h} \\end{split}</span>$</p>

    <p class="text-gray-300">If  <span class="math">e_1</span>  didn't occur, the  <span class="math">\\widetilde{\\mathsf{R}}^{\\langle \\mathsf{N}, 2 \\cdot \\mathsf{h} - 1 \\rangle}(m&#x27;_{2&#x27; \\cdot h - 1})</span>  call is fresh, so the probability it hits the value on the right hand side is exactly 1/p.</p>

    <p class="text-gray-300">Finally, we are left with the event  <span class="math">e_1</span> , namely that  <span class="math">m&#x27;_{2\\cdot h-1} = m_{2\\cdot h-1}</span> . Although it is not a given that an adversary will be able to turn this event into a forgery, we are generously granting a win regardless. We will assume that  <span class="math">c&#x27;_{2\\cdot h-1} \\neq c_{2\\cdot h-1}</span> , because otherwise the event  <span class="math">e_1</span>  is not possible (by inspection). Our assumption implies that the  <span class="math">\\widetilde{\\mathsf{R}}^{\\langle \\mathsf{N}, 2\\cdot \\mathsf{h}\\rangle}(c&#x27;_{2\\cdot h-1})</span>  call is fresh, and since it needs to hit a unique value in order for  <span class="math">e_1</span>  to occur,  <span class="math">e_1</span>  happens with probability 1/p.</p>

    <p class="text-gray-300">Case 3:  <span class="math">N&#x27; = N_j</span>  with  <span class="math">|\\mathbf{c}&#x27;| = |\\mathbf{c}_j|</span> , odd, for some  <span class="math">j \\in [1, ..., q]</span> .</p>

    <p class="text-gray-300">As before, we write  <span class="math">(c&#x27;_1, \\ldots, c&#x27;_{\\ell})</span>  for  <span class="math">\\mathbf{c}&#x27;</span>  and  <span class="math">(c_1, \\ldots, c_{\\ell})</span>  for  <span class="math">\\mathbf{c}_j</span> , so dropping the j index. As  <span class="math">\\mathbf{c}&#x27; \\neq \\mathbf{c}</span>  we know that for some i it holds that  <span class="math">c&#x27;_i \\neq c_i</span> , where we will concentrate on the largest such i, where we use a special ordering that makes the final, odd block  <span class="math">(i = \\ell)</span>  the smallest. If, under this ordering,  <span class="math">i &gt; \\ell</span>  there is a difference in one of the blocks used in the Feistel structure and the analysis for  <span class="math">\\ell</span>  even from above applies. Otherwise if  <span class="math">i = \\ell</span> , the <em>only</em> difference occurs for the  <span class="math">\\ell</span> &lt;sup&gt;th&lt;/sup&gt; block, so  <span class="math">c&#x27;_{\\ell} \\neq c_{\\ell}</span> . Observing that</p>

    <p class="text-gray-300"><span class="math">$m&#x27;_{\\ell} = c&#x27;_{\\ell} - \\widetilde{\\mathsf{R}}^{\\langle \\mathsf{N}, \\ell \\rangle}(0)</span>$
and  <span class="math">m_{\\ell} = c_{\\ell} - \\widetilde{\\mathsf{R}}^{\\langle \\mathsf{N}, \\ell \\rangle}(0)</span></p>

    <p class="text-gray-300">we obtain that  <span class="math">m&#x27;_{\\ell}</span>  and  <span class="math">m_{\\ell}</span>  always differ, and as a consequence so will  <span class="math">\\Sigma&#x27;</span>  and  <span class="math">\\Sigma</span> . This means that  <span class="math">\\mathsf{Tag}^* = \\widetilde{\\mathsf{R}}^{\\langle \\mathsf{N}, -\\ell \\rangle}(\\Sigma&#x27;)</span>  is the result of a fresh call, hitting the adversary's  <span class="math">\\mathsf{Tag}&#x27;</span>  with probability exactly 1/p.</p>

    <p class="text-gray-300">Case 4:  <span class="math">N&#x27; = N_j</span>  with  <span class="math">|\\mathbf{c}&#x27;| \\neq |\\mathbf{c}_j|</span>  for some  <span class="math">j \\in [1, ..., q]</span> . The length  <span class="math">\\ell&#x27; = |\\mathbf{c}&#x27;|</span>  is used as part of the tweak for the final  <span class="math">\\widetilde{\\mathsf{R}}</span>  call, as  <span class="math">\\mathsf{Tag}^* = \\widetilde{\\mathsf{R}}^{\\langle \\mathsf{N}, -\\ell&#x27; \\rangle}(\\Sigma&#x27;)</span> . Irrespective of  <span class="math">\\Sigma&#x27;</span> , this  <span class="math">-\\ell&#x27; \\neq -\\ell_j</span>  and therefore the tweak  <span class="math">(N, -\\ell&#x27;)</span>  is fresh and the output  <span class="math">\\mathsf{Tag}^*</span>  is random and independent, hitting the adversary's  <span class="math">\\mathsf{Tag}&#x27;</span>  with probability exactly 1/p.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-23-0&quot;&gt;&lt;/span&gt;Overall we obtain that  <span class="math">\\mathsf{FP}_{\\mathbf{z}} \\leq 3/p</span>  gives an AUTH bound for any number of queries  <span class="math">q_v</span>  greater or equal than one, and so  <span class="math">\\mathsf{Adv}^{\\mathsf{auth}}_{\\mathbb{OTR}}(\\mathcal{A}) \\leq 3q_v/p</span> .</p>

    <p class="text-gray-300">    <img src="_page_23_Picture_9.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 17: The OTR decryption case.</p>

    <h2 id="sec-19" class="text-2xl font-bold">6 Experimental Results</h2>

    <p class="text-gray-300">We consider two measurements latency and throughput, with various message lengths. Latency shows the total time required for a message to be encrypted and authenticated</p>

    <p class="text-gray-300">whereas throughput gives the maximum number of executions which can be done in parallel. The experiments were ran between two machines each with Intel i7-4790 CPUs running at 3.60GHz, 16GB of RAM connected through a LAN network of 1Gbps with an average ping of 0.3ms (roundtrip) and implemented using the SPDZ software&lt;sup&gt;2&lt;/sup&gt;. WAN experiments were simulated using Linux tc tool with an average ping latency of 100ms (roundtrip). To give precise timings, each experiment was averaged with at least 5 executions where each execution authenticated at least 1000 messages. We choose to exclude the times in the online phase for computing the key dependent pre-processing such as  <span class="math">\\mathsf{E}_{\\mathsf{k}}(0)</span>  or  <span class="math">\\mathsf{E}_{\\mathsf{k}}(1)</span>  since this is done just once before the start of authentication.</p>

    <p class="text-gray-300">Table 2 contains the preprocessing costs for encryption (similar costs apply for decryption). For this we counted the number of triples and bits required to evaluate each mode of operation instantiated with different PRF's, these costs are given in terms of the message length  <span class="math">\\ell</span> ; i.e. the number of finite field elements being encrypted. For Leg we assume a finite field size of  <span class="math">p\\approx 2^{128}</span> , where p is chosen such that we can select L=128 in the construction of the Leg PRF. The amount of data sent per party and computational cost is estimated, in the table, using the currently best-known method for producing triples and bits in  <span class="math">\\mathbb{F}_p</span>  with active security [KOS16]. According to [KOS16] bits and triples have the same cost in arithmetic circuits  <span class="math">\\mathbb{F}_p</span>  so we merge the costs into one column which is called Triples. As expected, OTR has a lower preprocessing cost, than using CTR+pPMAC, since the number of PRF calls is reduced by half compared to pPMAC. Whilst CTR+HtMAC is slightly better than OTR in terms of pre-processing costs.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-24-1&quot;&gt;&lt;/span&gt;<strong>Table 2:</strong> Preprocessing costs for Encryption using OTR, CTR+pPMAC, and CTR+Hash-then-MAC (HtMAC) in MPC for an  <span class="math">\\ell</span>  length message.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">PRF</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Mode</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Triples</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Leg</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CTR+pPMAC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1024 \\cdot \\ell - 256</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MiMC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CTR+pPMAC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">292\\cdot\\ell</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Leg</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CTR+HtMAC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">512 \\cdot \\ell + 128</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MiMC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CTR+HtMAC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">146 \\cdot \\ell + 146</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Leg</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">OTR</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">512 \\cdot \\ell + 728</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MiMC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">OTR</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">146 \\cdot \\ell + 292</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-24-2&quot;&gt;&lt;/span&gt;<strong>Table 3:</strong> Preprocessing cost (MBytes) and throughput (seconds) for encrypting message blocks of size  <span class="math">\\ell</span> , with two parties over a LAN and a simulated WAN network using CTR+HtMAC and MASCOT [KOS16].</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">PRF</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\ell = 1</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">2</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">4</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">8</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">16</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">32</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MBytes&lt;br&gt;per party</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">{</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Leg&lt;br&gt;MiMC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14.42&lt;br&gt;6.58</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25.95&lt;br&gt;9.87</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49.02&lt;br&gt;16.45</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">95.16&lt;br&gt;29.60</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">187.43&lt;br&gt;55.91</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">371.98&lt;br&gt;108.54</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">LAN Throughput&lt;br&gt;per second</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">{</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Leg&lt;br&gt;MiMC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.57&lt;br&gt;16.58</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.20&lt;br&gt;11.05</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.23&lt;br&gt;6.63</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.15&lt;br&gt;3.68</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">0.58 \\\\ 1.95</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.29&lt;br&gt;1.00</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">WAN Throughput&lt;br&gt;per second</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">{</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Leg&lt;br&gt;MiMC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.38&lt;br&gt;0.82</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">0.21 \\\\ 0.55</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.11&lt;br&gt;0.33</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">0.06 \\\\ 0.18</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.03&lt;br&gt;0.10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.01&lt;br&gt;0.05</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">For the case of CTR and Hash-then-MAC in Table 3 we give what these offline estimates would translate into in terms of MBytes of communication per party and throughput per</p>

    <p class="text-gray-300">&lt;span id=&quot;page-24-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;2&lt;/sup&gt;https://github.com/bristolcrypto/SPDZ-2</p>

    <p class="text-gray-300">second, for varying values of the number of message blocks <em>\`</em> for a LAN and WAN setting. These numbers are derived from the estimates in the MASCOT paper <a href="#page-29-11">[KOS16]</a>, which is currently the most efficient offline processing step for engines such as SPDZ. In <a href="#page-25-0">Table 4</a> we present our results for the online phase, in terms of latency and throughput for CTR and Hash-then-MAC, in the LAN and WAN setting.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-25-0&quot;&gt;&lt;/span&gt;<strong>Table 4:</strong> Online phase latency (ms) and best throughput (seconds) for encrypting message blocks of size <em>\`</em>, with two parties over a LAN and a simulated WAN network, using CTR+HtMAC.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">PRF</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">\` = 1</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">2</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">4</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">8</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">16</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">32</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">LAN Latency</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Leg</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.97</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.75</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.61</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15.68</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(ms)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MiMC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.63</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13.27</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13.42</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13.74</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14.25</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15.35</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">WAN Latency</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Leg</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">154</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">258</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">262</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">274</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">295</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(ms)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MiMC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3760</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7521</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7521</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7521</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7521</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7523</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">LAN Throughput</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Leg</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1389</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">895</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">527</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">285</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">149</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">76</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">per second</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MiMC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8853</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5697</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3589</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2010</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1079</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">561</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">WAN Throughput</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Leg</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">151</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">100</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">59</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">33</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">per second</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MiMC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">428</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">203</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">127</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">74</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">In <a href="#page-25-1">Table 5</a> we present the online costs, as a function of *<code>* for our various constructions. For each variant we give the number of rounds and the number of openings. As we have selected highly parallel modes of operation, the round complexity does not depend on the message length. Intuitively, the online round complexity should define the latency of a protocol and the online opening complexity should define the throughput. However, due to the nature of actual physical networks we expect that as soon as we reach the maximum capacity of the network, in terms of data sent (i.e. openings) per round, the latency will drop off rapidly. Thus as *</code>* increases we expect to see an increase in latency, despite latency &quot;theoretically&quot; being a constant. The key question is then how big does *<code>* need to be before the latency for a specific PRF and mode decreases linearly in *</code>*?</p>

    <p class="text-gray-300"><strong>Table 5:</strong> Online Costs for OTR and CTR+pPMAC in MPC.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-25-1&quot;&gt;&lt;/span&gt;</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">PRF</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Mode</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Online cost</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Rounds (Enc/Dec)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Openings</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Leg</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CTR+pPMAC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7/6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">768 · <code>+</code></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MiMC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CTR+pPMAC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">221/147</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">146 · <code>+</code> + 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Leg</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CTR+HtMAC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5/4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">384 · (<code>+ 1) +</code></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MiMC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CTR+HtMAC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">148/75</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">73 · (<code>+ 1) +</code> + 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Leg</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">OTR</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6/9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">384 · (<code>+ 128) +</code></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MiMC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">OTR</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">220/295</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">73 · (<code>+ 2) +</code> + 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">To investigate this potential drop off in latency we carried out experiments in the LAN setting, the results of which are detailed in <a href="#page-26-0">Figure 18</a> (for small messages) and <a href="#page-26-1">Figure 19</a> (for long messages for the MiMC PRF). We see that despite ciphers based on the Leg PRF having lower round complexity, this does not translate into low latency as soon as the size of *<code>* increases. For small values of *</code>* we do benefit from using Leg, but not for larger values. This is because we reach network capacity for only a few parallel calls to Leg; as evaluting the PRF itself takes up a lot of network capacity. On the other hand</p>

    <p class="text-gray-300">&lt;span id=&quot;page-26-0&quot;&gt;&lt;/span&gt;with MiMC we require more rounds, but in each round we need to send much less data, so even as <em>\`</em> increases the latency does not increase that much. Eventually we see that for large messages MiMC ends up having the same growth as we experience with Leg for smaller messages.</p>

    <p class="text-gray-300">    <img src="_page_26_Figure_3.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 18:</strong> Latency of Encryption for OTR vs CTR+pPMAC vs CTR+Hash-then-MAC with MiMC and Leg. In this and in other figures in this section: OTR is marked in blue, CTR+pMAC is marked in red, and CTR+Hash-then-MAC is marked in Green. Use of the Leg PRF is marked with a dot on the line, and use of the MiMC PRF is marked with a cross.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-26-1&quot;&gt;&lt;/span&gt;    <img src="_page_26_Figure_5.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 19:</strong> Latency of Encryption for OTR vs CTR+pPMAC vs CTR+HtMAC with MiMC, for large message sizes.</p>

    <p class="text-gray-300">In <a href="#page-27-2">Figure 20</a> and <a href="#page-27-3">Figure 21</a> we examine throughput for both Leg and MiMC in the LAN setting. Not surprisingly for all options throughput decreases as <em>\`</em> increases, and we get a better throughput if we select MiMC and use the CTR+HtMAC cipher. Indeed contrary to the conclusion in <a href="#page-29-4">[GRR</a>&lt;sup&gt;+&lt;/sup&gt;16] we conclude that MiMC is better than Leg for both throughput and latency. The primary reason for this conclusion is that, unlike the</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-2&quot;&gt;&lt;/span&gt;work in <a href="#page-29-4">[GRR</a>&lt;sup&gt;+&lt;/sup&gt;16], we consider how these MPC-friendly PRFs work in a larger application and not in isolation.</p>

    <p class="text-gray-300">    <img src="_page_27_Figure_3.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-3&quot;&gt;&lt;/span&gt;<strong>Figure 20:</strong> Throughput of OTR vs CTR+pPMAC vs CTR+HtMAC with MiMC and Leg</p>

    <p class="text-gray-300">    <img src="_page_27_Figure_5.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 21:</strong> Throughput of OTR vs CTR+pPMAC vs CTR+HtMAC with MiMC and Leg</p>

    <h2 id="sec-20" class="text-2xl font-bold"><strong>References</strong></h2>

    <p class="text-gray-300">&lt;span id=&quot;page-27-0&quot;&gt;&lt;/span&gt;[AGR&lt;sup&gt;+&lt;/sup&gt;16] Martin R. Albrecht, Lorenzo Grassi, Christian Rechberger, Arnab Roy, and Tyge Tiessen. MiMC: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. In Jung Hee Cheon and Tsuyoshi Takagi, editors, <em>ASIACRYPT 2016, Part I</em>, volume 10031 of <em>LNCS</em>, pages 191–219. Springer, Heidelberg, December 2016.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-1&quot;&gt;&lt;/span&gt;[ARS&lt;sup&gt;+&lt;/sup&gt;15] Martin R. Albrecht, Christian Rechberger, Thomas Schneider, Tyge Tiessen, and Michael Zohner. Ciphers for MPC and FHE. In Elisabeth Oswald and</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">Marc Fischlin, editors, <em>EUROCRYPT 2015, Part I</em>, volume 9056 of <em>LNCS</em>, pages 430–454. Springer, Heidelberg, April 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-0&quot;&gt;&lt;/span&gt;[BCG&lt;sup&gt;+&lt;/sup&gt;12] Julia Borghoff, Anne Canteaut, Tim Güneysu, Elif Bilge Kavun, Miroslav Knežević, Lars R. Knudsen, Gregor Leander, Ventzislav Nikov, Christof Paar, Christian Rechberger, Peter Rombouts, Søren S. Thomsen, and Tolga Yalçin. PRINCE - A low-latency block cipher for pervasive computing applications - extended abstract. In Xiaoyun Wang and Kazue Sako, editors, <em>ASIACRYPT 2012</em>, volume 7658 of <em>LNCS</em>, pages 208–225. Springer, Heidelberg, December 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-2&quot;&gt;&lt;/span&gt;[BDOZ11] Rikke Bendlin, Ivan Damgård, Claudio Orlandi, and Sarah Zakarias. Semihomomorphic encryption and multiparty computation. In Kenneth G. Paterson, editor, <em>EUROCRYPT 2011</em>, volume 6632 of <em>LNCS</em>, pages 169–188. Springer, Heidelberg, May 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-10&quot;&gt;&lt;/span&gt;[BGM04] Mihir Bellare, Oded Goldreich, and Anton Mityagin. The power of verification queries in message authentication and authenticated encryption. Cryptology ePrint Archive, Report 2004/309, 2004. <a href="http://eprint.iacr.org/2004/309">http://eprint.iacr.org/2004/309</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-8&quot;&gt;&lt;/span&gt;[BN08] Mihir Bellare and Chanathip Namprempre. Authenticated encryption: Relations among notions and analysis of the generic composition paradigm. <em>Journal of Cryptology</em>, 21(4):469–491, October 2008.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-4&quot;&gt;&lt;/span&gt;[BR02] John Black and Phillip Rogaway. A block-cipher mode of operation for parallelizable message authentication. In <em>International Conference on the Theory and Applications of Cryptographic Techniques</em>, pages 384–397. Springer, 2002.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-9&quot;&gt;&lt;/span&gt;[BS16] Raphael Bost and Olivier Sanders. Trick or tweak: On the (in)security of OTR's tweaks. In Jung Hee Cheon and Tsuyoshi Takagi, editors, <em>ASIACRYPT 2016, Part I</em>, volume 10031 of <em>LNCS</em>, pages 333–353. Springer, Heidelberg, December 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-5&quot;&gt;&lt;/span&gt;[CCF&lt;sup&gt;+&lt;/sup&gt;16] Anne Canteaut, Sergiu Carpov, Caroline Fontaine, Tancrède Lepoint, María Naya-Plasencia, Pascal Paillier, and Renaud Sirdey. Stream ciphers: A practical solution for efficient homomorphic-ciphertext compression. In Thomas Peyrin, editor, <em>FSE 2016</em>, volume 9783 of <em>LNCS</em>, pages 313–333. Springer, Heidelberg, March 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-7&quot;&gt;&lt;/span&gt;[Cv07] Andrew M. Childs and Wim van Dam. Quantum algorithm for a generalized hidden shift problem. In Nikhil Bansal, Kirk Pruhs, and Clifford Stein, editors, <em>18th SODA</em>, pages 1225–1232. ACM-SIAM, January 2007.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-6&quot;&gt;&lt;/span&gt;[Dam90] Ivan Damgård. On the randomness of legendre and jacobi sequences. In Shafi Goldwasser, editor, <em>CRYPTO'88</em>, volume 403 of <em>LNCS</em>, pages 163–172. Springer, Heidelberg, August 1990.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-3&quot;&gt;&lt;/span&gt;[DGKN09] Ivan Damgård, Martin Geisler, Mikkel Krøigaard, and Jesper Buus Nielsen. Asynchronous multiparty computation: Theory and implementation. In Stanislaw Jarecki and Gene Tsudik, editors, <em>PKC 2009</em>, volume 5443 of <em>LNCS</em>, pages 160–179. Springer, Heidelberg, March 2009.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-1&quot;&gt;&lt;/span&gt;[DK10] Ivan Damgård and Marcel Keller. Secure multiparty AES. In Radu Sion, editor, <em>FC 2010</em>, volume 6052 of <em>LNCS</em>, pages 367–374. Springer, Heidelberg, January 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-29-2&quot;&gt;&lt;/span&gt;[DKL&lt;sup&gt;+&lt;/sup&gt;12] Ivan Damgård, Marcel Keller, Enrique Larraia, Christian Miles, and Nigel P. Smart. Implementing AES via an actively/covertly secure dishonest-majority MPC protocol. In Ivan Visconti and Roberto De Prisco, editors, <em>SCN 12</em>, volume 7485 of <em>LNCS</em>, pages 241–263. Springer, Heidelberg, September 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-29-6&quot;&gt;&lt;/span&gt;[DKL&lt;sup&gt;+&lt;/sup&gt;13] Ivan Damgård, Marcel Keller, Enrique Larraia, Valerio Pastro, Peter Scholl, and Nigel P. Smart. Practical covertly secure MPC for dishonest majority or: Breaking the SPDZ limits. In Jason Crampton, Sushil Jajodia, and Keith Mayes, editors, <em>ESORICS 2013</em>, volume 8134 of <em>LNCS</em>, pages 1–18. Springer, Heidelberg, September 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-29-8&quot;&gt;&lt;/span&gt;[DLR16] Sébastien Duval, Virginie Lallemand, and Yann Rotella. Cryptanalysis of the FLIP family of stream ciphers. In Matthew Robshaw and Jonathan Katz, editors, <em>CRYPTO 2016, Part I</em>, volume 9814 of <em>LNCS</em>, pages 457–475. Springer, Heidelberg, August 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-29-1&quot;&gt;&lt;/span&gt;[DPAR00] J. Daemen, M. Peeters, G. Van Assche, and V. Rijmen. Nessie Proposal: Noekeon, 2000.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-29-5&quot;&gt;&lt;/span&gt;[DPSZ12] Ivan Damgård, Valerio Pastro, Nigel P. Smart, and Sarah Zakarias. Multiparty computation from somewhat homomorphic encryption. In Reihaneh Safavi-Naini and Ran Canetti, editors, <em>CRYPTO 2012</em>, volume 7417 of <em>LNCS</em>, pages 643–662. Springer, Heidelberg, August 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-29-9&quot;&gt;&lt;/span&gt;[DY15] Nilanjan Datta and Kan Yasuda. Generalizing PMAC under weaker assumptions. In Ernest Foo and Douglas Stebila, editors, <em>ACISP 15</em>, volume 9144 of <em>LNCS</em>, pages 433–450. Springer, Heidelberg, June / July 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-29-4&quot;&gt;&lt;/span&gt;[GRR&lt;sup&gt;+&lt;/sup&gt;16] Lorenzo Grassi, Christian Rechberger, Dragos Rotaru, Peter Scholl, and Nigel P. Smart. MPC-friendly symmetric key primitives. In Edgar R. Weippl, Stefan Katzenbeisser, Christopher Kruegel, Andrew C. Myers, and Shai Halevi, editors, <em>ACM CCS 16</em>, pages 430–443. ACM Press, October 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-29-11&quot;&gt;&lt;/span&gt;[KOS16] Marcel Keller, Emmanuela Orsini, and Peter Scholl. MASCOT: Faster malicious arithmetic secure computation with oblivious transfer. In Edgar R. Weippl, Stefan Katzenbeisser, Christopher Kruegel, Andrew C. Myers, and Shai Halevi, editors, <em>ACM CCS 16</em>, pages 830–842. ACM Press, October 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-29-0&quot;&gt;&lt;/span&gt;[LK06] Chae Hoon Lim and Tymur Korkishko. mCrypton - a lightweight block cipher for security of low-cost RFID tags and sensors. In Jooseok Song, Taekyoung Kwon, and Moti Yung, editors, <em>WISA 05</em>, volume 3786 of <em>LNCS</em>, pages 243–258. Springer, Heidelberg, August 2006.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-29-10&quot;&gt;&lt;/span&gt;[LPSY16] Atul Luykx, Bart Preneel, Alan Szepieniec, and Kan Yasuda. On the influence of message length in PMAC's security bounds. In Marc Fischlin and Jean-Sébastien Coron, editors, <em>EUROCRYPT 2016, Part I</em>, volume 9665 of <em>LNCS</em>, pages 596–621. Springer, Heidelberg, May 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-29-3&quot;&gt;&lt;/span&gt;[LR15] Yehuda Lindell and Ben Riva. Blazing fast 2PC in the offline/online setting with security for malicious adversaries. In Indrajit Ray, Ninghui Li, and Christopher Kruegel:, editors, <em>ACM CCS 15</em>, pages 579–590. ACM Press, October 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-29-7&quot;&gt;&lt;/span&gt;[Min14] Kazuhiko Minematsu. Parallelizable rate-1 authenticated encryption from pseudorandom functions. In Phong Q. Nguyen and Elisabeth Oswald, editors, <em>EUROCRYPT 2014</em>, volume 8441 of <em>LNCS</em>, pages 275–292. Springer, Heidelberg, May 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-30-3&quot;&gt;&lt;/span&gt;[MJSC16] Pierrick Méaux, Anthony Journault, François-Xavier Standaert, and Claude Carlet. Towards stream ciphers for efficient FHE with low-noise ciphertexts. In Marc Fischlin and Jean-Sébastien Coron, editors, <em>EUROCRYPT 2016, Part I</em>, volume 9665 of <em>LNCS</em>, pages 311–343. Springer, Heidelberg, May 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-30-8&quot;&gt;&lt;/span&gt;[MM07] Kazuhiko Minematsu and Toshiyasu Matsushima. New bounds for PMAC, TMAC, and XCBC. In Alex Biryukov, editor, <em>FSE 2007</em>, volume 4593 of <em>LNCS</em>, pages 434–451. Springer, Heidelberg, March 2007.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-30-5&quot;&gt;&lt;/span&gt;[NK95] Kaisa Nyberg and Lars R. Knudsen. Provable security against a differential attack. <em>Journal of Cryptology</em>, 8(1):27–37, 1995.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-30-1&quot;&gt;&lt;/span&gt;[NNOB12] Jesper Buus Nielsen, Peter Sebastian Nordholt, Claudio Orlandi, and Sai Sheshank Burra. A new approach to practical active-secure two-party computation. In Reihaneh Safavi-Naini and Ran Canetti, editors, <em>CRYPTO 2012</em>, volume 7417 of <em>LNCS</em>, pages 681–700. Springer, Heidelberg, August 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-30-4&quot;&gt;&lt;/span&gt;[NRS14] Chanathip Namprempre, Phillip Rogaway, and Thomas Shrimpton. Reconsidering generic composition. In Phong Q. Nguyen and Elisabeth Oswald, editors, <em>EUROCRYPT 2014</em>, volume 8441 of <em>LNCS</em>, pages 257–274. Springer, Heidelberg, May 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-30-7&quot;&gt;&lt;/span&gt;[PS16] Thomas Peyrin and Yannick Seurin. Counter-in-tweak: Authenticated encryption modes for tweakable block ciphers. In Matthew Robshaw and Jonathan Katz, editors, <em>CRYPTO 2016, Part I</em>, volume 9814 of <em>LNCS</em>, pages 33–63. Springer, Heidelberg, August 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-30-0&quot;&gt;&lt;/span&gt;[PSSW09] Benny Pinkas, Thomas Schneider, Nigel P. Smart, and Stephen C. Williams. Secure two-party computation is practical. In Mitsuru Matsui, editor, <em>ASI-ACRYPT 2009</em>, volume 5912 of <em>LNCS</em>, pages 250–267. Springer, Heidelberg, December 2009.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-30-2&quot;&gt;&lt;/span&gt;[Rog04] Phillip Rogaway. Efficient instantiations of tweakable blockciphers and refinements to modes OCB and PMAC. In Pil Joong Lee, editor, <em>ASIACRYPT 2004</em>, volume 3329 of <em>LNCS</em>, pages 16–31. Springer, Heidelberg, December 2004.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-30-6&quot;&gt;&lt;/span&gt;[vDHI03] Wim van Dam, Sean Hallgren, and Lawrence Ip. Quantum algorithms for some hidden shift problems. In <em>14th SODA</em>, pages 489–498. ACM-SIAM, January 2003.</p></li>
    </ul>

`;
---

<BaseLayout title="**Modes of Operation Suitable for Computing on Encrypted Dat... (2017/496)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/496
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="modes-of-operation-suitable-for-computing-on-encrypted-data-2017" />
  </article>
</BaseLayout>
