---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/582';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'ethSTARK Documentation';
const AUTHORS_HTML = 'Eli Ben-Sasson';

const CONTENT = `    <p class="text-gray-300">Page 1</p>

    <p class="text-gray-300">Eli Ben-Sasson David Levit</p>

    <p class="text-gray-300">Dan Brownstein Dori Medini</p>

    <p class="text-gray-300">Dan Carmon Alon Shtaierman</p>

    <p class="text-gray-300">Lior Goldberg Eylon Yogev</p>

    <p class="text-gray-300">July, 2023</p>

    <h2 id="sec-2" class="text-2xl font-bold">Abstract</h2>

    <p class="text-gray-300">This document is intended to accompany the ethSTARK codebase, describing the computational integrity statement proved by that code and the specific STARK construction used to prove the statement.</p>

    <p class="text-gray-300"><em>StarkWare Industries Ltd., Israel. The author list refers to those who contributed to the writeup, whereas the associated code is the product of all team members of StarkWare Industries Ltd. Send inquiries to info@starkware.co.</em></p>

    <p class="text-gray-300">STARKWARE</p>

    <p class="text-gray-300">1 Introduction 4 2 Rescue 4 2.1 Rescue Cipher 5 2.2 Rescue Hash Function 5 3 The STARK Protocol 7 3.1 The Trace 7 3.2 Periodic Columns 8 3.3 The Constraints 10 3.3.1 Intermediate Values 10 3.3.2 The Rescue Constraints 11 3.3.3 From Polynomial Constraints to Low Degree Testing Problem 14 3.4 Trace Low Degree Extension 14 3.5 Commitment Scheme 15 3.6 Composition Polynomial 15 3.6.1 Degree Adjustment 15 3.6.2 Combining the Constraints 16 3.6.3 Committing to the Composition Polynomial 16 3.7 Consistency Check on a Random Point (the DEEP Method) 16 3.8 The DEEP Composition Polynomial 17 3.8.1 Verifying the Mask Values 17 3.8.2 Verifying the Trace Values 18 3.9 The FRI Protocol for Low Degree Testing 18 3.9.1 Commit Phase 19 3.9.2 Query Phase 19 3.10 Transformation to Non-Interactive Protocol (the Fiat-Shamir heuristic) 20 3.11 Proof Length Optimizations 20 3.11.1 Skipping FRI Layers 20 3.11.2 FRI Last Layer 20 3.11.3 Grinding 21 4 Measurements and Benchmarks 21 4.1 Prover/Verifier Time and Proof Size vs. Number of Hash Invocations 21 4.2 Prover/Verifier Time and Proof Size vs. Blowup Factor 22 4.3 Memory Consumption and Recursive Proof Composition 23 5 Provable Knowledge Soundness and Security in the IOP Model 24 5.1 Satisfiable Algebraic Intermediate Representations (AIRs) 25 5.2 Soundness, knowledge soundness and security 26 5.3 The IOP Protocol 27 5.4 Prior results needed for the analysis 30 5.5 The Knowledge Extractor 31 5.6 Upper bound on knowledge soundness error 32</p>

    <p class="text-gray-300">STARKWARE</p>

    <p class="text-gray-300">Page 3</p>

    <p class="text-gray-300">5.7 Proof of Theorem 4 34 5.8 Proofs of Lemmas 35 5.8.1 Proof of Lemma 2 36 5.8.2 Proof of Lemma 3 36 5.8.3 Proof of Lemma 4 37 5.9 Security 38 5.9.1 IOP Toy Problem 38 5.10 Parameter settings 39 5.10.1 Suggested IOP Parameter Settings based on Conjectured Soundness 40 5.10.2 Suggested IOP Parameter Settings based on Provable IOP Knowledge Soundness 40</p>

    <p class="text-gray-300">6 Provable Round-by-Round Soundness 41 6.1 Definition of Vector Round-by-Round Soundness 41 6.2 Round-by-Round Soundness Analysis 42 6.3 Grinding 47</p>

    <p class="text-gray-300">7 STARK security 48 7.1 Non-interactive random-oracle arguments 48 7.1.1 Suggested Parameter based on Provable Soundness 50</p>

    <p class="text-gray-300">STARKWARE</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">On July 2, 2018, the Ethereum Foundation gave StarkWare a 2-year milestone-based grant to select a STARK friendly hash (SFH) function, to be used in combination with transparent and plausibly post-quantum secure proof systems within blockchains, and release an open source efficient STARK system for it. Under the grant agreement, StarkWare committed to publishing, among other things:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>“Production-quality software released under a software license, approved by the Ethereum Foundation, for the STARK-friendly hash function:

1. Arithmetised circuit with proofs compressing 100,000 hashes (3.2MB of data) to 200kB with 80 bits of security
2. Prover that compresses 100 hashes per second with a quad-core CPU and 16GB of RAM
3. Verifier verifying proofs in 10ms on a single-core CPU with 4GB of RAM
4. Detailed specification of the prover and verifier mechanics, inluding optimisations …”</p>
    </blockquote>

    <p class="text-gray-300">The ethSTARK code released by StarkWare answers items 1–3 above, and the purpose of this document it to address item 4. We assume familiarity with the notion of interactive proofs <em>[x10]</em>, non-interactive Computationally Sound proofs <em>[x16]</em>, Interactive Oracle Proofs (IOPs) <em>[x22, x3]</em> and Scalable Transparent ARgument of Knowledge (STARK) systems <em>[x2]</em>.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Organization of the document</h4>

    <p class="text-gray-300">Section 2 describes the Rescue hash function family and the particular member of it that ethSTARK implements. Section 3 describes in great detail the specific STARK protocol used in the code, including a description of the full system of constraints included in the Algebraic Intermediate Representation (AIR) of the system. Section 4 provides measurements and benchmarks of the system and discusses them. Security and soundness analysis for the IOP model are presented in Section 5. Round-by-round soundness, needed for analysing security in the random oracle model is presented in Section 6, and security of non-interactive STARKs in the random oracle model is discussed in Section 7. (The independent work of Block et al. <em>[BGK^{+}23]</em> achieves similar results to our Sections 6 and 7, see Remark 5 for a detailed comparison.)</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Acknowledgment</h4>

    <p class="text-gray-300">We would like to thank Justin Drake from the Ethereum Foundation for his thoughtful and detailed comments. We thank Venkatesan Guruswami and Amnon Ta-Shma for carefully auditing Section 5 and offering numerous comments that clarified the presentation, and the Ethereum Foundation for funding their audit.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2 Rescue</h2>

    <p class="text-gray-300">In this section we give a short description of the Rescue cipher family, referring the interested reader to <em>[AAB^{+}19]</em> for full details. We then present an instantiation of a hash function based on this Rescue cipher family.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">2.1 Rescue Cipher</p>

    <p class="text-gray-300">Rescue is a family of ciphers based on substitution-permutation networks (SPNs). A Rescue cipher manipulates a state of <span class="math">m&gt;1</span> elements in the vector space <span class="math">\\mathbb{F}_{p}^{m}</span> where <span class="math">\\mathbb{F}_{p}</span> is a field of characteristic <span class="math">p\\equiv 5\\pmod{6}</span>.</p>

    <p class="text-gray-300">A Rescue permutation is an iterative application of a round function <span class="math">R</span> times where <span class="math">R</span> is determined by the desired security level. The inputs to the first round are the plaintext and a master-key, and the output of the last round is the ciphertext. Each round takes as inputs the previous state and a subkey, derived from the master-key, and outputs a new state.</p>

    <p class="text-gray-300">A round of a Rescue permutation includes two steps. In each step an S-box is applied to each of the <span class="math">m</span> state elements, followed by a multiplication by a Maximum Distance Separable (MDS) matrix which mixes the elements together. At the end of each step a subkey is injected into the state. The S-boxes <span class="math">\\pi_{1}</span> and <span class="math">\\pi_{2}</span> that are used in the first and second step of each round, consist of the power maps <span class="math">x^{1/\\alpha}</span> and <span class="math">x^{\\alpha}</span>, respectively, for an integer <span class="math">\\alpha</span> that does not divide <span class="math">p-1</span> (in which case <span class="math">1/\\alpha</span> is well-defined).</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.2 Rescue Hash Function</h3>

    <p class="text-gray-300">The Rescue hash function is a sponge construction hash function, based on an un-keyed Rescue permutation, in which the secret key is set to zero and round constants are used instead of keys. A sponge construction generates a hash function from an underlying permutation by iteratively applying it to a large state. The state consists of <span class="math">m=r+c</span> field elements, where <span class="math">r</span> and <span class="math">c</span> are called the <em>rate</em> and the <em>capacity</em> of the sponge, respectively.</p>

    <p class="text-gray-300">We now present our instantiation of a Rescue hash function. Henceforth, the term “Rescue” refers to this particular instantiation, not to the larger family defined in <em>[AAB^{+}19]</em>. The native field in which Rescue operates is <span class="math">\\mathbb{F}_{p}</span> where <span class="math">p=2^{61}+20\\cdot 2^{32}+1</span>. The state is viewed as a column vector of <span class="math">m=12</span> field elements. For the S-boxes <span class="math">\\pi_{1}</span> and <span class="math">\\pi_{2}</span> we use <span class="math">\\alpha=3</span> such that the power maps are <span class="math">x^{1/3}</span> and <span class="math">x^{3}</span>, respectively. Since <span class="math">3</span> does not divide <span class="math">p-1</span> it holds that <span class="math">(2p-1)/3</span> is an integer and furthermore,</p>

    <p class="text-gray-300"><span class="math">\\forall x\\in\\mathbb{F}_{p},\\quad\\left(x^{3}\\right)^{(2p-1)/3}=\\left(x^{(2p-1)/3}\\right)^{3}=x.</span></p>

    <p class="text-gray-300">Therefore we use <span class="math">1/3</span> to denote <span class="math">(2p-1)/3</span>, noticing that <span class="math">x\\mapsto x^{1/3}</span> is indeed the cube-root permutation, modulo <span class="math">p</span>. To compute the Rescue permutation from a given input, the round function is iterated <span class="math">R=10</span>-times with constants injected before the first round, between each two consecutive steps (within and between rounds), and after the last round (a total of <span class="math">21</span> constant vectors).</p>

    <p class="text-gray-300">Let <span class="math">K=\\{K_{0},\\ldots,K_{20}\\}</span> denote the constants used in the Rescue hash function such that <span class="math">K_{2r+1},K_{2r+2}</span> are the constants used in the <span class="math">r</span>th round for <span class="math">r\\in[0,9]</span> and <span class="math">K_{0}</span> is the constant used before the first round. Note that each <span class="math">K_{i}\\in K</span> is in fact a field element vector of length <span class="math">m=12</span>. Thus, adding a constant to a state is merely a vector addition. Figure 1 is a graphic description of a single round of the Rescue permutation.</p>

    <p class="text-gray-300">To transform the Rescue permutation to a hash function, we apply the Sponge construction: The first <span class="math">8</span> elements of the <em>state</em> are the <em>rate</em> and the last <span class="math">4</span> elements are the <em>capacity</em>. The hash of two inputs <span class="math">w_{0},w_{1}\\in\\mathbb{F}_{p}^{4}</span> is defined by applying the rescue permutation to <span class="math">(w_{0},w_{1},0)\\in\\mathbb{F}_{p}^{12}</span> and taking the first <span class="math">4</span> elements. A graphic description of the Rescue hash function is given in Fig. 2, and its pseudo-code appears in Algorithm 1.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Round  <span class="math">r</span>  of the Rescue permutation.  <span class="math">M</span>  denotes a multiplication by the MDS matrix.  <span class="math">\\text{Inter}_r</span>  represents the state in the middle of the round.</p>

    <p class="text-gray-300">Algorithm 1 The Rescue permutation with an MDS matrix  <span class="math">M</span></p>

    <pre><code class="language-latex">INPUT:  $w_0, w_1 \\in \\mathbb{F}_p^4$ , round constants  $K$
OUTPUT:  $\\operatorname{Rescue}(w_0, w_1)$
Let  $\\text{State}_{\\text{in}}$  be the vector  $(w_0, w_1, 0) \\in \\mathbb{F}_p^{12}$ .
$\\text{State}_0 = \\text{State}_{\\text{in}} + K_0$
for  $r = 0$  to 9 do
for  $i = 0$  to 11 do
$\\operatorname{Inter}_r[i] = \\sum_{j=0}^{m-1} M[i,j] (\\text{State}_r[j])^{1/3} + K_{2r+1}[i]$
end for
for  $i = 0$  to 11 do
$\\operatorname{State}_{r+1}[i] = \\sum_{j=0}^{m-1} M[i,j] (\\operatorname{Inter}_r[j])^3 + K_{2r+2}[i]$
end for
end for
return  $\\text{State}_{10}$</code></pre>

    <p class="text-gray-300">STARKWARE</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: Instantiating the Rescue hash function as a sponge construction based on the Rescue permutation.</p>

    <p class="text-gray-300">STARKs (Scalable Transparent ARguments of Knowledge) are a family of proof systems characterized by scalability and transparency. Scalability - via quasilinear proving time and poly-logarithmic verification time, and transparency - meaning all verifier-side messages are public random coins (requiring no trusted setup). We assume familiarity with the general definition of STARKs, as described in [BBHR19]. In this section we describe the STARK proof system as an interactive protocol between two parties, the prover and the verifier. The prover sends a series of oracle messages in an attempt to convince the verifier that a certain computation on some input (the proven statement) was executed correctly. The verifier responds to the messages with public random values. After the interaction ends, the verifier uses more public random coins to query a small number of entries from the oracle messages sent by the prover. Based on the answers to these queries, the verifier reaches a decision whether to accept the statement as correct, or reject it. The completeness and soundness properties of the STARK system imply that correct statements proved by honest provers are guaranteed to be accepted by the verifier (with probability 1 over the random coin-tosses made by the verifier). Conversely, incorrect statements, and statements whose witness is unknown to the prover will be rejected with all but negligible probability (which we set here to be at most  <span class="math">2^{-80}</span> ).</p>

    <p class="text-gray-300">While we describe the system below as an interactive protocol, it is noted that this interactivity is eventually replaced by a transformation to a non-interactive system wherein the prover provides a proof and the verifier decides whether to accept or reject it. See Section 3.10.</p>

    <p class="text-gray-300">An execution trace of a computation, or trace, in short, is a sequence of machine states, one per clock cycle. If the computation requires  <span class="math">W</span>  registers and lasts for  <span class="math">N</span>  cycles, the execution trace</p>

    <p class="text-gray-300">STARKWARE</p>

    <p class="text-gray-300">can be represented by a table of size <span class="math">N \\times W</span>. Given a statement regarding the correctness of a computation, the prover first builds a trace.</p>

    <p class="text-gray-300">Denote the columns of the trace by <span class="math">f_{1},\\ldots ,f_{W}</span>. Each <span class="math">f_{j}</span> is of a fixed length, <span class="math">N</span>, that is a power of two. The values in the trace cells are elements in a finite field <span class="math">\\mathbb{F}_p</span>. The trace evaluation domain is defined to be a multiplicative subgroup of <span class="math">\\mathbb{F}_p^\\times</span> of size <span class="math">N</span>, generated by an element <span class="math">g</span>; we denote this subgroup by <span class="math">\\langle g\\rangle</span>. Effectively, we enumerate the trace rows using the elements of <span class="math">\\langle g\\rangle</span>, where the <span class="math">i</span>th row is enumerated by <span class="math">g^{i}</span> (the first row is the 0th row, enumerated by <span class="math">1 = g^{0}</span>). Each trace column is interpreted as <span class="math">N</span> point-wise evaluations of a polynomial<span class="math">^2</span> of degree smaller than <span class="math">N</span> over the trace evaluation domain. These polynomials are referred to as the trace column polynomials or column polynomials in short.</p>

    <p class="text-gray-300">The Rescue trace has 12 columns, corresponding to the <span class="math">m = 12</span> field elements of the state. Applying each hash requires slightly more than 10 rows (one per round). The hashes<span class="math">^3</span> can be computed in batches of 3 hashes that fit into 32 rows as follows (see Fig. 3):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Row 0: initial state of the first hash (8 input field elements and 4 zeros).</li>

      <li>Rows 1 to 10: state in the middle<span class="math">^4</span> of every round of the first hash.</li>

      <li>Rows 11 to 20: state in the middle of every round of the second hash.</li>

      <li>Rows 21 to 30: state in the middle of every round of the third hash.</li>

      <li>Row 31: final state of the third hash (the first 4 field elements in this state are the output).</li>

    </ul>

    <h2 id="sec-10" class="text-2xl font-bold">3.2 Periodic Columns</h2>

    <p class="text-gray-300">Many cryptographic primitives involve using some list constants. Applying the same cryptographic primitive many times, yields a periodic list of constants. For this, we use a technique we refer to as periodic columns. The periodic structure of each such column leads to a column polynomial which can be represented succinctly. In the classic representation of a polynomial <span class="math">\\sum a_{i}x^{i}</span> as a vector of its coefficients <span class="math">(a_0,a_1,\\ldots)</span>, a succinct representation means that most of the <span class="math">a_{i}</span>'s are zeros. This enables the verifier to efficiently compute the point-wise evaluations of these polynomials.</p>

    <p class="text-gray-300">We maintain the round constants of Rescue using periodic columns. For each trace column we have two periodic columns, one for each of the two steps of a round, up to the following small modifications. Each periodic column is of length 32 (corresponding to 3 hashes, see Section 3.1 for more details). For technical reasons that will be explained in Section 3.3, we decided to add <span class="math">K_{0}</span> to the round constants that correspond to the second step of a round, in the first four columns in rows 10 and 20 (the left inputs of the second and third hash invocations).</p>

    <p class="text-gray-300">Page 8</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: A batch of three hashes in the Rescue execution trace.</p>

    <p class="text-gray-300">STARKWARE</p>

    <p class="text-gray-300">Page 10</p>

    <p class="text-gray-300">An execution trace is valid if (1) certain boundary constraints hold and (2) each pair of consecutive states satisfies the constraints dictated by the computation. For example, if at time <span class="math">t</span> the computation should add the contents of the 1st and 2nd registers and place the result in the 3rd register, the relevant constraint would be <span class="math">f_{1}(g^{t}) + f_{2}(g^{t}) - f_{3}(g\\cdot g^{t}) = 0</span> where <span class="math">f_{j}</span> is the <span class="math">j</span>th column polynomial and <span class="math">g</span> is the generator of the trace evaluation domain.</p>

    <p class="text-gray-300">The constraints are expressed as polynomials composed over the trace cells that are satisfied if and only if the computation is correct. Hence, they are referred to as the Algebraic Intermediate Representation (AIR) Polynomial Constraints on the trace. For example, in the context of proving the computational integrity of an execution of a Rescue hash function, the constraints are such that they all hold if and only if the output of the hash function matches the input, where the input and output are designated cells within the trace (these cells will be part of the boundary constraints defining validity of the statement).</p>

    <p class="text-gray-300">Some examples of constraints over the trace cells:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f_{2}(x) - a = 0</span> for <span class="math">x = g^{7}</span> (the value in column 2 row 7 is equal to <span class="math">a</span>).</li>

      <li><span class="math">f_{6}^{2}(x) - f_{6}(g^{3}x) = 0</span> for all <span class="math">x</span> (the squared value in each row in column 6 is equal to the value three rows ahead).</li>

    </ol>

    <p class="text-gray-300">By writing a set of polynomial constraints which are satisfied if and only if the computation is valid, we reduce the original problem – proving the correctness of a computation – to proving that the polynomial constraints are satisfied. This reduction is a special case of the general process known in theoretical computer science as “arithmetization”.</p>

    <p class="text-gray-300">The AIR for the Rescue hash chain corresponds to the following claim:</p>

    <p class="text-gray-300">"I know a sequence of inputs <span class="math">w = \\{w_0, \\ldots, w_n\\}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">H(\\dots H(H(w_0, w_1), w_2) \\dots, w_n) = output&quot;, \\tag{1}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">H</span> is the Rescue hash function, each <span class="math">w_i</span> is a 4-tuple of field elements and output is the public output of the hash (which consists of 4 field elements). Recall that the hashes are computed in batches of 3 hashes, hence, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 3k + 1 = n + 1<span class="math"> for some </span>k \\in \\mathbb{Z}<span class="math">. We note that the number of hash invocations, which is known to the verifier, is </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1 = n<span class="math"> and refer to </span>n$ as the chain length.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">There are numerous ways to capture the correctness of an execution trace via polynomial constraints. When designing an AIR, one should take the tradeoffs that each approach yields into consideration. For example, consider the following synthetic trace with only two cells:</p>

    <p class="text-gray-300">|  X  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  √3/X+1  |</p>

    <p class="text-gray-300">A naïve constraint linking the two cells is <span class="math">f_0(g) - \\sqrt[3]{f_0(1) + 1} = 0</span>. Recall that in Rescue's native field <span class="math">x^{1/3} = x^{(2p-1)/3}</span>. Therefore, the degree of this polynomial constraint, <span class="math">(2p-1)/3</span>, is huge.</p>

    <p class="text-gray-300">STARKWARE</p>

    <p class="text-gray-300">A different possible approach would be to maintain intermediate execution values within the trace. For example, adding a column to the trace with the cubed values of the original column:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">X</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">X^{3}</span></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\sqrt[3]{X+1}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">X+1</span></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now, we can replace the former constraint with the following ones:</p>

    <p class="text-gray-300"><span class="math">f_{0}^{3}(x)-f_{1}(x)</span> <span class="math">=0\\text{ for }x=1,g</span> (2) <span class="math">f_{0}(1)+1-f_{1}(g)</span> <span class="math">=0</span> (3)</p>

    <p class="text-gray-300">Note that while the maximal degree of these constrains is 3, there are now three constraints instead of one. Also, the size of the trace is twice the size of the original trace. Both measures, number of constraints and trace size, affect the prover efficiency. Crucially, in both approaches we force the prover to place <span class="math">\\sqrt[3]{X+1}</span> in a certain well-defined trace cell, as needed to achieve computational integrity.</p>

    <p class="text-gray-300">A third approach is to compute the intermediate values for the constraints in which they are used, instead of adding them to the trace and asserting their validity by more constraints. Consequently, constraint (3) becomes <span class="math">f_{0}(1)+1-A=0</span>, where <span class="math">A=f_{0}^{3}(g)</span> and the intermediate value <span class="math">A</span> does not appear in the trace. Note that this constraint is defined over the original trace and is of degree 3. Although intermediate values are not part of the trace, it is helpful to think of them as trace intermediate columns.</p>

    <p class="text-gray-300">Recall that the rows in the Rescue trace are the states in the middle of rounds (except for the first and last rows of every batch of 3 hashes). Thus, as can be seen in Figure 4, calculating the second step of a round from a row in the trace should yield the same result as calculating the first step of a round, in reverse, from its consecutive row.</p>

    <p class="text-gray-300">In the Rescue AIR, for each trace column we have 3 intermediate columns. We denote these intermediate columns by:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>x_cube: computes the third powers of the state. Corresponds to transition A in Figure 4.</li>

      <li>after_linperm: computes the state at the end of a full round (half round forward from the current row). Corresponds to transition B in Figure 4.</li>

      <li>before_next_linperm_cubed: computes the state at the beginning of the next full round (half round backward from the next row). Corresponds to transition C in Figure 4. Note that this intermediate value depends on the next row, so for a given column polynomial <span class="math">f(x)</span>, before_next_linperm_cubed corresponds to <span class="math">f(gx)</span>.</li>

    </ol>

    <p class="text-gray-300">In the following section, for each intermediate column we use brackets notation to denote the corresponding trace column. For example, x_cube<span class="math"><a href="g^{i}">j</a></span> refers to the third power of the value of the cell in the <span class="math">j</span>th column and the <span class="math">i</span>th row.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">3.3.2 The Rescue Constraints</h4>

    <p class="text-gray-300">We now describe the constraints used in the Rescue AIR. For each constraint, we first describe the meaning of the constraint, that is, what the constraint enforces on the trace values. We then state the polynomial constraint itself, followed by the domain and columns to which the constraint should apply.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 4: A "shifted" round of the Rescue permutation. Represents the execution between consecutive rows of the trace.</p>

    <p class="text-gray-300">In the following constraints let  <span class="math">K</span>  denote the constants used in Rescue as in Section 2. We write  <span class="math">K_{i}[j]</span>  for the constant used in the  <span class="math">i</span> th step of the algorithm for the  <span class="math">j</span> th column. As mentioned above, we pack 3 hash invocations into 32 trace rows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The capacity part at the beginning of each hash is zero.</li>

    </ol>

    <p class="text-gray-300">(a) The capacity part of the first row of each batch of 3 hashes is zero.</p>

    <div class="my-4 text-center"><span class="math-block">f _ {j} (x) = 0</span></div>

    <p class="text-gray-300">for  <span class="math">x = g^i</span>  where  <span class="math">i \\equiv 0(32)</span>  and  <span class="math">j \\in [8,11]</span> .</p>

    <p class="text-gray-300">(b) The capacity part of the second and third hashes is zero.</p>

    <div class="my-4 text-center"><span class="math-block">K _ {0} [ j ] - \\text {b e f o r e \\_ n e x t \\_ l i n p e r m \\_ c u b e d} [ j ] (x) = 0</span></div>

    <p class="text-gray-300">for  <span class="math">x = g^i</span>  where  <span class="math">i \\equiv 10,20(32)</span>  and  <span class="math">j \\in [8,11]</span> : First row of the second and third hashes in each batch.</p>

    <p class="text-gray-300">To see why this holds, recall that between consecutive hashes the capacity is nullified and the constant  <span class="math">K_{0}</span>  is injected before the first step of each invocation.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The second row of each batch is obtained by applying the first half round of Rescue.</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">f _ {j} (x) + K _ {0} [ j ] - \\text {b e f o r e \\_ n e x t \\_ l i n p e r m \\_ c u b e d} [ j ] (x) = 0</span></div>

    <p class="text-gray-300">for  <span class="math">x = g^i</span>  where  <span class="math">i \\equiv 0(32)</span>  and  <span class="math">j \\in [0,11]</span> .</p>

    <p class="text-gray-300">STARKWARE</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The connection between the middle of a round (current row) with the middle of the next round (next row).</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For State[0],…,State[11].</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\texttt{after\\_linperm}<a href="x">j</a>-\\texttt{before\\_next\\_linperm\\_cubed}<a href="x">j</a>=0</span></p>

    <p class="text-gray-300">for <span class="math">x=g^{i}</span> where <span class="math">i\\not\\equiv 0,10,20,30,31(32)</span> and <span class="math">j\\in[0,11]</span>: All rows except for the first and last rows of each batch and the last row of each hash.</p>

    <p class="text-gray-300">Note that this constraint does not apply to rows 10 and 20 since in the connection between consecutive hashes, the capacity is nullified and the right input (State[4],…,State[7]) is reset to some nondeterministic witness. However, between consecutive hashes, the left input (State[0],…,State[3]) must be equal to the output of the former hash. Since we add <span class="math">K_{0}</span> to the round constants that correspond to the constants used in the second step of a round in the first four columns in rows 10 and 20 (See Section 3.2), we have the following constraint.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For State[0],…,State[3].</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\texttt{after\\_linperm}<a href="x">j</a>-\\texttt{before\\_next\\_linperm\\_cubed}<a href="x">j</a>=0</span></p>

    <p class="text-gray-300">for <span class="math">x=g^{i}</span> where <span class="math">i\\equiv 10,20(32)</span> and <span class="math">j\\in[0,3]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To see why this holds, recall that the state after the first hash (corresponds to after_linperm) is: OUTPUT0$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">JUNK</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">JUNK. The state before the second hash (which corresponds to before_next_linperm_cubed - </span>K_{0}<span class="math">) is: INP0</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">INP1</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$0. We require that OUTPUT0 = INP0. But instead of writing the equation:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\texttt{after\\_linperm}=\\texttt{before\\_next\\_linperm\\_cubed}-K_{0},</span></p>

    <p class="text-gray-300">we in fact add <span class="math">K_{0}</span> to the round constants that correspond to the constants used in the second step of a round in the first four columns in rows 10 and 20, and thus <span class="math">+K_{0}</span> is already part of after_linperm.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The connection between the last two rows of each batch (final half round of the third hash).</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\texttt{after\\_linperm}<a href="x">j</a>-f_{j}(gx)=0</span></p>

    <p class="text-gray-300">for <span class="math">x=g^{i}</span> where <span class="math">i\\equiv 30(32)</span> and <span class="math">j\\in[0,11]</span>: Last row of the third hash in each batch.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The output of the third hash of a batch is the input of the first hash of the next batch.</li>

    </ol>

    <p class="text-gray-300"><span class="math">f_{j}(x)-f_{j}(gx)=0</span></p>

    <p class="text-gray-300">for <span class="math">x=g^{i}</span> where <span class="math">i\\equiv 31(32),i&lt;N-1</span> and <span class="math">j\\in[0,3]</span> where <span class="math">N</span> is the length of the trace: Last row of the third hash in each batch except for the last row of the trace.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The output of the hash chain is the expected output.</li>

    </ol>

    <p class="text-gray-300"><span class="math">f_{j}(x)-\\texttt{output}=0</span></p>

    <p class="text-gray-300">for <span class="math">x=g^{32(\\texttt{chain\\_length}/3-1)+31}</span> where <span class="math">j\\in[0,3]</span>, chain_length is the number of hash invocations and output is the expected output of the hash chain.</p>

    <p class="text-gray-300">Note, each of the constraints listed above represents multiple constraints. For example, the last constraint (6) represents four constraints that correspond to the first four columns of the trace (as the output of the function is the first four elements of the state's rate). There is a total of 52 constraints in the Rescue AIR <span class="math">^6</span> .</p>

    <h2 id="sec-14" class="text-2xl font-bold">3.3.3 From Polynomial Constraints to Low Degree Testing Problem</h2>

    <p class="text-gray-300">Next, we represent each constraint as a rational function. Recall that the trace evaluation domain is of order  <span class="math">N</span>  and generated by  <span class="math">g</span> . Hence,  <span class="math">\\langle g \\rangle = \\{x \\in \\mathbb{F}_p \\mid x^N = 1\\}</span> . Constraint (1a) above is translated into the rational function:</p>

    <div class="my-4 text-center"><span class="math-block">C _ {1} (x) = \\frac {f _ {j} (x)}{x ^ {N / 32} - 1} \\tag {4}</span></div>

    <p class="text-gray-300">which is a polynomial of degree at most  <span class="math">\\deg(f_j) - N/32</span>  if and only if the constraint holds over  <span class="math">\\langle g \\rangle</span> .</p>

    <p class="text-gray-300">Represented as rational functions, the constraints are such that each numerator defines a relevant rule needed to be enforced over the trace cells, and each denominator defines the domain in which the corresponding rule should hold.</p>

    <p class="text-gray-300">Two remarks are in order. First, in order for the process of representing each constraint as a rational function to be well-defined, we need to make sure that the denominators are never zero. As we will see in the next section, the constraint polynomials will not be evaluated over the trace evaluation domain, but rather on a (larger) disjoint domain, which we call the evaluation domain. Thus, while the denominator can zero out over a subset of the trace evaluation domain, no denominator equals zero over the evaluation domain and expressions like Eq. (4) will be well-defined over the evaluation domain. Second, since the verifier needs to evaluate these rational functions, it is important for the succinctness of the STARK protocol that the domains are such that their corresponding denominators can be evaluated efficiently, i.e., that all high-degree polynomials be sparse, as indeed is the case with Eq. (4).</p>

    <h2 id="sec-15" class="text-2xl font-bold">3.4 Trace Low Degree Extension</h2>

    <p class="text-gray-300">Recall that each trace column is viewed as  <span class="math">N</span>  evaluations of a polynomial of degree less than  <span class="math">N</span> . In order to achieve a secure protocol, each such polynomial is evaluated over a larger domain, disjoint from the trace evaluation domain, which we call the evaluation domain. We refer to this evaluation as the trace Low Degree Extension (LDE) and the ratio between the size of the evaluation domain and the trace evaluation domain as the blowup factor,  <span class="math">\\beta</span> . (Those familiar with coding theory notation will notice that  <span class="math">\\beta</span>  is the inverse of the rate and the LDE is in fact simply a Reed-Solomon code of the trace.)</p>

    <p class="text-gray-300">The trace LDE is computed in two steps. First, we calculate the interpolation polynomial of each trace column using the Inverse Fast Fourier Transform (IFFT). Then, we evaluate each interpolation polynomial on the evaluation domain using the Fast Fourier Transform (FFT).</p>

    <p class="text-gray-300">In order to make sure that the evaluation domain and the trace evaluation domain are disjoint, we use a non-unit <span class="math">^7</span>  coset of the multiplicative subgroup of size  <span class="math">(\\beta \\cdot N)</span>  of  <span class="math">\\mathbb{F}_p^\\times</span>  as the evaluation</p>

    <p class="text-gray-300">STARKWARE</p>

    <p class="text-gray-300">domain.</p>

    <p class="text-gray-300">For Rescue, we use a blowup factor of 4 so the evaluation domain is of size <span class="math">4\\cdot N</span>.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">3.5 Commitment Scheme</h3>

    <p class="text-gray-300">Following the generation of the trace LDE, the prover commits to it. Throughout the system, commitments are implemented by building Merkle trees over the series of field elements and sending the Merkle roots to the verifier. We use BLAKE2s with digest size of 20 bytes, or 160 bits, as the underlying hash function, to reach 80-bit security.</p>

    <p class="text-gray-300">To gain better efficiency we use two optimizations for the Merkle tree implementation.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The leaves of the Merkle tree are selected such that if a decommitment is likely to involve multiple field elements together, they are grouped into a single Merkle leaf. In the case of the trace LDE, this implies we group all field elements in a trace LDE “row” into a single Merkle leaf.</li>

      <li>When the size of each element (Merkle leaf) is smaller than the input size of the hash used by the Merkle tree, feeding individual elements into such a tree is wasteful. Instead, we group several elements together into a package that fits as a single input to the hash and use these packages as the input elements for the tree.</li>

    </ol>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">3.6 Composition Polynomial</h3>

    <p class="text-gray-300">In order to efficiently prove the validity of the execution trace, we strive to achieve the following two goals:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compose the constraints on top of the trace polynomials to enforce them on the trace. (Described in Section 3.3.)</li>

      <li>Combine the constraints into a single (larger) polynomial, called the Composition Polynomial, so that a single low degree test can be used to attest to their low degree. To reach this goal, some of the composed polynomials will require adjustment to their degrees, so that all composed polynomials have the same designated degree (the ethSTARK code indeed enforces this degree adjustment).</li>

    </ol>

    <p class="text-gray-300">Before we continue to describe how the above is performed, we introduce another finite field. Recall that the elements in the trace are from <span class="math">\\mathbb{F}_{p}</span>, Rescue’s native field, whose size is between <span class="math">2^{61}</span> and <span class="math">2^{62}</span>. In order for the STARK protocol to be secure, one must use a larger field in some places. For this, we use the quadratic extension field <span class="math">\\mathbb{F}_{p}(\\phi)</span> where <span class="math">\\phi</span> is a root of the irreducible polynomial <span class="math">X^{2}-X-1</span>. Thus, <span class="math">\\mathbb{F}_{p}(\\phi)</span> is the field <span class="math">\\mathbb{F}_{p}[X]/(X^{2}-X-1)</span>. In the following sections it is crucial, for the soundness of the protocol, that each field element used in the protocol is from the appropriate field.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">3.6.1 Degree Adjustment</h4>

    <p class="text-gray-300">In order to ensure soundness, we need to show that all individual constraints composed with the trace column polynomials are of low degree. Let <span class="math">\\mathtt{max\\_deg}</span> be the highest degree of all the constraints. We adjust the degree of the constraints to degree <span class="math">D-1</span>, where D is the smallest power of 2 such that <span class="math">D&gt;\\mathtt{max\\_deg}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Degree adjustment is performed as follows: Given a constraint <span class="math">C_j(x)</span> of degree <span class="math">D_j</span>, we define a polynomial of the form:</p>

    <div class="my-4 text-center"><span class="math-block">C_j(x)(\\alpha_j x^{D - D_j - 1} + \\beta_j)</span></div>

    <p class="text-gray-300">where <span class="math">\\alpha_j</span> and <span class="math">\\beta_j</span> are random field elements from the extension field <span class="math">\\mathbb{F}_p(\\phi)</span>, chosen by the verifier. As a result, if the new constraint is of degree lower than <span class="math">D</span>, it automatically follows (w.h.p) that the original constraint is of degree at most <span class="math">D_j</span>, as desired.</p>

    <h2 id="sec-19" class="text-2xl font-bold">3.6.2 Combining the Constraints</h2>

    <p class="text-gray-300">Once the prover has committed to the trace LDE, the verifier provides random coefficients for creating a random linear combination of the constraints⁸ resulting in the composition polynomial. Instead of checking each constraint individually, it suffices to apply a low degree test to the composition polynomial.</p>

    <p class="text-gray-300">Thus, the composition polynomial takes the form:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{j=1}^{k} C_j(x)(\\alpha_j x^{D - D_j - 1} + \\beta_j)</span></div>

    <p class="text-gray-300">where <span class="math">k</span> is the number of constraints.</p>

    <p class="text-gray-300">Since the constraints used in the Rescue AIR are of degree three or below, the degree of the composition polynomial is <span class="math">&amp;lt; 4N</span>. Hence, we can represent the composition polynomial <span class="math">h(x)</span> as a single column of evaluations of length <span class="math">4N</span>. Instead, we prefer to represent it as four columns <span class="math">h_0(x), \\ldots, h_3(x)</span> of length <span class="math">N</span>, where <span class="math">h(x) = h_0(x^4) + x h_1(x^4) + x^2 h_2(x^4) + x^3 h_3(x^4)</span>. We "break" <span class="math">h(x)</span> into <span class="math">h_i(x)</span> by computing partial (two layer) IFFT.</p>

    <h2 id="sec-20" class="text-2xl font-bold">3.6.3 Committing to the Composition Polynomial</h2>

    <p class="text-gray-300">Next, the prover performs yet another low degree extension of the four composition polynomial columns <span class="math">h_0(x), \\ldots, h_3(x)</span>. As these columns are of the same length as the trace columns, we sometimes refer to them as the Composition Polynomial Trace and we address extending and committing to them in the same manner as with the execution trace. This step includes extending them by the same blowup factor, grouping the rows (of field element quadruples) into leaves of a Merkle tree, calculating the hash values and sending the root of the tree as the commitment.</p>

    <h2 id="sec-21" class="text-2xl font-bold">3.7 Consistency Check on a Random Point (the DEEP Method)</h2>

    <p class="text-gray-300">The value of <span class="math">h(x)</span> for a given point (an extension field element) <span class="math">z \\in \\mathbb{F}_p(\\phi)</span> can be obtained in two ways: by calculating the above mentioned linear combination of constraints (the composition polynomial) or from <span class="math">h_0(z^4), \\ldots, h_3(z^4)</span>. For the former, the composition polynomial calculation induces a set of points over the trace columns that are needed in order to compute <span class="math">h(z)</span>. This set of points, required to calculate <span class="math">h(x)</span> for a single point, is called the mask. Hence, given a point <span class="math">z</span>, we can check the consistency between the commitment on the execution trace and the commitment on</p>

    <p class="text-gray-300">⁸There are 52 constraints in Rescue, as described in Section 3.3.2. Therefore, in Rescue the verifier sends 104 random field elements – two for each constraint, as described in Section 3.6.1.</p>

    <p class="text-gray-300">⁹The constraint used in the Rescue AIR are of degree three, but we prefer to have a degree bound for the composition polynomial which is a power of two.</p>

    <p class="text-gray-300">STARKWARE Page 16</p>

    <p class="text-gray-300">the composition trace. For this we need the values of the induced mask on the trace and the values of <span class="math">h_{0}(z^{4}),\\ldots,h_{3}(z^{4})</span>.</p>

    <p class="text-gray-300">Recall that in the Rescue AIR, the constraints assert the transition between consecutive rows (except for the boundary constraints, which deal with the first and last rows of the trace). Thus, the mask of a given point <span class="math">z</span> in the Rescue AIR consists of 24 elements. For each of the 12 polynomial columns, <span class="math">f_{j}(x)</span>, there are two mask points: <span class="math">f_{j}(z)</span> and <span class="math">f_{j}(g\\cdot z)</span>, where <span class="math">g</span> is the generator of the trace evaluation domain.</p>

    <p class="text-gray-300">At this phase, the verifier sends a randomly sampled point <span class="math">z\\in\\mathbb{F}_{p}(\\phi)</span>. The prover sends back 28 elements: the evaluations of the relevant elements in the mask required for calculating <span class="math">h(z)</span>, along with the evaluations of <span class="math">h_{0}(z^{4}),\\ldots,h_{3}(z^{4})</span>. Denote the mask values sent by the prover by <span class="math">\\{y_{j,s}\\}_{j\\in[0,11],s\\in\\{0,1\\}}</span>, and the evaluations of <span class="math">h_{i}(z^{4})</span> sent by the prover by <span class="math">\\{\\hat{y}_{i}\\}_{i\\in[0,3]}</span>. For an honest prover, the value of each <span class="math">\\hat{y}_{i}</span> equals <span class="math">h_{i}(z^{4})</span>, and the value of each <span class="math">y_{j,s}</span> equals to <span class="math">f_{j}(zg^{s})</span> where <span class="math">j</span> is the column of the corresponding cell and <span class="math">s</span> is its row offset. The verifier may then calculate <span class="math">h(z)</span> in two ways: based on <span class="math">h_{0}(z^{4}),\\ldots,h_{3}(z^{4})</span> (using <span class="math">h(z)=\\sum_{i=0}^{3}x^{i}h_{i}(z^{4})</span>) and based on the mask values <span class="math">y_{j,s}</span>. It verifies that the two results are identical.</p>

    <p class="text-gray-300">It remains to show that the values sent by the prover in this phase are correct (i.e., indeed equal to the evaluation of the composition polynomial trace and the mask values of the point <span class="math">z</span>), which will be done in the next section. This method of checking consistency between two polynomials by sampling a random point from a large domain is called Domain Extension for Eliminating Pretenders (DEEP); see <em>[x1]</em> for more details about it.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">3.8 The DEEP Composition Polynomial</h3>

    <p class="text-gray-300">Verifying that the DEEP values sent by the prover are correct includes two parts:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifying that they are equal to the mask values of the point <span class="math">z</span>.</li>

      <li>Verifying that the trace is defined over <span class="math">\\mathbb{F}_{p}</span>, the native field in which Rescue operates (as opposed to the extension field <span class="math">\\mathbb{F}_{p}(\\phi)</span>).</li>

    </ol>

    <p class="text-gray-300">In the rest of this section we describe how these verifications are performed.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">3.8.1 Verifying the Mask Values</h4>

    <p class="text-gray-300">In order to verify the values sent by the prover, we create a second set of constraints and then translate them to a problem of low degree testing, similar to the composition polynomial. For each mask value <span class="math">y_{j,s}</span>, sent by the prover, we define the following constraint:</p>

    <p class="text-gray-300"><span class="math">\\frac{f_{j}(x)-y_{j,s}}{x-zg^{s}}</span></p>

    <p class="text-gray-300">where <span class="math">j,s</span> are the column and row offset of the corresponding cell. This rational function is a polynomial of degree <span class="math">(\\deg(f_{j})-1)</span> if and only if <span class="math">f_{j}(zg^{s})=y_{j,s}</span> for some polynomial <span class="math">f_{j}(X)</span> of degree <span class="math">\\deg(f_{j})</span>.</p>

    <p class="text-gray-300">Likewise, for each value <span class="math">\\hat{y}_{i}</span> that the prover sent, we define the following constraint:</p>

    <p class="text-gray-300"><span class="math">\\frac{h_{i}(x)-\\hat{y}_{i}}{x-z^{4}}</span></p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">where <span class="math">i</span> is the corresponding column index of the composition polynomial trace. This rational function is a polynomial of degree <span class="math">(\\deg(h_i(x)) - 1)</span> if and only if <span class="math">h_i(z^4) = \\hat{y}_i</span>.</p>

    <p class="text-gray-300">Denote the size of the mask by <span class="math">M_1</span>, the mask values <span class="math">\\{y_{j,s}\\}</span> by <span class="math">\\{y_{\\ell}\\}_{\\ell \\in [0,M_1 - 1]}</span> and the number of columns in the composition polynomial trace by <span class="math">M_2</span>. The verifier samples <span class="math">M = M_{1} + M_{2}</span> random elements from the extension field <span class="math">\\gamma_0\\ldots ,\\gamma_{M - 1}\\in \\mathbb{F}_p(\\phi)</span>. We define the DEEP Composition Polynomial as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {\\ell = 0} ^ {M _ {1} - 1} \\gamma_ {\\ell} \\cdot \\frac {f _ {j _ {\\ell}} (x) - y _ {\\ell}}{x - z g ^ {s _ {\\ell}}} + \\sum_ {i = 0} ^ {M _ {2} - 1} \\gamma_ {M _ {1} + i} \\cdot \\frac {h _ {i} (x) - \\hat {y} _ {i}}{x - z ^ {4}}</span></div>

    <p class="text-gray-300">where <span class="math">j_{\\ell}</span> and <span class="math">s_{\\ell}</span> are the column and row offset corresponding to <span class="math">y_{\\ell}</span>. This is a (random) linear combination of constraints of the form:</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {f (x) - y}{x - z}</span></div>

    <p class="text-gray-300">where <span class="math">f</span> is either a trace column polynomial or <span class="math">h_i</span> polynomial. Thus, proving that this linear combination is of low degree implies proving the low degree of the trace column polynomials and that of the <span class="math">h_i</span> polynomials, as well as that the DEEP values are correct.</p>

    <h2 id="sec-24" class="text-2xl font-bold">3.8.2 Verifying the Trace Values</h2>

    <p class="text-gray-300">In order to verify that the trace is defined over <span class="math">\\mathbb{F}_p</span>, we add yet another set of constraints that assert that the coefficients of each column polynomial is indeed from <span class="math">\\mathbb{F}_p</span> (rather than <span class="math">\\mathbb{F}_p(\\phi)</span>).</p>

    <p class="text-gray-300">Denote the conjugate of an element <span class="math">x \\in \\mathbb{F}_p(\\phi)</span> by <span class="math">\\overline{x}</span>. Recall that the mask of the Rescue AIR consists of two consecutive rows - two elements in each column. We pick a single row<span class="math">^{10}</span>, and for each column add the following constraint:</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {f _ {j} (x) - \\overline {{y _ {j , 0}}}}{x - \\overline {{z}}}</span></div>

    <p class="text-gray-300">This rational function is a polynomial of degree <span class="math">(\\deg(f_j) - 1)</span> if and only if <span class="math">f_j(\\overline{z}) = \\overline{y_{j,0}}</span>. Let <span class="math">m</span> denote the number of columns in the trace. The verifier then chooses another <span class="math">m</span> random extension field elements <span class="math">\\delta_0, \\ldots, \\delta_{m-1}</span> and adds the following linear combination to the DEEP composition polynomial:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {j = 0} ^ {m - 1} \\delta_ {i} \\cdot \\frac {f _ {j} (x) - \\overline {{y _ {j , 0}}}}{x - \\overline {{z}}}</span></div>

    <p class="text-gray-300">For a column polynomial <span class="math">f(x)</span>, if it holds for a random <span class="math">z \\in \\mathbb{F}_p(\\phi)</span> that <span class="math">f(\\overline{z}) = \\overline{f(z)}</span>, then (w.h.p) all the coefficients of <span class="math">f(x)</span> are from <span class="math">\\mathbb{F}_p</span>. Thus, proving that the new DEEP composition polynomial is of low degree, now also implies that the trace is defined over <span class="math">\\mathbb{F}_p</span> as desired.</p>

    <h2 id="sec-25" class="text-2xl font-bold">3.9 The FRI Protocol for Low Degree Testing</h2>

    <p class="text-gray-300">For low degree testing, we use an optimized variant of a protocol known as FRI (which stands for Fast Reed-Solomon Interactive Oracle Proof of Proximity) described in [BBHR18], with improved soundness bounds appearing in [BKS18, BGKS20, BCI+20]. The optimizations we use are described in Section 3.11. The FRI protocol consists of two phases: a commit phase and a query phase.</p>

    <p class="text-gray-300"><span class="math">^{10}</span>Since we verify that the coefficients of each column polynomial are from the appropriate field, adding the constraint for both mask values of each column is redundant. This is in contrast to verifying the mask values, where both mask values of each column are needed.</p>

    <p class="text-gray-300">Page 18</p>

    <p class="text-gray-300">3.9.1 Commit Phase</p>

    <p class="text-gray-300">In the basic FRI version, the prover splits the original DEEP composition polynomial of degree less than <span class="math">N</span>, denoted here as <span class="math">p_{0}(x)</span>, into two polynomials of degree less than <span class="math">N/2</span>, call them <span class="math">g_{0}(x)</span> and <span class="math">h_{0}(x)</span>, satisfying <span class="math">p_{0}(x)=g_{0}(x^{2})+x\\cdot h_{0}(x^{2})</span>. The verifier chooses a random value <span class="math">\\zeta_{0}\\in\\mathbb{F}_{p}(\\phi)</span>, sends it to the prover, and asks the prover to commit (using a Merkle commitment scheme) to the polynomial <span class="math">p_{1}(x)=g_{0}(x)+\\zeta_{0}\\cdot h_{0}(x)</span>. Note that <span class="math">p_{1}(x)</span> is of degree less than <span class="math">N/2</span>. (Looking ahead, in our optimized FRI version the degree reduction from <span class="math">p_{0}(x)</span> to <span class="math">p_{1}(x)</span> is actually from <span class="math">N</span> to <span class="math">N/2^{i}</span> for some <span class="math">i\\geq 1</span>, see Section 3.11.1.)</p>

    <p class="text-gray-300">We then continue recursively by splitting <span class="math">p_{1}(x)</span> into <span class="math">g_{1}(x)</span> and <span class="math">h_{1}(x)</span>, then constructing <span class="math">p_{2}(x)</span> with a random <span class="math">\\zeta_{1}\\in\\mathbb{F}_{p}(\\phi)</span> chosen by the verifier, and so on. Each time, the degree of the polynomial is halved. Hence, after <span class="math">\\log_{2}(N)</span> steps we are left with a constant polynomial, and the prover can simply send the constant value to the verifier.</p>

    <p class="text-gray-300">For the above protocol to work, we need the property that for every <span class="math">v</span> in the evaluation domain <span class="math">L</span>, it holds that <span class="math">-v</span> is also in <span class="math">L</span>, i.e., that <span class="math">L</span> be closed under negation. Moreover, the commitment on <span class="math">p_{1}(x)</span> will not be over <span class="math">L</span> but over <span class="math">L^{2}:=\\{x^{2}:x\\in L\\}</span>. Since we iteratively apply the FRI step, <span class="math">L^{2}</span> also has to be closed under negation, and so on. These algebraic requirements are satisfied via our choice of a multiplicative coset of size <span class="math">2^{k}</span> for integer <span class="math">k</span> as our evaluation domain.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">3.9.2 Query Phase</h4>

    <p class="text-gray-300">We now have to check that the prover did not cheat. Let <span class="math">L</span> be the evaluation domain. The verifier samples a random <span class="math">v\\in L</span> and queries <span class="math">p_{0}(v)</span> and <span class="math">p_{0}(-v)</span>. These two values suffice to determine the values of <span class="math">g_{0}(v^{2})</span> and <span class="math">h_{0}(v^{2})</span>, as can be seen by the following two linear equations in the two “variables” <span class="math">g_{0}(v^{2})</span> and <span class="math">h_{0}(v^{2})</span>:</p>

    <p class="text-gray-300"><span class="math">p_{0}(v)</span> <span class="math">=g_{0}(v^{2})+v\\cdot h_{0}(v^{2})</span> <span class="math">p_{0}(-v)</span> <span class="math">=g_{0}(v^{2})-v\\cdot h_{0}(v^{2})</span></p>

    <p class="text-gray-300">The verifier can solve this system of equations and deduce the values of <span class="math">g_{0}(v^{2})</span> and <span class="math">h_{0}(v^{2})</span>. It follows that it can compute the value of <span class="math">p_{1}(v^{2})</span> which is a linear combination of the two. Now the verifier queries <span class="math">p_{1}(v^{2})</span> and makes sure that it is equal to the value computed above. This serves as an indication that the commitment to <span class="math">p_{1}(x)</span>, which was sent by the prover in the commit phase, is indeed the correct one. The verifier may continue, by querying <span class="math">p_{1}(-v^{2})</span> (recall that <span class="math">(-v^{2})\\in L^{2}</span> and that the commitment on <span class="math">p_{1}(x)</span> was given on <span class="math">L^{2}</span>) and deduce from it <span class="math">p_{2}(v^{4})</span>.</p>

    <p class="text-gray-300">The verifier continues in this way until it uses all these queries to finally deduce the value of <span class="math">p_{\\log(d)}(v^{d})</span>. Recall that <span class="math">p_{\\log(d)}(x)</span> is a constant polynomial whose constant value was sent by the prover in the commit phase, prior to choosing <span class="math">v</span>. The verifier checks that the value sent by the prover is indeed equal to the value that the verifier computed from the queries to the previous functions.</p>

    <p class="text-gray-300">All query responses received by the verifier also need to be checked for consistency with the Merkle commitments sent by the prover during the commit phase. Hence, the prover sends decommitment information (Merkle paths) together with these responses to allow the verifier to enforce this.</p>

    <p class="text-gray-300">In addition, the verifier must also verify the values <span class="math">p_{0}(v)</span> and <span class="math">p_{0}(-v)</span> it received from the prover. Recall that the verifier does not maintain the DEEP composition polynomial <span class="math">p_{0}</span>. For this, the</p>

    <p class="text-gray-300">prover also sends the values of the trace <span class="math">f_{j}</span> and the composition polynomial trace <span class="math">h_{j}</span>, induced by the DEEP composition polynomial, together with their decommitments. Then, the verifier checks the consistency of these values with the commitments on the traces, calculates the values of <span class="math">p_{0}(v),p_{0}(-v)</span> and checks consistency with the values sent by the prover.</p>

    <p class="text-gray-300">In order to achieve the required soundness of the protocol, the query phase is repeated multiple times. In particular, to reach soundness error below <span class="math">2^{-\\lambda}</span>, and using a blowup factor of <span class="math">2^{k}</span>, we make a number <span class="math">\\lambda/k</span> of queries, using <em>[BCI^{+}20, Conjecture 7.3]</em> (with <span class="math">c_{1}=c_{2}=1</span> there), i.e., each query roughly contributes <span class="math">k</span> “bits of soundness” to the protocol.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">3.10 Transformation to Non-Interactive Protocol (the Fiat-Shamir heuristic)</h3>

    <p class="text-gray-300">So far, we described the proof generation process as an interactive protocol between a prover and a verifier. We now transform this interactive protocol into a non-interactive version, in which the prover generates a proof in the form of a file (or equivalent binary representation) and the verifier receives it to verify its correctness.</p>

    <p class="text-gray-300">The fundamental idea behind this construction is that the prover simulates receiving the randomness from the verifier. This is done by the Fiat-Shamir heuristic applied to the transformation of <em>[x1]</em> that converts interactive oracle proofs (IOPs) into non-interactive random oracle proofs (NIROPs). We extract randomness from a hash function that is applied to prior data sent by the prover (and appended to the proof). We initialize the seed by hashing a description of the statement – “Rescue hash chain”, and the public input, which are known to both the prover and the verifier.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that the AIR for the Rescue hash chain corresponds to the claim stated by Eq. (1). We use the chain_length ($</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1$) and the four field elements of output as the seed to the hash chain.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">3.11 Proof Length Optimizations</h3>

    <p class="text-gray-300">We employ several optimization techniques in order to reduce the proof size. These techniques are described in this section.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">3.11.1 Skipping FRI Layers</h4>

    <p class="text-gray-300">Instead of committing to each of the FRI layers in the commitment phase of the FRI protocol, the prover can skip layers and commit only to a subset of them. Doing that, the number of Merkle trees is reduced, which means that the prover has less decommitment paths to send to the verifier. There is a trade off, though. If, for example, the prover commits only to every third layer, in order to answer a query, it needs to decommit to 8 elements of the first layer (instead of only 2 in the standard case). This fact is taken into account in the commitment phase. It packs together neighbor elements in each leaf of the Merkle tree. For more details see Section 3.5. Thus, the cost of skipping layers is sending more field elements, but not more authentication paths.</p>

    <p class="text-gray-300">Skipping FRI layers can be configured using the fri_step_list parameter. The FRI reduction in the <span class="math">i</span>th layer will be <span class="math">2^{\\texttt{fri\\_step\\_list[i]}}</span> and the total reduction factor will be <span class="math">2^{\\sum_{i}\\texttt{fri\\_step\\_list[i]}}</span>.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">3.11.2 FRI Last Layer</h4>

    <p class="text-gray-300">Another FRI optimization used to reduce the proof size, is to terminate the FRI protocol earlier than when the last layer reaches a constant value. In such a case, instead of having the prover send</p>

    <p class="text-gray-300">only the constant value of the last layer as a commitment, the prover sends the coefficients of the polynomial representing the last layer. This allows the verifier to complete the protocol as before, without the need for commitments (and sending decommitments for field elements in following layers). The degree bound for early termination of the FRI protocol can be configured using the last_layer_degree_bound parameter.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">3.11.3 Grinding</h4>

    <p class="text-gray-300">As mentioned in Section 3.9, every query adds a certain number of bits to the security (soundness) of the proof. However, it also implies sending more decommitments which increases the proof size. One mechanism to reduce the need for many queries is to increase the cost of generating a false proof by a malicious prover. We achieve this by adding to the above protocol a requirement that following all the commitments made by the prover, the prover must find a 64 bit nonce that when hashed together with the state of the hash chain, results in a required number of leading zeros. The number of the leading zeros defines a certain amount of work that the prover must perform before generating the randomness representing the queries. As a result, a malicious prover that attempts to generate favorable queries will need to repeat the grinding process every time that a commitment is changed. On the other hand, an honest prover only needs to perform the grinding process once.</p>

    <p class="text-gray-300">This is similar to the grinding performed on many block-chains. The nonce found by the prover is sent to the verifier as part of the proof and in turn the verifier checks its consistency with the state of the hash chain by running the hash function once.</p>

    <p class="text-gray-300">The required number of leading zeros is configured by the proof_of_work_bits parameter.</p>

    <h2 id="sec-32" class="text-2xl font-bold">4 Measurements and Benchmarks</h2>

    <p class="text-gray-300">To estimate the concrete efficiency of our system, we ran experiments measuring the proving and verification time, the maximal memory consumption, and the generated proofs size, for different numbers of hash invocations, security levels and blowup factors. All the experiments, for both the prover and the verifier, were run on the same machine with the following specifications:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Operating-System: Linux 5.3.0-51-generic x86_64.</li>

      <li>CPU: Intel(R) Core(TM) i7-7700K @ 4.20GHz (4 cores, 2 threads per core).</li>

      <li>RAM: 16GB DDR4 (8GB <span class="math">\\times</span> 2, Speed: 2667 MHz)</li>

    </ol>

    <p class="text-gray-300">We note that while the prover uses multi-threading, in all of the experiments the verifier was restricted to utilize only a single thread. In addition, measurements corresponding to 80 bits of security are done using BLAKE2s with a digest size of 20 bytes (160 bits) as the underlying hash function, whereas measurements corresponding to 100 bits of security used BLAKE2s with a digest size of 25 bytes (200 bits).</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">4.1 Prover/Verifier Time and Proof Size vs. Number of Hash Invocations</h3>

    <p class="text-gray-300">In Figure 5 we present measurements of proving and verification time as well as proof size, as a function of the number of Rescue hash invocations. Recall that we fit batches of 3 hashes into 32 rows in the Rescue trace, see Section 3.1 for more details. Therefore, the number of hash invocations,</p>

    <p class="text-gray-300">also referred to as the chain length, is divisible by 3. Since the actual traces we produce must have a length that is a power of 2, we use  <span class="math">3 \\times 2^i</span> , for  <span class="math">i \\in [10, 18]</span> , as the number of hash invocations for our measurements.</p>

    <p class="text-gray-300">Since the values for the x-axis grow exponentially  <span class="math">(3\\times 2^{i})</span> , and the y-axis is on a logarithmic scale, the measurements in the top graphs in Figure 5 match our theoretical predictions that the amount of time spent by the prover scales nearly-linearly in the number of hash invocations. Whereas verification time and proof size scale poly-logarithmically in the number of hash invocations.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> (a) 80 bits of security.</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> (b) 100 bits of security. Figure 5: Verification time and proof size (bottom graphs) and proving time (top graphs) as a function of the number of Rescue hash invocations, measured for 80 bit security (left side) and 100 bits of security (right side). In the top graphs, the prover time is measured in seconds, while in the bottom graphs, the verifier time is measured in milliseconds.</p>

    <p class="text-gray-300">Recall that the blowup factor is the ratio between the size of the evaluation domain and the trace evaluation domain, see Section 3.4 for more details. In Fig. 6 we present measurements of proving/verifying time and proof size as a function of the blowup factor. The measurements are done with 80 bits of security, a chain length of size roughly 98K (98,304, to be precise) and blowup factors 4,8 and 16.</p>

    <p class="text-gray-300">It is evident from Figure 6 that the blowup factor enables shifting computation overheads between the prover and the verifier. For fixed security level, increasing the blowup factor increases</p>

    <p class="text-gray-300">STARKWARE</p>

    <p class="text-gray-300">prover time (blue bars) but reduces proof size (red bars) and verification time (green bars). Notice that none of the changes are linear, but rather sub-linear. I.e., as the blowup factor doubles  <span class="math">(4\\to 8</span>  and  <span class="math">8\\rightarrow 16)</span>  proving time increases only by  <span class="math">\\approx 50\\%</span>  while proof size and verification time decrease by  <span class="math">\\approx 25\\%</span> .</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Figure 6: Proving/verification time and proof size as a function of the blowup factor. Measurements are done with 80 bits of security and a chain length of size 98304.</p>

    <p class="text-gray-300">Memory Figure 7a depicts the prover's peak memory (RAM) consumption as a function of the number of Rescue hash invocations. It is readily apparent from the figure that: (i) memory consumption measured for 80 bits of security and 100 bits of security are fairly similar, (ii) prover memory requirements are satisfied by a machine with standard specifications, even for chain length nearing one million hashes, and (iii) as long as the computation fits inside the machine's available RAM, memory consumption matches the theoretical prediction of linear growth with the number of Rescue hash invocations. However, once memory consumption becomes larger than the available RAM, a deterioration in performance is expected (not discussed in the scope of this work). We stress that memory consumption need not scale linearly with chain length but rather, memory and proving time can be traded off, one against the other.</p>

    <p class="text-gray-300">STARKWARE</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> (a) Prover peak memory consumption.</p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> (b) Hash (BLAKE2s) count. Figure 7: Prover peak memory consumption and the number of underlying hash (BLAKE2s) invocations as a function of Rescue hash invocations.</p>

    <p class="text-gray-300">Recursion Any universal and succinct proof/argument of knowledge system (in particular, STARKs) can be used to incrementally verify computation [Val08, BCCT13]. This means that a computation may generate a proof that attests to the correctness of a previous instance of that computation, a concept known informally as "recursive proof composition", or, in our case, "recursive STARKs". In other words, a recursive STARK prover would generate a proof for a statement saying the state of a system can be moved from  <span class="math">x_{i}</span>  to  <span class="math">x_{i + 1}</span>  because the prover has verified a (recursive) proof attesting to the computational integrity of  <span class="math">x_{i}</span>  and has faithfully executed the computation on the state  <span class="math">x_{i}</span> , reaching the new state  <span class="math">x_{i + 1}</span> .</p>

    <p class="text-gray-300">While the impact of recursion depth is a delicate matter (cf. [Val08]), it is clear that a major part of the prover's computation in this case is focused on verifying a STARK proof. This requires verifying all the hashes in the decommitment paths of a previous STARK. For instance, if the statement proved recursively roughly matches our Eq. (1), the size of the recursive computation (i.e., the AIR and execution trace) would likely be dominated by the need to verify the correctness of the hash decommitments.</p>

    <p class="text-gray-300">In Figure 7b we present the number of hash invocations used in a proof of Eq. (1) for varying chain length, ranging between 3K and 786K hashes. Crucially, the number of hashes involved in decommitments of these statements does not reach even the lower end and ranges between  <span class="math">\\approx 1000</span>  and  <span class="math">\\approx 2700</span> . This suggests that for simple computational statements proved via STARKs that use the Rescue hash (instead of Blake2s) to commit to proof oracles, and for secure recursion depth (as discussed in [Val08]), recursive STARKs could be efficiently constructed.</p>

    <p class="text-gray-300">One of the main advantages on proof systems based on interactive oracle proofs is that in that model, knowledge soundness can be mathematically proven. The bulk of this section formally defines and proves the knowledge soundness of the ethSTARK IOP protocol. At the very end we discuss the security of the ethSTARK IOP, and this part resembles the kind of security analysis applied to other systems, e.g., ones whose security relies on conjecture but unproven number theoretic assumptions.</p>

    <p class="text-gray-300">In more detail, we start by formally defining the algebraic intermediate representation (AIR)</p>

    <p class="text-gray-300">STARKWARE</p>

    <p class="text-gray-300">format used by our system (Section 5.1), followed by formal definitions of soundness and knowledge soundness (Section 5.2). Then we define the particular IOP used to verify these AIR instances (Section 5.3). We describe the preliminary results needed to argue soundness in Section 5.4. Section 5.5 defines the knowledge extractor used in our soundness proof. In Section 5.6 we state the main theorem (Theorem 4) regarding knowledge soundness of the ethSTARK IOP protocol. The proof of this theorem appears in Section 5.7 and the sub-claims used in the proof are proved in Section 5.8. Section 5.9 discusses the IOP security. We end with parameter settings (Section 5.10).</p>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">5.1 Satisfiable Algebraic Intermediate Representations (AIRs)</h3>

    <p class="text-gray-300">The following definition is a variant on previous AIR definitions, like <em>[x1, Appendix B.2]</em>. It is catered towards the specific use case of ethSTARK and stated using multiplicative groups. Thus, the following definition restricts our attention only to finite fields <span class="math">\\mathbb{F}</span> that contain a large multiplicative subgroup of size <span class="math">2^{\\mathsf{h}}</span> even though the definition of an AIR could apply to more general fields.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a set <span class="math">S\\subseteq\\mathbb{F}</span>, we define the <em>vanishing polynomial</em> of <span class="math">S</span> to be <span class="math">\\mathsf{Z}_{S}(X):=\\prod_{\\alpha\\in S}(X-\\alpha)</span>. This is the unique monic polynomial of degree $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> whose set of roots is precisely </span>S$ (each root having multiplicity 1).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-38" class="text-base font-medium mt-4">Definition 1 (AIR).</h6>

    <p class="text-gray-300">An algebraic intermediate representation (AIR) is a tuple <span class="math">\\mathsf{A}=(\\mathbb{F},\\mathsf{w},\\mathsf{h},\\mathsf{d},\\mathsf{s},\\mathsf{g},\\mathsf{l},\\mathsf{Cset})</span> where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{F}</span> is a finite field</li>

      <li><span class="math">\\mathsf{w},\\mathsf{h},\\mathsf{d},\\mathsf{s}</span> are integers indicating the following sizes:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{w}</span> is the number of columns in the trace</li>

      <li><span class="math">\\mathsf{h}</span> denotes the logarithm of the size of a multiplicative subgroup used as the trace domain</li>

      <li><span class="math">\\mathsf{d}</span> is the maximal degree of a constraint</li>

      <li><span class="math">\\mathsf{s}</span> is the size of the set of constraints</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathsf{g}</span> is a generator of a multiplicative group $\\mathsf{H}_{0}\\subset\\mathbb{F}^{*},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{\\mathsf{h}}<span class="math">. We call </span>\\mathsf{H}_{0}$ the <em>trace domain</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{I}\\subseteq\\{1,\\ldots,\\mathsf{w}\\}\\times\\{0,\\ldots,2^{\\mathsf{h}}-1\\}</span> is a set of pairs of indices known as the set of <em>mask indices</em>. Let <span class="math">\\mathsf{Y}=\\{\\mathsf{Y}_{i,j}:(i,j)\\in\\mathsf{I}\\}</span> be a set of formal variables, called the <em>mask variables</em>, indexed by elements of <span class="math">\\mathsf{I}</span>.</li>

      <li><span class="math">\\mathsf{Cset}=\\{\\mathsf{C}_{1},\\ldots,\\mathsf{C}_{\\mathsf{s}}\\}</span> is a finite set of constraints, of size <span class="math">\\mathsf{s}</span>. Each constraint is an ordered pair <span class="math">\\mathsf{C}_{i}=(Q_{i},\\mathsf{H}_{i})</span> where:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Q_{i}\\in\\mathbb{F}^{\\leq\\mathsf{d}}[\\mathsf{Y}]</span> is a multivariate polynomial over the mask variables, of total degree at most <span class="math">\\mathsf{d}</span>, called the <em>i</em>th constraint polynomial.</li>

      <li><span class="math">\\mathsf{H}_{i}\\subseteq\\mathsf{H}_{0}</span> is a subset of the trace domain, called the <em>i</em>th constraint enforcement domain</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We use $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Cset}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ to denote the arithmetic complexity of the constraints, defined as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Cset}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:=\\sum_{i=1}^{\\mathsf{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the arithmetic circuit computing the polynomial </span>Q_{i}<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the arithmetic complexity of the vanishing polynomial </span>\\mathsf{Z}_{\\mathsf{H}_{i}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the case of the ethSTARK statement of Eq. (1) we have $\\mathsf{w}=12,\\mathsf{d}=3,\\mathsf{s}=52,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{I}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2\\mathsf{w}=24<span class="math"> because the mask involves two consecutive rows of the execution trace, and for chain length of </span>3\\cdot 2^{k}<span class="math"> we have </span>\\mathsf{h}=k+5<span class="math">; this latter parameter is the only one that depends on the chain length and, concretely, for the target length of 98304 we have </span>\\mathsf{h}=20$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-39" class="text-base font-medium mt-4">Remark 1 (Boundary constraints).</h6>

    <p class="text-gray-300">Prior definitions of AIRs (cf. <em>[x1]</em>) include a set of boundary constraints that vary among instances (in our setting, the boundary constraints include the claimed hash digest). Our protocol treats such a boundary constraint as a special case of constraint, in which <span class="math">\\mathsf{H}_{i}</span> is a singleton.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Definition 2 (AIR assignment and composition).</h6>

    <p class="text-gray-300">An <em>AIR assignment</em> is a sequence of polynomials <span class="math">\\vec{\\mathsf{P}}=(\\mathsf{P}_{1},\\ldots,\\mathsf{P}_{\\mathsf{w}}),\\mathsf{P}_{i}\\in\\mathbb{F}[X]</span>.</p>

    <p class="text-gray-300">Given an AIR constraint polynomial <span class="math">Q\\in\\mathbb{F}[\\mathsf{Y}]</span>, the <em>composition</em> of <span class="math">Q</span> and the assignment <span class="math">\\vec{\\mathsf{P}}</span> is the univariate polynomial denoted <span class="math">Q\\circ\\vec{\\mathsf{P}}\\in\\mathbb{F}[X]</span> that is obtained by replacing each variable <span class="math">\\mathsf{Y}_{i,j}\\in\\mathsf{Y}</span> that appears in <span class="math">Q(\\mathsf{Y})</span> with the polynomial <span class="math">\\mathsf{P}_{i}(\\mathsf{g}^{j}\\cdot X)\\in\\mathbb{F}[X]</span>. Henceforth we use <span class="math">Y\\leftarrow Z</span> to denote that <span class="math">Z</span> replaces <span class="math">Y</span>.</p>

    <p class="text-gray-300">Notice that if the total degree of <span class="math">Q</span> is <span class="math">\\mathsf{d}</span> and the maximal degree of <span class="math">\\mathsf{P}_{i}</span> is <span class="math">d^{\\prime}</span> then <span class="math">\\deg(Q\\circ\\vec{\\mathsf{P}})\\leq\\mathsf{d}\\cdot d^{\\prime}</span>.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Definition 3 (Satisfiability).</h6>

    <p class="text-gray-300">An AIR assignment <span class="math">\\vec{\\mathsf{P}}=(\\mathsf{P}_{1},\\ldots,\\mathsf{P}_{\\mathsf{w}}),\\mathsf{P}_{i}\\in\\mathbb{F}[X]</span> is said to <em>satisfy</em> an AIR <span class="math">\\mathsf{A}=(\\mathbb{F},\\mathsf{w},\\mathsf{h},\\mathsf{d},\\mathsf{s},\\mathsf{g},\\mathsf{I},\\mathsf{Cset})</span> if and only if</p>

    <p class="text-gray-300"><span class="math">\\forall i\\in[\\mathsf{s}]:\\quad x\\in\\mathsf{H}_{i}\\Rightarrow(Q_{i}\\circ\\vec{\\mathsf{P}})(x)=0.</span></p>

    <p class="text-gray-300">In words, <span class="math">\\vec{\\mathsf{P}}</span> satisfies <span class="math">\\mathsf{A}</span> iff for every constraint <span class="math">\\mathsf{C}_{i}=(Q_{i},\\mathsf{H}_{i})\\in\\mathsf{Cset}</span> it holds that <span class="math">Q_{i}\\circ\\vec{\\mathsf{P}}</span> vanishes on <span class="math">\\mathsf{H}_{i}</span>. We say that the AIR <span class="math">\\mathsf{A}</span> is satisfiable if there exists an AIR assignment <span class="math">\\vec{\\mathsf{P}}</span> that satisfies it.</p>

    <p class="text-gray-300">Notice that <span class="math">Q_{i}\\circ\\vec{\\mathsf{P}}</span> vanishes on <span class="math">\\mathsf{H}_{i}</span> if and only if the polynomial <span class="math">\\mathsf{Z}_{\\mathsf{H}_{i}}(X)</span> divides <span class="math">(Q_{i}\\circ\\vec{\\mathsf{P}})(X)</span> in the ring <span class="math">\\mathbb{F}[X]</span>, i.e., <span class="math">(Q_{i}\\circ\\vec{\\mathsf{P}})(X)/\\mathsf{Z}_{\\mathsf{H}_{i}}(X)\\in\\mathbb{F}[X]</span>.</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">5.2 Soundness, knowledge soundness and security</h3>

    <p class="text-gray-300">Recall the definition of the interactive oracle proof (IOP) model <em>[x23, x3]</em>. We recall the standard notions of soundness and knowledge soundness in this model, as well as the notion of security from <em>[x2, Section 1.1]</em>. We use <span class="math">\\mathsf{V},\\mathsf{P}</span> to denote the IOP verifier and prover, and allow them to receive auxiliary parameters <span class="math">\\mathsf{aux}</span> that may depend on <span class="math">\\mathsf{A}</span>, in addition to the AIR instance (as indeed will be the case later on).</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Definition 4 (Soundness and Knowledge Soundness).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{L}_{\\mathsf{AIR}}</span> be the language of satisfiable AIR instances as defined above. We say that an interactive oracle proof (IOP) protocol verifies <span class="math">\\mathsf{L}_{\\mathsf{AIR}}</span> with <em>soundness error</em> at most <span class="math">\\epsilon</span> if the following two conditions hold. If the third condition holds as well, we say the IOP has <em>knowledge soundness error</em> at most <span class="math">\\epsilon</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: There exists a prover <span class="math">\\mathsf{P}</span> such that <span class="math">\\forall\\mathsf{A}\\in\\mathsf{L}_{\\mathsf{AIR}}</span>, and letting <span class="math">\\mathsf{aux}=\\mathsf{aux}(\\mathsf{A})</span> denote the auxiliary parameters used by the protocol:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr[\\langle\\mathsf{V}(\\mathsf{A},\\mathsf{aux})\\leftrightarrow\\mathsf{P}(\\mathsf{A},\\mathsf{aux})\\rangle=\\mathsf{accept}]=1,</span></p>

    <p class="text-gray-300">where <span class="math">\\langle\\mathsf{V}(\\mathsf{A},\\mathsf{aux})\\leftrightarrow\\mathsf{P}(\\mathsf{A},\\mathsf{aux})\\rangle</span> denotes the verifier’s output after receiving input <span class="math">(\\mathsf{A},\\mathsf{aux})</span> and interacting with the prover (which also receives <span class="math">\\mathsf{A},\\mathsf{aux}</span> as input).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness: For every instance <span class="math">\\mathsf{A}</span>, auxiliary information <span class="math">\\mathsf{aux}</span> and prover <span class="math">\\mathsf{P}^{*}(\\mathsf{A},\\mathsf{aux})</span> the following holds:</li>

    </ul>

    <p class="text-gray-300">If <span class="math">\\operatorname<em>{Pr}[\\langle \\mathsf{V}(\\mathsf{A},\\mathsf{aux})\\leftrightarrow \\mathsf{P}^{</em>}(\\mathsf{A},\\mathsf{aux})\\rangle = \\mathsf{accept}]\\geq \\epsilon</span>, then <span class="math">\\mathsf{A}\\in \\mathsf{L}_{\\mathsf{AIR}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Knowledge soundness: There exists an algorithm <span class="math">\\mathsf{E}</span> — the knowledge extractor — that runs in expected time that is polynomial in $\\mathsf{w}, 2^{\\mathsf{h}}, \\mathsf{d},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Cset}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>1 / \\epsilon<span class="math"> (a Las Vegas algorithm), and for any instance </span>\\mathsf{A}<span class="math">, auxiliary information </span>\\mathsf{aux}<span class="math"> and prover </span>\\mathsf{P}^{*}(\\mathsf{A},\\mathsf{aux})$ the following condition holds:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If <span class="math">\\operatorname<em>{Pr}[\\langle \\mathsf{V}(\\mathsf{A},\\mathsf{aux})\\leftrightarrow \\mathsf{P}^{</em>}(\\mathsf{A},\\mathsf{aux})\\rangle = \\mathsf{accept}]\\geq \\epsilon</span>, then <span class="math">\\mathsf{E}(\\mathsf{A},\\mathsf{aux},\\mathsf{P}^{*}(\\mathsf{A},\\mathsf{aux})) = \\vec{\\mathsf{P}}</span> and <span class="math">\\vec{\\mathsf{P}}</span> satisfies A.</p>

    <p class="text-gray-300">An IOP that has knowledge soundness error at most <span class="math">\\epsilon</span> also has soundness error at most <span class="math">\\epsilon</span> but the converse is not necessarily true.</p>

    <h2 id="sec-44" class="text-2xl font-bold">5.3 The IOP Protocol</h2>

    <p class="text-gray-300">We now describe the specific IOP used in the ethSTARK system. It satisfies the definition of a Scalable Transparent IOP of Knowledge (STIK) as per [BBHR19, Definition 3.3]. Since it relies on AIRs for arithmetization and uses the FRI protocol for low-degree testing, it may be called a FRI-AIR, or an AIR-FRI<span class="math">^{12}</span>, STIK. When instantiated with Merkle tree commitments instead of oracles, it satisfies the definition of a Scalable Transparent ARgument of Knowledge (STARK) from [BBHR19] and may be called a FRI-AIR (or AIR-FRI) STARK to distinguish it from other STARKs that use different methods, like [BCG+19] which uses succinct-R1CS arithmetization instead of AIR.</p>

    <p class="text-gray-300">To describe this IOP we need to define the auxiliary inputs <span class="math">\\mathsf{aux}</span> used by it:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathbb{K}</span> is a finite extension of <span class="math">\\mathbb{F}</span>, of size <span class="math">q^{\\mathrm{e}}, \\mathrm{e} \\geq 1</span> where $q =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{D} \\subset \\mathbb{K}^<em></span> is a nontrivial coset of a multiplicative group <span class="math">^13</span> <span class="math">\\mathsf{D}_0 \\subset \\mathbb{K}^</em></span> where <span class="math">\\mathsf{D}_0 \\supset \\mathsf{H}_0</span>. We call <span class="math">\\mathsf{D}</span> the evaluation domain, noticing it is disjoint from the trace domain <span class="math">\\mathsf{H}_0</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathsf{k}&#x27;</span> denotes the logarithm of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, i.e., </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{\\mathsf{k}'}<span class="math">, where </span>\\mathsf{k}' &gt; \\mathsf{h}<span class="math">. We define the rate of the IOP by </span>\\rho := 2^{\\mathsf{h}} / 2^{\\mathsf{k}'}<span class="math"> and the IOP blowup factor is </span>1 / \\rho$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{aux}_{\\mathsf{FRI}}</span> is auxiliary information required by the FRI protocol (to be defined later)</li>

    </ul>

    <p class="text-gray-300">We shall also use the following notation:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">(x_0, y_0) \\in (\\mathbb{K} \\setminus \\mathsf{D}) \\times \\mathbb{K}</span> and <span class="math">f: \\mathsf{D} \\to \\mathbb{K}</span> let the quotient of <span class="math">f</span> by <span class="math">(x_0, y_0)</span> be the function</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {Quotient} \\left(f; x _ {0}, y _ {0}\\right): \\mathrm {D} \\rightarrow \\mathbb {F}, \\quad \\operatorname {Quotient} \\left(f; x _ {0}, y _ {0}\\right) (x) := \\frac {f (x) - y _ {0}}{x - x _ {0}}.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathsf{RS}[\\mathbb{K}, S, \\rho]</span> denote the Reed-Solomon code over field <span class="math">\\mathbb{K}</span>, evaluation domain <span class="math">S</span> and rate <span class="math">\\rho</span>:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{RS}[\\mathbb{K}, S, \\rho] = \\{f: S \\to \\mathbb{K}: \\deg (f) &lt; \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><span class="math">^{12}</span>These names were suggested by Pratyush Mishra and Daira Hopwood, respectively.</p>

    <p class="text-gray-300"><span class="math">^{13}</span>The ethSTARK implementation uses <span class="math">\\mathsf{D} \\cup \\mathsf{D}_0 \\subset \\mathbb{F}^*</span>, for computational efficiency, but we opt for a more general definition as it does not affect soundness.</p>

    <p class="text-gray-300">Page 27</p>

    <p class="text-gray-300">Description of the protocol</p>

    <p class="text-gray-300">The protocol starts with an AIR instance <span class="math">\\mathsf{A} = (\\mathbb{F}, \\mathsf{w}, \\mathsf{h}, \\mathsf{d}, \\mathsf{s}, \\mathsf{g}, \\mathsf{I}, \\mathsf{Cset})</span> and auxiliary IOP parameters <span class="math">\\mathsf{aux} = (\\mathbb{K}, \\mathsf{e}, \\mathsf{D}, \\mathsf{k}&#x27;, \\mathsf{aux}_{\\mathsf{FRI}})</span> given to both prover and verifier. We proceed as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Preprocessing:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Constraint weighted degree: For each constraint <span class="math">\\mathsf{C}_i = (Q_i, \\mathsf{H}_i) \\in \\mathsf{Cset}</span> define the <span class="math">i</span>th composed degree as</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {d} _ {i} := \\deg (Q _ {i}) \\cdot (2 ^ {\\mathrm {h}} - 1) -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {H} _ {i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Designated degree: Let <span class="math">\\mathsf{d}_{\\max}</span> be the smallest integral power of 2 that is strictly greater than <span class="math">\\max_{i\\in [\\mathbf{s}]} \\mathbf{d}_i</span>. Let <span class="math">\\mathsf{a} := \\mathsf{d}_{\\max} / 2^{\\mathsf{h}}</span>.</li>

      <li>Degree correction: For each <span class="math">C_i \\in Cset</span> let the degree correction parameter be <span class="math">c_i := d_{\\max} - d_i - 1</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Execution trace oracle: Prover sends oracle functions <span class="math">f_{1}, \\ldots, f_{\\mathsf{w}}: \\mathsf{D} \\to \\mathbb{K}</span>. The function <span class="math">f_{i}</span> is supposedly the evaluation of some polynomial <span class="math">\\mathsf{P}_{i}(X) \\in \\mathbb{F}[X], \\deg(\\mathsf{P}_{i}) &amp;lt; 2^{\\mathsf{h}}</span> where <span class="math">\\vec{\\mathsf{P}} = (\\mathsf{P}_{1}, \\ldots, \\mathsf{P}_{\\mathsf{w}})</span> is an AIR assignment that satisfies A. Notice that if <span class="math">\\mathsf{D} \\subset \\mathbb{F}</span> (as is the case with ethSTARK, see Footnote 13) then <span class="math">f_{1}, \\ldots, f_{\\mathsf{w}}</span> have their range in <span class="math">\\mathbb{F}</span> as well (cf. Remark 2).</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Constraint randomness: Verifier samples uniform randomness <span class="math">\\vec{r} := (r_1, r_1&#x27;, \\ldots, r_s, r_s&#x27;) \\in \\mathbb{K}^{2s}</span>, two elements per constraint, and defines the following constraint <span class="math">Q^{\\vec{r}}</span>, which is a rational function over variables <span class="math">(X, Y)</span> (i.e., <span class="math">Q^{\\vec{r}}(X, Y) \\in \\mathbb{K}(X, Y)</span>):</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">Q ^ {\\vec {r}} (X, \\Upsilon) := \\sum_ {i = 1} ^ {s} \\left(r _ {i} + r _ {i} ^ {\\prime} \\cdot X ^ {c _ {i}}\\right) \\cdot \\frac {Q _ {i} (\\Upsilon)}{Z _ {H _ {i}} (X)}. \\tag {5}</span></div>

    <p class="text-gray-300">Notice that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Q^{\\vec{r}}(X, Y)</span> has no poles outside of <span class="math">H_0</span> so it can be evaluated on any <span class="math">x \\notin H_0</span>.</li>

      <li>Assuming (i) <span class="math">\\Upsilon_{i,j}</span> is replaced by a polynomial <span class="math">\\mathsf{P}_{i,j}</span> of degree strictly less than <span class="math">2^{\\mathsf{h}}</span>, and (ii) <span class="math">Q_{i} \\circ \\vec{\\mathsf{P}}</span> vanishes on <span class="math">\\mathsf{H}_i</span>, we conclude that each summand on the right hand side of Eq. (5) is a polynomial <span class="math">R_i^{\\vec{r}}(X), \\deg(R_i^{\\vec{r}}(X)) &amp;lt; \\mathsf{d}_{\\max}</span>. Let <span class="math">R^{\\vec{r}}(X)</span> denote the sum of these <span class="math">\\mathsf{s}</span> polynomials.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Constraint trace oracle: Prover sends oracle functions <span class="math">f_0^{\\vec{r}}, \\ldots, f_{\\mathsf{a} - 1}^{\\vec{r}}: \\mathsf{D} \\to \\mathbb{K}</span>. The function <span class="math">f_i^{\\vec{r}}</span> is supposedly the evaluation on <span class="math">\\mathsf{D}</span> of a polynomial <span class="math">\\mathsf{P}_i^{\\vec{r}}(X), \\deg(\\mathsf{P}_i^{\\vec{r}}) &amp;lt; 2^{\\mathsf{h}}</span> such that <span class="math">\\mathsf{P}_0^{\\vec{r}}, \\ldots, \\mathsf{P}_{\\mathsf{a} - 1}^{\\vec{r}}</span> satisfy</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(Q ^ {\\vec {r}} (X, Y) \\circ \\vec {P}\\right) (X) = \\sum_ {k = 0} ^ {a - 1} X ^ {k} \\cdot P _ {k} ^ {\\vec {r}} \\left(X ^ {a}\\right). \\tag {6}</span></div>

    <p class="text-gray-300">I.e., supposedly the right hand side above equals <span class="math">R^{\\vec{r}}(X)</span> from the previous step.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. DEEP query: Verifier samples DEEP query <span class="math">\\mathfrak{q}</span> uniformly at random from <span class="math">\\mathbb{K}^<em> \\setminus (\\mathsf{H}_0 \\cup \\bar{\\mathsf{D}})</span> where <span class="math">\\bar{\\mathsf{D}} = \\{y \\in \\mathbb{K}^</em> : y^{\\mathsf{a}} \\in \\mathsf{D}\\}</span>. (We forbid <span class="math">\\mathfrak{q} \\in \\mathsf{H}_0</span> to ensure we can evaluate Eq. (7), and forbid <span class="math">\\mathfrak{q} \\in \\bar{\\mathsf{D}}</span> to ensure we can apply the quotient operation in Step 7.) Notice $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathsf{D}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathsf{a} \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">STARKWARE Page 28</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>DEEP answer: Prover sends an answer sequence <span class="math">\\mathsf{answer} = \\{\\alpha_{i,j}:(i,j)\\in \\mathsf{I}\\} \\cup \\{\\beta_k:k\\in \\{0,\\ldots ,\\mathsf{a} - 1\\} \\} \\in \\mathbb{K}^{\\mathsf{I}\\cup [\\mathsf{a}]}</span>, supposedly <span class="math">\\alpha_{i,j} = \\mathsf{P}_i(\\mathsf{q}\\cdot \\mathsf{g}^j)</span> and <span class="math">\\beta_{k} = \\mathsf{P}_{k}^{\\mathsf{r}}(\\mathsf{q}^{\\mathsf{a}})</span>. We say the constraint <span class="math">Q^{\\bar{r}}(X,\\Upsilon)</span> is validated by answer if the following equality holds:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">Q ^ {\\bar {r}} \\left(\\mathbf {q}, \\left\\{\\Upsilon_ {i, j} \\leftarrow \\alpha_ {i, j} \\right\\}\\right) = \\sum_ {k = 0} ^ {\\mathrm {a} - 1} \\mathbf {q} ^ {k} \\cdot \\beta_ {k} \\tag {7}</span></div>

    <p class="text-gray-300">where, recall, <span class="math">\\mathsf{Y}_{i,j}\\gets \\alpha_{i,j}</span> means evaluating<span class="math">^{14}</span> <span class="math">\\mathsf{Y}_{i,j}</span> to <span class="math">\\alpha_{i,j}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>FRI combination randomness: Verifier samples randomness</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {r} ^ {F} := \\left\\{\\mathsf {r} _ {(i, j)} ^ {F}: (i, j) \\in \\mathsf {I} \\right\\} \\cup \\left\\{\\mathsf {r} _ {k} ^ {F}: k \\in \\{0, \\dots , \\mathsf {a} - 1 \\} \\right\\} \\in \\mathbb {K} ^ {\\mathsf {I} \\cup [ \\mathsf {a} ]}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>FRI protocol: Both parties apply FRI with auxiliary information <span class="math">\\mathsf{aux}_{\\mathsf{FRI}}</span> to check proximity to the code <span class="math">\\mathsf{RS}[\\mathbb{K},\\mathsf{D},\\rho]</span> of the function <span class="math">g_{(\\vec{r},\\mathbf{q},\\mathsf{answer},\\mathbf{r}^F)}:\\mathsf{D}\\to \\mathbb{K}</span> defined thus:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">g _ {(\\vec {r}, \\mathbf {q}, \\text {answer}, r ^ {F})} (x) := \\sum_ {(i, j) \\in I} r _ {(i, j)} ^ {F} \\cdot \\text {Quotient} \\left(f _ {i}; \\mathbf {q} \\cdot \\mathbf {g} ^ {j}, \\alpha_ {i, j}\\right) (x) + \\sum_ {k = 0} ^ {\\mathrm {a} - 1} r _ {k} ^ {F} \\cdot \\text {Quotient} \\left(f _ {k} ^ {\\bar {r}}; \\mathbf {q} ^ {\\mathrm {a}}, \\beta_ {k}\\right) (x) \\tag {8}</span></div>

    <p class="text-gray-300">The answer to a FRI query to <span class="math">g_{(\\vec{r},\\mathbf{q},\\mathsf{answer},\\mathbf{r}^F)}</span> at <span class="math">x_0</span> is simulated by querying each <span class="math">f_{i}(x_{0}), i = 1,\\dots ,\\mathsf{w}</span> and <span class="math">f_{k}^{\\bar{r}}(x_{0}), k = 0,\\ldots ,\\mathsf{a} - 1</span> and computing the value of <span class="math">g_{(\\vec{r},\\mathbf{q},\\mathsf{answer},\\mathbf{r}^F)}(x_0)</span> according to the equation above. Namely, if <span class="math">y_{i} = f_{i}(x_{0})</span> and <span class="math">z_{k} = f_{k}^{\\bar{r}}(x_{0})</span> then set</p>

    <div class="my-4 text-center"><span class="math-block">g _ {(\\vec {r}, \\mathbf {q}, \\text {answer}, r ^ {F})} (x _ {0}) := \\sum_ {(i, j) \\in I} r _ {(i, j)} ^ {F} \\cdot \\frac {y _ {i} - \\alpha_ {i , j}}{x _ {0} - \\mathbf {q} \\cdot \\mathbf {g} ^ {j}} + \\sum_ {k = 0} ^ {\\mathrm {a} - 1} r _ {k} ^ {F} \\cdot \\frac {z _ {k} - \\beta_ {k}}{x _ {0} - \\mathbf {q} ^ {\\mathrm {a}}}</span></div>

    <p class="text-gray-300">Notice that <span class="math">g_{(\\vec{r},\\mathbf{q},\\mathsf{answer},\\mathbf{r}^F)}(x_0)</span> is well defined because <span class="math">x_0 \\in \\mathsf{D}</span> but <span class="math">\\mathbf{g}^j \\cdot \\mathbf{q}</span> and <span class="math">\\mathbf{q}^{\\mathbf{a}}</span> do not belong to <span class="math">\\mathsf{D}</span> so all denominators in the sum above are nonzero.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Decision: Verifier accepts iff (i) the FRI protocol accepts <span class="math">g_{(\\vec{r},\\mathbf{q},\\mathsf{answer},\\mathbf{r}^F)}</span> and (ii) the random constraint <span class="math">Q^{\\bar{r}}(X,\\Upsilon)</span> is validated by the answers provided by the prover, i.e., Eq. (7) holds.</li>

    </ol>

    <p class="text-gray-300"><strong>Remark 2 (Subfield test).</strong> The ethSTARK code includes an additional test, described in Section 3.8.2, for ensuring that the AIR assignment is over the subfield <span class="math">\\mathbb{F}</span> and not the larger field <span class="math">\\mathbb{K}</span>. We omit this sub-field test because it is not needed for soundness.</p>

    <p class="text-gray-300"><strong>Remark 3 (Field structure).</strong> The IOP protocol above requires <span class="math">\\mathbb{K}</span> to contain some sufficiently large 2-smooth multiplicative group. Thus, the protocol can only be applied to AIR instances over such fields. Since ethSTARK is defined over such fields this does not pose a problem. Note that the protocol can be modified to work over any field that contains a sufficiently large smooth additive or multiplicative sub-group. In particular, this includes fields of small characteristic (like binary fields). See [BBHR18, BBHR19] for details.</p>

    <p class="text-gray-300">Page 29</p>

    <p class="text-gray-300">5.4 Prior results needed for the analysis</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In our proof of Theorem 4 we shall rely on several prior results, stated here. In this section <span class="math">V=\\mathsf{RS}[\\mathbb{F}_{q},\\mathsf{D},\\rho]</span>, $n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span>k=\\rho n<span class="math"> and </span>\\rho=2^{-R}<span class="math"> for a positive integer </span>R<span class="math">, and </span>\\mathsf{D}<span class="math"> is a coset of a multiplicative subgroup of </span>\\mathbb{F}_{q}<span class="math">, the size of which is a power of </span>2<span class="math">. For the next result we say that </span>V\\subset\\mathbb{F}_{q}^{n}<span class="math"> is </span>(\\gamma,\\ell)<span class="math">-list decodable if for every </span>u\\in\\mathbb{F}_{q}^{n}<span class="math">; there are no more than </span>\\ell<span class="math"> codewords of </span>V<span class="math"> that are within relative Hamming distance at most </span>\\gamma<span class="math"> from </span>u$. Our first result is the Johnson bound for RS codes; see, e.g., <em>[x10, Theorem 3.3]</em> for a proof of this particular version.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-45" class="text-base font-medium mt-4">Theorem 1 (Johnson bound).</h6>

    <p class="text-gray-300">For every <span class="math">\\eta\\in(0,1-\\sqrt{\\rho})</span>, the code <span class="math">V</span> is <span class="math">(1-\\sqrt{\\rho}-\\eta,1/(2\\eta\\sqrt{\\rho}))</span>-list-decodable. (Moreover, the same list decoding bound holds for any maximum distance separable (MDS) code of rate <span class="math">\\rho</span>.)</p>

    <p class="text-gray-300">The next result is the polynomial time list-decoding algorithm of Guruswami and Sudan for RS codes <em>[x12]</em>.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Theorem 2 (Guruswami–Sudan list decoding).</h6>

    <p class="text-gray-300">The Guruswami–Sudan list decoding algorithm on received word <span class="math">u:\\mathsf{D}\\to\\mathbb{F}_{q}</span>, RS code <span class="math">V</span> and slackness parameter <span class="math">\\eta&gt;0</span> outputs the list of codewords in <span class="math">V</span> that agree with <span class="math">u</span> on at least a <span class="math">\\sqrt{\\rho}+\\eta</span> fraction of <span class="math">\\mathsf{D}</span>, in expected time that is polynomial in <span class="math">n,1/\\rho,1/\\eta</span> and <span class="math">\\log q</span>.</p>

    <p class="text-gray-300">From <em>[BCI^{+}20]</em> we use the state-of-the-art bounds on the soundness error of the batched FRI protocol. Recall that the batched FRI protocol starts with a commitment to a sequence of <span class="math">l+1</span> functions <span class="math">u_{0},\\ldots,u_{l}:\\mathsf{D}\\to\\mathbb{K}</span> and applies the (non-batched) FRI protocol to a uniformly random element in the affine space <span class="math">U</span> spanned by <span class="math">u_{1},\\ldots,u_{l}</span> and shifted by <span class="math">u_{0}</span>. Thus, in the first round of the batched FRI protocol the verifier <span class="math">\\mathsf{V}_{\\mathsf{FRI}}</span> samples uniformly random <span class="math">x_{1},\\ldots,x_{l}\\in\\mathbb{K}</span> and the prover commits to <span class="math">u:\\mathsf{D}\\to\\mathbb{K}</span>, where supposedly</p>

    <p class="text-gray-300"><span class="math">u=u_{0}+\\sum_{i}x_{i}u_{i}.</span> (9)</p>

    <p class="text-gray-300">Then the standard (non-batched) FRI protocol is applied to <span class="math">u</span> using <span class="math">\\mathsf{r}</span> rounds, where in the <span class="math">i</span>th round of the COMMIT phase a <span class="math">t_{i}</span>-to-1 map is applied to the <span class="math">i</span>th oracle to obtain the next oracle which is smaller by a <span class="math">\\times t_{i}</span> factor. For the batched setting we also apply the following natural modification: each query to <span class="math">u(x)</span> by the (non-batched) FRI verifier is augmented with queries to <span class="math">u_{0}(x),\\ldots,u_{l}(x)</span> and that invocation of the QUERY phase is rejected if Eq. (9) does not hold with respect to <span class="math">x</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\langle\\mathsf{V}_{\\mathsf{FRI}}^{U}(\\vec{t},s)\\leftrightarrow\\mathsf{P}_{\\mathsf{FRI}}^{U}(\\vec{t})\\rangle</span> denote the batched FRI verifier decision at the end of the protocol, when using a single COMMIT phase with a sequence of <span class="math">\\vec{t}=(t_{0},\\ldots,t_{\\mathsf{r}-1})</span>-to-1 maps and <span class="math">s</span> independent invocations of the QUERY phase, and we denote by <span class="math">\\mathsf{aux}_{\\mathsf{FRI}}=(\\vec{t},s)</span> the auxiliary information needed to execute the FRI protocol. This decision is a random variable depending on the randomness used by <span class="math">\\mathsf{V}_{\\mathsf{FRI}}^{U}</span> and the intermediate commitments supplied by <span class="math">\\mathsf{P}_{\\mathsf{FRI}}^{U}</span>. The following statement is <em>[BCI^{+}20, Theorem 8.3]</em>.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Theorem 3 (Batched FRI soundness error).</h6>

    <p class="text-gray-300">Let <span class="math">U=u_{0}+\\mathsf{span}\\{u_{1},\\ldots,u_{l}\\}\\subset\\mathbb{F}_{q}^{\\mathsf{D}}</span> be the affine space spanned by <span class="math">u_{1},\\ldots,u_{l}\\in\\mathbb{F}_{q}^{\\mathsf{D}}</span> and shifted by <span class="math">u_{0}</span>. Suppose the batched FRI verifier <span class="math">\\mathsf{V}_{\\mathsf{FRI}}^{U}(\\vec{t},s)</span> described above is invoked for checking proximity of <span class="math">U=u_{0}+\\mathsf{span}(u_{1},\\ldots,u_{l})</span> to <span class="math">V</span>. For an integer <span class="math">m\\geq 3</span> let</p>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\mathsf{FRI}}(q,n,\\rho,m,s,\\vec{t})=\\frac{\\left(m+\\frac{1}{2}\\right)^{7}\\cdot n^{2}}{2\\rho^{3/2}q}+\\frac{(2m+1)\\cdot(n+1)}{\\sqrt{\\rho}}\\cdot\\frac{\\sum_{i=0}^{{\\mathsf{r}}-1}t_{i}}{q}+\\left(\\sqrt{\\rho}\\cdot\\left(1+\\frac{1}{2m}\\right)\\right)^{s}.</span> (10)</p>

    <p class="text-gray-300">The</p>

    <p class="text-gray-300">Suppose there exists a batched FRI prover <span class="math">\\mathsf{P}_{\\mathsf{FRI}}^{*U}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\langle \\mathsf {V} _ {\\mathsf {F R I}} ^ {U} (\\vec {t}, s) \\leftrightarrow \\mathsf {P} _ {\\mathsf {F R I}} ^ {* U} (\\vec {t}) \\rangle = \\mathsf {a c c e p t} \\right] \\geq \\epsilon_ {\\mathsf {F R I}} (q, n, \\rho , m, s, \\vec {t}).</span></div>

    <p class="text-gray-300">Then there exists <span class="math">S \\subset \\mathsf{D}</span> and <span class="math">v_0, \\ldots, v_l \\in V</span> satisfying</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Density: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\sqrt{\\rho} \\left(1 + \\frac{1}{2m}\\right)$, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correlated agreement: for all <span class="math">i \\in \\{0, \\dots, l\\}</span>, the functions <span class="math">u_i</span> and <span class="math">v_i</span> agree on all of <span class="math">S</span>, i.e., <span class="math">\\forall x \\in S, u_i(x) = v_i(x)</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Remark 4.</strong> We point out that the first two summands in Eq. (10) correspond to the probability of error during the FRI COMMIT phase, and the third and last summand corresponds to the FRI QUERY phase (see [BCI⁺20, Theorem 8.3]). This distinction will be relevant to the suggested parameter settings for ethSTARK, as discussed in Section 5.10.2 and Eq. (21).</p>

    <h2 id="sec-48" class="text-2xl font-bold">5.5 The Knowledge Extractor</h2>

    <p class="text-gray-300">In this section we describe the extractor that will be used to prove the knowledge soundness in Section 5.6. The extractor will use the correlated list decoder, described next.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 5 (Correlated agreement).</strong> Let <span class="math">V \\subset \\mathbb{K}^{\\mathsf{D}}</span> be a set of vectors, <span class="math">W = \\{w_{1},\\ldots ,w_{k}\\} ,w_{i} \\in \\mathbb{K}^{\\mathsf{D}}</span> be a sequence of vectors and <span class="math">\\sigma \\in [0,1]</span> an agreement parameter. We say <span class="math">W</span> has correlated agreement with <span class="math">V</span> on agreement domain <span class="math">S \\subset \\mathsf{D}</span> of density <span class="math">\\sigma</span> if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\sigma<span class="math"> and there exist </span>v_{1},\\dots,v_{k} \\in V<span class="math"> such that </span>w_{i}<span class="math"> agrees with </span>v_{i}<span class="math"> on </span>S<span class="math"> (i.e., </span>\\forall x \\in S: w_{i}(x) = v_{i}(x)$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say <span class="math">S</span> is a maximal agreement domain if no set strictly containing <span class="math">S</span> is an agreement domain.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 1 (Correlated agreement list decoder).</strong> Let <span class="math">V = \\mathsf{RS}[\\mathbb{K},\\mathsf{D},\\rho]</span> and <span class="math">W = \\{w_{1},\\ldots ,w_{k}\\} ,w_{i}\\in \\mathbb{K}^{\\mathsf{D}}</span> be a sequence of vectors. Let <span class="math">\\sigma = \\sqrt{\\rho} +\\eta ,\\eta &amp;gt;0</span> be an agreement density parameter. Then there exists a randomized algorithm running in expected time that is polynomial in $1 / \\rho ,1 / \\eta ,k,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> that outputs a list </span>\\mathcal{S} = \\{S_1,\\dots,S_\\ell \\}<span class="math"> of all maximal correlated agreement domains of density at least </span>\\sigma<span class="math">, and </span>\\ell \\leq 1 / (2\\eta \\sqrt{\\rho})<span class="math">. Additionally, for each </span>S_{i}<span class="math"> and </span>w_{j}\\in W<span class="math"> the element </span>v_{i,j}\\in V<span class="math"> that agrees with </span>w_{j}<span class="math"> on </span>S_{i}$ is uniquely defined.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> Run the following procedure, which uses the Guruswami-Sudan list decoding algorithm from Theorem 2 [GS99], which has expected polynomial running time:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Apply the Guruswami-Sudan algorithm to <span class="math">w_{1}</span> with agreement parameter <span class="math">\\sigma</span>, and let <span class="math">\\mathcal{S} = \\{S_1, \\ldots, S_{\\ell_1}\\}</span> be the set of agreement sets derived from it. Notice <span class="math">\\ell_{1} \\leq 1 / (2\\eta \\sqrt{\\rho})</span> due to Theorem 1.</li>

      <li>For <span class="math">i = 2, \\ldots, k</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Apply the Guruswami-Sudan algorithm to <span class="math">w_{i}</span> with agreement parameter <span class="math">\\sigma</span>, and let <span class="math">S_{i} = \\{S_{i,1},\\ldots ,S_{i,\\ell_{i}}\\}</span> be the set of agreement sets derived from it. Let <span class="math">\\ell = \\ell_1</span>.</li>

      <li>Let</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat {\\mathcal {S}} _ {i} = \\left\\{S \\cap S ^ {\\prime}: S \\in \\mathcal {S}, S ^ {\\prime} \\in \\mathcal {S} _ {i},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S \\cap S ^ {\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm {D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\sigma \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">In words, <span class="math">\\hat{S}_i</span> is the set of correlated agreement domains of density at least <span class="math">\\sigma</span> for <span class="math">w_1, \\ldots, w_i</span>. Set <span class="math">\\mathcal{S} = \\hat{\\mathcal{S}}_i</span> and continue.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notice that Theorem 1 applied to the RS code of rate <span class="math">\\rho</span> over the field of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^i<span class="math"> implies that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{S}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\ell<span class="math"> for each </span>i = 1, \\ldots, k$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">STARKWARE Page 31</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return <span class="math">\\mathcal{S} = \\{S_1, \\ldots, S_\\ell\\}</span>, noticing <span class="math">\\ell \\leq 1/(2\\eta\\sqrt{\\rho})</span>.</li>

    </ul>

    <p class="text-gray-300">The claim on the running time of the algorithm follows from Theorems 1 and 2. Uniqueness of <span class="math">v_{i,j}</span> follows from the assumption <span class="math">\\sigma &amp;gt; \\rho</span> (recall <span class="math">\\rho &amp;lt; 1</span>).</p>

    <p class="text-gray-300">The Knowledge Extractor The extractor <span class="math">\\mathsf{E}(\\mathsf{A} = (\\mathbb{F},\\mathsf{w},\\mathsf{h},\\mathsf{d},\\mathsf{s},\\mathsf{g},\\mathsf{I},\\mathsf{Cset}),\\mathsf{aux},f = (f_1,\\ldots ,f_{\\mathsf{w}}))</span> receives the auxiliary IOP parameters <span class="math">\\mathsf{aux} = (\\mathbb{K},\\mathsf{e},\\mathsf{D},\\mathsf{k}&#x27;,\\mathsf{aux}_{\\mathsf{FRI}})</span> and extracts an assignment from the very first prover oracle. It operates thus:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Recall $\\rho = 2^{\\mathsf{h}} /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Let </span>\\rho^{+} := \\frac{2^{\\mathsf{h}} + 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, noticing codewords of </span>\\mathsf{RS}[\\mathbb{F}, S, \\rho]<span class="math"> are evaluations of polynomials of degree less than </span>2^{\\mathsf{h}}<span class="math"> whereas codewords of </span>\\mathsf{RS}[\\mathbb{F}, S, \\rho^{+}]<span class="math"> correspond to polynomials of degree at most </span>2^{\\mathsf{h}}<span class="math">. Run the correlated agreement list decoder from Lemma 1 with agreement parameter </span>\\sqrt{\\rho^{+}}(1 + 1/(2m))<span class="math"> on </span>U = \\{f_{1}, \\ldots, f_{\\mathsf{w}}\\} \\subset (\\mathbb{F}^{\\mathsf{D}})^{\\mathsf{w}}<span class="math"> and </span>V = \\mathsf{RS}[\\mathbb{F}, \\mathsf{D}, \\rho^{+}]<span class="math">. Let </span>\\mathcal{S} = \\{S_1, \\ldots, S_\\ell\\}<span class="math"> be the set of agreement domains of density </span>\\geq \\sqrt{\\rho^{+}}(1 + 1/(2m))<span class="math"> and let </span>\\mathcal{P} = \\{\\vec{P}_1, \\dots, \\vec{P}_\\ell\\}<span class="math"> be the set of polynomials of degree </span>\\leq 2^{\\mathsf{h}}<span class="math"> that match these domains, where </span>\\vec{P}_i = \\{\\mathsf{P}_{i,1}, \\dots, \\mathsf{P}_{i,\\mathsf{w}}\\}<span class="math">, and </span>\\mathsf{P}_{i,j}(X) \\in \\mathbb{F}^{\\leq 2^{\\mathsf{h}}} [X]<span class="math"> agrees with </span>f_j<span class="math"> on all of </span>S_i<span class="math">. Notice </span>\\vec{P}_i<span class="math"> is an AIR assignment per Definition 3, containing polynomials over </span>\\mathbb{F}<span class="math">, even though later parts of the protocol may use a strictly larger field </span>\\mathbb{K} \\supset \\mathbb{F}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">k = 1, \\ldots, \\ell</span>, if the AIR assignment <span class="math">\\vec{P}_k</span> satisfies A then output it and terminate with "success". Otherwise - if no <span class="math">\\vec{P}_k</span> satisfies A - terminate with "failure".</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Computational Complexity By Lemma 1 the expected running time of the extractor is polynomial in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, m, 1 / \\rho^{+}, \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>\\mathsf{w}<span class="math">. Clearly </span>1 / \\rho^{+} \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and likewise </span>m<span class="math"> may be bounded by </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> because the agreement parameter is an integral multiple of </span>1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Therefore, the expected running time of the extractor is polynomial in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\log \\mathbb{K}<span class="math"> and </span>\\mathsf{w}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-49" class="text-2xl font-bold">5.6 Upper bound on knowledge soundness error</h2>

    <p class="text-gray-300">The main result of this section is the following statement.</p>

    <p class="text-gray-300">Theorem 4 (Knowledge soundness). The knowledge extractor <span class="math">\\mathsf{E}(\\mathsf{A} = (\\mathbb{F},\\mathsf{w},\\mathsf{h},\\mathsf{d},\\mathsf{s},\\mathsf{g},\\mathsf{I},\\mathsf{Cset}),\\mathsf{aux},f = (f_1,\\ldots ,f_{\\mathsf{w}}))</span> from Section 5.5 successfully outputs a satisfying AIR assignment, whenever the verifier <span class="math">\\mathsf{V}</span> satisfies both of the following conditions:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}</span> invokes the FRI verifier with <span class="math">s</span> iterations of the QUERY phase, and</li>

      <li>There exists some prover <span class="math">\\mathsf{P}^{<em>}(\\mathsf{A},\\mathsf{aux})</span> sending <span class="math">f = (f_{1},\\ldots ,f_{\\mathsf{w}})</span> as its first oracle in Step 1, and the acceptance probability of <span class="math">\\mathsf{V}(\\mathsf{A},\\mathsf{aux})</span> upon interacting with <span class="math">\\mathsf{P}^{</em>}(\\mathsf{A},\\mathsf{aux})</span> is greater than</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{err}_{\\text{total}} = \\frac{\\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac{\\left(\\mathrm{d}_{\\max} + 2^{\\mathrm{h}} + \\mathrm{a}\\right) \\cdot \\ell^{2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\mathrm{a} \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{H}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\epsilon_{\\mathrm{FRI}}(q, n, \\rho, m, s, \\bar{t}). \\tag{11}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">m \\geq 3</span> is an integer and <span class="math">\\ell = m / \\rho</span>.</p>

    <p class="text-gray-300">From this statement we deduce the following result, which extracts a satisfying assignment from any prover that causes the verifier to accept with probability that is twice that which is stated in Eq. (11).</p>

    <p class="text-gray-300">STARKWARE Page 32</p>

    <p class="text-gray-300">Corollary 1 (Knowledge extraction from sufficiently convincing prover). Fix positive integers <span class="math">R \\geq 1, m \\geq 3</span>. Let <span class="math">\\mathsf{A} = (\\mathbb{F}, \\mathsf{w}, \\mathsf{h}, \\mathsf{d}, \\mathsf{s}, \\mathsf{g}, \\mathsf{I}, \\mathsf{Cset}), \\mathsf{aux} = (\\mathbb{K}, \\mathsf{e}, \\mathsf{D}, \\mathsf{k}&#x27;, \\mathsf{aux}_{\\mathsf{FRI}})</span> and <span class="math">\\mathsf{aux}_{\\mathsf{FRI}} = (\\vec{t}, s)</span> where <span class="math">2^{-R} = 2^{\\mathsf{h}} / 2^{\\mathsf{k}&#x27;}</span>. Suppose there exists a prover <span class="math">\\mathsf{P}^*</span> such that, when it interacts with the verifier <span class="math">\\mathsf{V}</span> described in Section 5.3 satisfies</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\langle \\mathrm{V}(\\mathrm{A}, \\mathrm{aux}) \\leftrightarrow \\mathrm{P}^*(\\mathrm{A}, \\mathrm{aux}) \\rangle = \\mathrm{accept} \\right] \\geq 2 \\cdot \\mathrm{err}_{\\text{total}} \\tag{12}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\mathrm{err}_{\\text{total}}</span> is as defined in Eq. (11) (and <span class="math">\\epsilon_{\\mathsf{FRI}}</span> is as defined in Eq. (10)). Then <span class="math">\\mathsf{A} \\in \\mathsf{L}_{\\mathsf{AIR}}</span> and furthermore, there exists a knowledge extractor <span class="math">\\mathsf{E}&#x27;</span> that, on input <span class="math">(\\mathsf{A}, \\mathsf{aux})</span>, interacts with <span class="math">\\mathsf{P}^*</span> and outputs a satisfying assignment for <span class="math">\\mathsf{A}</span> in expected time that is polynomial in $\\mathsf{w}, 2^{\\mathsf{h}}, \\mathsf{d},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Cset}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>1/\\epsilon$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. The extractor <span class="math">\\mathsf{E}&#x27;</span> repeats the following process a number <span class="math">1 / \\mathrm{err}_{\\text{total}}</span> of times:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Invoke the prover <span class="math">\\mathsf{P}^*</span> and read the first oracle <span class="math">f = (f_1, \\ldots, f_w)</span>.</li>

      <li>Invoke <span class="math">\\mathsf{E}(\\mathsf{A}, \\mathsf{aux}, f)</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We claim that <span class="math">\\mathsf{E}&#x27;</span> satisfies the conditions above. By the assumption of Eq. (12), with probability at least <span class="math">\\mathrm{err}_{\\text{total}}</span> the first oracle <span class="math">f</span> satisfies Item 2 of Theorem 4. Assuming <span class="math">f</span> indeed satisfies this condition, Theorem 4 implies that <span class="math">\\mathsf{E}</span> outputs a satisfying assignment to <span class="math">\\mathsf{A}</span>. Inspection shows that the expected running time of <span class="math">\\mathsf{E}</span> is bounded by a polynomial in $\\mathsf{w}, 2^{\\mathsf{h}}, \\mathsf{d},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Cset}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, because </span>m<span class="math"> and </span>\\rho<span class="math"> are fixed. Hence </span>\\mathsf{E}'<span class="math"> also runs in expected polynomial time in </span>\\mathsf{w}, 2^{\\mathsf{h}}, \\mathsf{d},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Cset}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>1/\\epsilon$, as claimed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fixing <span class="math">\\rho</span> and <span class="math">m</span> as in Corollary 1 gives the following result which generalizes Corollary 1 to show that the protocol of Section 5.3 constitutes a scalable and transparent IOP of knowledge (STIK) per [BBHR19, Definition 3.3].</p>

    <p class="text-gray-300">Corollary 2 (Scalalbe Transparent IOP of Knowledge (STIK) for <span class="math">\\mathsf{L}_{\\mathsf{AIR}}</span>). For any <span class="math">\\epsilon &amp;gt; 0</span>, the IOP protocol described in Section 5.3 constitutes an IOP of knowledge for the language <span class="math">\\mathsf{L}_{\\mathsf{AIR}}</span> from Definition 4 with knowledge soundness error at most <span class="math">\\epsilon</span>.</p>

    <p class="text-gray-300">In the proof below we prefer simplicity to optimizing parameters.</p>

    <p class="text-gray-300">Proof. Given <span class="math">\\epsilon</span> and an AIR instance <span class="math">\\mathsf{A} = (\\mathbb{F}, \\mathsf{w}, \\mathsf{h}, \\mathsf{d}, \\mathsf{s}, \\mathsf{g}, \\mathsf{I}, \\mathsf{Cset})</span>, set the auxiliary IOP parameters <span class="math">\\mathsf{aux} = (\\mathbb{K}, \\mathsf{e}, \\mathsf{D}, \\mathsf{k}&#x27;, \\mathsf{aux}_{\\mathsf{FRI}})</span> thus:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathsf{e}</span> be the smallest integer divisible by 4 that satisfies</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{1}{2\\epsilon} \\left((24)^2 \\cdot (10d + 2^h) + 100d2^h\\right) &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^e \\tag{13}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Let <span class="math">\\mathbb{K}</span> be the degree-<span class="math">e</span> extension of <span class="math">\\mathbb{F}</span>. Notice that <span class="math">\\mathbb{K}</span> contains a subgroup of size <span class="math">8 \\cdot 2^h</span> because <span class="math">2^h</span> divides $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^4 - 1 = (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1) \\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1)^3<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1<span class="math"> is divisible by 2 (recall </span>e<span class="math"> is divisible by 4). Therefore, we conclude that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is polynomial in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, 1/\\epsilon, d<span class="math"> and </span>2^h$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">k&#x27; = h + 3</span> and pick <span class="math">D</span> to be a subgroup of <span class="math">\\mathbb{K}</span> of size <span class="math">2^{k&#x27;}</span>, thus fixing <span class="math">\\rho = 1/8</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">\\mathsf{aux}_{\\mathsf{FRI}} = (\\vec{2}, s)</span> where <span class="math">\\vec{2} = (2, 2, \\ldots, 2)</span> and <span class="math">s = 100 \\cdot \\log(1/\\epsilon)</span> (the constant 100 can likely be vastly reduced)</li>

    </ul>

    <p class="text-gray-300">STARKWARE Page 33</p>

    <p class="text-gray-300">We claim that the IOP protocol of Section 5.3 constitutes an IOP of Knowledge for <span class="math">\\mathsf{L}_{\\mathsf{AIR}}</span> with knowledge soundness error <span class="math">\\leq \\epsilon</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Completeness is argued in the standard way (we omit details). Regarding soundness, we invoke the extractor <span class="math">\\mathsf{E}&#x27;</span> of Corollary 1 with <span class="math">m = 3</span>, noticing its expected running time is polynomial in $2^{\\mathsf{h}}, \\mathsf{w},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Cset}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>1 / \\epsilon<span class="math"> because </span>m, \\rho<span class="math"> are fixed, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{\\mathsf{h} + 3}<span class="math">, and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is polynomial in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>1 / \\epsilon<span class="math">. We now invoke Theorem 4 with </span>m = 3<span class="math"> and </span>\\ell = m / \\rho = 24<span class="math"> and notice that by definition of the size of </span>\\mathbb{K}<span class="math"> in Eq. (13), if the acceptance probability of the protocol is greater than </span>2\\epsilon<span class="math"> then the extractor described in Corollary 1 will output a satisfying assignment for </span>\\mathsf{A}<span class="math"> in time that is polynomial in </span>\\mathsf{w}, 2^{\\mathsf{h}}, \\mathsf{d},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Cset}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>1 / \\epsilon$, as claimed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-50" class="text-2xl font-bold">5.7 Proof of Theorem 4</h2>

    <p class="text-gray-300">Proof of Theorem 4. In our proof of Theorem 4 we make a few simplifying assumptions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover <span class="math">\\mathsf{P}^*(\\mathsf{A},\\mathsf{aux})</span> is deterministic. In particular,</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">\\vec{r}</span> the prover's composition oracles <span class="math">f_0^{\\vec{r}},\\ldots ,f_{\\mathsf{a} - 1}^{\\vec{r}}:\\mathsf{D}\\to \\mathbb{K}</span> provided in Step 3 are determined by <span class="math">\\vec{r}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The answer sequence $\\mathsf{answer} = (\\alpha, \\beta) \\in \\mathbb{K}^{\\mathsf{t},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{a}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> to the DEEP query </span>\\mathfrak{q}<span class="math"> provided in Step 5 is determined by </span>\\vec{r}<span class="math"> and </span>\\mathfrak{q}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The aforementioned answer validates the constraint <span class="math">Q^{\\vec{r}}(X, \\mathsf{Y})</span>, i.e., Eq. (7) is assumed to hold for all <span class="math">\\vec{r}</span> and <span class="math">\\mathfrak{q}</span>. This assumption follows by modifying, say, the very last answer <span class="math">\\beta_{\\mathsf{a} - 1} \\in \\mathsf{answer}</span> to ensure Eq. (7) holds; such an answer exists because <span class="math">\\mathfrak{q} \\neq 0</span>. Such a change will not decrease the probability of the verifier accepting because failing to validate <span class="math">Q^{\\vec{r}}(X, \\mathsf{Y})</span> implies the protocol ends in rejection (see Step 8).</li>

    </ul>

    <p class="text-gray-300">With these assumptions in hand, we proceed with the proof. Recall that the output of <span class="math">\\mathsf{E}</span> on input <span class="math">(f_{1},\\ldots ,f_{\\mathsf{w}})</span> is <span class="math">(\\mathcal{S},\\mathcal{P})</span> where <span class="math">\\mathcal{S} = \\{S_1,\\dots ,S_\\ell \\}</span> are sets of agreement domains of density <span class="math">\\geq \\sqrt{\\rho^{+}}(1 + 1 / (2m))</span> and <span class="math">\\mathcal{P} = \\{\\vec{\\mathsf{P}}_1,\\dots ,\\vec{\\mathsf{P}}_\\ell \\}</span> are AIR assignments such that <span class="math">\\vec{\\mathsf{P}}_i</span> has correlated agreement on <span class="math">S_{i}</span> with the sequence of functions <span class="math">(f_{1},\\ldots ,f_{\\mathsf{w}})</span>. By Theorem 1 we have <span class="math">\\ell \\leq m / \\rho^{+}\\leq m / \\rho</span> as claimed. Now extend this latter sequence of functions (namely, <span class="math">f_{1},\\ldots ,f_{\\mathsf{w}}</span>) by appending <span class="math">(f_0^{\\vec{r}},\\ldots ,f_{\\mathsf{a} - 1}^{\\vec{r}})</span> to it, and continue applying the correlated agreement decoder from Lemma 1 to this larger sequence, using agreement parameter <span class="math">\\sqrt{\\rho^{+}} +\\eta</span> where <span class="math">\\eta = \\frac{\\sqrt{\\rho^{+}}}{2m}</span>. Let <span class="math">\\mathcal{S}^{\\vec{r}} = \\{S_1^{\\vec{r}},\\ldots ,S_\\ell^{\\vec{r}}\\}</span> denote the resulting agreement domains of density <span class="math">\\sqrt{\\rho^{+}} +\\eta</span>. By construction, each <span class="math">S_i^{\\vec{r}}</span> is contained in some <span class="math">S_{k}\\in \\mathcal{S}</span>, and, since the density of <span class="math">S_i^{\\vec{r}}</span> is greater than <span class="math">\\rho^{+}</span>, the restriction of <span class="math">(f_{1},\\ldots ,f_{\\mathsf{w}})</span> to <span class="math">S_i^{\\vec{r}}</span> agrees with the assignment <span class="math">\\vec{\\mathsf{P}}_k</span> on all of <span class="math">S_i^{\\vec{r}}</span>. We thus say <span class="math">\\vec{\\mathsf{P}}_k</span> is associated with <span class="math">S_i^{\\vec{r}}</span>, noticing that <span class="math">\\vec{\\mathsf{P}}_k</span> may be associated with several different domains <span class="math">S^{\\vec{r}}\\in \\mathcal{S}^{\\vec{r}}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\vec{\\mathsf{P}}_i^{\\vec{r}} = (\\mathsf{P}_0^{\\vec{r}},\\ldots ,\\mathsf{P}_{\\mathsf{a} - 1}^{\\vec{r}})</span> denote the <span class="math">\\mathsf{a}</span>-tuple of polynomials of degree <span class="math">\\leq 2^{\\mathsf{h}}</span> that agree with <span class="math">f_0^{\\vec{r}},\\dots ,f_{\\mathsf{a} - 1}^{\\vec{r}}</span> on <span class="math">S_i^{\\vec{r}}</span>, and let <span class="math">\\mathcal{P}^{\\vec{r}} = \\{\\vec{\\mathsf{P}}_1^{\\vec{r}},\\dots ,\\vec{\\mathsf{P}}_\\ell^{\\vec{r}}\\}</span>. If <span class="math">\\vec{\\mathsf{P}}_k</span> is associated with <span class="math">S_i^{\\vec{r}}</span> we also say <span class="math">\\vec{\\mathsf{P}}_i^{\\vec{r}}</span> and <span class="math">\\vec{\\mathsf{P}}_k</span> are associated, noticing again that <span class="math">\\vec{\\mathsf{P}}_k</span> may be associated with several different <span class="math">\\vec{\\mathsf{P}}^{\\vec{r}}\\in \\mathcal{P}^{\\vec{r}}</span>.</p>

    <p class="text-gray-300">We say <span class="math">(\\vec{r},\\mathfrak{q})</span> is good if</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{r^{F}, r^{\\prime}} \\left[ \\text{FRI Verifier accepts } g_{(\\vec{r}, \\mathbf{q}, \\text{answer}, r^{F})} \\right] \\geq \\epsilon_{\\text{FRI}} \\tag{14}</span></div>

    <p class="text-gray-300">where <span class="math">r&#x27;</span> is the randomness used inside the FRI protocol (in both phases — COMMIT and QUERY) and <span class="math">\\epsilon_{\\mathsf{FRI}}</span> is the expression on the right hand side of Eq. (10).</p>

    <p class="text-gray-300">STARKWARE Page 34</p>

    <p class="text-gray-300">The following lemma explains why we call a tuple “good”. Its proof is deferred to Section 5.8.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">If <span class="math">(\\vec{r},\\mathfrak{q})</span> is good then there exists (i) an AIR assignment <span class="math">\\vec{\\mathsf{P}}_{k}=(\\mathsf{P}_{k,1},\\ldots,\\mathsf{P}_{k,\\mathsf{w}})\\in\\mathcal{P}</span>, (ii) an <span class="math">\\mathsf{a}</span>-tuple <span class="math">\\vec{\\mathsf{P}}^{\\vec{r}}=(\\mathsf{P}_{0}^{\\vec{r}},\\ldots,\\mathsf{P}_{\\mathsf{a}-1}^{\\vec{r}})\\in\\mathcal{P}^{\\vec{r}}</span> associated with <span class="math">\\vec{\\mathsf{P}}_{k}</span> and (iii) <span class="math">S_{(\\vec{r},\\mathfrak{q})}\\subseteq S_{k}</span> such that all the following hold, in which case we say that <span class="math">(\\vec{r},\\mathfrak{q})</span> is <em>good for</em> <span class="math">S_{k}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{(\\vec{r},\\mathfrak{q})}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>(\\sqrt{\\rho^{+}}+\\eta)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i\\in[\\mathsf{w}]</span> the polynomial <span class="math">\\mathsf{P}_{k,i}(X)</span> agrees with <span class="math">f_{i}</span> on all of <span class="math">S_{(\\vec{r},\\mathfrak{q})}</span></li>

      <li>For each <span class="math">(i,j)\\in\\mathsf{I}</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{P}_{k,i}(\\mathfrak{q}\\cdot\\mathsf{g}^{j})=\\alpha_{i,j}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">l\\in\\{0,\\ldots,\\mathsf{a}-1\\}</span> the polynomial <span class="math">\\mathsf{P}_{l}^{\\vec{r}}(X)</span> agrees with <span class="math">f_{l}^{\\vec{r}}</span> on all of <span class="math">S_{(\\vec{r},\\mathfrak{q})}</span></li>

      <li>For each <span class="math">l\\in\\{0,\\ldots,\\mathsf{a}-1\\}</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{P}_{l}^{\\vec{r}}(\\mathfrak{q}^{\\mathsf{a}})=\\beta_{l}</span></p>

    <p class="text-gray-300">Consequently, the polynomial <span class="math">\\hat{\\mathsf{P}}^{\\vec{r}}(X):=\\sum_{l=0}^{\\mathsf{a}-1}X^{l}\\cdot\\mathsf{P}_{l}^{\\vec{r}}(X^{\\mathsf{a}})</span> satisfies</p>

    <p class="text-gray-300"><span class="math">\\hat{\\mathsf{P}}^{\\vec{r}}(\\mathfrak{q})=\\sum_{l=1}^{\\mathsf{a}-1}\\mathfrak{q}^{l}\\cdot\\beta_{l}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, we say <span class="math">\\vec{r}</span> is <em>useful</em> for <span class="math">\\vec{\\mathsf{P}}_{k}\\in\\mathcal{P}</span> if the number of distinct <span class="math">\\mathfrak{q}</span> such that <span class="math">(\\vec{r},\\mathfrak{q})</span> is good for <span class="math">S_{k}</span> is strictly greater than $((\\mathsf{a}+1)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{a})\\cdot\\ell=(\\mathsf{d}_{\\mathsf{max}}+2^{\\mathsf{h}}+\\mathsf{a})\\cdot\\ell<span class="math">. (Notice that </span>\\vec{r}<span class="math"> may be useful for more than one </span>S_{k}<span class="math">.) We say </span>\\vec{r}<span class="math"> is <em>not useful</em> if there is no </span>S_{k}\\in\\mathcal{S}$ for which it is useful. We make two claims regarding useful randomness strings, the proofs are deferred to Section 5.8.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-52" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">If <span class="math">\\vec{r}</span> is useful for <span class="math">\\vec{\\mathsf{P}}_{k}</span>, then the rational function <span class="math">\\left(Q^{\\vec{r}}(X,\\mathsf{Y})\\circ\\vec{\\mathsf{P}}_{k}\\right)(X)</span> from Eq. (5) is a polynomial over <span class="math">\\mathbb{K}</span>.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">If linearly independent <span class="math">\\vec{r}_{1},\\ldots,\\vec{r}_{2\\mathsf{s}}\\in\\mathbb{K}^{2\\mathsf{s}}</span> are all useful for some <span class="math">\\vec{\\mathsf{P}}_{k}</span>, then <span class="math">\\vec{\\mathsf{P}}_{k}</span> satisfies <span class="math">\\mathsf{A}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assuming the lemmas, we complete the proof of Theorem 4. First we bound the fraction of <span class="math">\\vec{r}</span> that are not useful. If <span class="math">\\vec{r}</span> is not useful, then for each of the <span class="math">\\ell</span> assignments <span class="math">\\vec{\\mathsf{P}}_{k}</span>, there are at most <span class="math">(\\mathsf{d}_{\\mathsf{max}}+2^{\\mathsf{h}}+\\mathsf{a})\\cdot\\ell</span> choices of <span class="math">\\mathfrak{q}</span> for which <span class="math">(\\vec{r},\\mathfrak{q})</span> is good for <span class="math">\\vec{\\mathsf{P}}_{k}</span>. Thus, when <span class="math">\\vec{r}</span> is not useful, there are at most $(\\mathsf{d}_{\\mathsf{max}}+2^{\\mathsf{h}}+\\mathsf{a})\\cdot\\ell\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=(\\mathsf{d}_{\\mathsf{max}}+2^{\\mathsf{h}}+\\mathsf{a})\\cdot\\ell^{2}<span class="math"> values of </span>\\mathfrak{q}<span class="math"> for which the FRI acceptance probability is greater than </span>\\epsilon_{\\mathsf{FRI}}<span class="math">, and for all other values of </span>\\mathfrak{q}<span class="math"> the FRI acceptance probability is smaller than </span>\\epsilon_{\\mathsf{FRI}}<span class="math">. Thus, the probability of acceptance, conditioned on </span>\\vec{r}<span class="math"> being not useful is bounded by </span>\\frac{(\\mathsf{d}_{\\mathsf{max}}+2^{\\mathsf{h}}+\\mathsf{a})\\cdot\\ell^{2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\mathsf{a}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\epsilon_{\\mathsf{FRI}}<span class="math">. The denominator is the size of the pool from which we sample </span>\\mathfrak{q}<span class="math">. We conclude from the assumption of Eq. (11) that the probability of </span>\\vec{r}<span class="math"> being useful is greater than </span>\\ell/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Let </span>\\vec{\\mathsf{P}}_{k}\\in\\mathcal{P}<span class="math"> be an assignment for which the fraction of </span>\\vec{r}<span class="math"> useful for </span>\\vec{\\mathsf{P}}_{k}<span class="math"> is maximal. By the pigeonhole principle this fraction is strictly greater than </span>1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, so the set of useful </span>\\vec{r}<span class="math"> for </span>\\vec{\\mathsf{P}}_{k}<span class="math"> must contain a basis that spans </span>\\mathbb{K}^{2\\mathsf{s}}<span class="math">. Hence, by Lemma 4, we conclude </span>\\vec{\\mathsf{P}}_{k}<span class="math"> satisfies </span>\\mathsf{A}$ and this completes our proof. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">5.8 Proofs of Lemmas</h3>

    <p class="text-gray-300">In this section we prove the three main lemmas used in the proof of Theorem 4.</p>

    <p class="text-gray-300">5.8.1 Proof of Lemma 2</p>

    <p class="text-gray-300">Proof of Lemma 2. Recall from Eq. (8) that <span class="math">g_{(\\vec{r},\\mathfrak{q},\\mathsf{answer},\\mathsf{r}^F)}</span> is a uniformly random element of the linear space <span class="math">U</span> spanned by the following collection of functions <span class="math">v_{i,j}</span> and <span class="math">u_{k}</span>:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{v _ {i, j} := \\text {Quotient} \\left(f _ {i}; \\mathfrak {q} \\cdot \\mathbf {g} ^ {j}, \\alpha_ {i, j}\\right)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(i, j) \\in \\mathrm {I} \\right\\} \\cup \\left\\{u _ {k} := \\text {Quotient} \\left(f _ {k} ^ {\\vec {r}}; \\mathfrak {q} ^ {\\mathrm {a}}, \\beta_ {k}\\right)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k = 0, \\dots , \\mathrm {a} - 1 \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 3 applied to <span class="math">U</span> implies the existence of a set <span class="math">S = S_{(\\vec{r},\\mathfrak{q})} \\subset \\mathsf{D}</span> and polynomials that agree with <span class="math">v_{i,j}</span> and <span class="math">u_{k}</span> on all of <span class="math">S</span>. Furthermore, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq (\\sqrt{\\rho^{+}} + \\eta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Let </span>R_{i,j}(X)<span class="math"> be the polynomial that agrees with </span>u_{i,j}<span class="math"> on </span>S<span class="math">. Its degree is strictly smaller than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ thus it is unique. Now "unquotient" it by computing</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\tilde {R} _ {i, j} (X) := \\left(X - \\mathfrak {q} \\cdot \\mathbf {g} ^ {j}\\right) \\cdot R _ {i, j} (X) + \\alpha_ {i, j}.</span></div>

    <p class="text-gray-300">Notice <span class="math">\\tilde{R}_{i,j}</span> is a polynomial of degree <span class="math">\\leq 2^{\\mathsf{h}}</span> that agrees with <span class="math">f_{i}</span> on all of <span class="math">S</span> so there must be some <span class="math">k\\in [\\ell ]</span> such that for every <span class="math">i,j</span>, <span class="math">\\tilde{R}_{i,j} = \\mathsf{P}_{k,i}</span>, because <span class="math">\\mathcal{P}</span> is the set of all correlated agreement assignments of density at least <span class="math">\\sqrt{\\rho^{+}} +\\eta</span>. We have now proved the first two bullets of Lemma 2.</p>

    <p class="text-gray-300">Next, the polynomial <span class="math">\\tilde{R}_{i,j} = \\mathsf{P}_{k,i}</span> evaluates to <span class="math">\\alpha_{i,j}</span> on <span class="math">\\mathfrak{q} \\cdot \\mathbf{g}^j</span>. This holds for <span class="math">\\mathsf{P}_{k,i}</span> with respect to each <span class="math">j</span> such that <span class="math">(i,j) \\in \\mathsf{I}</span>, and we thus conclude that <span class="math">\\mathsf{P}_{k,i}</span> agrees with <span class="math">f_i</span> on <span class="math">S</span> and evaluates to <span class="math">\\alpha_{i,j}</span> on <span class="math">\\mathfrak{q} \\cdot \\mathbf{g}^j</span>, as claimed in the third bullet.</p>

    <p class="text-gray-300">In similar manner, "unquotient" the polynomial <span class="math">R_{l}(X)</span> that agrees with <span class="math">u_{l}</span> on <span class="math">S</span> by defining</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde {R} _ {l} (X) := \\left(X - \\mathfrak {q} ^ {\\mathrm {a}}\\right) \\cdot R _ {l} (X) + \\beta_ {l}.</span></div>

    <p class="text-gray-300">Notice <span class="math">\\tilde{R}_l(X)</span> is of degree <span class="math">\\leq 2^{\\mathsf{h}}</span> and agrees with <span class="math">f_{l}^{\\vec{r}}</span> on <span class="math">S</span>, showing <span class="math">(\\tilde{R}_0,\\dots ,\\tilde{R}_{\\mathsf{a} - 1})</span> is some <span class="math">\\vec{\\mathsf{P}}_i^{\\vec{r}}\\in \\mathcal{P}^{\\vec{r}}</span> that is associated with <span class="math">\\vec{\\mathsf{P}}_k</span>, and also proving the fourth bullet above. Additionally, <span class="math">\\tilde{R}_l(\\mathfrak{q}^{\\mathsf{a}}) = \\beta_l</span> by construction. Therefore, the polynomial <span class="math">\\tilde{\\mathsf{P}}^{\\vec{r}}(X)\\coloneqq \\sum_{l = 0}^{\\mathsf{a} - 1}X^{l}\\cdot \\tilde{R}_{l}(X^{\\mathsf{a}})</span> satisfies the last bullet above and this completes our proof.</p>

    <p class="text-gray-300">5.8.2 Proof of Lemma 3</p>

    <p class="text-gray-300">Proof of Lemma 3. To simplify the exposition rewrite <span class="math">Q^{\\vec{r}}(X,\\Upsilon)</span> as follows:</p>

    <div class="my-4 text-center"><span class="math-block">Q ^ {\\vec {r}} (X, \\Upsilon) = \\sum_ {i = 1} ^ {s} \\left(\\mathrm {r} _ {i} + \\mathrm {r} _ {i} ^ {\\prime} \\cdot X ^ {\\mathrm {c} _ {i}}\\right) \\cdot \\frac {Q _ {i} (\\Upsilon)}{\\mathrm {Z} _ {\\mathrm {H} _ {i}} (X)} = \\frac {1}{\\mathrm {Z} _ {\\mathrm {H} _ {0}} (X)} \\cdot \\sum_ {i = 1} ^ {s} \\left(\\mathrm {r} _ {i} + \\mathrm {r} _ {i} ^ {\\prime} \\cdot X ^ {\\mathrm {c} _ {i}}\\right) \\cdot \\left(Q _ {i} (\\Upsilon) \\cdot \\mathrm {Z} _ {\\mathrm {H} _ {0} \\backslash \\mathrm {H} _ {i}} (X)\\right) \\tag {15}</span></div>

    <p class="text-gray-300">The first equality comes from Eq. (5) and the second uses the fact that <span class="math">\\mathsf{H}_i\\subseteq \\mathsf{H}_0</span>. Consequently, composing <span class="math">Q^{\\vec{r}}(X,\\Upsilon)</span> with the AIR assignment <span class="math">\\vec{\\mathsf{P}} = \\vec{\\mathsf{P}}_k</span> gives</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(Q ^ {\\vec {r}} (X, \\Upsilon) \\circ \\vec {\\mathsf {P}}\\right) (X) = \\frac {1}{\\mathsf {Z} _ {\\mathsf {H} _ {0}} (X)} \\cdot \\sum_ {i = 1} ^ {\\mathsf {s}} \\left(\\mathsf {r} _ {i} + \\mathsf {r} _ {i} ^ {\\prime} \\cdot X ^ {\\mathsf {c} _ {i}}\\right) \\cdot \\left(Q _ {i} \\left(\\left\\{\\Upsilon_ {i, j} \\leftarrow \\vec {\\mathsf {P}} _ {i} (X \\cdot \\mathsf {g} ^ {j}) \\right\\}\\right) \\cdot \\mathsf {Z} _ {\\mathsf {H} _ {0} \\backslash \\mathsf {H} _ {i}} (X)\\right) \\\\ = \\frac {\\tilde {\\mathrm {P}} (X)}{\\mathrm {Z} _ {\\mathrm {H} _ {0}} (X)}, \\tag {16} \\\\ \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $\\mathrm{deg}(\\tilde{\\mathsf{P}})\\leq \\mathsf{a}\\cdot 2^{\\mathsf{h}} +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= (\\mathsf{a} + 1)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> by definition of </span>\\mathsf{c}_i<span class="math"> and </span>\\mathsf{a}<span class="math"> in Step 0 of the IOP, and because each polynomial in </span>\\vec{\\mathsf{P}}<span class="math"> has degree at most </span>2^{\\mathsf{h}} =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">STARKWARE Page 36</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">T = \\{\\mathfrak{q}_1, \\ldots, \\mathfrak{q}_t\\}</span> be those elements for which the pair <span class="math">(\\vec{r}, \\mathfrak{q}_i)</span> is good for <span class="math">\\vec{\\mathsf{P}} \\in \\mathcal{P}</span> and some <span class="math">\\vec{\\mathsf{P}}_i^{\\vec{r}}</span> associated with <span class="math">\\vec{\\mathsf{P}}</span>. Let $t =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, noticing we assume </span>t &gt; ((\\mathsf{a} + 1) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{a}) \\cdot \\ell<span class="math">. Let </span>\\vec{\\mathsf{P}}^r<span class="math"> denote the </span>\\vec{\\mathsf{P}}_i^{\\vec{r}}<span class="math"> that maximizes the size of the subset </span>T_i \\subseteq T<span class="math"> of elements </span>\\mathfrak{q} \\in T<span class="math"> for which </span>(\\vec{r}, \\mathfrak{q})<span class="math"> leads to </span>\\vec{\\mathsf{P}}_i^{\\vec{r}}<span class="math"> being used in Lemma 2 (with </span>\\vec{\\mathsf{P}} = \\vec{\\mathsf{P}}_k$). Notice</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T _ {i} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq t / \\ell = (\\mathsf {a} + 1) \\cdot \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {H} _ {0} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf {a}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">because $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}^{\\vec{r}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\ell<span class="math">. For each such good </span>\\mathfrak{q} \\in T_i$, apply Lemma 2 to obtain</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\frac {\\tilde {\\mathsf {P}} (\\mathfrak {q})}{\\mathsf {Z} _ {\\mathsf {H} _ {0}} (\\mathfrak {q})} = \\left(Q ^ {\\vec {r}} (X, \\Upsilon) \\circ \\vec {\\mathsf {P}}\\right) (\\mathfrak {q}) = Q ^ {\\vec {r}} \\left(\\mathfrak {q}, \\{\\Upsilon_ {i, j} \\leftarrow \\alpha_ {i, j} \\}\\right) = \\sum_ {l = 0} ^ {\\mathsf {a} - 1} \\mathfrak {q} ^ {l} \\cdot \\beta_ {l} = \\sum_ {l = 0} ^ {\\mathsf {a} - 1} \\mathfrak {q} ^ {l} \\cdot \\mathsf {P} _ {l} ^ {\\vec {r}} (\\mathfrak {q} ^ {\\mathsf {a}}) = \\hat {\\mathsf {P}} _ {i} ^ {\\vec {r}} (\\mathfrak {q}).</span></div>

    <p class="text-gray-300">where all <span class="math">\\mathfrak{q} \\in T_i</span> lead to the same rightmost polynomial <span class="math">\\hat{\\mathsf{P}}_i^{\\vec{r}}(X)</span>.</p>

    <p class="text-gray-300">The first equality follows from Eq. (16), the next equality follows from the second and third bullets of Lemma 2, the third equality follows from the assumption that the answers validate the constraint (cf. Eq. (7)) and the last two equalities above comes from the last two bullets of Lemma 2.</p>

    <p class="text-gray-300">We conclude that the polynomial</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde {\\mathsf {P}} (X) - \\mathsf {Z} _ {\\mathsf {H} _ {0}} (X) \\cdot \\hat {\\mathsf {P}} _ {i} ^ {\\vec {r}} (X)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which has degree at most $(\\mathsf{a} + 1)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{a}<span class="math"> has </span>t / \\ell<span class="math"> distinct roots, i.e., more roots than its degree, thus it equals 0 in </span>\\mathbb{K}[X]<span class="math">. Dividing both terms by </span>\\mathsf{Z}_{\\mathsf{H}_0}(X)<span class="math"> and using Eq. (16) again implies </span>\\left(Q^{\\vec{r}}(X,\\Upsilon)\\circ \\vec{\\mathsf{P}}\\right)(X)\\in \\mathbb{K}[X]$ and completes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-55" class="text-2xl font-bold">5.8.3 Proof of Lemma 4</h2>

    <p class="text-gray-300">Proof of Lemma 4. To simplify notation we drop the subscript <span class="math">k</span> from <span class="math">\\vec{\\mathsf{P}}_k</span> and <span class="math">S_{k}</span>, calling them <span class="math">\\vec{\\mathsf{P}}, S</span> instead. Let</p>

    <div class="my-4 text-center"><span class="math-block">v _ {l} := Q _ {l} \\left(\\left\\{\\Upsilon_ {i, j} \\leftarrow \\vec {\\mathrm {P}} (X \\cdot \\mathrm {g} ^ {j}) \\right\\}\\right) \\cdot \\mathrm {Z} _ {\\mathrm {H} _ {0} \\backslash \\mathrm {H} _ {l}} (X), \\quad v _ {l} ^ {\\prime} := X ^ {\\mathrm {c} _ {l}} \\cdot v _ {l}. \\tag {17}</span></div>

    <p class="text-gray-300">where, recall, <span class="math">(Q_{l},\\mathsf{H}_{l})</span> is the <span class="math">l</span>th constraint in Cset. Notice <span class="math">\\vec{v} = (v_{1},v_{1}^{\\prime},\\ldots ,v_{s},v_{s}^{\\prime})\\in (\\mathbb{K}[X])^{2s}</span> is a collection of 2s vectors in a linear space over <span class="math">\\mathbb{K}</span> (the space of univariate polynomials). Viewing <span class="math">\\vec{r}_i = (r_{i,1},r_{i,1}^{\\prime},\\dots,r_{i,s},r_{i,s}^{\\prime})</span> as a vector in <span class="math">\\mathbb{K}^{2s}</span>, rewrite Eq. (16) as</p>

    <div class="my-4 text-center"><span class="math-block">\\left(Q _ {\\vec {r} _ {i}} (X, \\Upsilon) \\circ \\vec {\\mathsf {P}}\\right) (X) = \\frac {1}{\\mathsf {Z} _ {\\mathsf {H} _ {0}} (X)} \\cdot \\sum_ {j = 1} ^ {\\mathsf {s}} \\left(\\mathsf {r} _ {i, j} \\cdot v _ {j} + \\mathsf {r} _ {i, j} ^ {\\prime} \\cdot v _ {j} ^ {\\prime}\\right) = \\frac {1}{\\mathsf {Z} _ {\\mathsf {H} _ {0}} (X)} \\cdot \\langle \\vec {v}, \\vec {r} _ {i} \\rangle ,</span></div>

    <p class="text-gray-300">where <span class="math">\\langle \\vec{u},\\vec{v}\\rangle \\coloneqq \\sum_{j}u_{j}\\cdot v_{j}</span>. In words, <span class="math">\\left(Q_{\\vec{r}_i}(X,\\Upsilon)\\circ \\vec{\\mathsf{P}}\\right)(X)</span> is <span class="math">1 / Z_{\\mathsf{H}_0}(X)</span> times the <span class="math">\\vec{r}_i</span>-linear combination of <span class="math">\\vec{v}</span>. By Lemma 3 we have <span class="math">\\frac{1}{Z_{\\mathsf{H}_0}(X)}\\cdot \\langle \\vec{v},\\vec{r}_i\\rangle \\in \\mathbb{K}[X]</span> for each <span class="math">\\vec{r}_i</span>. By the linear independence assumption on <span class="math">\\vec{r}_1,\\ldots ,\\vec{r}_{2s}</span> and the fact that <span class="math">\\mathbb{K}[X]</span> is a linear space over <span class="math">\\mathbb{K}</span>, we conclude that <span class="math">\\frac{v_i}{Z_{\\mathsf{H}_0}(X)}</span> and <span class="math">\\frac{v_i&#x27;}{Z_{\\mathsf{H}_0}(X)}</span> belong to <span class="math">\\mathbb{K}[X]</span> as well, for <span class="math">i = 1,\\dots ,s</span>. Using Eq. (17) and canceling common terms in <span class="math">Z_{\\mathsf{H}_0\\backslash \\mathsf{H}_i}</span> and <span class="math">Z_{\\mathsf{H}_0}</span> we conclude that for all <span class="math">l\\in [s]</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {Q _ {l} \\left(\\left\\{\\Upsilon_ {i , j} \\leftarrow \\vec {\\mathsf {P}} (X \\cdot \\mathsf {g} ^ {j}) \\right\\}\\right)}{\\mathsf {Z} _ {\\mathsf {H} _ {l}}} \\in \\mathbb {K} [ X ] \\quad \\mathrm {a n d} \\quad X _ {l} ^ {\\mathsf {c}} \\cdot \\frac {Q _ {l} \\left(\\left\\{\\Upsilon_ {i , j} \\leftarrow \\vec {\\mathsf {P}} (X \\cdot \\mathsf {g} ^ {j}) \\right\\}\\right)}{\\mathsf {Z} _ {\\mathsf {H} _ {l}}} \\in \\mathbb {K} [ X ].</span></div>

    <p class="text-gray-300">This means that <span class="math">\\vec{\\mathsf{P}}</span> satisfies all constraints according to Definition 3, and completes our proof.</p>

    <p class="text-gray-300">STARKWARE Page 37</p>

    <p class="text-gray-300">5.9 Security</p>

    <p class="text-gray-300">When we say that a cryptographic system has a security level of <span class="math">\\lambda</span> bits, we mean, somewhat informally, that the best known attack on it requires running time <span class="math">\\geq 2^{\\lambda}</span>. We follow a similar approach for discussing the security level of our systems. The security of PCP and IOP systems was studied first in <em>[x1]</em> and, to the best of our knowledge, that publication is the only one addressing such questions thus far. To simplify the study of STARK security we offer a simple “toy problem” and discuss its security. Furthermore, we conjecture that attacks on the toy problem can be converted to attacks on real STARK systems (like ethSTARK). Finally, we recount the state of the art attack on the toy problem and analyze its security (expected running time).</p>

    <h4 id="sec-56" class="text-lg font-semibold mt-6">5.9.1 IOP Toy Problem</h4>

    <h5 id="sec-57" class="text-base font-semibold mt-4">Rationale</h5>

    <p class="text-gray-300">Consider an attacker, a malicious prover P<em> attempting to fool the verifier V to accept an instance A which is either unsatisfiable, or perhaps is satisfiable but for which P</em> does not “know” a satisfying assignment. This means that P<em> does not know how to provide an assignment <span class="math">\\vec{\\mathsf{P}}</span> that will lead to all constraints being satisfied, which means that the random (rational) constraint <span class="math">Q^{\\vec{r}}</span> when composed with an assignment <span class="math">\\vec{\\mathsf{P}}</span> known to P</em>, will likely have a pole in H_{0}.</p>

    <p class="text-gray-300">However, the IOP protocol does not ask P* to provide an AIR assignment directly, but rather provide oracle access to functions <span class="math">(f_{1},\\ldots,f_{\\mathsf{w}}),f_{i}:\\mathsf{D}\\to\\mathbb{F}</span> that, supposedly, are the evaluations of a satisfying AIR assignment, so that the random constraint <span class="math">Q^{\\vec{r}}</span>, composed with these function, results in an evaluation of a low-degree polynomial (that has no poles in <span class="math">\\mathsf{D}</span>). To study this, the toy problem presents a simple setting in which the attacker is confronted with the problem of pole appearance. Details follow.</p>

    <h5 id="sec-58" class="text-base font-semibold mt-4">Toy problem protocol</h5>

    <p class="text-gray-300">Fix a finite field <span class="math">\\mathbb{F}</span> such that <span class="math">\\mathsf{D}\\subset\\mathbb{F}^{*}</span> is a multiplicative group of size <span class="math">\\frac{2^{\\mathsf{h}}}{\\rho}</span> where <span class="math">\\rho=2^{-R}</span> is the rate parameter, and <span class="math">R</span> is a positive integer. The interactive protocol works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Execution trace oracle: Prover sends oracle access to single function <span class="math">f:\\mathsf{D}\\to\\mathbb{F}</span></li>

      <li>Constraint randomness: Verifier samples a field element <span class="math">\\alpha\\in\\mathbb{F}</span> uniformly at random. Let <span class="math">g:\\mathsf{D}\\to\\mathbb{F}</span> be the function defined thus: <span class="math">g(x):=\\frac{f(x)-\\alpha}{x}</span>. Notice the function is well defined on <span class="math">\\mathsf{D}</span> because <span class="math">0\\not\\in\\mathsf{D}</span>.</li>

      <li>FRI protocol: Both parties apply the FRI protocol for checking proximity of <span class="math">g</span> to RS<span class="math">[\\mathbb{F},\\mathsf{D},\\rho]</span></li>

    </ol>

    <p class="text-gray-300">We propose to analyze security of ethSTARK (and other STARK constructions) under the following informal conjecture which says that attacks on the toy problem line up with attacks on actual “interesting” IOP instances.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Conjecture 1 (Toy problem as general security proxy – Informal).</h6>

    <p class="text-gray-300">If P* attacks the toy problem over field <span class="math">\\mathbb{F}</span> and rate <span class="math">\\rho</span> with time complexity <span class="math">T</span> and success probability <span class="math">\\epsilon</span>, then the IOP of Section 5.3 invoking the FRI protocol over field <span class="math">\\mathbb{F}</span> and rate <span class="math">\\rho</span> can be attacked in time <span class="math">T</span> with success probability <span class="math">\\epsilon</span>.</p>

    <p class="text-gray-300">Vice versa, if P* attacks the IOP of Section 5.3 applied to an “interesting” family of AIR instances using FRI over a field <span class="math">\\mathbb{F}</span> with rate <span class="math">\\rho</span> – in particular, to the family of AIR instances arising from the ethSTARK code — in time <span class="math">T</span> and with success probability <span class="math">\\epsilon</span>, then the toy problem over <span class="math">\\mathbb{F}</span> with rate <span class="math">\\rho</span> can be attacked in time <span class="math">T</span> with success probability <span class="math">\\epsilon</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Toy problem security</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The following presents the state of the art attack on the toy problem over <span class="math">\\mathbb{F}</span>, with rate <span class="math">\\rho</span>. The attacker <span class="math">\\mathsf{P}^{*}</span> commits to a low degree polynomial as the first function, say, the constant function <span class="math">\\forall xf(x)=1</span>. Now, with probability $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> we have </span>\\alpha=f(0)<span class="math"> in which case the function </span>g<span class="math"> is a low degree polynomial and we succeed with probability </span>1<span class="math">. Otherwise, the function </span>g<span class="math"> is a non-trivial rational function (in our example, </span>g(x)=\\frac{\\alpha}{x}$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, during the first iteration of the FRI protocol <span class="math">\\mathsf{P}^{*}</span> picks a <span class="math">\\rho</span>-fraction subset <span class="math">S</span> of <span class="math">\\mathsf{D}</span> and interpolates the polynomial $P_{S}(X),\\deg(P_{S}(X))<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> that agrees with </span>g<span class="math"> on </span>S<span class="math">. The prover </span>\\mathsf{P}^{*}<span class="math"> constructs all future FRI oracles using the (honest) FRI prover applied to </span>P_{S}(X)<span class="math"> instead of </span>g<span class="math">. The resulting acceptance probability of the FRI protocol, used with </span>t<span class="math"> iterations of the QUERY protocol, is </span>\\rho^{t}<span class="math">: this is the probability that all queries fall in </span>S<span class="math">. Summarizing, the attack succeeds with probability </span>\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\rho^{t}<span class="math"> and this is our conjectured security level for instances of ethSTARK that invoke FRI over a field </span>\\mathbb{F}<span class="math"> with rate </span>\\rho$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-60" class="text-xl font-semibold mt-8">5.10 Parameter settings</h3>

    <p class="text-gray-300">We specify a few concrete parameter settings for the IOP that can be used in the ethSTARK code to achieve 80, 100 and 128 bits of security or provable knowledge soundness. Recall ethSTARK operates over a base field <span class="math">\\mathbb{F}</span> of size <span class="math">p=2^{61}+20\\cdot 2^{32}+1</span>, so <span class="math">\\log_{2}p\\geq 61</span>. The extension field for DEEP and FRI are either the degree 2 extension <span class="math">\\mathbb{F}_{p^{2}}</span> or the degree 3 extension <span class="math">\\mathbb{F}_{p^{3}}</span>; let <span class="math">\\mathsf{e}</span> denote the extension degree. We use <span class="math">\\rho</span> to denote rate and <span class="math">R=-\\log_{2}\\rho</span> is the logarithm of the (inverse of the) rate. Recall that <span class="math">s</span> denotes the number of invocations of the FRI QUERY phase. We stress that the parameters selected in this section are not necessarily optimal, and can be easily modified in the ethSTARK code base.</p>

    <h4 id="sec-61" class="text-lg font-semibold mt-6">Hashes, the random oracle model, and grinding</h4>

    <p class="text-gray-300">ethSTARK uses Blake2s as the hash function used to create Merkle tree commitments and as a realization of the random oracle when using the Fiat-Shamir heuristic applied to the reduction from an IOP to a non-interactive IOP (NIROP) as per the reduction of <em>[x1]</em>. To achieve security level of <span class="math">\\lambda</span> bits we use Blake2s with digest size of at least <span class="math">2\\lambda</span>. Additionally, grinding may be used when generating the Fiat-Shamir challenge. This means we select as the random oracle output an output of the random oracle that also has a <span class="math">\\zeta</span> number of leading bits all equal to 0. In ethSTARK grinding is applied only before the very last step of the protocol, that of selecting the FRI queries in Step 7 of the ethSTARK IOP protocol described in Section 5.3, and this reduces the probability of erroneously accepting a false statement by a probability of <span class="math">2^{-\\zeta}</span>, which adds <span class="math">\\zeta</span> bits to the security/soundness of that last step. If <span class="math">\\epsilon_{0}</span> denotes the round-by-round soundness error of all steps before the FRI queries are generated, and <span class="math">\\epsilon_{1}</span> denotes the probability of acceptance of all FRI queries, the total probability of acceptance in the random oracle model is</p>

    <p class="text-gray-300"><span class="math">\\epsilon_{0}+(1-\\epsilon_{0})\\cdot 2^{-\\zeta}\\cdot\\epsilon_{1}</span> (18)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">and therefore the number of bits of security in the random oracle model is the logarithm of the expression above, which will be approximated by</p>

    <div class="my-4 text-center"><span class="math-block">\\lambda \\geq \\min \\{- \\log_ {2} \\epsilon_ {0}, \\zeta - \\log_ {2} \\epsilon_ {1} \\} - 1.</span></div>

    <p class="text-gray-300">see [CCH+18, CMS19] for further discussion of round-by-round soundness and the soundness of IOP-to-NIROP transformations.</p>

    <h2 id="sec-62" class="text-2xl font-bold">5.10.1 Suggested IOP Parameter Settings based on Conjectured Soundness</h2>

    <p class="text-gray-300">Based on Conjecture 1, the number of bits of security <span class="math">\\lambda</span> (in the random oracle model with <span class="math">\\zeta</span> bits of grinding and digest size <span class="math">\\geq 2\\lambda</span>), is given by the following formula:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\lambda \\geq \\min  \\left\\{\\zeta + R \\cdot s, \\log_ {2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right\\} - 1 \\tag {19}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Therefore, fixing the code rate to <span class="math">\\rho = 1 / 4</span> (with <span class="math">R = 2</span>) and <span class="math">\\zeta = 20</span> bits of grinding:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For <span class="math">\\lambda = 80</span> bits of security use extension degree <span class="math">\\mathsf{e} = 2</span> (so $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= p^2<span class="math">) and a number of FRI QUERY invocations equal to </span>s = 31$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">\\lambda = 100</span> use <span class="math">\\mathsf{e} = 2</span> and <span class="math">s = 41</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For <span class="math">\\lambda = 128</span> increase the extension degree to <span class="math">\\mathsf{e} = 3</span> (so $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= p^3<span class="math">) and </span>s = 55$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-63" class="text-2xl font-bold">5.10.2 Suggested IOP Parameter Settings based on Provable IOP Knowledge Soundness</h2>

    <p class="text-gray-300">To fix parameters for provable soundness we rely on Eq. (11) from Theorem 4 and plug in the expression for <span class="math">\\epsilon_{\\mathsf{FRI}}</span> from Eq. (10) in Theorem 3, obtaining the following formula:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\lambda \\geq \\min  \\left\\{ \\begin{array}{l} - \\log_ {2} \\left(\\frac {\\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac {\\left(\\mathrm {d} _ {\\max } + 2 ^ {\\mathrm {h}} + \\mathrm {a}\\right) \\cdot \\ell^ {2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\mathrm {a} \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm {D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm {H} _ {0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac {\\left(m + \\frac {1}{2}\\right) ^ {7} \\cdot n ^ {2}}{2 \\rho^ {3 / 2} q} + \\frac {(2 m + 1) \\cdot (n + 1)}{\\sqrt {\\rho}} \\cdot \\frac {\\sum_ {i = 0} ^ {\\prime - 1} t _ {i}}{q}\\right), \\\\ \\zeta - s \\cdot \\log_ {2} \\left(\\sqrt {\\rho} \\cdot \\left(1 + \\frac {1}{2 m}\\right)\\right) \\end{array} \\right\\} - 1 \\tag {20}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where the parameters above are defined as in Theorems 3 and 4, noticing that the expression on the top row corresponds to "pre-FRI-query error" as explained earlier (i.e., <span class="math">\\epsilon_0</span> in Eq. (18)) and the bottom row, to which grinding is applied in ethSTARK, corresponding to the FRI QUERY error (<span class="math">\\epsilon_{1}</span> in Eq. (18)), see Remark 4. For simplicity we shall fix the extension degree to <span class="math">\\mathsf{e} = 3</span> so $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; 2^{183}<span class="math"> and the rate to </span>\\rho = 1 / 4<span class="math"> so that </span>R = 2<span class="math">. Fix </span>m = 3<span class="math"> so that in Eq. (20) we have </span>\\ell = 12\\leq 2^4<span class="math">. In the ethSTARK statement referring to 98,304 invocations of the Rescue hash we have </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{\\mathsf{h}}<span class="math"> for </span>\\mathsf{h} = 20<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ \\rho = 2^{22}<span class="math">. We also have </span>\\mathsf{d}_{\\max} = 2^{22}<span class="math"> and </span>\\mathsf{a} = 4<span class="math">. We notice that in the FRI protocol </span>\\sum_{i}t_{i}\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{20}$. Therefore the sum in logarithm on the top row of Eq. (20) is bounded by</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\frac {2 ^ {4}}{2 ^ {1 8 3}} + \\frac {2 ^ {2 3} \\cdot 2 ^ {8}}{2 ^ {1 8 2}} + \\frac {4 ^ {7} \\cdot (2 ^ {2 2}) ^ {2}}{2 / 8 \\cdot 2 ^ {1 8 3}} + 2 ^ {2 6} \\cdot \\frac {2 ^ {2 0}}{2 ^ {1 8 3}} \\leq 2 ^ {- 1 2 2}, \\tag {21}</span></div>

    <p class="text-gray-300">where the dominating term is the third summand above.</p>

    <p class="text-gray-300">Fixing the number of bits of grinding to <span class="math">\\zeta = 20</span> as above, for provable soundness level of <span class="math">\\lambda = 80</span> bits we may use <span class="math">s = 79</span> invocations to reach soundness error of less than <span class="math">2^{-80}</span>, and for provable soundness of <span class="math">\\lambda = 100</span> bits we may use <span class="math">s = 104</span>.</p>

    <p class="text-gray-300">STARKWARE Page 40</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For provable soundness of <span class="math">\\lambda=128</span> bits the error term from Eq. (21) is too large. To lower it to acceptable levels, the simplest option is to work with a degree 4 extension field, so that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{244}<span class="math">. This would lower the error term of Eq. (21) to well below </span>2^{-128}<span class="math">, at which point fixing the number </span>s<span class="math"> of FRI QUERY invocations to </span>s=140<span class="math"> (with </span>\\zeta=20$ bits of grinding) will reach the target soundness error.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-64" class="text-2xl font-bold">6 Provable Round-by-Round Soundness</h2>

    <p class="text-gray-300">In the previous section, we derive bounds of the soundness (and knowledge soundness) of the ethSTARK protocol. The security of the IOP is shown in an idealized model (the IOP model) where the prover commits to messages, and the verifier has oracle access to these messages. The IOP is compiled into a STARK system using the transformation given in <em>[x1]</em> (the BCS transformation). The BCS transformation compiles IOPs to STARKs in the random oracle model (or heuristically based on a suitable cryptographic hash function). However, for the transformation to be sound, it is not sufficient to merely bound the soundness of the IOP, but one needs to show a stronger property called <em>round-by-round soundness</em> (The BCS transformation actually uses a different notion called state-restoration soundness. However, the former implies the latter as we explain in Claim 1). Round-by-round soundness captures the security of each round separately, which works well with Fiat-Shamir transformation (used in the BCS compiler), where the cheating prover is allowed to rewind the verifier to a previous round and try again.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Remark 5.</h6>

    <p class="text-gray-300">An independent and thorough analysis of round by round soundness for FRI and related protocols appears in the independent work of Block et al. <em>[BGK^{+}23]</em>. The round-by-round soundness in that work and this one are nearly identical. The main differences are that our work (1) gives fine-grained error terms for later rounds of the FRI protocol, and (2) analyzes the impact of grinding on security. Both aspects may be useful when optimizing concrete security parameters. On the other hand, the work of Block et al. takes an approach that may be more easily generalizable to other FRI-based protocols.</p>

    <p class="text-gray-300">We give bounds for the round-by-round soundness of the protocol. We begin with formal definitions.</p>

    <h3 id="sec-66" class="text-xl font-semibold mt-8">6.1 Definition of Vector Round-by-Round Soundness</h3>

    <p class="text-gray-300">We give a definition of round-by-round soundness for IOP protocols. The definition we give here is a fine-grained version of previous notions, where we precisely capture the soundness error <em>per round</em>. Thus, instead of a single soundness parameter, we will have a vector of parameters, one for each round of the IOP protocols. We begin with a definition of a state function for an IOP.</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Definition 6 (State function).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathsf{P},\\mathsf{V})</span> be an IOP for a relation <span class="math">R</span>. A state function for <span class="math">(\\mathsf{P},\\mathsf{V})</span> is a deterministic (possibly inefficient) function state that receives as input an instance <span class="math">\\mathtt{x}</span> and a transcript <span class="math">\\mathtt{tr}</span> and outputs a bit for which the following holds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Empty transcript: if <span class="math">\\mathtt{tr}=\\emptyset</span> is the empty transcript then <span class="math">\\mathtt{state}(\\mathtt{x},\\mathtt{tr})=0</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Prover moves: if <span class="math">\\mathtt{tr}</span> is a transcript where the prover is about to move and <span class="math">\\mathtt{state}(\\mathtt{x},\\mathtt{tr})=0</span>, then for any <span class="math">\\Pi</span>, $\\mathtt{state}(\\mathtt{x},\\mathtt{tr}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi)=0$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">18the current ethSTARK codebase does not specify a degree 4 extension for \\mathbb{F}_p .</p>

    <p class="text-gray-300">STARKWARE</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Full transcript: if <span class="math">\\operatorname{tr} = (\\vec{\\sigma}, \\vec{\\Pi})</span> (the verifier messages are <span class="math">\\vec{\\sigma}</span> and the prover messages are <span class="math">\\vec{\\Pi}</span>) is a full transcript and <span class="math">\\operatorname{state}(\\mathbf{x}, \\operatorname{tr}) = 0</span>, then <span class="math">\\mathsf{V}^{\\vec{\\Pi}}(\\mathbf{x}; \\vec{\\sigma}) = 0</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Definition 7 (Vector round-by-round soundness).</strong> An IOP <span class="math">(\\mathsf{P},\\mathsf{V})</span> with <span class="math">\\mathsf{k}</span> rounds for a relation <span class="math">R</span> has round-by-round soundness error <span class="math">(\\varepsilon_1,\\ldots ,\\varepsilon_{\\mathsf{k}})</span> if there exists a state function <span class="math">\\mathsf{state}</span> such that for all <span class="math">\\mathbf{x} \\notin L(R)</span>, every <span class="math">i \\in [\\mathsf{k}]</span>, and every transcript <span class="math">\\operatorname{tr}</span> of the first <span class="math">i</span> rounds where the verifier is about to move and <span class="math">\\mathsf{state}(\\mathbf{x},\\operatorname{tr}) = 0</span> it holds that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_{\\sigma}[\\mathsf{state}(\\mathbf{x}, \\mathsf{tr} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma) = 1] \\leq \\varepsilon_{i}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">If <span class="math">\\varepsilon_1 = \\dots = \\varepsilon_{\\mathsf{k}} = \\varepsilon</span> then we say that the IOP has <span class="math">\\varepsilon</span>-round-by-round soundness.</p>

    <h2 id="sec-68" class="text-2xl font-bold">6.2 Round-by-Round Soundness Analysis</h2>

    <p class="text-gray-300">We analyse the round-by-round soundness of the ethSTARK IOP. The soundness error vector is given in the following theorem.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Theorem 5.</strong> For any <span class="math">m \\geq 3</span>, the ethSTARK IOP has $\\mathsf{k} = 3 +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathsf{t}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> rounds and vector round-by-round soundness error </span>(\\varepsilon_1, \\ldots, \\varepsilon_{\\mathsf{k}})$ where:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. $\\varepsilon_{1} = \\frac{\\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\varepsilon_{3} = \\frac{(m + \\frac{1}{2})^{7}\\cdot n^{2}}{3\\rho^{3 / 2}\\cdot q}</span>.</li>

      <li>For any <span class="math">4 \\leq i \\leq \\mathsf{k} - 1</span>: <span class="math">\\varepsilon_{i} = \\frac{\\varepsilon_{3}}{t_{i-4}} \\prod_{j=0}^{i-5} t_{j}^{-2} + \\frac{(2m+1)(n+1)t_{i-4}}{q\\sqrt{\\rho}}</span>.</li>

      <li><span class="math">\\varepsilon_{\\mathsf{k}} = \\left(\\sqrt{\\rho} \\cdot \\left(1 + \\frac{1}{2m}\\right)\\right)^{s}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $\\ell = \\frac{m}{\\rho - \\frac{2m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Before we begin the proof, we give a useful definition and some lemmas.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 8 (Domain Degree).</strong> Given a function <span class="math">f</span> defined over some domain <span class="math">D</span>, we define <span class="math">\\deg_D(f)</span> to be the minimal degree <span class="math">d</span> of a polynomial <span class="math">p</span> that satisfies <span class="math">f(x) = p(x)</span> for all <span class="math">x \\in D</span>. We say <span class="math">f</span> has <span class="math">D</span>-degree <span class="math">d</span> in this case. Clearly $\\deg_D f \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 5.</strong> Fix some domain <span class="math">D \\subseteq \\mathbb{F}</span>. Let <span class="math">a, b \\in \\mathbb{F}[x]</span> such that <span class="math">b</span> does not divide <span class="math">a</span>, and for every <span class="math">x \\in D</span>: <span class="math">b(x) \\neq 0</span>. If $\\deg a \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math">, then, </span>\\deg_D \\frac{a}{b} \\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\deg_D b$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> Let <span class="math">c \\in \\mathbb{F}[x]</span> such that <span class="math">c = \\frac{a}{b}</span> on <span class="math">D</span> with minimal degree. The polynomial <span class="math">f = a - bc</span> is identically zero on <span class="math">D</span>, but not the zero polynomial (because <span class="math">b</span> does not divide <span class="math">a</span>), so $\\deg(f) \\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Since </span>\\deg(a) &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, we must have </span>\\deg(bc) \\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, or </span>\\deg(c) \\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\deg(b)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Lemma 6.</strong> <span class="math">\\mathsf{a} \\geq \\max_{i} \\{\\deg(Q_i)\\} - 1</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> For every <span class="math">i</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{\\mathsf{h}}<span class="math">. By definition of </span>\\mathsf{d}_{\\max}<span class="math">, for every </span>i$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{a} \\geq \\deg(Q_{i}) - \\frac{1 +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{2^{\\mathsf{h}}} \\geq \\deg(Q_{i}) - 1 - \\frac{1}{2^{\\mathsf{h}}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">As <span class="math">\\mathsf{a}</span> is an integer, <span class="math">\\mathsf{a} \\geq \\deg(Q_i) - 1</span> for every <span class="math">i</span>.</p>

    <p class="text-gray-300">STARKWARE Page 42</p>

    <p class="text-gray-300">Lemma 7. Let <span class="math">f_1, \\ldots, f_m \\colon \\mathsf{D} \\to \\mathbb{F}</span> be functions. Let <span class="math">(a_1, b_1), \\ldots, (a_m, b_m) \\in (\\mathbb{F} \\setminus \\mathsf{D}) \\times \\mathbb{F}</span>. Define <span class="math">g_i = \\text{Quotient}(f_i; a_i, b_i)</span>. For any <span class="math">\\eta \\geq \\rho</span>, if there exists a set <span class="math">S</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all <span class="math">i \\in [m]</span>: <span class="math">g_i</span> agrees with some <span class="math">v_i \\in \\mathsf{RS}[\\mathbb{F}, \\mathsf{D}, \\rho]</span> on <span class="math">S</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\eta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">then for all <span class="math">i \\in [m]</span>, there exists <span class="math">u_i \\in \\mathsf{RS}[\\mathbb{F}, \\mathsf{D}, \\rho^+]</span> such that <span class="math">f_i</span> and <span class="math">u_i</span> agree on <span class="math">S</span> and <span class="math">u_i(a_i) = b_i</span>.</p>

    <p class="text-gray-300">Proof. For every <span class="math">i \\in [m]</span>, define <span class="math">u_i(x) = (x - a_i)v_i(x) + b_i</span>. As <span class="math">v_i \\in \\mathsf{RS}[\\mathbb{F}, \\mathsf{D}, \\rho]</span> and <span class="math">\\deg(u_i) = \\deg(v_i) + 1</span>, we have <span class="math">u_i \\in \\mathsf{RS}[\\mathbb{F}, \\mathsf{D}, \\rho^+]</span>. By definition of the <span class="math">v_i</span>'s, for every <span class="math">i \\in [m]</span> and every <span class="math">x \\in S</span> we have</p>

    <div class="my-4 text-center"><span class="math-block">u_i(x) = (x - a_i) \\cdot \\frac{f_i(x) - b_i}{x - a_i} + b_i = f_i(x),</span></div>

    <p class="text-gray-300">and by definition of <span class="math">u_i</span>: <span class="math">u_i(a_i) = b_i</span>.</p>

    <p class="text-gray-300">With these lemmas, we are ready to start the proof.</p>

    <p class="text-gray-300">Proof of Theorem 5. Given the commitment <span class="math">\\vec{f} = (f_1, \\ldots, f_{\\mathsf{w}})</span> from Step 1 of the protocol, we denote by <span class="math">\\mathcal{P}</span> the set of polynomial vectors (vectors of <span class="math">\\mathsf{w}</span> polynomials), each of degree <span class="math">\\leq 2^{\\mathsf{h}}</span>, such that each vector <span class="math">\\vec{\\mathsf{P}} \\in \\mathcal{P}</span> has correlated agreement with <span class="math">\\vec{f}</span> on some set of density <span class="math">\\geq \\sqrt{\\rho}(1 + \\frac{1}{2m})</span>. Namely, we set</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P} = \\left\\{(\\mathsf{P}_1, \\ldots, \\mathsf{P}_{\\mathsf{w}}) \\in \\mathsf{RS}[\\mathbb{F}, \\mathsf{D}, \\rho^+]^{\\mathsf{w}}: \\exists S \\subseteq \\mathsf{D},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\sqrt{\\rho}(1 + \\frac{1}{2m})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\forall i \\in [\\mathsf{w}]: \\mathsf{P}_i \\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S \\equiv f_i \\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Similarly, we define <span class="math">\\mathcal{P}^{\\vec{r}}</span> as the set of polynomial vectors (with <span class="math">\\mathsf{a}</span> entries each), each of degree <span class="math">\\leq 2^{\\mathsf{h}}</span>, such that each vector <span class="math">\\vec{\\mathsf{P}}^{\\vec{r}} \\in \\mathcal{P}^{\\vec{r}}</span> has correlated agreement with <span class="math">\\vec{f}^{\\vec{r}}</span> (sent by the prover in Step 3 of the protocol) on some set of density <span class="math">\\geq \\sqrt{\\rho}(1 + \\frac{1}{2m})</span>:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}^{\\vec{r}} = \\left\\{(\\mathsf{P}_0^{\\vec{r}}, \\ldots, \\mathsf{P}_{\\mathsf{a} - 1}^{\\vec{r}}) \\in \\mathsf{RS}[\\mathbb{F}, \\mathsf{D}, \\rho^+]^{\\mathsf{a}}: \\exists S \\subseteq \\mathsf{D},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\sqrt{\\rho}(1 + \\frac{1}{2m})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\forall i \\in [\\mathsf{a}]: \\mathsf{P}_{i - 1}^{\\vec{r}} \\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S \\equiv f_i^{\\vec{r}} \\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Note that <span class="math">\\mathcal{P}, \\mathcal{P}^{\\vec{r}}</span> are sets of vectors of codewords in <span class="math">\\mathsf{RS}[\\mathbb{F}, \\mathsf{D}, \\rho^{+}]</span>, but the correlation domain size we need is given in terms of <span class="math">\\rho</span> (and not <span class="math">\\rho^{+}</span>). Looking ahead, this is useful when checking proximity of <span class="math">g_{(\\vec{r}, \\mathbf{q}, \\text{answer}, r^F)}</span> to <span class="math">\\mathsf{RS}[\\mathbb{F}, \\mathsf{D}, \\rho]</span> (in Step 7).</p>

    <p class="text-gray-300">To bound the sizes of <span class="math">\\mathcal{P}, \\mathcal{P}^{\\vec{r}}</span>, we use the Johnson bound (Theorem 1). We define the slackness parameter <span class="math">\\eta</span> as:</p>

    <div class="my-4 text-center"><span class="math-block">\\eta = \\sqrt{\\rho}(1 + \\frac{1}{2m}) - \\sqrt{\\rho^+}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">C = \\mathsf{RS}[\\mathbb{F}, \\mathsf{D}, \\rho^+]^{\\mathsf{w}}</span>. The set <span class="math">C</span> can be considered as a linear code over the alphabet <span class="math">\\Sigma = \\mathbb{F}^{\\mathsf{w}}</span>: if we enumerate $\\mathsf{D} = \\{x_1, \\ldots, x_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\}<span class="math">, every codeword </span>c = (c_1, \\ldots, c_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}) \\in C<span class="math"> corresponds to some tuple </span>(\\mathsf{P}_1, \\ldots, \\mathsf{P}_{\\mathsf{w}}) \\in \\mathsf{RS}[\\mathbb{F}, \\mathsf{D}, \\rho^+]^{\\mathsf{w}}<span class="math"> where </span>c_i = (\\mathsf{P}_1(x_i), \\ldots, \\mathsf{P}_{\\mathsf{w}}(x_i)) \\in \\Sigma<span class="math"> for every </span>i \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math">. The relative distance of the code </span>C<span class="math"> is exactly </span>1 - \\rho^+<span class="math">, so the Johnson bound implies that the number of codewords of </span>C<span class="math"> that agree with some arbitrary </span>y = (y_1, \\ldots, y_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}) \\in \\Sigma^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> on at least </span>\\sqrt{\\rho}(1 + \\frac{1}{2m})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> entries is at most </span>\\frac{1}{2\\eta\\sqrt{\\rho^+}}<span class="math">. A single point of agreement between </span>y<span class="math"> and some codeword </span>c \\in C<span class="math"> at entry </span>i \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math"> corresponds to a point of correlated agreement of </span>\\mathsf{P}_1, \\ldots, \\mathsf{P}_{\\mathsf{w}}<span class="math"> with </span>\\vec{f}<span class="math">, i.e. </span>\\mathsf{P}_j(x_i) = f_j(x_i)<span class="math"> for all </span>j \\in [\\mathsf{w}]<span class="math">. This means we can bound </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> from above by </span>\\frac{1}{2\\eta\\sqrt{\\rho^+}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">STARKWARE Page 43</p>

    <p class="text-gray-300">By applying the same argument for <span class="math">\\mathcal{P}^{\\vec{r}}</span>, we can bound the sizes of these sets as:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\max\\{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}^{\\vec{r}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}\\leq\\frac{1}{2\\eta\\sqrt{\\rho^{+}}}=\\frac{1}{2(\\sqrt{\\rho\\rho^{+}}(1+\\frac{1}{2m})-\\rho^{+})}\\leq\\frac{1}{\\frac{\\rho}{m}+2(\\rho-\\rho^{+})}=\\frac{m}{\\rho-\\frac{2m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}=\\ell.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As we are proving round-by-round soundness, we assume the AIR instance is unsatisfiable, as per Definitions 2 and 3.</p>

    <h4 id="sec-69" class="text-lg font-semibold mt-6">Bound on <span class="math">\\varepsilon_{1}</span>.</h4>

    <p class="text-gray-300">Let <span class="math">\\mathsf{tr}=\\vec{f}</span> be a partial transcript for Step 1 of the protocol. In Step 2, the verifier samples uniform randomness <span class="math">\\vec{r}=(r_{1},r^{\\prime}_{1},\\ldots,r_{s},r^{\\prime}_{s})\\in\\mathbb{K}^{2\\mathsf{s}}</span>, two elements per constraint. We define the state function <span class="math">\\mathsf{state}</span> such that <span class="math">\\mathsf{state}(\\mathsf{tr},\\vec{r})=1</span> if and only if</p>

    <p class="text-gray-300"><span class="math">\\exists\\vec{\\mathsf{P}}\\in\\mathcal{P}:\\deg_{\\mathbb{K}\\setminus\\mathsf{H}_{0}}(Q^{\\vec{r}}(X,\\mathsf{Y})\\circ\\vec{\\mathsf{P}})&lt;\\mathsf{d}_{\\mathsf{max}}+\\mathsf{a}.</span></p>

    <p class="text-gray-300">Namely, the state function indicates that the rational function on the LHS has <span class="math">\\mathbb{K}\\setminus\\mathsf{H}_{0}</span>-degree less than <span class="math">\\mathsf{d}_{\\mathsf{max}}+\\mathsf{a}</span>.</p>

    <p class="text-gray-300">We bound the probability that <span class="math">\\mathsf{state}(\\vec{f},\\vec{r})=1</span>. Fix any <span class="math">\\vec{\\mathsf{P}}\\in\\mathcal{P}</span>. Since the AIR is not satisfiable, no polynomial can satisfy all constraints, therefore there must exist some <span class="math">i\\in[\\mathsf{s}]</span> such that</p>

    <p class="text-gray-300"><span class="math">\\frac{\\left(Q_{i}(\\mathsf{Y})\\circ\\vec{\\mathsf{P}}\\right)(x)}{\\mathsf{Z}_{\\mathsf{H}_{i}}(x)}\\notin\\mathbb{F}[x].</span></p>

    <p class="text-gray-300">(Namely, it is a rational function, but not a polynomial.) By Lemma 5 (with <span class="math">a:=Q_{i}(\\mathsf{Y})\\circ\\vec{\\mathsf{P}}</span>, <span class="math">b=\\mathsf{Z}_{\\mathsf{H}_{i}}</span>, and <span class="math">D=\\mathbb{K}\\setminus\\mathsf{H}_{0}</span>, which is contained in <span class="math">\\mathbb{K}\\setminus\\mathsf{H}_{i}</span>), we get that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\deg_{\\mathbb{K}\\setminus\\mathsf{H}_{0}}\\frac{Q_{i}(\\mathsf{Y})\\circ\\vec{\\mathsf{P}}}{\\mathsf{Z}_{\\mathsf{H}_{i}}}\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\mathsf{d}_{\\mathsf{max}}+\\mathsf{a}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Therefore, for any <span class="math">\\vec{\\mathsf{P}}\\in\\mathcal{P}</span> there exist some <span class="math">i</span> such that <span class="math">\\deg_{\\mathbb{K}\\setminus\\mathsf{H}_{0}}(R^{\\vec{r}}_{i}(x))&gt;\\mathsf{d}_{\\mathsf{max}}+\\mathsf{a}</span>. As <span class="math">Q^{\\vec{r}}</span> is a random linear combination of the <span class="math">R^{\\vec{r}}_{j}</span>’s, the probability that the leading coefficient (of degree at least <span class="math">\\mathsf{d}_{\\mathsf{max}}+\\mathsf{a}</span>) cancels out is at most $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. By the union bound over all </span>\\vec{\\mathsf{P}}\\in\\mathcal{P}<span class="math">, the probability that some </span>\\vec{\\mathsf{P}}\\in\\mathcal{P}<span class="math"> satisfies </span>\\deg_{\\mathbb{K}\\setminus\\mathsf{H}_{0}}(Q^{\\vec{r}}(x,\\mathsf{Y})\\circ\\vec{\\mathsf{P}})<\\mathsf{d}_{\\mathsf{max}}+\\mathsf{a}<span class="math"> is at most </span>\\frac{\\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, proving the bound on </span>\\varepsilon_{1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-70" class="text-base font-medium mt-4">Remark 6 (Reducing randomness).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Instead of sampling <span class="math">\\vec{r}\\in\\mathbb{K}^{2\\mathsf{s}}</span>, one may sample a single <span class="math">r\\in\\mathbb{K}</span> and define <span class="math">r_{i}=r^{2(i-1)},r^{\\prime}_{i}=r^{2(i-1)+1}</span>. The leading coefficient would be a non-zero polynomial in <span class="math">r</span> of degree <span class="math">2\\mathsf{s}-1</span>, so the probability it is zero is at most <span class="math">\\frac{2\\mathsf{s}-1}{\\mathbb{K}}</span> (which would make the round soundness $\\frac{(2\\mathsf{s}-1)\\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$). This may be useful when minimizing usage of randomness is a priority.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-71" class="text-lg font-semibold mt-6">Bound on <span class="math">\\varepsilon_{2}</span>.</h4>

    <p class="text-gray-300">Let <span class="math">\\mathsf{tr}=(\\vec{f},\\vec{r},\\vec{f}^{\\prime})</span> be a partial trace up to Step 3. In Step 4, for a partial transcript, we define <span class="math">\\mathsf{state}(\\mathsf{tr},\\mathsf{q})=1</span> if and only if there exists some <span class="math">\\vec{\\mathsf{P}}\\in\\mathcal{P}</span> and <span class="math">\\vec{\\mathsf{P}}^{\\vec{r}}\\in\\mathcal{P}^{\\vec{r}}</span> such that for <span class="math">X=\\mathsf{q}</span> it holds that</p>

    <p class="text-gray-300"><span class="math">\\left(Q^{\\vec{r}}(X,\\mathsf{Y})\\circ\\vec{\\mathsf{P}}\\right)(X)=\\sum_{k=0}^{\\mathsf{a}-1}X^{k}\\cdot\\mathsf{P}^{\\vec{r}}_{k}(X^{\\mathsf{a}}).</span> (22)</p>

    <p class="text-gray-300">Assume that <span class="math">\\mathsf{state}(\\mathsf{tr})=0</span> and we bound the probability that <span class="math">\\mathsf{state}(\\mathsf{tr},\\mathsf{q})=1</span>. Fix any <span class="math">\\vec{\\mathsf{P}}\\in\\mathcal{P}</span> and any <span class="math">\\vec{\\mathsf{P}}^{\\vec{r}}\\in\\mathcal{P}^{\\vec{r}}</span>. First, we show that the left-hand side polynomial over <span class="math">\\mathbb{K}\\setminus\\mathsf{H}_{0}</span> and right-hand side polynomial are distinct polynomials. This follows since they have different degrees (over <span class="math">\\mathbb{K}\\setminus\\mathsf{H}_{0}</span>):</p>

    <p class="text-gray-300">###</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(Left-hand side.) Since <span class="math">\\textsf{state}(\\textsf{tr})=0</span>, we know that the polynomial on the left-hand side is of <span class="math">\\mathbb{K}\\setminus\\mathsf{H}_{0}</span>-degree at least <span class="math">\\mathsf{d}_{\\textsf{max}}+\\mathsf{a}</span>.</li>

      <li>(Right-hand side.) Recall that <span class="math">\\mathsf{a}\\cdot 2^{\\mathsf{h}}=\\mathsf{d}_{\\textsf{max}}</span>. Thus, the polynomial on the right-hand side is of <span class="math">\\mathbb{K}\\setminus\\mathsf{H}_{0}</span>-degree at most</li>

    </ul>

    <p class="text-gray-300"><span class="math">(\\mathsf{a}-1)+\\mathsf{a}\\cdot\\max_{k}\\{\\deg(\\mathsf{P}_{k}^{\\mathsf{\\bar{r}}})\\}\\leq(\\mathsf{a}-1)+\\mathsf{a}\\cdot 2^{\\mathsf{h}}=(\\mathsf{a}-1)+\\mathsf{d}_{\\textsf{max}}&lt;\\mathsf{d}_{\\textsf{max}}+\\mathsf{a}.</span></p>

    <p class="text-gray-300">Next, we bound the probability that <span class="math">\\mathsf{q}</span> satisfies Equation (22). It will be more convenient to multiply both sides by <span class="math">\\mathsf{Z}_{\\mathsf{H}_{0}}(X)</span> and write the equation:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Z}_{\\mathsf{H}_{0}}(X)\\cdot\\left(Q^{\\mathsf{\\bar{r}}}(X,\\mathsf{Y})\\circ\\vec{\\mathsf{P}}\\right)(X)=\\mathsf{Z}_{\\mathsf{H}_{0}}(X)\\cdot\\sum_{k=0}^{\\mathsf{a}-1}X^{k}\\cdot\\mathsf{P}_{k}^{\\mathsf{\\bar{r}}}(X^{\\mathsf{a}}).</span> (23)</p>

    <p class="text-gray-300">Note that the left-hand side and right-hand side are distinct polynomials over <span class="math">\\mathbb{K}\\setminus\\mathsf{H}_{0}</span>, since <span class="math">\\mathsf{Z}_{\\mathsf{H}_{0}}(X)</span> is non-zero on <span class="math">\\mathbb{K}\\setminus\\mathsf{H}_{0}</span>. Moreover, the point <span class="math">\\mathsf{q}</span> satisfies Equation (22) (in <span class="math">\\mathbb{K}\\setminus\\mathsf{H}_{0}</span>) if and only if it satisfies Equation (23). Thus, to bound the probability that <span class="math">\\mathsf{q}</span> satisfies Equation (23), we bound the degree of both polynomials.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(Left-hand side.) The left-hand side is a sum of polynomials, each summand of the following form:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{Z}_{\\mathsf{H}_{0}}(X)\\cdot(\\mathsf{r}_{i}+\\mathsf{r}_{i}^{\\prime}\\cdot X^{\\mathsf{c}_{i}})\\cdot\\frac{(Q_{i}(X,\\mathsf{Y})\\circ\\vec{\\mathsf{P}})(X)}{\\mathsf{Z}_{\\mathsf{H}_{i}}(X)}=\\mathsf{Z}_{\\mathsf{H}_{0}\\setminus\\mathsf{H}_{i}}(X)\\cdot(\\mathsf{r}_{i}+\\mathsf{r}_{i}^{\\prime}\\cdot X^{\\mathsf{c}_{i}})\\cdot(Q_{i}(X,\\mathsf{Y})\\circ\\vec{\\mathsf{P}})(X).</span></p>

    <p class="text-gray-300">Thus, the degree of such a summand is at most:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{c}_{i}+\\deg(Q_{i})\\cdot 2^{\\mathsf{h}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">=2^{\\mathsf{h}}+\\mathsf{d}_{i}+\\mathsf{c}_{i}+\\deg(Q_{i})</span> <span class="math">\\leq 2^{\\mathsf{h}}+\\mathsf{d}_{i}+\\mathsf{c}_{i}+\\mathsf{a}+1\\quad\\text{\\tiny(by Lemma 6)}</span> <span class="math">=2^{\\mathsf{h}}+\\mathsf{d}_{\\textsf{max}}-1+\\mathsf{a}+1=2^{\\mathsf{h}}+\\mathsf{d}_{\\textsf{max}}+\\mathsf{a}\\quad\\text{\\tiny(by definition of </span>\\mathsf{c}_{i}<span class="math">)}.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(Right-hand side.) Since <span class="math">\\deg(\\mathsf{Z}_{\\mathsf{H}_{0}\\setminus\\mathsf{H}_{i}}(X))\\leq 2^{\\mathsf{h}}</span>, the right-hand side is of degree at most</li>

    </ul>

    <p class="text-gray-300"><span class="math">2^{\\mathsf{h}}+\\mathsf{d}_{\\textsf{max}}+\\mathsf{a}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">That is, we have two <em>distinct</em> polynomials, each of degree at most <span class="math">2^{\\mathsf{h}}+\\mathsf{a}+\\mathsf{d}_{\\textsf{max}}</span>, which may agree on at most <span class="math">2^{\\mathsf{h}}+\\mathsf{a}+\\mathsf{d}_{\\textsf{max}}</span> points. The query <span class="math">\\mathsf{q}</span> is sampled from a set of size at least $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-(\\mathsf{a}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, thus the probability that Equation (23) is satisfied is at most</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{2^{\\mathsf{h}}+\\mathsf{a}+\\mathsf{d}_{\\textsf{max}}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-(\\mathsf{a}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Applying the union bound over all <span class="math">\\ell^{2}</span> pairs <span class="math">(\\vec{\\mathsf{P}},\\vec{\\mathsf{P}}^{\\mathsf{\\bar{r}}})\\in\\mathcal{P}\\times\\mathcal{P}^{\\mathsf{\\bar{r}}}</span>, we conclude the bound on <span class="math">\\varepsilon_{2}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Bound on <span class="math">\\varepsilon_3</span>. Let <span class="math">\\mathbf{tr}</span> be a partial transcript of the form <span class="math">\\mathbf{tr} = (\\vec{f},\\vec{r},\\vec{f}&#x27;&#x27;,\\mathbf{q},\\mathbf{answer})</span>, where <span class="math">\\mathbf{answer} = \\{\\alpha_{i,j}:(i,j)\\in \\mathsf{I}\\} \\cup \\{\\beta_k:k\\in \\{0,\\dots ,\\mathsf{a} - 1\\} \\} \\in \\mathbb{K}^{\\mathsf{I}\\cup [\\mathsf{a}]}</span>. We define <span class="math">\\mathsf{state}(\\mathbf{tr},\\mathbf{r}^F) = 1</span> if and only if the function</p>

    <div class="my-4 text-center"><span class="math-block">g _ {(\\vec {r}, \\mathbf {q}, \\text {answer}, r ^ {F})} (x) := \\sum_ {(i, j) \\in \\mathrm {I}} r _ {(i, j)} ^ {F} \\cdot \\text {Quotient} \\left(f _ {i}; \\mathbf {q} \\cdot \\mathbf {g} ^ {j}, \\alpha_ {i, j}\\right) (x) + \\sum_ {k = 0} ^ {\\mathrm {a} - 1} r _ {k} ^ {F} \\cdot \\text {Quotient} \\left(f _ {k} ^ {\\vec {r}}; \\mathbf {q} ^ {\\mathrm {a}}, \\beta_ {k}\\right) (x) \\tag {24}</span></div>

    <p class="text-gray-300">is <span class="math">\\delta</span>-close to <span class="math">\\mathsf{RS}[\\mathbb{F},D,\\rho]</span> for <span class="math">\\delta = 1 - \\sqrt{\\rho}(1 + \\frac{1}{2m})</span>.</p>

    <p class="text-gray-300">We now bound the probability over <span class="math">\\mathbf{r}^F</span> that <span class="math">\\mathrm{state}(\\mathrm{tr},\\mathbf{r}^F) = 1</span>. We start by applying Theorem 7.4 of [BCI+20] (with <span class="math">M = 1</span> and <span class="math">\\mu \\equiv 1</span>) to say that if</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_ {\\mathbf {r} ^ {F}} \\left(\\Delta \\left(g _ {(\\vec {\\mathbf {r}}, \\mathbf {q}, \\text {answer}, \\mathbf {r} ^ {F})}, \\mathsf {R S} [ \\mathbb {F}, \\mathsf {D}, \\rho ]\\right) \\leq \\delta\\right) &amp;gt; \\frac {(m + \\frac {1}{2}) ^ {7} n ^ {2}}{3 \\rho^ {\\frac {3}{2}} q},</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">then there exist polynomials <span class="math">\\{\\tilde{h}_{i,j},\\tilde{h}_k^r:(i,j)\\in \\mathsf{I},k\\in [\\mathsf{a}]\\} \\subseteq \\mathsf{RS}[\\mathbb{F},\\mathsf{D},\\rho ]</span> and a set $S\\subseteq \\mathsf{D},\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\geq 1 - \\delta<span class="math"> such that Quotient </span>(f_{i};\\mathbf{q}\\cdot \\mathbf{g}^{j},\\alpha_{i,j})(x) = \\tilde{h}_{i,j}(x)<span class="math"> and Quotient </span>(f_k^r;\\mathbf{q}^{\\mathrm{a}},\\beta_k)(x) = \\tilde{h}_k^r (x)<span class="math"> for all </span>x\\in S,(i,j)\\in \\mathsf{I},k\\in [\\mathsf{a}]<span class="math">. By Lemma 7, there must exist </span>\\{h_{i,j},h_k^r:(i,j)\\in \\mathsf{I},0\\leq k &lt;   \\mathsf{a}\\} \\subseteq \\mathsf{RS}[\\mathbb{F},\\mathsf{D},\\rho^{+}]<span class="math"> such that </span>f_{i}(x) = h_{i,j}(x)<span class="math"> and </span>f_{k}^{\\vec{r}}(x) = h_{k}^{\\vec{r}}(x)<span class="math"> for all </span>x\\in S,(i,j)\\in \\mathsf{I},k\\in [\\mathsf{a}]<span class="math">. In addition, </span>h_{i,j}(\\mathbf{q}\\cdot \\mathbf{g}^j) = \\alpha_{i,j}<span class="math"> for all </span>(i,j)\\in \\mathsf{I}<span class="math"> and </span>h_k(\\mathbf{q}^{\\mathrm{a}}) = \\beta_k<span class="math"> for all </span>k\\in [\\mathsf{a}]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that for a fixed <span class="math">i</span>, and any <span class="math">j_1 \\neq j_2</span>, we have <span class="math">h_{i,j_1} = h_{i,j_2}</span> (as they agree on <span class="math">S</span>). Thus, we drop the <span class="math">j</span> s, and simply denote <span class="math">h_i</span> when we refer to one of the <span class="math">h_{i,j}</span> s. We may assume <span class="math">h_i</span> exists for every <span class="math">1 \\leq i \\leq w</span>, otherwise the respective <span class="math">f_i</span> can be ignored throughout the protocol.</p>

    <p class="text-gray-300">Let <span class="math">\\vec{h} = (h_1, \\dots, h_{\\mathsf{w}})</span> and <span class="math">\\vec{h&#x27;}&#x27; = (h_0&#x27;&#x27;, \\dots, h_{\\mathsf{a} - 1}&#x27;)</span>. By definition of <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{P}&#x27;</span>', <span class="math">\\vec{h} \\in \\mathcal{P}</span> and <span class="math">\\vec{h&#x27;}&#x27; \\in \\mathcal{P}&#x27;</span> (recall codewords of <span class="math">\\mathsf{RS}[\\mathbb{F}, \\mathsf{D}, \\rho^{+}]</span> are polynomials of degree <span class="math">\\leq 2^{\\mathsf{h}}</span>). As <span class="math">\\mathsf{state}(\\mathsf{tr}) = 0</span>, we know <span class="math">\\mathfrak{q}</span> does not satisfy Equation (22) (with <span class="math">\\vec{h}, \\vec{h&#x27;}&#x27;</span> substituting <span class="math">\\vec{\\mathsf{P}}, \\vec{\\mathsf{P}&#x27;}</span> respectively). On the other hand, we may assume the DEEP answer verification (Step 5 of the protocol) passes. This means that either <span class="math">h_i(\\mathfrak{q} \\cdot \\mathfrak{g}^j) \\neq \\alpha_{i,j}</span> for some <span class="math">(i,j) \\in \\mathsf{I}</span> or <span class="math">h_k(\\mathfrak{q}^{\\mathsf{a}}) \\neq \\beta_k</span> for some <span class="math">k \\in [\\mathsf{a}]</span>, contradicting Lemma 7. This proves the bound on <span class="math">\\varepsilon_3</span>.</p>

    <p class="text-gray-300">Bound on <span class="math">\\varepsilon_{i}</span> for <span class="math">4\\leq i\\leq \\mathsf{k} - 1</span>. Consider the analysis of Lemma 8.2 in [BCI+20]. In the analysis, <span class="math">r</span> "bad" events are defined, <span class="math">E^{(1)},\\ldots ,E^{(r)}</span> (definition 8.9) and we use these definitions here. The parameter <span class="math">r</span> is the number of rounds in the FRI protocol, and thus <span class="math">r + 4 = \\mathsf{k}</span>. Let <span class="math">\\mathbf{tr}</span> be a transcript up to Step <span class="math">i</span>. On input <span class="math">z^{(i)}</span>, we define <span class="math">\\mathrm{state}(\\mathrm{tr},z^{(i)})</span> to equal 1 if and only if <span class="math">E^{(i - 3)}</span> occurs. We stress that the event depends only on <span class="math">\\mathbf{tr}</span> and <span class="math">z^{(i)}</span>.</p>

    <p class="text-gray-300">The analysis of Lemma 8.2 in [BCI+20] gives us a bound on the probability of each of these events (and thus a bound on the state-restoration soundness error). For any <span class="math">0 \\leq \\ell \\leq r - 1</span>, it is shown that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_ {z ^ {(\\ell)}} [ E ^ {(\\ell + 1)} ] \\leq (t _ {\\ell} - 1) \\left(\\zeta^ {(\\ell)} + \\frac {2 m + 1}{\\sqrt {\\rho}} \\cdot \\frac {n + 1}{q}\\right),</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $t_\\ell = \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}^{(i + 1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> (the </span>\\ell<span class="math">-th coordinate of </span>\\vec{\\mathbf{t}}<span class="math">) and </span>\\zeta^{(\\ell)} = \\varepsilon_3\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}^{(i + 1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2}{n^2} = \\varepsilon_3\\prod_{j = 0}^{\\ell}\\frac{1}{t_j^2}$. Therefore, we get</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">STARKWARE Page 46</p>

    <p class="text-gray-300">that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr_{z^{(\\ell)}}[E^{(\\ell + 1)}] \\leq (t_{\\ell} - 1) \\left(\\varepsilon_3 \\prod_{j = 0}^{\\ell} \\frac{1}{t_j^2} + \\frac{2m + 1}{\\sqrt{\\rho}} \\cdot \\frac{n + 1}{q}\\right) \\\\ \\leq \\frac{\\varepsilon_3}{t_{\\ell}} \\cdot \\prod_{j = 0}^{\\ell - 1} \\frac{1}{t_j^2} + t_{\\ell} \\cdot \\frac{2m + 1}{\\sqrt{\\rho}} \\cdot \\frac{n + 1}{q}. \\end{array}</span></div>

    <p class="text-gray-300">By the above analysis, for <span class="math">4 \\leq i \\leq k - 1</span>, we conclude that</p>

    <div class="my-4 text-center"><span class="math-block">\\varepsilon_i = \\Pr_{z^{(i - 4)}}[E^{(i - 3)}] = \\frac{\\varepsilon_3}{t_{i - 4}} \\prod_{j = 0}^{i - 5} t_j^{-2} + \\frac{(2m + 1)(n + 1)t_{i - 4}}{q\\sqrt{\\rho}}.</span></div>

    <p class="text-gray-300">Bound on <span class="math">\\varepsilon_{\\mathbf{k}}</span>. In the QUERY phase (final round <span class="math">\\mathsf{k}</span>) the verifier samples <span class="math">s</span> random queries <span class="math">\\vec{Q} = Q_1, \\dots, Q_s</span>. On input <span class="math">\\vec{Q}</span>, we define <span class="math">\\text{state}(\\mathsf{tr}, x_1, \\dots, x_s)</span> to equal 1 if and only if all <span class="math">s</span> queries are successful. By the analysis in theorem 8.3 of [BCI+20], a single query is successful w.p. at most <span class="math">\\sqrt{\\rho} \\cdot \\left(1 + \\frac{1}{2m}\\right)</span>, and as the <span class="math">s</span> queries are independent the probability that all <span class="math">s</span> queries are successful is at most <span class="math">\\left(\\sqrt{\\rho} \\cdot \\left(1 + \\frac{1}{2m}\\right)\\right)^s</span>. This proves <span class="math">\\varepsilon_{\\mathbf{k}} = \\left(\\sqrt{\\rho} \\cdot \\left(1 + \\frac{1}{2m}\\right)\\right)^s</span>.</p>

    <h2 id="sec-72" class="text-2xl font-bold">6.3 Grinding</h2>

    <p class="text-gray-300">In this section, we describe an optimization technique which is called grinding. Grinding refers to the process of having the honest prover give a mildly-hard proof-of-work at the bottleneck part of the STARKs security (i.e., before the query phase of the protocol, but possibly in other places as well). The difficulty of the proof-of-work is captured by a grinding parameter <span class="math">z</span>. This effectively reduces the computation power of the cheating prover while only slightly increasing the running time of the honest prover. This is since the honest prover needs to solve the proof-of-work once, while a cheating prover, during the long process of trying to find a false proof, would need to solve many different instances of the proof-of-work.</p>

    <p class="text-gray-300">We match the grinding to our definition of vector round-by-round soundness. That is, instead of having a single grinding parameter <span class="math">z</span>, we have a vector of parameters <span class="math">z_1, \\ldots, z_k</span> that define the hardness of the proof-of-work for all <span class="math">k</span> rounds of the IOP. This grinding can be incorporated into the IOP protocol, and its round-by-round soundness analysis is a black-box manner.</p>

    <p class="text-gray-300">Given a <span class="math">k</span>-round IOP <span class="math">(\\mathsf{P}, \\mathsf{V})</span> and with grinding parameters <span class="math">(z_1, \\ldots, z_k)</span>, we define a corresponding grinded IOP <span class="math">(\\mathsf{P}&#x27;, \\mathsf{V}&#x27;)</span>. In each round <span class="math">i \\in [k]</span>, the prover <span class="math">\\mathsf{P}&#x27;</span> sends an additional message <span class="math">\\mathsf{pow}_i</span> and the verifier <span class="math">\\mathsf{V}&#x27;</span> sends an additional random string <span class="math">r \\in \\{0, 1\\}^{z_i}</span> (if <span class="math">z_i = 0</span> then no additional strings is sent). Finally, the new verifier <span class="math">\\mathsf{V}&#x27;</span> accepts if and only if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The original verifier <span class="math">\\mathsf{V}</span> accepts; and</li>

      <li>For all <span class="math">i \\in [\\mathsf{k}]</span>: <span class="math">r_i = 0^{z_i}</span> (or <span class="math">z_i = 0</span>).</li>

    </ol>

    <p class="text-gray-300">(Note that <span class="math">\\mathsf{pow}_i</span> is ignored by the verifier, and only serves a purpose for completeness in the compiled SNARG) We relate the round-by-round soundness of the original IOP and the grinded IOP in the following theorem:</p>

    <p class="text-gray-300">Theorem 6. Let <span class="math">(\\mathsf{P},\\mathsf{V})</span> be a <span class="math">k</span>-round IOP with round-by-round soundness <span class="math">(\\varepsilon_1,\\ldots ,\\varepsilon_k)</span>. Then, for any grinding parameters <span class="math">(z_{1},\\dots,z_{k})</span>, the corresponding grinded IOP <span class="math">(\\mathsf{P},\\mathsf{V}^{\\prime})</span> has round-by-round soundness <span class="math">(\\varepsilon_{1}\\cdot 2^{-z_{1}},\\ldots ,\\varepsilon_{k}\\cdot 2^{-z_{k}})</span>.</p>

    <p class="text-gray-300">STARKWARE Page 47</p>

    <p class="text-gray-300">Proof. Let state be the state function of the original IOP. We define the new state function for <span class="math">(\\mathsf{P}&#x27;,\\mathsf{V}&#x27;)</span> as follows. For any round <span class="math">i\\in[\\mathsf{k}]</span>, we define</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {s t a t e} ^ {\\prime} (\\mathbf {x}, \\operatorname {t r}, \\sigma \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r) = 1 \\iff \\operatorname {s t a t e} (\\mathbf {x}, \\operatorname {t r}, \\sigma) = 1 \\wedge r = 0 ^ {z _ {i}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Above, for simplicity of notation, we assume that if <span class="math">z_{i} = 0</span> then it always holds that <span class="math">r = 0^{z_i}</span>. From the round-by-round soundness of the original protocol, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_ {\\sigma} [ \\text {s t a t e} (\\mathbf {x}, \\operatorname {t r}, \\sigma) = 1 ] \\leq \\varepsilon_ {i}.</span></div>

    <p class="text-gray-300">Moreover, we know that <span class="math">\\operatorname{Pr}_{r\\in \\{0,1\\}^{z_i}}[r = 0^{z_i}] = 2^{-z_i}</span>. Since the event that <span class="math">r = 0^{z_i}</span> is independent of the event that <span class="math">\\mathsf{state}(\\mathbf{x},\\mathsf{tr},\\sigma) = 1</span>, we can conclude that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\Pr_ {\\sigma , r \\in \\{0, 1 \\} ^ {z _ {i}}} [ \\text {s t a t e} ^ {\\prime} (\\mathbf {x}, \\operatorname {t r}, \\sigma \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r) = 1 ] \\\\ \\leq \\Pr_ {\\sigma} [ \\text {s t a t e} (\\mathbf {x}, \\operatorname {t r}, \\sigma) = 1 ] \\cdot \\Pr_ {r \\in \\{0, 1 \\} ^ {z _ {i}}} [ r = 0 ^ {z _ {i}} ] \\\\ \\leq \\varepsilon_ {i} \\cdot 2 ^ {- z _ {i}}. \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Completeness. We note that the resulting grinded IOP has poor completeness, even if the underlying IOP had perfect completeness. The honest prover will succeed only if for all <span class="math">i \\in [\\mathsf{k}]</span>: <span class="math">r_i = 0^{z_i}</span> (or <span class="math">z_i = 0</span>). Thus, its success probability is at most <span class="math">2^{-(z_1 + \\dots + z_k)}</span>. While this seems problematic for the interactive case, this is not an issue after compiling the IOP to be non-interactive. For each round <span class="math">i</span>, the honest prover enumerates over different values of <span class="math">\\mathsf{pow}_i</span>, each time getting a fresh random string <span class="math">r_i</span> from the random oracle until it gets <span class="math">r_i = 0^{z_i}</span>. The expected running time of the honest prover for the non-interactive version is <span class="math">\\mathbb{E}[T&#x27;] = T + 2^{z_1} + \\dots + 2^{z_k}</span>, where <span class="math">T</span> is the running time of the original prover. This gives a tradeoff between the security of the system and the running time of the honest prover. As we set the values of <span class="math">z_1, \\ldots, z_k</span> to be higher, we gain in security (i.e., in round-by-round soundness) but pay in the running time of the prover.</p>

    <p class="text-gray-300">We have established bounds for the round-by-round soundness (and state-restoration soundness) of the protocol. This enables us to apply the BSC transformation [BCS16] and derive concrete bounds for the STARK. We begin with a formal definition of a STARK, that is, a succinct non-interactive argument in the random oracle model.</p>

    <p class="text-gray-300">A non-interactive random-oracle argument system for a relation <span class="math">R</span> with soundness <span class="math">\\epsilon</span> is a tuple <span class="math">(P, V)</span>, where <span class="math">P, V</span> are (oracle) probabilistic algorithms that satisfy the following properties.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For every <span class="math">(\\mathbf{x}, \\mathbf{w}) \\in R</span> and <span class="math">\\kappa \\in \\mathbb{N}</span>,</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ V ^ {f} (\\mathbf {x}, \\pi) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} f \\leftarrow \\mathcal {U} (\\kappa) \\\\ \\pi \\leftarrow \\mathsf {P} ^ {f} (\\mathbf {x}, \\mathbf {w}) \\end{array} \\right. \\right] = 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Adaptive soundness. For every <span class="math">T</span>-query cheating prover <span class="math">\\tilde{P}</span>, and <span class="math">\\kappa \\in \\mathbb{N}</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathbf {x} \\notin L (R) &amp;amp; f \\leftarrow \\mathcal {U} (\\kappa) \\\\ \\wedge V ^ {f} (\\mathbf {x}, \\pi) = 1 &amp;amp; (\\mathbf {x}, \\pi) \\leftarrow \\tilde {P} ^ {f} \\end{array} \\right] \\leq \\epsilon (T, \\kappa).</span></div>

    <p class="text-gray-300">STARKWARE</p>

    <p class="text-gray-300">.</p>

    <h4 id="sec-75" class="text-lg font-semibold mt-6">Complexity measures.</h4>

    <p class="text-gray-300">Beyond soundness error, we consider other complexity measures. Given <span class="math">p\\colon\\{0,1\\}^{<em>}\\to\\mathbb{N}</span>, we say that <span class="math">(P,V)</span> has proof length <span class="math">p</span> if <span class="math">\\pi</span> has length <span class="math">p(\\mathtt{x},\\kappa)</span>. Given <span class="math">\\mathtt{pt},\\mathtt{vt}\\colon\\{0,1\\}^{</em>}\\to\\mathbb{N}</span>, we say that <span class="math">(P,V)</span> has prover time complexity <span class="math">\\mathtt{pt}</span> and verifier time complexity <span class="math">\\mathtt{vt}</span> if <span class="math">P^{f}(\\mathtt{x},\\mathtt{w})</span> runs in time <span class="math">\\mathtt{pt}(\\mathtt{x},\\kappa)</span> and <span class="math">V^{f}(\\mathtt{x},\\pi)</span> runs in time <span class="math">\\mathtt{vt}(\\mathtt{x},\\kappa)</span>. In sum, we say that <span class="math">(P,V)</span> has complexity <span class="math">(s,p,\\mathtt{pt},\\mathtt{vt})</span> if <span class="math">(P,V)</span> has soundness error <span class="math">s</span>, proof length <span class="math">p</span>, prover time complexity <span class="math">\\mathtt{pt}</span>, and verifier time complexity <span class="math">\\mathtt{vt}</span>.</p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Definition 9 (Bits of security).</h6>

    <p class="text-gray-300">We say that a non-interactive random-oracle argument with soundness error <span class="math">\\epsilon(T,\\kappa)</span> relative to a random oracle <span class="math">f\\leftarrow\\mathcal{U}(\\kappa)</span> has <span class="math">\\kappa</span> bits of security if for any <span class="math">T\\in\\mathbb{N}</span>, it holds that</p>

    <p class="text-gray-300"><span class="math">\\frac{T}{\\epsilon(T,\\kappa)}\\geq 2^{\\kappa}\\enspace.</span></p>

    <p class="text-gray-300">The BCS transformation is used to compile IOPs to STARKs in the random oracle model (or heuristically based on a suitable cryptographic hash function). However, in order for the transformation to be sound, it is not sufficient to merely bound the soundness error of the IOP, but one needs to show a stronger property called state restoration soundness. It is easy to deduce a bound on the state-restoration soundness of an IOP from its round-by-round soundness error.</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Claim 1.</h6>

    <p class="text-gray-300">If an IOP has round-by-round soundness <span class="math">(\\varepsilon_{1},\\ldots,\\varepsilon_{\\mathsf{k}})</span>, then for every <span class="math">T\\in\\mathbb{N}</span> it has state-restoration soundness <span class="math">s(T)\\leq T\\cdot\\max_{i}\\{\\varepsilon_{i}\\}</span>.</p>

    <p class="text-gray-300">The BCS compiler <em>[x1]</em> relates the state-restoration soundness of the IOP to the soundness error of the compiled non-interactive scheme. We note that in <em>[x1]</em> only non-adaptive soundness was considered. However, by careful observation, the same theorem holds for adaptive soundness as well. In particular, we have the following:</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Theorem 7 (Theorem 7.1 in <em>[x1]</em>).</h6>

    <p class="text-gray-300">For every relation <span class="math">R</span> if <span class="math">\\mathsf{IOP}</span> is a public-coin interactive oracle proof system for <span class="math">R</span> with state-restoration soundness <span class="math">s(\\cdot)</span> then the BCS compiled non-interactive random-oracle proof system for <span class="math">R</span> has (adaptive) soundness error <span class="math">\\epsilon(\\cdot)</span> such that for any query bound <span class="math">T\\in\\mathbb{N}</span>:</p>

    <p class="text-gray-300"><span class="math">\\epsilon(T)\\leq s(T)+3\\cdot\\frac{T^{2}+1}{2^{\\kappa}}\\enspace.</span></p>

    <p class="text-gray-300">By combining the compiler of Theorem 7 together with Claim 1 and Theorem 6 we get the following:</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Theorem 8.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{IOP}</span> be a <span class="math">\\mathsf{k}</span>-round IOP for the relation <span class="math">R</span> with vector round-by-round soundness <span class="math">(\\varepsilon_{1},\\ldots,\\varepsilon_{\\mathsf{k}})</span>. Then, for any grinding parameters <span class="math">(z_{1},\\ldots,z_{\\mathsf{k}})</span>, the BCS compiled non-interactive random-oracle proof system applied to the grinded version of the IOP has (adaptive) soundness error <span class="math">\\epsilon(\\cdot,\\cdot)</span> such that for any query bound <span class="math">T\\in\\mathbb{N}</span>:</p>

    <p class="text-gray-300"><span class="math">\\epsilon(T,\\kappa)\\leq T\\cdot\\max_{i}\\{\\varepsilon_{i}\\cdot 2^{-z_{i}}\\}+3\\cdot\\frac{T^{2}+1}{2^{\\kappa}}\\enspace.</span></p>

    <p class="text-gray-300">The theorem above can be used to obtain <span class="math">\\lambda</span> bits of security for a desired security parameter <span class="math">\\lambda</span>.</p>

    <h6 id="sec-80" class="text-base font-medium mt-4">Corollary 3.</h6>

    <p class="text-gray-300">We obtain <span class="math">\\lambda</span> bits of security when</p>

    <p class="text-gray-300">######</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\max_{i}\\{\\varepsilon_{i}\\cdot 2^{-z_{i}}\\} \\leq 2^{-(\\lambda +1)}</span>; and</li>

      <li><span class="math">\\kappa \\geq 2\\lambda +3</span></li>

    </ol>

    <p class="text-gray-300">Proof. Indeed, in this case (recalling that <span class="math">T \\leq 2^{\\lambda}</span>) we get that:</p>

    <div class="my-4 text-center"><span class="math-block">\\epsilon (T, \\kappa) \\leq T \\cdot 2 ^ {- (\\lambda + 1)} + \\frac {T}{2 ^ {\\lambda + 1}}.</span></div>

    <p class="text-gray-300">Thus, we derive the bound</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {T}{\\epsilon (T , \\kappa)} \\geq \\frac {T}{T \\cdot 2 ^ {- (\\lambda + 1)} + \\frac {T}{2 ^ {\\lambda + 1}}} = 2 ^ {\\lambda}</span></div>

    <p class="text-gray-300">□</p>

    <h2 id="sec-81" class="text-2xl font-bold">7.1.1 Suggested Parameter based on Provable Soundness</h2>

    <p class="text-gray-300">We plug-in the round-by-round analysis to obtain concrete parameters for the STARK construction using Corollary 3. We always set <span class="math">\\kappa = 2\\lambda + 3</span>. This leaves us to bound <span class="math">\\max \\{\\varepsilon_1, \\ldots, \\varepsilon_{k-1}, \\varepsilon_k \\cdot 2^{-z_k}\\}</span>, where <span class="math">\\varepsilon_i</span> is the round-by-round soundness error of round <span class="math">i</span>. Namely, using Theorem 5 we have</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2 ^ {- (\\lambda + 1)} \\geq \\max  \\left\\{\\frac {\\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, \\frac {\\left(\\mathrm {d} _ {\\max } + 2 ^ {\\mathrm {h}} + \\mathrm {a}\\right) \\cdot \\ell^ {2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (\\mathrm {a} \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm {D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm {H} _ {0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}, \\frac {(m + \\frac {1}{2}) ^ {7} \\cdot n ^ {2}}{3 \\rho^ {3 / 2} \\cdot q}, \\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\left. \\left\\{\\frac {\\varepsilon_ {3}}{t _ {i - 4}} \\prod_ {j = 0} ^ {i - 5} t _ {j} ^ {- 2} + \\frac {(2 m + 1) (n + 1) t _ {i - 4}}{q \\sqrt {\\rho}} \\right\\} _ {i = 4 \\dots k - 1}, \\right. \\\\ \\left. \\left(\\sqrt {\\rho} \\cdot \\left(1 + \\frac {1}{2 m}\\right)\\right) ^ {s} \\right\\} \\end{array} $$</p>

    <p class="text-gray-300">where the parameters above are defined as in Theorem 5.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For simplicity we shall fix the extension degree to <span class="math">\\mathsf{e} = 3</span> so $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; 2^{183}<span class="math"> and the rate to </span>\\rho = 1/4<span class="math">. Fix </span>m = 3<span class="math"> so that we have </span>\\ell = \\frac{m}{\\rho - \\frac{2m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}} \\leq 2^4<span class="math"> (for </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 100<span class="math"> which holds in our case). In the ethSTARK statement referring to 98,304 invocations of the Rescue hash we have </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{\\mathsf{h}}<span class="math"> for </span>\\mathsf{h} = 20<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ \\rho = 2^{22}<span class="math">. We also have </span>\\mathsf{d}_{\\max} = 2^{22}<span class="math"> and </span>\\mathsf{a} = 4<span class="math">. We notice that in the FRI protocol </span>\\sum_{i} t_i \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{20}<span class="math">. We begin by bounding each </span>\\varepsilon_i$ separately.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. $\\varepsilon_{1} = \\frac{\\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\leq \\frac{2^{4}}{2^{183}} = 2^{-179}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\varepsilon_{3} = \\frac{(m + \\frac{1}{2})^{7}\\cdot n^{2}}{3\\rho^{3 / 2}\\cdot q}\\leq \\frac{(3 + \\frac{1}{2})^{7}\\cdot 2^{44}}{3(1 / 4)^{3 / 2}\\cdot 2^{183}}\\leq \\frac{2^{56}}{2^{181}} = 2^{-125}</span></li>

      <li>For any <span class="math">4 \\leq i \\leq k - 1</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\varepsilon_ {i} = \\frac {\\varepsilon_ {3}}{t _ {i - 4}} \\prod_ {j = 0} ^ {i - 5} t _ {j} ^ {- 2} + \\frac {(2 m + 1) (n + 1) t _ {i - 4}}{q \\sqrt {\\rho}} \\leq \\frac {\\varepsilon_ {3}}{2} + \\frac {(6 + 1) (2 ^ {2 2} + 1) \\cdot 2 ^ {2 0}}{2 ^ {1 8 3} \\cdot 1 / 2} \\leq 2 ^ {- 1 2 6} + \\frac {2 ^ {4 5}}{2 ^ {1 8 2}} \\leq 2 ^ {- 1 2 5}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\varepsilon_{\\mathsf{k}} = \\left(\\sqrt{\\rho}\\cdot \\left(1 + \\frac{1}{2m}\\right)\\right)^{s}\\leq \\left(1 / 2\\cdot \\left(1 + \\frac{1}{6}\\right)\\right)^{s} = \\left(\\frac{7}{12}\\right)^{s}.</span></li>

    </ol>

    <p class="text-gray-300">STARKWARE Page 50</p>

    <p class="text-gray-300">This lets us derive concrete settings of parameters depending on the value of <span class="math">\\lambda</span>. Assume that by default <span class="math">z_{i}=0</span> for all <span class="math">i\\in[\\mathsf{k}]</span> unless stated differently.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">\\lambda=80</span> bits of security we use <span class="math">s=79</span> invocations, and grinding parameter <span class="math">z_{\\mathsf{k}}=20</span>.</li>

      <li>For <span class="math">\\lambda=100</span> bits of security we use <span class="math">s=105</span> invocations, and grinding parameter <span class="math">z_{\\mathsf{k}}=20</span>.</li>

      <li>For <span class="math">\\lambda=128</span> bits of security we use <span class="math">s=141</span> invocations, and grinding parameter <span class="math">z_{i}=4</span> for all <span class="math">3\\leq i\\leq\\varepsilon-1</span>, and <span class="math">z_{\\mathsf{k}}=20</span>.</li>

    </ol>

    <h2 id="sec-82" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AAB^{+}19] Abdelrahaman Aly, Tomer Ashur, Eli Ben-Sasson, Siemen Dhooghe, and Alan Szepieniec. Efficient symmetric primitives for advanced cryptographic protocols (A marvellous contribution). IACR Cryptology ePrint Archive, 2019:426, 2019.</li>

      <li>[BBGR16] Eli Ben-Sasson, Iddo Bentov, Ariel Gabizon, and Michael Riabzev. A security analysis of probabilistically checkable proofs. Electron. Colloquium Comput. Complex., 23:149, 2016.</li>

      <li>[BBHR18] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Fast reed-solomon interactive oracle proofs of proximity. In Ioannis Chatzigiannakis, Christos Kaklamanis, Dániel Marx, and Donald Sannella, editors, 45th International Colloquium on Automata, Languages, and Programming, ICALP 2018, July 9-13, 2018, Prague, Czech Republic, volume 107 of LIPIcs, pages 14:1–14:17. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2018.</li>

      <li>[BBHR19] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable zero knowledge with no trusted setup. In Proceedings of the 39th Annual International Cryptology Conference, CRYPTO ’19, pages 733–764, 2019.</li>

      <li>[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for SNARKS and proof-carrying data. In Dan Boneh, Tim Roughgarden, and Joan Feigenbaum, editors, Symposium on Theory of Computing Conference, STOC’13, Palo Alto, CA, USA, June 1-4, 2013, pages 111–120. ACM, 2013.</li>

      <li>[BCG^{+}19] Eli Ben-Sasson, Alessandro Chiesa, Lior Goldberg, Tom Gur, Michael Riabzev, and Nicholas Spooner. Linear-size constant-query iops for delegating computation. In Dennis Hofheinz and Alon Rosen, editors, Theory of Cryptography - 17th International Conference, TCC 2019, Nuremberg, Germany, December 1-5, 2019, Proceedings, Part II, volume 11892 of Lecture Notes in Computer Science, pages 494–521. Springer, 2019.</li>

      <li>[BCI^{+}20] Eli Ben-Sasson, Dan Carmon, Yuval Ishai, Swastik Kopparty, and Shubhangi Saraf. Proximity gaps for reed-solomon codes. In 61st IEEE Annual Symposium on Foundations of Computer Science, FOCS 2020, Durham, NC, USA, November 16-19, 2020, pages 900–909, 2020.</li>

      <li>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Proceedings of the 14th Theory of Cryptography Conference, TCC ’16-B, pages 31–60, 2016.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[BGK^{+}23] Alexander R. Block, Albert Garreta, Jonathan Katz, Justin Thaler, Pratyush Ranjan Tiwari, and Michał Zając. Fiat-shamir security of fri and related snarks. Cryptology ePrint Archive, Paper 2023/1071, 2023. https://eprint.iacr.org/2023/1071.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BGKS20] Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. DEEP-FRI: sampling outside the box improves soundness. In Thomas Vidick, editor, 11th Innovations in Theoretical Computer Science Conference, ITCS 2020, January 12-14, 2020, Seattle, Washington, USA, volume 151 of LIPIcs, pages 5:1–5:32. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2020.</li>

      <li>[BKS18] Eli Ben-Sasson, Swastik Kopparty, and Shubhangi Saraf. Worst-case to average case reductions for the distance to a code. In Rocco A. Servedio, editor, 33rd Computational Complexity Conference, CCC 2018, June 22-24, 2018, San Diego, CA, USA, volume 102 of LIPIcs, pages 24:1–24:23. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2018.</li>

      <li>[CCH^{+}18] Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N. Rothblum, and Ron D. Rothblum. Fiat-shamir from simpler assumptions. Cryptology ePrint Archive, Report 2018/1004, 2018. https://eprint.iacr.org/2018/1004.</li>

      <li>[CMS19] Alessandro Chiesa, Peter Manohar, and Nicholas Spooner. Succinct arguments in the quantum random oracle model. In Dennis Hofheinz and Alon Rosen, editors, Theory of Cryptography - 17th International Conference, TCC 2019, Nuremberg, Germany, December 1-5, 2019, Proceedings, Part II, volume 11892 of Lecture Notes in Computer Science, pages 1–29. Springer, 2019.</li>

      <li>[GMR89] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. SIAM Journal on Computing, 18(1):186–208, 1989. Preliminary version appeared in STOC ’85.</li>

      <li>[GS99] Venkatesan Guruswami and Madhu Sudan. Improved decoding of reed-solomon and algebraic-geometry codes. IEEE Trans. Information Theory, 45(6):1757–1767, 1999.</li>

      <li>[Gur07] Venkatesan Guruswami. Algorithmic results in list decoding. Foundations and Trends® in Theoretical Computer Science, 2(2):107–195, 2007.</li>

      <li>[Mic00] Silvio Micali. Computationally sound proofs. SIAM Journal on Computing, 30(4):1253–1298, 2000. Preliminary version appeared in FOCS ’94.</li>

      <li>[RRR16] Omer Reingold, Ron Rothblum, and Guy Rothblum. Constant-round interactive proofs for delegating computation. In Proceedings of the 48th ACM Symposium on the Theory of Computing, STOC ’16, pages 49–62, 2016.</li>

      <li>[Val08] Paul Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In Ran Canetti, editor, Theory of Cryptography, pages 1–18, Berlin, Heidelberg, 2008. Springer Berlin Heidelberg.</li>

    </ul>`;
---

<BaseLayout title="ethSTARK Documentation (2021/582)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/582
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
