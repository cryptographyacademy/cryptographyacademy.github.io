---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/1048';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Proof-of-Work Sidechains';
const AUTHORS_HTML = 'Aggelos Kiayias, Dionysis Zindros';

const CONTENT = `    <p class="text-gray-300">Aggelos Kiayias [ University of Edinburgh and IOHK ] Dionysis Zindros [ National and Kapodistrian University of Athens and IOHK ]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">During the last decade, the blockchain space has exploded with a plethora of new cryptocurrencies, covering a wide array of different features, performance and security characteristics. Nevertheless, each of these coins functions in a stand-alone manner, independently. Sidechains have been envisioned as a mechanism to allow blockchains to communicate with one another and, among other applications, allow the transfer of value from one chain to another, but so far there have been no decentralized constructions. In this paper, we put forth the first sidechains construction that allows communication between proof-of-work blockchains without trusted intermediaries. Our construction is generic in that it allows the passing of any information between blockchains. It gives rise to two illustrative examples: the “remote ICO,” in which an investor pays in currency on one blockchain to receive tokens in another, and the “two-way peg,” in which an asset can be transferred from one chain to another and back. We pinpoint the features needed for two chains to communicate: On the source side, a proof-of-work blockchain that has been interlinked, potentially with a velvet fork; on the destination side, a blockchain with any consensus mechanism that has sufficient expressibility to implement verification. We model our construction mathematically and give a formal proof of security. In the heart of our construction, we use a recently introduced cryptographic primitive, Non-Interactive Proofs of Proof-of-Work (NIPoPoWs). Our security proof uses a standard reduction from our new proof-of-work sidechains protocol to the security of NIPoPoWs, which has, in turn, been shown to be secure in previous work. Our working assumption is honest majority in each of the communicating chains. We demonstrate the feasibility of our construction by providing a pseudocode implementation in the form of a Solidity smart contract.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Bitcoin <em>[x14]</em> is the first and most successful cryptocurrency to date. Its core protocol introduced the concept of a blockchain, a type of cryptographic consensus protocol in which transactions are organized into blocks which are then put in a mutually agreed sequence despite the presence of adversarial nodes. Consensus is achieved via a proof-of-work <em>[x5]</em></p>

    <p class="text-gray-300">which is the precondition for a block to be valid. Transactions moving value within such blockchains have been proven to be secure in that consensus is eventually achieved, cf. <em>[x13, x25, x14]</em>, thus providing a way for reaching consensus in a setting where neither reliable point-to-point channels exists nor a public-key infrastructure.</p>

    <p class="text-gray-300">Ethereum <em>[B^{+}14]</em> extends Bitcoin’s functionality introducing the ability to write arbitrary Turing-complete <em>smart contracts</em> in programming languages such as Solidity running on top of the Ethereum Virtual Machine <em>[x31]</em>. These contracts execute autonomously. The smart contracts are confined to access data only within the blockchain itself, such as previous transactions and blocks. Access to external world data requires some trusted third party or group of third parties to vouch for the validity of the data <em>[ZCC^{+}16]</em>.</p>

    <p class="text-gray-300">Sidechains <em>[BCD^{+}14]</em> are a mechanism for cross-chain communication in blockchains. They allow the smart contracts on one blockchain to receive and react to <em>events</em> that take place on another blockchain without the need of a trusted third party. Despite the widely agreed usefulness of the primitive there exist no constructions that are decentralised and efficient at the same time.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Our contributions.</h4>

    <p class="text-gray-300">In this paper, we introduce the first trustless construction for proof-of-work sidechains. We describe how to build generic communication between blockchains. As one application, we give the construction of a <em>two-way pegged</em> asset which can be moved from one blockchain to another while retaining its nature. We provide a high-level construction in Solidity. Our construction works across a broad range of blockchains requiring only two underlying properties. First, that the <em>source</em> blockchain is a proof-of-work blockchain supporting Non-Interactive Proofs of Proof-of-Work (NIPoPoWs), a cryptographic primitive which allows constructing succinct proofs <em>about</em> events which occur in a proof-of-work blockchain and which was recently introduced in <em>[x17]</em>. Support for NIPoPoWs can be introduced to practically any work-based cryptocurrency such as Bitcoin, Ethereum, Bitcoin Cash, Litecoin or Monero without a hard or soft fork. Second, that the <em>target</em> blockchain is able to validate such proofs by, for instance, being Turing-complete, such as, e.g., Ethereum or Ethereum Classic. Any blockchain supporting advanced smart contracts is sufficient. In the appendix, we give a formal proof of security of our construction via reduction to NiPoPoW security under the assumption that the interoperating blockchains are secure individually. To our knowledge, we are the first to provide such a construction in full and prove its security.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Related work.</h4>

    <p class="text-gray-300">Sidechains were introduced as a Bitcoin upgrade mechanism by Back et al. <em>[BCD^{+}14]</em>. They proposed introducing a new <em>child</em> blockchain which implements a new protocol version, with which assets are <em>2-way pegged</em>. The <em>firewall</em> property was articulated. No security definitions nor a complete construction of the protocol were given. Their paper hints at the need for “<em>efficient SPV proofs</em>” (Appendix B) in future work, which we implemented here. We use the term <em>sidechains</em> in a more general notion than in their work. Our sidechains allow communication between <em>stand alone</em> blockchains and also convey <em>any</em> information, not just transfers of value. In our work, a blockchain is a sidechain of another chain if it can react to events on that chain, and so the relationship can be symmetric.</p>

    <p class="text-gray-300"><em>Polkadot</em> <em>[x20]</em>, <em>Tendermint</em>, <em>Cosmos</em> <em>[x1]</em>, <em>Liquid</em> and <em>Interledger</em> <em>[x12]</em> also build cross-chain transfers. Their validation relies on a trusted committees, federations or is left unspecified. <em>Drivechains</em> are a sidechain proposal which requires miners of both chains to be aware of both networks. In our scheme, miners remain agnostic to the existence of other chains and connect only to one network. <em>BTCRelay</em> is a trustless mechanism relaying information one-way from Bitcoin to Ethereum, in which miners are connected to their network only. BTCRelay requires the transmission of the entirety of the source blockchain headers into the target blockchain. Our proposal only requires data logarithmic in size of the source blockchain. This stems from the <em>succinctness</em> property of the NIPoPoW scheme. None of the aforementioned constructions include proofs of security. Other related work includes Plasma <em>[x21]</em>, XCLAIM <em>[ZHL^{+}]</em>, PeaceRelay, COMIT <em>[x16]</em>, and NOCUST <em>[x15]</em> and Dogethereum.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2 Overview</h2>

    <p class="text-gray-300">We wish to transfer assets from one blockchain to another and then back. When assets can be transferred from one blockchain to another but not back, we call it a <em>one-way peg</em>. If assets can also be moved back, we call it a <em>two-way peg</em>. In each individual transfer of an asset, we have a particular <em>source blockchain</em>, from which the asset is moved, and a particular <em>target blockchain</em>, to which the asset is moved. In a sidechain setting of two blockchains that are two-way pegged, both blockchains can function as a source and a target blockchain for different transfers.</p>

    <p class="text-gray-300">While the motivation for the construction is to be able to move assets from one blockchain to another, we generalize the notion of sidechains from this strict setting. In general, we would like the target blockchain</p>

    <p class="text-gray-300">to be able to react to any event that occurs on the source blockchain. Such events can be the fact that a transaction with a particular TXID took place, that a certain account was paid a certain amount of money, or that a particular smart contract was instantiated. Our sidechain construction allows the target blockchain to react to events that took place on the source blockchain. This reaction can be implemented in its target blockchain smart contracts. We describe our construction in pseudocode similar to Ethereum' Solidity. In Solidity, events can be fired arbitrarily from within a smart contract and do not have a semantic interpretation. In this setting, events are defined by Solidity using the event type and have an event name, a contract address which fired them, as well as certain parameter values. A contract can elect to fire an event with any name and any parameters of its choice by invoking the EMIT command.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. Basic information transfer between two blockchains</p>

    <p class="text-gray-300">A high-level overview of cross-chain event transmission is shown in Figure 1. The process is as follows. First, an event is fired in the source blockchain, shown at the top. This could be any event that can be emitted using Ethereum's EMIT command. This event firing is caused by a certain transaction which is included at a certain block, indicated in black at the top. This block is then buried under  <span class="math">k_{1}</span>  subsequent blocks within the source blockchain, where the  <span class="math">k_{1}</span>  parameter is a security parameter of the scheme depending on the specific parameters of the source blockchain [GKL15]. As soon as this confirmation occurs, the target blockchain can react to the event, shown at the bottom. This reaction occurs in a transaction which is included in a block within the target blockchain, illustrated in white. As usual, the block needs to be confirmed by waiting for  <span class="math">k_{2}</span>  blocks to be mined on top of it. It is possible that  <span class="math">k_{1} \\neq k_{2}</span>  because of different blockchain parameters such as a difference in block generation time or network synchrony. In this figure, arrows between blocks of the</p>

    <p class="text-gray-300">same blockchain indicate authenticated ancestry. The arrow between the two blockchains indicates the data transfer needed for the event.</p>

    <p class="text-gray-300">Using this basic functionality of event information exchange between blockchains, we can construct two-way pegged sidechains. In such a construction, an asset that exists on one blockchain will gain the ability to be <em>moved</em> to a different blockchain and back. We will use the example of moving ether, the native asset of the Ethereum blockchain, from the Ethereum blockchain into the Ethereum Classic blockchain and back. Such an action is different from <em>exchanging</em> ether (ETH), the native token of the Ethereum blockchain, with ether classic (ETC), the native token of the Ethereum Classic blockchain. Instead, the asset retains its nature; it maintains its price and its ability to be used for the same purposes, while being governed by the rules of the new blockchain, such as different performance, fees, features, or security guarantees. Furthermore, no counterparty or market is required to perform the exchange; the transfer is something a party can do on its own.</p>

    <h2 id="sec-7" class="text-2xl font-bold">3 Construction</h2>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">Cross-chain certificates</h3>

    <p class="text-gray-300">For our construction, we use a primitive called Non-Interactive Proofs of Proof-of-Work recently introduced in <em>[x13]</em>. Non-Interactive Proofs of Proofs-of-Work are cryptographic protocols which implement a <em>prover</em> and a <em>verifier</em>. The prover is a <em>full node</em> on the <em>source blockchain</em>. The verifier does not have access to that blockchain, but knows its genesis block <span class="math">\\mathcal{G}</span>. The prover wants to convince the verifier that an <em>event</em> took place in the source blockchain; for instance, a smart contract method was called with certain parameters or that a payment was made into a particular address. Whether such an event took place can easily be determined if one inspects the whole blockchain. However, the prover wishes to convince the verifier by only sending a <em>succinct proof</em>, a short string which does not grow linearly with the size of the blockchain, but, rather, <em>polylogarithmically</em>. The verifier must not be fooled by <em>adversarial provers</em> who provide incorrect proofs claiming that an event happened while in fact it didn’t, or that it didn’t while in fact it did. To withstand such attacks, the verifier accepts multiple proofs, at least one of which is assumed to have been honestly generated (this assumption is necessary in standard blockchain protocols in general <em>[x12, x24]</em>). Comparing these proofs against each other, the verifier extracts a reliable truth value corresponding to the same value it would deduce if it were to be running a full node on</p>

    <p class="text-gray-300">the blockchain itself. This property is the <em>security</em> of NIPoPoWs proven in <em>[x13]</em>.</p>

    <p class="text-gray-300">The NIPoPoWs construction talks about <em>predicates</em> evaluated on blockchains, but we are interested in <em>events</em>. We can translate from events to predicates provable with NIPoPoWs. Specifically, given a genesis block <span class="math">\\mathcal{G}</span>, a smart contract address <span class="math">\\mathsf{addr}</span>, an event name <span class="math">\\mathsf{Event}</span>, and a series of event parameter values <span class="math">(\\mathsf{param}_{1},\\mathsf{param}_{2},\\cdots,\\mathsf{param}_{n})</span>, the predicate <span class="math">e</span> we wish to check for truth is the following: <em>Has the event named <span class="math">\\mathsf{Event}</span> been fired with parameters <span class="math">(\\mathsf{param}_{1},\\mathsf{param}_{2},\\cdots,\\mathsf{param}_{n})</span> by the smart contract residing in address <span class="math">\\mathsf{addr}</span> on the blockchain with genesis block <span class="math">\\mathcal{G}</span> at least <span class="math">k</span> blocks ago?</em> This predicate is (1) <em>monotonic</em>, meaning that it starts with the value <span class="math">\\mathsf{false}</span> and, if it ever becomes <span class="math">\\mathsf{true}</span>, it cannot ever change its value back as the blockchain grows; (2) <em>infix-sensitive</em>, meaning that its truth value can be deduced by inspecting a constant number of blocks on the blockchain (one block, within which the event firing was confirmed); and (3) <em>stable</em>, meaning that, if one party deduces that its value is <span class="math">\\mathsf{true}</span>, then soon enough <em>all</em> parties will deduce that its value is <span class="math">\\mathsf{true}</span>. This last property stems from the requirement that the event be buried under <span class="math">k</span> blocks ensuring a blockchain reorganization up to <span class="math">k</span> blocks ago cannot affect the predicate’s value.</p>

    <p class="text-gray-300">In order to determine whether an event took place, the NIPoPoW verifier function <span class="math">\\mathsf{verify}_{k,m}^{\\mathcal{G},e}(\\mathcal{P})</span> accepts the event description in the form of a blockchain predicate <span class="math">e</span>, which we gave above, the genesis block of the remote chain <span class="math">\\mathcal{G}</span>, as well as two security parameters <span class="math">k</span> and <span class="math">m</span>. These security parameters can be constants specified when the sidechain system is created (concrete values for these are given in <em>[x13]</em>). Subsequently, the NIPoPoW verifier accepts a set of <em>proofs</em> <span class="math">\\mathcal{P}=\\{\\pi_{1},\\pi_{2},\\cdots,\\pi_{n}\\}</span> which it compares and extracts a truth value for the predicate: Whether the event has taken place in the remote blockchain or not. As long as at least one <em>honestly generated</em> proof <span class="math">\\pi_{i}</span> is provided, the verifier’s security ensures that the output will correspond to whether the event actually occurred.</p>

    <p class="text-gray-300">Our protocol works as follows. Whenever an event of interest occurs on the source blockchain, the occurence of this event is observed by a source blockchain honest node, who generates a NIPoPoW about it. The target blockchain contains a smart contract with a method to accept and verify the veracity of this proof. The node can then submit the proof to the smart contract by broadcasting a transaction on the target blockchain. As soon as the proof is validated by the smart contract, the target blockchain can elect to react to the event as desired.</p>

    <p class="text-gray-300">Adoption considerations. Our construction has certain prerequisites for both the source and the target blockchain before it can be adopted. In the case of bidirectionally connected blockchains, both of them must satisfy the source and the target blockchain prerequisites.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The source blockchain needs to support <em>proofs</em> about it, which requires augmenting it with an <em>interlink</em> vector, the details of which can be found in <em>[x13]</em>. This interlink vector can be added to a blockchain using a <em>user-activated velvet fork</em> <em>[x12, ZSJ^{+}18]</em>, which is performed without miner awareness and does not require a hard or soft fork. However, only events occuring <em>after</em> the velvet fork can be proven. New blockchains can adopt this from genesis.</li>

      <li>The target blockchain needs to be able to run the above verify function. This function can be programmed in a Turing-complete language such as Solidity. If the source blockchain proof-of-work hash function is available as an opcode or pre-compiled smart contract within the target blockchain’s VM the way, e.g., Bitcoin’s SHA256 hash function is available in Solidity, the implementation can be more gas-efficient.</li>

    </ul>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Blockchain agnosticism.</h4>

    <p class="text-gray-300">We underline the remarkable property that miners and full nodes of the target blockchain do not need to be aware of the source blockchain at all. To them, all information about the source blockchain is simply a string which is passed as a parameter to a smart contract and can remain <em>agnostic</em> to its semantics as a proof. Additionally, miners and full nodes of the source blockchain do not need to be aware of the target blockchain. Only the parties interested in facilitating cross-chain events must be aware of both. Those untrusted facilitators need to maintain an SPV node on the source blockchain with which they generate their NIPoPoW. To broadcast their proof on the target blockchain, they connect to target blockchain nodes and send the transaction containing the NIPoPoW. Blockchain agnosticism allows users to initiate cross-chain relationships between different blockchains <em>dynamically</em>, as long as the blockchains in question satisfy the above prerequisites.</p>

    <p class="text-gray-300">Algorithm 1 The smart contract skeleton that enables checking cross-chain proofs about events. 1: contract crosschain <span class="math">k,m,z</span> 2: internal function initialize( <span class="math">\\mathcal{G}_{\\text{remote}}</span> ) 3:  <span class="math">\\mathcal{G} \\gets \\mathcal{G}_{\\text{remote}}</span> 4: end function 5: payable function submit-event-proof( <span class="math">\\pi, e</span> ) 6: if msg.value &lt; z then 7: return  <span class="math">\\perp</span> 8: end if 9: if events[e] =  <span class="math">\\perp \\wedge \\text{verify}_{k,m}^{e,G}(\\{\\pi\\})</span>  then 10: events[e] ← {expire: block.number + k, proof:  <span class="math">\\pi</span> , author: msg sender} 11: end if 12: end function 13: function finalize-event(e) 14: if events[e] =  <span class="math">\\perp \\vee \\text{block.number} &amp;lt; \\text{events}[e]</span> . expire then 15: return  <span class="math">\\perp</span> 16: end if 17: finalized-events ← finalized-events ∪ {e} 18: author ← events[e].author 19: events[e] ←  <span class="math">\\perp</span> 20: author.send(z) 21: end function 22: function submit-contesting-proof( <span class="math">\\pi^<em>, e</span> ) 23: if events[e] =  <span class="math">\\perp \\vee \\text{block.number} \\geq \\text{events}[e]</span> . expire then 24: return  <span class="math">\\perp</span> 25: end if 26: if ¬verify <span class="math">_{k,m}^{e,G}(\\{\\text{events}[e].\\text{proof}, \\pi^</em>\\})</span>  then 27: events[e] ←  <span class="math">\\perp</span> 28: msg sender.send(z) 29: end if 30: end function 31: function event-exists(e) 32: return e ∈ finalized-events 33: end function 34: end contract</p>

    <p class="text-gray-300">We give our crosschain construction in Algorithm 1. Initially, our communication will be unidirectional. In the next section, we use two unidirectional channels to establish bidirectional communication. This smart contract runs on the target blockchain and informs it about events that took place in the source blockchain. It is parameterized by three parameters:  <span class="math">k</span>  and  <span class="math">m</span>  are the underlying security parameters of the NIPoPoW protocol. The value  <span class="math">z</span>  is a collateral parameter, denominated in ether (or</p>

    <p class="text-gray-300">the native currency of the blockchain in which the execution takes place) and is used to incentivize honest participants to intervene in cases of false claims. The contract utilizes the NIPoPoW verify function parameterized by the event  <span class="math">e</span> , the remote genesis block  <span class="math">\\mathcal{G}</span>  and the security parameters  <span class="math">k</span>  and  <span class="math">m</span> . We do not give an explicit implementation of verify, as it can be implemented in a straightforward manner by translating the pseudocode listing of [KMZ17]. For our purposes, it suffices to treat it as a black box which, given a set of proofs, at least one of which is honestly generated, returns the truth value of the respective predicate.</p>

    <p class="text-gray-300">The contract allows detecting remote blockchain events can be inherited by other contracts that wish to adopt its functionality. It works as follows. First, the initialize method is called exactly once to configure the contract, passing the hash of the genesis block of the remote chain which this contract will handle. This method is internal and can only be called by the contract inheriting from it. Users of the contract can check it has been configured with the correct genesis block prior to using it. We note that, while our algorithm does not reflect this to keep complexity low, it is possible to have a contract interact with multiple remote chains by extending it to include multiple geneses.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2. A sequence diagram showing the actions of the untrusted SPV node when communicating with both blockchain networks and the lifecycle of an event submission</p>

    <p class="text-gray-300">The lifecycle of an event submission is illustrated in Figure 2. When an event has taken place in the source blockchain, any source blockchain SPV node, the author, can inform the crosschain contract about this fact by generating a NIPoPoW  <span class="math">\\pi</span>  claiming that the event took place based on their current view of the source blockchain. This proof can then be submitted to the target blockchain by calling the submit-event-proof function</p>

    <p class="text-gray-300">and passing it the proof  <span class="math">\\pi</span>  and the event predicate  <span class="math">e</span> . The submission is accompanied by a collateral payment  <span class="math">z</span> . If the author is honest, this collateral will be returned to her later. The submit-event-proof function runs the NIPoPoW verify algorithm to check that the proof  <span class="math">\\pi</span>  is well-formed and that it claims that the predicate is true. It then stores the proof for later use. It also stores the address of the author and an expiration block number.</p>

    <p class="text-gray-300">Upon submission of a proof to the submit-event-proof function, the event is tentatively accepted for a contestation period of  <span class="math">k</span>  blocks, during which any other party, the contester, can provide a counter-proof showing that the original proof was fraudulent. The contester can call the submit-contesting-proof function passing it the contesting proof  <span class="math">\\pi^<em></span>  and the event predicate  <span class="math">e</span> . The function runs the NIPoPoW verify algorithm to compare the original proof events[e].proof against the contesting proof  <span class="math">\\pi^</em></span> . If the verification algorithm concludes that the original proof was fraudulent, the tentatively accepted event is abandoned and the collateral is paid to the contester.</p>

    <p class="text-gray-300">Otherwise, when the contestation period has expired without any valid contestations, the author can call the finalize-event function. This function changes the acceptance of the event from tentative to permanent by including it in the finalized-events set and returns the collateral to the author. Finally, the event-exists function can be used by the inheriting contract to check if an event has been permanently accepted. The target blockchain state during this execution is shown in Figure 3. The source blockchain's event included in the black box, upon sufficient confirmation by  <span class="math">k_{1}</span>  blocks (not shown), is transmitted to the target blockchain at the bottom. The target blockchain includes the event tentatively in block 1 until a contestation period of  <span class="math">k_{2}</span>  has passed; the event is included permanently in block 2; subsequently, permanent inclusion needs to be confirmed with  <span class="math">k_{2}</span>  further blocks.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 3. The target blockchain state during event submission</p>

    <p class="text-gray-300">Two-way pegged sidechains</p>

    <p class="text-gray-300">Having created the generic crosschain contract, we now build two-way pegged sidechains on top. For concreteness, we use the example of transferring ether (ETH), the native currency of the Ethereum blockchain, to the Ethereum Classic blockchain, and back. We note that this example is arbitrary and for illustration. Our construction can be used between any work-based blockchains satisfying the prerequisites detailed above.</p>

    <p class="text-gray-300">When ether is moved to the Ethereum Classic blockchain, it will be represented as an ERC20 token within Ethereum Classic. Let this custom token be called ETH20. The asset retains its nature as it moves from one blockchain to another if it is always possible to move ETH into ETH20 and back at a one-to-one rate. The economic reason is that the price of ETH and ETH20 on the market will necessarily be the same. If the price of ETH were to ever be significantly above the price of ETH20 in the market, then a rational participant would exchange their ETH20 for ETH using sidechains and sell their ETH on the market instead, and vice versa. There can be a small discrepancy in the two prices which stems from two different factors: First, the fees needed for a cross-chain transfer; and second, the temporary market fluctuations that can occur during the limited time needed to perform the cross chain transfer (<span class="math">k_{1}+2k_{2}</span>). If we assume the price fluctuation (of ETH20 denominated in ETH) per unit of time is bounded, then the market price difference between ETH and ETH20 at any moment in time can be bounded by the sum of these two factors.</p>

    <p class="text-gray-300">The sidechain smart contracts are presented in Algorithm 2. These smart contracts both extend the crosschain smart contract of Algorithm 1. Furthermore, sidechain_{2} also inherits basic ERC20 functionality which allows token owners to transfer the token <em>[x20]</em>. The sidechain_{1} contract will be instantiated on Ethereum, while the sidechain_{2} contract will be instantiated on Ethereum Classic. Suppose the genesis block hash of Ethereum is <span class="math">\\mathcal{G}_{1}</span> and of Ethereum Classic is <span class="math">\\mathcal{G}_{2}</span>. We will use the genesis block hash of each blockchain as its unique identifier.</p>

    <p class="text-gray-300">The two smart contracts both contain an initialize method which accepts the hash of the remote blockchain as well as the address of the remote smart contract it will interface with. Note that, while the two genesis hashes can be hard-coded into the respective smart contract code itself, the remote contract address cannot be built-in as a constant into</p>

    <p class="text-gray-300">the smart contract, but must be later specified by calling the initialize function. The reason is that, if sidechain_{1} were to be created on <span class="math">\\mathcal{G}_{1}</span>, it would require the address of sidechain_{2} to exist prior to its creation, and vice versa in a circular dependency. Therefore, the two contracts must first be created on their respective blockchain to obtain addresses, and then their initialize methods can be called to inform each contract about the address of the other. Specifically, first the contract sidechain_{1} is created on <span class="math">\\mathcal{G}_{1}</span> to obtain its instance address which we also denote sidechain_{1}. Then the second contract, sidechain_{2} is created on <span class="math">\\mathcal{G}_{2}</span> to obtain its address sidechain_{2}. Then, the initialize function of sidechain_{1} is called, passing it <span class="math">\\mathcal{G}_{2}</span> and the address sidechain_{2}. Finally, initialize is called on sidechain_{2}, passing it <span class="math">\\mathcal{G}_{1}</span> and the address sidechain_{1}. These initialization parameters are stored by the respective smart contracts for future use. As the crosschain contract requires, the initialize method can only be called once. Any user wishing to utilize this sidechain is expected to validate that the contracts have been set up correctly and that initialize has been called with the appropriate parameters.</p>

    <p class="text-gray-300">sidechain_{1} contains a deposit function which is payable in the native asset of Ethereum, ETH. When a user pays ETH into the deposit function, the funds are held by the smart contract and can later be used to pay parties who wish to withdraw, an operation performed by calling the withdraw function. sidechain_{2} contains similar deposit and withdraw functions which, however, do not pay in the native currency of Ethereum Classic, but instead maintain a balance mapping akin to a typical ERC20 implementation. The balance is updated when a user deposits or withdraws.</p>

    <p class="text-gray-300">Moving funds from the Ethereum blockchain into the Ethereum Classic blockchain works as follows. First, the user pays with ETH to call the deposit function of sidechain_{1} which resides on <span class="math">\\mathcal{G}_{1}</span>, passing the target parameter which indicates their address in the Ethereum Classic blockchain that they wish to receive the money into. This call emits an event, Deposited_{1} which contains the necessary data: the target, the amount paid, as well as a nonce ctr to allow for future payments of the same amount to the same target. When the event has been emitted and buried under <span class="math">k_{1}</span> blocks within the Ethereum blockchain, the user produces an Ethereum NIPoPoW <span class="math">\\pi_{1}</span> about the predicate <span class="math">e_{1}</span> which claims that the event Deposited_{1} has been emitted in blockchain <span class="math">\\mathcal{G}_{1}</span> with the particular parameters by the contract at address sidechain_{1}.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">|  Algorithm 2 An asset transferring contract between G1 and G2  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  1: contract sidechain1 extends crosschaink,m,z  |   |</p>

    <p class="text-gray-300">|  2: initialized ← false; ctr ← 0  |   |</p>

    <p class="text-gray-300">|  3: function initialize(G2, sidechain2)  |   |</p>

    <p class="text-gray-300">|  4: if ¬initialized then  |   |</p>

    <p class="text-gray-300">|  5: crosschaininitialize(G2) ▷ Initialize with the remote chain genesis block  |   |</p>

    <p class="text-gray-300">|  6: initialized ← true  |   |</p>

    <p class="text-gray-300">|  7: this.sidechain2 ← sidechain2  |   |</p>

    <p class="text-gray-300">|  8: end if  |   |</p>

    <p class="text-gray-300">|  9: end function  |   |</p>

    <p class="text-gray-300">|  10: payable function deposit(target)  |   |</p>

    <p class="text-gray-300">|  11: ▷ Emit an event to be picked up by remote contract  |   |</p>

    <p class="text-gray-300">|  12: ctr += 1  |   |</p>

    <p class="text-gray-300">|  13: emit Deposited1(target, msg.value, ctr)  |   |</p>

    <p class="text-gray-300">|  14: end function  |   |</p>

    <p class="text-gray-300">|  15: function withdraw(amount, target, ctr)  |   |</p>

    <p class="text-gray-300">|  16: ▷ Validate that event took place on remote chain  |   |</p>

    <p class="text-gray-300">|  17: if ¬event-exists((sidechain2, Deposited2, (amount, target, ctr))) then  |   |</p>

    <p class="text-gray-300">|  18: return ⊥  |   |</p>

    <p class="text-gray-300">|  19: end if  |   |</p>

    <p class="text-gray-300">|  20: msg sender.send(amount)  |   |</p>

    <p class="text-gray-300">|  21: end function  |   |</p>

    <p class="text-gray-300">|  22: end contract  |   |</p>

    <p class="text-gray-300">|  23: contract sidechain2 extends crosschaink,m,z; ERC20  |   |</p>

    <p class="text-gray-300">|  24: mapping(address ⇒ int) balances  |   |</p>

    <p class="text-gray-300">|  25: initialized ← false; ctr ← 0  |   |</p>

    <p class="text-gray-300">|  26: function initialize(G1, sidechain1)  |   |</p>

    <p class="text-gray-300">|  27: if ¬initialized then  |   |</p>

    <p class="text-gray-300">|  28: crosschaininitialize(G1)  |   |</p>

    <p class="text-gray-300">|  29: initialized ← true  |   |</p>

    <p class="text-gray-300">|  30: this.sidechain1 ← sidechain1  |   |</p>

    <p class="text-gray-300">|  31: end if  |   |</p>

    <p class="text-gray-300">|  32: end function  |   |</p>

    <p class="text-gray-300">|  33: function deposit(target, amount)  |   |</p>

    <p class="text-gray-300">|  34: if balances[msg sender] < amount then  |   |</p>

    <p class="text-gray-300">|  35: return ⊥  |   |</p>

    <p class="text-gray-300">|  36: end if  |   |</p>

    <p class="text-gray-300">|  37: balances[msg sender] -= amount ▷ Charge account of sender  |   |</p>

    <p class="text-gray-300">|  38: ctr += 1  |   |</p>

    <p class="text-gray-300">|  39: emit Deposited2(target, amount, ctr)  |   |</p>

    <p class="text-gray-300">|  40: end function  |   |</p>

    <p class="text-gray-300">|  41: function withdraw(amount, target, ctr)  |   |</p>

    <p class="text-gray-300">|  42: if ¬event-exists((sidechain1, Deposited1, (amount, target, ctr))) then  |   |</p>

    <p class="text-gray-300">|  43: return ⊥  |   |</p>

    <p class="text-gray-300">|  44: end if  |   |</p>

    <p class="text-gray-300">|  45: balances[target] += amount ▷ Credit target account  |   |</p>

    <p class="text-gray-300">|  46: end function  |   |</p>

    <p class="text-gray-300">|  47: end contract  |   |</p>

    <p class="text-gray-300">Subsequently, the user calls the submit-event-proof function of sidechain_{2} (which is inherited from the crosschain contract), passing the NIPoPoW <span class="math">\\pi_{1}</span> and the event predicate <span class="math">e_{1}</span> and paying collateral <span class="math">z</span>, which registers <span class="math">e_{1}</span> on sidechain_{2} as tentative. Because the user is honest, no adversary can produce a <span class="math">\\pi_{1}^{\\prime}</span> which disproves their claim during the dispute period, and therefore the user waits for <span class="math">k_{2}</span> blocks for the contestation period to expire without any successful contestations. She then calls the finalize-event function for <span class="math">e_{1}</span> and receives back the collateral <span class="math">z</span>, marking the event permanent. Finally, she calls the function withdraw of sidechain_{2}, passing it the same parameters that <span class="math">e_{1}</span> was issued with. The withdraw function checks that <span class="math">e_{1}</span> exists using the event-exists method, which will return true. The user is then credited with amount in their ETH20 balance stored in balances[target]. This increment in balance creates brand new ETH20 tokens.</p>

    <p class="text-gray-300">The user can then transfer their ETH20 tokens by utilizing the functionality inherited from the ERC20 contract. When some (not necessarily the same) user is ready to move some (not necessarily the same) amount of ETH20 from the Ethereum Classic blockchain back into ETH on the Ethereum blockchain, they follow the reverse procedure. Specifically, they call the withdraw function of sidechain_{2} which ensures their ERC20 balance is sufficient, deduces the requested amount, and fires an event <span class="math">e_{2}</span> as before. At this point, these particular ETH20 tokens are destroyed by the balance deduction. Once <span class="math">e_{2}</span> is confirmed in <span class="math">\\mathcal{G}_{2}</span>, the user produces the NIPoPoW <span class="math">\\pi_{2}</span> about <span class="math">e_{2}</span> which claims that a payment was made within <span class="math">\\mathcal{G}_{2}</span>. That proof is then submitted to sidechain_{1} by calling the submit-event-proof and finalize-event functions as before. Last, the user calls the withdraw function of sidechain_{1}, which uses the event-exists function which will return true, finally paying back the user the respective amount of ETH. Because the only way to create ETH20 tokens in sidechain_{2} is by depositing ETH into sidechain_{1}, there will always exist a sufficient balance of ETH owned by the sidechains_{1} smart contract to pay for any requested withdrawals.</p>

    <p class="text-gray-300">Suppose now that an adversarial user makes a false claim that an event <span class="math">e</span> took place in <span class="math">\\mathcal{G}_{1}</span> and posts a relevant NIPoPoW <span class="math">\\pi</span> in <span class="math">\\mathcal{G}_{2}</span>. If an honest party is monitoring the chain <span class="math">\\mathcal{G}_{2}</span> for the appearance of NIPoPoWs and the chain <span class="math">\\mathcal{G}_{1}</span> for the firing of events, the fraudulence of <span class="math">\\pi</span> will be immediately obvious to them. They can subsequently generate a contesting NIPoPoW <span class="math">\\pi^{*}</span> providing a counter-claim that <span class="math">e</span> did not occur. The honest party will broadcast this transaction at the beginning of the contestation period. Due to the chain quality of <span class="math">\\mathcal{G}_{2}</span>, the honest party will manage to include</p>

    <p class="text-gray-300">this transaction into <span class="math">\\mathcal{G}_{2}</span> within one of the blocks before the end of the contestation period. The collateral <span class="math">z</span> must be sufficient to incentivize an honest party to monitor <span class="math">\\mathcal{G}_{1}</span> and <span class="math">\\mathcal{G}_{2}</span> simultaneously, pay for transaction fees and ensure the time needed to generate a NIPoPoW <span class="math">\\pi^{*}</span> is small as compared to block generation time. The argument for <span class="math">\\mathcal{G}_{2}</span> is analogous. We make this security argument formal in the appendix.</p>

    <h2 id="sec-11" class="text-2xl font-bold">4 Applications</h2>

    <p class="text-gray-300">We give two futher applications of sidechains beyond the two-way peg.</p>

    <p class="text-gray-300">Remote ICOs. A group wants to fund raise by performing an ICO <em>[x20]</em> on a certain feature-rich target blockchain such as Ethereum. Investors who wish to purchase tokens are holding their cryptocurrency they wish to pay with on a different source blockchain with lower volatility such as Bitcoin. In this context, instead of trading Bitcoin for Ethereum, the investors can directly pay in Bitcoin and receive their ICO tokens on the Ethereum blockchain. Furthermore, the value of tokens can be denominated in Bitcoin.</p>

    <p class="text-gray-300">The course of action is as follows: Initially, the fundraising entity creates a <em>fund raiser</em> address on the source blockchain, in our example the Bitcoin blockchain. The fundraising entity also creates a <em>token generator</em> <em>[x19]</em> smart contract on the target blockchain, in our example the Ethereum blockchain. The token generator contract is initialized with the source blockchain genesis hash and the fund raiser address. The token generator contract contains a withdraw method which allows receiving the ICO tokens. The fundraising entity then advertises both the address and the smart contracts and allows investors to inspect them. An investor subsequently deposits bitcoin into the fund raiser address. The investor subsequently generates a NIPoPoW <span class="math">\\pi</span> for the deposit and submits it to the withdraw method of the token generator function. Upon verification of <span class="math">\\pi</span>, the investor receives their ICO tokens. This application is a special case of a <em>one-way peg</em> with extra rules such as a limited timeframe or dynamic pricing.</p>

    <p class="text-gray-300">Atomic swaps. Two mutually distrusting parties wish to exchange coins between two different chains, for example ETH for ETC, without using a centralized exchange. Alice wants to pay Bob in ETH and Bob wants to pay Alice in ETC. While atomic swaps are already possible using hash locks <em>[x16, x11]</em>, our construction provides an alternative possibility: One contract is created on the target blockchain, in our example Ethereum, and is made aware of the remote genesis block as well as an</p>

    <p class="text-gray-300">address on the source blockchain, in our case Alice’s Ethereum Classic address. Then, Alice deposits ether into the deposit function of the contract that sits on the target blockchain. The ether remains locked for a designated period of time. In the meantime, Bob pays Alice in Ethereum Classic by creating a regular transaction on the Ethereum Classic blockchain. He then generates a proof <span class="math">\\pi</span> that this transaction took place and is paying into Alice’s account. By submitting <span class="math">\\pi</span> into the withdraw function of the contract that sits on the target blockchain, Bob receive his ether payment, contingent on the fact that he has paid Alice. In case Bob aborts the protocol, Alice is able to withdraw her money from the source blockchain contract by calling an abort function, which is only callable as soon as a sufficient number of blocks have passed. As long as Bob cooperates in a timely manner, Alice is unable to call abort due to the timelock, and hence the protocol is atomic.</p>

    <h2 id="sec-12" class="text-2xl font-bold">Appendix</h2>

    <h2 id="sec-13" class="text-2xl font-bold">Appendix A Security analysis</h2>

    <p class="text-gray-300">We now formalize our protocol and provide a cryptographic analysis of its security. As NIPoPoWs security is modelled in the Bitcoin Backbone Protocol <em>[x11]</em>, we work in the same model (and note that the same mathematical model also captures Ethereum). We assume that the standard results of the backbone protocol are attained, namely blockchain persistence and liveness. Persistence and liveness can be proved to hold with overwhelming probability under the honest mining majority assumption. For the details of that result, consult the Bitcoin Backbone paper <em>[x11]</em>.</p>

    <p class="text-gray-300">We adopt the sidechains security definition from related work on proof-of-stake sidechains <em>[x12]</em>.</p>

    <p class="text-gray-300">We will show that proving, to the maintainers of a chain <span class="math">\\mathcal{G}_{2}</span>, that an event <span class="math">e</span> took place in chain <span class="math">\\mathcal{G}_{1}</span> without it actually happening, can only occur if the underlying NIPoPoWs protocol is insecure. Therefore, our proof strategy follows the standard form of a cryptographic computational reduction. In our assumptions, we will make use of the persistence and liveness of <span class="math">\\mathcal{G}_{2}</span>, but only the persistence of <span class="math">\\mathcal{G}_{1}</span>.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Assume a secure NIPoPoWs construction. Then, under the honest majority assumption for both <span class="math">\\mathcal{G}_{1}</span> and <span class="math">\\mathcal{G}_{2}</span>, for all PPT adversaries <span class="math">\\mathcal{A}</span> and for all environments <span class="math">\\mathcal{Z}</span>, the proof-of-work sidechains construction between <span class="math">\\mathcal{G}_{1}</span> and <span class="math">\\mathcal{G}_{2}</span> with contestation period <span class="math">2k</span> is secure, except with negligible probability in <span class="math">k</span>.</p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be an arbitrary PPT adversary against the proof-of-work sidechains construction and <span class="math">\\mathcal{Z}</span> be an arbitrary environment. We will construct an adversary <span class="math">\\mathcal{A}^{<em>}</span> against NIPoPoWs and an environment <span class="math">\\mathcal{Z}^{</em>}</span> in which it will operate.</p>

    <p class="text-gray-300">Suppose, without loss of generality, that <span class="math">\\mathcal{A}</span> can break the security of proof-of-work sidechains during a cross-chain transfer from <span class="math">\\mathcal{G}_{1}</span> to <span class="math">\\mathcal{G}_{2}</span>. (Because the construction is symmetric, if the adversary is not able to do that, then they will be able to break the security of a cross-chain transfer from <span class="math">\\mathcal{G}_{2}</span> to <span class="math">\\mathcal{G}_{1}</span> and the proof follows in the same manner.)</p>

    <p class="text-gray-300">Note that <span class="math">\\mathcal{A}</span> works in an environment with two blockchains, <span class="math">\\mathcal{G}_{1}</span> and <span class="math">\\mathcal{G}_{2}</span>, while <span class="math">\\mathcal{A}^{*}</span> must work in the environment of one blockchain, namely <span class="math">\\mathcal{G}_{1}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}^{<em>}</span> works as follows. First, it simulates the execution of the blockchain civilization <span class="math">\\mathcal{G}_{2}</span>. That is, it creates a new random oracle for <span class="math">\\mathcal{G}_{2}</span> which is independent of its external random oracle used with <span class="math">\\mathcal{G}_{1}</span>. For any random oracle queries of <span class="math">\\mathcal{A}</span> pertaining to <span class="math">\\mathcal{G}_{1}</span>, <span class="math">\\mathcal{A}^{</em>}</span> forwards the queries to its external random oracle. For random oracles queries of <span class="math">\\mathcal{A}</span> pertaining to <span class="math">\\mathcal{G}_{2}</span>, <span class="math">\\mathcal{A}^{<em>}</span> answers its queries with its simulated and independent random oracle. Because <span class="math">\\mathcal{A}</span> is subject to honest majority limitations in both <span class="math">\\mathcal{G}_{1}</span> and <span class="math">\\mathcal{G}_{2}</span>, it follows that <span class="math">\\mathcal{A}^{</em>}</span> will respect honest majority with regards to its external random oracle. For any environment instructions requested by <span class="math">\\mathcal{Z}</span> pertaining to <span class="math">\\mathcal{G}_{1}</span> (namely, the creation of new parties), the instructions are mirrored by <span class="math">\\mathcal{Z}^{<em>}</span>. Intructions of <span class="math">\\mathcal{Z}</span> pertaining to <span class="math">\\mathcal{G}_{2}</span> are simulated by <span class="math">\\mathcal{A}^{</em>}</span>. All diffusions of blocks in <span class="math">\\mathcal{G}_{1}</span> by <span class="math">\\mathcal{A}</span> are also diffused by <span class="math">\\mathcal{A}^{*}</span>, while diffusions in <span class="math">\\mathcal{G}_{2}</span> by <span class="math">\\mathcal{A}</span> are held private.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}^{<em>}</span> monitors the chains adopted by honest parties and for every round <span class="math">r</span> observes the state of all honest parties. <span class="math">\\mathcal{A}^{</em>}</span> looks for a round <span class="math">r</span>, an event <span class="math">e</span>, a <span class="math">\\mathcal{G}_{1}</span> maintainer <span class="math">p_{1}</span> and a <span class="math">\\mathcal{G}_{2}</span> maintainer <span class="math">p_{2}</span> for which the following properties hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">p_{1}</span> has not included <span class="math">e</span> in their state</li>

      <li><span class="math">p_{2}</span> has included <span class="math">e</span> in their finalized-events state</li>

    </ol>

    <p class="text-gray-300">Because of the construction of <span class="math">p_{2}</span>, finalized-events can contain <span class="math">e</span> only if an issuance of submit-event-proof is included at least <span class="math">2k</span> blocks deep and contains the respective NIPoPoW <span class="math">\\pi</span> stored in events[<span class="math">e</span>].proof. <span class="math">\\mathcal{A}^{*}</span> now returns the proof <span class="math">\\pi</span>.</p>

    <p class="text-gray-300">We will now analyze the probability of success of <span class="math">\\mathcal{A}</span>. Consider the following (probabilistic) events:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>SC-Brk that <span class="math">\\mathcal{A}</span> is successful</li>

      <li>Cert-Brk that <span class="math">\\mathcal{A}^{*}</span> is successful</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Per_{1} that persistence is maintained in <span class="math">\\mathcal{G}_{1}</span></li>

      <li>Per_{2} that persistence is maintained in <span class="math">\\mathcal{G}_{2}</span></li>

      <li>Live_{2} that liveness is maintained in <span class="math">\\mathcal{G}_{2}</span></li>

      <li>BC the union of <span class="math">\\textsc{Per}_{1}\\wedge\\textsc{Per}_{2}\\wedge\\textsc{Live}_{2}</span></li>

    </ol>

    <p class="text-gray-300">From total probability we obtain:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[\\text{SC-Brk}]=\\Pr[\\text{SC-Brk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{BC}]\\Pr[\\text{BC}]+\\Pr[\\text{SC-Brk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\neg\\text{BC}]\\Pr[\\neg\\text{BC}]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">From the honest majority assumption of <span class="math">\\mathcal{G}_{1}</span>, we deduce that <span class="math">\\Pr[\\neg\\textsc{Per}_{1}]</span> and <span class="math">\\Pr[\\neg\\textsc{Live}_{1}]</span> are negligible, and similarly from the honest majority assumption of <span class="math">\\mathcal{G}_{2}</span> we deduce that <span class="math">\\Pr[\\neg\\textsc{Per}_{2}]</span> is negligible, therefore <span class="math">\\Pr[\\neg\\text{BC}]</span> is negligible. It now suffices to show that $\\Pr[\\text{SC-Brk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{BC}]\\Pr[\\text{BC}]$ is negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Suppose that SC-Brk occurs. It follows that a (blockchain) event <span class="math">e</span> must have been adopted by <span class="math">p_{2}</span> with some NIPoPoW <span class="math">\\pi</span>, but not by <span class="math">p_{1}</span>, as detailed above. Suppose now that BC occurs.</p>

    <p class="text-gray-300">Because of the <em>persistence</em> of <span class="math">\\mathcal{G}_{2}</span>, when <span class="math">\\pi</span> was burried under <span class="math">k</span> blocks in the adopted chain of <span class="math">p_{2}</span>, all honest parties in <span class="math">\\mathcal{G}_{2}</span> must have seen <span class="math">\\pi</span> (this warrants the oldest <span class="math">k</span> of the <span class="math">2k</span> blocks in the contestation period). Because of the <em>liveness</em> of <span class="math">\\mathcal{G}_{2}</span>, at least one honest block must have been included in the last <span class="math">k</span> blocks after <span class="math">\\pi</span> had been received by all honest parties (this warrants the latest <span class="math">k</span> of the <span class="math">2k</span> blocks in the contestation period).</p>

    <p class="text-gray-300">Because of the <em>persistence</em> of <span class="math">\\mathcal{G}_{1}</span>, if <span class="math">e</span> is not included in the state of <span class="math">p_{1}</span> at round <span class="math">r</span>, then therefore it cannot have been included in the state of any <span class="math">\\mathcal{G}_{1}</span> party during round <span class="math">r-\\eta k</span>. It follows that an honest party will attempt and succeed in generating a <span class="math">\\mathcal{G}_{2}</span> block containing a contesting proof <span class="math">\\pi^{<em>}</span> attesting to the fraudulence of event <span class="math">e</span> by invoking <span class="math">\\textsf{submit-contesting-proof}(\\pi^{</em>},e)</span> and this block will be adopted by <span class="math">p_{2}</span>. As <span class="math">p_{2}</span> has finalized <span class="math">e</span>, then therefore it must be such that <span class="math">\\textsf{verify}_{k,m}^{e,\\mathcal{G}}(\\{\\pi,\\pi^{*}\\})</span>, and therefore Cert-Brk has occurred.</p>

    <p class="text-gray-300">Putting the above together, we obtain that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[\\textsc{Cert-Brk}]\\geq\\Pr[\\text{SC-Brk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{BC}]\\Pr[\\text{BC}]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">From the NIPoPoW security assumption, we have that <span class="math">\\Pr[\\textsc{Cert-Brk}]</span> is negligible. Therefore, <span class="math">\\Pr[\\text{SC-Brk}]</span> is negligible. ∎</p>

    <h2 id="sec-16" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[B^{+}14] Vitalik Buterin et al. A next-generation smart contract and decentralized application platform. white paper, 2014.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">BCD^{+}14. Adam Back, Matt Corallo, Luke Dashjr, Mark Friedenbach, Gregory Maxwell, Andrew Miller, Andrew Poelstra, Jorge Timón, and Pieter Wuille. Enabling blockchain innovations with pegged sidechains. 2014. http://www.opensciencereview.com/papers/123/enablingblockchain-innovations-with-pegged-sidechains.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Buc16] Ethan Buchman. Tendermint: Byzantine fault tolerance in the age of blockchains. PhD thesis, 2016.</li>

      <li>[DN93] Cynthia Dwork and Moni Naor. Pricing via processing or combatting junk mail. In Ernest F. Brickell, editor, CRYPTO’92, volume 740 of LNCS, pages 139–147. Springer, Heidelberg, August 1993.</li>

      <li>[GKL15] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol: Analysis and applications. In Elisabeth Oswald and Marc Fischlin, editors, EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 281–310. Springer, Heidelberg, April 2015. Updated version at http://eprint.iacr.org/2014/765.</li>

      <li>[GKL17] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol with chains of variable difficulty. LNCS, pages 291–323. Springer, Heidelberg, 2017.</li>

      <li>[GKZ18] Peter Gaži, Aggelos Kiayias, and Dionysis Zindros. Proof-of-stake sidechains. IACR Cryptology ePrint Archive, 2018.</li>

      <li>[Gro] The Interledger Payments Community Group. Interledger protocol v4. Available at: https://interledger.org/rfcs/0027-interledger-protocol-4/draft-5.html.</li>

      <li>[Her18] Maurice Herlihy. Atomic cross-chain swaps. arXiv preprint arXiv:1801.09515, 2018.</li>

      <li>[HHK17] Julian Hosp, Toby Hoenisch, and Paul Kittiwongsunthorn. Comit: Cryptographically-secure off-chain multi-asset instant transaction network. Available at: https://www.comit.network/doc/COMIT%20white%20paper%20v1.0.2.pdf, 2017.</li>

      <li>[HKZG15] Ethan Heilman, Alison Kendler, Aviv Zohar, and Sharon Goldberg. Eclipse attacks on bitcoin’s peer-to-peer network. Cryptology ePrint Archive, Report 2015/263, 2015. http://eprint.iacr.org/2015/263.</li>

      <li>[KG18] Rami Khalil and Arthur Gervais. Nocust–a non-custodial 2 nd-layer financial intermediary. Technical report, Cryptology ePrint Archive, Report 2018/642. https://eprint. iacr. org/2018/642, 2018.</li>

      <li>[KLS16] Aggelos Kiayias, Nikolaos Lamprou, and Aikaterini-Panagiota Stouka. Proofs of proofs of work with sublinear complexity. In International Conference on Financial Cryptography and Data Security, pages 61–78. Springer, 2016.</li>

      <li>[KMZ17] Aggelos Kiayias, Andrew Miller, and Dionysis Zindros. Non-interactive proofs of proof-of-work, 2017.</li>

      <li>[Nak08] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. 2008.</li>

      <li>[Nol13] Tier Nolan. Alt chains and atomic transfers. Available at: https://bitcointalk.org/index.php?topic=193281.0, 2013.</li>

      <li>[PB17] Joseph Poon and Vitalik Buterin. Plasma: Scalable autonomous smart contracts. White paper, 2017.</li>

      <li>[PSS17] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol in asynchronous networks. LNCS, pages 643–673. Springer, Heidelberg, 2017.</li>

    </ul>

    <p class="text-gray-300">SCS17a. Inc Smart Contract Solutions. Openzeppelin crowdsale contract. Available at: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.0.0-rc.1/contracts/token/ERC20/ERC20.sol, 2017.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[20] [2017] [2017]. [20] [2017]. [2017]. [2017]. [2017]. [2017]. [2017]. [2017]. [2017]. [2017]. [2017]. [2017]. [2017]. [2017].</li>

    </ul>`;
---

<BaseLayout title="Proof-of-Work Sidechains (2018/1048)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/1048
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
