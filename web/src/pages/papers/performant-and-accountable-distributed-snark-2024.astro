---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/1873';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = '$\\mathsf{Cirrus}$: Performant and Accountable Distributed SNARK';
const AUTHORS_HTML = 'Wenhao Wang, Fangyan Shi, Dani Vilardell, Fan Zhang';

const CONTENT = `    <p class="text-gray-300">Wenhao Wang [ Yale Univerity, IC3 wenhao.wang@yale.edu ] Fangyan Shi [ Tsinghua University sfy21@tsinghua.org.cn ] Dani Vilardell [ Cornell University, IC3 dv296@cornell.edu ] Fan Zhang [ Yale University, IC3 f.zhang@yale.edu ]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Succinct Non-interactive Arguments of Knowledge (SNARKs) can enable efficient verification of computation in many applications. However, generating SNARK proofs for large-scale tasks, such as verifiable machine learning or virtual machines, remains computationally expensive. A promising approach is to distribute the proof generation workload across multiple workers. A practical distributed SNARK protocol should have three properties: horizontal scalability with low overhead (linear computation and logarithmic communication per worker), accountability (efficient detection of malicious workers), and a universal trusted setup independent of circuits and the number of workers. Existing protocols fail to achieve all these properties.</p>

    <p class="text-gray-300">In this paper, we present Cirrus, the first distributed SNARK generation protocol achieving all three desirable properties at once. Our protocol builds on HyperPlonk (EUROCRYPT’23), inheriting its universal trusted setup. It achieves linear computation complexity for both workers and the coordinator, along with low communication overhead. To achieve accountability, we introduce a highly efficient accountability protocol to localize malicious workers. Additionally, we propose a hierarchical aggregation technique to further reduce the coordinator’s workload.</p>

    <p class="text-gray-300">We implemented and evaluated Cirrus on machines with modest hardware. Our experiments show that Cirrus is highly scalable: it generates proofs for circuits with <span class="math">33</span>M gates in under <span class="math">40</span> seconds using <span class="math">32</span> <span class="math">8</span>-core machines. Compared to the state-of-the-art accountable protocol Hekaton (CCS’24), Cirrus achieves over <span class="math">7\\times</span> faster proof generation for PLONK-friendly circuits such as the Pedersen hash. Our accountability protocol also efficiently identifies faulty workers within just <span class="math">4</span> seconds, making Cirrus particularly suitable for decentralized and outsourced computation scenarios.</p>

    <h2 id="sec-3" class="text-2xl font-bold">I Introduction</h2>

    <p class="text-gray-300">Succinct Non-interactive Arguments of Knowledge (SNARKs) <em>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</em> have emerged as a breakthrough in cryptographic tools, enabling efficient, non-interactive verification of computations. The primitive has proven practical for various applications, such as privacy-preserving payments (e.g., Zcash <em>[12]</em>), scalability solutions for decentralized consensus (e.g., zkRollups <em>[13]</em>), and blockchain interoperability (e.g., zkBridges <em>[14]</em>). However, for more ambitious applications, such as verifiable machine learning (zkML) and verifiable virtual machines (zkVM), the computational demands of proof generation remain a substantial bottleneck.</p>

    <p class="text-gray-300">A recent line of works <em>[15, 14, 16, 17, 18]</em> proposed to horizontally scale up SNARK generation with distributed SNARK generation protocols, where multiple workers collaborate on different parts of a general-purpose circuit to create a final proof. By splitting up the proof task across workers, distributed proof generation not only speeds up computation but also reduces memory usage, making it feasible to prove statements about large circuits that cannot fit in the memory of a single server.</p>

    <p class="text-gray-300">We identify three properties that a distributed SNARK generation scheme should satisfy:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Firstly, it should scale horizontally with low overhead. Specifically, each worker’s computational complexity should ideally grow linearly with the size of the subcircuit it is assigned,avoiding performance degradation as more workers are added. Furthermore, each worker’s communication complexity should scale sub-linearly with its sub-task size, as large tasks would otherwise result in prohibitive communication costs.</li>

      <li>Secondly, it should achieve accountability, i.e., being able to efficiently detect malicious behavior and identify of faulty or dishonest workers. Accountability is particularly important in distributed SNARK generation settings where proof computation is outsourced to decentralized networks involving potentially untrusted participants. For instance, in prover marketplaces <em>[19, 20, 21]</em>, users delegate computation tasks to workers offering spare computational resources, which necessitates mechanisms to detect malfeasance and hold responsible parties accountable to maintain trust and reliability.</li>

      <li>Thirdly, it should have a universal setup, avoiding the need for per-circuit trusted setup ceremonies. Requiring a dedicated setup each time a new application is encountered is highly inefficient, especially in proof outsourcing scenarios where workers frequently handle tasks from many different applications. The complexity and cost associated with conducting secure multi-party ceremonies for each application would severely limit scalability and usability <em>[22]</em>. A universal setup addresses this challenge by enabling diverse applications to leverage distributed SNARKs without additional trusted initialization.</li>

    </ol>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">Limitation of prior works.</h3>

    <p class="text-gray-300">While prior works reduced overhead and achieved partial accountability, none achieved all three properties. Pianist <em>[16]</em> is the first distributed proof generation scheme based on PLONK. It achieves a robust quasilinear prover time protocol for general circuits, but not</p>

    <p class="text-gray-300">accountability. HyperPianist <em>[18]</em> improves the prover complexity to linear time but still lacks accountability. Hekaton <em>[17]</em> introduced an accountable protocol with quasilinear prover time, but it relies on Mirage <em>[23]</em>, a SNARK requiring a circuit-specific setup, making it costly to use in general-purpose circuits. Neither of Pianist of Hekaton achieves linear worker time.</p>

    <p class="text-gray-300">This work: Cirrus. We introduce Cirrus, the first distributed SNARK generation scheme that simultaneously satisfies all of the desired properties: low overhead, accountability, and universal trusted setup. Specifically, Cirrus achieves linear computational complexity for both workers and the coordinator, with communication overhead scaling sub-linearly with task size, ensuring practical efficiency for large-scale deployments. Moreover, Cirrus reuses existing universal setup parameters from HyperPlonk, which significantly simplifies its deployment. Unlike previous accountable schemes such as Hekaton, Cirrus does not require circuit-specific setups, and therefore avoiding repeated costly setup ceremonies. Furthermore, Cirrus implements an efficient accountability protocol that enables the coordinator to quickly detect malicious behavior, precisely identify offending workers, and support incentive-based systems to maintain security and trustworthiness. By simultaneously addressing computational efficiency, accountability, and setup universality, Cirrus significantly expands the potential scalability and security of SNARK applications in decentralized and outsourced computation environments.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">I-A Technical Overview</h3>

    <p class="text-gray-300">Our distributed scheme is built upon HyperPlonk <em>[8]</em>, a non-distributed SNARK scheme with prover time linear in circuit size and universal trusted setup. Our adaptation of HyperPlonk to a distributed setting must preserve these properties.</p>

    <p class="text-gray-300">We use <span class="math">M</span> to denote the number of workers. A circuit <span class="math">\\mathcal{C}</span> of <span class="math">N</span> gates is particitioned into <span class="math">M</span> sub-circuits (using approach proposed in <em>[16]</em>), each of size <span class="math">T</span>. Additionally, <span class="math">M</span> workers collaborate with a single coordinator.</p>

    <p class="text-gray-300">Distributing HyperPlonk. To adapt HyperPlonk to a distributed setting, we need to distribute its core building blocks: multilinear KZG, the sum-check protocol (SumCheck), the zero test protocol (ZeroTest), and the permutation test protocol (PermTest). While distributing the multilinear KZG protocol is straightforward, naively distributing the SumCheck protocol using existing techniques (e.g., <em>[14]</em>) introduces a critical issue. Specifically, at the conclusion of the distributed SumCheck, we must open a multivariate polynomial with constant degree <span class="math">d&gt;1</span>. However, existing techniques from <em>[14]</em> combined with multilinear KZG only support committing to and opening multivariate polynomials of degree at most <span class="math">1</span>.</p>

    <p class="text-gray-300">We address this limitation using the following key observation: any constant-degree multivariate polynomial can be equivalently represented as a function of a constant number of multilinear (i.e., degree-<span class="math">1</span>) polynomials. More formally, each polynomial <span class="math">f(\\bm{x})</span> of constant degree can be expressed as <span class="math">f(\\bm{x})=h(g_{1}(\\bm{x}),\\ldots,g_{c}(\\bm{x}))</span>, where each <span class="math">g_{i}(\\bm{x})</span> is multilinear. Furthermore, additions and multiplications of these degree-<span class="math">1</span> distributed polynomials produce results that match the evaluation of the original polynomial on the Boolean hypercube <span class="math">\\{0,1\\}^{n}</span>. Consequently, we transform the original challenge into distributing the sum-check protocol for multilinear polynomials. This transformation enables us to employ distributed multilinear KZG effectively to commit to and open polynomials at the end of the distributed SumCheck. With this distributed version of SumCheck, we subsequently extend our construction to a fully distributed HyperPlonk scheme.</p>

    <p class="text-gray-300">Optimistic accountability. When a proof is generated by workers, the coordinator verifies the proof. If this verification succeeds, no further action is required, as correctness is ensured with overwhelming probability by the soundness property. However, when verification fails, the coordinator is required to identify one or more workers at fault. A naive approach would require the coordinator to independently recompute all intermediate results and compare them with the results sent by the workers, incurring high computational costs same as generating the entire proof on its own. To address this issue, Cirrus introduces a fault localization protocol that significantly reduces computational overhead.</p>

    <p class="text-gray-300">First, the coordinator verifies the KZG sub-proofs provided by each worker and checks their consistency with the respective KZG commitments of the witness polynomials constructed by the workers. A failed verification at this stage directly identifies a faulty worker. If all sub-proofs verify successfully, the coordinator proceeds by reconstructing the witness polynomials from each worker and evaluates them at a common random point determined at the conclusion of the distributed sum-check protocol. A mismatch in any evaluation result indicates a malicious worker. Asymptotically, our fault localization protocol requires only <span class="math">O(M\\log T)</span> pairings and <span class="math">O(MT)</span> field operations. Since the field operations are lightweight in practice, our accountability is substantially more efficient than the baseline approach of recomputing the proof.Our evaluation confirms that the optimistic accountability protocol is concretely efficient, requiring only <span class="math">4</span> seconds to localize malicious workers, even for circuits with <span class="math">33</span> million gates distributed across <span class="math">256</span> workers.</p>

    <p class="text-gray-300">Reducing the coordinator’s computational overhead. In the optimistic case where all workers are honest, the coordinator’s computational workload scales with the number of workers, potentially becoming a performance bottleneck as the worker count grows. In the vanilla distributed HyperPlonk protocol, the coordinator’s runtime complexity would be <span class="math">O(M\\log T)</span>, which originates from aggregating <span class="math">M</span> vectors, each of length <span class="math">O(\\log T)</span>, in the distributed SumCheck and distributed multilinear KZG protocols. To reduce this, Cirrus introduces an efficient hierarchical aggregation approach. Specifically, we partition the aggregation task among <span class="math">M/\\log T</span> designated worker provers, referred to as leaders, each of</p>

    <p class="text-gray-300">whom aggregates vectors from <span class="math">\\log T</span> workers. Consequently, the coordinator’s computational complexity for this aggregation step is reduced significantly to <span class="math">O(M)</span>. We note that the resulting computational overhead per leader is <span class="math">O(\\log^{2}T)</span>, which remains negligible compared to their primary computation tasks dominated by <span class="math">O(T)</span>.</p>

    <p class="text-gray-300">In summary, Cirrus is the first distributed SNARK protocol achieving linear computational complexity and logarithmic communication per worker, efficient accountability, and universal trusted setup. As shown in Table I, Cirrus outperforms previous state-of-the-art distributed SNARK schemes by simultaneously achieving all desirable properties, which are linear runtime scaling, accountability with efficient fault localization, and setup universality. Therefore, Cirrus significantly improves both practicality and scalability for real-world deployments of ZKP applications.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">II-B Implementation and Evaluation</h3>

    <p class="text-gray-300">We implement and extensively evaluate Cirrus to assess its end-to-end performance. Our implementation builds upon the HyperPlonk library <em>[24]</em>. To benchmark performance, we generated random PLONK circuits with corresponding random witnesses, distributing the SNARK generation process across up to <span class="math">32</span> AWS t3.2xlarge machines (each equipped with <span class="math">8</span> vCPUs and <span class="math">32</span> GB of memory). We note that Cirrus seamlessly reuses existing universal setup parameters from HyperPlonk, which simplifies its deployment in real life.</p>

    <p class="text-gray-300">Our experiments demonstrate that Cirrus can efficiently produce proofs for circuits containing up to <span class="math">33</span>M gates in merely <span class="math">39</span> seconds, using a distributed network of <span class="math">32</span> worker machines. In contrast, vanilla HyperPlonk can only handle circuits of size <span class="math">4</span>M gates, requiring more than <span class="math">110</span> seconds on the same hardware configuration. These results clearly illustrate the horizontal scalability advantages of Cirrus.</p>

    <p class="text-gray-300">Additionally, we evaluate the efficiency of our accountability protocol. Our results indicate that when an incorrect proof is produced, the coordinator can identify at least one faulty worker within less than <span class="math">4</span> seconds for circuits of <span class="math">33</span>M gates and <span class="math">256</span> workers, showing the practicality of the accountability checks. We further assess the coordinator’s computational overhead and confirmed that, due to our hierarchical aggregation approach, the coordinator’s runtime remains independent of the individual sub-circuit size, which validates this theoretical improvement.</p>

    <p class="text-gray-300">Finally, we perform comparative evaluations with another state-of-the-art accountable distributed SNARK scheme Hekaton <em>[17]</em>. Our experiments highlight that for PLONK-friendly workloads, such as Pedersen hash circuits, Cirrus significantly outperforms Hekaton, achieving a performance gain of over <span class="math">7\\times</span>. For other tasks including MiMC hash and PoK of Exponent, Cirrus also achieves faster performance than Hekaton, while additionally offering the advantage of a universal trusted setup. Specifically, unlike Hekaton, our approach does not require separate trusted setups for each distinct application or varying worker configurations, substantially simplifying practical deployment and enhancing flexibility.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Our Contribution</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We introduce the notion of <em>accountability</em> to distributed SNARK generation protocols. An accountable distributed SNARK scheme allows the coordinator to efficiently detect incorrect proofs and accurately identify malicious or faulty workers. This property is particularly critical in decentralized settings, such as zero-knowledge prover markets <em>[19]</em>, where participants may behave maliciously or unreliably.</li>

      <li>In Section III, we present Cirrus, the first accountable distributed SNARK generation protocol that simultaneously achieves all the essential properties for practical deployment, i.e., Cirrus can efficiently scale horizontally, Cirrus enables efficient detection of incorrect proofs and identification of malicious workers, and Cirrus requires only a single universal setup same as the setup in HyperPlonk, eliminating the inefficiency of repeated per-application setup ceremonies.</li>

      <li>In Section IV, we implement and comprehensively evaluate Cirrus. Our experiments demonstrate that Cirrus achieves exceptional performance, enabling proofs for circuits containing <span class="math">33</span>M gates in under <span class="math">40</span> seconds on a distributed setup of <span class="math">32</span> <span class="math">8</span>-core machines, and allows the coordinator rapidly detects malicious behavior within <span class="math">4</span> seconds.</li>

    </ul>

    <h2 id="sec-8" class="text-2xl font-bold">II Preliminaries</h2>

    <p class="text-gray-300">In this section, we introduce the key notation, definitions, and foundational tools essential for the completeness and soundness of our protocol. For the interest of space, we move canonical definitions of SNARKs, polynomial interactive oracle proofs (Poly-IOPs), and polynomial commitment schemes (PCS’s) to Appendix A. We also refer readers to Appendix B for details of the HyperPlonk protocol, and Appendix C for details of the multilinear KZG PCS.</p>

    <p class="text-gray-300">Notation.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathbb{F}</span> be a finite field of size <span class="math">\\Omega(2^{\\lambda})</span>, where <span class="math">\\lambda</span> is the security parameter.</li>

      <li>Let <span class="math">B_{\\mu}:=\\{0,1\\}^{\\mu}</span> denote the <span class="math">\\mu</span>-dimension boolean hypercube.</li>

      <li>Let <span class="math">\\mathbb{F}_{\\mu}^{&lt;d}[{\\bm{X}}]</span> denote the set of <span class="math">\\mu</span>-variate polynomials where the degree of each variable is not greater than <span class="math">d</span>. A multivariate polynomial <span class="math">g</span> is <em>multilinear</em> if the degree of the polynomial in each variable is at most <span class="math">1</span>. Each element <span class="math">f\\in\\mathbb{F}_{\\mu}^{&lt;d}[{\\bm{X}}]</span> would satisfy <span class="math">f({\\bm{x}})=h(g_{1}({\\bm{x}}),\\ldots,g_{c}({\\bm{x}}))</span> where <span class="math">h</span> has total degree <span class="math">O(d)</span> and can be evaluated with an arithmetic circuit of <span class="math">O(d)</span> gates, and each <span class="math">g_{i}</span> is multilinear.</li>

      <li>Let <span class="math">\\chi_{\\bm{w}}({\\bm{x}}):=\\prod_{i=1}^{\\mu}(w_{i}x_{i}+(1-w_{i})(1-x_{i}))</span> be a multilinear Lagrange polynomial over <span class="math">B_{\\mu}</span>.</li>

      <li>For <span class="math">{\\bm{x}}\\in\\mathbb{F}^{\\mu}</span>, let <span class="math">[{\\bm{x}}]:=\\sum_{i=1}^{\\mu}2^{i-1}\\cdot x_{i}</span>. Let <span class="math">\\langle v\\rangle_{m}</span> be the <span class="math">m</span>-bit representation of <span class="math">v\\in[0,2^{m}-1]</span>.</li>

      <li>Let <span class="math">\\mathcal{P}_{0}</span> denote the coordinator, and let <span class="math">(\\mathcal{P}_{\\bm{b}})_{\\bm{b}\\in\\{0,1\\}^{\\xi}}</span> denote the <span class="math">M</span> workers, where <span class="math">2^{\\xi}=M</span>.</li>

    </ul>

    <p class="text-gray-300">Useful tools. Here we introduce frequently used tools.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Lemma 1 (Multilinear Extension).</h6>

    <p class="text-gray-300">For a function <span class="math">g:B_{\\mu}\\rightarrow\\mathbb{F}</span>, there is a unique multilinear polynomial <span class="math">\\tilde{g}</span> such that <span class="math">\\tilde{g}({\\bm{x}})=g({\\bm{x}})</span> for all <span class="math">{\\bm{x}}\\in B_{\\mu}</span>. The function <span class="math">\\tilde{g}</span> is said to be</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Worker Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Coordinator Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Comm.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Accountable</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setup</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Cirrus (Ours)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(T)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M log T)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">Universal</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hekaton [17]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(T log T)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">+ M log M)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">Circuit-specific</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HyperPianist [18]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(T)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M log T)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M log T)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">Universal</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pianist [16]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(T log T)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M log M)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">Universal</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DeVirgo [14]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(T)</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2N)</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">Transparent</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DIZK [15]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(T log2T)</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">Circuit-specific</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">TABLE I: Comparison between Cirrus and existing distributed SNARK generation protocols. Comm. denotes the communication cost in total.  <span class="math">\\nu</span>  Time denotes the verifier time.  <span class="math">N</span>  is the number of gates (or constraints) in the whole circuit, and  <span class="math">M</span>  is the number of workers.  <span class="math">T = N / M</span>  is the size of each sub-circuit. For Setup, "Circuit-specific" denotes that each different circuit requires its own trusted setup, "Universal" denotes that one set of trusted setup parameters works for circuits up to a certain size, and "Transparent" denotes that no trusted setup is required.</p>

    <p class="text-gray-300">the multilinear extension (MLE) of  <span class="math">g</span> .  <span class="math">\\tilde{g}</span>  can be expressed as  <span class="math">\\tilde{g}(\\boldsymbol{x}) = \\sum_{\\boldsymbol{a} \\in B_{\\mu}} f(\\boldsymbol{a}) \\cdot \\chi_{\\boldsymbol{a}}(\\boldsymbol{x})</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 2 (Schwartz-Zippel Lemma). Let  <span class="math">g: \\mathbb{F}^{\\ell} \\to \\mathbb{F}</span>  be a nonzero  <span class="math">\\ell</span> -variate polynomial of degree at most  <span class="math">d</span> . Then for all  <span class="math">\\emptyset \\neq S \\subseteq \\mathbb{F}</span> ,  $\\underset{\\boldsymbol{x} \\leftarrow S^2}{\\operatorname{Pr}}[g(\\boldsymbol{x}) = 0] \\leq \\frac{d}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Accountable distributed SNARK. In an environment where each prover except the coordinator may sabotage the distributed proving process by intentionally sending incorrect information such as wrong proofs, an accountable distributed SNARK generation system enables the coordinator  <span class="math">\\mathcal{P}_0</span>  to either (1) generate a valid proof or (2) detect at least one malicious prover. In [16] the authors proposed such a scheme for circuits comprising independent sub-circuits and left the construction of accountable distributed SNARK generation schemes that work for single general-purpose circuits as an open problem. Here we define accountability as follows.</p>

    <p class="text-gray-300">Definition 1 (Accountable Distributed SNARK Generation Scheme). For a circuit  <span class="math">\\mathcal{C}</span>  with  <span class="math">M</span>  workers and one designated coordinator, an accountable distributed SNARK generation scheme is a protocol that ensures completeness, knowledge soundness, and succinctness, along with the following key property named accountability: for any number of malicious worker provers who produce incorrect proofs, the system enables the coordinator to reliably and accurately identify at least one of such malicious participants.</p>

    <p class="text-gray-300">In this section, we formally describe Cirrus, a distributed SNARK generation scheme with linear prover time where the coordinator can make accountable any malicious behavior. We start by giving the construction to distribute HyperPlonk for a general circuit. We first present a distributed multilinear KZG PCS, and how to construct a distributed multivariate SumCheck protocol that is compatible with our distributed PCS. With the distributed multivariate SumCheck protocol, we show how to construct the distributed HyperPlonk accordingly.</p>

    <p class="text-gray-300">The distributed HyperPlonk protocol is complete and sound, but it still suffers from the following drawbacks: (1) the coordinator cannot find accountable the malicious prover(s) if the final proof is incorrect, and (2) the coordinator needs</p>

    <p class="text-gray-300">to perform  <span class="math">O(M \\log T)</span>  group and field operations, which is not truly linear in  <span class="math">M</span>  and  <span class="math">T</span> . To tackle the first challenge, we propose a verification protocol that allows the coordinator to detect any malicious prover. The core technique in the verification protocol is that the coordinator can evaluate the permutation products of each circuit segment. Note that the additional verification steps would introduce a large overhead for the coordinator if the verification is performed on the fly. We overcome this with an alternative protocol: the coordinator first verifies the final proof to check if there exist malicious nodes. The coordinator will only run the complete check if the verification fails. In this way, the optimistic runtime overhead of the coordinator can be reduced to the verifier time of our protocol. To tackle the second challenge, we delegate part of the work of the coordinator to multiple nodes to reduce the runtime of the coordinator and show how this technique can work along with the optimistic verification. This is done while keeping all the coordinator's computation time linear.</p>

    <p class="text-gray-300">Our protocol is built on top of HyperPlonk [8], an adaptation of PLONK to the boolean hypercube, using multilinear polynomial commitments to remove the need for FFT computation and achieving linear prover time. We first define polynomials necessary for the protocol.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Defining polynomials. Before running the distributed SNARK, we assume that a circuit  <span class="math">\\mathcal{C}</span>  has been divided into  <span class="math">M = 2^{\\xi}</span>  different sub-circuits. This can be done by just dividing the PLONK trace  <span class="math">t</span>  of the circuit evenly into  <span class="math">M</span>  chunks  <span class="math">\\{t^{(b)}\\}_{b\\in B_{\\xi}}</span> , where the gates within the same chunk are in the same circuit segment. Then each circuit segment has its own public inputs, addition and multiplication gate selectors, and wiring permutations. Let  <span class="math">\\nu^{(b)}</span>  be the length of the binary index to represent public inputs for  <span class="math">\\mathcal{P}_b</span> , i.e.  <span class="math">2^{\\nu^{(b)}} = \\ell_x^{(b)}</span> . Let  <span class="math">\\mu</span>  be the length of the binary index to represent the gates for all workers, i.e.  $2^{\\mu} =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ M<span class="math"> . Let  </span>s^{(b)}<span class="math">  represent the gate selection vector for  </span>\\mathcal{P}_b<span class="math"> . Note that there is a wiring permutation between different circuit segments. Let  </span>s^{(b)}<span class="math"> ,  </span>\\sigma^{(b)}: B_{\\mu + 2} \\to B_{\\mu + 2}<span class="math">  and  </span>\\rho^{(b)}: B_{\\mu + 2} \\to B_{\\xi}<span class="math">  be the mappings of the circuit wiring for  </span>\\mathcal{P}_b<span class="math"> , such that  </span>\\{(\\sigma^{(b)}(\\boldsymbol{c}), \\rho^{(b)}(\\boldsymbol{c})): \\boldsymbol{c} \\in B_{\\mu}, \\boldsymbol{b} \\in B_{\\xi}\\} = B_{\\mu + 2} \\times B_{\\xi}<span class="math"> . Specifically, the permutations indicate that  </span>t_i^{(b)} = t_{\\sigma^{(b)}(\\langle i\\rangle)}^{\\rho^{(b)}(\\langle i\\rangle)}<span class="math">  for all  </span>i \\in [2^{\\mu}]<span class="math"> ,  </span>b \\in B_{\\xi}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A worker prover <span class="math">\\mathcal{P}_b</span> interpolates the following polynomials:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Two multilinear polynomials <span class="math">S_{\\mathrm{add}}^{(b)}, S_{\\mathrm{mult}}^{(b)} \\in \\mathbb{F}_{\\mu}^{\\leq 1}[\\mathbf{X}]</span> such that for all <span class="math">i \\in [N^{(b)}]</span> <span class="math">S_{\\mathrm{add}}^{(b)}(\\langle i \\rangle_{\\mu}) = s_i^{(b)}</span> and <span class="math">S_{\\mathrm{mult}}^{(b)}(\\langle i \\rangle_{\\mu}) = 1 - s_i^{(b)}</span>.</li>

      <li>A multilinear polynomial <span class="math">F^{(b)} \\in \\mathbb{F}_{\\mu + 2}^{\\leq 1}</span> such that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l l} F ^ {(b)} (0, 0, \\langle i \\rangle_ {\\mu}) = t _ {3 i + 1} ^ {(b)} &amp;amp; i \\in [ 0, N ^ {(b)} - 1 ] \\\\ F ^ {(b)} (0, 1, \\langle i \\rangle_ {\\mu}) = t _ {3 i + 2} ^ {(b)} &amp;amp; i \\in [ 0, N ^ {(b)} - 1 ] \\\\ F ^ {(b)} (1, 0, \\langle i \\rangle_ {\\mu}) = t _ {3 i + 3} ^ {(b)} &amp;amp; i \\in [ 0, N ^ {(b)} - 1 ] \\\\ F ^ {(b)} (1, \\ldots , 1, \\langle i \\rangle_ {\\nu}) = x _ {i + 1} ^ {(b)} &amp;amp; i \\in [ 0, \\ell_ {x} ^ {(b)} - 1 ] \\end{array} \\right.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A multilinear polynomial <span class="math">I^{(b)} \\in \\mathbb{F}_{\\mu^{(b)}}^{\\leq 1}[\\mathbf{X}]</span> such that for all <span class="math">i \\in [0, \\ell_x^{(b)} - 1]</span> we have <span class="math">I^{(b)}(\\langle i \\rangle_{\\nu^{(b)}}) = x_{i+1}^{(b)}</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Distributed multilinear KZG PCS.</strong> First, we introduce the distributed multilinear KZG PCS. This protocol enables us to commit and open a multilinear polynomial distributedly. For a multilinear polynomial <span class="math">f(\\pmb{x}, \\pmb{y}) = \\sum_{\\pmb{b} \\in B_{\\xi}} f^{(b)}(\\pmb{x}) \\chi_{\\pmb{b}}(\\pmb{y}) \\in \\mathbb{F}_{\\mu + \\xi}^{\\leq 1}[\\pmb{X}]</span>, the PCS protocol is described as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>KeyGen: Generate <span class="math">\\operatorname{crs} = (g, (g^{\\tau_i})_{i \\in [\\mu + \\xi]}, (U_{c,b} := g^{\\chi_c(\\tau_1, \\dots, \\tau_\\mu) \\cdot \\chi_b(\\tau_{\\mu + 1}, \\dots, \\tau_{\\mu + \\xi})})_{c \\in B_\\mu, b \\in B_\\xi})</span> where <span class="math">\\tau_1, \\ldots, \\tau_{\\mu + \\xi}</span> are secrets. Note that we can derive <span class="math">V_b := g^{\\chi_b(\\tau_{\\mu + 1}, \\dots, \\tau_{\\mu + \\xi})}</span> with <span class="math">\\operatorname{crs}</span>, which will be useful to <span class="math">\\mathcal{P}_0</span>, since <span class="math">\\sum_{c \\in B_\\mu} \\chi_c \\equiv 1</span>.</li>

      <li>Commit <span class="math">(f, \\mathrm{crs})</span>: each <span class="math">\\mathcal{P}_b</span> computes <span class="math">\\operatorname{com}_b := \\prod_{c \\in B_\\mu} U_{c,b}^{f^{(b)}(\\pmb{c})}</span> and sends <span class="math">\\operatorname{com}_b</span> to <span class="math">\\mathcal{P}_0</span>. Then <span class="math">\\mathcal{P}_0</span> computes <span class="math">\\operatorname{com} := \\prod_{b \\in B_\\xi} \\operatorname{com}_b</span>.</li>

      <li>Open <span class="math">(f, \\alpha, \\beta, \\mathrm{crs})</span>:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each prover <span class="math">\\mathcal{P}_b</span> computes <span class="math">z^{(b)} := f^{(b)}(\\alpha)</span> and <span class="math">f^{(b)}(\\pmb{x}) - f^{(b)}(\\pmb{\\alpha}) := \\sum_{i \\in [\\mu]} q_i^{(b)}(\\pmb{x})(x_i - \\alpha_i)</span>. Then it computes <span class="math">\\pi_i^{(b)} = g^{q_i^{(b)}(\\tau_1, \\dots, \\tau_\\mu) \\cdot \\chi_b(\\tau_{\\mu + 1}, \\dots, \\tau_{\\mu + \\xi})}</span> with crs, and sends <span class="math">\\pi^{(b)}</span> and <span class="math">z^{(b)}</span> to <span class="math">\\mathcal{P}_0</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}_0</span> computes <span class="math">z = f(\\alpha, \\beta) = \\sum_{b \\in B_\\xi} z^{(b)} \\cdot \\chi_b(\\beta)</span>. <span class="math">\\mathcal{P}_0</span> decomposes</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">f (\\boldsymbol {\\alpha}, \\boldsymbol {y}) - f (\\boldsymbol {\\alpha}, \\boldsymbol {\\beta}) = \\sum_ {j \\in [ \\xi ]} q _ {j} (\\boldsymbol {y}) (y _ {j} - \\beta_ {j}).</span></div>

    <p class="text-gray-300">Then it computes <span class="math">\\pi_{\\mu +j} = g^{q_j(\\tau_{\\mu +1},\\dots,\\tau_{\\mu +\\xi})}</span> with <span class="math">V_{b}</span>. <span class="math">\\mathcal{P}_0</span> also computes <span class="math">\\pi_i = \\prod_{b\\in B_\\xi}\\pi_i^{(b)}</span> for all <span class="math">i\\in [\\mu ]</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Then <span class="math">\\mathcal{P}_0</span> sends <span class="math">\\pi \\coloneqq (\\pi_1, \\dots, \\pi_{\\mu + \\xi})</span> and <span class="math">z</span> to <span class="math">\\mathcal{V}</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify <span class="math">(\\operatorname{com}, \\pi, \\alpha, \\beta, z, \\mathrm{crs})</span>: The verifier checks if <span class="math">e(\\operatorname{com} / g^z, g) = \\prod_{i \\in [\\mu]} e(\\pi_i, g^{\\tau_i - \\alpha_i}) \\cdot \\prod_{j \\in [\\xi]} e(\\pi_{\\mu + j}, g^{\\tau_{\\mu + j} - \\beta_j})</span>.</li>

    </ul>

    <p class="text-gray-300">Here we summarize the complexity of the distributed multilinear KZG PCS. The worker time is <span class="math">O(2^{\\mu})</span>, and the coordinator time is <span class="math">O(2^{\\xi} \\cdot \\mu)</span>. All provers will communicate <span class="math">O(\\mu + \\xi)</span> group elements. The verifier time is <span class="math">O(\\mu + \\xi)</span>.</p>

    <p class="text-gray-300"><strong>Proposition 1.</strong> The distributed multilinear KZG PCS is complete and sound.</p>

    <p class="text-gray-300"><strong>Proof.</strong> If <span class="math">\\pi</span> is honestly generated, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\prod_ {i \\in [ \\mu ]} e \\left(\\pi_ {i}, g ^ {\\tau_ {i} - \\alpha_ {i}}\\right) \\cdot \\prod_ {j \\in [ \\xi ]} e \\left(\\pi_ {\\mu + j}, g ^ {\\tau_ {\\mu + j} - \\beta_ {j}}\\right) \\\\ = e \\left(g ^ {\\sum_ {i \\in [ \\mu ]} \\sum_ {b \\in B _ {\\xi}} q _ {i} ^ {(b)} \\left(\\tau_ {1}, \\dots , \\tau_ {\\mu}\\right) \\cdot \\left(\\tau_ {i} - \\alpha_ {i}\\right)}, g\\right) \\\\ \\cdot e \\left(g ^ {\\sum_ {j \\in [ \\xi ]} q _ {j} \\left(\\tau_ {\\mu + 1}, \\dots , \\tau_ {\\mu + \\xi}\\right) \\cdot \\left(\\tau_ {\\mu + j} - \\beta_ {j}\\right)}, g\\right) \\\\ = e \\left(g ^ {f (\\boldsymbol {\\tau}) - f (\\boldsymbol {\\alpha}, \\boldsymbol {\\beta})}, g\\right) \\end{array}</span></div>

    <p class="text-gray-300">Therefore, the protocol is complete. We kindly refer to [25] for a full proof of the soundness and knowledge soundness of the multilinear KZG protocol.</p>

    <p class="text-gray-300"><strong>Distributed multivariate SumCheck Poly-IOP.</strong> Here we describe the distributed multivariate SumCheck Poly-IOP. Suppose each prover <span class="math">\\mathcal{P}_b</span> has a multivariate polynomial <span class="math">f^{(b)} \\in \\mathbb{F}_{\\mu}[\\mathbf{X}]</span>. The provers want to show to the verifier that a multivariate polynomial <span class="math">f(\\mathbf{x}) \\coloneqq h(g_1(\\mathbf{x}), \\ldots, g_c(\\mathbf{x})) \\in \\mathbb{F}_{\\mu + \\xi}[\\mathbf{X}]</span> satisfies <span class="math">\\sum_{\\mathbf{x} \\in B_{\\mu + \\xi}} f(\\mathbf{x}) = v</span>, where each <span class="math">g_i</span> is multilinear and <span class="math">h</span> can be evaluated using a arithmetic circuit with <span class="math">O(d)</span> gates. Suppose each prover <span class="math">\\mathcal{P}_b</span> has access to <span class="math">g_i^{(b)}</span> for <span class="math">i \\in [c]</span>, where <span class="math">g_i^{(b)}(\\mathbf{y}) = g_i(\\mathbf{y}, b)</span>. We further define <span class="math">f^{(b)}(\\mathbf{y}) = f(\\mathbf{y}, b) = h\\left(g_1^{(b)}(\\mathbf{y}), \\ldots, g_c^{(b)}(\\mathbf{y})\\right)</span>. The protocol is described as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i \\in [\\mu]</span>:</li>

    </ol>

    <p class="text-gray-300">a) Let <span class="math">\\alpha_{i - 1} = (\\alpha_{1},\\ldots ,\\alpha_{i - 1})</span> b) Each <span class="math">\\mathcal{P}_b</span> computes and sends to <span class="math">\\mathcal{P}_0</span> the polynomial <span class="math">r_i^{(b)}(x) \\coloneqq \\sum_{\\boldsymbol{w} \\in B_{\\mu - i}} f^{(b)}(\\boldsymbol{\\alpha}_{i - 1}, x, \\boldsymbol{w})</span>. c) Then <span class="math">\\mathcal{P}_0</span> adds</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} r _ {i} := \\sum_ {\\boldsymbol {b} \\in B _ {\\xi}} r _ {i} ^ {(\\boldsymbol {b})} = \\sum_ {\\boldsymbol {b} \\in B _ {\\xi}, \\boldsymbol {w} \\in B _ {\\mu - i}} f ^ {(\\boldsymbol {b})} (\\boldsymbol {\\alpha} _ {i - 1}, x, \\boldsymbol {w}) \\\\ = \\sum_ {\\boldsymbol {w} \\in B _ {\\mu - i}} \\sum_ {\\boldsymbol {b} \\in B _ {\\xi}} f (\\boldsymbol {\\alpha} _ {i - 1}, x, \\boldsymbol {w}, \\boldsymbol {b}) \\end{array}</span></div>

    <p class="text-gray-300">and sends the oracle of <span class="math">r_i</span> to <span class="math">\\mathcal{V}</span>.</p>

    <p class="text-gray-300">d) <span class="math">\\mathcal{V}</span> checks if <span class="math">v = r_{i}(0) + r_{i}(1)</span>, and samples and sends to <span class="math">\\mathcal{P}_0</span> a random <span class="math">\\alpha_{i} \\gets \\mathbb{F}</span>. Then <span class="math">\\mathcal{V}</span> sets <span class="math">v := r_{i}(\\alpha_{i})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\alpha = (\\alpha_{1},\\ldots ,\\alpha_{\\mu})</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}_0</span> receives <span class="math">g_i^{(b)}(\\alpha)</span> for <span class="math">i \\in [c]</span> from each <span class="math">\\mathcal{P}_b</span>. <span class="math">\\mathcal{P}_0</span> first construct</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\tilde {g} _ {i} (\\boldsymbol {y}) := g (\\boldsymbol {\\alpha}, \\boldsymbol {y}) = \\sum_ {\\boldsymbol {b} \\in B _ {\\mu}} g _ {i} (\\boldsymbol {\\alpha}, \\boldsymbol {b}) \\chi_ {\\boldsymbol {b}} (\\boldsymbol {y}) \\\\ = \\sum_ {\\boldsymbol {b} \\in B _ {\\mu}} g _ {i} ^ {(\\boldsymbol {b})} (\\boldsymbol {\\alpha}) \\chi_ {\\boldsymbol {b}} (\\boldsymbol {y}) \\end{array}</span></div>

    <p class="text-gray-300">Then <span class="math">\\mathcal{P}_0</span> has <span class="math">\\tilde{f} (\\pmb {y}) = f(\\pmb {\\alpha},\\pmb {y}) = h\\left(\\tilde{g}_1(\\pmb {y}),\\dots ,\\tilde{g}_c(\\pmb {y})\\right)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}_0</span> and <span class="math">\\mathcal{V}</span> perform Multivariate SumCheck on <span class="math">\\tilde{f}</span> with target value <span class="math">v</span>. Denote the challenge as <span class="math">\\beta</span>. Note that in the final round, the verifier queries <span class="math">g_i(\\alpha, \\beta)</span> for <span class="math">i \\in [c]</span> and calculates <span class="math">f(\\alpha, \\beta)</span> itself.</li>

    </ol>

    <p class="text-gray-300">We give an example of how to perform SumCheck with <span class="math">f^{(b)} = f_1^{(b)} \\cdot f_2^{(b)}</span>, to illustrate the sum-check protocol on <span class="math">h(f_1, f_2, \\ldots, f_k)</span>. In Step 3, <span class="math">\\mathcal{P}_b</span> opens <span class="math">f^{(b)}</span>, and compute <span class="math">g(\\pmb{y}) := \\sum_{\\pmb{b} \\in B_\\xi} (v_1^{(b)} \\cdot \\chi_b(\\pmb{y})) \\cdot \\sum_{\\pmb{b} \\in B_\\xi} (v_2^{(b)} \\cdot \\chi_b(\\pmb{y}))</span>. In Step 4, <span class="math">\\mathcal{V}</span> and the provers open <span class="math">f_1(\\alpha, \\beta) \\cdot f_2(\\alpha, \\beta)</span> at the end.</p>

    <p class="text-gray-300">We summarize the complexity of the distributed multivariate SumCheck Poly-IOP. The worker time is <span class="math">O(2^{\\mu} \\cdot d \\log^{2} d)</span>, and the coordinator time is <span class="math">O(2^{\\xi} \\cdot d \\log^{2} d + \\mu \\cdot 2^{\\xi} \\cdot d)</span>. All provers will communicate <span class="math">O((\\mu + \\xi) \\cdot d)</span> field elements. The verifier time is <span class="math">O((\\mu + \\xi) \\cdot d)</span>.</p>

    <p class="text-gray-300"><strong>Proposition 2.</strong> The distributed multivariate SumCheck protocol is complete and sound.</p>

    <p class="text-gray-300"><strong>Proof.</strong> If all workers and the coordinator are honest, in step 1 we have</p>

    <div class="my-4 text-center"><span class="math-block">r _ {i} (0) + r _ {i} (1) = \\sum_ {\\boldsymbol {w} \\in B _ {\\mu - i + 1}} \\sum_ {\\boldsymbol {b} \\in B _ {\\xi}} f (\\boldsymbol {\\alpha} _ {i - 1}, \\boldsymbol {w}, \\boldsymbol {b}) = v _ {i},</span></div>

    <p class="text-gray-300">so the verifier check will pass. In step 4, by the completeness of the SumCheck protocol, the verifier check will pass. Therefore, the protocol is complete. In step 3 we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\forall \\boldsymbol {y} \\in B _ {\\xi}, \\quad \\tilde {f} (\\boldsymbol {y}) = h \\left(\\tilde {g} _ {1} (\\boldsymbol {y}), \\dots , \\tilde {g} _ {c} (\\boldsymbol {y})\\right) \\\\ \\equiv \\sum_ {\\boldsymbol {b} \\in B _ {\\xi}} h \\left(g _ {1} ^ {(\\boldsymbol {b})} (\\boldsymbol {y}), \\dots , g _ {c} ^ {(\\boldsymbol {b})} (\\boldsymbol {y})\\right) \\cdot \\chi_ {\\boldsymbol {b}} (\\boldsymbol {y}) = f (\\boldsymbol {\\alpha}, \\boldsymbol {y}). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Therefore, we have the target <span class="math">v</span> at the end of step 1 is consistent with the target at the beginning of step 4. Following the soundness of the SumCheck protocol, the distributed multivariate SumCheck protocol is sound.</p>

    <p class="text-gray-300"><strong>Distributed multivariate ZeroTest Poly-IOP.</strong> Suppose each prover <span class="math">\\mathcal{P}_b</span> has a multivariate polynomial <span class="math">f^{(b)}(\\pmb {x})\\in \\mathbb{F}_{\\mu}^{\\leq d}[\\pmb {X}]</span>. The provers wants to show to the verifier that <span class="math">f^{(b)}(\\pmb {x}) = 0</span> for all <span class="math">\\pmb {b}\\in B_{\\xi}</span> and <span class="math">\\pmb {x}\\in B_{\\mu}</span>. The protocol is described as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> samples and sends to <span class="math">\\mathcal{P}_0</span> two random vectors <span class="math">\\pmb {r} \\gets \\mathbb{F}^{\\mu}</span> and <span class="math">\\pmb{r}_0 \\gets \\mathbb{F}^\\xi</span>.</li>

      <li><span class="math">\\mathcal{P}_0</span> sends <span class="math">\\pmb{r}</span> to each <span class="math">\\mathcal{P}_b</span>. Note that when we apply the Fiat-Shamir heuristic to make the argument non-interactive, communication in this step is no longer needed.</li>

      <li>Each <span class="math">\\mathcal{P}_b</span> sets <span class="math">\\tilde{f}^{(b)}(\\pmb {x})\\coloneqq f^{(b)}(\\pmb {x})\\cdot \\chi_r(\\pmb {x})\\cdot \\chi_{r_0}(\\pmb {b}).</span></li>

      <li>The provers and <span class="math">\\mathcal{V}</span> run distributed multivariate SumCheck protocol on <span class="math">\\tilde{f}^{(b)}(\\pmb {x})</span> with target value 0.</li>

    </ol>

    <p class="text-gray-300">To improve the efficiency of the protocol, the verifier has oracle access to <span class="math">f(x,y) \\coloneqq \\sum_{\\pmb{b} \\in B_{\\xi}} f^{(b)}(\\pmb{x}) \\cdot \\chi_{\\pmb{b}}(\\pmb{y})</span> and knows <span class="math">\\chi_{\\pmb{r}}(\\pmb{x}) \\cdot \\chi_{\\pmb{r}_0}(\\pmb{y})</span>. In Step 4 of SumCheck, <span class="math">\\mathcal{P}_0</span> will evaluate <span class="math">\\chi_{\\pmb{r}_0}(\\pmb{y})</span> over the boolean hypercube <span class="math">B_{\\xi}</span> using dynamic programming techniques [6] and then add them up. Since <span class="math">\\mathcal{V}</span> has oracle access to <span class="math">f</span> and can efficiently evaluate <span class="math">\\chi_{\\pmb{r}}(\\pmb{x}) \\cdot \\chi_{\\pmb{r}_0}(\\pmb{y})</span> at a random point in <span class="math">O(\\mu + \\xi)</span> time, the protocol is succinct.</p>

    <p class="text-gray-300"><strong>Proposition 3.</strong> The distributed multivariate ZeroTest Poly-IOP presented above is complete and sound.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> Let <span class="math">F(x, y) \\coloneqq \\sum_{\\pmb{b} \\in B_{\\xi}, \\pmb{c} \\in B_{\\mu}} f^{(b)}(\\pmb{c}) \\cdot \\chi_{\\pmb{c}}(\\pmb{x}) \\cdot \\chi_{\\pmb{b}}(\\pmb{y})</span>. If <span class="math">f^{(b)}(\\pmb{c})</span> is identically zero for all <span class="math">\\pmb{b} \\in B_{\\xi}</span> and <span class="math">\\pmb{c} \\in B_{\\mu}</span>, <span class="math">F</span> is identically zero, therefore, <span class="math">F(\\pmb{r}, \\pmb{r}_0) = 0</span> and the SumCheck will always pass. Therefore, the protocol is complete. On the other hand, if <span class="math">F</span> is not identically zero, by Schwartz-Zippel lemma <span class="math">F(\\pmb{r}, \\pmb{r}_0) = 0</span> holds w.p. at most $(\\mu + \\xi)d /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, which is negligible. Therefore, the protocol is also sound.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Distributed multivariate PermTest Poly-IOP.</strong> Let <span class="math">\\sigma^{(b)}: B_{\\mu} \\to B_{\\mu}</span> and <span class="math">\\rho^{(b)}: B_{\\mu} \\to B_{\\xi}</span> be two mappings such that <span class="math">\\{(\\sigma^{(b)}(\\pmb{c}), \\rho^{(b)}(\\pmb{c})): \\pmb{c} \\in B_{\\mu}, \\pmb{b} \\in B_{\\xi}\\} = B_{\\mu} \\times B_{\\xi}</span>.</p>

    <p class="text-gray-300">Each prover <span class="math">\\mathcal{P}_b</span> has a multivariate polynomial <span class="math">f^{(b)} \\in \\mathbb{F}_{\\mu}^{\\leq d}[\\pmb{X}]</span>. The provers want to show to the verifier that <span class="math">f^{(b)}(\\pmb{c}) = f^{(\\rho^{(b)}(\\pmb{c}))}(\\sigma^{(b)}(\\pmb{c}))</span> for all <span class="math">\\pmb{b} \\in B_{\\xi}</span> and <span class="math">\\pmb{c} \\in B_{\\mu}</span>. Here we introduce the protocol in the more complicated case where <span class="math">\\rho^{(b)}(\\pmb{c})</span> is not identically <span class="math">\\pmb{b}</span> for all <span class="math">\\pmb{c} \\in B_{\\mu}</span>.</p>

    <p class="text-gray-300">We define the multivariate polynomials <span class="math">s, s_{\\mu}^{(b)}, s_{\\xi}^{(b)} \\in \\mathbb{F}_{\\mu}^{\\leq 1}[\\pmb{X}]</span> where <span class="math">s(\\pmb{x}) \\coloneqq [\\pmb{x}]</span>, <span class="math">s_{\\mu}^{(b)}(\\pmb{x}) \\coloneqq [\\sigma^{(b)}(\\pmb{x})]</span> and <span class="math">s_{\\xi}^{(b)}(\\pmb{x}) \\coloneqq [\\rho^{(b)}(\\pmb{x})]</span>. The protocol then goes as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> samples and sends to the coordinator <span class="math">\\gamma_{\\mu},\\gamma_{\\xi},\\delta \\gets \\mathbb{F}</span></li>

      <li>Let <span class="math">f_{1}^{(b)}(\\pmb{x}) \\coloneqq f^{(b)}(\\pmb{x}) + \\gamma_{\\mu} \\cdot s(\\pmb{x}) + \\gamma_{\\xi} \\cdot [\\pmb{b}] + \\delta</span> and <span class="math">f_{2}^{(b)}(\\pmb{x}) \\coloneqq f^{(b)}(\\pmb{x}) + \\gamma_{\\mu} \\cdot s_{\\mu}^{(b)}(\\pmb{x}) + \\gamma_{\\xi} \\cdot s_{\\xi}^{(b)}(\\pmb{x}) + \\delta</span>. Each prover <span class="math">\\mathcal{P}_b</span> builds a multilinear polynomial <span class="math">z^{(b)} \\in \\mathbb{F}_{\\mu + 1}^{\\leq 1}[\\pmb{X}]</span> such that for all <span class="math">\\pmb{x} \\in B_{\\mu}</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} z ^ {(b)} (0, \\boldsymbol {x}) = f _ {1} ^ {(b)} (\\boldsymbol {x}) / f _ {2} ^ {(b)} (\\boldsymbol {x}) \\\\ z ^ {(b)} (1, \\boldsymbol {x}) = z ^ {(b)} (\\boldsymbol {x}, 0) \\cdot z ^ {(b)} (\\boldsymbol {x}, 1), \\boldsymbol {x} \\neq \\mathbf {1} \\\\ z ^ {(b)} (1, \\mathbf {1}) = 0 \\end{array} \\right.</span></div>

    <p class="text-gray-300">Let <span class="math">w_{1}^{(b)}(\\pmb{x}) \\coloneqq z^{(b)}(1, \\pmb{x}) - z^{(b)}(\\pmb{x}, 0) \\cdot z^{(b)}(\\pmb{x}, 1)</span> and <span class="math">w_{2}^{(b)}(\\pmb{x}) \\coloneqq f_{2}^{(b)}(\\pmb{x}) \\cdot z^{(b)}(0, \\pmb{x}) - f_{1}^{(b)}(\\pmb{x})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each <span class="math">\\mathcal{P}_b</span> sends <span class="math">z^{(b)} \\coloneqq z^{(b)}(1,1,\\ldots,1,0)</span> to <span class="math">\\mathcal{P}_0</span>. We have <span class="math">\\prod_{\\pmb{b} \\in B_\\mu} z^{(b)} = 1</span>. Then <span class="math">\\mathcal{P}_0</span> interpolates a multilinear polynomial <span class="math">z \\in \\mathbb{F}_{\\xi + 1}^{\\leq 1}[\\pmb{X}]</span> such that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} z (0, \\boldsymbol {y}) = z ^ {(\\boldsymbol {y})} \\\\ z (1, \\boldsymbol {y}) = z (\\boldsymbol {y}, 0) \\cdot z (\\boldsymbol {y}, 1) \\end{array} \\right.</span></div>

    <p class="text-gray-300">Let <span class="math">w_{3}(\\pmb{y}) \\coloneqq z(1, \\pmb{y}) - z(\\pmb{y}, 0) \\cdot z(\\pmb{y}, 1)</span> and <span class="math">w_{4}^{(b)}(\\pmb{x}) \\coloneqq z(0, \\pmb{b}) - z^{(b)}(\\pmb{x}, 0) \\cdot \\chi_{(1,1,\\dots,1,0)}(\\pmb{x}, 0)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The provers and <span class="math">\\mathcal{V}</span> run distributed multivariate ZeroTest on <span class="math">\\{w_1^{(b)}\\}</span>, <span class="math">\\{w_2^{(b)}\\}</span> and <span class="math">\\{w_4^{(b)}\\}</span>. <span class="math">\\mathcal{P}_0</span> and <span class="math">\\mathcal{V}</span> run multivariate ZeroTest on <span class="math">w_3</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Proposition 4.</strong> The distributed PermTest protocol is complete and sound.</p>

    <p class="text-gray-300"><strong>Proof.</strong> The completeness and soundness of PermTest directly follow the completeness and soundness of ZeroTest.</p>

    <p class="text-gray-300"><strong>Distributed HyperPlonk Poly-IOP.</strong> We construct a distributed HyperPlonk Poly-IOP as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input Constraint: <span class="math">\\mathcal{V}</span> ensures that <span class="math">F^{(b)}(1,\\ldots,1,\\bm{x})-I^{(b)}(\\bm{x})=0</span> for all <span class="math">\\bm{x}\\in B_{\\nu}</span> and <span class="math">\\bm{b}\\in B_{\\xi}</span> with distributed multilinear ZeroTest.</li>

      <li>Output Constraint: <span class="math">\\mathcal{V}</span> queries <span class="math">F^{(1,\\ldots,1)}(1,0,\\langle N^{(b)}-1\\rangle_{\\mu})</span> and checks if it is zero.</li>

      <li>Gate Constraint: Define a multivariate polynomial</li>

    </ul>

    <p class="text-gray-300"><span class="math">G^{(b)}(\\bm{x}):=S_{\\text{add}}^{(b)}(\\bm{x})(F^{(b)}(0,0,\\bm{x})+F^{(b)}(0,1,\\bm{x}))+</span> <span class="math">S_{\\text{mult}}^{(b)}(\\bm{x})(F^{(b)}(0,0,\\bm{x})\\cdot F^{(b)}(0,1,\\bm{x}))-F^{(b)}(1,0,\\bm{x}).</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> checks that <span class="math">G^{(b)}(\\bm{x})=0</span> for all <span class="math">\\bm{x}\\in B_{\\mu}</span> and <span class="math">\\bm{b}\\in B_{\\xi}</span> with distributed multivariate ZeroTest.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Wiring Constraint: <span class="math">\\mathcal{V}</span> verifies that <span class="math">F^{(b)}(\\bm{x})=F^{(\\rho^{(b)}(\\bm{x}))}(\\sigma^{(b)}(\\bm{x}))</span> for all <span class="math">\\bm{x}\\in B_{\\mu+2}</span> and <span class="math">\\bm{b}\\in B_{\\xi}</span> with distributed multivariate PermTest.</li>

    </ul>

    <p class="text-gray-300">Batch openings. Batch opening is a technique introduced in <em>[8, 3]</em> that reduces prover and verifier time. It is especially useful since the practical bottleneck for the prover and the verifier is polynomial opening which are primarily group exponentiations, instead of field operations. Here we introduce the distributed batch opening protocol.</p>

    <p class="text-gray-300">Assume there are <span class="math">2^{\\rho}</span> distributed polynomials <span class="math">\\{f_{\\bm{v}}^{(b)}\\}_{\\bm{v}\\in B_{\\rho},\\bm{b}\\in B_{\\xi}}</span>, and <span class="math">2^{\\rho}</span> evaluation points <span class="math">\\{(\\alpha_{\\bm{v}},\\beta_{\\bm{v}})\\}_{\\bm{v}\\in B_{\\rho}}</span>, with opening values <span class="math">\\{z_{\\bm{v}}\\}_{\\bm{v}\\in B_{\\rho}}</span>. Then the distributed batch opening and verification protocol is described as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier <span class="math">\\mathcal{V}</span> samples and sends to <span class="math">\\mathcal{P}_{0}\\ \\bm{t}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}^{\\rho}$.</li>

      <li><span class="math">\\mathcal{V}</span> computes the target sum <span class="math">s:=\\sum_{\\bm{v}\\in B_{\\rho}}\\chi_{\\bm{v}}(\\bm{t})\\cdot z_{\\bm{v}}</span>.</li>

      <li>Each worker <span class="math">\\mathcal{P}_{\\bm{b}}</span> defines a multilinear polynomial <span class="math">g^{(b)}(\\bm{v},\\bm{c}):=\\chi_{\\bm{v}}(\\bm{t})\\cdot f_{\\bm{v}}^{(b)}(\\bm{c})</span> for all <span class="math">\\bm{c}\\in B_{\\mu}</span> and <span class="math">\\bm{v}\\in B_{\\rho}</span>.</li>

      <li>Each worker <span class="math">\\mathcal{P}_{\\bm{b}}</span> defines a multilinear polynomial <span class="math">h^{(b)}(\\bm{v},\\bm{c}):=\\chi_{\\bm{c}}(\\bm{\\alpha}_{\\bm{v}})\\cdot\\chi_{\\bm{b}}(\\bm{\\beta}_{\\bm{v}})</span> for all <span class="math">\\bm{c}\\in B_{\\mu}</span> and <span class="math">\\bm{v}\\in B_{\\rho}</span>.</li>

      <li>The provers and <span class="math">\\mathcal{V}</span> runs a distributed multivariate SumCheck protocol for <span class="math">\\{g^{(b)}\\cdot h^{(b)}\\}</span> with target <span class="math">s</span>.</li>

    </ul>

    <h6 id="sec-12" class="text-base font-medium mt-4">Proposition 5.</h6>

    <p class="text-gray-300">The distributed batch opening protocol previously presented is sound, if the distributed SumCheck and KZG PCS are sound.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The soundness of the protocol depends on the soundness of the distributed SumCheck Proposition 2. Note that <span class="math">s=\\sum_{\\bm{b}\\in B_{\\xi},\\bm{v}\\in B_{\\rho},\\bm{c}\\in b_{\\rho}}g^{(b)}(\\bm{v},\\bm{c})\\cdot h^{(b)}(\\bm{v},\\bm{c})</span> is the same equality that the soundness of the batch opening protocol in HyperPlonk relies on. Since the vanilla batch opening protocol is sound, the distributed batch opening protocol is sound. ∎</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">V-B Efficient Accountability Protocol</h3>

    <p class="text-gray-300">Up to this point, our protocol does not yet ensure accountability. A straightforward but naive approach to accountability would require the coordinator to verify all intermediate results by independently recomputing every step of each worker’s computation. However, this naive solution incurs prohibitive computational and storage overhead, making it impractical for large-scale circuits.</p>

    <p class="text-gray-300">We observe that it is unnecessary for the coordinator to verify all intermediate computations immediately. Instead, the coordinator can optimistically defer these checks until the final aggregated proof is available, running only the verifier’s check at the end. The soundness property of the distributed SNARK protocol ensures that any incorrect proof will indicate at least one malicious worker. If the verification fails, the coordinator can then retrospectively examine all communications and intermediate computations performed by each worker to pinpoint the malicious parties. We refer to this deferred verification approach as an <em>optimistic check</em>.</p>

    <p class="text-gray-300">One remaining challenge is to significantly reduce the computational cost of the optimistic check in cases when malicious behavior is detected. Our key insight is that accountability can be efficiently enforced by splitting the verification into two clearly defined stages:</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Stage 1: Verifying polynomial openings.</h4>

    <p class="text-gray-300">In the first stage, the coordinator checks the correctness of separate polynomial opening proofs submitted by each worker. Specifically, recall that in the distributed multilinear KZG PCS protocol, each worker prover <span class="math">\\mathcal{P}_{\\bm{b}}</span> sends an opening proof <span class="math">\\bm{\\pi}^{(b)}</span> to the coordinator. The coordinator can verify these openings by checking the pairing equation:</p>

    <p class="text-gray-300"><span class="math">e(\\text{com}_{f^{(b)}},g)\\cdot e(g^{-z^{(b)}},V_{\\bm{b}})\\stackrel{{\\scriptstyle\\scriptscriptstyle 2}}{{=}}\\prod_{i\\in[\\mu]}e(\\pi^{(b)}_{i},g^{\\tau_{i}-\\alpha_{i}}).</span></p>

    <p class="text-gray-300">If this check fails, the coordinator immediately identifies the corresponding prover as malicious.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Stage 2: Verifying witness polynomials.</h4>

    <p class="text-gray-300">If all polynomial opening proofs from workers verify correctly but the final proof still fails, we prove in Proposition 6 that with overwhelming probability at least one worker has committed to an incorrect witness polynomial <span class="math">F^{(b)}</span>. Therefore, the coordinator must pinpoint the worker who constructed this incorrect polynomial.</p>

    <p class="text-gray-300">To achieve this efficiently, we leverage the fact that all parties, including the coordinator, already perform a plaintext evaluation of the entire circuit at the start of the distributed proof generation. Therefore, the coordinator can store evaluations of each worker’s witness polynomial <span class="math">F^{(b)}</span> over <span class="math">B_{\\mu}</span> for all <span class="math">\\bm{b}\\in B_{\\xi}</span> at no additional computational overhead.</p>

    <p class="text-gray-300">Recall that in step 3 of the distributed SumCheck protocol, each worker sends the evaluation <span class="math">F^{(b)}(\\bm{r})</span> at a random point <span class="math">\\bm{r}</span> chosen by the coordinator. Therefore, the coordinator only needs to record the randomness <span class="math">\\bm{r}</span> and locally compute <span class="math">F^{(b)}(\\bm{r})</span> for each worker, comparing it with the evaluation reported by the worker. Any discrepancy indicates a malicious worker.</p>

    <p class="text-gray-300">Overall, our two-stage accountability protocol efficiently detects malicious behavior without requiring the coordinator to recompute the entire distributed proof. Furthermore, this accoutability protocol does not require the coordinator to</p>

    <p class="text-gray-300">communicate with workers. Here we analyze in detail the cost of the protocol for the coordinator. In the first stage, the coordinator verifies <span class="math">O(M)</span> polynomial opening proofs, each of length <span class="math">\\mu</span>, resulting in a total overhead of <span class="math">O(M\\log T)</span> pairing operations. In the second stage, the coordinator evaluates <span class="math">O(M)</span> multilinear polynomials, each with <span class="math">\\mu</span> variables, incurring <span class="math">O(MT)=O(N)</span> field operations. In Section IV, we empirically demonstrate that this accountability protocol introduces minimal overhead and performs efficiently.</p>

    <p class="text-gray-300">Our efficient accountability protocol is detailed as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The coordinator (<span class="math">\\mathcal{P}_{0}</span>) first verifies the final distributed polynomial opening. If this verification passes, no further action is required. If it fails, the coordinator proceeds to identify malicious workers through a two-stage verification process:</li>

      <li>Stage 1: Verifying polynomial openings. For each prover <span class="math">\\mathcal{P}_{b}</span>, let <span class="math">\\boldsymbol{\\pi}^{(b)}</span> denote the polynomial opening proof submitted during the distributed polynomial commitment opening protocol. The coordinator verifies: <span class="math">e(\\mathsf{com}_{f^{(b)}},g)\\cdot e(g^{-z^{(b)}},V_{b})=\\prod_{i\\in[\\mu]}e(\\pi_{i}^{(b)},g^{\\tau_{i}-\\alpha_{i}})</span>. Any prover <span class="math">\\mathcal{P}_{b}</span> whose verification fails at this step is immediately identified as malicious.</li>

      <li>Stage 2: Verifying witness polynomial evaluations. If all polynomial openings verify correctly in Stage 1, the coordinator checks for discrepancies in witness polynomial evaluations. Let <span class="math">F^{(b)}</span> denote the witness polynomial for the subcircuit indexed by <span class="math">b</span>, and let <span class="math">r</span> be the randomness used in step 3 of the distributed SumCheck protocol. Each prover <span class="math">\\mathcal{P}_{b}</span> previously sent the evaluation <span class="math">F^{(b)}(r)</span> to the coordinator. The coordinator independently evaluates each polynomial <span class="math">F^{(b)}</span> at point <span class="math">r</span> using the correct witness data it holds and compares the results. Any discrepancy identifies the worker <span class="math">\\mathcal{P}_{b}</span> as malicious.</li>

    </ol>

    <p class="text-gray-300">We show the correctness of this protocol with the following proposition.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Proposition 6.</h6>

    <p class="text-gray-300">If the final proof sent to the verifier cannot verify, in the accountability protocol described above, an honest coordinator can identify at least one malicious worker with overwhelming probability.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Assume the coordinator is honest and the final aggregated proof sent to the verifier fails to verify. Let the set of workers be <span class="math">\\{\\mathcal{P}_{b}\\}_{b\\in B_{\\xi}}</span>.</p>

    <p class="text-gray-300">During Stage 1 each worker <span class="math">\\mathcal{P}_{b}</span> supplies an opening proof <span class="math">\\boldsymbol{\\pi}^{(b)}</span> for the commitment <span class="math">\\mathsf{com}_{f^{(b)}}</span>. Then the coordinator checks</p>

    <p class="text-gray-300"><span class="math">e(\\mathsf{com}_{f^{(b)}},g)\\cdot e(g^{-z^{(b)}},V_{b})=\\prod_{i\\in[\\mu]}e(\\pi_{i}^{(b)},\\,g^{\\tau_{i}-\\alpha_{i}}).</span></p>

    <p class="text-gray-300">By the soundness of the KZG PCS, an incorrect opening passes this check with only negligible probability. If the check fails, the corresponding <span class="math">\\mathcal{P}_{b}</span> must be malicious.</p>

    <p class="text-gray-300">Suppose every worker passes Stage 1. Note that only the witness polynomial <span class="math">F^{(b)}</span> is committed by each worker instead of preprocessed. Then each commitment <span class="math">\\mathsf{com}_{f^{(b)}}</span> corresponds to <em>some</em> degree-bounded polynomial <span class="math">F^{(b)}</span>, and the opening value <span class="math">z^{(b)}</span> is consistent with that commitment. By completeness of the distributed <span class="math">\\mathsf{PermTest}+\\mathsf{SumCheck}</span> system, this can only happen if at least one <span class="math">F^{(b)}</span> is not the <em>correct</em> witness polynomial <span class="math">F^{(b)}_{\\mathrm{true}}</span>.</p>

    <p class="text-gray-300">Because the (incorrect) commitment was fixed <em>before</em> the challenge point <span class="math">r</span> was chosen, by Schwartz-Zippel lemma</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\big{[}F^{(b)}(r)=F^{(b)}_{\\mathrm{true}}(r)\\big{]}\\leq\\frac{\\deg(F^{(b)}_{\\mathrm{true}})}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">which is negligible. In Stage 2 the coordinator recomputes <span class="math">F^{(b)}_{\\mathrm{true}}(r)</span> from the stored plaintext circuit evaluation and compares it to the worker’s reported <span class="math">F^{(b)}(r)</span>. Any discrepancy exposes <span class="math">\\mathcal{P}_{b}</span> as malicious.</p>

    <p class="text-gray-300">Since the failure probability in each stage is negligible, an honest coordinator identifies at least one malicious worker with overwhelming probability. ∎</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">V-C Hierarchical aggregation</h3>

    <p class="text-gray-300">By far, we have achieved linear prover time for each worker. However, we still have a coordinator time of <span class="math">O(M\\log T)</span>, <span class="math">T</span> being the size of each sub-circuit, and <span class="math">M</span> being the number of worker nodes. In this part, we discuss how to eliminate the <span class="math">(\\log T)</span> term while maintaining the accountability property.</p>

    <p class="text-gray-300">We note that the coordinator’s work of summing up group or field elements in distributed SumCheck and distributed KZG can be distributed. However, naively distributing this step (e.g., having each node add one element) could introduce a larger round complexity. Instead, only a subset of nodes is required for computing. We demonstrate this idea with the following example. Suppose each node has <span class="math">A</span> elements, and the coordinator would finally need to get the sum of all elements. We divide the <span class="math">M</span> nodes into <span class="math">k</span> groups and select a leader of each group. In the first round, the leader in each group adds up all <span class="math">MA/k</span> elements in its group. In the second round, the coordinator adds up <span class="math">k</span> elements from the leaders. The cost of the leader of each group is <span class="math">O(MA/k)</span>, and the cost of the coordinator is <span class="math">O(k)</span>. In our case, when choosing <span class="math">k=\\log(T)</span> we end up with a <span class="math">O(M)</span> coordinator cost and the same worker cost as before for the leaders, as their previous cost dominates this extra computation.</p>

    <p class="text-gray-300">In the following paragraphs, we introduce the modified protocols with hierarchical aggregation. The modified protocol steps are highlighted in blue.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Distributed KZG PCS with hierarchical aggregation.</h4>

    <p class="text-gray-300">For a multilinear polynomial <span class="math">f(\\boldsymbol{x},\\boldsymbol{y})=\\sum_{\\boldsymbol{b}\\in B_{\\xi}}f^{(b)}(\\boldsymbol{x})\\chi_{\\boldsymbol{b}}(\\boldsymbol{y})</span>, the PCS protocol is described as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>KeyGen, Commit<span class="math">(f,\\mathsf{crs})</span>, Verify<span class="math">(\\mathsf{com},\\boldsymbol{\\pi},\\boldsymbol{\\alpha},\\boldsymbol{\\beta},z,\\mathsf{crs})</span>: Same as the previous protocol.</li>

      <li>Open<span class="math">(f,\\boldsymbol{\\alpha},\\boldsymbol{\\beta},\\mathsf{crs})</span>:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Divide nodes into groups of size <span class="math">\\log T</span>. The coordinator randomly select one leader out of each group.</li>

      <li>Each prover <span class="math">\\mathcal{P}_{\\bm{b}}</span> computes <span class="math">z^{(\\bm{b})}:=f^{(\\bm{b})}(\\bm{\\alpha})</span> and <span class="math">f^{(\\bm{b})}(\\bm{x})-f^{(\\bm{b})}(\\bm{\\alpha}):=\\sum_{i\\in[\\mu]}q_{i}^{(\\bm{b})}(\\bm{x})(x_{i}-\\alpha_{i})</span>. Then it computes <span class="math">\\pi_{i}^{(\\bm{b})}=g^{q_{i}^{(\\bm{b})}(\\tau_{1},\\ldots,\\tau_{\\mu})\\cdot\\chi_{\\bm{b}}(\\tau_{\\mu+1},\\ldots,\\tau_{\\mu+\\xi})}</span> using the crs. <span class="math">\\mathcal{P}_{\\bm{b}}</span> sends <span class="math">(\\bm{\\pi}^{(\\bm{b})},z^{(\\bm{b})})</span> to both leader of its group and <span class="math">\\mathcal{P}_{0}</span>.</li>

      <li>The leader of each group sums up the <span class="math">\\bm{\\pi}^{(\\bm{b})}</span> it receives, and sends the result together with all the communication to the coordinator. In the case where the leader does not receive <span class="math">\\bm{\\pi}^{(\\bm{b})}</span> from a specific node, it communicates with the coordinator to send a dispute.</li>

      <li><span class="math">\\mathcal{P}_{0}</span> computes <span class="math">z=f(\\bm{\\alpha},\\bm{\\beta})=\\sum_{\\bm{b}\\in B_{\\xi}}z^{(\\bm{b})}\\cdot\\chi_{\\bm{b}}(\\bm{\\beta})</span>. <span class="math">\\mathcal{P}_{0}</span> decomposes</li>

    </ol>

    <p class="text-gray-300"><span class="math">f(\\bm{\\alpha},\\bm{y})-f(\\bm{\\alpha},\\bm{\\beta})=\\sum_{j\\in[\\xi]}q_{j}(\\bm{y})(y_{j}-\\beta_{j}).</span></p>

    <p class="text-gray-300">Then it computes <span class="math">\\pi_{\\mu+j}=g^{q_{j}(\\tau_{\\mu+1},\\ldots,\\tau_{\\mu+\\xi})}</span> with <span class="math">V_{\\bm{b}}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}_{0}</span> sets <span class="math">\\bm{\\pi}:=(\\pi_{1},\\ldots,\\pi_{\\mu+\\xi})</span>.</li>

    </ol>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">Distributed SumCheck with hierarchical aggregation.</h3>

    <p class="text-gray-300">Using the previously presented KZG PCS with hierarchical aggregation we can build a distributed SumCheck with hierarchical aggregation as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i\\in[\\mu]</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">\\bm{b}\\in B_{\\xi}</span>, <span class="math">\\mathcal{P}_{\\bm{b}}</span> computes <span class="math">r_{i}^{(\\bm{b})}(x):=\\sum_{\\bm{w}\\in B_{\\mu-i}}f^{(\\bm{b})}(\\alpha_{1},\\ldots,\\alpha_{i-1},x,\\bm{w})</span>. <span class="math">\\mathcal{P}_{\\bm{b}}</span> sends <span class="math">r_{i}^{(\\bm{b})}</span> to both the leader of its group and <span class="math">\\mathcal{P}_{0}</span>.</li>

      <li>The leader of each group sums up the <span class="math">r_{i}^{(\\bm{b})}</span> it receives, and sends the result together with all communication to the coordinator. In the case where the leader does not receive <span class="math">r_{i}^{(\\bm{b})}</span> from a specific worker, it communicates with the coordinator to send a dispute. <span class="math">\\mathcal{P}_{0}</span> sends the oracle of <span class="math">r_{i}</span> to <span class="math">\\mathcal{V}</span>.</li>

      <li><span class="math">\\mathcal{V}</span> checks if <span class="math">v=r_{i}(0)+r_{i}(1)</span>, and samples and sends a random <span class="math">\\alpha_{i}\\leftarrow\\mathbb{F}</span> to <span class="math">\\mathcal{P}_{0}</span>. Then <span class="math">\\mathcal{V}</span> sets <span class="math">v:=r_{i}(\\alpha_{i})</span>. <span class="math">\\mathcal{P}_{0}</span> sends <span class="math">\\alpha_{i}</span> to each <span class="math">\\mathcal{P}_{\\bm{b}}</span>.</li>

      <li><span class="math">\\mathcal{P}_{0}</span> receives <span class="math">v^{(\\bm{b})}:=f^{(\\bm{b})}(\\bm{\\alpha})</span> from each <span class="math">\\mathcal{P}_{\\bm{b}}</span>. <span class="math">\\mathcal{P}_{0}</span> has a multivariate polynomial <span class="math">g(\\bm{y}):=f(\\bm{\\alpha},\\bm{y})=\\sum_{\\bm{b}\\in B_{\\xi}}v^{(\\bm{b})}\\cdot\\chi_{\\bm{b}}(\\bm{y})</span>.</li>

      <li><span class="math">\\mathcal{P}_{0}</span> and <span class="math">\\mathcal{V}</span> perform SumCheck on <span class="math">g</span> with target value <span class="math">v</span>. <span class="math">\\mathcal{P}_{0}</span> and the worker provers open <span class="math">f(\\bm{\\alpha},\\bm{\\beta})</span>.</li>

    </ol>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">Dispute Control.</h3>

    <p class="text-gray-300">After every invocation of the hierarchical aggregation protocols, the coordinator <span class="math">\\mathcal{P}_{0}</span> executes the following <em>dispute control protocol</em> after identifying a malicious leader group using our accountability protocol. Its goal is to identify at least one misbehaving party (worker or leader). This dispute control is necessary, since a worker may have sent the correct value, but its leader may tamper with the communicated value sent to the coordinator.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Collection of messages. Every leader in group <span class="math">j</span> has already forwarded to <span class="math">\\mathcal{P}_{0}</span>:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Its own partial sum, where for KZG this is <span class="math">\\sum_{\\bm{b}\\in\\text{group }j}\\bm{\\pi}^{(\\bm{b})}</span>, and for SumCheck it is <span class="math">\\sum_{\\bm{b}\\in\\text{group }j}r_{i}^{(\\bm{b})}</span>.</li>

      <li>The <em>entire set</em> of messages <span class="math">\\left\\{(m^{(\\bm{b})})\\right\\}_{\\bm{b}\\in\\text{group }j}</span> that it received from its workers,</li>

    </ul>

    <p class="text-gray-300">where <span class="math">m^{(\\bm{b})}</span> denotes either <span class="math">(\\bm{\\pi}^{(\\bm{b})},z^{(\\bm{b})})</span> or <span class="math">r_{i}^{(\\bm{b})}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Recognition of worker values. For every worker <span class="math">\\mathcal{P}_{\\bm{b}}</span>, <span class="math">\\mathcal{P}_{0}</span> confirms the value that this worker sent to the coordinator in the previous protocol, denoted <span class="math">\\widetilde{m}^{(\\bm{b})}</span>, using the communication sent to the coordinator.</li>

      <li>Leader consistency check. For each group <span class="math">j</span>, compare the leader’s reported sum <span class="math">S_{j}</span> with <span class="math">\\widetilde{S}_{j}</span>:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">S_{j}=\\widetilde{S}_{j}</span>, the leader passes the check.</li>

      <li>Otherwise the leader <span class="math">j</span> is marked malicious.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Detection of double behaviour. For any worker <span class="math">\\mathcal{P}_{\\bm{b}}</span> that sent <em>two different</em> signed messages—one to the leader and one directly to <span class="math">\\mathcal{P}_{0}</span>—the inconsistent pair of signatures is sufficient evidence of malicious behaviour, even if neither message was individually incorrect.</li>

      <li>Accountability check. The leader finally runs the accountability check protocol, to further identify any malicious worker.</li>

    </ol>

    <p class="text-gray-300">We summarize the accountability guarantee of the dispute control protocol in the following proposition.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proposition 7.</h6>

    <p class="text-gray-300">The dispute control protocol satisfies that, if any worker or leader deviates from the prescribed protocol–either by sending incorrect values, omitting messages, or equivocating–the coordinator will identify at least one malicious party.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Since the protocol is sound, the coordinator can detect when a malicious worker or leader has submitted incorrect proof. Accountability is ensured in these scenarios through the following mechanism:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If a worker submits an incorrect proof to both the leader and the coordinator, the coordinator can identify the worker in the accountability check step.</li>

      <li>If the leader submits an incorrect addition, the coordinator can detect the leader’s error by recomputing the additions based on the values submitted directly by the workers to the coordinator in the leader consistency check step.</li>

      <li>If the previous verification fails because a worker submitted inconsistent signed values to the leader and the coordinator, the leader can show that they received a different value than the one available to the coordinator in the detection of double behavior step.</li>

    </ul>

    <p class="text-gray-300">Since all the possible cases are covered, the coordinator will always be able to identify the malicious node, ensuring accountability in the protocol with dispute control. ∎</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">The Cirrus distributed SNARK.</h4>

    <p class="text-gray-300">Cirrus, the accountable and efficiently computable distributed SNARK, is structured as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input Constraint: <span class="math">F^{(b)}(1,\\ldots,1,\\bm{x})-I^{(b)}(\\bm{x})=0</span> for all <span class="math">\\bm{x}\\in B_{\\nu}</span> and <span class="math">\\bm{b}\\in B_{\\xi}</span> with distributed multilinear ZeroTest.</li>

      <li>Output Constraint: <span class="math">\\mathcal{V}</span> queries <span class="math">F^{(1,\\ldots,1)}(1,0,\\langle N^{(b)}-1\\rangle_{\\mu})</span> and checks if it is zero.</li>

      <li>Gate Constraint: Define a multivariate polynomial</li>

    </ul>

    <p class="text-gray-300"><span class="math">G^{(b)}(\\bm{x}):=S_{\\text{add}}^{(b)}(\\bm{x})(F^{(b)}(0,0,\\bm{x})+F^{(b)}(0,1,\\bm{x}))+</span> <span class="math">S_{\\text{mult}}^{(b)}(\\bm{x})(F^{(b)}(0,0,\\bm{x})\\cdot F^{(b)}(0,1,\\bm{x}))-F^{(b)}(1,0,\\bm{x}).</span></p>

    <p class="text-gray-300"><span class="math">G^{(b)}(\\bm{x})=0</span> for all <span class="math">\\bm{x}\\in B_{\\mu}</span> and <span class="math">\\bm{b}\\in B_{\\xi}</span> with distributed multivariate ZeroTest.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Wiring Constraint: Check if <span class="math">F^{(b)}(\\bm{x})=F^{(\\rho^{(b)}(\\bm{x}))}(\\sigma^{(b)}(\\bm{x}))</span> for all <span class="math">\\bm{x}\\in B_{\\mu}</span> and <span class="math">\\bm{b}\\in B_{\\xi}</span> with distributed multivariate PermTest.</li>

      <li>Accountability Check: At the end the protocol, the coordinator runs the efficient accountability protocol presented in Section III-B.</li>

    </ul>

    <h6 id="sec-26" class="text-base font-medium mt-4">Theorem 1 (Main Theorem).</h6>

    <p class="text-gray-300">Cirrus is an accountable distributed SNARK generation scheme (Definition 1).</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The completeness and soundness of Cirrus follows the completeness and soundness of distributed KZG (Proposition 1), distributed SumCheck (Proposition 2), distributed ZeroTest (Proposition 3), distributed PermTest (Proposition 4), and distributed batch opening (Proposition 5). The accountability of Cirrus follows Proposition 6. Therefore, Cirrus is an accountable distributed SNARK generation scheme. ∎</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">III-D ZK for Cirrus</h3>

    <p class="text-gray-300">To make Cirrus a zero-knowledge protocol, the verifier first samples a blinding scalar <span class="math">\\rho\\in\\mathbb{F}</span> and broadcasts it to all workers. Each worker <span class="math">\\mathcal{P}_{\\bm{b}}</span> then chooses a random mask polynomial <span class="math">m^{(b)}</span> of the same degree, publishes a KZG commitment to <span class="math">f^{(b)}+\\rho\\cdot m^{(b)}</span> and uses <span class="math">m^{(b)}</span> to blind every message <span class="math">r_{i}^{(b)}</span>. Group leaders sum these masked commitments and messages exactly as in the transparent protocol, forwarding only the aggregated proofs and signed transcripts to the coordinator. Finally, the coordinator emits a single succinct opening proof over the masked sums, which the verifier checks in O(1) and then algebraically subtracts off <span class="math">\\rho\\cdot m^{(b)}</span> to recover the unblinded result. Because masks are bound by the KZG binding property, accountability holds unchanged, and both worker/coordinator cost and the overall communication complexity remain identical to the non-ZK protocol.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}_{0}</span> samples two random vectors <span class="math">\\bm{r}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}^{\\mu}<span class="math"> and </span>\\bm{r}_{0}\\stackrel{{\\scriptstyle\\<span class="math">}}{{\\leftarrow}}\\mathbb{F}^{\\xi}</span> and defines <span class="math">g^{(b)}(\\bm{x})=\\chi_{\\bm{r}}(\\bm{x})\\cdot\\chi_{\\bm{r}_{0}}(\\bm{b})</span>.</li>

      <li><span class="math">\\mathcal{P}_{0}</span> sends <span class="math">\\bm{r}</span> and <span class="math">\\chi_{\\bm{r}_{0}}(\\bm{b})</span> to <span class="math">\\mathcal{P}_{\\bm{b}}</span>.</li>

      <li><span class="math">\\mathcal{V}</span> sends a challenge <span class="math">\\rho\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}^{*}<span class="math"> to </span>\\mathcal{P}_{0}<span class="math"> that is relayed to all </span>\\mathcal{P}_{\\bm{b}}$.</li>

      <li>The provers and the verifier now run distributed SumCheck protocol over polynomial <span class="math">f+\\rho g</span>.</li>

      <li><span class="math">\\mathcal{V}</span> queries <span class="math">g</span> and <span class="math">f</span> at point <span class="math">\\bm{r}^{\\prime}</span> where <span class="math">\\bm{r}^{\\prime}\\in\\mathbb{F}^{\\varepsilon+\\mu}</span> is the vector of sumcheck’s challenge. <span class="math">V</span> checks that <span class="math">f(\\bm{r}^{\\prime})+\\rho g(\\bm{r}^{\\prime})</span> is consistent with the last message of the SumCheck.</li>

    </ol>

    <p class="text-gray-300">Once we have the zero-knowledge Distributed SumCheck, we can build Cirrus the same way it as in III-C.</p>

    <h2 id="sec-29" class="text-2xl font-bold">IV Implementation and Evaluation</h2>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">IV-A Implementation Details</h3>

    <p class="text-gray-300">We implement Cirrus with our accountability protocol. Our implementation is based on the code base of HyperPlonk <em>[24]</em> and adds <span class="math">5,000</span>+ lines of Rust.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">Cirrus is developer-friendly.</h4>

    <p class="text-gray-300">An advantage of Cirrus, in addition to its high efficiency and its accountability, is that it automatically distributes workloads across workers, eliminating the need for developers to explicitly specify circuit partitions. Moreover, Cirrus uses a universal setup and reuses the existing setup parameters from HyperPlonk, simplifying deployment in practice, because a trustworthy setup ceremony is expensive to organize <em>[22]</em>. In contrast, prior schemes such as Hekaton require developers to manually partition circuits into sub-circuits, explicitly manage shared wires between partitions, and perform separate trusted setups for each partition, significantly increasing complexity and overhead.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">IV-B Evaluation Results</h3>

    <p class="text-gray-300">To assess the practicality of running Cirrus in a decentralized environment (e.g., by individual volunteers), we decide to benchmark Cirrus on hardware comparable to personal computers. In contrast, related works such as Hekaton and Pianist are evaluated on much more powerful HPC servers (e.g., with <span class="math">128</span> cores and <span class="math">512</span> GB memory). Our distributed setting consists of <span class="math">32</span> AWS t3.2xlarge machines in North Virginia, each with <span class="math">8</span> vCPUs and <span class="math">32</span> GB of memory; the average network latency across nodes in our setup was measured at <span class="math">306</span> microseconds.</p>

    <p class="text-gray-300">We found that the best setting for Cirrus is one worker per core (i.e., running <span class="math">8</span> workers per machine), and we use this configuration across all experiments.</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">End-to-end proof generation time.</h4>

    <p class="text-gray-300">We first evaluate the end-to-end proof generation time of Cirrus. As a baseline, we run multi-threaded HyperPlonk on the same worker machine to generate proofs for random circuits of varying sizes. We select random circuits because the overall proof generation time is only dependent on the number of gates in the circuit, and</p>

    <p class="text-gray-300">independent of the structure of the circuit. Then, we run Cirrus with up to 32 workers (each with 8 cores) for random circuits generated in the same way. Figure 1 shows the end-to-end proof generation time of Cirrus, as a function of total circuit size and the number of workers. The line for HyperPlonk stops at  <span class="math">2^{22}</span>  (4M) gates when it runs out of memory (32 GB). In comparison, Cirrus can support larger circuits with more machines. We stopped at  <span class="math">2^{25}</span>  (33M) gates with 8 AWS machines since the horizontal scalability is clear.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1: End-to-end proof generation time of Cirrus when all workers are honest with different total cores and circuit sizes. C denotes Cirrus; H denotes HyperPlonk.</p>

    <p class="text-gray-300">Accountability protocol runtime. A key advantage of Cirrus is the high efficiency of its accountability protocol (see Section III-B). We implement the accountability protocol, and evaluate the time required by the coordinator to identify malicious worker(s) for various circuit sizes and numbers of workers. As shown in Fig. 2, the accountability check is extremely fast in practice compared with the time to generate the proof. For circuits of  <span class="math">2^{25}</span>  total gates and the distribution of 256 workers, the accountability protocol takes under 4 seconds to run. This demonstrates that our accountability mechanism imposes minimal overhead on the coordinator compared with the time to generate the proof.</p>

    <p class="text-gray-300">Coordinator's computation time. A feature of Cirrus is that the coordinator's computation is lightweight thanks to hierarchical aggregation (see Section III-C). We measure the coordinator's computation time in Fig. 3. Without hierarchical aggregation, the computation time of the coordinator increases as the sub-circuit size increases. With our hierarchical aggregation technique, the computation time of the coordinator is independent of the size of the sub-circuits. Overall, the coordinator's computation is lightweight and well under 1 second for less than 10,000 workers.</p>

    <p class="text-gray-300">Memory usage. We record how each worker's memory usage varies with the worker's sub-circuit size in Table IIa. In Cirrus,</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2: The time to run the accountability protocol with different number of workers and full circuit sizes.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 3: Computation time of the coordinator with varying number of workers and sub-circuit sizes. In this figure, "HA" denotes the coordinator time with hierarchical aggregation, while "No HA" denotes the coordinator time without hierarchical aggregation.</p>

    <p class="text-gray-300">worker memory consumption is similar to that of Pianist and Hekaton for sub-circuits of the same sizes.</p>

    <p class="text-gray-300">The memory usage of the coordinator is reported in Table IIb. We observe that the memory usage of the coordinator only depends on the size of the full circuit.</p>

    <p class="text-gray-300">Comparison with Hekaton. To understand the performance of Cirrus in practice, we compare it with Hekaton, which is the fastest distributed SNARK system and the only accountable distributed SNARK known at the time of writing. Hekaton reportedly outperforms Pianist by  <span class="math">3 \\times</span> . We obtained the source code from the authors and evaluated Hekaton on the same machines used for our Cirrus experiments.</p>

    <p class="text-gray-300">We compare the two systems across a range of tasks to</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> (a) Comparison between Cirrus and Hekaton to prove Pedersen Hashes.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> (b) Comparison between Cirrus and Hekaton to prove MiMC hashes.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> (c) Comparison between Cirrus and Hekaton to prove PoK of exponent tasks. Fig. 4: Comparison between Cirrus and Hekaton on different tasks. C denotes Cirrus, and He denotes Hekaton. The total number of working cores is shown in the parentheses.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sub-Circuit Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Memory</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">383 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">217</td>

            <td class="px-3 py-2 border-b border-gray-700">765 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">218</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4 GB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">219</td>

            <td class="px-3 py-2 border-b border-gray-700">2.8 GB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">5.6 GB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">221</td>

            <td class="px-3 py-2 border-b border-gray-700">11.3 GB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">222</td>

            <td class="px-3 py-2 border-b border-gray-700">22.6 GB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(a) Memory usage of each worker with varying sub-circuit sizes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Full Circuit Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Memory</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">219</td>

            <td class="px-3 py-2 border-b border-gray-700">200 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">396 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">221</td>

            <td class="px-3 py-2 border-b border-gray-700">799 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">222</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5 GB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">223</td>

            <td class="px-3 py-2 border-b border-gray-700">3.0 GB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">224</td>

            <td class="px-3 py-2 border-b border-gray-700">6.0 GB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">225</td>

            <td class="px-3 py-2 border-b border-gray-700">12.1 GB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(b) Memory usage of the coordinator with varying full circuit sizes.</p>

    <p class="text-gray-300">TABLE II: Memory usage of workers and the coordinator.</p>

    <p class="text-gray-300">show practical performance differences. We tested three tasks: Pedersen hashing [12], MiMC hashing [26], and proof of knowledge of exponent (PoK of Exp). In each case, we repeated the task multiple times in the circuit to test the scalability of both protocols when they are required to prove a large number of instances. The results are shown in Fig. 4.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For Pedersen hashing, Cirrus is over  <span class="math">7 \\times</span>  faster.</li>

      <li>For MiMC hashing, Cirrus is about  <span class="math">2 \\times</span>  faster.</li>

      <li>For PoK of Exponent, Cirrus is around  <span class="math">4 \\times</span>  faster.</li>

    </ul>

    <p class="text-gray-300">These results show that Cirrus performs well in these real-world applications, especially for PLONK-friendly tasks. We also emphasize that, unlike Hekaton, Cirrus supports a universal trusted setup and does not require any per-circuit configuration, and is therefore more flexible to deploy.</p>

    <p class="text-gray-300">In this section, we review prior works on distributed proof generation schemes, focusing on asymptotical performance (prover time, verifier time, communications) and accountability. We summarize the comparison in Table I.</p>

    <p class="text-gray-300">DIZK. Wu et. al. [15] introduced a distributed approach to zkSNARK provers, focusing on optimizing key operations such as Fast Fourier Transforms (FFTs) and multi-scalar multiplications. Their system scales Groth16 by distributing the computation across multiple machines, and can handle much larger circuits using a cluster of machines. However, a significant limitation is that the communication cost of each machine is linear in the size of the full circuit (as opposed to the size of a worker's sub-circuit) due to the distributed FFT algorithm. Another limitation of DIZK is that it uses a circuit-specific setup instead of a universal setup.</p>

    <p class="text-gray-300">DeVirgo. Introduced in zkBridge [14], DeVirgo is a distributed variant of Virgo [7]. Authors of DeVirgo proposed a way to distribute the SumCheck protocol [27] and the FRI low-degree test across multiple machines. With  <span class="math">n</span>  machines, the proof generation time is reduced by  <span class="math">1/n</span> . The protocol only supports data-parallel circuits. Despite these improvements in scalability over DIZK, DeVirgo incurs a per-worker communication cost linear in the size of the full circuit due to its reliance on the FRI low-degree test.</p>

    <p class="text-gray-300">Pianist. [16] introduces a distributed proving algorithm for the PLONK SNARK that works for general circuits [3], aiming to reduce communication overhead in distributed proving</p>

    <p class="text-gray-300">systems. The core innovation in Pianist is the use of bivariate polynomial commitments, which allows for decomposing PLONK’s global permutation check (which is responsible for ensuring the correctness of circuit wiring) into local permutation checks for each prover. Pianist achieves only partial accountability (only for data-parallel circuits) and their paper does not formally define accountability. Pianist is also the first distributed SNARK scheme to achieve constant per-node communication. Despite these advances, the prover time of each worker remains <em>quasi-linear</em> in the circuit size. In comparison, our protocol achieves linear worker prover time (in the size of the sub-circuit) and stronger accountability for general circuits (not just data-parallel circuits).</p>

    <p class="text-gray-300">Mangrove. <em>[28]</em> presents a framework for dividing PLONK into segments of proofs and using folding schemes to aggregate them. While Mangrove shows promising theoretical results with estimated performance comparable to leading SNARKs, it has not been fully implemented or evaluated, especially when it comes to distributing the evaluation of the segments. Additionally, if applied to distributed proving, its techniques would require an inter-worker communication complexity that is linear in the circuit size. In comparison, Cirrus achieves an amortized communication complexity logarithmic in the size of each sub-circuit. Since Mangrove is not implemented, its concrete performance is unknown.</p>

    <p class="text-gray-300">Hekaton. <em>[17]</em> proposes a “distribute-and-aggregate” framework to achieve accountable distributed SNARK generation. Specifically, Hekaton leverages memory-checking techniques, where a coordinator constructs a global memory based on the value of the shared wires among circuits. Then, the provers perform consistency checks on their memory access. In this way, the coordinator can detect malicious behavior, and therefore, Hekaton is an accountable scheme. However, like Pianist, the workers’ prover time of Hekaton is quasi-linear instead of truly linear in the size of the sub-circuit. Another drawback of Hekaton is that it requires a circuit-specific setup. Moreover, the coordinator’s work scales linearly with the global memory size, which could be a potential bottleneck when the number of shared wires among circuits is large. In comparison, the per-worker prover time of Cirrus is “truly” linear in the size of the sub-circuit, and the coordinator’s workload is independent of the number of shared wires among sub-circuits.</p>

    <p class="text-gray-300">HyperPianist. <em>[18]</em> is a concurrent work with similar distributed permutation test and zero test techniques with multilinear polynomials, while they adopt a different distributed polynomial commitment scheme. However, their protocol is not accountable. There has not been a proof of completeness or soundness or a thorough performance evaluation.</p>

    <p class="text-gray-300">SNARK aggregation schemes. A series of works <em>[29, 30, 31]</em> focuses on SNARK aggregation schemes, where the system uses cryptographic techniques to aggregate proofs of sub-circuits. However, these schemes can only aggregate the proofs when the sub-circuits do not have shared wires or inputs, and cannot be directly used to construct distributed SNARK generation schemes for general circuits.</p>

    <p class="text-gray-300">Collaborative ZK-SNARKs. A recent line of work on <em>collaborative ZK-SNARKs</em> <em>[32, 33, 34, 35, 36]</em> addresses the privacy problem when generating proofs with witnesses from multiple parties using multi-party computation. All these schemes require preprocessing among all servers for each proof, which requires total communication that is linear in the size of the full circuit. Therefore, Collaborative ZK-SNARKs are not as efficient, though they achieve privacy, which is a non-goal for distributed proof generation schemes.</p>

    <h2 id="sec-35" class="text-2xl font-bold">VI Conclusions and Future Directions</h2>

    <p class="text-gray-300">We have introduced Cirrus, the first <em>accountable</em> distributed SNARK generation scheme with linear-time worker and coordinator computation time, minimal communication overhead, and supports a universal trusted setup. By our accountability protocol, the coordinator can efficiently identify any malicious prover, making Cirrus suitable for deployment in decentralized settings, e.g., in prover markets, where workers cannot be fully trusted. We formally define accountability in distributed proof generation schemes and prove that Cirrus satisfies this definition. According to our experiments, Cirrus is horizontally scalable and is concretely faster than the state-of-the-art for representative workloads.</p>

    <p class="text-gray-300">One future direction is to further improve the communication round complexity, currently logarithmic in the size of each sub-circuit due to the distributed SumCheck. It is of both theoretical and practical interest to design an accountable distributed SNARK with a constant number of communication rounds while preserving the efficiency of Cirrus. Additionally, future work could focus on minimizing the coordinator’s overhead in the accountability protocol. Currently, identifying malicious provers in stage 2 of the accountability protocol requires number of field operations linear in the size of the entire circuit. While the cost of the accountability protocol is acceptable in most settings, optimizing this step would make the protocol even more scalable for deployments involving even larger circuits.</p>

    <h2 id="sec-36" class="text-2xl font-bold">Acknowledgement</h2>

    <p class="text-gray-300">This material is supported in part by Ethereum Foundation. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of these institute.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] J. Groth, “On the size of pairing-based non-interactive arguments,” in <em>Advances in Cryptology–EUROCRYPT 2016: 35th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Vienna, Austria, May 8-12, 2016, Proceedings, Part II 35</em>. Springer, 2016, pp. 305–326.</li>

      <li>[2] S. Ames, C. Hazay, Y. Ishai, and M. Venkitasubramaniam, “Ligero: Lightweight sublinear arguments without a trusted setup,” in <em>Proceedings of the 2017 acm sigsac conference on computer and communications security</em>, 2017, pp. 2087–2104.</li>

      <li>[3] A. Gabizon, Z. J. Williamson, and O. Ciobotaru, “Plonk: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge,” <em>Cryptology ePrint Archive</em>, 2019.</li>

      <li>[4] A. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. Ward, “Marlin: Preprocessing zksnarks with universal and updatable srs,” in <em>Advances in Cryptology–EUROCRYPT 2020: 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zagreb, Croatia, May 10–14, 2020, Proceedings, Part I 39</em>. Springer, 2020, pp. 738–768.</li>

      <li>[5] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer, “From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again,” in <em>Proceedings of the 3rd Innovations in Theoretical Computer Science Conference</em>, ser. ITCS ’12. New York, NY, USA: Association for Computing Machinery, 2012, p. 326–349. [Online]. Available: https://doi.org/10.1145/2090236.2090263</li>

      <li>[6] T. Xie, J. Zhang, Y. Zhang, C. Papamanthou, and D. Song, “Libra: Succinct zero-knowledge proofs with optimal prover computation,” in <em>Advances in Cryptology–CRYPTO 2019: 39th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 18–22, 2019, Proceedings, Part III 39</em>. Springer, 2019, pp. 733–764.</li>

      <li>[7] J. Zhang, T. Xie, Y. Zhang, and D. Song, “Transparent polynomial delegation and its applications to zero knowledge proof,” in <em>2020 IEEE Symposium on Security and Privacy (SP)</em>. IEEE, 2020, pp. 859–876.</li>

      <li>[8] B. Chen, B. Bünz, D. Boneh, and Z. Zhang, “Hyperplonk: Plonk with linear-time prover and high-degree custom gates,” in <em>Annual International Conference on the Theory and Applications of Cryptographic Techniques</em>. Springer, 2023, pp. 499–530.</li>

      <li>[9] S. Setty, “Spartan: Efficient and general-purpose zksnarks without trusted setup,” in <em>Annual International Cryptology Conference</em>. Springer, 2020, pp. 704–737.</li>

      <li>[10] A. Golovnev, J. Lee, S. T. Setty, J. Thaler, and R. S. Wahby, “Brakedown: Linear-time and post-quantum snarks for r1cs.” <em>IACR Cryptol. ePrint Arch.</em>, vol. 2021, p. 1043, 2021.</li>

      <li>[11] T. Xie, Y. Zhang, and D. Song, “Orion: Zero knowledge proof with linear prover time,” in <em>Annual International Cryptology Conference</em>. Springer, 2022, pp. 299–328.</li>

      <li>[12] D. Hopwood, S. Bowe, T. Hornby, N. Wilcox et al., “Zcash protocol specification,” <em>GitHub: San Francisco, CA, USA</em>, vol. 4, no. 220, p. 32, 2016.</li>

      <li>[13] Ethereum Foundation, “zk-rollups: Scaling solutions for ethereum,” https://ethereum.org/en/developers/docs/scaling/zk-rollups/, Jul. 2024.</li>

      <li>[14] T. Xie, J. Zhang, Z. Cheng, F. Zhang, Y. Zhang, Y. Jia, D. Boneh, and D. Song, “zkbridge: Trustless cross-chain bridges made practical,” in <em>Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security</em>, 2022, pp. 3003–3017.</li>

      <li>[15] H. Wu, W. Zheng, A. Chiesa, R. A. Popa, and I. Stoica, “{DIZK}: A distributed zero knowledge proof system,” in <em>27th USENIX Security Symposium (USENIX Security 18)</em>, 2018, pp. 675–692.</li>

      <li>[16] T. Liu, T. Xie, J. Zhang, D. Song, and Y. Zhang, “Pianist: Scalable zkrollups via fully distributed zero-knowledge proofs,” <em>Cryptology ePrint Archive</em>, 2023.</li>

      <li>[17] M. Rosenberg, T. Mopuri, H. Hafezi, I. Miers, and P. Mishra, “Hekaton: Horizontally-scalable zksnarks via proof aggregation,” <em>Cryptology ePrint Archive</em>, 2024.</li>

      <li>[18] C. Li, Y. Li, P. Zhu, W. Qu, and J. Zhang, “Hyperpianist: Pianist with linear-time prover via fully distributed hyperplonk,” <em>Cryptology ePrint Archive</em>, 2024.</li>

      <li>[19] W. Wang, L. Zhou, A. Yaish, F. Zhang, B. Fisch, and B. Livshits, “Mechanism design for zk-rollup prover markets,” <em>arXiv preprint arXiv:2404.06495</em>, 2024.</li>

      <li>[20] “Gevulot docs,” https://docs.gevulot.com/gevulot-docs/, accessed: 2024-04-06.</li>

      <li>[21] “Ferham docs,” https://docs.fermah.xyz/, accessed: 2024-11-06.</li>

      <li>[22] S. Walters, “What is the zcash ceremony? the complete beginners guide,” accessed: 2024-11-14. [Online]. Available: https://coinbureau.com/education/zcash-ceremony/</li>

      <li>[23] A. Kosba, D. Papadopoulos, C. Papamanthou, and D. Song, “{MIRAGE}: Succinct arguments for randomized algorithms with applications to universal {zk-SNARKs},” in <em>29th USENIX Security Symposium (USENIX Security 20)</em>, 2020, pp. 2129–2146.</li>

      <li>[24] Espresso Systems, “Hyperplonk library,” accessed: 2024-11-13. [Online]. Available: https://github.com/EspressoSystems/hyperplonk</li>

      <li>[25] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou, “vsql: Verifying arbitrary sql queries over dynamic outsourced databases,” in <em>2017 IEEE Symposium on Security and Privacy (SP)</em>. IEEE, 2017, pp. 863–880.</li>

      <li>[26] M. Albrecht, L. Grassi, C. Rechberger, A. Roy, and T. Tiessen, “Mimc: Efficient encryption and cryptographic hashing with minimal multiplicative complexity,” in <em>International Conference on the Theory and Application of Cryptology and Information Security</em>. Springer, 2016, pp. 191–219.</li>

      <li>[27] C. Lund, L. Fortnow, H. Karloff, and N. Nisan, “Algebraic methods for interactive proof systems,” <em>Journal of the ACM (JACM)</em>, vol. 39, no. 4, pp. 859–868, 1992.</li>

      <li>[28] W. Nguyen, T. Datta, B. Chen, N. Tyagi, and D. Boneh, “Mangrove: A scalable framework for folding-based SNARKs,” 2024, https://eprint.iacr.org/2024/416. [Online]. Available: https://eprint.iacr.org/2024/416</li>

      <li>[29] X. Liu, S. Gao, T. Zheng, Y. Guo, and B. Xiao, “SnarkFold: Efficient proof aggregation from incrementally verifiable computation and applications,” Cryptology ePrint Archive, Paper 2023/1946, 2023. [Online]. Available: https://eprint.iacr.org/2023/1946</li>

      <li>[30] M. Ambrosu, M. Beunardeau, A.-L. Schmitt, and R. R. Toledo, “aPlonK : Aggregated PlonK from multi-polynomial commitment schemes,” Cryptology ePrint Archive, Paper 2022/1352, 2022. [Online]. Available: https://eprint.iacr.org/2022/1352</li>

      <li>[31] N. Gailly, M. Maller, and A. Nitulescu, “Snarkpack: Practical snark aggregation,” in <em>International Conference on Financial Cryptography and Data Security</em>. Springer, 2022, pp. 203–229.</li>

      <li>[32] A. Ozdemir and D. Boneh, “Experimenting with collaborative {zk-SNARKs}:{Zero-Knowledge} proofs for distributed secrets,” in <em>31st USENIX Security Symposium (USENIX Security 22)</em>, 2022, pp. 4291–4308.</li>

      <li>[33] S. Garg, A. Goel, A. Jain, G.-V. Policharla, and S. Sekar, “{zkSaaS}:{Zero-Knowledge}{SNARKs} as a service,” in <em>32nd USENIX Security Symposium (USENIX Security 23)</em>, 2023, pp. 4427–4444.</li>

      <li>[34] A. Chiesa, R. Lehmkuhl, P. Mishra, and Y. Zhang, “Eos: Efficient private delegation of {zkSNARK} provers,” in <em>32nd USENIX Security Symposium (USENIX Security 23)</em>, 2023, pp. 6453–6469.</li>

      <li>[35] X. Liu, Z. Zhou, Y. Wang, B. Zhang, and X. Yang, “Scalable collaborative zk-snark: Fully distributed proof generation and malicious security,” Cryptology ePrint Archive, Paper 2024/143, 2024, https://eprint.iacr.org/2024/143. [Online]. Available: https://eprint.iacr.org/2024/143</li>

      <li>[36] X. Liu, Z. Zhou, Y. Wang, J. He, B. Zhang, X. Yang, and J. Zhang, “Scalable collaborative zk-SNARK and its application to efficient proof outsourcing,” Cryptology ePrint Archive, Paper 2024/940, 2024, https://eprint.iacr.org/2024/940. [Online]. Available: https://eprint.iacr.org/2024/940</li>

      <li>[37] A. Fiat and A. Shamir, “How to prove yourself: Practical solutions to identification and signature problems,” in <em>Conference on the theory and application of cryptographic techniques</em>. Springer, 1986, pp. 186–194.</li>

      <li>[38] J. Thaler, “Time-optimal interactive proofs for circuit evaluation,” in <em>Annual Cryptology Conference</em>. Springer, 2013, pp. 71–89.</li>

      <li>[39] C. Papamanthou, E. Shi, and R. Tamassia, “Signatures of correct computation,” in <em>Theory of Cryptography Conference</em>. Springer, 2013, pp. 222–242.</li>

      <li>[40] I. Corporation, “Intel® software guard extentions programming reference,” accessed: 2024-08-27. [Online]. Available: https://www.intel.com/content/dam/develop/external/us/en/documents/329298-002-629101.pdf</li>

      <li>[41] J.-B. Truong, W. Gallagher, T. Guo, and R. J. Walls, “Memory-efficient deep learning inference in trusted execution environments,” in <em>2021 IEEE International Conference on Cloud Engineering (IC2E)</em>. IEEE, 2021, pp. 161–167.</li>

    </ul>

    <p class="text-gray-300">Appendix</p>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">A Definitions</h3>

    <p class="text-gray-300">Succinct non-interactive argument of knowledge. We recall the definitions of SNARKs.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Definition 2 (Interactive Argument of Knowledge).</h6>

    <p class="text-gray-300">A tuple of algorithms <span class="math">(\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span> is an interactive argument of knowledge for relation <span class="math">\\mathcal{R}</span> between a prover <span class="math">\\mathcal{P}</span> and a verifier <span class="math">\\mathcal{V}</span> if it has the following completeness and knowledge soundness properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: For all <span class="math">(\\mathtt{x},\\mathtt{w})\\in\\mathcal{R}</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[\\langle\\mathcal{P}(\\mathtt{w}),\\mathcal{V}\\rangle(\\mathtt{x},\\mathtt{pp})=1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\mathtt{pp}\\leftarrow\\mathsf{Setup}(1^{\\lambda},\\mathcal{R})]=1.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge Soundness and Soundness: An interactive protocol is knowledge-sound if for any PPT adversary <span class="math">(\\mathcal{A}_{1},\\mathcal{A}_{2})</span>, there exists a PPT extractor algorithm <span class="math">\\mathcal{E}</span> with oracle access to <span class="math">\\mathcal{A}_{1},\\mathcal{A}_{2}</span> such that this probability is <span class="math">\\mathsf{negl}(\\lambda)</span>.</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr\\left[\\langle\\mathcal{A}_{2}(\\mathtt{w}),\\mathcal{V}\\rangle(\\mathtt{x},\\mathtt{pp})=1\\ \\land\\ (\\mathtt{x},\\mathtt{w})\\notin\\mathcal{R}\\begin{array}[]{l}\\mathtt{pp}\\leftarrow\\mathsf{Setup}(1^{\\lambda},\\mathcal{R})\\\\ \\mathtt{x}\\leftarrow\\mathcal{A}_{1}(\\mathtt{pp})\\\\ \\mathtt{w}\\leftarrow\\mathcal{E}(\\mathtt{pp},\\mathtt{x},\\mathcal{R})\\end{array}\\right] \\]</p>

    <p class="text-gray-300">If the statement holds when the constraint on the extractor is removed, the interactive protocol is considered sound, and the protocol is considered an interactive argument.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Succinctness: An interactive argument of knowledge is considered succinct if the communication between the prover and the verifier and the running time of the verifier are both $O(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathtt{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathtt{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Public-Coin: An interactive protocol is considered to be public-coin if all of the <span class="math">\\mathcal{V}</span> messages can be computed as a deterministic function given a random public input.</li>

    </ul>

    <p class="text-gray-300">A public coin interactive argument of knowledge can be turned into a non-interactive via Fiat-Shamir transformation <em>[37]</em>. The Fiat-Shamir transformation replaces the challenges of the verifier with PRF outputs of the transcript. A succinct non-interactive argument of knowledge is called a SNARK.</p>

    <p class="text-gray-300">Polynomial interactive oracle proof. Interactive arguments of knowledge can be constructed from argument systems with oracle access to prover messages, e.g., oracle access to polynomials. The argument is then compiled using cryptographic protocols, such as polynomial commitments. Here we define polynomial interactive oracle proof (Poly-IOP), a specific category of such argument systems.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Definition 3 (Polynomial Interactive Oracle Proof).</h6>

    <p class="text-gray-300">A polynomial interactive oracle proof (Poly-IOP) is a public-coin interactive argument for an oracle relation <span class="math">\\mathcal{R}</span>. In any instance <span class="math">(\\mathtt{x},\\mathtt{w})\\in\\mathcal{R}</span> of the oracle relation, the public input <span class="math">\\mathtt{x}</span> can contain oracles to <span class="math">\\mu</span>-variate polynomials over a field <span class="math">\\mathbb{F}</span>, where <span class="math">\\mu</span> and the degree of the polynomials are specified by the oracles. The oracles can be queried at arbitrary points in <span class="math">\\mathbb{F}^{\\mu}</span> to evaluate the polynomials. The polynomials specifications corresponding to the oracles are in <span class="math">\\mathtt{pp}\\leftarrow\\mathsf{Setup}(1^{\\lambda},\\mathcal{R})</span> and <span class="math">\\mathtt{w}</span>. In each round of the Poly-IOP protocol, the prover sends several polynomial oracles to the verifier, and the verifier sends random challenges to the prover.</p>

    <p class="text-gray-300">The knowledge soundness of a Poly-IOP protocol differs from the knowledge soundness of an ordinary interactive argument protocol in that the extractor <span class="math">\\mathcal{E}</span> can query the polynomial oracles at arbitrary points. It is shown in <em>[8]</em> that a Poly-IOP protocol is knowledge sound if it is sound.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">The Poly-IOP definition here should be more precisely described as polynomial interactive oracle arguments. Yet the usage of the words “proof” and “argument” are often mixed with each other, and it is more conventional to write Poly-IOPs instead of Poly-IOAs. That is why we keep the term Poly-IOP here.</p>

    <p class="text-gray-300">Polynomial commitment scheme. To compile a Poly-IOPs to a SNARK, a polynomial commitment scheme (PCS) is required. On a high level, a PCS securely implements polynomial oracles and queries to such oracles. Here we define PCS as follows.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Definition 4 (Polynomial Commitment Scheme).</h6>

    <p class="text-gray-300">A polynomial commit scheme for a class of functions <span class="math">\\mathcal{F}\\subseteq\\mathbb{F}[\\bm{X}]</span> is a tuple of algorithms <span class="math">(\\mathsf{KeyGen},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Verify})</span>, where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{KeyGen}(1^{\\lambda},\\mathcal{F})\\rightarrow\\mathsf{crs}</span> generates the public parameter <span class="math">\\mathsf{crs}</span>.</li>

      <li><span class="math">\\mathsf{Commit}(f,\\mathsf{crs})\\rightarrow\\mathsf{com}_{f}</span> generates a commitment <span class="math">\\mathsf{com}_{f}</span> of a function <span class="math">f</span>.</li>

      <li><span class="math">\\mathsf{Open}(f,\\bm{x},\\mathsf{crs})\\rightarrow(y,\\pi)</span> outputs <span class="math">y:=f(\\bm{x})</span> and an opening proof <span class="math">\\pi</span>.</li>

      <li><span class="math">\\mathsf{Verify}(\\mathsf{com}_{f},\\bm{x},y,\\pi,\\mathsf{crs})\\rightarrow b\\in\\{0,1\\}</span> verifies the polynomial opening given the proof, and returns whether the verification passes.</li>

    </ul>

    <p class="text-gray-300">A PCS protocol should have the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: For all <span class="math">f\\in\\mathcal{F}</span> and for all <span class="math">\\bm{x}</span></li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr\\left[b=1\\ \\begin{vmatrix}\\mathsf{crs}\\leftarrow\\mathsf{KeyGen}(1^{\\lambda},\\mathcal{F})\\\\ \\mathsf{com}_{f}\\leftarrow\\mathsf{Commit}(f,\\mathsf{crs})\\\\ (y,\\pi)\\leftarrow\\mathsf{Open}(f,\\bm{x},\\mathsf{crs})\\\\ b\\leftarrow\\mathsf{Verify}(\\mathsf{com}_{f},\\bm{x},y,\\pi,\\mathsf{crs})\\end{vmatrix}\\right]=1\\right. \\]</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Binding: For all PPT adversary <span class="math">\\mathcal{A}</span> the following probability is <span class="math">\\mathsf{negl}(\\lambda)</span>.</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr\\left[b_{1}=b_{2}=1\\ \\begin{vmatrix}\\mathsf{crs}\\leftarrow\\mathsf{KeyGen}(1^{\\lambda},\\mathcal{F})\\\\ \\mathsf{com}_{f}\\leftarrow\\mathsf{Commit}(f,\\mathsf{crs})\\\\ \\bm{x}_{1},\\bm{x}_{2},y_{1},y_{2},\\pi_{1},\\pi_{2}\\leftarrow\\mathcal{A}(\\mathsf{crs})\\\\ b_{\\{1,2\\}}\\leftarrow\\mathsf{Verify}(\\mathsf{com}_{f},\\bm{x}_{\\{1,2\\}},y_{\\{1,2\\}},\\pi_{\\{1,2\\}},\\mathsf{crs})\\end{vmatrix}\\right] \\]</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">B HyperPlonk Poly-IOP</h3>

    <p class="text-gray-300">HyperPlonk is a Poly-IOP that features linear prover time <em>[8]</em>. Recall that in Plonk Poly-IOP, we need to interpolate univariate polynomials over a set of size <span class="math">O(N)</span>. However, interpolating degree-<span class="math">n</span> polynomials would incur at least <span class="math">O(n\\log n)</span> prover time, which means that the prover time is at least <span class="math">O(N\\log N)</span>. To resolve this problem, in HyperPlonk multivariate polynomials are interpolated over the boolean hypercube <span class="math">B_{\\mu}:=\\{0,1\\}^{\\mu}</span>. By the merits of linear time algorithms to evaluate and interpolate multilinear polynomials</p>

    <p class="text-gray-300">in the previous work [6], [38], the prover time is finally reduced to <span class="math">O(N)</span> in HyperPlonk Poly-IOP.</p>

    <p class="text-gray-300">Multivariate polynomials in HyperPlonk. Let <span class="math">\\nu</span> be the length of binary index to represent public inputs, i.e. <span class="math">2^{\\nu} = \\ell_{x}</span>. Let <span class="math">\\mu</span> be the length of binary index to represent the gates, i.e. <span class="math">2^{\\mu} = N</span>. We can interpret <span class="math">\\sigma</span> to another permutation <span class="math">\\sigma_{\\mu}: B_{\\mu + 2} \\to B_{\\mu + 2}</span>. Then the multivariate polynomials that characterizes the Plonk constraint <span class="math">(s, \\sigma)</span> are defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Two multilinear polynomials <span class="math">S_{\\mathrm{add}}(\\pmb{x}), S_{\\mathrm{mult}}(\\pmb{x}) \\in \\mathbb{F}_{\\mu}^{\\leq 1}[\\pmb{X}]</span> such that for all <span class="math">i \\in [N]</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} S _ {\\text {a d d}} (\\langle i \\rangle_ {\\mu}) = s _ {i} \\\\ S _ {\\text {m u l t}} (\\langle i \\rangle_ {\\mu}) = 1 - s _ {i} \\end{array} \\right.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A multilinear polynomial <span class="math">F \\in \\mathbb{F}_{\\mu + 2}^{\\leq 1}</span> such that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l l} F (0, 0, \\langle i \\rangle_ {\\mu}) = t _ {3 i + 1} &amp;amp; i \\in [ 0, N - 1 ] \\\\ F (0, 1, \\langle i \\rangle_ {\\mu}) = t _ {3 i + 2} &amp;amp; i \\in [ 0, N - 1 ] \\\\ F (1, 0, \\langle i \\rangle_ {\\mu}) = t _ {3 i + 3} &amp;amp; i \\in [ 0, N - 1 ] \\\\ F (1, \\dots , 1, \\langle i \\rangle_ {\\nu}) = x _ {i + 1} &amp;amp; i \\in [ 0, \\ell_ {x} - 1 ] \\end{array} \\right.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A multilinear polynomial <span class="math">I \\in \\mathbb{F}_{\\nu}^{\\leq 1}</span> such that for all <span class="math">i \\in [0, \\ell_x - 1]</span> we have</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">I (\\langle i \\rangle_ {\\nu}) = x _ {i + 1}.</span></div>

    <p class="text-gray-300">Multivariate SumCheck Poly-IOP. Prover wants to show to the verifier that a multivariate polynomial <span class="math">f(\\pmb{x}) \\coloneqq h(g_1(\\pmb{x}), \\dots, g_c(\\pmb{x})) \\in \\mathbb{F}_\\mu[\\pmb{X}]</span> satisfies <span class="math">\\sum_{\\pmb{x} \\in B_\\mu} f(\\pmb{x}) = v</span>, where each <span class="math">g_i</span> is multilinear and <span class="math">h</span> can be evaluated using an arithmetic circuit with <span class="math">O(d)</span> gates. Before describing the final Poly-IOP protocol, recall the original SumCheck protocol in [27] that works for <span class="math">f \\in \\mathbb{F}_\\mu^{\\leq d}[\\pmb{X}]</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i \\in [\\mu]</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> computes <span class="math">r_i(x) := \\sum_{\\pmb{b} \\in B_{\\mu - i}} f(\\alpha_1, \\dots, \\alpha_{i-1}, x, \\pmb{b})</span> and sends the oracle of <span class="math">r_i</span> to <span class="math">\\mathcal{V}</span>.</li>

      <li><span class="math">\\mathcal{V}</span> checks if <span class="math">v = r_i(0) + r_i(1)</span>. Then <span class="math">\\mathcal{V}</span> samples <span class="math">\\alpha_i \\gets \\mathbb{F}</span> and sets <span class="math">v := r_i(\\alpha_i)</span>. <span class="math">\\mathcal{V}</span> sends <span class="math">\\alpha_i</span> to <span class="math">\\mathcal{P}</span>.</li>

      <li><span class="math">\\mathcal{V}</span> checks if <span class="math">f(\\alpha) = v</span>.</li>

    </ul>

    <p class="text-gray-300">Note that in [27] the vanilla SumCheck protocol assumes that the prover has oracle access to <span class="math">f</span>. To efficiently evaluate <span class="math">f</span> at the given points along the protocol for the prover, Chen et al. build upon the protocols in [38], [6] and developed a dynamic-programming-based scheme for polynomials <span class="math">f \\in \\mathbb{F}_{\\mu}^{\\leq d}</span>. Specifically, the compiled SumCheck protocol without oracle access to <span class="math">f</span> is described as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all <span class="math">j \\in [c]</span>, <span class="math">\\mathcal{P}</span> evaluate <span class="math">g_j(\\pmb{x})</span> for all <span class="math">\\pmb{x} \\in B_{\\mu}</span> and build a table <span class="math">A_j</span> to store the valuations.</li>

      <li>For each <span class="math">i \\in [\\mu]</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> computes <span class="math">r_j^{(b)}(x) \\coloneqq (1 - x)A(0, b) + xA(1, b)</span> for all <span class="math">b \\in B_{\\mu - i}</span> and for all <span class="math">j \\in [c]</span>.</li>

      <li>For all <span class="math">\\pmb{b} \\in B_{\\mu - i}</span>, <span class="math">\\mathcal{P}</span> computes <span class="math">r^{(b)}(x) := h(r_1^{(b)}(x), \\dots, r_\\nu^{(b)}(x))</span>, where each addition gate is computed using polynomial addition, and each multiplication is computed using fast polynomial multiplication.</li>

      <li><span class="math">\\mathcal{P}</span> computes <span class="math">r_i(x) \\coloneqq \\sum_{b \\in B_{\\mu - i}} r^{(b)}(x)</span>, and sends the oracle of <span class="math">r_i</span> to <span class="math">\\mathcal{V}</span>.</li>

      <li><span class="math">\\mathcal{V}</span> checks if <span class="math">v = r_i(0) + r_i(1)</span>. Then <span class="math">\\mathcal{V}</span> samples <span class="math">\\alpha_i \\gets \\mathbb{F}</span> and sets <span class="math">v := r_i(\\alpha_i)</span>.</li>

      <li><span class="math">\\mathcal{V}</span> sends <span class="math">\\alpha_{i}</span> to <span class="math">\\mathcal{P}</span>.</li>

      <li><span class="math">\\mathcal{P}</span> sets <span class="math">A_{j}[\\pmb {b}] = r_{j}^{(b)}(\\alpha_{i})</span> for all <span class="math">b\\in B_{\\mu -i}</span></li>

      <li><span class="math">\\mathcal{V}</span> queries <span class="math">f(\\alpha)</span> and checks if it is equal to <span class="math">v</span>.</li>

    </ul>

    <p class="text-gray-300">Here we summarize the complexity of the multivariate SumCheck Poly-IOP:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prover Time: <span class="math">O(2^{\\mu} \\cdot d \\log^{2} d)</span></li>

      <li>Verifier Time: <span class="math">O(\\mu)</span></li>

      <li>Communication: <span class="math">O(\\mu)\\mathbb{F}</span></li>

      <li>Oracle Access: The prover builds and sends oracle for <span class="math">O(\\mu)</span> degree-<span class="math">d</span> univariate polynomials and <span class="math">O(1)</span> multivariate polynomials in <span class="math">\\mathbb{F}_{\\mu}^{\\leq d}[\\pmb{X}]</span>. The verifier queries <span class="math">O(\\mu)</span> degree-<span class="math">d</span> univariate polynomials and <span class="math">O(1)</span> multivariate polynomials in <span class="math">\\mathbb{F}_{\\mu}^{\\leq d}[\\pmb{X}]</span>.</li>

    </ul>

    <p class="text-gray-300">Multivariate ZeroTest Poly-IOP. The prover wants to show to the verifier that a multivariate polynomial <span class="math">f \\in \\mathbb{F}_{\\mu}^{\\leq d}[\\pmb{X}]</span> satisfies <span class="math">f(\\pmb{x}) = 0</span> for all <span class="math">\\pmb{x} \\in B_{\\mu}</span>. The protocol reduces ZeroTest to SumCheck, and is described as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> samples and sends to <span class="math">\\mathcal{P}</span> a random vector <span class="math">\\pmb{r} \\gets \\mathbb{F}^{\\mu}</span>.</li>

      <li>Let <span class="math">\\tilde{f}(\\pmb{x}) \\coloneqq f(\\pmb{x}) \\cdot \\chi_{\\pmb{r}}(\\pmb{x})</span>. <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> run multilinear SumCheck on <span class="math">\\tilde{f}</span> with target value 0.</li>

    </ul>

    <p class="text-gray-300">We argue that this protocol is complete. Let <span class="math">g(\\pmb{y}) \\coloneqq \\sum_{\\pmb{x} \\in B_{\\mu}} f(\\pmb{x}) \\cdot \\chi_{\\pmb{y}}(\\pmb{x})</span>. Then it is clear that <span class="math">g(\\pmb{y}) = f(\\pmb{y})</span> for all <span class="math">\\pmb{y} \\in B_{\\mu}</span>. Since <span class="math">g</span> is multilinear, we have <span class="math">g(\\pmb{y})</span> is zero polynomial if and only if <span class="math">f(\\pmb{y})</span> is zero over <span class="math">B_{\\mu}</span>.</p>

    <p class="text-gray-300">Multivariate PermTest Poly-IOP. Let <span class="math">f \\in \\mathbb{F}_{\\mu}^{\\leq d}[\\pmb{X}]</span> be a multivariate polynomial. Let <span class="math">\\sigma : B_{\\mu} \\to B_{\\mu}</span> be a permutation over <span class="math">B_{\\mu}</span>. The prover wants to show to the verifier that <span class="math">f(\\pmb{x}) = f(\\sigma(\\pmb{x}))</span> for all <span class="math">\\pmb{x} \\in B_{\\mu}</span>. The multivariate PermTest Poly-IOP is described as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">s, s_{\\sigma} \\in \\mathbb{F}_{\\mu}^{\\leq 1}[\\pmb{X}]</span> be two mappings, where <span class="math">s(\\pmb{x}) \\coloneqq [\\pmb{x}]</span> and <span class="math">s_{\\sigma}(\\pmb{x}) \\coloneqq [\\sigma(\\pmb{x})]</span>.</li>

      <li><span class="math">\\mathcal{V}</span> samples and sends to the prover <span class="math">\\gamma, \\delta \\gets \\mathbb{F}</span>.</li>

      <li>Let <span class="math">f_{1} \\coloneqq f + \\gamma s + \\delta</span> and <span class="math">f_{2} \\coloneqq f + \\gamma s_{\\sigma} + \\delta</span>. <span class="math">\\mathcal{P}</span> builds a multilinear polynomial <span class="math">z \\in \\mathbb{F}_{\\mu + 1}^{\\leq 1}</span> such that for all</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\bm{x}\\in B_{\\mu}</span></p>

    <p class="text-gray-300">\\[ \\begin{cases}z(0,\\bm{x})=f_{1}(\\bm{x})/f_{2}(\\bm{x})\\\\ z(1,\\bm{x})=z(\\bm{x},0)\\cdot z(\\bm{x},1)\\end{cases} \\]</p>

    <p class="text-gray-300">Let <span class="math">w_{1}(\\bm{x}):=z(1,\\bm{x})-z(\\bm{x},0)\\cdot z(\\bm{x},1)</span> and <span class="math">w_{2}(\\bm{x}):=f_{2}(\\bm{x})\\cdot z(0,\\bm{x})-f_{1}(\\bm{x})</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> sends the oracle of <span class="math">z</span> to <span class="math">\\mathcal{V}</span>.</li>

      <li><span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> run multilinear ZeroTest on <span class="math">w_{1}</span> and <span class="math">w_{2}</span>.</li>

      <li><span class="math">\\mathcal{V}</span> queries <span class="math">z(1,1,\\cdots,1,0)</span> and checks if it is 1.</li>

    </ul>

    <p class="text-gray-300">The HyperPlonk Poly-IOP. The HyperPlonk Poly-IOP is structured as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input Constraint: <span class="math">F(1,\\cdots,1,\\bm{x})-I(\\bm{x})=0</span> for all <span class="math">\\bm{x}\\in B_{\\nu}</span> with multilinear ZeroTest.</li>

      <li>Output Constraint: <span class="math">\\mathcal{V}</span> queries <span class="math">F(1,0,\\langle N-1\\rangle_{\\mu})</span> and checks if it is zero.</li>

      <li>Gate Constraint: Define a multivariate polynomial</li>

    </ul>

    <p class="text-gray-300"><span class="math">G(\\bm{x}):=</span> <span class="math">S_{\\text{add}}(\\bm{x})(F(0,0,\\bm{x})+F(0,1,\\bm{x}))</span> <span class="math">+S_{\\text{mult}}(\\bm{x})(F(0,0,\\bm{x})\\cdot F(0,1,\\bm{x}))-F(1,0,\\bm{x}).</span></p>

    <p class="text-gray-300"><span class="math">G(\\bm{x})=0</span> for all <span class="math">\\bm{x}\\in B_{\\mu}</span> with multivariate ZeroTest.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Wiring Constraint: Check if <span class="math">F(\\bm{x})=F(\\sigma_{\\mu}(\\bm{x}))</span> for all <span class="math">\\bm{x}\\in B_{\\mu}</span> with multivariate PermTest.</li>

    </ul>

    <h3 id="sec-43" class="text-xl font-semibold mt-8">IV-C Multilinear KZG PCS</h3>

    <p class="text-gray-300">We now present the multilinear KZG PCS which is developed upon the scheme in <em>[39, 25, 6]</em> for the multilinear polynomials. It is shown in <em>[6]</em> that to commit a <span class="math">\\mu</span>-variate multilinear polynomial <span class="math">f</span>, the cost of the prover is <span class="math">O(2^{\\mu})</span> group operations. To open <span class="math">f</span>, the cost of the prover is <span class="math">O(2^{\\mu})</span> group operations, and the proof size is <span class="math">O(\\mu)</span> group elements. The cost of the verifier is <span class="math">O(\\mu)</span> bilinear mappings and <span class="math">O(\\mu)</span> group operations.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>KeyGen<span class="math">(1^{\\lambda},\\mu,d)</span>: Generate <span class="math">\\mathsf{crs}=(\\tau_{1},\\cdots,\\tau_{\\mu},(U_{\\bm{b}}:=g^{\\chi_{\\bm{b}}(\\bm{\\tau})})_{\\bm{b}\\in B_{\\mu}})</span>, where <span class="math">\\tau_{1},\\cdots,\\tau_{\\mu}</span> are secrets.</li>

      <li>Commit<span class="math">(f,\\mathsf{crs})</span>: Suppose <span class="math">f(x)=\\sum_{\\bm{b}\\in B_{\\mu}}f_{\\bm{b}}\\cdot\\chi_{\\bm{b}}(\\bm{x})</span>. <span class="math">\\mathcal{P}</span> computes <span class="math">\\mathsf{com}:=\\prod_{\\bm{b}\\in B_{\\mu}}U_{\\bm{b}}^{f_{\\bm{b}}}</span>.</li>

      <li>Open<span class="math">(f,\\bm{a},\\mathsf{crs})</span>: <span class="math">\\mathcal{P}</span> has <span class="math">y:=f(\\bm{a})</span> locally stored. Then it evaluates the multilinear degree-1 polynomials <span class="math">q_{i}(\\bm{x})</span> such that <span class="math">f(\\bm{x})-y=\\sum_{i\\in[\\mu]}(x_{i}-a_{i})q_{i}(\\bm{x})</span>. Then it computes <span class="math">\\pi_{i}=g^{q_{i}(\\bm{\\tau})}</span>, and takes <span class="math">\\bm{\\pi}</span> as proof of the opening.</li>

      <li>Verify<span class="math">(\\mathsf{com},\\bm{\\pi},\\bm{a},y,\\mathsf{crs})</span>: The verifier checks if <span class="math">e(\\mathsf{com}/g^{y},g)=\\prod_{i\\in[\\mu]}e(\\pi_{i},g^{\\tau_{i}-a_{i}})</span>.</li>

    </ul>

    <h3 id="sec-44" class="text-xl font-semibold mt-8">IV-D Application to SNARK Outsourcing</h3>

    <p class="text-gray-300">With Cirrus, we propose a novel design for outsourcing ZK-SNARKs. We focus on using trusted execution environments (TEEs) <em>[40]</em> to enable efficient ZK-SNARK outsourcing while keeping the secret inputs of the users private. TEEs provide a secure enclave within a processor, where sensitive data and computations can be performed in isolation from the rest of the system. TEEs ensure that even privileged users, such as system administrators, cannot access the data or computation within the enclave. This isolation, combined with the ability to verify the integrity of the execution through remote attestation, makes TEEs a powerful tool for securely outsourcing ZK-SNARK generation. By leveraging TEEs, we can achieve efficient computation while ensuring that the secret inputs remain protected throughout the outsourcing process.</p>

    <p class="text-gray-300">The use of Trusted Execution Environments (TEEs) as a straightforward approach for generating ZK-SNARKs is likely to face considerable performance bottlenecks due to the high memory demands inherent to ZK-SNARK generation. This process involves substantial cryptographic computations—such as group exponentiations and bilinear mappings—that require significant memory resources, posing a challenge to the efficiency of TEE-based solutions. Given that most TEEs, like Intel SGX, provide relatively small secure memory enclaves (e.g., 128 MB or less of usable secure memory), such operations quickly exceed the available memory within the enclave, leading to frequent page thrashing. Page thrashing occurs when memory pages are continuously swapped between the secure enclave and untrusted memory, drastically increasing latency. <em>[41]</em> This is particularly problematic for ZK-SNARK generation, where each cryptographic operation must maintain high integrity and constant memory evictions introduce significant overhead.</p>

    <p class="text-gray-300">With Cirrus, we can use the memory-efficient property of the scheme on TEEs to build an efficient TEE-based ZK-SNARK outsourcing protocol. By combining the parallel processing capabilities of Cirrus with the secure computation environment of TEEs, our solution not only addresses the memory bottleneck but also ensures that the secret inputs remain protected during the proof generation process. This hybrid approach allows for both scalable and secure ZK-SNARK outsourcing, overcoming the memory limitations typically associated with TEEs while preserving privacy guarantees.</p>`;
---

<BaseLayout title="$\mathsf{Cirrus}$: Performant and Accountable Distributed SN... (2024/1873)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/1873
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
