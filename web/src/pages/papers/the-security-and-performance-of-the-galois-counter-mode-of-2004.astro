---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/193';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'The Security and Performance of the Galois/Counter Mode of Operation (Full Version)';
const AUTHORS_HTML = 'David A.  McGrew, John Viega';

const CONTENT = `    <p class="text-gray-300">David A. McGrew¹ and John Viega² mcgrew@cisco.com,viega@securesoftware.com</p>

    <p class="text-gray-300">† Cisco Systems, Inc., ‡ Secure Software</p>

    <p class="text-gray-300">Abstract. The recently introduced Galois/Counter Mode (GCM) of operation for block ciphers provides both encryption and message authentication, using universal hashing based on multiplication in a binary finite field. We analyze its security and performance, and show that it is the most efficient mode of operation for high speed packet networks, by using a realistic model of a network crypto module and empirical data from studies of Internet traffic in conjunction with software experiments and hardware designs. GCM has several useful features: it can accept IVs of arbitrary length, can act as a stand-alone message authentication code (MAC), and can be used as an incremental MAC. We show that GCM is secure in the standard model of concrete security, even when these features are used. We also consider several of its important system-security aspects.</p>

    <p class="text-gray-300">The Galois/Counter Mode (GCM) of operation for block ciphers was designed to meet the need for an authenticated encryption mode that can efficiently achieve speeds of 10 gigabits per second and higher in hardware, can perform well in software, and is free of intellectual property restrictions. It was recently submitted to several standards venues, including the NIST Modes of Operation process [19], IEEE 802.1AE Link Security [23], where it is the mandatory-to-implement cryptoalgorithm in the current draft standard, and IPsec [26]. In the following, we consider its performance and security.</p>

    <p class="text-gray-300">The counter mode of operation (CTR) has become the mode of choice for high speed applications, because it can be efficiently pipelined in hardware implementations. However, it provides no message authentication. GCM incorporates CTR and builds on it by adding a message authentication code (MAC) based on universal hashing [27, 17]. It uses polynomial hashing in the finite field <span class="math">GF(2^w)</span>, the core operation of which is multiplication by a fixed field element. The binary field multiplication can be implemented easily in hardware, and can be made surprisingly efficient in software via table-driven methods. Additionally, GCM can be used as a stand-alone MAC, and can be used as an incremental MAC [3].</p>

    <p class="text-gray-300">This paper is structured as follows. In Section 1.1 we review existing work on authenticated encryption with associated data (AEAD) methods <em>[21]</em>. In Section 2 we briefly review the GCM definition. In Section 3 we analyze and describe its performance in hardware are software, and compare it to other AEAD modes of operation. In Section 4, we review our analysis of GCM in the concrete model; proofs of our results are provided in the Appendices. In Section 5 we consider several important system-security aspects. An abridged version of this paper appeared as an extended abstract <em>[20]</em>, in which the appendices were omitted.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Overview of Authenticated Encryption Modes</h3>

    <p class="text-gray-300">Recently, many authenticated encryption modes have been proposed, because of the efficiency and usability benefits of the combined approach. The first such mode was Jutla’s IAPM (Integrity-Aware Parallelizable) mode <em>[14]</em>. The better known OCB (Offset Code Book) mode <em>[22]</em> is a refinement of IAPM. Both of these modes are parallelizable, making them suitable for high-speed hardware implementations (though they cannot take complete advantage of pipelining; see Section 3). Independently, Gligor and Donescu proposed several authenticated encryption modes <em>[12]</em>. All of the above modes are covered by patents, which has motivated some other work in this space. CCM <em>[28]</em> uses a single key and combines CTR mode with CBC-MAC to produce an authenticated encryption scheme. However, CCM is not suited to high-speed implementations, because CBC-MAC is neither pipel enable nor parallelizable. EAX <em>[7]</em> is a patent-free mode similar to CCM, combining CTR with the OMAC <em>[13]</em> variant of CBC-MAC. OMAC cannot be pipelined or parallelized, so neither can EAX. However, EAX solves some minor issues unique to CCM: it is not on-line, meaning that the message length must be known before one can start processing the message, and there are cases in which it does not preserve word alignment. CWC mode <em>[16]</em> is both patent-free and fully parallelizable; it combines CTR with a MAC based on a universal hash function over <span class="math">GF(2^{127}-1)</span>. Due to its use of an integer multiply operation, CWC is relatively expensive to implement in hardware.</p>

    <p class="text-gray-300">One useful feature of many authenticated encryption schemes is the ability to authenticate associated data that is not part of the message, such as packet headers. IAPM and OCB are the only two modes we have discussed that have no facilities for this. Another interesting feature, introduced by EAX, is the ability to accept arbitrary-length IVs (most modes use IVs no longer than the cipher block width). This facility increases the usability of the mode, but has the disadvantage of requiring additional processing - particularly in hardware, where a pipeline stall caused by IV processing can significantly impact throughput. GCM supports arbitrary sized IVs, but is optimized for the 12-byte case. As with most modes, GCM uses a single key, supports additional authenticated data, preserves data alignment in all cases, and is on-line.</p>

    <p class="text-gray-300">GCM’s design draws from several sources. It uses CTR for encryption, and uses a polynomial hash, like CWC, but with a relatively inexpensive binary field. Its architecture follows that of the Universal Security Transform <em>[18]</em>, which enables it to be efficiently pipelined.</p>

    <p class="text-gray-300">2 GCM Definition</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We briefly review the definition of GCM, closely following its specification <em>[19]</em>, but considering a block cipher with a width of <span class="math">w\\geq 64</span> bits, instead of focusing on the 128-bit wide Advanced Encryption Standard (AES) <em>[25]</em>. We assume that <span class="math">w</span> is even. The two main functions that GCM uses are block cipher encryption and multiplication over the field <span class="math">GF(2^{w})</span>; it defines a particular field, but its details are irrelevant to our analysis. The block cipher encryption of the value <span class="math">X\\in\\{0,1\\}^{w}</span> with the key <span class="math">K</span> is denoted as <span class="math">E(K,X)</span>. The multiplication of two elements <span class="math">X,Y\\in GF(2^{w})</span> is denoted as <span class="math">X\\cdot Y</span>, and the addition of <span class="math">X</span> and <span class="math">Y</span> is denoted as <span class="math">X\\oplus Y</span>. The function <span class="math">\\mathrm{len}(S)</span> takes a bit string <span class="math">S</span> with a length between zero and <span class="math">2^{w/2}-1</span>, inclusive, and returns a <span class="math">w/2</span>-bit string containing the nonnegative integer describing the number of bits in its argument, with the least significant bit on the right. The expression <span class="math">0^{l}</span> denotes a string of <span class="math">l</span> zero bits, and $A\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B<span class="math"> denotes the concatenation of two bit strings </span>A<span class="math"> and </span>B<span class="math">. The function </span>\\mathrm{MSB}_{t}(S)<span class="math"> takes a bit string </span>S<span class="math"> and returns the bit string containing only the leftmost </span>t<span class="math"> bits of </span>S<span class="math">, and the symbol </span>\\{\\}$ denotes the bit string with zero length.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The authenticated encryption operation takes as inputs a secret key <span class="math">K</span>, initialization vector <span class="math">IV</span>, a plaintext <span class="math">P</span>, and additional authenticated data <span class="math">A</span>, and gives as its outputs a ciphertext <span class="math">C</span> and an authentication tag <span class="math">T</span>. These values are bit strings with lengths given as follows:</p>

    <p class="text-gray-300"><span class="math">0\\leq\\mathrm{len}(P)\\leq(2^{32}-2)w</span> (1) <span class="math">0\\leq\\mathrm{len}(A)\\leq 2^{w/2}</span> <span class="math">0&lt;\\mathrm{len}(IV)\\leq 2^{w/2}</span> <span class="math">\\mathrm{len}(C)=\\mathrm{len}(P)</span> <span class="math">\\mathrm{len}(T)=t\\leq w,</span></p>

    <p class="text-gray-300">where the parameter <span class="math">t</span> is fixed for each instance of the key. The secret key has a length appropriate to the block cipher, and is only used as an input to that cipher. For each fixed value of <span class="math">K</span>, each value of the IV must be distinct, but those values need not have equal lengths. The authenticated decryption operation has five inputs: <span class="math">K,IV,C,A,</span> and <span class="math">T</span>, as defined above. It has only one output, either the plaintext value <span class="math">P</span> or the special symbol <span class="math">\\mathbf{FAIL}</span> that indicates that its inputs are not authentic.</p>

    <p class="text-gray-300">During the encryption and decryption processes, the bit strings <span class="math">P</span>, <span class="math">C</span>, and <span class="math">A</span> are broken up into <span class="math">w</span>-bit blocks. We let <span class="math">n</span> and <span class="math">u</span> denote the unique pair of positive integers such that the total number of bits in the plaintext is <span class="math">(n-1)w+u</span>, where <span class="math">1\\leq u\\leq w</span>, when <span class="math">\\mathrm{len}(P)&gt;0</span>; otherwise <span class="math">n=u=0</span>. The plaintext consists of a sequence of <span class="math">n</span> bit strings, in which the bit length of the last bit string is <span class="math">u</span>, and the bit length of the other bit strings is <span class="math">w</span>. The sequence is denoted <span class="math">P_{1},P_{2},\\ldots,P_{n-1},P_{n}^{<em>}</span> , and the bit strings are called data blocks, although the last bit string, <span class="math">P_{n}^{</em>}</span> , may not be a complete block. Similarly, the ciphertext is denoted as <span class="math">C_{1},C_{2},\\ldots,C_{n-1},C_{n}^{<em>}</span>, where the number of bits in the final block <span class="math">C_{n}^{</em>}</span> is <span class="math">u</span>. The additional authenticated data <span class="math">A</span> is denoted as <span class="math">A_{1},A_{2},\\ldots,A_{m-1},A_{m}^{*}</span>,</p>

    <p class="text-gray-300">where the last bit string <span class="math">A_{m}^{*}</span> may be a partial block of length <span class="math">v</span>, and <span class="math">m</span> and <span class="math">v</span> denote the unique pair of positive integers such that the total number of bits in <span class="math">A</span> is <span class="math">(m-1)w+v</span> and <span class="math">1\\leq v\\leq w</span>, when <span class="math">\\mathrm{len}(A)&amp;gt;0</span>; otherwise <span class="math">m=v=0</span>. The authenticated encryption operation is defined by the following equations:</p>

    <p class="text-gray-300"><span class="math">H</span> <span class="math">=E(K,0^{w})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">Y_{0}</span> \\[ =\\begin{cases}IV\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{31}1&\\text{if }\\mathrm{len}(IV)=w-32\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathrm{GHASH}(H,\\{\\},IV)&\\text{otherwise.}\\end{cases} \\] <span class="math">Y_{i}</span> <span class="math">=\\mathrm{incr}(Y_{i-1})\\text{ for }i=1,\\ldots,n</span> (2) <span class="math">C_{i}</span> <span class="math">=P_{i}\\oplus E(K,Y_{i})\\text{ for }i=1,\\ldots,n-1</span> <span class="math">C_{n}^{<em>}</span> <span class="math">=P_{n}^{</em>}\\oplus\\mathrm{MSB}_{u}(E(K,Y_{n}))</span> <span class="math">T</span> <span class="math">=\\mathrm{MSB}_{t}(\\mathrm{GHASH}(H,A,C)\\oplus E(K,Y_{0}))</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Successive counter values are generated using the function <span class="math">\\mathrm{incr}()</span>, which treats the rightmost 32 bits of its argument as a nonnegative integer with the least significant bit on the right, and increments this value modulo <span class="math">2^{32}</span>. More formally, the value of $\\mathrm{incr}(F\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I)<span class="math"> is </span>F\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(I+1\\bmod 2^{32})<span class="math">. The function </span>\\mathrm{GHASH}<span class="math"> is defined by </span>\\mathrm{GHASH}(H,A,C)=X_{m+n+1}<span class="math">, where the inputs </span>A<span class="math"> and </span>C<span class="math"> are formatted as described above, and the variables </span>X_{i}<span class="math"> for </span>i=0,\\ldots,m+n+1$ are defined as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\[ X_{i}=\\begin{cases}0&\\text{for }i=0\\\\ (X_{i-1}\\oplus A_{i})\\cdot H&\\text{for }i=1,\\ldots,m-1\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(X_{m-1}\\oplus(A_{m}^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{w-v}))\\cdot H&\\text{for }i=m\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(X_{i-1}\\oplus C_{i-m})\\cdot H&\\text{for }i=m+1,\\ldots,m+n-1\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(X_{m+n-1}\\oplus(C_{n}^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{w-u}))\\cdot H&\\text{for }i=m+n\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-4" class="text-2xl font-bold">3 Performance</h2>

    <p class="text-gray-300">We considered the performance of various modes of operation of the AES-128 block cipher in both hardware and software. We use a simple model of a network crypto module in order to analyze the performance of different AEAD modes under realistic conditions. The module consists of a device that accepts a continuous stream unprotected data packets on one interface and then outputs the stream of encrypted and authenticated packets out another interface. We assume that the key is present in the module, and that the mode and data encapsulation are fixed, in order to focus on the data processing performance. We assume that the module contains a clock which runs at a fixed rate. In general, the number of clock cycles <span class="math">C(s)</span> required to process a packet with <span class="math">s</span> bytes varies as a function of <span class="math">s</span>. We assume that the packet sizes are distributed probabilistically, where the probability of having size <span class="math">s</span> is <span class="math">\\mathbf{P}[S=s]</span>. The expected number of clocks per byte</p>

    <p class="text-gray-300"><span class="math">C</span> of the module is <span class="math">C=\\sum_{s}C(s)f(s)</span>, where</p>

    <p class="text-gray-300"><span class="math">f(s)=\\frac{\\mathbf{P}[S=s]}{\\sum_{r}r\\mathbf{P}[S=r]}</span> (4)</p>

    <p class="text-gray-300">is the expected fraction of bytes that are carried in packets of size <span class="math">s</span>. The function <span class="math">f(s)</span> is important because it can be empirically observed. Studies of Internet traffic reveal a predominance of small packets, with peaks in the distribution of packet sizes at 44, 552, 576, and 1500 bytes, and very few packets with larger sizes <em>[10]</em>, reflecting the nature of the TCP/IP protocol family. About half of the data on the Internet is carried in packets of 576 bytes or less, and most of the remainder is carried in packets of about 1500 bytes. We defined the <em>Internet Performance Index</em> (IPI) as the expected number of bits processed per clock cycle when the packet distribution has the values <span class="math">f(1500)=.6</span>, <span class="math">f(576)=.2</span>, <span class="math">f(552)=.15</span>, and <span class="math">f(44)=.05</span>, using data from <em>[10]</em>. This index is a useful indicator of the performance of a crypto module that protects IP traffic using e.g. the Encapsulating Security Payload (ESP) <em>[15]</em> in tunnel mode, the protocol which underlies most Virtual Private Networks.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">3.1 Hardware</h3>

    <p class="text-gray-300">A typical high-speed AES-128 implementation consists of a pipeline of ten units, each of which implements a single AES round. At each clock cycle, data moves from one unit to the next, and 128 bits enter the pipeline and the same number leave the pipeline as output. In the following, we describe and analyze the best GCM, CWC, and OCB implementations that use a single instance of this AES pipeline. We disregard the other modes, since they use cipher block chaining and thus cannot be implemented in this manner. We require that packets be processed sequentially, rather than concurrently, because the complexity and circuit cost of the concurrent approach makes sequential processing more desirable in practice. In our performance analysis we determine the value of <span class="math">C(s)</span> for each mode and tabulate the results, and also compare the circuit costs for the modes. Data from multiple packets may be in the module simultaneously. To account for this fact, we measure <span class="math">C(s)</span> by counting the number of cycles between the time when the last data from one protected packet leaves the module and when the initial data from the next protected packet leaves the module. Our hardware implementation model is not detailed, but it very effectively reveals the effects of pipeline stalls on performance; a <em>stall</em> occurs when a circuit is not generating outputs for some number of clock cycles.</p>

    <p class="text-gray-300">GCM can easily take advantage of the AES pipeline (Figure 1, top), as long as a 96-bit IV is used (as is recommended for high-speed implementations). We use a finite-field multiplier over <span class="math">GF(2^{w})</span> that executes in a single clock cycle. An important property of the mode is that the counter <span class="math">Y_{0}</span> that is used to encrypt the GHASH output can immediately follow the other counters through the AES pipeline, so that after the plaintext is encrypted, only one additional clock is needed to compute the authentication tag. Thus GCM can achieve</p>

    <p class="text-gray-300"><span class="math">C(s) = \\lceil s / 16\\rceil +1</span>  by having the data from each packet immediately follow that of the previous packet through the pipeline. CWC is similar but requires an additional AES encryption to process the authentication tag. This causes a pipeline stall of 10 clock cycles during which the tag passes through the AES pipeline; thus for CWC,  <span class="math">C(s) = \\lceil s / 16\\rceil +11</span></p>

    <p class="text-gray-300">In OCB (Figure 1, bottom), the AES pipeline is used in three distinct ways: to encrypt the IV, to encrypt the plaintext, and to compute the authentication tag. The pipeline stalls for ten clock cycles while the IV is being encrypted. After that computation, the stall continues for another ten clock cycles, until the plaintext that is being encrypted appears at the output of the pipeline as ciphertext. After all of the plaintext has been encrypted, the 'checksum' value is encrypted; this operation requires only a single clock cycle, because the data from the IV-encryption of the next packet can follow the data from the checksum-encryption through the pipeline. Thus OCB can achieve  <span class="math">C_{\\mathrm{OCB}} = \\lceil s / 16 \\rceil + 21</span> . In Table</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 1. Pipelined high-speed implementations of AES-128 GCM (top) and AES-128 OCB (bottom). During each clock cycle, 128 bits of data move across each arrow. Some details have been omitted for clarity.</p>

    <p class="text-gray-300">1, we compare the GCM, CWC, and OCB implementations described above. Various data sizes are included, along with the Internet Performance Index, and throughput is shown in bits per clock cycle. GCM excels the other modes in every category, especially at shorter lengths, because it keeps its pipeline full. In a crypto module that can process 128 bits per clock cycle, an ten-cycle pipeline</p>

    <p class="text-gray-300">stall has a considerable opportunity cost: 160 bytes could be encrypted during that time. GCM performance on the IPI is over twice that of CWC and over three times that of OCB. The circuit cost of GCM is higher than that of OCB because of its finite-field multiplier, but GCM is still the most economical mode for high-speed operation. Even in the unlikely case that this multiplier required a circuit as large as the entire AES pipeline, a single GCM instance would have higher throughput on Internet data than three OCB implementations, while having less total circuit area. The cost of a single-clock  <span class="math">GF(2^{128})</span> -multiplier has been estimated at  <span class="math">30\\%</span>  of the cost of the AES-128 pipeline; a detailed analysis of this cost is beyond the scope of this paper. The circuit cost of CWC is significantly higher than that of GCM because it uses an integer multiplier rather than a binary-field multiplier.</p>

    <p class="text-gray-300">Table 1. Hardware performance in bits per clock cycle, with three significant digits, for a variety of packet sizes and the Internet Performance Index (IPI).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bytes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">20</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">40</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">44</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">64</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">256</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">552</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">576</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1024</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1500</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8192</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">IPI</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GCM</td>

            <td class="px-3 py-2 border-b border-gray-700">64.0</td>

            <td class="px-3 py-2 border-b border-gray-700">71.1</td>

            <td class="px-3 py-2 border-b border-gray-700">91.4</td>

            <td class="px-3 py-2 border-b border-gray-700">93.9</td>

            <td class="px-3 py-2 border-b border-gray-700">102</td>

            <td class="px-3 py-2 border-b border-gray-700">114</td>

            <td class="px-3 py-2 border-b border-gray-700">120</td>

            <td class="px-3 py-2 border-b border-gray-700">124</td>

            <td class="px-3 py-2 border-b border-gray-700">124</td>

            <td class="px-3 py-2 border-b border-gray-700">126</td>

            <td class="px-3 py-2 border-b border-gray-700">127</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">77.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CWC</td>

            <td class="px-3 py-2 border-b border-gray-700">10.7</td>

            <td class="px-3 py-2 border-b border-gray-700">13.1</td>

            <td class="px-3 py-2 border-b border-gray-700">23.7</td>

            <td class="px-3 py-2 border-b border-gray-700">25.6</td>

            <td class="px-3 py-2 border-b border-gray-700">34.1</td>

            <td class="px-3 py-2 border-b border-gray-700">53.9</td>

            <td class="px-3 py-2 border-b border-gray-700">75.9</td>

            <td class="px-3 py-2 border-b border-gray-700">97.0</td>

            <td class="px-3 py-2 border-b border-gray-700">98.0</td>

            <td class="px-3 py-2 border-b border-gray-700">109</td>

            <td class="px-3 py-2 border-b border-gray-700">115</td>

            <td class="px-3 py-2 border-b border-gray-700">125</td>

            <td class="px-3 py-2 border-b border-gray-700">35.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">OCB</td>

            <td class="px-3 py-2 border-b border-gray-700">5.82</td>

            <td class="px-3 py-2 border-b border-gray-700">7.19</td>

            <td class="px-3 py-2 border-b border-gray-700">13.6</td>

            <td class="px-3 py-2 border-b border-gray-700">14.8</td>

            <td class="px-3 py-2 border-b border-gray-700">20.5</td>

            <td class="px-3 py-2 border-b border-gray-700">35.3</td>

            <td class="px-3 py-2 border-b border-gray-700">55.4</td>

            <td class="px-3 py-2 border-b border-gray-700">79.6</td>

            <td class="px-3 py-2 border-b border-gray-700">80.8</td>

            <td class="px-3 py-2 border-b border-gray-700">96.4</td>

            <td class="px-3 py-2 border-b border-gray-700">105</td>

            <td class="px-3 py-2 border-b border-gray-700">123</td>

            <td class="px-3 py-2 border-b border-gray-700">22.8</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We tested software implementations of GCM, EAX, CCM, CWC, and OCB, each instantiated with the AES-128 cipher [25]. We also included CBC with HMAC-SHA1 to represent common current practice. We used the best available implementation of each mode, modified to use the fastest available AES implementation. All experiments took place on a 1Ghz Motorola G4 CPU using the GNU C compiler version 3.3 with full optimization. In this environment, AES-128 itself ran at 25 cycles per byte <span class="math">^{1}</span> . Qualitatively similar results were found on an Intel P4 [11], though CWC performed better on that  <span class="math">\\mathrm{CPU}^2</span> . We tested GCM with both of the GHASH implementation strategies described in its specification, using 256 byte and 4Kb tables with Shoup's method [24] and 64Kb with the straightforward method. Table 2 shows our results. GCM has the best performance for the Internet Performance Index and on packets up to 576 bytes, while OCB has the best performance on larger packets. This result is easy to understand: OCB uses one more AES encryption per packet, while GCM does a  <span class="math">GF(2^{w})</span> -multiply operation per block that OCB does not. The point at which</p>

    <p class="text-gray-300">their performance is equal reflects the number of multiplies that can be done in the time taken for a single AES encryption.</p>

    <p class="text-gray-300">Table 2. Software performance in bits per kilocycle (or equivalently, megabits per second on a 1GHz processor) to three significant digits, on various packet sizes, and the Internet Performance Index (IPI), for various AES-128 modes of operation. GCM256, GCM4K, and GCM64K refer to GCM with 256, 4K, and 64K byte table sizes, respectively. The highest entry in each column is highlighted.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bytes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">20</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">40</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">44</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">64</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">256</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">552</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">576</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1024</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1500</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8192</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">IPI</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GCM64K</td>

            <td class="px-3 py-2 border-b border-gray-700">136</td>

            <td class="px-3 py-2 border-b border-gray-700">167</td>

            <td class="px-3 py-2 border-b border-gray-700">227</td>

            <td class="px-3 py-2 border-b border-gray-700">253</td>

            <td class="px-3 py-2 border-b border-gray-700">223</td>

            <td class="px-3 py-2 border-b border-gray-700">263</td>

            <td class="px-3 py-2 border-b border-gray-700">267</td>

            <td class="px-3 py-2 border-b border-gray-700">273</td>

            <td class="px-3 py-2 border-b border-gray-700">273</td>

            <td class="px-3 py-2 border-b border-gray-700">266</td>

            <td class="px-3 py-2 border-b border-gray-700">266</td>

            <td class="px-3 py-2 border-b border-gray-700">258</td>

            <td class="px-3 py-2 border-b border-gray-700">268</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GCM4K</td>

            <td class="px-3 py-2 border-b border-gray-700">116</td>

            <td class="px-3 py-2 border-b border-gray-700">140</td>

            <td class="px-3 py-2 border-b border-gray-700">190</td>

            <td class="px-3 py-2 border-b border-gray-700">207</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">213</td>

            <td class="px-3 py-2 border-b border-gray-700">229</td>

            <td class="px-3 py-2 border-b border-gray-700">237</td>

            <td class="px-3 py-2 border-b border-gray-700">233</td>

            <td class="px-3 py-2 border-b border-gray-700">239</td>

            <td class="px-3 py-2 border-b border-gray-700">247</td>

            <td class="px-3 py-2 border-b border-gray-700">240</td>

            <td class="px-3 py-2 border-b border-gray-700">240</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GCM256</td>

            <td class="px-3 py-2 border-b border-gray-700">88.4</td>

            <td class="px-3 py-2 border-b border-gray-700">107</td>

            <td class="px-3 py-2 border-b border-gray-700">148</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">177</td>

            <td class="px-3 py-2 border-b border-gray-700">162</td>

            <td class="px-3 py-2 border-b border-gray-700">171</td>

            <td class="px-3 py-2 border-b border-gray-700">183</td>

            <td class="px-3 py-2 border-b border-gray-700">184</td>

            <td class="px-3 py-2 border-b border-gray-700">181</td>

            <td class="px-3 py-2 border-b border-gray-700">183</td>

            <td class="px-3 py-2 border-b border-gray-700">182</td>

            <td class="px-3 py-2 border-b border-gray-700">182</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">OCB</td>

            <td class="px-3 py-2 border-b border-gray-700">89.5</td>

            <td class="px-3 py-2 border-b border-gray-700">85.7</td>

            <td class="px-3 py-2 border-b border-gray-700">140</td>

            <td class="px-3 py-2 border-b border-gray-700">150</td>

            <td class="px-3 py-2 border-b border-gray-700">185</td>

            <td class="px-3 py-2 border-b border-gray-700">225</td>

            <td class="px-3 py-2 border-b border-gray-700">255</td>

            <td class="px-3 py-2 border-b border-gray-700">261</td>

            <td class="px-3 py-2 border-b border-gray-700">265</td>

            <td class="px-3 py-2 border-b border-gray-700">273</td>

            <td class="px-3 py-2 border-b border-gray-700">275</td>

            <td class="px-3 py-2 border-b border-gray-700">282</td>

            <td class="px-3 py-2 border-b border-gray-700">260</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CWC</td>

            <td class="px-3 py-2 border-b border-gray-700">45.7</td>

            <td class="px-3 py-2 border-b border-gray-700">51.9</td>

            <td class="px-3 py-2 border-b border-gray-700">73.4</td>

            <td class="px-3 py-2 border-b border-gray-700">75.5</td>

            <td class="px-3 py-2 border-b border-gray-700">88.1</td>

            <td class="px-3 py-2 border-b border-gray-700">104</td>

            <td class="px-3 py-2 border-b border-gray-700">116</td>

            <td class="px-3 py-2 border-b border-gray-700">127</td>

            <td class="px-3 py-2 border-b border-gray-700">126</td>

            <td class="px-3 py-2 border-b border-gray-700">131</td>

            <td class="px-3 py-2 border-b border-gray-700">124</td>

            <td class="px-3 py-2 border-b border-gray-700">135</td>

            <td class="px-3 py-2 border-b border-gray-700">121</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">EAX</td>

            <td class="px-3 py-2 border-b border-gray-700">46.0</td>

            <td class="px-3 py-2 border-b border-gray-700">44.9</td>

            <td class="px-3 py-2 border-b border-gray-700">73.4</td>

            <td class="px-3 py-2 border-b border-gray-700">80.0</td>

            <td class="px-3 py-2 border-b border-gray-700">102</td>

            <td class="px-3 py-2 border-b border-gray-700">129</td>

            <td class="px-3 py-2 border-b border-gray-700">148</td>

            <td class="px-3 py-2 border-b border-gray-700">157</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">165</td>

            <td class="px-3 py-2 border-b border-gray-700">167</td>

            <td class="px-3 py-2 border-b border-gray-700">174</td>

            <td class="px-3 py-2 border-b border-gray-700">156</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CCM</td>

            <td class="px-3 py-2 border-b border-gray-700">91.3</td>

            <td class="px-3 py-2 border-b border-gray-700">88.9</td>

            <td class="px-3 py-2 border-b border-gray-700">123</td>

            <td class="px-3 py-2 border-b border-gray-700">133</td>

            <td class="px-3 py-2 border-b border-gray-700">142</td>

            <td class="px-3 py-2 border-b border-gray-700">171</td>

            <td class="px-3 py-2 border-b border-gray-700">163</td>

            <td class="px-3 py-2 border-b border-gray-700">168</td>

            <td class="px-3 py-2 border-b border-gray-700">168</td>

            <td class="px-3 py-2 border-b border-gray-700">174</td>

            <td class="px-3 py-2 border-b border-gray-700">172</td>

            <td class="px-3 py-2 border-b border-gray-700">175</td>

            <td class="px-3 py-2 border-b border-gray-700">168</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CBC-HMAC</td>

            <td class="px-3 py-2 border-b border-gray-700">6.3</td>

            <td class="px-3 py-2 border-b border-gray-700">8.0</td>

            <td class="px-3 py-2 border-b border-gray-700">15.2</td>

            <td class="px-3 py-2 border-b border-gray-700">16.6</td>

            <td class="px-3 py-2 border-b border-gray-700">23.4</td>

            <td class="px-3 py-2 border-b border-gray-700">39.0</td>

            <td class="px-3 py-2 border-b border-gray-700">64.5</td>

            <td class="px-3 py-2 border-b border-gray-700">96.0</td>

            <td class="px-3 py-2 border-b border-gray-700">97.0</td>

            <td class="px-3 py-2 border-b border-gray-700">117</td>

            <td class="px-3 py-2 border-b border-gray-700">129</td>

            <td class="px-3 py-2 border-b border-gray-700">156</td>

            <td class="px-3 py-2 border-b border-gray-700">88.6</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">GCM can be used in an authentication-only mode, in which the data to be authenticated is included in  <span class="math">A</span>  and the plaintext has zero length. In this mode (called GMAC), GCM has even more compelling advantages over most other modes because it avoids calling the block cipher once per block of data. (CWC is the only other mode with this property.) For instance, GMAC in our software test environment can process 1500-byte packets in 10.2 cycles per byte, whereas PMAC, a stand-alone MAC based on OCB [8], requires 27.6 cycles per byte.</p>

    <p class="text-gray-300">The Secure Real-time Transport Protocol (SRTP) encrypts and authenticates real-time traffic, such as conversational voice, at the transport layer [1]. Typical plaintext sizes for this traffic include 20 bytes for the G.729 encoding, and 80 bytes for the G.721 encoding; GCM's performance on short packets makes it ideal for this application.</p>

    <p class="text-gray-300">The security of GCM stands on a single cryptographic conjecture: the block cipher  <span class="math">E</span>  is assumed to be a secure pseudorandom permutation (PRP). To paraphrase Occam, we do not multiply conjectures beyond necessity. This requirement is met when  <span class="math">E</span>  cannot be distinguished from a random permutation by an adversary that can choose its inputs and view its outputs. To formalize this idea, we use standard definitions from concrete security analysis, following [4]. The permutation oracle has the same interface as does the block cipher  <span class="math">E</span>  with a fixed key. It takes as input a plaintext in  <span class="math">\\{0,1\\}^w</span>  and returns a ciphertext in</p>

    <p class="text-gray-300"><span class="math">\\{0,1\\}^{w}</span>. We consider the experiment in which the adversary is given access to a permutation oracle and is challenged to determine whether it is the block cipher <span class="math">E</span> with a randomly selected key (we denote this event as <span class="math">B_{E}</span>), or a random permutation (which we denote as <span class="math">B_{E}^{c}</span>). Each of these cases occurs with probability of <span class="math">1/2</span>. During the experiment, the adversary makes queries to the oracle and receives its responses. Afterwards, the adversary returns a bit that indicates its guess as to the content of the oracle. We denote as <span class="math">D</span> the event that it guesses that <span class="math">B_{E}</span> occurred, and denote as <span class="math">D^{c}</span> the guess that <span class="math">B_{E}^{c}</span> occured.</p>

    <p class="text-gray-300">We define the <em>distinguishing advantage</em> <span class="math">A_{E}</span> as the adversary’s true positive probability less her false positive probability, that is,</p>

    <p class="text-gray-300"><span class="math">A_{E}=\\mathbf{P}[D\\mid B_{E}]-\\mathbf{P}[D\\mid B_{E}^{c}].</span> (5)</p>

    <p class="text-gray-300">Here we use the conventional notation that <span class="math">\\mathbf{P}[\\mathcal{X}]</span> denotes the probability that the event <span class="math">\\mathcal{X}</span> occurs, and <span class="math">\\mathbf{P}[\\mathcal{X}\\mid\\mathcal{Y}]=\\mathbf{P}[\\mathcal{X}\\cap\\mathcal{Y}]/\\mathbf{P}[\\mathcal{Y}]</span> denotes the probability that <span class="math">\\mathcal{X}</span> occurs, given that the event <span class="math">\\mathcal{Y}</span> has occured. We also use <span class="math">\\mathcal{X}\\cap\\mathcal{Y}</span> to denote the event in which both events <span class="math">\\mathcal{X}</span> and <span class="math">\\mathcal{Y}</span> occur, and use <span class="math">\\mathcal{X}^{c}</span> to denote the complement of <span class="math">\\mathcal{X}</span>, that is, the event that <span class="math">\\mathcal{X}</span> does not occur. We make the simplifying assumption that <span class="math">A_{E}&gt;0</span>, because an adversary that is consistently wrong can turn itself into one that is consistently right by just inverting its output. Thus the value <span class="math">A_{E}</span> ranges between <span class="math">0</span> and <span class="math">1</span>, inclusive.</p>

    <p class="text-gray-300">Our model for the security of an AEAD system follows Rogaway <em>[21]</em>. The <em>authenticated encryption oracle</em> models the GCM authenticated encryption operation. It takes as input the bit strings <span class="math">IV,A</span>, and <span class="math">P</span> and returns the bit strings <span class="math">C</span> and <span class="math">T</span>, whose lengths obey the restrictions of Equations 1. The <em>authenticated decryption oracle</em> accepts inputs of the form <span class="math">(IV,A,C,T)</span> and returns as its outputs either the special symbol <span class="math">\\mathbf{FAIL}</span> or the plaintext <span class="math">P</span>, where all of the bit strings are as defined above. We let the adversary choose the IVs, but assume that she is <em>nonce-respecting</em> and will not submit the same IV value to the same oracle multiple times (though she is free to submit a value to both oracles). We allow the adversary to interleave queries to these oracles. For our definition of confidentiality, we use the indistinguishability of ciphertext from random under a chosen plaintext attack and indistinguishability of plaintext from random under a chosen ciphertext attack. This strong definition has been shown to be equivalent to several other definitions <em>[2]</em>. Under these assumptions, GCM encryption is secure if an adversary presented with these oracles cannot tell if they contain GCM with a randomly selected key ( we denote this event as <span class="math">B_{\\text{GCM}}</span>) or if <span class="math">C</span> and <span class="math">T</span> are a random function of the other inputs (which we denote as <span class="math">B_{\\text{GCM}}^{c}</span>). Each of these cases occurs with probability <span class="math">1/2</span>. Because GCM is not a generic composition of a cipher and a MAC, we cannot use the results of Bellare and Namprempre <em>[5]</em>. Most importantly, the use of the same secret value <span class="math">H</span> for both hashing the IV and for computing the authentication tag provides the adversary a potential attack vector against confidentiality. For this reason, we need to give adversary access to the authenticated decryption oracle.</p>

    <p class="text-gray-300">GCM uses <span class="math">E</span> as a pseudorandom function (PRF). In our analysis, we make use of the well-known result on the use of a PRP as a PRF <em>[4]</em>. Our definition of PRF security considers the experiment in which we are given access to</p>

    <p class="text-gray-300">the function oracle, and are challenged to determine whether it contains a true random function or a PRF. That oracle has the same interface as does the permutation oracle; unlike that oracle, the function oracle may not be invertible. We use the convention that <span class="math">B_{\\text{PRF}}</span> denotes the PRF case and <span class="math">B_{\\text{PRF}}^{c}</span> denotes the random function case. The advantage of a PRF-distinguisher is given by <span class="math">A_{\\text{PRF}}=\\mathbf{P}[D\\mid B_{\\text{PRF}}]-\\mathbf{P}[D\\mid B_{\\text{PRF}}^{c}]</span>. The distinguishing advantage against a PRF is similar to that against a PRP, and has similar properties. The following Lemma bounds <span class="math">A_{\\text{PRF}}</span> in terms of <span class="math">A_{E}</span>.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Lemma 1 (A PRP can be a good PRF)</h6>

    <p class="text-gray-300">The advantage <span class="math">A_{PRF}</span> of an adversary in distinguishing a <span class="math">w</span>-bit PRP <span class="math">E</span> from a random function is bounded by <span class="math">A_{PRF}\\leq A_{E}+q(q-1)2^{-w-1}</span>, where <span class="math">A_{E}</span> is the adversary’s advantage in distinguishing <span class="math">E</span> from a random permutation, and the value <span class="math">q</span> is the number of queries to the function oracle.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Theorem 1 (GCM Encryption is Secure)</h6>

    <p class="text-gray-300">If there is an adversary that can distinguish GCM encryption from a random function with advantage <span class="math">A_{GCM}</span>, when the output of that function is limited to <span class="math">q</span> queries to the authenticated encryption and decryption oracles, where the total number of plaintext bits processed is <span class="math">l_{P}</span> and where <span class="math">\\text{len}(C)+\\text{len}(A)\\leq l</span> and <span class="math">\\text{len}(IV)\\leq l_{IV}</span> for each query, then that adversary can distinguish <span class="math">E</span> from a random permutation with advantage <span class="math">A_{E}</span>, where</p>

    <p class="text-gray-300"><span class="math">A_{E}\\geq A_{GCM}-(l_{P}/w+2q)^{2}2^{-w-1}-q((l_{P}/w+2q)\\lceil l_{IV}/w+1\\rceil 2^{1-w}+\\lceil l/w+1\\rceil 2^{-t}).</span></p>

    <p class="text-gray-300">This result is similar to that for counter mode, with a term that is quadratic in <span class="math">l_{\\text{P}}</span>. It also has a term that is linear in both <span class="math">l_{\\text{P}}</span> and <span class="math">ql_{\\text{IV}}</span>, which is due to the fact that collisions in the counter values are more likely when the lengths of the IVs that are hashed becomes greater. This term is dominant when <span class="math">ql_{\\text{IV}}&gt;l_{\\text{P}}</span>. The implication is that when long IVs are used, fewer queries should be made before a key is changed. However, in most cases <span class="math">l_{\\text{IV}}</span> will be no greater than <span class="math">l</span>, and thus the accommodation of variable length IVs comes at negligible security cost.</p>

    <p class="text-gray-300">The authentication tag size <span class="math">t</span> affects the security of GCM encryption, but its effect is relatively weak. The term containing <span class="math">2^{-t}</span> in the bound on <span class="math">A_{E}</span> does not dominate that value as long as <span class="math">t</span> is greater than about <span class="math">w-\\lg\\left(q\\lceil l/w\\rceil+\\lceil l_{\\text{IV}}/w\\rceil\\right)</span>.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">4.1 Authentication</h3>

    <p class="text-gray-300">We use the standard model for the security of a MAC in the presence of a chosen-message attack, in which an adversary is given access to a tag generation oracle and a message/tag verification oracle. The adversary can pass messages to the tag generation oracle and construct any message/tag pairs that it likes and send these to the verification oracle. Queries to the oracles can be interleaved by the adversary, if desired. The forgery advantage <span class="math">F_{\\text{GCM}}</span> is the probability that the adversary can get the verification oracle to accept a message/tag pair other than one generated by the tag generation oracle, after making <span class="math">q</span> queries to the tag-generation oracle and the verification oracle.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Theorem 2 (GCM authentication is secure)</h6>

    <p class="text-gray-300">An adversary with forgery advantage <span class="math">F_{GCM}</span> against GCM, when <span class="math">q</span>, <span class="math">l_{P}</span>, <span class="math">l</span> and <span class="math">l_{IV}</span> are as defined in Theorem 1, has a distinguishing advantage <span class="math">A_{E}</span> against the pseudorandom permutation <span class="math">E</span> used in GCM of at least <span class="math">F_{GCM}-(l_{P}/w+2q)^{2}2^{-w-1}-q((l_{P}/w+2q+1)\\lceil l_{IV}/w+1\\rceil 2^{1-w}+\\lceil l/w+1\\rceil 2^{-t})</span>.</p>

    <p class="text-gray-300">Like most authentication modes, the forgery advantage has a term that is quadratic in the amount of data that is authenticated. This term is dominant whenever many short messages are processed, as is typical for network crypto modules. When very long messages are processed, the term proportional to <span class="math">l</span> will dominate. This term is characteristic of MACs that are based on universal hashing.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">4.2 AES GCM Security</h3>

    <p class="text-gray-300">To tie our analysis to current practice, we apply it to the AES GCM specification for IPsec <em>[26]</em>, for which <span class="math">l_{\\text{IV}}=96</span> and <span class="math">t=96</span>. Any of the AES key lengths (of 128, 192, and 256 bits) can be used; for each variant, the block width <span class="math">w=128</span>. We use the typical Internet maximum packet size of 1500 bytes (<span class="math">l\\leq 12000</span>). The security of AES-<span class="math">N</span>-GCM (for <span class="math">N</span>=128, 192, or 256) is captured in the following corollary.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Corollary 1</h6>

    <p class="text-gray-300">If there are no attacks against AES-<span class="math">N</span> that can distinguish it from a random permutation with advantage greater than <span class="math">A_{AES-N}</span>, and no more than <span class="math">q</span> packets are processed, then</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there are no distinguishing attacks against AES-<span class="math">N</span>-GCM that work with distinguishing advantage greater than <span class="math">A_{AES-N}+q^{2}2^{-116}-q2^{-89.4}</span>, and</li>

      <li>there are no forgery attacks against AES-<span class="math">N</span>-GCM that work with forgery advantage greater than <span class="math">A_{AES-N}+q^{2}2^{-116}-q2^{-89.4}-q2^{-128}</span>.</li>

    </ul>

    <p class="text-gray-300">In these equations, the key size appears implicitly in the value of <span class="math">A_{\\text{AES-}N}</span>. To provide a concrete example, these results show that, if AES is indistinguishable from a random permutation, and fewer than <span class="math">2^{48}</span> packets are protected, then the attacker’s advantage is no more than <span class="math">2^{-18}</span>.</p>

    <h2 id="sec-15" class="text-2xl font-bold">5 Other Security Aspects</h2>

    <p class="text-gray-300">We next consider system-security aspects. Having shown GCM secure when used properly, we consider what can go wrong. One often overlooked aspect of mode security is the consequence of IV misuse. It is well known that reusing a key/IV pair in CTR results in a loss of confidentiality for the messages that used the common IV value. Since GCM is built on top of CTR, it shares this property. However, the reuse of an IV in the GCM authenticated encryption operation (e.g. on the sender’s side) causes even worse problems. It allows the attacker to solve for the underlying GHASH key <span class="math">H</span>, making subsequent forgeries trivial and also enabling the attacker to choose IVs that will cause colliding counters. However, the reuse of an IV in the authenticated decryption operation (on the</p>

    <p class="text-gray-300">receiver’s side) does not cause this problem. If an attacker convinces a receiver to decrypt multiple messages with the same IV, she still cannot exploit this situation to glean information about <span class="math">H</span> efficiently. Fortunately, it is often comparatively easy for a sender to protect against IV reuse, for example, by using a simple message counter as an IV. Additionally, GCM’s ability to accept an arbitrary-length IVs makes it easier to ensure all IVs are unique, by including any possible distinguishing information, no matter how verbose. Interestingly, CWC avoids some of these issues by using the underlying block cipher to encrypt the output of its universal hash function. But this aspect of its design is responsible for causing the pipeline stalls that significantly degrade CWC’s performance.</p>

    <p class="text-gray-300">It is possible that <span class="math">H=E(K,0^{w})=0</span>, and in this case, <span class="math">\\text{GHASH}(H,A,C)=0^{w}</span> for all values of <span class="math">A</span> and <span class="math">C</span>. If <span class="math">E</span> behaves as a random permutation, then the expected number of keys for which <span class="math">H=0^{w}</span> is the fraction <span class="math">2^{-w}</span> times the number of keys. This fact does not degrade the effectiveness of the message authentication; it is implicitly dealt with in the proof of security. When <span class="math">H=0^{w}</span>, the authentication tags will not be predictable; that case is no easier to detect than any other value of the key. However, that value causes all IVs to hash to the same value (if 96-bit IVs are not used). For this reason, some users may want to avoid using that key, e.g. by using the convention that <span class="math">H</span> is set to a fixed value whenever the zero value is detected at key setup time. Of course, that key is so unlikely to arise in practice that its effect on the bounds in the security proofs are negligible, and it is equally reasonable not to bother to check for it.</p>

    <h2 id="sec-16" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] M. Baugher , D. McGrew, M. Naslund, E. Carrara, K. Norrman. “The Secure Real-time Transport Protocol,” IETF RFC 3711, March 2004.</li>

      <li>[2] M. Bellare, A. Desai, E. Jokipii, and P. Rogaway. “A concrete security treatment of symmetric encryption,” In Proceedings of the 38th FOCS, IEEE Computer Society Press, 1997.</li>

      <li>[3] M. Bellare, O. Goldreich, and S. Goldwasser, “Incremental cryptography: the case of hashing and signing”, CRYPTO ’94, LNCS, Springer-Verlag, Aug. 1994.</li>

      <li>[4] M. Bellare, J. Kilian, P. Rogaway, “The Security of the Cipher Block Chaining Message Authentication Code,” J. Comput. Syst. Sci. 61(3). pg. 362-399 (2000).</li>

      <li>[5] M. Bellare and C. Namprempre, “Authenticated encryption: Relations among notions and analysis of the generic composition paradigm,” ASIACRYPT ’00, Springer-Verlag, LNCS, 2000.</li>

      <li>[6] D. Bernstein. Floating-point arithmetic and message a uthentication, Manuscript, 2000. Available online at http://cr.yp.to/p apers.#hash127.</li>

      <li>[7] M. Bellare, P. Rogaway, and D. Wagner, “A conventional authenticated-encryption mode”, Submission to NIST Modes of Operation process, 2003.</li>

      <li>[8] J. Black and P. Rogaway, “A Block-Cipher Mode of Operation for Parallelizable Message Authentication,” EUROCRYPT ’02, LNCS, Springer-Verlag, 2002.</li>

      <li>[9] N. Biggs. Discrete Mathematics, Revised Edition, Oxford Science Publications, Oxford University Press. 1993.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[10] K. Claffy, G. Miller, K. Thompson, “The nature of the beast: recent traffic measurements from an Internet backbone,” INET ’98, ISOC, 1998.</li>

      <li>[11] B. Gladman, “AES and Combined Encryption/Authentication Modes,” Web Page, http://fp.gladman.plus.com/AES/index.htm, February, 2004.</li>

      <li>[12] V. Gligor and P. Donescu, “Fast encryption and authentication: XCBC encryption and XECB authentication modes,” Proceedings of the Fast Software Encryption Workshop - FSE ’01. Springer-Verlag, 2001.</li>

      <li>[13] T. Iwata, K. Kurosawa, “OMAC: One-Key CBC MAC,” Submission to NIST Modes of Operation Process, 2002.</li>

      <li>[14] C. Jutla, “Encryption modes with almost free message integrity,” Advanced in Cryptology - EUROCRYPT ’01, Springer-Verlag, 2001.</li>

      <li>[15] S. Kent, R. Atkinson, “IP Encapsulating Security Payload (ESP),” IETF Request For Comments (RFC) 2406, November 1998.</li>

      <li>[16] T. Kohno, J. Viega, and D. Whiting, “The CWC-AES Dual-use Mode,” Submission to NIST Modes of Operation Process, 2003.</li>

      <li>[17] H. Krawczyk, “LFSR-based hashing and authentication,” In Y. Desmedt, editor, CRYPTO ’94, LNCS, Springer-Verlag, Aug. 1994.</li>

      <li>[18] D. McGrew, “The Universal Security Transform,” IETF Internet Draft, Work in Progress. Oct. 2002.</li>

      <li>[19] D. McGrew and J. Viega, “The Galois/Counter Mode of Operation (GCM),” Submission to NIST Modes of Operation Process, January, 2004.</li>

      <li>[20] D. McGrew and J. Viega, “The Security and Performance of the Galois/Counter Mode (GCM) of Operation,” INDOCRYPT ’04, LNCS, Springer-Verlag, 2004.</li>

      <li>[21] P. Rogaway. “Authenticated encryption with associated data,” In Proceedings of the 9th CCS, Nov. 2002.</li>

      <li>[22] P. Rogaway, M. Bellare, J. Black, and T. Krovitz, “OCB: a block-cipher mode of operation for efficient authenticated encryption,” ACM CCS, 2001.</li>

      <li>[23] A. Romanow, Ed. “Media Access Control (MAC) Security”, IEEE 802.1AE, Draft Standard, July, 2004.</li>

      <li>[24] V. Shoup, “On Fast and Provably Secure Message Authentication Based on Universal Hashing,” CRYPTO ’96, LNCS, Springer-Verlag, 1996.</li>

      <li>[25] U.S. National Institute of Standards and Technology. The Advanced Encryption Standard. Federal Information Processing Standard (FIPS) 197, 2002.</li>

      <li>[26] J. Viega and D. McGrew, “The Use of Galois/Counter Mode (GCM) in IPsec ESP,” IETF Internet Draft, Work in Progress, April, 2004.</li>

      <li>[27] M. Wegman and L. Carter, “New hash functions and their use in authentication and set equality,” Journal of Computer and System Sciences, 22:265–279, 1981.</li>

      <li>[28] D. Whiting, N. Ferguson, and R. Housley, “Counter with CBC-MAC (CCM),” Submission to NIST Modes of Operation Process, 2002.</li>

    </ul>

    <p class="text-gray-300">A Properties of GHASH</p>

    <p class="text-gray-300">We now show that GHASH has the properties that we need, in the next three straightforward lemmas.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Lemma 2 (GHASH is almost xor universal).</h6>

    <p class="text-gray-300">The function GHASH is <span class="math">\\lceil l/w+1\\rceil 2^{-t}</span>-almost xor universal when its second and third inputs are restricted so that their lengths sum to <span class="math">l</span> or fewer bits and its output is truncated to <span class="math">t</span> bits.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We consider two distinct inputs <span class="math">(A,C)</span> and <span class="math">(A^{\\prime},C^{\\prime})</span>, then analyze the probability of the event that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathrm{GHASH}(H,A,C)\\oplus\\mathrm{GHASH}(H,A^{\\prime},C^{\\prime})=a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z,$ (6)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for some fixed <span class="math">t</span>-bit value <span class="math">a</span> and any value of the <span class="math">t</span>-bit variable <span class="math">z</span> (which we use to account for the truncation of the GHASH ouput). We assume that these inputs are formatted as described in Section 2, in which <span class="math">A,C,A^{\\prime}</span>, and <span class="math">C^{\\prime}</span> consist of <span class="math">m,n,m^{\\prime}</span>, and <span class="math">n^{\\prime}</span> <span class="math">w</span>-bit blocks, respectively, the final blocks of which have lengths <span class="math">v,u,v^{\\prime}</span>, and <span class="math">u^{\\prime}</span>, respectively. We let <span class="math">p=\\max(m+n,m^{\\prime}+n^{\\prime})</span> denote the number of blocks in the longer input. We define the blocks <span class="math">D_{i},D_{i}^{\\prime}</span> for <span class="math">1\\leq i\\leq p+1</span> as</p>

    <p class="text-gray-300">\\[ D_{i}=\\begin{cases}A_{i}&\\text{for }i=1,\\ldots,m-1\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{m}^{\\ast}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{w-v}&\\text{for }i=m\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">C_{i-m}&\\text{for }i=m+1,\\ldots,m+n-1\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{n}^{\\ast}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{w-u}&\\text{for }i=m+n\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">0^{w}&\\text{for }m+n+2,\\ldots,p+1.\\end{cases} \\] (7)</p>

    <p class="text-gray-300">We similarly define the blocks <span class="math">D_{i}^{\\prime}</span> for based on the input <span class="math">(A^{\\prime},C^{\\prime})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The condition that $\\mathrm{GHASH}(H,A,C)\\oplus\\mathrm{GHASH}(H,A^{\\prime},C^{\\prime})=a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z<span class="math"> can be expressed as </span>R(H)=0<span class="math">, where the polynomial </span>R<span class="math"> of degree at most </span>p+1<span class="math"> over </span>GF(2^{w})$ is defined by</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$R(H)=(a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z)\\oplus\\bigoplus_{i=1,}^{p}(D_{i}\\oplus D_{i}^{\\prime})\\cdot H^{i}.$ (8)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The polynomial <span class="math">R</span> must be nonzero, because the strings $A\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C<span class="math"> and </span>A^{\\prime}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C^{\\prime}<span class="math"> are distinct. There are at most </span>p+1<span class="math"> values of </span>H\\in G<span class="math"> for which </span>R(H)=0<span class="math"> holds. This follows from the fact that an </span>d^{th}<span class="math"> degree polynomial over </span>GF(2^{w})<span class="math"> has at most </span>d<span class="math"> distinct roots (this is the fundamental theorem of algebra over a finite field; see, for example, <em>[9, Theorem 15.8.2]</em>), and the fact that </span>R<span class="math"> is nonzero. The probability that </span>R(H)=0<span class="math"> holds, given that </span>H<span class="math"> is chosen at random from </span>GF(2^{w})<span class="math">, is </span>(p+1)/2^{w}\\leq\\lceil l/w+1\\rceil 2^{-w}<span class="math">, when the cumulative length of the inputs is restricted to </span>l$ bits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For each vector <span class="math">D</span>, there is a unique pair <span class="math">(A,C)</span> where both <span class="math">A</span> and <span class="math">C</span> are bit strings as described in Section 1, and vice-versa. This is because the last</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">element of <span class="math">D</span> unambiguously encodes the lengths of both <span class="math">A</span> and <span class="math">C</span>. Thus, the probability that <span class="math">R(H) = 0</span> holds for any two given messages <span class="math">(A,C)</span> and <span class="math">(A^{\\prime},C^{\\prime})</span>, and a given vector $a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z<span class="math">, is equal to the probability that </span>\\mathrm{GHASH}(H,A,C)\\oplus \\mathrm{GHASH}(H,A^{\\prime},C^{\\prime}) = a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z<span class="math">. Because there are </span>2^{w - t}<span class="math"> possible values for </span>z<span class="math">, Equation 6 holds with probability </span>\\lceil l / w + 1\\rceil 2^{-w}\\times 2^{w - t} = \\lceil l / w + 1\\rceil 2^{-t}<span class="math"> for any given values of </span>(A,C),(A^{\\prime},C^{\\prime})<span class="math">, and </span>a\\in \\{0,1\\} ^t$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We define the function <span class="math">h</span>, which is (implicitly) used in GCM to compute the initial counter value <span class="math">Y_{0}</span> based on the IV, so that we can analyze its properties:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h (H, M) = \\left\\{ \\begin{array}{l l} M \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 ^ {3 1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 &amp; \\text {if} \\operatorname {l e n} (M) = w - 3 2 \\\\ \\operatorname {G H A S H} (H, \\{\\}, M) &amp; \\text {otherwise.} \\end{array} \\right. \\tag {9}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Lemma 3</strong> (<span class="math">h</span> is unlikely to collide). The bound</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {P} [ h (H, I V) = \\operatorname {i n c r} ^ {j} (h (H, I V ^ {\\prime})) \\mid H \\stackrel {R} {\\leftarrow} G F (2 ^ {w}) ] \\leq \\lceil l / w + 1 \\rceil 2 ^ {- w}, \\tag {10}</span></div>

    <p class="text-gray-300">holds for the function <span class="math">h</span> defined in Equation 9, for any values of <span class="math">j</span>, <span class="math">IV</span>, and <span class="math">IV&#x27;</span>, where the inputs <span class="math">IV</span> and <span class="math">IV&#x27;</span> are distinct and are allowed to have any lengths up to <span class="math">l_{IV}</span> bits.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We call the event that <span class="math">h(H,IV) = \\mathrm{incr}^j (h(H,IV&#x27;))</span> as <span class="math">\\mathcal{E}</span>, for short. We separately consider the following cases:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{len}(IV) = \\operatorname{len}(IV&#x27;) = w - 32</span>,</li>

      <li><span class="math">\\operatorname{len}(IV) = w - 32</span>  and  <span class="math">\\operatorname{len}(IV&#x27;) \\neq w - 32</span> , and</li>

      <li><span class="math">\\operatorname{len}(IV) \\neq w - 32</span>  and  <span class="math">\\operatorname{len}(IV&#x27;) = w - 32</span> , and</li>

      <li><span class="math">\\operatorname{len}(IV) \\neq w - 32</span>  and  <span class="math">\\operatorname{len}(IV&#x27;) \\neq w - 32</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In case 1, $h(H,IV) = IV\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{31}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1<span class="math"> and </span>h(H,IV') = IV'\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{31}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1<span class="math">. Because of the fact that </span>IV<span class="math"> and </span>IV'<span class="math"> are distinct and the fact that the increment function does not alter the leftmost </span>w - 32<span class="math"> bits of its input, the probability of a collision is zero. In case 2 when </span>\\mathcal{E}$ occurs it follows that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h (H, I V ^ {\\prime}) = \\operatorname {i n c r} ^ {- j} (I V \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 ^ {3 1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1) = I V \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(1 - j \\bmod 2 ^ {3 2}).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">(Here we rely on the implicit conversion of non-negative integers to their representation as binary vectors; the important fact is that this conversion is unique and invertible.) This condition can be re-expressed as <span class="math">R(H) = 0</span>, where the polynomial <span class="math">R</span> of degree <span class="math">n&#x27; + 1</span> over <span class="math">GF(2^w)</span> is defined by <span class="math">R = \\bigoplus_{i=1}^{n&#x27;+1} R_i \\cdot H^i</span> with the coefficients</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R _ {i} = \\left\\{ \\begin{array}{l l} I V \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(1 - j \\bmod 2 ^ {3 2}\\right) &amp; \\text {for} i = 0, \\\\ I V _ {i} ^ {\\prime} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 ^ {p} &amp; \\text {for} 1 &lt; i \\leq n ^ {\\prime}, \\\\ \\left(0 ^ {w / 2} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {l e n} \\left(I V ^ {\\prime}\\right)\\right) &amp; \\text {for} i = n ^ {\\prime} + 1 \\end{array} \\right. \\tag {11}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">n&#x27; = \\lceil \\mathrm{len}(IV&#x27;) / w \\rceil</span> and <span class="math">p = \\mathrm{len}(IV&#x27;) \\bmod w</span> is the number of padding bits in the <span class="math">n&#x27;</span>th coefficient. There are at most <span class="math">n&#x27; + 1</span> values of <span class="math">H \\in G</span> for which</p>

    <p class="text-gray-300"><span class="math">R(H) = 0</span> holds, since that it is the number of distinct roots of <span class="math">R</span>. This fact is true for any value of <span class="math">j</span>, since each value of <span class="math">j</span> corresponds to a distinct polynomial. Thus the probability of <span class="math">\\mathcal{E}</span>, given that <span class="math">H</span> is chosen at random from <span class="math">GF(2^w)</span>, is <span class="math">(n&#x27; + 1)/2^w \\leq \\lceil l_{\\mathrm{IV}}/w + 1 \\rceil 2^{-w}</span>. Case 3 is identical to case 2 after a relabeling of <span class="math">IV</span> and <span class="math">IV&#x27;</span>. In Case 4, the probability that <span class="math">h(H, IV) = h(H, IV&#x27;)</span> is equal to the probability that <span class="math">\\mathrm{GHASH}(H, \\{\\}, IV) = \\mathrm{GHASH}(H, \\{\\}, IV&#x27;)</span>, which is no greater than <span class="math">\\lceil l_{\\mathrm{IV}}/w + 1 \\rceil 2^{-w}</span> from Lemma 2. The claimed result holds in all four cases.</p>

    <p class="text-gray-300"><strong>Lemma 4</strong> (h is unlikely to return zero). The function <span class="math">h</span> defined in Equation 9 satisfies</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{P}[h(H, IV) = 0^w \\mid H \\stackrel{R}{\\leftarrow} GF(2^w)] \\leq \\lceil l_{IV}/w + 1 \\rceil 2^{-w} \\text{ for all } IV: \\mathrm{len}(IV) \\leq l_{IV}.</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> When <span class="math">\\mathrm{len}(IV) = w - 32</span>, then the probability is equal to zero. Otherwise, the condition that <span class="math">h(H, IV) = 0</span> can be re-expressed as <span class="math">R(H) = 0</span>, where the polynomial <span class="math">R</span> has the coefficients</p>

    <p class="text-gray-300">$$ R_i = \\begin{cases} 0 &amp; \\text{for } i = 0, \\\\ IV_{i-1} &amp; \\text{for } i = 1 \\leq n + 1 \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{w/2} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{len}(IV) &amp; \\text{for } i = n + 1,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{cases} \\tag{12} $$</p>

    <p class="text-gray-300">and <span class="math">n = \\lceil \\mathrm{len}(N)/w \\rceil</span>. There are no more than <span class="math">\\lceil l_{\\mathrm{IV}}/w + 1 \\rceil</span> values of <span class="math">H</span> that satisfy this equation, because each of those values is a root of <span class="math">R(H) = 0</span> over <span class="math">GF(2^w)</span>. Because <span class="math">H</span> is chosen at random, the probability that <span class="math">R(H) = 0</span> is no more than <span class="math">\\lceil l_{\\mathrm{IV}}/w + 1 \\rceil 2^{-w}</span>.</p>

    <h2 id="sec-19" class="text-2xl font-bold">B Proofs of Theorems 1 and 2</h2>

    <p class="text-gray-300">We first prove Theorem 2, which shows that GCM is a good MAC, then we prove Theorem 1, which shows that GCM's encryption is effective. This order is important, since we use results from the analysis of the forgery probability when analyzing encryption. We start by reviewing message authentication based on universal hashing.</p>

    <p class="text-gray-300">A function <span class="math">g(K, M)</span> is <span class="math">\\epsilon</span>-almost xor universal [17] if</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{P}[g(K, M) \\oplus g(K, M&#x27;) = a \\mid K \\stackrel{R}{\\leftarrow} \\{0, 1\\}^n] \\leq \\epsilon \\text{ for all } M \\neq M&#x27; \\text{ and } a. \\tag{13}</span></div>

    <p class="text-gray-300">Here the expression <span class="math">K \\stackrel{R}{\\leftarrow} \\{0,1\\}^n</span> denotes the event that <span class="math">K</span> is chosen at random from the set <span class="math">\\{0,1\\}^n</span>. We diverge slightly from the usual definition in order to make our exposition more explicit.</p>

    <p class="text-gray-300">3 In the standard definition, <span class="math">g</span> would define a family of (unkeyed) hash functions, and we would select a function from that family. Our keyed hash function corresponds to the hash function family, and a particular value of the key <span class="math">K</span> corresponds to a particular function in that family.</p>

    <p class="text-gray-300">An <span class="math">\\epsilon</span>-almost xor universal function can be combined with a pseudorandom function to make a strong MAC. First, we analyze the security of the ideal case, following Krawczyk <em>[17]</em>. We consider the message authentication code AXU-MAC defined by <span class="math">T=R(N)\\oplus H(K,M)</span>, where the hash function <span class="math">H(K,M)</span> is <span class="math">\\epsilon</span>-almost xor universal and <span class="math">R</span> is a random function. Here <span class="math">M</span> is a message, <span class="math">N</span> is a nonce and <span class="math">T</span> is the tag corresponding to <span class="math">M</span> and <span class="math">N</span>.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Lemma 5 (AXU-MAC is secure).</h6>

    <p class="text-gray-300">If <span class="math">H</span> is <span class="math">\\epsilon</span>-almost xor universal, then the probability of success of a single forgery attempt against AXU-MAC is no greater than <span class="math">\\epsilon</span>.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The lemma follows directly from the properties of an xor-universal hash function. We denote as <span class="math">(N,M^{\\prime},T^{\\prime})</span> the 3-tuple that represents a forgery attempt, and we assume that the adversary has access to a valid 3-tuple <span class="math">(N,M,T)</span>, with <span class="math">T=R(N)\\oplus H(K,M)</span>, for the same nonce value <span class="math">N</span>. Then</p>

    <p class="text-gray-300"><span class="math">\\mathbf{P}[\\ (N,M,T)\\ \\text{accepted}\\ ]=\\mathbf{P}[T^{\\prime}\\oplus T=H(K,M^{\\prime})\\oplus H(K,M)]\\leq\\epsilon.\\ \\square</span> (14)</p>

    <p class="text-gray-300">The best strategy for forging messages is to choose values of <span class="math">M\\oplus M^{\\prime}</span> and <span class="math">T^{\\prime}\\oplus T</span> such that the lower bound on the probability is met. A simple but important corollary follows.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Corollary 2.</h6>

    <p class="text-gray-300">The forgery advantage against AXU-MAC is no greater than <span class="math">q\\epsilon</span>, whenever <span class="math">q</span> queries to the authentication and verification oracles are allowed.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We define the event <span class="math">U_{i}</span> as the case in which the adversary does not produce a successful forgery against AXU-MAC on the <span class="math">i</span> query to the message/tag-verification oracle. If <span class="math">U_{1}\\cap U_{2}\\ldots\\cap U_{i}</span> occurs, then the probability of the adversary succeeding in its next forgery attempt is limited by Lemma 5; thus</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbf{P}[U_{i+1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ U_{i}\\cap U_{i-1}\\cap\\ldots\\cap U_{1}]\\geq 1-\\epsilon.$ (15)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This fact holds independent from the number of queries that have been made to the tag-generation oracle. For any set of events <span class="math">A_{1},A_{2},\\ldots,A_{n}</span> such that <span class="math">\\mathbf{P}[A_{1}\\cap A_{2}\\cap\\ldots\\cap A_{n}]&gt;0</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbf{P}[A_{1}\\cap A_{2}\\cap\\ldots\\cap A_{n}]=\\mathbf{P}[A_{n}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ A_{1}\\cap A_{2}\\cap\\ldots\\cap A_{n-1}]\\times$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The probability <span class="math">\\mathbf{P}[U_{1}\\cap U_{2}\\ldots\\cap U_{q}]</span> that there are no successful forgeries after <span class="math">q</span> queries to each oracle is at least <span class="math">(1-\\epsilon)^{q}</span>. The forgery advantage is no more than <span class="math">1-(1-\\epsilon)^{q}\\leq q\\epsilon</span>, with the inequality following from using Taylor’s theorem with remainder. ∎</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proof of Theorem 2.</h6>

    <p class="text-gray-300">We proceed by treating <span class="math">E</span> as a PRF, not a PRP, then rationalize this assumption using Lemma 1. We assume that we have a machine that generates GCM message/tag pairs with forgery advantage <span class="math">F_{\\text{GCM}}</span>, using a chosen-message attack. We use this machine to distinguish between the case that</p>

    <p class="text-gray-300">the oracle contains GCM implemented with <span class="math">E</span>, which we denote as <span class="math">B_{\\mathrm{PRF}}</span>, and the case of GCM implemented with a random function, which we denote as <span class="math">B_{\\mathrm{PRF}}^c</span>. We measure the advantage <span class="math">A_{\\mathrm{PRF}}</span> defined above. We use the function oracle to implement GCM, by replacing each invocation of <span class="math">E</span> with an invocation to that oracle, then run the machine and provide it with access to a tag-generation oracle and a message/tag verification oracle. If the machine succeeds in forging a message/tag pair, then we guess that event <span class="math">B_{\\mathrm{PRF}}</span> occurred, otherwise, we guess that <span class="math">B_{\\mathrm{PRF}}^c</span> occurred. We compute the hash key <span class="math">H</span> by querying the function oracle with the input value <span class="math">0^w</span> at the very outset of the experiment, and set that key to the value returned by the oracle. We denote the event that none of the counter values <span class="math">Y_i</span> input to the function oracle during the experiment are equal to the zero value <span class="math">0^w</span> as <span class="math">\\mathcal{Z}</span>. We also consider the event <span class="math">\\mathcal{Y}</span> that all counter values are distinct, for the entire run of the experiment, as used in the proof of Theorem 1. Our analysis uses the following facts:</p>

    <p class="text-gray-300">Fact 1. <span class="math">F_{\\mathrm{GCM}} = \\mathbf{P}[D \\mid B_{\\mathrm{PRF}}]</span>, which follows directly from the definition of the forgery advantage.</p>

    <p class="text-gray-300">Fact 2. For any three events <span class="math">A, B</span> and <span class="math">C</span> (with <span class="math">\\mathbf{P}[B] \\neq 0</span>),</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf{P}[A \\mid B] = \\frac{\\mathbf{P}[A \\cap B]}{\\mathbf{P}[B]} \\\\ = \\frac{\\mathbf{P}[A \\cap B \\cap C]}{\\mathbf{P}[B]} + \\frac{\\mathbf{P}[A \\cap B \\cap C^c]}{\\mathbf{P}[B]} \\\\ = \\frac{\\mathbf{P}[A \\cap B \\cap C]}{\\mathbf{P}[B \\cap C]} \\frac{\\mathbf{P}[B \\cap C]}{\\mathbf{P}[B]} + \\frac{\\mathbf{P}[A \\cap B \\cap C^c]}{\\mathbf{P}[B \\cap C^c]} \\frac{\\mathbf{P}[B \\cap C^c]}{\\mathbf{P}[B]} \\\\ = \\mathbf{P}[A \\mid B \\cap C] \\mathbf{P}[C \\mid B] + \\mathbf{P}[A \\mid B \\cap C^c] \\mathbf{P}[C^c \\mid B]. \\tag{16} \\end{array}</span></div>

    <p class="text-gray-300">Fact 3. <span class="math">\\mathbf{P}[D \\mid B_{\\mathrm{PRF}}^c \\cap \\mathcal{Y} \\cap \\mathcal{Z}] \\leq q\\lceil l / w + 1 \\rceil 2^{-t}</span>, because when the events <span class="math">B_{\\mathrm{PRF}}^c, \\mathcal{Y}</span>, and <span class="math">\\mathcal{Z}</span> occur in conjunction, Lemma 5 applies. When <span class="math">B_{\\mathrm{PRF}}^c</span> occurs, the hash key <span class="math">H</span> is chosen uniformly at random, as required by that lemma. When <span class="math">\\mathcal{Z}</span> occurs, <span class="math">H</span> is not used to encrypt any plaintext block, and the adversary has no information about its value. Event <span class="math">\\mathcal{Y}</span> ensures that no output from <span class="math">g</span> is used more than once. We also know from Lemma 2 that GHASH is <span class="math">\\lceil l / w + 1 \\rceil 2^{-t}</span> almost xor universal.</p>

    <p class="text-gray-300">Fact 4. <span class="math">\\mathbf{P}[\\mathcal{Z}^c \\mid B_{\\mathrm{PRF}}^c] \\leq (q - 1)\\lceil l_{\\mathrm{IV}} / w + 1 \\rceil 2^{-w}</span> from Corollary 2.</p>

    <p class="text-gray-300">We can express the PRF-distinguishing advantage <span class="math">A_{\\mathrm{PRF}}</span> in terms of <span class="math">A_{\\mathrm{GCM}}</span> as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} A_{\\mathrm{PRF}} &amp;amp;= \\mathbf{P}[D \\mid B_{\\mathrm{PRF}}] - \\mathbf{P}[D \\mid B_{\\mathrm{PRF}}^c] \\\\ &amp;amp;= F_{\\mathrm{GCM}} - \\mathbf{P}[D \\mid B_{\\mathrm{PRF}}^c] \\\\ &amp;amp;= F_{\\mathrm{GCM}} - \\mathbf{P}[D \\mid B_{\\mathrm{PRF}}^c \\cap (\\mathcal{Y} \\cap \\mathcal{Z})^c] \\mathbf{P}[(\\mathcal{Y} \\cap \\mathcal{Z})^c \\mid B_{\\mathrm{PRF}}^c] \\\\ &amp;amp;\\quad - \\mathbf{P}[D \\cap (\\mathcal{Y} \\cap \\mathcal{Z}) \\mid B_{\\mathrm{PRF}}^c] \\mathbf{P}[\\mathcal{Y} \\cap \\mathcal{Z} \\mid B_{\\mathrm{PRF}}^c], \\\\ &amp;amp;\\geq F_{\\mathrm{GCM}} - \\mathbf{P}[(\\mathcal{Y} \\cap \\mathcal{Z})^c \\mid B_{\\mathrm{PRF}}^c] - \\mathbf{P}[D \\cap (\\mathcal{Y} \\cap \\mathcal{Z}) \\mid B_{\\mathrm{PRF}}^c] \\\\ &amp;amp;\\geq F_{\\mathrm{GCM}} - \\mathbf{P}[(\\mathcal{Y} \\cap \\mathcal{Z})^c \\mid B_{\\mathrm{PRF}}^c] - q\\lceil l/w + 1 \\rceil 2^{-t} \\\\ &amp;amp;\\geq F_{\\mathrm{GCM}} - \\mathbf{P}[\\mathcal{Y}^c \\mid B_{\\mathrm{PRF}}^c] - \\mathbf{P}[\\mathcal{Z}^c \\mid B_{\\mathrm{PRF}}^c] - q\\lceil l/w + 1 \\rceil 2^{-t} \\\\ &amp;amp;\\geq F_{\\mathrm{GCM}} - \\mathbf{P}[\\mathcal{Y}^c \\mid B_{\\mathrm{PRF}}^c] - (q - 1)\\lceil l_{\\mathrm{IV}}/w + 1 \\rceil 2^{-w} - q\\lceil l/w + 1 \\rceil 2^{-t}, \\\\ &amp;amp;\\geq F_{\\mathrm{GCM}} - \\mathbf{P}[\\mathcal{Y}^c \\mid B_{\\mathrm{PRF}}^c] - q(\\lceil l_{\\mathrm{IV}}/w + 1 \\rceil 2^{-w} + \\lceil l/w + 1 \\rceil 2^{-t}). \\end{aligned} \\tag{17}</span></div>

    <p class="text-gray-300">We rely on the fact that <span class="math">\\mathbf{P}[\\mathcal{Y}^c \\mid B_{\\mathrm{PRF}}^c]</span> is extremely small to keep the advantage low, and next consider that value.</p>

    <p class="text-gray-300">During the experiment, the adversary makes a series of queries to the authenticated encryption oracle. For each query, there is a sequence of counter values <span class="math">Y_0, Y_1, \\ldots, Y_n</span> used as the input to <span class="math">E</span>. We denote as <span class="math">U_i</span> the event that the counter sequence of the <span class="math">i^{th}</span> query is distinct from the counter sequences of all of the previous queries. In order for a sequence of length <span class="math">l</span> to overlap with another sequence, then either the initial counter of the first sequence is contained in the second sequence, or the initial counter of the first sequence is contained in the <span class="math">l</span> counters that precede the second sequence. If the counter sequences for queries <span class="math">r</span> and <span class="math">s</span> overlap, then <span class="math">h(H, IV_r) = \\mathrm{inc}r^j(h(H, IV_s))</span> for some value of <span class="math">j</span> such that <span class="math">-b_r &amp;lt; j &amp;lt; b_s</span>, where we let <span class="math">b_i</span> denote the number of counters used during the <span class="math">i^{th}</span> query. From Lemma 3, we know that the probability of this event, for any fixed value of <span class="math">j</span>, is no greater than <span class="math">\\lceil l_{\\mathrm{IV}}/w + 1 \\rceil 2^{-w}</span>. (Importantly, when <span class="math">B_{\\mathrm{PRF}}^c</span> occurs, the value of the hash key <span class="math">H</span> is random, as is required by that Lemma.) Summing over all of the previous queries, we find that <span class="math">\\mathbf{P}[U_r^c] \\leq \\left((r - 1)b_r + \\sum_{i=1}^{r-1} b_i\\right) \\lceil l_{\\mathrm{IV}}/w + 1 \\rceil 2^{-w}</span> and the probability that there are no collisions across all queries is</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\mathbf{P}[\\mathcal{Y}^c \\mid B_{\\mathrm{GCM}}^c] &amp;amp;= \\mathbf{P}[U_1^c \\cup U_2^c \\cup \\ldots \\cup U_q^c] \\\\ &amp;amp;\\leq \\mathbf{P}[U_1^c] + \\mathbf{P}[U_2^c] + \\ldots + \\mathbf{P}[U_q^c] \\\\ &amp;amp;\\leq \\sum_{r=1,}^{q} \\left((r - 1)b_r + \\sum_{i=1}^{r-1} b_i\\right) \\lceil l_{\\mathrm{IV}}/w + 1 \\rceil 2^{-w} \\\\ &amp;amp;\\leq qb\\lceil l_{\\mathrm{IV}}/w + 1 \\rceil 2^{1-w}, \\end{aligned} \\tag{18}</span></div>

    <p class="text-gray-300">where <span class="math">b = \\sum_{r=1,}^{q} b_r</span> denotes the total number of counter blocks used during all of the queries. This value is no greater than <span class="math">l_{\\mathrm{P}}/w + 2q</span>, where <span class="math">l_{\\mathrm{P}}</span> is the total number of bits in all of the plaintexts. The theorem follows from combining Equations 17 and 18 with Lemma 1.</p>

    <p class="text-gray-300">Proof of Theorem 1. We assume that we have a distinguisher <span class="math">\\mathcal{D}_{\\mathrm{GCM}}</span> that can distinguish between those two cases with advantage <span class="math">A_{\\mathrm{GCM}}</span> given by</p>

    <div class="my-4 text-center"><span class="math-block">A_{\\mathrm{GCM}} = \\mathbf{P}[D \\mid B_{\\mathrm{GCM}}] - \\mathbf{P}[D \\mid B_{\\mathrm{GCM}}^c]. \\tag{19}</span></div>

    <p class="text-gray-300">We use <span class="math">\\mathcal{D}_{\\mathrm{GCM}}</span> to discern <span class="math">E</span> from a random function as follows. We assume that we are given access to a function oracle, which contains <span class="math">E</span> if the event <span class="math">B_{\\mathrm{PRF}}</span> occurred and contains a true random function if <span class="math">B_{\\mathrm{PRF}}^c</span> occurred. We replace each invocation of <span class="math">E</span> in Equations 2 with a query to the function oracle. We run <span class="math">\\mathcal{D}_{\\mathrm{GCM}}</span> on the resulting algorithm, and return whatever value that it returns. For each query to this algorithm, there is a sequence of counter values <span class="math">Y_0, Y_1, \\ldots, Y_n</span> used as the input to <span class="math">E</span> (as defined in Equation 2). We define the event <span class="math">\\mathcal{Y}</span> as the case in which all of these counter values are distinct, across all counter sequences. We also define the event <span class="math">\\mathcal{F}</span> as the case in which there are no successful forgeries during the distinguishing experiment. This latter case is important because an attacker can use information gleaned from a chosen-ciphertext or chosen-associated-data forgery to craft two distinct IV values that will cause a counter collision. This attack can be used to distinguish <span class="math">B_{\\mathrm{GCM}}</span> from <span class="math">B_{\\mathrm{GCM}}^c</span>, but cannot be used to distinguish <span class="math">B_{\\mathrm{PRF}}</span> from <span class="math">B_{\\mathrm{PRF}}^c</span>. We account for this fact by keeping explicit track of the forgery probability in our bounds. For notational simplicity, we define the event <span class="math">\\mathcal{G} = \\mathcal{F} \\cap \\mathcal{Y}</span>. Our analysis uses the following facts:</p>

    <p class="text-gray-300">Fact 1. <span class="math">\\mathbf{P}[D \\mid B_{\\mathrm{PRF}}] = \\mathbf{P}[D \\mid B_{\\mathrm{GCM}}]</span>, because the two cases <span class="math">B_{\\mathrm{PRF}}</span> and <span class="math">B_{\\mathrm{GCM}}</span> provide equivalent inputs to the distinguisher.</p>

    <p class="text-gray-300">Fact 2. <span class="math">\\mathbf{P}[D \\mid B_{\\mathrm{PRF}}^c \\cap \\mathcal{G}]\\mathbf{P}[\\mathcal{G} \\mid B_{\\mathrm{PRF}}^c] \\leq \\mathbf{P}[D \\mid B_{\\mathrm{GCM}}^c]</span>, because the two cases <span class="math">B_{\\mathrm{PRF}}^c \\cap \\mathcal{Y}</span> and <span class="math">B_{\\mathrm{GCM}}^c</span> provide equivalent inputs to the distinguisher. When <span class="math">E</span> is replaced by a random function whose inputs are distinct, the set of its outputs form a random function with a larger range. Thus</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf{P}[D \\mid B_{\\mathrm{PRF}}^c \\cap \\mathcal{G}]\\mathbf{P}[\\mathcal{G} \\mid B_{\\mathrm{PRF}}^c] = \\frac{\\mathbf{P}[D \\cap B_{\\mathrm{PRF}}^c \\cap \\mathcal{G}]}{\\mathbf{P}[B_{\\mathrm{PRF}}^c \\cap \\mathcal{G}]} \\frac{\\mathbf{P}[\\mathcal{G} \\cap B_{\\mathrm{PRF}}^c]}{\\mathbf{P}[B_{\\mathrm{PRF}}^c]} \\\\ = \\frac{\\mathbf{P}[D \\cap \\mathcal{F} \\cap \\mathcal{Y} \\cap B_{\\mathrm{PRF}}^c]}{\\mathbf{P}[B_{\\mathrm{PRF}}^c]} \\\\ = \\frac{\\mathbf{P}[D \\cap \\mathcal{F} \\cap B_{\\mathrm{GCM}}^c]}{\\mathbf{P}[B_{\\mathrm{GCM}}^c]} \\\\ = \\mathbf{P}[D \\cap \\mathcal{F} \\mid B_{\\mathrm{GCM}}^c] \\\\ \\leq \\mathbf{P}[D \\mid B_{\\mathrm{GCM}}^c]. \\tag{20} \\end{array}</span></div>

    <p class="text-gray-300">The advantage <span class="math">A_{\\mathrm{PRF}}</span> can be expressed in terms of <span class="math">A_{\\mathrm{GCM}}</span> as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} A_{\\mathrm{PRF}} &amp;amp;= \\mathbf{P}[D \\mid B_{\\mathrm{PRF}}] - \\mathbf{P}[D \\mid B_{\\mathrm{PRF}}^c], \\\\ &amp;amp;= \\mathbf{P}[D \\mid B_{\\mathrm{GCM}}] - \\mathbf{P}[D \\mid B_{\\mathrm{PRF}}^c] \\\\ &amp;amp;= \\mathbf{P}[D \\mid B_{\\mathrm{GCM}}] - \\mathbf{P}[D \\mid B_{\\mathrm{PRF}}^c \\cap \\mathcal{G}] \\mathbf{P}[\\mathcal{G} \\mid B_{\\mathrm{PRF}}^c] \\\\ &amp;amp;\\quad - \\mathbf{P}[D \\mid B_{\\mathrm{PRF}}^c \\cap \\mathcal{G}^c] \\mathbf{P}[\\mathcal{G}^c \\mid B_{\\mathrm{PRF}}^c], \\\\ &amp;amp;\\geq \\mathbf{P}[D \\mid B_{\\mathrm{GCM}}] - \\mathbf{P}[D \\mid B_{\\mathrm{GCM}}^c] - \\mathbf{P}[D \\mid B_{\\mathrm{PRF}}^c \\cap \\mathcal{G}^c] \\mathbf{P}[\\mathcal{G}^c \\mid B_{\\mathrm{PRF}}^c], \\\\ &amp;amp;= A_{\\mathrm{GCM}} - \\mathbf{P}[D \\mid B_{\\mathrm{PRF}}^c \\cap \\mathcal{G}^c] \\mathbf{P}[\\mathcal{G}^c \\mid B_{\\mathrm{PRF}}^c], \\\\ &amp;amp;\\geq A_{\\mathrm{GCM}} - \\mathbf{P}[\\mathcal{G}^c \\mid B_{\\mathrm{PRF}}^c] \\\\ &amp;amp;\\geq A_{\\mathrm{GCM}} - \\mathbf{P}[\\mathcal{Y}^c \\mid B_{\\mathrm{PRF}}^c] - \\mathbf{P}[\\mathcal{F}^c \\mid B_{\\mathrm{PRF}}^c]. \\end{aligned} \\tag{21}</span></div>

    <p class="text-gray-300">We rely on the fact that the rightmost two terms of Equation 21 are extremely small to keep the advantage low. The probability <span class="math">\\mathbf{P}[\\mathcal{Y}^c \\mid B_{\\mathrm{PRF}}^c]</span> was bounded in Equation 18. We next turn to <span class="math">\\mathbf{P}[\\mathcal{F}^c \\mid B_{\\mathrm{PRF}}^c]</span>. When the event <span class="math">B_{\\mathrm{PRF}}^c</span> occurs, Corollary 2 applies, and thus that probability is no more than <span class="math">q\\lceil l / w + 1 \\rceil 2^{-t}</span> (where we also make use of Lemma 2). The result then follows from Equation 21 and Lemma 1.</p>`;
---

<BaseLayout title="The Security and Performance of the Galois/Counter Mode of O... (2004/193)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/193
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
