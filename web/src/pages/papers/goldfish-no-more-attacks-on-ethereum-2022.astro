---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/1171';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Goldfish: No More Attacks on Ethereum?!';
const AUTHORS_HTML = 'Francesco D&#x27;Amato, Joachim Neu, Ertem Nusret Tas, David Tse';

const CONTENT = `    <p class="text-gray-300">Francesco D'Amato<span class="math">^{1}</span>, Joachim Neu<span class="math">^{2}</span>, Ertem Nusret Tas<span class="math">^{2}</span>, and David Tse<span class="math">^{2}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> Ethereum Foundation francesco.damato@ethereum.org <span class="math">^{2}</span> Stanford University {jneu,nusret,dntse}@stanford.edu</p>

    <p class="text-gray-300">Abstract. The LMD GHOST consensus protocol is a critical component of proof-of-stake Ethereum. In its current form, this protocol is brittle, as evidenced by recent attacks and patching attempts. We propose Goldfish, a new protocol that satisfies key properties required of a drop-in replacement for LMD GHOST: Goldfish is secure in the sleepy model, assuming a majority of the validators follows the protocol. Goldfish is reorg resilient so that honestly produced blocks are guaranteed inclusion in the ledger, and it supports fast confirmation with expected confirmation latency independent of the desired security level. Subsampling validators can improve the communication efficiency of Goldfish, and Goldfish is composable with finality/accountability gadgets. Crucially, Goldfish is structurally similar to LMD GHOST, providing a credible path to adoption in Ethereum. Attacks on LMD GHOST exploit lack of coordination among honest validators, typically provided by a locking mechanism in classical BFT protocols. However, locking requires votes from a quorum of all participants and is not compatible with fluctuating participation. Goldfish is powered by a novel coordination mechanism to synchronize the honest validators' actions. Experiments with our prototype implementation of Goldfish suggest practicality.</p>

    <p class="text-gray-300">Ethereum's Consensus Protocol. Ethereum's proof-of-stake (PoS) Byzantine fault tolerant (BFT) consensus protocol (Gasper [15], Fig. 1) consists of an overlay finality gadget (Casper FFG [14]) which provides safety under asynchrony, on top of an underlay chain (LMD GHOST, Latest Message Driven Greedy Heaviest Observed Sub-Tree [12, 73]) which should be secure under synchrony and dynamic participation. Importantly, dynamic participation here refers to the sleepy model [65] for a large number of unexpected temporary crash faults, not to, for instance, stake shift. This design works around the impossibility [34, 44, 56, 60, 61, 69] of having a single ledger that is secure under both asynchrony and dynamic participation. It is crucial that the underlay is both safe and live in the sleepy model, because earlier works have shown [16, 53, 60, 61, 69] that otherwise the whole protocol (i.e., underlay and overlay) can stall indefinitely. In</p>

    <p class="text-gray-300"><span class="math">^{1,2}</span> The authors are listed alphabetically. Contact authors: FD, JN, ENT.</p>

    <p class="text-gray-300">Francesco D'Amato, Joachim Neu, Ertem Nusret Tas, and David Tse</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. Gasper [15] consists of two sub-protocols: LMD GHOST ('fork choice rule') and Casper FFG [14] ('finality gadget'). The desiderata for Gasper were formalized by ebb-and-flow [60, 61, 69], which consists of security of the full chain under dynamic participation of validators, and accountable security of a finalized prefix.</p>

    <p class="text-gray-300">particular, the overlay can only 'checkpoint' transactions that are stable in the underlay. If the underlay stalls (not live) or keeps switching between different chains (not safe), then the overlay won't make progress. Thus, the underlay is not "just some optional optimistic path", but on the critical path for any transaction to get confirmed. Also, from a practical point of view, overlay confirmation is typically slow (e.g., min. 12 min delay to finality in Ethereum), while the underlay generates a block every few seconds. As a result, in Ethereum today, most users don't wait for Casper overlay confirmation, but de-facto already consider a transaction confirmed when it enters the tip of the LMD GHOST underlay chain. If the underlay does not provide at least some non-trivial safety guarantee, transactions can be reverted that have not yet been 'checkpointed' by the overlay, especially when overlay confirmation is delayed due to many unexpected crash faults, e.g., as happened on Ethereum mainnet in May 2023 [26, 63].</p>

    <p class="text-gray-300">Attacks and Patches for LMD GHOST. But, LMD GHOST (cf. Fig. 4) is not secure in the sleepy model. The initial version of LMD GHOST [15] is susceptible to the balancing attack [60,70]. In the attack, the adversary exploits the lack of a coordination mechanism for synchronizing the views of honest validators; so that different validators vote for conflicting blocks at each slot, and the network fails to reach consensus indefinitely. In response, a patch called proposer boosting was added [13]. Proposer boosting gives a current proposal a temporary extra weight in fork-choice. This was supposed to coordinate voters towards honest proposals and break the balance. However, the LMD provision alone can be exploited to conduct a balancing-type attack despite boosting [62], and LMD GHOST without LMD would suffer from a so-called avalanche attack [62]. Again in response, a patch called equivocation discounting was added to the protocol. Not least because of its complexity, the protocol with these patches has so far defied security analysis—both in terms of giving a security proof and further attacks. Certainly, the extra weight from proposer boosting gives an adversary much control over the chain, especially when the number of votes is low. Thus, proposer boosting renders LMD GHOST insecure under dynamic participation.</p>

    <p class="text-gray-300">Quest for a Coordination Mechanism. PBFT-style protocols [11, 18, 19, 74] coordinate validators using locking and absolute quorums, i.e., sets of votes from a large fraction of all validators. However, absolute quorums cannot be reached in the presence of many unexpected crash faults. Thus, such protocols don't satisfy liveness under dynamic participation in the sleepy model, which is crucial to withstand unforeseen regulatory changes, or soft-/hardware failures or</p>

    <p class="text-gray-300">Goldfish: No More Attacks on Ethereum?!</p>

    <p class="text-gray-300">upgrades <em>[60]</em>. Tolerating dynamic participation is indeed one reason why LMD GHOST avoids absolute quorums and selects <em>relatively</em> heavier blocks.</p>

    <p class="text-gray-300">Conversely, PoS variants of Nakamoto’s <em>longest chain</em> (LC) protocol <em>[4, 21, 27, 41, 65]</em> are secure in the sleepy model <em>[65]</em>. In LC, validators continuously build blocks extending the (relatively) longest chain. Only after a while, honest validators reach coordination on a chain prefix. Unfortunately, this entails <em>slow confirmation</em>, <em>i.e.</em>, expected confirmation latency linear in the desired consensus failure probability. Moreover, in LC, honestly produced blocks can be displaced (<em>reorg’ed</em>) by adversaries <em>[30]</em>, and validators have incentives to do so <em>[17, 1, 22, 45]</em>.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Key Techniques of Goldfish.</h4>

    <p class="text-gray-300">For Goldfish’s overall structure, failure of LC protocols to satisfy reorg resilience and fast confirmation due to “too few votes spread across too much time” suggests to employ a committee of voters that can create many votes supporting honest proposals soon after they are broadcast, similar to committees in PBFT-style protocols. However, as absolute quorums of PBFT-style protocols are incompatible with liveness under dynamic participation, rather than using the absolute number of votes, a protocol for dynamic participation must use their relative weights to favor blocks with stronger support during fork choice, similar to Nakamoto’s longest-chain rule. Together, these observations vindicate some structural elements of LMD GHOST and suggest to retain them in Goldfish: a succession of slots with a proposer and a committee that votes, all based on blocks’ relative vote weights like in the GHOST rule.</p>

    <p class="text-gray-300">Key to Goldfish is a novel coordination mechanism for honest voters to rally behind honest proposals. Unlike aforementioned mechanisms, this mechanism is secure in the sleepy model while also allowing for reorg resilience and fast confirmations. It is based on two techniques not commonly found in the literature:</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> Message buffering means each validator buffers votes received from the network and carefully times the inclusion of these votes into its local view, with priority given to votes relayed by the proposer. Conceptually, a validator echoes received votes but processes them only after some time or as soon as the proposer relays them. This ensures that in slots with an honest proposer, all honest validators adopt the view of the proposer and thus vote for its proposed block.</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> Vote expiry means that during each slot, only votes from the immediately preceding slot influence honest validators’ behavior. As a result, if in some slot all honest validators (which are assumed to outnumber adversary validators) vote to support a block (<em>i.e.</em>, vote for the block or one of its descendants), then all honest validators will again vote to support that block in the next slot.</p>

    <p class="text-gray-300">Together, these two techniques allow for a simple inductive security argument: Because proposers are selected randomly among the majority-honest val</p>

    <p class="text-gray-300">3 Confirmation latency denotes the delay for a transaction to enter the ledgers of all validators. It is a random variable that depends on the sequence of block proposers.</p>

    <p class="text-gray-300">4 Message buffering was also called 'view-merge' in a blog post [6] by one of the authors. We later noticed that a similar technique was used before in the unpublished Highway protocol [37]. Message buffering (cf. Alg. 2) also bears some conceptual resemblance to the view-change sub-protocol of Sync HotStuff [3, Fig. 2].</p>

    <p class="text-gray-300">5 Alleged forgetfulness of its animal namesake inspired Goldfish’s name.</p>

    <p class="text-gray-300">idators, slots with an honest proposer are frequent. By message buffering, all honest voters vote for the block proposed in such a slot (base case). By vote expiry, honest voters keep reaffirming this vote in perpetuity (induction step). Thus, honest proposals are guaranteed to remain in the canonical chain, implying reorg resilience. Since honest proposals contain fresh transactions and stabilize their prefix, and long streaks of adversary proposers are exponentially unlikely, liveness and safety follow readily. Details are provided in Secs. 3.1 and 4.</p>

    <p class="text-gray-300">A complementary perspective is that, conceptually, message buffering thwarts balancing-type attacks <em>[60, 70]</em> (it ensures that honest voters rally behind honest proposals), while vote expiry thwarts avalanche-type attacks <em>[62]</em> (it ensures that the adversary cannot reveal votes from long past slots—where the respective voter may still have been honest even). In this regard, LMD has a similar effect as vote expiry <em>[62]</em>, but LMD does not recover reorg resilience under dynamic participation, and is rendered ineffective entirely if validators are subsampled to form small voter committees for reduced communication complexity. In contrast, vote expiry allows subsampling. With expiry and subsampling, vote expiry drastically reduces the number of votes validators need to buffer and consider at any point, greatly contributing to message buffering’s practicality (see Sec. 5).</p>

    <p class="text-gray-300">Goldfish’s Contributions. Goldfish achieves the aforementioned desiderata: (a) Goldfish is <em>provably secure</em>, <em>i.e.</em>, safe and live, under <em>dynamic participation</em> in the sleepy model assuming an honest majority of validators, and adversary network delay up to a known upper bound <span class="math">\\Delta</span>. (b) Goldfish is <em>reorg resilient</em>, <em>i.e.</em>, honest proposals eventually enter the ledger, with the proposal’s prefix as determined at the time of block production (thus, no selfish mining <em>[30]</em>). (c) Goldfish satisfies <em>optimistic fast confirmation</em>: under optimistic conditions, <em>i.e.</em>, when participation is high and <span class="math">\\frac{3}{4}</span> fraction of validators are honest, it confirms transactions with constant expected latency independent of the consensus failure probability.</p>

    <p class="text-gray-300">Additionally, Goldfish supports <em>subsampling</em> of validators, which reduces communication and achieves resilience to adaptive corruption, since randomly selected validators send only a single protocol message (cf. player-replaceability <em>[20, 33, 72]</em>). Goldfish is also composable with <em>finality and accountability gadgets</em> such as <em>[14, 60, 61, 69]</em>. This means it can indeed be used as a dynamically available underlay in conjunction with an overlay (cf. Fig. 1) that preserves safety under asynchrony. Since the construction and its security proof mostly reuses techniques from <em>[60, 61, 69]</em>, we provide it in App. D, and focus in the following on Goldfish’s standalone behavior in the sleepy model assuming synchrony.</p>

    <p class="text-gray-300">Crucially, Goldfish is intentionally simple, and similar to LMD GHOST as currently deployed in Ethereum, to provide a credible path for adoption (compare Figs. 4, 5 and 6). Message buffering and vote expiry can be realized with modest changes to the existing vote accounting logic of LMD GHOST. Goldfish is the first positive result (security proof) for a variant of LMD GHOST, strengthening confidence in this protocol family. Simplicity of Goldfish also makes it a good pedagogical example as a feature-rich consensus protocol for the sleepy model.</p>

    <p class="text-gray-300">Related Works. The first secure consensus protocol for the sleepy model <em>[65]</em> was Nakamoto’s LC protocol, first based on proof-of-work (PoW) <em>[32, 52]</em>, and</p>

    <p class="text-gray-300">Goldfish: No More Attacks on Ethereum?!</p>

    <p class="text-gray-300">Table 1. Comparison of Goldfish with related works regarding key desiderata. Optimistic ('opt.') fast confirmation requires high participation and less than  <span class="math">\\frac{1}{4}</span>  adversary fraction. Dynamic participation  <span class="math">\\checkmark</span>  (slow)' indicates the protocol remains live only under slow fluctuations in participation. A number next to  <span class="math">\\checkmark</span>  for fast confirmation denotes the minimum confirmation latency. Responsive ('resp.') confirmation means with delay of the actual network delay rather than delay bound  <span class="math">\\Delta</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PoS/permissioned BFT consensus protocols ... for the sleepy model [65]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">... for other models</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">LC [4] [5,21,31]</td>

            <td class="px-3 py-2 border-b border-gray-700">Thunder- ella [66]</td>

            <td class="px-3 py-2 border-b border-gray-700">KW21 [40]</td>

            <td class="px-3 py-2 border-b border-gray-700">GLR21 [35]</td>

            <td class="px-3 py-2 border-b border-gray-700">MR22 [51]</td>

            <td class="px-3 py-2 border-b border-gray-700">MMR22 [47]</td>

            <td class="px-3 py-2 border-b border-gray-700">GL23† [46]</td>

            <td class="px-3 py-2 border-b border-gray-700">MMR23† [49]</td>

            <td class="px-3 py-2 border-b border-gray-700">Goldfish (this work)</td>

            <td class="px-3 py-2 border-b border-gray-700">PBFT-style [11,18,19,74]</td>

            <td class="px-3 py-2 border-b border-gray-700">Highway [37]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Dynamic participation</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓ (slow)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓ (slow)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Reorg resilience</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Adversary resilience</td>

            <td class="px-3 py-2 border-b border-gray-700">1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">1/3</td>

            <td class="px-3 py-2 border-b border-gray-700">1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">1/3</td>

            <td class="px-3 py-2 border-b border-gray-700">1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">1/3</td>

            <td class="px-3 py-2 border-b border-gray-700">flexible</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fast confirmation</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">opt. (resp.)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✓ (37Δ)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓ (3Δ)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓ (10Δ)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓ (4Δ)</td>

            <td class="px-3 py-2 border-b border-gray-700">opt. (4Δ)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓ (resp.)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Similar to LMD GHOST</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\dagger</span>  Appeared in preprint after completion of Goldfish [23].</p>

    <p class="text-gray-300">subsequently on PoS [4,21,27,41,65] (see Tab. 1 for a comparison of Goldfish with related works). Parallel composition of LC protocol instances was suggested in [5,31] to overcome the scaling of LC protocols' confirmation latency with the security parameter  <span class="math">\\kappa</span> . For the same goal, Thunderella [66] proposed combining a PBFT-style protocol achieving optimistic fast confirmation with a slow LC protocol for when the adversary fraction is high. (A similar idea was explored in Zyzzyva [2,43], where validators run a PBFT-style protocol, but optimistically confirm the primary's ordering. Zyzzyva is not dynamically available.) However, as observed above, LC protocols and Thunderella that builds on an LC protocol are not reorg resilient. Moreover, under optimistic conditions, Thunderella recovers fast confirmation only after a period of LC confirmation delay, whereas Goldfish can instantaneously resume fast-confirming. Many classical PBFT-style consensus protocols [18,19,74] have constant (expected) confirmation latency and can be reorg resilient, but don't tolerate dynamic participation. Highway [37] enables confirming blocks using different absolute quorum sizes; however it does not support dynamic participation. An early 'classical' BFT protocol for a model with unknown (but static) participation is KW21 [39,40]. A subsequent protocol GLR21 [35] supports dynamic participation with confirmation latency independent of the participation level, but still linear in the security parameter  <span class="math">\\kappa</span>  [51]. Confirmation latency independent of the security parameter is achieved in the PoW setting with omission and Byzantine faults by [67] and [68], respectively.</p>

    <p class="text-gray-300">A recent work MR22 [51] presents the first permissioned/PoS protocol that supports dynamic participation with confirmation latency independent of the security parameter and participation level, with the caveats that temporary stability in the honest participation is necessary to ensure liveness, and a growing adversary cannot be tolerated. Whereas [51] ensures fast confirmation with adversary resilience  <span class="math">\\frac{1}{2}</span>  without requiring high participation, its confirmation latency is  <span class="math">37\\Delta</span> , considerably larger than the latency of Goldfish  <span class="math">(4\\Delta)</span>  under optimistic conditions. In the contemporary independent work [47,48], the prerequisites for liveness were relaxed and latency was improved to  <span class="math">3\\Delta</span> , at the expense of reduced adversary resilience (from  <span class="math">\\frac{1}{2}</span>  down to  <span class="math">\\frac{1}{3}</span> ). After completion of Goldfish,</p>

    <p class="text-gray-300">MMR23 <em>[49]</em> combines techniques from <em>[51]</em> and <em>[47]</em> to achieve resilience <span class="math">\\frac{1}{2}</span> and latency <span class="math">4\\Delta</span>, while doing away with the stable participation requirement for liveness of <em>[51]</em>. GL23 <em>[46]</em> achieves a similar result independently and concurrently. Both use expiring votes, like Goldfish, to tolerate increasing adversaries.</p>

    <p class="text-gray-300">Increased communication complexity is a challenge with these later protocols. In Goldfish, each voter only has to send a single message per slot, and messages can be relayed as-is to other validators, in practice efficiently implemented through gossip networks. In MMR23 <em>[49]</em>, for instance, validators need to send tally messages for potentially many blocks, while GL23 <em>[46]</em> requires each validator to attach its own signature on every received vote before relaying. Thus, Goldfish always needs to gossip at most linearly many <em>distinct</em> messages, while GL23 <em>[46]</em> needs to at times gossip quadratically many distinct messages. The possibility of many messages with different contents also makes these protocols less amenable to signature aggregation. Together with their considerable deviations from LMD GHOST, these are concrete challenges faced by these protocols in their possible path to adoption in Ethereum, as compared to Goldfish.</p>

    <p class="text-gray-300">Follow-Ups & Adoption. A challenge Goldfish shares with related works <em>[46, 49, 51]</em> is that a brief period of asynchrony suffices to cause ‘deep’ safety violations (up to the last checkpoint if used with overlay, cf. Fig. 1). A Goldfish variant in follow-up work <em>[24]</em> addresses this issue, by trading off a longer vote expiry period for a less dynamic participation model. The current candidate protocol <em>[25]</em> to provide ‘single-slot finality’ for Ethereum is based on that Goldfish variant.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 Preliminaries and Model</h2>

    <p class="text-gray-300">We recap the sleepy model <em>[65]</em> for dynamic participation under synchrony.</p>

    <p class="text-gray-300">Preliminaries. Let <span class="math">\\kappa,\\lambda</span> be the <em>security parameters</em> of Goldfish itself and of the cryptographic primitives it uses, respectively. Specifically, <span class="math">\\kappa</span> will be Goldfish’s (slow-path) confirmation latency, cf. Alg. 2, l. 29. A function is <em>negligible</em> in <span class="math">\\mu</span>, denoted <span class="math">\\text{negl}(\\mu)</span>, if it is <span class="math">o(1/\\mu^{d})</span> for all <span class="math">d&gt;0</span>. An event happens <em>with overwhelming probability</em> (<em>w.o.p.</em>) if it happens except with probability (<em>w.p.</em>) <span class="math">\\text{negl}(\\kappa)+\\text{negl}(\\lambda)</span>. Goldfish uses a signature scheme Sig with key generation, sign, and verify algorithms Sig.Gen, Sig.Sign, Sig.Verify (cf. App. G.1). A verifiable random function (VRF) <em>[50]</em> scheme Vrf with function generation, evaluation prove, and evaluation verify algorithms Vrf.Gen, Vrf.Eval, Vrf.Verify (cf. App. G.2) is used for leader election and committee subsampling, as in <em>[20, 33]</em>.</p>

    <p class="text-gray-300">Validator. Goldfish is run among <span class="math">n</span> validators, with identities <span class="math">\\mathsf{id}\\in[n]\\triangleq\\{1,...,n\\}</span>. Each generates a secret/public key pair <span class="math">(\\mathsf{ssk}_{\\mathsf{id}},\\mathsf{spk}_{\\mathsf{id}})</span> and <span class="math">(\\mathsf{vsk}_{\\mathsf{id}},\\mathsf{vpk}_{\\mathsf{id}})</span> for Sig and Vrf, respectively. The public keys are commonly known (<em>i.e.</em>, PKI). As is customary to study new consensus protocols, we assume that every validator has one unit of stake throughout the execution (<em>i.e.</em>, static homogeneous stake). Gradual stake shift (<em>i.e.</em>, dynamic stake) can be supported using techniques that bootstrap PoS protocols from static-stake protocols with PKI <em>[21, 27, 29]</em>.</p>

    <p class="text-gray-300">Environment and Adversary. Time proceeds in discrete <em>rounds</em> and the</p>

    <p class="text-gray-300">Goldfish: No More Attacks on Ethereum?!</p>

    <p class="text-gray-300">validators have synchronized clocks. (Bounded clock offsets can be lumped into the network delay upper bound <span class="math">\\Delta</span> discussed below.) Validators receive transactions (txs) from the environment, and can <em>broadcast</em> messages to each other. The adversary is a probabilistic poly-time (PPT) algorithm that can control three aspects of the model (corruption, sleepiness, network delay) to attack consensus. We first discuss these three aspects, and then the adversary’s powers and limits.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Corruption</h4>

    <p class="text-gray-300">The adversary chooses <span class="math">f</span> <em>adversary</em> validators (adaptively, subject to constraints detailed below). Non-adversary validators are <em>honest</em>. Naturally, the adversary learns the internal state of its validators and can make them deviate from the protocol arbitrarily (Byzantine faults) for the rest of the execution (permanent corruption). We define the adversary fraction <span class="math">\\beta\\triangleq f/n</span>.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Sleepiness</h4>

    <p class="text-gray-300">The adversary decides for each round and honest validator whether it is <em>asleep</em> or not. Asleep validators do not execute the protocol (temporary crash faults). Messages delivered to an asleep validator are picked up by it only once it is no longer asleep. When a validator stops being asleep, it becomes <em>dreamy</em>. It then <em>joins</em> the protocol, possibly over multiple rounds, using a <em>joining procedure</em> specified by the protocol. Upon completion, the validator becomes <em>awake</em> and follows the protocol normally. Adversary validators are always awake. The number of awake validators is bounded below by a constant <span class="math">n_{0}</span> across rounds.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Network Delay</h4>

    <p class="text-gray-300">Messages sent between validators are delivered with an adversarially determined delay that can differ for each recipient. Upon picking up messages (<em>i.e.</em>, once not asleep), an honest validator re-broadcasts them.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Adversary Powers and Limits</h4>

    <p class="text-gray-300">For message delivery, the adversary has to obey a delay upper-bound of <span class="math">\\Delta</span> rounds, which is known to the validators (<em>synchrony</em>). Message delays and sleep schedule are chosen by the adversary adaptively. For sleepiness and corruption, Goldfish supports two assumptions: Either, we require <em>mildly</em> adaptive corruption, where it takes <span class="math">3\\Delta</span> rounds for corruption to take effect, together with the constraint that for every round <span class="math">r</span>, the number of adversary validators at round <span class="math">r</span> must be less than the number of honest awake validators at round <span class="math">r-3\\Delta</span>. Or, analogously to earlier works <em>[4, 20, 41]</em>, through the use of key evolving <em>[7, 36]</em> signature and VRF schemes, we allow for fully adaptive corruption, together with the constraint that for every round <span class="math">r</span>, the number of adversary validators at round <span class="math">r</span> must be less than the number of honest awake validators at round <span class="math">r</span>. The precise technical assumptions are stated by Def. 2.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Security</h4>

    <p class="text-gray-300">Security is parameterized by <span class="math">\\kappa</span>, which for Goldfish affects the confirmation latency. We consider a finite execution horizon of <span class="math">T_{\\text{hor}}=\\text{poly}(\\kappa)</span> rounds.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 1 (Security).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{ch}\\preceq\\mathsf{ch}^{\\prime}</span> express that ledger <span class="math">\\mathsf{ch}</span> is a prefix of (or the same as) ledger <span class="math">\\mathsf{ch}^{\\prime}</span>. A consensus protocol, where at round <span class="math">r</span> validator <span class="math">\\mathsf{id}</span> outputs ledger <span class="math">\\mathsf{ch}_{r}^{\\mathsf{id}}</span>, is <em>secure with transaction confirmation time</em> <span class="math">T_{\\text{conf}}</span>, iff w.o.p.:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Safety: <span class="math">\\forall r,r^{\\prime}\\colon\\forall\\text{honest }\\mathsf{id},\\mathsf{id}^{\\prime}</span> awake at <span class="math">r,r^{\\prime}\\colon(\\mathsf{ch}_{r}^{\\mathsf{id}}\\preceq\\mathsf{ch}_{r^{\\prime}}^{\\mathsf{id}^{\\prime}})\\vee(\\mathsf{ch}_{r^{\\prime}}^{\\mathsf{id}^{\\prime}}\\preceq\\mathsf{ch}_{r}^{\\mathsf{id}})</span>.</li>

      <li>Liveness: If transaction <span class="math">\\mathsf{tx}</span> was received by some awake honest validator by <span class="math">r</span>, then <span class="math">\\forall r^{\\prime}\\geq r+T_{\\text{conf}}\\colon\\forall\\text{honest }\\mathsf{id}</span> awake at <span class="math">r^{\\prime}\\colon\\mathsf{tx}\\in\\mathsf{ch}_{r^{\\prime}}^{\\mathsf{id}}</span>.</li>

    </ul>

    <p class="text-gray-300">The protocol satisfies <em><span class="math">\\bar{f}</span>-safety</em> (<span class="math">\\bar{f}</span>-<em>liveness</em>) if it is safe (live) if <span class="math">f&amp;lt;\\bar{f}</span>. It satisfies <em><span class="math">1/2</span>-safety</em> (<span class="math">1/2</span>-<em>liveness</em>) if it is safe (live) if <span class="math">\\beta&amp;lt;1/2-\\varepsilon</span> for some <span class="math">\\varepsilon&amp;gt;0</span>.</p>

    <p class="text-gray-300">Francesco D'Amato, Joachim Neu, Ertem Nusret Tas, and David Tse</p>

    <p class="text-gray-300">Algorithm 1 Interface of VRF-based lotteries and validity of data structures. 1:  <span class="math">\\triangleright</span>  VRF-based lotteries 2:  <span class="math">\\varrho \\triangleq (y,\\pi)\\gets \\mathrm{Open}_{\\varrho}^{\\mathrm{(tag,thr)}}(t)\\triangleq \\mathrm{Vrf.Eval}(\\mathrm{vsk}_{\\mathrm{id}},\\mathrm{tag}\\parallel t)</span> 3:  <span class="math">\\{1,0\\} \\leftarrow \\mathrm{Wins}^{\\mathrm{(tag,thr)}}((\\mathrm{id},t),\\varrho)\\triangleq (\\varrho .y\\leq \\mathrm{thr}2^{\\lambda})\\wedge \\mathrm{Vrf.Verify}(\\mathrm{vpk}_{\\mathrm{id}},\\mathrm{tag}\\parallel t,(\\varrho .y,\\varrho .\\pi))</span> 4:  <span class="math">[0,1]\\gets \\mathrm{Prio}(\\varrho)\\triangleq \\frac{\\varrho.y}{\\lambda}</span> 5: Data structures 6:  <span class="math">\\{1,0\\} \\leftarrow \\mathrm{Valid}(B)\\triangleq (B = B_0)</span>  Block  <span class="math">B</span> <span class="math">\\vee (\\mathrm{Wins}^{(\\mathrm{block,thr_b})}((B.\\mathrm{id},B.t),B.\\varrho)</span> <span class="math">\\wedge \\mathrm{Sig.Verify}(\\mathrm{spk}_{B.\\mathrm{id}},\\mathrm{block}\\parallel B.h\\parallel B.tx,s,B.\\sigma)</span> <span class="math">\\wedge \\mathrm{Valid}(^{<em>} [B.h])\\wedge (B.t &amp;gt; ^{</em>} [B.h].t))</span> 7:  <span class="math">\\{1,0\\} \\leftarrow \\mathrm{Valid}(v)\\triangleq \\mathrm{Wins}^{(\\mathrm{vote,thr_v})}((v.\\mathrm{id},v.t),v.\\varrho)\\wedge \\mathrm{Sig.Verify}(\\mathrm{spk}_{v.\\mathrm{id}},\\mathrm{vote}\\parallel v.h,v.\\sigma)</span>  Vote  <span class="math">v</span> <span class="math">\\wedge \\mathrm{Valid}(^{<em>} [v.h])\\wedge (v.t\\geq^{</em>} [v.h].t)</span> 8:  <span class="math">\\{1,0\\} \\leftarrow \\mathrm{Valid}(M)\\triangleq \\mathrm{Valid}(M.x)</span>  Piece  <span class="math">M</span> 9:  <span class="math">\\{1,0\\} \\leftarrow \\mathrm{Valid}(P)\\triangleq \\mathrm{Valid}(P.B)</span> <span class="math">\\wedge</span>  Consistent  <span class="math">(P.\\mathcal{T}\\cup \\{P.B\\})</span> <span class="math">\\wedge</span>  Sig.Verify  <span class="math">(\\mathrm{spk}_{P.B.M},\\mathrm{propose}\\parallel P.\\mathcal{T}\\parallel P.B,P.\\sigma)</span> <span class="math">\\wedge (\\forall x\\in P.\\mathcal{T}:</span>  Valid  <span class="math">(x)\\wedge (x.t &amp;lt;   P.B.t))</span></p>

    <p class="text-gray-300">We describe the basic Goldfish protocol in Sec. 3.1 and its optimistic fast confirmation extension in Sec. 3.2. The composition of Goldfish as underlay chain with an overlay gadget (cf. Fig. 1) is described and analyzed in App. D, due to space constraints and since this mostly reuses orthogonal techniques from [60, 61, 69],</p>

    <p class="text-gray-300">The basic Goldfish protocol (cf. Algs. 1, 2 and 3) proceeds in slots of  <span class="math">3\\Delta</span>  rounds.</p>

    <p class="text-gray-300">VRF-based Lotteries. The VRF PKI enables cryptographic lotteries. A lottery (tag, thr) is defined by a fixed tag and threshold thr ∈ [0,1]. Each validator id receives for each slot  <span class="math">t</span>  a lottery ticket (id, t). A ticket can be opened, Alg. 1, l. 2. An opened ticket with opening  <span class="math">\\varrho</span>  can be winning for (tag, thr), Alg. 1, l. 3, and winning opened tickets are totally ordered by increasing precedence, Alg. 1, l. 4.</p>

    <p class="text-gray-300">Data Structures. Blocks and votes are central to Goldfish. A block  <span class="math">B \\triangleq (\\mathsf{block}, (\\mathsf{id}, t), \\varrho, h, \\mathsf{txs}, \\sigma)</span>  consists of tag 'block', ticket  <span class="math">(\\mathsf{id}, t)</span>  and opening  <span class="math">\\varrho</span>  to the  <span class="math">(\\mathsf{block}, \\mathsf{thr}_{\\mathrm{b}})</span>  block production lottery, hash  <span class="math">h</span>  committing to the new block's parent block and transactions txs (as block 'content'), and signature  <span class="math">\\sigma</span>  binding together block production opportunity and the block's content. A special genesis block  <span class="math">B_0 \\triangleq (\\mathsf{block}, (\\bot, 0), \\bot, \\bot, \\emptyset, \\bot)</span>  is known to all validators. A block  <span class="math">B</span>  is valid following Alg. 1, l. 6, where  <span class="math">^<em>[B.h]</span>  means the parent block that  <span class="math">B.h</span>  commits to (namely,  <span class="math">^</em>[x]</span>  represents the block committed by hash  <span class="math">x</span> ). The context within which these references get resolved is detailed with the different network message types below. A vote  <span class="math">v \\triangleq (\\mathsf{vote}, (\\mathsf{id}, t), \\varrho, h, \\sigma)</span>  consists of tag 'vote', ticket  <span class="math">(\\mathsf{id}, t)</span>  and opening  <span class="math">\\varrho</span>  to the  <span class="math">(\\mathsf{vote}, \\mathsf{thr}_{\\mathrm{v}})</span>  voting lottery, hash  <span class="math">h</span>  committing to the block voted for (as vote 'content'), and signature  <span class="math">\\sigma</span>  binding together voting opportunity and the vote's content. Every vote  <span class="math">v</span>  is tied to its slot  <span class="math">v.t</span>  via the lottery ticket  <span class="math">(\\mathsf{id}, t)</span> . A vote  <span class="math">v</span>  is valid following Alg. 1, l. 7.</p>

    <p class="text-gray-300">We call block-vote-set (short bvset) a set of blocks and votes. Commitments to blocks for the purpose of the references <span class="math">v.h</span> or <span class="math">B.h</span> are computed using <span class="math">H(.)</span>. For a bvset <span class="math">\\mathcal{T}</span> we denote by <span class="math">\\mathcal{T}[h]</span> the block <span class="math">B\\in\\mathcal{T}</span> with <span class="math">H(B)=h</span>, and <span class="math">\\bot</span> if non-existent. In Goldfish, votes and blocks are encapsulated and exchanged in two network message types, pieces and proposals. A piece <span class="math">M\\triangleq(\\texttt{piece},x)</span> consists of tag ‘piece’ and for payload <span class="math">x</span> either a vote or a block, and is valid following Alg. 1, l. 8. Pieces are used to propagate blocks and votes and abstract peer-to-peer broadcast object propagation. In determining a piece’s validity, block references <em>[.]</em> are resolved with respect to the bvset <span class="math">\\mathcal{T}</span> each validator maintains as part of its state, see below. If a validator does not have any matching block in <span class="math">\\mathcal{T}</span>, it cannot currently determine the piece’s validity. It then queues the piece ‘in limbo’ for re-examination until its (in-)validity is established. A proposal <span class="math">P\\triangleq(\\texttt{propose},\\mathcal{T},B,\\sigma)</span> consists of tag ‘propose’, bvset <span class="math">\\mathcal{T}</span> and block <span class="math">B</span> (as proposal content), and signature <span class="math">\\sigma</span> tying the proposal to the block production opportunity of <span class="math">B</span>. Thus, a proposal <span class="math">P</span> is valid following Alg. 1, l. 9, where Consistent(<span class="math">\\mathcal{T}</span>) is satisfied on a bvset <span class="math">\\mathcal{T}</span> iff <span class="math">B_{0}\\in\\mathcal{T}</span> and for every vote and block in <span class="math">\\mathcal{T}</span> the referenced target/parent block is also in <span class="math">\\mathcal{T}</span>. In determining the validity of proposal <span class="math">P</span>, block references *[.] are resolved with respect to <span class="math">P.\\mathcal{T}</span>. We call a bvset <span class="math">\\mathcal{T}</span> with Consistent(<span class="math">\\mathcal{T}</span>) a block-vote-tree (short bvtree). Merge(<span class="math">\\mathcal{T},\\mathcal{B}</span>) returns the largest bvtree <span class="math">\\mathcal{T}^{\\prime}</span> that is a subset of the union of <span class="math">\\mathcal{T}</span> and the pieces in <span class="math">\\mathcal{B}</span>.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">3.2.2 Protocol.</h4>

    <p class="text-gray-300">Each validator knows the current slot <span class="math">t</span>, and maintains a buffer <span class="math">\\mathcal{B}</span> and a bvtree <span class="math">\\mathcal{T}</span>. On a high level, messages enter from the network into <span class="math">\\mathcal{B}</span>, while votes are tallied on <span class="math">\\mathcal{T}</span>. The ‘magic’ of Goldfish is in how blocks and votes enter from <span class="math">\\mathcal{B}</span> to <span class="math">\\mathcal{T}</span> (message buffering, purple) and leave <span class="math">\\mathcal{T}</span> (vote expiry, orange).</p>

    <p class="text-gray-300">Valid messages received from the network are re-broadcast and added to <span class="math">\\mathcal{B}</span>. (As is customary, messages whose validity is unknown due to missing references, and messages with future slot numbers, are queued ‘in limbo’ outside the protocol.) For proposals, the blocks and votes contained therein are additionally re-broadcast and added to <span class="math">\\mathcal{B}</span> as individual pieces.</p>

    <p class="text-gray-300">We describe the three phases (Propose, Vote, Confirm) of each slot <span class="math">t</span> from the perspective of an awake honest validator id (Alg. 2, Fig. 5):</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> Propose: At round <span class="math">3\\Delta t</span>, id checks if its lottery ticket <span class="math">(\\texttt{id},t)</span> is winning for <span class="math">(\\texttt{block},\\texttt{thr}_{\\texttt{b}})</span> (Alg. 2, l. 6). If so, id temporarily merges its bvtree with its buffer (Alg. 2, l. 7), identifies the GHOST-Eph chain tip using only slot <span class="math">t-1</span> votes (Alg. 2, l. 8, Alg. 3), and proposes its temporary bvtree and a new block based on it (Alg. 2, l. 12). Note that in a practical implementation, the proposals need not contain the whole bvtree, but merely the votes therein (see Sec. 5).</p>

    <p class="text-gray-300">For GHOST-Eph fork-choice (Alg. 3), a validator walks its bvtree, starting at the genesis block, and at each block <span class="math">B</span>, the validator proceeds to the child of <span class="math">B</span> whose subtree is heaviest, i.e., received the plurality of non-expired votes.</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> Vote: At <span class="math">3\\Delta t+\\Delta</span>, id identifies as leader for slot <span class="math">t</span> the proposal with smallest precedence (Alg. 2, l. 17). It merges the leading proposal’s bvtree into its bvtree <span class="math">\\mathcal{T}</span> (Alg. 2, l. 19). Then it checks if its lottery ticket <span class="math">(\\texttt{id},t)</span> is winning for <span class="math">(\\texttt{vote},\\texttt{thr}_{\\texttt{v}})</span> (Alg. 2, l. 21). If so, id identifies the GHOST-Eph chain tip using only slot <span class="math">t-1</span> votes (Alg. 2, l. 22), and votes for it (Alg. 2, l. 25).</p>

    <p class="text-gray-300">Francesco D'Amato, Joachim Neu, Ertem Nusret Tas, and David Tse</p>

    <p class="text-gray-300">Algorithm 2 Goldfish executed by validator id with signature keys  <span class="math">(\\mathsf{ssk}_{\\mathsf{id}},\\mathsf{spk}_{\\mathsf{id}})</span> , VRF keys  <span class="math">(\\mathsf{vsk}_{\\mathsf{id}},\\mathsf{vpk}_{\\mathsf{id}})</span> , bvtree  <span class="math">\\mathcal{T}</span>  and buffer  <span class="math">\\mathcal{B}</span> . Here, notation 'at' means executing the code block at the specified round,  <span class="math">\\mathsf{ch}^{\\mathsf{id}}</span>  denotes the Goldfish chain momentarily confirmed at id. For GHOST-EPH  <span class="math">(\\mathcal{T},t)</span> , see Alg. 3.</p>

    <p class="text-gray-300">| 1: (B, T, t) ← (θ, {B0}, 0) ▷ Initialize buffer B and bvtree T |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">| 2: ▷ As is customary, only valid messages with time slot numbers at most t are re-broadcast and put into B. Invalid messages are discarded. Messages of unknown validity are queued. Blocks and votes contained in proposals are also re-broadcast and added to B as individual pieces. |</p>

    <p class="text-gray-300">| 3: for t = 1, 2, ... do ▷ Slots |</p>

    <p class="text-gray-300">| 4: at 3Δt do ▷ Propose phase |</p>

    <p class="text-gray-300">| 5: φ ← Open(d block, thrb) (t) ▷ Check if eligible to propose |</p>

    <p class="text-gray-300">| 6: if Wins(block, thrb) ((id, t), φ) then |</p>

    <p class="text-gray-300">| 7: T' ← MERGE(T, B) ▷ Bvtree to propose |</p>

    <p class="text-gray-300">| 8: B ← GHOST-EPH(T', t-1) ▷ Parent block |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9: σ ← Sig. Sign(ssk_id, block</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H(B)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">txs)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 10: B ← (block, (id, t), φ, H(B), txs, σ) ▷ New block |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11: σ ← Sig. Sign(ssk_id, propose</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 12: Broadcast (propose, T', B, σ) ▷ Propose |</p>

    <p class="text-gray-300">| 13: at 3Δt + Δ do ▷ Vote phase |</p>

    <p class="text-gray-300">| 14: ▷ Filter for proposals from slot t |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">15: B' ← {(T', B)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(propose, T', B, .) ∈ B ∧ B.t = t}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 16: Identify the leader of slot t and its proposal |</p>

    <p class="text-gray-300">| 17: (T', B') ← arg min{ (T', B) ∈ B' } Prio(B, φ) |</p>

    <p class="text-gray-300">| 18: ▷ Merge own buffer and that of the leader into own bvtree |</p>

    <p class="text-gray-300">| 19: T ← MERGE(T, T' <em> ∪ {B</em>}) |</p>

    <p class="text-gray-300">| 20: φ ← Open(d vote, thrv) (t) ▷ Check if eligible to vote |</p>

    <p class="text-gray-300">| 21: if Wins(vote, thrv) ((id, t), φ) then |</p>

    <p class="text-gray-300">| 22: B ← GHOST-EPH(T, t-1) ▷ Target block |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">23: σ ← Sig. Sign(ssk_id, vote</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H(B))</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 24: v ← (vote, (id, t), φ, H(B), σ) ▷ New vote |</p>

    <p class="text-gray-300">| 25: Broadcast (piece, v) ▷ Vote |</p>

    <p class="text-gray-300">| 26: at 3Δt + 2Δ do ▷ CONFIRM phase |</p>

    <p class="text-gray-300">| 27: T ← MERGE(T, B) ▷ Merge buffer and bvtree |</p>

    <p class="text-gray-300">| 28: B ← GHOST-EPH(T, t) ▷ Canonical GHOST-Eph chain |</p>

    <p class="text-gray-300">| 29: chid ← B' ∧ Output ledger: B's κ-deep prefix in terms of slots |</p>

    <p class="text-gray-300">Algorithm 3 GHOST-Eph fork-choice rule.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1: CHILDREN(T,B) ≡ {B' ∈ T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B'.h = H(B)}</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2: VOTES(T,B,t) ≡ {id'</td>

            <td class="px-3 py-2 border-b border-gray-700">(vots, (id',t),.,h,.) ∈ T ∧ B ≤ T[h]}</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 3: function GHOST-EPH(T,t) |</p>

    <p class="text-gray-300">| 4: B ← B0 ▷ Start fork-choice at genesis block |</p>

    <p class="text-gray-300">| 5: forever do |</p>

    <p class="text-gray-300">| 6: ▷ Choose the heaviest subtree (breaking ties deterministically) rooted at one of the children blocks B' of B, by number of validators that have cast a vote in slot t for B' or one of its descendants; B' = ⊥ if CHILDREN(T,B) = ∅ |</p>

    <p class="text-gray-300">| 7: B' ← arg maxB'∈CHILDREN(T,B) VOTES(T,B',t) |</p>

    <p class="text-gray-300">| 8: if B' = ⊥ then return B |</p>

    <p class="text-gray-300">| 9: B ← B' |</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CONFIRM: At round  <span class="math">3\\Delta t + 2\\Delta</span> , id merges its buffer into its bvtree (Alg. 2, l. 27). It then identifies the GHOST-Eph chain tip using only slot  <span class="math">t</span>  votes (Alg. 2, l. 28), and outputs as confirmed ledger  <span class="math">\\mathsf{ch}^{\\mathsf{id}}</span>  the transactions of those blocks in the GHOST-Eph chain that are from slots  <span class="math">\\leq t - \\kappa</span>  (' <span class="math">\\kappa</span> -deep in time', Alg. 2, l. 29). Since the ledger in view of an awake honest validator id is only updated at this point, we may view the ledger as indexed by slot  <span class="math">t</span> :  <span class="math">\\mathsf{ch}_t^{\\mathsf{id}}</span> .</li>

    </ul>

    <p class="text-gray-300">Key Mechanism. Message buffering ensures that if in slot  <span class="math">t</span>  the leading proposal is honest, then all honest voters in  <span class="math">t</span>  will vote for it (Lem. 2), because in</p>

    <p class="text-gray-300">Propose, the leader’s temporary bvtree <span class="math">\\mathcal{T}^{\\prime}</span> is a superset of all honest validators’ bvtrees, and thus in Vote all honest voters adopt that leader’s bvtree. <em>Vote expiry</em> (and honest majority) ensures that if in slot <span class="math">t</span> all honest voters vote into the subtree rooted at some block <span class="math">B</span>, then all honest voters in slot <span class="math">t+1</span> will also vote into the subtree rooted at <span class="math">B</span> (Lem. 3). Induction on <span class="math">t</span> readily yields reorg resilience. Furthermore, w.o.p., every interval of <span class="math">\\kappa</span> slots has at least one honest leading proposer (Lem. 1). The prefix of that proposal stabilizes (by reorg resilience), and the proposal includes unconfirmed transactions, leading to safety and liveness (with <span class="math">T_{\\mathrm{conf}}=2\\kappa+2</span>) of the <span class="math">\\kappa</span>-deep confirmation rule.</p>

    <p class="text-gray-300">Without <em>message buffering</em>, honest voters would no longer be guaranteed to rally behind honest proposals. Instead, the adversary could induce inconsistent views among honest voters, leading to them no longer voting <em>en bloc</em>, which restores the balancing attack <em>[60, 70]</em>. Without <em>vote expiry</em>, honest voters would not be guaranteed to vote into the subtree of <span class="math">B</span> in <span class="math">t+1</span> just because <span class="math">B</span> gathered votes from all honest validators in <span class="math">t</span>. In fact, the adversary could use votes from longer ago to break the protocol. We give two examples. First, adversary validators could strategically release votes for long past slots, like in the avalanche attack <em>[62]</em>. Second, in periods where participation is increasing, the adversary could, for validators that were asleep in the past but are now adversary, forge votes for these past slots for a block conflicting with <span class="math">B</span>. Conceptually, thereby, the adversary gains control of a dishonest majority for past slots, which can break security. Vote expiry preserves security when the number of adversary validators increases together with the number of honest validators over time.</p>

    <p class="text-gray-300">Joining Procedure. At each round, a validator is either asleep, dreamy or awake (Sec. 2). Whenever a validator stops being asleep, it is <em>dreamy</em>. Dreamy validators don’t follow Alg. 2, except for relaying messages. With the next Confirm phase, the validator returns to being <em>awake</em> and fully resumes Alg. 2. To allow for more time to download messages missed during sleep, dreaminess can be extended accordingly, but should always end at a Confirm phase.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.2 Optimistic Fast Confirmations</h3>

    <p class="text-gray-300">Basic Goldfish (Sec. 3.1) provides reorg resilience, but its <span class="math">\\kappa</span>-deep confirmation rule leads to <span class="math">\\Theta(\\kappa)</span> latency in worst and expected case. We add a Fast-Confirm phase and introduce a fast confirmation rule, to achieve constant expected confirmation latency <em>under optimistic conditions</em>, <em>i.e.</em>, under high participation and honest <span class="math">3/4</span>-supermajority (Fig. 6, Alg. 4). In particular, validators can now confirm honest proposals within the same slot, under optimistic conditions. The <span class="math">\\kappa</span>-deep confirmation rule (Alg. 6, l. 29) (now called <em>standard</em> confirmation rule), still applies and guarantees security when optimistic conditions don’t hold.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fast Confirmation Phase. Slots are now <span class="math">4\\Delta</span> rounds, with the insertion of phase Fast-Confirm at round <span class="math">4\\Delta t+2\\Delta</span> (Fig. 6, Alg. 4). In Fast-Confirm, a validator id first merges its buffer into its bvtree <span class="math">\\mathcal{T}</span> (Alg. 4, l. 8). It then marks a block <span class="math">B</span> as fast confirmed if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Votes}(\\mathcal{T},B,t)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq n(\\frac{3}{4}+\\frac{\\epsilon}{2})\\mathsf{thr}_{\\tau}<span class="math"> for some </span>\\epsilon>0<span class="math"> that can be made arbitrarily small as </span>n\\to\\infty<span class="math">, and updates </span>\\mathsf{ch}_{\\mathrm{fast}}^{\\mathsf{id}}$ to the highest fast</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Francesco D'Amato, Joachim Neu, Ertem Nusret Tas, and David Tse</p>

    <p class="text-gray-300">|  Algorithm 4 Goldfish executed by validator id, modified (blue) to use (optimistic) fast and standard confirmation (cf. Alg. 2). See Alg. 3 for VOTES.  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  1: Same initialization and housekeeping as Alg. 2  |   |</p>

    <p class="text-gray-300">|  2: for t = 1, 2, ... do ▷ Slots  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3: at 4Δt do</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ PROPOSE phase</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  4: Same as PROPOSE phase in Alg. 2 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5: at 4Δt + Δ do</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ VOTE phase</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  6: Same as VOTE phase in Alg. 2 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7: at 4Δt + 2Δ do</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ FAST-CONFIRM phase</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9: chidfast ← arg maxB∈T:</td>

            <td class="px-3 py-2 border-b border-gray-700">VOTES(T, B, t)</td>

            <td class="px-3 py-2 border-b border-gray-700">≥n(3/4 + t/2)thrv</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10: at 4Δt + 3Δ do</td>

            <td class="px-3 py-2 border-b border-gray-700">▷ CONFIRM phase</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">11: T ← MERGE(T, B)</td>

            <td class="px-3 py-2 border-b border-gray-700">▷ Merge buffer and bvtree</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">12: B ← GHOST-EPH(T, t)</td>

            <td class="px-3 py-2 border-b border-gray-700">▷ Canonical GHOST-Eph chain</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">13: chid← arg maxch∈{chidfast, B</td>

            <td class="px-3 py-2 border-b border-gray-700">n}</td>

            <td class="px-3 py-2 border-b border-gray-700">ch</td>

            <td class="px-3 py-2 border-b border-gray-700">▷ Output Goldfish ledger</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">confirmed block (Alg. 4, l. 9). In CONFIRM (Alg. 4, l. 13), validator id outputs the higher of  <span class="math">\\mathsf{ch}_{\\mathrm{fast}}^{\\mathrm{id}}</span>  and the standard-confirmed  <span class="math">\\kappa</span> -deep prefix  <span class="math">B^{\\lceil \\kappa \\rceil}</span> . For simplicity, we omit a mechanism to avoid ledger 'roll back' (to ensure  <span class="math">\\forall \\mathsf{id}, t&#x27; \\geq t</span> :  <span class="math">\\mathsf{ch}_t^{\\mathrm{id}} \\preceq \\mathsf{ch}_{t&#x27;}^{\\mathrm{id}}</span> ).</p>

    <p class="text-gray-300">Intuitively, the extra FAST-CONFIRM phase guarantees that when an honest validator fast confirms a block  <span class="math">B</span>  in slot  <span class="math">t</span> , all honest awake validators see the causative votes by the time their bvtrees are last updated in  <span class="math">t</span> . The subtree rooted at  <span class="math">B</span>  will be heaviest in all steps of GHOST-Eph fork-choice for all honest voters and forever (Thm. 4), which implies that fast confirmations are safe (Thm. 5). Security of Goldfish with fast confirmations is proven in App. C.</p>

    <p class="text-gray-300">Joining Procedure. Once a validator stops being asleep, it is dreamy until the next CONFIRM phase (Alg. 4, l. 11), when it turns awake and resumes execution.</p>

    <p class="text-gray-300">Due to space constraints, we show the security proof for 'basic' Goldfish (Sec. 3.1) here. The proofs for Goldfish with fast confirmations (Sec. 3.2), and for Goldfish when used as an underlay chain composed with an overlay finality/accountability gadget (as in Fig. 1), are provided in Apps. C and D, respectively.</p>

    <p class="text-gray-300">In the subsequent analysis, a validator id is eligible to vote at slot  <span class="math">t</span>  if its ticket  <span class="math">(\\mathrm{id}, t)</span>  is winning for the lottery  <span class="math">(\\mathrm{vote}, \\mathrm{thr}_{\\mathrm{v}})</span> . Recall that awake honest validators consider the proposal with lowest precedence received by  <span class="math">3\\Delta t + \\Delta</span>  from the leader of slot  <span class="math">t</span>  (Alg. 2, l. 16). We use blocks and the chains they induce via the parent relation interchangeably. A block  <span class="math">B_{1}</span>  is a descendant (resp., ancestor) of block  <span class="math">B_{2}</span>  iff the underlying chains satisfy  <span class="math">B_{2} \\preceq B_{1}</span>  (resp.,  <span class="math">B_{1} \\preceq B_{2}</span> ).</p>

    <p class="text-gray-300">Let  <span class="math">A_r</span>  and  <span class="math">H_r</span>  denote the number of adversary and honest validators awake at round  <span class="math">r</span> , respectively. Our theorems hold for  <span class="math">(\\frac{1}{2}, 3\\Delta)</span> -compliant executions (Def. 2) that satisfy the following relations on  <span class="math">A_r</span>  and  <span class="math">H_r</span> : (i) in the absence of key-evolving cryptographic primitives, the adversary is mildly adaptive and  <span class="math">\\forall r: \\frac{A_r}{A_r + H_{r-3\\Delta}} &amp;lt; \\frac{1}{2} - \\epsilon</span> , and (ii) with key-evolving primitives,  <span class="math">\\forall r: \\frac{A_r}{A_r + H_r} &amp;lt; \\frac{1}{2} - \\epsilon</span> .</p>

    <p class="text-gray-300">Theorem 1. Suppose a  <span class="math">(\\frac{1}{2},3\\Delta)</span> -compliant execution of Goldfish in the syn-</p>

    <p class="text-gray-300">chronous sleepy network model of Sec. 2, and validator <span class="math">\\mathsf{id}</span> with proposal <span class="math">P^{<em>}</span> is recognized as the leader of a slot <span class="math">t</span> by all awake honest validators at round <span class="math">3\\Delta t+\\Delta</span> (Alg. 2, l. 16). Then, w.o.p., <span class="math">P^{</em>}.B\\preceq B</span> for any <span class="math">B</span> identified in Alg. 2, ll. 8, 22, 28 by any awake honest validator in any round <span class="math">r\\geq 3\\Delta t+2\\Delta</span>.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Theorem 2 (Security).</h6>

    <p class="text-gray-300">Suppose a <span class="math">(\\frac{1}{2},3\\Delta)</span>-compliant execution of Goldfish in the synchronous sleepy network model. Then, w.o.p., Goldfish is secure with transaction confirmation time <span class="math">T_{\\mathrm{conf}}=2\\kappa+2</span> slots.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Theorem 3 (Reorg resilience).</h6>

    <p class="text-gray-300">Suppose a <span class="math">(\\frac{1}{2},3\\Delta)</span>-compliant execution of Goldfish in the synchronous sleepy network model, and validator <span class="math">\\mathsf{id}</span> with proposal <span class="math">P^{<em>}</span> is recognized as the leader of a slot <span class="math">t</span> by all awake honest validators at round <span class="math">3\\Delta t+\\Delta</span> (Alg. 2, l. 16). Then, w.o.p., <span class="math">\\exists r^{\\prime}\\colon\\forall r\\geq r^{\\prime}\\colon\\forall\\mathsf{id}\\colon\\ P^{</em>}.B\\preceq\\mathsf{ch}_{r}^{\\mathsf{id}}</span>, where <span class="math">\\mathsf{ch}_{r}^{\\mathsf{id}}</span> denotes Goldfish’s ledger at validator <span class="math">\\mathsf{id}</span> and round <span class="math">r</span>. In particular, <span class="math">r^{\\prime}=3\\Delta(t+\\kappa)+2\\Delta</span> satisfies the above.</p>

    <p class="text-gray-300">Due to space constraints, a formal definition of <span class="math">(\\gamma,\\tau)</span>-compliant executions and formal proofs of Thms. 1, 2 and 3 and the subsequent lemmas are given in App. B. In the rest of this section, we focus on the intuition. Proof of Thm. 1 in follows from Lems. 1, 2 and 3 below. The structure of this argument is inductive: Lem. 1 shows that in compliant executions, honest voters outnumber adversary voters; and every long interval of slots contains at least one slot in which all honest validators recognize the same honest validator as the slot leader. Lem. 2 shows that in a slot <span class="math">t</span> with such recognized honest leader, all honest voters vote for the leader’s proposal. Finally, Lem. 3 shows that if in slot <span class="math">t</span>, all honest voters have voted for a descendant of a certain block, then in slot <span class="math">t+1</span> all honest voters will vote for a descendant of that block. This concludes the induction and Thm. 1 follows. Proofs of Thms. 2 and 3 follow readily from Thm. 1 and Lem. 1 below.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Suppose the Goldfish execution is <span class="math">(\\frac{1}{2},3\\Delta)</span>-compliant. Then, w.o.p., for every slot <span class="math">t</span>, adversary validators at round <span class="math">3\\Delta(t+1)+\\Delta</span> eligible to vote at slot <span class="math">t</span> are less than honest validators awake at round <span class="math">3\\Delta t+\\Delta</span> and eligible to vote at slot <span class="math">t</span>. Also w.o.p., all slot intervals of length <span class="math">\\kappa</span> have at least one slot <span class="math">t</span> where an honest validator is recognized as the slot <span class="math">t</span> leader by all awake honest validators at round <span class="math">3\\Delta t+\\Delta</span>.</p>

    <p class="text-gray-300">Lem. 1’s proof uses correctness, uniqueness and pseudorandomness of VRF-based lotteries along with Chernoff bounds.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">Suppose an execution of Goldfish in the synchronous sleepy network model, and validator <span class="math">\\mathsf{id}^{<em>}</span> with proposal <span class="math">P^{</em>}</span> is recognized as leader of a slot <span class="math">t</span> by all awake honest validators at round <span class="math">3\\Delta t+\\Delta</span> (Alg. 2, l. 16). Then, all honest validators awake at round <span class="math">3\\Delta t+\\Delta</span> and eligible to vote at <span class="math">t</span> vote for <span class="math">P^{*}.B</span> at <span class="math">t</span>.</p>

    <p class="text-gray-300">By message buffering and honest <span class="math">\\mathsf{id}^{<em>}</span>, <span class="math">P^{</em>}</span>.<span class="math">\\mathcal{T}</span> is a superset of the bvtrees of all honest validators awake at round <span class="math">3\\Delta t+\\Delta</span> and eligible to vote at slot <span class="math">t</span>. Hence, upon merging <span class="math">P^{<em>}</span>.<span class="math">\\mathcal{T}</span> into their bvtrees (Alg. 2, l. 19) at round <span class="math">3\\Delta t+\\Delta</span>, all of these validators vote for the GHOST-Eph tip in <span class="math">P^{</em>}</span>.<span class="math">\\mathcal{T}</span>, i.e., for <span class="math">P^{*}</span>.<span class="math">B</span>.</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Lemma 3</h6>

    <p class="text-gray-300">Suppose a <span class="math">(\\frac{1}{2},3\\Delta)</span>-compliant execution of Goldfish in the synchronous sleepy network model. Consider a slot <span class="math">t</span> where all honest validators awake at round <span class="math">3\\Delta t+\\Delta</span> and eligible to vote at slot <span class="math">t</span>, vote for a descendant of <span class="math">B</span>. Then, w.o.p., all honest validators awake at round <span class="math">3\\Delta(t+1)+\\Delta</span> and eligible to vote at slot <span class="math">t+1</span>, vote for a descendant of <span class="math">B</span>.</p>

    <p class="text-gray-300">By vote expiry, the eligible honest validators awake at round <span class="math">3\\Delta(t+1)+\\Delta</span> consider only the slot <span class="math">t</span> votes in GHOST-Eph fork-choice (Alg. 2, l. 22). Due to honest majority, the subtree rooted at <span class="math">B</span> is heaviest in all steps of GHOST-Eph fork-choice. Thus, all honest voters vote for a descendant of <span class="math">B</span>, if all eligible honest validators awake at round <span class="math">3\\Delta t+\\Delta</span> voted for a descendant of <span class="math">B</span>.</p>

    <h2 id="sec-21" class="text-2xl font-bold">5 Implementation and Experiments</h2>

    <p class="text-gray-300">We discuss implementation aspects of Goldfish and study its behavior under dynamic participation. We focus on communication-efficient implementation of proposals and message buffering, and on the interplay between the block production lottery threshold <span class="math">\\mathsf{thr}_{\\mathrm{b}}</span>, communication load, and behavior under low participation. We have implemented a prototype of Goldfish in Rust, with BLAKE3 hashes <em>[64]</em> and BLS signatures <em>[8]</em> over the BLS12-381 curve <em>[10]</em> for signatures and VRFs. The network was simulated with delay <span class="math">\\Delta=4\\,\\mathrm{s}</span>.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">Proposal Size and Wire Format</h3>

    <p class="text-gray-300">In the Goldfish variant of Sec. 3.1, for ease of exposition, proposals include the proposer’s entire bvtree <span class="math">\\mathcal{T}^{\\prime}</span> (Alg. 2, l. 7). This raises concerns about the resulting communication load. Proposal messages would grow over time with the number of blocks, and could be inflated by <em>equivocation spamming</em> (<em>i.e.</em>, adversary uses one winning lottery ticket to create many equivocating blocks or votes, cf. <em>[42, 55]</em>). The following implementation details resolve these concerns. It suffices for a proposal to only include votes from the latest Vote phase, as older votes are already expired anyway. Another tweak is <em>equivocation discounting</em>, <em>i.e.</em>, not counting votes during fork-choice from validators who have sent votes for two or more different blocks during the latest Vote phase. We discuss equivocation discounting in detail, and show it to not compromise security, in App. E. As <em>any two</em> equivocating votes suffice as evidence for an honest validator to discount all votes of an equivocating adversary, the above two measures mean that every proposal needs to include at most two votes per validator eligible to vote in the previous slot.</p>

    <p class="text-gray-300">Notice also that it suffices for proposals to include <em>references</em> (hashes) to blocks and votes. In fact, an honest proposer’s role in message buffering is only to point validators to messages (<em>which they already have in their buffer</em> because at least the honest proposer would have relayed them) that they should merge into their bvtree. Finally, only blocks with nonzero fork-choice weight need to be referenced, because blocks with zero weight cannot possibly alter fork-choice regarding the proposer’s block. Nonzero weight blocks are either referenced by votes, or by a nonzero weight child block. *Thus, it suffices for proposals to only</p>

    <p class="text-gray-300">Goldfish: No More Attacks on Ethereum?!</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2. Ledger growth rate and average broadcast load of Goldfish as a function of block production lottery threshold, for experiments  <span class="math">(\\rightarrow \\rightarrow \\rightarrow \\rightarrow)</span>  with  <span class="math">n = 1000</span> ,  <span class="math">\\mathrm{thr_v} = 0.1</span> ,  <span class="math">\\Delta = 4\\mathrm{s}</span> , under full honest participation. For the block production lottery, we expect the number of proposals per slot to be binomially distributed with mean  <span class="math">n</span>  thrb. The measurements fit the predictions for the probability of zero proposals in a given slot  <span class="math">(1 - e^{-n\\mathrm{thrb}})</span> , ——, and that the communication load is affine  <span class="math">(5723\\cdot \\mathrm{thrb} + 4.472</span>  with coefficients to four digit accuracy, —) with the constant term accounting for votes.</p>

    <p class="text-gray-300">reference at most two votes per validator eligible to vote in the previous slot.</p>

    <p class="text-gray-300">Concretely, if Goldfish is used among  <span class="math">n = 1,024</span>  validators without voter subsampling, so  <span class="math">\\mathsf{thr}_{\\mathrm{v}} = 1</span> , with 32 Byte hashes, then even worst-case a proposal is only of 64 kByte plus one block. This is representative for a deployment in Ethereum, where votes get aggregated by 1,024 aggregators per slot, Goldfish's fork-choice would operate on aggregates, and at most two aggregates per aggregator need to be referenced in a proposal. Comparing 64 kByte to the current block size of 80 kByte, message buffering seems feasible in terms of network load.</p>

    <p class="text-gray-300">Garbage Collection. Proposals are discarded after their slot's VOTE phase. Vote expiry allows to discard votes within two slots. Blocks (including 'in limbo') are discarded once inconsistent with confirmed blocks (i.e., after at most  <span class="math">\\kappa</span>  slots).</p>

    <p class="text-gray-300">Block Production Lottery Threshold. Sec. 4 shows how to tune the vote lottery threshold  <span class="math">\\mathsf{thr}_{\\mathrm{v}}</span>  so that, w.o.p., all voter committees over the execution horizon have an honest majority. Given a number  <span class="math">n</span>  of validators and a threshold  <span class="math">\\mathsf{thr}_{\\mathrm{v}}</span> , the size of a proposal and the communication load resulting from votes are close to constant. The block production lottery threshold  <span class="math">\\mathsf{thr}_{\\mathrm{b}}</span>  is the remaining parameter affecting the overall broadcast load through the expected number of proposals per slot  <span class="math">n</span> <span class="math">\\mathsf{thr}_{\\mathrm{b}}</span>  (Fig. 2). For low  <span class="math">\\mathsf{thr}_{\\mathrm{b}} &amp;lt; 1/n</span> , communication load is low but ledger growth is impaired because many slots have no proposal. For high  <span class="math">\\mathsf{thr}_{\\mathrm{b}} &amp;gt; 1/n</span> , most slots have more than one proposal, leading to communication overhead but also close-to-optimal ledger growth. For a reasonable tradeoff in the non-degraded common case of near-full participation, we tune  <span class="math">\\mathsf{thr}_{\\mathrm{b}} = 3/n</span> .</p>

    <p class="text-gray-300">Behavior under Dynamic Participation. Based on Fig. 2, we expect a confirmation performance degradation under low participation if  <span class="math">\\mathsf{thr}_{\\mathrm{b}} = 3 / n</span> . (If good performance is to be ensured even under very low participation  <span class="math">n_0 \\ll n</span> , tune  <span class="math">\\mathsf{thr}_{\\mathrm{b}}</span>  to  <span class="math">n_0</span>  rather than to  <span class="math">n</span> .) To study the impact of dynamic participation on Goldfish with  <span class="math">\\mathsf{thr}_{\\mathrm{b}} = 3 / n</span> , we run it (Fig. 3) in four different dynamic participation environments inspired by [51]:  <span class="math">\\bullet</span>  Stable participation: Starting from  <span class="math">50\\%</span> , randomly increase or decrease participation by  <span class="math">3\\%</span>  per  <span class="math">\\Delta</span>  (unless this would exceed  <span class="math">[10\\%, 90\\%]</span> ).  <span class="math">\\bullet</span>  Unstable participation: Select a participation level uni</p>

    <p class="text-gray-300">Francesco D'Amato, Joachim Neu, Ertem Nusret Tas, and David Tse</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 3. Ledger length / age of most recently confirmed block under fast (——) / slow (——) confirmation, and resulting broadcast load (——), for Goldfish with  <span class="math">n = 1000</span> ,  <span class="math">\\mathrm{thr_v} = 0.1</span> ,  <span class="math">\\Delta = 4\\mathrm{s}</span> ,  <span class="math">\\mathrm{thr_b} = 3 / n</span> ,  <span class="math">\\kappa = 10</span> , block size  <span class="math">80\\mathrm{kByte}</span> , different environments of dynamic participation (——). When participation is above the fast-confirmation threshold of approx.  <span class="math">3n / 4</span>  (——), transactions are confirmed swiftly (4Δ, ——,  <span class="math">\\bullet</span> ,  <span class="math">\\bullet</span> ), otherwise fast confirmation stalls. When participation is volatile (cf. 600s to 950s,  <span class="math">\\bullet</span> ), many honest validators are dreamy (——, cf. Sec. 3.1). Then, or when participation is steady but at a low level (cf. 1400s to 1700s,  <span class="math">\\bullet</span> ), effective participation (by honest validators who are neither asleep nor dreamy) is low. Slow confirmation (4Δκ base latency, ——) takes place throughout, but since  <span class="math">\\mathrm{thr_b} = 3 / n</span> , slow confirmation degrades (cf. Fig. 2) when effective participation is low (cf. slots with no proposal around 650s or 1600s, ——, lead to latency spikes, —). Communication load is modest (——).</p>

    <p class="text-gray-300">formly at random in  <span class="math">[10\\%, 90\\%]</span>  per  <span class="math">\\Delta</span> . High participation: Reset participation to  <span class="math">80\\%</span> , randomly increase or decrease by  <span class="math">3\\%</span>  per  <span class="math">\\Delta</span>  (staying in  <span class="math">[70\\%, 90\\%]</span> ). Low participation: Reset participation to  <span class="math">20\\%</span> , randomly increase or decrease by  <span class="math">3\\%</span>  per  <span class="math">\\Delta</span>  (staying in  <span class="math">[10\\%, 30\\%]</span> ). Once the participation level was drawn according to this schedule, from instant to instant the environment selects a random set of asleep (awake) validators to wake up (put to sleep), respectively, to meet the participation levels. A performance-based comparison of LMD GHOST and Goldfish is apples-to-oranges, as LMD GHOST is not secure under dynamic participation, while Goldfish is. That said, Goldfish has a slightly lower block production rate due to extra phases (cf. Figs. 4, 5 and 6), at otherwise comparable confirmation latency and communication load. The choice of leader election mechanism, i.e., VRF-based vs. a randomness beacon like Ethereum's RANDAO (cf. App. F.2), also affects performance of both protocols equally.</p>

    <p class="text-gray-300">Goldfish: No More Attacks on Ethereum?!</p>

    <p class="text-gray-300">We thank Aditya Asgaonkar, Carl Beekhuizen, Vitalik Buterin, Justin Drake, Dankrad Feist, Sreeram Kannan, Georgios Konstantopoulos, Barnabé Monnot, Ling Ren, Dan Robinson, Danny Ryan, Caspar Schwarz-Schilling, Alberto Sonnino, and Fan Zhang for fruitful discussions. The work of JN was conducted in part while at Paradigm. JN, ENT and DT are supported by a gift from the Ethereum Foundation. JN is supported by the Protocol Labs PhD Fellowship and the Reed-Hodgson Stanford Graduate Fellowship. ENT is supported by the Stanford Center for Blockchain Research.</p>

    <h2 id="sec-23" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Maximal extractable value (MEV) (2023), https://ethereum.org/en/developers/docs/mev/</li>

      <li>[2] Abraham, I., Gueta, G., Malkhi, D., Alvisi, L., Kotla, R., Martin, J.P.: Revisiting fast practical Byzantine fault tolerance. arXiv:1712.01367v1 [cs.DC] (2017), http://arxiv.org/abs/1712.01367v1</li>

      <li>[3] Abraham, I., Malkhi, D., Nayak, K., Ren, L., Yin, M.: Sync HotStuff: Simple and practical synchronous state machine replication. In: SP. pp. 106–118. IEEE (2020)</li>

      <li>[4] Badertscher, C., Gazi, P., Kiayias, A., Russell, A., Zikas, V.: Ouroboros Genesis: Composable proof-of-stake blockchains with dynamic availability. In: CCS. pp. 913–930. ACM (2018)</li>

      <li>[5] Bagaria, V.K., Kannan, S., Tse, D., Fanti, G., Viswanath, P.: Prism: Deconstructing the blockchain to approach physical limits. In: CCS. pp. 585–602. ACM (2019)</li>

      <li>[6] Beekhuizen, C., Schwarz-Schilling, C., D’Amato, F.: Change fork choice rule to mitigate balancing and reorging attacks (2021), https://ethresear.ch/t/change-fork-choice-rule-to-mitigate-balancing-and-reorging-attacks/11127</li>

      <li>[7] Bellare, M., Miner, S.K.: A forward-secure digital signature scheme. In: CRYPTO. LNCS, vol. 1666, pp. 431–448. Springer (1999)</li>

      <li>[8] Boneh, D., Lynn, B., Shacham, H.: Short signatures from the Weil pairing. J. Cryptol. 17(4), 297–319 (2004)</li>

      <li>[9] Boneh, D., Shoup, V.: A graduate course in applied cryptography (2015), http://cryptobook.us/, version 0.6, posted Jan. 14, 2023</li>

      <li>[10] Bowe, S.: BLS12-381: New zk-SNARK elliptic curve construction (2017), https://electriccoin.co/blog/new-snark-curve/</li>

      <li>[11] Buchman, E., Kwon, J., Milosevic, Z.: The latest gossip on BFT consensus. arXiv:1807.04938v3 [cs.DC] (2018), http://arxiv.org/abs/1807.04938v3</li>

      <li>[12] Buterin, V.: A CBC Casper tutorial (2018), https://vitalik.eth.limo/general/2018/12/05/cbc_casper.html</li>

      <li>[13] Buterin, V.: Proposal for mitigation against balancing attacks to LMD GHOST (2020), https://notes.ethereum.org/@vbuterin/lmd_ghost_mitigation</li>

      <li>[14] Buterin, V., Griffith, V.: Casper the friendly finality gadget. arXiv:1710.09437v4 [cs.CR] (2017), http://arxiv.org/abs/1710.09437v4</li>

      <li>[15] Buterin, V., Hernandez, D., Kamphefner, T., Pham, K., Qiao, Z., Ryan, D., Sin, J., Wang, Y., Zhang, Y.X.: Combining GHOST and Casper. arXiv:2003.03052v3 [cs.CR] (2020), http://arxiv.org/abs/2003.03052v3</li>

      <li>[16] Buterin, V., Stewart, A.: Beacon chain Casper mini-spec (comments #17, #19) (2018), https://ethresear.ch/t/beacon-chain-casper-mini-spec/2760/17</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[17] Carlsten, M., Kalodner, H.A., Weinberg, S.M., Narayanan, A.: On the instability of Bitcoin without the block reward. In: CCS. pp. 154–167. ACM (2016)</li>

      <li>[18] Castro, M., Liskov, B.: Practical Byzantine fault tolerance. In: OSDI. pp. 173–186. USENIX Association (1999)</li>

      <li>[19] Chan, B.Y., Shi, E.: Streamlet: Textbook streamlined blockchains. In: AFT. pp. 1–11. ACM (2020)</li>

      <li>[20] Chen, J., Micali, S.: Algorand: A secure and efficient distributed ledger. Theor. Comput. Sci. 777, 155–183 (2019)</li>

      <li>[21] Daian, P., Pass, R., Shi, E.: Snow White: Robustly reconfigurable consensus and applications to provably secure proof of stake. In: Financial Cryptography. LNCS, vol. 11598, pp. 23–41. Springer (2019)</li>

      <li>[22] Daian, P., Goldfeder, S., Kell, T., Li, Y., Zhao, X., Bentov, I., Breidenbach, L., Juels, A.: Flash Boys 2.0: Frontrunning in decentralized exchanges, miner extractable value, and consensus instability. In: SP. pp. 910–927. IEEE (2020)</li>

      <li>[23] D’Amato, F., Neu, J., Tas, E.N., Tse, D.: Goldfish: No more attacks on Ethereum?! Cryptology ePrint Archive, Paper 2022/1171 (2022), https://eprint.iacr.org/2022/1171</li>

      <li>[24] D’Amato, F., Zanolini, L.: Recent latest message driven GHOST: Balancing dynamic availability with asynchrony resilience. Cryptology ePrint Archive, Paper 2023/279 (2023), https://eprint.iacr.org/2023/279</li>

      <li>[25] D’Amato, F., Zanolini, L.: A simple single slot finality protocol for Ethereum. Cryptology ePrint Archive, Paper 2023/280 (2023), https://eprint.iacr.org/2023/280</li>

      <li>[26] Das, N., Tsao, T., Loon, P.V., Potuz, Kirkham, K., He, J.: Post-mortem report: Ethereum mainnet finality (05/11/2023) (2023), https://offchain.medium.com/post-mortem-report-ethereum-mainnet-finality-05-11-2023-95e271dfd8b2</li>

      <li>[27] David, B., Gazi, P., Kiayias, A., Russell, A.: Ouroboros Praos: An adaptively-secure, semi-synchronous proof-of-stake blockchain. In: EUROCRYPT (2). LNCS, vol. 10821, pp. 66–98. Springer (2018)</li>

      <li>[28] Dodis, Y., Yampolskiy, A.: A verifiable random function with short proofs and keys. In: Public Key Cryptography. LNCS, vol. 3386, pp. 416–431. Springer (2005)</li>

      <li>[29] Duan, S., Zhang, H.: Foundations of dynamic BFT. In: SP. pp. 1317–1334. IEEE (2022)</li>

      <li>[30] Eyal, I., Sirer, E.G.: Majority is not enough: Bitcoin mining is vulnerable. Commun. ACM 61(7), 95–102 (2018)</li>

      <li>[31] Fitzi, M., Gaži, P., Kiayias, A., Russell, A.: Parallel Chains: Improving throughput and latency of blockchain protocols via parallel composition. Cryptology ePrint Archive, Paper 2018/1119 (2018), https://eprint.iacr.org/2018/1119</li>

      <li>[32] Garay, J.A., Kiayias, A., Leonardos, N.: The Bitcoin backbone protocol: Analysis and applications. In: EUROCRYPT (2). LNCS, vol. 9057, pp. 281–310. Springer (2015)</li>

      <li>[33] Gilad, Y., Hemo, R., Micali, S., Vlachos, G., Zeldovich, N.: Algorand: Scaling Byzantine agreements for cryptocurrencies. In: SOSP. pp. 51–68. ACM (2017)</li>

      <li>[34] Gilbert, S., Lynch, N.A.: Brewer’s conjecture and the feasibility of consistent, available, partition-tolerant web services. SIGACT News 33(2), 51–59 (2002)</li>

      <li>[35] Goyal, V., Li, H., Raizes, J.: Instant block confirmation in the sleepy model. In: Financial Cryptography (2). LNCS, vol. 12675, pp. 65–83. Springer (2021)</li>

      <li>[36] Itkis, G., Reyzin, L.: Forward-secure signatures with optimal signing and verifying. In: CRYPTO. LNCS, vol. 2139, pp. 332–354. Springer (2001)</li>

    </ul>

    <p class="text-gray-300">Goldfish: No More Attacks on Ethereum?!</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[37] Kane, D., Fackler, A., Gągol, A., Straszak, D.: Highway: Efficient consensus with flexible finality. arXiv:2101.02159v2 [cs.DC] (2021), http://arxiv.org/abs/2101.02159v2</li>

      <li>[38] Katz, J., Lindell, Y.: Introduction to Modern Cryptography, Second Edition. CRC Press (2014)</li>

      <li>[39] Khanchandani, P., Wattenhofer, R.: Brief announcement: Byzantine agreement with unknown participants and failures. In: PODC. pp. 178–180. ACM (2020)</li>

      <li>[40] Khanchandani, P., Wattenhofer, R.: Byzantine agreement with unknown participants and failures. In: IPDPS. pp. 952–961. IEEE (2021)</li>

      <li>[41] Kiayias, A., Russell, A., David, B., Oliynykov, R.: Ouroboros: A provably secure proof-of-stake blockchain protocol. In: CRYPTO (1). LNCS, vol. 10401, pp. 357–388. Springer (2017)</li>

      <li>[42] Kiffer, L., Neu, J., Sridhar, S., Zohar, A., Tse, D.: Security of Nakamoto consensus under congestion. Cryptology ePrint Archive, Paper 2023/381 (2023), https://eprint.iacr.org/2023/381</li>

      <li>[43] Kotla, R., Alvisi, L., Dahlin, M., Clement, A., Wong, E.L.: Zyzzyva: Speculative Byzantine fault tolerance. ACM Trans. Comput. Syst. 27(4), 7:1–7:39 (2009)</li>

      <li>[44] Lewis-Pye, A., Roughgarden, T.: Byzantine generals in the permissionless setting. In: FC (1). LNCS, vol. 13950, pp. 21–37. Springer (2023)</li>

      <li>[45] Liao, K., Katz, J.: Incentivizing blockchain forks via whale transactions. In: Financial Cryptography Workshops. LNCS, vol. 10323, pp. 264–279. Springer (2017)</li>

      <li>[46] Losa, G., Gafni, E.: Consensus in the unknown-participation message-adversary model. arXiv:2301.04817v2 [cs.DC] (2023), http://arxiv.org/abs/2301.04817v2</li>

      <li>[47] Malkhi, D., Momose, A., Ren, L.: Byzantine consensus under fully fluctuating participation. Cryptology ePrint Archive, Paper 2022/1448, Version 20221024:011919 (2022), https://eprint.iacr.org/archive/2022/1448/20221024:011919</li>

      <li>[48] Malkhi, D., Momose, A., Ren, L.: Instant finality in Byzantine generals with unknown and dynamic participation (2022), https://blog.chain.link/instant-finality-in-byzantine-generals-with-unknown-and-dynamic-participation/</li>

      <li>[49] Malkhi, D., Momose, A., Ren, L.: Towards practical sleepy BFT. In: CCS. pp. 490–503. ACM (2023)</li>

      <li>[50] Micali, S., Rabin, M.O., Vadhan, S.P.: Verifiable random functions. In: FOCS. pp. 120–130. IEEE Computer Society (1999)</li>

      <li>[51] Momose, A., Ren, L.: Constant latency in sleepy consensus. In: CCS. pp. 2295–2308. ACM (2022)</li>

      <li>[52] Nakamoto, S.: Bitcoin: A peer-to-peer electronic cash system. https://bitcoin.org/bitcoin.pdf (2008)</li>

      <li>[53] Nakamura, R.: Analysis of bouncing attack on FFG (2019), https://ethresear.ch/t/analysis-of-bouncing-attack-on-ffg/6113</li>

      <li>[54] Nakamura, R.: Prevention of bouncing attack on FFG (2019), https://ethresear.ch/t/prevention-of-bouncing-attack-on-ffg/6114</li>

      <li>[55] Neu, J., Sridhar, S., Yang, L., Tse, D., Alizadeh, M.: Longest chain consensus under bandwidth constraint. In: AFT. pp. 126–147. ACM (2022)</li>

      <li>[56] Neu, J., Tas, E.N., Tse, D.: Short paper: Accountable safety implies finality. Financial Cryptography and Data Security 2024, https://eprint.iacr.org/2023/1301</li>

      <li>[57] Neu, J., Tas, E.N., Tse, D.: A balancing attack on Gasper, the current candidate for Eth2’s beacon chain (2020), https://ethresear.ch/t/a-balancing-attack-on-gasper-the-current-candidate-for-eth2s-beacon-chain/8079</li>

      <li>[58] Neu, J., Tas, E.N., Tse, D.: Snap-and-Chat protocols: System aspects. arXiv:2010.10447v1 [cs.CR] (2020), http://arxiv.org/abs/2010.10447v1</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[59] Neu, J., Tas, E.N., Tse, D.: Attacking Gasper without adversarial network delay (2021), https://ethresear.ch/t/attacking-gasper-without-adversarial-network-delay/10187</li>

      <li>[60] Neu, J., Tas, E.N., Tse, D.: Ebb-and-Flow protocols: A resolution of the availability-finality dilemma. In: SP. pp. 446–465. IEEE (2021)</li>

      <li>[61] Neu, J., Tas, E.N., Tse, D.: The availability-accountability dilemma and its resolution via accountability gadgets. In: Financial Cryptography. LNCS, vol. 13411, pp. 541–559. Springer (2022)</li>

      <li>[62] Neu, J., Tas, E.N., Tse, D.: Two more attacks on proof-of-stake GHOST/Ethereum. In: Proceedings of the 2022 ACM Workshop on Developments in Consensus. ConsensusDay ’22, ACM (2022). https://doi.org/10.1145/3560829.3563560</li>

      <li>[63] Nijkerk, M.: Ethereum briefly stopped finalizing transactions. what happened? (2023), https://www.coindesk.com/tech/2023/05/17/ethereums-loss-of-finality-what-happened/</li>

      <li>[64] O’Connor, J., Aumasson, J.P., Neves, S., Wilcox-O’Hearn, Z.: BLAKE3 (2020), https://github.com/BLAKE3-team/BLAKE3-specs/blob/ea51a3ac997288bf690ee82ac9cfc8b3e0e60f2a/blake3.pdf</li>

      <li>[65] Pass, R., Shi, E.: The sleepy model of consensus. In: ASIACRYPT (2). LNCS, vol. 10625, pp. 380–409. Springer (2017)</li>

      <li>[66] Pass, R., Shi, E.: Thunderella: Blockchains with optimistic instant confirmation. In: EUROCRYPT (2). LNCS, vol. 10821, pp. 3–33. Springer (2018)</li>

      <li>[67] Pu, Y., Alvisi, L., Eyal, I.: Safe permissionless consensus. In: DISC. LIPIcs, vol. 246, pp. 33:1–33:15. Schloss Dagstuhl - Leibniz-Zentrum für Informatik (2022)</li>

      <li>[68] Pu, Y., Farahbakhsh, A., Alvisi, L., Eyal, I.: Gorilla: Safe permissionless byzantine consensus. In: DISC. LIPIcs, vol. 281, pp. 31:1–31:16. Schloss Dagstuhl - Leibniz-Zentrum für Informatik (2023)</li>

      <li>[69] Sankagiri, S., Wang, X., Kannan, S., Viswanath, P.: Blockchain CAP theorem allows user-dependent adaptivity and finality. In: Financial Cryptography (2). LNCS, vol. 12675, pp. 84–103. Springer (2021)</li>

      <li>[70] Schwarz-Schilling, C., Neu, J., Monnot, B., Asgaonkar, A., Tas, E.N., Tse, D.: Three attacks on proof-of-stake Ethereum. In: Financial Cryptography. LNCS, vol. 13411, pp. 560–576. Springer (2022)</li>

      <li>[71] Sheng, P., Wang, G., Nayak, K., Kannan, S., Viswanath, P.: BFT protocol forensics. In: CCS. pp. 1722–1743. ACM (2021)</li>

      <li>[72] Sheng, P., Wang, G., Nayak, K., Kannan, S., Viswanath, P.: Player-replaceability and forensic support are two sides of the same (crypto) coin. In: FC (1). LNCS, vol. 13950, pp. 56–74. Springer (2023)</li>

      <li>[73] Sompolinsky, Y., Zohar, A.: Secure high-rate transaction processing in Bitcoin. In: Financial Cryptography. LNCS, vol. 8975, pp. 507–527. Springer (2015)</li>

      <li>[74] Yin, M., Malkhi, D., Reiter, M.K., Golan-Gueta, G., Abraham, I.: Hotstuff: BFT consensus with linearity and responsiveness. In: PODC. pp. 347–356. ACM (2019)</li>

    </ul>

    <h2 id="sec-24" class="text-2xl font-bold">Appendix 0.A Protocol Slot Structures</h2>

    <p class="text-gray-300">The slot structure of LMD GHOST, Goldfish, and Goldfish with optimistic fast confirmations are depicted in Fig. 4, Fig. 5, and Fig. 6, respectively.</p>

    <p class="text-gray-300">Goldfish: No More Attacks on Ethereum?!</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 4. LMD GHOST has slots with two phases of  <span class="math">\\Delta</span>  duration each. Each slot has a pseudorandomly elected proposer and a committee of voters. PROPOSE: At the start of a slot, the proposer runs fork-choice and proposes a block extending the tip of the identified canonical chain. VOTE: Midway into a slot, voters run fork-choice and vote for the block at the tip of the identified chain. * For greedy heaviest observed sub-tree fork-choice [15, Alg. 3.1] (cf. Alg. 3), conceptually, a validator walks the block tree in its view, starting at the genesis block, and at each block  <span class="math">B</span> , the validator proceeds to the child of  <span class="math">B</span>  whose subtree is heaviest, i.e., received the largest number of votes.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 5. Throughout the execution, validators buffer received proposals and pieces, and merge the blocks and votes contained therein into their bvtrees only as explicitly instructed. Goldfish has slots of three phases of  <span class="math">\\Delta</span>  rounds each. Each slot has proposers (one of which will later be recognized as the slot's leader) and a committee of voters. PROPOSE: At the start of a slot, proposers temporarily merge their buffers into their local bvtrees, and propose their temporary bvtrees and a new block based on it. VOTE: One-thirds into a slot, voters identify the slot's leader's proposal, merge the proposed bvtree into their local bvtrees, and cast a vote based on their local bvtrees. CONFIRM: Two-thirds into a slot, all awake validators merge their buffers into their local bvtrees, and confirm a ledger based on their local bvtrees.</p>

    <p class="text-gray-300">In this section, we provide a formal, complete security proof of Goldfish under a synchronous network in the sleepy model. For this purpose, we restate and expand on the definitions and theorem statements first presented in Sec. 4.</p>

    <p class="text-gray-300">In the subsequent analysis, a valid proposal  <span class="math">P</span>  (cf. Sec. 3) is for slot  <span class="math">t</span>  iff  <span class="math">t = P.B.t</span> , and it has precedence  <span class="math">p</span>  iff  <span class="math">p = \\operatorname{Prio}(P.B.\\rho)</span> . A validator id is eligible</p>

    <p class="text-gray-300">Francesco D'Amato, Joachim Neu, Ertem Nusret Tas, and David Tse</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 6. To enable optimistic fast confirmations, a FAST-CONFIRM phase (blue) of  <span class="math">\\Delta</span>  rounds is inserted between VOTE and CONFIRM phase (cf. Fig. 5). FAST-CONFIRM: Two-fourth into a slot, all awake validators merge their buffers into their local bvtrees, and run the optimistic fast confirmation rule based on their local bvtrees.</p>

    <p class="text-gray-300">to propose at slot  <span class="math">t</span>  if its ticket  <span class="math">(\\mathrm{id}, t)</span>  is winning for the lottery  <span class="math">(\\mathrm{block}, \\mathrm{thr}_{\\mathrm{b}})</span> . Similarly, a validator  <span class="math">\\mathrm{id}</span>  is eligible to vote at slot  <span class="math">t</span>  if its ticket  <span class="math">(\\mathrm{id}, t)</span>  is winning for the lottery  <span class="math">(\\mathrm{vote}, \\mathrm{thr}_{\\mathrm{v}})</span> . Recall that awake honest validators consider the proposal with lowest precedence received by  <span class="math">3\\Delta t + \\Delta</span>  from the leader of slot  <span class="math">t</span>  (Alg. 2, l. 16). We hereafter use blocks and the sequences of blocks they induce via the parent-block chain relation interchangeably. A block  <span class="math">B_{1}</span>  is a descendant (resp., ancestor) of block  <span class="math">B_{2}</span>  iff the underlying chains satisfy  <span class="math">B_{2} \\preceq B_{1}</span>  (resp.,  <span class="math">B_{1} \\preceq B_{2}</span> ). Two blocks  <span class="math">B_{1}, B_{2}</span>  are conflicting if  <span class="math">B_{1}</span>  is neither an ancestor nor a descendant of  <span class="math">B_{2}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">A_r</span>  and  <span class="math">H_r</span>  denote the number of adversary and honest validators awake at round  <span class="math">r</span> , respectively. Our security theorems hold for compliant executions that satisfy the following relations on  <span class="math">A_r</span>  and  <span class="math">H_r</span> :</p>

    <p class="text-gray-300">Definition 2. In the absence of key-evolving cryptographic primitives (signatures and VRFs), an execution is  <span class="math">(\\gamma, \\tau)</span> -compliant iff:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\forall r\\colon \\frac{A_r}{A_r + H_{r - \\tau}}\\leq \\beta &amp;lt;  \\gamma -\\epsilon .</span></li>

      <li>The corruption is mildly adaptive: If the adversary decides to corrupt an honest validator at round  <span class="math">r</span> , then the validator becomes adversary no earlier than at round  <span class="math">r + \\tau</span> .</li>

    </ul>

    <p class="text-gray-300">With key-evolving primitives, an execution is compliant iff:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\forall r\\colon \\frac{A_r}{A_r + H_r}\\leq \\beta &amp;lt;  \\gamma -\\epsilon .</span></li>

    </ul>

    <p class="text-gray-300">Moreover, in both cases,  <span class="math">H_r &amp;gt; \\gamma n_0 = \\Theta(\\kappa)</span>  for all rounds  <span class="math">r</span> , and the time horizon  <span class="math">T_{\\mathrm{hor}}</span>  of the protocol execution satisfies  <span class="math">T_{\\mathrm{hor}} = \\mathrm{poly}(\\kappa)</span> .</p>

    <p class="text-gray-300">Lem. 1 shows that in compliant executions, honest voters outnumber adversary voters (as long as votes have not yet expired); and every long interval of slots contains at least one slot in which all honest validators recognize the same honest validator as the slot leader.</p>

    <p class="text-gray-300">Goldfish: No More Attacks on Ethereum?!</p>

    <p class="text-gray-300">Lemma 1. Suppose the Goldfish execution is  <span class="math">(\\frac{1}{2},3\\Delta)</span> -compliant. Then, w.o.p., for every slot  <span class="math">t</span> , adversary validators at round  <span class="math">3\\Delta (t + 1) + \\Delta</span>  eligible to vote at slot  <span class="math">t</span>  are less than honest validators awake at round  <span class="math">3\\Delta t + \\Delta</span>  and eligible to vote at slot  <span class="math">t</span> . Also w.o.p., all slot intervals of length  <span class="math">\\kappa</span>  have at least one slot  <span class="math">t</span>  where an honest validator is recognized as the slot  <span class="math">t</span>  leader by all awake honest validators at round  <span class="math">3\\Delta t + \\Delta</span> .</p>

    <p class="text-gray-300">Lem. 1's proof uses correctness, uniqueness and pseudorandomness of VRF-based lotteries along with Chernoff bounds.</p>

    <p class="text-gray-300">Proof of Lem. 1. By the pseudorandomness property of the VRF-based lottery (App. G), for any given slot  <span class="math">t</span>  and validators  <span class="math">\\mathsf{id}_1</span>  and  <span class="math">\\mathsf{id}_2</span> ,  <span class="math">\\mathsf{id}_1 \\neq \\mathsf{id}_2</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\operatorname {W i n s} ^ {l _ {v}} \\left(\\left(\\mathrm {i d}, t\\right), \\operatorname {O p e n} _ {\\mathrm {i d} _ {1}} ^ {l _ {v}} (t)\\right) \\right] = \\operatorname {t h r} _ {\\mathrm {v}} \\tag {1}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\operatorname {W i n s} ^ {l _ {b}} \\left(\\left(\\mathrm {i d}, t\\right), \\operatorname {O p e n} _ {\\mathrm {i d} _ {1}} ^ {l _ {b}} (t)\\right) \\right] = \\operatorname {t h r} _ {\\mathrm {b}} \\tag {2}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\operatorname {P r i o} \\left(\\operatorname {O p e n} _ {\\mathrm {i d} _ {1}} ^ {l _ {b}} (t)\\right) &amp;lt;   \\operatorname {P r i o} \\left(\\operatorname {O p e n} _ {\\mathrm {i d} _ {2}} ^ {l _ {b}} (t)\\right) \\right] = \\frac {1}{2}, \\tag {3}</span></div>

    <p class="text-gray-300">where  <span class="math">l_{v} = (\\mathsf{vote},\\mathsf{thr}_{\\mathrm{v}})</span>  and  <span class="math">l_{b} = (\\mathsf{block},\\mathsf{thr}_{\\mathrm{b}})</span>  are the lotteries, and  <span class="math">\\mathrm{Open}_{\\mathsf{id}_1}^{l_v}(t)</span> ,  <span class="math">\\mathrm{Open}_{\\mathsf{id}_1}^{l_b}(t)</span> ,  <span class="math">\\mathrm{Open}_{\\mathsf{id}_2}^{l_b}(t)</span> , and  <span class="math">\\mathrm{Open}_{\\mathsf{id}_2}^{l_v}(t)</span>  are independent random variables.</p>

    <p class="text-gray-300">We first consider the protocol without key-evolving primitives. By the uniqueness property of the lottery (App. G), w.o.p., for all validators id and slots  <span class="math">t</span> , the ticket  <span class="math">(\\mathsf{id}, t)</span>  can be opened at most one unique opening (Alg. 2, l. 20). Let  <span class="math">\\tilde{H}_t</span>  denote the number of honest validators awake at round  <span class="math">3\\Delta t + \\Delta</span>  and eligible to vote at slot  <span class="math">t</span> . Let  <span class="math">\\tilde{A}_t</span>  denote the number of adversary validators at round  <span class="math">3\\Delta (t + 1) + \\Delta</span>  that are eligible to vote at slot  <span class="math">t</span> . Recall that  <span class="math">A_r</span>  and  <span class="math">H_r</span>  denote the number of adversary and honest validators awake at round  <span class="math">r</span>  respectively (note that the honest validators have been awake since the closest round  <span class="math">3\\Delta t + 2\\Delta</span>  same as or preceding  <span class="math">r</span> ). Let  <span class="math">n_t = H_{3\\Delta t + \\Delta} + A_{3\\Delta (t + 1) + \\Delta} \\geq n_0 = \\Theta(\\kappa)</span> .</p>

    <p class="text-gray-300">By the pseudorandomness property, the adversary cannot predict in advance which honest validators will become eligible to vote or propose at a given slot. Moreover, if the adversary decides to corrupt the honest validators eligible to vote at a slot  <span class="math">t</span>  after learning their identities at round  <span class="math">3\\Delta t + \\Delta</span> , it takes over  <span class="math">3\\Delta</span>  rounds for the corruption to take effect, implying that these validators cannot be counted as part of  <span class="math">\\tilde{A}_t</span> . Hence, as  <span class="math">\\frac{A_r}{A_r + H_{r - 3\\Delta}} \\leq \\beta &amp;lt; \\frac{1}{2} - \\epsilon</span>  for all rounds  <span class="math">r</span> , w.o.p.,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} [ \\tilde {H} _ {t} ] = H _ {3 \\Delta t + \\Delta} \\mathsf {t h r} _ {\\mathrm {v}} \\geq (\\frac {1}{2} + \\epsilon) n _ {t} \\mathsf {t h r} _ {\\mathrm {v}}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} [ \\tilde {A} _ {t} ] = A _ {3 \\Delta (t + 1) + \\Delta} \\mathsf {t h r} _ {\\mathrm {v}} \\leq (\\frac {1}{2} - \\epsilon) n _ {t} \\mathsf {t h r} _ {\\mathrm {v}}</span></div>

    <p class="text-gray-300">By a Chernoff bound,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\tilde {H} _ {t} &amp;lt;   \\frac {1}{2} n _ {t} \\mathsf {t h r} _ {\\mathrm {v}} \\right] \\leq e ^ {- \\frac {\\epsilon^ {2}}{1 + 2 \\epsilon} n _ {t} \\mathsf {t h r} _ {\\mathrm {v}}}</span></div>

    <p class="text-gray-300">8 The proposer-lottery threshold thr_b can be tuned following Algorand [33, Appendix-B.1] so that each slot has at least one eligible proposer.</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\tilde{A}_{t}&gt;\\frac{1}{2}n_{t}\\mathsf{thr}_{\\mathrm{v}}\\right]\\leq e^{-\\frac{\\epsilon^{2}}{1+3\\epsilon}n_{t}\\mathsf{thr}_{\\mathrm{v}}}.</span></p>

    <p class="text-gray-300">Thus, at any given slot <span class="math">t</span>, <span class="math">\\tilde{H}_{t}&gt;\\tilde{A}_{t}</span>, except with probability</p>

    <p class="text-gray-300"><span class="math">2\\exp{(-\\frac{\\epsilon^{2}}{1+3\\epsilon}n_{0}\\mathsf{thr}_{\\mathrm{v}})}.</span></p>

    <p class="text-gray-300">By a union bound, every slot <span class="math">t</span> has more honest validators awake at round <span class="math">3\\Delta t+\\Delta</span> and eligible to vote at slot <span class="math">t</span> than adversary validators at round <span class="math">3\\Delta(t+1)+\\Delta</span>, eligible to vote at slot <span class="math">t</span> (and more than <span class="math">\\frac{1}{2}n_{0}\\mathsf{thr}_{\\mathrm{v}}</span> such honest validators), except with probability</p>

    <p class="text-gray-300"><span class="math">2T_{\\mathrm{hor}}\\exp{\\left(-\\frac{\\epsilon^{2}}{1+3\\epsilon}n_{0}\\mathsf{thr}_{\\mathrm{v}}\\right)}+\\mathrm{negl}(\\lambda)=\\mathrm{negl}(\\kappa)+\\mathrm{negl}(\\lambda),</span></p>

    <p class="text-gray-300">since <span class="math">n_{0}=\\Theta(\\kappa)</span> and <span class="math">T_{\\mathrm{hor}}=\\Theta(\\kappa)</span>. By the same reasoning, w.o.p., every slot <span class="math">t</span> has more honest validators awake and eligible to propose for slot <span class="math">t</span> at round <span class="math">3\\Delta t</span> than adversary validators at round <span class="math">3\\Delta t+\\Delta</span>, eligible to propose for slot <span class="math">t</span>.</p>

    <p class="text-gray-300">Finally, for any given slot <span class="math">t</span>, each valid slot <span class="math">t</span> proposal broadcast within rounds <span class="math">[3\\Delta t,3\\Delta t+\\Delta]</span> has the same probability of achieving the minimum precedence up to terms negligible in <span class="math">\\lambda</span>. Now, at a slot <span class="math">t</span>, if an honest validator’s proposal achieves the minimum precedence among the valid slot <span class="math">t</span> proposals broadcast by <span class="math">\\Delta</span> rounds into the slot, then that validator is identified as the slot leader by all honest validators awake at round <span class="math">3\\Delta t+\\Delta</span>. Taking a fixed <span class="math">t\\geq\\kappa</span>, the probability that no awake honest validator’s proposal has the minimum precedence among the valid slot <span class="math">s</span> proposals broadcast by <span class="math">\\Delta</span> rounds into the slot, during the slots <span class="math">s\\in[t-\\kappa,t]</span>, is upper bounded by <span class="math">2^{-\\kappa}+\\mathrm{negl}(\\kappa)+\\mathrm{negl}(\\lambda)</span>. Union bounding over all <span class="math">T_{\\mathrm{hor}}</span> many such intervals, we find that w.o.p., all slot intervals of length <span class="math">\\kappa</span> have at least one slot <span class="math">t</span>, where an honest validator is identified as the slot leader by all awake honest validators at round <span class="math">3\\Delta t+\\Delta</span>.</p>

    <p class="text-gray-300">Now with key-evolving primitives, we define <span class="math">\\tilde{H}_{t}=H_{3\\Delta t+\\Delta}</span> and <span class="math">\\tilde{A}_{t}=A_{3\\Delta t+\\Delta}</span>. Similarly, we define <span class="math">n_{t}=H_{3\\Delta t+\\Delta}+A_{3\\Delta t+\\Delta}\\geq n_{0}=\\Theta(\\kappa)</span>. In this case, <span class="math">\\frac{A_{r}}{A_{r}+H_{r}}\\leq\\beta&lt;\\frac{1}{2}-\\epsilon</span> for all rounds <span class="math">r</span>. Note that the adversary cannot predict in advance which honest validators will become eligible to vote or propose at a given slot due to the pseudorandomness property of the lottery. Moreover, if the adversary corrupts the honest validators eligible to vote at a slot <span class="math">t</span> after learning their identities at round <span class="math">3\\Delta t+\\Delta</span>, it cannot make these validators broadcast new valid votes for slot <span class="math">t</span> since the keys for slot <span class="math">t</span> would have been evolved prior to adversary corrruption (i.e., these corrupted validators cannot be counted as part of <span class="math">\\tilde{A}_{t}</span>). Hence, the number of valid slot <span class="math">t</span> votes adversary validators can broadcast by round <span class="math">3\\Delta(t+1)+\\Delta</span> is upper bounded by the number of adversary validators at round <span class="math">3\\Delta t+\\Delta</span> that are eligible to vote at slot <span class="math">t</span>. Finally, by the same calculations as above, every slot <span class="math">t</span> has more honest validators eligible to vote and awake at round <span class="math">3\\Delta t+\\Delta</span> than the adversary validators at round <span class="math">3\\Delta(t+1)+\\Delta</span> eligible to vote at slot <span class="math">t</span> (and more than <span class="math">\\frac{1}{2}n_{0}\\mathsf{thr}_{\\mathrm{v}}</span> such honest validators), except with</p>

    <p class="text-gray-300">probability</p>

    <p class="text-gray-300"><span class="math">2T_{\\mathrm{hor}}\\exp\\left(-\\frac{\\epsilon^{2}}{1+3\\epsilon}n_{0}\\mathsf{thr}_{\\mathrm{v}}\\right)+\\mathrm{negl}(\\lambda)=\\mathrm{negl}(\\kappa)+\\mathrm{negl}(\\lambda).</span></p>

    <p class="text-gray-300">Similarly, w.o.p., every slot <span class="math">t</span> has more honest validators awake and eligible to propose for slot <span class="math">t</span> at round <span class="math">3\\Delta t</span> than adversary validators at round <span class="math">3\\Delta t+\\Delta</span> eligible to propose for slot <span class="math">t</span>. Thus, via the same argument, w.o.p., all slot intervals of length <span class="math">\\kappa</span> have at least one slot <span class="math">t</span>, where an honest validator is identified as the slot leader by all awake honest validators at round <span class="math">3\\Delta t+\\Delta</span>. ∎</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">B.3 Main Security Results</h3>

    <p class="text-gray-300">The main security results are as follows:</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Suppose a <span class="math">(\\frac{1}{2},3\\Delta)</span>-compliant execution of Goldfish in the synchronous sleepy network model of Sec. 2, and validator <span class="math">\\mathsf{id}</span> with proposal <span class="math">P^{<em>}</span> is recognized as the leader of a slot <span class="math">t</span> by all awake honest validators at round <span class="math">3\\Delta t+\\Delta</span> (Alg. 2, l. 16). Then, w.o.p., <span class="math">P^{</em>}.B\\preceq B</span> for any <span class="math">B</span> identified in Alg. 2, ll. 8, 22, 28 by any awake honest validator in any round <span class="math">r\\geq 3\\Delta t+2\\Delta</span>.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Theorem 2 (Security).</h6>

    <p class="text-gray-300">Suppose a <span class="math">(\\frac{1}{2},3\\Delta)</span>-compliant execution of Goldfish in the synchronous sleepy network model. Then, w.o.p., Goldfish is secure with transaction confirmation time <span class="math">T_{\\mathrm{conf}}=2\\kappa+2</span> slots.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Theorem 3 (Reorg resilience).</h6>

    <p class="text-gray-300">Suppose a <span class="math">(\\frac{1}{2},3\\Delta)</span>-compliant execution of Goldfish in the synchronous sleepy network model, and validator <span class="math">\\mathsf{id}</span> with proposal <span class="math">P^{<em>}</span> is recognized as the leader of a slot <span class="math">t</span> by all awake honest validators at round <span class="math">3\\Delta t+\\Delta</span> (Alg. 2, l. 16). Then, w.o.p., <span class="math">\\exists r^{\\prime}\\colon\\forall r\\geq r^{\\prime}\\colon\\forall\\mathsf{id}\\colon\\ P^{</em>}.B\\preceq\\mathsf{ch}_{r}^{\\mathsf{id}}</span>, where <span class="math">\\mathsf{ch}_{r}^{\\mathsf{id}}</span> denotes Goldfish’s ledger at validator <span class="math">\\mathsf{id}</span> and round <span class="math">r</span>. In particular, <span class="math">r^{\\prime}=3\\Delta(t+\\kappa)+2\\Delta</span> satisfies the above.</p>

    <p class="text-gray-300">We first prove Thms. 2 and 3 from Thm. 1 and Lem. 1. Then, we prove Thm. 1 from the subsequent Lems. 1, 2 and 3.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Proof of Thm. 2.</h6>

    <p class="text-gray-300">By Lem. 1, w.o.p., all slot intervals of length <span class="math">\\kappa</span> have at least one slot <span class="math">t</span>, where an honest validator with proposal <span class="math">P^{<em>}</span> is recognized as the slot leader by all awake honest validators at round <span class="math">3\\Delta t+\\Delta</span>, and, by Thm. 1, <span class="math">P^{</em>}.B\\preceq B</span> for any <span class="math">B</span> identified in Alg. 2, ll. 8, 22, 28 by any awake honest validator in any <span class="math">r\\geq 3\\Delta t+2\\Delta</span>.</p>

    <p class="text-gray-300">Liveness. A transaction <span class="math">\\mathsf{tx}</span> is input to an honest validator at some round <span class="math">r</span>. At most <span class="math">6\\Delta</span> rounds (i.e., 2 slots) later the transaction is propagated to all honest validators and we have reached the beginning of a slot <span class="math">t_{0}</span>. For the next <span class="math">\\kappa</span> slots all honest proposers will include <span class="math">\\mathsf{tx}</span> if they extend a tip whose chain does not include <span class="math">\\mathsf{tx}</span> yet. By the earlier argument, one of these proposals will be an ancestor of any <span class="math">B</span> identified in Alg. 2, ll. 8, 22, 28 by any awake honest validator in any <span class="math">r^{\\prime}\\geq 3\\Delta(t_{0}+\\kappa)+2\\Delta</span>. From <span class="math">\\kappa</span> slots later onwards, all awake honest validators include the transaction in their ledger (Alg. 2, l. 29). Thus, Goldfish is live with</p>

    <p class="text-gray-300">Francesco D'Amato, Joachim Neu, Ertem Nusret Tas, and David Tse</p>

    <p class="text-gray-300"><span class="math">T_{\\mathrm{conf}} = 2\\kappa + 2</span>  slots.</p>

    <p class="text-gray-300">Safety. Pick any two honest validators  <span class="math">\\mathsf{id}_1</span>  and  <span class="math">\\mathsf{id}_2</span> , and two slots  <span class="math">t_1</span>  and  <span class="math">t_2 \\geq t_1</span> . By the earlier argument, there exists a block  <span class="math">B&#x27;</span>  proposed (by an honest validator) at some slot  <span class="math">t&#x27; \\in [t_1 - \\kappa, t_1]</span>  such that  <span class="math">B&#x27; \\preceq B</span>  for any  <span class="math">B</span>  identified in Alg. 2, ll. 8, 22, 28 by any awake honest validator in any  <span class="math">r&#x27; \\geq 3\\Delta t&#x27; + 2\\Delta</span> . As  <span class="math">t&#x27; \\geq t_1 - \\kappa</span>  but by Goldfish's confirmation rule blocks in  <span class="math">\\mathsf{ch}_{t_1}^{\\mathsf{id}_2}</span>  are from no later than  <span class="math">t_1 - \\kappa</span> ,  <span class="math">\\mathsf{ch}_{t_1}^{\\mathsf{id}_1} \\preceq B</span> . Similarly, if  <span class="math">t&#x27; \\geq t_2 - \\kappa</span> , then  <span class="math">\\mathsf{ch}_{t_2}^{\\mathsf{id}_2} \\preceq B</span> ; otherwise,  <span class="math">B \\preceq \\mathsf{ch}_{t_2}^{\\mathsf{id}_2}</span> . In both cases, either  <span class="math">\\mathsf{ch}_{t_1}^{\\mathsf{id}_1} \\preceq \\mathsf{ch}_{t_2}^{\\mathsf{id}_2}</span>  or  <span class="math">\\mathsf{ch}_{t_2}^{\\mathsf{id}_2} \\preceq \\mathsf{ch}_{t_1}^{\\mathsf{id}_1}</span> .</p>

    <p class="text-gray-300">Proof of Thm. 3. By Thm. 1,  <span class="math">P^{*}.B \\preceq B</span>  for any  <span class="math">B</span>  identified in Alg. 2, ll. 8, 22, 28 by any awake honest validator in any  <span class="math">r \\geq 3\\Delta t + 2\\Delta</span> . From  <span class="math">\\kappa</span>  slots later onwards, all awake honest validators include the transaction in their ledger (Alg. 2, l. 29).</p>

    <p class="text-gray-300">Proof of Thm. 1 follows from Lems. 1, 2 and 3, and is provided at the end of this section. The structure of the argument is inductive: Lem. 2 shows that in a slot  <span class="math">t</span>  with honest leader, all honest voters vote for the leader's proposal. Lem. 3 shows that if in slot  <span class="math">t</span>  all honest voters have voted for a descendant of a certain block, then in slot  <span class="math">t + 1</span>  all honest voters will vote for a descendant of that block.</p>

    <p class="text-gray-300">Lemma 2. Suppose an execution of Goldfish in the synchronous sleepy network model, and validator  <span class="math">\\mathsf{id}^<em></span>  with proposal  <span class="math">P^{</em>}</span>  is recognized as leader of a slot  <span class="math">t</span>  by all awake honest validators at round  <span class="math">3\\Delta t + \\Delta</span>  (Alg. 2, l. 16). Then, all honest validators awake at round  <span class="math">3\\Delta t + \\Delta</span>  and eligible to vote at  <span class="math">t</span>  vote for  <span class="math">P^{*}.B</span>  at  <span class="math">t</span> .</p>

    <p class="text-gray-300">Proof. Let  <span class="math">\\mathcal{T}&#x27; = P^{<em>}.T</span> , and  <span class="math">\\mathcal{B}^</em></span>  and  <span class="math">\\mathcal{T}^<em></span>  denote the buffer and bvtree of  <span class="math">\\mathsf{id}^</em></span>  at round  <span class="math">3\\Delta t</span> . Since  <span class="math">\\mathsf{id}^<em></span>  is honest, it must have broadcast  <span class="math">P^</em></span>  at round  <span class="math">3\\Delta t</span>  with bvtree  <span class="math">\\mathcal{T}&#x27; = \\mathrm{MERGE}(\\mathcal{T}^<em>,\\mathcal{B}^</em>)</span>  and a new block  <span class="math">P^*.B</span>  with parent GHOST-EPH  <span class="math">(\\mathcal{T}&#x27;,t - 1)</span>  (Alg. 2, ll. 7, 8, 12).</p>

    <p class="text-gray-300">By synchrony, any message that a non-asleep honest validator id could have added to its bvtree  <span class="math">\\mathcal{T}_{\\mathrm{id}}</span>  by  <span class="math">3\\Delta (t - 1) + 2\\Delta</span> , is received by  <span class="math">\\mathrm{id}^*</span>  by  <span class="math">3\\Delta t</span> , and thus in  <span class="math">\\mathcal{T}&#x27;</span> . As awake honest validators do not update their bvtrees and no honest validators turn awake in the interval  <span class="math">(3\\Delta (t - 1) + 2\\Delta, 3\\Delta t + \\Delta)</span> , for any honest validator id awake at round  <span class="math">3\\Delta t + \\Delta</span> ,  <span class="math">\\mathcal{T}_{\\mathrm{id}} \\subseteq \\mathcal{T}&#x27;</span>  prior to Alg. 2, l. 19.</p>

    <p class="text-gray-300">Since  <span class="math">\\mathsf{id}^<em></span>  is recognized as the leader of slot  <span class="math">t</span>  by all awake honest validators at round  <span class="math">3\\Delta t + \\Delta</span> , at that round, each awake honest validator id merges its bvtree with  <span class="math">\\mathcal{T}&#x27; \\cup \\{P^</em>.B\\}</span>  (Alg. 2, l. 19) and reaches  <span class="math">\\mathcal{T}_{\\mathsf{id}} = \\mathcal{T}&#x27; \\cup \\{P^<em>.B\\}</span> . Consequently, each honest validator id awake at round  <span class="math">3\\Delta t + \\Delta</span>  and eligible to vote at slot  <span class="math">t</span>  votes for  <span class="math">P^</em>.B</span>  due to the recursive structure of the GHOST-Eph rule (Alg. 3).</p>

    <p class="text-gray-300">Lemma 3. Suppose a  <span class="math">(\\frac{1}{2}, 3\\Delta)</span> -compliant execution of Goldfish in the synchronous sleepy network model. Consider a slot  <span class="math">t</span>  where all honest validators awake at round  <span class="math">3\\Delta t + \\Delta</span>  and eligible to vote at slot  <span class="math">t</span> , vote for a descendant of  <span class="math">B</span> . Then, w.o.p., all honest validators awake at round  <span class="math">3\\Delta (t + 1) + \\Delta</span>  and eligible to vote at slot  <span class="math">t + 1</span> , vote for a descendant of  <span class="math">B</span> .</p>

    <p class="text-gray-300">Goldfish: No More Attacks on Ethereum?!</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">By Lem. 1, w.o.p., for every slot <span class="math">t</span>, the number of adversary validators at round <span class="math">3\\Delta(t+1)+\\Delta</span> and eligible to vote at slot <span class="math">t</span> is less than the number of honest validators awake at round <span class="math">3\\Delta t+\\Delta</span> and eligible to vote at slot <span class="math">t</span>.</p>

    <p class="text-gray-300">Let <span class="math">t</span> be a slot such that all honest validators awake at round <span class="math">3\\Delta t+\\Delta</span> and eligible to vote at <span class="math">t</span> voted for a descendant of <span class="math">B</span>. Pick any honest validator id awake at round <span class="math">3\\Delta(t+1)+\\Delta</span> and eligible to vote at slot <span class="math">t+1</span>. Since id must have been awake at least since round <span class="math">3\\Delta t+2\\Delta</span>, its bvtree at round <span class="math">3\\Delta t+2\\Delta</span> contains all votes broadcast by honest validators awake at round <span class="math">3\\Delta t+\\Delta</span> and eligible to vote at slot <span class="math">t</span> (Alg. 2, l. 19). The same is true for its bvtree at round <span class="math">3\\Delta(t+1)+\\Delta</span>, even after id merges its bvtree with that of any proposal (Alg. 2, l. 7). Moreover, the number of honest validators awake at round <span class="math">3\\Delta t+\\Delta</span> and eligible to vote at slot <span class="math">t</span> is greater than the number of adversary validators at round <span class="math">3\\Delta(t+1)+\\Delta</span> that are eligible to vote at slot <span class="math">t</span>.</p>

    <p class="text-gray-300">Consequently, upon invoking the GHOST-Eph fork-choice rule at round <span class="math">3\\Delta(t+1)+\\Delta</span> (Alg. 2, l. 22), id observes that at every iteration of the fork choice (Alg. 3, l. 7), blocks consistent with <span class="math">B</span> have more votes than blocks conflicting with <span class="math">B</span>. Thus, at round <span class="math">3\\Delta(t+1)+\\Delta</span>, fork choice returns a descendant of <span class="math">B</span>, and id votes for it. ∎</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Proof of Thm. 1.</h6>

    <p class="text-gray-300">From Lems. 1, 2 and 3, it follows by induction that w.o.p., for all <span class="math">t^{\\prime}\\geq t</span>, all honest validators awake at round <span class="math">3\\Delta t^{\\prime}+\\Delta</span> and eligible to vote at slot <span class="math">t^{\\prime}</span>, vote for a descendant of <span class="math">P^{*}.B</span>.</p>

    <p class="text-gray-300">By synchrony, the honest votes of slot <span class="math">t^{\\prime}</span> reach all honest validators awake at <span class="math">3\\Delta t^{\\prime}+2\\Delta</span> by then, when they also merge the votes into their bvtrees. The number of honest validators awake at round <span class="math">3\\Delta t^{\\prime}+\\Delta</span> and eligible to vote at slot <span class="math">t^{\\prime}</span> is greater than the number of adversary validators by round <span class="math">3\\Delta(t^{\\prime}+1)+\\Delta</span> that are eligible to vote at slot <span class="math">t^{\\prime}</span> (by Lem. 1). Upon invoking the GHOST-Eph rule of Alg. 2, ll. 8, 22, 28 at <span class="math">3\\Delta t^{\\prime}+2\\Delta</span>, <span class="math">3\\Delta(t^{\\prime}+1)</span> and <span class="math">3\\Delta(t^{\\prime}+1)+\\Delta</span>, respectively, an awake honest validator id (who must have been awake since at least <span class="math">3\\Delta t^{\\prime}+2\\Delta</span>, due to the joining procedure) observes that at every iteration of the fork choice (Alg. 3, l. 7), blocks consistent with <span class="math">P^{<em>}.B</span> have more votes than blocks conflicting with <span class="math">P^{</em>}.B</span>. Thus, id’s fork choice reaches a descendant of <span class="math">P^{*}.B</span>. ∎</p>

    <h2 id="sec-34" class="text-2xl font-bold">Appendix C Security Proof of Goldfish with Fast Confirmation</h2>

    <p class="text-gray-300">In the following analysis, we consider a synchronous network in the sleepy model as described in Sec. 2. Recall that the total number of validators is <span class="math">n</span> (cf. Sec. 2). Since Goldfish slots consist of <span class="math">4\\Delta</span> rounds in the case of fast confirmation, we hereafter assume that the Goldfish execution is <span class="math">(\\frac{1}{2},4\\Delta)</span>-compliant. We show that Thm. 2 holds for Goldfish with fast confirmations (w.o.p.) in compliant executions. To do so, we first prove Thm. 4, an analogue of Thm. 1 for fast confirmations, showing that fast confirmed blocks are always in the canonical chain of awake validators at later rounds.</p>

    <p class="text-gray-300">Since Goldfish slots consist of <span class="math">4\\Delta</span> rounds in the case of fast confirmation, we state an analogue of Lem. 1 to match the new slot structure:</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Lemma 4</h6>

    <p class="text-gray-300">Suppose the Goldfish execution is <span class="math">(\\frac{1}{2},4\\Delta)</span>-compliant. Then, w.o.p., for every slot <span class="math">t</span>, the number of adversary validators at round <span class="math">4\\Delta(t+1)+\\Delta</span>, eligible to vote at slot <span class="math">t</span>, is less than the number of honest validators, awake at round <span class="math">4\\Delta t+\\Delta</span> and eligible to vote at slot <span class="math">t</span>. Also w.o.p., all slot intervals of length <span class="math">\\kappa</span> have at least one slot <span class="math">t</span>, where an honest validator is identified as the slot leader by all awake honest validators at round <span class="math">4\\Delta t+\\Delta</span>.</p>

    <p class="text-gray-300">Proof of Lem. 4 is analogous to the proof of Lem. 1, and follows from the same arguments using <span class="math">(\\frac{1}{2},4\\Delta)</span>-compliant executions.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Proposition 1</h6>

    <p class="text-gray-300">Suppose <span class="math">T_{\\mathrm{hor}}=\\mathrm{poly}(\\kappa)</span>. Then, w.o.p., there can be at most <span class="math">(1+\\epsilon)n\\,\\mathsf{thr}_{\\mathrm{v}}</span> validators that are eligible to vote at any given slot. If the Goldfish execution is <span class="math">(\\frac{1}{2},4\\Delta)</span>-compliant, then, w.o.p., for all slots <span class="math">t</span>, the number of adversary validators at round <span class="math">4\\Delta(t+1)+\\Delta</span>, eligible to vote at slot <span class="math">t</span>, is less than <span class="math">\\frac{1}{2}n\\,\\mathsf{thr}_{\\mathrm{v}}</span>.</p>

    <p class="text-gray-300">Proof follows from a Chernoff bound.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Lemma 5</h6>

    <p class="text-gray-300">Suppose the Goldfish execution is <span class="math">(\\frac{1}{2},4\\Delta)</span>-compliant in the synchronous sleepy network model, and an honest validator <span class="math">\\mathsf{id}^{*}</span> fast confirms a block <span class="math">B</span> at slot <span class="math">t</span>. Then, w.o.p, all honest validators awake at round <span class="math">4\\Delta(t+1)+\\Delta</span> and eligible to vote at slot <span class="math">t+1</span>, vote for a descendant of <span class="math">B</span> at slot <span class="math">t+1</span>.</p>

    <p class="text-gray-300">Proof is stated below and follows from Prop. 1 and a quorum intersection argument.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Proof of Lem. 5</h6>

    <p class="text-gray-300">By Prop. 1, w.o.p., the number of adversary validators at round <span class="math">4\\Delta(t+1)+\\Delta</span>, eligible to vote at slot <span class="math">t</span>, is less than <span class="math">\\frac{1}{2}n\\,\\mathsf{thr}_{\\mathrm{v}}</span>. An eligible awake honest validator sends a single slot <span class="math">t</span> vote at round <span class="math">4\\Delta t+\\Delta</span>, implying that over <span class="math">(\\frac{3}{4}+\\frac{\\epsilon}{2})n\\,\\mathsf{thr}_{\\mathrm{v}}-\\frac{1}{2}n\\,\\mathsf{thr}_{\\mathrm{v}}=(\\frac{1}{4}+\\frac{\\epsilon}{2})n\\,\\mathsf{thr}_{\\mathrm{v}}</span> validators broadcast a single slot <span class="math">t</span> vote by round <span class="math">4\\Delta(t+1)+\\Delta</span>, and that is for a descendant of <span class="math">B</span>. By Prop. 1, w.o.p., for all slots <span class="math">t</span>, there can be at most <span class="math">(1+\\epsilon)n\\,\\mathsf{thr}_{\\mathrm{v}}</span> validators that are eligible to vote at <span class="math">t</span>. Hence, the number of valid slot <span class="math">t</span> votes for the descendants of any block <span class="math">B^{\\prime}</span> conflicting with <span class="math">B</span> must be less than <span class="math">(1+\\epsilon)n\\,\\mathsf{thr}_{\\mathrm{v}}-(\\frac{1}{4}+\\frac{\\epsilon}{2})n\\,\\mathsf{thr}_{\\mathrm{v}}=(\\frac{3}{4}+\\frac{\\epsilon}{2})n\\,\\mathsf{thr}_{\\mathrm{v}}</span> at any given round. The validator <span class="math">\\mathsf{id}^{*}</span> broadcasts <span class="math">B</span> and over <span class="math">(\\frac{3}{4}+\\frac{\\epsilon}{2})n\\,\\mathsf{thr}_{\\mathrm{v}}</span> valid votes for it (in pieces) at round <span class="math">4\\Delta t+2\\Delta</span>. Each honest validator, awake at round <span class="math">4\\Delta(t+1)+\\Delta</span> and eligible to vote at slot <span class="math">t+1</span>, observes these votes in its bvtree at the round of voting (Alg. 4, l. 11). Upon invoking the GHOST-Eph fork-choice rule at any of the rounds <span class="math">4\\Delta t+3\\Delta</span>, <span class="math">4\\Delta(t+1)</span> or <span class="math">4\\Delta(t+1)+\\Delta</span> (Alg. 2, ll. 8, 22, 28), for any awake honest validator <span class="math">\\mathsf{id}</span> with bvtree <span class="math">\\mathcal{T}^{\\prime}</span>, <span class="math">\\textsc{Votes}(\\mathcal{T}^{\\prime},B,t)&gt;\\textsc{Votes}(\\mathcal{T}^{\\prime},B^{\\prime},t)</span> for any block <span class="math">B^{\\prime}</span> conflicting with <span class="math">B</span>. This implies that all honest validators, awake at round <span class="math">4\\Delta(t+1)+\\Delta</span> and eligible to vote at slot <span class="math">t+1</span> all vote for <span class="math">B</span> or one of its descendants at slot <span class="math">t+1</span>. ∎</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Theorem 4</h6>

    <p class="text-gray-300">Suppose the Goldfish execution is <span class="math">(\\frac{1}{2},4\\Delta)</span>-compliant in the synchronous sleepy network model, and an honest validator <span class="math">\\mathsf{id}^{*}</span> fast confirms a block <span class="math">B</span> at slot <span class="math">t</span>. Then, w.o.p., <span class="math">B\\preceq B</span> for any <span class="math">B</span> identified in Alg. 2, ll. 8, 22, 28 by any awake honest validator in any round <span class="math">r\\geq 4\\Delta(t+1)+\\Delta</span></p>

    <p class="text-gray-300">Proof is stated below and follows from Lems. 4, 5 and 3 and the inductive argument used in the proof of Thm. 1.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Proof of Thm. 4.</h6>

    <p class="text-gray-300">Follows by Lems. 4, 5 and 3, by the same inductive argument used in the proof of Thm. 1, in that case following from Lems. 1, 2 and 3. Here, Lem. 4 is the analogue of Lem. 1 with the new slot structure, and Lem. 5 provides the base case, substituting Lem. 2. ∎</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">Suppose the Goldfish execution is <span class="math">(\\frac{1}{2},4\\Delta)</span>-compliant. Then, Goldfish with fast confirmations satisfies safety (w.o.p.).</p>

    <p class="text-gray-300">Proof is stated below and follows from Thm. 2.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Proof of Thm. 5.</h6>

    <p class="text-gray-300">If an honest validator fast confirms a block <span class="math">B</span> at slot <span class="math">t</span>, then <span class="math">B</span> is in the canonical GHOST-Eph chain of every awake honest validator at all slots larger than <span class="math">t</span> by Thm. 4. Therefore, <span class="math">B</span> is in the <span class="math">\\kappa</span>-slots-deep prefix of the canonical GHOST-Eph chains of all awake honest validators at slot <span class="math">t+\\kappa</span>, and thus confirmed by them with the standard confirmation rule. Therefore, Thm. 2 implies the safety of the protocol. ∎</p>

    <p class="text-gray-300">In <span class="math">(\\frac{1}{2},4\\Delta)</span>-compliant executions, we automatically get liveness of Goldfish with fast confirmations from the liveness of the standard confirmation rule, since fast confirmation is not needed for a block to be confirmed. Under optimistic conditions, liveness of fast confirmations holds as well. We prove that a block within an honest, valid proposal is immediately fast confirmed within the same slot by the awake honest validators, if there are over <span class="math">(\\frac{3}{4}+\\frac{3}{2}\\epsilon)n</span> awake, honest validators at the voting time of the given slot, implying the liveness of fast confirmations under optimistic conditions.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Theorem 6.</h6>

    <p class="text-gray-300">Suppose the Goldfish execution is <span class="math">(\\frac{1}{2},4\\Delta)</span>-compliant. Then, Goldfish with fast confirmations satisfies liveness with <span class="math">T_{\\mathrm{conf}}=\\Theta(\\kappa)</span> (w.o.p.).</p>

    <p class="text-gray-300">Consider a slot <span class="math">t</span>, such that there are <span class="math">(\\frac{3}{4}+\\frac{3}{2}\\epsilon)n\\,\\mathsf{thr}_{\\mathrm{v}}</span> honest validators eligible to vote at slot <span class="math">t</span> and awake at round <span class="math">4\\Delta t+\\Delta</span>. Suppose an honest validator <span class="math">\\mathsf{id}</span> with proposal <span class="math">P^{<em>}</span> is recognized as the leader of a slot <span class="math">t</span> by all awake honest validators at round <span class="math">4\\Delta t+\\Delta</span> (Alg. 2, l. 16). Then all honest validators awake at round <span class="math">4\\Delta t+2\\Delta</span> fast confirm <span class="math">P^{</em>}.B</span> in Alg. 4, l. 9.</p>

    <p class="text-gray-300">Liveness is stated below and follows from Thm. 2 and fast confirmation from Lem. 2.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof of Thm. 6.</h6>

    <p class="text-gray-300">Proof of liveness follows from Thm. 2.</p>

    <p class="text-gray-300">For the second part of the proof, by Lem. 2, all of eligible and awake honest validators vote for <span class="math">P^{<em>}.B</span> at slot <span class="math">t</span>. Then, the buffer of any honest validator awake at round <span class="math">4\\Delta t+2\\Delta</span> contains at least <span class="math">(\\frac{3}{4}+\\frac{\\epsilon}{2})n\\,\\mathsf{thr}_{\\mathrm{v}}</span> votes (by Chernoff bound) for the block <span class="math">P^{</em>}.B</span>, implying that all honest validators awake at rounds <span class="math">4\\Delta t+2\\Delta</span> fast confirm <span class="math">P^{*}.B</span> at the respective slots. ∎</p>

    <p class="text-gray-300">D Goldfish with Overlay Gadgets</p>

    <p class="text-gray-300">Two properties desired for Ethereum consensus as a whole, besides security under dynamic participation, fast confirmation, and reorg resilience, are security under partial synchrony and accountable safety. However, it is impossible for all these properties to be satisfied by a single ledger <em>[60, 61, 69, 34, 44]</em>. For this reason, Ethereum’s consensus protocol (Gasper <em>[15]</em>, Fig. 1) consists of an overlay finality/accountability gadget (Casper FFG <em>[14]</em>) which provides accountable safety under asynchrony, on top of an underlay chain which should be secure under synchrony and dynamic participation, and provide fast confirmations and reorg resilience. The desiderata for Gasper were formalized by ebb-and-flow <em>[60, 61, 69]</em>. The objective is, slightly more abstractly, to design a flexible two-ledger consensus protocol, which supports a full dynamically available ledger in conjunction with a finalized and accountable prefix ledger. The finalized ledger falls behind the full ledger when the network partitions or participation is low, but catches up when the network heals. Clients adopt the ledger that provides the property (accountable safety under network partition, or liveness under dynamic participation) which they value more.</p>

    <p class="text-gray-300">In this section, we show that Goldfish can indeed be used as an underlay chain in conjunction with an overlay finality/accountability gadget, and that the so composed protocol satisfies the design goal for Gasper, the ebb-and-flow formulation <em>[60, 61]</em>. Specifically, for ease of exposition, since the focus of this paper is on designing a new underlay, Goldfish, rather than designing the gadget/overlay and the checkpointing interaction between underlay and overlay, and since we are not aware of any formal work showing how to apply Casper to an underlay chain to obtain a secure ebb-and-flow protocol, we instead reuse finality/accountability gadgets from the literature <em>[60, 61, 69]</em>. Given their earlier analyses, the primary job left to do for us as designers of the Goldfish underlay, is to show that Goldfish ‘heals’ (to be made precise below) after network partition and in conjunction with the gadget (i.e., despite the gadget’s influence over the underlay).</p>

    <p class="text-gray-300">App. D.1 presents the formal model and problem formulation. App. D.2 describes the composition of Goldfish with accountability gadgets <em>[61]</em>. A security proof for the composition is presented in Apps. D.3, D.4, D.5 and D.6.</p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">D.1 Model</h3>

    <h4 id="sec-46" class="text-lg font-semibold mt-6">D.1.1 Partial Synchrony</h4>

    <p class="text-gray-300">Security under a partially synchronous network captures the resilience of the consensus protocol against network partitions. A partially synchronous network in the sleepy model <em>[60]</em> is characterized by a global stabilization time (<span class="math">\\mathsf{GST}</span>), a global awake time (<span class="math">\\mathsf{GAT}</span>), and a delay upper-bound <span class="math">\\Delta</span>. <span class="math">\\mathsf{GST}</span> and <span class="math">\\mathsf{GAT}</span> are constants unknown to the honest validators chosen adaptively by the adversary, i.e., as causal functions of the execution, whereas <span class="math">\\Delta</span> is a constant known to the validators. Before <span class="math">\\mathsf{GST}</span>, message delays are arbitrarily adversary (asynchronous). After <span class="math">\\mathsf{GST}</span>, message delays are subject to the delay upper bound <span class="math">\\Delta</span> (synchronous). Similarly, before <span class="math">\\mathsf{GAT}</span>, the adversary can set the sleep schedule for honest validators. After <span class="math">\\mathsf{GAT}</span>, all honest validators are awake.</p>

    <h4 id="sec-47" class="text-lg font-semibold mt-6">D.1.2 Security</h4>

    <p class="text-gray-300">We next formalize the notion of security <em>after a certain time</em>, generalizing Def. 1. Security is parameterized by <span class="math">\\kappa</span>, which, for longest-chain protocols and Goldfish, determines the confirmation delay for transactions (<em>i.e.</em>, these protocols come with a security–latency trade-off). We consider a finite time horizon <span class="math">T_{\\mathrm{hor}}</span> that is polynomial in <span class="math">\\kappa</span>. We denote a consensus protocol’s output ledger, <em>e.g.</em>, the Goldfish ledger, in the view of a validator <span class="math">i</span> at round <span class="math">r</span> by <span class="math">\\mathsf{ch}_{r}^{i}</span>. We write <span class="math">\\mathsf{ch}_{1}\\preceq\\mathsf{ch}_{2}</span> to express that the ledger <span class="math">\\mathsf{ch}_{1}</span> is a prefix of (or the same as) ledger <span class="math">\\mathsf{ch}_{2}</span>.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Definition 3 (Security)</h6>

    <p class="text-gray-300">Let <span class="math">T_{\\mathrm{conf}}</span> be a polynomial function of the security parameter <span class="math">\\kappa</span>. A state machine replication protocol that outputs a ledger <span class="math">\\mathsf{ch}</span> is <em>secure after time</em> <span class="math">T_{\\mathsf{sec}}</span>, and has transaction confirmation time <span class="math">T_{\\mathrm{conf}}</span>, iff: Safety: For any two rounds <span class="math">r,r^{\\prime}\\geq T_{\\mathsf{sec}}</span>, and any two honest validators <span class="math">i,j</span> awake at rounds <span class="math">r</span> and <span class="math">r^{\\prime}</span>, respectively, either <span class="math">\\mathsf{ch}_{r}^{i}\\preceq\\mathsf{ch}_{r^{\\prime}}^{j}</span> or <span class="math">\\mathsf{ch}_{r^{\\prime}}^{j}\\preceq\\mathsf{ch}_{r}^{i}</span>. Liveness: If a transaction has been received by some awake honest validator by some round <span class="math">r\\geq T_{\\mathsf{sec}}</span>, then for any round <span class="math">r^{\\prime}\\geq r+T_{\\mathrm{conf}}</span> and any honest validator <span class="math">i</span> awake at round <span class="math">r^{\\prime}</span>, the transaction will be included in <span class="math">\\mathsf{ch}_{r^{\\prime}}^{i}</span>.</p>

    <p class="text-gray-300">The protocol satisfies <em><span class="math">\\bar{f}</span>-safety</em> (<span class="math">\\bar{f}</span>-liveness) <em>if it satisfies safety (liveness) as long as the number of adversary validators <span class="math">f</span> stays below <span class="math">\\bar{f}</span> for all rounds. It satisfies </em><span class="math">1/2</span>-safety<em> (<span class="math">1/2</span>-liveness) if it satisfies safety (liveness) if the fraction of adversary validators <span class="math">\\beta</span> is bounded above away from <span class="math">1/2</span> for all rounds.</em></p>

    <h4 id="sec-49" class="text-lg font-semibold mt-6">D.1.3 Accountable Safety</h4>

    <p class="text-gray-300">Accountable safety provides a <em>trust-minimizing</em> strengthening of safety, with the aim to hold validators accountable for their actions. In a protocol with accountable safety resilience <span class="math">\\bar{f}&gt;0</span>, after a safety violation, one can, upon collecting evidence from sufficiently many honest validators, generate a cryptographic proof that identifies <span class="math">\\bar{f}</span> adversary validators as protocol violators <em>[61, 71]</em>. By definition, the proof does not falsely accuse any honest validator, except with negligible probability.</p>

    <h4 id="sec-50" class="text-lg font-semibold mt-6">D.1.4 The Ebb-and-Flow Formulation</h4>

    <p class="text-gray-300">As Goldfish outputs a <em>dynamically available</em> ledger (<em>i.e.</em>, live under dynamic participation), by the availability-accountability dilemma <em>[61]</em>, its output ledger cannot satisfy accountable safety. Similarly, it cannot satisfy safety under a partially synchronous network (<em>i.e.</em>, <em>finality</em>), by an analogue of the CAP theorem <em>[34, 44]</em>. However, Goldfish can be used as an underlay composed with an accountability gadget as overlay (cf. Figs. 1 and 7) in order to obtain a separate prefix ledger that attains accountable safety under partial synchrony while staying consistent with the output of Goldfish <em>[61]</em>. Denoting the output of Goldfish as the available ledger <span class="math">\\mathsf{ch}_{\\mathrm{ava}}</span> and that of the accountability gadget as the accountable final prefix ledger <span class="math">\\mathsf{ch}_{\\mathrm{acc}}</span>, the desiderata are captured in the <em>ebb-and-flow formulation</em> <em>[60]</em>:</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Definition 4 (Ebb-and-flow formulation <em>[60, 61]</em>).</h6>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(P1: Accountability and finality) Under a partially synchronous network in the sleepy model, the accountable final prefix ledger <span class="math">\\mathsf{ch}_{\\mathrm{acc}}</span> has accountabl</li>

    </ol>

    <p class="text-gray-300">Francesco D'Amato, Joachim Neu, Ertem Nusret Tas, and David Tse</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Fig. 7. An accountability/finality gadget (AG/FG, a.k.a. overlay, like Casper) checkpoints decisions of the dynamically available protocol Goldfish (a.k.a. underlay) (cf. Fig. 1). A feedback loop ensures that Goldfish respects earlier checkpoints. This construction satisfies the ebb-and-flow design objective of Ethereum, to produce an available full ledger that is secure under dynamic participation of validators, and a prefix ledger that is accountability secure under network partition [60, 61].</p>

    <p class="text-gray-300">Algorithm 5 GHOST-Eph (cf. Alg. 3) modified (green) to respect the latest checkpoint  <span class="math">B</span> . See Alg. 3 for CHILDREN and VOTES.</p>

    <pre><code class="language-txt">1: function GHOST-EPH(T, t, B)
2:  $\\triangleright$  Start fork-choice from latest checkpoint  $B$
3: forever do
4:  $\\triangleright$  Choose the heaviest subtree rooted (breaking ties deterministically) at one of the children blocks  $B&#x27;$  of  $B$ , by number of validators that have cast a vote in slot  $t$  into the subtree rooted at  $B&#x27;$ ;  $B&#x27; = \\bot$  if CHILDREN(T, B) =  $\\emptyset$
5:  $B&#x27; \\gets \\arg \\max_{B&#x27; \\in \\mathrm{CHILDREN}(T, B)} \\mathrm{VOTES}(T, B&#x27;, t)$
6: if  $B&#x27; = \\bot$  then return  $B$
7:  $B \\gets B&#x27;$</code></pre>

    <p class="text-gray-300">safety resilience  <span class="math">n/3</span>  at all times, (except w.p.  <span class="math">\\mathrm{negl}(\\lambda)</span> ), and there exists a constant  <span class="math">\\mathbf{C}</span>  such that  <span class="math">\\mathsf{ch}_{\\mathrm{acc}}</span>  provides  <span class="math">n/3</span> -liveness with confirmation time  <span class="math">T_{\\mathrm{conf}}</span>  after round  <span class="math">\\max(\\mathsf{GST}, \\mathsf{GAT}) + \\mathbf{C} \\cdot \\kappa</span>  (w.o.p.).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(P2: Dynamic availability) Under a synchronous network in the sleepy model (i.e., for  <span class="math">\\mathsf{GST} = 0</span> ), the available ledger  <span class="math">\\mathsf{ch}_{\\mathrm{ava}}</span>  provides  <span class="math">1/2</span> -safety and  <span class="math">1/2</span> -liveness at all times (w.o.p.).</li>

      <li>(Prefix) For each honest id and round  <span class="math">r</span> ,  <span class="math">\\mathsf{ch}_{\\mathrm{acc},r}^{\\mathrm{id}} \\preceq \\mathsf{ch}_{\\mathrm{ava},r}^{\\mathrm{id}}</span> .</li>

    </ol>

    <p class="text-gray-300">The accountable final prefix ledger  <span class="math">\\mathsf{ch}_{\\mathrm{acc}}</span>  can experience liveness violations before GST or GAT, due to lack of timely communication among sufficiently many honest validators, but  <span class="math">\\mathsf{ch}_{\\mathrm{acc}}</span>  remains accountability safe throughout. The available ledger  <span class="math">\\mathsf{ch}_{\\mathrm{ava}}</span>  can experience safety violations before GST, but remains live throughout. When conditions improve,  <span class="math">\\mathsf{ch}_{\\mathrm{acc}}</span>  catches up with  <span class="math">\\mathsf{ch}_{\\mathrm{ava}}</span> . This ebb-and-flow behavior lends the formulation its name. Providing the irreconcilable properties in two separate but consistent ledgers provides a user-dependent resolution to the CAP theorem [34, 44].</p>

    <p class="text-gray-300">For the composition of Goldfish with accountability gadgets, we follow the construction of [61, 69] (Fig. 7, Alg. 6). In this construction, a partially synchronous accountability-safe consensus protocol such as Streamlet, Tendermint, or HotStuff [11, 19, 58, 74], with accountable safety resilience of  <span class="math">n/3</span>  out of  <span class="math">n</span>  validation</p>

    <p class="text-gray-300">Goldfish: No More Attacks on Ethereum?!</p>

    <p class="text-gray-300">Algorithm 6 Composition of Goldfish and accountability gadget (cf. Fig. 7, [61, Alg. 1]), executed by validator id. Here, Goldfish (cf. Alg. 2) uses a modified GHOST-Eph rule (Alg. 5), starting the recursion from the latest checkpoint, i.e., the last block of  <span class="math">\\mathsf{ch}_{\\mathrm{acc}}^{\\mathrm{id}}</span> . Throughout, Goldfish maintains the available chain  <span class="math">\\mathsf{ch}_{\\mathrm{ava}}^{\\mathrm{id}}</span> . RUNACCOUNTABILITYGADGET attempts the next iteration of the gadget, where valid checkpoint candidates are determined using  <span class="math">\\mathsf{ch}_{\\mathrm{ava}}^{\\mathrm{id}}</span> . Iterations may fail  <span class="math">(\\perp)</span> , e.g., if the gadget invokes a malicious leader.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1: chidacc← B0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ ‘Zero-th’ checkpoint: Goldfish’s genesis block</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2: for c = 1, 2, ... do</td>

            <td class="px-3 py-2 border-b border-gray-700">▷ Checkpoint iterations</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  3: checkpoint ← RUNACCOUNTABILITYGADGET(chidava) |   |</p>

    <p class="text-gray-300">|  4: if checkpoint ≠ ⊥ then |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5: chidacc← checkpoint</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Update latest checkpoint</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  6: Sleep for Tchkpt rounds |   |</p>

    <p class="text-gray-300">tors, is used to determine checkpoints of Goldfish's output ledger. To ensure that Goldfish respects earlier checkpoints, its fork-choice rule is modified to respect earlier checkpoint decisions (cf. Alg. 5). The most recent checkpoint forms the accountability-safe finalized prefix ledger  <span class="math">\\mathsf{ch}_{\\mathrm{acc}}</span> , while Goldfish's output forms the dynamically available full ledger  <span class="math">\\mathsf{ch}_{\\mathrm{ava}}</span>  (cf. ebb-and-flow, Def. 4). As Goldfish now respects checkpoints,  <span class="math">\\mathsf{ch}_{\\mathrm{acc}} \\preceq \\mathsf{ch}_{\\mathrm{ava}}</span>  holds.</p>

    <p class="text-gray-300">The full protocol proceeds in checkpointing iterations (cf. Alg. 6). Iterations may fail, e.g., when the consensus protocol of the gadget invokes a malicious leader, or during asynchrony before GST, or while many validators are asleep before GAT. Successful checkpoint iterations are separated by at least  <span class="math">T_{\\mathrm{chkpt}}</span>  rounds of inactivity of the gadget. In the following sections, we apply the techniques of earlier analyses [61, 69] to the combination of Goldfish and the accountability gadget, to show how to tune  <span class="math">T_{\\mathrm{chkpt}}</span>  as a function of the network delay  <span class="math">\\Delta</span>  and the confirmation parameter  <span class="math">\\kappa</span> , and to formally prove that the combination satisfies the ebb-and-flow desiderata:</p>

    <p class="text-gray-300">Theorem 7 (Ebb-and-flow property). Goldfish combined with accountability gadgets (cf. App. D.2) satisfies the ebb-and-flow property of Def. 4.</p>

    <p class="text-gray-300">Proof of Thm. 7 is provided in Apps. D.3, D.4, D.5 and D.6. It follows the same blueprint as the original construction of accountability gadgets in [61, Appendices B, C].</p>

    <p class="text-gray-300">Fast Confirmation Rule and Accountability Gadgets. When composing accountability gadgets and Goldfish with the fast confirmation rule, we stipulate that the validators input to the gadget only those blocks confirmed via the standard confirmation rule (GHOST-EPH <span class="math">(\\mathcal{T},t)^{\\lceil \\kappa \\rceil}</span> ) in their view. This is necessary to ensure that all honest validators promptly agree on the confirmation status of the blocks input to the gadget for checkpointing, which in turn is a prerequisite for the liveness of the accountable final prefix ledger  <span class="math">\\mathsf{ch}_{\\mathrm{acc}}</span> . Otherwise, it is possible that a block fast confirmed by one honest validator might not become confirmed in the view of another honest validator until after  <span class="math">\\kappa</span>  slots, stalling the checkpointing process of the accountability gadget for that block. Thus, the fast confirmation rule is primarily for reducing the latency of the available ledger</p>

    <p class="text-gray-300">ch_{ava}, and does not affect the time for a block to enter the accountable final prefix ledger ch_{acc}.</p>

    <h3 id="sec-53" class="text-xl font-semibold mt-8">D.3 Overview of the Analysis</h3>

    <p class="text-gray-300">Recall that in Goldfish with accountability gadgets, the fork-choice rule of Goldfish is modified to respect earlier checkpoint decisions (Alg. 5). This modification requires adjustments of the analysis of Goldfish, because it opens up the possibility that for a proposal <span class="math">P^{<em>}</span> by an honest leader, <span class="math">P^{</em>}.B\\preceq B</span> no longer holds for all blocks <span class="math">B</span> identified in Alg. 2, ll. 8, 22, 28 by awake honest validators at future rounds, due to a new checkpoint conflicting with <span class="math">P^{*}.B</span>.</p>

    <p class="text-gray-300">In the synchronous sleepy network model, Sec. 4 implies that ch_{ava} remains secure until the first checkpoint is determined. Therefore, checkpoints cannot undermine its security since only confirmed blocks in ch_{ava} are approved for checkpointing by honest validators (App. D.4 for formal analysis). However, when GST <span class="math">&gt;0</span>, one cannot directly rely on the analysis of Goldfish under synchrony. In this case, to prevent checkpoints from undermining the security, and rigorously argue security for the combination despite the modified fork-choice rule, the framework of accountability gadgets <em>[61, 69]</em> relies on two principles:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Gap property: After a (successful) checkpointing iteration with a new checkpoint, honest validators wait for <span class="math">T_{\\text{chkpt}}=\\Theta(\\kappa)</span> rounds before participating in the next iteration.</li>

      <li>Recency property: For checkpointing, honest validators suggest and approve only the blocks that were <em>recently</em> confirmed as part of ch_{ava}.</li>

    </ul>

    <p class="text-gray-300">We prove that once the network heals and honest validators become awake at round <span class="math">\\max(\\textsf{GST},\\textsf{GAT})</span>, ch_{ava} regains its security with the help of these properties, a feature called the <em>healing property</em>. The healing property, together with the liveness of the accountability gadget’s consensus protocol imply the liveness of ch_{acc} in the partially synchronous sleepy network model (App. D.5 for formal analysis). Finally, accountable safety of ch_{acc} follows from the accountable safety of the gadget. Security of ch_{ava} under the synchronous sleepy network model, accountable safety of ch_{acc} and its liveness after <span class="math">\\max(\\textsf{GST},\\textsf{GAT})</span> together imply the ebb-and-flow property, <em>i.e.</em> Theorem Thm. 7 (App. D.6).</p>

    <p class="text-gray-300">We now formally prove the ebb-and-flow property for Goldfish combined with accountability gadgets (Fig. 7). The following analysis extensively refers to the details of the accountability gadgets described in <em>[61, Section 4]</em>. To distinguish the votes cast by validators as part of the accountability gadget iterations from those broadcast within Goldfish, we will refer to the former as <em>gadget votes</em>. Similarly, to distinguish the leaders of accountability gadget iterations from the leaders of Goldfish slots, we will refer to the former as the <em>iteration leaders</em>. We refer the reader to <em>[61]</em> for the accountability gadget specific definitions of the timeout parameter <span class="math">T_{\\text{tmout}}</span> and the confirmation delay <span class="math">T_{\\textsf{bft}}</span> of the BFT protocol. We highlight that honest iteration leaders propose only the blocks <span class="math">B^{<em>}</span> that are </em>confirmed<em> in their view of ch_{ava}, </em>i.e.<em>, <span class="math">B^{</em>}\\preceq B^{\\lceil\\kappa}</span> for <span class="math">B</span> identified in Alg. 2, ll. 8, 22, 28 run using ch_{ava}. Similarly, honest validators send accepting gadget votes</p>

    <p class="text-gray-300">only for the checkpointing proposals that are <em>confirmed</em> in their view of <span class="math">\\mathsf{ch}_{\\mathrm{ava}}</span>. We set <span class="math">T_{\\mathrm{chkpt}}</span>, the time gap between the accountability gadget iterations, to be at least <span class="math">6\\pazocal{\\Delta}(\\kappa+1)+T_{\\mathrm{tmout}}+T_{\\mathsf{bft}}</span> (this is necessary for proving the ebb-and-flow property as will be evident in the following proofs). This makes the upper bound <span class="math">T_{\\mathrm{upper}}</span> on the total duration of an iteration <span class="math">T_{\\mathrm{chkpt}}+T_{\\mathrm{tmout}}+T_{\\mathsf{bft}}=6\\pazocal{\\Delta}(\\kappa+1)+2(T_{\\mathrm{tmout}}+T_{\\mathsf{bft}})=\\Theta(\\kappa)</span>.</p>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">D.4 Security of <span class="math">\\mathsf{ch}_{\\mathrm{ava}}</span> under the Synchronous Sleepy Network Model</h3>

    <p class="text-gray-300">We first show that <span class="math">\\mathsf{ch}_{\\mathrm{ava}}</span> remains secure under synchrony in the sleepy network model, despite the added gadget.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Proposition 2</h6>

    <p class="text-gray-300">Suppose a <span class="math">(\\frac{1}{2},3\\pazocal{\\Delta})</span>-compliant execution of Goldfish in the synchronous sleepy network model of Sec. 2. If a block <span class="math">B</span> is observed to be checkpointed by an honest validator for the first time at some round <span class="math">r</span>, then <span class="math">B</span> is in the common prefix of the chains identified in Alg. 2, ll. 8, 22, 28 right before round <span class="math">r</span> by all awake honest validators.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">Since the execution is <span class="math">(\\frac{1}{2},3\\pazocal{\\Delta})</span>-compliant, for a block to become checkpointed, at least one honest validator must have sent an accepting gadget vote for that block. Let <span class="math">B_{i}</span> denote the sequence of checkpointed blocks listed in the order of the rounds <span class="math">r_{i}</span> at which, an awake honest validator observed <span class="math">B_{i}</span> to be checkpointed for the first time. Proof is by induction on these blocks’ indices.</p>

    <h4 id="sec-57" class="text-lg font-semibold mt-6">Induction Hypothesis</h4>

    <p class="text-gray-300"><span class="math">B_{i}</span> is in the common prefix of the chains identified in Alg. 2, ll. 8, 22, 28 right before round <span class="math">r_{i}</span> by all awake honest validators, and stays so until at least round <span class="math">r_{i+1}</span>.</p>

    <h4 id="sec-58" class="text-lg font-semibold mt-6">Base Case</h4>

    <p class="text-gray-300">Since an honest validator sends an accepting gadget vote only for a confirmed block (<em>i.e.</em>, <span class="math">\\kappa</span> slots deep), <span class="math">B_{1}</span> must have been confirmed by an honest validator at some slot <span class="math">t_{1}</span> before round <span class="math">r_{1}</span>. As all honest validators start the fork-choice at the genesis block prior to <span class="math">r_{1}</span> and <span class="math">B_{1}</span> is confirmed in an honest view, it is in the prefix of a block proposed by an honest leader by Lem. 1 and Thm. 1. Hence, <span class="math">B_{1}</span> is in the common prefix of the chains identified in Alg. 2, ll. 8, 22, 28 right before round <span class="math">r_{1}</span> by all awake honest validators. It also stays in the common prefix until at least round <span class="math">r_{2}</span>.</p>

    <h4 id="sec-59" class="text-lg font-semibold mt-6">Inductive Step</h4>

    <p class="text-gray-300">By the induction hypothesis, checkpointing of the blocks <span class="math">B_{1},\\ldots,B_{i-1}</span> does not alter the fork-choice rule at Alg. 5, l. 2 for any awake honest validator. Hence, by the same reasoning above, <span class="math">B_{i}</span> is in the common prefix of the chains identified in Alg. 2, ll. 8, 22, 28 right before round <span class="math">r_{i}</span> by all awake honest validators, and stays so until at least round <span class="math">r_{i+2}</span>. ∎</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Lemma 6 (Safety and liveness of <span class="math">\\mathsf{ch}_{\\mathrm{ava}}</span> under synchrony)</h6>

    <p class="text-gray-300">Suppose a <span class="math">(\\frac{1}{2},3\\pazocal{\\Delta})</span>-compliant execution of Goldfish in the synchronous sleepy network model of Sec. 2. Then, w.o.p., the available ledger <span class="math">\\mathsf{ch}_{\\mathrm{ava}}</span> satisfies <span class="math">1/2</span>-safety and <span class="math">1/2</span>-liveness (at all times).</p>

    <p class="text-gray-300">Francesco D'Amato, Joachim Neu, Ertem Nusret Tas, and David Tse</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">By Prop. 2, checkpointing of blocks does not alter the fork-choice rule at Alg. 5, l. 2 for any awake honest validator. Concretely, if the honest validators started the fork-choice rule from the genesis block at all rounds instead of the latest checkpoint in view, then they would end up with the same execution. Thus, the security of <span class="math">\\mathsf{ch}_{\\mathrm{ava}}</span> follows from Thm. 2. ∎</p>

    <h3 id="sec-61" class="text-xl font-semibold mt-8">D.5 Liveness of <span class="math">\\mathsf{ch}_{\\mathrm{acc}}</span> after <span class="math">\\max(\\mathsf{GST},\\mathsf{GAT})</span></h3>

    <p class="text-gray-300">We next demonstrate the liveness of <span class="math">\\mathsf{ch}_{\\mathrm{acc}}</span> after <span class="math">\\max(\\mathsf{GST},\\mathsf{GAT})</span>. In the subsequent analysis, the total number of validators is denoted by <span class="math">n</span> (cf. Sec. 2). The accountability gadget is instantiated with a BFT protocol that has an accountable safety resilience of <span class="math">n/3</span>.</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Proposition 3 (Prop. 2 of <em>[61]</em>).</h6>

    <p class="text-gray-300">The BFT protocol satisfies <span class="math">n/3</span>-liveness after <span class="math">\\max(\\mathsf{GST},\\mathsf{GAT})</span> with transaction confirmation time <span class="math">T_{\\mathsf{bft}}&amp;lt;\\infty</span>.</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Proposition 4 (Prop. 3 of <em>[61]</em>).</h6>

    <p class="text-gray-300">Consider a <span class="math">(\\frac{1}{3},3\\Delta)</span>-compliant execution of Goldfish in the partially synchronous sleepy network model of Sec. 2. Suppose a block from iteration <span class="math">c</span> was checkpointed in the view of an honest validator at round <span class="math">r</span>. Then, every honest validator enters iteration <span class="math">c+1</span> by round <span class="math">\\max(\\mathsf{GST},\\mathsf{GAT},r)+\\Delta</span>.</p>

    <p class="text-gray-300">Let <span class="math">c^{\\prime}</span> be the largest iteration such that a block <span class="math">B</span> was checkpointed in the view of some honest validator before <span class="math">\\max(\\mathsf{GAT},\\mathsf{GST})</span>. (Let <span class="math">c^{\\prime}=0</span> and <span class="math">B</span> be the genesis block if there does not exist such an iteration.) If an honest validator enters an iteration <span class="math">c^{\\prime\\prime}&amp;gt;c^{\\prime}</span> at some round <span class="math">r\\geq\\max(\\mathsf{GAT},\\mathsf{GST})+\\Delta+T_{\\mathrm{chkpt}}</span>, every honest validator enters iteration <span class="math">c^{\\prime\\prime}</span> by round <span class="math">r+\\Delta</span>.</p>

    <p class="text-gray-300">Proof of Prop. 4 follows from the proof of <em>[61, Prop. 3]</em>.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose a block <span class="math">B</span> from iteration <span class="math">c</span> was checkpointed in the view of an honest validator <span class="math">\\mathsf{id}</span> at round <span class="math">r</span>. Then, there are over <span class="math">2n/3</span> accepting gadget votes for <span class="math">B</span> from iteration <span class="math">c</span> on <span class="math">\\mathsf{LOG}_{\\mathsf{bft},\\mathsf{id}}^{\\tau}</span>, the output ledger of the BFT protocol in <span class="math">\\mathsf{id}</span>’s view at round <span class="math">r</span>. All gadget votes and BFT protocol messages observed by <span class="math">\\mathsf{id}</span> by round <span class="math">r</span> are delivered to all other honest validators by round <span class="math">\\max(\\mathsf{GST},\\mathsf{GAT},r)+\\Delta</span>. Hence, by the safety of the BFT protocol when <span class="math">f&lt;n 3</span>, <span class="math">\\mathsf{id}^{\\prime}</span>="" <span class="math">\\mathsf{id}^{\\prime}</span>,="" <span class="math">c+1</span>="" <span class="math">c^{\\prime}=&quot;&quot; </span>c^{\\prime\\prime}="" <span class="math">d</span>="" <span class="math">d^{\\prime}</span>,="" <span class="math">e</span>="" <span class="math">f</span>="" <span class="math">i\\mathsf{d}^{\\prime}</span>="" <span class="math">r=&quot;&quot; </span>r\\geq\\max(\\mathsf{gat},\\mathsf{gst})+\\delta<span class="math">.=&quot;&quot; </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{d}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">,=&quot;&quot; (and=&quot;&quot; *[61,=&quot;&quot; 3=&quot;&quot; 3,=&quot;&quot; 61,=&quot;&quot; \\mathsf{id}</span>="" \\mathsf{id}^{\\prime}<span class="math">,=&quot;&quot; \\mathsf{id}^{\\prime}</span>,="" \\mathsf{id}^{\\prime}<span class="math">,=&quot;&quot; \\mathsf{id}^{\\prime}</span>.="" \\mathsf{id}^{\\prime}<span class="math">,=&quot;&quot; \\mathsf{id}^{\\prime}</span>,="" \\mathsf{id}^{\\prime}<span class="math">;=&quot;&quot; a=&quot;&quot; above,=&quot;&quot; accepted=&quot;&quot; according=&quot;&quot; all=&quot;&quot; an=&quot;&quot; and=&quot;&quot; any=&quot;&quot; are=&quot;&quot; as=&quot;&quot; at=&quot;&quot; become=&quot;&quot; become=&quot;&quot; be=&quot;&quot; become=&quot;&quot; become:=&quot;&quot; be,=&quot;&quot; because=&quot;&quot; be.=&quot;&quot; by=&quot;&quot; can=&quot;&quot; check=&quot;&quot; checkpoint=&quot;&quot; checkpointed=&quot;&quot; condition=&quot;&quot; condition:=&quot;&quot; condition:=&quot;&quot; condition:=&quot;&quot; cycle=&quot;&quot; cycle,=&quot;&quot; d^{\\prime}</span>,="" de="" de,="" de.="" determine="" determined="" each="" enter="" enters="" every="" for="" from="" gadget="" has="" have="" honest="" if="" implies="" in="" is="" it="" its="" j.="" j.1="" kpt}<span class="math">:=&quot;&quot; l_{\\mathsf{chkpt}}</span>:="" l_{\\mathsf{chkpt}}<span class="math">.=&quot;&quot; l_{\\mathsf{chkpt}}&lt;n=&quot;&quot; l_{\\mathsf{chkpt}}</span>.="" l_{\\mathsf{chkpt}}:="" implies="" in="" it="" its="" j.1="" kpt}<span class="math">,=&quot;&quot; know=&quot;&quot; implies=&quot;&quot; in,=&quot;&quot; it.=&quot;&quot; implies=&quot;&quot; if=&quot;&quot; implies=&quot;&quot; in}</span>="" it.="" j.1,="" kpt})<span class="math">.=&quot;&quot; kpt})&lt;n=&quot;&quot; let=&quot;&quot; let,=&quot;&quot; make=&quot;&quot; max(\\mathsf{gat},\\mathsf{gst})+\\delta</span>.="" max(\\mathsf{gat},\\mathsf{gst})+\\delta+t_{\\mathsf{chkpt}},<span class="math">=&quot;&quot; max}(\\mathsf{gat},r)+\\delta</span>.="" n.="" of="" on="" or="" over="" p.="" prefix="" round="" runs="" same="" say="" say,="" second="" show="" shows="" since="" some="" synch="" synch.="" synch.2="" that="" the="" then="" there="" this="" thus,="" time="" to="" v="" v.2="" was="" we="" when="" which="" with="" without="" x="" z.="" z.2="" z.3="">c^{\\prime}<span class="math"> at some round </span>r\\geq\\max(\\mathsf{GAT},\\mathsf{GST})+\\Delta+T_{\\mathrm{chkpt}}<span class="math">, every honest validator enters iteration </span>c^{\\prime\\prime}<span class="math"> by round </span>r+\\Delta<span class="math">. Similarly, if a block from iteration </span>c^{\\prime\\prime}<span class="math"> is first checkpointed in the view of an honest validator at some round after </span>\\max(\\mathsf{GAT},\\mathsf{GST})+\\Delta+T_{\\mathrm{chkpt}}<span class="math">, then it is checkpointed in the view of all honest validators within </span>\\Delta$ rounds. ∎</n></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-65" class="text-base font-medium mt-4">Lemma 7 (Liveness of <span class="math">\\mathsf{ch}_{\\mathrm{acc}}</span>, analogue of Thm. 4 of <em>[61]</em>).</h6>

    <p class="text-gray-300">Consider a <span class="math">(\\frac{1}{3},3\\Delta)</span>-compliant execution of Goldfish in the partially synchronous sleepy network model of Sec. 2. Suppose <span class="math">\\mathsf{ch}_{\\mathrm{ava}}</span> is secure (safe and live) after some round <span class="math">T_{\\mathsf{heal}}\\geq\\max(\\mathsf{GST},\\mathsf{GAT})+\\Delta+T_{\\mathrm{chkpt}}</span>. Then, w.o.p., <span class="math">\\mathsf{ch}_{\\mathrm{acc}}</span> satisfies <span class="math">n/3</span>-liveness after round <span class="math">T_{\\mathsf{heal}}</span> with transaction confirmation time <span class="math">T_{\\mathrm{conf}}=\\Theta(\\kappa^{2})</span>.</p>

    <p class="text-gray-300">Proof of Lem. 7 follows from the proof of <em>[61, Thm. 4]</em>.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By Prop. 3, <span class="math">\\mathsf{LOG}_{\\mathrm{bft}}</span> is live with transaction confirmation time <span class="math">T_{\\mathsf{bft}}</span> after <span class="math">\\max(\\mathsf{GST},\\mathsf{GAT})</span>, a fact we will use subsequently.</p>

    <p class="text-gray-300">Let <span class="math">c^{\\prime}</span> be the largest iteration such that a block <span class="math">B</span> was checkpointed in the view of some honest validator before <span class="math">\\max(\\mathsf{GAT},\\mathsf{GST})</span> (Let <span class="math">c^{\\prime}=0</span> and <span class="math">B</span> be the genesis block if there does not exist such an iteration). Then, by Prop. 4, entrance times of the honest validators to subsequent iterations become synchronized by round <span class="math">\\max(\\mathsf{GAT},\\mathsf{GST})+\\Delta+T_{\\mathrm{chkpt}}</span>: If an honest validator enters an iteration <span class="math">c&gt;c^{\\prime}</span> at some round <span class="math">r\\geq\\max(\\mathsf{GAT},\\mathsf{GST})+\\Delta+T_{\\mathrm{chkpt}}</span>, every honest validator enters iteration <span class="math">c</span> by round <span class="math">r+\\Delta</span>.</p>

    <p class="text-gray-300">Suppose an iteration <span class="math">c&gt;c^{\\prime}</span> has an honest iteration leader <span class="math">\\mathrm{L}^{(c)}</span>, which sends a checkpoint proposal, denoted by <span class="math">\\hat{b}_{c}</span>, at some round <span class="math">r&gt;T_{\\mathsf{heal}}+T_{\\mathrm{chkpt}}</span>. The proposal <span class="math">\\hat{b}_{c}</span> is received by every honest validator by round <span class="math">r+\\Delta</span>. Since the entrance times of the validators are synchronized by <span class="math">T_{\\mathsf{heal}}\\geq\\max(\\mathsf{GST},\\mathsf{GAT})+\\Delta+T_{\\mathrm{chkpt}}</span>, every honest validator sends a gadget vote by round <span class="math">r+\\Delta</span>. By Lem. 9, <span class="math">\\hat{b}_{c}\\preceq B^{\\lfloor\\kappa}</span> for any <span class="math">B</span> identified in Alg. 2, ll. 8, 22, 28 by any awake honest validator after <span class="math">r</span>. Moreover, <span class="math">\\hat{b}_{c}</span> is a descendant all of the checkpoints seen by the honest validators until then. Consequently, at iteration <span class="math">c</span>, every honest validator sends a gadget vote accepting <span class="math">\\hat{b}_{c}</span> by round <span class="math">r+\\Delta</span>, all of which appear within <span class="math">\\mathsf{LOG}_{\\mathrm{bft}}</span> in the view of every honest validator by round <span class="math">r+\\Delta+T_{\\mathsf{bft}}</span>. Thus, <span class="math">\\hat{b}_{c}</span> becomes checkpointed in the view of every honest validator by round <span class="math">r+\\Delta+T_{\\mathsf{bft}}</span>. (Here, we assume that <span class="math">T_{\\mathrm{tmout}}</span> was chosen large enough for <span class="math">T_{\\mathrm{tmout}}&gt;\\Delta+T_{\\mathsf{bft}}</span> to hold.)</p>

    <p class="text-gray-300">Since <span class="math">r&gt;T_{\\mathsf{heal}}+T_{\\mathrm{chkpt}}</span>, by Lem. 9, <span class="math">\\hat{b}_{c}</span> contains at least one honest block since an earlier checkpointed block in its prefix from before iteration <span class="math">c</span>. This implies that the prefix of <span class="math">\\hat{b}_{c}</span> contains at least one fresh honest block that enters <span class="math">\\mathsf{ch}_{\\mathrm{acc}}</span> by round <span class="math">r+\\Delta+T_{\\mathsf{bft}}</span>.</p>

    <p class="text-gray-300">Next, we show that an adversary leader cannot make an iteration last longer than <span class="math">\\Delta+T_{\\mathrm{tmout}}+T_{\\mathsf{bft}}</span> for any honest validator after the initial <span class="math">T_{\\mathrm{chkpt}}</span> period elapsed. Indeed, if an honest validator <span class="math">\\mathsf{id}</span> enters an iteration <span class="math">c</span> at round <span class="math">r-T_{\\mathrm{chkpt}}</span>, by round <span class="math">r+T_{\\mathrm{tmout}}</span>, either it sees a block (potentially <span class="math">\\bot</span>) become checkpointed for iteration <span class="math">c</span>, or it sends a reject vote for iteration <span class="math">c</span>. In the first case, every honest validator sees a block checkpointed for iteration <span class="math">c</span> by round at most <span class="math">r+T_{\\mathrm{tmout}}+\\Delta</span>. In the second case, rejecting gadget votes from over <span class="math">2n/3&gt;n/3</span> validators appear in <span class="math">\\mathsf{LOG}_{\\mathrm{bft}}</span> in the view of every honest validator by round at most <span class="math">r+T_{\\mathrm{tmout}}+\\Delta+T_{\\mathsf{bft}}</span>. Hence, a new checkpoint, potentially <span class="math">\\bot</span>, is output in the view of every honest validator by round <span class="math">r+T_{\\mathrm{tmout}}+\\Delta+T_{\\mathsf{bft}}</span>.</p>

    <p class="text-gray-300">Finally, we observe that except with probability <span class="math">(1/3)^{\\kappa}</span>, there exists a checkpoint iteration with an honest leader within <span class="math">\\kappa</span> consecutive iterations. Since an iteration lasts at most <span class="math">\\max(\\Delta+T_{\\mathrm{tmout}}+T_{\\mathsf{bft}},\\Delta+T_{\\mathrm{chkpt}}+T_{\\mathsf{bft}})\\leq\\Delta+T_{\\mathrm{chkpt}}+T_{\\mathsf{bft}}</span></p>

    <p class="text-gray-300"><span class="math">T_{\\mathrm{tmout}}+T_{\\mathrm{bft}}=\\Theta(\\kappa)</span> rounds, and a new checkpoint containing a fresh honest block in its prefix appears when an iteration has an honest leader (Lem. 9), w.o.p., any transaction received by an honest validator at round <span class="math">t</span> appears within <span class="math">\\mathsf{ch}_{\\mathrm{acc}}</span> in the view of every honest validator by round at most <span class="math">t+\\kappa(\\Delta+T_{\\mathrm{tmout}}+T_{\\mathrm{bft}}+T_{\\mathrm{chkpt}})</span>. Hence, via a union bound over the total number of iterations (which is a polynomial in <span class="math">\\kappa</span>), we observe that if <span class="math">\\mathsf{ch}_{\\mathrm{ava}}</span> satisfies security after some round <span class="math">T_{\\mathsf{heal}}</span>, then w.o.p., <span class="math">\\mathsf{ch}_{\\mathrm{acc}}</span> satisfies liveness after <span class="math">T_{\\mathsf{heal}}</span> with a transaction confirmation time <span class="math">T_{\\mathrm{conf}}=\\Theta(\\kappa^{2})</span>. ∎</p>

    <p class="text-gray-300">The latency expression <span class="math">T_{\\mathrm{conf}}=\\Theta(\\kappa^{2})</span> stated in Lem. 7 is a <em>worst-case</em> latency to guarantee that an honest block enters the accountable, final prefix ledger <span class="math">\\mathsf{ch}_{\\mathrm{acc}}</span> with overwhelming probability. In the expression, the first <span class="math">\\kappa</span> term comes from the requirement to have <span class="math">T_{\\mathrm{chkpt}}=\\Theta(\\kappa)</span> slots in between the accountability gadget iterations, and the second <span class="math">\\kappa</span> term comes from the fact that it takes <span class="math">\\Theta(\\kappa)</span> iterations for the accountability gadget to have an honest iteration leader except with probability <span class="math">\\mathrm{negl}(\\kappa)</span>. The accountability gadget protocol asks honest validators to wait for <span class="math">T_{\\mathrm{chkpt}}=\\Theta(\\kappa)</span> slots in between iterations to ensure the security of the protocol, reasons for which will be evident in the proof of Lem. 9.</p>

    <p class="text-gray-300">Unlike the worst-case latency, the expected latency for an honest block to enter <span class="math">\\mathsf{ch}_{\\mathrm{acc}}</span> after <span class="math">\\mathsf{ch}_{\\mathrm{ava}}</span> regains its security would be <span class="math">\\Theta(\\kappa)</span> as each checkpointing iteration has an honest leader with probability at least <span class="math">2/3</span>. In this context, the latency of <span class="math">\\Theta(\\kappa)</span> is purely due to the requirement to have <span class="math">T_{\\mathrm{chkpt}}=\\Theta(\\kappa)</span> slots in between the accountability gadget iterations. Here, waiting for <span class="math">T_{\\mathrm{chkpt}}</span> slots in between iterations guarantees the inclusion of a new honest block in <span class="math">\\mathsf{ch}_{\\mathrm{ava}}</span>, which in turn appears in the prefix of the next checkpoint, implying a liveness event whenever there is an honest iteration leader.</p>

    <p class="text-gray-300">Lem. 7 requires the available ledger <span class="math">\\mathsf{ch}_{\\mathrm{ava}}</span> to eventually regain security under partial synchrony when there are less than <span class="math">n/3</span> adversary validators. Towards this goal, we first analyze the gap and recency properties, the core properties that must be satisfied by the accountability gadget for recovery of security of <span class="math">\\mathsf{ch}_{\\mathrm{ava}}</span>. The gap property states that the blocks are checkpointed sufficiently apart in time, controlled by the parameter <span class="math">T_{\\mathrm{chkpt}}</span>:</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Proposition 5 (Gap property, analogue of Prop. 4 of <em>[61]</em>).</h6>

    <p class="text-gray-300">Consider a <span class="math">(\\frac{1}{3},3\\Delta)</span>-compliant execution of Goldfish in the partially synchronous sleepy network model of Sec. 2. Given any round interval of size <span class="math">T_{\\mathrm{chkpt}}</span>, no more than a single block can be checkpointed in the interval in the view of any honest validator.</p>

    <p class="text-gray-300">Proof of Prop. 5 follows from the fact that upon observing a new checkpoint that is not <span class="math">\\bot</span> for an iteration, honest validators wait for <span class="math">T_{\\mathrm{chkpt}}</span> rounds before sending gadget votes for the checkpoint proposal of the next iteration, and there cannot be two conflicting checkpoints for the same iteration in the view of any honest validator.</p>

    <p class="text-gray-300">As in <em>[61]</em> and <em>[69]</em>, we state that a block <span class="math">B^{<em>}</span> checkpointed at iteration <span class="math">c</span> and round <span class="math">r&gt;\\max(\\mathsf{GST},\\mathsf{GAT})</span> in the view of an honest validator <span class="math">\\mathsf{id}</span> is <span class="math">T_{\\mathrm{rcnt}}</span>-recent if <span class="math">B^{</em>}\\preceq B^{\\lceil\\kappa}</span> for <span class="math">B</span> identified in Alg. 2, l. 28 by <span class="math">\\mathsf{id}^{\\prime}</span> at some round within <span class="math">[r-T_{\\mathrm{rcnt}},r]</span>. Then, we can express the recency property as follows:</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Lemma 8 (Recency property, analogue of Lem. 1 of <em>[61]</em>).</h6>

    <p class="text-gray-300">Consider a <span class="math">(\\frac{1}{3},3\\Delta)</span>-compliant execution of Goldfish in the partially synchronous sleepy network model of Sec. 2. Every checkpointed block proposed after <span class="math">\\max(\\mathsf{GST},\\mathsf{GAT})</span> is <span class="math">T_{\\mathrm{rcnt}}</span>-recent for <span class="math">T_{\\mathrm{rcnt}}=\\Delta+T_{\\mathrm{tmout}}+T_{\\mathsf{bft}}</span>.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By the proof of Lem. 7, if a block <span class="math">B</span> proposed after <span class="math">\\max(\\mathsf{GST},\\mathsf{GAT})</span> is checkpointed in the view of an honest validator at some round <span class="math">r</span>, it should have been proposed after round <span class="math">r-(\\Delta+T_{\\mathrm{tmout}}+T_{\\mathsf{bft}})</span>. Moreover, over <span class="math">2n/3</span> validators must have sent accepting gadget votes for <span class="math">B</span> by round <span class="math">r</span>. Let <span class="math">\\mathsf{id}</span> denote such an honest validator. It would vote for <span class="math">B</span> only after it sees the checkpoint proposal for iteration <span class="math">c</span>, <em>i.e.</em>, after round <span class="math">r-T_{\\mathrm{rcnt}}=r-(\\Delta+T_{\\mathrm{tmout}}+T_{\\mathsf{bft}})</span>, and only if the proposal is confirmed in its view. Hence, <span class="math">B</span> must be <span class="math">\\kappa</span> slots deep in the chain returned at Alg. 2, l. 28 by validator <span class="math">\\mathsf{id}</span> at some round within <span class="math">[r-T_{\\mathrm{rcnt}},r]</span>. This concludes the proof that every checkpointed block proposed after <span class="math">\\max(\\mathsf{GST},\\mathsf{GAT})</span> is <span class="math">T_{\\mathrm{rcnt}}</span>-recent. ∎</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Lemma 9 (Healing property, analogue of Thm. 5 of <em>[61]</em>).</h6>

    <p class="text-gray-300">Consider a <span class="math">(\\frac{1}{3},3\\Delta)</span>-compliant execution of Goldfish in the partially synchronous sleepy network model of Sec. 2. Then, <span class="math">\\mathsf{ch}_{\\mathrm{ava}}</span> is secure with transaction confirmation time <span class="math">T_{\\mathrm{chkpt}}+T_{\\mathrm{tmout}}+T_{\\mathsf{bft}}=\\Theta(\\kappa)</span> after round <span class="math">\\max(\\mathsf{GAT},\\mathsf{GST})+\\Delta+2T_{\\mathrm{chkpt}}</span>.</p>

    <p class="text-gray-300">Moreover, for the iteration proposal <span class="math">\\hat{b}_{c}</span> of an honest iteration leader broadcast at round <span class="math">r</span>, it holds that <span class="math">\\hat{b}_{c}\\preceq B^{\\lceil\\kappa}</span> for any <span class="math">B</span> identified in Alg. 2, ll. 8, 22, 28 by any awake honest validator after <span class="math">r</span>, and <span class="math">\\hat{b}_{c}</span> contains a fresh honest block that is not in the prefix of any checkpoint from before iteration <span class="math">c</span>.</p>

    <p class="text-gray-300">Proof of Lem. 9 is different from the proof of <em>[61, Thm. 5]</em> since the accountability gadget is applied to a longest chain protocol in <em>[61]</em>, whereas it is applied to Goldfish in our case. Therefore, the full proof is presented below.</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By <em>[61, Thm. 3]</em>, <span class="math">\\mathsf{ch}_{\\mathrm{acc}}</span> provides accountable safety with resilience <span class="math">n/3</span> except with probability <span class="math">\\mathrm{negl}(\\lambda)</span> in the partially synchronous sleepy network model. As the execution is <span class="math">(\\frac{1}{3},3\\Delta)</span>-compliant, w.o.p., no two checkpoints observed by awake honest validators conflict.</p>

    <p class="text-gray-300">Let <span class="math">c</span> be the largest iteration such that a block <span class="math">B</span> was checkpointed in the view of some honest validator before <span class="math">\\max(\\mathsf{GAT},\\mathsf{GST})</span>. (Let <span class="math">c=0</span> and <span class="math">B</span> be the genesis block if there does not exist such an iteration.) Then, by Prop. 4, if an honest validator enters an iteration <span class="math">c^{\\prime}&gt;c</span> at some round <span class="math">r\\geq\\max(\\mathsf{GAT},\\mathsf{GST})+\\Delta+T_{\\mathrm{chkpt}}</span>, every honest validator enters iteration <span class="math">c</span> by round <span class="math">r+\\Delta</span>. Let <span class="math">c^{\\prime}</span> be the first iteration such that the first honest validator to enter <span class="math">c^{\\prime}</span> enters it after round <span class="math">\\max(\\mathsf{GAT},\\mathsf{GST})+\\Delta+T_{\\mathrm{chkpt}}</span> (<em>e.g.</em>, at some round <span class="math">r</span> such that <span class="math">\\max(\\mathsf{GAT},\\mathsf{GST})+\\Delta+T_{\\mathrm{chkpt}}&lt;r&lt;\\max(\\mathsf{GAT},\\mathsf{GST})+\\Delta+2T_{\\mathrm{chkpt}}</span>). Then, all honest validators enter iteration <span class="math">c^{\\prime}</span> and agree on the last checkpointed block within <span class="math">\\Delta</span> rounds. Subsequently, the honest validators wait for <span class="math">T_{\\mathrm{chkpt}}</span> rounds before casting any gadget vote for a checkpoint proposal of iteration <span class="math">c^{\\prime}</span>, during which no block can be checkpointed (Prop. 5, gap property).</p>

    <p class="text-gray-300">By Lem. 1, w.o.p., the slot interval of length <span class="math">\\kappa</span> starting after round <span class="math">r+\\Delta</span> contains a slot <span class="math">t</span> with an honest leader and proposal <span class="math">P^{*}</span>. After round <span class="math">r\\geq\\mathsf{GST}</span></p>

    <p class="text-gray-300">all messages broadcast by honest validators are received by all honest validators within <span class="math">\\Delta</span> rounds. As honest validators agree on the last checkpointed block during the interval <span class="math">[r+\\Delta,r+T_{\\text{chkpt}}]</span>, by the absence of new checkpoints, the GHOST-Eph fork-choice rule starts at the same last checkpointed block for all honest validators during the interval (Alg. 3, l. 2). Then, by Lem. 1, w.o.p., <span class="math">P^{*}.B\\preceq B</span> for any <span class="math">B</span> identified in Alg. 2, ll. 8, 22, 28 by any awake honest validator in any round after <span class="math">3\\Delta t+2\\Delta</span>, until at least a new block is checkpointed in the view of an honest validator.</p>

    <p class="text-gray-300">By Lem. 8 (recency property), the next block checkpointed in the view of an honest validator (which happens earliest at some iteration <span class="math">c^{\\prime\\prime}\\geq c^{\\prime}</span> and round <span class="math">r^{\\prime}\\geq r+T_{\\text{chkpt}}</span> by Prop. 5, the gap property) must have been confirmed by some honest validator id at some round within <span class="math">[r^{\\prime}-T_{\\text{rcnt}},r^{\\prime}]</span>, where <span class="math">r^{\\prime}-T_{\\text{rcnt}}\\geq r+6\\Delta\\kappa+4\\Delta</span>. Hence, the new checkpointed block is <span class="math">\\kappa</span> slots deep in the chains identified in Alg. 2, ll. 8, 22, 28 by id, and is a descendant of <span class="math">P^{<em>}.B</span>. This implies <span class="math">P^{</em>}.B\\preceq B</span> for any <span class="math">B</span> identified in Alg. 2, ll. 8, 22, 28 by any awake honest validator in any round after <span class="math">3\\Delta t+2\\Delta</span> indefinitely.</p>

    <p class="text-gray-300">Note that if the iteration leader was honest, for its proposal <span class="math">\\hat{b}_{c}</span> broadcast at some round <span class="math">r^{\\prime\\prime}</span>, it holds that <span class="math">\\hat{b}_{c}\\preceq B^{\\lceil\\kappa}</span> for any <span class="math">B</span> identified in Alg. 2, ll. 8, 22, 28 by any awake honest validator after round <span class="math">r</span>. Moreover, <span class="math">P^{*}.B\\preceq\\hat{b}_{c}</span>, implying that honest checkpoint proposals contain fresh honest blocks in their prefixes.</p>

    <p class="text-gray-300">Finally, we extend the above argument to future checkpoints by induction. Let <span class="math">B_{n}</span> denote the sequence of checkpointed blocks, ordered by their iteration numbers <span class="math">c_{n}\\geq c^{\\prime}</span>, <span class="math">c_{1}=c^{\\prime\\prime}</span>. The rounds <span class="math">r_{n}</span>, at which the blocks <span class="math">B_{n}</span> are first checkpointed in the view of an honest validator satisfy the relation <span class="math">r_{n+1}\\geq r_{n}+T_{\\text{chkpt}}</span> and <span class="math">r_{1}=r^{\\prime\\prime}</span>. Via the inductive assumption and the reasoning above, w.o.p., in each interval <span class="math">[r_{n}+\\Delta,r_{n+1}-T_{\\text{rcnt}}]</span>, there exists a slot <span class="math">t_{n}</span> with an honest leader and proposal <span class="math">P_{n}</span> such that <span class="math">P_{n}.B\\preceq B</span> for any <span class="math">B</span> identified in Alg. 2, ll. 8, 22, 28 by any awake honest validator in any round after <span class="math">3\\Delta t_{n}+2\\Delta</span> indefinitely. Hence, for a sufficiently large confirmation time exceeding the maximum possible iteration length <span class="math">(i.e.,T_{\\text{conf}}\\geq T_{\\text{chkpt}}+T_{\\text{tmout}}+T_{\\text{bft}})</span>, these honest blocks imply the security of the Goldfish protocol after round <span class="math">\\max(\\mathsf{GAT},\\mathsf{GST})+\\Delta+2T_{\\text{chkpt}}</span>. ∎</p>

    <p class="text-gray-300">Thm. 1 holds for the honest blocks proposed in intervals <span class="math">[r_{n}+\\Delta,r_{n+1}-T_{\\text{rcnt}}]</span> as all honest validators agree on the latest checkpoint during these intervals.</p>

    <h3 id="sec-72" class="text-xl font-semibold mt-8">D.6 Proof of Thm. 7</h3>

    <h6 id="sec-73" class="text-base font-medium mt-4">Proof of Thm. 7.</h6>

    <p class="text-gray-300">We first show the property P1, namely, the accountable safety and liveness of the accountable, final prefix ledger <span class="math">\\mathsf{ch}_{\\text{acc}}</span> under partial synchrony in the sleepy model. By <em>[61, Thm. 3]</em>, <span class="math">\\mathsf{ch}_{\\text{acc}}</span> provides accountable safety with resilience <span class="math">n/3</span> except with probability <span class="math">\\text{negl}(\\lambda)</span> under partial synchrony in the sleepy model. By Lem. 9, under the same model, the available ledger <span class="math">\\mathsf{ch}_{\\text{ava}}</span> is secure after round <span class="math">\\max(\\mathsf{GAT},\\mathsf{GST})+\\Delta+2T_{\\text{chkpt}}</span>. Using this fact and Lem. 7, we can state that, w.o.p., <span class="math">\\mathsf{ch}_{\\text{acc}}</span> satisfies liveness after round <span class="math">\\max(\\mathsf{GAT},\\mathsf{GST})+\\Delta+2T_{\\text{chkpt}}</span> with transaction confirmation time <span class="math">T_{\\text{conf}}=\\Theta(\\kappa^{2})</span>.</p>

    <p class="text-gray-300">Finally, the property P2 follows from Lem. 6, and Prefix follows by construc</p>

    <p class="text-gray-300">tion of the ledgers <span class="math">\\mathsf{ch}_{\\mathrm{acc}}</span> and <span class="math">\\mathsf{ch}_{\\mathrm{ava}}</span>. This concludes the proof of the ebb-and-flow property. ∎</p>

    <h2 id="sec-74" class="text-2xl font-bold">Appendix 0.E Equivocation Discounting to Mitigate Spamming</h2>

    <p class="text-gray-300">For ease of exposition, we have presented a version of Goldfish which deals with equivocating votes simply by accepting all of them, but counting at most one per subtree (Alg. 3, l. 7). This approach is vulnerable to spamming attacks, because it requires validators to accept all the votes they receive. Even a single adversarially controlled validator can be used to create an arbitrarily large number of equivocating votes at a slot, with the goal of creating network congestion and making it impossible for honest validators to download all of the other votes in time, which can result in a loss of safety.</p>

    <p class="text-gray-300">Equivocations are attributable faults, punishable by slashing a posteriori, but this does not prevent the attack vector a priori, given that only one validator is required for it. To mitigate it, we introduce equivocation discounting. This general technique is already present in the current implementation of Ethereum, but the ephemerality of votes in Goldfish allows for a simpler rule, with clear bounds on the number of messages required for honest views to converge. This is particularly important in order to have guarantees about the functioning of the vote buffering technique, and in turn about the security of the whole protocol, which relies on reorg resilience. We formalize the simple equivocation discounting rule here, as a combination of a modification to the GHOST-Eph fork-choice, a download rule, and a validity condition for proposals.</p>

    <h3 id="sec-75" class="text-xl font-semibold mt-8">0.E.1. Equivocation Discounting.</h3>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[label=()]</li>

      <li>Fork-choice discounting: When running the GHOST-Eph fork-choice rule at slot <span class="math">t_{\\mathrm{o}}</span> only count the valid slot <span class="math">t-1</span> votes from those validators for which your bvtree contains a single valid slot <span class="math">t-1</span> vote, i.e., those which are not viewed to have equivocated at slot <span class="math">t-1</span>.</li>

      <li>Download rule: Only download (or forward as part of the peer-to-peer gossip layer) votes from the current and prior slots, and at most two votes per eligible validator (i.e., the opened ticket <span class="math">(\\mathsf{id},t)</span> for the validator <span class="math">\\mathsf{id}</span> is winning for the tag <span class="math">(\\mathsf{vote},\\mathsf{thr}_{\\mathrm{v}})</span>, cf. Sec. 4).</li>

      <li>Validity condition for proposals: A proposal whose bvtree contains more than two valid votes for the same slot from some validator is invalid, and so is one which contains any invalid vote.</li>

    </ol>

    <p class="text-gray-300">The download rule and validity condition ensure that a validator only ever needs to download at most two votes per subsampled validator of the current and previous slot. Setting the subsampling parameters so that this is manageable, we can ensure that equivocations cannot succeed at creating network congestion sufficient to prevent the functioning of vote buffering. Previously, this meant guaranteeing that an honest proposer’s bvtree be a superset of honest validators’ bvtrees. Instead, the success of vote buffering now only requires that a leader’s view of votes from voters which have not equivocated in the last slot is a superset</p>

    <p class="text-gray-300">of the validators’ views of such votes, and so is its view of the list of equivocators from the previous slot. Agreement on these two is sufficient for agreement on the fork-choice output, <em>i.e.</em>, Lem. 2 still holds. Note that the leader still only needs to include its bvtree in the proposal message, because following the download rule guarantees that it will contain exactly all valid votes from validators which have not equivocated in the previous slot, together with a pair of votes, <em>i.e.</em>, equivocation evidence, for validators which have.</p>

    <p class="text-gray-300">The security analysis for Goldfish with equivocation discounting is then the same as that for vanilla Goldfish. Vote buffering implies that all honest validators vote together when the proposal with the minimum precedence is honest, as in Lem. 2, and all honest validators voting together implies that the proposal is never reorged, as in Lem. 3. The latter is not affected by equivocation discounting, because it relies on the valid votes of honest validators, which do not equivocate. From these two properties, we obtain reorg resilience as in Thm. 3, and from reorg resilience, we eventually obtain safety and liveness.</p>

    <p class="text-gray-300">Optimistic fast confirmations are also compatible with equivocation discounting, without any loss of resilience. Liveness and fast confirmation of honest proposals follow from Thm. 6, since equivocation discounting plays no role in it. For safety, the key ingredient is Lem. 5, from which Thm. 5 follows unchanged. We thus prove Lem. 5 here for Goldfish with equivocation discounting, by making a very small modification to the argument:</p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Proof of Lem. 5 with equivocation discounting.</h6>

    <p class="text-gray-300">By Prop. 1, w.o.p., the number of adversary validators at round <span class="math">4\\Delta(t+1)+\\Delta</span>, eligible to vote at slot <span class="math">t</span>, is less than <span class="math">\\frac{1}{2}n\\,\\mathsf{thr}_{\\mathrm{v}}</span>. An eligible awake honest validator sends a single slot <span class="math">t</span> vote at round <span class="math">4\\Delta t+\\Delta</span>, implying that over <span class="math">(\\frac{3}{4}+\\frac{\\epsilon}{2})n\\,\\mathsf{thr}_{\\mathrm{v}}-\\frac{1}{2}n\\,\\mathsf{thr}_{\\mathrm{v}}=(\\frac{1}{4}+\\frac{\\epsilon}{2})n\\,\\mathsf{thr}_{\\mathrm{v}}</span> validators broadcast a single slot <span class="math">t</span> vote by round <span class="math">4\\Delta(t+1)+\\Delta</span>, and that is for a descendant of <span class="math">B</span>. By Prop. 1, w.o.p., for all slots <span class="math">t</span>, there can be at most <span class="math">(1+\\epsilon)n\\,\\mathsf{thr}_{\\mathrm{v}}</span> validators that are eligible to vote at <span class="math">t</span>. Hence, the number of valid slot <span class="math">t</span> votes for the descendants of any block <span class="math">B^{\\prime}</span> conflicting with <span class="math">B</span>, and which are from validators which have not also cast one of the <span class="math">(\\frac{3}{4}+\\frac{\\epsilon}{2})n\\,\\mathsf{thr}_{\\mathrm{v}}</span> votes for <span class="math">B</span>, must be less than <span class="math">(1+\\epsilon)n\\,\\mathsf{thr}_{\\mathrm{v}}-(\\frac{3}{4}+\\frac{\\epsilon}{2})n\\,\\mathsf{thr}_{\\mathrm{v}}=(\\frac{1}{4}+\\frac{\\epsilon}{2})n\\,\\mathsf{thr}_{\\mathrm{v}}</span> at any given round. The validator <span class="math">\\mathsf{id}^{*}</span> broadcasts <span class="math">B</span> and over <span class="math">(\\frac{3}{4}+\\frac{\\epsilon}{2})n\\,\\mathsf{thr}_{\\mathrm{v}}</span> valid votes for it (in pieces) at round <span class="math">4\\Delta t+2\\Delta</span>. Each honest validator, awake at round <span class="math">4\\Delta(t+1)+\\Delta</span> and eligible to vote at slot <span class="math">t+1</span>, observes these votes in its bvtree at the round of voting (Alg. 4, l. 11). Upon invoking the GHOST-Eph fork-choice rule at any of the rounds <span class="math">4\\Delta t+3\\Delta</span>, <span class="math">4\\Delta(t+1)</span> or <span class="math">4\\Delta(t+1)+\\Delta</span>, using only the votes from validators which are not seen to be equivocating at slot <span class="math">t-1</span>, the votes for the descendants of any block <span class="math">B^{\\prime}</span> conflicting with <span class="math">B</span> are then less than <span class="math">(\\frac{1}{4}+\\frac{\\epsilon}{2})n\\,\\mathsf{thr}_{\\mathrm{v}}</span>, and the votes for descendants of <span class="math">B</span> are over <span class="math">(\\frac{1}{4}+\\frac{\\epsilon}{2})n\\,\\mathsf{thr}_{\\mathrm{v}}</span>. This implies that all honest validators, awake at round <span class="math">4\\Delta(t+1)+\\Delta</span> and eligible to vote at slot <span class="math">t+1</span>, all vote for <span class="math">B</span> or one of its descendants at slot <span class="math">t+1</span>. ∎</p>

    <p class="text-gray-300">F From LMD GHOST to Goldfish</p>

    <p class="text-gray-300">In this section, we outline the shortcomings of LMD GHOST in comparison to Goldfish, then discuss how Goldfish could replace it in the Ethereum protocol.</p>

    <h3 id="sec-77" class="text-xl font-semibold mt-8">F.1 Limitations of Gasper</h3>

    <p class="text-gray-300">In the first iteration of Gasper’s LMD GHOST, ex-ante reorgs and balancing attacks <em>[57, 59, 70]</em> prevent security even in the full participation setting and without subsampling. The proposer boost technique <em>[13]</em> mitigates these issues, but is itself not compatible with dynamic participation, and it entails a lower adversary tolerance (<span class="math">\\frac{1}{4}</span>) than what is obtained with message buffering (<span class="math">\\frac{1}{2}</span>). Moreover, ex-ante reorgs <em>[70]</em> are still possible with subsampling, compromising reorg resilience, and the latest message rule (LMD) itself is not compatible with dynamic participation. Both of these issues are due to considering votes from older slots, and Goldfish solves them through vote expiry. In the following, we give a more detailed account of all of these limitations.</p>

    <p class="text-gray-300">Interaction of LMD GHOST and Casper FFG. The combination of Goldfish with the accountability gadget in Sec. 3 follows the generic construction of <em>[61]</em>, which is proven to be secure for any appropriately secure dynamically available protocol and accountable BFT protocol. On the other hand, the combination of LMD GHOST and Casper FFG in HLMD GHOST, the hybrid fork-choice rule of <em>[15]</em>, is ad-hoc and complicated to reason about. Firstly, it is known to be susceptible to a <em>bouncing attack</em> <em>[53]</em>. Instead of LMD GHOST starting its fork-choice iteration from the last block <em>finalized</em> by Casper FFG, it starts from the last <em>justified</em> block, in the terminology of Casper FFG, <em>i.e.</em>, the last block that has been the target of FFG votes by a supermajority of all <span class="math">n</span> validators. This is sufficient to ensure accountable safety of the finalized checkpoints; however, it hinders safety of the available ledger <span class="math">\\mathsf{ch}_{\\text{ava}}</span> (after <span class="math">\\max(\\mathsf{GST},\\mathsf{GAT})</span>) under partial synchrony in the sleepy model, in particular negating the healing property (Lem. 9) of <span class="math">\\mathsf{ch}_{\\text{ava}}</span>, preventing us from proving the ebb-and-flow property. The current mitigation for the bouncing attack causes other problems such as the splitting attack <em>[54]</em>, akin to the balancing attacks <em>[60]</em>. Another problematic interaction stems from the fact that the FFG votes at any Ethereum epoch point at the epoch boundary block of that epoch, regardless of its confirmation status by the underlying LMD GHOST rule. (In fact, there is no confirmation rule specified for LMD GHOST.) The accountability gadget can then in principle interfere with the available chain, jeopardizing its standalone security properties. Finally, the FFG voting schedule is staggered throughout an epoch, as FFG votes are cast together with LMD GHOST votes, so it is not clear how to ensure that the views of honest validators when casting FFG votes are consistent, which would at least ensure liveness of the accountable chain.</p>

    <p class="text-gray-300">Stale Votes in LMD GHOST. Without vote expiry, the votes of honest asleep validators can be weaponized by an adversary controlling a small fraction of the validator set to execute an arbitrarily long reorg. This implies that the protocol</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is not dynamically available with <em>any</em> confirmation rule with finite confirmation time <span class="math">T_{\\mathrm{conf}}</span>. Consider for example a validator set of size <span class="math">n=2m+1</span>, and a partition of the validator set into three sets, <span class="math">V_{1}</span>, <span class="math">V_{2}</span>, <span class="math">V_{3}</span>, with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=m<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math">. The validators in </span>V_{1}<span class="math">, </span>V_{2}<span class="math"> are all honest, while the one in </span>V_{3}<span class="math"> is adversary. Suppose that the adversary validator in </span>V_{3}<span class="math"> is the leader of slots </span>t<span class="math">, and that it broadcasts two proposals, with conflicting blocks </span>B_{1}<span class="math"> and </span>B_{2}<span class="math">. It does so in such a way that validators in </span>V_{1}<span class="math"> see only </span>B_{1}<span class="math"> before voting, and validators in </span>V_{2}<span class="math"> only </span>B_{2}<span class="math">. Validators in </span>V_{1}<span class="math"> then vote for </span>B_{1}<span class="math">, and so does the adversary validator, while validators in </span>V_{2}<span class="math"> vote for </span>B_{2}<span class="math">. </span>B_{1}<span class="math"> becomes canonical, since it has received </span>m+1<span class="math"> votes. The adversary then puts all validators in </span>V_{2}<span class="math"> to sleep, and they do not become awake for the remainder of the protocol. The adversary validator does not cast any more votes for a while. Meanwhile, validators in </span>V_{1}<span class="math">, keep voting for descendants of </span>B_{1}<span class="math">. After waiting for </span>>T_{\\mathrm{conf}}<span class="math"> slots, the adversary validator votes for </span>B_{2}<span class="math">. Since the </span>m<span class="math"> latest votes of the validators in </span>V_{2}<span class="math"> are still for </span>B_{2}<span class="math">, it now has </span>m+1<span class="math"> votes and becomes canonical, resulting in all awake honest validators experiencing a reorg of all blocks confirmed after slot </span>t$. If there are no such blocks, liveness is violated, and otherwise safety is violated.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-78" class="text-lg font-semibold mt-6">3.2.2 Proposer Boost.</h4>

    <p class="text-gray-300">Proposer boost is not compatible with dynamic participation, because the artificial fork-choice weight it temporarily provides to proposals is independent of participation: the lower the participation, the more powerful the boost is relative to the weight of real attestations from awake validators, and thus the more it can be exploited by the adversary. When the weight of awake honest validators is less than the boost, the adversary has complete control of the fork-choice during the slots in which it is elected as the leader.</p>

    <h4 id="sec-79" class="text-lg font-semibold mt-6">3.2.3 Reorg Resilience.</h4>

    <p class="text-gray-300">Even in the setting of full participation, where the adversary cannot take advantage of votes of asleep validators, LMD GHOST lacks reorg resilience. This is firstly due to subsampling without vote expiry, because it allows the adversary to accumulate fork-choice weight by withholding blocks and attestations, <em>i.e.</em>, to execute ex ante reorgs <em>[70]</em>. Without subsampling, LMD GHOST is indeed reorg resilient in the full participation setting, <em>if proposer boost is replaced by vote buffering</em>. In fact, Thm. 3 obtains reorg resilience as a consequence of two properties, Lems. 2 and 3, respectively the properties that all honest awake validators vote for an honest proposal, and all honest validators voting together guarantee the inclusion of honest blocks in the canonical GHOST-Eph chain, both of which also hold for LMD GHOST with vote buffering.</p>

    <p class="text-gray-300">With proposer boost, LMD GHOST is not reorg resilient for <span class="math">\\beta\\geq\\frac{1}{4}</span>, even in the full participation setting and without subsampling, because those two properties are in conflict for such <span class="math">\\beta</span>, for any boost value <span class="math">W_{\\mathrm{p}}</span>. The first property only holds if <span class="math">W_{\\mathrm{p}}&gt;2\\beta</span>, because the adversary can otherwise still conclude an ex ante reorg by revealing later votes, which move all adversary weight <span class="math">\\beta</span> from the proposer’s branch to a conflicting one, and outweigh the proposer boost <span class="math">W_{\\mathrm{p}}</span>. On the other hand, the second property only holds if <span class="math">W_{\\mathrm{p}}+\\beta&lt;1-\\beta</span>, because otherwise an adversary proposer can make use of boost to conclude an ex post reorg. Therefore, we can only have reorg resilience when <span class="math">3\\beta&lt;W_{\\mathrm{p}}+\\beta&lt;1-\\beta</span>, <em>i.e.</em>, for <span class="math">\\beta&lt;\\frac{1}{4}</span>, by setting <span class="math">W_{\\mathrm{p}}=\\frac{1}{2}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">F.2 Replacing LMD GHOST with Goldfish in Gasper</p>

    <p class="text-gray-300">For Goldfish to be used as a drop-in replacement for LMD GHOST in Ethereum, only a few adjustments are required. Most importantly, vote expiry and message buffering would have to be introduced, with the latter replacing proposer boost. In principle, the proposer selection mechanism does not need to be overhauled, as Goldfish can operate with RANDAO, the proposer selection mechanism of LMD GHOST. RANDAO always selects a unique proposer, which reduces the communication load, when compared to a VRF lottery. On the other hand, it is not compatible with adaptive security, because the selected proposer is publicly known in advance, and moreover the selection is biasable. A VRF lottery also enables the confirmation time to be independent of participation.</p>

    <p class="text-gray-300">Finally, in order to benefit from the security guarantees of Goldfish in its combination with an accountability gadget, the interaction with Casper FFG would have to be modified to fit the construction from <em>[61]</em>, which we have also employed in this work.</p>

    <h2 id="sec-80" class="text-2xl font-bold">Appendix 0.G Cryptographic Preliminaries</h2>

    <h3 id="sec-81" class="text-xl font-semibold mt-8">0.G.1 Digital Signatures</h3>

    <h6 id="sec-82" class="text-base font-medium mt-4">Definition 5 (Informal, cf. <em>[9, 38]</em>).</h6>

    <p class="text-gray-300">A signature scheme <span class="math">\\mathsf{Sig}=(\\mathsf{Gen},\\mathsf{Sign},\\mathsf{Verify})</span> consists of probabilistic poly-time (PPT) algorithms so that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{ssk},\\mathsf{spk})\\leftarrow\\mathsf{Sig}.\\mathsf{Gen}(1^{\\lambda})</span> creates a secret/public key pair.</li>

      <li><span class="math">\\sigma\\leftarrow\\mathsf{Sig}.\\mathsf{Sign}(\\mathsf{ssk},m)</span> creates a signature on a message.</li>

      <li><span class="math">\\{0,1\\}\\leftarrow\\mathsf{Sig}.\\mathsf{Verify}(\\mathsf{spk},m,\\sigma)</span> verifies a signature.</li>

      <li>Correctness: With overwhelming probability, for all messages, <span class="math">\\mathsf{Sig}.\\mathsf{Verify}(\\mathsf{spk},m,\\mathsf{Sig}.\\mathsf{Sign}(\\mathsf{ssk},m))=1</span>.</li>

      <li>Security (existential unforgeability): An adversary with access to <span class="math">\\mathsf{spk}</span> and to a signing oracle <span class="math">\\mathsf{Sig}.\\mathsf{Sign}(\\mathsf{ssk},.)</span> cannot produce a valid <span class="math">(m,\\sigma)</span> other than via the oracle.</li>

    </ul>

    <h3 id="sec-83" class="text-xl font-semibold mt-8">0.G.2 Verifiable Random Functions</h3>

    <p class="text-gray-300">A verifiable random function (VRF) <em>[50]</em> is used for leader election and subsampling of the validators within the Goldfish protocol.</p>

    <h6 id="sec-84" class="text-base font-medium mt-4">Definition 6 (Informal, cf. <em>[27, Sec. 3.2, Fig. 2]</em>, <em>[20, 28]</em>).</h6>

    <p class="text-gray-300">A verifiable random function (VRF) scheme <span class="math">\\mathsf{Vrf}=(\\mathsf{Gen},\\mathsf{Eval},\\mathsf{Verify})</span> consists of PPT algorithms so that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{vsk},\\mathsf{vpk})\\leftarrow\\mathsf{Vrf}.\\mathsf{Gen}(1^{\\lambda})</span> samples a VRF with associated secret/public key pair for evaluation/verification.</li>

      <li><span class="math">(y,\\pi)\\leftarrow\\mathsf{Vrf}.\\mathsf{Eval}(\\mathsf{vsk},x)</span> obtains the output <span class="math">y</span> of the VRF at input <span class="math">x</span>, and the evaluation proof <span class="math">\\pi</span>.</li>

      <li><span class="math">\\{0,1\\}\\leftarrow\\mathsf{Vrf}.\\mathsf{Verify}(\\mathsf{vpk},x,(y,\\pi))</span> verifies an evaluation.</li>

    </ul>

    <p class="text-gray-300">Francesco D'Amato, Joachim Neu, Ertem Nusret Tas, and David Tse</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness: With overwhelming probability, for all inputs, Vrf.Verify(vpk, x, Vrf.Eval(vsk, x)) = 1.</li>

      <li>Uniqueness: Per input <span class="math">x</span>, there is only one output <span class="math">y</span>: if Vrf.Verify(vpk, x, (y, π)) = 1 for <span class="math">(y, \\pi) = (y_1, \\pi_1)</span> and <span class="math">(y, \\pi) = (y_2, \\pi_2)</span>, then <span class="math">y_1 = y_2</span>.</li>

      <li>‘Pseudorandomness’: Conceptually, the VRF behaves like a random oracle that is unpredictable (i.e., without knowledge of vsk, the VRF output cannot be distinguished from a random string) and verifiable (i.e., given vpk, an alleged output of the VRF can be verified). For a formal definition, see [27, Sec. 3.2, Fig. 2].</li>

    </ul>`;
---

<BaseLayout title="Goldfish: No More Attacks on Ethereum?! (2022/1171)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/1171
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
