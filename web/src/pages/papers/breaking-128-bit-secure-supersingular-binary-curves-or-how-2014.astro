---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/119';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Breaking `128-bit Secure&#x27; Supersingular Binary Curves (or how to solve discrete logarithms in ${\\mathbb F}_{2^{4 \\cdot 1223}}$ and ${\\mathbb F}_{2^{12 \\cdot 367}}$)';
const AUTHORS_HTML = 'Robert Granger, Thorsten Kleinjung, Jens Zumbrägel';

const CONTENT = `    <p class="text-gray-300">Breaking ‘128-bit Secure’ Supersingular Binary Curves* (or how to solve discrete logarithms in <span class="math">\\mathbb{F}_{2^{4}\\cdot 12^{23}}</span> and <span class="math">\\mathbb{F}_{2^{12}\\cdot 367}</span>)</p>

    <p class="text-gray-300">Robert Granger<span class="math">^{1}</span>, Thorsten Kleinjung<span class="math">^{1}</span>, and Jens Zumbrägel<span class="math">^{2}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> Laboratory for Cryptologic Algorithms, EPFL, Switzerland</p>

    <p class="text-gray-300"><span class="math">^{2}</span> Institute of Algebra, TU Dresden, Germany</p>

    <p class="text-gray-300">robbiegranger@gmail.com, thorsten.kleinjung@epfl.ch, jens.zumbragel@ucd.ie</p>

    <p class="text-gray-300">Abstract. In late 2012 and early 2013 the discrete logarithm problem (DLP) in finite fields of small characteristic underwent a dramatic series of breakthroughs, culminating in a heuristic quasi-polynomial time algorithm, due to Barbulescu, Gaudry, Joux and Thomé. Using these developments, Adj, Menezes, Oliveira and Rodríguez-Henríquez analysed the concrete security of the DLP, as it arises from pairings on (the Jacobians of) various genus one and two supersingular curves in the literature, which were originally thought to be 128-bit secure. In particular, they suggested that the new algorithms have no impact on the security of a genus one curve over <span class="math">\\mathbb{F}_{2^{1223}}</span>, and reduce the security of a genus two curve over <span class="math">\\mathbb{F}_{2^{367}}</span> to 94.6 bits. In this paper we propose a new field representation and efficient general descent principles which together make the new techniques far more practical. Indeed, at the ‘128-bit security level’ our analysis shows that the aforementioned genus one curve has approximately 59 bits of security, and we report a total break of the genus two curve.</p>

    <p class="text-gray-300">Keywords: Discrete logarithm problem, finite fields, supersingular binary curves, pairings</p>

    <p class="text-gray-300">The role of small characteristic supersingular curves in cryptography has been a varied and an interesting one. Having been eschewed by the cryptographic community for succumbing spectacularly to the subexponential MOV attack in 1993 [40], which maps the DLP from an elliptic curve (or more generally, the Jacobian of a higher genus curve) to the DLP in a small degree extension of the base field of the curve, they made a remarkable comeback with the advent of pairing-based cryptography in 2001 [42, 31, 9]. In particular, for the latter it was reasoned that the existence of a subexponential attack on the DLP does not ipso facto warrant their complete exclusion; rather, provided that the finite field DLP into which the elliptic curve DLP embeds is sufficiently hard, this state of affairs would be acceptable.</p>

    <p class="text-gray-300">Neglecting the possible existence of native attacks arising from the supersingularity of these curves, much research effort has been expended in making instantiations of the required cryptographic operations on such curves as efficient as possible [6, 17, 14, 28, 27, 5, 30, 7, 11, 18, 3, 1], to name but a few, with the associated security levels having been estimated using Coppersmith’s algorithm from 1984 [12, 39]. Alas, a series of dramatic breakthrough results for the DLP in finite fields of small characteristic have potentially rendered all of these efforts in vain.</p>

    <p class="text-gray-300">The first of these results was due to Joux, in December 2012, and consisted of a more efficient method — dubbed ‘pinpointing’ — to obtain relations between factor base elements [32]. For medium-sized base fields, this technique has heuristic complexity as low as <span class="math">L(1/3, 2^{1/3}) \\approx L(1/3, 1.260)^{\\dagger}</span>, where as usual <span class="math">L(\\alpha, c) = L_{Q}(\\alpha, c) = \\exp((c + o(1)) (\\log Q)^{\\alpha} (\\log \\log Q)^{1 - \\alpha})</span>, with</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The second author acknowledges the support of the Swiss National Science Foundation, via grant numbers 206021-128727 and 200020-132160, while the third author acknowledges the support of the Irish Research Council, grant number ELEVATEPD/2013/82.</li>

    </ul>

    <p class="text-gray-300">† The original paper states a complexity of <span class="math">L(1/3, (8/9)^{1/3}) \\approx L(1/3, 0.961)</span>; however, on foot of recent communications the constant should be as stated.</p>

    <p class="text-gray-300"><span class="math">Q</span> the cardinality of the field. This improved upon the previous best complexity of <span class="math">L(1/3,3^{1/3})\\approx L(1/3,1.442)</span> due to Joux and Lercier <em>[37]</em>. Using this technique Joux solved example DLPs in fields of bitlength 1175 and 1425, both with prime base fields.</p>

    <p class="text-gray-300">Then in February 2013, Göloğlu, Granger, McGuire and Zumbrägel used a specialisation of the Joux-Lercier doubly-rational function field sieve (FFS) variant <em>[37]</em>, in order to exploit a well-known family of ‘splitting polynomials’, i.e., polynomials which split completely over the base field <em>[19]</em>. For fields of the form <span class="math">\\mathbb{F}_{q^{kn}}</span> with <span class="math">k\\geq 3</span> fixed (<span class="math">k=2</span> is even simpler) and <span class="math">n\\approx dq</span> for a fixed integer <span class="math">d\\geq 1</span>, they showed that for binary (and more generally small characteristic) fields, relation generation for degree one elements runs in heuristic polynomial time, as does finding the logarithms of degree two elements (if <span class="math">q^{k}</span> can be written as <span class="math">q^{\\prime k^{\\prime}}</span> for <span class="math">k^{\\prime}\\geq 4</span>), once degree one logarithms are known. For medium-sized base fields of small characteristic a heuristic complexity as low as <span class="math">L(1/3,(4/9)^{1/3})\\approx L(1/3,0.763)</span> was attained; this approach was demonstrated via the solution of example DLPs in the fields <span class="math">\\mathbb{F}_{2^{1971}}</span> <em>[21]</em> and <span class="math">\\mathbb{F}_{2^{3164}}</span>.</p>

    <p class="text-gray-300">After the initial publication of <em>[19]</em>, Joux released a preprint <em>[33]</em> detailing an algorithm for solving the discrete logarithm problem for fields of the form <span class="math">\\mathbb{F}_{q^{2n}}</span>, with <span class="math">n\\leq q+d</span> for some very small <span class="math">d</span>, which was used to solve a DLP in <span class="math">\\mathbb{F}_{2^{1778}}</span> <em>[34]</em> and later in <span class="math">\\mathbb{F}_{2^{4080}}</span> <em>[35]</em>. For <span class="math">n\\approx q</span> this algorithm has heuristic complexity <span class="math">L(1/4+o(1),c)</span> for some undetermined <span class="math">c</span>, and also has a heuristic polynomial time relation generation method, similar in principle to that in <em>[19]</em>. While the degree two element elimination method in <em>[19]</em> is arguably superior – since elements can be eliminated on the fly – for other small degrees Joux’s elimination method is faster, resulting in the stated complexity.</p>

    <p class="text-gray-300">In April 2013 Göloğlu et al. combined their approach with Joux’s to solve an example DLP in the field <span class="math">\\mathbb{F}_{2^{6120}}</span> <em>[22]</em> and later demonstrated that Joux’s algorithm can be tweaked to have heuristic complexity <span class="math">L(1/4,c)</span> <em>[20]</em>, where <span class="math">c</span> can be as low as <span class="math">(\\omega/8)^{1/4}</span> <em>[24]</em>, with <span class="math">\\omega</span> the linear algebra constant, i.e., the exponent of matrix multiplication. Then in May 2013, Joux announced the solution of a DLP in the field <span class="math">\\mathbb{F}_{2^{6168}}</span> <em>[36]</em>.</p>

    <p class="text-gray-300">Most recently, in June 2013, Barbulescu, Gaudry, Joux and Thomé announced a quasi-polynomial time for solving the DLP <em>[4]</em>, for fields <span class="math">\\mathbb{F}_{q^{kn}}</span> with <span class="math">k\\geq 2</span> fixed and <span class="math">n\\leq q+d</span> with <span class="math">d</span> very small, which for <span class="math">n\\approx q</span> has heuristic complexity</p>

    <p class="text-gray-300"><span class="math">(\\log q^{kn})^{O(\\log\\log q^{kn})}.</span> (1)</p>

    <p class="text-gray-300">Since (1) is smaller than <span class="math">L(\\alpha,c)</span> for any <span class="math">\\alpha&gt;0</span>, it is asymptotically the most efficient algorithm known for solving the DLP in finite fields of small characteristic, which can always be embedded into a field of the required form. Interestingly, the algorithmic ingredients and analysis of this algorithm are much simpler than for Joux’s <span class="math">L(1/4+o(1),c)</span> algorithm.</p>

    <p class="text-gray-300">Taken all together, one would expect the above developments to have a substantial impact on the security of small characteristic parameters appearing in the pairing-based cryptography literature. However, all of the record DLP computations mentioned above used Kummer or twisted Kummer extensions (those with <span class="math">n</span> dividing <span class="math">q^{k}\\mp 1</span>), which allow for a reduction in the size of the factor base by a factor of <span class="math">kn</span> and make the descent phase for individual logarithms relatively easy. While such parameters are preferable for setting records (most recently in <span class="math">\\mathbb{F}_{2^{9234}}</span> <em>[26]</em>), none of the parameters featured in the literature are of this form, and so it is not a priori clear whether the new techniques weaken existing pairing-based protocol parameters.</p>

    <p class="text-gray-300">A recent paper by Adj, Menezes, Oliveira and Rodríguez-Henríquez has begun to address this very issue <em>[2]</em>. Using the time required to compute a single multiplication modulo the cardinality of the relevant prime order subgroup as their basic unit of time, which we denote by <span class="math">M_{r}</span>, they showed that the DLP in the field <span class="math">\\mathbb{F}_{3^{6\\cdot 509}}</span> costs at most <span class="math">2^{73.7}</span> <span class="math">M_{r}</span>. One can arguably interpret this</p>

    <p class="text-gray-300">result to mean that this field has 73.7 bits of security. This significantly reduces the intended security level of 128 bits (or 111 bits as estimated by Shinohara et al. <em>[43]</em>, or 102.7 bits for the Joux-Lercier FFS variant with pinpointing, as estimated in <em>[2]</em>). An interesting feature of their analysis is that during the descent phase, some elimination steps are performed using the method from the quasi-polynomial time algorithm of Barbulescu et al., when one might have expected these steps to only come into play at much higher bitlengths, due to the high arity of the arising descent nodes.</p>

    <p class="text-gray-300">In the context of binary fields, Adj et al. considered in detail the DLP in the field <span class="math">\\mathbb{F}_{2^{12\\cdot 367}}</span>, which arises via a pairing from the DLP on the Jacobian of a supersingular genus two curve over <span class="math">\\mathbb{F}_{2^{367}}</span>, first proposed in <em>[3]</em>, with embedding degree 12. Using all of the available techniques they provided an upper bound of <span class="math">2^{94.6}</span> <span class="math">M_{r}</span> for the cost of breaking the DLP in the embedding field, which is some way below the intended 128-bit security level. In their conclusion Adj et al. also suggest that a commonly implemented genus one supersingular curve over <span class="math">\\mathbb{F}_{2^{1223}}</span> with embedding degree 4 <span class="math">[30,7,11,18,1]</span>, is not weakened by the new algorithmic advances, i.e., its security remains very close to 128 bits.</p>

    <p class="text-gray-300">In this work we show that the above security estimates were incredibly optimistic. Our techniques and results are summarised as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Field representation: We introduce a new field representation that can have a profound effect on the resulting complexity of the new algorithms. In particular it permits the use of a smaller <span class="math">q</span> than before, which not only speeds up the computation of factor base logarithms, but also the descent (both classical and new).</li>

      <li>Exploit subfield membership: During the descent phase we apply a principle of parsimony, by which one should always try to eliminate an element in the target field, and only when this is not possible should one embed it into an extension field. So although the very small degree logarithms may be computed over a larger field, the descent cost is greatly reduced relative to solving a DLP in the larger field.</li>

      <li>Further descent tricks: The above principle also means that elements can automatically be rewritten in terms of elements of smaller degree, via factorisation over a larger field, and that elements can be eliminated via Joux’s Gröbner basis computation method <em>[33]</em> with <span class="math">k=1</span>, rather than <span class="math">k&gt;1</span>, which increases its degree of applicability.</li>

      <li>‘128-bit secure’ genus one DLP: We show that the DLP in <span class="math">\\mathbb{F}_{2^{4\\cdot 1223}}</span> can be solved in approximately <span class="math">2^{40}</span> s, or <span class="math">2^{59}</span> <span class="math">M_{r}</span>, with <span class="math">r</span> a 1221-bit prime.</li>

      <li>‘128-bit secure’ genus two DLP: We report a total break of the DLP in <span class="math">\\mathbb{F}_{2^{12\\cdot 367}}</span> (announced in <em>[25]</em>), which took about 52240 core-hours.</li>

      <li><span class="math">\\mathbf{L(1/4,c)}</span> technique only: Interestingly, using our approach the elimination steps à la Barbulesu et al. <em>[4]</em> were not necessary for the above estimate and break.</li>

    </ul>

    <p class="text-gray-300">The rest of the paper is organised as follows. In §2 we describe our field representation and our target fields. In §3 we present the corresponding polynomial time relation generation method for degree one elements and degree two elements (although we do not need the latter for the fields targeted in the present paper), as well as how to apply Joux’s small degree elimination method <em>[33]</em> with the new representation. We then apply these and other techniques to <span class="math">\\mathbb{F}_{2^{4\\cdot 1223}}</span> in §4 and to <span class="math">\\mathbb{F}_{2^{12\\cdot 367}}</span> in §5 . Finally, we conclude in §6.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2 Field Representation and Target Fields</p>

    <p class="text-gray-300">In this section we introduce our new field representation and the fields whose DLP security we will address. This representation, as well as some preliminary security estimates, were initially presented in <em>[23]</em>.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">2.1 Field Representation</h3>

    <p class="text-gray-300">Although we focus on binary fields in this paper, for the purposes of generality, in this section we allow for extension fields of arbitrary characteristic. Hence let <span class="math">q=p^{l}</span> for some prime <span class="math">p</span>, and let <span class="math">\\mathbb{K}=\\mathbb{F}_{q^{kn}}</span> be the field under consideration, with <span class="math">k\\geq 1</span>.</p>

    <p class="text-gray-300">We choose a positive integer <span class="math">d_{h}</span> such that <span class="math">n\\leq qd_{h}+1</span>, and then choose <span class="math">h_{0},h_{1}\\in\\mathbb{F}_{q^{k}}[X]</span> with <span class="math">\\max\\{\\deg(h_{0}),\\deg(h_{1})\\}=d_{h}</span> such that</p>

    <p class="text-gray-300"><span class="math">h_{1}(X^{q})X-h_{0}(X^{q})\\equiv 0\\pmod{I(X)},</span> (2)</p>

    <p class="text-gray-300">where <span class="math">I(X)</span> is an irreducible degree <span class="math">n</span> polynomial in <span class="math">\\mathbb{F}_{q^{k}}[X]</span>. Then <span class="math">\\mathbb{K}=\\mathbb{F}_{q^{k}}[X]/(I(X))</span>. Denoting by <span class="math">x</span> a root of <span class="math">I(X)</span>, we introduce the auxiliary variable <span class="math">y=x^{q}</span>, so that one has two isomorphic representations of <span class="math">\\mathbb{K}</span>, namely <span class="math">\\mathbb{F}_{q^{k}}(x)</span> and <span class="math">\\mathbb{F}_{q^{k}}(y)</span>, with <span class="math">\\sigma:\\mathbb{F}_{q^{k}}(y)\\to\\mathbb{F}_{q^{k}}(x):y\\mapsto x^{q}</span>. To establish the inverse isomorphism, note that by (2) in <span class="math">\\mathbb{K}</span> we have <span class="math">h_{1}(y)x-h_{0}(y)=0</span>, and hence <span class="math">\\sigma^{-1}:\\mathbb{F}_{q^{k}}(x)\\to\\mathbb{F}_{q^{k}}(y):x\\mapsto h_{0}(y)/h_{1}(y)</span>.</p>

    <p class="text-gray-300">The knowledgeable reader will have observed that our representation is a synthesis of two other useful representations: the one used by Joux <em>[33]</em>, in which one searches for a degree <span class="math">n</span> factor <span class="math">I(X)</span> of <span class="math">h_{1}(X)X^{q}-h_{0}(X)</span>; and the one used by Göloğlu et al. <em>[19, 20]</em>, in which one searches for a degree <span class="math">n</span> factor <span class="math">I(X)</span> of <span class="math">X-h_{0}(X^{q})</span>. The problem with the former is that it constrains <span class="math">n</span> to be approximately <span class="math">q</span>. The problem with the latter is that the polynomial <span class="math">X-h_{0}(X^{q})</span> is insufficiently general to represent all degrees <span class="math">n</span> up to <span class="math">qd_{h}</span>. By changing the coefficient of <span class="math">X</span> in the latter from <span class="math">1</span> to <span class="math">h_{1}(X^{q})</span>, we greatly increase the probability of overcoming the second problem, thus combining the higher degree coverage of Joux’s representation with the higher degree possibilities of <em>[19, 20]</em>.</p>

    <p class="text-gray-300">The raison d’être of using this representation rather than Joux’s representation is that for a given <span class="math">n</span>, by choosing <span class="math">d_{h}&gt;1</span>, one may use a smaller <span class="math">q</span>. So why is this useful? Well, since the complexity of the new descent methods is typically a function of <span class="math">q</span>, then subject to the satisfaction of certain constraints, one may use a smaller <span class="math">q</span>, thus reducing the complexity of solving the DLP. This observation was our motivation for choosing field representations of the above form.</p>

    <p class="text-gray-300">Another advantage of having an <span class="math">h_{1}</span> coefficient (which also applies to Joux’s representation) is that it increases the chance of there being a suitable <span class="math">(h_{1},h_{0})</span> pair with coefficients defined over a proper subfield of <span class="math">\\mathbb{F}_{q^{k}}</span>, which then permits one to apply the factor base reduction technique of <em>[37]</em>, see §4 and §5.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">2.2 Target Fields</h3>

    <p class="text-gray-300">For <span class="math">i\\in\\{0,1\\}</span> let <span class="math">E_{i}/\\mathbb{F}_{2^{p}}:Y^{2}+Y=X^{3}+X+i</span>. These elliptic curves are supersingular and can have prime or nearly prime order only for <span class="math">p</span> prime, and have embedding degree <span class="math">4</span> <em>[16, 6, 17]</em>. We focus on the curve</p>

    <p class="text-gray-300"><span class="math">E_{0}/\\mathbb{F}_{2^{1223}}:Y^{2}+Y=X^{3}+X,</span> (3)</p>

    <p class="text-gray-300">which has a prime order subgroup of cardinality <span class="math">r_{1}=(2^{1223}+2^{612}+1)/5</span>, of bitlength <span class="math">1221</span>. This curve was initially proposed for <span class="math">128</span>-bit secure protocols <em>[30]</em> and has enjoyed several optimised</p>

    <p class="text-gray-300">implementations <em>[7, 11, 1, 18]</em>. Many smaller <span class="math">p</span> have also been proposed in the literature (see <em>[5, 16]</em>, for instance), and are clearly weaker.</p>

    <p class="text-gray-300">For <span class="math">i\\in\\{0,1\\}</span> let <span class="math">H_{i}/\\mathbb{F}_{2^{p}}:Y^{2}+Y=X^{5}+X^{3}+i</span>. These genus two hyperelliptic curves are supersingular and can have a nearly prime order Jacobian only for <span class="math">p</span> prime (note that 13 is always a factor of <span class="math">\\#\\mathrm{Jac}_{H_{0}}(\\mathbb{F}_{2^{p}})</span>, since <span class="math">\\#\\mathrm{Jac}_{H_{0}}(\\mathbb{F}_{2})=13</span>), and have embedding degree 12 <em>[5, 16]</em>. We focus on the curve</p>

    <p class="text-gray-300"><span class="math">H_{0}/\\mathbb{F}_{2^{367}}:Y^{2}+Y=X^{5}+X^{3},</span> (4)</p>

    <p class="text-gray-300">with <span class="math">\\#\\mathrm{Jac}_{H}(\\mathbb{F}_{2^{367}})=13\\cdot 7170258097\\cdot r_{2}</span>, and <span class="math">r_{2}=(2^{734}+2^{551}+2^{367}+2^{184}+1)/(13\\cdot 7170258097)</span> is a 698-bit prime, since this was proposed for 128-bit secure protocols <em>[3]</em>, and whose security was analysed in depth by Adj et al. in <em>[2]</em>.</p>

    <h2 id="sec-4" class="text-2xl font-bold">3 Computing the Logarithms of Small Degree Elements</h2>

    <p class="text-gray-300">In this section we adapt the polynomial time relation generation method from <em>[19]</em> and Joux’s small degree elimination method <em>[33]</em> to the new field representation as detailed in §2.1. Note that henceforth, we shall refer to elements of <span class="math">\\mathbb{F}_{q^{kn}}=\\mathbb{F}_{q^{k}}[X]/(I(X))</span> as field elements or as polynomials, as appropriate, and thus use <span class="math">x</span> and <span class="math">X</span> (and <span class="math">y</span> and <span class="math">Y</span>) interchangeably. We therefore freely apply polynomial ring concepts, such as degree, factorisation and smoothness, to field elements.</p>

    <p class="text-gray-300">In order to compute discrete logarithms in our target fields we apply the usual index calculus method. It consists of a precomputation phase in which by means of (sparse) linear algebra techniques one obtains the logarithms of the factor base elements, which will consist of the low degree irreducible polynomials. Afterwards, in the individual logarithm phase, one applies procedures to recursively rewrite each element as a product of elements of smaller degree, in this way building up a descent tree, which has the target element as its root and factor base elements as its leaves. This proceeds in several stages, starting with a continued fraction descent of the target element, followed by a special-<span class="math">Q</span> lattice descent (referred to as degree-balanced classical descent, see <em>[19]</em>), and finally using Joux’s Gröbner basis descent <em>[33]</em> for the lower degree elements. Details of the continued fraction and classical descent steps are given in §4, while in this section we provide details of how to find the logarithms of elements of small degree.</p>

    <p class="text-gray-300">We now describe how the logarithms of degree one and two elements (when needed) are to be computed. We use the relation generation method from <em>[19]</em>, rather than Joux’s method <em>[33]</em>, since it automatically avoids duplicate relations. For <span class="math">k\\geq 2</span> we first precompute the set <span class="math">\\mathcal{S}_{k}</span>, where</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}_{k}=\\{(a,b,c)\\in(\\mathbb{F}_{q^{k}})^{3}\\mid X^{q+1}+aX^{q}+bX+c\\ \\ \\text{ splits completely over }\\mathbb{F}_{q^{k}}\\}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For <span class="math">k=2</span>, this set of triples is parameterised by <span class="math">(a,a^{q},\\mathbb{F}_{q}\\ni c\\neq a^{q+1})</span>, of which there are precisely <span class="math">q^{3}-q^{2}</span> elements. For <span class="math">k\\geq 3</span>, <span class="math">\\mathcal{S}_{k}</span> can also be computed very efficiently, as follows. Assuming <span class="math">c\\neq ab</span> and <span class="math">b\\neq a^{q}</span>, the polynomial <span class="math">X^{q+1}+aX^{q}+bX+c</span> may be transformed (up to a scalar factor) into the polynomial <span class="math">f_{B}(\\overline{X})=\\overline{X}^{q+1}+B\\overline{X}+B</span>, where <span class="math">B=\\frac{(b-a^{q})^{q+1}}{(c-ab)^{q}}</span>, and <span class="math">X=\\frac{c-ab}{b-a^{q}}\\overline{X}-a</span>. The set <span class="math">\\mathcal{L}</span> of <span class="math">B\\in\\mathbb{F}_{q^{k}}</span> for which <span class="math">f_{B}</span> splits completely over <span class="math">\\mathbb{F}_{q^{k}}</span> can be computed by simply testing for each such <span class="math">B</span> whether this occurs, and there are precisely <span class="math">(q^{k-1}-1)/(q^{2}-1)</span> such <span class="math">B</span> if <span class="math">k</span> is odd, and <span class="math">(q^{k-1}-q)/(q^{2}-1)</span> such <span class="math">B</span> if <span class="math">k</span> is even <em>[8]</em>. Then for any <span class="math">(a,b)</span> such that <span class="math">b\\neq a^{q}</span> and for each <span class="math">B\\in\\mathcal{L}</span>, we compute via <span class="math">B=\\frac{(b-a^{q})^{q+1}}{(c-ab)^{q}}</span> the corresponding (unique) <span class="math">c\\in\\mathbb{F}_{q^{k}}</span>, which thus ensures that <span class="math">(a,b,c)\\in\\mathcal{S}_{k}</span>. Note that in all cases we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}_{k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx q^{3k-3}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">3.1 Degree 1 Logarithms</h3>

    <p class="text-gray-300">We define the factor base <span class="math">\\mathcal{B}_{1}</span> to be the set of linear elements in <span class="math">x</span>, i.e., <span class="math">\\mathcal{B}_{1}=\\{x-a\\mid a\\in\\mathbb{F}_{q^{k}}\\}</span>. Observe that the elements linear in <span class="math">y</span> are each expressible in <span class="math">\\mathcal{B}_{1}</span>, since <span class="math">(y-a)=(x-a^{1/q})^{q}</span>.</p>

    <p class="text-gray-300">As in <em>[37, 19, 20]</em>, the basic idea is to consider elements of the form <span class="math">xy+ay+bx+c</span> with <span class="math">(a,b,c)\\in\\mathcal{S}_{k}</span>. The above two field isomorphisms induce the following equality in <span class="math">\\mathbb{K}</span>:</p>

    <p class="text-gray-300"><span class="math">x^{q+1}+ax^{q}+bx+c=\\frac{1}{h_{1}(y)}\\big{(}yh_{0}(y)+ayh_{1}(y)+bh_{0}(y)+ch_{1}(y)\\big{)}.</span> (5)</p>

    <p class="text-gray-300">When the r.h.s. of (5) also splits completely over <span class="math">\\mathbb{F}_{q^{k}}</span>, one obtains a relation between elements of <span class="math">\\mathcal{B}_{1}</span> and the logarithm of <span class="math">h_{1}(y)</span>. One can either adjoin <span class="math">h_{1}(y)</span> to the factor base, or simply use an <span class="math">h_{1}(y)</span> which splits completely over <span class="math">\\mathbb{F}_{q^{k}}</span>.</p>

    <p class="text-gray-300">We assume that for each <span class="math">(a,b,c)\\in\\mathcal{S}_{k}</span> that the r.h.s. of (5) – which has degree <span class="math">d_{h}+1</span> – splits completely over <span class="math">\\mathbb{F}_{q^{k}}</span> with probability <span class="math">1/(d_{h}+1)!</span>. Hence in order for there to be sufficiently many relations we require that</p>

    <p class="text-gray-300"><span class="math">\\frac{q^{3k-3}}{(d_{h}+1)!}&gt;q^{k},\\ \\ \\text{or equivalently}\\ \\ q^{2k-3}&gt;(d_{h}+1)!.</span> (6)</p>

    <p class="text-gray-300">When this holds, the expected cost of relation generation is <span class="math">(d_{h}+1)!\\cdot q^{k}\\cdot S_{q^{k}}(1,d_{h}+1)</span>, where <span class="math">S_{q^{k}}(m,n)</span> denotes the cost of testing whether a degree <span class="math">n</span> polynomial is <span class="math">m</span>-smooth, i.e., has all of its irreducible factors of degree <span class="math">\\leq m</span>, see Appendix B. The cost of solving the resulting linear system using sparse linear algebra techniques is <span class="math">O(q^{2k+1})</span> arithmetic operations modulo the order <span class="math">r</span> subgroup in which one is working.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">3.2 Degree 2 Logarithms</h3>

    <p class="text-gray-300">For degree two logarithms, there are several options. The simplest is to apply the degree one method over a quadratic extension of <span class="math">\\mathbb{F}_{q^{k}}</span>, but in general (without any factor base automorphisms) this will cost <span class="math">O(q^{4k+1})</span> modular arithmetic operations. If <span class="math">k\\geq 4</span> then subject to a condition on <span class="math">q</span>, <span class="math">k</span> and <span class="math">d_{h}</span>, it is possible to find the logarithms of irreducible degree two elements on the fly, using the techniques of <em>[19, 20]</em>. In fact, for the DLP in <span class="math">\\mathbb{F}_{2^{12\\cdot 367}}</span> we use both of these approaches, but for different base fields, see §5.</p>

    <p class="text-gray-300">Although not used in the present paper, for completeness we include here the analogue in our field representation of Joux’s approach <em>[33]</em>. Since this approach forms the basis of the higher degree elimination steps in the quasi-polynomial time algorithm of Barbulescu et al., its analogue in our field representation should be clear.</p>

    <p class="text-gray-300">We define <span class="math">\\mathcal{B}_{2,u}</span> to be the set of irreducible elements of <span class="math">\\mathbb{F}_{q^{k}}[X]</span> of the form <span class="math">X^{2}+uX+v</span>. For each <span class="math">u\\in\\mathbb{F}_{q^{k}}</span> one expects there to be about <span class="math">q^{k}/2</span> such elements. As in <em>[33]</em>, for each <span class="math">u\\in\\mathbb{F}_{q^{k}}</span> we find the logarithms of all the elements of <span class="math">\\mathcal{B}_{2,u}</span> simultaneously. To do so, consider (5) but with <span class="math">x</span> on the l.h.s. replaced with <span class="math">Q=x^{2}+ux</span>. Using the field isomorphisms we have that <span class="math">Q^{q+1}+aQ^{q}+bQ+c</span> is equal to</p>

    <p class="text-gray-300"><span class="math">(y^{2}+u^{q}y)((h_{0}(y)/h_{1}(y))^{2}+u(h_{0}(y)/h_{1}(y)))+a(y^{2}+u^{q}y)+b((h_{0}(y)/h_{1}(y))^{2}+u(h_{0}(y)/h_{1}(y)))+c</span> <span class="math">=\\frac{1}{h_{1}(y)^{2}}\\big{(}(y^{2}+u^{q}y)(h_{0}(y)^{2}+uh_{0}(y)h_{1}(y))+a(y^{2}+u^{q}y)h_{1}(y)^{2}+b(h_{0}(y)^{2}+uh_{0}(y)h_{1}(y))+ch_{1}(y)^{2}\\big{)}.</span></p>

    <p class="text-gray-300">The degree of the r.h.s. is <span class="math">2(d_{h}+1)</span>, and when it splits completely over <span class="math">\\mathbb{F}_{q^{k}}</span> we have a relation between elements of <span class="math">\\mathcal{B}_{2,u}</span> and degree one elements, whose logarithms are presumed known, which we assume occurs with probability <span class="math">1/(2(d_{h}+1))!</span>. Hence in order for there to be sufficiently many relations we require that</p>

    <p class="text-gray-300"><span class="math">\\frac{q^{3k-3}}{(2(d_{h}+1))!}&gt;\\frac{q^{k}}{2},\\ \\ \\text{or equivalently}\\ \\ q^{2k-3}&gt;(2(d_{h}+1))!/2.</span> (7)</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Observe that (7) implies (6). When this holds, the expected cost of relation generation is <span class="math">(2(d_{h}+1))!\\cdot q^{k}\\cdot S_{q^{k}}(1,2(d_{h}+1))/2</span>. The cost of solving the resulting linear system using sparse linear algebra techniques is again <span class="math">O(q^{2k+1})</span> modular arithmetic operations, where now both the number of variables and the average weight is halved relative to the degree one case. Since there are <span class="math">q^{k}</span> such <span class="math">u</span>, the total expected cost of this stage is <span class="math">O(q^{3k+1})</span> modular arithmetic operations, which may of course be parallelised.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">3.3 Joux’s Small Degree Elimination with the New Representation</h3>

    <p class="text-gray-300">As in <em>[33]</em>, let <span class="math">Q</span> be a degree <span class="math">d_{Q}</span> element to be eliminated, let <span class="math">F(X)=\\sum_{i=0}^{d_{F}}f_{i}X^{i},G(X)=\\sum_{j=0}^{d_{G}}g_{j}X^{j}\\in\\mathbb{F}_{q^{k}}[X]</span> with <span class="math">d_{F}+d_{G}+2\\geq d_{Q}</span>, and assume without loss of generality <span class="math">d_{F}\\geq d_{G}</span>. Consider the following expression:</p>

    <p class="text-gray-300"><span class="math">G(X)\\prod_{\\alpha\\in\\mathbb{F}_{q}}\\left(F(X)-\\alpha\\,G(X)\\right)=F(X)^{q}G(X)-F(X)G(X)^{q}</span> (8)</p>

    <p class="text-gray-300">The l.h.s. is <span class="math">\\max(d_{F},d_{G})</span>-smooth. The r.h.s. can be expressed modulo <span class="math">h_{1}(X^{q})X-h_{0}(X^{q})</span> in terms of <span class="math">Y=X^{q}</span> as a quotient of polynomials of relatively low degree by using</p>

    <p class="text-gray-300"><span class="math">F(X)^{q}=\\sum_{i=0}^{d_{F}}f_{i}^{q}Y^{i},\\ G(X)^{q}=\\sum_{j=0}^{d_{G}}g_{j}^{q}Y^{j}\\text{ and }X\\equiv\\frac{h_{0}(Y)}{h_{1}(Y)}.</span></p>

    <p class="text-gray-300">Then the numerator of the r.h.s. becomes</p>

    <p class="text-gray-300"><span class="math">\\bigg{(}\\sum_{i=0}^{d_{F}}f_{i}^{q}Y^{i}\\bigg{)}\\bigg{(}\\sum_{j=0}^{d_{G}}g_{j}^{q}h_{0}(Y)^{j}h_{1}(Y)^{d_{F}-j}\\bigg{)}-\\bigg{(}\\sum_{i=0}^{d_{F}}f_{i}^{q}h_{0}(Y)^{i}h_{1}(Y)^{d_{F}-i}\\bigg{)}\\bigg{(}\\sum_{j=0}^{d_{G}}g_{j}^{q}Y^{j}\\bigg{)}.</span> (9)</p>

    <p class="text-gray-300">Setting (9) to be <span class="math">0</span> modulo <span class="math">Q(Y)</span> gives a system of <span class="math">d_{Q}</span> equations over <span class="math">\\mathbb{F}_{q^{k}}</span> in the <span class="math">d_{F}+d_{G}+2</span> variables <span class="math">f_{0},\\ldots,f_{d_{F}},g_{0},\\ldots,g_{d_{G}}</span>. By choosing a basis for <span class="math">\\mathbb{F}_{q^{k}}</span> over <span class="math">\\mathbb{F}_{q}</span> and expressing each of the <span class="math">d_{F}+d_{G}+2</span> variables <span class="math">f_{0},\\ldots,f_{d_{F}},g_{0},\\ldots,g_{d_{G}}</span> in this basis, this system becomes a bilinear quadratic system of <span class="math">kd_{Q}</span> equations in <span class="math">(d_{F}+d_{G}+2)k</span> variables. To find solutions to this system, one can specialise <span class="math">(d_{F}+d_{G}+2-d_{Q})k</span> of the variables in order to make the resulting system generically zero-dimensional while keeping its bilinearity, and then compute the corresponding Gröbner basis, which may have no solution, or a small number of solutions. For each solution, one checks whether (9) divided by <span class="math">Q(Y)</span> is <span class="math">(d_{Q}-1)</span>-smooth: if so then <span class="math">Q</span> has successfully been rewritten as a product of elements of smaller degree; if no solutions give a <span class="math">(d_{Q}-1)</span>-smooth cofactor, then one begins again with another specialisation.</p>

    <p class="text-gray-300">The degree of the cofactor of <span class="math">Q(Y)</span> is upper bounded by <span class="math">d_{F}(1+d_{h})-d_{Q}</span>, so assuming that it behaves as a uniformly chosen polynomial of such a degree one can calculate the probability <span class="math">\\rho</span> that it is <span class="math">(d_{Q}-1)</span>-smooth using standard combinatorial techniques.</p>

    <p class="text-gray-300">Generally, in order for <span class="math">Q</span> to be eliminable by this method with good probability, the number of solutions to the initial bilinear system must be greater than <span class="math">1/\\rho</span>. To estimate the number of solutions, consider the action of <span class="math">\\text{Gl}_{2}(\\mathbb{F}_{q^{k}})</span> on the set of pairs <span class="math">(F,G)</span>. The subgroups <span class="math">\\text{Gl}_{2}(\\mathbb{F}_{q})</span> and <span class="math">\\mathbb{F}_{q^{k}}^{\\times}</span> (via diagonal embedding) both act trivially on the set of relations, modulo multiplication by elements in <span class="math">\\mathbb{F}_{q^{k}}^{\\times}</span>. Assuming that the set of <span class="math">(F,G)</span> quotiented out by the action of the compositum of these subgroups (which has cardinality <span class="math">\\approx q^{k+3}</span>), generates distinct relations, one must satisfy the condition</p>

    <p class="text-gray-300"><span class="math">q^{(d_{F}+d_{G}+1-d_{Q})k-3}&gt;1/\\rho\\ .</span> (10)</p>

    <p class="text-gray-300">Note that while (10) is preferable for an easy descent, one may yet violate it and still successfully eliminate elements by using various tactics, as demonstrated in §5.</p>

    <h2 id="sec-8" class="text-2xl font-bold">4 Concrete Security Analysis of <span class="math">\\mathbb{F}_{2^{4\\cdot 1223}}</span></h2>

    <p class="text-gray-300">In this section we focus on the DLP in the 1221-bit prime order <span class="math">r_{1}</span> subgroup of <span class="math">\\mathbb{F}_{2^{4\\cdot 1223}}^{\\times}</span>, which arises from the MOV attack applied to the genus one supersingular curve (3). By embedding <span class="math">\\mathbb{F}_{2^{4\\cdot 1223}}</span> into its degree two extension <span class="math">\\mathbb{F}_{2^{8\\cdot 1223}}=\\mathbb{F}_{2^{9784}}</span> we show that, after a precomputation taking approximately <span class="math">2^{40}</span> s, individual discrete logarithms can be computed in less than <span class="math">2^{34}</span> s.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">4.1 Setup</h3>

    <p class="text-gray-300">We consider the field <span class="math">\\mathbb{F}_{2^{8\\cdot 1223}}=\\mathbb{F}_{q^{n}}</span> with <span class="math">q=2^{8}</span> and <span class="math">n=1223</span> given by the irreducible factor of degree <span class="math">n</span> of <span class="math">h_{1}(X^{q})X-h_{0}(X^{q})</span>, with</p>

    <p class="text-gray-300"><span class="math">h_{0}=X^{5}+tX^{4}+tX^{3}+X^{2}+tX+t\\,,\\quad h_{1}=X^{5}+X^{4}+X^{3}+X^{2}+X+t\\,,</span></p>

    <p class="text-gray-300">where <span class="math">t</span> is an element of <span class="math">\\mathbb{F}_{2^{2}}\\setminus\\mathbb{F}_{2}</span>. Note that the field of definition of this representation is <span class="math">\\mathbb{F}_{2^{2}}</span>.</p>

    <p class="text-gray-300">Since the target element is contained in the subfield <span class="math">\\mathbb{F}_{2^{4\\cdot 1223}}</span>, we begin the classical descent over <span class="math">\\mathbb{F}_{2^{4}}</span>, we switch to <span class="math">\\mathbb{F}_{q}=\\mathbb{F}_{2^{8}}</span>, i.e., <span class="math">k=1</span>, for the Gröbner basis descent, and, as explained below, we work over <span class="math">\\mathbb{F}_{q^{k}}</span> with either <span class="math">k=1</span> or a few <span class="math">k&gt;1</span> to obtain the logarithms of all factor base elements.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">4.2 Linear Algebra Cost Estimate</h3>

    <p class="text-gray-300">In this precomputation we obtain the logarithms of all elements of degree at most four over <span class="math">\\mathbb{F}_{q}</span>. Since the degree 1223 extension is defined over <span class="math">\\mathbb{F}_{2^{2}}</span> in our field representation, by the action of the Galois group <span class="math">\\mathrm{Gal}(\\mathbb{F}_{q}/\\mathbb{F}_{2^{2}})</span> on the factor base, the number of irreducible elements of degree <span class="math">j</span> whose logarithms are to be computed can be reduced to about <span class="math">2^{8j}/(4j)</span> for <span class="math">j\\in\\{1,2,3,4\\}</span>.</p>

    <p class="text-gray-300">One way to obtain the logarithms of these elements is to carry out the degree 1 relation generation method from §3.1, together with the elementary observation that an irreducible polynomial of degree <span class="math">k</span> over <span class="math">\\mathbb{F}_{q}</span> splits completely over <span class="math">\\mathbb{F}_{q^{k}}</span>. First, computing degree one logarithms over <span class="math">\\mathbb{F}_{q^{3}}</span> gives the logarithms of irreducible elements of degrees one and three over <span class="math">\\mathbb{F}_{q}</span>. Similarly, computing degree one logarithms over <span class="math">\\mathbb{F}_{q^{4}}</span> gives the logarithms of irreducible elements of degrees one, two, and four over <span class="math">\\mathbb{F}_{q}</span>. The main computational cost consists in solving the latter system arising from <span class="math">\\mathbb{F}_{q^{4}}</span>, which has size <span class="math">2^{28}</span> and an average row weight of 256.</p>

    <p class="text-gray-300">However, we propose to reduce the cost of finding these logarithms by using <span class="math">k=1</span> only, in the following easy way. Consider §3.3, and observe that for each polynomial pair <span class="math">(F,G)</span> of degree at most <span class="math">d</span>, one obtains a relation between elements of degree at most <span class="math">d</span> when the numerator of the r.h.s. is <span class="math">d</span>-smooth (ignoring factors of <span class="math">h_{1}</span>). Note that we are not setting the r.h.s. numerator to be zero modulo <span class="math">Q</span> or computing any Gröbner bases. Up to the action of <span class="math">\\mathrm{Gl}_{2}(\\mathbb{F}_{q})</span> (which gives equivalent relations) there are about <span class="math">q^{2d-2}</span> such polynomial pairs. Hence, for <span class="math">d\\geq 3</span> there are more relations than elements if the smoothness probability of the r.h.s. is sufficiently high. Notice that <span class="math">k=1</span> implies that the r.h.s. is divisible by <span class="math">h_{1}(Y)Y-h_{0}(Y)</span>, thus increasing its smoothness probability and resulting in enough relations for <span class="math">d=3</span> and for <span class="math">d=4</span>. After having solved the much smaller system for <span class="math">d=3</span> we know the logarithms of all elements up to degree three, so that the average row weight for the system for <span class="math">d=4</span> can be reduced to about <span class="math">\\frac{1}{4}\\cdot 256=64</span> (irreducible degree four polynomials on the l.h.s.). As above the size of this system is <span class="math">2^{28}</span>.</p>

    <p class="text-gray-300">The cost for generating the linear systems is negligible compared to the linear algebra cost. For estimating the latter cost we consider Lanczos’ algorithm to solve a sparse <span class="math">N\\times N</span>, <span class="math">N=2^{28}</span>, linear system with average row weight <span class="math">W=64</span>. As noted in <em>[41, 20]</em> this algorithm can be implemented such that</p>

    <p class="text-gray-300"><span class="math">N^{2}\\left(2\\,W\\,\\mathrm{ADD}+2\\,\\mathrm{SQR}+3\\,\\mathrm{MULMOD}\\right)</span> (11)</p>

    <p class="text-gray-300">operations are used. On our benchmark system, an AMD Opteron 6168 processor at <span class="math">1.9\\text{\\,}\\mathrm{GHz}</span>, using <em>[29]</em> our implementation of these operations took 62 ns, 467 ns and 1853 ns for an ADD, a SQR and a MULMOD, respectively, resulting in a linear algebra cost of <span class="math">2^{40}</span> s.</p>

    <p class="text-gray-300">As in <em>[2]</em>, the above estimate ignores communication costs and other possible slowdowns which may arise in practice. An alternative estimate can be obtained by considering a problem of a similar size over <span class="math">\\mathbb{F}_{2}</span> and extrapolating from <em>[38]</em>. This gives an estimated time of <span class="math">2^{42}</span> s, or for newer hardware slightly less. Note that this computation was carried out using the block Wiedemann algorithm <em>[13]</em>, which we recommend in practice because it allows one to distribute the main part of the computation. For the sake of a fair comparison with <em>[2]</em> we use the former estimate of <span class="math">2^{40}</span> s.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">4.3 Descent Cost Estimate</h3>

    <p class="text-gray-300">We assume that the logarithms of elements up to degree four are known, and that computing these logarithms with a lookup table is free.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Small Degree Descent.</h4>

    <p class="text-gray-300">We have implemented the small degree descent of §3.3 in Magma <em>[10]</em> V2.20-1, using Faugere’s F4 algorithm <em>[15]</em>. For each degree from 5 to 15, on the same AMD Opteron 6168 processor we timed the Gröbner basis computation between <span class="math">10^{6}</span> and 100 times, depending on the degree. Then using a bottom-up recursive strategy we estimated the following average running times in seconds for a full logarithm computation, which we present to two significant figures:</p>

    <p class="text-gray-300"><span class="math">C[5,\\ldots,15]=[\\,0.038\\,,\\,2.1\\,,\\,2.1\\,,\\,93\\,,\\,95\\,,\\,180\\,,\\,190\\,,\\,3200\\,,\\,3500\\,,\\,6300\\,,\\,11000\\,]\\,.</span></p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Degree-Balanced Classical Descent.</h4>

    <p class="text-gray-300">From now on, we make the conservative assumption that a degree <span class="math">n</span> polynomial which is <span class="math">m</span>-smooth, is a product of <span class="math">n/m</span> degree <span class="math">m</span> polynomials. In practice the descent cost will be lower than this, however, the linear algebra cost is dominating, so this issue is inconsequential for our security estimate. The algorithms we used for smoothness testing are detailed in Appendix B.</p>

    <p class="text-gray-300">For a classical descent step with degree balancing we consider polynomials <span class="math">P(X^{2^{a}},Y)\\in\\mathbb{F}_{q}[X,Y]</span> for a suitably chosen integer <span class="math">0\\leq a\\leq 8</span>. It is advantageous to choose <span class="math">P</span> such that its degree in one variable is one; let <span class="math">d</span> be the degree in the other variable. In the case <span class="math">\\deg_{X^{2^{a}}}(P)=1</span>, i.e., <span class="math">P=v_{1}(Y)X^{2^{a}}+v_{0}(Y)</span>, <span class="math">\\deg v_{i}\\leq d</span>, this gives rise to the relation</p>

    <p class="text-gray-300"><span class="math">L_{v}^{2^{a}}=\\left(\\frac{R_{v}}{h_{1}(X)^{2^{a}}}\\right)^{2^{8}}\\quad\\text{where}\\quad</span> <span class="math">L_{v}=\\tilde{v}_{1}(X^{2^{8-a}})X+\\tilde{v}_{0}(X^{2^{8-a}})\\,,</span> <span class="math">R_{v}=v_{1}(X)h_{0}(X)^{2^{a}}+v_{0}(X)h_{1}(X)^{2^{a}}</span></p>

    <p class="text-gray-300">in <span class="math">\\mathbb{F}_{q}[X]/(h_{1}(X^{q})X-h_{0}(X^{q}))</span> with <span class="math">\\deg L_{v}\\leq 2^{8-a}d+1</span>, <span class="math">\\deg R_{v}\\leq d+5\\cdot 2^{a}</span>, and <span class="math">\\tilde{v}_{i}</span> being <span class="math">v_{i}</span> with its coefficients powered by <span class="math">2^{8-a}</span>, for <span class="math">i=0,1</span>. Similarly, in the case <span class="math">\\deg_{Y}(P)=1</span>, i.e., <span class="math">P=w_{1}(X^{2^{a}})Y+w_{0}(X^{2^{a}})</span>, <span class="math">\\deg w_{i}\\leq d</span>, we have the relation</p>

    <p class="text-gray-300"><span class="math">L_{w}^{2^{a}}=\\left(\\frac{R_{w}}{h_{1}(X)^{2^{a}d}}\\right)^{2^{8}}\\quad\\text{where}\\quad</span> <span class="math">L_{w}=\\tilde{w}_{1}(X)X^{2^{8-a}}+\\tilde{w}_{0}(X)\\,,</span> <span class="math">R_{w}=h_{1}(X)^{2^{a}d}\\big{(}w_{1}\\big{(}\\big{(}\\frac{h_{0}(X)}{h_{1}(X)}\\big{)}^{2^{a}}\\big{)}X+w_{0}\\big{(}\\big{(}\\frac{h_{0}(X)}{h_{1}(X)}\\big{)}^{2^{a}}\\big{)}\\big{)}</span></p>

    <p class="text-gray-300">with <span class="math">\\deg L_{w}\\leq d+2^{8-a}</span>, <span class="math">\\deg R_{w}\\leq 5\\cdot 2^{a}d+1</span> and again <span class="math">\\tilde{w}_{i}</span> being <span class="math">w_{i}</span> with its coefficients powered by <span class="math">2^{8-a}</span>, for <span class="math">i=0,1</span>.</p>

    <p class="text-gray-300">The polynomials <span class="math">v_{i}</span> (respectively <span class="math">w_{i}</span>) are chosen in such a way that either the l.h.s. or the r.h.s. is divisible by a polynomial <span class="math">Q(X)</span> of degree <span class="math">d_{Q}</span>. Gaussian reduction provides a lattice basis <span class="math">(u_{0},u_{1}),(u_{0}^{\\prime},u_{1}^{\\prime})</span> such that the polynomial pairs satisfying the divisibility condition above are</p>

    <p class="text-gray-300">given by  <span class="math">ru_{i} + su_{i}^{\\prime}</span>  for  <span class="math">i = 0,1</span> , where  <span class="math">r,s\\in \\mathbb{F}_q[X]</span> . For nearly all polynomials  <span class="math">Q</span>  it is possible to choose a lattice basis of polynomials with degree  <span class="math">\\approx d_Q / 2</span>  which we will assume for all  <span class="math">Q</span>  appearing in the analysis; extreme cases can be avoided by look-ahead or backtracking techniques. Notice that a polynomial  <span class="math">Q</span>  over  <span class="math">\\mathbb{F}_{2^4}\\subset \\mathbb{F}_q</span>  can be rewritten as a product of polynomials which are also over  <span class="math">\\mathbb{F}_{2^4}</span> , by choosing the basis as well as  <span class="math">r</span>  and  <span class="math">s</span>  to be over  <span class="math">\\mathbb{F}_{2^4}</span> . This will be done in all steps of the classical descent. The polynomials  <span class="math">r</span>  and  <span class="math">s</span>  are chosen to be of degree four, resulting in  <span class="math">2^{36}</span>  possible pairs (multiplying both by a common non-zero constant gives the same relation).</p>

    <p class="text-gray-300">In the final step of the classical eliminations (from degree 26 to 15) we relax the criterion that the l.h.s. and r.h.s. are 15-smooth, allowing also irreducibles of even degree up to degree 30, since these can each be split over  <span class="math">\\mathbb{F}_q</span>  into two polynomials of half the degree, thereby increasing the smoothness probabilities. Admittedly, if we follow our worst-case analysis stipulation that all polynomials at this step have degree 26, then one could immediately split each of them into two degree 13 polynomials. However, in practice one will encounter polynomials of all degrees  <span class="math">\\leq 26</span>  and we therefore carry out the analysis without using the splitting shortcut, which will still provide an overestimate of the cost of this step.</p>

    <p class="text-gray-300">In the following we will state the logarithmic cost (in seconds) of a classical descent step as  <span class="math">c_{l} + c_{r} + c_{s}</span> , where  <span class="math">2^{c_{l}}</span>  and  <span class="math">2^{c_{r}}</span>  denote the number of trials to get the left hand side and the right hand side  <span class="math">m</span> -smooth, and  <span class="math">2^{c_{s}}</span>  s is the time required for the corresponding smoothness test. See Table 1 for the smoothness timings that we benchmarked on the AMD Opteron 6168 processor.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{d}_{\\mathbf{Q}} = \\mathbf{26}</span>  to  <span class="math">\\mathbf{m} = \\mathbf{15}</span> : We choose  <span class="math">\\deg_{X^{2^6}} P = 1</span> ,  <span class="math">a = 5</span> ,  <span class="math">Q</span>  on the right, and we have  <span class="math">d = 17</span> ,  <span class="math">(\\deg(L_v), \\deg(R_v)) = (137, 151)</span> , and logarithmic cost  <span class="math">13.4 + 15.6 - 9.0</span> , hence  <span class="math">2^{20.0}</span>  s; the expected number of factors is 19.2, so the subsequent cost will be less than  <span class="math">2^{17.7}</span>  s. Note that, as explained above, we use the splitting shortcut for irreducibles of even degree up to 30, resulting in the higher than expected smoothness probabilities.</li>

      <li><span class="math">\\mathbf{d}_{\\mathbf{Q}} = \\mathbf{36}</span>  to  <span class="math">\\mathbf{m} = \\mathbf{26}</span> : We choose  <span class="math">\\deg_{X^{2^6}} P = 1</span> ,  <span class="math">a = 5</span> ,  <span class="math">Q</span>  on the right, and we have  <span class="math">d = 22</span> ,  <span class="math">(\\deg(L_v), \\deg(R_v)) = (177, 146)</span> , and logarithmic cost  <span class="math">18.7 + 13.6 - 9.0</span> , hence  <span class="math">2^{23.3}</span>  s; the expected number of factors is 12.4, so the subsequent cost will be less than  <span class="math">2^{23.9}</span>  s.</li>

      <li><span class="math">\\mathbf{d}_{\\mathbf{Q}} = \\mathbf{94}</span>  to  <span class="math">\\mathbf{m} = \\mathbf{36}</span> : We choose  <span class="math">\\deg_Y P = 1</span> ,  <span class="math">a = 0</span> ,  <span class="math">Q</span>  on the left, and we have  <span class="math">d = 51</span> ,  <span class="math">(\\deg(L_w), \\deg(R_w)) = (213, 256)</span> , and logarithmic cost  <span class="math">15.0 + 20.3 - 7.5</span> , hence  <span class="math">2^{27.8}</span>  s; the expected number of factors is 13.0, so the subsequent cost will be less than  <span class="math">2^{28.4}</span>  s.</li>

    </ul>

    <p class="text-gray-300">Table 1. Timings for testing a degree  <span class="math">n</span>  polynomial over  <span class="math">{\\mathbb{F}}_{{2}^{4}}</span>  for  <span class="math">m</span>  -smoothness.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">137</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">1.9 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">146</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">1.9 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">213</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">5.1 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">611</td>

            <td class="px-3 py-2 border-b border-gray-700">94</td>

            <td class="px-3 py-2 border-b border-gray-700">94 ms</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Continued Fraction Descent. For the continued fraction descent we multiply the target element by random powers of the generator and express the product as a ratio of two polynomials of degree at most 611. For each such expression we test if both the numerator and the denominator are 94-smooth. The logarithmic cost here is  <span class="math">17.7 + 17.7 - 3.4</span> , hence the cost is  <span class="math">2^{32.0}</span>  s. The expected number of degree 94 factors on both sides will be 13, so the subsequent cost will be less than  <span class="math">2^{32.8}</span>  s.</p>

    <p class="text-gray-300">Total Descent Cost</p>

    <p class="text-gray-300">The cost for computing an individual logarithm is therefore upper-bounded by <span class="math">2^{32.0}</span> s <span class="math">+2^{32.8}</span> s <span class="math">&lt;2^{34}</span> s.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">4.4 Summary</h3>

    <p class="text-gray-300">The main cost in our analysis is the linear algebra computation which takes about <span class="math">2^{40}</span> s, with the individual logarithm stage being considerably faster. In order to compare with the estimate in <em>[2]</em>, we write the main cost in terms of <span class="math">M_{r}</span> which gives <span class="math">2^{59}</span> <span class="math">M_{r}</span>, and thus an improvement by a factor of <span class="math">2^{69}</span>. Nevertheless, solving a system of cardinality <span class="math">2^{28}</span> is still a formidable challenge, but perhaps not so much for a well-funded adversary. For completeness we note that if one wants to avoid a linear algebra step of this size, then one can work over different fields, e.g., with <span class="math">q=2^{10}</span> and <span class="math">k=2</span>, or <span class="math">q=2^{12}</span> and <span class="math">k=1</span>. However, while this allows a partitioning of the linear algebra into smaller steps as described in §3.2 but at a slightly higher cost, the resulting descent cost is expected to be significantly higher.</p>

    <h2 id="sec-15" class="text-2xl font-bold">5 Solving the DLP in <span class="math">\\mathbb{F}_{2^{12\\cdot 367}}</span></h2>

    <p class="text-gray-300">In this section we present the details of our solution of a DLP in the 698-bit prime order <span class="math">r_{2}</span> subgroup of <span class="math">\\mathbb{F}_{2^{12\\cdot 367}}^{\\times}=\\mathbb{F}_{2^{4404}}^{\\times}</span>, which arises from the MOV attack applied to the Jacobian of the genus two supersingular curve (4). Magma verification code is provided in Appendix A. Note that the prime order elliptic curve <span class="math">E_{1}/\\mathbb{F}_{2^{367}}:Y^{2}+Y=X^{3}+X+1</span> with embedding degree 4 also embeds into <span class="math">\\mathbb{F}_{2^{4404}}</span>, so that logarithms on this curve could have easily been computed as well.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">5.1 Setup</h3>

    <p class="text-gray-300">To compute the target logarithm, as stated in §1 we applied a principle of parsimony, namely, we tried to solve all intermediate logarithms in <span class="math">\\mathbb{F}_{2^{12\\cdot 367}}</span>, considered as a degree 367 extension of <span class="math">\\mathbb{F}_{2^{12}}</span>, and only when this was not possible did we embed elements into the extension field <span class="math">\\mathbb{F}_{2^{24\\cdot 367}}</span> (by extending the base field to <span class="math">\\mathbb{F}_{2^{24}}</span>) and solve them there.</p>

    <p class="text-gray-300">All of the classical descent down to degree 8 was carried out over <span class="math">\\mathbb{F}_{2^{12\\cdot 367}}</span>, which we formed as the compositum of the following two extension fields. We defined <span class="math">\\mathbb{F}_{2^{12}}</span> using the irreducible polynomial <span class="math">U^{12}+U^{3}+1</span> over <span class="math">\\mathbb{F}_{2}</span>, and defined <span class="math">\\mathbb{F}_{2^{367}}</span> over <span class="math">\\mathbb{F}_{2}</span> using the degree 367 irreducible factor of <span class="math">h_{1}(X^{64})X-h_{0}(X^{64})</span>, where <span class="math">h_{1}=X^{5}+X^{3}+X+1</span>, and <span class="math">h_{0}=X^{6}+X^{4}+X^{2}+X+1</span>. Let <span class="math">u</span> and <span class="math">x</span> be roots of the extension defining polynomials in <span class="math">U</span> and <span class="math">X</span> respectively, and let <span class="math">c=(2^{4404}-1)/r_{2}</span>. Then <span class="math">g=x+u^{7}</span> is a generator of <span class="math">\\mathbb{F}_{2^{4404}}^{\\times}</span> and <span class="math">\\bar{g}=g^{c}</span> is a generator of the subgroup of order <span class="math">r_{2}</span>. As usual, our target element was chosen to be <span class="math">\\bar{x}_{\\pi}=x_{\\pi}^{c}</span> where</p>

    <p class="text-gray-300"><span class="math">x_{\\pi}=\\sum_{i=0}^{4403}(\\lfloor\\pi\\cdot 2^{i+1}\\rfloor\\bmod 2)\\cdot u^{11-(i\\bmod 12)}\\cdot x^{\\lfloor i/12\\rfloor}.</span></p>

    <p class="text-gray-300">The remaining logarithms were computed using a combination of tactics, over <span class="math">\\mathbb{F}_{2^{12}}</span> when possible, and over <span class="math">\\mathbb{F}_{2^{24}}</span> when not. These fields were constructed as degree 2 and 4 extensions of <span class="math">\\mathbb{F}_{2^{6}}</span>, respectively. To define <span class="math">\\mathbb{F}_{2^{6}}</span> we used the irreducible polynomial <span class="math">T^{6}+T+1</span>. We then defined <span class="math">\\mathbb{F}_{2^{12}}</span> using the irreducible polynomial <span class="math">V^{2}+tV+1</span> over <span class="math">\\mathbb{F}_{2^{6}}</span>, and <span class="math">\\mathbb{F}_{2^{24}}</span> using the irreducible polynomial <span class="math">W^{4}+W^{3}+W^{2}+t^{3}</span> over <span class="math">\\mathbb{F}_{2^{6}}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">5.2 Degree 1 Logarithms</p>

    <p class="text-gray-300">It was not possible to find enough relations for degree 1 elements over <span class="math">\\mathbb{F}_{2^{12}}</span>, so in accordance with our stated principle, we extended the base field to <span class="math">\\mathbb{F}_{2^{24}}</span> to compute the logarithms of all <span class="math">2^{24}</span> degree 1 elements. We used the polynomial time relation generation from §3.1, which took 47 hours. This relative sluggishness was due to the r.h.s. having degree <span class="math">d_{h}+1=7</span>, which must split over <span class="math">\\mathbb{F}_{2^{24}}</span>. However, this was faster by a factor of 24 than it would have been otherwise, thanks to <span class="math">h_{0}</span> and <span class="math">h_{1}</span> being defined over <span class="math">\\mathbb{F}_{2}</span>. This allowed us to use the technique from <em>[37]</em> to reduce the size of the factor base via the automorphism <span class="math">(x+a)\\mapsto(x+a)^{2^{367}}</span>, which fixes <span class="math">x</span> but has order 24 on all non-subfield elements of <span class="math">\\mathbb{F}_{2^{24}}</span>, since <span class="math">367\\equiv 7\\bmod 24</span> and <span class="math">\\gcd(7,24)=1</span>. This reduced the factor base size to 699252 elements, which was solved in 4896 core hours on a 24 core cluster using Lanczos’ algorithm, approximately <span class="math">24^{2}</span> times faster than if we had not used the automorphisms.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">5.3 Individual Logarithm</h3>

    <p class="text-gray-300">We performed the standard continued fraction initial split followed by degree-balanced classical descent as in §4.3, using Magma <em>[10]</em> and NTL <em>[44]</em>, to reduce the target element to an 8-smooth product in 641 and 38224 core hours respectively. The most interesting part of the descent was the elimination of the elements of degree up to 8 over <span class="math">\\mathbb{F}_{2^{12}}</span> into elements of degree one over <span class="math">\\mathbb{F}_{2^{24}}</span>, which we detail below. This phase was completed using Magma and took a further 8432 core hours. However, we think that the combined time of the classical and non-classical parts could be reduced significantly via a backwards-induction analysis of the elimination times of each degree.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">5.3.1 Small Degree Elimination</h4>

    <p class="text-gray-300">As stated above we used several tactics to achieve these eliminations. The first was the splitting of an element of even degree over <span class="math">\\mathbb{F}_{2^{12}}</span> into two elements of half the degree (which had the same logarithm modulo <span class="math">r_{2}</span>) over the larger field. This automatically provided the logarithms of all degree 2 elements over <span class="math">\\mathbb{F}_{2^{12}}</span>. Similarly elements of degree 4 and 8 over <span class="math">\\mathbb{F}_{2^{12}}</span> were rewritten as elements of degree 2 and 4 over <span class="math">\\mathbb{F}_{2^{24}}</span>, while we found that degree 6 elements were eliminable more efficiently by initially continuing the descent over <span class="math">\\mathbb{F}_{2^{12}}</span>, as with degree 5 and 7 elements.</p>

    <p class="text-gray-300">The second tactic was the application of Joux’s Gröbner basis elimination method from §3.3 to elements over <span class="math">\\mathbb{F}_{2^{12}}</span>, as well as elements over <span class="math">\\mathbb{F}_{2^{24}}</span>. However, in many cases condition (10) was violated, in which case we had to employ various recursive strategies in order to eliminate elements. In particular, elements of the same degree were allowed on the r.h.s. of relations, and we then attempted to eliminate these using the same (recursive) strategy. For degree 3 elements over <span class="math">\\mathbb{F}_{2^{12}}</span>, we even allowed degree 4 elements to feature on the r.h.s. of relations, since these were eliminable via the factorisation into degree 2 elements over <span class="math">\\mathbb{F}_{2^{24}}</span>.</p>

    <p class="text-gray-300">In Figure 1 we provide a flow chart for the elimination of elements of degree up to 8 over <span class="math">\\mathbb{F}_{2^{12}}</span>, and for the supporting elimination of elements of degree up to 4 over <span class="math">\\mathbb{F}_{2^{24}}</span>. Nearly all of the arrows in Figure 1 were necessary for these field parameters (the exceptions being that for degrees 4 and 8 over <span class="math">\\mathbb{F}_{2^{12}}</span> we could have initially continued the descent along the bottom row, but this would have been slower). The reason this ‘non-linear’ descent arises is due to <span class="math">q</span> being so small, and <span class="math">d_{H}</span> being relatively large, which increases the degree of the r.h.s. cofactors, thus decreasing the smoothness probability. Indeed these tactics were only borderline applicable for these parameters; if <span class="math">h_{0}</span> or <span class="math">h_{1}</span> had degree any larger than 6 then not only would most of the descent have been much harder, but it seems that one would be forced to compute the logarithms of degree 2 elements over <span class="math">\\mathbb{F}_{2^{24}}</span> using Joux’s linear system method from §3.2, greatly increasing</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. This diagram depicts the set of strategies employed to eliminate elements over  <span class="math">\\mathbb{F}_{2^{12}}</span>  of degree up to 8. The encircled numbers represent the degrees of elements over  <span class="math">\\mathbb{F}_{2^{12}}</span>  on the bottom row, and over  <span class="math">\\mathbb{F}_{2^{24}}</span>  on the top row. The arrows indicate how an element of a given degree is rewritten as a product of elements of other degrees, possibly over the larger field. Unadorned solid arrows indicate the maximum degree of elements obtained on the l.h.s. of the Gröbner basis elimination method; likewise dashed arrows indicate the degrees of elements obtained on the r.h.s. of the Gröbner basis elimination method, when these are greater than those obtained on the l.h.s. Dotted arrows indicate a fall-back strategy when the initial strategy fails. An  <span class="math">s</span>  indicates that the element is to be split over the larger field into two elements of half the degree. An  <span class="math">\\iota</span>  indicates that an element is promoted to the larger field. Finally, a loop indicates that one must use a recursive strategy in which further instances of the elimination in question must be solved in order to eliminate the element in question.</p>

    <p class="text-gray-300">the required number of core hours. As it was, we were able to eliminate degree 2 elements over  <span class="math">\\mathbb{F}_{2^{24}}</span>  on the fly, as we describe explicitly below.</p>

    <p class="text-gray-300">Finally, we note that our descent strategy is considerably faster than the alternative of embedding the DLP into  <span class="math">\\mathbb{F}_{2^{24}367}</span>  and performing a full descent in this field, even with the elimination on the fly of degree 2 elements over  <span class="math">\\mathbb{F}_{2^{24}}</span> , since much of the resulting computation would constitute superfluous effort for the task in hand.</p>

    <p class="text-gray-300">Degree 2 Elimination over  <span class="math">\\mathbb{F}_{2^{24}}</span>  Let  <span class="math">Q(Y)</span>  be a degree two element which is to be eliminated, i.e., written as a product of degree one elements. As in [19, 20] we first precompute the set of 64 elements  <span class="math">B \\in \\mathbb{F}_{2^{24}}</span>  such that the polynomial  <span class="math">f_{B}(X) = X^{65} + BX + B</span>  splits completely over  <span class="math">\\mathbb{F}_{2^{24}}</span>  (in fact these  <span class="math">B</span> 's happen to be in  <span class="math">\\mathbb{F}_{2^{12}}</span> , but this is not relevant to the method). We then find a Gaussian-reduced basis of the lattice  <span class="math">L_{Q(Y)}</span>  defined by</p>

    <div class="my-4 text-center"><span class="math-block">L _ {Q (Y)} = \\left\\{\\left(w _ {0} (Y), w _ {1} (Y)\\right) \\in \\mathbb {F} _ {2 ^ {2 4}} [ Y ] ^ {2}: w _ {0} (Y) h _ {0} (Y) + w _ {1} (Y) h _ {1} (Y) \\equiv 0 \\quad (\\mathrm {m o d} Q (Y)) \\right\\}.</span></div>

    <p class="text-gray-300">Such a basis has the form  <span class="math">(u_0, Y + u_1), (Y + v_0, v_1)</span> , with  <span class="math">u_i, v_i \\in \\mathbb{F}_{2^{24}}</span> , except in rare cases, see Remark 1. For  <span class="math">s \\in \\mathbb{F}_{2^{24}}</span>  we obtain lattice elements  <span class="math">(w_0(Y), w_1(Y)) = (Y + v_0 + su_0, sY + v_1 + su_1)</span> .</p>

    <p class="text-gray-300">Using the transformation detailed in §3, for each  <span class="math">B \\in \\mathbb{F}_{2^{24}}</span>  such that  <span class="math">f_{B}</span>  splits completely over  <span class="math">\\mathbb{F}_{2^{24}}</span>  we perform a Gröbner basis computation to find the set of  <span class="math">s \\in \\mathbb{F}_{2^{24}}</span>  that satisfy</p>

    <div class="my-4 text-center"><span class="math-block">B = \\frac {(s ^ {6 4} + u _ {0} s + v _ {0}) ^ {6 5}}{(u _ {0} s ^ {2} + (u _ {1} + v _ {0}) s + v _ {1}) ^ {6 4}},</span></div>

    <p class="text-gray-300">by first expressing  <span class="math">s</span>  in a  <span class="math">\\mathbb{F}_{2^{24}} / \\mathbb{F}_{2^6}</span>  basis, which results in a quadratic system in 4 variables. This ensures that the l.h.s. splits completely over  <span class="math">\\mathbb{F}_{2^{24}}</span> . For each such  <span class="math">s</span>  we check whether the r.h.s. cofactor of  <span class="math">Q(Y)</span> , which has degree 5, is 1-smooth. If this occurs, we have successfully eliminated  <span class="math">Q(Y)</span> .</p>

    <p class="text-gray-300">However, one expects on average just one  <span class="math">s</span>  per  <span class="math">B</span> , and so the probability of  <span class="math">Q(Y)</span>  being eliminated in this way is  <span class="math">1 - (1 - 1 / 5!)^{64} \\approx 0.415</span> , which was borne out in practice to two decimal places. Hence, we adopted a recursive strategy in which we stored all of the r.h.s. cofactors whose factorisation degrees had the form  <span class="math">(1,1,1,2)</span>  (denoted type 1), or  <span class="math">(1,2,2)</span>  (denoted type</p>

    <p class="text-gray-300">2). Then for each type 1 cofactor we checked to see if the degree 2 factor was eliminable by the above method. If none were eliminable we stored every type 1 cofactor of each degree 2 irreducible occurring in the list of type 1 cofactors of <span class="math">Q(Y)</span>. If none of these were eliminable (which occurred with probability just 0.003), then we reverted to the type 2 cofactors, and adopted the same strategy just specified for each of the degree 2 irreducible factors. Overall, we expected our strategy to fail about once in every <span class="math">6\\cdot 10^{6}</span> such <span class="math">Q(Y)</span>. This happened just once during our descent, and so we multiplied this <span class="math">Q(Y)</span> by a random linear polynomial over <span class="math">\\mathbb{F}_{2^{24}}</span> and performed a degree 3 elimination, which necessitates an estimated 32 degree 2 polynomials being simultaneously eliminable by the above method, which thanks to the high probability of elimination, will very likely be successful for any linear multiplier.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">5.4 Summary</h3>

    <p class="text-gray-300">Finally, after a total of approximately 52240 core hours (or <span class="math">2^{48}</span> <span class="math">M_{r_{2}}</span>), we found that <span class="math">\\bar{x}_{\\pi}=\\bar{g}^{\\log}</span>, with <span class="math">\\log=</span></p>

    <p class="text-gray-300"><span class="math">40932089202142351640934477339007025637256140979451423541922853874473604</span> <span class="math">39015351684721408233687689563902511062230980145272871017382542826764695</span> <span class="math">59843114767895545475795766475848754227211594761182312814017076893242\\;.</span></p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">During the descent, we encountered several polynomials <span class="math">Q(Y)</span> that were apparently not eliminable via the Gröbner basis method. We discovered that they were all factors of <span class="math">h_{1}(Y)\\cdot c+h_{0}(Y)</span> for <span class="math">c\\in\\mathbb{F}_{2^{12}}</span> or <span class="math">\\mathbb{F}_{2^{24}}</span>, and hence <span class="math">h_{0}(Y)/h_{1}(Y)\\equiv c\\pmod{Q(Y)}</span>. This implies that (9) is equal to <span class="math">F(c)G^{(q)}(Y)+F^{(q)}(Y)G(c)</span> modulo <span class="math">Q(Y)</span>, where <span class="math">G^{(q)}</span> denotes the Frobenius twisted <span class="math">G</span> and similarly for <span class="math">F^{(q)}</span>. This cannot become 0 modulo <span class="math">Q(Y)</span> if the degrees of <span class="math">F</span> and <span class="math">G</span> are smaller than the degree of <span class="math">Q</span>, unless <span class="math">F</span> and <span class="math">G</span> are both constants. However, thanks to the field representation, finding the logarithm of these <span class="math">Q(Y)</span> turns out to be easy. In particular, if <span class="math">h_{1}(Y)\\cdot c+h_{0}(Y)=Q(Y)\\cdot R(Y)</span> then <span class="math">Q(Y)=h_{1}(Y)\\cdot((h_{0}/h_{1})(Y)+c)/R(Y)=h_{1}(Y)\\cdot(X+c)/R(Y)</span>, and thus modulo <span class="math">r_{2}</span> we have <span class="math">\\log(Q(y))\\equiv\\log(x+c)-\\log(R(y))</span>, since <span class="math">\\log(h_{1}(y))\\equiv 0</span>. Since <span class="math">(x+c)</span> is in the factor base, if we are able to compute the logarithm of <span class="math">R(y)</span>, then we are done. In all the cases we encountered, the cofactor <span class="math">R(y)</span> was solvable by the above methods.</p>

    <h2 id="sec-21" class="text-2xl font-bold">6 Conclusion</h2>

    <p class="text-gray-300">We have introduced a new field representation and efficient descent principles which together make the recent DLP advances far more practical. As example demonstrations, we have applied these techniques to two binary fields of central interest to pairing-based cryptography, namely <span class="math">\\mathbb{F}_{2^{4\\cdot 1223}}</span> and <span class="math">\\mathbb{F}_{2^{12\\cdot 367}}</span>, which arise as the embedding fields of (the Jacobians of) a genus one and a genus two supersingular curve, respectively. When initially proposed, these fields were believed to be 128-bit secure, and even in light of the recent DLP advances, were believed to be 128-bit and 94.6-bit secure. On the contrary, our analysis indicates that the former field has approximately 59 bits of security and we have implemented a total break of the latter.</p>

    <h2 id="sec-22" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Jithra Adikari, M. Anwar Hasan, and Christophe Nègre. Towards faster and greener cryptoprocessor for eta pairing on supersingular elliptic curve over <span class="math">\\mathbb{F}_{2^{1223}}</span>. In Selected Areas in Cryptography—SAC 2012, volume 7707 of LNCS, pages 166–183. Springer, 2012.</li>

      <li>[</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[2] Gora Adj, Alfred Menezes, Thomaz Oliveira, and Francisco Rodríguez-Henríquez. Weakness of <span class="math">\\mathbb{F}_{2^{6\\cdot 509}}</span> for discrete logarithm cryptography. In Pairing-based Cryptography—Pairing 2013, volume 8365 of LNCS, pages 20–44. Springer, 2013.</li>

      <li>[3] Diego F. Aranha, Jean-Luc Beuchat, Jérémie Detrey, and Nicolas Estibals. Optimal eta pairing on supersingular genus-2 binary hyperelliptic curves. In Topics in Cryptology—CT-RSA 2012, volume 7178 of LNCS, pages 98–115. Springer, 2012.</li>

      <li>[4] Razvan Barbulescu, Pierrick Gaudry, Antoine Joux, and Emmanuel Thomé. A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic. In Advances in Cryptology—EUROCRYPT 2014, volume 8441 of LNCS, pages 1–16. Springer, 2014.</li>

      <li>[5] Paulo S. L. M. Barreto, Steven D. Galbraith, Colm Ó’ Héigeartaigh, and Michael Scott. Efficient pairing computation on supersingular abelian varieties. Des. Codes Cryptography, 42(3):239–271, March 2007.</li>

      <li>[6] Paulo S. L. M. Barreto, Hae Yong Kim, Ben Lynn, and Michael Scott. Efficient algorithms for pairing-based cryptosystems. In Advances in Cryptology—CRYPTO 2002, volume 2442 of LNCS, pages 354–368. Springer, 2002.</li>

      <li>[7] Jean-Luc Beuchat, Emmanuel López-Trejo, Luis Martínez-Ramos, Shigeo Mitsunari, and Francisco Rodríguez-Henríquez. Multi-core implementation of the Tate pairing over supersingular elliptic curves. In Cryptology and Network Security—CANS 2009, volume 5888 of LNCS, pages 413–432. Springer, 2009.</li>

      <li>[8] Antonia W. Bluher. On <span class="math">x^{s+1}+ax+b</span>. Finite Fields and Their Applications, 10(3):285–305, 2004.</li>

      <li>[9] Dan Boneh and Matt Franklin. Identity-based encryption from the Weil pairing. In Advances in Cryptology—CRYPTO 2001, volume 2139 of LNCS, pages 213–229. Springer, 2001.</li>

      <li>[10] Wieb Bosma, John Cannon, and Catherine Playoust. The Magma algebra system. I. The user language. J. Symbolic Comput., 24(3-4):235–265, 1997.</li>

      <li>[11] Sanjit Chatterjee, Darrel Hankerson, and Alfred Menezes. On the efficiency and security of pairing-based protocols in the type 1 and type 4 settings. In Arithmetic of Finite Fields, volume 6087 of LNCS, pages 114–134. Springer, 2010.</li>

      <li>[12] Don Coppersmith. Fast evaluation of logarithms in fields of characteristic two. IEEE Transactions on Information Theory, 30(4):587–593, 1984.</li>

      <li>[13] Don Coppersmith. Solving homogeneous linear equations over GF(2) via block Wiedemann algorithm. Mathematics of Computation, 62(205):333–350, 1994.</li>

      <li>[14] Iwan Duursma and Hyang-Sook Lee. Tate pairing implementation for hyperelliptic curves <span class="math">y^{2}=x^{p}-x+d</span>. In Advances in Cryptology—ASIACRYPT 2003, volume 2894 of LNCS, pages 111–123. Springer, 2003.</li>

      <li>[15] Jean-Charles Faugère. A new efficient algorithm for computing Gröbner bases (<span class="math">F_{4}</span>). J. Pure Appl. Algebra, 139(1-3):61–88, 1999.</li>

      <li>[16] Steven D. Galbraith. Supersingular curves in cryptography. In Advances in Cryptology—ASIACRYPT 2001, volume 2248 of LNCS, pages 495–513. Springer, 2001.</li>

      <li>[17] Steven D. Galbraith, Keith Harrison, and David Soldera. Implementing the Tate pairing. In Algorithmic Number Theory—ANTS-V, volume 2369 of LNCS, pages 324–337. Springer, 2002.</li>

      <li>[18] Santosh Ghosh, Dipanwita Roychowdhury, and Abhijit Das. High speed cryptoprocessor for <span class="math">\\eta_{t}</span> pairing on 128-bit secure supersingular elliptic curves over characteristic two fields. In Cryptographic Hardware and Embedded Systems—CHES 2011, volume 6917 of LNCS, pages 442–458. Springer, 2011.</li>

      <li>[19] Faruk Göloğlu, Robert Granger, Gary McGuire, and Jens Zumbrägel. On the function field sieve and the impact of higher splitting probabilities: Application to discrete logarithms in <span class="math">\\mathbb{F}_{2^{1971}}</span> and <span class="math">\\mathbb{F}_{2^{3164}}</span>. In Advances in Cryptology—CRYPTO 2013, volume 8043 of LNCS, pages 109–128. Springer, 2013.</li>

      <li>[20] Faruk Göloğlu, Robert Granger, Gary McGuire, and Jens Zumbrägel. Solving a 6120-bit DLP on a desktop computer. In Selected Areas in Cryptography—SAC 2013, volume 8282 of LNCS, pages 136–152. Springer, 2014.</li>

      <li>[21] Faruk Göloğlu, Robert Granger, Gary McGuire, and Jens Zumbrägel. Discrete Logarithms in <span class="math">GF(2^{1971})</span>. NMBRTHRY list, 19/2/2013.</li>

      <li>[22] Faruk Göloğlu, Robert Granger, Gary McGuire, and Jens Zumbrägel. Discrete Logarithms in <span class="math">GF(2^{6120})</span>. NMBRTHRY list, 11/4/2013.</li>

      <li>[23] Robert Granger. On the function field sieve and the impact of higher splitting probabilities, 2013. Presentation at the 17th Workshop on Elliptic Curve Cryptography, 16/9/2013.</li>

      <li>[24] Robert Granger. Solving a 6120-bit DLP on a desktop computer, 2013. Presentation at Selected Areas in Cryptography 2013, 15/8/2013.</li>

      <li>[25] Robert Granger, Thorsten Kleinjung, and Jens Zumbrägel. Discrete logarithms in the Jacobian of a genus 2 supersingular curve over <span class="math">GF(2^{367})</span>. NMBRTHRY list, 30/1/2014.</li>

      <li>[26] Robert Granger, Thorsten Kleinjung, and Jens Zumbrägel. Discrete Logarithms in <span class="math">GF(2^{9234})</span>. NMBRTHRY list, 31/1/2014.</li>

      <li>[27] Robert Granger, Dan Page, and Martijn Stam. Hardware and software normal basis arithmetic for pairing-based cryptography in characteristic three. IEEE Trans. Computers, 54(7):852–860, 2005.</li>

      <li>[28] Robert Granger, Dan Page, and Martijn Stam. On small characteristic algebraic tori in pairing-based cryptography. LMS J. Comput. Math., 9:64–85, 2006.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Torbjörn Granlund and the GMP development team. GNU MP: The GNU Multiple Precision Arithmetic Library, 5.0.5 edition, 2012. http://gmplib.org/.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>30. Darrel Hankerson, Alfred Menezes, and Michael Scott. Software implementation of pairings. In Identity-Based Cryptography, vol. 2, Cryptology and Information Security, pages 188–206. IOS Press, 2008.</li>

      <li>31. Antoine Joux. A one round protocol for tripartite Diffie-Hellman. In Algorithmic Number Theory—ANTS-VI, volume 1838 of Lecture Notes in Comput. Sci., pages 385–393. Springer, 2000.</li>

      <li>32. Antoine Joux. Faster index calculus for the medium prime case. Application to 1175-bit and 1425-bit finite fields. In Advances in Cryptology—EUROCRYPT 2013, volume 7881 of LNCS, pages 177–193. Springer, 2013.</li>

      <li>33. Antoine Joux. A new index calculus algorithm with complexity <span class="math">L(1/4+o(1))</span> in very small characteristic. In Selected Areas in Cryptography—SAC 2013, volume 8282 of LNCS, pages 355–379. Springer, 2014.</li>

      <li>34. Antoine Joux. Discrete Logarithms in <span class="math">GF(2^{1778})</span>. NMBRTHRY list, 11/2/2013.</li>

      <li>35. Antoine Joux. Discrete Logarithms in <span class="math">GF(2^{4080})</span>. NMBRTHRY list, 22/3/2013.</li>

      <li>36. Antoine Joux. Discrete Logarithms in <span class="math">GF(2^{6168})</span>. NMBRTHRY list, 21/5/2013.</li>

      <li>37. Antoine Joux and Reynald Lercier. The function field sieve in the medium prime case. In Advances in Cryptology—EUROCRYPT 2006, volume 4004 of LNCS, pages 254–270. Springer, 2006.</li>

      <li>38. Thorsten Kleinjung, Kazumaro Aoki, Jens Franke, Arjen K. Lenstra, Emmanuel Thomé, Joppe W. Bos, Pierrick Gaudry, Alexander Kruppa, Peter L. Montgomery, Dag Arne Osvik, Herman J. J. te Riele, Andrey Timofeev, and Paul Zimmermann. Factorization of a 768-bit RSA modulus. In Advances in Cryptology—CRYPTO 2010, volume 6223 of LNCS, pages 333–350. Springer, 2010.</li>

      <li>39. Arjen K. Lenstra. Unbelievable security: Matching AES security using public key systems. In Advances in Cryptology—ASIACRYPT 2001, volume 2248 of LNCS, pages 67–86. Springer, 2001.</li>

      <li>40. Alfred J. Menezes, Tatsuaki Okamoto, and Scott A. Vanstone. Reducing elliptic curve logarithms to logarithms in a finite field. IEEE Trans. Inform. Theory, 39(5):1639–1646, 1993.</li>

      <li>41. Ilya Popovyan. Efficient parallelization of lanczos type algorithms. Cryptology ePrint Archive, Report 2011/416, 2011. http://eprint.iacr.org/.</li>

      <li>42. Ryuichi Sakai, Shigeo Mitsunari, and Masao Kasahara. Cryptographic schemes based on pairing over elliptic curve. IEIC Technical Report, 101(214):75–80, 2001.</li>

      <li>43. Naoyuki Shinohara, Takeshi Shimoyama, Takuya Hayashi, and Tsuyoshi Takagi. Key length estimation of pairing-based cryptosystems using <span class="math">\\eta_{t}</span> pairing. In Information Security Practice and Experience, volume 7232 of LNCS, pages 228–244. Springer, 2012.</li>

      <li>44. Victor Shoup. NTL: A library for doing number theory, 5.5.2 edition, 2009. http://www.shoup.net/ntl/.</li>

      <li>45. Pierre-Jean Spaenlehauer. Solving multihomogeneous and determinantal systems algorithms - complexity - applications. Ph.D. thesis, Université Pierre et Marie Curie (UPMC), 2012.</li>

    </ul>

    <h2 id="sec-23" class="text-2xl font-bold">Appendix A</h2>

    <p class="text-gray-300">The following Magma script verifies the solution of the chosen DLP in the order <span class="math">r_{2}</span> subgroup of <span class="math">\\mathbb{F}_{2^{12\\cdot 367}}^{\\times}</span>:</p>

    <p class="text-gray-300">⬇ // Field setup F2 := GF(2); F2U<U> := PolynomialRing(F2);</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F2_12<u> := ext< F2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U^12 + U^3 + 1 >;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">F2_12X<X> := PolynomialRing(F2_12);</p>

    <p class="text-gray-300">modulus := (2^734 + 2^551 + 2^367 + 2^184 + 1) div (13 * 7170258097); cofactor := (2^4404 - 1) div modulus;</p>

    <p class="text-gray-300">h1 := X^5 + X^3 + X + 1; h0 := X^6 + X^4 + X^2 + X + 1; temp1 := Evaluate(h1, X^64) * X + Evaluate(h0, X^64); temp2 := X^17 + X^15 + X^14 + X^13 + X^12 + X^11 + X^10 + X^6 + 1; polyx := temp1 div temp2;</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fqx<x> := ext< F2_12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">polyx >;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">// This is a generator for the entire multiplicative group of GF(2^4404). g := x + u^7;</p>

    <p class="text-gray-300">// Generate the target element.</p>

    <p class="text-gray-300">pi := Pi(RealField(1500)); xpi := &+[ (Floor(pi <em> 2^(i+1)) mod 2) </em> u^(11-(i mod 12)) * x^(i div 12) : i in [0..4403]];</p>

    <p class="text-gray-300">log := 4093208920214235164093447733900702563725614097945142354192285387447\\ 36043901535168472140823368768956390251106223098014527287101738254282676469\\ 559843114767895545475795766475848754227211594761182312814017076893242;</p>

    <p class="text-gray-300">// If the following is true, then verification was successful (g^cofactor)^log eq xpi^cofactor;</p>

    <pre><code>
### Appendix B

This section provides the algorithmic details of the smoothness testing function used in §4 and §5. Given a polynomial $f(X)$ of degree $n$ over $\\mathbb{F}_{q}$, in order to test its $m$-smoothness we compute

$t(X)\\;:=\\;f^{\\prime}(X)\\prod_{\\lfloor m/2\\rfloor+1}^{m}(X^{q^{i}}-X)\\mod f\\,.$

Let $R$ be the quotient ring $\\mathbb{F}_{q}[X]/\\langle f\\rangle$ (so that $R\\cong\\mathbb{F}_{q}^{n}$ as vector spaces), and denote a residue class in $R$ by $[a(X)]$. A multiplication in $R$ can be computed using $2n^{2}$ $\\mathbb{F}_{q}$-multiplications. In order to obtain the above product our main task is to compute $[X^{q^{i}}]$ for $i\\in\\{\\lfloor m/2\\rfloor+1,\\ldots,m\\}$, after which we can compute $t(X)$ using $\\lceil m/2\\rceil$ $R$-multiplications.

#### How to Compute a Power $[X^{p^{rs}}]$

First we explain a method how to obtain a general power $[X^{p^{rs}}]$, where $p$ is the characteristic of $\\mathbb{F}_{q}$. We precompute $[X^{p^{r}}],[X^{2p^{r}}],\\ldots,[X^{(n-1)p^{r}}]$ by consecutively multiplying by $[X]$ (i.e., shifting). This requires $(n-1)(p^{r}-1)$ shifts, each using $n$ $\\mathbb{F}_{q}$-multiplications, so less than $n^{2}p^{r}$ $\\mathbb{F}_{q}$-multiplications in total.

With this precomputation we then can compute $p^{r}$-powering in $R$, i.e., one application of the map $\\varphi:R\\to R$, $\\alpha\\to\\alpha^{p^{r}}$, in the following way:

$\\big{[}\\sum_{i=0}^{n-1}a_{i}X^{i}\\big{]}^{p^{r}}=\\sum_{i=0}^{n-1}a_{i}^{p^{r}}\\big{[}X^{ip^{r}}\\big{]}$

This requires $n$ $p^{r}$-powering operations in $\\mathbb{F}_{q}$ (which we ignore) and $n$ scalar multiplications in $R$, hence $n^{2}$ $\\mathbb{F}_{q}$-multiplications. Finally, we compute the powers $[X^{p^{ri}}]$ by repeatedly applying the map $\\varphi$, i.e., $[X^{p^{ri}}]=\\varphi^{i}([X])=\\varphi^{i-1}([X^{p^{r}}])$, for $i\\in\\{2,\\ldots,s\\}$, which requires $(s-1)$ $p^{r}$-powerings in $R$. Altogether we can compute $[X^{p^{rs}}]$ in less than $n^{2}(p^{r}+s)$ $\\mathbb{F}_{q}$-operations.

For an alternative method of computing $[X^{p^{r}}],[X^{2p^{r}}],\\ldots,[X^{(n-1)p^{r}}]$ we assume that $[X^{p^{r}}]$ is already known. First, by multiplying by $[X]$ we obtain $[X^{p^{r}+1}],[X^{p^{r}+2}],\\ldots,[X^{p^{r}+(n-1)}]$ using $(n-1)$ shifts, hence less than $n^{2}$ $\\mathbb{F}_{q}$-multiplications. With this we can compute a multiplication by $X^{p^{r}}$, i.e.,

$\\big{[}\\sum_{i=0}^{n-1}a_{i}X^{i}\\big{]}\\cdot[X^{p^{r}}]=\\sum_{i=0}^{n-1}a_{i}\\big{[}X^{p^{r}+i}\\big{]}\\,,$

using $n^{2}$ $\\mathbb{F}_{q}$-multiplications. We apply this multiplication map repeatedly in order to compute $[X^{p^{r}}],[X^{2p^{r}}],\\ldots,[X^{(n-1)p^{r}}]$; instead of $n^{2}p^{r}$ $\\mathbb{F}_{q}$-multiplications, this method requires $n^{3}$ $\\mathbb{F}_{q}$-multiplications.

####

Computing the Powers $[X^{q^{i}}]$

We outline two strategies to compute the powers $[X^{q^{i}}]$ for $i\\in\\{1,\\ldots,m\\}$.

Strategy 1 Write $q=(p^{r})^{s}=p^{rs}$. As in the method outlined above we do a precomputation in order to represent the $p^{r}$-powering map in $R$. We then apply this map repeatedly in order to compute $[X^{p^{rj}}]$ for $j\\in\\{2,\\ldots,sm\\}$, and obtain this way the powers $[X^{q^{i}}]=[X^{p^{rsi}}]$.

This method requires about $n^{2}(p^{r}+sm)$ $\\mathbb{F}_{q}$-multiplications.

Strategy 2 First we compute $[X^{q}]$ by writing $q=p^{rs}$ and using the above method, which requires $n^{2}(p^{r}+s)$ $\\mathbb{F}_{q}$-multiplications. With this we can use the alternative method outlined above for precomputing the $q$-powering map in $R$; here we let $s=1$, i.e., $q=p^{r}$. We then apply this map repeatedly to obtain the powers $[X^{q^{i}}]$. This method requires about $n^{2}(p^{r}+s+n+m)$ $\\mathbb{F}_{q}$-multiplications, and corresponds to the smoothness test in the Adj et al. paper; but the version here has an improved running time (the previous one was $n^{2}(2n+m+4\\log q)$ $\\mathbb{F}_{q}$-multiplications).

#### Examples

In the case $q=2^{8}$ the running time (in $\\mathbb{F}_{q}$-multiplications) using Strategy 1 and $s=2$ is $n^{2}(16+2m)$, while using Strategy 2 and $s=4$ it is $n^{2}(8+n+m)$. When $q=2^{4}$ the running time using Strategy 1 and $s=1$ is $n^{2}(16+m)$, and using Strategy 2 and $s=2$ is $n^{2}(6+n+m)$. Hence, for typical values of $n$ and $m$ we prefer and implement Strategy 1. For example, if $q=2^{4}$, $n=611$, $m=94$ (see §4.3) we need $110n^{2}$ $\\mathbb{F}_{q}$-multiplications.

Remark 2. Recall that in either case, in order to obtain $t(X)$ and thus to complete the smoothness test, we have to consider the final $\\lceil m/2\\rceil$ $R$-multiplications. This requires an additional cost of about $n^{2}m$ $\\mathbb{F}_{q}$-multiplications.

##</code></pre>`;
---

<BaseLayout title="Breaking `128-bit Secure&#x27; Supersingular Binary Curves (or ho... (2014/119)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/119
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
