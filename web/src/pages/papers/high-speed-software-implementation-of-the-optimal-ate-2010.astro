---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2010/354';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'High-Speed Software Implementation of the Optimal Ate Pairing over Barreto-Naehrig Curves';
const AUTHORS_HTML = 'Jean-Luc Beuchat, Jorge Enrique González Díaz, Shigeo Mitsunari, Eiji Okamoto, Francisco Rodríguez-Henríquez, Tadanori Teruya';

const CONTENT = `    <p class="text-gray-300">Jean-Luc Beuchat¹, Jorge E. González-Díaz², Shigeo Mitsunari³, Eiji Okamoto¹, Francisco Rodríguez-Henríquez², and Tadanori Teruya¹</p>

    <p class="text-gray-300">¹ Graduate School of Systems and Information Engineering, University of Tsukuba, 1-1-1 Tennodai, Tsukuba, Ibaraki, 305-8573, Japan ² Computer Science Department, Centro de Investigación y de Estudios Avanzados del IPN, Av. Instituto Politécnico Nacional No. 2508, 07300 México City, México ³ Cybozu Labs, Inc., Akasaka Twin Tower East 15F, 2-17-22 Akasaka, Minato-ku, Tokyo 107-0052</p>

    <p class="text-gray-300">Abstract. This paper describes the design of a fast software library for the computation of the optimal ate pairing on a Barreto–Naehrig elliptic curve. Our library is able to compute the optimal ate pairing over a 254-bit prime field <span class="math">\\mathbb{F}_p</span>, in just 2.33 million of clock cycles on a single core of an Intel Core i7 2.8GHz processor, which implies that the pairing computation takes 0.832msec. We are able to achieve this performance by a careful implementation of the base field arithmetic through the usage of the customary Montgomery multiplier for prime fields. The prime field is constructed via the Barreto–Naehrig polynomial parametrization of the prime <span class="math">p</span> given as, <span class="math">p = 36t^4 + 36t^3 + 24t^2 + 6t + 1</span>, with <span class="math">t = 2^{62} - 2^{54} + 2^{44}</span>. This selection of <span class="math">t</span> allows us to obtain important savings for both the Miller loop as well as the final exponentiation steps of the optimal ate pairing.</p>

    <p class="text-gray-300">Keywords: Tate pairing, optimal pairing, Barreto–Naehrig curve, ordinary curve, finite field arithmetic, bilinear pairing software implementation.</p>

    <p class="text-gray-300">The protocol solutions provided by pairing-based cryptography can only be made practical if one can efficiently compute bilinear pairings at high levels of security. Back in 1986, Victor Miller proposed in [26, 27] an iterative algorithm that can evaluate rational functions from scalar multiplications of divisors, thus allowing to compute bilinear pairings at a linear complexity cost with respect to the size of the input. Since then, several authors have found further algorithmic improvements to decrease the complexity of Miller's algorithm by reducing its loop length [3, 4, 12, 20, 21, 38], and by constructing pairing-friendly elliptic curves [5, 14, 29] and pairing-friendly tower extensions of finite fields [6, 24].</p>

    <p class="text-gray-300">Roughly speaking, an asymmetric bilinear pairing can be defined as the non-degenerate bilinear mapping, <span class="math">\\hat{e}:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\rightarrow~{}\\mathbb{G}_{3}</span>, where both <span class="math">\\mathbb{G}_{1}</span>, <span class="math">\\mathbb{G}_{2}</span> are finite cyclic additive groups with prime order <span class="math">r</span>, whereas <span class="math">\\mathbb{G}_{3}</span> is a multiplicative cyclic group whose order is also <span class="math">r</span>. Additionally, as it was mentioned above, for cryptographic applications it is desirable that pairings can be computed efficiently. When <span class="math">\\mathbb{G}_{1}=\\mathbb{G}_{2}</span>, we say that the pairing is symmetric, otherwise, if <span class="math">\\mathbb{G}_{1}\\neq\\mathbb{G}_{2}</span>, the pairing is asymmetric <em>[15]</em>.</p>

    <p class="text-gray-300">Arguably the <span class="math">\\eta_{T}</span> pairing <em>[3]</em> is the most efficient algorithm for symmetric pairings that are always defined over supersingular curves. In the case of asymmetric pairings, recent breakthroughs include the ate pairing <em>[21]</em>, the R-ate pairing <em>[25]</em>, and the optimal ate pairing <em>[38]</em>.</p>

    <p class="text-gray-300">Several authors have presented software implementations of bilinear pairings targeting the 128-bit security level <em>[1, 8, 10, 16, 18, 23, 31, 32]</em>. By taking advantage of the eight cores of a dual quad-core Intel Xeon 45nm, the software library presented in <em>[1]</em> takes 3.02 millions of cycles to compute the <span class="math">\\eta_{T}</span> pairing on a supersingular curve defined over <span class="math">\\mathbb{F}_{2^{1223}}</span>. Authors in <em>[8]</em> report 5.42 millions of cycles to compute the <span class="math">\\eta_{T}</span> pairing on a supersingular curve defined over <span class="math">\\mathbb{F}_{3^{509}}</span> on an Intel Core i7 45nm processor using eight cores. The software library presented in <em>[32]</em> takes 4.470 millions of cycles to compute the optimal ate pairing on a 257-bit BN curve using only one core of an Intel Core 2 Quad Q6600 processor.</p>

    <p class="text-gray-300">This paper addresses the efficient software implementation of asymmetric bilinear pairings at high security levels. We present a library that performs the optimal ate pairing over a 254-bit Barreto–Naehrig (BN) curve in just 2.33 million of clock cycles on a single core of an Intel i7 2.8GHz processor, which implies that the optimal ate pairing is computed in 0.832msec. To the best of our knowledge, this is the first time that a software or a hardware accelerator reports a high security level pairing computation either symmetric or asymmetric, either on one core or on a multi-core platform, in less than one millisecond. After a careful selection of a pairing-friendly elliptic curve and the tower field (Sections 2 and 3), we describe the computational complexity associated to the execution of the optimal ate pairing (Section 4). Then, we describe our approach to implement arithmetic over the underlying field <span class="math">\\mathbb{F}_{p}</span> and to perform tower field arithmetic (Section 5), and we give benchmarking results of our software library (Section 6).</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 Optimal Ate Pairing over Barreto–Naehrig Curves</h2>

    <p class="text-gray-300">Barreto and Naehrig <em>[5]</em> described a method to construct pairing-friendly ordinary elliptic curves over a prime field <span class="math">\\mathbb{F}_{p}</span>. Barreto–Naehrig curves (or BN curves) are defined by the equation <span class="math">E:y^{2}=x^{3}+b</span>, where <span class="math">b\\neq 0</span>. Their embedding degree <span class="math">k</span> is equal to 12. Furthermore, the number of <span class="math">\\mathbb{F}_{p}</span>-rational points of <span class="math">E</span>, denoted by <span class="math">r</span> in the following, is a prime. The characteristic <span class="math">p</span> of the prime field, the group order <span class="math">r</span>, and the trace of Frobenius <span class="math">t_{r}</span> of the curve are parametrized as</p>

    <p class="text-gray-300">follows <em>[5]</em>:</p>

    <p class="text-gray-300"><span class="math">p(t)</span> <span class="math">=36t^{4}+36t^{3}+24t^{2}+6t+1,</span> <span class="math">r(t)</span> <span class="math">=36t^{4}+36t^{3}+18t^{2}+6t+1,</span> (1) <span class="math">t_{r}(t)</span> <span class="math">=6t^{2}+1,</span></p>

    <p class="text-gray-300">where <span class="math">t\\in\\mathbb{Z}</span> is an arbitrary integer such that <span class="math">p=p(t)</span> and <span class="math">r=r(t)</span> are both prime numbers. Additionally, <span class="math">t</span> must be large enough to guarantee an adequate security level. For a security level equivalent to AES-128, we should select <span class="math">t</span> such that <span class="math">\\log_{2}(r(t))\\geq 256</span> and <span class="math">3000\\leq k\\cdot\\log_{2}(p(t))\\leq 5000</span> <em>[14]</em>. For this to be possible <span class="math">t</span> should have roughly 64 bits.</p>

    <p class="text-gray-300">Let <span class="math">E[r]</span> denote the <span class="math">r</span>-torsion subgroup of <span class="math">E</span> and <span class="math">\\pi_{p}</span> be the Frobenius endomorphism <span class="math">\\pi_{p}:E\\to E</span> given by <span class="math">\\pi_{p}(x,y)=(x^{p},y^{p})</span>. We define <span class="math">\\mathbb{G}_{1}=E[r]\\cap\\mathrm{Ker}(\\pi_{p}-[1])=E(\\mathbb{F}_{p})[r]</span>, <span class="math">\\mathbb{G}_{2}=E[r]\\cap\\mathrm{Ker}(\\pi_{p}-[p])\\subseteq E(\\mathbb{F}_{p^{12}})[r]</span>, and <span class="math">\\mathbb{G}_{3}=\\mu_{r}\\subset\\mathbb{F}_{p^{12}}^{<em>}</span> (</em>i.e.<em> the group of <span class="math">r</span>-th roots of unity). Since we work with a BN curve, <span class="math">r</span> is a prime and <span class="math">\\mathbb{G}_{1}=E(\\mathbb{F}_{p})[r]=E(\\mathbb{F}_{p})</span>. The optimal ate pairing on the BN curve <span class="math">E</span> is a non-degenerate and bilinear pairing given by the map </em>[30, 32, 38]*:</p>

    <p class="text-gray-300"><span class="math">a_{\\mathrm{opt}}:\\mathbb{G}_{2}\\times\\mathbb{G}_{1}</span> <span class="math">\\longrightarrow\\mathbb{G}_{3}</span> <span class="math">(Q,P)</span> <span class="math">\\longmapsto\\big{(}f_{6t+2,Q}(P)\\cdot l_{[6t+2]Q,\\pi_{p}(Q)}(P)\\cdot</span> <span class="math">l_{[6t+2]Q+\\pi_{p}(Q),-\\pi_{p}^{2}(Q)}(P)\\big{)}^{\\frac{\\kappa^{12}-1}{r}},</span></p>

    <p class="text-gray-300">where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f_{s,Q}</span>, for <span class="math">s\\in\\mathbb{N}</span> and <span class="math">Q\\in\\mathbb{G}_{2}</span>, is a family of normalized <span class="math">\\mathbb{F}_{p^{12}}</span>-rational functions with divisor <span class="math">(f_{s,Q})=s(Q)-([s]Q)-(s-1)(\\mathcal{O})</span>, where <span class="math">\\mathcal{O}</span> denotes the point at infinity.</li>

      <li><span class="math">l_{Q_{1},Q_{2}}</span> is the equation of the line corresponding to the addition of <span class="math">Q_{1}\\in\\mathbb{G}_{2}</span> with <span class="math">Q_{2}\\in\\mathbb{G}_{2}</span>.</li>

    </ul>

    <p class="text-gray-300">Algorithm 1 shows how we compute the optimal ate pairing in this work. Our approach can be seen as a signed-digit version of the algorithm utilized in <em>[32]</em>, where both point additions and point subtractions are allowed. The Miller loop (lines 3–10) calculates the value of the rational function <span class="math">f_{6t+2,Q}</span> at point <span class="math">P</span>. In lines 11–13 the product of the line functions <span class="math">l_{[6t+2]Q,\\pi_{p}(Q)}(P)\\cdot l_{[6t+2]Q+\\pi_{p}(Q),-\\pi_{p}^{2}(Q)}(P)</span> is multiplied by <span class="math">f_{6t+2,Q}(P)</span>. The so-called final exponentiation is computed in line 14. A detailed summary of the computational costs associated to Algorithm 1 can be found in Section 4.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The BN curves admit a sextic twist <span class="math">E^{\\prime}/\\mathbb{F}_{p^{2}}:y^{2}=x^{3}+b/\\xi</span> defined over <span class="math">\\mathbb{F}_{p^{2}}</span>, where <span class="math">\\xi\\in\\mathbb{F}_{p^{2}}</span> is an element that is neither a square nor a cube in <span class="math">\\mathbb{F}_{p^{2}}</span>, and that has to be carefully selected such that $r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\#E^{\\prime}(\\mathbb{F}_{p^{2}})<span class="math"> holds. This means that pairing computations can be restricted to points </span>P<span class="math"> and </span>Q^{\\prime}<span class="math"> that belong to </span>E(\\mathbb{F}_{p})<span class="math"> and </span>E^{\\prime}(\\mathbb{F}_{p^{2}})<span class="math">, respectively, since we can represent the points in </span>\\mathbb{G}_{2}$ by points on the twist <em>[5, 21, 38]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Algorithm 1 Optimal ate pairing over Barreto–Naehrig curves. 0: <span class="math">P\\in\\mathbb{G}_{1}</span> and <span class="math">Q\\in\\mathbb{G}_{2}</span>. 0: <span class="math">a_{\\mathrm{opt}}(Q,P)</span>. 1: Write <span class="math">s=6t+2</span> as <span class="math">s=\\sum_{i=0}^{L-1}s_{i}2^{i}</span>, where <span class="math">s_{i}\\in\\{-1,0,1\\}</span>; 2: <span class="math">T\\leftarrow Q</span>, <span class="math">f\\leftarrow 1</span>; 3: for <span class="math">i=L-2</span> to <span class="math">0</span> do 4: <span class="math">f\\leftarrow f^{2}\\cdot l_{T,T}(P)</span>; <span class="math">T\\leftarrow 2T</span>; 5: if <span class="math">s_{i}=-1</span> then 6: <span class="math">f\\leftarrow f\\cdot l_{T,-Q}(P)</span>; <span class="math">T\\leftarrow T-Q</span>; 7: else if <span class="math">s_{i}=1</span> then 8: <span class="math">f\\leftarrow f\\cdot l_{T,Q}(P)</span>; <span class="math">T\\leftarrow T+Q</span>; 9: end if 10: end for 11: <span class="math">Q_{1}\\leftarrow\\pi_{p}(Q)</span>; <span class="math">Q_{2}\\leftarrow\\pi_{p^{2}}(Q)</span>; 12: <span class="math">f\\leftarrow f\\cdot l_{T,Q_{1}}(P)</span>; <span class="math">T\\leftarrow T+Q_{1}</span>; 13: <span class="math">f\\leftarrow f\\cdot l_{T,-Q_{2}}(P)</span>; <span class="math">T\\leftarrow T-Q_{2}</span>; 14: <span class="math">f\\leftarrow f^{(p^{12}-1)/r}</span>; 15: return <span class="math">f</span>;</p>

    <h2 id="sec-4" class="text-2xl font-bold">3 Tower Extension Field Arithmetic</h2>

    <p class="text-gray-300">Since <span class="math">k=12=2^{2}\\cdot 3</span>, the tower extensions can be created using irreducible binomials only. This is because <span class="math">x^{k}-\\beta</span> is irreducible over <span class="math">\\mathbb{F}_{p}</span> provided that <span class="math">\\beta\\in\\mathbb{F}_{p}</span> is neither a square nor a cube in <span class="math">\\mathbb{F}_{p}</span> <em>[24]</em>. Hence, the tower extension can be constructed by simply adjoining a cube or square root of such element <span class="math">\\beta</span> and then the cube or square root of the previous root. This process should be repeated until the desired extension of the tower has been reached.</p>

    <p class="text-gray-300">Accordingly, we decided to represent <span class="math">\\mathbb{F}_{p^{12}}</span> using the same tower extension of <em>[18]</em>, namely, we first construct a quadratic extension, which is followed by a cubic extension and then by a quadratic one, using the following irreducible binomials:</p>

    <p class="text-gray-300"><span class="math">\\mathbb{F}_{p^{2}}</span> <span class="math">=\\mathbb{F}_{p}[u]/(u^{2}-\\beta),</span> <span class="math">\\text{where }\\beta=-5,</span> <span class="math">\\mathbb{F}_{p^{6}}</span> <span class="math">=\\mathbb{F}_{p^{2}}[v]/(v^{3}-\\xi),</span> <span class="math">\\text{where }\\xi=u,</span> (2) <span class="math">\\mathbb{F}_{p^{12}}</span> <span class="math">=\\mathbb{F}_{p^{6}}[w]/(w^{2}-v).</span></p>

    <p class="text-gray-300">We adopted the tower extension of Equation (2), mainly because field elements <span class="math">f\\in\\mathbb{F}_{p^{12}}</span> can be seen as a quadratic extension of <span class="math">\\mathbb{F}_{p^{6}}</span>, and hence they can be represented as <span class="math">f=g+hw</span>, with <span class="math">g</span>, <span class="math">h\\in\\mathbb{F}_{p^{6}}</span>. This towering will help us to exploit the fact that in the hard part of the final exponentiation we will deal with field elements <span class="math">f\\in\\mathbb{F}_{p^{12}}</span> that become unitary <em>[35, 36]</em>, i.e., elements that belong to the cyclotomic subgroup <span class="math">\\mathbb{G}_{\\Phi_{k}}(\\mathbb{F}_{p^{2}})</span> as defined in <em>[17]</em>. Such elements satisfy, <span class="math">f^{p^{6}+1}=1</span>, which means that <span class="math">f^{-1}=f^{p^{6}}=g-hw</span>. In other words, inversion of such elements can be accomplished by simple conjugation. This nice feature opens the door for using addition-subtraction chains in the final exponentiation step, which is especially valuable for our binary signed choice of the parameter <span class="math">t</span></p>

    <p class="text-gray-300">Software Implementation of the Optimal Ate Pairing over BN curves</p>

    <p class="text-gray-300">We also stress that our specific <span class="math">t</span> selection permits to use <span class="math">\\xi=u\\in\\mathbb{F}_{p}</span>, which will yield important savings in the arithmetic computational cost as discussed next.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">3.1 Computational Costs of the Tower Extension Field Arithmetic</h3>

    <p class="text-gray-300">The tower extension arithmetic algorithms used in this work were directly adopted from <em>[18]</em>. Let <span class="math">(a,m,s,i)</span>, <span class="math">(\\tilde{a},\\tilde{m},\\tilde{s},\\tilde{i})</span>, and <span class="math">(A,M,S,I)</span> denote the cost of field addition, multiplication, squaring, and inversion in <span class="math">\\mathbb{F}_{p}</span>, <span class="math">\\mathbb{F}_{p^{2}}</span>, and <span class="math">\\mathbb{F}_{p^{6}}</span>, respectively. From our implementation (see Section 5), we observed experimentally that <span class="math">m=s=8a</span> and <span class="math">i=48.3m</span>. We summarize the towering arithmetic costs as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the field <span class="math">\\mathbb{F}_{p^{2}}</span>, we used Karatsuba multiplication and the complex method for squaring, at a cost of <span class="math">3</span> and <span class="math">2</span> field multiplications in <span class="math">\\mathbb{F}_{p}</span>, respectively. Inversion of an element <span class="math">A=a_{0}+a_{1}u\\in\\mathbb{F}_{p^{2}}</span>, can be found from the identity, <span class="math">(a_{0}+a_{1}u)^{-1}=(a_{0}-a_{1}u)/(a_{0}^{2}-\\beta a_{1}^{2})</span>. Using once again the Karatsuba method, field multiplication in <span class="math">\\mathbb{F}_{p^{6}}</span> can be computed at a cost of <span class="math">6\\tilde{m}</span> plus several addition operations. All these three operations require the multiplication in the base field by the constant coefficient <span class="math">\\beta\\in\\mathbb{F}_{p}</span> of the irreducible binomial <span class="math">u^{2}-\\beta</span>. We refer to this operation as <span class="math">m_{\\beta}</span> Additionally, we sometimes need to compute the multiplication of an arbitrary element in <span class="math">\\mathbb{F}_{p^{2}}</span> times the constant <span class="math">\\xi=u\\in\\mathbb{F}_{p}</span> at a cost of one multiplication by the constant <span class="math">\\beta</span>. We refer to this operation as <span class="math">m_{\\xi}</span>, but it is noticed that the cost of <span class="math">m_{\\xi}</span> is essentially the same of that of <span class="math">m_{\\beta}</span>.</li>

      <li>Squaring in <span class="math">\\mathbb{F}_{p^{6}}</span> can be computed via the formula derived in <em>[9]</em> at a cost of <span class="math">2\\tilde{m}+3\\tilde{s}</span> plus some addition operations. Inversion in the sextic extension can be computed at a cost of <span class="math">9\\tilde{m}+3\\tilde{s}+4m_{\\beta}+5\\tilde{a}+\\tilde{i}</span> <em>[34]</em>.</li>

      <li>Since our field towering constructed <span class="math">\\mathbb{F}_{p^{12}}</span> as a quadratic extension of <span class="math">\\mathbb{F}_{p^{6}}</span>, the arithmetic costs of the quadratic extension apply. Hence, a field multiplication, squaring and inversion costs in <span class="math">\\mathbb{F}_{p^{12}}</span> are, <span class="math">3M+5A</span>, <span class="math">2M+5A</span> and <span class="math">2M+2S+2A+I</span>, respectively. However, if <span class="math">f\\in\\mathbb{F}_{p^{12}}</span>, belongs to the cyclotomic subgroup <span class="math">\\mathbb{G}_{\\Phi_{6}}(\\mathbb{F}_{p^{2}})</span>, its field squaring <span class="math">f^{2}</span> can be reduced to three squarings in <span class="math">\\mathbb{F}_{p^{4}}</span> <em>[17]</em>.</li>

    </ul>

    <p class="text-gray-300">Table 1 lists the computational costs of the tower extension field arithmetic in terms of the <span class="math">\\mathbb{F}_{p^{2}}</span> field arithmetic operations, namely, <span class="math">(\\tilde{a},\\tilde{m},\\tilde{s},\\tilde{i})</span>.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">3.2 Frobenius Operator</h3>

    <p class="text-gray-300">Raising an element <span class="math">f\\in\\mathbb{F}_{p^{12}}=\\mathbb{F}_{p^{6}}[w]/(w^{2}-v)</span> to the <span class="math">p</span>-power, is an arithmetic operation needed in the final exponentiation (line 14) of the optimal ate pairing (Algorithm 1). We briefly describe in the following how to compute <span class="math">f^{p}</span> efficiently.</p>

    <p class="text-gray-300">We first remark that the field extension <span class="math">\\mathbb{F}_{p^{12}}</span> can be also represented as a sextic extension of the quadratic field, i.e., <span class="math">\\mathbb{F}_{p^{12}}=\\mathbb{F}_{p^{2}}[W]/(W^{6}-u)</span>, with <span class="math">W=w</span>. Hence, we can write <span class="math">f=g+hw\\in\\mathbb{F}_{p^{12}}</span>, with <span class="math">g</span>, <span class="math">h\\in\\mathbb{F}_{p^{6}}</span> such that, <span class="math">g=g_{0}+g_{1}v+g_{2}v^{2}</span>, <span class="math">h=h_{0}+h_{1}v+h_{2}v^{2}</span>, where <span class="math">g_{i},h_{i}\\in\\mathbb{F}_{p^{2}}</span>, for <span class="math">i=1,2,3</span>. This</p>

    <p class="text-gray-300">J.-L. Beuchat et al.</p>

    <p class="text-gray-300">Table 1. Computational costs of the tower extension field arithmetic.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Field</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Add./Sub.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Mult.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Squaring</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Inversion</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fp2</td>

            <td class="px-3 py-2 border-b border-gray-700">a=2a</td>

            <td class="px-3 py-2 border-b border-gray-700">m=3m+3a+mβ</td>

            <td class="px-3 py-2 border-b border-gray-700">s=2m+3a+mβ</td>

            <td class="px-3 py-2 border-b border-gray-700">i=4m+mβ+2a+i</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fp6</td>

            <td class="px-3 py-2 border-b border-gray-700">3a</td>

            <td class="px-3 py-2 border-b border-gray-700">6m+2mβ+15a</td>

            <td class="px-3 py-2 border-b border-gray-700">2m+3s+2mβ+8a</td>

            <td class="px-3 py-2 border-b border-gray-700">9m+3s+4mβ+4a+i</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fp12</td>

            <td class="px-3 py-2 border-b border-gray-700">6a</td>

            <td class="px-3 py-2 border-b border-gray-700">18m+6mβ+60a</td>

            <td class="px-3 py-2 border-b border-gray-700">12m+4mβ+45a</td>

            <td class="px-3 py-2 border-b border-gray-700">25m+9s+12mβ+61a+i</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GΦ6(Fp2)</td>

            <td class="px-3 py-2 border-b border-gray-700">6a</td>

            <td class="px-3 py-2 border-b border-gray-700">18m+6mβ+60a</td>

            <td class="px-3 py-2 border-b border-gray-700">9s+4mβ+30a</td>

            <td class="px-3 py-2 border-b border-gray-700">Conjugation</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">means that  <span class="math">f</span>  can be equivalently written as,  <span class="math">f = g + hw = g_0 + h_0W + g_1W^2 + h_1W^3 + g_2W^4 + h_2W^5</span> .</p>

    <p class="text-gray-300">We note that the  <span class="math">p</span> -power of an arbitrary element in the quadratic extension field  <span class="math">\\mathbb{F}_{p^2}</span>  can be computed essentially free of cost as follows. Let  <span class="math">b \\in \\mathbb{F}_{p^2}</span>  be an arbitrary element that can be represented as  <span class="math">b = b_0 + b_1u</span> . Then,  <span class="math">(b)^{p^{2i}} = b</span>  and  <span class="math">(b)^{p^{2i-1}} = \\bar{b}</span> , with  <span class="math">\\bar{b} = b_0 - b_1u</span> , for  <span class="math">i \\in \\mathbb{N}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\bar{g}_i</span> ,  <span class="math">\\bar{h}_i</span> , denote the conjugates of  <span class="math">g_i</span> ,  <span class="math">h_i</span> , for  <span class="math">i = 1,2,3</span>  respectively. Then, using the identity  <span class="math">W^p = u^{(p - 1) / 6}W</span> , we can write,  <span class="math">(W^i)^p = \\gamma_{1,i}W^i</span> , with  <span class="math">\\gamma_{1,i} = u^{i(p - 1) / 6}</span> , for  <span class="math">i = 1,\\ldots ,5</span> . From the definitions given above, we can compute  <span class="math">f^p</span>  as,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f ^ {p} = \\left(g _ {0} + h _ {0} W + g _ {1} W ^ {2} + h _ {1} W ^ {3} + g _ {2} W ^ {4} + h _ {2} W ^ {5}\\right) ^ {p} \\\\ = \\bar {g} _ {0} + \\bar {h} _ {0} W ^ {p} + \\bar {g} _ {1} W ^ {2 p} + \\bar {h} _ {1} W ^ {3 p} + \\bar {g} _ {2} W ^ {4 p} + \\bar {h} _ {2} W ^ {5 p} \\\\ = \\bar {g} _ {0} + \\bar {h} _ {0} \\gamma_ {1, 1} W + \\bar {g} _ {1} \\gamma_ {1, 2} W ^ {2} + \\bar {h} _ {1} \\gamma_ {1, 3} W ^ {3} + \\bar {g} _ {2} \\gamma_ {1, 4} W ^ {4} + \\bar {h} _ {2} \\gamma_ {1, 5} W ^ {5}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The equation above has a computational cost of 5 multiplications in  <span class="math">\\mathbb{F}_p</span>  and 5 conjugations in  <span class="math">\\mathbb{F}_{p^2}</span> . We can follow a similar procedure for computing  <span class="math">f^{p^2}</span>  and  <span class="math">f^{p^3}</span> , which are arithmetic operations required in the hard part of the final exponentiation of Algorithm 1. For that, we must pre-compute and store the per-field constants  <span class="math">\\gamma_{1,i} = u^{i\\cdot (p - 1) / 6}</span> ,  <span class="math">\\gamma_{2,i} = \\gamma_{1,i}\\cdot \\bar{\\gamma}_{1,i}</span> , and  <span class="math">\\gamma_{3,i} = \\gamma_{1,i}\\cdot \\gamma_{2,i}</span>  for  <span class="math">i = 1,\\ldots ,5</span> .</p>

    <p class="text-gray-300">In this work we considered several choices of the parameter  <span class="math">t</span> , required for defining  <span class="math">p(t)</span> ,  <span class="math">r(t)</span> , and  <span class="math">t_r(t)</span>  of Equation (1). We found 64-bit values of  <span class="math">t</span>  with Hamming weight as low as 2 that yield the desired properties for  <span class="math">p</span> ,  <span class="math">r</span> , and  <span class="math">t_r</span> . For example, the binomial  <span class="math">t = 2^{63} - 2^{49}</span>  guarantees that  <span class="math">p</span>  and  <span class="math">r</span>  as defined in Equation (1) are both 258-bit prime numbers. However, due to the superior efficiency on its associated base field arithmetic, we decided to use the trinomial  <span class="math">t = 2^{62} - 2^{54} + 2^{44}</span> , which guarantees that  <span class="math">p</span>  and  <span class="math">r</span>  as defined in Equation (1)</p>

    <p class="text-gray-300">are 254-bit prime numbers. Since the automorphism group <span class="math">\\mathrm{Aut}(E)</span> is a cyclic group of order 6 <em>[30]</em>, it is possible to slightly improve Pollard’s rho attack and get a speedup of <span class="math">\\sqrt{6}</span> <em>[11]</em>. Therefore, we achieve a 126-bit security level with our choice of parameters. The curve equation is <span class="math">E:Y^{2}=X^{3}+5</span> and we followed the procedure outlined in <em>[6, 36]</em> in order to find a generator <span class="math">P=(x_{P},y_{P})=(1,\\sqrt{6})</span> for the group <span class="math">E(\\mathbb{F}_{p})</span>, and one generator <span class="math">Q^{\\prime}=(x_{Q^{\\prime}},y_{Q^{\\prime}})</span> for the group <span class="math">E^{\\prime}(\\mathbb{F}_{p^{2}})[r]</span>, given as,</p>

    <p class="text-gray-300"><span class="math">x_{Q^{\\prime}}</span> <span class="math">=0\\mathrm{x}19B0BEA4AFE4C330DA93CC3533DA38A9F430B471C6F8A536E81962ED967909B5</span> <span class="math">+0\\mathrm{x}A1CF585585A61C6E9880B1F2A5C539F7D906FFF238FA6341E1DE1A2E45C3F72u,</span> <span class="math">y_{Q^{\\prime}}</span> <span class="math">=0\\mathrm{x}17ABD366EBBD65333E49C711A80A0CF6D24ADF1B9B3990EEDCC91731384D2627</span> <span class="math">+0\\mathrm{x}EE97D6DE9902A27D00E952232A78700863BC9AA9BE960C32F5BF9FD0A32D345u.</span></p>

    <p class="text-gray-300">In this Section, we show that our selection of <span class="math">t</span> yields important savings in the Miller loop and the hard part of the final exponentiation step of Algorithm 1.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">4.1 Miller Loop</h3>

    <p class="text-gray-300">We remark that the parameter <span class="math">6t+2</span> of Algorithm 1 has a bitlength <span class="math">L=65</span>, with a Hamming weight of 7. This implies that the execution of the Miller loop requires 64 doubling step computations in line 4, and 6 addition/subtraction steps in lines 6 and 8.</p>

    <p class="text-gray-300">It is noted that the equation of the tangent line at <span class="math">T\\in\\mathbb{G}_{2}</span> evaluated at <span class="math">P</span> defines a sparse element in <span class="math">\\mathbb{F}_{p^{12}}</span> (half of the coefficients are equal to zero). The same observation holds for the equation of the line through the points <span class="math">T</span> and <span class="math">\\pm Q</span> evaluated at <span class="math">P</span>. This sparsity allows us to reduce the number of operations on the underlying field when performing accumulation steps (lines 4, 6, 8, 12, and 13 of Algorithm 1).</p>

    <p class="text-gray-300">We perform an interleaved computation of the tangent line at point <span class="math">T</span> (respectively, the line through the points <span class="math">T</span> and <span class="math">Q</span>) evaluated at the base point <span class="math">P</span>, with a point doubling (respectively, point addition) using the formulae given in <em>[2]</em>. We recall that the field extension <span class="math">\\mathbb{F}_{p^{12}}</span> can be also represented as, <span class="math">\\mathbb{F}_{p^{12}}</span> <span class="math">=</span> <span class="math">\\mathbb{F}_{p^{2}}[W]/(W^{6}-u)</span>, with <span class="math">W=w</span>.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">4.1.1 Doubling step (line 4).</h4>

    <p class="text-gray-300">We represent the point <span class="math">T\\in E^{\\prime}(\\mathbb{F}_{p^{2}})</span> in Jacobian coordinates as <span class="math">T=(X_{T},Y_{T},Z_{T})</span>. The formulae for doubling <span class="math">T</span>, i.e., the equations that define the point <span class="math">R=2T=(X_{R},Y_{R},Z_{R})</span> are,</p>

    <p class="text-gray-300"><span class="math">X_{R}=9X_{T}^{4}-8X_{T}Y_{T}^{2},\\,Y_{R}=3X_{T}^{2}(4X_{T}Y_{T}^{2}-X_{R})-8Y_{T}^{4},\\,Z_{R}=2Y_{T}Z_{T}.</span></p>

    <p class="text-gray-300">Let the point <span class="math">P\\in E(\\mathbb{F}_{p})</span> be represented in affine coordinates as <span class="math">P=(x_{P},y_{P})</span>. Then, the tangent line at <span class="math">T</span> evaluated at <span class="math">P</span> can be calculated as <em>[32]</em>,</p>

    <p class="text-gray-300"><span class="math">l_{T,T}(P)=2Z_{R}Z_{T}^{2}y_{P}\\,-\\,(6X_{T}^{2}Z_{T}^{2}x_{P})W\\,+\\,(6X_{T}^{3}-4Y_{T}^{2})W^{2}\\in\\mathbb{F}_{p^{12}}.</span></p>

    <p class="text-gray-300">Hence, the computational cost of the interleaving computation of the tangent line and the doubling of the point <span class="math">T</span> is, <span class="math">3\\tilde{m}+8\\tilde{s}+16\\tilde{a}+4m</span>. Other operations</p>

    <p class="text-gray-300">J.-L. Beuchat et al.</p>

    <p class="text-gray-300">included in line 4 are <span class="math">f^2</span> and the product <span class="math">f^2 \\cdot l_{T,T}(P)</span>, which can be computed at a cost of, <span class="math">12\\tilde{m} + 45\\tilde{a} + 4m_{\\beta}</span> and <span class="math">13\\tilde{m} + 39\\tilde{a} + 2m_{\\beta}</span>, respectively. In summary, the computational cost associated to line 4 of Algorithm 1 is given as, <span class="math">28\\tilde{m} + 8\\tilde{s} + 100\\tilde{a} + 4m + 6m_{\\beta}</span>.</p>

    <p class="text-gray-300"><strong>Addition step (lines 6 and 8).</strong> Let <span class="math">Q = (X_{Q},Y_{Q},Z_{Q})</span> and <span class="math">T = (X_{T},Y_{T},Z_{T})</span> represent the points <span class="math">Q</span> and <span class="math">T\\in E^{\\prime}(\\mathbb{F}_{p^{2}})</span> in Jacobian coordinates. Then the point <span class="math">R = T + Q = (X_R,Y_R,Z_R)</span>, can be computed as,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} X _ {R} = (2 Y _ {Q} Z _ {T} ^ {3} - 2 Y _ {T}) ^ {2} - 4 (X _ {Q} Z _ {T} ^ {2} - X _ {T}) ^ {3} - 8 (X _ {Q} Z _ {T} ^ {2} - X _ {T}) ^ {2} X _ {T}, \\\\ Y _ {R} = (2 Y _ {Q} Z _ {T} ^ {3} - 2 Y _ {T}) (4 (X _ {Q} Z _ {T} ^ {2} - X _ {T}) ^ {2} X _ {T} - X _ {R}) - 8 Y _ {T} (X _ {Q} Z _ {T} ^ {2} - X _ {T}) ^ {3}, \\\\ Z _ {R} = 2 Z _ {T} \\left(X _ {Q} Z _ {T} ^ {2} - X _ {T}\\right). \\end{array}</span></div>

    <p class="text-gray-300">Once again, let the point <span class="math">P \\in E(\\mathbb{F}_p)</span> be represented in affine coordinates as <span class="math">P = (x_P, y_P)</span>. Then, the line through <span class="math">T</span> and <span class="math">Q</span> evaluated at the point <span class="math">P</span> is given as,</p>

    <div class="my-4 text-center"><span class="math-block">l _ {T, Q} (P) = 2 Z _ {R} y _ {P} - 4 x _ {P} (Y _ {Q} Z _ {T} ^ {3} + Y _ {T}) W + (4 X _ {Q} (Y _ {Q} Z _ {T} ^ {3} X _ {Q} - Y _ {T}) - 2 Y _ {Q} Z _ {R}) W ^ {2} \\in \\mathbb {F} _ {p ^ {1 2}}.</span></div>

    <p class="text-gray-300">The combined cost of computing <span class="math">l_{T,Q}(P)</span> and the point addition <span class="math">R = T + Q</span> is, <span class="math">7\\tilde{m} + 7\\tilde{s} + 25\\tilde{a} + 4m</span>. Finally we must accumulate the value of <span class="math">l_{T,Q}(P)</span> by performing the product <span class="math">f \\cdot l_{T,Q}(P)</span> at a cost of, <span class="math">13\\tilde{m} + 39\\tilde{a} + 2m_{\\beta}</span>.</p>

    <p class="text-gray-300">Therefore, the computational cost associated to line 6 of Algorithm 1 is given as, <span class="math">20\\tilde{m} + 7\\tilde{s} + 64\\tilde{a} + 4m + 2m_{\\beta}</span>. This is the same cost of line 8.</p>

    <p class="text-gray-300"><strong>Frobenius application and final addition step (lines 11–13).</strong> In this step we add to the value accumulated in <span class="math">f = f_{6t + 2,Q}(P)</span>, the product of the lines through the points <span class="math">Q_{1}, -Q_{2} \\in E^{\\prime}(\\mathbb{F}_{p^{2}})</span>, namely, <span class="math">l_{[6t + 2]Q,Q_1}(P) \\cdot l_{[6t + 2]Q + Q_1, -Q_2}(P)</span>.</p>

    <p class="text-gray-300">The points <span class="math">Q_{1}, Q_{2}</span> can be found by applying the Frobenius operator as, <span class="math">Q_{1} = \\pi_{p}(Q)</span>, <span class="math">Q_{2} = \\pi_{p}^{2}(Q)</span>. The total cost of computing lines 11–13 is given as, <span class="math">40\\tilde{m} + 14\\tilde{s} + 128\\tilde{a} + 4m + 4m_{\\beta}</span>.</p>

    <p class="text-gray-300">Let us recall that from our selection of <span class="math">t</span>, <span class="math">6t + 2</span> is a 65-bit number with a low Hamming weight of 7. This implies that the Miller loop of the optimal ate pairing can be computed using only 64 point doubling steps and 6 point addition/subtraction steps. Therefore, the total cost of the Miller loop portion of Algorithm 1 is approximately given as,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\text{Cost of Miller loop} = 64 \\cdot (28\\tilde{m} + 8\\tilde{s} + 100\\tilde{a} + 4m + 6m_{\\beta}) + \\\\ 6 \\cdot (20\\tilde{m} + 7\\tilde{s} + 64\\tilde{a} + 4m + 2m_{\\beta}) + \\\\ 40\\tilde{m} + 14\\tilde{s} + 128\\tilde{a} + 14m + 4m_{\\beta} \\\\ = 1952\\tilde{m} + 568\\tilde{s} + 6912\\tilde{a} + 294m + 400m_{\\beta}. \\end{array}</span></div>

    <p class="text-gray-300">2 We note that in the binary signed representation with digit set <span class="math">\\{-1,0,1\\}</span>, the integers <span class="math">t = 2^{62} - 2^{54} + 2^{44}</span> and <span class="math">6t + 2 = 2^{64} + 2^{63} - 2^{56} - 2^{55} + 2^{46} + 2^{45} + 2</span> have a signed bitlength of 63 and 65, respectively.</p>

    <p class="text-gray-300">4.2 Final Exponentiation</p>

    <p class="text-gray-300">Line 14 of Algorithm 1 performs the final exponentiation step, by raising <span class="math">f\\in\\mathbb{F}_{p^{12}}</span> to the power <span class="math">e=(p^{12}-1)/r</span>. We computed the final exponentiation by following the procedure described by Scott et al. in <em>[36]</em>, where the exponent <span class="math">e</span> is split into three coefficients as,</p>

    <p class="text-gray-300"><span class="math">e=\\frac{p^{12}-1}{r}=(p^{6}-1)\\cdot(p^{2}+1)\\cdot\\frac{p^{4}-p^{2}+1}{r}.</span> (3)</p>

    <p class="text-gray-300">As it was discussed in Section 3, we can take advantage of the fact that raising <span class="math">f</span> to the power <span class="math">p^{6}</span> is equivalent to one conjugation. Hence, one can compute <span class="math">f^{(p^{6}-1)}=\\bar{f}\\cdot f^{-1}</span>, which costs one field inversion and one field multiplication in <span class="math">\\mathbb{F}_{p^{12}}</span>. Moreover, after raising to the power <span class="math">p^{6}-1</span>, the resulting field element becomes a member of the cyclotomic subgroup <span class="math">\\mathbb{G}_{\\Phi_{6}}(\\mathbb{F}_{p^{2}})</span>, which implies that inversion of such elements can be computed by simply conjugation (see Table 1). Furthermore, from the discussion in Section 3.2 raising to the power <span class="math">p^{2}+1</span>, can be done with five field multiplications in the base field <span class="math">\\mathbb{F}_{p}</span>, plus one field multiplication in <span class="math">\\mathbb{F}_{p^{12}}</span>. The processing of the third coefficient in Equation (3) is referred as the hard part of the final exponentiation, i.e, the task of computing <span class="math">m^{(p^{4}-p^{2}+1)/r}</span>, with <span class="math">m\\in\\mathbb{F}_{p^{12}}</span>. In order to accomplish that, Scott et al. described in <em>[36]</em> a clever procedure that requires the calculation of ten temporary values, namely,</p>

    <p class="text-gray-300"><span class="math">m^{t},\\,m^{t^{2}},\\,m^{t^{3}},\\,m^{p},\\,m^{p^{2}},\\,m^{p^{3}},\\,m^{(tp)},\\,m^{(t^{2}p)},\\,m^{(t^{3}p)},\\,m^{(t^{2}p^{2})},</span></p>

    <p class="text-gray-300">which are the building blocks required for constructing a vectorial addition chain whose evaluation yields the final exponentiation <span class="math">f^{e}</span>, by performing 13 and 4 field multiplication and squaring operations over <span class="math">\\mathbb{F}_{p^{12}}</span>, respectively. Taking advantage of the Frobenius operator efficiency, the temporary values <span class="math">m^{p}</span>, <span class="math">m^{p^{2}}</span>, <span class="math">m^{p^{3}}</span>, <span class="math">m^{(tp)}</span>, <span class="math">m^{(t^{2}p)}</span>, <span class="math">m^{(t^{3}p)}</span>, and <span class="math">m^{(t^{2}p^{2})}</span> can be computed at a cost of just 35 field multiplications over <span class="math">\\mathbb{F}_{p}</span> (see Section 3.2). Therefore, the most costly computation of the hard part of the final exponentiation is the calculation of <span class="math">m^{t},m^{t^{2}}=(m^{t})^{t},m^{t^{3}}=(m^{t^{2}})^{t}</span>. From our choice, <span class="math">t=2^{62}-2^{54}+2^{44}</span>, we can compute these three temporary values at a combined cost of <span class="math">62\\cdot 3=186</span> cyclotomic squarings plus <span class="math">2\\cdot 3=6</span> field multiplications over <span class="math">\\mathbb{F}_{p^{12}}</span>. This is cheaper than the <span class="math">t</span> selection used in <em>[32]</em> that requires <span class="math">4\\cdot 3=12</span> more field multiplications over <span class="math">\\mathbb{F}_{p^{12}}</span>.</p>

    <p class="text-gray-300">Consulting Table 1, we can approximately estimate the total computational cost associated to the final exponentiation as,</p>

    <p class="text-gray-300"><span class="math">\\text{F. Exp. cost}=</span> <span class="math">\\ (25\\tilde{m}+9\\tilde{s}+12m_{\\beta}+61\\tilde{a}+\\tilde{i})+(18\\tilde{m}+6m_{\\beta}+60\\tilde{a})+</span> <span class="math">\\ (18\\tilde{m}+6m_{\\beta}+60\\tilde{a})+10m+</span> <span class="math">\\ 13\\cdot(18\\tilde{m}+6m_{\\beta}+60\\tilde{a})+4\\cdot(9\\tilde{s}+4m_{\\beta}+30\\tilde{a})+70m+</span> <span class="math">\\ 186\\cdot(9\\tilde{s}+4m_{\\beta}+30\\tilde{a})+6\\cdot(18\\tilde{m}+6m_{\\beta}+60\\tilde{a})</span> <span class="math">=</span> <span class="math">\\ 403\\tilde{m}+1719\\tilde{s}+7021\\tilde{a}+80m+898m_{\\beta}+\\tilde{i}.</span></p>

    <p class="text-gray-300">J.-L. Beuchat et al.</p>

    <p class="text-gray-300">Table 2. A Comparison of arithmetic operations required by the computation of the ate pairing variants.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">mξ</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hankerson et al. [18]R-ate pairing</td>

            <td class="px-3 py-2 border-b border-gray-700">Miller Loop</td>

            <td class="px-3 py-2 border-b border-gray-700">2277</td>

            <td class="px-3 py-2 border-b border-gray-700">356</td>

            <td class="px-3 py-2 border-b border-gray-700">6712</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">412</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Final Exp.</td>

            <td class="px-3 py-2 border-b border-gray-700">1616</td>

            <td class="px-3 py-2 border-b border-gray-700">1197</td>

            <td class="px-3 py-2 border-b border-gray-700">8977</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1062</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Total</td>

            <td class="px-3 py-2 border-b border-gray-700">3893</td>

            <td class="px-3 py-2 border-b border-gray-700">1553</td>

            <td class="px-3 py-2 border-b border-gray-700">15689</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1474</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Naehrig et al. [32]Optimal ate pairing</td>

            <td class="px-3 py-2 border-b border-gray-700">Miller Loop</td>

            <td class="px-3 py-2 border-b border-gray-700">2022</td>

            <td class="px-3 py-2 border-b border-gray-700">590</td>

            <td class="px-3 py-2 border-b border-gray-700">7140</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">410</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Final Exp.</td>

            <td class="px-3 py-2 border-b border-gray-700">678</td>

            <td class="px-3 py-2 border-b border-gray-700">1719</td>

            <td class="px-3 py-2 border-b border-gray-700">7921</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">988</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Total</td>

            <td class="px-3 py-2 border-b border-gray-700">2700</td>

            <td class="px-3 py-2 border-b border-gray-700">2309</td>

            <td class="px-3 py-2 border-b border-gray-700">15061</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1398</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This workOptimal ate pairing</td>

            <td class="px-3 py-2 border-b border-gray-700">Miller Loop</td>

            <td class="px-3 py-2 border-b border-gray-700">1952</td>

            <td class="px-3 py-2 border-b border-gray-700">568</td>

            <td class="px-3 py-2 border-b border-gray-700">6912</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">400</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Final Exp.</td>

            <td class="px-3 py-2 border-b border-gray-700">403</td>

            <td class="px-3 py-2 border-b border-gray-700">1719</td>

            <td class="px-3 py-2 border-b border-gray-700">7021</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">898</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Total</td>

            <td class="px-3 py-2 border-b border-gray-700">2355</td>

            <td class="px-3 py-2 border-b border-gray-700">2287</td>

            <td class="px-3 py-2 border-b border-gray-700">13933</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1298</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2 presents a comparison of  <span class="math">\\mathbb{F}_{p^2}</span>  arithmetic operations of our work against the reference pairing software libraries [18, 32]. From Table 2, we observe that our approach saves about  <span class="math">39.5\\%</span>  and  <span class="math">13\\%</span> <span class="math">\\mathbb{F}_{p^2}</span>  multiplications when compared against [18] and [32], respectively. We recall that in our work, the cost of the operation  <span class="math">m_{\\xi}</span>  is essentially the same of that of  <span class="math">m_{\\beta}</span> . This is not the case in [18, 32], where the operation  <span class="math">m_{\\xi}</span>  is considerably more costly than  <span class="math">m_{\\beta}</span> .</p>

    <p class="text-gray-300">In this work, we target the x86-64 instruction set [22]. Our software library is written in C++ and can be used on several platforms: 64-bit Windows 7 with Visual Studio 2008 Professional, 64-bit Linux 2.6 and Mac OS X 10.5 with gcc 4.4.1 or later, etc. In order to improve the runtime performance of our pairing library, we made an extensive use of Xbyak [28], a x86/x64 just-in-time assembler for the C++ language.</p>

    <p class="text-gray-300">The x86-64 instruction set has a mul operation which multiplies two 64-bit unsigned integers and returns a 128-bit unsigned integer. The execution of this operation takes about 3 cycles on Intel Core i7 and AMD Opteron processors. Compared to previous architectures, the gap between multiplication and addition/subtraction in terms of cycles is much smaller. This means that we have to be careful when selecting algorithms to perform prime field arithmetic: the schoolbook method is for instance faster than Karatsuba multiplication in the case of 256-bit operands.</p>

    <p class="text-gray-300">An element  <span class="math">x \\in \\mathbb{F}_p</span>  is represented as  <span class="math">x = (x_3, x_2, x_1, x_0)</span> , where  <span class="math">x_i, 0 \\leq i \\leq 3</span> , are 64-bit integers. The addition and the subtraction over  <span class="math">\\mathbb{F}_p</span>  are performed in a straightforward manner, i.e., we add/subtract the operands followed by reduction into  <span class="math">\\mathbb{F}_p</span> . Multiplication and inversion over  <span class="math">\\mathbb{F}_p</span>  are accomplished according</p>

    <p class="text-gray-300">to the well-known Montgomery multiplication and Montgomery inversion algorithms, respectively <em>[19]</em>.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">5.2 Implementation of Quadratic Extension Field Arithmetic</h3>

    <p class="text-gray-300">This section describes our optimizations for some operations over <span class="math">\\mathbb{F}_{p^{2}}</span> defined in Equation (2).</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">5.2.1 Multiplication.</h4>

    <p class="text-gray-300">We implemented the multiplication over the quadratic extension field <span class="math">\\mathbb{F}_{p^{2}}</span> using a Montgomery multiplication scheme split into two steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The straightforward multiplication of two 256-bit integers (producing a 512-bit integer), denoted as, mul256.</li>

      <li>The Montgomery reduction from a 512-bit integer to a 256-bit integer. This operation is denoted by mod512.</li>

    </ol>

    <p class="text-gray-300">According to our implementation, mul256 (resp. mod512) contains 16 (resp. 20) mul operations and its execution takes about 55 (resp. 100) cycles.</p>

    <p class="text-gray-300">Let <span class="math">P(u)=u^{2}+5</span> be the irreducible binomial defining the quadratic extension <span class="math">\\mathbb{F}_{p^{2}}</span>. Let <span class="math">A,B,C\\in\\mathbb{F}_{p^{2}}</span> such that, <span class="math">A=a_{0}+a_{1}u</span>, <span class="math">B=b_{0}+b_{1}u</span>, and <span class="math">C=c_{0}+c_{1}u=A\\cdot B</span>. Then, <span class="math">c_{0}=a_{0}b_{0}-5a_{1}b_{1}</span> and <span class="math">c_{1}=(a_{0}+a_{1})(b_{0}+b_{1})-a_{0}b_{0}-a_{1}b_{1}</span>. Hence, in order to obtain the field multiplication over the quadratic extension field, we must compute three multiplications over <span class="math">\\mathbb{F}_{p}</span>, and it may seem that three mod512 operations are necessary. However, we can keep the results of the products mul256<span class="math">(a_{0},b_{0})</span>, mul256<span class="math">(a_{1},b_{1})</span>, and mul256<span class="math">(a_{0}+a_{1},b_{0}+b_{1})</span> in three temporary 512-bit integer values. Then, we can add or subtract them without reduction, followed by a final call to mod512 in order to get <span class="math">c_{0},c_{1}\\in\\mathbb{F}_{p}</span>. This approach yields the saving of one mod512 operation as shown in Algorithm 2. We stress that the addNC/subNC functions in lines 1, 2, 6, and 7 of Algorithm 2, stand for addition/subtraction between 256-bit or 512-bit integers without checking the output carry. We explain next the rationale for using addition/subtraction without output carry check.</p>

    <p class="text-gray-300">The addition <span class="math">x+y</span>, and subtraction <span class="math">x-y</span>, of two elements <span class="math">x</span>, <span class="math">y\\in\\mathbb{F}_{p}</span> include an unpredictable branch check to figure out whether <span class="math">x+y\\geq p</span> or <span class="math">x&lt;y</span>. This is a costly check that is convenient to avoid as much as possible. Fortunately, our selected prime <span class="math">p</span> satisfies <span class="math">7p&lt;N</span>, with <span class="math">N=2^{256}</span>, and the function mod512 can reduce operands <span class="math">x</span>, whenever, <span class="math">x&lt;pN</span>. This implies that we can add up to seven times without performing an output carry check. In line 8, <span class="math">d_{0}</span> is equal to <span class="math">(a_{0}+a_{1})(b_{0}+b_{1})-a_{0}b_{0}-a_{1}b_{1}=a_{0}b_{1}+a_{1}b_{0}&lt;2p^{2}&lt;pN</span>. Hence, we can use addNC/subNC for step 1, 2, 6, and 7. In line 9, we multiply <span class="math">d_{2}</span> by the constant value 5, which can be computed with no carry operation. By applying these modifications, we manage to reduce the cost of the field multiplication over <span class="math">\\mathbb{F}_{p^{2}}</span> from about 640 cycles (required by a non-optimized procedure) to just 440 cycles.</p>

    <p class="text-gray-300">In line 10, <span class="math">d_{1}=a_{0}b_{0}-5a_{1}b_{1}</span>. We perform this operation as a 512-bit integer subtraction with carry operation followed by a mod512 reduction. Let <span class="math">x</span> be a</p>

    <p class="text-gray-300">512-bit integer such that <span class="math">x=a_{0}b_{0}-5a_{1}b_{1}</span> and let <span class="math">t</span> be a 256-bit integer. The aforementioned carry operation can be accomplished as follows: if <span class="math">x&lt;0</span>, then <span class="math">t\\leftarrow p</span>, otherwise <span class="math">t\\leftarrow 0</span>, then <span class="math">d_{1}\\leftarrow x+tN</span>, where this addition operation only uses the 256 most significant bits of <span class="math">x</span>.</p>

    <p class="text-gray-300">Algorithm 2 Optimized multiplication over <span class="math">\\mathbb{F}_{p^{2}}</span>. 0: <span class="math">A</span> and <span class="math">B\\in\\mathbb{F}_{p^{2}}</span> such that <span class="math">A=a_{0}+a_{1}u</span> and <span class="math">B=b_{0}+b_{1}u</span>. 0: <span class="math">C=A\\cdot B\\in\\mathbb{F}_{p^{2}}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">s\\leftarrow</span> addNC(<span class="math">a_{0},a_{1}</span>);</li>

      <li><span class="math">t\\leftarrow</span> addNC(<span class="math">b_{0},b_{1}</span>);</li>

      <li><span class="math">d_{0}\\leftarrow</span> mul256(<span class="math">s,t</span>);</li>

      <li><span class="math">d_{1}\\leftarrow</span> mul256(<span class="math">a_{0},b_{0}</span>);</li>

      <li><span class="math">d_{2}\\leftarrow</span> mul256(<span class="math">a_{1},b_{1}</span>);</li>

      <li><span class="math">d_{0}\\leftarrow</span> subNC(<span class="math">d_{0},d_{1}</span>);</li>

      <li><span class="math">d_{0}\\leftarrow</span> subNC(<span class="math">d_{0},d_{2}</span>);</li>

      <li><span class="math">c_{1}\\leftarrow</span> mod512(<span class="math">d_{0}</span>);</li>

      <li><span class="math">d_{2}\\leftarrow 5d_{2}</span>;</li>

      <li><span class="math">d_{1}\\leftarrow d_{1}-d_{2}</span>;</li>

      <li><span class="math">c_{0}\\leftarrow</span> mod512(<span class="math">d_{1}</span>);</li>

      <li>return <span class="math">C\\leftarrow c_{0}+c_{1}u</span>;</li>

    </ol>

    <p class="text-gray-300">Squaring. Algorithm 3 performs field squaring where some carry operations have been reduced, as explained next. Let <span class="math">A=a_{0}+a_{1}u\\in\\mathbb{F}_{p^{2}}</span>, <span class="math">C=A^{2}=c_{0}+c_{1}u</span>, and let <span class="math">x=(a_{0}+p-a_{1})(a_{0}+5a_{1})</span>. Then <span class="math">c_{0}=x-4a_{0}a_{1}\\bmod p</span>. However, we observe that <span class="math">x\\leq 2p\\cdot 6p=12p^{2}&lt;N^{2}</span> where <span class="math">N=2^{256}</span>. Also we have that,</p>

    <p class="text-gray-300"><span class="math">x-4a_{0}a_{1}\\geq a_{0}(a_{0}+5a_{1})-4a_{0}a_{1}=a_{0}(a_{0}+a_{1})\\geq 0,</span></p>

    <p class="text-gray-300">which implies,</p>

    <p class="text-gray-300"><span class="math">\\max(x-4a_{0}a_{1})</span> <span class="math">=\\max(a_{0}(a_{0}+p)+5a_{1}(p-a_{1}))</span> <span class="math">&lt;p\\cdot 2p+5(p/2)(p-p/2)&lt;pN.</span></p>

    <p class="text-gray-300">We conclude that we can safely add/subtract the operands in Algorithm 3 without carry check.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">3.2.2 Fast reduction for multiplication by small constant values.</h4>

    <p class="text-gray-300">The procedures of point doubling/addition and line evaluation in Miller loop, and the operations <span class="math">m_{\\xi},m_{\\beta}</span> in the tower field arithmetic, involve field multiplications of an arbitrary element <span class="math">A\\in\\mathbb{F}_{p^{2}}</span> by small constant values 3, 4, 5, and 8.</p>

    <p class="text-gray-300">We first remark that <span class="math">m_{\\xi}</span> requires the calculation of a field multiplication by the constant <span class="math">u</span>. Given <span class="math">A=a_{0}+a_{1}u\\in\\mathbb{F}_{p^{2}}</span>, then <span class="math">A\\cdot u=\\beta\\cdot a_{1}+a_{0}u=-5a_{1}+a_{0}u</span>. Computing this operation using shift-and-add expressions such as</p>

    <p class="text-gray-300">Software Implementation of the Optimal Ate Pairing over BN curves</p>

    <p class="text-gray-300">|  Algorithm 3 Optimized squaring over Fp2.  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: A ∈ Fp2 such that A = a0 + a1u.  |   |</p>

    <p class="text-gray-300">|  Output: C = A2 ∈ Fp2.  |   |</p>

    <p class="text-gray-300">|  1. t ← addNC(a1, a1);  |   |</p>

    <p class="text-gray-300">|  2. d1 ← mul256(t, a0);  |   |</p>

    <p class="text-gray-300">|  3. t ← addNC(a0, p);  |   |</p>

    <p class="text-gray-300">|  4. t ← subNC(t, a1);  |   |</p>

    <p class="text-gray-300">|  5. c1 ← 5a1;  |   |</p>

    <p class="text-gray-300">|  6. c1 ← addNC(c1, a0);  |   |</p>

    <p class="text-gray-300">|  7. d0 ← mul256(t, c1);  |   |</p>

    <p class="text-gray-300">|  8. c1 ← mod512(d1);  |   |</p>

    <p class="text-gray-300">|  9. d1 ← addNC(d1, d1);  |   |</p>

    <p class="text-gray-300">|  10. d0 ← subNC(d0, d1);  |   |</p>

    <p class="text-gray-300">|  11. c0 ← mod512(d0);  |   |</p>

    <p class="text-gray-300">|  12. return C ← c0 + c1u;  |   |</p>

    <p class="text-gray-300"><span class="math">5n = n + (n \\ll 2)</span>  for  <span class="math">n \\in \\mathbb{F}_p</span>  may be tempting as a means to avoid full multiplication calculations. Nevertheless, in our implementation we preferred to compute those multiplication-by-constant operations using the x86-64 mul instruction, since the cost in clock cycles of mul is almost the same or even a little cheaper than the one associated to the shift-and-add method.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Multiplications by small constant values require the reduction modulo  <span class="math">p</span>  of an integer  <span class="math">x</span>  smaller than  <span class="math">8p</span> . Note that we need five 64-bit registers to store  <span class="math">x = (x_{4},x_{3},x_{2},x_{1},x_{0})</span> . However, one can easily see that  <span class="math">x_{4} = 0</span>  or  <span class="math">x_{4} = 1</span> , and then one can prove that  <span class="math">x</span>  div  $2^{253} = (x_{4} \\ll 3)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(x_{3} \\gg 61)<span class="math"> . Division by  </span>2^{253}<span class="math">  involves only three logical operations and it can be efficiently performed on our target processor. Furthermore, the prime  </span>p$  we selected has the following nice property:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">(i p) \\operatorname {d i v} 2 ^ {2 5 3} = \\left\\{ \\begin{array}{l l} i &amp;amp; \\text {i f} 0 \\leq i \\leq 9, \\\\ i + 1 &amp;amp; \\text {i f} 1 0 \\leq i \\leq 1 4. \\end{array} \\right.</span></div>

    <p class="text-gray-300">Hence, we built a small look-up table  <span class="math">p</span> -Tbl defined as follows:</p>

    <div class="my-4 text-center"><span class="math-block">p \\text {- T b l} [ i ] = \\left\\{ \\begin{array}{l l} i p &amp;amp; \\text {i f} 0 \\leq i \\leq 9, \\\\ (i - 1) p &amp;amp; \\text {i f} 1 0 \\leq i \\leq 1 4. \\end{array} \\right. \\tag {4}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We then get  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x - p\\text{-Tbl}[x \\gg 253]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; p<span class="math"> . Algorithm 4 summarizes how we apply this strategy to perform a modulo  </span>p$  reduction.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We list in Table 3 the timings that we achieved on different architectures. Our library is able to evaluate the optimal ate pairing over a 254-bit prime field  <span class="math">\\mathbb{F}_p</span> , in just 2.33 million of clock cycles on a single core of an Intel Core i7 2.8GHz processor, which implies that the pairing computation takes 0.832msec. To our</p>

    <p class="text-gray-300">J.-L. Beuchat et al.</p>

    <p class="text-gray-300">|  Algorithm 4 Fast reduction x mod p.  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: x ∈ Z such that 0 ≤ x < 13p and represented as x = (x4, x3, x2, x1, x0), where x_i, 0 ≤ i ≤ 4, are 64-bit integers. Let p-Tbl be the precomputed look-up table defined in Equation (4).  |   |</p>

    <p class="text-gray-300">|  Output: z = x mod p.  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. q ← (x4 << 3)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(x3 ≫ 61);</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(q ← [x/2253])</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  2. z ← x - p-Tbl[q]; |   |</p>

    <p class="text-gray-300">|  3. if z < 0 then |   |</p>

    <p class="text-gray-300">|  4. z ← z + p; |   |</p>

    <p class="text-gray-300">|  5. end if |   |</p>

    <p class="text-gray-300">|  6. return z; |   |</p>

    <p class="text-gray-300">best knowledge, we are the first to compute a cryptographic pairing in less than one millisecond at this level of security on a desktop computer.</p>

    <p class="text-gray-300">According to the second column of Table 3, the costs (in clock cycles) that were measured for the  <span class="math">\\mathbb{F}_{p^2}</span>  arithmetic when implemented in the Core i7 processor are  <span class="math">\\tilde{m} = 435</span>  and  <span class="math">\\tilde{s} = 342</span> . Additionally, we measured  <span class="math">\\tilde{a} = 40</span> , and  <span class="math">\\tilde{i} = 7504</span> . Now, from Table 2, one can see that the predicted computational cost of the optimal ate pairing is given as,</p>

    <p class="text-gray-300">Opt. ate pairing cost  <span class="math">= 2355\\tilde{m} + 2287\\tilde{s} + 13933\\tilde{a} + \\tilde{i}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} = 2 3 5 5 \\cdot 4 3 5 + 2 2 8 7 \\cdot 3 4 2 + 1 3 9 3 3 \\cdot 4 0 + 7 5 0 4 \\\\ = 2, 3 7 1, 4 0 3. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">We observe that the experimental results presented in Table 3 have a reasonable match with the computational cost prediction given in Section 4.</p>

    <p class="text-gray-300">For comparison purpose, we also report the performance of the software library for BN curves developed by Naehrig et al. [32], which is the best software implementation that we know of. Naehrig et al. combined several state-of-the-art optimization techniques to write a software that is more than twice as fast as the previous reference implementation by Hankerson et al. [18]. Perhaps the most original contribution in [32] is the implementation of the arithmetic over the quadratic extension  <span class="math">\\mathbb{F}_{p^2}</span>  based on a tailored use of SIMD floating point instructions. Working in the case of hardware realizations of pairings, Fan et al. [13] suggested to take advantage of the polynomial form of  <span class="math">p(t)</span>  and introduced a new hybrid modular multiplication algorithm. The operands  <span class="math">a</span>  and  <span class="math">b\\in \\mathbb{F}_p</span>  are converted to degree-4 polynomials  <span class="math">a(t)</span>  and  <span class="math">b(t)</span> , and multiplied according to Montgomery's algorithm in the polynomial ring. Coefficients of the results must be reduced modulo  <span class="math">t</span> . Fan et al noticed that, if  <span class="math">t = 2^{m} + s</span> , where  <span class="math">s</span>  is a small constant, this step consists of a multiplication by  <span class="math">s</span>  instead of a division by  <span class="math">t</span> .</p>

    <p class="text-gray-300">Table 4 summarizes the best results published in the open literature since 2007. All the works featured in Table 4, targeted a level of security equivalent to that of AES-128. Aranha et al. [1] and Beuchat et al. [8] considered supersingular</p>

    <p class="text-gray-300">Software Implementation of the Optimal Ate Pairing over BN curves</p>

    <p class="text-gray-300">Table 3. Cycle counts of multiplication over  <span class="math">\\mathbb{F}_{p^2}</span> , squaring over  <span class="math">\\mathbb{F}_{p^2}</span> , and optimal ate pairing on different machines.</p>

    <p class="text-gray-300">|   | Our results  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Multiplication over Fp2</td>

            <td class="px-3 py-2 border-b border-gray-700">435</td>

            <td class="px-3 py-2 border-b border-gray-700">443</td>

            <td class="px-3 py-2 border-b border-gray-700">558</td>

            <td class="px-3 py-2 border-b border-gray-700">473</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Squaring over Fp2</td>

            <td class="px-3 py-2 border-b border-gray-700">342</td>

            <td class="px-3 py-2 border-b border-gray-700">355</td>

            <td class="px-3 py-2 border-b border-gray-700">445</td>

            <td class="px-3 py-2 border-b border-gray-700">376</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Miller loop</td>

            <td class="px-3 py-2 border-b border-gray-700">1,330,000</td>

            <td class="px-3 py-2 border-b border-gray-700">1,360,000</td>

            <td class="px-3 py-2 border-b border-gray-700">1,680,000</td>

            <td class="px-3 py-2 border-b border-gray-700">1,480,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Final exponentiation</td>

            <td class="px-3 py-2 border-b border-gray-700">1,000,000</td>

            <td class="px-3 py-2 border-b border-gray-700">1,040,000</td>

            <td class="px-3 py-2 border-b border-gray-700">1,270,000</td>

            <td class="px-3 py-2 border-b border-gray-700">1,081,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Optimal ate pairing</td>

            <td class="px-3 py-2 border-b border-gray-700">2,330,000</td>

            <td class="px-3 py-2 border-b border-gray-700">2,400,000</td>

            <td class="px-3 py-2 border-b border-gray-700">2,950,000</td>

            <td class="px-3 py-2 border-b border-gray-700">2,561,000</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | dclxvi [32,33]  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Core i7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Opteronb</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Core 2 Quadc</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Athlon 64 X2d</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Squaring over Fp2</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">614</td>

            <td class="px-3 py-2 border-b border-gray-700">558</td>

            <td class="px-3 py-2 border-b border-gray-700">1207</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Miller loop</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">2,480,000</td>

            <td class="px-3 py-2 border-b border-gray-700">2,260,000</td>

            <td class="px-3 py-2 border-b border-gray-700">5,760,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Final exponentiation</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">2,520,000</td>

            <td class="px-3 py-2 border-b border-gray-700">2,210,000</td>

            <td class="px-3 py-2 border-b border-gray-700">5,510,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Optimal ate pairing</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">5,000,000</td>

            <td class="px-3 py-2 border-b border-gray-700">4,470,000</td>

            <td class="px-3 py-2 border-b border-gray-700">11,270,000</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">a Intel Core i7 860 (2.8GHz), Windows 7, Visual Studio 2008 Professional b Quad-Core AMD Opteron 2376 (2.3GHz), Linux 2.6.18, gcc 4.4.1 c Intel Core 2 Duo T7100 (1.8GHz), Windows 7, Visual Studio 2008 Professional <span class="math">^{\\mathrm{d}}</span>  Athlon 64 X2 Dual Core  <span class="math">6000 + (3\\mathrm{GHz})</span> , Linux 2.6.23, gcc 4.1.2 e Intel Core 2 Quad Q6600 (2394MHz), Linux 2.6.28, gcc 4.3.3</p>

    <p class="text-gray-300">elliptic curves in characteristic 2 and 3, respectively. All other authors worked with ordinary curves.</p>

    <p class="text-gray-300">Several authors studied multi-core implementations of a cryptographic pairing [1,8,16]. In the light of the results reported in Table 4, it seems that the acceleration achieved by an  <span class="math">n</span> -core implementation is always less than the ideal  <span class="math">n \\times</span>  speedup. This is related to the extra arithmetic operations needed to combine the partial results generated by each core, and the dependencies between the different operations involved in the final exponentiation. The question that arises is therefore: how many cores should be utilized to compute a cryptographic pairing? We believe that the best answer is the one provided by Grabher et al.: "if the requirement is for two pairing evaluations, the slightly moronic conclusion is that one can perform one pairing on each core [...] doubling the performance versus two sequential invocations of any other method that does not already use multi-core parallelism internally" [16].</p>

    <p class="text-gray-300">In this paper we have presented a software library that implements the optimal ate pairing over a Barreto-Naehrig curve at the 126-bit security level. To the best of our knowledge, we are the first to have reported the computation of a bilinear pairing at a level of security roughly equivalent to that of AES-128 in</p>

    <p class="text-gray-300">J.-L. Beuchat et al.</p>

    <p class="text-gray-300">Table 4. A comparison of cycles and timings required by the computation of the ate pairing variants. The frequency is given in GHz and the timings are in milliseconds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algo.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Architecture</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cycles</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Freq.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Calc. time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Devegili et al. [10]</td>

            <td class="px-3 py-2 border-b border-gray-700">ate</td>

            <td class="px-3 py-2 border-b border-gray-700">Intel Pentium IV</td>

            <td class="px-3 py-2 border-b border-gray-700">69,600,000</td>

            <td class="px-3 py-2 border-b border-gray-700">3.0</td>

            <td class="px-3 py-2 border-b border-gray-700">23.20</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Naehrig et al. [31]</td>

            <td class="px-3 py-2 border-b border-gray-700">ate</td>

            <td class="px-3 py-2 border-b border-gray-700">Intel Core 2 Duo</td>

            <td class="px-3 py-2 border-b border-gray-700">29,650,000</td>

            <td class="px-3 py-2 border-b border-gray-700">2.2</td>

            <td class="px-3 py-2 border-b border-gray-700">13.50</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Grabher et al. [16]</td>

            <td class="px-3 py-2 border-b border-gray-700">ate</td>

            <td class="px-3 py-2 border-b border-gray-700">Intel Core 2 Duo (1 core)</td>

            <td class="px-3 py-2 border-b border-gray-700">23,319,673</td>

            <td class="px-3 py-2 border-b border-gray-700">2.4</td>

            <td class="px-3 py-2 border-b border-gray-700">9.72</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Intel Core 2 Duo (2 cores)</td>

            <td class="px-3 py-2 border-b border-gray-700">14,429,439</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6.01</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Aranha et al. [1]</td>

            <td class="px-3 py-2 border-b border-gray-700">ηT</td>

            <td class="px-3 py-2 border-b border-gray-700">Intel Xeon 45nm (1 core)</td>

            <td class="px-3 py-2 border-b border-gray-700">17,400,000</td>

            <td class="px-3 py-2 border-b border-gray-700">2.0</td>

            <td class="px-3 py-2 border-b border-gray-700">8.70</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Intel Xeon 45nm (8 cores)</td>

            <td class="px-3 py-2 border-b border-gray-700">3,020,000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.51</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Beuchat et al. [8]</td>

            <td class="px-3 py-2 border-b border-gray-700">ηT</td>

            <td class="px-3 py-2 border-b border-gray-700">Intel Core i7 (1 core)</td>

            <td class="px-3 py-2 border-b border-gray-700">15,138,000</td>

            <td class="px-3 py-2 border-b border-gray-700">2.9</td>

            <td class="px-3 py-2 border-b border-gray-700">5.22</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Intel Core i7 (8 cores)</td>

            <td class="px-3 py-2 border-b border-gray-700">5,423,000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.87</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hankerson et al. [18]</td>

            <td class="px-3 py-2 border-b border-gray-700">R-ate</td>

            <td class="px-3 py-2 border-b border-gray-700">Intel Core 2</td>

            <td class="px-3 py-2 border-b border-gray-700">10,000,000</td>

            <td class="px-3 py-2 border-b border-gray-700">2.4</td>

            <td class="px-3 py-2 border-b border-gray-700">4.10</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Naehrig et al. [32]</td>

            <td class="px-3 py-2 border-b border-gray-700">a_opt</td>

            <td class="px-3 py-2 border-b border-gray-700">Intel Core 2 Quad Q6600</td>

            <td class="px-3 py-2 border-b border-gray-700">4,470,000</td>

            <td class="px-3 py-2 border-b border-gray-700">2.4</td>

            <td class="px-3 py-2 border-b border-gray-700">1.80</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">a_opt</td>

            <td class="px-3 py-2 border-b border-gray-700">Intel Core i7</td>

            <td class="px-3 py-2 border-b border-gray-700">2,330,000</td>

            <td class="px-3 py-2 border-b border-gray-700">2.8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.83</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">less than one millisecond on a single core of an Intel Core i7 2.8GHz processor. The speedup achieved in this work is a combination of two main factors:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A careful programming of the underlying field arithmetic based on Montgomery multiplication that allowed us to perform a field multiplication over  <span class="math">\\mathbb{F}_p</span>  and  <span class="math">\\mathbb{F}_{p^2}</span>  in just 160 and 435 cycles, respectively, when working in an Opteron-based machine. We remark that in contrast with [32], we did not make use of the 128-bit multimedia arithmetic instructions.</li>

      <li>A binary signed selection of the parameter  <span class="math">t</span>  that allowed us to obtain significant savings in both the Miller loop and the final exponentiation of the optimal ate pairing.</li>

    </ul>

    <p class="text-gray-300">Our selection of  <span class="math">t</span>  yields a prime  <span class="math">p = p(t)</span>  that has a bitlength of just 254 bits. This size is slightly below than what Freeman et al. [14] recommend for achieving a high security level. If for certain scenarios, it becomes strictly necessary to meet or exceed the 128-bit level of security, we recommend to select  <span class="math">t = 2^{63} - 2^{49}</span>  that produces a prime  <span class="math">p = p(t)</span>  with a bitlength of 258 bits. However, we warn the reader that since a 258-bit prime implies that more than four 64-bit register will be required to store field elements, the performance of the arithmetic library will deteriorate.</p>

    <p class="text-gray-300">Consulting the cycle count costs listed in Table 3, one can see that for our implementation the cost of the final exponentiation step is nearly  <span class="math">25\\%</span>  cheaper than that of the Miller loop.</p>

    <p class="text-gray-300">Authors in [13, 32] proposed to exploit the polynomial parametrization of the prime  <span class="math">p</span>  as a means to speed up the underlying field arithmetic. We performed extensive experiments trying to apply this idea to our particular selection of  <span class="math">t</span>  with no success. Instead, the customary Montgomery multiplier algorithm appears to achieve a performance that is very hard to beat by other multiplication schemes, whether integer-based or polynomial-based multipliers.</p>

    <p class="text-gray-300">The software library presented in this work computes a bilinear pairing at a high security level at a speed that is faster than the best hardware accelerators published in the open literature (see for instance <em>[7, 13, 23, 37]</em>). We believe that this situation is unrealistic and therefore we will try to design a hardware architecture that can compute 128-bit security bilinear pairing in shorter timings. Our future work will also include a study of the parallelization possibilities on pairing-based protocols that specify the computation of many bilinear pairing during their execution.</p>

    <h2 id="sec-17" class="text-2xl font-bold">8 Acknowledgements</h2>

    <p class="text-gray-300">We thank Michael Naehrig, Ruben Niederhagen, and Peter Schwabe for making their pairing software library <em>[33]</em> freely available for research purposes.</p>

    <p class="text-gray-300">The authors also want to thank Diego Aranha, Paulo S.L.M. Barreto, Darrel Hankerson, Alfred Menezes, and the anonymous referees for their valuable comments.</p>

    <h2 id="sec-18" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] D.F. Aranha, J. López, and D. Hankerson. High-speed parallel software implementation of the <span class="math">\\eta_{T}</span> pairing. In J. Pieprzyk, editor, Topics in Cryptology–CT-RSA 2010, volume 5985 of Lecture Notes in Computer Science, pages 89–105. Springer, 2010.</li>

      <li>[2] C. Arene, T. Lange, M. Naehrig, and C. Ritzenthaler. Faster computation of the Tate pairing. Cryptology ePrint Archive, Report 2009/155, 2009. Available at http://eprint.iacr.org/2009/155.pdf.</li>

      <li>[3] P.S.L.M. Barreto, S.D. Galbraith, C. Ó hÉigeartaigh, and M. Scott. Efficient pairing computation on supersingular Abelian varieties. Designs, Codes and Cryptography, 42:239–271, 2007.</li>

      <li>[4] P.S.L.M. Barreto, H.Y. Kim, B. Lynn, and M. Scott. Efficient algorithms for pairing-based cryptosystems. In M. Yung, editor, Advances in Cryptology–CRYPTO 2002, number 2442 in Lecture Notes in Computer Science, pages 354–368. Springer, 2002.</li>

      <li>[5] P.S.L.M. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. In B. Preneel and S. Tavares, editors, Selected Areas in Cryptography–SAC 2005, volume 3897 of Lecture Notes in Computer Science, pages 319–331. Springer, 2006.</li>

      <li>[6] N. Benger and M. Scott. Constructing tower extensions for the implementation of pairing-based cryptography. Cryptology ePrint Archive, Report 2009/556, 2009. Available at http://eprint.iacr.org/2009/556.pdf.</li>

      <li>[7] J.-L. Beuchat, J. Detrey, N. Estibals, E. Okamoto, and F. Rodríguez-Henríquez. Fast architectures for the <span class="math">\\eta_{T}</span> pairing over small-characteristic supersingular elliptic curves. Cryptology ePrint Archive, Report 2009/398, 2009. Available at http://eprint.iacr.org/2009/398.pdf.</li>

      <li>[8] J.-L. Beuchat, E. López-Trejo, L. Martínez-Ramos, S. Mitsunari, and F. Rodríguez-Henríquez. Multi-core implementation of the Tate pairing over supersingular elliptic curves. In J.A. Garay, A. Miyaji, and A. Otsuka, editors, Cryptology and Network Security–CANS 2009, number 5888 in Lecture Notes in Computer Science, pages 413–432. Springer, 2009.</li>

    </ul>

    <p class="text-gray-300">J.-L. Beuchat et al.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[9] J. Chung and M.A. Hasan. Asymmetric squaring formulae. In P. Kornerup and J.-M. Muller, editors, Proceedings of the 18th IEEE Symposium on Computer Arithmetic, pages 113–122. IEEE Computer Society, 2007.</li>

      <li>[10] A.J. Devegili, M. Scott, and R. Dahab. Implementing cryptographic pairings over Barreto–Naehrig curves. In T. Takagi, T. Okamoto, E. Okamoto, and T. Okamoto, editors, Pairing-Based Cryptography–Pairing 2007, volume 4575 of Lecture Notes in Computer Science, pages 197–207. Springer, 2007.</li>

      <li>[11] I. Duursma, P. Gaudry, and F. Morain. Speeding up the discrete log computation on curves with automorphisms. In K.-Y. Lam, E. Okamoto, and C. Xing, editors, Advances in Cryptology–ASIACRYPT 1999, volume 1716 of Lecture Notes in Computer Science, pages 103–121. Springer, 1999.</li>

      <li>[12] I. Duursma and H.S. Lee. Tate pairing implementation for hyperelliptic curves <span class="math">y^{2}=x^{p}-x+d</span>. In C.S. Laih, editor, Advances in Cryptology–ASIACRYPT 2003, number 2894 in Lecture Notes in Computer Science, pages 111–123. Springer, 2003.</li>

      <li>[13] J. Fan, F. Vercauteren, and I. Verbauwhede. Faster F_{p}-arithmetic for cryptographic pairings on Barreto–Naehrig curves. In C. Clavier and K. Gaj, editors, Cryptographic Hardware and Embedded Systems–CHES 2009, number 5747 in Lecture Notes in Computer Science, pages 240–253. Springer, 2009.</li>

      <li>[14] D. Freeman, M. Scott, and E. Teske. A taxonomy of pairing-friendly elliptic curves. Journal of Cryptology, 23(2):224–280, April 2010.</li>

      <li>[15] S. Galbraith, K. Paterson, and N. Smart. Pairings for cryptographers. Discrete Applied Mathematics, 156:3113–3121, January 2008.</li>

      <li>[16] P. Grabher, J. Großschädl, and D. Page. On software parallel implementation of cryptographic pairings. In Selected Areas in Cryptography–SAC 2008, number 5381 in Lecture Notes in Computer Science, pages 34–49. Springer, 2008.</li>

      <li>[17] R. Granger and M. Scott. Faster squaring in the cyclotomic subgroup of sixth degree extensions. Cryptology ePrint Archive, Report 2009/565, 2009. Available at http://eprint.iacr.org/2009/565.pdf.</li>

      <li>[18] D. Hankerson, A. Menezes, and M. Scott. Software implementation of pairings. In M. Joye and G. Neven, editors, Identity-based Cryptography, Cryptology and Information Security Series, chapter 12, pages 188–206. IOS Press, 2009.</li>

      <li>[19] D. Hankerson, A. Menezes, and S. Vanstone. Guide to Elliptic Curve Cryptography. Springer-Verlag New York, Inc., 2004.</li>

      <li>[20] F. Hess. Pairing lattices. In S.D. Galbraith and K.G. Paterson, editors, Pairing-Based Cryptography–Pairing 2008, number 5209 in Lecture Notes in Computer Science, pages 18–38. Springer, 2008.</li>

      <li>[21] F. Hess, N. Smart, and F. Vercauteren. The Eta pairing revisited. IEEE Transactions on Information Theory, 52(10):4595–4602, October 2006.</li>

      <li>[22] Intel Corporation. Intel 64 and IA-32 Architectures Software Developer’s Manuals. Available at http://www.intel.com/products/processor/manuals/.</li>

      <li>[23] D. Kammler, D. Zhang, P. Schwabe, H. Scharwaechter, M. Langenberg, D. Auras, G. Ascheid, and R. Mathar. Designing an ASIP for cryptographic pairings over Barreto–Naehrig curves. In C. Clavier and K. Gaj, editors, Cryptographic Hardware and Embedded Systems–CHES 2009, number 5747 in Lecture Notes in Computer Science, pages 254–271. Springer, 2009.</li>

      <li>[24] N. Koblitz and A. Menezes. Pairing-based cryptography at high security levels. Cryptology ePrint Archive, Report 2005/076, 2005. Available at http://eprint.iacr.org/2005/076.pdf.</li>

      <li>[25] E. Lee, H.-S. Lee, and C.-M. Park. Efficient and generalized pairing computation on abelian varieties. Cryptology ePrint Archive, Report 2008/040, 2008. Available at http://eprint.iacr.org/2008/040.pdf.</li>

    </ul>

    <p class="text-gray-300">Software Implementation of the Optimal Ate Pairing over BN curves</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[26] V.S. Miller. Short programs for functions on curves. Available at http://crypto.stanford.edu/miller, 1986.</li>

      <li>[27] V.S. Miller. The Weil pairing, and its efficient calculation. Journal of Cryptology, 17(4):235–261, September 2004.</li>

      <li>[28] S. Mitsunari. Xbyak: JIT assembler for C++. Available at http://homepage1.nifty.com/herumi/soft/xbyak_e..</li>

      <li>[29] A. Miyaji, M. Nakabayashi, and S. Takano. New explicit conditions of elliptic curve traces for FR-reduction. IEICE Trans. Fundamentals, E84:1234–1243, 2001.</li>

      <li>[30] M. Naehrig. Constructive and Computational Aspects of Cryptographic Pairings. PhD thesis, Technische Universiteit Eindhoven, 2009. Available at http://www.cryptojedi.org/users/michael/data/thesis/2009-05-13-diss.pdf.</li>

      <li>[31] M. Naehrig, P.S.L.M. Barreto, and P. Schwabe. On compressible pairings and their computation. In S. Vaudenay, editor, Progress in Cryptology–AFRICACRYPT 2008, volume 5023 of Lecture Notes in Computer Science, pages 371–388. Springer, 2008.</li>

      <li>[32] M. Naehrig, R. Niederhagen, and P. Schwabe. New software speed records for cryptographic pairings. Cryptology ePrint Archive, Report 2010/186, 2010. Available at http://eprint.iacr.org/2010/186.pdf.</li>

      <li>[33] P. Schwabe. Software library of “New software speed records for cryptographic pairings”, Accessed June, 4, 2010. Available at http://cryptojedi.org/crypto/#dclxvi.</li>

      <li>[34] M. Scott. Implementing cryptographic pairings. In T. Takagi, T. Okamoto, E. Okamoto, and T. Okamoto, editors, Pairing-Based Cryptography–Pairing 2007, volume 4575 of Lecture Notes in Computer Science, pages 177–196. Springer, 2007.</li>

      <li>[35] M. Scott and P.S.L.M. Barreto. Compressed pairings. In M.K. Franklin, editor, Advances in Cryptology–CRYPTO 2004, volume 3152 of Lecture Notes in Computer Science, pages 140–156. Springer, 2004.</li>

      <li>[36] M. Scott, N. Benger, M. Charlemagne, L.J. Dominguez Perez, and E.J. Kachisa. On the final exponentiation for calculating pairings on ordinary elliptic curves. Cryptology ePrint Archive, Report 2008/490, 2008. Available at http://eprint.iacr.org/2008/490.pdf.</li>

      <li>[37] C. Shu, S. Kwon, and K. Gaj. Reconfigurable computing approach for Tate pairing cryptosystems over binary fields. IEEE Transactions on Computers, 58(9):1221–1237, September 2009.</li>

      <li>[38] F. Vercauteren. Optimal pairings. IEEE Transactions on Information Theory, 56(1):455–461, January 2010.</li>

    </ul>

    <p class="text-gray-300">J.-L. Beuchat et al.</p>

    <p class="text-gray-300">Algorithm 5 Addition in  <span class="math">\\mathbb{F}_{p^2} = \\mathbb{F}_p[u] / (u^2 -\\beta)</span></p>

    <p class="text-gray-300">Require:  <span class="math">A = a_{0} + a_{1}u\\in \\mathbb{F}_{p^{2}}</span>  and  <span class="math">B = b_{0} + b_{1}u\\in \\mathbb{F}_{p^{2}}</span></p>

    <p class="text-gray-300">Ensure:  <span class="math">C = c_{0} + c_{1}u = A + B \\in \\mathbb{F}_{p^{2}}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">c_{0}\\gets a_{0} + b_{0}</span></li>

      <li><span class="math">c_{1}\\gets a_{1} + b_{1}</span></li>

      <li>return  <span class="math">C = c_0 + c_1u</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 6 Subtraction in  <span class="math">\\mathbb{F}_{p^2} = \\mathbb{F}_p[u] / (u^2 -\\beta)</span></p>

    <p class="text-gray-300">Require:  <span class="math">A = a_{0} + a_{1}u\\in \\mathbb{F}_{p^{2}}</span>  and  <span class="math">B = b_{0} + b_{1}u\\in \\mathbb{F}_{p^{2}}</span></p>

    <p class="text-gray-300">Ensure:  <span class="math">C = c_{0} + c_{1}u = A - B \\in \\mathbb{F}_{p^{2}}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">c_{0}\\gets a_{0} - b_{0}</span></li>

      <li><span class="math">c_{1}\\gets a_{1} - b_{1}</span></li>

      <li>return  <span class="math">C = c_0 + c_1u</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 7 Multiplication by  <span class="math">b_{0} \\in \\mathbb{F}_{p}</span> .</p>

    <p class="text-gray-300">Require:  <span class="math">A = a_{0} + a_{1}u\\in \\mathbb{F}_{p^{2}}</span>  and  <span class="math">b_{0}\\in \\mathbb{F}_{p}</span></p>

    <p class="text-gray-300">Ensure:  <span class="math">C = c_{0} + c_{1}u = A\\cdot b_{0}\\in \\mathbb{F}_{p^{2}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">c_{0}\\gets a_{0}\\cdot b_{0}</span></li>

      <li><span class="math">c_{1}\\gets a_{1}\\cdot b_{0}</span></li>

      <li>return  <span class="math">C = c_0 + c_1u</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 8 Inverse in  <span class="math">\\mathbb{F}_{p^2} = \\mathbb{F}_p[u] / (u^2 -\\beta)</span></p>

    <p class="text-gray-300">Require:  <span class="math">A = a_{0} + a_{1}u\\in \\mathbb{F}_{p^{2}}</span></p>

    <p class="text-gray-300">Ensure:  <span class="math">C = c_{0} + c_{1}u = A^{-1}\\in \\mathbb{F}_{p^{2}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">t_0\\gets a_0^2</span></li>

      <li><span class="math">t_1\\gets a_1^2</span></li>

      <li><span class="math">t_0\\gets t_0 - \\beta \\cdot t1</span></li>

      <li><span class="math">t_1\\gets t_0^{-1}</span></li>

      <li><span class="math">c_{0}\\gets a_{0}\\cdot t_{1}</span></li>

      <li><span class="math">c_{1}\\gets -1\\cdot a_{1}\\cdot t_{1}</span></li>

      <li>return  <span class="math">C = c_0 + c_1u</span></li>

    </ol>

    <p class="text-gray-300">Software Implementation of the Optimal Ate Pairing over BN curves</p>

    <p class="text-gray-300">Algorithm 9 Squaring in  <span class="math">\\mathbb{F}_{p^4} = \\mathbb{F}_{p^2}[V] / (V^2 -\\xi)</span> Require:  <span class="math">A = a_{0} + a_{1}V\\in \\mathbb{F}_{p^{4}}</span> Ensure:  <span class="math">C = c_0 + c_1V = A^2\\in \\mathbb{F}_{p^2}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">t_0\\gets a_0^2</span></li>

      <li><span class="math">t_1\\gets a_1^2</span></li>

      <li><span class="math">c_{0}\\leftarrow t_{1}\\cdot \\xi</span></li>

      <li><span class="math">c_{0}\\gets c_{0} + t_{0}</span></li>

      <li><span class="math">c_{1}\\gets a_{0} + a_{1}</span></li>

      <li><span class="math">c_{1}\\gets c_{1}^{2} - t_{0} - t_{1}</span></li>

      <li>return  <span class="math">C = c_0 + c_1V</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 10 Addition in  <span class="math">\\mathbb{F}_{p^6} = \\mathbb{F}_{p^2}[v] / (v^3 -\\xi)</span> Require:  <span class="math">A = a_{0} + a_{1}v + a_{2}v^{2}\\in \\mathbb{F}_{p^{6}}</span>  and  <span class="math">B = b_{0} + b_{1}v + b_{2}v^{2}\\in \\mathbb{F}_{p^{6}}</span> Ensure:  <span class="math">C = c_{0} + c_{1}v + c_{2}v^{2} = A + B\\in \\mathbb{F}_{p^{6}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">c_{0}\\gets a_{0} + b_{0}</span></li>

      <li><span class="math">c_{1}\\gets a_{1} + b_{1}</span></li>

      <li><span class="math">c_{2}\\gets a_{2} + b_{2}</span></li>

      <li>return  <span class="math">C = c_{0} + c_{1}v + c_{2}v^{2}</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 11 Subtraction in  <span class="math">\\mathbb{F}_{p^6} = \\mathbb{F}_{p^2}[v] / (v^3 -\\xi)</span> Require:  <span class="math">A = a_{0} + a_{1}v + a_{2}v^{2}\\in \\mathbb{F}_{p^{6}}</span>  and  <span class="math">B = b_{0} + b_{1}v + b_{2}v^{2}\\in \\mathbb{F}_{p^{6}}</span> Ensure:  <span class="math">C = c_{0} + c_{1}v + c_{2}v^{2} = A - B\\in \\mathbb{F}_{p^{6}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">c_{0}\\gets a_{0} - b_{0}</span></li>

      <li><span class="math">c_{1}\\gets a_{1} - b_{1}</span></li>

      <li><span class="math">c_{2}\\gets a_{2} - b_{2}</span></li>

      <li>return  <span class="math">C = c_{0} + c_{1}v + c_{2}v^{2}</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 12 Multiplication by  <span class="math">\\gamma</span> Require:  <span class="math">A\\in \\mathbb{F}_{p^6}</span>  , where  <span class="math">A = a_0 + a_1v + a_2v^2</span>  .  <span class="math">a_{i}\\in \\mathbb{F}_{p^{6}}</span> Ensure:  <span class="math">C = A\\cdot \\gamma ,C\\in \\mathbb{F}_{p^6}</span>  , where  <span class="math">C = c_0 + c_1v + c_2v^2</span>  .  <span class="math">c_{i}\\in \\mathbb{F}_{p^{2}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">c_{0}\\gets a_{2}\\cdot \\xi</span></li>

      <li>return  <span class="math">C\\gets c_0 + a_0v + a_1v^2</span></li>

    </ol>

    <p class="text-gray-300">J.-L. Beuchat et al.</p>

    <p class="text-gray-300">Algorithm 13 Multiplication in  <span class="math">\\mathbb{F}_{p^6} = \\mathbb{F}_{p^2}[v] / (v^3 -\\xi)</span> Require:  <span class="math">A = a_{0} + a_{1}v + a_{2}v^{2}\\in \\mathbb{F}_{p^{6}}</span>  and  <span class="math">B = b_{0} + b_{1}v + b_{2}v^{2}\\in \\mathbb{F}_{p^{6}}</span> Ensure:  <span class="math">C = c_0 + c_1v + c_2v^2 = A\\cdot B\\in \\mathbb{F}_{p^6}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">t_0\\gets a_0\\cdot b_0</span></li>

      <li><span class="math">t_1\\gets a_1\\cdot b_1</span></li>

      <li><span class="math">t_2\\gets a_2\\cdot b_2</span></li>

      <li><span class="math">c_{0}\\gets [(a_{1} + a_{2})\\cdot (b_{1} + b_{2}) - t_{1} - t_{2}]\\cdot \\xi +t_{0};</span></li>

      <li><span class="math">c_{1}\\gets (a_{0} + a_{1})\\cdot (b_{0} + b_{1}) - t_{0} - t_{1} + \\xi \\cdot t_{2};</span></li>

      <li><span class="math">c_{2}\\gets (a_{0} + a_{2})\\cdot (b_{0} + b_{2}) - t_{0} - t_{2} + t_{1};</span></li>

      <li>return  <span class="math">C = c_0 + c_1v + c_2v^2</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 15 computes the product of  <span class="math">A \\in \\mathbb{F}_{p^6}</span>  by a constant  <span class="math">b \\in \\mathbb{F}_{p^2}</span> . However, it can be also used to compute the product of  <span class="math">A</span>  by a constant  <span class="math">b&#x27; \\in \\mathbb{F}_p</span>  using Algorithm 7, instead of the general multiplication in  <span class="math">\\mathbb{F}_{p^2}</span> .</p>

    <p class="text-gray-300">Algorithm 14 Multiplication by  <span class="math">b_{0} \\in \\mathbb{F}_{p^{2}}</span> . Require:  <span class="math">A = a_{0} + a_{1}v + a_{2}v^{2}\\in \\mathbb{F}_{p^{6}}</span>  and  <span class="math">b_{0}\\in \\mathbb{F}_{p^{2}}</span> Ensure:  <span class="math">C = c_0 + c_1v + c_2v^2 = A\\cdot b_0\\in \\mathbb{F}_{p^6}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">c_{0}\\gets a_{0}\\cdot b_{0}</span></li>

      <li><span class="math">c_{1}\\gets a_{1}\\cdot b_{0}</span></li>

      <li><span class="math">c_{2}\\gets a_{2}\\cdot b_{0}</span></li>

      <li>return  <span class="math">C = c_0 + c_1v + c_2v^2</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 15 Multiplication by  <span class="math">b_{0} + b_{1}v</span> . Require:  <span class="math">A = a_{0} + a_{1}v + a_{2}v^{2}\\in \\mathbb{F}_{p^{6}}</span>  and  <span class="math">b_{0},b_{1}\\in \\mathbb{F}_{p^{2}}</span> Ensure:  <span class="math">C = c_0 + c_1v + c_2v^2 = A\\cdot (b_0 + b_1v)\\in \\mathbb{F}_{p^6}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">t_0\\gets a_0\\cdot b_0</span></li>

      <li><span class="math">t_1\\gets a_1\\cdot b_1</span></li>

      <li><span class="math">c_{0}\\gets ((a_{1} + a_{2})\\cdot (b_{1}) - t_{1})\\cdot \\xi +t_{0};</span></li>

      <li><span class="math">c_{1}\\gets (a_{0} + a_{1})\\cdot (b_{0} + b_{1}) - t_{0} - t_{1};</span></li>

      <li><span class="math">c_{2}\\gets a_{2}\\cdot b_{0} + t_{1};</span></li>

      <li>return  <span class="math">C = c_0 + c_1v + c_2v^2</span></li>

    </ol>

    <p class="text-gray-300">Software Implementation of the Optimal Ate Pairing over BN curves</p>

    <p class="text-gray-300">Algorithm 16 Squaring in  <span class="math">\\mathbb{F}_{p^6} = \\mathbb{F}_{p^2}[v] / (v^3 -\\xi)</span> Require:  <span class="math">A = a_{0} + a_{1}v + a_{2}v^{2}\\in \\mathbb{F}_{p^{6}}</span> Ensure:  <span class="math">C = c_{0} + c_{1}v + c_{2}v^{2} = A^{2}\\in \\mathbb{F}_{p^{6}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">c_{4}\\gets 2(a_{0}\\cdot a_{1})</span></li>

      <li><span class="math">c_{5}\\gets a_{5}^{2}</span></li>

      <li><span class="math">c_{1}\\gets c_{5}\\cdot \\xi +c_{4}</span></li>

      <li><span class="math">c_{2}\\gets c_{4} - c_{5}</span></li>

      <li><span class="math">c_{3}\\gets a_{0}^{2}</span></li>

      <li><span class="math">c_{4}\\gets a_{0} - a_{1} + a_{2}</span></li>

      <li><span class="math">c_{5}\\gets 2(a_{1}\\cdot a_{2})</span></li>

      <li><span class="math">c_{4}\\gets c_{4}^{2}</span></li>

      <li><span class="math">c_{0}\\gets c_{5}\\cdot \\xi +c_{3}</span></li>

      <li><span class="math">c_{2}\\gets c_{2} + c_{4} + c_{5} - c_{3}</span></li>

      <li>return  <span class="math">C = c_{0} + c_{1}v + c_{2}v^{2}</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 17 Inverse in  <span class="math">\\mathbb{F}_{p^6} = \\mathbb{F}_{p^2}[v] / (v^3 -\\xi)</span> Require:  <span class="math">A = a_{0} + a_{1}v + a_{2}v^{2}\\in \\mathbb{F}_{p^{6}}</span> Ensure:  <span class="math">C = c_{0} + c_{1}v + c_{2}v^{2} = A^{-1}\\in \\mathbb{F}_{p^{6}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">t_0\\gets a_0^2</span></li>

      <li><span class="math">t_1\\gets a_1^2</span></li>

      <li><span class="math">t_2\\gets a_2^2</span></li>

      <li><span class="math">t_3\\gets a_0\\cdot a_1</span></li>

      <li><span class="math">t_4\\gets a_0\\cdot a_2</span></li>

      <li><span class="math">t_5\\gets a_2\\cdot a_3</span></li>

      <li><span class="math">c_{0}\\gets t_{0} - \\xi \\cdot t_{5}</span></li>

      <li><span class="math">c_{1}\\gets \\xi \\cdot t_{2} - t_{3}</span></li>

      <li><span class="math">c_{2}\\gets t_{1}\\cdot t_{4}</span></li>

      <li><span class="math">t_6\\gets a_0\\cdot c_0</span></li>

      <li><span class="math">t_6\\gets t_6 + \\xi \\cdot a_2\\cdot c_1</span></li>

      <li><span class="math">t_6\\gets t_6 + \\xi \\cdot a_1\\cdot c_2</span></li>

      <li><span class="math">t_6\\gets t_6^{-1}</span></li>

      <li><span class="math">c_{0}\\gets c_{0}\\cdot t_{6}</span></li>

      <li><span class="math">c_{1}\\gets c_{1}\\cdot t_{6}</span></li>

      <li><span class="math">c_{2}\\gets c_{2}\\cdot t_{6}</span></li>

      <li>return  <span class="math">C = c_{0} + c_{1}v + c_{2}v^{2}</span></li>

    </ol>

    <p class="text-gray-300">J.-L. Beuchat et al.</p>

    <p class="text-gray-300">Algorithm 18 Addition in  <span class="math">\\mathbb{F}_{p^{12}} = \\mathbb{F}_{p^6}[w] / (w^2 -\\gamma)</span> Require:  <span class="math">A = a_{0} + a_{1}w\\in \\mathbb{F}_{p^{12}}</span>  and  <span class="math">B = b_{0} + b_{1}w\\in \\mathbb{F}_{p^{12}}</span> Ensure:  <span class="math">C = c_{0} + c_{1}w = A + B\\in \\mathbb{F}_{p^{12}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">c_{0}\\gets a_{0} + b_{0}</span></li>

      <li><span class="math">c_{1}\\gets a_{1} + b_{1}</span></li>

      <li>return  <span class="math">C = c_0 + c_1w</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 19 Subtraction in  <span class="math">\\mathbb{F}_{p^{12}} = \\mathbb{F}_{p^6}[w] / (w^2 -\\gamma)</span> Require:  <span class="math">A = a_{0} + a_{1}w\\in \\mathbb{F}_{p^{12}}</span>  and  <span class="math">B = b_{0} + b_{1}w\\in \\mathbb{F}_{p^{12}}</span> Ensure:  <span class="math">C = c_0 + c_1w = A - B\\in \\mathbb{F}_{p^{12}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">c_{0}\\gets a_{0} - b_{0}</span></li>

      <li><span class="math">c_{1}\\gets a_{1} - b_{1}</span></li>

      <li>return  <span class="math">C = c_0 + c_1w</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 20 Multiplication in  <span class="math">\\mathbb{F}_{p^{12}} = \\mathbb{F}_{p^6}[w] / (w^2 -\\gamma)</span> Require:  <span class="math">A = a_0 + a_1w\\in \\mathbb{F}_{p^{12}}</span>  and  <span class="math">B = b_{0} + b_{1}w\\in \\mathbb{F}_{p^{12}}</span> Ensure:  <span class="math">C = c_0 + c_1w = A\\cdot B\\in \\mathbb{F}_{p^{12}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">t_0\\gets a_0\\cdot b_0</span></li>

      <li><span class="math">t_1\\gets a_1\\cdot b_1</span></li>

      <li><span class="math">c_{0}\\gets t_{0} + t_{1}\\cdot \\gamma</span></li>

      <li><span class="math">c_{1}\\gets (a_{0} + a_{1})\\cdot (b_{0} + b_{1}) - t_{0} - t_{1}</span></li>

      <li>return  <span class="math">C = c_0 + c_1w</span></li>

    </ol>

    <p class="text-gray-300">The next algorithm will be required during the execution of the optimal ate pairing computation (instead of Algorithm 20), avoiding unnecessary multiplications by zero.</p>

    <p class="text-gray-300">Software Implementation of the Optimal Ate Pairing over BN curves</p>

    <p class="text-gray-300">|  Algorithm 21 Multiplication by B = b0 + b1w, where b0 ∈ Fp2 and b1 = b10 + b11v + 0v2  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Require: A = a0 + a1w ∈ Fp12 and B = b0 + b1w ∈ Fp12, with b0 = b00 + 0v + 0v2 and b1 = b10 + b11v + 0v2.  |   |</p>

    <p class="text-gray-300">|  Ensure: C = c0 + c1w = A · B ∈ Fp12.  |   |</p>

    <p class="text-gray-300">|  1. t0 ← a0 · b0; {Algorithm 14}  |   |</p>

    <p class="text-gray-300">|  2. t1 ← a1 · b1; {Algorithm 15}  |   |</p>

    <p class="text-gray-300">|  3. c0 ← t0 + t1 · γ;  |   |</p>

    <p class="text-gray-300">|  4. t2 ← (b0 + b10)v + b11v + 0v2;  |   |</p>

    <p class="text-gray-300">|  5. c1 ← (a0 + a1) · t2; {Algorithm 15}  |   |</p>

    <p class="text-gray-300">|  6. c1 ← c1 - t0 - t1;  |   |</p>

    <p class="text-gray-300">|  7. return C = c0 + c1w;  |   |</p>

    <p class="text-gray-300">|  Algorithm 22 Squaring in Fp12 = Fp6[w]/(w2 - γ).  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Require: A = a0 + a1w ∈ Fp12.  |   |</p>

    <p class="text-gray-300">|  Ensure: C = c0 + c1w = A2 ∈ Fp12.  |   |</p>

    <p class="text-gray-300">|  1. c0 ← a0 - a1;  |   |</p>

    <p class="text-gray-300">|  2. c3 ← a0 - γ · a1;  |   |</p>

    <p class="text-gray-300">|  3. c2 ← a0 · a1;  |   |</p>

    <p class="text-gray-300">|  4. c0 ← c0 · c3 + c2;  |   |</p>

    <p class="text-gray-300">|  5. c1 ← 2c2;  |   |</p>

    <p class="text-gray-300">|  6. c2 ← γ · c2;  |   |</p>

    <p class="text-gray-300">|  7. c0 ← c0 + c2;  |   |</p>

    <p class="text-gray-300">|  8. return C = c0 + c1w;  |   |</p>

    <p class="text-gray-300">|  Algorithm 23 Inverse in Fp12 = Fp6[w]/(w2 - γ).  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Require: A = a0 + a1w ∈ Fp12.  |   |</p>

    <p class="text-gray-300">|  Ensure: C = c0 + c1w = A-1 ∈ Fp12.  |   |</p>

    <p class="text-gray-300">|  1. t0 ← a03;  |   |</p>

    <p class="text-gray-300">|  2. t1 ← a12;  |   |</p>

    <p class="text-gray-300">|  3. t0 ← t0 - γ · t1;  |   |</p>

    <p class="text-gray-300">|  4. t1 ← t0-1;  |   |</p>

    <p class="text-gray-300">|  5. c0 ← a0 · t1;  |   |</p>

    <p class="text-gray-300">|  6. c1 ← -1 · a1 · t1;  |   |</p>

    <p class="text-gray-300">|  7. return C = c0 + c1w;  |   |</p>

    <p class="text-gray-300">J.-L. Beuchat et al.</p>

    <p class="text-gray-300">We stress that Algorithms 24 and 25 for computing field squaring and exponentiation over  <span class="math">\\mathbb{F}_{p^{12}}</span> , respectively, can be only used when  <span class="math">X \\in \\mathbb{F}_{p^{12}}</span>  satisfies  <span class="math">X^{p^0 + 1} = 1</span> . Algorithm 24 is based on the work presented in [17]. Let  <span class="math">f = g + hw \\in \\mathbb{F}_{p^{12}}</span>  be an element in the representation  <span class="math">\\mathbb{F}_{p^{12}} = \\mathbb{F}_{p^6}[w] / (w^2 - \\gamma)</span> . Then, in order to reduce the required number of field multiplications, we can write  <span class="math">f</span>  using the towering  <span class="math">\\mathbb{F}_{p^{12}} = \\mathbb{F}_{p^4}[X] / (X^3 - \\gamma)</span> , where  <span class="math">\\mathbb{F}_{p^4} = \\mathbb{F}_{p^2}[V] / (V^2 - \\xi)</span> . In that representation,  <span class="math">f</span>  can be equivalently written as  <span class="math">f = g + hw = (g_0 + h_1V) + (h_0 + g_2V)X + (g_1 + h_2V)X^2</span> . We note that the first three squarings of Lines 1, 2 and 3, must be performed using Algorithm 9.</p>

    <p class="text-gray-300">Algorithm 24 Squaring in  <span class="math">\\mathbb{F}_{p^{12}} = \\mathbb{F}_{p^6}[w] / (w^2 -\\gamma)</span> Require:  <span class="math">f = g + hw\\in \\mathbb{F}_{p^{12}}</span>  , with  <span class="math">g = g_{0} + g_{1}v + g_{2}v^{2}</span>  and  <span class="math">h = h_0 + h_1v + h_2v^2</span> Ensure:  <span class="math">C = c_{0} + c_{1}w = f^{2}\\in \\mathbb{F}_{p^{12}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">t_{0,0},t_{1,1}\\gets (g_0 + h_1V)^2;</span></li>

      <li><span class="math">t_{1,2},t_{0,1}\\gets (h_0 + g_2V)^2;</span></li>

      <li><span class="math">t_{0,2}</span>  ,aux  <span class="math">\\leftarrow (g_1 + h_2V)^2</span></li>

      <li><span class="math">t_{1,0}\\gets aux\\cdot \\xi</span></li>

      <li><span class="math">c_{0,0}\\gets -2g_0 + 3t_{0,0}</span></li>

      <li><span class="math">c_{0,1}\\gets -2g_1 + 3t_{0,1}</span></li>

      <li><span class="math">c_{0,2}\\gets -2g_2 + 3t_{0,2}</span></li>

      <li><span class="math">c_{1,0}\\gets 2h_0 + 3t_{1,0}</span></li>

      <li><span class="math">c_{1,1}\\gets 2h_1 + 3t_{1,1}</span></li>

      <li><span class="math">c_{1,2}\\gets 2h_2 + 3t_{1,2}</span></li>

      <li><span class="math">c_{0},c_{1}\\in \\mathbb{F}_{p^{6}}</span></li>

      <li><span class="math">c_{0}\\gets c_{0,0} + c_{0,1}v + c_{1,2}v^{2};</span></li>

      <li><span class="math">c_{1}\\gets c_{1,0} + c_{1,1}v + c_{1,2}v^{2};</span></li>

      <li>return  <span class="math">C = c_0 + c_1w</span></li>

    </ol>

    <p class="text-gray-300">In the exponentiation Algorithm 25, it is assumed that the exponent  <span class="math">e</span>  is given as,  <span class="math">e = (e_{L - 1},\\ldots ,e_1,e_0)</span> , where  <span class="math">e_i\\in \\{-1,0,1\\}</span>  for  <span class="math">i = 0,\\dots ,L - 1</span>  and where  <span class="math">e_{L - 1} = 1</span> .</p>

    <p class="text-gray-300">Software Implementation of the Optimal Ate Pairing over BN curves</p>

    <p class="text-gray-300">Algorithm 25 Exponentiation in  <span class="math">\\mathbb{F}_{p^{12}} = \\mathbb{F}_{p^6}[w] / (w^2 -\\gamma)</span> Require:  <span class="math">A\\in \\mathbb{F}_{p^{12}}</span>  and  <span class="math">e = \\sum_{i = 0}^{L - 1}e_i2^i</span> Ensure:  <span class="math">C = A^e\\in \\mathbb{F}_{p^{12}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">C\\gets A</span></li>

      <li>for  <span class="math">i\\gets L - 2</span>  downto 0 do</li>

      <li><span class="math">C\\gets C^2</span>  ; {Algorithm 24}</li>

      <li>if  <span class="math">e_i\\neq 0</span>  then</li>

      <li>if  <span class="math">e_i &amp;gt; 0</span>  then</li>

      <li><span class="math">C\\gets C\\cdot A</span></li>

      <li>else</li>

      <li><span class="math">C\\gets C\\cdot \\bar{A}</span></li>

      <li>end if</li>

      <li>end if</li>

      <li>end for</li>

      <li>return C;</li>

    </ol>

    <p class="text-gray-300">For the line operations, we need to work with the points on the twist as a jacobian points, i.e.  <span class="math">(X,Y,Z)\\in E^{\\prime}(\\mathbb{F}_{p^{2}})</span> . But it is also a good idea to keep some extra values, for instance  <span class="math">Z^2</span> , which is required several times in Algorithms 26 and 27.</p>

    <p class="text-gray-300">J.-L. Beuchat et al.</p>

    <p class="text-gray-300">|  Algorithm 26 Point doubling and line evaluation  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Require: Q ∈ E(Fp2) and P ∈ E(Fp), where Q = (XQ, YQ, ZQ) and P = (xP, yP).  |   |</p>

    <p class="text-gray-300">|  Ensure: T = 2Q and lQ,Q(P) ∈ Fp12, where T = (XT, YT, ZT) and l = l0 + l1w; l_i ∈ Fp6.  |   |</p>

    <p class="text-gray-300">|  1. tmp0← XQ2;  |   |</p>

    <p class="text-gray-300">|  2. tmp1← YQ2;  |   |</p>

    <p class="text-gray-300">|  3. tmp2← tmp12;  |   |</p>

    <p class="text-gray-300">|  4. tmp3← (tmp1 + XQ)2 - tmp0 - tmp2;  |   |</p>

    <p class="text-gray-300">|  5. tmp3← 2tmp3;  |   |</p>

    <p class="text-gray-300">|  6. tmp4← 3tmp0;  |   |</p>

    <p class="text-gray-300">|  7. tmp0← XQ + tmp4;  |   |</p>

    <p class="text-gray-300">|  8. tmp5← tmp42;  |   |</p>

    <p class="text-gray-300">|  9. XT← tmp5 - 2tmp3;  |   |</p>

    <p class="text-gray-300">|  10. ZT← (YQ + ZQ)2 - tmp1 - ZQ2;  |   |</p>

    <p class="text-gray-300">|  11. YT← (tmp3 - XT) · tmp4 - 8tmp2;  |   |</p>

    <p class="text-gray-300">|  12. tmp3← -2(tmp4 · ZQ2);  |   |</p>

    <p class="text-gray-300">|  13. tmp3← tmp2 · xP; {Algorithm 7}  |   |</p>

    <p class="text-gray-300">|  14. tmp0← tmp02 - tmp0 - tmp5 - 4tmp1;  |   |</p>

    <p class="text-gray-300">|  15. tmp0← 2(ZT · ZQ2);  |   |</p>

    <p class="text-gray-300">|  16. tmp0← tmp0 · yP; {Algorithm 7}  |   |</p>

    <p class="text-gray-300">|  17. a0, a1 ∈ Fp6;  |   |</p>

    <p class="text-gray-300">|  18. a0← tmp0 + 0v + 0v2;  |   |</p>

    <p class="text-gray-300">|  19. a1← tmp3 + tmp0v + 0v2;  |   |</p>

    <p class="text-gray-300">|  20. T← (XT, YT, ZT);  |   |</p>

    <p class="text-gray-300">|  21. l← a0 + a1w;  |   |</p>

    <p class="text-gray-300">|  22. return l, T;  |   |</p>

    <p class="text-gray-300">Software Implementation of the Optimal Ate Pairing over BN curves</p>

    <p class="text-gray-300">|  Algorithm 27 Point addition and line evaluation  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Require: Q, R ∈ E(Fp2) and P ∈ E(Fp), where Q = (XQ, YQ, ZQ), R = (XR, YR, ZR) and P = (xP, yP).  |   |</p>

    <p class="text-gray-300">|  Ensure: T = Q + R and lR,Q(P) ∈ Fp12, where T = (XT, YT, ZT) and l = l0 + l1w; l_i ∈ Fp6.  |   |</p>

    <p class="text-gray-300">|  1. t0← XQ · ZR2;  |   |</p>

    <p class="text-gray-300">|  2. t1← (YQ + ZR)2 - YQ2 - ZR2;  |   |</p>

    <p class="text-gray-300">|  3. t1← t1 · ZR2;  |   |</p>

    <p class="text-gray-300">|  4. t2← t0 - XR;  |   |</p>

    <p class="text-gray-300">|  5. t3← t2;  |   |</p>

    <p class="text-gray-300">|  6. t4← 4t3;  |   |</p>

    <p class="text-gray-300">|  7. t5← t4 · t2;  |   |</p>

    <p class="text-gray-300">|  8. t6← t1 - 2YR;  |   |</p>

    <p class="text-gray-300">|  9. t9← t6 · XQ;  |   |</p>

    <p class="text-gray-300">|  10. t7← XR · t4;  |   |</p>

    <p class="text-gray-300">|  11. XT← t62 - t5 - 2t7;  |   |</p>

    <p class="text-gray-300">|  12. ZT← (ZR + t2)2 - ZR2 - t3;  |   |</p>

    <p class="text-gray-300">|  13. t10← YQ + ZT;  |   |</p>

    <p class="text-gray-300">|  14. t8← (t7 - XT) · t6;  |   |</p>

    <p class="text-gray-300">|  15. t0← 2(YR · t5);  |   |</p>

    <p class="text-gray-300">|  16. YT← t8 - t0;  |   |</p>

    <p class="text-gray-300">|  17. t10← t102 - YQ2 - ZT2;  |   |</p>

    <p class="text-gray-300">|  18. t9← 2t9 - t10;  |   |</p>

    <p class="text-gray-300">|  19. t10← 2(ZT · yP); {Algorithm 7}  |   |</p>

    <p class="text-gray-300">|  20. t6← -t6;  |   |</p>

    <p class="text-gray-300">|  21. t1← 2(t6 · xP); {Algorithm 7}  |   |</p>

    <p class="text-gray-300">|  22. l0, l1 ∈ Fp6;  |   |</p>

    <p class="text-gray-300">|  23. l0← t10 + 0v + 0v2;  |   |</p>

    <p class="text-gray-300">|  24. l1← t1 + t9v + 0v2;  |   |</p>

    <p class="text-gray-300">|  25. T← (XT, YT, ZT);  |   |</p>

    <p class="text-gray-300">|  26. l← l0 + l1w;  |   |</p>

    <p class="text-gray-300">|  27. return l, T;  |   |</p>

    <p class="text-gray-300">Some multiplications between elements from different field extensions are required, we need to consider those operations as particular cases instead of performing unnecessary products by zero.</p>

    <p class="text-gray-300">To perform the final exponentiation, we need to raise  <span class="math">f \\in \\mathbb{F}_{p^{12}}</span>  to the  <span class="math">p</span> -power, as described in Section 3.2. Algorithms 28-30, compute  <span class="math">f^p</span> ,  <span class="math">f^{p^2}</span>  and  <span class="math">f^{p^3}</span> , respectively, where  <span class="math">f</span>  is a field element in  <span class="math">\\mathbb{F}_{p^{12}} = \\mathbb{F}_{p^2}[W] / (W^6 - \\xi)</span> .</p>

    <p class="text-gray-300">J.-L. Beuchat et al.</p>

    <p class="text-gray-300">Algorithm 28 Frobenius raised to  <span class="math">p</span>  of  <span class="math">f\\in \\mathbb{F}_{p^{12}} = \\mathbb{F}_{p^6}[w] / (w^2 -\\gamma)</span> Require:  <span class="math">f\\in \\mathbb{F}_{p^{12}}</span>  , where  <span class="math">f = g + hw</span>  .  <span class="math">f_{i}\\in \\mathbb{F}_{p^{6}}</span>  . And  <span class="math">g = g_0 + g_1v + g_2v^2</span>  .  <span class="math">h =</span> <span class="math">h_0 + h_1v + h_2v^2</span> Ensure:  <span class="math">f^{p}\\in \\mathbb{F}_{p^{12}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">t_1\\gets \\bar{g}_0</span>  ; {First we need to rearrange the elements and conjugate them}</li>

      <li><span class="math">t_2\\gets \\bar{h}_0</span>  .</li>

      <li><span class="math">t_3\\gets \\bar{g}_1</span>  .</li>

      <li><span class="math">t_4\\gets \\bar{h}_1</span>  .</li>

      <li><span class="math">t_5\\gets \\bar{g}_2</span>  .</li>

      <li><span class="math">t_6\\gets \\bar{h}_2</span>  .</li>

      <li>for  <span class="math">i = 1</span>  to 5 do</li>

      <li><span class="math">\\gamma_{1,i} = \\xi^{i\\cdot (p - 1) / 6}</span>  .</li>

      <li>end for</li>

      <li><span class="math">t_2\\gets t_2\\cdot \\gamma_{1,1}</span>  .</li>

      <li><span class="math">t_3\\gets t_3\\cdot \\gamma_{1,2}</span>  .</li>

      <li><span class="math">t_4\\gets t_4\\cdot \\gamma_{1,3}</span>  .</li>

      <li><span class="math">t_5\\gets t_5\\cdot \\gamma_{1,4}</span>  .</li>

      <li><span class="math">t_6\\gets t_6\\cdot \\gamma_{1,5}</span>  .</li>

      <li><span class="math">c_{0}\\gets t_{1} + t_{3}v + t_{5}v^{2}</span>  .</li>

      <li><span class="math">c_{1}\\gets t_{2} + t_{4}v + t_{6}v^{2}</span>  .</li>

      <li>return  <span class="math">C\\gets c_0 + c_1w</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 29 Frobenius raised to  <span class="math">p^2</span>  of  <span class="math">f \\in \\mathbb{F}_{p^{12}} = \\mathbb{F}_{p^6}[w] / (w^2 - \\gamma)</span> . Require:  <span class="math">f\\in \\mathbb{F}_{p^{12}}</span>  , where  <span class="math">f = g + hw</span>  .  <span class="math">f_{i}\\in \\mathbb{F}_{p^{6}}</span>  . And  <span class="math">g = g_0 + g_1v + g_2v^2</span>  .  <span class="math">h =</span> <span class="math">h_0 + h_1v + h_2v^2</span> Ensure:  <span class="math">f^{p^2}\\in \\mathbb{F}_{p^{12}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for  <span class="math">i = 1</span>  to 5 do</li>

      <li><span class="math">\\gamma_{2,i} = \\gamma_{1,i}\\cdot \\gamma_i^p</span>  .</li>

      <li>end for</li>

      <li><span class="math">t_1\\gets g_0</span>  .</li>

      <li><span class="math">t_2\\gets h_0\\cdot \\gamma_{2,1}</span>  .</li>

      <li><span class="math">t_3\\gets g_1\\cdot \\gamma_{2,2}</span>  .</li>

      <li><span class="math">t_4\\gets h_1\\cdot \\gamma_{2,3}</span>  .</li>

      <li><span class="math">t_5\\gets g_2\\cdot \\gamma_{2,4}</span>  .</li>

      <li><span class="math">t_6\\gets h_2\\cdot \\gamma_{2,5}</span>  .</li>

      <li><span class="math">c_{0}\\gets t_{1} + t_{3}v + t_{5}v^{2}</span>  .</li>

      <li><span class="math">c_{1}\\gets t_{2} + t_{4}v + t_{6}v^{2}</span>  .</li>

      <li>return  <span class="math">C\\gets c_0 + c_1w</span></li>

    </ol>

    <p class="text-gray-300">Software Implementation of the Optimal Ate Pairing over BN curves</p>

    <p class="text-gray-300">|  Algorithm 30 Frobenius raised to p3 of f ∈ Fp12 = Fp6[w]/(w2 - γ).  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Require: f ∈ Fp12, where f = g + hw; fi ∈ Fp6. And g = g0 + g1v + g2v2; h = h0 + h1v + h2v2  |   |</p>

    <p class="text-gray-300">|  Ensure: fp3 ∈ Fp12.  |   |</p>

    <p class="text-gray-300">|  1. t1 ← g0; {First we need to rearrange the elements and conjugate them}  |   |</p>

    <p class="text-gray-300">|  2. t2 ← h0;  |   |</p>

    <p class="text-gray-300">|  3. t3 ← g1;  |   |</p>

    <p class="text-gray-300">|  4. t4 ← h1;  |   |</p>

    <p class="text-gray-300">|  5. t5 ← g2;  |   |</p>

    <p class="text-gray-300">|  6. t6 ← h2;  |   |</p>

    <p class="text-gray-300">|  7. for i = 1 to 5 do  |   |</p>

    <p class="text-gray-300">|  8. γ3,i = γ1,i · γ2,i;  |   |</p>

    <p class="text-gray-300">|  9. end for  |   |</p>

    <p class="text-gray-300">|  10. t2 ← t2 · γ3,1;  |   |</p>

    <p class="text-gray-300">|  11. t3 ← t3 · γ3,2;  |   |</p>

    <p class="text-gray-300">|  12. t4 ← t4 · γ3,3;  |   |</p>

    <p class="text-gray-300">|  13. t5 ← t5 · γ3,4;  |   |</p>

    <p class="text-gray-300">|  14. t6 ← t6 · γ3,5;  |   |</p>

    <p class="text-gray-300">|  15. c0 ← t1 + t3v + t5v2;  |   |</p>

    <p class="text-gray-300">|  16. c1 ← t2 + t4v + t6v2;  |   |</p>

    <p class="text-gray-300">|  17. return C ← c0 + c1w;  |   |</p>

    <p class="text-gray-300">J.-L. Beuchat et al.</p>

    <p class="text-gray-300">|  Algorithm 31 Final Exponentiation  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Require: f ∈ Fp12 = Fp6[w]/(w2-γ), where f = g + hw.  |   |</p>

    <p class="text-gray-300">|  Ensure: f(p12-1)/r ∈ Fp12.  |   |</p>

    <p class="text-gray-300">|  1. f1← f;  |   |</p>

    <p class="text-gray-300">|  2. f2← f-1;  |   |</p>

    <p class="text-gray-300">|  3. f← f1·f2;  |   |</p>

    <p class="text-gray-300">|  4. f← fp3·f; {Algorithm 29}  |   |</p>

    <p class="text-gray-300">|  5. ft1← f1; {Algorithm 25}  |   |</p>

    <p class="text-gray-300">|  6. ft2← f12;  |   |</p>

    <p class="text-gray-300">|  7. ft3← f13;  |   |</p>

    <p class="text-gray-300">|  8. fp1← fp; {Algorithm 28}  |   |</p>

    <p class="text-gray-300">|  9. fp2← fp2; {Algorithm 29}  |   |</p>

    <p class="text-gray-300">|  10. fp3← fp3; {Algorithm 30}  |   |</p>

    <p class="text-gray-300">|  11. y0← fp1·fp2·fp3;  |   |</p>

    <p class="text-gray-300">|  12. y1← f1;  |   |</p>

    <p class="text-gray-300">|  13. y2← (ft2)p2; {Algorithm 29}  |   |</p>

    <p class="text-gray-300">|  14. y3← (ft1)p; {Algorithm 28}  |   |</p>

    <p class="text-gray-300">|  15. y3← y3;  |   |</p>

    <p class="text-gray-300">|  16. y4← (ft2)p·ft1; {Algorithm 28}  |   |</p>

    <p class="text-gray-300">|  17. y4← y4;  |   |</p>

    <p class="text-gray-300">|  18. y5← ft2;  |   |</p>

    <p class="text-gray-300">|  19. y6← (ft3)p·ft3; {Algorithm 28}  |   |</p>

    <p class="text-gray-300">|  20. y6← y6;  |   |</p>

    <p class="text-gray-300">|  21. t0← y62·y4·y5; {Algorithm 24 for squaring}  |   |</p>

    <p class="text-gray-300">|  22. t1← y3·y5·t0;  |   |</p>

    <p class="text-gray-300">|  23. t0← t0·y2;  |   |</p>

    <p class="text-gray-300">|  24. t1← (t12·t0)2; {Algorithm 24 for squaring}  |   |</p>

    <p class="text-gray-300">|  25. t0← t1·y1;  |   |</p>

    <p class="text-gray-300">|  26. t1← t1·y0;  |   |</p>

    <p class="text-gray-300">|  27. t0← t02; {Algorithm 24}  |   |</p>

    <p class="text-gray-300">|  28. f← t1·t0;  |   |</p>

    <p class="text-gray-300">|  29. return f;  |   |</p>`;
---

<BaseLayout title="High-Speed Software Implementation of the Optimal Ate Pairin... (2010/354)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2010 &middot; eprint 2010/354
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
