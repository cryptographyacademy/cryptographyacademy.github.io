---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/613';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A Security Analysis of the Composition of ChaCha20 and Poly1305';
const AUTHORS_HTML = 'Gordon Procter';

const CONTENT = `    <p class="text-gray-300">Gordon Procter</p>

    <p class="text-gray-300">Information Security Group, Royal Holloway, University of London, London, UK gordon.procter.2011@live.rhul.ac.uk</p>

    <p class="text-gray-300">Abstract. This note contains a security reduction to demonstrate that Langley's composition of Bernstein's ChaCha20 and Poly1305, as proposed for use in IETF protocols, is a secure authenticated encryption scheme. The reduction assumes that ChaCha20 is a PRF, that Poly1305 is <span class="math">\\epsilon</span>-almost-<span class="math">\\Delta</span>-universal, and that the adversary is nonce respecting.</p>

    <p class="text-gray-300">There has recently been a proposal to the CFRG to consider a combination of ChaCha20 and Poly1305 for inclusion in future IETF protocols [11]. This proposal has come about, in part, due to concern over the reliance of existing IETF protocols on AES and the risk that advances in the cryptanalysis of AES could leave users without a good choice for a symmetric cryptographic primitive. A similar concern lead to the SHA-3 competition; improvements to attacks against SHA-1 lead NIST to transition to the SHA-2 family of hash functions and to announce the SHA-3 competition, with the aim of choosing an alternative hash function to 'improve the robustness of NISTs overall hash algorithm toolkit' [12].</p>

    <p class="text-gray-300">ChaCha20 is a stream cipher designed by Bernstein [4], based on the Salsa family of stream ciphers [5]; in both of these ciphers, the keystream is generated using a 'block function' in a mode reminiscent of the counter mode of operation for block ciphers. This note will assume that the ChaCha20 block function is a PRF with signature <span class="math">\\mathsf{CC}:\\{0,1\\}^{256}\\times \\{0,1\\}^{128}\\to \\{0,1\\}^{512}</span>, that is, 32-byte keys, 16-byte input, and 64-byte output. A few papers have attacked reduced round versions for ChaCha20 (for example, [1,9,14]) however this analysis has not contradicted the PRF security of ChaCha20. Poly1305 is a universal hash function [7] based on polynomial evaluation [6,8,16], also designed by Bernstein [3].</p>

    <p class="text-gray-300">This note gives a reduction from the security of the proposed combination of ChaCha20 and Poly1305 to the PRF-security of the ChaCha20 block function. Although both primitives are believed to be secure, it is possible to combine secure primitives in a way that is insecure (for a discussion and formal treatment of this issue, see [2]); for this reason, a security analysis of the combined scheme is important. Note that the generic results of Bellare and Namprempre [2] do not apply in this case as those results assume that independent keys are used in the component primitives. The analysis presented in this note does not concern the assumption that ChaCha20 behaves as a PRF. The proof will also make use of the fact that Poly1305 is an <span class="math">\\epsilon</span>-almost-<span class="math">\\Delta</span>-universal (<span class="math">\\epsilon</span>-A<span class="math">\\Delta</span>U) hash function [15] where <span class="math">\\Delta</span> represents addition modulo <span class="math">2^{128}</span>, which Bernstein [3] has shown to be the case for <span class="math">\\epsilon = \\frac{8\\lceil L / 16\\rceil}{2^{106}}</span> for messages of length at most <span class="math">L</span> bytes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notation For brevity, the ChaCha20 block function will be denoted by CC, Poly1305 by Poly, and the composition as defined in draft-irtf-cfrg-chacha20-poly1305-00 [11] by CC&amp;Poly. The key will be denoted by <span class="math">k</span> and the per-message nonce by <span class="math">N</span>. Associated data, plaintext, and ciphertext will be denoted by <span class="math">A</span>, <span class="math">P</span>, and <span class="math">C</span> respectively. The concatenation of strings <span class="math">x</span> and <span class="math">y</span> will be denoted by $x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y<span class="math"> and </span>\\mathsf{trunc}_n(x)<span class="math"> will represent the truncation of a string </span>x<span class="math"> to </span>n<span class="math"> bytes. The byte length of a string </span>x<span class="math"> will be denoted </span>\\mathsf{len}_x<span class="math">; in the computation of </span>\\mathsf{Poly}_r(A,C)<span class="math">, </span>\\mathsf{len}_{A,C}<span class="math"> will represent the 16-byte block consisting of a 8-byte representation of the length of </span>A<span class="math"> in bytes, concatenated with a 8-byte block corresponding to the length of </span>C$. The ChaCha20 block function outputs blocks of keystream that are 64 bytes wide, so the plaintext and ciphertext will be encrypted and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ecrypted in blocks of 64 bytes. These blocks of plaintext and ciphertext will be denoted <span class="math">P_{i}</span> and <span class="math">C_{i}</span> with $P=P_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_{p}<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=64<span class="math"> bytes, except perhaps for </span>P_{p}<span class="math"> which may be shorter (similarly for </span>C<span class="math">). When </span>A<span class="math"> and </span>C<span class="math"> are zero padded to fill 16-byte blocks, this will be denoted </span>\\overline{A}<span class="math"> and </span>\\overline{C}<span class="math">. The notation </span>x\\ \\leftarrow{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">the Integrity of Ciphertexts (INT-CTXT). These notions were introduced by Bellare and Namprempre <em>[2]</em> and together these these properties imply IND-CCA security. In fact, the stronger notion of IND$-CPA security <em>[13]</em> can be shown to be achieved by this composition.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To model these two notions the adversary is given access to an encryption oracle and a decryption oracle and permitted to make at most <span class="math">q</span> queries to these oracles. The proof proceeds via a series of games and the encryption and decryption oracles in Game <span class="math">i</span> are denoted <span class="math">E^{i}</span> and <span class="math">D^{i}</span> respectively. An adversary breaks the IND<span class="math">-CPA security of the scheme if they can distinguish </span>(C,T)<span class="math"> generated by </span>E^{0}<span class="math"> from a random bitstring of the same length (generated by an oracle denoted by </span>);<span class="math"> the adversary’s advantage against the IND</span>-CPA security of a scheme is measured by <span class="math">\\mathbf{Adv}_{ind\\</span>-\\mathit{cpa}}^{\\mathsf{CC\\&Poly}}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\mathcal{A}^{E^{0}}\\to 1]-\\Pr[\\mathcal{A}^{\\$}\\to 1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. An adversary breaks the INT-CTXT security of a scheme if they can forge a ciphertext, i.e. output a tuple </span>(N,A,C,T)<span class="math"> with </span>D_{k}(N,A,C,T)=(N,A,P)\\neq\\bot<span class="math"> where </span>(N,A,C,T)<span class="math"> is not the output from an encryption query and </span>D<span class="math"> outputs </span>\\bot<span class="math"> to signify that the input was not a valid ciphertext. The advantage of this adversary is measured by </span>\\mathbf{Adv}_{int-\\mathit{ctxt}}^{\\mathsf{CC\\&Poly}}=\\Pr[\\mathcal{A}^{E^{0},D^{0}}<span class="math"> forges]. A combined measure of the adversary’s advantage against both IND</span>-CPA and INT-CTXT can be defined as $\\mathbf{Adv}_{ae}^{\\mathsf{CC\\&Poly}}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\mathcal{A}^{E^{0},D^{0}}\\to 1]-\\Pr[\\mathcal{A}^{\\$,\\bot}\\to 1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span>\\bot<span class="math"> is an oracle that simply returns </span>\\bot$ (representing an invalid ciphertext) an all inputs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The adversaries that are considered in this section will be restricted to nonce-respecting adversaries. This is a standard restriction for nonce-based authenticated encryption schemes and means that an adversary will never ask encryption queries <span class="math">(N,A,P)</span> and <span class="math">(N,A^{\\prime},P^{\\prime})</span> for <span class="math">(A,P)\\neq(A^{\\prime},P^{\\prime})</span>. There are no restrictions on the adversary’s use of nonces for decryption queries, however without loss of generality, it is assumed that an adversary makes no redundant queries; no query is repeated and the output from an <span class="math">E</span> query is never input to the <span class="math">D</span> oracle, or vice versa.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">3.2 Reduction</h3>

    <p class="text-gray-300">It is assumed in this security analysis that no pair <span class="math">(k,N^{\\prime})</span> is ever repeated, where <span class="math">N^{\\prime}</span> is the 12-byte nonce that is input to the ChaCha20 block function; this assumption is critical to the security of <span class="math">\\mathsf{CC\\&amp;Poly}</span>. The draft recognises that not all protocols will use 12-byte nonces and ‘it is up to the protocol document to define how to transform the protocol nonce into a 12-byte nonce’ <em>[11, Sect. 2.8]</em>; one suggestion is that prepending a constant value could provide a way to expand a shorter nonce to 12 bytes.</p>

    <p class="text-gray-300">If an implementation permits both 12-byte nonces and shorter nonces and an adversary is able to predict how a short nonce will be expanded to 12 bytes (for example, by guessing the value that will be prepended), then a nonce collision could be forced by querying the encryption oracle using a short <span class="math">N</span> and a 12-byte <span class="math">N^{\\prime}</span> which is the expanded version of <span class="math">N</span>. In what follows, we will assume that all nonces are 12 bytes long and that no (key,nonce) pair is ever repeated to the encryption oracle; the protocol specification therefore must prevent nonce collisions of this form.</p>

    <p class="text-gray-300">This section will assume that ChaCha20 is a PRF with signature <span class="math">\\mathsf{CC}:\\{0,1\\}^{256}\\times\\{0,1\\}^{128}\\to\\{0,1\\}^{512}</span>, that is, 32-byte keys, 16-byte input, and 64-byte output. This assumption has not been contradicted by any of the existing cryptanalysis of ChaCha20 and the analysis presented in this note does not concern this assumption. The proof will also make use of the fact that Poly1305 is an <span class="math">\\epsilon</span>-almost-<span class="math">\\Delta</span>-universal hash function.</p>

    <p class="text-gray-300">The proof proceeds via a series of games, specified in Figures 1 and 2. Game 0 defines a combined IND-CPA and INT-CTXT game, with oracles that realise <span class="math">\\mathsf{CC\\&amp;Poly}</span>. The scheme specified in Game 4 clearly gives no adversary any advantage in either of the IND<span class="math">-CPA and INT-CTXT games: the ciphertext and tag are sampled independently of </span>P<span class="math"> and uniformly at random from </span>\\{0,1\\}^{512}<span class="math"> (as they would be if generated by </span>) and it is impossible for an adversary to query <span class="math">D_{4}</span> with anything returning <span class="math">(N,A,P)\\neq\\bot</span>.</p>

    <p class="text-gray-300">The transitions between these games are justified as follows:</p>

    <p class="text-gray-300">If an adversary is able to distinguish between these two games, then they can distinguish ChaCha20 from a function chosen uniformly at random from the set of all functions with domain <span class="math">\\{0,1\\}^{128}</span> and range <span class="math">\\{0,1\\}^{512}</span>. However, we assume that ChaCha20 is a PRF so no adversary gains a significant advantage through the transition between these games.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">These games are identical, on the condition that the inputs to <span class="math">\\mathsf{URF}</span> in Game 1 never repeat. The inputs to <span class="math">\\mathsf{URF}</span> are all of the form $(i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N)<span class="math">; for each query, </span>N<span class="math"> is constant, but </span>i$ is never re</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and no two encryption queries use the same value for <span class="math">N</span>, therefore the random variables in Games 1 and 2 are identically distributed. These games are identical unless an adversary submits <span class="math">(N,A,C,T)</span> to their decryption oracle and <span class="math">D_{1}</span> returns <span class="math">(N,A,P)\\neq\\bot</span>. However, for each query that an adversary makes, this happens with probability at most <span class="math">\\epsilon</span> (because Poly is <span class="math">\\epsilon</span>-A<span class="math">\\Delta</span>U) (see <em>[10]</em> and <em>[15]</em> for a proof of this). By a standard hybrid argument, the probability that an adversary making at most <span class="math">q</span> queries successfully forges is at most <span class="math">q\\epsilon</span>. The random variables in these games are sampled in different orders, however the joint distributions are identical and therefore these games are identical.</p>

    <p class="text-gray-300">A standard game-hopping argument allows the probability <span class="math">\\Pr(\\mathcal{A}^{G(i-1)}\\to 1)</span> to be bounded in terms of <span class="math">\\Pr(\\mathcal{A}^{Gi}\\to 1)</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr(\\mathcal{A}^{G0}\\to 1)</span> <span class="math">\\leq\\Pr(\\mathcal{A}^{G1}\\to 1)+\\mathbf{Adv}_{prf}^{\\mathsf{CC}}(\\mathcal{B})</span> <span class="math">\\Pr(\\mathcal{A}^{G1}\\to 1)</span> <span class="math">=\\Pr(\\mathcal{A}^{G2}\\to 1)</span> <span class="math">\\Pr(\\mathcal{A}^{G2}\\to 1)</span> <span class="math">\\leq\\Pr(\\mathcal{A}^{G3}\\to 1)+q\\epsilon</span> <span class="math">\\Pr(\\mathcal{A}^{G3}\\to 1)</span> <span class="math">=\\Pr(\\mathcal{A}^{G4}\\to 1)=\\Pr(\\mathcal{A}^{\\S,\\bot}\\to 1)</span></p>

    <p class="text-gray-300">Bernstein <em>[3]</em> demonstrates that Poly1305 is <span class="math">\\epsilon</span>-almost-<span class="math">\\Delta</span>-universal for <span class="math">\\epsilon=\\frac{8\\lceil L/16\\rceil}{2^{106}}</span>, where <span class="math">L</span> denotes the maximum byte length of messages. For this construction <span class="math">L</span> is the largest possible value of <span class="math">16(\\lceil\\frac{1\\mathsf{en}_{A}}{16}\\rceil+\\lceil\\frac{1\\mathsf{en}_{C}}{16}\\rceil+1)</span>, because the specification of CC&Poly pads <span class="math">A</span> and <span class="math">C</span> to 16-byte blocks and adds an extra 16 bytes of message denoting the length of additional data and ciphertext.</p>

    <p class="text-gray-300">Therefore it can be concluded that for every adversary <span class="math">\\mathcal{A}</span> there is an adversary <span class="math">\\mathcal{B}</span> against the PRF security of the ChaCha20 block function such that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbf{Adv}_{AE}^{\\mathsf{CC\\&Poly}}(\\mathcal{A})=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr(\\mathcal{A}^{G0}\\to 1)-\\Pr(\\mathcal{A}^{G4}\\to 1)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathbf{Adv}_{prf}^{\\mathsf{CC}}(\\mathcal{B})+q\\frac{8(\\lceil L/16\\rceil)}{2^{106}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Game <span class="math">i</span>:</p>

    <p class="text-gray-300"><span class="math">k\\ \\leftrightarrows\\{0,1\\}^{n}</span> <span class="math">b\\leftarrow\\mathcal{A}^{E_{k}^{i},D_{k}^{i}}</span> return <span class="math">(b=1)</span></p>

    <p class="text-gray-300">Figure 1: Games used to reduce the security of CC&Poly to the PRF security of CC. Oracles <span class="math">E^{i}</span> and <span class="math">D^{i}</span> are defined in Figure 2</p>

    <h2 id="sec-4" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Jean-Philippe Aumasson, Simon Fischer, Shahram Khazaei, Willi Meier, and Christian Rechberger. New Features of Latin Dances: Analysis of Salsa, ChaCha, and Rumba. In Kaisa Nyberg, editor, Fast Software Encryption, volume 5086 of Lecture Notes in Computer Science, pages 470–488. Springer Berlin Heidelberg, 2008.</li>

      <li>[2] Mihir Bellare and Chanathip Namprempre. Authenticated Encryption: Relations among Notions and Analysis of the Generic Composition Paradigm. In Tatsuaki Okamoto, editor, Advances in Cryptology – ASIACRYPT 2000, volume 1976 of Lecture Notes in Computer Science, pages 531–545. Springer Berlin Heidelberg, 2000.</li>

      <li>[3] Daniel J. Bernstein. The Poly1305-AES Message-Authentication Code. In Henri Gilbert and Helena Handschuh, editors, Fast Software Encryption, volume 3557 of Lecture Notes in Computer Science, pages 32–49. Springer Berlin Heidelberg, 2005.</li>

    </ul>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 2. Oracles used in the games introduced in Figure 1.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">4] Daniel. J. Bernstein. ChaCha, a variant of Salsa20. http://cr.yp.to/papers.html#chacha, 2008. Document ID: 4027b5256e17b9796842e6d0f68b0b5e.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[5] Daniel J. Bernstein. The Salsa20 family of stream ciphers. In Matthew Robshaw and Olivier Billet, editors, New Stream Cipher Designs, volume 4986 of Lecture Notes in Computer Science, pages 84–97. Springer Berlin Heidelberg, 2008.</li>

      <li>[6] Jürgen Bierbrauer, Thomas Johansson, Gregory Kabatianskii, and Ben Smeets. On Families of Hash Functions via Geometric Codes and Concatenation. In Douglas R. Stinson, editor, Advances in Cryptology CRYPTO 93, volume 773 of Lecture Notes in Computer Science, pages 331–342. Springer Berlin Heidelberg, 1994.</li>

      <li>[7] J. Lawrence Carter and Mark N. Wegman. Universal classes of hash functions (extended abstract). In Proceedings of the Ninth Annual ACM Symposium on Theory of Computing, STOC ’77, pages 106–112, New York, NY, USA, 1977. ACM.</li>

      <li>[8] Bert den Boer. A simple and key-economical unconditional authentication scheme. Journal of Computer Security, 2:65–72, 1993.</li>

      <li>[9] Tsukasa Ishiguro. Modified version of latin dances revisited: New analytic results of Salsa20 and ChaCha. Cryptology ePrint Archive, Report 2012/065, 2012. http://eprint.iacr.org/.</li>

      <li>[10] Hugo Krawczyk. LFSR-based hashing and authentication. In Yvo G. Desmedt, editor, Advances in Cryptology CRYPTO 94, volume 839 of Lecture Notes in Computer Science, pages 129–139. Springer Berlin Heidelberg, 1994.</li>

      <li>[11] Y. Nir and A. Langley. ChaCha20 and Poly1305 for IETF protocols. https://datatracker.ietf.org/doc/draft-irtf-cfrg-chacha20-poly1305/, Jul 2014.</li>

      <li>[12] National Institute of Standards and Technology. Announcing request for candidate algorithm nominations for a new cryptographic hash algorithm (SHA3) family. Federal Register, 72(212):62212–62220, Nov 2007. http://csrc.nist.gov/groups/ST/hash/documents/FR_Notice_Nov07.pdf.</li>

      <li>[13] Phillip Rogaway, Mihir Bellare, and John Black. OCB: A block-cipher mode of operation for efficient authenticated encryption. ACM Trans. Inf. Syst. Secur., 6(3):365–403, August 2003.</li>

      <li>[14] Zhenqing Shi, Bin Zhang, Dengguo Feng, and Wenling Wu. Improved key recovery attacks on reduced-round Salsa20 and ChaCha. In Taekyoung Kwon, Mun-Kyu Lee, and Daesung Kwon, editors, Information Security and Cryptology ICISC 2012, volume 7839 of Lecture Notes in Computer Science, pages 337–351. Springer Berlin Heidelberg, 2013.</li>

      <li>[15] D. R. Stinson. On the Connections Between Universal Hashing, Combinatorial Designs and Error-Correcting Codes. Electronic Colloquium on Computational Complexity (ECCC), 2(52), 1995.</li>

      <li>[16] Richard Taylor. Near optimal unconditionally secure authentication. In Alfredo Santis, editor, Advances in Cryptology EUROCRYPT’94, volume 950 of Lecture Notes in Computer Science, pages 244–253. Springer Berlin Heidelberg, 1995.</li>

    </ul>`;
---

<BaseLayout title="A Security Analysis of the Composition of ChaCha20 and Poly1... (2014/613)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/613
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
