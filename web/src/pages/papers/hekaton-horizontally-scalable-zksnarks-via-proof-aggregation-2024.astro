---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/1208';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Hekaton: Horizontally-Scalable zkSNARKs via Proof Aggregation';
const AUTHORS_HTML = 'Michael Rosenberg, Tushar Mopuri, Hossein Hafezi, Ian Miers, Pratyush Mishra';

const CONTENT = `    <p class="text-gray-300">Michael Rosenberg micro@umd.edu UMD Tushar Mopuri tmopuri@upenn.edu UPenn Hossein Hafezi h.hafezi@nyu.edu NYU Ian Miers imiers@umd.edu UMD Pratyush Mishra prat@upenn.edu UPenn</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Zero-knowledge Succinct Non-interactive ARguments of Knowledge (zkSNARKs) allow a prover to convince a verifier of the correct execution of a large computation in private and easily-verifiable manner. These properties make zkSNARKs a powerful tool for adding accountability, scalability, and privacy to numerous systems such as blockchains and verifiable key directories. Unfortunately, existing zkSNARKs are unable to scale to large computations due to time and space complexity requirements for the prover algorithm. As a result, they cannot handle real-world instances of the aforementioned applications.</p>

    <p class="text-gray-300">In this work, we introduce HEKATON, a zkSNARK that overcomes these barriers and can efficiently handle arbitrarily large computations. We construct HEKATON via a new “distribute-and-aggregate” framework that breaks up large computations into small chunks, proves these chunks in parallel in a distributed system, and then aggregates the resulting chunk proofs into a single succinct proof. Underlying this framework is a new technique for efficiently handling data that is shared between chunks that we believe could be of independent interest.</p>

    <p class="text-gray-300">We implement a distributed prover for HEKATON, and evaluate its performance on a compute cluster. Our experiments show that HEKATON achieves strong horizontal scalability (proving time decreases linearly as we increase the number of nodes in the cluster), and is able to prove large computations quickly: it can prove computations of size <span class="math">2^{35}</span> gates in under an hour, which is much faster than prior work.</p>

    <p class="text-gray-300">Finally, we also apply HEKATON to two applications of real-world interest: proofs of batched insertion for a verifiable key directory and proving correctness of RAM computations. In both cases, HEKATON is able to scale to handle realistic workloads with better efficiency than prior work.</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  1 1.1 Our contributions  1 1.2 Related work  3</p>

    <p class="text-gray-300">2  Techniques  6 2.1 Partition-friendly memory checking  6 2.2 Aggregating heterogeneous commit-carrying zkSNARKs  8 2.3 Our aggregation scheme for Mirage  8 2.4 Optimizations  10</p>

    <p class="text-gray-300">3  Preliminaries  11 3.1 Commitment schemes  11 3.2 Commit-carrying zkSNARKs  11 3.3 Aggregation schemes  12</p>

    <p class="text-gray-300">4  Partitioning circuits via memory checking  14 4.1 Notation  14 4.2 Eliminating shared wires with ROM circuits  15 4.3 Reducing partitioned ROM circuits to committable circuits  15</p>

    <p class="text-gray-300">5  Aggregation scheme for Mirage  20 5.1 Background  20 5.2 Proving multiple pairing products simultaneously  22 5.3 Construction  24</p>

    <p class="text-gray-300">6  Divide-and-aggregate zkSNARKs  26 6.1 Construction  26 6.2 Distributed prover workflow  27 6.3 Optimizations  27</p>

    <p class="text-gray-300">7  Implementation  29</p>

    <p class="text-gray-300">8  Evaluation  30 8.1 Experimental setup  30 8.2 Scaling experiments  30 8.3 Application: verifiable key directories  33 8.4 Application: verifiable RAM computation  34</p>

    <p class="text-gray-300">Acknowledgements  36</p>

    <p class="text-gray-300">A  Design choices and cluster architecture  37 B  Additional definitions and lemmas  37 B.1 Zero-finding lemma  38 C  Proof of Theorem 6.1  39 C.1 Completeness  39 C.2 Knowledge soundness  40 C.3 Zero-knowledge  43 C.4 Efficiency  44</p>

    <p class="text-gray-300">References  45</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Zero-knowledge Succinct Non-interactive ARguments of Knowledge (zkSNARKs) are cryptographic proofs that allow a prover to convince a verifier that, given a function <span class="math">F</span> and public input <span class="math">\\mathtt{x}</span>, there is a private witness <span class="math">\\mathtt{w}</span> such that <span class="math">F(\\mathtt{x},\\mathtt{w})=1</span>. zkSNARKs hide all information about <span class="math">\\mathtt{w}</span>, and are small and easy to verify regardless of the complexity of <span class="math">F</span>. Recent efficient constructions of zkSNARKs <em>[x13, x15, x16, x14, x12]</em> have enabled a range of applications and industrial deployments that rely on zkSNARKs to improve efficiency and privacy characteristics. However, zkSNARKs cannot currently scale to prove useful computations on realistic problem sizes. Indeed, many proposed applications of zkSNARKs, such as verifiable key transparency <em>[x27]</em>, proofs of program execution or vulnerability <em>[x5, x32]</em>, or machine learning inference <em>[x21]</em>, are limited to toy problem sizes due to zkSNARK scalability limitations.</p>

    <p class="text-gray-300">In more detail, in typical zkSNARKs, to prove the correctness of a computation <span class="math">F</span> on inputs <span class="math">(\\mathtt{x},\\mathtt{w})</span>, we must first express <span class="math">F</span> as an arithmetic circuit <span class="math">C_{F}</span>. The size of the latter is often much larger than the description of <span class="math">F</span>, leading to two scalability issues:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Poor parallelization: zkSNARK provers perform a number of expensive operations whose cost grows linearly with the circuit size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. Unfortunately, these operations have diminishing parallelizability, particularly for real implementations that must account for inter-process communication costs between cores, processors, and even compute clusters.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">These problems are not merely asymptotic, but lead to high concrete costs even for relatively simple computations. For instance, a circuit for proving the multiplication of two <span class="math">700\\times 700</span> matrices requires 685 million gates. Prior work <em>[x34]</em> reports that using even a 64-threaded machine to prove this circuit requires hundreds of minutes and a prohibitive 1.7TB of RAM.</p>

    <p class="text-gray-300">Moreover, these problems are exacerbated for many exciting SNARKs applications which, frequently, are RAM Programs (e.g., proofs of vulnerability, zkRollups, etc.). This poses two challenges. First, representing a RAM program as a bare circuit requires all branches be taken and loops be unrolled, drastically increasing circuit size. Second, circuits do not, natively, provide memory access and the methods for providing memory either offer high overhead or, as we will see, place constraints how we can address the space and time complexity.</p>

    <p class="text-gray-300">Distributed proving: a path forward? A promising approach to scale zkSNARKs up to large circuits is to distribute the proving algorithm across a set of workers in a way that ensures that the proof computation is parallelized across the workers, and which ensures that each worker’s local memory requirements are low. In this work, we revisit this approach and design Hekaton, a new horizontally-scalable zkSNARK whose prover algorithm can be distributed over large compute clusters much more efficiently than all prior work <em>[x34, x30, x21]</em>. We detail the technical contributions underlying Hekaton next.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Our contributions</h3>

    <p class="text-gray-300">Hekaton is the result of several contributions:</p>

    <p class="text-gray-300">(1) Scalable proving via divide-and-aggregate. We distill a generic framework for constructing scalable zkSNARKs that we call divide-and-aggregate, or DNA for short. Our framework proceeds as follows:</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> (a) Unpartitioned circuit  <span class="math">C</span></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (b) Partitioning  <span class="math">C</span>  into 3 subcircuits.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> (c) Replacing shared wires with memory accesses. Figure 1: Partitioning circuits for use with our divide-and-aggregate zkSNARK.</p>

    <p class="text-gray-300">to prove the execution of a function  <span class="math">F</span>  represented as a circuit  <span class="math">C_F</span> , partition  <span class="math">C_F</span>  into smaller subcircuits  <span class="math">C_1, \\ldots, C_n</span> , and have each cluster machine use a simpler "inner" zkSNARK to prove the satisfaction of an individual subcircuit separately. Then, invoke a proof aggregation protocol [BMMTV21; GMN22; ABST23] to relatively cheaply aggregate these subcircuit proofs into a single succinctly-verifiable proof.</p>

    <p class="text-gray-300">Instantiating the foregoing blueprint requires addressing two challenges: aggregating proofs for different subcircuits, and sharing wires between subcircuits.</p>

    <p class="text-gray-300">(2) Multi-circuit aggregation. We generalize prior proof aggregation schemes [BMMTV21; GMN22] to efficiently aggregate proofs for different circuits. This allows our framework to handle computations with arbitrary subcircuit structure. In contrast, schemes implicit in prior work [BMMTV21] are only able to handle uniform circuits that just repeat the same subcircuit many times. (3) Shared wires via efficient global memory. All known aggregation schemes (including ours) are only able to achieve succinct verification when proofs for neighbouring subcircuits share a small constant amount of data. However, this is incompatible with our goal of designing a proof system for arbitrary circuits where subcircuits might share many wires.</p>

    <p class="text-gray-300">We overcome this challenge via a new low-overhead technique for providing subcircuits with efficient access to a global memory bank. This allows subcircuits to share wire values by accessing them from the memory bank, rather than directly passing them between subcircuits. To efficiently prove correctness of memory accesses, we design a new memory-checking circuit that can itself be partitioned into subcircuits that share just a constant number of wires. The resulting workflow is illustrated in Fig. 1.</p>

    <p class="text-gray-300">On a technical level, our approach extends recent work on permutation-based memory checking techniques [ZGKPP18; BCGJM18] that uses commit-carrying SNARKs by extending our aggregation scheme into one that supports a commit-carrying mode.</p>

    <p class="text-gray-300">(4) Efficient instantiation and implementation. We instantiate our DNA zkSNARK blueprint by choosing Mirage [KPPS20] as the inner zkSNARK, and designing a new "commit-carrying" aggregation scheme for Mirage. We call the resulting system HEKATON.</p>

    <p class="text-gray-300">We implement HEKATON in a Rust library that supports distributed proving. Our implementation also provides a novel framework for writing partitioned circuits that enables us to minimize communication (in distributed mode) and memory requirements (in both modes). We provide details in Section 7.</p>

    <p class="text-gray-300">(5) Applications and evaluation. As noted above, our evaluation of HEKATON demonstrates that it can prove computations that are orders-of-magnitude larger than prior work, while requiring a fraction of the time. We provide details in Section 8. To showcase the improvements HEKATON offers over state of the art provers, we implement two real world applications. In the first application, we use HEKATON to prove the correctness of batched updates to a Verifiable Key Directory [TFZBT22], whose configuration, for the first time, matches that of deployed systems, i.e., using a sparse Merkle Tree and SHA256 as a hash function. In the second application, we adapt our memory-checking techniques to build a proof for RAM execution that achieves a throughput of  <span class="math">50\\mathrm{kHz}</span> . Our system is able to prove a large execution trace of  <span class="math">2^{25}</span>  instructions via a circuit of  <span class="math">2^{35}</span>  constraints.</p>

    <p class="text-gray-300">Lookup tables. Our global memory technique is reminiscent of recent work on lookup arguments [GW20; ZBKMNS22]. Indeed, one could consider constructing a large lookup table containing the shared wire values. However, a key difference is that most lookup arguments assume that the commitment to the table is constructed honestly in an offline phase (often over public values), and hence optimize their proving algorithm for this regime. In our setting, the "table" is for secret wire values unique to the witness and therefore must be constructed online during the proving phase by the untrusted prover. To use a lookup argument, we would first need to check that the table commitment was generated honestly, and would need to design a proving algorithm optimized for this regime.</p>

    <p class="text-gray-300">Partitioning circuits. Assuming sufficient resources, HEKATON's latency is determined by the size of the largest subcircuit and the number of shared wires between subcircuits. Because handling shared wires costs only 13 constraints per wire, in practice partitioning the circuit into equal-sized subcircuits leads to good performance, because these circuits that arise in practice tend to be partitionable in a manner that results in a small number of shared wires. We leave the problem of optimal circuit partitioning to future work, but note that HEKATON is compatible with prior automatic circuit partitioning schemes [Cos+15; San+23].</p>

    <p class="text-gray-300">Like HEKATON, all prior works on distributed zkSNARKs use a coordinator which gets as input the circuit  <span class="math">C</span> , the public input  <span class="math">x</span> , and the witness  <span class="math">w</span> , and is responsible for distributing these to the worker nodes, who in turn jointly compute the zkSNARK proof. Existing protocols differ in how these workers perform the latter computation. We provide an asymptotic comparison between the above systems in Table 1, and focus below on qualitative differences.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">system</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">supported computation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">proof size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">per-worker time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">total comm.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SRS size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DIZK [WZCPS18]</td>

            <td class="px-3 py-2 border-b border-gray-700">arbitrary</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">/n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DeVirgo [Xie+22]</td>

            <td class="px-3 py-2 border-b border-gray-700">data-parallel</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">/n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pianist [LXZSZ24]</td>

            <td class="px-3 py-2 border-b border-gray-700">arbitrary</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HEKATON</td>

            <td class="px-3 py-2 border-b border-gray-700">arbitrary</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n+k</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Comparison of distributed zkSNARKs. Here  <span class="math">C</span>  is the circuit being proved,  <span class="math">n</span>  is the number of subcircuits,  <span class="math">k</span>  is the number of unique subcircuits, and  <span class="math">B</span>  is the largest unique subcircuit.</p>

    <p class="text-gray-300">DIZK [WZCPS18] initiated the study of distributed algorithms for zkSNARK provers, focusing on the zkSNARK in [Gro16] (though the techniques are applicable to other proof systems as well). In more detail,</p>

    <p class="text-gray-300">the core contributions of DIZK are the design and implementation of efficient distributed algorithms for the core operations performed in zkSNARK provers, namely FFTs and multi-scalar multiplications. The primary drawback of DIZK is its need for a <em>linear</em> amount of inter-worker communication. In practice, this greatly increases the latency of proving: the per-gate cost is <span class="math">10\\times</span> worse than local proving. In contrast, Hekaton requires only <em>constant</em> inter-worker communication, and is able to achieve per-gate costs that are very similar to local proving.</p>

    <p class="text-gray-300">DeVirgo <em>[x21]</em> is a SNARK with a distributed prover that focuses on supporting only <em>data-parallel</em> computations, i.e., the circuit being proved consists of repeated copies of a single subcircuit. DeVirgo’s prover requires the primary node to perform cryptographic work that scales with the size of the subcircuit, and requires linear inter-worker communication. In contrast, as noted above, Hekaton supports arbitrary computations, requires only constant inter-worker communication, and ensures that the cryptographic work performed by the primary node scales only with the number of workers.</p>

    <p class="text-gray-300">Pianist <em>[x14]</em> is a very recent work that designs a distributed proving algorithm for the Plonk zkSNARK <em>[x10]</em>. At a high level, Pianist relies on the elegant observation that using <em>bivariate</em> polynomial commitments allows one to decompose Plonk’s global permutation check, which is used for circuit wiring correctness, into local per-worker permutation checks. The resulting protocol, produces constant proof size and verifier time, whereas the latter costs scale logarithmically for Hekaton.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">However, Pianist, as instantiated, requires an SRS whose size scales linearly with circuit size. To be precise, the SRS for the bivariate polynomial commitment in Pianist depends on the degree of the variables. The degree of the first variable corresponds to subcircuit size, and that of the other to the number of workers. As a result, Pianist’s SRS size is $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. In contrast, because Hekaton’s SRS consists of the SRS(es) for subcircuits and a small SRS for aggregation, its SRS size is dominated by the number of unique subcircuits. For many circuits of interest (e.g., RAM programs), the number and size of the unique subcircuits is much smaller than the total circuit size, leading to substantial SRS size savings for Hekaton. We provide a thorough experimental comparison of Hekaton and Pianist in Section 8.2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Mangrove <em>[x16]</em> is a concurrent theoretical work that uses similar commit-and-prove-based permutation-checking techniques as us. Unlike us, however, Mangrove only reports estimated performance numbers, and does not provide a full implementation or evaluation. Furthermore, applying Mangrove’s techniques to distributed proving would lead to a prover that requires linear inter-worker communication.</p>

    <p class="text-gray-300">Distributed proving based via recursive proofs. A promising idea for distributed proving is to use recursive verification, where the system uses recursive proofs to aggregate subcircuit proofs. The idea would be to replace the custom aggregation scheme in Hekaton with a system that verifies batches of subcircuit proofs recursively in a tree-like manner. However, this approach has several drawbacks.</p>

    <p class="text-gray-300">First, even assuming state-of-the-art folding-based techniques <em>[x3, x11]</em> that have reduced the cost of recursive verification, a back-of-the-envelope calculation shows that such an approach would have over <span class="math">2\\times</span>-worse aggregation time than Hekaton. This is even when we assume that the aggregation step is <em>also</em> distributed; without this assumption, the recursive verification approach would have much worse aggregation time.</p>

    <p class="text-gray-300">Second, even a state-of-the-art recursive aggregation scheme, would still need to support shared wires between subcircuits, and as discussed in Section 2.1.1, existing approaches for this would incur much higher overhead than Hekaton. Adapting the memory-checking techniques in Hekaton to a recursive verification setting is a non-trivial research problem, and indeed formed a key component of concurrent work <em>[x16]</em>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Finally, scalable implementation of these approaches would be challenging due to the need for complex multi-round communication and straggler management.</p>

    <p class="text-gray-300">2 Techniques</p>

    <p class="text-gray-300">We construct our divide-and-aggregate zkSNARK via the blueprint outlined in Section 1.1, which we recall next. To prove a circuit <span class="math">C</span>, (a) partition <span class="math">C</span> into subcircuits <span class="math">(C_{1},\\ldots,C_{n})</span>, (b) replace shared wires with accesses to a global memory, (c) construct augmented subcircuits <span class="math">(C^{\\prime}_{1},\\ldots,C^{\\prime}_{n})</span> that additionally check memory accesses, (d) prove each <span class="math">C^{\\prime}_{i}</span> using via an inner zkSNARK (denoted <span class="math">\\mathsf{ARG}</span>), and (e) aggregate the resulting proofs using an aggregation scheme for <span class="math">\\mathsf{ARG}</span> proofs (denoted <span class="math">\\mathsf{Agg}</span>).</p>

    <p class="text-gray-300">In the rest of this section, we will expand on each of these steps, focusing on our novel memory checker (Section 2.1) and our new commit-carrying aggregation scheme (Section 2.2) that supports this memory checker.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.1 Partition-friendly memory checking</h3>

    <p class="text-gray-300">To check the consistency of these memory accesses, one can design a “memory-checker” circuit <span class="math">M</span> using standard memory checking techniques <em>[x1]</em>. However, integrating this into our blueprint requires that the memory checker <span class="math">M</span> can be partitioned into <span class="math">n</span> subcircuits <span class="math">M_{1},\\ldots,M_{n}</span>, such that (a) <span class="math">M_{i}</span> checks the memory accesses made by <span class="math">C_{i}</span>, and (b) <span class="math">M_{i}</span> and <span class="math">M_{i+1}</span> share just a constant number of wires. Given such an <span class="math">M</span>, we can obtain a DNA zkSNARK for arbitrary circuits by invoking our blueprint on <em>augmented</em> subcircuits <span class="math">C^{\\prime}_{i}</span> that invoke <span class="math">C_{i}</span> and <span class="math">M_{i}</span> together. Let us thus focus on constructing such a partitioning-friendly memory checker.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">2.1.1 Limitations of existing memory checkers</h4>

    <h5 id="sec-9" class="text-base font-semibold mt-4">Attempt 1: Online memory checkers.</h5>

    <p class="text-gray-300">In <em>online memory checking</em> <em>[x1]</em>, memory is committed to via a Merkle tree and read/write operations consist of checking/updating the Merkle path for that location. This requires sharing only a single wire value (the Merkle root) between subcircuits, and is used in all prior divide-and-aggregate SNARKs <em>[x1, x12]</em>. However, online memory checking creates both asymptotic and concrete bottlenecks.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Asymptotically, Merkle path checking imposes a logarithmic overhead: if <span class="math">s_{i}</span> is the number of shared wires in the <span class="math">i</span>-th subcircuit <span class="math">C_{i}</span>, then checking <span class="math">C_{i}</span>’s memory accesses requires <span class="math">s_{i}\\cdot O(\\log s)</span> hash function invocations, where <span class="math">s=\\sum_{i}s_{i}</span> is the size of the global memory. Since in the worst case the number of shared wires can be as large as the circuit size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, the size of the memory checker subcircuit </span>M_{i}<span class="math">, and hence that of the augmented subcircuit </span>C^{\\prime}_{i}<span class="math">, can be as large as </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Concretely, even with zkSNARK-friendly <em>[x1, x11]</em> hash functions that require </span>\\sim 300<span class="math"> gates, each memory access costs </span>300\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ gates, which results in unacceptable slowdowns in practice.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-10" class="text-base font-semibold mt-4">Attempt 2: Memory trace checkers.</h5>

    <p class="text-gray-300">A second approach <em>[x2]</em> verifies memory operations by recording them in a <em>memory trace</em>, and performing cheap checks on the trace entries. In more detail, a memory trace logs each memory operation as <span class="math">(\\texttt{subcircuit-number},\\texttt{op}=\\texttt{read}/\\texttt{write},\\texttt{addr},\\texttt{value})</span>. The checker then considers two versions of this trace: one sorted by address (denoted <span class="math">\\bm{A}</span>), and another sorted by subcircuit number (denoted <span class="math">\\bm{T}</span>), and performs both local and global checks on these traces. As we will show later, the local checks are easily partitioned across subcircuits, but the global check requires verifying that the two traces contain the same entries, and are hence permutations of each other. Efficiently implementing this “permutation check” in a manner amenable to partitioning is a challenge, as we explain next.</p>

    <h5 id="sec-11" class="text-base font-semibold mt-4">Permutation checking.</h5>

    <p class="text-gray-300">State-of-the-art permutation checking techniques <em>[x27, x1, x10]</em> require the optimal <span class="math">O(s)</span> gates to check permutations between <span class="math">s</span>-sized traces. They achieve this low cost by relying on randomized Reed–Solomon fingerprinting <em>[x16, x17]</em>, which performs the following randomized check to ensure that two traces <span class="math">\\bm{T}:=(t_{1},\\ldots,t_{s})</span> and <span class="math">\\bm{A}:=(a_{1},\\ldots,a_{s})</span> are permutations:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>construct trace polynomials <span class="math">T(X):=\\prod_{i=1}^{s}(X-t_{i})</span> and <span class="math">A(X):=\\prod_{i=1}^{s}(X-a_{i})</span>;</li>

      <li>sample a random field element <span class="math">r\\leftarrow\\mathbb{F}</span>; and</li>

      <li>check that <span class="math">T(r)=A(r)</span>.</li>

    </ol>

    <p class="text-gray-300">This check can be realized quite efficiently via a circuit that witnesses <span class="math">\\bm{T}</span>, <span class="math">\\bm{A}</span>, and <span class="math">r</span>, computes the products <span class="math">\\prod_{i=1}^{s}(r-t_{i})</span> and <span class="math">\\prod_{i=1}^{s}(r-a_{i})</span>, and checks that these are equal. We now show that this computation can also be partitioned easily across subcircuits in a way that ensures that each subcircuit only pays for the accesses it makes to the memory.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">2.1.2 Partitioning polynomial evaluation</h4>

    <p class="text-gray-300">Our partitioning strategy relies on the simple but crucial observation that the trace polynomials can be evaluated incrementally. In more detail, notice that for every <span class="math">j\\in[s]</span>, if we are given the running products <span class="math">\\tau:=\\prod_{i=1}^{j}(r-t_{i})</span> and <span class="math">\\alpha:=\\prod_{i=1}^{j}(r-a_{i})</span>, and the <span class="math">j+1</span>-th trace entries <span class="math">t_{j+1}</span> and <span class="math">a_{j+1}</span>, we can easily compute the next running products <span class="math">\\tau^{\\prime}:=\\tau\\cdot(r-t_{j+1})</span> and <span class="math">\\alpha^{\\prime}:=\\alpha\\cdot(r-a_{j+1})</span>. We can then iterate this process to eventually compute <span class="math">T(r)</span> and <span class="math">A(r)</span>. We leverage this observation to construct memory-checking subcircuits <span class="math">M_{1},\\ldots,M_{n}</span> as follows.</p>

    <h5 id="sec-13" class="text-base font-semibold mt-4">Notation.</h5>

    <p class="text-gray-300">Denote by <span class="math">s_{i}</span> the number of memory accesses in the <span class="math">i</span>-th subcircuit <span class="math">C_{i}</span>, by <span class="math">k_{i}=\\sum_{j=1}^{i-1}s_{j}</span> the total number of accesses in the previous subcircuits <span class="math">C_{1},\\ldots,C_{i-1}</span>, and finally by <span class="math">\\mathcal{S}_{i}</span> the set <span class="math">\\{k_{i}+1,\\ldots,k_{i}+s_{i}\\}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\bm{T}=(t_{1},\\ldots,t_{s})</span> and <span class="math">\\bm{A}=(a_{1},\\ldots,a_{s})</span> be the memory traces as defined in Section 2.1.1. We split these traces up into <span class="math">n</span> subtraces, one for each subcircuit, as follows. The <span class="math">i</span>-th subtrace of <span class="math">\\bm{T}</span> is defined to contain those entries access by <span class="math">C_{i}</span>, i.e., <span class="math">\\bm{T}_{i}:=\\{t_{j}\\mid\\ j\\in\\mathcal{S}_{i}\\}</span>. The <span class="math">i</span>-th subtrace of <span class="math">\\bm{A}</span> is defined analogously as <span class="math">\\bm{A}_{i}:=\\{a_{j}\\mid\\ j\\in\\mathcal{S}_{i}\\}</span>. Finally, denote by <span class="math">\\tau_{i}</span> and <span class="math">\\alpha_{i}</span> the running products up to (but excluding) the <span class="math">i</span>-th subcircuit, i.e., <span class="math">\\tau_{i}:=\\prod_{j\\in[k_{i}]}(r-t_{j})</span> and <span class="math">\\alpha_{i}:=\\prod_{j\\in[k_{i}]}(r-a_{j})</span>.</p>

    <h5 id="sec-14" class="text-base font-semibold mt-4">Construction.</h5>

    <p class="text-gray-300">We are now ready to describe how our construction of the memory-checking subcircuits <span class="math">M_{i}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">M_{i}</span> receives as public input the random challenge <span class="math">r</span>, the last entries <span class="math">t</span> and <span class="math">a</span> of <span class="math">\\bm{T}_{i-1}</span> and <span class="math">\\bm{A}_{i-1}</span> respectively, as well as the running products <span class="math">\\tau_{i}</span> and <span class="math">\\alpha_{i}</span>.</li>

      <li>The public output of <span class="math">M_{i}^{\\prime}</span> consists of the last entries <span class="math">t^{\\prime}</span> and <span class="math">a^{\\prime}</span> of <span class="math">\\bm{T}_{i}</span> and <span class="math">\\bm{A}_{i}</span> respectively, as well as the updated running evaluations <span class="math">\\tau_{i+1}</span> and <span class="math">\\alpha_{i+1}</span>.</li>

      <li><span class="math">M_{i}</span> receives as additional witness the subtraces <span class="math">\\bm{T}_{i}</span> and <span class="math">\\bm{A}_{i}</span>.</li>

      <li><span class="math">M_{i}</span> performs the following computations:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">M_{i}</span> replaces each memory gate with with a ‘read’ from the value in the corresponding entry in <span class="math">\\bm{T}_{i}</span>.</li>

      <li><span class="math">M_{i}</span> checks that entries in <span class="math">\\bm{T}_{i}</span> all have the subcircuit number set to <span class="math">i</span>, and that <span class="math">\\bm{A}_{i}</span> is sorted by address.</li>

      <li><span class="math">M_{i}</span> checks that consecutive entries in <span class="math">\\bm{A}_{i}</span> are consistent: if they have the same address, then they must contain the same value.</li>

      <li><span class="math">M_{i}</span> computes the new running products <span class="math">\\tau_{i+1}:=\\tau_{i}\\cdot\\prod_{j\\in\\mathcal{S}_{i}}(r-t_{j})</span> and <span class="math">\\alpha_{i+1}:=\\alpha_{i}\\cdot\\prod_{j\\in\\mathcal{S}_{i}}(r-a_{j})</span></li>

    </ul>

    <p class="text-gray-300">This approach, illustrated in Fig. 2, achieves the desired performance: the <span class="math">i</span>-th memory-checking circuit processes exactly an <span class="math">s_{i}/s</span>-fraction of the traces in just <span class="math">O(s_{i})</span> gates, as required, and the hidden constants are great: just 13 gates per shared wire. We provide formal details and analyses of this construction in Section 4.2.</p>

    <p class="text-gray-300">We note that our full construction in Section 4.2 incorporates the optimizations mentioned in Section 2.4 to further simplify and reduce the cost of memory-checking.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 2: Memory traces are partitioned across subcircuits.</p>

    <p class="text-gray-300">A question left open by the description of the memory-checker construction in Section 2.1 is that of how to derive the challenge  <span class="math">r</span>  for the trace polynomial evaluation. An approach taken by prior work [ZGKPP18; KPPS20] is to derive the random challenge  <span class="math">r</span>  by hashing (via a random oracle  <span class="math">\\rho</span> ) commitments to the traces. This requires the SNARK proof for each subcircuit to additionally ensure that the witnessed traces are consistent with their claimed commitments. Prior work achieves this consistency check efficiently by using special commit-carrying zkSNARKs (cc-zkSNARK) [CFQ19] where the commitment scheme is co-designed with the SNARK so that the contents of the commitment are "natively" available as witnesses in the proven circuit.</p>

    <p class="text-gray-300">We briefly recall their high-level strategy here, and then explain why it does not work in our setting. First, the prover commits to the traces, obtaining commitments tcm and acm; then, it derives the challenge  <span class="math">r \\coloneqq \\rho(\\text{tcm}, \\text{acm})</span> ; and finally, it invokes the zkSNARK's proving algorithm on the augmented subcircuits  <span class="math">C_i&#x27;</span>  to prove that the committed traces are valid memory traces. Unfortunately, the natural extension to our setting where the prover derives the challenge  <span class="math">r</span>  by hashing the individual subcircuit commitments fails to meet our goals because the proof is no longer succinct.</p>

    <p class="text-gray-300">Our approach: commit-carrying aggregation schemes. We resolve this issue by defining a new notion of commit-carrying aggregation schemes that support aggregating not only the proofs the underlying inner cc-zkSNARK, but also their commitments. Our notion also naturally supports multi-circuit aggregation that allows the prover to aggregate proofs for multiple circuits into a single combined proof.</p>

    <p class="text-gray-300">With this new tool in hand, we can augment our blueprint construction as follows. Given an inner cc-zkSNARK ARG and a commit-carrying aggregation scheme Agg for ARG, to prove a partitioned circuit  <span class="math">C = (C_1, \\ldots, C_n)</span> ,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>construct augmented subcircuits  <span class="math">(C_1&#x27;,\\ldots ,C_n&#x27;)</span>  and memory substraces  <span class="math">(T_{1},\\dots,T_{n})</span>  and  <span class="math">(A_{1},\\dots,A_{n})</span></li>

      <li>compute trace commitments  <span class="math">(\\mathsf{tcm}_1,\\dots ,\\mathsf{tcm}_n)</span>  and  <span class="math">(\\mathsf{acm}_1,\\dots ,\\mathsf{acm}_n)</span>  using ARG's commitment scheme;</li>

      <li>aggregate these with Agg to obtain succinct commitments (tcm, acm), and derive  <span class="math">r \\coloneqq \\rho(\\text{tcm}, \\text{acm})</span> ;</li>

      <li>prove each circuit  <span class="math">C_i&#x27;</span>  with ARG and aggregate the resulting inner proofs with Agg.</li>

    </ol>

    <p class="text-gray-300">This approach achieves succinctness while preserving soundness. We provide details of our construction in Section 6.</p>

    <p class="text-gray-300">To instantiate the foregoing blueprint, we choose the Mirage cc-zkSNARK [KPPS20] as our inner zkSNARK. Mirage is a commit-carrying variant of the Groth16 zkSNARK [Gro16], and inherits the succinctness and prover efficiency of the latter. In more detail, a Mirage proof, like a Groth16 one, consists of three group elements  <span class="math">(A,B,C)</span> , while the commitment is another group element  <span class="math">D</span> . The verifying key, like that of Groth16,</p>

    <p class="text-gray-300">contains elements <span class="math">\\alpha\\in\\mathbb{G}_{1}</span> and <span class="math">\\beta,\\delta,\\in\\mathbb{G}_{2}</span>, as well as an extra element <span class="math">\\eta\\in\\mathbb{G}_{2}</span>. To check a proof <span class="math">\\bm{\\pi}=(A,B,C)</span> with respect to a commitment <span class="math">D</span>, the verifier checks that the following pairing equation is satisfied.</p>

    <p class="text-gray-300"><span class="math">e(A,B)=e(\\alpha,\\beta)e(C,\\delta)e(D,\\eta)\\quad.</span></p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Background for Mirage.</h4>

    <p class="text-gray-300">To construct an aggregation scheme for Mirage, we follow existing work on aggregation schemes for Groth16 <em>[BMMTV21, GMN22]</em> by relying on <em>inner-pairing product</em> argument systems <em>[BMMTV21]</em>. The latter generalize inner-product argument systems <em>[BCCGP16, BBBPWM18]</em> to enable proving more general bilinear products. Two variants are relevant for our purposes: “MIPPs”, which prove the inner product <span class="math">\\sum_{i}a_{i}\\cdot B_{i}</span> for (committed) vectors <span class="math">\\bm{a}\\in\\mathbb{F}^{n},\\bm{B}\\in\\mathbb{G}^{n}</span>, and “TIPPs”, which prove the pairing product <span class="math">\\prod_{i}e(r^{i}\\cdot A_{i},B_{i})</span> for a scalar <span class="math">r</span> and (committed) vectors <span class="math">\\bm{A}\\in\\mathbb{G}_{1}^{n},\\bm{B}\\in\\mathbb{G}_{2}^{n}</span>.</p>

    <p class="text-gray-300">To construct an aggregation scheme for Mirage that proves the correctness of a batch of Mirage proofs <span class="math">(\\bm{A},\\bm{B},\\bm{C})</span> with respect to commitments <span class="math">\\bm{D}</span>, we will use the above ingredients to prove the following randomized pairing check with respect to a random challenge <span class="math">r</span>:</p>

    <p class="text-gray-300"><span class="math">\\prod_{i}e(r^{i}\\cdot A_{i},B_{i})=e(\\alpha,\\beta)^{\\sum r^{i}}\\prod_{i}e(r^{i}\\cdot C_{i},\\delta)\\prod_{i}e(r^{i}\\cdot D_{i},\\eta)\\quad.</span></p>

    <p class="text-gray-300">To aggregate these proofs, the aggregation prover first commits to the <span class="math">\\bm{A},\\bm{B},\\bm{C},\\bm{D}</span> using a “structure-preserving” commitment scheme <em>[AFGHO16]</em>, hashes these to obtain <span class="math">r</span>, and then proves the above equation using MIPPs and TIPPs. Clearly, the left hand side can be proven using a TIPP, while the remaining terms can be proven using MIPPs. Unfortunately, we are not done yet, as our setting requires us to aggregate proofs for multiple circuits simultaneously.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Multi-circuit aggregation.</h4>

    <p class="text-gray-300">When aggregating multiple circuits, the <span class="math">\\delta</span> and <span class="math">\\eta</span> components of the verifying key differ across circuits, meaning our randomized check changes to the following:</p>

    <p class="text-gray-300"><span class="math">\\prod_{i}e(r^{i}\\cdot A_{i},B_{i})=e(\\alpha,\\beta)^{\\sum r^{i}}\\prod_{i}e(r^{i}\\cdot C_{i},\\delta_{i})\\prod_{i}e(r^{i}\\cdot D_{i},\\eta_{i})\\quad.</span></p>

    <p class="text-gray-300">While all the pairing checks can now be proven using TIPPs, preserving succinctness requires care. To see this, let us inspect the two kinds of TIPPs performed in the above equation. Notice that in the TIPP for the left-hand-side check (<span class="math">\\prod_{i}e(r^{i}\\cdot A_{i},B_{i})</span>), both arguments are prover-supplied, and hence it is fine for the prover to provide commitments to <span class="math">\\bm{A}</span> and <span class="math">\\bm{B}</span>. The TIPPs on the right-hand side, however, involve one prover-supplied argument (<span class="math">\\bm{C}</span> and <span class="math">\\bm{D}</span>) and one verifier-supplied argument (<span class="math">\\bm{\\delta}</span> and <span class="math">\\bm{\\eta}</span>). While the prover can provide commitments to <span class="math">\\bm{C}</span> and <span class="math">\\bm{D}</span>, it would be <em>unsound</em> for it to do the same for <span class="math">\\bm{\\delta}</span> and <span class="math">\\bm{\\eta}</span>, as it could commit to arbitrary elements that cause the checks to pass.</p>

    <p class="text-gray-300">Therefore, the verifier must obtain these commitments itself. The straightforward solution of having the verifier compute them itself would violate succinctness. To resolve this issue, we leverage the fact that the subcircuit structure is known at setup time, which in turn means that the vectors <span class="math">\\bm{\\delta}</span> and <span class="math">\\bm{\\eta}</span> are also known at setup time. This means that commitments to the latter can be computed then and included in the verifying key, thus preserving succinctness.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Reducing the number of TIPPs.</h4>

    <p class="text-gray-300">The aggregation scheme proposed so far is sound and relatively efficient. However, it requires the prover to prove multiple TIPPs, worsening prover complexity and proof size. Because aggregation is performed on a single machine (and is not parallelized), improving its prover complexity is important. We do so by devising a method for batching multiple TIPP instances together into a single TIPP instance, and providing a single TIPP proof for the latter.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Our aggregation scheme for Mirage.</h4>

    <p class="text-gray-300">The sketch above omits details, including how we handle public inputs. We provide these details in Section 5.</p>

    <p class="text-gray-300">2.4 Optimizations</p>

    <p class="text-gray-300">The foregoing discussions omit a number of optimizations that we developed to improve the efficiency of our construction. We describe these next.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">Read-only memory.</h4>

    <p class="text-gray-300">Notice that we can assume that the memory is read-only, as the prover can initialize the memory with values of all the shared wires, and subcircuits which access these wires can simply check that the memory contains the correct value. This optimization greatly reduces the concrete cost of the local checks performed on the memory traces.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">Reducing SRS size.</h4>

    <p class="text-gray-300">The description in the foregoing sections obscures the fact that, as described, each augmented subcircuit <span class="math">C_{i}^{\\prime}</span> is unique, even if the topology of the underlying subcircuit <span class="math">C_{i}</span> is shared with other subcircuits. This is because we need to embed into <span class="math">C_{i}^{\\prime}</span> information about (a) its circuit number <span class="math">i</span> (so that it can check the trace entries correspond to its own memory access), and (b) the addresses it reads from (so that it reads the appropriate shared wires). Because of this, each subcircuit becomes unique, leading to a blowup in SRS size when we instantiate Hekaton with the Mirage cc-zkSNARK <em>[x10]</em> as the latter has circuit-specific setup (we would need to generate a separate SRS for each subcircuit).</p>

    <p class="text-gray-300">To resolve this issue, we observe that the aforementioned information (circuit number and addresses) is not dependent on the prover’s witness, and can be committed to via Mirage’s commitment scheme in a preprocessing phase. We provide details in Section 6.3.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">Homogenizing public inputs via Merkle trees.</h4>

    <p class="text-gray-300">Recall from Section 2.1.2 that each memory-checking subcircuit <span class="math">M_{i}</span> receives as public input the triple <span class="math">\\mathsf{in}_{i}=(r,(t,a),(\\tau_{k_{i}},\\alpha_{k_{i}}))</span>, and outputs the pair <span class="math">\\mathsf{out}_{i}=((t^{\\prime},a^{\\prime}),(\\tau_{k_{i+1}},\\alpha_{k_{i+1}}))</span>. This means that each <span class="math">M_{i}</span>’s public input is necessarily different. Existing constructions of aggregation schemes <em>[x3]</em> can handle such heterogeneous public inputs, but incur prover complexity and proof size overheads. Instead, we propose to homogenize the public inputs of all the subcircuits by careful and selective use of <em>online</em> memory checking: we commit to <span class="math">(\\mathsf{in}_{i},\\mathsf{out}_{i})</span> in the <span class="math">i</span>-th leaf of a Merkle tree, and use the corresponding path to verifiably access the <span class="math">i</span>-th leaf in the <span class="math">i</span>-th subcircuit. This allows us to eschew the complex public input handling mechanisms of prior aggregation schemes.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">Batch setup optimization.</h4>

    <p class="text-gray-300">We perform a common setup for all circuits simultaneously. This helps us improve efficiency by reducing the number of TIPPs by 1.</p>

    <p class="text-gray-300">3 Preliminaries</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Indexed relations.</h4>

    <p class="text-gray-300">An <em>indexed relation</em> <span class="math">\\mathcal{R}</span> is a set of triples <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w})</span> where <span class="math">\\dot{\\mathfrak{s}}</span> is the index, <span class="math">\\mathfrak{x}</span> is the instance, and <span class="math">\\mathfrak{w}</span> is the witness; the corresponding <em>indexed language</em> <span class="math">\\mathcal{L}(\\mathcal{R})</span> is the set of pairs <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x})</span> for which there exists a witness <span class="math">\\mathfrak{w}</span> such that <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w})\\in\\mathcal{R}</span>. An indexed relation is said to be <em>committable</em> if the witness can be split into two parts, <span class="math">\\mathfrak{w}=(\\mathfrak{w}_{1},\\mathfrak{w}_{2})</span>.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Definition 3.1 (circuit satisfiability).</h6>

    <p class="text-gray-300">The committable indexed relation <span class="math">\\mathrm{CSAT}</span> is the set of triples <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w})=\\big{(}(\\mathbb{F},\\ell,m,n,C),x,(w_{1},w_{2})\\big{)}</span> where <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">\\ell</span>, <span class="math">m</span>, and <span class="math">n</span> are natural numbers, <span class="math">x\\in\\mathbb{F}^{\\ell}</span>, <span class="math">w_{1}\\in\\mathbb{F}^{m}</span>, and <span class="math">w_{2}\\in\\mathbb{F}^{n}</span> are vectors, and <span class="math">C:\\mathbb{F}^{\\ell+m+n}\\to\\mathbb{F}</span> is an arithmetic circuit over <span class="math">\\mathbb{F}</span> such that <span class="math">C(x,w_{1},w_{2})=0</span>.</p>

    <p class="text-gray-300">To obtain the usual notion of circuit satisfiability we can set <span class="math">m=0</span> and <span class="math">w_{1}=\\bot</span>.</p>

    <p class="text-gray-300">Security parameters. For simplicity of notation, we assume that all public parameters have length at least <span class="math">\\lambda</span>, so that algorithms which receive such parameters can run in time <span class="math">\\mathrm{poly}(\\lambda)</span>.</p>

    <p class="text-gray-300">Random oracles. We denote by <span class="math">\\mathcal{U}(\\lambda)</span> the set of all functions that map <span class="math">\\{0,1\\}^{<em>}</span> to <span class="math">\\{0,1\\}^{\\lambda}</span>. A </em>random oracle<em> with security parameter <span class="math">\\lambda</span> is a function <span class="math">\\rho:\\{0,1\\}^{</em>}\\to\\{0,1\\}^{\\lambda}</span> sampled uniformly at random from <span class="math">\\mathcal{U}(\\lambda)</span>.</p>

    <p class="text-gray-300">Bilinear groups. We denote groups by <span class="math">\\mathbb{G}</span>. A bilinear function <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span> is a <em>type-3 bilinear pairing</em> if there is no efficiently computable group homomorphism from <span class="math">\\mathbb{G}_{2}</span> to <span class="math">\\mathbb{G}_{1}</span>. <span class="math">e</span> is <em>degenerate</em> if there is a non-identity <span class="math">G\\in\\mathbb{G}_{1}</span> such that <span class="math">e(G,H)=1</span> for all <span class="math">H\\in\\mathbb{G}_{2}</span>. We use additive notation for <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>, and multiplicative notation for <span class="math">\\mathbb{G}_{T}</span>. As shorthand we sometimes write <span class="math">[a]_{1}</span> for <span class="math">a\\cdot G</span> and <span class="math">[b]_{2}</span> for <span class="math">b\\cdot H</span>.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">3.1 Commitment schemes</h3>

    <p class="text-gray-300">A commitment scheme <span class="math">\\mathsf{CM}=(\\mathsf{Setup},\\mathsf{Commit})</span> over a universe of message spaces <span class="math">\\{\\mathcal{M}_{i}\\}_{i\\in\\mathbb{N}}</span> enables a party to generate a (perfectly) hiding and (computationally) binding commitment to a given message <span class="math">m\\in\\mathcal{M}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Setup:</em> on input a security parameter and a description of the message space <span class="math">\\mathcal{M}</span>, <span class="math">\\mathsf{CM}.\\mathsf{Setup}</span> samples a commitment key <span class="math">\\mathsf{ck}</span>.</li>

      <li><em>Commitment:</em> on input public parameters <span class="math">\\mathsf{ck}</span>, message <span class="math">m\\in\\mathcal{M}</span>, and randomness <span class="math">r</span>, <span class="math">\\mathsf{CM}.\\mathsf{Commit}</span> outputs a commitment <span class="math">C</span> to <span class="math">m</span>.</li>

    </ul>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">3.2 Commit-carrying zkSNARKs</h3>

    <p class="text-gray-300">A tuple of algorithms <span class="math">\\mathsf{ARG}=(\\mathcal{G},\\mathcal{C},\\mathcal{P},\\mathcal{V})</span> is a commit-carrying succinct non-interactive argument of knowledge (cc-SNARK) <em>[x10]</em> in the random oracle model (ROM) for a committable indexed relation <span class="math">\\mathcal{R}</span> if it satisfies the following syntax and properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Setup.</em> On input a security parameter <span class="math">\\lambda</span> and a set of indices <span class="math">[\\dot{\\mathfrak{s}}_{i}]_{i=1}^{n}</span>, <span class="math">\\mathcal{G}</span> outputs corresponding proving keys <span class="math">[\\mathrm{ipk}_{i}]_{i=1}^{n}</span>, commitment keys <span class="math">[\\mathrm{ick}_{i}]_{i=1}^{n}</span>, and verification keys <span class="math">[\\mathrm{ivk}_{i}]_{i=1}^{n}</span>. When <span class="math">n=1</span>, we omit indices.</li>

      <li><em>Commitment.</em> On input a commitment key <span class="math">\\mathrm{ick}</span>, a message <span class="math">\\mathfrak{w}_{1}</span>, and commitment randomness <span class="math">r</span>, <span class="math">\\mathcal{C}</span> outputs a commitment <span class="math">\\mathsf{cm}</span>.</li>

      <li><em>Proving.</em> On input a proving key <span class="math">\\mathrm{ipk}</span>, an instance <span class="math">\\mathfrak{x}</span>, a witness <span class="math">\\mathfrak{w}=(\\mathfrak{w}_{1},\\mathfrak{w}_{2})</span>, and commitment randomness <span class="math">r</span>, <span class="math">\\mathcal{P}</span> outputs a proof <span class="math">\\pi</span>.</li>

      <li><em>Verifying.</em> On input a verification key <span class="math">\\mathrm{ivk}</span>, an instance <span class="math">\\mathfrak{x}</span>, a commitment <span class="math">\\mathsf{cm}</span>, and a proof <span class="math">\\pi</span>, <span class="math">\\mathcal{V}</span> outputs a bit indicating whether <span class="math">\\pi</span> is a valid proof.</li>

    </ul>

    <p class="text-gray-300">Throughout, we assume without loss of generality that the proving key <span class="math">\\mathrm{ipk}</span> contains <span class="math">\\mathrm{ick}</span>, <span class="math">\\mathrm{ivk}</span> and <span class="math">\\dot{\\mathfrak{s}}</span>. These algorithms must satisfy the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Multi-instance completeness. For every set of indices  <span class="math">[\\dot{\\mathfrak{s}}_i]_{i=1}^n</span>  and every efficient adversary  <span class="math">\\mathcal{A}</span> , the following probability is 1.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} \\forall i \\in [ n ]: &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\left(\\dot {\\mathfrak {s}} _ {i}, \\mathfrak {x} _ {i}, \\mathfrak {w} _ {i}\\right) \\in \\mathcal {R} &amp;amp; \\left([ \\mathrm {i p k} _ {i} ] _ {i = 1} ^ {n}, [ \\mathrm {i c k} _ {i} ] _ {i = 1} ^ {n}, [ \\mathrm {i v k} _ {i} ] _ {i = 1} ^ {n}) \\leftarrow \\mathcal {G} ^ {\\rho} (1 ^ {\\lambda}, [ \\dot {\\mathfrak {s}} _ {i} ] _ {i = 1} ^ {n}) \\\\ \\downarrow &amp;amp; \\left([ \\mathfrak {x} _ {i} ] _ {i = 1} ^ {n}, [ \\mathrm {w} _ {i} ] _ {i = 1} ^ {n}, [ r _ {i} ] _ {i = 1} ^ {n}) \\leftarrow \\mathcal {A} ^ {\\rho} ([ \\mathrm {i p k} _ {i} ] _ {i = 1} ^ {n}) \\\\ \\mathcal {V} ^ {\\rho} (\\mathrm {i v k} _ {i}, \\mathfrak {x} _ {i}, \\mathrm {c m} _ {i}, \\pi_ {i}) = 1\\right) &amp;amp; \\forall i \\in [ n ]: \\mathrm {c m} _ {i} \\leftarrow \\mathcal {C} ^ {\\rho} (\\mathrm {i c k} _ {i}, \\mathrm {w} _ {i, 1}; r _ {i}) \\\\ &amp;amp; \\forall i \\in [ n ]: \\pi_ {i} \\leftarrow \\mathcal {P} ^ {\\rho} (\\mathrm {i p k} _ {i}, \\mathfrak {x} _ {i}, \\mathrm {w} _ {i}; r _ {i}) \\end{array} \\right]</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Multi-instance knowledge soundness. For every efficient adversary  <span class="math">\\tilde{\\mathcal{P}}</span>  and auxiliary input distribution  <span class="math">\\mathcal{D}</span> , there exists an efficient extractor  <span class="math">\\mathcal{E}_{\\tilde{\\mathcal{P}}}</span>  such that for every set of indices  <span class="math">[\\dot{\\mathfrak{s}}_i]_{i=1}^n</span> , the following probability is negligible:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} \\exists i \\in [ n ]: &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\left(\\dot {\\mathfrak {s}} _ {i}, \\mathfrak {x} _ {i}, \\mathfrak {w} _ {i}\\right) \\notin \\mathcal {R} &amp;amp; \\left([ \\mathrm {i p k} _ {i} ] _ {i = 1} ^ {n}, [ \\mathrm {i c k} _ {i} ] _ {i = 1} ^ {n}, [ \\mathrm {i v k} _ {i} ] _ {i = 1} ^ {n}) \\leftarrow \\mathcal {G} ^ {\\rho} (1 ^ {\\lambda}, [ \\dot {\\mathfrak {s}} _ {i} ] _ {i = 1} ^ {n}) \\\\ \\vee &amp;amp; \\left(\\left[ \\mathrm {x} _ {i} \\right] _ {i = 1} ^ {n}, \\left[ \\mathrm {w} _ {i} \\right] _ {i = 1} ^ {n} \\leftarrow \\mathcal {D} ^ {\\rho} (1 ^ {\\lambda}, [ \\mathrm {i p k} _ {i} ] _ {i = 1} ^ {n}) \\\\ \\mathcal {C} ^ {\\rho} (\\mathrm {i p k} _ {i}, \\mathrm {w} _ {i, 1}; r _ {i}) \\neq \\mathrm {c m}\\right) &amp;amp; \\left[ (\\mathrm {w} _ {i}, \\mathrm {c m} _ {i}, \\pi_ {i}) \\right] _ {i = 1} ^ {n} \\leftarrow \\tilde {\\mathcal {P}} ^ {\\rho} ([ \\mathrm {i p k} _ {i} ] _ {i = 1} ^ {n}, \\mathrm {a u x}) \\\\ \\bigvee^ {\\rho} (\\mathrm {i v k} _ {i}, \\mathrm {x} _ {i}, \\mathrm {c m} _ {i}, \\pi_ {i}) = 1 &amp;amp; \\left[ (\\mathrm {w} _ {i}, r _ {i}) \\right] _ {i = 1} ^ {n} \\leftarrow \\mathcal {E} _ {\\tilde {\\mathcal {P}}} ([ \\mathrm {i p k} _ {i} ] _ {i = 1} ^ {n}, \\mathrm {a u x}) \\end{array} \\right]</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Multi-instance zero-knowledge. There exists an efficient simulator  <span class="math">S = (S_{1}, S_{2})</span>  such that for every efficient stateful adversary  <span class="math">\\tilde{\\mathcal{V}} = (\\tilde{\\mathcal{V}}_{1}, \\tilde{\\mathcal{V}}_{2}, \\tilde{\\mathcal{V}}_{3})</span> , the following probabilities are negligibly close:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\forall i \\in [ n ]: &amp;amp; [ \\dot {\\mathfrak {s}} _ {i} ] _ {i = 1} ^ {n} \\leftarrow \\tilde {\\mathcal {V}} _ {1} ^ {\\rho} (1 ^ {\\lambda}) \\\\ (\\dot {\\mathfrak {s}} _ {i}, \\mathfrak {x} _ {i}, \\mathfrak {w} _ {i}) \\in \\mathcal {R} &amp;amp; ([ \\mathrm {i p k} _ {i} ] _ {i = 1} ^ {n}, [ \\mathrm {i c k} _ {i} ] _ {i = 1} ^ {n}, [ \\mathrm {i v k} _ {i} ] _ {i = 1} ^ {n}) \\leftarrow \\mathcal {G} ^ {\\rho} (1 ^ {\\lambda}, [ \\dot {\\mathfrak {s}} _ {i} ] _ {i = 1} ^ {n}) \\\\ \\wedge &amp;amp; ([ \\mathrm {x} _ {i} ] _ {i = 1} ^ {n}, [ \\mathrm {w} _ {i} ] _ {i = 1} ^ {n}) \\leftarrow \\tilde {\\mathcal {V}} _ {2} ^ {\\rho} (1 ^ {\\lambda}, [ \\mathrm {i p k} _ {i} ] _ {i = 1} ^ {n}) \\\\ \\tilde {\\mathcal {V}} _ {3} ^ {\\rho} ([ \\mathrm {i p k} _ {i} ] _ {i = 1} ^ {n}, [ \\mathrm {c m} _ {i} ] _ {i = 1} ^ {n}, [ \\pi_ {i} ] _ {i = 1} ^ {n}, \\mathrm {s t}) = 1 &amp;amp; \\forall i \\in [ n ]: \\mathrm {c m} _ {i} \\leftarrow \\mathcal {C} ^ {\\rho} (\\mathrm {i c k} _ {i}, \\mathrm {w} _ {i, 1}) \\\\ &amp;amp; \\forall i \\in [ n ]: \\pi_ {i} \\leftarrow \\mathcal {P} ^ {\\rho} (\\mathrm {i p k} _ {i}, \\mathrm {x} _ {i}, \\mathrm {w} _ {i}) \\end{array} \\right]</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} \\forall i \\in [ n ]: &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ (\\dot {\\mathfrak {s}} _ {i}, \\mathfrak {x} _ {i}, \\mathfrak {w} _ {i}) \\in \\mathcal {R} &amp;amp; [ \\dot {\\mathfrak {s}} _ {i} ] _ {i = 1} ^ {n} \\leftarrow \\tilde {\\mathcal {V}} _ {1} ^ {\\rho} (1 ^ {\\lambda}) \\\\ \\wedge &amp;amp; ([ \\mathrm {i p k} _ {i} ] _ {i = 1} ^ {n}, \\tau) \\leftarrow \\mathcal {S} _ {1} ^ {\\rho} (1 ^ {\\lambda}, [ \\dot {\\mathfrak {s}} _ {i} ] _ {i = 1} ^ {n}) \\\\ \\tilde {\\mathcal {V}} _ {3} ^ {\\rho [ \\mu ]} ([ \\mathrm {i p k} _ {i} ] _ {i = 1} ^ {n}, [ \\mathrm {c m} _ {i} ] _ {i = 1} ^ {n}, [ \\pi_ {i} ] _ {i = 1} ^ {n}, \\mathrm {s t}) = 1 &amp;amp; ([ \\mathrm {c m} _ {i} ] _ {i = 1} ^ {n}, [ \\mathrm {w} _ {i} ] _ {i = 1} ^ {n}) \\leftarrow \\tilde {\\mathcal {V}} _ {2} ^ {\\rho} (1 ^ {\\lambda}, [ \\mathrm {i p k} _ {i} ] _ {i = 1} ^ {n}) \\\\ &amp;amp; ([ \\mathrm {c m} _ {i} ] _ {i = 1} ^ {n}, [ \\pi_ {i} ] _ {i = 1} ^ {n}, \\mu) \\leftarrow \\mathcal {S} _ {2} ^ {\\rho} ([ \\mathrm {i p k} _ {i} ] _ {i = 1} ^ {n}, [ \\mathrm {x} _ {i} ] _ {i = 1} ^ {n}, \\tau) \\end{array} \\right]</span></div>

    <p class="text-gray-300">In the foregoing,  <span class="math">\\rho[\\mu]</span>  is the function that, on input  <span class="math">x</span> , equals  <span class="math">\\mu(x)</span>  if  <span class="math">\\mu</span>  is defined on  <span class="math">x</span> , or  <span class="math">\\rho(x)</span>  otherwise. This definition uses explicitly-programmable random oracles [BR93]. Note that we can recover the definition of a standard zkSNARK by setting the commitment algorithm  <span class="math">\\mathcal{C}</span>  to be a no-op and considering  <span class="math">n = 1</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\mathsf{ARG} = (\\mathcal{G},\\mathcal{C},\\mathcal{P},\\mathcal{V})</span>  be a ccSNARK for CSAT. Then, at a high level, an aggregation scheme for ARG is a ccSNARK that proves the validity of a batch of ARG proofs (for possibly different circuits). Formally, an aggregation scheme for ARG is a ccSNARK for the committable indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{Agg}}</span>  defined below.</p>

    <p class="text-gray-300">Definition 3.2 (aggregation relation). The committable indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{Agg}}</span>  is the set of triples</p>

    <div class="my-4 text-center"><span class="math-block">(\\dot {\\mathfrak {s}}, \\mathfrak {x}, (\\mathrm {w} _ {1}, \\mathrm {w} _ {2})) = ([ \\mathrm {i v k} _ {i} ] _ {i = 1} ^ {n}, \\mathfrak {x}, ([ \\mathrm {c m} _ {i} ] _ {i = 1} ^ {n}, [ \\pi_ {i} ] _ {i = 1} ^ {n}))</span></div>

    <p class="text-gray-300">where, for each  <span class="math">i\\in [n]</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{ivk}_i</span> is an honestly-generated verification key under ARG for some index <span class="math">\\dot{\\mathfrak{s}}_i</span> for CSAT,</li>

      <li><span class="math">\\Xi</span> is a valid instance for CSAT with respect to <span class="math">\\dot{\\mathfrak{s}}_i</span> (i.e., <span class="math">(\\dot{\\mathfrak{s}}_i, \\Xi) \\in \\mathcal{L}(\\mathrm{CSAT})</span>),</li>

      <li><span class="math">\\mathsf{cm}_i</span> is a commitment, and</li>

      <li><span class="math">\\pi_i</span> is a valid proof under <span class="math">\\mathrm{ivk}_i</span> for <span class="math">\\Xi</span>, i.e., <span class="math">\\mathcal{V}(\\mathrm{ivk}_i, \\Xi, \\mathsf{cm}_i, \\pi_i) = 1</span>.</li>

    </ul>

    <p class="text-gray-300">13</p>

    <p class="text-gray-300">We now describe our transformation that partitions a circuit  <span class="math">C</span>  into augmented subcircuits via the memory-checking infrastructure described in Section 2.1. Our transformation can be decomposed into two steps. First, in Section 4.2, we show how to augment a partitioned circuit  <span class="math">C</span>  into a 'ROM'-circuit where wires between subcircuits are replaced with memory accesses. Then, in Section 4.3, we show how to check these memory accesses with a memory checker, and how to split the checks performed by the latter across subcircuits.</p>

    <p class="text-gray-300">The resulting transformation, which we denote by  <span class="math">f = (f_{\\mathbb{i}}, f_{\\mathbb{w}_1}, f_{\\mathbb{x}, \\mathbb{w}_2})</span> , maps a partitioned circuit instance  <span class="math">(\\mathbb{i}, \\mathbb{x}, \\mathbb{w}) \\in k</span> -CSAT (Definition 4.3) to a batch of CSAT instances  <span class="math">[(\\mathbb{i}_i, \\mathbb{x}&#x27;, (\\mathbb{w}_{i,1}, \\mathbb{w}_{i,2}))]_{i=1}^k</span>  such that  <span class="math">\\mathbb{x}&#x27;</span>  is of the form  <span class="math">(1, \\mathsf{rt}, \\alpha, \\beta)</span> , where  <span class="math">(\\alpha, \\beta)</span>  are field elements, and  <span class="math">\\mathsf{rt}</span>  is the root of a Merkle tree. The reduction satisfies the following lemma.</p>

    <p class="text-gray-300">Lemma 4.1. There exists an efficient transformation  <span class="math">f = (f_{\\mathbb{i}}, f_{\\mathbb{w}_1}, f_{\\mathbb{x}, \\mathbb{w}_2})</span>  satisfying the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: For all  <span class="math">\\alpha, \\beta \\in \\mathbb{F}</span> , if  <span class="math">(\\dot{\\mathfrak{s}}, \\mathfrak{x}, \\mathfrak{w}) \\in k</span> -CSAT, then  <span class="math">\\mathfrak{x}</span>  is the 0-th leaf of  <span class="math">\\mathsf{rt}</span>  and  <span class="math">(\\dot{\\mathfrak{s}}_i, \\mathfrak{x}&#x27;, (\\mathfrak{w}_{i,1}, \\mathfrak{w}_{i,2})) \\in \\mathrm{CSAT}</span>  for all  <span class="math">i \\in [k]</span> .</li>

      <li>Knowledge soundness: Let  <span class="math">\\mathsf{CM} = (\\mathsf{Setup},\\mathsf{Commit})</span>  be a commitment scheme whose message spaces are indexed by  <span class="math">k</span> -CSAT indices  <span class="math">\\dot{\\mathfrak{s}}</span> . Then there exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that for every  <span class="math">k</span> -CSAT index  <span class="math">\\dot{\\mathfrak{s}}</span> , every efficient adversary  <span class="math">\\mathcal{W}</span> , and every benign auxiliary-input distribution  <span class="math">\\mathcal{D}</span> , the following probability is negligible:</li>

    </ul>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a></p>

    <p class="text-gray-300">We now describe the components of the transformation  <span class="math">f</span> , beginning with some notation.</p>

    <p class="text-gray-300">We begin by defining a notion of graph and circuit partitions.</p>

    <p class="text-gray-300">Definition 4.2. A labelled  <span class="math">k</span> -partition  <span class="math">\\mathcal{V}</span>  of a graph  <span class="math">G = (V, E)</span>  is a list  <span class="math">\\{V_1, \\ldots, V_k\\}</span>  that partitions the vertex set  <span class="math">V</span> . Specifically,  <span class="math">\\mathcal{V}</span>  is a  <span class="math">k</span> -partition of  <span class="math">G</span>  if and only if the sets in  <span class="math">\\mathcal{V}</span>  are non-empty and mutually disjoint, and the union of these sets equals  <span class="math">V</span> .</p>

    <p class="text-gray-300">In the following, let  <span class="math">G = (V,E)</span>  be a directed acyclic graph, and  <span class="math">\\mathcal{V}</span>  a  <span class="math">k</span> -partition of  <span class="math">G</span> . The cut-set of two vertex subsets  <span class="math">V_{1}, V_{2} \\subseteq V</span>  is defined as the set of edges originating in  <span class="math">V_{1}</span>  and terminating in  <span class="math">V_{2}</span> . That is,  <span class="math">\\operatorname{cut}(V_{1}, V_{2}) := \\{(u, v) \\in E \\mid u \\in V_{1}, v \\in V_{2}\\}</span> . The reduced cut-set of  <span class="math">V_{1}, V_{2}</span>  (denoted  <span class="math">\\mathrm{d-cut}(V_{1}, V_{2})</span> ) is obtained from  <span class="math">\\operatorname{cut}(V_{1}, V_{2})</span>  by removing all edges with the same source vertex except the lexicographically first one. That is, for all  <span class="math">e = (u, v) \\in \\operatorname{cut}(V_{1}, V_{2})</span> ,  <span class="math">e \\in \\mathrm{d-cut}(V_{1}, V_{2})</span>  if and only if there is no  <span class="math">v&#x27;</span>  such that  <span class="math">(u, v&#x27;) \\in \\mathrm{d-cut}(V_{1}, V_{2})</span> .</p>

    <p class="text-gray-300">We often identify circuits with their underlying graphs. If  <span class="math">\\mathcal{C} = \\{C_1, \\ldots, C_k\\}</span>  is a partition of the graph underlying a circuit  <span class="math">C</span> , then we say that  <span class="math">\\mathcal{C}</span>  partitions  <span class="math">C</span>  itself. Each  <span class="math">C_i \\in \\mathcal{C}</span>  is called a subcircuit of  <span class="math">C</span> . This identification allows us to define the following relation.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Definition 4.3 (<span class="math">k</span>-partitioned circuit satisfiability).</h6>

    <p class="text-gray-300">The committable indexed relation <span class="math">k</span>-CSAT is the set of triples <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w})=\\big{(}(\\dot{\\mathfrak{s}}_{\\text{CSAT}}=(\\mathbb{F},\\ell,m,n,C),\\mathcal{C}),x_{\\text{CSAT}},w_{\\text{CSAT}}\\big{)}</span> where <span class="math">(\\dot{\\mathfrak{s}}_{\\text{CSAT}},\\mathfrak{x}_{\\text{CSAT}},\\mathfrak{w}_{\\text{CSAT}})\\in\\text{CSAT}</span> and <span class="math">\\mathcal{C}=\\{C_{1},\\ldots,C_{k}\\}</span> is a <span class="math">k</span>-partition of <span class="math">C</span>.</p>

    <p class="text-gray-300">Notice that the set of wires shared between two subcircuits <span class="math">C_{i},C_{j}\\in\\mathcal{C}</span> is exactly the reduced cut-set <span class="math">\\text{d-cut}(C_{i},C_{j})</span>. We will denote by <span class="math">S</span> the set of all shared wires, i.e., <span class="math">S=\\bigcup_{i\\neq j}\\text{d-cut}(C_{i},C_{j})</span>.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">4.2 Eliminating shared wires with ROM circuits</h3>

    <p class="text-gray-300">We introduce a new circuit model: circuits with read-only access to a memory bank. We call such circuits ROM circuits.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Definition 4.4.</h6>

    <p class="text-gray-300">A ROM circuit over the field <span class="math">\\mathbb{F}</span> is an arithmetic circuit over <span class="math">\\mathbb{F}</span> equipped with access to a memory <span class="math">M</span>, which is an array of <span class="math">\\mathbb{F}</span> elements that is indexed by the elements of <span class="math">\\mathbb{F}</span>. A ROM circuit, in addition to the standard addition and multiplication gates, contains a <em>read</em> gate that takes as input an index <span class="math">i</span> and outputs the value <span class="math">M[i]</span>.</p>

    <p class="text-gray-300">Throughout this section, we will use <span class="math">s</span> to denote the size of a memory bank <span class="math">M</span>.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Definition 4.5 (<span class="math">k</span>-partitioned ROM circuit satisfiability).</h6>

    <p class="text-gray-300">The indexed relation <span class="math">k</span>-RCSAT is the set of all triples <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w})=\\big{(}(\\mathbb{F},k,\\ell,n,s,C,\\mathcal{C}),x,(w,M)\\big{)}</span> where <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">\\ell</span>, <span class="math">n</span>, and <span class="math">s</span> are natural numbers, <span class="math">x\\in\\mathbb{F}^{\\ell}</span> and <span class="math">w\\in\\mathbb{F}^{n}</span> are vectors over <span class="math">\\mathbb{F}</span>, <span class="math">M</span> is a memory bank of size <span class="math">s</span> over <span class="math">\\mathbb{F}</span>, and <span class="math">C:\\mathbb{F}^{\\ell+n}\\to\\mathbb{F}</span> is a ROM circuit over <span class="math">\\mathbb{F}</span> with respect to <span class="math">M</span>, such that <span class="math">C^{M}(x,w)=0</span> and <span class="math">\\mathcal{C}=\\{C_{1},\\ldots,C_{k}\\}</span> is a <span class="math">k</span>-partition of <span class="math">C</span>.</p>

    <p class="text-gray-300">In Figure 3, we provide a formal description of our reduction <span class="math">\\mathsf{c2r}=(\\mathsf{c2r}_{\\dot{\\mathfrak{s}}},\\mathsf{c2r}_{\\mathfrak{x}},\\mathsf{c2r}_{\\mathfrak{w}})</span> from <span class="math">k</span>-CSAT to <span class="math">k</span>-RCSAT that removes shared wires between subcircuits. The following lemma follows from the construction of the reduction.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Lemma 4.6.</h6>

    <p class="text-gray-300">The function <span class="math">\\mathsf{c2r}=(\\mathsf{c2r}_{\\dot{\\mathfrak{s}}},\\mathsf{c2r}_{\\mathfrak{x}},\\mathsf{c2r}_{\\mathfrak{w}})</span> defined in Fig. 3 is a reduction from <span class="math">k</span>-CSAT to <span class="math">k</span>-RCSAT. That is, <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w})\\in k</span>-CSAT if and only if <span class="math">(\\dot{\\mathfrak{s}}_{M},\\mathfrak{x}_{M},\\mathfrak{w}_{M})\\in k</span>-RCSAT, where <span class="math">\\dot{\\mathfrak{s}}_{M}=\\mathsf{c2r}_{\\dot{\\mathfrak{s}}}(\\dot{\\mathfrak{s}})</span>, <span class="math">\\mathfrak{x}_{M}=\\mathsf{c2r}_{\\mathfrak{x}}(\\mathfrak{x})</span>, and furthermore, there are no shared wires between the subcircuits in <span class="math">\\dot{\\mathfrak{s}}_{M}</span>.</p>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">4.3 Reducing partitioned ROM circuits to committable circuits</h3>

    <p class="text-gray-300">We now show how to reduce the problem of checking satisfiability of an instance of <span class="math">k</span>-RCSAT to that of checking simultaneous satisfaction of <span class="math">k</span> instances of CSAT. For this we use the notion of a <em>memory trace</em> <em>[BCG+13, BCG+13, BC+14b, ZGK+18]</em>. Informally, a memory trace is a list of entries recording memory reads performed by a ROM circuit.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Definition 4.7.</h6>

    <p class="text-gray-300">A memory trace entry is a tuple <span class="math">\\bm{e}=(t,i,v)</span>, where <span class="math">t\\in[s]</span> is the index of the subcircuit that performed this operation, <span class="math">i</span> is the memory address accessed, and <span class="math">v</span> is the value read from <span class="math">M[i]</span>. A memory trace is a list of memory trace entries, one for each read gate in a ROM circuit.</p>

    <p class="text-gray-300">We will consider memory traces whose entries are sorted by subcircuit index (denoted <span class="math">\\bm{T}</span>), and by memory address (denoted <span class="math">\\bm{A}</span>).</p>

    <p class="text-gray-300">Notation. We now introduce some notation for partitioning memory traces arising from a <span class="math">k</span>-partitioned ROM CSAT instance <span class="math">(\\mathbb{F},\\ell,n,s,R,\\mathcal{R}=\\{R_{1},\\ldots,R_{k}\\})</span>. Denote by <span class="math">s_{i}</span> the number of read gates in the <span class="math">i</span>-th subcircuit <span class="math">R_{i}</span>, by <span class="math">k_{i}=\\sum_{j=1}^{i-1}s_{j}</span> the cumulative number of read gates in circuits <span class="math">R_{1},\\ldots,R_{i-1}</span>, and by <span class="math">\\mathcal{S}_{i}=\\{k_{i}+1,\\ldots,k_{i+1}\\}</span> the set of (indices of) all read gates in <span class="math">R_{i}</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{c}2\\mathrm{r}_{\\mathbb{I}}(\\mathbb{i} = (\\mathbb{F},k,\\ell ,n,C,\\mathcal{C}))\\to \\mathbb{i}_M</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\mathcal{C}</span>  as  <span class="math">\\{C_1,\\dots ,C_k\\}</span></li>

      <li>Initialize an empty memory bank  <span class="math">M</span>  and a counter  <span class="math">t\\coloneqq 0</span></li>

      <li>For each  <span class="math">i\\in [k]</span>  , initialize new ROM subcircuits  <span class="math">R_{i}\\coloneqq C_{i}</span></li>

      <li>For each pair of distinct subcircuits  <span class="math">C_i, C_j \\in \\mathcal{C}</span> , and for each shared wire  <span class="math">w = (u, v) \\in \\mathrm{d-cut}(C_i, C_j)</span> :</li>

    </ol>

    <p class="text-gray-300">(a) Append a new entry to  <span class="math">M</span>  containing the value of  <span class="math">w</span> , and increment  <span class="math">t</span> . (b) Add read gates to  <span class="math">R_{i}</span>  and  <span class="math">R_{j}</span>  that read index  <span class="math">t</span>  of the memory  <span class="math">M</span> . (c) Add to  <span class="math">R_{i}</span>  a new equality check between  <span class="math">u</span>  and the output of the new read gate. (d) For every wire  <span class="math">w&#x27; = (u, v&#x27;) \\in \\mathrm{cut}(C_i, C_j)</span>  with the same source  <span class="math">u</span>  as  <span class="math">w</span> :</p>

    <p class="text-gray-300">i. Remove  <span class="math">w&#x27;</span>  from  <span class="math">R_i</span>  and  <span class="math">R_j</span> . ii. Add to  <span class="math">R_{j}</span>  a new equality check between  <span class="math">\\nu^{\\prime}</span>  and the output of the new read gate.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Denote by  <span class="math">R</span>  the circuit whose partition is  <span class="math">\\mathcal{R} = \\{R_1, \\ldots, R_k\\}</span> .</li>

      <li>Denote by  <span class="math">s</span>  the size of  <span class="math">M</span> , and by  <span class="math">\\ell&#x27;</span>  and  <span class="math">n&#x27;</span>  the number of public input and witness wires in  <span class="math">R</span> , respectively.</li>

      <li>Output  <span class="math">(\\mathbb{F},\\ell^{\\prime},n^{\\prime},s,R,\\mathcal{R})</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{c}2\\mathrm{r}_{\\mathbb{x}}(\\mathbb{x})\\to \\mathbb{x}_M</span>  : Output  <span class="math">\\mathbb{x}_M\\coloneqq \\mathbb{x}</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{c}2\\mathrm{r}_{\\mathbb{W}}(\\mathbb{i},\\mathbb{x},\\mathbb{W})\\to \\mathbb{W}_M</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Use  <span class="math">\\mathrm{c2r_i(i)}</span>  to obtain the ROM circuit  <span class="math">R</span> .</li>

      <li>Use  <span class="math">\\mathbb{x}</span>  and  <span class="math">\\mathbb{W}</span>  to compute the witness  <span class="math">\\mathbb{W}_M</span>  for  <span class="math">R</span>  (i.e., the wires  <span class="math">w_{M}</span>  and the contents of  <span class="math">M</span> ).</li>

      <li>Output  <span class="math">\\mathbb{W}_M</span></li>

    </ol>

    <p class="text-gray-300">Figure 3: Reduction from  <span class="math">k</span> -CSAT to  <span class="math">k</span> -RCSAT.</p>

    <p class="text-gray-300">Let  <span class="math">\\pmb{T} = (\\pmb{T}_1, \\dots, \\pmb{T}_s)</span>  and  <span class="math">\\pmb{A} = (A_1, \\dots, A_s)</span>  denote the subcircuit-sorted and the address-sorted memory traces respectively. Then the  <span class="math">i</span> -th subcircuit-sorted subtrace  <span class="math">\\pmb{T}_i</span>  is defined as  <span class="math">\\pmb{T}_i := (\\pmb{T}_{k_i + 1}, \\dots, \\pmb{T}_{k_i + s_i})</span> . Note that, by construction, the subcircuit index of each entry in  <span class="math">\\pmb{T}_i</span>  equals  <span class="math">i</span> , i.e.  <span class="math">\\pmb{T}_i</span>  contains only those trace entries that correspond to the memory reads made by  <span class="math">R_i</span> . Denote by  <span class="math">\\pmb{t}_i</span>  the last entry in  <span class="math">\\pmb{T}_i</span> . Similarly, the  <span class="math">i</span> -th address-sorted subtrace is defined as  <span class="math">\\pmb{A}_i := (\\pmb{A}_{k_i + 1}, \\dots, \\pmb{A}_{k_i + s_i})</span> , and  <span class="math">\\pmb{a}_i</span>  denotes the last entry in  <span class="math">\\pmb{A}_i</span> .</p>

    <p class="text-gray-300">Construction intuition. We begin by noting that valid memory traces for ROM circuits produced by the reduction in Section 4.2 should satisfy the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Values are consistent: If consecutive entries  <span class="math">(t,i,\\nu)</span>  and  <span class="math">(t^{\\prime},i^{\\prime},\\nu^{\\prime})</span>  in the trace  <span class="math">A</span>  have the same address (i.e.  <span class="math">i = i^{\\prime}</span> ), they must have the same values  <span class="math">(\\nu = \\nu^{\\prime})</span> .</li>

      <li>Every subcircuit reads: Consecutive entries  <span class="math">(t,i,\\nu)</span>  and  <span class="math">(t^{\\prime},i^{\\prime},\\nu^{\\prime})</span>  in  <span class="math">\\pmb{T}</span>  satisfy the constraint that either  <span class="math">t = t^{\\prime}</span>  or  <span class="math">t = t^{\\prime} + 1</span> . If  <span class="math">t = t^{\\prime}</span> , then it must be that  <span class="math">i\\leq i^{\\prime}</span> .</li>

      <li>Every address is read: Consecutive entries  <span class="math">(t,i,\\nu)</span>  and  <span class="math">(t^{\\prime},i^{\\prime},\\nu^{\\prime})</span>  in  <span class="math">\\mathbf{A}</span>  must satisfy the constraint that either  <span class="math">i = i^{\\prime}</span>  or  <span class="math">i = i^{\\prime} + 1</span> . If  <span class="math">i = i^{\\prime}</span> , then it must be that  <span class="math">t\\leq t^{\\prime}</span> .</li>

      <li>Traces are consistent:  <span class="math">\\pmb{T}</span>  and  <span class="math">\\pmb{A}</span>  are permutations of each other.</li>

    </ol>

    <p class="text-gray-300">We now describe the intuition behind our reduction  <span class="math">f^{k} = (f_{\\mathbb{I}}^{k}, f_{\\mathbb{W}_{1}}^{k}, f_{\\mathbb{X}, \\mathbb{W}_{2}}^{k})</span>  from  <span class="math">k</span> -RCSAT to  <span class="math">k</span> -CSAT, deferring to Figure 4 the formal pseudocode of the reduction.</p>

    <p class="text-gray-300">The function  <span class="math">f_{\\mathbb{I}}^{k}</span>  constructs a set of  <span class="math">k</span>  'commit-carrying' circuits  <span class="math">R_{i}^{\\prime}</span>  by relying on the following observations. Checks 1 to 3 are entirely local as they inspect only consecutive entries in  <span class="math">T_{i}</span>  and  <span class="math">A_{i}^{\\prime}</span> , and can thus be enforced by each subcircuit  <span class="math">R_{i}</span>  independently. Check 4, on the other hand, is a global property that requires coordination between the subcircuits. To enable this coordination, we store the running trace evaluations (as well as the last entries of the sorted traces) in a Merkle tree, and give to each subcircuit the root of this tree as public</p>

    <p class="text-gray-300">input. In more detail, each circuit  <span class="math">R_{i}^{\\prime}</span>  is constructed as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">R_{i}^{\\prime}</span>  takes as public input  <span class="math">\\mathbb{x}^{\\prime} = (1, \\mathrm{rt}, \\alpha, \\beta)</span>  where  <span class="math">\\alpha, \\beta \\in \\mathbb{F}</span>  are field elements, and  <span class="math">\\mathrm{rt}</span>  is a Merkle tree root. (We will specify how these are obtained below.)</li>

      <li><span class="math">R_{i}^{\\prime}</span>  takes as input a witness that can be split two parts,  <span class="math">\\mathbb{W}_{i,1}</span>  and  <span class="math">\\mathbb{W}_{i,2}</span> , where the first contains the subtraces  <span class="math">T_{i}</span>  and  <span class="math">A_{i}</span> , while the second contains the witness wires of  <span class="math">R_{i}</span>  and two Merkle paths.</li>

      <li><span class="math">R_{i}^{\\prime}</span>  enforces (a) that the input Merkle paths are valid paths for the  <span class="math">i - 1</span> -th and the  <span class="math">i</span> -th leaves in a Merkle tree with root  <span class="math">\\mathsf{rt}</span> ; (b) that the  <span class="math">i</span> -th leaf of the Merkle tree contains the last entries  <span class="math">\\pmb{t}_{i}</span>  and  <span class="math">\\pmb{a}_{i}</span>  of  <span class="math">T_{i}</span>  and  <span class="math">A_{i}</span>  respectively; (c) the correctness of running trace evaluations  <span class="math">T_{i}(\\alpha, \\beta)</span>  and  <span class="math">A_{i}(\\alpha, \\beta)</span> , where  <span class="math">T_{i}(X, Y) := \\prod_{j=1}^{k_{i+1}} (X - (t_{j}^{T} + Y \\cdot i_{j}^{T} + Y^{2} \\cdot v_{j}^{T}))</span>  and  <span class="math">A_{i}(X, Y) := \\prod_{j=1}^{k_{i+1}} (X - (t_{j}^{A} + Y \\cdot i_{j}^{A} + Y^{2} \\cdot v_{j}^{A}))</span> ; and (d) that the 0-th leaf holds the public input  <span class="math">\\mathbb{x}</span>  of  <span class="math">R</span> .</li>

    </ul>

    <p class="text-gray-300"><span class="math">f_{i}^{k}(\\dot{\\mathfrak{s}})\\to [\\dot{\\mathfrak{s}}_{i}]_{i = 1}^{k}</span> Parse  <span class="math">\\dot{\\mathbf{i}} = (\\mathbb{F},\\ell ,n,s,R,\\mathcal{R} = \\{R_1,\\dots ,R_k\\})</span>  and construct circuits  <span class="math">[C_i]_{i = 1}^k</span>  by augmenting  <span class="math">[R_i]_{i = 1}^k</span>  as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each  <span class="math">C_i</span>  takes as public input  <span class="math">\\mathbb{x}&#x27;</span>  and takes as witness  <span class="math">\\mathbb{w}_{i,1}</span>  and  <span class="math">\\mathbb{w}_{i,2}</span> . The contents of these are as described in the construction intuition.</li>

      <li>For each  <span class="math">i\\in [k]\\setminus \\{1\\}</span> , augment  <span class="math">C_i</span>  further as follows:</li>

    </ol>

    <p class="text-gray-300">(a) Replace the output wire of the  <span class="math">j</span> -th read gate in  <span class="math">R_{i}</span>  with a wire carrying the value of the  <span class="math">j</span> -th entry in  <span class="math">\\pmb{T}_i</span> . (b)  <span class="math">C_i</span>  parses  <span class="math">\\mathbb{w}_{i,2}</span>  as Merkle proofs  <span class="math">\\pi_{\\mathrm{rt}}^{i - 1}</span>  and  <span class="math">\\pi_{\\mathrm{rt}}^i</span>  , and checks that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">j \\in \\{i - 1, i\\}</span> ,  <span class="math">\\pi_{\\mathrm{rt}}^j</span>  is a valid path with respect to rt for the  <span class="math">j</span> -th leaf with value  <span class="math">(t_j, a_j, T_j(\\alpha, \\beta), A_j(\\alpha, \\beta))</span> .</li>

      <li>The trace  <span class="math">(t_{i - 1}, T_i)</span>  is sorted by the label  <span class="math">t_j^T</span> , and the trace  <span class="math">(a_{i - 1}, A_i)</span>  is sorted by the address  <span class="math">i_j^A</span> .</li>

      <li>Entries of  <span class="math">(\\pmb{a}_{i - 1},\\pmb{A}_i)</span>  with the same address  <span class="math">i_j^A</span>  contain the same value  <span class="math">\\nu_{j}^{A}</span> , and that consecutive values of  <span class="math">i_j^A</span>  differ by at most 1.</li>

      <li>The running products are computed correctly:  <span class="math">T_{i}(\\alpha, \\beta) = T_{i - 1}(\\alpha, \\beta) \\cdot \\prod_{j \\in S_{i}} (\\alpha - (t_{j}^{T} + \\beta \\cdot i_{j}^{T} + \\beta^{2} \\cdot v_{j}^{T}))</span> , and  <span class="math">A_{i}(\\alpha, \\beta) = A_{i - 1}(\\alpha, \\beta) \\cdot \\prod_{j \\in S_{i}} (\\alpha - (t_{j}^{A} + \\beta \\cdot i_{j}^{A} + \\beta^{2} \\cdot v_{j}^{A}))</span> .</li>

      <li>The entries  <span class="math">t_i</span>  and  <span class="math">a_i</span>  are the last entries of  <span class="math">T_i</span>  and  <span class="math">A_i</span>  respectively.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">C_1</span>  is augmented to perform analogous checks on leaf 1 of the Merkle tree and to additionally check that  <span class="math">\\mathbb{x}</span>  in leaf 0 is consistent with its wires.</li>

      <li>For each  <span class="math">i\\in [k]</span> , compute  <span class="math">\\ell_i&#x27;,n_i&#x27;,m_i&#x27;</span>  to be the sizes of  <span class="math">\\mathbb{x}_i&#x27;</span> ,  <span class="math">\\mathbb{w}_{i,1}</span>  and  <span class="math">\\mathbb{w}_{i,2}</span>  respectively. Output  <span class="math">[(F,\\ell_i&#x27;,n_i&#x27;,m_i&#x27;,C_i)]_{i = 1}^k</span> .</li>

    </ol>

    <p class="text-gray-300"><span class="math">f_{\\mathbb{W}_1}^k (\\dot{\\mathfrak{s}},\\mathbb{x},(\\mathbb{W},M))\\to [\\mathbb{W}_{i,1}]_{i = 1}^k</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse i as  <span class="math">((\\mathbb{F},\\ell ,n,s,R),\\mathcal{R})</span></li>

      <li>Construct the memory traces  <span class="math">\\pmb{T}</span>  and  <span class="math">\\pmb{A}</span>  by executing  <span class="math">R^{M}(\\mathbb{x},\\mathbb{w})</span>  , and partition them to obtain  <span class="math">[\\pmb {T}_i]_i^k</span>  and  <span class="math">[\\pmb {A}_i]_i^k</span></li>

      <li>Output  <span class="math">[\\mathbb{W}_{i,1} = (\\pmb {T}_i,\\pmb {A}_i)]_{i = 1}^k</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">f_{\\mathbb{X},\\mathbb{W}_1}^k (\\dot{\\mathfrak{s}},\\mathbb{x},(\\mathbb{W},M),\\alpha ,\\beta)\\to (\\mathbb{x}&#x27;,[\\mathbb{W}_{i,2}]_{i = 1}^k):</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse i as  <span class="math">((\\mathbb{F},\\ell ,n,s,R),\\mathcal{R})</span></li>

      <li>Compute the augmented indices  <span class="math">[\\mathfrak{s}]_{i = 1}^{k} := f_{\\mathfrak{s}}^{k}(\\mathfrak{s})</span></li>

      <li>Construct the memory traces  <span class="math">\\pmb{T}</span>  and  <span class="math">\\pmb{A}</span>  by executing  <span class="math">R^{M}(\\mathbb{x},\\mathbb{w})</span></li>

      <li>Use  <span class="math">\\mathbb{x},\\alpha ,\\beta ,T</span>  and  <span class="math">\\pmb{A}</span>  to construct a Merkle tree with root rt with the 0-th leaf containing  <span class="math">\\mathbb{x}</span>  and the  <span class="math">i</span>  -th leaf containing  <span class="math">(t_i,a_i,T_i(\\alpha ,\\beta),A_i(\\alpha ,\\beta))</span></li>

      <li>Partition w into disjoint subwitnesses  <span class="math">\\mathbb{W}_1,\\dots ,\\mathbb{W}_k</span>  , corresponding to  <span class="math">R_{1},\\ldots ,R_{k}</span>  respectively.</li>

      <li>For each  <span class="math">i\\in [k]</span>  , construct  <span class="math">\\mathbb{W}_{i,2}</span>  to contain  <span class="math">\\mathbb{W}_i</span>  and the Merkle paths for leaves  <span class="math">i - 1</span>  and  <span class="math">i</span>  of the Merkle tree.</li>

      <li>Output  <span class="math">(\\mathbb{x}^{\\prime}\\coloneqq (1,\\mathsf{rt},\\alpha ,\\beta),[\\mathbb{w}_{i,2}]_{i = 1}^{k})</span></li>

    </ol>

    <p class="text-gray-300">Figure 4: Reduction from  <span class="math">k</span> -RCSAT to  <span class="math">k</span>  instances of CSAT.</p>

    <p class="text-gray-300">The reduction satisfies the following lemma, which roughly says that when the inputs  <span class="math">\\alpha, \\beta</span>  are chosen by hashing commitments to the memory traces, the output circuits are satisfiable if and only if the input ROM circuit is satisfiable.</p>

    <p class="text-gray-300">Lemma 4.8. The reduction  <span class="math">f^{k} = (f_{\\mathbb{I}}^{k}, f_{\\mathbb{W}_{1}}^{k}, f_{\\mathbb{x}, \\mathbb{W}_{2}}^{k})</span>  defined in Fig. 4, on input  <span class="math">(\\dot{\\mathbb{i}}, \\mathbb{x}, (\\mathbb{w}, M), \\alpha, \\beta)</span> , outputs  <span class="math">([\\dot{\\mathbb{i}}_{i}]_{i=1}^{k}, \\mathbb{x}&#x27;, [\\mathbb{w}_{i,1}]_{i=1}^{k}, [\\mathbb{w}_{i,2}]_{i=1}^{k})</span>  such that the following properties hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: For all  <span class="math">\\alpha, \\beta \\in \\mathbb{F}</span> , if  <span class="math">(\\dot{\\mathfrak{i}}, \\mathfrak{x}, (\\mathfrak{w}, M)) \\in k</span> -RCSAT, then  <span class="math">(\\dot{\\mathfrak{i}}_i, \\mathfrak{x}&#x27;, (\\mathfrak{w}_{i,1}, \\mathfrak{w}_{i,2})) \\in \\mathrm{CSAT}</span>  for all  <span class="math">i \\in [k]</span>  and  <span class="math">\\mathfrak{x}</span>  is the 0-th leaf of rt.</li>

      <li>Knowledge soundness: Let  <span class="math">\\mathsf{CM} = (\\mathsf{Setup},\\mathsf{Commit})</span>  be a commitment scheme whose message space  <span class="math">\\mathcal{M}</span>  consists of the memory traces  <span class="math">\\pmb{T}</span>  and  <span class="math">\\pmb{A}</span> . There exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that for every efficient adversary  <span class="math">\\mathcal{W}</span> , the following probability is negligible:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ←U(λ) [ˆi]i=1=fi(k, C) ck←CM.Setup(1λ, M)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  auxW←D(i) ([wi]i=1, rt)←Wρ(i, auxW) cm←CM.Commit(ck, [wi,1]i=1) (α, β)←ρ(cm)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(ˆi, x', (wi, 1, wi, 2)) ∈ CSAT & x is the 0-th leaf of rt</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x' := (1, rt, α, β) (x, (w, M)) ← ΕρW(i, auxW)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  |</p>

    <p class="text-gray-300">Proof. Completeness. Let  <span class="math">\\alpha, \\beta</span>  be arbitrary elements of  <span class="math">\\mathbb{F}</span>  and parse  <span class="math">\\dot{\\mathfrak{i}}</span>  as  <span class="math">(\\mathbb{F}, k, \\ell, n, s, R, \\mathcal{R})</span>  and  <span class="math">\\mathfrak{x}&#x27;</span>  as  <span class="math">(1, \\mathsf{rt}, \\alpha, \\beta)</span> . By construction,  <span class="math">\\mathfrak{x}</span>  is the 0-th leaf of the Merkle tree with root  <span class="math">\\mathsf{rt}</span> .</p>

    <p class="text-gray-300">If  <span class="math">(\\dot{\\mathfrak{i}},\\mathfrak{x},(\\mathfrak{w},M))\\in k</span>  -RCSAT, then  <span class="math">R^{M}(\\mathfrak{x},\\mathfrak{w}) = 0</span>  , which in turn implies that we can construct appropriate memory sub-traces  <span class="math">[\\mathbb{w}_{i,1} = (T_i,A_i)]_{i = 1}^k</span>  and witnesses  <span class="math">[\\mathbb{w}_{i,2}]_{i = 1}^{k}</span>  such that  <span class="math">(\\dot{\\mathfrak{i}}_i,\\mathfrak{x}&#x27;,(\\mathbb{w}_{i,1},\\mathbb{w}_{i,2}))\\in \\mathrm{CSAT}</span>  for all  <span class="math">i\\in [k]</span></p>

    <p class="text-gray-300">Knowledge soundness. We construct an extractor  <span class="math">\\mathcal{E}</span>  such that if  <span class="math">(\\dot{\\mathfrak{i}}_i,\\mathfrak{x}&#x27;,(\\mathfrak{w}_{i,1},\\mathfrak{w}_{i,2}))\\in \\mathrm{CSAT}</span>  for all  <span class="math">i\\in [k]</span> , the probability that  <span class="math">\\mathcal{E}</span>  fails to produce  <span class="math">(\\mathfrak{x},(\\mathfrak{w},M))</span>  such that  <span class="math">(\\dot{\\mathfrak{i}},\\mathfrak{x},(\\mathfrak{w},M))\\in k</span> -RCSAT and  <span class="math">\\mathfrak{x}</span>  is the 0-th leaf of rt is negligible.  <span class="math">\\mathcal{E}</span>  works as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}_{\\mathcal{W}}^{\\rho}(\\mathfrak{i},\\mathrm{aux}_{\\mathcal{W}})\\to (\\mathfrak{x},(\\mathfrak{w},M))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\mathfrak{i}</span>  as  <span class="math">(\\mathbb{F},k,\\ell ,n,s,R,\\mathcal{R})</span>  and compute  <span class="math">[\\dot{\\mathfrak{i}}_i^{\\prime}]_{i = 1}^k = f_{\\mathfrak{i}}^k (\\mathfrak{i})</span></li>

      <li>Obtain  <span class="math">([(\\mathbb{w}_{i,1},\\mathbb{w}_{i,2})]_{i = 1}^{k},\\mathsf{rt})\\gets \\mathcal{W}^{\\rho}(\\dot{\\mathfrak{i}},\\mathsf{aux}_{\\mathcal{W}})</span></li>

      <li>Compute  <span class="math">(\\alpha, \\beta) \\gets \\rho(\\mathsf{CM}.\\mathsf{Commit}(\\mathsf{ck}, [\\mathbb{w}_{i,1}]_{i=1}^{k}))</span> .</li>

      <li>Set  <span class="math">\\mathfrak{x}&#x27; := (1, \\mathsf{rt}, \\alpha, \\beta)</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5. For all  <span class="math">i</span>  in  <span class="math">\\{1,\\dots ,k\\}</span>  parse  <span class="math">\\mathbb{W}_{i,1}</span>  as  <span class="math">(T_{i},A_{i})</span>  and construct  $\\pmb {T} = \\pmb{T}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb {T}_k<span class="math">  and  </span>\\pmb {A} = \\pmb {A}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb {A}_k$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all  <span class="math">i \\in [k] \\setminus \\{1\\}</span> , check that the values read from the  <span class="math">i</span> -th leaf of the Merkle tree with root  <span class="math">\\mathsf{rt}</span>  are consistent in  <span class="math">\\mathbb{W}_{i-1,2}</span>  and  <span class="math">\\mathbb{W}_{i,2}</span> .</li>

      <li>Check that  <span class="math">\\pmb{T}</span>  is sorted by subcircuit index,  <span class="math">\\pmb{A}</span>  is sorted by address, and that  <span class="math">\\pmb{T}</span>  and  <span class="math">\\pmb{A}</span>  are permutations of each other.</li>

      <li>Construct the memory  <span class="math">M</span>  from  <span class="math">\\pmb{T}</span>  and  <span class="math">\\pmb{A}</span> .</li>

      <li>For all  <span class="math">i \\in [k]</span> , parse  <span class="math">\\mathbb{W}_{i,2}</span>  to obtain  <span class="math">\\mathbb{W}_i</span>  corresponding to  <span class="math">R_i</span>  and the Merkle paths for leaves  <span class="math">i - 1</span>  and  <span class="math">i</span>  of the tree corresponding to rt.</li>

      <li>Use  <span class="math">[\\mathbb{W}_i]_{i = 1}^k</span>  to reconstruct  <span class="math">\\mathbb{W}</span></li>

      <li>Use the merkle path from  <span class="math">\\mathbb{W}_{1,2}</span>  to set  <span class="math">\\mathfrak{x}</span>  to be the value in the 0-th leaf of the Merkle tree.</li>

      <li>Output  <span class="math">(\\mathfrak{x},(\\mathfrak{w},M))</span></li>

    </ol>

    <p class="text-gray-300">We prove the following claim about the extractor  <span class="math">\\mathcal{E}</span> .</p>

    <p class="text-gray-300">Claim 4.9.</p>

    <p class="text-gray-300">Given that <span class="math">(\\dot{\\mathfrak{s}}_{i},\\mathfrak{x}^{\\prime},(\\mathfrak{w}_{i,1},\\mathfrak{w}_{i,2}))\\in</span> CSAT for all <span class="math">i\\in[k]</span>, if the extractor <span class="math">\\mathcal{E}</span> does not abort, it outputs a valid <span class="math">(\\mathfrak{x},(\\mathfrak{w},M))</span> such that <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},(\\mathfrak{w},M))\\in</span> <span class="math">k</span>-RCSAT.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Since the public input of <span class="math">R</span> is used only in the first subcircuit <span class="math">R_{1}</span>, the fact that <span class="math">(\\dot{\\mathfrak{s}}_{1},\\mathfrak{x}^{\\prime},(\\mathfrak{w}_{1,1},\\mathfrak{w}_{1,2}))\\in</span> CSAT and the extracted <span class="math">\\mathfrak{x}</span> is exactly the <span class="math">0</span>-th leaf of <span class="math">\\mathsf{rt}</span> implies that the public input of <span class="math">R</span> is consistent with <span class="math">\\mathfrak{x}</span>, by construction of <span class="math">C_{1}</span>.</p>

    <p class="text-gray-300">Since <span class="math">\\mathcal{E}</span> does not abort, this implies that all the values read from the Merkle tree are consistent amongst all <span class="math">k</span> subcircuits and <span class="math">\\bm{T}</span> and <span class="math">\\bm{A}</span> are permutations of each other.</p>

    <p class="text-gray-300">By construction of each index <span class="math">[\\dot{\\mathfrak{s}}]_{i=1}^{k}</span>, and because for each <span class="math">i</span>, <span class="math">(\\dot{\\mathfrak{s}}_{i},\\mathfrak{x}^{\\prime},(\\mathfrak{w}_{i,1},\\mathfrak{w}_{i,2}))\\in</span> CSAT, we have that the witness <span class="math">\\mathfrak{w}</span> and memory <span class="math">M</span> extracted by <span class="math">\\mathcal{E}</span> are such that <span class="math">R^{M}(\\mathfrak{x},\\mathfrak{w})=1</span>. ∎</p>

    <p class="text-gray-300">It is now sufficient to prove that the extractor aborts with negligible probability, which we do in the following claim.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Claim 4.10.</h6>

    <p class="text-gray-300">Given that <span class="math">(\\dot{\\mathfrak{s}}_{i},\\mathfrak{x}^{\\prime},(\\mathfrak{w}_{i,1},\\mathfrak{w}_{i,2}))\\in</span> CSAT for all <span class="math">i\\in[k]</span>, the extractor <span class="math">\\mathcal{E}</span> aborts with negligible probability.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The extractor only aborts if the values read from the Merkle tree are not consistent amongst all <span class="math">k</span> subcircuits, or if <span class="math">\\bm{T}</span> and <span class="math">\\bm{A}</span> are not permutations of each other.</p>

    <p class="text-gray-300">The probability that the adversary can open the same leaf to two different values is negligible due to collision resistance of the underlying hash function, and so it must be the case that, except with negligible probability, the values read from the Merkle tree are consistent amongst all <span class="math">k</span> subcircuits.</p>

    <p class="text-gray-300">Now, <span class="math">(\\dot{\\mathfrak{s}}_{i},\\mathfrak{x}^{\\prime},(\\mathfrak{w}_{i,1},\\mathfrak{w}_{i,2}))\\in</span> CSAT for all <span class="math">i\\in[k]</span> implies that <span class="math">\\bm{T}</span> is a valid subcircuit-sorted trace, <span class="math">\\bm{A}</span> is a valid address-sorted trace, and <span class="math">T(\\alpha,\\beta)=A(\\alpha,\\beta)</span>, where <span class="math">T(X,Y):=\\prod_{j=1}^{s}(X-(t_{j}^{T}+Y\\cdot i_{j}^{T}+Y^{2}\\cdot\\nu_{j}^{T}))</span> and <span class="math">A(X,Y):=\\prod_{j=1}^{s}(X-(t_{j}^{A}+Y\\cdot i_{j}^{A}+Y^{2}\\cdot\\nu_{j}^{A}))</span>. Lemma B.1 now implies that, except with negligible probability, <span class="math">T(X,Y)=A(X,Y)</span>, thus implying that <span class="math">\\bm{T}</span> and <span class="math">\\bm{A}</span> are permutations of each other.</p>

    <p class="text-gray-300">Thus overall the probability of abort is negligible. ∎</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">We now describe our aggregation scheme for the Mirage commit-carrying zkSNARK (Section 5.1.1). We describe the aggregation scheme and prove it secure in Section 5.3. A key building block of our construction is a method to prove the correctness of multiple pairing products simultaneously. We describe this building block in Section 5.2.</p>

    <p class="text-gray-300">Throughout this section we assume that the public inputs to each subcircuit are of the form  <span class="math">(1, \\mathsf{rt}, \\alpha, \\beta)</span>  as this is what the reduction in Section 4 mandates. We also assume  <span class="math">\\mathsf{Agg}.\\mathcal{C}</span>  does not take any randomness as input as  <span class="math">\\mathsf{Agg}</span>  does not have to be hiding.</p>

    <p class="text-gray-300">We begin by recalling some results from prior work [BMMTV21; GMN22] that we will use in our construction.</p>

    <p class="text-gray-300">Commitment schemes. The commitment scheme  <span class="math">\\mathsf{CM}_D</span>  [GMN22] is defined as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CM}_D</span>  .Setup  <span class="math">(\\mathbb{G}_1^n,\\mathbb{G}_2^n)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">a, b \\gets \\overline{\\mathbb{F}}</span> .</li>

      <li>Set  <span class="math">\\mathbf{v}_1 \\coloneqq [a^i H]_{i=0}^{n-1}</span> , and  <span class="math">\\mathbf{v}_2 \\coloneqq [b^i H]_{i=0}^{n-1}</span> .</li>

      <li>Set  <span class="math">\\mathbf{w}_1 \\coloneqq [a^i G]_{j=n}^{2n-1}</span> , and  <span class="math">\\mathbf{w}_2 \\coloneqq [b^i G]_{j=n}^{2n-1}</span> .</li>

      <li>Output  <span class="math">\\mathsf{ck}_D\\coloneqq (\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{w}_1,\\mathbf{w}_2)</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{CM}_D</span>  .Commit  <span class="math">(\\mathsf{ck}_D,m = (\\pmb {A},\\pmb {B}))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\mathsf{ck}_D</span>  as  <span class="math">(\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{w}_1,\\mathbf{w}_2)</span></li>

      <li>Parse  <span class="math">\\mathbf{v}_1</span>  as  <span class="math">[a^i H]_{i=0}^{n-1}</span> , and  <span class="math">\\mathbf{v}_2</span>  as  <span class="math">[b^i H]_{i=0}^{n-1}</span> .</li>

      <li>Parse  <span class="math">\\mathbf{w}_1</span>  as  <span class="math">[a^i G]_{i = n}^{2n - 1}</span> , and  <span class="math">\\mathbf{w}_2</span>  as  <span class="math">[b^i G]_{i = n}^{2n - 1}</span> .</li>

      <li>Parse  <span class="math">\\mathbf{A}</span>  as  <span class="math">[A_i]_{i=0}^{n-1}</span>  and  <span class="math">\\mathbf{B}</span>  as  <span class="math">[B_i]_{i=0}^{n-1}</span> .</li>

      <li>Set  <span class="math">T \\coloneqq \\prod_{i=0}^{n-1} e(A_i, a^i H) \\cdot \\prod_{i=0}^{n-1} e(a^{n+i} G, B_i)</span> .</li>

      <li>Set  <span class="math">U \\coloneqq \\prod_{i=0}^{n-1} e(A_i, b^i H) \\cdot \\prod_{i=0}^{n-1} e(b^{n+i} G, B_i)</span> .</li>

      <li>Output  <span class="math">C \\coloneqq (T, U)</span> .</li>

    </ol>

    <p class="text-gray-300">We will also use  <span class="math">\\mathsf{CM}_1</span>  and  <span class="math">\\mathsf{CM}_2</span> , two special cases of the above commitment scheme. In the former, the  <span class="math">\\mathbb{G}_2</span>  component of the message is ignored, while in the latter, the  <span class="math">\\mathbb{G}_1</span>  component is ignored. That is,  <span class="math">\\mathsf{CM}_1</span>  is a commitment scheme with message space  <span class="math">\\mathbb{G}_1^n</span> , while  <span class="math">\\mathsf{CM}_2</span>  is a commitment scheme with message space  <span class="math">\\mathbb{G}_2^n</span> . In fact,  <span class="math">\\mathsf{CM}_1</span>  is the same as the commitment scheme  <span class="math">\\mathsf{CM}_S</span>  from [GMN22].</p>

    <p class="text-gray-300">We now define two relations associated with the above commitment schemes. These are slightly modified versions of the relation  <span class="math">\\mathcal{R}_{\\mathrm{TIPP}}</span>  defined in [BMMTV21]:</p>

    <p class="text-gray-300">Definition 5.1 (separate pairing product relation). The indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{SPP}}</span>  is the set of triples</p>

    <div class="my-4 text-center"><span class="math-block">(\\dot {\\mathrm {s}}, \\mathrm {z}, \\mathrm {w}) = (\\mathrm {c k} _ {D}, (\\mathrm {c m} _ {A} ^ {1}, \\mathrm {c m} _ {B} ^ {2}, Z, r), (\\boldsymbol {A} ^ {\\prime}, \\boldsymbol {B}))</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathsf{ck}_D</span>  is a commitment key for the commitment schemes  <span class="math">\\mathsf{CM}_1</span>  and  <span class="math">\\mathsf{CM}_2</span>  (Section 3.1),  <span class="math">\\mathsf{cm}_A^1</span>  and  <span class="math">\\mathsf{cm}_B^2</span>  are commitments under  <span class="math">\\mathsf{CM}_1</span>  and  <span class="math">\\mathsf{CM}_2</span> ,  <span class="math">Z</span>  is the claimed pairing product of  <span class="math">\\mathbf{A}&#x27;</span>  and  <span class="math">\\mathbf{B}</span> ,  <span class="math">r</span>  is a field element, and  <span class="math">\\mathbf{A}&#x27; \\in \\mathbb{G}_1^n</span>  and  <span class="math">\\mathbf{B} \\in \\mathbb{G}_2^n</span>  are vectors of group elements such that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{cm}_A^1 = \\mathsf{CM}_1.\\mathsf{Commit}(\\mathsf{ck}_D,\\boldsymbol {r}^{-1}\\circ \\boldsymbol {A}&#x27;)</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{cm}_B^2 = \\mathsf{CM}_2.\\mathsf{Commit}(\\mathsf{ck}_D,\\pmb {B})</span></p>

    <p class="text-gray-300"><span class="math">Z = \\mathbf{A}^{\\prime}*\\mathbf{B}</span></p>

    <p class="text-gray-300">Definition 5.2 (combined pairing product relation). The indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{CPP}}</span>  is the set of triples</p>

    <p class="text-gray-300"><span class="math">(\\dot{\\mathbf{s}},\\mathbf{z},\\mathbf{w}) = (\\mathsf{ck}_D,(\\mathsf{cm}^D,Z,r),(\\mathbf{A}&#x27;,\\mathbf{B}))</span></p>

    <p class="text-gray-300">where  <span class="math">\\mathsf{ck}_D</span>  is a commitment key for the commitment scheme  <span class="math">\\mathsf{CM}_D</span>  (Section 3.1),  <span class="math">\\mathsf{cm}^D</span>  is a commitment under  <span class="math">\\mathsf{CM}_D</span> ,  <span class="math">Z</span>  is the claimed pairing product of  <span class="math">\\mathbf{A}&#x27;</span>  and  <span class="math">\\mathbf{B}</span> ,  <span class="math">r</span>  is a field element, and  <span class="math">\\mathbf{A}&#x27; \\in \\mathbb{G}_1^n</span>  and  <span class="math">\\mathbf{B} \\in \\mathbb{G}_2^n</span>  are vectors of group elements such that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{cm}^D = \\mathsf{CM}_D.\\mathsf{Commit}(\\mathsf{ck}_D,\\pmb {r}^{-1}\\circ \\pmb {A}&#x27;,\\pmb {B})</span></p>

    <p class="text-gray-300"><span class="math">Z = A^{\\prime}*B</span></p>

    <p class="text-gray-300">Below we describe the commit-carrying zkSNARK Mirage [CFQ19; KPPS20]. We note that while [KPPS20] does not have a formal statement regarding the binding property of Mirage, the ccGro16 construction in [CFQ19] is morally the same as Mirage, except that the latter handles public inputs as well. As a result, Theorem H.1 from [CFQ19] can easily be extended to prove knowledge soundness for Mirage. For simplicity, in our use case, we use a construction of ARG where  <span class="math">\\mathrm{ipk}_i = \\mathrm{ick}_i</span>  for all  <span class="math">i\\in [n]</span> .</p>

    <p class="text-gray-300">Mirage.Setup  <span class="math">(\\lambda ,[\\dot{\\mathbf{i}} ]_{i = 1}^{n})\\to ([\\mathrm{ipk}_{i}]_{i = 1}^{n},[\\mathrm{ick}_{i}]_{i = 1}^{n},[\\mathrm{ivk}_{i}]_{i = 1}^{n})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i</span>  in  <span class="math">\\{1,\\dots ,n\\}</span>  , parse  <span class="math">\\dot{\\mathbf{i}}_i</span>  as  <span class="math">(\\mathbb{F},\\ell_i,m_i,n_i,C_i)</span>  and construct from it the QAP index  <span class="math">(\\mathbb{F},t_i(X),\\pmb {a}_i(X),\\pmb {b}_i(X),\\pmb {c}_i(X))</span></li>

      <li>Sample  <span class="math">\\alpha, \\beta, [\\gamma_{i=1}^{n}, [s_i]_{i=1}^{n} \\gets \\mathbb{F}</span>  and  <span class="math">[\\delta_{i=1}^{n}, [\\eta_i]_{i=1}^{n} \\gets \\mathbb{F}</span> .</li>

      <li>For each  <span class="math">i\\in [n]</span>  and  <span class="math">j\\in [\\ell_i + m_i + n_i]</span> , define  <span class="math">p_{i,j}(X)\\coloneqq \\beta a_{i,j}(X) + \\alpha b_{i,j}(X) + c_{i,j}(X)</span> .</li>

      <li>For each  <span class="math">i</span>  in  <span class="math">[n]</span> , construct the verifying, committing, and proving keys, and output these:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathrm{ivk}_i\\coloneqq \\left(e([\\alpha ]_1,[\\beta ]_2),[\\gamma ]_2,[\\delta ]_2,[\\eta_i]_2,\\left\\{\\left[p_{i,j}(s_i) / \\gamma_i\\right]_1\\right\\}_{j = 0}^{\\ell_i - 1}\\right);\\quad \\mathsf{ck}_i\\coloneqq \\left([\\delta ]_1,\\left\\{\\left[p_{i,j}(s_i) / \\eta_i\\right]_1\\right\\}_{j = \\ell_i}^{\\ell_i + m_i - 1}\\right)</span></p>

    <p class="text-gray-300"><span class="math">\\mathrm{ipk}_i\\coloneqq \\left(\\mathsf{ck}_i,\\mathrm{ivk}_i,\\left\\{\\left[s_i&#x27;\\right]_1,\\left[s_i&#x27;\\right]_2\\right\\}_{j = 0}^{\\ell_i + m_i + n_i - 1},\\left\\{\\left[p_{i,j}(s) / \\delta_i\\right]_1\\right\\}_{j = \\ell_i + m_i}^{\\ell_i + m_i + n_i - 1},\\left\\{\\left[s_i&#x27; \\ell_i(s_i) / \\delta_i\\right]_1\\right\\}_{j = 0}^{\\ell_i + m_i + n_i - 1}\\right);\\quad \\mathrm{ick}_i\\coloneqq \\mathrm{ipk}_i</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">([\\mathrm{ipk}_i]_i^n, [\\mathrm{ick}_i]_i^n, [\\mathrm{ivk}_i]_i^n)</span> .</li>

    </ol>

    <p class="text-gray-300">Mirage.Commit(ick,  <span class="math">\\mathbb{W}_C^\\prime ,\\kappa_D)\\to D</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Obtain ck from ick and parse ck as  <span class="math">\\left([\\delta ]_1,\\{[p_i(s) / \\eta ]_1\\}_{i = \\ell}^{\\ell +m - 1}\\right)</span></li>

      <li>Obtain partial QAP witness  <span class="math">\\mathbb{W}&#x27; = [w_i]_{i = \\ell}^{\\ell +m - 1}</span>  from  <span class="math">\\mathbb{W}_C^\\prime</span></li>

      <li>Define  <span class="math">V_{1}(X)\\coloneqq \\sum_{i = \\ell}^{\\ell +m - 1}w_{i}\\cdot p_{i}(X)</span></li>

      <li>Output  <span class="math">D\\coloneqq [V_1(s) / \\eta ]_1 + [\\kappa_D\\delta ]_1</span></li>

    </ol>

    <p class="text-gray-300">Mirage.Verify(ivk,  <span class="math">\\pi_C,D,\\pi)\\to \\{0,1\\}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Obtain the QAP instance  <span class="math">\\pi</span>  from  <span class="math">\\pi_C</span> .</li>

      <li>Parse proof  <span class="math">\\pi</span>  as  <span class="math">(A,B,C)</span></li>

      <li>Check that  <span class="math">e(A,B) =</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">e([\\alpha ]_1,[\\beta ]_2)e(\\left[\\sum_{i = 0}^{\\ell -1}\\frac{\\pi_i p_i(s)}{\\gamma}\\right]_1,[\\gamma ]_2)e(C,[\\delta ]_2)e(D,[\\eta ]_2).</span></p>

    <p class="text-gray-300">Mirage.Prove  <span class="math">(\\mathrm{ipk},\\pi_C,(\\mathbb{W}_C&#x27;,\\mathbb{W}_C),\\kappa_D)\\to \\pi</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse ipk as  <span class="math">\\left(\\mathsf{ck},\\mathsf{ivk},\\left\\{\\left[s^{\\prime}\\right]_{1},\\left[s^{\\prime}\\right]_{2}\\right\\}_{i = 0}^{\\ell +m + n - 1},\\left\\{\\left[p_{i}(s) / \\delta \\right]_{1}\\right\\}_{i = \\ell +m}^{\\ell +m + n - 1},\\left\\{\\left[s^{\\prime}t(s) / \\delta \\right]_{1}\\right\\}_{i = 0}^{\\ell +m + n - 2}\\right)</span></li>

      <li>Obtain the QAP instance  <span class="math">\\pi</span>  from  <span class="math">\\pi_C</span>  and the QAP witness  <span class="math">(\\mathbb{W}&#x27;,\\mathbb{W})</span>  from  <span class="math">(\\mathbb{W}_C&#x27;,\\mathbb{W}_C)</span></li>

      <li>Parse  <span class="math">\\pi</span>  as the public input variables  <span class="math">[w_i]_{i=0}^{\\ell-1}</span> ,  <span class="math">\\mathbb{W}&#x27;</span>  as  <span class="math">[w_i]_{i=\\ell}^{\\ell+m-1}</span>  and  <span class="math">\\mathbb{W}</span>  as  <span class="math">[w_i]_{i=\\ell+m}^{\\ell+m-1}</span> .</li>

      <li>Sample randomizers  <span class="math">\\kappa_{A},\\kappa_{B}\\gets \\mathbb{F}</span>  , and set</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">p_A(X)\\coloneqq \\sum_{i = 0}^{\\ell +m + n - 1}w_i\\cdot a_i(X).</span></p>

    <p class="text-gray-300">(d)  <span class="math">p_A^\\prime (X)\\coloneqq \\alpha +p_A(X) + \\kappa_A\\delta .</span></p>

    <p class="text-gray-300">(f)  <span class="math">V_{2}(X)\\coloneqq \\sum_{i = \\ell +m}^{\\ell +m + n - 1}w_{i}\\cdot p_{i}(X).</span></p>

    <p class="text-gray-300">(b)  <span class="math">p_B(X)\\coloneqq \\sum_{i = 0}^{\\ell +m + n - 1}w_i\\cdot b_i(X).</span></p>

    <p class="text-gray-300">(e)  <span class="math">p_B^\\prime (X)\\coloneqq \\beta +p_B(X) + \\kappa_B\\delta .</span></p>

    <p class="text-gray-300">(g)  <span class="math">h(X)\\coloneqq \\frac{p_A(X)\\cdot p_B(X) - p_C(X)}{t(X)}</span></p>

    <p class="text-gray-300">(c)  <span class="math">p_C(X)\\coloneqq \\sum_{i = 0}^{\\ell +m + n - 1}w_i\\cdot c_i(X).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">A\\coloneqq \\left[p_A&#x27;(s)\\right]_1,B\\coloneqq \\left[p_B&#x27;(s)\\right]_2</span>  , and  <span class="math">C\\coloneqq \\left[\\frac{h(s)t(s)}{\\delta}\\right]_1 + [V_2(s) / \\delta ]_1 + \\kappa_B A + \\kappa_A[p_B&#x27;(s)]_1 - [\\kappa_A\\kappa_B\\delta ]_1 - [\\kappa_D\\eta ]_1.</span></li>

      <li>Output  <span class="math">\\pi \\coloneqq (A,B,C)</span></li>

    </ol>

    <p class="text-gray-300">We now describe our protocol for showing the correctness of multiple pairing products, where the inputs to each pairing product are vectors of group elements committed under the commitment schemes described in Section 5.1. Concretely, we describe a protocol for the following relation.</p>

    <p class="text-gray-300">Definition 5.3 (multiple pairing product relation). The indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{MPP}}</span>  is the set of triples</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ck</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(cm2ABZAB),</td>

            <td class="px-3 py-2 border-b border-gray-700">(cm1S, cm2γZSY),</td>

            <td class="px-3 py-2 border-b border-gray-700">(cm1C, cm2δZCδ),</td>

            <td class="px-3 py-2 border-b border-gray-700">(cm1D, cm2δZDη), r</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(A', B),</td>

            <td class="px-3 py-2 border-b border-gray-700">(S', γ),</td>

            <td class="px-3 py-2 border-b border-gray-700">(C', δ),</td>

            <td class="px-3 py-2 border-b border-gray-700">(D', η)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where  <span class="math">\\mathsf{ck}</span>  is a commitment key for the commitment schemes  <span class="math">\\mathsf{CM}_D</span> ,  <span class="math">\\mathsf{CM}_1</span> , and  <span class="math">\\mathsf{CM}_2</span>  (Section 3.1), and</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{ck},(\\mathsf{cm}_{AB}^{D},Z_{AB},r),(\\pmb {A}^{\\prime},\\pmb {B}))\\in \\mathcal{R}_{\\mathrm{CP}}</span></li>

      <li><span class="math">(\\mathsf{ck},(\\mathsf{cm}_S^1,\\mathsf{cm}_T^2,Z_{S\\gamma},r),(\\pmb {S}&#x27;,\\pmb {\\gamma}))\\in \\mathcal{R}_{\\mathrm{SP}}</span></li>

      <li><span class="math">(\\mathsf{ck},(\\mathsf{cm}_C^1,\\mathsf{cm}_\\delta^2,Z_{C\\delta},r),(\\pmb {C}&#x27;,\\pmb {\\delta}))\\in \\mathcal{R}_{\\mathrm{SP}}</span>  and</li>

      <li><span class="math">(\\mathsf{ck},(\\mathsf{cm}_D^1,\\mathsf{cm}_\\eta^2,Z_{D\\eta},r),(D&#x27;,\\pmb {\\eta}))\\in \\mathcal{R}_{\\mathrm{SP}}</span> .</li>

    </ul>

    <p class="text-gray-300">Theorem 5.4. Given a SNARK TIPP for the  <span class="math">\\mathcal{R}_{\\mathrm{CP}}</span>  NP relation, the construction MPP in Fig. 5 is a SNARK for the  <span class="math">\\mathcal{R}_{\\mathrm{MPP}}</span>  relation. MPP achieves the following efficiency properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover's running time is the cost of running TIPP.Prove once.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The proof size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathrm{TIPP}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Completeness. Completeness follows from the completeness of TIPP.</p>

    <p class="text-gray-300">Knowledge soundness. We reduce to the knowledge soundness of the underlying TIPP protocol by using any successful adversary  <span class="math">\\mathcal{A}</span>  against MPP to construct an adversary  <span class="math">\\mathcal{B}</span>  against TIPP. We then use the extractor for the latter to construct an extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  for  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}^{\\rho &#x27;}(\\mathrm{pk}_{\\mathrm{TIPP}},\\mathrm{aux})\\to (\\pi_{\\mathrm{TIPP}},\\pi_{\\mathrm{TIPP}})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\mathsf{pk}_{\\mathrm{MPP}} = \\mathsf{pk}_{\\mathrm{TIPP}}</span></li>

      <li>Obtain  <span class="math">(\\pi, \\pi) \\gets \\mathcal{A}^{\\rho&#x27;}(\\mathrm{pk}_{\\mathrm{MPP}}, \\mathrm{aux})</span> .</li>

      <li>Construct  <span class="math">\\pi_{\\mathrm{TIPP}} := ((\\mathsf{cm}_{LR}^{D}, Z_{LR}), r)</span>  as in MPP.Prove.</li>

      <li>Output  <span class="math">(\\pi_{\\mathrm{TIPP}},\\pi_{\\mathrm{TIPP}})</span></li>

    </ol>

    <p class="text-gray-300">Now we construct  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  as follows. The high level idea is to have  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  rewind  <span class="math">\\mathcal{A}</span>  with the same  <span class="math">\\pi</span> , but obtaining TIPP proofs for  <span class="math">\\pi</span>  with respect to 4 different random challenges  <span class="math">(s_1, t_1)</span> ,  <span class="math">(s_2, t_2)</span> ,  <span class="math">(s_3, t_3)</span>  and  <span class="math">(s_4, t_4)</span> . We then use the TIPP extractor  <span class="math">\\mathcal{E}_{\\mathcal{B}}</span>  to extract witnesses for each of these TIPP instances, and interpolate to obtain a valid witness  <span class="math">\\mathfrak{w}</span>  for  <span class="math">\\mathcal{R}_{\\mathrm{MPP}}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}_{\\mathcal{A}}^{\\rho}(\\mathrm{pk}_{\\mathrm{MPP}},\\mathrm{aux})\\to \\mathbb{W}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\mathsf{pk}_{\\mathrm{TIPP}} = \\mathsf{pk}_{\\mathrm{MPP}}</span></li>

      <li>Compute  <span class="math">(\\pi, \\pi = (\\mathcal{Z}_{\\mathbb{CP}}, \\pi_{\\mathrm{TIPP}})) \\gets \\mathcal{A}^{\\rho}(\\mathrm{pk}_{\\mathrm{MPP}}, \\mathrm{aux})</span> .</li>

      <li>For  <span class="math">i\\in \\{1,2,3,4\\}</span></li>

    </ol>

    <p class="text-gray-300">(a) If  <span class="math">i \\neq 1</span> , sample  <span class="math">(s_i, t_i) \\gets \\mathbb{F}^2</span>  and program  <span class="math">\\rho</span>  to return  <span class="math">(s_i, t_i)</span>  at  <span class="math">(\\mathrm{vk}_{\\mathrm{TIPP}}, \\pi, \\mathcal{Z}_{\\mathbb{CP}})</span> . (b) Extract TIPP witness  <span class="math">(\\pmb {L}_i,\\pmb {R}_i)\\gets \\mathcal{E}_\\mathcal{B}^\\rho (\\mathrm{pk}_{\\mathrm{TIPP}},\\mathrm{aux}).</span></p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 5: The MPP Protocol</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Interpolate the extracted TIPP witnesses to obtain  <span class="math">\\mathbb{W} := (A, B, C, D)</span> .</li>

    </ol>

    <p class="text-gray-300">The correctness of the extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}}^{\\rho}</span>  follows from Lemma B.1.</p>

    <p class="text-gray-300">Efficiency. The efficiency claims follow from inspection:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>MPP.Prove runs TIPP.Prove once.</li>

      <li><span class="math">\\pi_{\\mathrm{MPP}}</span>  is of the form  <span class="math">(\\mathcal{Z}_{\\mathbb{CP}},\\pi_{\\mathrm{TIPP}})</span> , where  <span class="math">\\mathcal{Z}_{\\mathbb{CP}}</span>  consists of  <span class="math">12\\mathbb{G}_T</span>  elements.</li>

    </ul>

    <p class="text-gray-300">We present the full construction of our aggregation scheme for Mirage in Fig. 6.</p>

    <p class="text-gray-300">Completeness. Completeness follows from the completeness of MPP and  <span class="math">\\mathsf{CM}_D</span> . Commit.</p>

    <p class="text-gray-300">Knowledge Soundness. Knowledge soundness reduces to the knowledge soundness of MPP and the binding property of  <span class="math">\\mathsf{CM}_D</span> . Commit. That is, given a successful adversary  <span class="math">\\mathcal{A}</span>  against Agg, we will construct an adversary  <span class="math">\\mathcal{B}</span>  against MPP. We will then use the knowledge soundness of the latter to construct an extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  for  <span class="math">\\mathcal{A}</span> . We begin by constructing  <span class="math">\\mathcal{B}</span>  for MPP as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}^{\\rho}(\\mathrm{pk}_{\\mathrm{MPP}},\\mathrm{aux}_{\\mathcal{B}})\\to (\\mathrm{x}_{\\mathrm{MPP}},\\pi_{\\mathrm{MPP}})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse auxB as (auxA, pkAgg).</li>

      <li>Parse  <span class="math">\\mathsf{pk}_{\\mathrm{Agg}}</span>  as  <span class="math">(\\mathsf{pk}_{\\mathrm{MPP}},\\mathsf{vk}_{\\mathrm{Agg}},\\hat{\\pmb{S}},\\pmb {S}_2,\\pmb {S}_3,\\pmb {\\gamma},\\pmb {\\delta},\\pmb {\\eta})</span></li>

      <li>Parse verification key  <span class="math">\\mathsf{vk}_{\\mathrm{Agg}} = (\\mathsf{vk}_{\\mathrm{MPP}},\\mathsf{cm}_{S_1}^1,\\mathsf{cm}_{S_2}^1,\\mathsf{cm}_{S_3}^1,\\mathsf{cm}_{\\gamma}^2,\\mathsf{cm}_{\\delta}^2,\\mathsf{cm}_{\\eta}^2)</span></li>

      <li>Obtain  <span class="math">(\\mathrm{x},\\mathrm{cm}_{\\mathrm{Agg}},\\pi)\\gets \\mathcal{A}(\\mathrm{pk}_{\\mathrm{Agg}},\\mathrm{aux})</span></li>

      <li>Parse public input  <span class="math">\\mathbf{x}</span>  as  <span class="math">(1, \\mathrm{rt}, \\alpha, \\beta)</span> , commitment  <span class="math">\\mathrm{cm}_{\\mathrm{Agg}}</span>  as  <span class="math">\\mathrm{cm}_D^1</span> , and proof  <span class="math">\\pi</span>  as  <span class="math">(\\mathrm{cm}_{AB}^D, \\mathrm{cm}_C^1, (Z_{AB}, Z_{S\\gamma}, Z_{C\\delta}, Z_{D\\eta}), \\pi_{\\mathrm{MPP}})</span> .</li>

      <li>Construct  <span class="math">\\mathbf{x}_{\\mathrm{MPP}}</span>  and  <span class="math">\\pi_{\\mathrm{MPP}}</span>  as in Agg.  <span class="math">\\mathcal{P}</span> , and output these.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathrm{Agg}.\\mathcal{V}</span>  accepting implies that the batched SNARK verification equation holds and MPP.Verify accepts. The latter implies that  <span class="math">\\mathcal{E}_{\\mathcal{B}}</span>  outputs a valid witness  <span class="math">\\mathbb{W}_{\\mathrm{MPP}} = \\big((A&#x27;,B),(S&#x27;,\\gamma),(C&#x27;,\\delta),(D&#x27;,\\eta)\\big)</span>  for  <span class="math">\\mathbf{x}_{\\mathrm{MPP}}</span> , except with negligible probability.</p>

    <p class="text-gray-300">After rescaling  <span class="math">\\mathbf{A} = \\mathbf{r}^{-1} \\circ \\mathbf{A}&#x27;</span> ,  <span class="math">\\mathbf{S} = \\mathbf{r}^{-1} \\circ \\mathbf{S}&#x27;</span> ,  <span class="math">\\mathbf{C} = \\mathbf{r}^{-1} \\circ \\mathbf{C}&#x27;</span>  and  <span class="math">[\\mathrm{cm}_i]_{i=1}^n = \\mathbf{r}^{-1} \\circ \\mathbf{D}&#x27;</span> , the batched SNARK verification equation  <span class="math">Z_{AB} = (e([\\alpha]_1, [\\beta]_2))^{\\sigma} \\cdot Z_{S\\gamma} \\cdot Z_{C\\delta} \\cdot Z_{D\\eta}</span>  implies that, except with negligible probability, for all  <span class="math">i \\in [n]</span> , Mirage.Verify(ivki, (1, rt,  <span class="math">\\alpha</span> ), cm_i, (Ai, Bi, Ci)) = 1 (by Lemma B.1).</p>

    <p class="text-gray-300">This allows us to argue the success of the extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  constructed below:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}_{\\mathcal{A}}^{\\rho}(\\mathrm{pk}_{\\mathrm{Agg}},\\mathrm{aux}_{\\mathcal{A}})\\to \\mathbb{W}_{\\mathrm{Agg}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\mathrm{aux}_{\\mathcal{B}} := (\\mathrm{aux}_{\\mathcal{A}}, \\mathrm{pk}_{\\mathrm{Agg}})</span> .</li>

      <li>Obtain  <span class="math">\\mathbb{W}_{\\mathrm{MPP}}\\gets \\mathcal{E}_{\\mathcal{B}}^{\\rho}(\\mathrm{pk}_{\\mathrm{MPP}},\\mathrm{aux}_{\\mathcal{B}})</span></li>

      <li>Parse  <span class="math">\\mathbb{W}_{\\mathrm{MPP}}</span>  as  <span class="math">((A&#x27;, B), (S&#x27;, \\gamma), (C&#x27;, \\delta), (D&#x27;, \\eta))</span> .</li>

      <li>Rescale  <span class="math">\\mathbf{A} = \\mathbf{r}^{-1} \\circ \\mathbf{A}&#x27;</span> ,  <span class="math">\\mathbf{S} = \\mathbf{r}^{-1} \\circ \\mathbf{S}&#x27;</span> ,  <span class="math">\\mathbf{C} = \\mathbf{r}^{-1} \\circ \\mathbf{C}&#x27;</span>  and  <span class="math">[\\mathrm{cm}_i]_{i=1}^n = \\mathbf{r}^{-1} \\circ \\mathbf{D}&#x27;</span> . c</li>

      <li>Output  <span class="math">(\\mathbb{W}_1\\coloneqq D,\\mathbb{W}_2\\coloneqq (A_i,B_i,C_i)_{i = 1}^n)</span></li>

    </ol>

    <p class="text-gray-300">Efficiency. The efficiency claims follow from inspection:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Agg.  <span class="math">\\mathcal{P}</span>  runs MPP.Prove once,  <span class="math">\\mathrm{CM}_D</span> . Commit once, and  <span class="math">\\mathrm{CM}_1</span> . Commit once.</li>

      <li><span class="math">\\pi_{\\mathrm{Agg}}</span>  is of the form  <span class="math">(\\mathsf{cm}_{AB}^{D},\\mathsf{cm}_{C}^{1},Z_{\\mathsf{IP}},\\pi_{\\mathsf{MPP}})</span> , where  <span class="math">\\mathcal{Z}_{\\mathsf{IP}}</span>  consists of  <span class="math">4\\mathbb{G}_T</span>  elements and  <span class="math">\\mathsf{cm}_{AB}^{D}</span>  and  <span class="math">\\mathsf{cm}_{C}^{1}</span>  are 2  <span class="math">\\mathbb{G}_T</span>  elements each.</li>

    </ul>

    <p class="text-gray-300">|  Agg.G(λ,(ivki)n=1,((vi,j)n=1)→(pkAgg,ckAgg,vkAgg):  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  1. Sample public parameters for MPP: (pkMPP,vkMPP)← MPP.Setup(λ).  |</p>

    <p class="text-gray-300">|  2. For all i∈[n] parse ivki as (e([α]1, [β]2), [γi]2, [δi]2, [ηi]2, { [pi,j(s)/γi]1}4j=1).  |</p>

    <p class="text-gray-300">|  3. For each j in {1,2,3,4}, set Sj:= ([p1,j(s)/γi]1, ..., [pn,j(s)/γn]1) and commit to Sj: cm1Sj← CM1.Commit(ckD,Sj).  |</p>

    <p class="text-gray-300">|  4. Set γ:= ([γi]2, ..., [γn]2), δ:= ([δ1]2, ..., [δn]2), and η:= ([η1]2, ..., [ηn]2).  |</p>

    <p class="text-gray-300">|  5. Commit to γ, δ, η: cm2γ← CM2.Commit(ckD,γ), cm2δ← CM2.Commit(ckD,δ), cm2η← CM2.Commit(ckD,η).  |</p>

    <p class="text-gray-300">|  6. Parse pkMPP as ((ckD,ckKZG),vkTIPP).  |</p>

    <p class="text-gray-300">|  7. Set ckAgg := ckD.  |</p>

    <p class="text-gray-300">|  8. Set vkAgg := (vkMPP,cm1S1,cm1S2,cm1S3,cm1S4,cm2γ,cm2δ,cm2η).  |</p>

    <p class="text-gray-300">|  9. Set pkAgg := (pkMPP,ckAgg, vkAgg, S1, S2, S3, S4, γ, δ, η).  |</p>

    <p class="text-gray-300">|  10. Output (pkAgg,ckAgg, vkAgg).  |</p>

    <p class="text-gray-300">|  Agg.Lρ(ckAgg, [cmi]n=1)→cmAgg:  |</p>

    <p class="text-gray-300">|  1. Parse commitment key ckAgg as ckD and commitments [cmi]n=1 as D.  |</p>

    <p class="text-gray-300">|  2. Output cmAgg := CM1.Commit(ckD,D).  |</p>

    <p class="text-gray-300">|  Agg.Pρ(pkAgg,π,w,cmAgg)→π:  |</p>

    <p class="text-gray-300">|  1. Parse pkAgg as (pkMPP,ckAgg, vkAgg, S1, S2, S3, S4, γ, δ, η).  |</p>

    <p class="text-gray-300">|  2. Parse ckAgg as ckD and vkAgg as (vkMPP,cm1S1,cm1S2,cm1S3,cm1S4,cm2γ,cm2δ,cm2η).  |</p>

    <p class="text-gray-300">|  3. Parse π as (1,rt,α,β) and w as (D, (Ai, Bi, Ci)i=1).  |</p>

    <p class="text-gray-300">|  4. Parse cmAgg as cm1D.  |</p>

    <p class="text-gray-300">|  5. Commit to A and B: cm1AB← CM2. Commit(ckD,A,B).  |</p>

    <p class="text-gray-300">|  6. Commit to C: cm1C← CM1. Commit(ckD,C).  |</p>

    <p class="text-gray-300">|  7. Compute public input vector S = S1 + rt · S2 + α · S3 + β · S4.  |</p>

    <p class="text-gray-300">|  8. Compute public input commitment cm1S := (cm1S1) · (cm1S2)rt · (cm1S3)α · (cm1S4)β.  |</p>

    <p class="text-gray-300">|  9. Compute random linear combination challenge r := ρ(vkAgg,π,cm2AB, (cm1S, cm2γ), (cm1C, cm2δ), (cm1D, cm2η)).  |</p>

    <p class="text-gray-300">|  10. Construct r := (1, r1, r2, ..., rn-1).  |</p>

    <p class="text-gray-300">|  11. Rescale A' = r∘A, S' = r∘S, C' = r∘C and D' = r∘D.  |</p>

    <p class="text-gray-300">|  12. Compute the claimed inner products ZIP = (ZAB := A' <em> B, ZSY := S' </em> γ, ZCδ := C' <em> δ, ZDη := D' </em> η).  |</p>

    <p class="text-gray-300">|  13. Assemble the RMPP instance and witness:  |</p>

    <p class="text-gray-300">|  αMPP := (cm2AB ZAB) (cm1S, cm2γ ZSY) (cm1C, cm2δ ZCδ) (cm1D, cm2η ZDη) r  |</p>

    <p class="text-gray-300">|  wMPP := (A', B) (S', γ) (C', δ) (D', η)  |</p>

    <p class="text-gray-300">|  14. Compute Multi-TIPP proof: πMPP← MPP.Prove(pkMPP,πMPP; wMPP).  |</p>

    <p class="text-gray-300">|  15. Output π := (cm2AB, cm1C, ZIP, πMPP).  |</p>

    <p class="text-gray-300">|  Agg.V(vkAgg,π,cmAgg,π)→{0,1}:  |</p>

    <p class="text-gray-300">|  1. Parse verification key vkAgg = (vkMPP, cm1S1, cm1S2, cm1S3, cm2γ, cm2δ, cm2η).  |</p>

    <p class="text-gray-300">|  2. Parse public input π as (1,rt,α,β), commitment cmAgg as cm1D, and proof π as (cm2AB, cm1C, (ZAB, ZSY, ZCδ, ZDη), πMPP).  |</p>

    <p class="text-gray-300">|  3. Compute cm1S = (cm1S1) · (cm1S2)rt · (cm1S3)α · (cm1S4)β.  |</p>

    <p class="text-gray-300">|  4. Compute r = ρ(vkAgg,π,cm2AB, (cm1S, cm2γ), (cm1C, cm2δ), (cm1D, cm2η)).  |</p>

    <p class="text-gray-300">|  5. Assemble the RMPP instance: πMPP := ((cm2AB ZAB) (cm1S, cm2γ ZSY) (cm1C, cm2δ ZCδ) (cm1D, cm2η ZDη) r  |</p>

    <p class="text-gray-300">|  6. Check that MPP.Verify(vkMPP, πMPP, πMPP) = 1.  |</p>

    <p class="text-gray-300">|  7. Check that the batched Mirage verification equation holds: ZAB = (e([α]1, [β]2))σ · ZSY · ZCδ · ZDη.  |</p>

    <p class="text-gray-300">Figure 6: Our aggregation scheme for Mirage.</p>

    <p class="text-gray-300">6 Divide-and-aggregate zkSNARKs</p>

    <p class="text-gray-300">The following theorem describes our main result: a divide-and-aggregate (DNA) zkSNARK for CSAT that supports both the distributed and low-memory prover workflows.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Theorem 6.1.</h6>

    <p class="text-gray-300">Consider the following ingredients:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>an inner commit-carrying zkSNARK <span class="math">\\mathsf{ARG}</span> for CSAT (Section 3.2), and</li>

      <li>an aggregation scheme <span class="math">\\mathsf{Agg}</span> for <span class="math">\\mathsf{ARG}</span> (Section 3.3),</li>

    </ul>

    <p class="text-gray-300">Then the construction in Section 6.1 is a zkSNARK for CSAT that has a horizontally-scalable distributed prover (Section 6.2).</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Remark 6.2.</h6>

    <p class="text-gray-300">Our construction can be instantiated with a variety of different ingredients, including aggregation schemes based on proof-carrying data <em>[x13, x10, x11, x12]</em>. However, it fails to capture divide-and-aggregate zkSNARKs which leverage fine-grained aggregation within the execution of the inner zkSNARK. An example of such a scheme is the aPlonk SNARK <em>[x1]</em>, which aggregates separately the polynomial commitments generated in each round of the Plonk SNARK. We leave the task of extending our construction to capture such zkSNARKs to future work.</p>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">6.1 Construction</h3>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">Generator DNA.<span class="math">\\mathcal{G}</span>.</h4>

    <p class="text-gray-300">On input the security parameter <span class="math">\\lambda</span> and the CSAT index <span class="math">\\mathbbm{i}=(\\mathbb{F},k,\\ell,n,C,\\mathcal{C})</span>, compute the index-specific proving and verifying keys <span class="math">(\\mathsf{ipk},\\mathsf{ivk})</span> as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Reduce <span class="math">\\mathbbm{i}</span> to multiple CSAT indices: <span class="math">[\\mathbbm{i}_{i}]_{i=1}^{n}:=f_{\\mathbbm{i}}(\\mathbbm{i})</span>.</li>

      <li>Sample keys for CSAT indices: <span class="math">([\\mathsf{ipk}_{i}]_{i=1}^{n},[\\mathsf{ick}_{i}]_{i=1}^{n},[\\mathsf{ivk}_{i}]_{i=1}^{n})\\leftarrow\\mathsf{ARG}.\\mathcal{G}(\\lambda,[\\mathbbm{i}_{i}]_{i=1}^{n})</span>.</li>

      <li>Construct <span class="math">\\mathsf{Agg}</span> index: <span class="math">\\mathbbm{i}_{\\mathsf{Agg}}:=[\\mathsf{ivk}_{i}]_{i=1}^{n}</span>.</li>

      <li>Sample keys for <span class="math">\\mathsf{Agg}</span>: <span class="math">(\\mathsf{pk}_{\\mathsf{Agg}},\\mathsf{ck}_{\\mathsf{Agg}},\\mathsf{vk}_{\\mathsf{Agg}})\\leftarrow\\mathsf{Agg}.\\mathcal{G}(\\lambda,\\mathbbm{i}_{\\mathsf{Agg}})</span>.</li>

      <li>Construct verifying key: <span class="math">\\mathsf{ivk}:=\\mathsf{vk}_{\\mathsf{Agg}}</span> and proving key <span class="math">\\mathsf{ipk}:=(\\mathbbm{i},\\mathsf{ivk},[\\mathsf{ipk}_{i}]_{i=1}^{n},\\mathsf{pk}_{\\mathsf{Agg}})</span>.</li>

      <li>Output <span class="math">(\\mathsf{ipk},\\mathsf{ivk})</span>.</li>

    </ol>

    <h4 id="sec-52" class="text-lg font-semibold mt-6">Prover DNA.<span class="math">\\mathcal{P}</span>.</h4>

    <p class="text-gray-300">Given oracle access to a random oracle <span class="math">\\rho</span>, and on input the proving key <span class="math">\\mathsf{ipk}</span>, the CSAT instance <span class="math">\\mathbbm{x}</span>, and the CSAT witness <span class="math">\\mathbbm{w}</span>, compute the proof <span class="math">\\pi</span> as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse the proving key as <span class="math">\\mathsf{ipk}=(\\mathbbm{i},\\mathsf{ivk},[\\mathsf{ipk}_{i}]_{i=1}^{n},\\mathsf{pk}_{\\mathsf{Agg}})</span>.</li>

      <li>Compute the memory subtraces: <span class="math">[\\mathbbm{w}^{\\prime}_{i}]_{i=1}^{n}=f_{\\mathbbm{w}_{1}}(\\mathbbm{i},\\mathbbm{x},\\mathbbm{w})</span>.</li>

      <li>For each <span class="math">i</span> in <span class="math">\\{1,\\ldots,n\\}</span>, obtain <span class="math">\\mathsf{ick}_{i}</span> from <span class="math">\\mathsf{ipk}_{i}</span> and commit to <span class="math">\\mathbbm{w}^{\\prime}_{i}</span>: <span class="math">\\mathsf{cm}_{i}\\leftarrow\\mathsf{ARG}.\\mathcal{C}(\\mathsf{ick}_{i},\\mathbbm{w}^{\\prime}_{i})</span>.</li>

      <li>Obtain <span class="math">\\mathsf{ck}_{\\mathsf{Agg}}</span> from <span class="math">\\mathsf{pk}_{\\mathsf{Agg}}</span> and commit to <span class="math">[\\mathsf{cm}_{i}]_{i=1}^{n}</span>: <span class="math">\\mathsf{cm}_{\\mathsf{Agg}}\\leftarrow\\mathsf{Agg}.\\mathcal{C}^{\\rho}(\\mathsf{ck}_{\\mathsf{Agg}},[\\mathsf{cm}_{i}]_{i=1}^{n})</span>.</li>

      <li>Compute the challenges <span class="math">(\\alpha,\\beta)=\\rho(\\mathsf{ivk},\\mathsf{cm}_{\\mathsf{Agg}})</span>.</li>

      <li>Compute instances and witnesses for subcircuits: <span class="math">(\\mathbbm{x}_{\\mathsf{Agg}},[\\mathbbm{w}_{i}]_{i=1}^{k})=f_{\\mathbbm{x},\\mathbbm{w}_{2}}(\\mathbbm{i},\\mathbbm{x},\\mathbbm{w},\\alpha,\\beta)</span>.</li>

      <li>For each <span class="math">i</span> in <span class="math">\\{1,\\ldots,n\\}</span>, compute the cc-zkSNARK proofs: <span class="math">\\pi_{i}\\leftarrow\\mathsf{ARG}.\\mathcal{P}(\\mathsf{ipk}_{i},\\mathbbm{x}_{\\mathsf{Agg}},(\\mathbbm{w}^{\\prime}_{i},\\mathbbm{w}_{i}))</span>.</li>

      <li>Parse <span class="math">\\mathbbm{x}_{\\mathsf{Agg}}</span> as <span class="math">(1,\\mathsf{rt},\\alpha,\\beta)</span>.</li>

      <li>Compute a membership proof <span class="math">\\pi_{\\mathsf{rt}}</span> asserting that the first leaf of the Merkle tree with root <span class="math">\\mathsf{rt}</span> is <span class="math">\\mathbbm{x}</span>.</li>

      <li>Assemble <span class="math">\\mathcal{R}_{\\mathsf{Agg}}</span> witness: <span class="math">\\mathbbm{w}_{\\mathsf{Agg}}:=([\\mathsf{cm}_{i}]_{i=1}^{n},[\\pi_{i}]_{i=1}^{n})</span>.</li>

      <li>Compute aggregated proof: <span class="math">\\pi_{\\mathsf{Agg}}\\leftarrow\\mathsf{Agg}.\\mathcal{P}^{\\rho}(\\mathsf{pk}_{\\mathsf{Agg}},\\mathbbm{x}_{\\mathsf{Agg}},\\mathbbm{w}_{\\mathsf{Agg}},\\mathsf{cm}_{\\mathsf{Agg}})</span>.</li>

      <li>Output <span class="math">\\pi:=(\\mathbbm{x}_{\\mathsf{Agg}},\\mathsf{cm}_{\\mathsf{Agg}},\\pi_{\\mathsf{Agg}},\\pi_{\\mathsf{rt}})</span>.</li>

    </ol>

    <h4 id="sec-53" class="text-lg font-semibold mt-6">Verifier DNA.<span class="math">\\mathcal{V}</span>.</h4>

    <p class="text-gray-300">Given oracle access to a random oracle <span class="math">\\rho</span>, and on input the verification key <span class="math">\\mathsf{ivk}</span>, the CSAT instance <span class="math">\\mathbbm{x}</span>, and the proof <span class="math">\\pi</span>, compute the verdict <span class="math">b</span> as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse the verification key as <span class="math">\\mathsf{ivk}=\\mathsf{vk}_{\\mathsf{Agg}}</span>.</li>

      <li>Parse <span class="math">\\pi</span> as <span class="math">(\\mathbbm{x}_{\\mathsf{Agg}},\\mathsf{cm}_{\\mathsf{Agg}},\\pi_{\\mathsf{Agg}},\\pi_{\\mathsf{rt}})</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\Xi_{\\mathsf{Agg}}</span> as <span class="math">(1,\\mathsf{rt},\\alpha,\\beta)</span>.</li>

      <li>Check that <span class="math">\\pi_{\\mathsf{rt}}</span> is a valid proof that <span class="math">\\Xi</span> is the first leaf of the Merkle tree with root <span class="math">\\mathsf{rt}</span>.</li>

      <li>Check that <span class="math">(\\alpha,\\beta)=\\rho(\\mathsf{vk}_{\\mathsf{Agg}},\\mathsf{cm}_{\\mathsf{Agg}})</span>.</li>

      <li>Check that <span class="math">\\mathsf{Agg}.\\mathcal{V}(\\mathsf{vk}_{\\mathsf{Agg}},\\Xi_{\\mathsf{Agg}},\\mathsf{cm}_{\\mathsf{Agg}},\\pi_{\\mathsf{Agg}})=1</span>.</li>

    </ol>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">6.2 Distributed prover workflow</h3>

    <p class="text-gray-300">We now describe at a high level the workflow for distributed proving of the foregoing zkSNARK. Proving responsibilities are split between a central <em>coordinator</em> and <em>n workers</em>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup: The coordinator generates and partitions the memory traces, and distributes the subtraces and witness shares to the respective workers.</li>

      <li>Commit: In parallel, each worker invokes <span class="math">\\mathsf{ARG}.\\mathcal{C}</span> to commit to its subtrace, and sends the resulting commitment back to the coordinator.</li>

      <li>Challenge: The coordinator aggregates the received commitments via <span class="math">\\mathsf{Agg}.\\mathcal{C}</span>, and uses the resulting commitment to derive a challenge <span class="math">r</span> which it sends to each worker.</li>

      <li>Prove: In parallel, each worker invokes <span class="math">\\mathsf{ARG}.\\mathcal{P}</span> to compute its proof <span class="math">\\pi_{i}</span> for its subcircuit, and sends the resulting proof back to the coordinator.</li>

      <li>Aggregate: The coordinator aggregates the received proofs via <span class="math">\\mathsf{Agg}.\\mathcal{P}</span> to compute the final proof <span class="math">\\pi</span>.</li>

    </ol>

    <p class="text-gray-300">Note that “Commit” and “Prove” steps above are highlighted in brown in Section 6.1.</p>

    <p class="text-gray-300">Efficiency analysis.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Per-worker running time is the cost of running <span class="math">\\mathsf{ARG}.\\mathcal{C}</span> and <span class="math">\\mathsf{ARG}.\\mathcal{P}</span> on input <span class="math">C_{i}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Per-worker communication cost is the size of a single proof and a single commitment of <span class="math">\\mathsf{ARG}</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathsf{ARG}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{CM}_{\\mathsf{ARG}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The primary node’s active compute time is dominated by the cost of running <span class="math">\\mathsf{Agg}.\\mathcal{C}</span> and <span class="math">\\mathsf{Agg}.\\mathcal{P}</span> on inputs of size <span class="math">n</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Proof size is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathsf{Agg}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{cm}_{\\mathsf{Agg}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathsf{rt}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-55" class="text-xl font-semibold mt-8">6.3 Optimizations</h3>

    <p class="text-gray-300">When the underlying ccSNARK <span class="math">\\mathsf{ARG}</span> relies on circuit-specific setup, it is not clear how to obtain an SRS that grows only with the number of unique subcircuits because the construction in Section 6.1 creates subcircuits which have hardcoded in them the subcircuit number as well as the indices of the accessed shared wires. Since the latter are unique to each subcircuit, the SRS size would grow with the number of subcircuits.</p>

    <p class="text-gray-300">To address this, we can modify the construction in Section 6.1 via the following optimization: instead of hardcoding the aforementioned values, we will instead provide these as <em>public input</em> to each subcircuit; since these values are known at setup time, the computations required for this public input handling can also be done during setup. This would ensure that we only need to perform one setup per unique subcircuit independent of how it is wired with respect to other subcircuits or how it is numbered. We provide details next. Assuming each subcircuit takes at most <span class="math">u</span> public inputs, they can be preprocessed in <span class="math">\\mathsf{Agg}.\\mathcal{G}</span> as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all <span class="math">i\\in[n]</span> parse <span class="math">\\mathsf{ivk}_{i}</span> as <span class="math">(e([\\alpha]_{1},[\\beta]_{2}),[\\gamma_{i}]_{2},[\\delta_{i}]_{2},[\\eta_{i}]_{2},</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\left\\{[p_{i,j}(s)/\\gamma_{i}]_{1}\\right\\}_{j=1}^{u})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i\\in[n]</span> let the <span class="math">i</span>-th subcircuits public inputs be <span class="math">(1,\\mathsf{rt},\\alpha,\\beta</span>,</li>

    </ol>

    <p class="text-gray-300"><span class="math">v_{i,5},\\ldots,v_{i,u})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">j</span> in <span class="math">\\{5,6,\\ldots,u\\}</span>, multiply the <span class="math">\\mathbb{G}_{1}</span> elements of <span class="math">(\\mathsf{ivk}_{i})_{i=1}^{n}</span> corresponding to public inputs with the appropriate coeffecients to obtain <span class="math">\\bm{S}_{j}:=(v_{1,j}\\cdot[p_{1,j}(s)/\\gamma_{1}]_{1},\\ldots,v_{n,j}\\cdot[p_{n,j}(s)/\\gamma_{n}]_{1})</span>.</li>

      <li>Replace <span class="math">\\bm{S}_{1}</span> with <span class="math">\\bm{\\hat{S}}:=\\bm{S}_{1}+\\sum_{j=5}^{u}\\bm{S}_{j}</span>.</li>

    </ol>

    <p class="text-gray-300">###</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Replace <span class="math">\\mathsf{cm}_{S_1}^1</span> with a commitment to <span class="math">\\bar{\\boldsymbol{S}}</span>: <span class="math">\\mathsf{cm}_S^1\\gets \\mathsf{CM}_1.\\mathsf{Commit}(\\mathsf{ck}_D,\\bar{\\boldsymbol{S}})</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">\\mathsf{vk}_{\\mathrm{Agg}} := (\\mathsf{vk}_{\\mathrm{MPP}}, \\mathsf{cm}_S^1, \\mathsf{cm}_{S_2}^1, \\mathsf{cm}_{S_3}^1, \\mathsf{cm}_{S_4}^1, \\mathsf{cm}_{\\gamma}^2, \\mathsf{cm}_{\\delta}^2, \\mathsf{cm}_{\\eta}^2)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">\\mathsf{pk}_{\\mathrm{Agg}} := (\\mathsf{pk}_{\\mathrm{MPP}}, \\mathsf{ck}_{\\mathrm{Agg}}, \\mathsf{vk}_{\\mathrm{Agg}}, \\bar{\\boldsymbol{S}}, \\boldsymbol{S}_2, \\boldsymbol{S}_3, \\boldsymbol{S}_4, \\boldsymbol{\\gamma}, \\bar{\\boldsymbol{\\delta}}, \\boldsymbol{\\eta})</span>.</li>

    </ol>

    <p class="text-gray-300">Now in <span class="math">\\mathrm{Agg}.\\mathcal{P}</span> and <span class="math">\\mathrm{Agg}.\\mathcal{V}</span> we can:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute public input vector <span class="math">\\boldsymbol{S} = \\bar{\\boldsymbol{S}} + \\mathrm{rt} \\cdot \\boldsymbol{S}_2 + \\alpha \\cdot \\boldsymbol{S}_3 + \\beta \\cdot \\boldsymbol{S}_4</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute public input commitment <span class="math">\\mathsf{cm}_S^1 \\coloneqq (\\mathsf{cm}_S^1) \\cdot (\\mathsf{cm}_{S_2}^1)^{\\mathrm{rt}} \\cdot (\\mathsf{cm}_{S_3}^1)^\\alpha \\cdot (\\mathsf{cm}_{S_4}^1)^\\beta</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We can then proceed by using <span class="math">\\boldsymbol{S}</span> and <span class="math">\\mathsf{cm}_S^1</span> as usual.</li>

    </ol>

    <p class="text-gray-300">28</p>

    <p class="text-gray-300">7 Implementation</p>

    <p class="text-gray-300">We implemented Hekaton in 5400 lines of Rust code using the arkworks framework <em>[x1]</em>. Our library implements: (1) a generic API to describe partitionable circuits with shared wires, (2) an implementation of the Mirage cc-zkSNARK, (3) the aggregation scheme for Mirage described in Section 5, (4) an OpenMPI implementation of coordinator and worker nodes for distributed proving described below, and (5) implementations of the applications described in Section 1 atop Hekaton. Our code will be open-sourced shortly.</p>

    <p class="text-gray-300">Design choices for distributed proving. Our library is cluster-agnostic and highly configurable. Due to space constraints, we defer further discussion of design decisions to Appendix A.</p>

    <p class="text-gray-300">We use the OpenMPI message passing framework for communication, and SLURM for job orchestration. We implement our system using two rounds of MPI scatter-gather: one for the Commit phase and one for the Proving phase. Our system is highly configurable: each MPI node has multiple threads to run tasks, and the number of nodes, threads per node, and memory per thread is configurable at runtime.</p>

    <p class="text-gray-300">8 Evaluation</p>

    <p class="text-gray-300">In this section we evaluate the performance of our built system Hekaton via a set of scalability experiments (Section 8.2) and via two applications: verifiable key directories (Section 8.3) and verifiable RAM computation (Section 8.4). Overall, our experiments suggest that Hekaton indeed achieves its goal of horizontal scalability, and furthermore, improves upon existing solutions for the aforementioned applications.</p>

    <h3 id="sec-56" class="text-xl font-semibold mt-8">8.1 Experimental setup</h3>

    <h5 id="sec-57" class="text-base font-semibold mt-4">Hardware.</h5>

    <p class="text-gray-300">Our experiments are run on a large multi-tenant HPC cluster. The cluster consists of nodes with AMD EPYC 7763 processors with 128 cores and 512GB of RAM. The cluster costs <span class="math">0.00232 per core-hour. (For comparison, on-demand pricing for the equivalent AWS instance (m6a.32xlarge) is </span>0.0432 per core-hour).</p>

    <h5 id="sec-58" class="text-base font-semibold mt-4">Circuit choice.</h5>

    <p class="text-gray-300">For most zkSNARKs, prover performance is independent of the circuit structure. This is true for Mirage, and so should also hold (modulo shared wires) for Hekaton. We want a circuit that, when partitioned into subcircuits, exercises the full features of Hekaton, yielding heterogeneous subcircuits and shared wires. We generate 5 distinct subcircuits, each with a tunable number of shared wires between them and an adjustable number of constraints. This adjustability is necessary both for benchmarking, and also for prototyping and performance tuning early iterations of Hekaton. We define the larger circuit as a power-of-two number of subcircuits.</p>

    <h5 id="sec-59" class="text-base font-semibold mt-4">Shared wire costs are low.</h5>

    <p class="text-gray-300">We find that shared wires cost 13 constraints each. At the scale we aim for, this adds a negligible overhead to the cost of subcircuit proving. Indeed, for any reasonable computation, the additional cost of handling shared wires is negligible compared the cost of the core computation. For our end-to-end experiments, we arbitrarily fix the proportion of constraints that come from shared wires to 10%.</p>

    <h5 id="sec-60" class="text-base font-semibold mt-4">Parameters for distributed proving.</h5>

    <p class="text-gray-300">As described in Section 7, Hekaton’s distributed prover is highly configurable. To determine an appropriate configuration for our cluster, we ran preliminary experiments which confirmed our intuition to allocate each subcircuit its own core (this avoids diminishing returns of multithreading subcircuit proof generation). Further exploration indicated that, accounting for miscellaneous memory overhead, we could not reliably exceed 3.5GB of memory for the prover. This translates to proving a 1.3 million constraint subcircuit. For our distributed experiments, we fix this as the subcircuit size and vary total circuit size by adding subcircuits.</p>

    <p class="text-gray-300">We found that a configuration where each MPI node runs 32 provers, each equipped with one core and 4GB of memory, was the optimal setting for our workload.</p>

    <h3 id="sec-61" class="text-xl font-semibold mt-8">8.2 Scaling experiments</h3>

    <p class="text-gray-300">Figure 7 plots latency and throughput for Hekaton, for a varying number of cores, as the size of the circuit increases. We stress that, in a departure from previous work <em>[x28, x16]</em>, the numbers are <em>end-to-end</em>, counting the full cost of pre-positioning data, serialization and deserialization, data transmission, and computation.</p>

    <h5 id="sec-62" class="text-base font-semibold mt-4">Prover latency and throughput.</h5>

    <p class="text-gray-300">Both latency and throughput scale well. As shown in the latency graph, Figure 7(a), workers appear to initially starve, having insufficient work to achieve full utilization. However, after initial starvation, latency stabilizes. The throughput in Figure 7(b) follows the same pattern.</p>

    <p class="text-gray-300">For an ideal system, we would expect end-to-end latency to scale linearly; doubling the circuit size should double the runtime Indeed this is the largely case: of all the plots in Figure 7(a), the worst fitting simple linear</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Figure 7: HEKATON proving performance for a fixed set of cores as total circuit size increases.</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a></p>

    <p class="text-gray-300">regression line is a  <span class="math">98.58\\%</span>  fit.4</p>

    <p class="text-gray-300">Communication costs. We report the communication costs per subcircuit in Table 2. The largest overhead is less than 1MB per subcircuit. As expected, commit and proving phase responses sizes do not vary with any circuit parameters. Commit phase request sizes do not vary with number of circuits.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Number of subcircuits</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Commit phase</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proving phase</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">request</td>

            <td class="px-3 py-2 border-b border-gray-700">response</td>

            <td class="px-3 py-2 border-b border-gray-700">request</td>

            <td class="px-3 py-2 border-b border-gray-700">response</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">↑</td>

            <td class="px-3 py-2 border-b border-gray-700">↑</td>

            <td class="px-3 py-2 border-b border-gray-700">577B</td>

            <td class="px-3 py-2 border-b border-gray-700">↑</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">211</td>

            <td class="px-3 py-2 border-b border-gray-700">923kB</td>

            <td class="px-3 py-2 border-b border-gray-700">136B</td>

            <td class="px-3 py-2 border-b border-gray-700">673B</td>

            <td class="px-3 py-2 border-b border-gray-700">496B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">214</td>

            <td class="px-3 py-2 border-b border-gray-700">↓</td>

            <td class="px-3 py-2 border-b border-gray-700">↓</td>

            <td class="px-3 py-2 border-b border-gray-700">769B</td>

            <td class="px-3 py-2 border-b border-gray-700">↓</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Maximum communication costs per subcircuit for each round of HEKATON.</p>

    <p class="text-gray-300">Proof size and verification time. Proofs size and verifier time grow logarithmically. Concretely, in our largest test at  <span class="math">2^{18}</span>  subcircuits, proofs are  <span class="math">32\\mathrm{kB}</span>  and take  <span class="math">83\\mathrm{ms}</span>  to verify. We did not attempt to optimize the latter cost, but expect that it can be reduced greatly.</p>

    <p class="text-gray-300">Aggregation times. We report aggregation times in Fig. 8. As expected, aggregation time grows linearly with number of subcircuits, topping out at  <span class="math">\\approx 100100</span>  s for  <span class="math">2^{16}</span>  subcircuits. While this is non-trivial, we expect that the aggregation itself can be distributed across multiple nodes. We leave this task to future work.</p>

    <p class="text-gray-300">Overhead relative to existing provers. Recall that HEKATON is modular, using an existing monolithic inner cc-zkSNARK ARG to prove subcircuits. We now investigate the overhead added by HEKATON relative to ARG (which in the experiments is Mirage).</p>

    <p class="text-gray-300">Overhead comes from two sources, First, for every subcircuit, HEKATON adds extra constraints for shared wires that are not needed in a single monolithic prover. Second, HEKATON imposes overhead for the additional machinery for the commit-carrying aggregation scheme and extra communication.</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Figure 8: Time to aggregate subcircuit proofs. Note that our experimental measurements are end-to-end, meaning that they include aggregation time.</p>

    <p class="text-gray-300">To measure total overhead, we compare normalized throughput in constraints per core-second (cpcs) of a monolithic Mirage prover versus HEKATON. To set the baseline maximum normalized throughput, we run the monolithic prover using just 1 thread. This operates at 38kcps. For comparison, HEKATON achieves 34kcps (90% baseline) at 4 threads.</p>

    <p class="text-gray-300">We now look at how this overhead scales when we add more compute cores. For context, the normalized throughput for a perfectly parallelizable problem would be identical regardless of the number of cores. When we scale up our baseline monolithic Groth16 prover by  <span class="math">32 \\times</span> , the normalized throughput drops dramatically to 1.2kcps (5% of the baseline). Meanwhile, when we scale up HEKATON by  <span class="math">32 \\times</span> , the normalized throughput drops to 33kcps (87% baseline). When we scale again by  <span class="math">32 \\times</span> , it drops to 12kcps (64% baseline). This is promising: HEKATON is able to utilize its additional resources much more effectively than the monolithic prover.</p>

    <p class="text-gray-300">Comparison to Pianist. As noted in Section 1.2, the most closely related prior work to ours is Pianist [LXZSZ24], and so we tried to benchmark their implementation on our cluster. Unfortunately, despite significant effort, we were unable to get their implementation to run stably on our cluster for circuit sizes larger than  <span class="math">2^{21}</span>  constraints, or with more than 2 worker nodes. The numbers that we did obtain, however, are in line with the numbers reported in Pianist.</p>

    <p class="text-gray-300">For example, the running time of Pianist when trying to prove  <span class="math">2^{21}</span>  constraints with 128 cores, each with 4GB of memory, is the same in our setup as in theirs, at around 9.3s. This allows us to perform a rough extrapolated comparison of the performance of the two systems, which we do next.</p>

    <p class="text-gray-300">Pianist reports a runtime of 1 second for a circuit of size  <span class="math">2^{22}</span>  and, for their largest measured circuit, sub-10s runtimes for  <span class="math">2^{25}</span>  constraints. Both of these are on 2048 cores, the most powerful hardware configuration they benchmark for general circuits. In contrast, the smallest circuit size we benchmark  <span class="math">(2^{27})</span>  takes 11.6s to prove on 2048 cores in the same configuration. Extrapolating Pianist's numbers to this many constraints indicates that HEKATON is able to achieve  <span class="math">\\approx 3\\times</span>  lower latency.</p>

    <p class="text-gray-300">This gap is despite a couple of factors in Pianist's favor. First, Pianist uses the BN254 curve, which is faster than BLS12-381 used by HEKATON, but has worse security, estimated to be 100 bits [BD19]. Updating Pianist to use the latter curve would likely lead to a further slowdown in their reported numbers.</p>

    <p class="text-gray-300">Second, Pianist's circuit sizes are for Plonk constraints [GWC19]. Liu et al. [LXZSZ24] themselves</p>

    <p class="text-gray-300">report that equivalent R1CS circuits would be <span class="math">\\approx 7</span> times smaller, meaning that the effective number of constraints proved by Pianist in a given time is <span class="math">\\approx 7</span> times smaller than that proved by Hekaton. (However, keep in mind that optimized circuits and custom Plonk gates might reduce this overhead.)</p>

    <p class="text-gray-300">Overall, these factors combine to indicate that Hekaton is able to achieve better performance in practice.</p>

    <h3 id="sec-63" class="text-xl font-semibold mt-8">8.3 Application: verifiable key directories</h3>

    <p class="text-gray-300">A Verifiable Key Directory (VKD) <em>[x18, x10]</em> is a primitive that allows clients to monitor a key-value mapping maintained by an untrusted server that a service is distributing on their behalf. VKDs are commonly used to maintain public key registries for end-to-end encrypted messaging services <em>[x12, x14]</em> in a way that prevents the server from tampering with the registry by changing users’ public keys undetectably.</p>

    <p class="text-gray-300">In a VKD, the server maintains a mapping from a client-specific identifier <span class="math">k</span> to a tuple <span class="math">(i,v)</span>, where <span class="math">i</span> is a <em>version number</em> recording the number of times this entry has been updated, and <span class="math">v</span> is the current value. A client can request the server to either insert a new key-value pair <span class="math">(k,(0,v))</span>, or to update an existing key <span class="math">k</span> to a new value <span class="math">v^{\\prime}</span> while incrementing the version number. This mapping is committed inside a Merkle tree, and both operations come with “proofs” that the server has indeed performed the requested operation correctly. Periodically at each epoch <span class="math">t</span>, the server signs and publishes a digest <span class="math">d_{t}</span> corresponding to the current state of the tree.</p>

    <p class="text-gray-300">To verify the integrity of its stored value, a client can request from the server a proof attesting that the value <span class="math">v</span> is indeed the one committed in the latest published digest <span class="math">d_{t}</span>. Existing VKDs use this mechanism to allow clients to audit the integrity of their mappings over time: they can request proofs for the value of their key at different epochs, and verify that the server has not tampered with their key-value mapping. Unfortunately, this mechanism is not scalable: if the client goes offline between epochs <span class="math">t</span> and <span class="math">t^{\\prime}</span> that are far apart, they would need to download and verify all intervening digests and proofs to ensure integrity.</p>

    <p class="text-gray-300">Baseline approach. Recent work <em>[x23]</em> proposes to improve the efficiency of this process via <em>invariant proofs</em>. Roughly, such a proof would assert that if at any point between <span class="math">t</span> and <span class="math">t^{\\prime}</span> the server updated the value of <span class="math">k</span>, then the server must have also incremented the version number. Now, if version numbers <span class="math">i_{t}</span> and <span class="math">i_{t^{\\prime}}</span> are equal, then the invariant proof guarantees that the value <span class="math">v</span> was unchanged between epochs <span class="math">t</span> and <span class="math">t^{\\prime}</span>.</p>

    <p class="text-gray-300">Tyagi et al. <em>[x23]</em> construct constant-sized invariant proofs by replacing Merkle trees with RSA-based authenticated dictionaries, and using SNARKs to prove the preservation of the invariant. Unfortunately, their reliance on RSA accumulators makes them incompatible with existing systems that already use Merkle tree based registries.</p>

    <p class="text-gray-300">Our approach. We leverage Hekaton to provide invariant proofs for existing registries by proving that all operations performed by the server on the key-value mapping preserve the versioning invariant and correctly update the Merkle tree.</p>

    <p class="text-gray-300">In more detail, we consider a VKD with a SHA-256-based Merkle tree of depth 128. Our circuit verifies a batch of update operations on the VKD, each of which requires incrementing the user’s version number and checking two Merkle paths. Because the task of checking even a single Merkle path is too onerous for a single subcircuit, we partition each path check into four subcircuits. Each subcircuit passes its intermediate computation to the next, until the root is computed and checked against the expected root.</p>

    <p class="text-gray-300">Experimental comparison. We measure total proving latency as we increase the size of the batch of VKD updates. We use 4096 cores, with the same core allocation as in the previous section. Each subcircuit is</p>

    <p class="text-gray-300">2.4M constraints. Prover performance is illustrated in Fig. 9; observe that prover throughput increases as we increase the batch size.</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> Figure 9: End-to-end runtime for proving batches of updates in a Merkle-tree-based VKD; the x-axis indicates the batch size.</p>

    <p class="text-gray-300">Numerous applications are most easily and efficiently expressed as RAM computations. As a result, much industrial and academic effort has been invested in constructing efficient "zkVMs" that can verify the correctness of RAM computations [BCGTV13; BCTV14b; ZGKPP18; Sta21; AST24]. In this section, we show that HEKATON can scale to prove such RAM computations very efficiently, focusing on the TinyRAM instruction set.</p>

    <p class="text-gray-300">Circuit construction. Our circuit consists of repeated CPU "cycle" circuits. Each of the latter contains two modules: an ALU that executes TinyRAM instructions, and a memory checker that verifies memory accesses. We instantiate the ALU module with dummy constraints that do not actually execute TinyRAM instructions, but whose cost equals that of a real ALU. The resulting dummy ALU module costs roughly 1,114 constraints (we obtained this number from the breakdown in [BCTV14b, Figure 7]).</p>

    <p class="text-gray-300">We instantiate the memory checking module in two ways. The first constitutes our baseline approach that uses online memory checking via Merkle trees. Indeed, as discussed in Section 2.1.1, prior to our work, this was the only way to verify memory accesses in a distributed setting. We use a Merkle tree of depth 32 with the Poseidon hash function (concretely, two Merkle path verifications).</p>

    <p class="text-gray-300">The second instantiation is obtained by adapting our permutation-based memory checker to the read-write setting in a standard way [BCTV14b]. This adaptation does not fundamentally change any asymptotic costs, and only increases the cost of the local checks by a constant factor.</p>

    <p class="text-gray-300">Again, we use 4096 cores, with the same core allocation as in the previous section. Each Merkle-backed subcircuit is 2.4M constraints, and each shared wire-backed subcircuit is 1.6M constraints.</p>

    <p class="text-gray-300">Experimental comparison. The performance of the two approaches is illustrated in Fig. 10. It can be clearly seen that the permutation-based memory checker offers much higher throughput (in terms of cycles per second) than the Merkle tree-based memory checker.</p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Figure 10: Comparison of end-to-end runtime for proving a TinyRAM computation using a Merkle tree-based memory checker versus a permutation-based memory checker.</p>

    <p class="text-gray-300">Acknowledgements</p>

    <p class="text-gray-300">We thank Aakash Dutt for contributions to an early stage of our implementation.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">A Design choices and cluster architecture</p>

    <p class="text-gray-300">There are many choices for using a cluster for the above fan-out/fan-in approach. Below we consider the design choices.</p>

    <p class="text-gray-300">Breaking down the job. Firstly, we must define precisely what a worker does. In the SLURM clustering architecture, a job (a complete end-to-end computation) is broken up into multiple tasks. Each task can be thought of an individual process, with access to some number of threads, in communication with the other tasks, which possibly reside on the same node (physical machine) or other nodes. For Hekaton, a worker task could reasonably be a single-threaded or multi-threaded process which proves one subcircuit or many subcircuits. After experimentation, we found it is most efficient to have a worker task be a multithreaded process, which batch executes a many (specifically 32) single-threaded provers. For a fixed number of subcircuits, it is more efficient to have many single-threaded provers than few multi-threaded provers because of the sublinear speedup conferred by adding threads to proving.</p>

    <p class="text-gray-300">Scheduling. Beyond the structure of tasks, there is also the choice of scheduling of tasks. Two options here are a work-stealing queue, wherein workers ingests subcircuit proof requests as threads open up, or fixed allocation, wherein every worker is given its set of proof requests in advance, and it must work through all of them. There are meaningful tradeoffs in both cases. A work-stealing queue is an adaptive strategy, and thus optimal in a theoretic sense because it avoids over- or under-utilization due to environmental conditions of the cluster. On the other hand, this method requires a large amount of coordination in the form of a literal queue, which must be available and highly responsive to every worker performing the job. The fixed allocation method is suboptimal from a utilization perspective, since you may have workers which complete all their requests while other workers still have many remaining. On the other hand, far less coordination is required, as there is no queue to maintain. For simplicity in our implementation, we choose the fixed array allocation. But we leave the queue method as an interesting avenue for future optimizations.</p>

    <p class="text-gray-300">Our final note on scheduling: rather than bringing up <span class="math">N</span> workers for committing, tearing them down, and bringing up <span class="math">N</span> workers for proving, we simply bring them up once and use them for both committing and proving. Again, this is not perfectly optimal in terms of utilization, since some workers may be idle while stragglers finish their work. But we avoid an extra set of setup and teardown costs for our job. In addition, it simplifies our deployment, as our entire worker job is encapsulated by a single binary, which we execute via mpirun on our cluster.</p>

    <p class="text-gray-300">Communication channels. Communication in a cluster can operate one of two ways: via MPI channels for small, low-latency transfers; and via the cluster filesystem (BeeGFS) for large, high-bandwidth transfers. The largest single piece of data in our experiments is the bundle of Groth16 proving keys, which reaches up to 5GB. Since this data must be precomputed in order for the protocol to run, it must exist in nonvolatile storage anyway. From experimentation, we found that the optimal data loading procedure is to have the coordinator load the proving keys from the filesystem, and use MPI for all further communications, including sending workers the proving key bundle.</p>

    <h2 id="sec-65" class="text-2xl font-bold">Appendix B Additional definitions and lemmas</h2>

    <p class="text-gray-300">We now recall formal definitions and lemmas that we will use in our proofs and algorithm descriptions in subsequent appendices.</p>

    <p class="text-gray-300">We recall a simplification of a useful lemma from [BCMS20; BCLMS21] that bounds the probability that applying a random oracle to a commitment to a polynomial yields a root of the polynomial.</p>

    <p class="text-gray-300">Lemma B.1. Let  <span class="math">\\mathsf{CM} = (\\mathsf{Setup},\\mathsf{Commit})</span>  be a commitment scheme for a message space universe  <span class="math">\\{\\mathcal{M}_i\\}_{i\\in \\mathbb{N}}</span> . Let  <span class="math">\\mathbb{F}</span>  be a finite field,  <span class="math">M\\in \\mathbb{N}</span>  a number of variables, and  <span class="math">D\\in \\mathbb{N}</span>  a total degree bound. Then, for large enough message size  <span class="math">i\\in \\mathbb{N}</span> , every family of (possibly inefficient) functions  <span class="math">\\{f\\colon \\mathcal{M}_i\\to \\mathbb{F}^{\\leq D}[X_1,\\ldots ,X_M]\\}</span>  mapping messages to polynomials of degree at most  <span class="math">D</span>  over  <span class="math">\\mathbb{F}</span> , and every  <span class="math">t</span> -query oracle algorithm  <span class="math">\\mathcal{A}</span>  that runs in expected polynomial time, the following holds:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname * {P r} \\left[ \\begin{array}{c c} &amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ p \\not \\equiv 0 &amp; \\mathrm {c k} \\leftarrow \\mathrm {C M . S e t u p} (1 ^ {\\lambda}, \\mathcal {M} _ {i}) \\\\ \\wedge &amp; (\\mathfrak {p} \\in \\mathcal {M} _ {i}, r) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathrm {c k}) \\\\ p (z) = 0 &amp; C \\leftarrow \\mathrm {C M . C o m m i t} (\\mathrm {c k}, \\mathfrak {p}; r) \\\\ &amp; z \\in \\mathbb {F} ^ {M} \\leftarrow \\rho (C) \\\\ &amp; p \\leftarrow f (\\mathfrak {p}) \\end{array} \\right] \\leq \\sqrt {(t + 1) \\cdot \\frac {M D}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}} + \\operatorname {n e g l} (\\lambda) .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">If CM is perfectly binding, then the above holds also for computationally-unbounded  <span class="math">t</span> -query adversaries  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300">We now prove Theorem 6.1 which asserts that the protocol DNA in Section 6.1 satisfies the completeness and knowledge soundness properties. We assume that a partitioning of the circuit is provided during setup and proving.</p>

    <p class="text-gray-300">Completeness follows from the completeness of  <span class="math">f</span> , ARG and Agg. To see this, we first recall the following definitions.</p>

    <p class="text-gray-300">The completeness of  <span class="math">f = (f_{\\hat{\\mathbf{s}}}, f_{\\mathrm{w}_1}, f_{\\mathrm{x}, \\mathrm{w}_2})</span>  defined in Section 4 gives that for all  <span class="math">\\alpha, \\beta \\in \\mathbb{F}</span>  and  <span class="math">(\\dot{\\mathbf{s}}, \\mathbf{x}, \\mathbf{w}) \\in k</span> -CSAT, on input  <span class="math">(\\dot{\\mathbf{s}}, \\mathbf{x}, \\mathbf{w}, \\alpha, \\beta)</span> ,  <span class="math">f</span>  outputs  <span class="math">([\\dot{\\mathbf{s}}_i]_{i=1}^n, \\mathbf{x}&#x27;, [\\mathbf{w}_{i,1}]_{i=1}^n, [\\mathbf{w}_{i,2}]_{i=1}^n)</span> , such that  <span class="math">(\\dot{\\mathbf{s}}_i, \\mathbf{x}&#x27;, (\\mathbf{w}_{i,1}, \\mathbf{w}_{i,2})) \\in \\mathrm{CSAT}</span>  for all  <span class="math">i \\in [n]</span>  and  <span class="math">\\mathbf{x}</span>  is the 0-th leaf of rt.</p>

    <p class="text-gray-300">The completeness of Agg gives that for every index  <span class="math">\\dot{\\mathbf{s}}_{\\mathrm{Agg}}</span>  and every adversary  <span class="math">\\mathcal{B}</span> , the following probability is 1.</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ (\\dot {\\mathrm {s}} _ {\\mathrm {A g g}}, \\mathrm {x} _ {\\mathrm {A g g}}, \\mathrm {w} _ {\\mathrm {A g g}}) \\notin \\mathcal {R} _ {\\mathrm {A g g}} &amp;amp; (\\mathrm {p k} _ {\\mathrm {A g g}}, \\mathrm {c h} _ {\\mathrm {A g g}}, \\mathrm {w} _ {\\mathrm {A g g}}) \\leftarrow \\mathcal {B} ^ {\\rho} (\\mathrm {p k} _ {\\mathrm {A g g}}) \\\\ \\vee &amp;amp; \\mathrm {c m} _ {\\mathrm {A g g}} \\leftarrow \\mathrm {A g g}. \\mathcal {C} ^ {\\rho} (\\mathrm {c h} _ {\\mathrm {A g g}}, (\\mathrm {w} _ {\\mathrm {A g g}}) _ {1}) \\\\ \\mathrm {A g g}. \\mathcal {V} ^ {\\rho} (\\mathrm {v k} _ {\\mathrm {A g g}}, \\mathrm {x} _ {\\mathrm {A g g}}, \\mathrm {c m} _ {\\mathrm {A g g}}, \\pi_ {\\mathrm {A g g}}) = 1 &amp;amp; \\pi_ {\\mathrm {A g g}} \\leftarrow \\\\ &amp;amp; \\mathrm {A g g}. \\mathcal {P} ^ {\\rho} (\\mathrm {p k} _ {\\mathrm {A g g}}, \\mathrm {x} _ {\\mathrm {A g g}}, \\mathrm {w} _ {\\mathrm {A g g}}) \\end{array} \\right]</span></div>

    <p class="text-gray-300">The completeness of ARG gives that, for every set of indices  <span class="math">[\\dot{\\mathbf{s}}_i]_{i = 1}^n</span>  and every adversary  <span class="math">\\mathcal{C}</span> , the following probability is 1.</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ (\\dot {s} _ {i}, \\mathbf {x} _ {i}, \\mathbf {w} _ {i}) \\in \\mathcal {R} &amp;amp; ([ \\mathrm {i p k} _ {i} ] _ {i = 1} ^ {n}, [ \\mathrm {i c k} _ {i} ] _ {i = 1} ^ {n}) \\leftarrow \\\\ \\Downarrow &amp;amp; \\mathrm {A R G}. \\mathcal {V} ^ {\\rho} (\\mathrm {i v k} _ {i}, \\mathbf {x} _ {i}, \\mathbf {c m} _ {i}, \\pi_ {i}) = 1) \\\\ &amp;amp; \\forall i \\in [ n ]: \\end{array} \\right] \\left( \\begin{array}{c} (\\mathrm {i p k} _ {i}) _ {i = 1} ^ {n}, [ \\mathrm {i c k} _ {i} ] _ {i = 1} ^ {n}, [ \\mathrm {i v k} _ {i} ] _ {i = 1} ^ {n}) \\leftarrow \\\\ \\mathrm {A R G}. \\mathcal {G} ^ {\\rho} (1 ^ {\\lambda}, [ \\dot {\\mathrm {s}} _ {i} ] _ {i = 1} ^ {n}) \\\\ ([ \\mathrm {x} _ {i} ] _ {i = 1} ^ {n}, [ \\mathrm {w} _ {i} ] _ {i = 1} ^ {n}) \\leftarrow \\\\ \\mathcal {C} ^ {\\rho} ([ \\mathrm {i p k} _ {i} ] _ {i = 1} ^ {n}) \\\\ \\forall i \\in [ n ]: \\mathrm {c m} _ {i} \\leftarrow \\\\ \\mathrm {A R G}. \\mathcal {C} ^ {\\rho} (\\mathrm {i c k} _ {i}, \\mathrm {w} _ {i, 1}) \\\\ \\forall i \\in [ n ]: \\pi_ {i} \\leftarrow \\\\ \\mathrm {A R G}. \\mathcal {P} ^ {\\rho} (\\mathrm {i p k} _ {i}, \\mathrm {x} _ {i}, \\mathrm {w} _ {i}) \\end{array} \\right)</span></div>

    <p class="text-gray-300">Construction of adversaries. Given an index  <span class="math">\\dot{\\mathbf{s}}</span>  and an adversary  <span class="math">\\mathcal{A}</span>  for DNA, we can define  <span class="math">\\dot{\\mathbf{s}}_{\\mathrm{Agg}}</span>  and  <span class="math">\\mathcal{B}</span>  for Agg, and  <span class="math">[\\dot{\\mathbf{s}}_i]_{i=1}^n</span>  and  <span class="math">\\mathcal{C}</span>  for ARG as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Obtain the partitioned indices  <span class="math">[\\dot{\\mathbf{s}}_i]_{i = 1}^n\\gets f_{\\dot{\\mathbf{s}}}(\\dot{\\mathbf{s}})</span></li>

      <li>Sample ARG public parameters:  <span class="math">([\\mathrm{ipk}_i]_{i = 1}^n, [\\mathrm{ick}_i]_{i = 1}^n, [\\mathrm{ivk}_i]_{i = 1}^n) \\gets \\mathsf{ARG}.G^\\rho(1^\\lambda, [\\dot{\\mathbf{s}}_i]_{i = 1}^n)</span> .</li>

      <li>Set  <span class="math">\\dot{\\mathbf{s}}_{\\mathrm{Agg}} := [\\mathrm{ivk}_i]_{i=1}^n</span> .</li>

    </ol>

    <p class="text-gray-300">If  <span class="math">\\mathcal{A}(\\mathrm{ipk})</span>  outputs  <span class="math">(\\mathbf{x},\\mathbf{w})</span> , do the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Partition  <span class="math">\\mathbf{w}</span>  to obtain the subcircuit witnesses to be committed to:  <span class="math">[\\mathbf{w}_{i,1}]_{i = 1}^{n}\\gets f_{\\mathrm{w}_{1}}(\\dot{\\mathbf{s}},\\mathbf{x},\\mathbf{w})</span></li>

      <li>For each  <span class="math">i</span>  in  <span class="math">\\{1,\\dots ,n\\}</span>  , commit to  <span class="math">\\mathbf{w}_{i,1}</span>  ..  <span class="math">\\mathsf{cm}_i\\gets \\mathsf{ARG}.C(\\mathsf{ick}_i,\\mathsf{w}_{i,1})</span></li>

      <li>Commit to  <span class="math">[\\mathsf{cm}_i]_{i = 1}^n</span>  ..  <span class="math">\\mathsf{cm}_{\\mathrm{Agg}}\\gets \\mathsf{Agg}.C^{\\rho}(\\mathsf{ck}_{\\mathrm{Agg}},[\\mathsf{cm}_i]_{i = 1}^n)</span></li>

      <li>Compute the challenge  <span class="math">(\\alpha, \\beta) \\coloneqq \\rho(\\mathsf{vk}_{\\mathrm{Agg}}, \\mathsf{cm}_{\\mathrm{Agg}})</span> .</li>

      <li>Obtain the witnesses that depend on the committed witnesses:  <span class="math">(\\mathbf{x}_{\\mathrm{Agg}},[\\mathbf{w}_{i,2}]_{i = 1}^{n})\\gets f_{\\mathbf{x},\\mathbf{w}_2}(\\dot{\\mathbf{s}},\\mathbf{x},\\mathbf{w},\\alpha ,\\beta)</span></li>

      <li>For each  <span class="math">i</span>  in  <span class="math">\\{1,\\dots ,n\\}</span>  , compute the cc-SNARK Proofs:  <span class="math">\\pi_i\\gets \\mathsf{ARG}.P(\\mathsf{ipk}_i,\\mathbf{x}_{\\mathrm{Agg}},(\\mathbf{w}_i&#x27;,\\mathbf{w}_i))</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\mathbb{W}_{\\mathrm{Agg}} := ([cm_i]_{i=1}^n, [\\pi_i]_{i=1}^n)</span> .</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span>  outputs  <span class="math">(\\mathbb{x}_{\\mathrm{Agg}},\\mathbb{w}_{\\mathrm{Agg}})</span>  and  <span class="math">\\mathcal{C}</span>  outputs  <span class="math">(\\mathbb{x}_{\\mathrm{Agg}},\\mathbb{w}_i)</span> .</p>

    <p class="text-gray-300">Completeness analysis. We now show that for every index  <span class="math">\\dot{\\mathbf{x}}</span>  and every adversary  <span class="math">\\mathcal{A}</span> , the following probability is 1.</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} (\\dot {\\mathrm {x}}, \\mathrm {x}, \\mathrm {w}) \\notin \\mathcal {R} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\vee &amp;amp; (\\mathrm {i p k}, \\mathrm {i c k}, \\mathrm {i v k}) \\leftarrow \\mathrm {D N A}. \\mathcal {G} ^ {\\rho} (1 ^ {\\lambda}, \\dot {\\mathrm {x}}) \\\\ \\mathrm {D N A}. \\mathcal {V} ^ {\\rho} (\\mathrm {i v k}, \\mathrm {x}, \\mathrm {c m}, \\pi) = 1 &amp;amp; (\\mathrm {x}, \\mathrm {w}) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathrm {i p k}) \\\\ &amp;amp; \\pi \\leftarrow \\mathrm {D N A}. \\mathcal {P} ^ {\\rho} (\\mathrm {i p k}, \\mathrm {x}, \\mathrm {w}) \\end{array} \\right]</span></div>

    <p class="text-gray-300">If  <span class="math">(\\dot{\\mathbf{x}},\\mathbf{x},\\mathbf{w})\\notin \\mathcal{R}</span> , the condition trivially holds. If  <span class="math">(\\dot{\\mathbf{x}},\\mathbf{x},\\mathbf{w})\\in \\mathcal{R}</span> , then the completeness of  <span class="math">f</span>  implies that  <span class="math">\\forall i\\in [n]</span> ,  <span class="math">(\\dot{\\mathbf{x}}_i,\\mathbf{x}_{\\mathrm{Agg}},(\\mathbf{w}_{i,1},\\mathbf{w}_{i,2}))\\in \\mathcal{R}_{\\mathrm{ARG}}</span>  and  <span class="math">\\pi_{\\mathrm{rt}}</span>  is a valid proof that  <span class="math">\\mathbf{x}</span>  is the first leaf of the Merkle tree with rooth rt.</p>

    <p class="text-gray-300">The completeness of ARG thus implies that  <span class="math">\\forall i\\in [n]</span> , ARG.  <span class="math">\\mathcal{V}^{\\rho}(\\mathrm{ivk}_i,\\mathbb{x}_i,\\mathrm{cm}_i,\\pi_i) = 1</span> , implying that  <span class="math">(\\dot{\\mathbf{x}}_{\\mathrm{Agg}},\\mathbf{x}_{\\mathrm{Agg}},\\mathbf{w}_{\\mathrm{Agg}})\\in \\mathcal{R}_{\\mathrm{Agg}}</span> .</p>

    <p class="text-gray-300">Now the completeness of Agg gives that  <span class="math">\\mathrm{Agg}.\\mathcal{V}^{\\rho}(\\mathrm{vk}_{\\mathrm{Agg}},\\mathrm{x}_{\\mathrm{Agg}},\\mathrm{cm}_{\\mathrm{Agg}},\\pi_{\\mathrm{Agg}}) = 1</span> . This, along with the fact that  <span class="math">\\pi_{\\mathrm{rt}}</span>  is a valid proof that  <span class="math">\\mathbf{x}</span>  is the first leaf of the Merkle tree with rooth rt implies that DNA.  <span class="math">\\mathcal{V}^{\\rho}(\\mathrm{ivk},\\mathrm{x},\\mathrm{cm},\\pi) = 1</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{A}</span>  be an adversary that succeeds against  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  constructed above with probability  <span class="math">\\varepsilon (\\lambda)</span> , that is, for some  <span class="math">\\dot{\\mathbf{x}}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} (\\dot {\\mathrm {x}}, \\mathrm {x}, \\mathrm {w}) \\notin \\mathcal {R} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\wedge &amp;amp; (\\mathrm {i p k}, \\mathrm {i c k}, \\mathrm {i v k}) \\leftarrow \\mathrm {D N A}. \\mathcal {G} ^ {\\rho} \\left(1 ^ {\\lambda}, \\dot {\\mathrm {x}}\\right) \\\\ \\mathrm {D N A}. \\mathcal {V} ^ {\\rho} (\\mathrm {i v k}, \\mathrm {x}, \\mathrm {c m}, \\pi) = 1 &amp;amp; \\mathrm {a u x} _ {\\mathcal {A}} \\leftarrow \\mathcal {D} _ {\\mathcal {A}} (\\mathrm {i p k}) \\\\ &amp;amp; (\\mathrm {x}, \\mathrm {c m}, \\pi) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathrm {i p k}, \\mathrm {a u x} _ {\\mathcal {A}}) \\\\ &amp;amp; \\mathrm {w} \\leftarrow \\mathcal {E} _ {\\mathcal {A}} (\\mathrm {i p k}, \\mathrm {a u x} _ {\\mathcal {A}}) \\end{array} \\right] \\geq \\varepsilon (\\lambda). \\tag {1}</span></div>

    <p class="text-gray-300">Given this  <span class="math">\\dot{\\mathbf{x}}</span> , do the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Reduce  <span class="math">\\dot{\\mathbf{x}}</span>  to multiple CSAT indices:  <span class="math">[\\dot{\\mathbf{x}}_i]_{i=1}^n \\coloneqq f_{\\dot{\\mathbf{x}}}(\\dot{\\mathbf{x}})</span> .</li>

      <li>Sample keys for the CSAT indices:  <span class="math">([\\mathrm{ipk}_i]_{i=1}^n, [\\mathrm{ick}_i]_{i=1}^n, [\\mathrm{ivk}_i]_{i=1}^n) \\gets \\mathsf{ARG}.\\mathcal{G}(\\lambda, [\\dot{\\mathbf{x}}_i]_{i=1}^n)</span> .</li>

      <li>Construct Agg index:  <span class="math">\\dot{\\mathbf{x}}_{\\mathrm{Agg}} := [\\mathrm{ivk}_i]_{i=1}^n</span> .</li>

    </ol>

    <p class="text-gray-300">For this value of  <span class="math">\\dot{\\mathbf{x}}</span> , Lemma 4.1 says that there exists an efficient extractor  <span class="math">\\mathcal{E}_{\\mathcal{W}}</span>  such that for every efficient adversary  <span class="math">\\mathcal{W}</span>  and auxiliary distribution  <span class="math">\\mathcal{D}_{\\mathcal{W}}</span> , the following probability is negligible:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} (\\dot {\\mathrm {x}}, \\mathrm {x}, \\mathrm {w}) \\notin k - \\mathrm {C S A T} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\&amp;amp; \\forall i \\in [ k ]: &amp;amp; [ \\dot {\\mathrm {i}} _ {i} ] _ {i = 1} ^ {n} = f _ {\\dot {\\mathrm {i}}} (\\dot {\\mathrm {x}}, \\mathcal {C}) \\\\ (\\dot {\\mathrm {x}} _ {i}, \\mathrm {x} ^ {\\prime}, (\\mathrm {w} _ {i, 1}, \\mathrm {w} _ {i, 2})) \\in \\mathrm {C S A T} &amp;amp; c k \\leftarrow C M. S e t u p (1 ^ {\\lambda}, \\mathcal {M} _ {i}) \\\\ \\&amp;amp; \\mathrm {x} \\text {i s t h e 0 - t h l e a f} &amp;amp; a u x _ {\\mathcal {W}} \\leftarrow \\mathcal {D} _ {\\mathcal {W}} (\\dot {\\mathrm {i}}) \\\\ &amp;amp; ([ \\mathrm {w} _ {i} ] _ {i = 1} ^ {n}, r t) \\leftarrow \\mathcal {W} ^ {\\rho} (\\dot {\\mathrm {i}}, a u x _ {\\mathcal {W}}) \\\\ &amp;amp; c m \\leftarrow C M. C o m m i t (c k, [ \\mathrm {w} _ {i, 1} ] _ {i = 1} ^ {n}) \\\\ &amp;amp; (\\alpha , \\beta) \\leftarrow \\rho (c m) \\\\ &amp;amp; \\mathrm {x} ^ {\\prime} := (1, r t, \\alpha , \\beta) \\\\ &amp;amp; (\\mathrm {x}, \\mathrm {w}) \\leftarrow \\mathcal {E} _ {\\mathcal {W}} ^ {\\rho} (\\dot {\\mathrm {i}}, a u x _ {\\mathcal {W}}) \\end{array} \\right]</span></div>

    <p class="text-gray-300">For the aforementioned values  <span class="math">[\\dot{\\mathbf{x}}_i]_{i=1}^n</span> , multi-instance knowledge soundness of ARG says that for every adversary  <span class="math">\\mathcal{C}</span>  and auxiliary input distribution  <span class="math">\\mathcal{D}_{\\mathcal{C}}</span> , there exists an efficient extractor  <span class="math">\\mathcal{E}_{\\mathcal{C}}</span>  such that the following probability is negligible.</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\exists i \\in [ n ]: &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\left(\\dot {\\mathrm {i}} _ {i}, \\mathrm {x} _ {i}, \\mathrm {w} _ {i}\\right) \\notin \\mathcal {R} &amp;amp; \\left([ \\mathrm {i p k} _ {i} ] _ {i = 1} ^ {n}, [ \\mathrm {i c k} _ {i} ] _ {i = 1} ^ {n}, [ \\mathrm {i v k} _ {i} ] _ {i = 1} ^ {n}) \\\\ \\vee &amp;amp; \\left(\\mathcal {G} ^ {\\rho} (\\mathrm {i p k} _ {i}, \\mathrm {w} _ {i, 1}; r _ {i}) \\neq \\mathrm {c m}\\right) \\\\ \\wedge &amp;amp; \\left(\\mathcal {G} ^ {\\rho} (1 ^ {\\lambda}, [ \\dot {\\mathrm {i}} _ {i} ] _ {i = 1} ^ {n}) \\\\ \\mathcal {V} ^ {\\rho} (\\mathrm {i v k} _ {i}, \\mathrm {x} _ {i}, \\mathrm {c m} _ {i}, \\pi_ {i}) = 1 &amp;amp; [ (\\mathrm {w} _ {i}, r _ {i}) ] _ {i = 1} ^ {n} \\leftarrow \\mathcal {P} ^ {\\rho} ([ \\mathrm {i p k} _ {i} ] _ {i = 1} ^ {n}, \\mathrm {a u x}) \\\\ &amp;amp; [ (\\mathrm {w} _ {i}, r _ {i}) ] _ {i = 1} ^ {n} \\leftarrow \\mathcal {E} _ {\\hat {\\mathcal {P}}} ([ \\mathrm {i p k} _ {i} ] _ {i = 1} ^ {n}, \\mathrm {a u x}) \\end{array} \\right]</span></div>

    <p class="text-gray-300">Finally, for this  <span class="math">\\dot{\\mathbf{i}}_{\\mathrm{Agg}}</span> , knowledge soundness of Agg gives that for every adversary  <span class="math">\\mathcal{B}</span>  and auxiliary input distribution  <span class="math">\\mathcal{D}_{\\mathcal{B}}</span> , there exists an efficient extractor  <span class="math">\\mathcal{E}_{\\mathcal{B}}</span>  such that the following probability is negligible.</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\left( \\begin{array}{c} (\\dot {\\mathrm {i}} _ {\\mathrm {A g g}}, \\mathrm {x} _ {\\mathrm {A g g}}, \\mathrm {w} _ {\\mathrm {A g g}}) \\notin \\mathcal {R} _ {\\mathrm {A g g}} \\\\ \\vee \\\\ \\mathrm {A g g}. \\mathcal {C} ^ {\\rho} (\\mathrm {c k} _ {\\mathrm {A g g}}, (\\mathrm {w} _ {\\mathrm {A g g}}) _ {1}) \\neq \\mathrm {c m} _ {\\mathrm {A g g}} \\end{array} \\right) &amp;amp; (\\mathrm {p k} _ {\\mathrm {A g g}}, \\mathrm {c k} _ {\\mathrm {A g g}}, \\mathrm {v k} _ {\\mathrm {A g g}}) \\leftarrow \\\\ \\&amp;amp; \\mathrm {A g g}. \\mathcal {V} ^ {\\rho} (\\mathrm {v k} _ {\\mathrm {A g g}}, \\mathrm {x} _ {\\mathrm {A g g}}, \\mathrm {c m} _ {\\mathrm {A g g}}, \\pi_ {\\mathrm {A g g}}) = 1 \\\\ &amp;amp; (\\mathrm {w} _ {\\mathrm {A g g}}) \\end{array} \\right] + \\Pr \\left[ \\begin{array}{c} \\mathcal {W} \\text {b r e a k s} \\\\ \\text {L e m m a 4 . 1 f o r} \\dot {\\mathrm {i}} \\end{array} \\right] \\geq \\varepsilon (\\lambda) \\quad ,</span></div>

    <p class="text-gray-300">Construction of adversaries and auxiliary input distribution. We describe how to use  <span class="math">\\mathcal{A}</span>  to build an adversary  <span class="math">\\mathcal{B}</span>  and auxiliary distribution  <span class="math">\\mathcal{D}_{\\mathcal{A}}</span>  against Agg, an adversary  <span class="math">\\mathcal{C}</span>  and auxiliary distribution  <span class="math">\\mathcal{D}_{\\mathcal{B}}</span>  against ARG, and an adversary  <span class="math">\\mathcal{W}</span>  and auxiliary distribution  <span class="math">\\mathcal{D}_{\\mathcal{C}}</span>  that breaks Lemma 4.1, such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} \\mathcal {B} \\text {b r e a k s} \\\\ \\text {k n o w l e d g e s o u n d n e s s} \\\\ \\text {o f A g g f o r} \\dot {\\mathrm {i}} _ {\\mathrm {A g g}} \\end{array} \\right] + \\Pr \\left[ \\begin{array}{c} \\mathcal {C} \\text {b r e a k s m u l t i - i n s t a n c e} \\\\ \\text {k n o w l e d g e s o u n d n e s s} \\\\ \\text {o f A R G f o r} [ \\dot {\\mathrm {i}} _ {i} ] _ {i = 1} ^ {n} \\end{array} \\right] + \\Pr \\left[ \\begin{array}{c} \\mathcal {W} \\text {b r e a k s} \\\\ \\text {L e m m a 4 . 1 f o r} \\dot {\\mathrm {i}} \\end{array} \\right] \\geq \\varepsilon (\\lambda) \\quad ,</span></div>

    <p class="text-gray-300">This is sufficient, because if  <span class="math">\\varepsilon (\\lambda)</span>  is non-negligible, then at least one of the three probabilities on the left-hand side must be non-negligible, leading to a contradiction.</p>

    <p class="text-gray-300">Constructing  <span class="math">\\mathcal{B}</span> . We construct adversary  <span class="math">\\mathcal{B}</span>  from the adversary  <span class="math">\\mathcal{A}</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}^{\\rho}(\\mathrm{pk}_{\\mathrm{Agg}},\\mathrm{aux}_{\\mathcal{B}})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse aux  <span class="math">\\mathcal{B}</span>  as (auxA, ipk).</li>

      <li>Obtain  <span class="math">(\\mathrm{x},\\pi)\\gets \\mathcal{A}^{\\rho}(\\mathrm{ipk},\\mathrm{aux}_{\\mathcal{A}})</span></li>

      <li>Parse  <span class="math">\\pi</span>  as  <span class="math">(\\mathrm{x}_{\\mathrm{Agg}},\\mathrm{cm}_{\\mathrm{Agg}},\\pi_{\\mathrm{Agg}},\\pi_{\\mathrm{rt}})</span></li>

      <li>Output  <span class="math">(\\mathrm{x}_{\\mathrm{Agg}},\\mathrm{cm}_{\\mathrm{Agg}},\\pi_{\\mathrm{Agg}})</span></li>

    </ol>

    <p class="text-gray-300">Constructing  <span class="math">\\mathcal{C}</span> . Denote by  <span class="math">\\mathcal{E}_{\\mathcal{B}}</span>  the extractor corresponding to  <span class="math">\\mathcal{B}</span>  for Agg. Then we construct  <span class="math">\\mathcal{C}</span>  from  <span class="math">\\mathcal{B}</span>  as well as the extractor  <span class="math">\\mathcal{E}_{\\mathcal{B}}</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{C}^{\\rho}([\\mathrm{ipk}_i]_i^n,\\mathrm{aux}_{\\mathcal{C}})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse aux  <span class="math">\\mathcal{C}</span>  as (auxA, ipk).</li>

      <li>Obtain  <span class="math">\\mathrm{pk}_{\\mathrm{Agg}}</span>  from ipk.</li>

      <li>Obtain  <span class="math">(\\mathrm{x}_{\\mathrm{Agg}},\\mathrm{cm}_{\\mathrm{Agg}},\\pi_{\\mathrm{Agg}})\\gets \\mathcal{B}^{\\rho}(\\mathrm{pk}_{\\mathrm{Agg}},\\mathrm{aux}_{\\mathcal{C}})</span></li>

      <li>Extract  <span class="math">\\mathrm{w}_{\\mathrm{Agg}} \\gets \\mathcal{E}_{\\mathcal{B}}^{\\rho}(\\mathrm{pk}_{\\mathrm{Agg}}, \\mathrm{aux}_{\\mathcal{C}})</span> .</li>

      <li>Parse  <span class="math">\\mathrm{w}_{\\mathrm{Agg}}</span>  as  <span class="math">([\\mathrm{cm}_i]_i^n, [\\pi_i]_i^n)</span> .</li>

      <li>Output  <span class="math">[(x_{\\mathrm{Agg}}, \\mathrm{cm}_i, \\pi_i)]_{i=1}^n</span> .</li>

    </ol>

    <p class="text-gray-300">Constructing  <span class="math">\\mathcal{W}</span> . Denote by  <span class="math">\\mathcal{E}_{\\mathcal{C}}</span>  the extractor corresponding to  <span class="math">\\mathcal{C}</span>  for ARG. Then we construct  <span class="math">\\mathcal{W}</span>  from the adversary  <span class="math">\\mathcal{C}</span>  as well as the extractor  <span class="math">\\mathcal{E}_{\\mathcal{C}}</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{W}^{\\rho}(1^{\\lambda},\\mathrm{i},\\mathrm{aux}_{\\mathcal{W}})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse auxw as (auxA, ipk).</li>

      <li>Obtain  <span class="math">[\\mathrm{ipk}_i]_{i = 1}^n</span>  from ipk.</li>

      <li>Extract  <span class="math">[(w_i)]_{i = 1}^n\\gets \\mathcal{E}_C([ipk_i]_{i = 1}^n,\\mathrm{aux}_W)</span></li>

      <li>Use  <span class="math">\\mathbf{x},\\alpha ,\\beta ,\\pmb{T}</span>  and  <span class="math">\\pmb{A}</span>  from  <span class="math">[(w_i)]_{i = 1}^n</span>  to construct rt as in Fig. 4.</li>

      <li>Output  <span class="math">([(\\mathrm{w}_i)]_{i = 1}^n,\\mathrm{rt})</span></li>

    </ol>

    <p class="text-gray-300">Constructing an extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  for  <span class="math">\\mathcal{A}</span> . We now use the extractor for  <span class="math">\\mathcal{W}</span>  to construct an extractor for  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}_{\\mathcal{A}}(\\mathrm{ipk},\\mathrm{aux}_{\\mathcal{A}})\\to \\mathrm{w}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Obtain i from ipk.</li>

      <li>Set  <span class="math">\\mathrm{aux}_{\\mathcal{W}} := (\\mathrm{aux}_{\\mathcal{A}}, \\mathrm{ipk})</span> .</li>

      <li>Run  <span class="math">(\\mathbf{x},\\mathbf{w})\\gets \\mathcal{E}_{\\mathcal{W}}(\\mathbf{i},\\mathbf{aux}^{\\prime})</span></li>

      <li>Output w.</li>

    </ol>

    <p class="text-gray-300">Success probability of  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> . For  <span class="math">\\mathfrak{i}</span>  in Eq. (1) we have:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\operatorname*{Pr}\\left[ \\begin{array}{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cc}(\\mathfrak{i},\\mathfrak{x},\\mathfrak{w})\\notin \\mathcal{R}\\\\ \\wedge \\\\ \\mathrm{DNA.}\\mathcal{V}^{\\rho}(\\mathrm{ivk},\\mathfrak{x},\\mathrm{cm},\\pi) = 1 \\end{array} \\right]\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c}\\rho \\leftarrow \\mathcal{U}(\\lambda)\\\\ (\\mathrm{ipk,ick,ivk})\\leftarrow \\mathrm{DNA.}\\mathcal{G}^{\\rho}(1^{\\lambda},\\mathfrak{i})\\\\ \\mathrm{aux}_{\\mathcal{A}}\\leftarrow \\mathcal{D}_{\\mathcal{A}}(\\mathrm{ipk})\\\\ (\\mathfrak{x},\\mathrm{cm},\\pi)\\leftarrow \\mathcal{A}^{\\rho}(\\mathrm{ipk},\\mathrm{aux}_{\\mathcal{A}})\\\\ \\mathrm{w}\\leftarrow \\mathcal{E}_{\\mathcal{A}}(\\mathrm{ipk},\\mathrm{aux}_{\\mathcal{A}}) \\end{array} \\right]\\geq \\varepsilon (\\lambda)\\quad .$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Parsing  <span class="math">\\pi</span>  as  <span class="math">(\\mathbf{x}_{\\mathrm{Agg}},\\mathrm{cm}_{\\mathrm{Agg}},\\pi_{\\mathrm{Agg}},\\pi_{\\mathrm{rt}})</span>  and ivk as  <span class="math">\\mathsf{vk}_{\\mathrm{Agg}}</span> , by construction of DNA, DNA.  <span class="math">\\mathcal{V}^{\\rho}(\\mathrm{ivk},\\mathbf{x},\\mathrm{cm},\\pi) = 1</span>  implies that  <span class="math">\\mathrm{Agg.}\\mathcal{V}^{\\rho}(\\mathsf{vk}_{\\mathrm{Agg}},\\mathbf{x}_{\\mathrm{Agg}},\\mathrm{cm}_{\\mathrm{Agg}},\\pi_{\\mathrm{Agg}}) = 1</span> . Thus:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\operatorname*{Pr}\\left[ \\begin{array}{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cc}(\\mathfrak{i},\\mathfrak{x},\\mathfrak{w})\\notin \\mathcal{R}\\\\ \\wedge \\\\ \\mathrm{Agg.}\\mathcal{V}^{\\rho}(\\mathsf{vk}_{\\mathrm{Agg}},\\mathfrak{x}_{\\mathrm{Agg}},\\mathsf{cm}_{\\mathrm{Agg}},\\pi_{\\mathrm{Agg}}) = 1 \\end{array} \\right]\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c}\\rho \\leftarrow \\mathcal{U}(\\lambda)\\\\ (\\mathrm{ipk,ick,ivk})\\leftarrow \\mathrm{DNA.}\\mathcal{G}^{\\rho}(1^{\\lambda},\\mathfrak{i})\\\\ \\mathrm{aux}\\leftarrow \\mathcal{D}(\\mathsf{pp})\\\\ (\\mathfrak{x},\\mathsf{cm},\\pi)\\leftarrow \\mathcal{A}^{\\rho}(\\mathrm{ipk},\\mathrm{aux})\\\\ \\mathrm{w}\\leftarrow \\mathcal{E}_{\\mathcal{A}}(\\mathrm{ipk},\\mathrm{aux})\\\\ \\pi = (\\mathfrak{x}_{\\mathrm{Agg}},\\mathsf{cm}_{\\mathrm{Agg}},\\pi_{\\mathrm{Agg}},\\pi_{\\mathrm{rt}})\\\\ \\mathrm{ivk} = \\mathsf{vk}_{\\mathrm{Agg}} \\end{array} \\right]\\geq \\varepsilon (\\lambda)\\quad .$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Factoring out' the probability of  <span class="math">\\mathcal{E}_{\\mathcal{W}}</span>  failing.  <span class="math">(\\dot{\\mathrm{i}},\\mathrm{x},\\mathrm{w})\\notin \\mathcal{R}</span>  either when</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\forall i\\in [n]:(\\dot{\\mathfrak{i}}_i,\\mathfrak{x}&#x27;,(\\mathfrak{w}_{i,1},\\mathfrak{w}_{i,2}))\\in \\mathrm{CSAT}</span>  but  <span class="math">\\mathcal{E}_{\\mathcal{W}}</span>  fails to extract a valid w. The probability of this happening is precisely:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\operatorname*{Pr}\\left[ \\begin{array}{c}\\mathcal{W}\\text{ breaks}\\\\ \\text{Lemma 4.1 for}\\dot{\\mathfrak{i}} \\end{array} \\right]</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\exists i\\in [n]:(\\dot{\\mathfrak{i}}_i,\\mathfrak{x}&#x27;,(\\mathfrak{w}_{i,1},\\mathfrak{w}_{i,2}))\\notin \\mathrm{CSAT}.</span></li>

    </ol>

    <p class="text-gray-300">Factoring out' the probability of  <span class="math">\\mathcal{E}_{\\mathcal{C}}</span>  failing.  <span class="math">\\exists i\\in [n]:(\\dot{\\mathfrak{i}}_i,\\mathfrak{x}&#x27;,(\\mathfrak{w}_{i,1},\\mathfrak{w}_{i,2}))\\notin \\mathrm{CSAT}</span>  either when</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\forall i\\in [n]:ARG.\\mathcal{V}^{\\rho}(\\mathrm{ivk}_i,\\mathbf{x}_i,\\mathrm{cm}_i,\\pi_i) = 1</span>  but  <span class="math">\\mathcal{E}_{\\mathcal{C}}</span>  fails to extract valid  <span class="math">[\\mathbf{w}_i]_{i = 1}^n</span> . The probability of this happening is precisely:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\operatorname*{Pr}\\left[ \\begin{array}{c}\\mathcal{C}\\text{ breaks multi-instance}\\\\ \\text{knowledge soundness}\\\\ \\text{of ARG for } [\\dot{\\mathfrak{i}} ]_{i = 1}^{n} \\end{array} \\right]</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\exists i\\in [n]:ARG.\\mathcal{V}^{\\rho}(\\mathrm{ivk}_i,\\mathbf{x}_i,\\mathrm{cm}_i,\\pi_i)\\neq 1.</span></li>

    </ol>

    <p class="text-gray-300">'Factoring out' the probability of  <span class="math">\\mathcal{E}_{\\mathcal{B}}</span>  failing. The probability that  <span class="math">\\mathrm{Agg}.\\mathcal{V}^{\\rho}(\\mathrm{vk}_{\\mathrm{Agg}},\\mathrm{x}_{\\mathrm{Agg}},\\mathrm{cm}_{\\mathrm{Agg}},\\pi_{\\mathrm{Agg}}) = 1</span>  and  <span class="math">\\exists i\\in [n]: \\mathrm{ARG}.\\mathcal{V}^{\\rho}(\\mathrm{ivk}_i,\\mathrm{x}_i,\\mathrm{cm}_i,\\pi_i)\\neq 1</span>  is exactly:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} \\mathcal {B} \\text {b r e a k s} \\\\ \\text {k n o w l e d g e s o u n d n e s s} \\\\ \\text {o f A g g f o r} \\dot {\\mathrm {i}} _ {\\mathrm {A g g}} \\end{array} \\right]</span></div>

    <p class="text-gray-300">Putting the above together, we obtain our desired contradiction, i.e., that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} \\mathcal {B} \\text {b r e a k s} \\\\ \\text {k n o w l e d g e s o u n d n e s s} \\\\ \\text {o f A g g f o r} \\dot {\\mathrm {i}} _ {\\mathrm {A g g}} \\end{array} \\right] + \\Pr \\left[ \\begin{array}{c} \\mathcal {C} \\text {b r e a k s m u l t i - i n s t a n c e} \\\\ \\text {k n o w l e d g e s o u n d n e s s} \\\\ \\text {o f A R G f o r} [ \\dot {\\mathrm {i}} _ {i} ] _ {i = 1} ^ {n} \\end{array} \\right] + \\Pr \\left[ \\begin{array}{c} \\mathcal {W} \\text {b r e a k s} \\\\ \\text {L e m m a 4 . 1 f o r} \\dot {\\mathrm {i}} \\end{array} \\right] \\geq \\varepsilon (\\lambda) \\quad ,</span></div>

    <p class="text-gray-300">The construction in Section 6.1 can be turned zero-knowledge by using a commit-carrying SNARK ARG with multi-instance zero-knowledge and the hiding version of Merkle commitments.</p>

    <p class="text-gray-300">Zero-Knowledge then follows from the multi-instance zero-knowledge property of ARG and the zero-knowledge property of hiding Merkle proofs. The former implies the existence of  <span class="math">S^{\\mathrm{ARG}} = (S_1^{\\mathrm{ARG}}, S_2^{\\mathrm{ARG}})</span>  for ARG.</p>

    <p class="text-gray-300">The Simulator  <span class="math">S = (S_{1}, S_{2})</span>  for the distributed zkSNARK DNA is presented in Figure 11.</p>

    <p class="text-gray-300">|  S1ρ(1λ, i) → (ipk, τ):  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  1. Obtain the partitioned indices: [i]i=1= f1(i).  |</p>

    <p class="text-gray-300">|  2. Run S1ARG to obtain ([ipki]i=1, τ) ← (S1ARG)ρ(1λ, [i]i=1).  |</p>

    <p class="text-gray-300">|  3. Obtain [ivki]i=1 from [ipki]i=1 and set iAgg = [ivki]i=1.  |</p>

    <p class="text-gray-300">|  4. Sample public parameters for Agg: (pkAgg, ckAgg, vkAgg) ← Agg.G(1λ, iAgg).  |</p>

    <p class="text-gray-300">|  5. Output (ipk := (i, ivk, [ipki]i=1, pkAgg), τ).  |</p>

    <p class="text-gray-300">|  S2ρ(ipk, x, τ) → (π, μ):  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  1. Parse proving key as ipk = (i, ivk, [ipki]i=1, pkAgg).  |</p>

    <p class="text-gray-300">|  2. Sample random (α, β) ← F2.  |</p>

    <p class="text-gray-300">|  3. Compute a random Merkle tree root rt and proof πrt that x is its first leaf.  |</p>

    <p class="text-gray-300">|  4. Set xAgg := (1, rt, α, β).  |</p>

    <p class="text-gray-300">|  5. Run S2ARG to obtain ([cmi]i=1, [πi]i=1, μ) ← (S2ARG)ρ([ipki]i=1, [xAgg]i=1, τ).  |</p>

    <p class="text-gray-300">|  6. Commit to [cmi]i=1: cmAgg ← Agg.Cρ(ckAgg, [cmi]i=1).  |</p>

    <p class="text-gray-300">|  7. Program μ(ivk, cmAgg) := (α, β).  |</p>

    <p class="text-gray-300">|  8. Assemble the R_Agg instance and witness:  |</p>

    <p class="text-gray-300">|  (xAgg, wAgg) = ((1, rt, α, β), ([cmi]i=1, [πi]i=1))  |</p>

    <p class="text-gray-300">|  9. Compute aggregated proof: πAgg ← Agg.Pρ(pkAgg, xAgg, wAgg, cmAgg).  |</p>

    <p class="text-gray-300">|  10. Output (π := (xAgg, cmAgg, πAgg, πrt), μ).  |</p>

    <p class="text-gray-300">Figure 11: Simulator for the Distributed zkSNARK</p>

    <p class="text-gray-300">Proof sketch. The zero-knowledge of DNA follows from the multi-instance zero-knowledge property of ARG and the zero-knowledge property of hiding Merkle proofs. At a high level, the proof  <span class="math">\\pi</span>  generated by DNA consists of  <span class="math">\\mathbb{x}_{\\mathrm{Agg}} = (1,\\mathrm{rt},\\alpha ,\\beta)</span> ,  <span class="math">\\pi_{\\mathrm{rt}}</span>  and  <span class="math">(\\mathrm{cm}_{\\mathrm{Agg}},\\pi_{\\mathrm{Agg}})</span> .  <span class="math">(\\alpha ,\\beta)</span>  are randomly sampled and  <span class="math">(\\mathrm{rt},\\pi_{\\mathrm{rt}})</span>  hide all information about their leaves because of the hiding property of Merkle trees. Lastly,  <span class="math">\\mathrm{cm}_{\\mathrm{Agg}}</span>  and  <span class="math">\\pi_{\\mathrm{Agg}}</span>  are</p>

    <p class="text-gray-300">also indistinguishable from the honest case, as they are deterministic functions of <span class="math">[\\mathsf{cm}_{i}]_{i=1}^{n}</span> and <span class="math">[\\pi_{i}]_{i=1}^{n}</span> and the latter hide all information about the underlying witness since ARG has multi-instance zero-knowledge.</p>

    <p class="text-gray-300">Note that the simulator can fail if the simulator <span class="math">\\mathcal{S}^{\\text{ARG}}</span> for ARG also programs the random oracle at the point <span class="math">(\\text{ivk},\\mathsf{cm}_{\\text{Agg}})</span> to a value different from <span class="math">(\\alpha,\\beta)</span>. This can happen with non-negligible probability only if <span class="math">\\mathcal{S}^{\\text{ARG}}</span> is ‘adversarial’ and purposely programs that point. However, for all natural constructions of ARG (including Mirage, the cc-zkSNARK we use in Hekaton), the simulator is benign. In fact, the simulator for Mirage does not program the random oracle at all.</p>

    <h3 id="sec-71" class="text-xl font-semibold mt-8">C.4 Efficiency</h3>

    <p class="text-gray-300">The efficiency claims follow from inspection:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each worker node runs ARG.<span class="math">\\mathcal{C}</span> and ARG.<span class="math">\\mathcal{P}</span> once.</li>

      <li>Each worker node’s communication cost is the size of a single commitment of ARG and a single proof of ARG.</li>

      <li>The primary node runs Agg.<span class="math">\\mathcal{C}</span> and Agg.<span class="math">\\mathcal{P}</span> once on inputs of size <span class="math">n</span>.</li>

      <li>Proof size is the size of an Agg proof and one Merkle proof for the tree with root rt.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AABDS20] A. Aly, T. Ashur, E. Ben-Sasson, S. Dhooghe, and A. Szepieniec. “Design of Symmetric-Key Primitives for Advanced Cryptographic Protocols”. In: IACR Trans. Symmetric Cryptol. 2020.3 (2020), pp. 1–45.</li>

      <li>[ABST23] M. Ambrona, M. Beunardeau, A.-L. Schmitt, and R. R. Toledo. “aPlonK: Aggregated PlonK from Multi-polynomial Commitment Schemes”. In: Proceedings of the 18th International Workshop on Security. IWSEC ’23. 2023.</li>

      <li>[AFGHO16] M. Abe, G. Fuchsbauer, J. Groth, K. Haralambiev, and M. Ohkubo. “Structure-Preserving Signatures and Commitments to Group Elements”. In: Journal of Cryptology 29.2 (2016), pp. 363–421.</li>

      <li>[Ark22] Arkworks contributors. arkworks zkSNARK ecosystem. 2022. URL: https://arkworks.rs.</li>

      <li>[AST24] A. Arun, S. Setty, and J. Thaler. “Jolt: SNARKs for Virtual Machines via Lookups”. In: Proceedings of the 43rd Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’24. 2024.</li>

      <li>[BBBPWM18] B. Bünz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell. “Bulletproofs: Short Proofs for Confidential Transactions and More”. In: Proceedings of the 39th IEEE Symposium on Security and Privacy. S&amp;P ’18. 2018, pp. 315–334.</li>

      <li>[BCCGP16] J. Bootle, A. Cerulli, P. Chaidos, J. Groth, and C. Petit. “Efficient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting”. In: Proceedings of the 35th Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’16. 2016, pp. 327–357.</li>

      <li>[BCGJM18] J. Bootle, A. Cerulli, J. Groth, S. K. Jakobsen, and M. Maller. “Arya: Nearly Linear-Time Zero-Knowledge Proofs for Correct Program Execution”. In: Proceedings of the 24th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’18. 2018, pp. 595–626.</li>

      <li>[BCGMMW20] S. Bowe, A. Chiesa, M. Green, I. Miers, P. Mishra, and H. Wu. “ZEXE: Enabling Decentralized Private Computation”. In: Proceedings of the 41st IEEE Symposium on Security and Privacy. S&amp;P ’20. 2020, pp. 947–964.</li>

      <li>[BCGT13] E. Ben-Sasson, A. Chiesa, D. Genkin, and E. Tromer. “Fast Reductions from RAMs to Delegatable Succinct Constraint Satisfaction Problems”. In: Proceedings of the 4th Innovations in Theoretical Computer Science Conference. ITCS ’13. 2013.</li>

      <li>[BCGTV13] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza. “SNARKs for C: Verifying Program Executions Succinctly and in Zero Knowledge”. In: Proceedings of the 33rd Annual International Cryptology Conference. CRYPTO ’13. 2013, pp. 90–108.</li>

      <li>[BCLMS21] B. Bünz, A. Chiesa, W. Lin, P. Mishra, and N. Spooner. “Proof-Carrying Data Without Succinct Arguments”. In: Proceedings of the 41st Annual International Cryptology Conference. CRYPTO ’21. 2021, pp. 681–710.</li>

      <li>[BCMS20] B. Bünz, A. Chiesa, P. Mishra, and N. Spooner. “Proof-Carrying Data from Accumulation Schemes”. In: Proceedings of the 18th Theory of Cryptography Conference. TCC ’20. 2020.</li>

      <li>[BCTV14a] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. “Scalable Zero Knowledge via Cycles of Elliptic Curves”. In: Proceedings of the 34th Annual International Cryptology Conference. CRYPTO ’14. 2014, pp. 276–294.</li>

      <li>[BCTV14b] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. “Succinct Non-Interactive Zero Knowledge for a von Neumann Architecture”. In: Proceedings of the 23rd USENIX Security Symposium. USENIX Security ’14. 2014, pp. 781–796.</li>

      <li>[BD19] R. Barbulescu and S. Duquesne. “Updating Key Size Estimations for Pairings”. In: Journal of Cryptology 32 (2019), pp. 1298–1336.</li>

    </ul>

    <p class="text-gray-300">[BEGKN91] M. Blum, W. Evans, P. Gemmell, S. Kannan, and M. Naor. “Checking the correctness of memories”. In: Proceedings of the 32nd Annual Symposium on Foundations of Computer Science. FOCS '91. 1991, pp. 90–99.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BMMTV21] B. Bünz, M. Maller, P. Mishra, N. Tyagi, and P. Vesely. “Proofs for Inner Pairing Products and Applications”. In: Proceedings of the 27th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’21. 2021, pp. 65–97.</li>

      <li>[BR93] M. Bellare and P. Rogaway. “Random Oracles Are Practical: A Paradigm for Designing Efficient Protocols”. In: Proceedings of the 1st ACM Conference on Computer and Communications Security. CCS ’93. 1993, pp. 62–73.</li>

      <li>[CDGM19] M. Chase, A. Deshpande, E. Ghosh, and H. Malvai. “SEEMless: Secure End-to-End Encrypted Messaging with Less Trust”. In: CCS ’19. 2019, pp. 1639–1656.</li>

      <li>[CFQ19] M. Campanelli, D. Fiore, and A. Querol. “LegoSNARK: Modular Design and Composition of Succinct Zero-Knowledge Proofs”. In: Proceedings of the 26th ACM Conference on Computer and Communications Security. CCS ’19. 2019, pp. 2075–2092.</li>

      <li>[CHMMVW20] A. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. Ward. “Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS”. In: Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’20. 2020.</li>

      <li>[Cos+15] C. Costello et al. “Geppetto: Versatile Verifiable Computation”. In: Proceedings of the 36th IEEE Symposium on Security and Privacy. S&amp;P ’15. 2015, pp. 250–273.</li>

      <li>[CT10] A. Chiesa and E. Tromer. “Proof-Carrying Data and Hearsay Arguments from Signature Cards”. In: Proceedings of the 1st Symposium on Innovations in Computer Science. ICS ’10. 2010, pp. 310–331.</li>

      <li>[CTV15] A. Chiesa, E. Tromer, and M. Virza. “Cluster Computing in Zero Knowledge”. In: Proceedings of the 34th Annual International Conference on Theory and Applications of Cryptographic Techniques. EUROCRYPT ’15. 2015, pp. 371–403.</li>

      <li>[EA23] A. S. Engineering and Architecture. Advancing iMessage security: iMessage Contact Key Verification. https://security.apple.com/blog/imessage-contact-key-verification/. 2023.</li>

      <li>[GGPR13] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. “Quadratic Span Programs and Succinct NIZKs without PCPs”. In: Proceedings of the 32nd Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’13. 2013, pp. 626–645.</li>

      <li>[GKRRS21] L. Grassi, D. Khovratovich, C. Rechberger, A. Roy, and M. Schofnegger. “Poseidon: A New Hash Function for Zero-Knowledge Proof Systems”. In: Proceedings of the 29th USENIX Security Symposium. USENIX Security ’21. 2021, pp. 519–535.</li>

      <li>[GMN22] N. Gailly, M. Maller, and A. Nitulescu. “SnarkPack: Practical SNARK Aggregation”. In: Proceedings of the 26th International Conference on Financial Cryptography and Data Security. FC ’22. 2022, pp. 203–229.</li>

      <li>[Gro16] J. Groth. “On the Size of Pairing-Based Non-interactive Arguments”. In: Proceedings of the 35th Annual International Conference on Theory and Applications of Cryptographic Techniques. EUROCRYPT ’16. 2016, pp. 305–326.</li>

      <li>[GW20] A. Gabizon and Z. J. Williamson. plookup: A simplified polynomial protocol for lookup tables. Cryptology ePrint Archive Report 2020/315. 2020.</li>

      <li>[GWC19] A. Gabizon, Z. J. Williamson, and O. Ciobotaru. PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge. Cryptology ePrint Archive Report 2019/953. 2019.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[KPPS20] A. E. Kosba, D. Papadopoulos, C. Papamanthou, and D. Song. “MIRAGE: Succinct Arguments for Randomized Algorithms with Applications to Universal zk-SNARKs”. In: Proceedings of the 29th USENIX Security Symposium. USENIX Security ’20. 2020, pp. 2129–2146.</li>

      <li>[KST22] A. Kothapalli, S. T. V. Setty, and I. Tzialla. “Nova: Recursive Zero-Knowledge Arguments from Folding Schemes”. In: Proceedings of the 42nd Annual International Cryptology Conference. CRYPTO ’22. 2022, pp. 359–388.</li>

      <li>[Lip89] R. J. Lipton. Fingerprinting Sets. Tech. rep. CS-TR-212-89. Princeton University, 1989.</li>

      <li>[Lip90] R. J. Lipton. “Efficient Checking of Computations”. In: Proceedings of the 7th Annual Symposium on Theoretical Aspects of Computer Science. STACS ’90. 1990, pp. 207–215.</li>

      <li>[LL23] S. Lawlor and K. Lewi. Deploying key transparency at WhatsApp. https://engineering.fb.com/2023/04/13/security/whatsapp-key-transparency/. 2023.</li>

      <li>[LXZ21] T. Liu, X. Xie, and Y. Zhang. “zkCNN: Zero Knowledge Proofs for Convolutional Neural Network Predictions and Accuracy”. In: Proceedings of the 28th ACM Conference on Computer and Communications Security. CCS ’21. 2021, pp. 2968–2985.</li>

      <li>[LXZSZ24] T. Liu, T. Xie, J. Zhang, D. Song, and Y. Zhang. “Pianist: Scalable zkRollups via Fully Distributed Zero-Knowledge Proofs”. In: Proceedings of the 45th IEEE Symposium on Security and Privacy. S&P ’24. 2024.</li>

      <li>[MBBFF15] M. S. Melara, A. Blankstein, J. Bonneau, E. W. Felten, and M. J. Freedman. “CONIKS: Bringing Key Transparency to End Users”. In: Proceedings of the 24th USENIX Security Symposium. USENIX Security ’15. 2015, pp. 383–398.</li>

      <li>[NDCTB24] W. Nguyen, T. Datta, B. Chen, N. Tyagi, and D. Boneh. “Mangrove: A Scalable Framework for Folding-based SNARKs”. In: Proceedings of the 44th Annual International Cryptology Conference. CRYPTO ’24. 2024.</li>

      <li>[San+23] Y. Sang et al. “Ou: Automating the Parallelization of Zero-Knowledge Protocols”. In: Proceedings of the 30th ACM Conference on Computer and Communications Security. CCS ’23. 2023, pp. 534–548.</li>

      <li>[Set20] S. Setty. “Spartan: Efficient and General-Purpose zkSNARKs Without Trusted Setup”. In: Proceedings of the 40th Annual International Cryptology Conference. CRYPTO ’20. 2020, pp. 704–737.</li>

      <li>[Sta21] StarkWare. ethSTARK Documentation. Cryptology ePrint Archive Report 2021/582. 2021. url: https://eprint.iacr.org/2021/582.</li>

      <li>[TFZBT22] N. Tyagi, B. Fisch, A. Zitek, J. Bonneau, and S. Tessaro. “VeRSA: Verifiable Registries with Efficient Client Audits from RSA Authenticated Dictionaries”. In: Proceedings of the 29th ACM Conference on Computer and Communications Security. CCS ’22. 2022, pp. 2968–2985.</li>

      <li>[WZCPS18] H. Wu, W. Zheng, A. Chiesa, R. A. Popa, and I. Stoica. “DIZK: A Distributed Zero Knowledge Proof System”. In: Proceedings of the 27th USENIX Security Symposium. USENIX Security ’18. 2018, pp. 675–692.</li>

      <li>[Xie+22] T. Xie et al. “zkBridge: Trustless Cross-chain Bridges Made Practical”. In: Proceedings of the 29th ACM Conference on Computer and Communications Security. CCS ’22. 2022, pp. 3003–3017.</li>

      <li>[ZBKMNS22] A. Zapico, V. Buterin, D. Khovratovich, M. Maller, A. Nitulescu, and M. Simkin. “Caulk: Lookup Arguments in Sublinear Time”. In: Proceedings of the 29th ACM SIGSAC Conference on Computer and Communications Security. CCS ’22. 2022.</li>

      <li>[ZGKPP18] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou. “vRAM: Faster Verifiable RAM with Program-Independent Preprocessing”. In: Proceedings of the 39th IEEE Symposium on Security and Privacy. S&P ’18. 2018, pp. 908–925.</li>

    </ul>`;
---

<BaseLayout title="Hekaton: Horizontally-Scalable zkSNARKs via Proof Aggregatio... (2024/1208)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/1208
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
