---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2025/144';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'KZH-Fold: Accountable Voting from Sublinear Accumulation';
const AUTHORS_HTML = 'George Kadianakis, Arantxa Zapico, Hossein Hafezi, Benedikt B&uuml;nz';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Accumulation schemes are powerful primitives that enable distributed and incremental verifiable computation with less overhead than recursive SNARKs. However, most existing schemes with constant-size accumulation verifiers suffer from linear-sized accumulators and deciders, leading to unsuitable linear-sized proofs in distributed settings such as accountable voting protocols. Our contributions are as follows:

I) We introduce KZH, a novel multilinear polynomial commitment scheme (PCS) with sublinear opening and KZH-fold, a polynomial accumulation (PA) scheme where the verifier only does $3$ group scalar multiplications and $O(n^{1/2})$ accumulator size and decider time. Our scheme generalizes to achieve accumulator and decider complexity of $O(k \\cdot n^{1/k})$ while a verifier complexity $O(k)$. 

2) As an orthogonal contribution to KZH-fold, we build an IVC (PCD) scheme for R1CS via Spartan+PA, in which instantiated with KZH-fold, i.e. Spartan+KZH-fold results in a sublinear proof and decider. With the recipe of Spartan+PA, we build non-uniform IVC and non-uniform PCD. Our non-uniform PCD is the first approach in which the prover&#x27;s computation and communication at each step and grow sublinearly with the combined circuit size of all instructions. This approach can be instantiated with any PA and doesn&#x27;t depend on KZH-fold.

3) We demonstrate the power of Spartan+KZH-fold by implementing an accountable voting scheme using a novel signature aggregation protocol supporting millions of participants, significantly reducing communication overhead and verifier time compared to BLS-based aggregation.  We implemented and benchmarked our protocols, Spartan+KZH-fold achieves a 2000x reduction in communication and a 50x improvement in decider time over Nova when proving 2000 Poseidon hashes, at the cost of 3x the prover time.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Incrementally verifiable computation &middot; Zero-knowledge proof &middot; Accountable voting &middot; Sublinear Accumulation</p>
    </section>

    <p class="text-gray-300">We present KZH in Figure 2. For a multilinear polynomial  <span class="math">f(\\vec{X})</span> , where  <span class="math">\\vec{X} \\in \\mathbb{F}^k</span> , which interpolates a vector in  <span class="math">\\mathbb{F}^{2^k}</span> , we set  <span class="math">\\ell = 2^k = |f|</span> . We can select any  <span class="math">\\nu, \\mu</span>  such that  <span class="math">k = \\nu + \\mu</span>  and the following costs apply:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Committing to f costs  <span class="math">O(\\ell)</span>  group operations.</li>
      <li>Proof consists of  <span class="math">2^{\\nu}</span>   <span class="math">\\mathbb{G}_1</span>  elements and  <span class="math">2^{\\mu}</span>  field elements.</li>
      <li>Opening requires  <span class="math">2^{\\nu}</span>  field operations.</li>
      <li>Verifier requires  <span class="math">2^{\\nu}</span>  pairings, multi-exponentiations of size  <span class="math">2^{\\nu}+2^{\\mu}</span> , and  <span class="math">2^{\\mu}</span>  field operations.</li>
    </ul>

    <p class="text-gray-300">We can set  <span class="math">\\nu = \\mu = \\frac{k}{2}</span>  so  <span class="math">2^{\\nu} = 2^{\\mu} = 2^{\\frac{k}{2}}</span> , or choose a trade-off between prover and verifier work based on convenience. For example, when the verifier workload or proof size is more critical, selecting a lower  <span class="math">\\nu</span>  results in fewer pairings and smaller proof size, but at the expense of more multi-exponentiations by the prover to open the commitment. The polynomial commitment scheme has two key properties: The opening proof can be precomputed during the commitment phase and is  <span class="math">O(\\ell^{\\frac{1}{2}})</span>  in size. Secondly, it can be accumulated efficiently using only  <span class="math">\\mathbb{G}_1</span>  operation and has an  <span class="math">O(\\ell^{\\frac{1}{2}})</span>  accumulator witness. More precisely, the prover commits to the multilinear commitment  <span class="math">f(\\vec{X}, \\vec{Y})</span>  with  <span class="math">\\vec{X} \\in \\mathbb{F}^{\\nu}</span>  and  <span class="math">\\vec{Y} \\in \\mathbb{F}^{\\mu}</span>  as a matrix of evaluation points. During the opening at point  <span class="math">(\\vec{x}_0, \\vec{y}_0)</span> , the prover decomposes the matrix into row commitments. The correctness of this decomposition can be checked using pairings. Intuitively, KZH is a proof of correct partial evaluation at point  <span class="math">X = \\vec{x}_0</span> . Once the verifier is convinced about the correctness of  <span class="math">f^*(\\vec{Y}) = f(\\vec{x}_0, \\vec{Y})</span> , it can evaluate  <span class="math">f^*(\\vec{Y})</span> at  <span class="math">y_0</span>  on its own. We can then use the technique from Hyrax to evaluate the bivariate commitment as a vector, matrix, or vector product. The technique extends to more variables as presented in Appendix C (which reduces the verification cost). KZH is not inherently hiding; however, by utilizing the general compiler described in [B&uuml;+19] for homomorphic polynomial commitments, it can be transformed to achieve hiding. However, the general compiler requires committing to a fully random polynomial, which forces the prover to perform a linear-sized MSM during the opening phase. Recent work, IronDict [Haf+25], building on KZH, demonstrates that it suffices to use a sparse random polynomial with only  <span class="math">\\sqrt{|f|}</span>  non-zero coefficients. They further generalize this result to  <span class="math">k \\cdot \\sqrt[k]{|f|}</span>  for the KZH-k setting. In brief, IronDict builds a hiding version of KZH (zk-KZH) in which the opening remains sublinear and hence efficient.</p>

    <p class="text-gray-300">Below we state a theorem proving the security of KZH under the  <span class="math">\\mathcal{D}_n</span> -find-rep [DRZ20], for a distribution  <span class="math">\\mathcal{D}_n</span> . We instantiate  <span class="math">\\mathcal{D}_n</span>  with our setup Setup<sub>KZH</sub> algorithm. All the secret trapdoors in our setup appear up to m times in exponents of  <span class="math">\\mathbb{G}_1</span>  generators and once in the exponent of an  <span class="math">\\mathbb{G}_2</span>  generator. [DRZ20]'s proof suggests that this should be equivalent to the m, 1-dlog assumption [BFL20]. We leave this reduction as an open problem.</p>

    <p class="text-gray-300">SetupKZH(&lambda;, k) :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Choose &micro;, &nu; such that k = 2&nu;+<sup>&micro;</sup>. Let n = 2<sup>&nu;</sup> and m = 2<sup>&micro;</sup> and define the boolean cubes as B<sup>n</sup> = {0, 1} <sup>&nu;</sup> and B<sup>m</sup> = {0, 1} &micro;.</li>
      <li>Sample {G (&#8407;i) <sup>&larr;</sup>$ <sup>G</sup>1}&#8407;i&isin;B<sup>m</sup> , V &larr;$ G<sup>2</sup> and sample trapdoor {&tau; (&#8407;j)}&#8407;j&isin;B<sup>n</sup> , &alpha; &larr;$ F <a href="#page-0-0">f</a> .</li>
      <li>For &#8407;i &isin; Bn, &#8407;j &isin; Bm, define:</li>
    </ul>

    <p class="text-gray-300"><span class="math">$- \\ \\mathsf{H}^{(\\vec{i},\\,\\vec{j})} \\leftarrow \\tau^{(\\vec{i})} \\times \\mathsf{G}^{(\\vec{j})}</span>$</p>

    <p class="text-gray-300"><span class="math">$- \\ \\mathsf{H}^{(\\vec{j})} \\leftarrow \\alpha \\times \\mathsf{G}^{(\\vec{j})}</span>$</p>

    <p class="text-gray-300"><span class="math">$- \\mathsf{V}^{(\\vec{i})} \\leftarrow \\tau^{(\\vec{i})} \\times \\mathsf{V} \\in \\mathbb{G}_2</span>$</p>

    <p class="text-gray-300"><span class="math">$- V&#x27; \\leftarrow \\alpha \\times V</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let srs &larr; [G (&#8407;i) , H (&#8407;i,&#8407;j) , H (&#8407;j) , V &prime; , V (&#8407;i) ]&#8407;i&isin;Bn,&#8407;j&isin;B<sup>m</sup> .</li>
      <li>Output srs.</li>
    </ul>

    <p class="text-gray-300">CommitKZH(srs, f(X, &#8407; Y&#8407; )): For f &isin; MLP(&nu; + &micro;) and X&#8407; &isin; F &nu; , Y&#8407; &isin; F &micro;</p>

    <p class="text-gray-300">&bull; Output
<span class="math">$\\mathsf{C} \\leftarrow \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} f(\\vec{x}, \\vec{y}) \\times \\mathsf{H}^{(\\vec{x}, \\vec{y})}</span>$
.</p>

    <p class="text-gray-300">&bull; Let
<span class="math">$\\mathsf{D}^{(\\vec{x})} \\leftarrow \\sum_{\\vec{y} \\in B_m} f(\\vec{x}, \\vec{y}) \\times \\mathsf{H}^{(\\vec{y})} \\ \\forall \\ \\vec{x} \\in B_n.</span>$</p>

    <p class="text-gray-300">&bull; Output C and aux = {D (&#8407;x)}&#8407;x&isin;B<sup>n</sup> as cache.</p>

    <p class="text-gray-300">OpenKZH(srs, f(X, &#8407; Y&#8407; ), &#8407;x0, &#8407;y0, aux):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let f &lowast; (Y&#8407; ) &larr; f( &#8407;x0, Y&#8407; ), f <sup>&lowast;</sup> &isin; MLP(F, &micro;).</li>
      <li>Let z<sup>0</sup> &larr; f &lowast; ( &#8407;y0).</li>
      <li>Output &pi; &larr; f &lowast; (Y&#8407; ), aux = {D (&#8407;x)}&#8407;x&isin;B<sup>n</sup> , z0.</li>
    </ul>

    <p class="text-gray-300">VerifyKZH(srs, C, &#8407;x0, &#8407;y0, &pi;, z0): Accept if and only if all checks below pass:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300"><span class="math">$e(C, V&#x27;) = \\sum_{\\vec{x} \\in B_n} e(D^{(\\vec{x})}, V^{(\\vec{x})}),</span>$</p></li>
      <li><p class="text-gray-300"><span class="math">$\\textstyle\\sum_{\\vec{y}\\in B_m} f^*(\\vec{y})\\times \\mathsf{H}^{(\\vec{y})} = \\sum_{\\vec{x}\\in B_n} \\mathsf{eq}(\\vec{x},\\,\\vec{x_0})\\times \\mathsf{D}^{(\\vec{x})},</span>$</p></li>
    </ol>

    <p class="text-gray-300">3.
<span class="math">$f^*(\\vec{y_0}) = z_0</span>$
.</p>

    <p class="text-gray-300">Figure 2: KZH polynomial commitment scheme</p>

    <p class="text-gray-300">Theorem 3. The protocol in Fig. <a href="#page-19-0">2</a> is a complete and knowledge-sound polynomial commitment scheme as defined in Definition <a href="#page-14-1">1,</a> in the AGM under the (q1, q2) &minus; dlog and Setup-find-rep assumptions.</p>

    <p class="text-gray-300">The proof is deferred to Appendix <a href="#page-45-1">B.1</a></p>

    <p class="text-gray-300">Dual polynomials. A dual polynomial <a href="#page-43-6">[GNS24]</a> is a recent primitive that allows us to link a witness committed to using a univariate polynomial commitment scheme with a witness inside a multilinear polynomial commitment scheme. KZH, when the SRS is initialized with the powers of &tau; , acts both as a univariate KZG commitment and as a multilinear KZH commitment. To be more precise, in Figure <a href="#page-19-0">2,</a> when G (&#8407;i) is initialized with &tau; <sup>i</sup>&times;<sup>m</sup> &times; g, and &tau; (&#8407;j) is equal to &tau; <sup>j</sup>&mdash;i.e., we assume i and j are the decimal values corresponding to &#8407;i and &#8407;j&mdash;we observe that:</p>

    <p class="text-gray-300"><span class="math">$\\{H^{(\\vec{i},\\vec{j})}: \\vec{i} \\in B_n, \\ \\vec{j} \\in B_m\\} = \\{g^{\\tau^i}: i \\in [n \\times m]\\}.</span>$</p>

    <p class="text-gray-300">Since the commitment C in KZH is an MSM between {H(&#8407;i,&#8407;j)} and the values f(&#8407;x, &#8407;y) (i.e., the evaluations of the polynomial on the boolean hypercube), it follows that C is also a KZG commitment to a univariate polynomial g(X) defined as:</p>

    <p class="text-gray-300"><span class="math">$g(X) = \\sum_{i \\in [n], j \\in [m]} f(\\vec{i}, \\vec{j}) \\cdot X^{i \\times m + j}.</span>$</p>

    <p class="text-gray-300">This duality with KZH comes for free; for example, the same group element serves as both a KZG and KZH commitment. We defer the security proof of this modification of KZH to future work.</p>

    <p class="text-gray-300">Free opening on the boolean hypercube for KZH. As previously mentioned, KZH takes advantage of the low-weight witness in both the commitment and opening phases. However, in the special case of the opening function at points on the Boolean hypercube, it is essentially free. Given boolean input vectors &#8407;x<sup>0</sup> and &#8407;y0, let f &lowast; (Y&#8407; ) = f(&#8407;x0, Y&#8407; ) denote the restriction of f to a fixed &#8407;x0. This corresponds to a row in the matrix of evaluation points, indexed by &#10216;&#8407;x0&#10217;&mdash;i.e., the decimal value of &#8407;x0. Since this row is already stored, the prover only needs to read it from the matrix. Next, the evaluation point z<sup>0</sup> = f &lowast; (&#8407;y0) lies on the boolean hypercube and is already stored, so it does not require any additional computation. We also extend this property to KZH-k for k &gt; 2 in Appendix <a href="#page-53-1">C.1.</a></p>

    <p class="text-gray-300">Applying the Protostar compiler, we build an accumulator for KZH, the polynomial commitment scheme described in Section <a href="#page-17-1">4.</a> For the polynomial evaluation predicate, we have that the instance &pi;.x and witness &pi;.w are as follows:</p>

    <p class="text-gray-300"><span class="math">$\\pi.x = \\{\\mathsf{C}, \\vec{x}_0, \\vec{y}_0, z_0\\}, \\pi.w = \\{\\vec{\\mathsf{D}} := [\\mathsf{D}^{(\\vec{x})}]_{\\vec{x} \\in B_n}, f^*(\\vec{Y})\\}</span>$</p>

    <p class="text-gray-300">where C is the commitment to  <span class="math">f(\\vec{X}, \\vec{Y})</span> ,  <span class="math">(\\vec{x}_0, \\vec{y}_0) \\in \\mathbb{F}^{\\nu+\\mu}</span>  is the opening value,  <span class="math">z_0</span>  is claimed to be  <span class="math">z_0 = f(\\vec{x}_0, \\vec{y}_0)</span> , and  <span class="math">\\pi.w</span>  is the output of  <span class="math">\\mathsf{Open}_{\\mathsf{KZH}}</span> . The accumulator instance and witness are defined as follows, where the red elements only appear in the accumulator and not in a proof:<sup>g</sup></p>

    <p class="text-gray-300"><span class="math">$acc.x = \\{C, T, \\vec{x}_0, \\vec{y}_0, z_0, E\\},\\</span>$</p>

    <p class="text-gray-300"><span class="math">$\\mathrm{acc.} w = \\{\\vec{\\mathsf{D}} := [\\mathsf{D}^{(\\vec{x})}]_{\\vec{x} \\in B_n}, \\vec{f}^*, \\, \\textcolor{red}{\\mathcal{T}^{(x)}}, \\textcolor{red}{\\mathcal{T}^{(y)}}\\}</span>$</p>

    <p class="text-gray-300">for  <span class="math">T \\in \\mathbb{G}_1</span> ,  <span class="math">\\mathcal{T}^{(x)} \\in \\mathcal{T}(\\mathbb{F}, \\nu)</span> ,  <span class="math">\\mathcal{T}^{(y)} \\in \\mathcal{T}(\\mathbb{F}, \\mu)</span> , and  <span class="math">\\vec{f}^*</span>  which is the vector of the evaluation of  <span class="math">f^*(\\vec{Y})</span>  on the boolean hypercube. We also define the function Dec to represent the checks performed by Verify<sub>KZH</sub>. This function computes the error term in the verifier equations, which should evaluate to 0 when evaluated in a fresh proof. Given a tree  <span class="math">\\mathcal{T}</span>  of depth n and a vector  <span class="math">\\vec{x} = (x_1, x_2, \\dots, x_n)</span> , the error tree  <span class="math">\\overline{\\mathsf{EqTree}}(\\mathcal{T}, \\vec{x})</span>  is another tree of depth n constructed as follows: The root node of the error tree is initialized to 0; for each node in  <span class="math">\\mathcal{T}</span>  at depth i with value t, having left and right children with values  <span class="math">\\ell</span>  and r, respectively, the corresponding nodes in the error tree have left and right child values  <span class="math">\\ell - t \\times (1 - x_i)</span>  and  <span class="math">r - t \\times x_i</span> , respectively. Now given the following values,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathcal{T}_x^{(\\text{error})} \\leftarrow \\overline{\\mathsf{EqTree}}(\\mathcal{T}^{(x)}, \\, \\vec{x}_0)</span></li>
      <li><span class="math">\\mathcal{T}_{y}^{(\\text{error})} \\leftarrow \\overline{\\mathsf{EqTree}}(\\mathcal{T}^{(y)}, \\, \\vec{y}_{0})</span></li>
      <li><span class="math">e&#x27;&#x27; \\leftarrow \\langle f^*, \\mathcal{T}^{(y)}. \\text{leaves} \\rangle z</span></li>
      <li><span class="math">\\mathsf{E}_{\\mathbb{G}} \\leftarrow \\langle \\vec{f^*}, (\\mathsf{H}^{(\\vec{y})})_{\\vec{y} \\in B_n} \\rangle \\langle \\mathcal{T}^{(x)}. \\text{leaves}, \\vec{\\mathsf{D}} \\rangle</span></li>
    </ul>

    <p class="text-gray-300">Dec is defined as it follows:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Dec}(\\vec{x}_0,\\vec{y}_0,z_0,\\vec{f}^*,\\mathcal{T}^{(x)},\\mathcal{T}^{(y)},\\vec{\\mathsf{D}}) \\ = \\langle \\mathcal{T}_x^{(\\mathsf{error})} || \\mathcal{T}_y^{(\\mathsf{error})} || e&#x27;&#x27;,\\vec{\\mathsf{K}} || \\mathsf{K}&#x27; \\rangle + \\mathsf{E}_{\\mathbb{G}}.</span>$</p>

    <p class="text-gray-300">The algorithms  <span class="math">\\mathsf{Setup}_{\\mathsf{acc}}</span>  and  <span class="math">\\mathsf{P}_{\\mathsf{acc}}</span>  are described in Figure 3 whereas  <span class="math">\\mathsf{V}_{\\mathsf{acc}}</span>  and  <span class="math">\\mathsf{D}_{\\mathsf{acc}}</span>  are in Figure 4. In Figure 3, in fact challenge  <span class="math">\\beta</span>  is the random challenge coming from the verifier in an interactive accumulation protocol, but we directly apply Fiat-Shamir heuristic to make the protocol non-interactive, deriving the random challenge through a random oracle initialized with a hash function. We present an overview of the efficiency of the accumulation scheme below:</p>

    <p class="text-gray-300"><strong>Communication.</strong> The size of the accumulation witness is  <span class="math">O(n+m) = O(\\ell^{\\frac{1}{2}})</span> . The accumulator instance is constant in size. The communication is significantly lower than Nova, Halo Infinite, HyperNova and Protostar, where it is  <span class="math">\\Theta(\\ell)</span> . Using the generalization to multivariate polynomial commitments in Appendix C, we can reduce the communication to  <span class="math">O(k \\cdot \\ell^{\\frac{1}{k}})</span></p>

    <p class="text-gray-300">gHere, proof refers to a fresh accumulator in the context of an accumulator.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;h</sup>Optimized as  <span class="math">E&#x27;&#x27; \\leftarrow E + \\beta \\times (E - E&#x27;) + (1 - \\beta)\\beta \\times Q</span></p>

    <pre><code class="language-text">Setup&lt;sub&gt;acc&lt;/sub&gt;(1^{\\lambda}, k):
</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\operatorname{srs}_{\\mathsf{K7H}} \\leftarrow \\operatorname{Setup}_{\\mathsf{K7H}}(\\lambda, k)</span> .</li>
      <li>Parse n,m from  <span class="math">\\mathsf{srs}_{\\mathsf{KZH}}</span>  and generate  <span class="math">\\vec{\\mathsf{K}} = (\\mathsf{K}_1,\\dots,\\mathsf{K}_{2\\cdot(n+m-1)}) \\in \\mathbb{G}_1^{2\\cdot(n+m-1)}</span>  and  <span class="math">\\mathsf{K}&#x27; \\leftarrow \\mathbb{G}_1</span>  (unknown DLOG from all other generators).</li>
      <li>Output srs =  <span class="math">(srs_{KZH}, \\vec{K}, K&#x27;)</span> .</li>
    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{P}_{\\mathsf{acc}}(\\mathsf{srs},\\mathsf{st},(\\pi.x,\\pi.w),(\\mathsf{acc}_1.x,\\mathsf{acc}_1.w))</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">Build accumulator ( <span class="math">acc_2.x, acc_2.w</span> ) from  <span class="math">(\\pi.x, \\pi.w)</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\begin{array}{l} \\ \\operatorname{Parse} \\ (\\mathsf{C}_2, \\vec{x}_2, \\vec{y}_2, z_2) \\leftarrow \\pi.x \\ \\operatorname{and} \\ (\\{\\mathsf{D}_2^{(\\vec{x})}\\}_{\\vec{x} \\in B_n}, f_2^*(\\vec{Y})) \\leftarrow \\pi.w \\\\ \\ \\operatorname{Let} \\ \\mathcal{T}_2^{(x)} \\leftarrow \\operatorname{EqTree}(\\vec{x}_2), \\mathcal{T}_2^{(y)} \\leftarrow \\operatorname{EqTree}(\\vec{y}_2) \\\\ \\ \\operatorname{Parse} \\ \\mathcal{T}_2^{(x)} \\in \\mathbb{F}^{2n-1}, \\ \\mathcal{T}_2^{(y)} \\in \\mathbb{F}^{2m-1} \\ \\operatorname{and} \\ \\operatorname{compute} \\ T_2 \\leftarrow \\langle \\mathcal{T}_2^{(x)} || \\mathcal{T}_2^{(y)}, \\vec{\\mathsf{K}} \\rangle \\\\ \\ \\operatorname{Output} \\ \\operatorname{acc}_2.x = \\{\\mathsf{C}_2, T_2, \\vec{x}_2, \\vec{y}_2, z_2, 0_{\\mathbb{G}}\\}, \\ \\operatorname{acc}_2.w = (\\{\\mathsf{D}_2^{(\\vec{x})}\\}_{\\vec{x} \\in B_n}, \\vec{f}_2^*, \\mathcal{T}_2^{(x)}, \\mathcal{T}_2^{(y)}\\} \\end{array}</span></li>
    </ul></li>
      <li><p class="text-gray-300">Compute proof pf:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse  <span class="math">(\\mathsf{C}_1,\\,T_1,\\,\\vec{x}_1,\\vec{y}_1,z_1,\\mathsf{E}_1) \\leftarrow \\mathsf{acc}_1.x</span>  and  <span class="math">(\\{\\mathsf{D}_1^{(\\vec{x})}\\}_{\\vec{x}\\in B_n},\\,\\vec{f}_1^*,\\mathcal{T}_1^{(x)},\\mathcal{T}_1^{(y)}) \\leftarrow \\mathsf{acc}.w</span></li>
      <li>Set pf = Q for  <span class="math">Q \\in \\mathbb{G}_1</span>  such that,</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\begin{array}{l} \\mathsf{Dec}((1-X)\\cdot(\\vec{x}_1,\\vec{y}_1,z_1,\\vec{f}_1^*,\\mathcal{T}_1^{(x)},\\mathcal{T}_1^{(y)},\\vec{\\mathsf{D}}_1) + X\\cdot(\\vec{x}_2,\\vec{y}_2,z_2,\\vec{f}_2^*,\\mathcal{T}_2^{(x)},\\mathcal{T}_2^{(y)},\\vec{\\mathsf{D}}_2)) \\\\ = (1-X)\\times\\mathsf{E}_1 + X\\times\\mathsf{E}_2 + (1-X)\\cdot X\\times\\mathsf{Q} \\end{array}</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Accumulate  <span class="math">(acc_1.x, acc_1.w)</span>  and  <span class="math">(acc_2.x, acc_2.w)</span>  into (acc.x, acc.w):    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate challenge  <span class="math">\\beta \\leftarrow H(\\mathsf{acc}_1.x, \\mathsf{acc}_2.x, \\mathsf{Q})</span>  through Fiat-Shamir.</li>
      <li>Compute new error term</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mathsf{E} \\leftarrow (1-\\beta) \\times \\mathsf{E}_1 + \\beta \\times \\mathsf{E}_2 + (1-\\beta)\\beta \\times \\mathsf{Q}^{\\mathrm{h}}</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute the following linear combinations:</li>
    </ul>

    <p class="text-gray-300"><span class="math">$(\\mathsf{C}, T, \\vec{x}, \\vec{y}, z) = (1 - \\beta) \\cdot (\\mathsf{C}_1, T_1, \\vec{x}_1, \\vec{y}_1, z_1) + \\beta \\cdot (\\mathsf{C}_2, T_2, \\vec{x}_2, \\vec{y}_2, z_2)</span>$</p>

    <p class="text-gray-300">and set  <span class="math">acc.x = (C, T, \\vec{x}, \\vec{y}, z, E)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute the new accumulator witness</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mathsf{acc.} w \\leftarrow (1-\\beta) \\cdot (\\{\\mathsf{D}_1^{(\\vec{x})}\\}_{\\vec{x} \\in B_n}, \\vec{f_1}^*, \\mathcal{T}_1^{(x)}, \\mathcal{T}_1^{(y)}) + \\beta \\cdot (\\{\\mathsf{D}_2^{(\\vec{x})}\\}_{\\vec{x} \\in B_n}, \\vec{f_2}^*, \\mathcal{T}_2^{(x)}, \\mathcal{T}_2^{(y)})</span>$</p>

    <p class="text-gray-300">- Output (acc.x, acc.w, pf)</p>

    <p class="text-gray-300">Figure 3: Setup and prover algorithms for KZH-fold</p>

    <p class="text-gray-300">Vacc(srs, acc.x1, acc.x2, pf):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse (C1, T1, &#8407;x1, &#8407;y1, z1, E1) &larr; acc1.x and (C2, T2, &#8407;x2, &#8407;y2, z2, E2) &larr; acc2.x</li>
      <li>Parse Q &larr; pf</li>
      <li>Regenerate challenge &beta; &larr; H(acc1.x, acc2.x, Q)</li>
      <li>Compute E &larr; (1 &minus; &beta;) &times; E<sup>1</sup> + &beta; &times; E<sup>2</sup> + (1 &minus; &beta;) &middot; &beta; &times; Q and</li>
    </ul>

    <p class="text-gray-300"><span class="math">$(\\mathsf{C}, T, \\vec{x}, \\vec{y}, z) = (1 - \\beta) \\cdot (\\mathsf{C}_1, T_1, \\vec{x}_1, \\vec{y}_1, z_1) + \\beta \\cdot (\\mathsf{C}_2, T_2, \\vec{x}_2, \\vec{y}_2, z_2)</span>$</p>

    <p class="text-gray-300">&bull; Output acc.x = (C, T, &#8407;x, &#8407;y, z, E)</p>

    <p class="text-gray-300">Dacc(srs, acc.x, acc.w):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse (C, T, &#8407;x0, &#8407;y0, z0, E) &larr; acc.x and ({D (&#8407;x)}&#8407;x&isin;B<sup>n</sup> , &#8407;f &lowast; , T (x) , T (y) ) &larr; acc.w</li>
      <li>Output 1 if and only if all following checks pass, otherwise output 0.</li>
    </ul>

    <p class="text-gray-300"><span class="math">$(i) \\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}^{(\\vec{x})}, \\mathsf{V}^{(\\vec{x})}) \\stackrel{?}{=} e(\\mathsf{C}, \\mathsf{V}&#x27;)</span>$</p>

    <p class="text-gray-300">(ii)
<span class="math">$\\langle (\\mathcal{T}^{(x)}||\\mathcal{T}^{(y)}), \\vec{\\mathsf{K}} \\rangle \\stackrel{?}{=} T</span>$</p>

    <p class="text-gray-300">
<span class="math">$(iii) \\ \\operatorname{Dec}(\\vec{x}_0,\\vec{y}_0,z_0,\\vec{f^*},\\mathcal{T}^{(x)},\\mathcal{T}^{(y)},\\vec{\\mathsf{D}}) \\stackrel{?}{=} \\mathsf{E}</span>$</p>

    <p class="text-gray-300">Figure 4: Verifier and decider algorithms in KZH-fold</p>

    <p class="text-gray-300"><strong>Decider complexity.</strong> The decider is essentially has the same characteristic of KZH verifier, and thus runs in time  <span class="math">O(\\ell^{\\frac{1}{2}})</span>  or  <span class="math">O(k \\cdot \\ell^{\\frac{1}{k}})</span>  in the generalized case.</p>

    <p class="text-gray-300"><strong>Prover complexity.</strong> The accumulation prover performs  <span class="math">O(n+m) = O(\\ell^{\\frac{1}{2}})</span>  operations to combine the two witnesses and compute the cross-term  <span class="math">\\mathbb{Q}</span> . This contrasts with previous approaches - namely Nova, Halo Infinite, and Protostar - which require a linear number of operations.</p>

    <p class="text-gray-300"><strong>Verifier complexity.</strong> The accumulation verifier performs 3-4  <span class="math">\\mathbb{G}_1</span>  exponentiations, along with a constant number of field operations, which is consistent with schemes like Nova (requiring 2-3  <span class="math">\\mathbb{G}_1</span>  operations) and Protostar (requiring 3-4  <span class="math">\\mathbb{G}_1</span>  operations).</p>

    <p class="text-gray-300"><strong>Theorem 4.</strong> The protocol in Figures 3 and 4 is an accumulator scheme satisfying completeness and knowledge soundness as in Definition 2, in the AGM under the dlog assumption.</p>

    <p class="text-gray-300">The proof is deferred to Appendix B.2. Intuitively, correctness follows since  <span class="math">V_{acc}</span>  and  <span class="math">D_{acc}</span>  together go through the same computations as  <span class="math">P_{acc}</span> , and thus the outputs are the same. For soundness, note that if decider's first check passes, since  <span class="math">\\beta</span>  is computed after the prover outputs  <span class="math">acc_1</span>  and  <span class="math">acc_2</span> , it implies the first check of the KZH verifier is satisfied for  <span class="math">C_1</span> ,  <span class="math">\\{D_1^{(\\vec{x})}\\}</span>  and for  <span class="math">C_2</span> ,  <span class="math">\\{D_2^{(\\vec{x})}\\}</span> . For the other two KZH verifier checks, the decider computes the error terms and verifies their consistency with the error term computed by  <span class="math">P_{acc}</span> . Again, since  <span class="math">\\beta</span>  depends on the outputs of  <span class="math">P_{acc}</span> , the error terms of  <span class="math">acc_1</span>  and  <span class="math">acc_2</span>  are correctly computed and thus the KZH checks are satisfied.</p>

    <p class="text-gray-300">In the previous section, we designed a polynomial accumulation scheme (KZH-fold). Next, using that, we aim to build an accumulation scheme for the NP-complete language of R1CS. Our strategy is to translate R1CS via Spartan PIOP into polynomial checks and then accumulate those polynomial evaluations with PA. Specifically, when we translate R1CS with Spartan, we obtain an evaluation for the witness polynomial and three evaluation for the multilinear extension of the R1CS matrices. Let  <span class="math">A, B, C \\in \\mathbb{F}^{n \\times m}</span>  be the R1CS matrices and subsequently define  <span class="math">\\mu_n = \\log_2(n)</span>  and  <span class="math">\\mu_m = \\log_2(m)</span> . Further, let  <span class="math">\\tilde{A}(X,Y) \\in \\mathbb{F}[X_1,\\ldots,X_{\\mu_n},Y_1,\\ldots,Y_{\\mu_m}]</span>  be the multilinear extension of A and similarly define  <span class="math">\\tilde{B}</span>  and  <span class="math">\\tilde{C}</span> . In Spartan [Set20], the prover and verifier compute a random challenge  <span class="math">\\vec{r}</span>  via Fiat-Shamir and run a sumcheck protocol for the following equation</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{x} \\in \\{0,1\\}^{\\mu_n}} \\operatorname{eq}(\\vec{r},\\vec{x}) \\cdot \\left( \\tilde{A}z(\\vec{x}) \\cdot \\tilde{B}z(\\vec{x}) - \\tilde{C}z(\\vec{x}) \\right) = 0</span>$</p>

    <p class="text-gray-300">in which Az&tilde; (&#8407;x) = P &#8407;y&isin;{0,1} &micro;m A&tilde;(&#8407;x, &#8407;y) &middot; z&tilde;(&#8407;y). Now to accumulate the equation above, we need to accumulate the evaluations of A, &tilde; B, &tilde; C&tilde; and z&tilde; (witness polynomial). We can directly accumulate the witness polynomial with an PA such as KZH-fold. However, the same strategy cannot be applied to the multilinear extension of matrices since these polynomials are sparse and interpolating them directly with KZH-fold will result in a large SRS, hence we take a different strategy. For extension polynomials A&tilde;, B&tilde; and C&tilde;, note that we need to accumulate the evaluations of the same multilinear polynomial at multiple evaluation points, i.e. A&tilde;(r (1) <sup>x</sup> , r (1) <sup>y</sup> ) = z (1) and A&tilde;(r (2) <sup>x</sup> , r (2) <sup>y</sup> ) = z (2). This can be done easily using a simple random linear combination. We present an accumulation scheme in Figure <a href="#page-26-0">5</a> for relation <sup>R</sup>A&tilde;, i.e. <sup>A</sup>&tilde; <sup>&isin;</sup> MLP(F, &micro;<sup>n</sup> <sup>+</sup> <sup>&micro;</sup>m) as defined below:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{R}_{\\tilde{A}} = \\{ (r_x \\in \\mathbb{F}^{\\mu_n}, r_y \\in \\mathbb{F}^{\\mu_m}, z \\in \\mathbb{F}) : \\tilde{A}(r_x, r_y) = z \\}</span>$</p>

    <p class="text-gray-300">Given a polynomial accumulation scheme (e.g., KZH-fold) and the accumulation of sparse matrix evaluations described in Figure <a href="#page-26-0">5,</a> we can now accumulate the polynomial checks produced by the Spartan PIOP. This enables us to construct an accumulation scheme for R1CS, as we describe in detail in the next subsection.</p>

    <p class="text-gray-300">In the previous section, we introduced a polynomial commitment scheme and built an accumulation scheme for its verifier, i.e. the polynomial evaluation predicate in Section <a href="#page-20-0">4.1.</a> Notably, many modern NARK constructions have succinct verifiers when given oracle access to a polynomial commitment scheme capable of proving polynomial evaluations. In Subsection <a href="#page-24-1">5.1,</a> we introduce a PIOP for R1CS inspired by Spartan with these characteristics. Thus, from Theorem <a href="#page-17-2">1</a> in Section <a href="#page-17-0">3.5,</a> an accumulation scheme for PCS (e.g. KZH) implies an accumulation scheme for R1CS. Next, from Theorem <a href="#page-17-3">2</a> there exists an efficient transformation that takes the NARK and its accumulation scheme and constructs an IVC (PCD) scheme IVC = (SetupIVC, PIVC, VIVC) which we just refer to as Spartan+PA. According to Theorem <a href="#page-17-3">2,</a> this IVC (PCD) scheme for a step function with size n (i.e. the step function represented as R1CS has size n) has the following efficiency properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>PIVC time = the prover time of PA.</li>
      <li>VIVC time = the decider time of PA.</li>
      <li>Proof size of IVC = the accumulator size of PA.</li>
    </ul>

    <p class="text-gray-300">For example when PA=KZH-fold, it implies the prover cost per step is O(n) while the verifier time and proof size are O(n 1 <sup>2</sup> ). This is in contrast with IVC schemes from Nova, HyperNova and Protostar which have O(n) prover time, verifier time and proof size. An overview of Spartan+PA's step function initiated with KZH-fold can be seen in Figure <a href="#page-27-1">6.</a></p>

    <p class="text-gray-300"><span class="math">$\\mathsf{P}_{\\mathsf{ABC}}(\\tilde{A}, (r_x^{(1)}, r_y^{(1)}, z^{(1)}), (r_x^{(2)}, r_y^{(2)}, z^{(2)}))</span>$
:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Given two satisfying instances  <span class="math">(r_x^{(1)},\\,r_y^{(2)},\\,z^{(1)}),\\,(r_x^{(2)},\\,r_y^{(2)},\\,z^{(2)})\\in\\mathcal{R}_{\\tilde{A}}</span></li>
      <li>Prover computes q(X) in the following polynomial identity where q(x) is a polynomial of degree  <span class="math">\\mu + \\nu 2</span> .</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\tilde{A}((1-X) \\cdot r_x + X \\cdot r_x&#x27;, (1-X) \\cdot r_y + X \\cdot r_y&#x27;) = (1-X) \\cdot z + X \\cdot z&#x27; + (1-X) \\cdot X \\cdot q(X)</span>$</p>

    <p class="text-gray-300">Note q(X) can be computed directly through polynomial interpolation by evaluating the identity above with different X values.</p>

    <p class="text-gray-300">&bull; Derive challenge</p>

    <p class="text-gray-300"><span class="math">$\\alpha \\leftarrow H((r_x^{(1)},\\,r_y^{(2)},\\,z^{(1)}),(r_x^{(2)},\\,r_y^{(2)},\\,z^{(2)}),q(X))</span>$</p>

    <p class="text-gray-300">&bull; Compute the accumulated instances as follows:</p>

    <p class="text-gray-300"><span class="math">$r_x \\leftarrow (1 - \\alpha) \\cdot r_x^{(1)} + \\alpha \\cdot r_x^{(2)} \\quad r_y \\leftarrow (1 - \\alpha) \\cdot r_y^{(1)} + \\alpha \\cdot r_y^{(2)}</span>$</p>

    <p class="text-gray-300"><span class="math">z \\leftarrow (1 - \\alpha) \\cdot z^{(1)} + \\alpha \\cdot z^{(2)} + \\alpha \\cdot (1 - \\alpha) \\cdot q(\\alpha)</span></p>

    <p class="text-gray-300">&bull; Output accumulated instance  <span class="math">(r_x, r_y, z)</span>  along with accumulation proof q(x)</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{V}_{\\mathsf{ABC}}((r_x^{(1)}, r_y^{(1)}, z^{(1)}), (r_x^{(2)}, r_y^{(2)}, z^{(2)}), q(X)) \\mathbf{:}</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Derive challenge  <span class="math">\\alpha \\leftarrow H((r_x^{(1)},\\,r_y^{(2)},\\,z^{(1)}),(r_x^{(2)},\\,r_y^{(2)},\\,z^{(2)}),q(X))</span></li>
      <li>Compute the accumulated instances as it follows:</li>
    </ul>

    <p class="text-gray-300"><span class="math">$r_x \\leftarrow (1 - \\alpha) \\cdot r_x^{(1)} + \\alpha \\cdot r_x^{(2)} \\quad r_y \\leftarrow (1 - \\alpha) \\cdot r_y^{(1)} + \\alpha \\cdot r_y^{(2)}</span>$</p>

    <p class="text-gray-300"><span class="math">z \\leftarrow (1 - \\alpha) \\cdot z^{(1)} + \\alpha \\cdot z^{(2)} + \\alpha \\cdot (1 - \\alpha) \\cdot q(\\alpha)</span></p>

    <p class="text-gray-300">&bull; Output accumulated instance  <span class="math">(r_x, r_y, z)</span></p>

    <p class="text-gray-300">
<span class="math">$\\mathsf{D}_{\\mathsf{ABC}}(\\tilde{A},(r_x,r_y,z))</span>$
: Compute  <span class="math">z&#x27; \\leftarrow \\tilde{A}(r_x,r_y)</span>  and assert  <span class="math">z \\stackrel{?}{=} z&#x27;</span></p>

    <p class="text-gray-300">Figure 5: Matrix evaluation accumulation description</p>

    <p class="text-gray-300">    <img src="_page_27_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 6: Spartan+PA step (augmented) circuit initiated with KZH-fold</p>

    <p class="text-gray-300">This construction works with any other PCS accumulation scheme too as long as the accumulation verifier is sublinear. In the next section, we will use Spartan+KZH-fold to build an efficient signature aggregation scheme. Our Spartan+PA construction is not zero knowledge; however, we believe that one can use the techniques presented in HyperNova [KS23c] to make our IVC scheme zero knowledge, we leave this to future work.</p>

    <p class="text-gray-300">Review on previous work. N-IVC [KS22] extends traditional IVC by allowing each step to execute one of several predefined instructions  <span class="math">F_1, F_2, \\ldots, F_k</span>  rather than a single instruction F. Earlier implementations relied on a universal circuit that computes all instructions and selects the output based on the program counter, resulting in inefficiency as the prover computes every instruction, even when only one is needed. SuperNova improves this by maintaining a running accumulator for each instruction and using memory techniques (e.g., Merkle trees) to select and accumulate only the relevant accumulator at each step, reducing he per-step computation cost of the prover to align with the step circuit cost. However, the witness size grows linearly with the combined sizes of all instruction witnesses. Protostar [BC23] offers a similar improvement, leveraging the fact that committing to zeros incurs no additional cost. While it also reduces the per-step computation cost of the prover to the cost of the step circuit for N-IVC, like SuperNova, it still requires the prover to manage a witness size that scales linearly with the sum of all instruction witnesses.</p>

    <p class="text-gray-300">Similar to N-IVC, N-PCD [Zhe+23] extends the definition of PCD to support multiple instruction circuits instead of a single instruction. Constructing N-PCD using previous approaches results in both the prover's computation and witness size being linear in the combined size of all instructions. Intuitively, SuperNova maintains a set of running ac-</p>

    <p class="text-gray-300">cumulator, one for each instruction. Accumulating this running accumulator with a fresh accumulator can be done efficiently by selecting the correct running accumulator. However, to construct N-PCD, it must accumulate two sets of running accumulators, leading to a prover time that is linear in the combined size of all instruction circuits, along with the size of the circuit growing linearly with k, i.e. the number of instructions. Protostar follows a similar paradigm, building a universal circuit and maintaining a Pedersen commitment to it. To execute one of the instruction circuits, the wires of the other instructions are set to zero. Since these zeroed wires do not contribute to the commitment, the cost of committing to the wires of this universal circuit to run a single instruction matches the step circuit cost. However, accumulating two running accumulators requires computing a new commitment that is linear in the size of the universal circuit. However, the circuit size remains constant, since it requires taking a linear combination between two Pederson commitments.</p>

    <p class="text-gray-300">KiloNova <a href="#page-42-0">[Zhe+23]</a> naively builds non-uniform PCD based on HyperNova and results in the same issue as SuperNova. Their construction relies on the ability to efficiently fold commitments to sparse CCS matrices, which is necessary for IVC/PCD. Unfortunately, folding different sparse matrices does not necessarily preserve sparseness as demonstrated in Appendix <a href="#page-64-0">D</a> and that is the reason, in this work we avoid folding sparse matrices with different structures.</p>

    <p class="text-gray-300">N-IVC and N-PCD from Spartan+PA. We propose an alternative approach to achieve N-IVC and N-PCD via Spartan+PA with appealing efficiency and communication features. Our N-PCD is the first N-PCD scheme in which the prover is efficient, i.e. the prover time is not linear in the combined size of all instructions and the decider algorithm only requires group operations proportional to the maximum instruction size, while it needs a linear number of field operations in the combined size of all instructions. This is in contrast to SuperNova and Protostar, where the decider requires linear group operations in the combined size of all circuits. Given that group scalar multiplication is 100x-1000x more expensive than a field operation<a href="#page-28-0">i</a> , the decider's cost in these schemes is dominated by the number of group operations, making our decider far more efficient. Let F1, F2, ..., F<sup>k</sup> be the instruction circuits. An overview and comparison of our approach to N-IVC and N-PICD can be seen in Tables <a href="#page-29-0">3</a> and <a href="#page-29-1">4</a> respectively. The high-level idea is to accumulate polynomials corresponding to F<sup>i</sup> rather than accumulating the circuit F<sup>i</sup> (i.e. its R1CS representation) directly. The key insight is that any polynomial of degree d<sup>i</sup> &lt; D can be padded to become a polynomial of degree D, allowing it to be accumulated with a running polynomial of degree D. To be more precise, to build N-IVC and N-PCD from Spartan+PA, we maintain a running accumulator corresponding to a polynomial of degree D and use it to accumulate PCS opening statements of degree d<sup>i</sup> (e.g., opening a witness commitment at a random point) required by the Spartan verifier. This strategy is compatible with any polynomial accumulation scheme with a sublinear accumulation verifier. We</p>

    <p class="text-gray-300">i <a href="https://zka.lc/" target="_blank" rel="noopener noreferrer">https://zka.lc/</a></p>

    <p class="text-gray-300">defer its details to Appendix D.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Scheme</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Prover Time</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Verifier Time</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Witness Size</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SuperNova</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O( F_i )</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O\\left(\\sum_{i} F_{i} \\right)\\mathbb{G}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O\\left(\\sum_{i} F_{i} \\right)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Protostar</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O( F_i )</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O\\left(\\sum_{i} F_{i} \\right)\\mathbb{G}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O\\left(\\sum_{i} F_{i} \\right)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Spartan+PA</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{P}_{\\mathrm{acc}}(\\max_i  F_i )</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{D}_{\\mathrm{acc}}(\\max_{i} F_{i} ) + O\\left(\\sum_{i} F_{i} \\right)\\mathbb{F}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O( \\mathrm{acc}  + \\sum_{i} \\log  F_i )</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Spartan+KZH-fold</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O(\\max_i  F_i )</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O\\left(\\sqrt{\\max_{i} F_{i} }\\right) + O\\left(\\sum_{i} F_{i} \\right)\\mathbb{F}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O\\left(\\sqrt{\\max_i  F_i } + \\sum_i \\log  F_i \\right)</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 3: Comparison of different N-IVC approaches based on prover/verifier time and witness size. We assume SuperNova is working over Nova and Protostar is working over Pedersen commitment, while we describe our approach as generic over a polynomial accumulation scheme PA, where  <span class="math">\\mathcal{P}_{acc}(\\max_i |F_i|)</span>  denotes the time for the accumulation prover to accumulate two accumulators of size  <span class="math">\\max_i |F_i|</span> , which is  <span class="math">O(\\max_i |F_i|)</span>  for KZH-fold. Similarly,  <span class="math">\\mathcal{D}_{acc}(\\max_i |F_i|)</span>  represents the decider time for an accumulator of size  <span class="math">\\max_i |F_i|</span> , given by  <span class="math">O(\\sqrt{\\max_i |F_i|})</span>  for KZH-fold.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Scheme</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Prover Time</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Verifier Time</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Witness Size</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SuperNova</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O(\\sum  F_i )</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O(\\sum  F_i )\\mathbb{G}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O(\\sum_{i}  F_{i} )</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Protostar</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O(\\sum  F_i )</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O(\\sum  F_i )\\mathbb{G}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O(\\sum_{i}  F_{i} )</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">KiloNova</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O(\\sum  F_i )</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O(\\sum  F_i )\\mathbb{G}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O(\\sum_{i}  F_{i} )</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Spartan+PA</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{P}_{\\rm acc}(\\max_i  F_i ) + \\sum_i \\log  F_i </span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{D}_{\\mathrm{acc}}(\\max_{i} F_{i} ) + O(\\sum_{i} F_{i} )\\mathbb{F}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O( \\mathrm{acc}  + \\sum_{i} \\log  F_i )</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Spartan+KZH-fold</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O(\\max_i  F_i ) + \\sum_i \\log  F_i </span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O(\\sqrt{\\max_i  F_i }) + O(\\sum_i  F_i )\\mathbb{F}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O(\\sqrt{\\max_i  F_i } + \\sum_i \\log  F_i )</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 4: Comparison of different N-PCD approaches based on prover/verifier time and witness size. We assume SuperNova is working over Nova and Protostar is working over Pedersen commitment, while we describe our approach as generic over a polynomial accumulation scheme PA where  <span class="math">\\mathcal{P}_{acc}(\\max_i |F_i|)</span>  denotes the time for the accumulation prover to accumulate two accumulators of size  <span class="math">\\max_i |F_i|</span> , which is  <span class="math">O(\\max_i |F_i|)</span>  for KZH-fold. Similarly,  <span class="math">\\mathcal{D}_{acc}(\\max_i |F_i|)</span>  represents the decider time for an accumulator of size  <span class="math">\\max_i |F_i|</span> , given by  <span class="math">O(\\sqrt{\\max_i |F_i|})</span>  for KZH-fold.</p>

    <p class="text-gray-300">In Figure 7 and 8, we provide a protocol enabling bandwidth-efficient recursive aggregation of accountable signatures. A distinctive feature of our protocol is that the circuit size remains independent of the number of signers, made possible by the homomorphic properties of our KZH commitment scheme. Our protocol uses - as building blocks - an aggregate signature scheme (KGen<sub>ss</sub>, Sign<sub>ss</sub>, Verify<sub>ss</sub>) (Definition 4), the IVC scheme ( <span class="math">Setup_{IVC}</span> ,  <span class="math">P_{IVC}</span> ,  <span class="math">V_{IVC}</span> ) of Section 5, and our polynomial commitment scheme KZH =(Setup<sub>KZH</sub>, Commit<sub>KZH</sub>, Open<sub>KZH</sub>, Verify<sub>KZH</sub>). Our scheme also uses the famous sumcheck protocol (P<sub>smck</sub>, V<sub>smck</sub>) [Lun+90]. We implement our signature aggregation protocol using BLS as the signature scheme [BLS04], and present its efficiency, along with a comparison to the state of the art, in Section 7. To track the signers, we use a bitvector: a vector bwith a size equal to the number of validators such that  <span class="math">b_k = 1</span>  if user k has signed, and 0 otherwise. Here  <span class="math">\\langle k \\rangle</span>  is the  <span class="math">\\mu</span> -bit binary representation of k. The circuit size of the scheme is constant, independent of the number of validators, enabling the recursive aggregation of signatures for millions of validators with minimal overhead. This is achieved via utilizing the IVC scheme from Section 5. The scheme proves the union of the bitvector by relying on the fact that  <span class="math">\\vec{b}_1 \\vee \\vec{b}_2 = \\vec{b}_1 + \\vec{b}_2 - \\vec{b}_1 \\circ \\vec{b}_2</span> . In Figure 8, we build a simple sumcheck-based PIOP for this statement. We compile this PIOP into a proof system using KZH, and accumulate the resulting evaluation checks.</p>

    <p class="text-gray-300">The Setup algorithm of the signature aggregation scheme initializes the IVC scheme. Users use KGen to generate their public and signing key pair (sk, pk). Initalize initializes the vector of all public keys from the users in the system. To sign, users run Sign<sub>ss</sub>. Next, user k runs SigToAggSig to convert their signature into aggregated form. Aggregate is similar to an accumulation scheme and is run by a prover and a verifier: it takes two aggregated signatures as input and outputs a new one. The aggregated signature includes an IVC proof  <span class="math">\\pi_{\\text{IVC}}</span>  for the function F, which is the KZH verifier. That is,  <span class="math">\\pi_{\\text{IVC}}.x</span>  consists of the polynomial evaluation claims (including F and F.x) whereas  <span class="math">\\pi_{\\text{IVC}}.w</span>  is a proof that they have been aggregated correctly. Finally, Verify (intuitively, the decider of the accumulation scheme) is run to check the validity of aggregated signatures. We provide an overview of the resulting IVC circuit in Figure 9.</p>

    <p class="text-gray-300">Efficiency. The aggregate signature consists of the public key, the signature and a polynomial that interpolates the bitvector of signers, as well as an IVC proof (which contains PCS evaluation claims). Using Spartan+KZH-fold from Section 4.1, the IVC proof is  <span class="math">O(\\ell^{\\frac{1}{2}})</span>  in size. Thus the aggregate, accountable signature size is dominated by the bitvector of signers  <span class="math">\\vec{c}</span> , which contains at most  <span class="math">\\ell</span>  bits. This is the minimal information that can be transmitted for an accountable signature. The aggregator's work consists of computing and committing to  <span class="math">\\vec{c}</span>  which takes at most  <span class="math">\\ell</span>  group additions (not scalar multiplications as  <span class="math">\\vec{c}</span>  consists of bits), as well as the work of running the sumcheck prover and the accumulation prover. Both of these are linear prover time and do not require additional commitments.</p>

    <pre><code class="language-text">Setup(1&lambda;
         , n):
    &bull; Sample {(p, g1, g2, G1, G2, GT , e)} &larr;$ GGen(1&lambda;
    &bull; G &larr;$ G1
    &bull; srsIVC &larr; SetupIVC(&lambda;)
</code></pre>

    <p class="text-gray-300">&bull; Output
<span class="math">$srs = (srs_{IVC}, G)</span>$</p>

    <p class="text-gray-300"><span class="math">KGen(\\lambda)</span> :  <span class="math">(sk, pk) \\leftarrow KGen_{ss}(1^{\\lambda}, n)</span></p>

    <p class="text-gray-300">Intialize(srsPC, [pk<sup>i</sup> n <sup>i</sup>=1):</p>

    <p class="text-gray-300">Compute vector commitment VC such that VC[k] = pk<sup>k</sup> .</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Sign}(\\mathsf{pk}, M \\in \\{0,1\\}^*) \\ : \\ \\sigma \\leftarrow \\mathsf{Sign}_{\\mathsf{ss}}(\\mathsf{sk}, M)</span>$</p>

    <p class="text-gray-300">SigToAggSig(k &isin; [n &middot; m], pk<sup>k</sup> , &sigma;k): user k prepares its signature to aggregate</p>

    <p class="text-gray-300">&bull; Set
<span class="math">$\\vec{b} = \\langle k \\rangle \\in \\{0, 1\\}^{\\mu}</span>$</p>

    <p class="text-gray-300">&bull;
<span class="math">$\\mathsf{B}_k \\leftarrow \\mathsf{Commit}_{\\mathsf{KZH}}(\\mathsf{srs}_{\\mathsf{KZH}}, b(\\vec{X}))</span>$</p>

    <p class="text-gray-300">&bull; Set IVC proof
<span class="math">$\\pi_{\\mathsf{IVC}}^{(k)} = \\bot</span>$</p>

    <p class="text-gray-300">&bull; Output:</p>

    <p class="text-gray-300"><span class="math">$A_k = (\\mathsf{pk}_k, \\mathsf{B}_k, \\pi_{\\mathsf{IVC},k}.x, b_k(\\vec{X}), \\sigma_k, \\pi_{\\mathsf{IVC}}^{(k)}.w)</span>$</p>

    <p class="text-gray-300">)</p>

    <p class="text-gray-300">Verify(srs, Ak): Verify an aggregated signature</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check B = CommitKZH(srsKZH, b(X&#8407; )).</li>
      <li>Check Vss(pk, M, &sigma;) = 1</li>
      <li>&bull; Check VerifyIVC(srsIVC, F, F.x, &pi;IVC) = 1</li>
    </ul>

    <p class="text-gray-300">Figure 7: Signature aggregation protocol - 1</p>

    <p class="text-gray-300">Aggregate <span class="math">(A_{k_1}, A_{k_2})</span> :</p>

    <p class="text-gray-300">Aggregate the signatures:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\bullet \\ \\ A_{k_1} = (\\mathsf{pk}_{k_1}, \\mathsf{B}_{k_1}, \\pi_{\\mathsf{IVC}}^{(k_1)}.x, \\sigma_{k_1}, b_{k_1}(\\vec{X}), \\pi_{\\mathsf{IVC}}^{(k_1)}.w)</span></li>
      <li><span class="math">\\bullet \\ \\ A_{k_2} = (\\mathsf{pk}_{k_2}, \\mathsf{B}_{k_2}, \\pi_{\\mathsf{IVC}}^{(k_2)}.x, \\sigma_{k_2}, b_{k_2}(\\vec{X}), \\pi_{\\mathsf{IVC}}^{(k_2)}.w)</span></li>
      <li>Set  <span class="math">\\mathsf{pk&#x27;} \\leftarrow \\mathsf{pk}_{k_1} + \\mathsf{pk}_{k_2}</span></li>
      <li>Set  <span class="math">\\sigma&#x27; \\leftarrow \\sigma_{k_1} + \\sigma_{k_2}</span></li>
    </ul>

    <p class="text-gray-300">Proof of well-formedness of new bitvector</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">c(\\vec{X})</span>  such that  <span class="math">c(\\vec{x}) = b_{k_1}(\\vec{x}) \\vee b_{k_2}(\\vec{x}) \\ \\forall \\vec{x} \\in \\{0,1\\}^{\\mu}</span></li>
      <li>Send C  <span class="math">\\leftarrow</span>  Commit<sub>KZH</sub>(srs<sub>KZH</sub>,  <span class="math">c(\\vec{X})</span> )</li>
      <li>Verifier sends challenge  <span class="math">\\vec{r} \\leftarrow \\mathbb{F}^{\\mu}</span></li>
      <li>Define  <span class="math">c(\\vec{X}) = b_{k_1}(\\vec{X}) + b_{k_2}(\\vec{X}) b_{k_1}(\\vec{X}) \\cdot b_{k_2}(\\vec{X})</span>  and run the sumcheck to prove that</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{x} \\in \\{0,1\\}^{\\mu}} eq(\\vec{x}, \\vec{r}) (b_{k_1}(\\vec{x}) + b_{k_2}(\\vec{x}) - b_{k_1}(\\vec{x}) \\cdot b_{k_2}(\\vec{x}) - c(\\vec{x})) = 0</span>$</p>

    <p class="text-gray-300">Output  <span class="math">b_{k_1}(\\vec{\\rho})</span> ,  <span class="math">b_{k_2}(\\vec{\\rho})</span> ,  <span class="math">\\vec{c}(\\vec{\\rho})</span>  where  <span class="math">\\vec{\\rho} \\in \\mathbb{F}^k</span>  is the vector of randomness sampled by the verifier during the sumcheck.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verifier sends random challenges  <span class="math">\\alpha_1</span> ,  <span class="math">\\alpha_2</span>  from  <span class="math">\\mathbb{F}</span></li>
      <li>Prover computes the polynomial  <span class="math">p(\\vec{X}) = b_{k_1}(\\vec{X}) + \\alpha_1 b_{k_2}(\\vec{X}) + \\alpha_2 c(\\vec{X})</span> , runs  <span class="math">(\\pi, z_0) \\leftarrow \\mathsf{Open}_{\\mathsf{KZH}}(\\mathsf{srs}_{\\mathsf{KZH}}, p(\\vec{X}), \\vec{x}_0, \\vec{y}_0, \\mathsf{aux})</span> , for  <span class="math">\\vec{x}_0 || \\vec{y}_0 = \\vec{\\rho}</span></li>
      <li>Verifier adds evaluation claim  <span class="math">(P = B_{k_1} + \\alpha_1 B_{k_2} + \\alpha_2 C, \\vec{x}_0, \\vec{y}_0, \\pi, z_0)</span>  to  <span class="math">\\pi&#x27;_{IVC}.x</span></li>
    </ul>

    <p class="text-gray-300">New Aggregated Signature:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\pi&#x27;_{IVC} \\leftarrow \\mathsf{P}_{IVC}(\\mathsf{srs}_{IVC}, F, F.x, F.w, \\pi_{IVC})</span></li>
      <li>Let  <span class="math">A&#x27; = (\\mathsf{pk}&#x27;, \\sigma&#x27;, \\mathsf{C}, \\pi&#x27;_{\\mathsf{IVC}}.x; \\sigma&#x27;, c(\\vec{X}), \\pi&#x27;_{\\mathsf{IVC}}.w)</span></li>
      <li>&bull; Output A'</li>
    </ul>

    <p class="text-gray-300">Figure 8: Signature aggregation protocol - 2</p>

    <p class="text-gray-300">    <img src="_page_33_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 9: Signature aggregation augmented circuit</p>

    <p class="text-gray-300">The aggregation verifier, which is implemented as a recursive circuit in the IVC protocol, consists of a constant number of group operations and  <span class="math">\\log(\\ell)</span>  native field operations and hashes. These are mostly used to verify the accumulation of PCS evaluation claims. The recursive circuit for each leaf also needs to check that the signer polynomial  <span class="math">\\vec{b}</span>  is instantiated correctly and that the correct public key is being aggregated. This consists of a single vector commitment check (can be outsourced using a PC) and an evaluation of two Lagrange polynomials. Using the extension from Section C, the communication cost can be lowered to  <span class="math">O(k \\cdot \\ell^{\\frac{1}{k}}) + \\ell</span>  bits, however, the aggregator's computation overhead is dominated by opening a KZH-k polynomial commitment of size  <span class="math">\\ell</span> , which still costs  <span class="math">O(\\ell^{\\frac{1}{2}})</span>  group scalar multiplications.</p>

    <p class="text-gray-300">We implement all our subprotocols in Rust, by leveraging the arkworks library<sup>j</sup>. Our CycleFold [KS23a] module builds on the implementation from the Nexus zkVM project<sup>k</sup>, and our Spartan PIOP module builds on the original Spartan codebase<sup>l</sup>. We made our implementation publicly available as an open-source library<sup>m</sup>.</p>

    <p class="text-gray-300">The accumulation verifier circuit for PCD (accumulating two accumulators) in KZH2-fold and KZH3-fold schemes, respectively requires four and five scalar multiplications, implemented using CycleFold and Ova [Ova]. The total circuit size for KZH2-fold and KZH3-fold verifiers are approximately 60k and 73k constraints on the primary curve and 12k and 15k</p>

    <p class="text-gray-300">jhttps://arkworks.rs</p>

    <p class="text-gray-300">khttps://nexus-xyz.github.io/assets/nexus_whitepaper.pdf</p>

    <p class="text-gray-300">https://github.com/microsoft/Spartan</p>

    <p class="text-gray-300">mhttps://github.com/h-hafezi/kzh_fold</p>

    <p class="text-gray-300">on the secondary curve, with about 40% of constraint on the primary curve dedicated to hashing non-native field elements. Our implementation is not highly optimized. Inspired by Nexus, we also implemented a Nova circuit for IVC, accumulating one fresh proof with a running accumulation, resulting in a circuit size of 35k constraints on the primary curve and 6k on the secondary curve<a href="#page-34-3">n</a> . This comparison aligns with expectations, for example, KZH2-fold verifier is naturally larger, requiring three to four group scalar multiplications compared to two to three for Nova.</p>

    <p class="text-gray-300">As part of our implementation, we built an augmented circuit for our signature aggregation protocol as seen in Figure <a href="#page-33-1">9,</a> along with a smaller augmented circuit for our KZH-based folding scheme for NP. We used the R1CS PIOP from Section <a href="#page-24-1">5.1</a> to prove our circuits. We ran our benchmarks on a laptop with an Intel i7-1370 CPU and 32GB of RAM and 16 cores. We used the half-pairing cycles of BN254 and Grumpkin as our primary and secondary curves. We present our results in the following sections.</p>

    <p class="text-gray-300">In Figure <a href="#page-35-0">10,</a> we provide benchmarks for our variants of KZH2, KZH3 and KZH4 polynomial commitment schemes and compare them with the celebrated KZG scheme. KZG is efficient and offers constant verification time, while KZH benefits from faster opening times and supports a natural accumulation scheme.</p>

    <p class="text-gray-300">Halo Infinite <a href="#page-43-10">[Bon+21]</a> (HI) presents an accumulation scheme for arbitrary homomorphic polynomial opening aggregation schemes. The prover aggregates n polynomial openings taking the polynomials themselves as input. In this section, we compare the efficiency of KZH2-fold, KZH3-fold and HI by implementing all three schemes in our codebase.</p>

    <p class="text-gray-300">In Figure <a href="#page-36-1">11,</a> we observe that KZH-fold's prover is significantly faster than HI's. For large witness sizes, HI spends most of its time committing to the polynomial q(x). On the other hand, we also see that HI's accumulation verifier is significantly faster compared to KZH-fold. Finally, we see how KZH-fold's communication overhead scales far more efficiently as the polynomial's size increases, since in HI's private aggregation scheme the prover must transmit the entire polynomial to the aggregator.</p>

    <p class="text-gray-300"><sup>n</sup>Unlike our implementation and Nexus, the original Nova implementation by Microsoft does not use Arkworks. We believe a primary reason for our circuit's inefficiency is likely due to inefficiencies in Arkworks' implementation of group operations and non-native field arithmetic in R1CS. For example, a group scalar multiplication by Nova reportedly takes 1k constraints while it takes 3k with Arkworks.</p>

    <p class="text-gray-300">    <img src="_page_35_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 10: KZH benchmarks and comparison with KZG. KZH polynomial degree n refers to a multilinear polynomial with n variables and hence  <span class="math">2^n</span>  size of evaluations over boolean hypercube. The polynomial coefficients for KZG and evaluation points over the boolean hypercube are selected randomly. i.e. not small field elements. When polynomial evaluation points in KZH family are set to value &lt; 1024, we realize a 10-20x improvement in the commitment time.</p>

      <h3 id="sec-7.3" class="text-xl font-semibold mt-8">7.3 Comparison with Nova</h3>

    <p class="text-gray-300">We have implemented our IVC schemes Spartan+KZH2-fold and Spartan+KZH3-fold and compared it to our implementation of Nova<sup>o</sup> using different-sized F circuits in Table 5. For the purposes of IVC, we use a circuit F that iteratively computes Poseidon hashes, and the first column contains the number of Poseidon invocations. At the end of the R1CS PIOP protocol, the decider must evaluate the R1CS matrices A, B and C at a random point. We outsource this computation by having the prover provide an opening proof. This outsourcing is independent of the rest of the protocol, allowing any polynomial commitment scheme to be used, e.g. SPARK compiler. The commitment to the matrices, which the costly part, can be performed during the setup phase.</p>

    <p class="text-gray-300">As expected, Spartan+KZH-fold prover is slower than Nova, with a factor of almost 3 for moderate computations. However, Spartan+KZH-fold accumulator size is more compact and its verifier times are faster. Spartan+KZH-fold prover is slower for two reasons. First, Nova's prover cost is essentially two MSMs, whereas Spartan+KZH-fold prover uses KZH to commit to the witness. Furthermore, Spartan+KZH-fold's augmented circuit must partially</p>

    <p class="text-gray-300"><sup>&deg;</sup>Primarily borrowed from Nexus zkVM project</p>

    <p class="text-gray-300">    <img src="_page_36_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 11: KZH-fold performance and communication cost, along with a comparison with Halo Infinite private aggregation</p>

    <p class="text-gray-300">verify the Spartan proof's sumcheck and the accumulation of the matrix evaluations (Section 5.1). We believe that a large part of the slowdown is due to unoptimized code, which can be improved.</p>

      <h3 id="sec-7.4" class="text-xl font-semibold mt-8">7.4 Comparison with BLS aggregation</h3>

    <p class="text-gray-300">We implemented our accountable signature aggregation scheme based on Spartan+KZH3-fold from Figure 8 and compared it to the accountable BLS signature aggregation scheme in Table 6. In the BLS scheme, communication cost scales with the size of the multiplicity vector, which incurs a redundancy overhead of  <span class="math">r \\cdot \\log d</span> , where r is the number of recursive aggregation layers and d is the number of aggregators per layer. For an aggregation scheme with a single layer (r=1) with 1 million validators, the multiplicity vector requires 128 kB multiplied by  <span class="math">\\log d</span> . With additional recursive layers, this cost increases linearly with r, further exacerbating bandwidth requirements for larger validator sets. Verification involves a multiscalar multiplication (MSM) to compute the aggregated public key, using the multiplicity vector and validators' public keys.</p>

    <p class="text-gray-300">In contrast, approach based on Spartan+KZH3-fold, eliminates the need for multiplicity vectors, making its communication cost independent of the number of recursive layers and the number of aggregators. The communication cost of our scheme is dominated by the participation bitfield, whereas the recursive proof itself is less than 40% of the overall size. Our signature aggregation augmented circuit is described in approximately  <span class="math">2^{19}</span>  constraints.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"># of H</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Scheme</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Prover</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Verifier</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Acc</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"># Constraints</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Spartan+KZH2-fold</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.1 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">103 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">74 KB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17 &asymp;<br>2<br>131k</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Spartan+KZH3-fold</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.87 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">62 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16 KB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17 &asymp;<br>2<br>131k</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Nova</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">157 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">250 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.8 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">35k</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Spartan+KZH2-fold</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.0 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">133 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">148 KB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19 &asymp;<br>2<br>524k</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">150</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Spartan+KZH3-fold</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.1 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">63 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25 KB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19 &asymp;<br>2<br>524k</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Nova</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">447 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">704 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.6 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">165k</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Spartan+KZH2-fold</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.2 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">193 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">197 KB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20 &asymp;<br>2<br>1048k</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1000</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Spartan+KZH3-fold</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.68 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">93 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31 KB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20 &asymp;<br>2<br>1048k</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Nova</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.0 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.8 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">42 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">675k</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Spartan+KZH2-fold</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23.1 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">295 KB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21 &asymp;<br>2<br>2097k</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2000</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Spartan+KZH3-fold</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16.5 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">135 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">37 KB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21 &asymp;<br>2<br>2097k</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Nova</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.8 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.6 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80.8 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1185k</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 5: Comparison of IVC schemes Spartan+KZH2-fold, Spartan+KZH3-fold and Nova</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"># of validators</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Scheme</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Communication</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Verifier</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BLS (r = 1, d = 16)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">512 kB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">338 ms</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BLS (r = 4, d = 16)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">340 ms</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BLS (r = 4, d = 32)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">342 ms</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ours</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">205 kB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">226 ms</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BLS (r = 1, d = 16)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">669 ms</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BLS (r = 4, d = 16)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">670 ms</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BLS (r = 4, d = 32)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">673 ms</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ours</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">333 kB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">276 ms</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BLS (r = 1, d = 16)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.29 s</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BLS (r = 4, d = 16)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.3 s</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BLS (r = 4, d = 32)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.3 s</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ours</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">589 kB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">322 ms</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 6: Comparison of BLS and Spartan+KZH3-fold based accountable signature aggregation schemes</p>

    <p class="text-gray-300">We find that the witness for this circuit is low-weight (with about 33% of the entries being zero or one). As a result, committing to this low-weight witness is significantly more efficient compared to committing to a random vector of the same size. To exploit this property, we pair KZH3-fold with the Spartan PIOP, which only requires computing a single commitment to the witness vector. Table <a href="#page-37-0">6</a> highlights the communication and verification costs of both schemes across different validator counts and recursive layers. Our approach maintains consistent communication costs regardless of r, while BLS incurs significant growth due to the r &middot; log d multiplicative factor.</p>

    <p class="text-gray-300">We would like to thank Alireza Shirzad and Yue Zhang for pointing out small mistakes in a previous version. We would like to thank anonymous reviewers who helped us to improve the paper. This work was supported by Chaincode, Alpen Labs, Google and the Sui Foundation.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[CT10] Alessandro Chiesa and Eran Tromer. &quot;Proof-Carrying Data and Hearsay Arguments from Signature Cards&quot;. In: 2010, pp. 310&ndash;331.</p></li>
      <li><p class="text-gray-300">[DG08] Jeffrey Dean and Sanjay Ghemawat. &quot;MapReduce: simplified data processing on large clusters&quot;. In: Commun. ACM 51.1 (Jan. 2008), 107&ndash;113. issn: 0001- 0782. doi: <a href="https://doi.org/10.1145/1327452.1327492" target="_blank" rel="noopener noreferrer">10.1145/1327452.1327492</a>. url: <a href="https://doi.org/10.1145/1327452.1327492" target="_blank" rel="noopener noreferrer">https://doi.org/10.1145/</a> <a href="https://doi.org/10.1145/1327452.1327492" target="_blank" rel="noopener noreferrer">1327452.1327492</a>.</p></li>
      <li><p class="text-gray-300">[CTV15] Alessandro Chiesa, Eran Tromer, and Madars Virza. &quot;Cluster Computing in Zero Knowledge&quot;. In: 2015, pp. 371&ndash;403. doi: <a href="https://doi.org/10.1007/978-3-662-46803-6_13" target="_blank" rel="noopener noreferrer">10.1007/978-3-662-46803-</a> <a href="https://doi.org/10.1007/978-3-662-46803-6_13" target="_blank" rel="noopener noreferrer">6\\_13</a>.</p></li>
      <li><p class="text-gray-300">[Her24] Polygon Hermez. Polygon zkevm: Recursion, aggregation and composition of proofs. <a href="https://github.com/0xPolygonHermez/zkevm-techdocs/blob/main/docs/proof-recursion.pdf" target="_blank" rel="noopener noreferrer">https : / / github . com / 0xPolygonHermez / zkevm - techdocs / blob /</a> <a href="https://github.com/0xPolygonHermez/zkevm-techdocs/blob/main/docs/proof-recursion.pdf" target="_blank" rel="noopener noreferrer">main/docs/proof-recursion.pdf</a>. Accessed: 2024-11-15. 2024. url: <a href="https://github.com/0xPolygonHermez/zkevm-techdocs/blob/main/docs/proof-recursion.pdf" target="_blank" rel="noopener noreferrer">https:</a> <a href="https://github.com/0xPolygonHermez/zkevm-techdocs/blob/main/docs/proof-recursion.pdf" target="_blank" rel="noopener noreferrer">/ / github . com / 0xPolygonHermez / zkevm - techdocs / blob / main / docs /</a> <a href="https://github.com/0xPolygonHermez/zkevm-techdocs/blob/main/docs/proof-recursion.pdf" target="_blank" rel="noopener noreferrer">proof-recursion.pdf</a>.</p></li>
      <li><p class="text-gray-300">[KB23] Assimakis Kattis and Joseph Bonneau. &quot;Proof of Necessary Work: Succinct State Verification with Fairness Guarantees&quot;. In: 2023, pp. 18&ndash;35. doi: <a href="https://doi.org/10.1007/978-3-031-47751-5_2" target="_blank" rel="noopener noreferrer">10.</a> <a href="https://doi.org/10.1007/978-3-031-47751-5_2" target="_blank" rel="noopener noreferrer">1007/978-3-031-47751-5\\_2</a>.</p></li>
      <li><p class="text-gray-300">[Ben+14] Eli Ben-Sasson et al. &quot;Scalable Zero Knowledge via Cycles of Elliptic Curves&quot;. In: 2014, pp. 276&ndash;294. doi: <a href="https://doi.org/10.1007/978-3-662-44381-1_16" target="_blank" rel="noopener noreferrer">10.1007/978-3-662-44381-1\\_16</a>.</p></li>
      <li><p class="text-gray-300">[KST22] Abhiram Kothapalli, Srinath Setty, and Ioanna Tzialla. &quot;Nova: Recursive Zero-Knowledge Arguments from Folding Schemes&quot;. In: 2022, pp. 359&ndash;388. doi: <a href="https://doi.org/10.1007/978-3-031-15985-5_13" target="_blank" rel="noopener noreferrer">10.1007/978-3-031-15985-5\\_13</a>.</p></li>
      <li><p class="text-gray-300">[B&uuml;n+21] Benedikt B&uuml;nz et al. &quot;Proof-Carrying Data Without Succinct Arguments&quot;. In: 2021, pp. 681&ndash;710. doi: <a href="https://doi.org/10.1007/978-3-030-84242-0_24" target="_blank" rel="noopener noreferrer">10.1007/978-3-030-84242-0\\_24</a>.</p></li>
      <li><p class="text-gray-300">[KS24] Abhiram Kothapalli and Srinath T. V. Setty. &quot;HyperNova: Recursive Arguments for Customizable Constraint Systems&quot;. In: 2024, pp. 345&ndash;379. doi: <a href="https://doi.org/10.1007/978-3-031-68403-6_11" target="_blank" rel="noopener noreferrer">10.1007/978-3-031-68403-6\\_11</a>.</p></li>
      <li><p class="text-gray-300">[BC23] Benedikt B&uuml;nz and Binyi Chen. &quot;Protostar: Generic Efficient Accumulation/Folding for Special-Sound Protocols&quot;. In: 2023, pp. 77&ndash;110. doi: <a href="https://doi.org/10.1007/978-981-99-8724-5_3" target="_blank" rel="noopener noreferrer">10.1007/978-981-</a> <a href="https://doi.org/10.1007/978-981-99-8724-5_3" target="_blank" rel="noopener noreferrer">99-8724-5\\_3</a>.</p></li>
      <li><p class="text-gray-300">[KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. &quot;Constant-Size Commitments to Polynomials and Their Applications&quot;. In: 2010, pp. 177&ndash;194. doi: <a href="https://doi.org/10.1007/978-3-642-17373-8_11" target="_blank" rel="noopener noreferrer">10.1007/978-3-642-17373-8\\_11</a>.</p></li>
      <li><p class="text-gray-300">[B&uuml;n+20] Benedikt B&uuml;nz et al. &quot;Recursive Proof Composition from Accumulation Schemes&quot;. In: 2020, pp. 1&ndash;18. doi: <a href="https://doi.org/10.1007/978-3-030-64378-2_1" target="_blank" rel="noopener noreferrer">10.1007/978-3-030-64378-2\\_1</a>.</p></li>
      <li><p class="text-gray-300">[Set20] Srinath Setty. &quot;Spartan: Efficient and General-Purpose zkSNARKs Without Trusted Setup&quot;. In: 2020, pp. 704&ndash;737. doi: <a href="https://doi.org/10.1007/978-3-030-56877-1_25" target="_blank" rel="noopener noreferrer">10.1007/978-3-030-56877-1\\_25</a>.</p></li>
      <li><p class="text-gray-300">[PST13] Charalampos Papamanthou, Elaine Shi, and Roberto Tamassia. &quot;Signatures of Correct Computation&quot;. In: 2013, pp. 222&ndash;242. doi: <a href="https://doi.org/10.1007/978-3-642-36594-2_13" target="_blank" rel="noopener noreferrer">10.1007/978-3-642-</a> <a href="https://doi.org/10.1007/978-3-642-36594-2_13" target="_blank" rel="noopener noreferrer">36594-2\\_13</a>.</p></li>
      <li><p class="text-gray-300">[Lee21] Jonathan Lee. &quot;Dory: Efficient, Transparent Arguments for Generalised Inner Products and Polynomial Commitments&quot;. In: 2021, pp. 1&ndash;34. doi: <a href="https://doi.org/10.1007/978-3-030-90453-1_1" target="_blank" rel="noopener noreferrer">10.1007/</a> <a href="https://doi.org/10.1007/978-3-030-90453-1_1" target="_blank" rel="noopener noreferrer">978-3-030-90453-1\\_1</a>.</p></li>
      <li><p class="text-gray-300">[Cam+25] Matteo Campanelli et al. On the Power of Polynomial Preprocessing: Proving Computations in Sublinear Time, and More. Cryptology ePrint Archive, Paper 2025/238. 2025. url: <a href="https://eprint.iacr.org/2025/238" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2025/238</a>.</p></li>
      <li><p class="text-gray-300">[KS23a] Abhiram Kothapalli and Srinath Setty. CycleFold: Folding-scheme-based recursive arguments over a cycle of elliptic curves. Cryptology ePrint Archive, Report 2023/1192. 2023. url: <a href="https://eprint.iacr.org/2023/1192" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2023/1192</a>.</p></li>
      <li><p class="text-gray-300">[BFS20] Benedikt B&uuml;nz, Ben Fisch, and Alan Szepieniec. &quot;Transparent SNARKs from DARK Compilers&quot;. In: 2020, pp. 677&ndash;706. doi: <a href="https://doi.org/10.1007/978-3-030-45721-1_24" target="_blank" rel="noopener noreferrer">10.1007/978-3-030-45721-</a> <a href="https://doi.org/10.1007/978-3-030-45721-1_24" target="_blank" rel="noopener noreferrer">1\\_24</a>.</p></li>
      <li><p class="text-gray-300">[KS23b] Abhiram Kothapalli and Srinath Setty. CycleFold: Folding-scheme-based recursive arguments over a cycle of elliptic curves. Cryptology ePrint Archive, Paper 2023/1192. 2023. url: <a href="https://eprint.iacr.org/2023/1192" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2023/1192</a>.</p></li>
      <li><p class="text-gray-300">[ZSC24] Jiaxing Zhao, Srinath Setty, and Weidong Cui. MicroNova: Folding-based arguments with efficient (on-chain) verification. Cryptology ePrint Archive, Paper 2024/2099. 2024. url: <a href="https://eprint.iacr.org/2024/2099" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2024/2099</a>.</p></li>
      <li><p class="text-gray-300">[Che+20] Weikeng Chen et al. Reducing Participation Costs via Incremental Verification for Ledger Systems. Cryptology ePrint Archive, Paper 2020/1522. 2020. url: <a href="https://eprint.iacr.org/2020/1522" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2020/1522</a>.</p></li>
      <li><p class="text-gray-300">[Bon+20] Joseph Bonneau et al. Coda: Decentralized Cryptocurrency at Scale. Cryptology ePrint Archive, Paper 2020/352. 2020. url: <a href="https://eprint.iacr.org/2020/352" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/</a> <a href="https://eprint.iacr.org/2020/352" target="_blank" rel="noopener noreferrer">2020/352</a>.</p></li>
      <li><p class="text-gray-300">[Tya+21] Nirvan Tyagi et al. VeRSA: Verifiable Registries with Efficient Client Audits from RSA Authenticated Dictionaries. Cryptology ePrint Archive, Paper 2021/627. 2021. doi: <a href="https://doi.org/10.1145/3548606.3560605" target="_blank" rel="noopener noreferrer">10.1145/3548606. 3560605</a>. url: <a href="https://eprint.iacr.org/2021/627" target="_blank" rel="noopener noreferrer">https://eprint.</a> <a href="https://eprint.iacr.org/2021/627" target="_blank" rel="noopener noreferrer">iacr.org/2021/627</a>.</p></li>
      <li><p class="text-gray-300">[Gro+18] Jens Groth et al. &quot;Updatable and Universal Common Reference Strings with Applications to zk-SNARKs&quot;. In: 2018, pp. 698&ndash;728. doi: <a href="https://doi.org/10.1007/978-3-319-96878-0_24" target="_blank" rel="noopener noreferrer">10.1007/978- 3-</a> <a href="https://doi.org/10.1007/978-3-319-96878-0_24" target="_blank" rel="noopener noreferrer">319-96878-0\\_24</a>.</p></li>
      <li><p class="text-gray-300">[Resb] Ethereum Research. Sticking to 8192 Signatures per Slot Post-SSF: How and Why. <a href="https://ethresear.ch/t/sticking-to-8192-signatures-per-slot-post-ssf-how-and-why/" target="_blank" rel="noopener noreferrer">https : / / ethresear . ch / t / sticking - to - 8192 - signatures - per</a>  <a href="https://ethresear.ch/t/sticking-to-8192-signatures-per-slot-post-ssf-how-and-why/" target="_blank" rel="noopener noreferrer">slot-post-ssf-how-and-why/</a>. Accessed: 2024-11-15.</p></li>
      <li><p class="text-gray-300">[Sin] Single Slot Finality. <a href="https://ethereum.org/en/roadmap/single-slot-finality/" target="_blank" rel="noopener noreferrer">https : / /ethereum .org / en / roadmap / single - slot</a>  <a href="https://ethereum.org/en/roadmap/single-slot-finality/" target="_blank" rel="noopener noreferrer">finality/</a>. Accessed: 2024-11-15.</p></li>
      <li><p class="text-gray-300">[But] Vitalik Buterin. Possible futures of the Ethereum protocol, part 1: The Merge. <a href="https://vitalik.eth.limo/general/2024/10/14/futures1.html" target="_blank" rel="noopener noreferrer">https://vitalik.eth.limo/general/2024/10/14/futures1.html</a>. Accessed: 2024-11-15.</p></li>
      <li><p class="text-gray-300">[D'A+24b] Francesco D'Amato et al. TOB-SVD: Total-Order Broadcast with Single-Vote Decisions in the Sleepy Model. 2024. arXiv: <a href="https://arxiv.org/abs/2310.11331" target="_blank" rel="noopener noreferrer">2310.11331 [cs.DC]</a>. url: <a href="https://arxiv.org/abs/2310.11331" target="_blank" rel="noopener noreferrer">https:</a> <a href="https://arxiv.org/abs/2310.11331" target="_blank" rel="noopener noreferrer">//arxiv.org/abs/2310.11331</a>.</p></li>
      <li><p class="text-gray-300">[DZ23] Francesco D'Amato and Luca Zanolini. A Simple Single Slot Finality Protocol For Ethereum. Cryptology ePrint Archive, Report 2023/280. 2023. url: <a href="https://eprint.iacr.org/2023/280" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2023/280</a>.</p></li>
      <li><p class="text-gray-300">[D'A+24a] Francesco D'Amato et al. 3-Slot-Finality Protocol for Ethereum. 2024. arXiv: <a href="https://arxiv.org/abs/2411.00558" target="_blank" rel="noopener noreferrer">2411.00558 [cs.DC]</a>. url: <a href="https://arxiv.org/abs/2411.00558" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2411.00558</a>.</p></li>
      <li><p class="text-gray-300">[D'A+22] Francesco D'Amato et al. No More Attacks on Proof-of-Stake Ethereum? Cryptology ePrint Archive, Report 2022/1171. 2022. url: <a href="https://eprint.iacr.org/2022/1171" target="_blank" rel="noopener noreferrer">https://eprint.iacr.</a> <a href="https://eprint.iacr.org/2022/1171" target="_blank" rel="noopener noreferrer">org/2022/1171</a>.</p></li>
      <li><p class="text-gray-300">[Gil+17] Yossi Gilad et al. Algorand: Scaling Byzantine Agreements for Cryptocurrencies. Cryptology ePrint Archive, Report 2017/454. 2017. url: <a href="https://eprint.iacr.org/2017/454" target="_blank" rel="noopener noreferrer">https://</a> <a href="https://eprint.iacr.org/2017/454" target="_blank" rel="noopener noreferrer">eprint.iacr.org/2017/454</a>.</p></li>
      <li><p class="text-gray-300">[Yin+19] Maofan Yin et al. &quot;HotStuff: BFT Consensus with Linearity and Responsiveness&quot;. In: 2019, pp. 347&ndash;356. doi: <a href="https://doi.org/10.1145/3293611.3331591" target="_blank" rel="noopener noreferrer">10.1145/3293611.3331591</a>.</p></li>
      <li><p class="text-gray-300">[BLS04] Dan Boneh, Ben Lynn, and Hovav Shacham. &quot;Short Signatures from the Weil Pairing&quot;. In: 17.4 (Sept. 2004), pp. 297&ndash;319. doi: <a href="https://doi.org/10.1007/s00145-004-0314-9" target="_blank" rel="noopener noreferrer">10.1007/s00145-004-0314-</a> <a href="https://doi.org/10.1007/s00145-004-0314-9" target="_blank" rel="noopener noreferrer">9</a>.</p></li>
      <li><p class="text-gray-300">[BDN18] Dan Boneh, Manu Drijvers, and Gregory Neven. &quot;Compact Multi-signatures for Smaller Blockchains&quot;. In: 2018, pp. 435&ndash;464. doi: <a href="https://doi.org/10.1007/978-3-030-03329-3_15" target="_blank" rel="noopener noreferrer">10.1007/978-3-030-</a> <a href="https://doi.org/10.1007/978-3-030-03329-3_15" target="_blank" rel="noopener noreferrer">03329-3\\_15</a>.</p></li>
      <li><p class="text-gray-300">[Resa] Ethereum Research. Signature Merging for Large-Scale Consensus. <a href="https://ethresear.ch/t/signature-merging-for-large-scale-consensus/17386" target="_blank" rel="noopener noreferrer">https://</a> <a href="https://ethresear.ch/t/signature-merging-for-large-scale-consensus/17386" target="_blank" rel="noopener noreferrer">ethresear.ch/t/signature-merging-for-large-scale-consensus/17386</a>. Accessed: 2024-11-15.</p></li>
      <li><p class="text-gray-300">[KS22] Abhiram Kothapalli and Srinath Setty. SuperNova: Proving universal machine executions without universal circuits. Cryptology ePrint Archive, Paper 2022/1758. 2022. url: <a href="https://eprint.iacr.org/2022/1758" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2022/1758</a>.</p></li>
      <li><p class="text-gray-300">[Zhe+23] Tianyu Zheng et al. KiloNova: Non-Uniform PCD with Zero-Knowledge Property from Generic Folding Schemes. Cryptology ePrint Archive, Paper 2023/1579. 2023. url: <a href="https://eprint.iacr.org/2023/1579" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2023/1579</a>.</p></li>
      <li><p class="text-gray-300">[BGH19] Sean Bowe, Jack Grigg, and Daira Hopwood. Halo: Recursive Proof Composition without a Trusted Setup. Cryptology ePrint Archive, Report 2019/1021. 2019. url: <a href="https://eprint.iacr.org/2019/1021" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2019/1021</a>.</p></li>
      <li><p class="text-gray-300">[Wu+18] Howard Wu et al. DIZK: A Distributed Zero Knowledge Proof System. Cryptology ePrint Archive, Paper 2018/691. 2018. url: <a href="https://eprint.iacr.org/2018/691" target="_blank" rel="noopener noreferrer">https://eprint.iacr.</a> <a href="https://eprint.iacr.org/2018/691" target="_blank" rel="noopener noreferrer">org/2018/691</a>.</p></li>
      <li><p class="text-gray-300">[Liu+23] Tianyi Liu et al. Pianist: Scalable zkRollups via Fully Distributed Zero-Knowledge Proofs. Cryptology ePrint Archive, Paper 2023/1271. 2023. url: <a href="https://eprint.iacr.org/2023/1271" target="_blank" rel="noopener noreferrer">https://</a> <a href="https://eprint.iacr.org/2023/1271" target="_blank" rel="noopener noreferrer">eprint.iacr.org/2023/1271</a>.</p></li>
      <li><p class="text-gray-300">[Ros+24] Michael Rosenberg et al. Hekaton: Horizontally-Scalable zkSNARKs via Proof Aggregation. Cryptology ePrint Archive, Paper 2024/1208. 2024. url: <a href="https://eprint.iacr.org/2024/1208" target="_blank" rel="noopener noreferrer">https:</a> <a href="https://eprint.iacr.org/2024/1208" target="_blank" rel="noopener noreferrer">//eprint.iacr.org/2024/1208</a>.</p></li>
      <li><p class="text-gray-300">[Wan+24] Wenhao Wang et al. Cirrus: Performant and Accountable Distributed SNARK. Cryptology ePrint Archive, Paper 2024/1873. 2024. url: <a href="https://eprint.iacr.org/2024/1873" target="_blank" rel="noopener noreferrer">https://eprint.</a> <a href="https://eprint.iacr.org/2024/1873" target="_blank" rel="noopener noreferrer">iacr.org/2024/1873</a>.</p></li>
      <li><p class="text-gray-300">[B&eacute;+19] Olivier B&eacute;gassat et al. Handel: Practical Multi-Signature Aggregation for Large Byzantine Committees. 2019. arXiv: <a href="https://arxiv.org/abs/1906.05132" target="_blank" rel="noopener noreferrer">1906 . 05132 [cs.DC]</a>. url: <a href="https://arxiv.org/abs/1906.05132" target="_blank" rel="noopener noreferrer">https : / /</a> <a href="https://arxiv.org/abs/1906.05132" target="_blank" rel="noopener noreferrer">arxiv.org/abs/1906.05132</a>.</p></li>
      <li><p class="text-gray-300">[Kha+21] Irakliy Khaburzaniya et al. Aggregating hash-based signatures using STARKs. Cryptology ePrint Archive, Report 2021/1048. 2021. url: <a href="https://eprint.iacr.org/2021/1048" target="_blank" rel="noopener noreferrer">https://eprint.</a> <a href="https://eprint.iacr.org/2021/1048" target="_blank" rel="noopener noreferrer">iacr.org/2021/1048</a>.</p></li>
      <li><p class="text-gray-300">[Aar+24] Marius A. Aardal et al. &quot;Aggregating Falcon Signatures with LaBRADOR&quot;. In: 2024, pp. 71&ndash;106. doi: <a href="https://doi.org/10.1007/978-3-031-68376-3_3" target="_blank" rel="noopener noreferrer">10.1007/978-3-031-68376-3\\_3</a>.</p></li>
      <li><p class="text-gray-300">[Wah+18] Riad S. Wahby et al. &quot;Doubly-Efficient zkSNARKs Without Trusted Setup&quot;. In: 2018, pp. 926&ndash;943. doi: <a href="https://doi.org/10.1109/SP.2018.00060" target="_blank" rel="noopener noreferrer">10.1109/SP.2018.00060</a>.</p></li>
      <li><p class="text-gray-300">[Ped92] Torben P. Pedersen. &quot;Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing&quot;. In: 1992, pp. 129&ndash;140. doi: <a href="https://doi.org/10.1007/3-540-46766-1_9" target="_blank" rel="noopener noreferrer">10.1007/3-540-46766-1\\_9</a>.</p></li>
      <li><p class="text-gray-300">[Abe+16] Masayuki Abe et al. &quot;Structure-Preserving Signatures and Commitments to Group Elements&quot;. In: 29.2 (Apr. 2016), pp. 363&ndash;421. doi: <a href="https://doi.org/10.1007/s00145-014-9196-7" target="_blank" rel="noopener noreferrer">10.1007/s00145-</a> <a href="https://doi.org/10.1007/s00145-014-9196-7" target="_blank" rel="noopener noreferrer">014-9196-7</a>.</p></li>
      <li><p class="text-gray-300">[Che+23] Binyi Chen et al. &quot;HyperPlonk: Plonk with Linear-Time Prover and High-Degree Custom Gates&quot;. In: 2023, pp. 499&ndash;530. doi: <a href="https://doi.org/10.1007/978-3-031-30617-4_17" target="_blank" rel="noopener noreferrer">10.1007/978- 3- 031-</a> <a href="https://doi.org/10.1007/978-3-031-30617-4_17" target="_blank" rel="noopener noreferrer">30617-4\\_17</a>.</p></li>
      <li><p class="text-gray-300">[STW23] Srinath Setty, Justin Thaler, and Riad Wahby. Customizable constraint systems for succinct arguments. Cryptology ePrint Archive, Paper 2023/552. 2023. url: <a href="https://eprint.iacr.org/2023/552" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2023/552</a>.</p></li>
      <li><p class="text-gray-300">[FKL18] Georg Fuchsbauer, Eike Kiltz, and Julian Loss. &quot;The Algebraic Group Model and its Applications&quot;. In: 2018, pp. 33&ndash;62. doi: <a href="https://doi.org/10.1007/978-3-319-96881-0_2" target="_blank" rel="noopener noreferrer">10.1007/978-3-319-96881-</a> <a href="https://doi.org/10.1007/978-3-319-96881-0_2" target="_blank" rel="noopener noreferrer">0\\_2</a>.</p></li>
      <li><p class="text-gray-300">[B&uuml;+19] Benedikt B&uuml;nz et al. Proofs for Inner Pairing Products and Applications. Cryptology ePrint Archive, Paper 2019/1177. 2019. url: <a href="https://eprint.iacr.org/2019/1177" target="_blank" rel="noopener noreferrer">https://eprint.iacr.</a> <a href="https://eprint.iacr.org/2019/1177" target="_blank" rel="noopener noreferrer">org/2019/1177</a>.</p></li>
      <li><p class="text-gray-300">[Haf+25] Hossein Hafezi et al. IronDict: Transparent Dictionaries from Polynomial Commitments. Cryptology ePrint Archive, Paper 2025/1580. 2025. url: <a href="https://eprint.iacr.org/2025/1580" target="_blank" rel="noopener noreferrer">https:</a> <a href="https://eprint.iacr.org/2025/1580" target="_blank" rel="noopener noreferrer">//eprint.iacr.org/2025/1580</a>.</p></li>
      <li><p class="text-gray-300">[DRZ20] Vanesa Daza, Carla R&agrave;fols, and Alexandros Zacharakis. &quot;Updateable Inner Product Argument with Logarithmic Verifier and Applications&quot;. In: 2020, pp. 527&ndash;557. doi: <a href="https://doi.org/10.1007/978-3-030-45374-9_18" target="_blank" rel="noopener noreferrer">10.1007/978-3-030-45374-9\\_18</a>.</p></li>
      <li><p class="text-gray-300">[BFL20] Balthazar Bauer, Georg Fuchsbauer, and Julian Loss. &quot;A Classification of Computational Assumptions in the Algebraic Group Model&quot;. In: 2020, pp. 121&ndash; 151. doi: <a href="https://doi.org/10.1007/978-3-030-56880-1_5" target="_blank" rel="noopener noreferrer">10.1007/978-3-030-56880-1\\_5</a>.</p></li>
      <li><p class="text-gray-300">[GNS24] Chaya Ganesh, Vineet Nair, and Ashish Sharma. Dual Polynomial Commitment Schemes and Applications to Commit-and-Prove SNARKs. Cryptology ePrint Archive, Paper 2024/943. 2024. url: <a href="https://eprint.iacr.org/2024/943" target="_blank" rel="noopener noreferrer">https : / / eprint . iacr . org /</a> <a href="https://eprint.iacr.org/2024/943" target="_blank" rel="noopener noreferrer">2024/943</a>.</p></li>
      <li><p class="text-gray-300">[KS23c] Abhiram Kothapalli and Srinath Setty. HyperNova: Recursive arguments for customizable constraint systems. Cryptology ePrint Archive, Paper 2023/573. 2023. url: <a href="https://eprint.iacr.org/2023/573" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2023/573</a>.</p></li>
      <li><p class="text-gray-300">[Lun+90] Carsten Lund et al. &quot;Algebraic Methods for Interactive Proof Systems&quot;. In: 1990, pp. 2&ndash;10. doi: <a href="https://doi.org/10.1109/FSCS.1990.89518" target="_blank" rel="noopener noreferrer">10.1109/FSCS.1990.89518</a>.</p></li>
      <li><p class="text-gray-300">[Ova] Ova: A slightly better Nova. <a href="https://hackmd.io/V4838nnlRKal9ZiTHiGYzw" target="_blank" rel="noopener noreferrer">https://hackmd.io/V4838nnlRKal9ZiTHiGYzw</a>. Accessed: 2024-11-15.</p></li>
      <li><p class="text-gray-300">[Bon+21] Dan Boneh et al. &quot;Halo Infinite: Proof-Carrying Data from Additive Polynomial Commitments&quot;. In: 2021, pp. 649&ndash;680. doi: <a href="https://doi.org/10.1007/978-3-030-84242-0_23" target="_blank" rel="noopener noreferrer">10.1007/978-3-030-84242-</a> <a href="https://doi.org/10.1007/978-3-030-84242-0_23" target="_blank" rel="noopener noreferrer">0\\_23</a>.</p></li>
      <li><p class="text-gray-300">[Blu+91] M. Blum et al. &quot;Checking the correctness of memories&quot;. In: [1991] Proceedings 32nd Annual Symposium of Foundations of Computer Science. 1991, pp. 90&ndash; 99. doi: <a href="https://doi.org/10.1109/SFCS.1991.185352" target="_blank" rel="noopener noreferrer">10.1109/SFCS.1991.185352</a>.</p></li>
    </ul>

    <p class="text-gray-300"><strong>Definition 4.</strong> A signature scheme is parametrized by a message space  <span class="math">\\mathcal{M}</span>  and consists on a tuple of PPT algorithms (KGen<sub>ss</sub>, Sign<sub>ss</sub>, Verify<sub>ss</sub>) such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathsf{KGen}_{\\mathsf{ss}}(n) \\to (\\mathsf{sk}, \\mathsf{pk})</span> : On input security parameter n, outputs public parameters  <span class="math">\\mathsf{pp}</span> , signing key  <span class="math">\\mathsf{pk}</span>  and verification key  <span class="math">\\mathsf{pk}</span> .</li>
      <li><span class="math">\\mathsf{Sign}_{\\mathsf{ss}}(\\mathsf{sk}, m) \\to \\sigma_m</span> : On input  <span class="math">\\mathsf{sk}</span>  and  <span class="math">m \\in \\mathcal{M}</span> , outputs a signature  <span class="math">\\sigma_M</span>  on M.</li>
      <li>Verify<sub>ss</sub>(pk, m,  <span class="math">\\sigma_m</span> )  <span class="math">\\rightarrow 0/1</span> : takes as input pk, m and signature  <span class="math">\\sigma_m</span>  and produces a bit expressing acceptance (1), or rejection (0);</li>
    </ul>

    <p class="text-gray-300"><span class="math">That \\ must \\ satisfy \\ correctness \\ and \\ unforgeability:</span></p>

    <p class="text-gray-300"><strong>Correctness.</strong> For all  <span class="math">m \\in \\mathcal{M}</span>  the following holds:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\begin{array}{c|c} \\mathsf{Verify_{ss}}(\\mathsf{pk}, m, \\sigma_m) = 1 &amp; \\left(\\begin{array}{c} (\\mathsf{pk}, \\mathsf{sk}) \\leftarrow \\mathsf{KGen_{ss}}(n) \\\\ \\sigma_m \\leftarrow \\mathsf{Sign_{ss}}(\\mathsf{sk}, m) \\end{array}\\right] = 1</span>$</p>

    <p class="text-gray-300"><strong>Unforgeability.</strong> For all PPT adversaries A, the following probability is negligible:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\begin{array}{c} (m,\\sigma_m) \\notin \\mathcal{Q} \\middle| \\begin{array}{c} (\\mathsf{pk},\\mathsf{pk}) \\leftarrow \\mathsf{KGen_{ss}}(n) \\\\ (m,\\sigma_m) \\leftarrow \\mathcal{A}^{\\mathcal{O}}(\\mathsf{pk},\\mathsf{sk}) \\\\ \\mathsf{Verify_{ss}}(\\mathsf{pk},m,\\sigma_m) = 1 \\end{array}\\right]</span>$</p>

    <p class="text-gray-300">where Q is a list of all the queries A makes to the signing oracle O.</p>

      <h3 id="app-b.1" class="text-xl font-semibold mt-8">B.1 Proof of theorem 3</h3>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">Completeness. The commitment C to  <span class="math">f(\\vec{X})</span>  is given by</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{C} = \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} f(\\vec{x}, \\vec{y}) \\times \\mathsf{H}^{(\\vec{x}, \\vec{y})}.</span>$</p>

    <p class="text-gray-300">Since nm=k, this can be computed from the structured reference string (srs). The opening proof  <span class="math">\\pi</span>  for  <span class="math">(\\vec{x}_0,\\vec{y}_0)</span>  is defined as:  <span class="math">\\pi=\\left(f^*(\\vec{Y}), \\mathsf{aux}=\\{\\mathsf{D}^{(\\vec{x})}\\}_{\\vec{x}\\in B_n}\\right)</span> , where  <span class="math">f^*(\\vec{Y})=f(\\vec{x}_0,\\vec{Y})</span> , and  <span class="math">\\mathsf{D}^{(\\vec{x})}=\\sum_{\\vec{y}\\in B_m}f(\\vec{x},\\vec{y})\\times\\mathsf{H}^{(\\vec{y})}</span> . We see that  <span class="math">\\mathsf{Verify}_{\\mathsf{KZH}}(\\mathsf{C},(\\vec{x}_0,\\vec{y}_0),\\pi)=1</span> :</p>

    <p class="text-gray-300">(I) Check that  <span class="math">e(\\mathsf{C},\\mathsf{V}&#x27;) = \\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}^{(\\vec{x})},\\mathsf{V}^{(\\vec{x})})</span> :</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} e(\\mathsf{C},\\mathsf{V}&#x27;) &amp;\\stackrel{(1)}{=} e(\\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} f(\\vec{x},\\vec{y}) \\times \\mathsf{H}^{(\\vec{x},\\vec{y})}, \\alpha \\times \\mathsf{V}) \\\\ &amp;\\stackrel{(2)}{=} \\sum_{\\vec{x} \\in B_n} e(\\sum_{\\vec{y} \\in B_m} f(\\vec{x},\\vec{y}) \\cdot \\tau^{(\\vec{x})} \\times \\mathsf{G}^{(\\vec{y})}, \\alpha \\times \\mathsf{V}) \\\\ &amp;\\stackrel{(3)}{=} \\sum_{\\vec{x} \\in B_n} e(\\sum_{\\vec{y} \\in B_m} f(\\vec{x},\\vec{y}) \\cdot \\alpha \\times \\mathsf{G}^{(\\vec{y})}, \\tau^{(\\vec{x})} \\times \\mathsf{V}) \\\\ &amp;\\stackrel{(4)}{=} \\sum_{\\vec{x} \\in B_n} e(\\sum_{\\vec{y} \\in B_m} f(\\vec{x},\\vec{y}) \\times \\mathsf{H}^{(\\vec{y})}, \\mathsf{V}^{(\\vec{x})}) \\\\ &amp;\\stackrel{(5)}{=} \\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}^{(\\vec{x})}, \\mathsf{V}^{(\\vec{x})}) \\end{split}</span>$</p>

    <p class="text-gray-300">(1) and (2) is exploding terms  <span class="math">\\mathsf{C},\\mathsf{H}^{(\\vec{x},\\vec{y})},\\mathsf{V}&#x27;</span>  and using the bilinearity property, (3) is using property  <span class="math">e(g^a,g^b)=e(g^b,g^a)</span>  by interchanging the exponents  <span class="math">\\alpha</span>  and  <span class="math">\\tau^{(\\vec{x})}</span> . (4) is replaying  <span class="math">\\alpha\\times\\mathsf{G}^{(\\vec{y})}</span>  with the equivalent value  <span class="math">\\mathsf{H}^{(\\vec{y})}</span>  and finally (5) follows from the definition of  <span class="math">\\mathsf{D}^{(\\vec{x})}</span> .</p>

    <p class="text-gray-300">(II) Check that
<span class="math">$\\sum_{\\vec{y} \\in B_m} f^*(\\vec{y}) \\times \\mathsf{H}^{(\\vec{y})} = \\sum_{\\vec{x} \\in B_n} \\mathsf{eq}(\\vec{x}, \\, \\vec{x}_0) \\times \\mathsf{D}^{(\\vec{x})}.</span>$</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{x} \\in B_n} \\mathsf{eq}(\\vec{x}, \\, \\vec{x}) \\times \\mathsf{D}^{(\\vec{x})} \\stackrel{(1)}{=} \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} \\mathsf{eq}(\\vec{x}, \\, \\vec{x}_0) \\cdot f(\\vec{x}, \\, \\vec{y}) \\times \\mathsf{H}^{(\\vec{y})}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\stackrel{(2)}{=} \\sum_{\\vec{y} \\in B_m} \\left( \\sum_{\\vec{x} \\in B_n} \\mathsf{eq}(\\vec{x}, \\, \\vec{x}_0) \\cdot f(\\vec{x}, \\, \\vec{y}) \\right) \\times \\mathsf{H}^{(\\vec{y})}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\stackrel{(3)}{=} \\sum_{\\vec{y} \\in B_m} f^*(\\vec{y}) \\times \\mathsf{H}^{(\\vec{y})}</span>$</p>

    <p class="text-gray-300">Finally, (III) checking that  <span class="math">f^*(\\vec{y_0}) = z_0</span> , follows from the definition of  <span class="math">z_0</span> .</p>

    <p class="text-gray-300"><strong>Knowledge soundness.</strong> Let  <span class="math">\\mathcal{A}</span>  be a PPT adversary that, on input srs outputs a commitment  <span class="math">\\mathsf{C}</span> . We define an extractor  <span class="math">\\mathcal{E}</span>  that outputs  <span class="math">p(\\vec{X},\\vec{Y})</span>  such that, for any  <span class="math">((\\vec{x}_0,\\vec{y}_0),z_0,\\pi)</span> , if the verifier accepts then  <span class="math">p(\\vec{x}_0,\\vec{y}_0)=z_0</span>  with overwhelming probability. Given  <span class="math">\\mathsf{C}</span>  and  <span class="math">\\{c_{\\vec{x},\\vec{y}},\\hat{c}_{\\vec{y}}\\}_{\\vec{x}\\in B_n,\\vec{y}\\in B_m}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{C} = \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} c_{\\vec{x}, \\vec{y}} \\times \\mathsf{H}^{(\\vec{x}, \\vec{y})} + \\sum_{\\vec{y} \\in B_m} \\hat{c}_{\\vec{y}} \\times \\mathsf{H}^{(\\vec{y})},</span>$</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}</span>  outputs  <span class="math">f(\\vec{X}, \\vec{Y}) = \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} c_{\\vec{x}, \\vec{y}} \\vec{X}^{\\vec{x}} \\vec{Y}^{\\vec{y}}</span> . Under the AGM,  <span class="math">\\mathcal{E}</span>  does not abort. Similarly, under the AGM we have that all the  <span class="math">\\mathsf{D}^{(\\vec{x})}</span>  are represented as a linear combination of the srs elements, i.e.,</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{D}^{(\\vec{x})} = \\sum_{\\vec{y} \\in B_m} d_{\\vec{y}}^{(\\vec{x})} \\times \\mathsf{H}^{(\\vec{y})} + \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} \\hat{d}_{\\vec{x},\\vec{y}}^{(\\vec{x})} \\times \\mathsf{H}^{(\\vec{x},\\vec{y})}</span>$</p>

    <p class="text-gray-300">The following conditions are satisfied:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\text{(I)} \\ &amp; e(\\mathsf{C},\\mathsf{V}&#x27;) = \\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}^{(\\vec{x})},\\mathsf{V}^{(\\vec{x})}), \\, \\text{we first consider each side separately:} \\\\ &amp; e(\\mathsf{C},\\mathsf{V}&#x27;) = e(\\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} c_{\\vec{x},\\vec{y}} \\times \\mathsf{H}^{(\\vec{x},\\vec{y})} + \\sum_{\\vec{y} \\in B_m} \\hat{c}_{\\vec{y}} \\times \\mathsf{H}^{(\\vec{y})}, \\alpha \\times \\mathsf{V}) \\\\ &amp; = e(\\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} c_{\\vec{x},\\vec{y}} \\times \\mathsf{H}^{(\\vec{x},\\vec{y})}, \\alpha \\times \\mathsf{V}) + e(\\sum_{\\vec{y} \\in B_m} \\hat{c}_{\\vec{y}}(\\vec{y}) \\times \\mathsf{H}^{(\\vec{y})}, \\alpha \\times \\mathsf{V}) \\\\ &amp; = \\alpha \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} c_{\\vec{x},\\vec{y}} \\cdot \\tau^{(\\vec{x})} \\times e(\\mathsf{G}^{(\\vec{y})}, \\mathsf{V}) + \\alpha^2 \\times e(\\sum_{\\vec{y} \\in B_m} \\hat{c}_{\\vec{y}} \\times \\mathsf{G}^{(\\vec{y})}, \\mathsf{V}) \\end{split}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}^{(\\vec{x})}, \\mathsf{V}^{(\\vec{x})}) = \\sum_{\\vec{x} \\in B_n} e(\\sum_{\\vec{y} \\in B_m} d^{(\\vec{x})}_{\\vec{y}} \\times \\mathsf{H}^{(\\vec{y})} + \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} d^{(\\vec{x})}_{\\vec{x}, \\vec{y}} \\times \\mathsf{H}^{(\\vec{x}, \\vec{y})}, \\tau^{(\\vec{x})} \\times \\mathsf{V}) \\\\ &amp;= \\sum_{\\vec{x} \\in B_n} e(\\sum_{\\vec{y} \\in B_m} d^{(\\vec{x})}_{\\vec{y}} \\cdot \\alpha \\times \\mathsf{G}^{(\\vec{y})} + \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} d^{(\\vec{x})}_{\\vec{x}, \\vec{y}} \\cdot \\tau^{(\\vec{x})} \\times \\mathsf{G}^{(\\vec{y})}, \\tau^{(\\vec{x})} \\times \\mathsf{V}) \\\\ &amp;= \\sum_{\\vec{x} \\in B_n} \\tau^{(\\vec{x})} \\cdot \\left(\\alpha \\cdot \\sum_{\\vec{y} \\in B_m} d^{(\\vec{x})}_{\\vec{y}} + \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} d^{(\\vec{x})}_{\\vec{x}, \\vec{y}} \\cdot \\tau^{(\\vec{x})}\\right) \\times e(G^{(\\vec{y})}, \\mathsf{V}) \\end{split}</span>$</p>

    <p class="text-gray-300">Now the difference  <span class="math">e(\\mathsf{C},\\mathsf{V}&#x27;) - \\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}^{(\\vec{x})},\\mathsf{V}^{(\\vec{x})})</span>  can be seen as degree 2 polynomial of  <span class="math">\\alpha</span> , then the coefficients of 1,  <span class="math">\\alpha</span> ,  <span class="math">\\alpha^2</span>  on the two terms are equal or we can break quadratic CDH, which implies:</p>

    <p class="text-gray-300">&bull; Coefficient 1.</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} \\hat{d}_{\\vec{x}, \\vec{y}}^{(\\vec{x})} \\cdot \\tau^{(\\vec{x})} \\times e(G^{(\\vec{y})}, \\mathsf{V}) = 0 \\implies \\sum_{\\vec{x}, \\vec{y}} \\hat{d}_{\\vec{x}, \\vec{y}}^{(\\vec{x})} \\times \\mathsf{H}^{(\\vec{x}, \\vec{y})} = 0</span>$</p>

    <p class="text-gray-300">This implies  <span class="math">\\hat{d}_{\\vec{x},\\vec{y}}^{(\\vec{x})} = 0</span>  for all  <span class="math">\\vec{x}, \\vec{y}</span> , or we found a multivariate polynomial that vanishes at  <span class="math">\\mathsf{H}^{(\\vec{x},\\vec{y})}</span>  and thus break the setup-find-rep assumption.</p>

    <p class="text-gray-300">&bull; Coefficient  <span class="math">\\alpha</span> .</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} \\tau^{(\\vec{x})} \\cdot c_{\\vec{x}, \\vec{y}} \\times e(G^{(\\vec{y})}, \\mathsf{V}) = \\sum_{\\vec{x} \\in B_n} \\tau^{(\\vec{x})} \\cdot \\sum_{\\vec{y} \\in B_m} d^{(\\vec{x})}_{\\vec{y}} \\times e(G^{(\\vec{y})}, \\mathsf{V})</span>$</p>

    <p class="text-gray-300">Then we have that  <span class="math">c_{\\vec{x},\\vec{y}} = d_{\\vec{y}}^{(\\vec{x})}</span>  for all  <span class="math">\\vec{x},\\vec{y}</span>  or we can break the find-rep assumption as above.</p>

    <p class="text-gray-300">&bull; Coefficient  <span class="math">\\alpha^2</span> .</p>

    <p class="text-gray-300"><span class="math">$e(\\sum_{\\vec{y} \\in B_m} \\hat{c}_{\\vec{y}} \\times \\mathsf{G}^{(\\vec{y})}, \\mathsf{V}) = 0 \\implies \\sum_{\\vec{y} \\in B_m} \\hat{c}_{\\vec{y}} \\times \\mathsf{G}^{(\\vec{y})} = 0</span>$</p>

    <p class="text-gray-300">We then have:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{C} = \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} c_{\\vec{x}, \\vec{y}} \\times \\mathsf{H}^{(\\vec{x}, \\, \\vec{y})}, \\quad \\mathsf{D}^{(\\vec{x})} = \\sum_{\\vec{y} \\in B_m} d_{\\vec{y}}^{(\\vec{x})} \\times \\mathsf{H}^{(\\vec{y})}</span>$</p>

    <p class="text-gray-300">(II)
<span class="math">$\\sum_{\\vec{y} \\in B_m} f^*(\\vec{y}) \\times \\mathsf{H}^{(\\vec{y})} = \\sum_{\\vec{x} \\in B_n} \\mathsf{eq}(\\vec{x}, \\vec{x}_0) \\times \\mathsf{D}^{(\\vec{x})}</span>$
, we have:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\sum_{\\vec{y} \\in B_m} f^*(\\vec{y}) \\times \\mathbf{H}^{(\\vec{y})} &amp;= \\sum_{\\vec{x} \\in B_n} \\operatorname{eq}(\\vec{x}, \\, \\vec{x_0}) \\times \\mathbf{D}^{(\\vec{x})} \\\\ &amp;= \\sum_{\\vec{x} \\in B_n} \\operatorname{eq}(\\vec{x}, \\, \\vec{x_0}) \\times \\sum_{\\vec{y} \\in B_m} c_{\\vec{x}, \\vec{y}} \\times \\mathbf{H}^{(\\vec{y})} \\\\ &amp;= \\sum_{\\vec{y} \\in B_m} c_{\\vec{x_0}, \\vec{y}} \\times \\mathbf{H}^{(\\vec{y})} \\end{split}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\implies \\sum_{\\vec{y} \\in B_m} f^*(\\vec{y}) \\times \\mathsf{H}^{(\\vec{y})} = \\sum_{\\vec{y} \\in B_m} c_{\\vec{x_0}, \\vec{y}} \\times \\mathsf{H}^{(\\vec{y})}</span>$</p>

    <p class="text-gray-300">Now note that:</p>

    <p class="text-gray-300"><span class="math">$f^*(\\vec{y}) = \\sum_{\\vec{y} \\in B_m} c_{\\vec{x_0}, \\vec{y}} \\mathsf{H}^{(\\vec{x}_0, \\vec{y})} = f(\\vec{x}_0, \\vec{Y})</span>$</p>

    <p class="text-gray-300">or we can break the (1,1) &ndash; dlog assumption by finding the roots of</p>

    <p class="text-gray-300"><span class="math">$P(Y) = \\sum_{\\vec{y} \\in B_m} (f^*(\\vec{y}) - c_{\\vec{x_0}, \\vec{y}}) \\times (Y \\times \\mathsf{G}^{(\\vec{y})})</span>$</p>

    <p class="text-gray-300">and give trapdoor  <span class="math">\\alpha</span>  as output. Finally, the extractor outputs polynomial  <span class="math">f(\\vec{x}, \\vec{y})</span> . Since  <span class="math">f^*(\\vec{y}_0) = z_0</span> , and C commits to  <span class="math">f(\\vec{x}, \\vec{y})</span> , we have the construction is knowledge sound.</p>

      <h3 id="app-b.2" class="text-xl font-semibold mt-8">B.2 Proof of theorem 4</h3>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">Completeness. Consider the following two satisfying accumulators:</p>

    <p class="text-gray-300">&bull; acc.
<span class="math">$x_1 = \\{C_1, T_1, E_1, \\vec{x}_1, \\vec{y}_1, z_1\\}</span>$</p>

    <p class="text-gray-300">&bull;
<span class="math">$\\operatorname{acc.} w_1 = \\{ [\\mathsf{D}_1^{(\\vec{i})}]_{\\vec{i} \\in B_n}, \\vec{f_1^*}, \\, \\mathcal{T}_x^{(1)}, \\mathcal{T}_y^{(1)} \\}</span>$</p>

    <p class="text-gray-300">&bull; acc.
<span class="math">$x_2 = \\{C_2, T_2, E_2, \\vec{x}_2, \\vec{y}_2, z_2\\}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\bullet \\ \\text{acc.} w_2 = \\{ [\\mathsf{D}_2^{(\\vec{i})}]_{\\vec{i} \\in B_n}, \\vec{f_2}^*, \\, \\mathcal{T}_x{}^{(2)}, \\mathcal{T}_y{}^{(2)} \\}</span>$</p>

    <p class="text-gray-300">As they are valid accumulators, the following hold:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\bullet &amp; \\quad -\\sum_{i=0}^n e(\\mathsf{D}_1^{(i)},\\mathsf{V}_i) = e(\\mathsf{C}_1,\\mathsf{V}) \\\\ &amp; \\quad - \\langle (\\mathcal{T}_x^{(1)}||\\mathcal{T}_y^{(1)}), \\vec{\\mathsf{K}} \\rangle = T_1 \\\\ &amp; \\quad - E_1 = \\mathsf{Dec}(\\vec{x_1},\\vec{y_1},z_1,\\vec{f_1^*},\\mathcal{T}_x^{(1)},\\mathcal{T}_y^{(1)},\\vec{\\mathsf{D}_1}) \\end{split}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\bullet &amp; \\quad -\\sum_{i=0}^n e(\\mathsf{D}_2^{(i)},\\mathsf{V}_i) = e(\\mathsf{C}_2,\\mathsf{V}) \\\\ &amp; \\quad - \\langle (\\mathcal{T}_x^{(2)}||\\mathcal{T}_y^{(2)}), \\vec{\\mathsf{K}} \\rangle = T_2 \\\\ &amp; \\quad - E_2 = \\mathsf{Dec}(\\vec{x_2},\\vec{y_2},z_2,\\vec{f_2^*},\\mathcal{T}_x^{(2)},\\mathcal{T}_y^{(2)},\\vec{\\mathsf{D}_2}) \\end{split}</span>$</p>

    <p class="text-gray-300">Now let acc.x, acc.w be the accumulated instance/witness computed as follows.</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} &amp; \\mathsf{acc.} x \\leftarrow ((1-\\beta) \\cdot [\\mathsf{C}_1, T_1, \\vec{x_1}, \\vec{y_1}, z_1] + \\beta \\cdot [\\mathsf{C}_2, T_2,, \\vec{x_2}, \\vec{y_2}, z_2]), \\ \\mathsf{E} \\\\ &amp; \\mathsf{acc.} w \\leftarrow (1-\\beta) \\cdot [\\vec{\\mathsf{D}}_1, \\vec{f}_1^*, \\mathcal{T}_x^{(1)}, \\mathcal{T}_y^{(1)}] + \\beta \\cdot [\\vec{\\mathsf{D}}_2, \\vec{f}_2^*, \\mathcal{T}_x^{(2)}, \\mathcal{T}_y^{(2)}], \\ \\mathsf{E} \\end{aligned}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathsf{E} \\leftarrow (1-\\beta) \\times \\mathsf{E}_1 + \\beta \\times \\mathsf{E}_2 + (1-\\beta)\\beta \\times \\mathsf{Q}</span> . Below, we show acc is also a satisfying accumulator:</p>

    <p class="text-gray-300">&bull; First condition</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=0}^{n} e(\\mathsf{D}^{(i)}, \\mathsf{V}_i) \\stackrel{(1)}{=} \\sum_{i=0}^{n} e\\left((1-\\beta) \\times \\mathsf{D}_1^{(i)} + \\beta \\times \\mathsf{D}_2^{(i)}, \\mathsf{V}_i\\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\stackrel{(2)}{=} (1-\\beta) \\times \\sum_{i=0}^{n} e(\\mathsf{D}_1^{(i)}, \\mathsf{V}_i) + \\beta \\times \\sum_{i=0}^{n} e(\\mathsf{D}_2^{(i)}, \\mathsf{V}_i)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\stackrel{(3)}{=} (1-\\beta) \\times e(\\mathsf{C}_1, \\mathsf{V}) + \\beta \\times e(\\mathsf{C}_2, \\mathsf{V})</span>$</p>

    <p class="text-gray-300"><span class="math">$\\stackrel{(4)}{=} e\\left((1-\\beta) \\times \\mathsf{C}_1 + \\beta \\times \\mathsf{C}_2, \\mathsf{V}\\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\stackrel{(5)}{=} e(\\mathsf{C}, \\mathsf{V})</span>$</p>

    <p class="text-gray-300">Where (1) holds by expanding  <span class="math">D^{(i)}</span>  terms, (2), (4) because of bilinearity property, (3) holds because the first condition was satisfied for the underlying instances, and finally (5) holds because of the definition of C.</p>

    <p class="text-gray-300">&bull; Second condition.</p>

    <p class="text-gray-300"><span class="math">$\\langle (\\mathcal{T}_{x}||\\mathcal{T}_{y}), \\vec{\\mathsf{K}} \\rangle \\stackrel{(1)}{=} \\left\\langle (1-\\beta) \\cdot (\\mathcal{T}_{x}^{(1)}||\\mathcal{T}_{y}^{(1)}) + \\beta \\cdot (\\mathcal{T}_{x}^{(2)}||\\mathcal{T}_{y}^{(2)}), \\vec{\\mathsf{K}} \\right\\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$\\stackrel{(2)}{=} (1-\\beta) \\cdot \\left\\langle \\mathcal{T}_{x}^{(1)}||\\mathcal{T}_{y}^{(1)}, \\vec{\\mathsf{K}} \\right\\rangle + \\beta \\cdot \\left\\langle \\mathcal{T}_{x}^{(2)}||\\mathcal{T}_{y}^{(2)}, \\vec{\\mathsf{K}} \\right\\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$\\stackrel{(3)}{=} (1-\\beta) \\times T_{2} + \\beta \\times T_{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\stackrel{(4)}{=} T</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) holds by definition, whereas (2) is implied by bilinearity of the inner product. (3) and (4) follow by definition.</li>
      <li>Third condition.</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathsf{Dec}(\\vec{x}, \\vec{y}, z, \\vec{f}^*, \\mathcal{T}_x, \\mathcal{T}_y, \\vec{\\mathsf{D}}) &amp; \\stackrel{(1)}{=} \\mathsf{Dec}((1 - \\beta) \\cdot [\\vec{x_1}, \\vec{y_1}, z_1, \\vec{f_1}^*, \\mathcal{T}_x^{(1)}, \\mathcal{T}_y^{(1)}, \\vec{\\mathsf{D}_1}] \\\\ &amp; + \\beta \\cdot [\\vec{x_2}, \\vec{y_2}, z_2, \\vec{f_2}^*, \\mathcal{T}_x^{(2)}, \\mathcal{T}_y^{(2)}, \\vec{\\mathsf{D}_2}]) \\\\ &amp; \\stackrel{(2)}{=} (1 - \\beta) \\times \\mathsf{E}_1 + \\beta \\times \\mathsf{E}_2 + (1 - \\beta) \\cdot \\beta \\times \\mathsf{Q} \\\\ &amp; \\stackrel{(3)}{=} \\mathsf{E} \\end{split}</span>$</p>

    <p class="text-gray-300">by definition of E.</p>

    <p class="text-gray-300">Knowledge soundness. Consider an adversary  <span class="math">\\mathcal{A}</span>  that outputs  <span class="math">\\hat{\\pi} = (\\pi.x, \\pi.w)</span> , acc = (acc.x, acc.w),  <span class="math">\\hat{\\mathsf{pf}} \\in \\mathbb{G}_1</span>  and acc<sub>1</sub>.x, acc<sub>2</sub>.x. We build an extractor  <span class="math">\\mathsf{Ext}_{\\mathsf{acc}}</span>  that if  <span class="math">\\mathsf{V}_{\\mathsf{acc}}</span>  and  <span class="math">\\mathsf{D}_{\\mathsf{acc}}</span>  accept, extracts valid witnesses  <span class="math">\\mathsf{acc}_1.w</span> ,  <span class="math">\\mathsf{acc}_2.w</span>  for  <span class="math">\\mathsf{acc}_1.x</span> ,  <span class="math">\\mathsf{acc}_2.x</span> . Since  <span class="math">\\mathsf{acc}.w</span>  is an equation of degree one, given two accepting transcripts for different challenges  <span class="math">\\beta_1, \\beta_2</span> ,  <span class="math">\\mathsf{Ext}_{\\mathsf{acc}}</span>  can use the Vandermonde matrix to extract</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp; \\mathsf{acc}_1.w = (\\{\\mathsf{D}_1^{(\\vec{x})}\\}_{\\vec{x} \\in B_n}, \\vec{f}_1^*, \\mathcal{T}_1^{(x)}, \\mathcal{T}_1^{(y)}), \\\\ &amp; \\mathsf{acc}_2.w = (\\{\\mathsf{D}_2^{(\\vec{x})}\\}_{\\vec{x} \\in B_n}, \\vec{f}_2^*, \\mathcal{T}_2^{(x)}, \\mathcal{T}_2^{(y)}). \\end{split}</span>$</p>

    <p class="text-gray-300">We now prove that the extracted witnesses are valid. First, note that since the verifier accepts,  <span class="math">E = (1 - \\beta) \\times E_1 + \\beta \\times E_2 + (1 - \\beta) \\cdot \\beta \\times Q</span>  and</p>

    <p class="text-gray-300"><span class="math">$(\\mathsf{C}, T, \\vec{x}, \\vec{y}, z) = (1 - \\beta) \\cdot (\\mathsf{C}_1, T_1, \\vec{x}_1, \\vec{y}_1, z_1) + \\beta \\cdot (\\mathsf{C}_2, T_2, \\vec{x}_2, \\vec{y}_2, z_2)</span>$</p>

    <p class="text-gray-300">The left side of Eq.(i) of the decider is:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp; \\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}^{(\\vec{x})}, \\mathsf{V}^{(\\vec{x})}) = \\sum_{\\vec{x} \\in B_n} e\\Big((1-\\beta) \\times \\mathsf{D}_1^{(\\vec{x})} + \\beta \\times \\mathsf{D}_2^{(\\vec{x})}, \\mathsf{V}^{(\\vec{x})}\\Big) \\\\ &amp; = (1-\\beta) \\times \\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}_1^{(\\vec{x})}, \\mathsf{V}^{(\\vec{x})}) + \\beta \\times \\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}_2^{(\\vec{x})}, \\mathsf{V}^{(\\vec{x})}) \\end{split}</span>$</p>

    <p class="text-gray-300">Whereas the right side equals</p>

    <p class="text-gray-300"><span class="math">$e(\\mathsf{C},\\mathsf{V}) = e((1-\\beta) \\times \\mathsf{C}_1 + \\beta \\times \\mathsf{C}_2,\\mathsf{V}) = (1-\\beta) \\times e(\\mathsf{C}_1,\\mathsf{V}) + \\beta \\times e(\\mathsf{C}_2,\\mathsf{V})</span>$</p>

    <p class="text-gray-300">Since  <span class="math">\\beta</span>  is computed as a hash of  <span class="math">\\mathsf{acc}_1.x</span>  and  <span class="math">\\mathsf{acc}_2.x</span> , except with negligible probability  <span class="math">\\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}_1^{(\\vec{x})}, \\mathsf{V}^{(\\vec{x})}) = e(\\mathsf{C}_1, \\mathsf{V})</span>  and</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}_2^{(\\vec{x})}, \\mathsf{V}^{(\\vec{x})}) = e(\\mathsf{C}_2, \\mathsf{V})</span>$
. Similarly, Eq.(ii) holds if and only if</p>

    <p class="text-gray-300"><span class="math">$\\langle \\left( (1-\\beta)\\mathcal{T}_{1}^{(x)} + \\beta\\mathcal{T}_{2}^{(x)} \\parallel (1-\\beta)\\mathcal{T}_{1}^{(y)} + \\beta\\mathcal{T}_{2}^{(y)} \\right), \\vec{\\mathsf{K}} \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$= (1-\\beta)\\langle \\left( \\mathcal{T}_{1}^{(x)} \\parallel \\mathcal{T}_{1}^{(y)} \\right), \\vec{\\mathsf{K}} \\rangle + \\beta\\langle \\left( \\mathcal{T}_{2}^{(x)} \\parallel \\mathcal{T}_{2}^{(y)} \\right), \\vec{\\mathsf{K}} \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$= (1-\\beta)T_{1} + \\beta T_{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$= T.</span>$</p>

    <p class="text-gray-300">Thus the equation holds for  <span class="math">acc_1.w</span>  and  <span class="math">acc_2.w</span> . Finally, replacing the accumulation witness by the extracted ones, we have that Eq.(iii) is</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} &amp; \\mathsf{Dec}((1-\\beta)\\vec{x}_1 + \\beta\\vec{x}_2, (1-\\beta)\\vec{y}_1 + \\beta\\vec{y}_2, (1-\\beta)z_1 + \\beta z_2, (1-\\beta)\\vec{f}_1^* + \\beta\\vec{f}_2^*, \\\\ &amp; (1-\\beta)\\mathcal{T}_{x,1} + \\beta\\mathcal{T}_{x,2}, (1-\\beta)\\mathcal{T}_{y,1} + \\beta\\mathcal{T}_{y,2}, (1-\\beta)\\vec{D}_1 + \\beta\\vec{D}_2) \\\\ &amp; = (1-\\beta) \\times \\mathsf{E}_1 + \\beta \\times \\mathsf{E}_2 + (1-\\beta)\\beta \\times \\mathsf{Q} \\end{aligned}</span>$</p>

    <p class="text-gray-300">The left side of the equation equals</p>

    <p class="text-gray-300"><span class="math">$\\left\\langle \\mathcal{T}_{x}^{(\\mathrm{err})} || \\mathcal{T}_{y}^{(\\mathrm{err})} || \\langle \\vec{f}^{*}, \\mathcal{T}_{\\mathrm{leaves}}^{(y)} \\rangle - z, \\vec{\\mathsf{K}} || \\mathsf{K}&#x27; \\right\\rangle + \\langle \\vec{f}^{*}, (\\mathsf{H}^{(\\vec{y})})_{\\vec{y} \\in B_{n}} \\rangle - \\langle \\mathcal{T}_{\\mathrm{leaves}}^{(x)}, \\vec{\\mathsf{D}} \\rangle.</span>$</p>

    <p class="text-gray-300">such that:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{T}_{x}^{(\\text{err})} := (1 - \\beta)\\mathcal{T}_{x_{1}}^{(\\text{error})} + \\beta\\mathcal{T}_{x_{2}}^{(\\text{error})}, \\quad \\mathcal{T}_{y}^{(\\text{err})} := (1 - \\beta)\\mathcal{T}_{y_{1}}^{(\\text{error})} + \\beta\\mathcal{T}_{y_{2}}^{(\\text{error})},</span>$</p>

    <p class="text-gray-300"><span class="math">$\\vec{f}^{*} := (1 - \\beta)\\vec{f}_{1}^{*} + \\beta\\vec{f}_{2}^{*}, \\quad \\mathcal{T}_{\\text{leaves}}^{(y)} := (1 - \\beta)\\mathcal{T}^{(y_{1})}.\\text{leaves} + \\beta\\mathcal{T}^{(y_{2})}.\\text{leaves},</span>$</p>

    <p class="text-gray-300"><span class="math">$z := (1 - \\beta)z_{1} + \\beta z_{2}, \\quad \\mathcal{T}_{\\text{leaves}}^{(x)} := (1 - \\beta)\\mathcal{T}^{(x_{1})}.\\text{leaves} + \\beta\\mathcal{T}^{(x_{2})}.\\text{leaves},</span>$</p>

    <p class="text-gray-300"><span class="math">$\\vec{\\mathsf{D}} := (1 - \\beta)\\vec{\\mathsf{D}}_{1} + \\beta\\vec{\\mathsf{D}}_{2}.</span>$</p>

    <p class="text-gray-300">Term  <span class="math">\\beta</span>  contains equation (iii) of the Decider for  <span class="math">\\operatorname{acc}_1</span> , whereas term  <span class="math">\\beta(1-\\beta)</span>  contains the one for  <span class="math">\\operatorname{acc}_2</span> . Cross terms are in the coefficient of  <span class="math">\\beta(1-\\beta)</span> . Then, except with negligible probability,  <span class="math">\\operatorname{D}_{\\operatorname{acc}}(\\operatorname{acc}_1) = \\operatorname{D}_{\\operatorname{acc}}(\\operatorname{acc}_2) = 1</span>  and the extractor succeeds. We now prove that if  <span class="math">\\mathsf{E}_1 = 0</span> , we can extract a valid opening to  <span class="math">\\vec{C}_1</span> . That is,  <span class="math">(\\operatorname{acc}_1.x,\\operatorname{acc}_1.w)</span>  is a valid pair for the predicate  <span class="math">\\Phi</span> . From term  <span class="math">(1-\\beta)</span>  in the equation above we have that, except with negligible probability,  <span class="math">\\operatorname{Dec}(\\vec{x}_1,\\vec{y}_1,z_1,\\vec{f}_1^*,\\mathcal{T}^{(x_1)i},\\mathcal{T}^{(x_2)},\\vec{\\mathsf{D}}) = 0</span> . That is,</p>

    <p class="text-gray-300"><span class="math">$0 = \\langle \\mathcal{T}_x^{(\\text{error})} || \\mathcal{T}_y^{(\\text{error})} || \\langle \\vec{f}_1^*, \\mathcal{T}^{(y)}. \\text{leaves} \\rangle - z_1, \\vec{\\mathsf{K}} || \\mathsf{K}&#x27; \\rangle + \\langle \\vec{f}_1^*, (\\mathsf{H}^{(\\vec{y})})_{\\vec{y} \\in B_n} \\rangle - \\langle \\mathcal{T}^{(x)}. \\text{leaves}, \\vec{\\mathsf{D}}_1 \\rangle</span>$</p>

    <p class="text-gray-300">Claim:  <span class="math">\\vec{\\mathsf{D}}_1</span>  is base  <span class="math">(\\mathsf{H}^{(\\vec{y})})_{\\vec{y} \\in B_n}</span>  We first show that in the algebraic group model, we can write  <span class="math">\\vec{\\mathsf{D}}_1</span>  base  <span class="math">\\mathsf{H}^{(\\vec{y})}</span> . Consider the following check:</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}_1^{(\\vec{x})},\\mathsf{V}^{(\\vec{x})}) = e(\\mathsf{C}_1,\\mathsf{V}&#x27;)</span>$</p>

    <p class="text-gray-300">Note that,  <span class="math">V^{(\\vec{x})}</span>  contains a factor of  <span class="math">\\tau^{(\\vec{x})}</span> . The only elements that contain this factor in  <span class="math">\\mathbb{G}_1</span>  are the  <span class="math">\\mathsf{H}^{((\\vec{i}),(\\vec{j}))}</span>  generators. Thus,  <span class="math">\\mathsf{C}_1</span>  can only be written base  <span class="math">\\mathsf{H}^{(\\vec{i},\\vec{j})}</span> . Otherwise, we can break the discrete logarithm assumption. Conversely, this implies that each  <span class="math">\\mathsf{D}_1^{(\\vec{x})}</span>  must be written base  <span class="math">\\mathsf{H}^{(\\vec{i})}</span> , i.e.  <span class="math">\\mathsf{D}_1^{(\\vec{x})} = \\langle \\vec{f}^{(x)}, (\\mathsf{H}^{(\\vec{i})})_{\\vec{i} \\in B_n} \\rangle</span> . This proves the claim. Given this, we can write</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\langle \\mathcal{T}^{(x)}.\\text{leaves}, \\vec{\\mathsf{D}}_{1} \\rangle &amp;= \\sum_{\\vec{x} \\in B_{n}} \\mathcal{T}^{(x)}.\\text{leaves} \\cdot \\langle \\vec{f}^{(x)}, (\\mathsf{H}^{(\\vec{i})})_{\\vec{i} \\in B_{n}} \\rangle \\\\ &amp;= \\langle \\sum_{\\vec{x} \\in B_{n}} \\mathcal{T}^{(x)}.\\text{leaves} \\cdot \\vec{f}^{(x)}, (\\mathsf{H}^{(\\vec{i})})_{\\vec{i} \\in B_{n}} \\rangle \\\\ 0 &amp;= \\langle \\mathcal{T}_{x}^{(\\text{error})} ||\\mathcal{T}_{y}^{(\\text{error})}|| \\langle \\vec{f}_{1}^{*}, \\mathcal{T}^{(y)}.\\text{leaves} \\rangle - z_{1}, \\vec{\\mathsf{K}} || \\mathsf{K}&#x27; \\rangle + \\\\ &amp;\\qquad \\langle \\vec{f}_{1}^{*} - \\sum_{\\vec{x} \\in B_{n}} \\mathcal{T}^{(x)}.\\text{leaves} \\cdot \\vec{f}^{(x)}, (\\mathsf{H}^{(\\vec{i})})_{\\vec{i} \\in B_{n}} \\rangle \\end{split}</span>$</p>

    <p class="text-gray-300">We can split this equation into</p>

    <p class="text-gray-300"><span class="math">$\\langle \\mathcal{T}_x^{(\\mathrm{error})} || \\mathcal{T}_y^{(\\mathrm{error})} || \\langle \\vec{f_1}^*, \\, \\mathcal{T}^{(y)}. \\mathrm{leaves} \\rangle - z_1, \\vec{\\mathsf{K}} || \\mathsf{K}&#x27; \\rangle = 0</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$\\langle \\vec{f}_1^* - \\sum_{\\vec{x} \\in B_n} \\mathcal{T}^{(x)}. \\text{leaves} \\cdot \\vec{f}^{(x)}, (\\mathsf{H}^{(\\vec{i})})_{\\vec{i} \\in B_n} \\rangle = 0</span>$</p>

    <p class="text-gray-300">or we can break the  <span class="math">\\mathcal{U}</span> -find-rep assumption as the left side of the product is a polynomial that vanishes at the logarithms of the group elements in  <span class="math">\\vec{K}</span> . Then, we have that that Eq.(3) in Fig. 2 is satisfied since  <span class="math">f^*(\\vec{y}_1) = \\langle \\vec{f}_1^*, \\mathcal{T}^{(y_1)}.</span> leaves <span class="math">\\rangle = z_1</span> . Also,  <span class="math">\\langle \\vec{f}_1^*, (\\mathsf{H}^{(\\vec{y})})_{\\vec{y} \\in B_n} \\rangle = \\langle \\mathcal{T}^{(x)}.</span> leaves,  <span class="math">\\vec{\\mathsf{D}}_1 \\rangle = 0</span> , representing Eq.(2) in Figure 2. Finally, from above we have that Eq.(1) is also satisfied. Then, it is enough for Ext<sub>acc</sub> to run Ext<sub>KZH</sub>.</p>

    <p class="text-gray-300">We extend KZH-2 to a higher dimensional polynomial commitment which has a more efficient verifier and smaller proof size. This results in a smaller accumulator and a more efficient decider. In particular, we generalize the 2-dimensional KZH-2, which can be viewed as a vector-matrix-vector product, to higher-dimensional tensor products. This reduces the PC verifier from  <span class="math">\\sqrt{n}</span>  to  <span class="math">n^{1/k}</span> . Note that in order to build efficient accumulation for a multilinear PCS, we need to expand a <em>short</em> evaluation point  <span class="math">\\vec{x}</span>  into <em>long</em> vectors, which correspond to  <span class="math">\\operatorname{eq}(\\vec{x}, \\vec{b})</span>  for  <span class="math">\\vec{b} \\in H \\subset \\mathbb{F}</span> . This transformation is equivalent to the one in KZH-2, and we omit it here for ease of presentation.</p>

      <h3 id="app-c.1" class="text-xl font-semibold mt-8">C.1 KZH-k</h3>

    <p class="text-gray-300"><strong>Notation.</strong> We denote the space of n dimensional tensors with dimensions  <span class="math">(d_1, d_2, \\ldots, d_n)</span>  on field  <span class="math">\\mathbb{F}</span>  with  <span class="math">\\mathbb{F}^{d_1 \\times d_2 \\times \\cdots \\times d_n}</span> . For  <span class="math">\\mathbf{T} \\in \\mathbb{F}^{d_1 \\times d_2 \\times \\cdots \\times d_k}</span>  and  <span class="math">\\vec{x}_1 \\in \\mathbb{F}^{d_1}</span> , we denote tensor inner product as</p>

    <p class="text-gray-300"><span class="math">$\\langle \\mathbf{T}, \\vec{x}_1 \\rangle = \\langle \\mathbf{T}_1, \\vec{x}_1 \\rangle \\otimes \\mathbf{T}_2 \\otimes \\ldots \\otimes \\mathbf{T}_k.</span>$</p>

    <p class="text-gray-300">Note that the result is a tensor in  <span class="math">\\mathbb{F}^{d_2 \\times \\cdots \\times d_k}</span> . Similarly for  <span class="math">\\vec{x}_1 \\in \\mathbb{F}^{d_1}</span>  and  <span class="math">\\vec{x}_2 \\in \\mathbb{F}^{d_2}</span> ,  <span class="math">\\langle \\mathbf{T}, \\vec{x}_1 \\otimes \\vec{x}_2 \\rangle = \\langle \\langle \\mathbf{T}, \\vec{x}_1 \\rangle, \\vec{x}_2 \\rangle \\in \\mathbb{F}^{d_3 \\times \\cdots \\times d_k}</span> .</p>

    <p class="text-gray-300"><strong>Protocol description.</strong> We construct a commitment scheme for such tensors, where <strong>T</strong> represents the polynomial that can be opened at evaluation point  <span class="math">(\\vec{x}_1, \\ldots, \\vec{x}_k)</span>  for  <span class="math">\\vec{x}_j \\in \\mathbb{F}^{d_j}</span>  as:</p>

    <p class="text-gray-300"><span class="math">$\\langle \\langle \\langle \\langle \\mathbf{T}, \\vec{x}_1 \\rangle, \\vec{x}_2 \\rangle, \\dots, \\vec{x}_{k-1} \\rangle, \\vec{x}_k \\rangle = y \\in \\mathbb{F}.</span>$</p>

    <p class="text-gray-300">The scheme admits an efficient accumulation scheme and is general enough to support multilinear and univariate polynomial commitments. Compared to two-dimensional KZH, the tradeoff is that the accumulator instance and verifier are of size k, but the accumulation witness is of size  <span class="math">n^{\\frac{1}{k}}</span> . The core insight is that we commit to  <span class="math">\\mathsf{C} = \\langle \\mathbf{T}, \\vec{\\mu}_1 \\otimes \\vec{\\mu}_2 \\cdots \\otimes \\vec{\\mu}_k \\rangle \\times \\mathsf{G}</span> , for secret elements  <span class="math">\\vec{\\mu}_1, \\ldots, \\vec{\\mu}_k</span>  and group generator  <span class="math">\\mathsf{G}</span> , and open  <span class="math">[\\mathsf{C}_i]_{i=1}^k</span> , commitments to all k-1 dimensional slices of  <span class="math">\\mathbf{T}</span> . The verifier can check that these slices are correct using a pairing with  <span class="math">\\vec{\\mu}_1</span>  and compute  <span class="math">\\mathsf{C}&#x27; = \\langle (\\mathsf{C}_1, \\ldots, \\mathsf{C}_k), \\vec{x}_1, \\rangle</span> .  <span class="math">\\mathsf{C}&#x27;</span>  is now a commitment to the k-1 dimensional tensor  <span class="math">\\mathbf{T}_1 = \\langle \\mathbf{T}, \\vec{x}_1 \\rangle</span>  and we can recursively apply the scheme. We present the full protocol for degree  <span class="math">[d]^k := (d, d, \\ldots, d)</span>  tensor in Figure 12.</p>

    <p class="text-gray-300">Efficiency. The commitment size is a single  <span class="math">\\mathbb{G}_1</span>  element. The commitment time is dominated by an MSM of size n for tensors of size n. Part of the opening can be preprocessed, as with KZH-2, reducing the opening time to the tensor product plus  <span class="math">O(n^{1/2})</span>  group operations. Concretely, the prover will compute commitments to  <span class="math">f(\\vec{X}, \\vec{b})</span>  for all  <span class="math">\\vec{b} \\in \\{0, 1\\}^{\\log(n)/2}</span> . Using these the first  <span class="math">\\log(n)/2</span>  steps of the opening proof can be computed in time  <span class="math">O(\\sqrt{n})</span> . The second half of the opening proof can also be computed efficiently using  <span class="math">f(\\vec{\\alpha}, \\vec{X})</span>  for the</p>

    <p class="text-gray-300">partial evaluation point &#8407;&alpha; &isin; F log(n)/2 . The proof size is (k &minus; 1) &middot; n <sup>1</sup>/k G<sup>1</sup> elements, as well as n <sup>1</sup>/k field elements. The verification time is O(k &middot; n <sup>1</sup>/k) and dominated by k &minus; 1 pairing products of size n 1/k .</p>

    <p class="text-gray-300">Preprocessing for free Boolean openings. As in KZH-2, we can preprocess so that openings at Boolean points are essentially free: the opening reduces to retrieving a precomputed commitment. Let</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{T}_{\\vec{x}_1,\\dots,\\vec{x}_i} := \\langle \\dots \\langle \\mathbf{T}, \\vec{x}_1 \\rangle, \\vec{x}_2 \\rangle, \\dots, \\vec{x}_i \\rangle</span>$</p>

    <p class="text-gray-300">denote the sequential multilinear evaluation of T at Boolean points &#8407;x1, . . . , &#8407;x<sup>i</sup> . During setup, for each 1 &le; i &lt; k, we precompute all commitments of the form</p>

    <p class="text-gray-300"><span class="math">$\\forall \\vec{x}_1 \\in \\{0,1\\}^{d_1}, \\dots, \\vec{x}_i \\in \\{0,1\\}^{d_i} : \\langle \\mathbf{T}_{\\vec{x}_1,\\dots,\\vec{x}_i}, \\mathbf{H}_{j+1} \\rangle.</span>$</p>

    <p class="text-gray-300">For each i, this takes O(n) time, so the total preprocessing cost is O(nk). Once preprocessing is done, any Boolean opening (&#8407;x1, . . . , &#8407;xk) can be resolved without extra computation. In the online phase, the usual computation D<sup>j</sup> [i] &larr; &#10216;&#10216;i&#10217;&otimes;T<sup>j</sup> , Hj+1&#10217;, where T<sup>j</sup> = T&#8407;x1,...,&#8407;xj&minus;<sup>1</sup> , is already precomputed, since all the points &#8407;x<sup>t</sup> and &#10216;i&#10217; are Boolean points. Thus, the opening step reduces to simply selecting the corresponding precomputed commitment.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{KZH}^{(k)}.\\mathsf{Setup}(\\lambda,d,k)</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\bullet \\ \\ \\text{Sample} \\ \\mathsf{G} \\leftarrow \\!\\!\\!\\! \\</span> , \\mathbb{G}<em>1, \\mathsf{V} \\leftarrow !!!! $ , \\mathbb{G}_2 \\ \\text{and} \\ [[\\mu</em>{i,j}]<em>{i=1}^d]</em>{i=1}^k \\leftarrow !!!! $ , \\mathbb{F}$</li>
      <li><span class="math">\\mathbf{H}_1 = \\{ \\mathsf{H}_{i_1,...,i_k} \\leftarrow (\\prod_{i=1}^k \\mu_{i_s,j}) \\times \\mathsf{G} : \\forall i_1,...,i_k \\in [d] \\}</span></li>
      <li><span class="math">\\mathbf{H}_2 = \\{ \\mathsf{H}_{i_2,...,i_k} \\leftarrow (\\prod_{i=2}^k \\mu_{i_j,j}) \\times \\mathsf{G} : \\forall i_2,...,i_k \\in [d] \\}</span></li>
      <li>...</li>
      <li><span class="math">\\mathbf{H}_k = \\{ \\mathsf{H}_{i_k} \\leftarrow \\mu_{i_k,k} \\times \\mathsf{G} : \\forall i_k \\in [d] \\}</span></li>
      <li><span class="math">\\mathbf{V} = \\{ V_{i,j} \\leftarrow \\mu_{i,j} \\times V : \\forall i \\in [d], j \\in [k] \\}</span></li>
      <li>Output  <span class="math">(G, V, \\mathbf{H}_1, \\mathbf{H}_2, \\dots, \\mathbf{H}_k, \\mathbf{V})</span></li>
    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{KZH}^{(k)}.\\mathsf{Commit}(\\mathsf{srs},\\mathbf{T})</span> : For  <span class="math">\\mathbf{T}\\in\\mathbb{F}^{d\\times d\\times \\cdots \\times d}</span> , compute the commitment as it follows:</p>

    <p class="text-gray-300">&bull; Output
<span class="math">$\\mathsf{C} \\leftarrow \\langle \\mathbf{T}, \\mathbf{H}_1 \\rangle = \\sum_{(i_1,i_2,\\dots,i_k) \\in [d]^k} \\mathbf{T}_{i_1,i_2,\\dots,i_k} \\times \\mathsf{H}_{i_1,i_2,\\dots,i_k}</span>$</p>

    <p class="text-gray-300"><span class="math">\\mathsf{KZH}^{(k)}.\\mathsf{Open}(\\mathsf{srs},\\mathsf{C},\\mathbf{T},\\vec{x}_1,\\ldots,\\vec{x}_k)</span> : Given commitment  <span class="math">\\mathsf{C}\\in\\mathbb{G}_1</span> , tensor  <span class="math">\\mathbf{T}\\in\\mathbb{F}^{d\\times d\\times \\cdots \\times d}</span>  and inputs  <span class="math">\\vec{x}_i\\in\\mathbb{F}^d</span> , compute opening as it follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">\\mathbf{T}_1 = \\mathbf{T}</span></li>
      <li>For j = 1, ..., k 1:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set  <span class="math">\\mathbf{T}_{i+1} \\leftarrow \\langle \\mathbf{T}_i, \\vec{x_i} \\rangle</span></li>
      <li>Compute vector  <span class="math">\\vec{\\mathsf{D}}_j</span>  e.g.  <span class="math">\\mathsf{D}_j[i] \\leftarrow \\langle \\langle i \\rangle \\otimes \\mathbf{T}_j, \\mathbf{H}_{j+1} \\rangle</span>  for all  <span class="math">i \\in [d]</span> , where  <span class="math">\\langle i \\rangle</span>  represents decomposition of i into d bits.</li>
    </ul></li>
      <li>Output  <span class="math">\\pi \\leftarrow \\{ [\\vec{\\mathsf{D}}_j]_{j \\in [k-1]}, \\, \\mathbf{T}_k \\}</span></li>
    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{KZH}^{(k)}.\\mathsf{Verify}(\\mathsf{srs},\\mathsf{C},[\\vec{x}_j]_{j\\in[k]},y,\\pi)</span> : Given commitment  <span class="math">\\mathsf{C}\\in\\mathbb{G}_1</span> , inputs  <span class="math">\\vec{x}_j\\in\\mathbb{F}^d</span> , output  <span class="math">y\\in\\mathbb{F}</span>  and opening proof  <span class="math">\\pi</span> , does as it follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse  <span class="math">\\{[\\vec{\\mathsf{D}}_j]_{j\\in[k-1]},\\,\\mathbf{T}_k\\}\\leftarrow\\pi</span></li>
      <li>Set  <span class="math">C_0 = C</span></li>
      <li>For  <span class="math">j \\in 1, ..., k-1</span>    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that  <span class="math">e(C_{j-1}, V) = \\sum_{i=0}^{d} e(D_{j}[i], V_{i,j})</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">C_j \\leftarrow \\langle \\vec{x}_j, \\vec{\\mathsf{D}}_i \\rangle</span></li>
    </ol></li>
    </ul></li>
      <li>Check that  <span class="math">C_{k-1} = \\langle \\mathbf{T}_k, \\mathbf{H}_k \\rangle</span></li>
      <li>&bull; Check that  <span class="math">\\langle \\mathbf{T}_k, \\vec{x}_k \\rangle = y</span></li>
    </ul>

    <p class="text-gray-300">Figure 12: KZH-k description</p>

    <p class="text-gray-300"><strong>Theorem 5.</strong> The protocol in Figure 12 is a complete and knowledge-sound polynomial commitment scheme in the AGM under  <span class="math">(q_1, q_2)</span> -dlog and Setup-find-rep assumption in the algebraic group model.</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300"><strong>Completeness.</strong> Consider honestly generated C,  <span class="math">[C_j]_{j=1}^k</span> . For the first check, note that  <span class="math">e(C_0, V) = e(\\langle \\mathbf{T}, \\mathbf{H}_1 \\rangle, V)</span>  by construction of C. On the other hand,</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=0}^{d} e(\\mathsf{D}_{1}[i], \\mathsf{V}_{i,1}) = \\sum_{i=0}^{d} e(\\langle \\langle i \\rangle \\otimes \\mathbf{T}_{1}, \\mathbf{H}_{2} \\rangle, \\mu_{i,1} \\times \\mathsf{V}) = \\sum_{i=0}^{d} e(\\langle \\langle i \\rangle \\otimes \\mathbf{T}_{1}, \\mu_{i,1} \\times \\mathbf{H}_{2} \\rangle, \\mathsf{V})</span>$</p>

    <p class="text-gray-300"><span class="math">$= e(\\langle \\mathbf{T}_{1}, \\mathbf{H}_{1} \\rangle, \\mathsf{V})</span>$</p>

    <p class="text-gray-300">and since  <span class="math">T_1 = T</span> , the verifier accepts. For the general case,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} e(\\mathsf{C}_{j-1},\\mathsf{V}) &amp;= e(\\langle \\vec{\\mathsf{D}}_{j-1}, \\vec{x}_{j-1} \\rangle, \\mathsf{V}) = e(\\sum_{i=1}^d \\vec{\\mathsf{D}}_{j-1}[i] \\vec{x}_{j-1}[i], \\mathsf{V}) \\\\ &amp;= e(\\sum_{i=1}^d \\langle \\langle i \\rangle \\otimes \\mathbf{T}_{j-1}, \\, \\mathbf{H}_j \\rangle \\vec{x}_{j-1}[i], \\mathsf{V}) = e(\\sum_{i=1}^d \\langle \\langle \\vec{x}_{j-1}, \\mathbf{T}_{j-1} \\rangle, \\, \\mathbf{H}_j \\rangle, \\mathsf{V}) \\\\ &amp;= e(\\langle \\mathbf{T}_j, \\, \\mathbf{H}_j \\rangle, \\mathsf{V}) = \\sum_{i=1}^d e(\\langle \\mathbf{T}_j, \\, \\mathbf{H}_{j+1} \\rangle, \\mathsf{V}_{i,j}) \\\\ &amp;= \\sum_{i=1}^d e(\\mathsf{D}_j[i], \\mathsf{V}_{i,j}). \\end{split}</span>$</p>

    <p class="text-gray-300">In the second verification equation we have:</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\mathsf{C}_{k-1} &amp;= \\langle \\vec{x}_{k-1}, \\vec{\\mathsf{D}}_{k-1} \\rangle = \\sum_{i=1}^d \\vec{\\mathsf{D}}_{k-1}[i] \\vec{x}_{k-1}[i] \\\\ &amp;= \\sum_{i=1}^d \\langle \\langle i \\rangle \\otimes \\mathbf{T}_{k-1}, \\, \\mathbf{H}_k \\rangle \\vec{x}_{k-1}[i] = \\sum_{i=1}^d \\langle \\langle \\mathbf{T}_{k-1}, \\vec{x}_{k-1} \\rangle, \\, \\mathbf{H}_k \\rangle \\\\ &amp;= \\langle \\mathbf{T}_k, \\mathbf{H}_k \\rangle. \\end{aligned}</span>$</p>

    <p class="text-gray-300">And since the third check follows directly, we have that the verifier accepts.</p>

    <p class="text-gray-300"><strong>Knowledge soundness.</strong> Let  <span class="math">\\mathcal{A}</span>  be a PPT adversary that on input srs outputs a commitment  <span class="math">\\mathsf{C}</span> . We define an extractor  <span class="math">\\mathcal{E}</span>  that outputs  <span class="math">p(\\vec{X}_1,\\ldots,\\vec{X}_k)</span>  such that, for any tuple  <span class="math">((\\vec{x}_1,\\ldots,\\vec{x}_k),y,\\pi)</span> , accepted by the verifier,  <span class="math">p(\\vec{x}_1,\\ldots,\\vec{x}_k)=y</span>  with overwhelming probability. Under the AGM, we assume  <span class="math">\\mathcal{A}</span>  is algebraic and thus  <span class="math">\\mathcal{A}</span>  outputs  <span class="math">\\mathsf{C}</span>  along with  <span class="math">\\{\\vec{c}^r\\}_{r=1}^k</span>  such that:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{C} = \\sum_{r=1}^k \\langle \\vec{c}^r, \\mathbf{H}_r \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}</span>  outputs  <span class="math">p(\\vec{X}_1, \\dots, \\vec{X}_k) = (\\vec{c}_1, \\dots, \\vec{c}_k) \\otimes (\\vec{X}_1, \\dots, \\vec{X}_k)</span> . Under the AGM,  <span class="math">\\mathcal{E}</span>  does not abort. Similarly, under the AGM we have that there exist  <span class="math">[\\vec{d}_{i,j}^r]_{r=1}^k</span>  such that for all i, j:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{D}_{j}[i] = \\sum_{r=1}^{k} \\langle \\vec{d}_{i,j}^{r}, \\mathbf{H}_{r} \\rangle</span>$</p>

    <p class="text-gray-300">Because the verifier accepts, we have that all their checks are satisfied. In particular, for C and all  <span class="math">[D_1[i]]_{i=0}^d</span> :</p>

    <p class="text-gray-300"><span class="math">$e(\\mathsf{C},\\mathsf{V}) = \\sum_{i=1}^d e(\\mathsf{D}_1[i],\\mathsf{V}_{i,1})</span>$</p>

    <p class="text-gray-300">Replacing by the extracted  <span class="math">C, D_1[i]</span>  and the form of  <span class="math">V_{i,1}</span> , we have</p>

    <p class="text-gray-300"><span class="math">$e\\left(\\sum_{r=1}^{k}\\langle \\vec{c}^r, \\mathbf{H}_r \\rangle, \\mathsf{V}\\right) = \\sum_{i=1}^{d} e\\left(\\sum_{r=1}^{k}\\langle \\vec{d}_{i,1}^r, \\mathbf{H}_r \\rangle, \\mu_{i,1} \\times \\mathsf{V}\\right)</span>$</p>

    <p class="text-gray-300">Then,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) It must be the case that  <span class="math">\\vec{c}^r = 0</span>  for all  <span class="math">r \\neq 1</span>  or we can calculate the discrete logarithm relation between  <span class="math">\\mathbf{H}_2, \\ldots, \\mathbf{H}_k</span>  and  <span class="math">[\\mathsf{V}_{i,1}]_{i=1}^d</span> , breaking the dlog assumption. Similarly, we have  <span class="math">\\vec{d}_{i,1}^r = 0</span>  for all r &gt; 2 or we can find the discrete log relation between  <span class="math">\\mathbf{H}_2</span>  and  <span class="math">\\mathbf{H}_3, \\ldots, \\mathbf{H}_k</span> .</li>
      <li>(2) Also,  <span class="math">\\vec{d}_{i,1}^1=0</span>  or we can extract  <span class="math">(\\mu_{i,1}^2\\prod_{j\\neq 1}\\mu_{i,j})\\times\\mathsf{G},</span>  breaking CDH.</li>
      <li>(3) Finally, we have that each  <span class="math">\\mathsf{D}_1[i]</span>  is base  <span class="math">[\\mathsf{H}_{ii_3...i_k}]_{i_3,...,i_k\\in[d]}</span> , i.e.,  <span class="math">\\mathsf{D}_1[i]=\\langle \\vec{d}_{i,1}^2,\\mu_{i,2}\\times\\mathbf{H}_3\\rangle</span> , or we can find the discrete log relation between  <span class="math">\\mu_{i,1}\\times\\mu_{s,2}\\times\\mathbf{H}_3</span>  and  <span class="math">\\mathbf{H}_1</span>  for  <span class="math">s\\neq i</span> . This implies  <span class="math">(\\vec{d}_{i,1}^2)_s=0</span>  for all  <span class="math">s\\neq i</span> .</li>
    </ul>

    <p class="text-gray-300">The equation then is</p>

    <p class="text-gray-300"><span class="math">$e\\left(\\langle \\vec{c}^1, \\mathbf{H}_1 \\rangle, \\mathsf{V}\\right) = \\sum_{i=1}^d e\\left(\\langle \\vec{d}_{i,1}^2, \\mathbf{H}_{2,i} \\rangle, \\mu_{i,1} \\times \\mathsf{V}\\right)</span>$</p>

    <p class="text-gray-300">which implies  <span class="math">\\vec{c}_1 = \\sum_{i=1}^d \\vec{d}_{i,1}^2</span> . Indeed, if there exists  <span class="math">s \\in [k]</span>  such that  <span class="math">c_s \\neq d_{s,1}^2</span> ,  <span class="math">\\mu_{s,1}</span>  is a root of the polynomial  <span class="math">c_s X - d_{s,1}^2 X</span>  and we can find it, breaking dlog. In the general case, for every  <span class="math">j = 2, \\ldots, k</span>  we have:</p>

    <p class="text-gray-300"><span class="math">$e\\left(\\mathsf{C}_{j},\\mathsf{V}\\right) = \\sum_{i=0}^{d} e\\left(\\mathsf{D}_{j+1}[i], \\mu_{i,j+1} \\times \\mathsf{V}\\right)</span>$</p>

    <p class="text-gray-300">for  <span class="math">C_j = \\langle \\vec{x}_j, \\vec{\\mathsf{D}}^j \\rangle</span> . Then, if  <span class="math">\\mathsf{D}^j = \\langle \\vec{d}^j, \\mathbf{H}_j \\rangle</span> , it must be the case that  <span class="math">\\mathsf{D}^{j+1} = \\langle \\vec{d}^{j+1}, \\mathbf{H}_{j+1} \\rangle</span> , with  <span class="math">\\vec{d}_s^{j+1} = 0</span>  fro all  <span class="math">s \\neq j+1</span>  or we break dlog as in item (1) and (3), and CDH as in (2) above. By induction, we have  <span class="math">\\mathsf{D}^j = \\langle \\vec{d}^j, \\mathbf{H}_j \\rangle</span>  for all  <span class="math">j = 1, \\ldots, k</span> ., Finally, we have</p>

    <p class="text-gray-300"><span class="math">$e\\left(\\langle \\vec{x}_j, \\vec{\\mathsf{D}}^j \\rangle, \\mathsf{V}\\right) = \\sum_{i=0}^d e\\left(\\langle \\vec{d}_i^{\\vec{\\jmath}+1}, \\mathbf{H}_{j+1} \\rangle, \\mu_{i,j+1} \\times \\mathsf{V}\\right)</span>$</p>

    <p class="text-gray-300">And thus</p>

    <p class="text-gray-300"><span class="math">$\\langle \\vec{x}_j, \\langle \\vec{d}^j, \\mathbf{H}_j \\rangle \\rangle = \\langle \\sum_{i=0}^d \\vec{d}_i^{j+1}, \\mathbf{H}_{j+1} \\rangle</span>$</p>

    <p class="text-gray-300">So  <span class="math">\\sum_{i=0}^{d} \\vec{d}_{i}^{j+1} = \\vec{x}_{j} \\otimes \\vec{d}^{j}</span> , This implies  <span class="math">\\mathbf{T}_{k} = \\vec{x}_{k-1} \\otimes \\ldots \\otimes \\vec{x}_{1} \\otimes \\vec{c}</span>  and thus  <span class="math">y = \\vec{x}_{k} \\otimes \\mathbf{T}_{k}</span>  implies  <span class="math">y = p(\\vec{x}_{1}, \\ldots, \\vec{x}_{k})</span>  for the polynomial  <span class="math">p(\\vec{X}_{1}, \\ldots, \\vec{X}_{k})</span>  encoded in C and we conclude the proof.</p>

      <h3 id="app-c.2" class="text-xl font-semibold mt-8">C.2 KZH-k accumulation</h3>

    <p class="text-gray-300">We now construct an accumulation scheme for KZH-k. In particular, we focus on the case where the tensor  <span class="math">\\mathbf{T}</span>  is a multilinear polynomial. At a high level, the KZH-k verifier is still low degree and algebraic, and therefore, we can apply the same accumulation strategy as in the two-dimensional case. Importantly, the accumulator size and the decider time are reduced to  <span class="math">O(k \\cdot n^{\\frac{1}{k}})</span> . The accumulation verifier performs O(k)  <span class="math">\\mathbb{G}_1</span>  operations. For a  <span class="math">k \\cdot d</span> -linear polynomial, the accumulator instance and witness can be described as it follows: (red terms only appear in accumulators not proofs)</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\mathsf{acc}.x &amp;= \\{\\mathsf{C},\\, \\mathsf{C}_1, \\dots, \\mathsf{C}_{k-1} \\in \\mathbb{G},\\, \\vec{x}_1, \\dots, \\vec{x}_k \\in \\mathbb{F}^d, y \\in \\mathbb{F},\\, \\underline{E_{\\mathbb{G}}} \\in \\mathbb{G}, e_{\\mathbb{F}} \\in \\mathbb{F} \\} \\\\ \\\\ \\mathsf{acc}.w &amp;= \\{ [\\mathsf{D}_{i,j}]_{j \\in [k-1],\\, i \\in [0,d]}, \\mathbf{T}_k \\in \\mathbb{F}^d \\} \\end{aligned}</span>$</p>

    <p class="text-gray-300">The accumulation prover, verifier and decider of KZH-k are respectively defined in Figures 13 and 14.</p>

    <p class="text-gray-300"><strong>Efficiency.</strong> The accumulator consists of the PCS proof and is of size  <span class="math">O(k \\cdot n^{1/k})</span> . The accumulation decider runs the PCS verifier and is dominated by k-1  <span class="math">n^{1/k}</span>  pairing products and the accumulation verifier is dominated by k+1  <span class="math">\\mathbb{G}_1</span>  operations.</p>

    <p class="text-gray-300"><span class="math">P_{acc}(srs, (acc.x, acc.w), (acc&#x27;.x, acc&#x27;.w))</span> :</p>

    <p class="text-gray-300">&bull; Parse acc.x, acc.w and acc'.x, acc'.w as below:</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{l} - \\ \\{\\mathsf{C},\\mathsf{C}_1,\\ldots,\\mathsf{C}_{k-1},\\ (\\vec{x}_1,\\ldots,\\vec{x}_k,y),\\ (E_{\\mathbb{G}},e_{\\mathbb{F}})\\} \\leftarrow \\mathsf{acc}.x \\\\ - \\ \\{\\{[\\mathsf{D}_{i,j}]_{j\\in[k-1],\\,i\\in[0,d]},\\ \\mathbf{T}_k\\} \\leftarrow \\mathsf{acc}.w \\\\ - \\ \\{\\mathsf{C}&#x27;,\\mathsf{C}&#x27;_1,\\ldots,\\mathsf{C}&#x27;_{k-1},\\ (\\vec{x}&#x27;_1,\\ldots,\\vec{x}&#x27;_k,y&#x27;),\\ (E&#x27;_{\\mathbb{G}},e&#x27;_{\\mathbb{F}})\\} \\leftarrow \\mathsf{acc}&#x27;.x \\\\ - \\ \\{\\{[\\mathsf{D}&#x27;_{i,j}]_{j\\in[k-1],\\,i\\in[0,d]},\\mathbf{T}&#x27;_k\\} \\leftarrow \\mathsf{acc}&#x27;.w \\end{array}</span>$</p>

    <p class="text-gray-300">&bull; Let  <span class="math">\\mathsf{Dec}_{\\mathbb{G}}</span>  and  <span class="math">\\mathsf{Dec}_{\\mathbb{F}}</span>  be the verification checks as defined in Figure ??. Compute  <span class="math">Q \\in \\mathbb{G}</span>  such that:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathsf{Dec}_{\\mathbb{G}} \\big( (1-X) \\cdot (\\vec{x}_j, \\mathsf{C}_j, [\\mathsf{D}_{i,j}]_{i=0}^d) + X \\cdot (\\vec{x}_j&#x27;, \\mathsf{C}_j&#x27;, [\\mathsf{D}_{i,j}&#x27;]_{i=0}^{d_j}) \\big) \\\\ &amp;= (1-X) \\times E_j + X \\times E_j&#x27; + (1-X) \\cdot X \\times Q. \\end{split}</span>$</p>

    <p class="text-gray-300">and  <span class="math">q \\in \\mathbb{F}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\mathsf{Dec}_{\\mathbb{F}} \\Big( (1-X) \\cdot (\\mathbf{T}_k, \\vec{x}_k, y) + X \\cdot (\\mathbf{T}_k&#x27;, \\vec{x}_k&#x27;, y&#x27;) \\Big) \\\\ &amp;= (1-X) \\cdot e_{\\mathbb{F}} + X \\cdot e_{\\mathbb{F}}&#x27; + (1-X) \\cdot X \\cdot q. \\end{aligned}</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Derive challenge  <span class="math">\\alpha \\leftarrow H(\\mathsf{acc}.x, \\mathsf{acc}&#x27;.x, Q, q)</span>  through Fiat-Shamir.</li>
      <li>Compute</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} &amp;- \\mathsf{C}&#x27;&#x27; \\leftarrow (1-\\alpha) \\times \\mathsf{C} + \\alpha \\times \\mathsf{C}&#x27; \\\\ &amp;- \\vec{x_i}&#x27;&#x27; \\leftarrow (1-\\alpha) \\cdot \\vec{x_i} + \\alpha \\cdot \\vec{x_i}&#x27; \\text{ for } i \\in [k] \\\\ &amp;- y&#x27;&#x27; \\leftarrow (1-\\alpha) \\cdot y + \\alpha \\cdot y&#x27; \\\\ &amp;- \\mathsf{C}&#x27;&#x27;_j \\leftarrow (1-\\alpha) \\times \\mathsf{C}_j + \\alpha \\times \\mathsf{C}&#x27;_j \\text{ for } j \\in [1, k-1] \\\\ &amp;- \\mathsf{D}&#x27;&#x27;_{i,j} \\leftarrow (1-\\alpha) \\times \\mathsf{D}_{i,j} + \\alpha \\times \\mathsf{D}&#x27;_{i,j} \\text{ for each } j, i \\text{ for } i \\in [k] \\text{ and } j \\in [k-1] \\\\ &amp;- E&#x27;&#x27;_{\\mathbb{G}} \\leftarrow (1-\\alpha) \\times E_{\\mathbb{G}} + \\alpha \\times E&#x27;_{\\mathbb{G}} + (1-\\alpha) \\cdot \\alpha \\times Q \\\\ &amp;- e&#x27;&#x27;_{\\mathbb{F}} \\leftarrow (1-\\alpha) \\cdot e_{\\mathbb{F}} + \\alpha \\cdot e&#x27;_{\\mathbb{F}} + (1-\\alpha) \\cdot \\alpha \\cdot q \\\\ &amp;- \\mathbf{T}&#x27;&#x27;_k \\leftarrow (1-\\alpha) \\times \\mathbf{T}_k + \\alpha \\times \\mathbf{T}&#x27;_k \\end{aligned}</span>$</p>

    <p class="text-gray-300">&bull; Output the new accumulator  <span class="math">\\mathsf{acc}&#x27;&#x27; = (\\mathsf{acc}&#x27;&#x27;.x, \\mathsf{acc}&#x27;&#x27;.w)</span>  and  <span class="math">\\mathsf{pf} = \\{Q, q\\}</span>  as the accumulation proof.</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp; \\mathsf{acc&#x27;&#x27;}.x = \\{\\mathsf{C&#x27;&#x27;},\\, [\\mathsf{C}&#x27;&#x27;_j]_{j \\in [k-1]}, [\\vec{x}&#x27;&#x27;_i]_{i \\in [k]}, y&#x27;&#x27;, [E&#x27;&#x27;_{\\mathbb{G}}, e_{\\mathbb{F}}\\} \\\\ &amp; \\mathsf{acc&#x27;&#x27;}.w = \\{\\{[\\mathsf{D}&#x27;&#x27;_{i,j}]_{j \\in [k-1],\\, i \\in [0,d_j]}, \\mathbf{T}&#x27;&#x27;_k\\} \\end{split}</span>$</p>

    <p class="text-gray-300">Figure 13: KZH-k accumulation prover</p>

    <p class="text-gray-300"><span class="math">V_{acc}(srs, acc.x, acc&#x27;.x, pf = \\{Q \\in \\mathbb{G}, q \\in \\mathbb{F}\\})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Input acc.x, acc'.x and pf =  <span class="math">\\{Q, q\\}</span> .</li>
      <li>Regenerate challenge  <span class="math">\\alpha \\leftarrow H(A.X, A&#x27;.X, \\mathsf{pf})</span></li>
      <li>Compute</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;-\\mathsf{C}&#x27;&#x27; \\leftarrow (1-\\alpha) \\times \\mathsf{C} + \\alpha \\times \\mathsf{C}&#x27; \\\\ &amp;-\\vec{x_i}&#x27;&#x27; \\leftarrow (1-\\alpha) \\cdot \\vec{x_i} + \\alpha \\cdot \\vec{x_i}&#x27; \\text{ for } i \\in [k] \\\\ &amp;-y&#x27;&#x27; \\leftarrow (1-\\alpha) \\cdot y + \\alpha \\cdot y&#x27; \\\\ &amp;-\\mathsf{C}&#x27;&#x27;_j \\leftarrow (1-\\alpha) \\times \\mathsf{C}_j + \\alpha \\times \\mathsf{C}&#x27;_j \\text{ for } j \\in [1,k-1] \\\\ &amp;-E&#x27;&#x27;_{\\mathbb{G}} \\leftarrow (1-\\alpha) \\times E_{\\mathbb{G}} + \\alpha \\times E&#x27;_{\\mathbb{G}} + (1-\\alpha) \\cdot \\alpha \\times Q \\\\ &amp;-e&#x27;&#x27;_{\\mathbb{F}} \\leftarrow (1-\\alpha) \\cdot e_{\\mathbb{F}} + \\alpha \\cdot e&#x27;_{\\mathbb{F}} + (1-\\alpha) \\cdot \\alpha \\times q \\end{split}</span>$</p>

    <p class="text-gray-300">&bull; Output the new accumulator instance acc&quot;.x.</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{acc}&#x27;&#x27;.x = \\{\\mathsf{C}&#x27;&#x27;,\\, [\\mathsf{C}&#x27;&#x27;_j]_{j \\in [k-1]}, [\\vec{x}&#x27;&#x27;_i]_{i \\in [k]}, y&#x27;&#x27;, E&#x27;&#x27;_{\\mathbb{G}}, e&#x27;&#x27;_{\\mathbb{F}} \\}</span>$</p>

    <p class="text-gray-300"><span class="math">D_{acc}(srs, acc.x, acc.w)</span> :</p>

    <p class="text-gray-300">&bull; Parse instance and witness as it follows:</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{l} - \\ \\{\\mathsf{C}, \\ (\\mathsf{C}_1, \\dots, \\mathsf{C}_{k-1}), \\ (\\vec{x}_1, \\dots, \\vec{x}_k, y), \\ E_{\\mathbb{G}}, e_{\\mathbb{F}}\\} \\leftarrow \\mathsf{acc}.x \\\\ - \\ \\{ [\\vec{\\mathsf{D}}_j = [\\mathsf{D}_{i,j}]_{i \\in [0,d]}]_{j=1}^{k-1}, \\ \\mathbf{T}_k \\} \\leftarrow \\mathsf{acc}.w \\end{array}</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set  <span class="math">C_0 \\leftarrow C</span></li>
      <li>For each  <span class="math">j \\in [1, k-1]</span>  check that</li>
    </ul>

    <p class="text-gray-300"><span class="math">$e(\\mathsf{C}_{j-1},\\mathsf{V}) - \\sum_{i=0}^d e(\\mathsf{D}_{i,j},\\mathsf{V}_{i,j}) = 0</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that  <span class="math">\\mathsf{Dec}_{\\mathbb{G}}([\\vec{x}_i]_{i=1}^k\\mathsf{C},[\\mathsf{C}_i]_{i=1}^{k-1},[\\vec{\\mathsf{D}_j}\\in\\mathbb{G}^d]_{j=1}^{k-1}) = \\sum_{j=1}^{k-1}(\\mathsf{C}_j-\\langle\\vec{x}_j,\\vec{\\mathsf{D}_j}\\rangle) = E_{\\mathbb{G}}</span></li>
      <li>Check that  <span class="math">\\langle \\mathbf{T}_k, \\mathbf{H}_k \\rangle = \\mathsf{C}_{k-1}</span></li>
      <li>Check that  <span class="math">\\mathsf{Dec}_{\\mathbb{F}}(\\vec{x}_k, \\mathbf{T}_k, y) = \\langle \\mathbf{T}_k, \\vec{x}_k \\rangle y = e_{\\mathbb{F}}</span></li>
    </ul>

    <p class="text-gray-300">Figure 14: KZH-k accumulation verifier and decider</p>

    <p class="text-gray-300"><strong>Theorem 6.</strong> KZH-k-fold is a secure accumulation scheme, also under the dlog-assumption in the algebraic group model.</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">Completeness. Consider the following two satisfying accumulator instances:</p>

    <p class="text-gray-300">&bull;
<span class="math">$acc.x = \\{C, C_1, \\dots, C_{k-1}, (\\vec{x}_1, \\dots, \\vec{x}_k, y), (E_{\\mathbb{G}}, e_{\\mathbb{F}})\\}</span>$</p>

    <p class="text-gray-300">&bull;
<span class="math">$acc.w = \\{\\{[D_{i,j}]_{j \\in [k-1], i \\in [0,d]}, T_k\\}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\bullet \\ \\operatorname{acc}&#x27;.x = \\{\\mathsf{C}&#x27;,\\mathsf{C}_1&#x27;,\\dots,\\mathsf{C}_{k-1}&#x27;,\\, (\\vec{x}_1&#x27;,\\dots,\\vec{x}_k&#x27;,y&#x27;),\\, (E_{\\mathbb{G}}&#x27;,e_{\\mathbb{F}}&#x27;)\\}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\bullet \\ \\operatorname{acc}&#x27;.w = \\{ \\{ [\\mathsf{D}&#x27;_{i,j}]_{j \\in [k-1], \\, i \\in [0,d]}, \\mathbf{T}&#x27;_k \\}</span>$</p>

    <p class="text-gray-300">It is straightforward to see that honest  <span class="math">\\mathsf{P}_{\\mathsf{acc}}</span>  and  <span class="math">\\mathsf{V}_{\\mathsf{acc}}</span>  output the same  <span class="math">\\mathsf{acc}&#x27;&#x27;.x</span>  as they follow the same instructions. Then it is left to see that on input  <span class="math">(\\mathsf{acc}&#x27;&#x27;.x, \\mathsf{acc}&#x27;&#x27;.w)</span>  computed by an honest prover,  <span class="math">\\mathsf{D}_{\\mathsf{acc}}</span>  always accepts. For each  <span class="math">j \\in [1, k-1]</span> :</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} e(\\mathsf{C}_{j-1}&#x27;&#x27;,\\mathsf{V}) &amp;= e\\left((1-\\alpha)\\times\\mathsf{C}_{j-1} + \\alpha\\times\\mathsf{C}_{j-1}&#x27;,\\mathsf{V}\\right) = (1-\\alpha)\\times e\\left(\\mathsf{C}_{j-1},\\mathsf{V}\\right) + \\alpha\\times e\\left(\\mathsf{C}_{j-1}&#x27;,\\mathsf{V}\\right) \\\\ &amp;= (1-\\alpha)\\times\\sum_{i=0}^d e\\left(\\mathsf{D}_{i,j},\\mathsf{V}_{i,j}\\right) + \\alpha\\times\\sum_{i=0}^d e\\left(\\mathsf{D}_{i,j}&#x27;,\\mathsf{V}_{i,j}\\right) \\\\ &amp;= \\sum_{i=0}^d e\\left((1-\\alpha)\\times\\mathsf{D}_{i,j} + \\alpha\\times\\mathsf{D}_{i,j}&#x27;,\\mathsf{V}_{i,j}\\right) \\\\ &amp;= \\sum_{i=0}^d e\\left(\\mathsf{D}_{i,j}&#x27;&#x27;,\\mathsf{V}_{i,j}\\right) \\end{split}</span>$</p>

    <p class="text-gray-300">so the first equation holds. For the second check, we have:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\operatorname{Dec}_{\\mathbb{G}}([\\vec{x}_i]_{i=1}^k, \\mathsf{C}&#x27;&#x27;, [\\mathsf{C}_i&#x27;&#x27;]_{i=1}^{k-1}, [\\vec{\\mathsf{D}}_j&#x27;&#x27;]_{j=1}^{k-1}) \\\\ &amp;= \\operatorname{Dec}_{\\mathbb{G}}([\\vec{x}_i]_{i=1}^k, (1-\\alpha) \\times \\mathsf{C} + \\alpha \\times \\mathsf{C}&#x27;, [(1-\\alpha) \\times \\mathsf{C}_i + \\alpha \\times \\mathsf{C}_i&#x27;]_{i=1}^{k-1}, [(1-\\alpha) \\times \\vec{\\mathsf{D}}_j + \\alpha \\times \\vec{\\mathsf{D}}_j&#x27;]_{j=1}^{k-1}) \\\\ &amp;= (1-\\alpha) \\times \\mathsf{E}_{\\mathbb{G}} + \\alpha \\times \\mathsf{E}_{\\mathbb{G}}&#x27; + (1-\\alpha)\\alpha \\times \\mathsf{Q} = \\mathsf{E}_{\\mathbb{G}}&#x27;&#x27; \\end{split}</span>$</p>

    <p class="text-gray-300">by construction of Q. The third equation verifies as</p>

    <p class="text-gray-300"><span class="math">$\\langle \\mathbf{T}_{k}&#x27;&#x27;, \\mathbf{H}_{k} \\rangle = \\langle (1 - \\alpha) \\times \\mathbf{T}_{k} + \\alpha \\times \\mathbf{T}_{k}&#x27;, \\mathbf{H}_{k} \\rangle = (1 - \\alpha) \\times \\langle \\mathbf{T}_{k}, \\mathbf{H}_{k} \\rangle + \\alpha \\times \\langle \\mathbf{T}_{k}&#x27;, \\mathbf{H}_{k} \\rangle</span>$
<span class="math">$= (1 - \\alpha) \\times \\mathsf{C}_{k-1} + \\alpha \\times \\mathsf{C}_{k-1}&#x27; = \\mathsf{C}_{k-1}&#x27;&#x27;.</span>$</p>

    <p class="text-gray-300">Finally, by definition of  <span class="math">e_{\\mathbb{F}}&#x27;&#x27;</span></p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\operatorname{Dec}_{\\mathbb{F}}(\\vec{x}_k&#x27;&#x27;, \\mathbf{T}_k&#x27;&#x27;, y&#x27;&#x27;) &amp;= \\langle \\mathbf{T}_k&#x27;&#x27;, \\vec{x}_k&#x27;&#x27; \\rangle - y&#x27;&#x27; \\\\ &amp;= \\langle (1 - \\alpha)e_{\\mathbb{F}} + \\alpha e_{\\mathbb{F}}&#x27; + (1 - \\alpha) + (1 - \\alpha)\\alpha q \\\\ &amp;= e_{\\mathbb{F}}&#x27;&#x27;, \\end{aligned}</span>$</p>

    <p class="text-gray-300">and  <span class="math">D_{\\mathsf{acc}}</span>  outputs 1, concluding the proof of completeness.</p>

    <p class="text-gray-300"><strong>Knowledge soundness.</strong> Consider an adversary  <span class="math">\\mathcal{A}</span>  that outputs  <span class="math">\\hat{\\pi} = (\\pi.x, \\pi.w)</span> ,  <span class="math">\\mathsf{acc}&#x27;&#x27; = (\\mathsf{acc}&#x27;&#x27;.x, \\mathsf{acc}&#x27;&#x27;.w)</span> ,  <span class="math">\\mathsf{pf} \\in \\mathbb{G}_1 \\times \\mathbb{F}</span>  and  <span class="math">\\mathsf{acc}.x, \\mathsf{acc}&#x27;.x</span> . We build an extractor  <span class="math">\\mathsf{Ext}_{\\mathsf{acc}}</span>  such that if  <span class="math">\\mathsf{V}_{\\mathsf{acc}}</span>  and  <span class="math">\\mathsf{D}_{\\mathsf{acc}}</span>  accept, extracts valid witnesses  <span class="math">\\mathsf{acc}.w, \\mathsf{acc}&#x27;.w</span>  for  <span class="math">\\mathsf{acc}.x, \\mathsf{acc}&#x27;.x</span> . Since  <span class="math">\\mathsf{acc}&#x27;&#x27;.w</span>  is an equation of degree one, given two accepting transcripts for different challenges  <span class="math">\\alpha_1, \\alpha_2</span> ,  <span class="math">\\mathsf{Ext}_{\\mathsf{acc}}</span>  can use the Vandermonde matrix to extract</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{acc}.w = \\{\\{[\\mathsf{D}_{i,j}]_{j \\in [k-1],\\, i \\in [0,d]},\\, \\mathbf{T}_k\\}, \\quad \\mathsf{acc}&#x27;.w = \\{\\{[\\mathsf{D}_{i,j}&#x27;]_{j \\in [k-1],\\, i \\in [0,d]}, \\mathbf{T}_k&#x27;\\}.</span>$</p>

    <p class="text-gray-300">Since  <span class="math">\\mathsf{D}_{\\mathsf{acc}}(\\mathsf{acc&#x27;&#x27;}.x,\\mathsf{acc&#x27;&#x27;}.w)</span>  accepts, we have the first check passes, i.e.,</p>

    <p class="text-gray-300"><span class="math">$e(\\mathsf{C}_{j-1}&#x27;&#x27;,\\mathsf{V}) = \\sum_{i=0}^d e\\left(\\mathsf{D}_{i,j}&#x27;&#x27;,\\mathsf{V}_{i,j}\\right).</span>$</p>

    <p class="text-gray-300">We analyze each side of the equation independently:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} e(\\mathsf{C}_{j-1}&#x27;&#x27;,\\mathsf{V}) &amp;= e\\left((1-\\alpha)\\times\\mathsf{C}_{j-1} + \\alpha\\times\\mathsf{C}_{j-1}&#x27;,\\mathsf{V}\\right) \\\\ &amp;= (1-\\alpha)\\times e\\left(\\mathsf{C}_{j-1},\\mathsf{V}\\right) + \\alpha\\times e\\left(\\mathsf{C}_{j-1}&#x27;,\\mathsf{V}\\right) \\end{split}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\sum_{i=0}^{d} e\\left(\\mathsf{D}_{i,j}^{\\prime\\prime}, \\mathsf{V}_{i,j}\\right) &amp;= \\sum_{i=0}^{d} e\\left((1-\\alpha) \\times \\mathsf{D}_{i,j} + \\alpha \\times \\mathsf{D}_{i,j}^{\\prime}, \\mathsf{V}_{i,j}\\right) \\\\ &amp;= (1-\\alpha) \\times \\sum_{i=0}^{d} e\\left(\\mathsf{D}_{i,j}, \\mathsf{V}_{i,j}\\right) + \\alpha \\times \\sum_{i=0}^{d} e\\left(\\mathsf{D}_{i,j}^{\\prime}, \\mathsf{V}_{i,j}^{\\prime}\\right) \\end{split}</span>$</p>

    <p class="text-gray-300">Since  <span class="math">\\alpha</span>  is computed as a hash of acc.x and acc'.x, except with negligible probability  <span class="math">e\\left(\\mathsf{C}_{j-1},\\mathsf{V}\\right) - \\sum_{i=0}^{d} e\\left(\\mathsf{D}_{i,j},\\mathsf{V}_{i,j}\\right) = 0</span>  and  <span class="math">e\\left(\\mathsf{C}_{j-1}&#x27;,\\mathsf{V}\\right) - \\sum_{i=0}^{d} e\\left(\\mathsf{D}_{i,j}&#x27;,\\mathsf{V}_{i,j}&#x27;\\right) = 0</span> . Similarly, replacing the accumulation witness by the extracted ones, we have that Eq.(ii)'s left side is</p>

    <p class="text-gray-300"><span class="math">$\\sum_{j=1}^{k-1} (\\mathsf{C}&#x27;&#x27;_j - \\langle \\vec{x}&#x27;&#x27;_j, \\vec{\\mathsf{D}}&#x27;&#x27;_j \\rangle) = \\sum_{j=1}^{k-1} ((1-\\alpha)\\mathsf{C}_j + \\alpha\\mathsf{C}&#x27;_k - \\langle (1-\\alpha)\\vec{x}_j + \\alpha\\vec{x}&#x27;_j, (1-\\alpha)\\vec{\\mathsf{D}}_j + \\alpha\\vec{\\mathsf{D}}&#x27;_j \\rangle)</span>$</p>

    <p class="text-gray-300">whereas from the verifier's output we have that the right side equals  <span class="math">(1-\\alpha) \\times \\mathsf{E}_{\\mathbb{G}} + \\alpha \\times \\mathsf{E}&#x27;_{\\mathbb{G}} + (1-\\alpha) \\cdot \\alpha \\times \\mathsf{Q}</span> . Because  <span class="math">\\alpha</span>  is computed as a hash of  <span class="math">\\mathsf{acc}.x</span>  and  <span class="math">\\mathsf{acc}&#x27;.x</span>  we have that except with negligible probability the equation hold for any X and, in particular, when X=1 we got  <span class="math">\\sum_{j=1}^{k-1} \\mathsf{C}_j - \\langle \\vec{x}_j, \\vec{\\mathsf{D}}_j \\rangle = \\mathsf{E}_{\\mathbb{G}}</span>  and for X=0,  <span class="math">\\sum_{j=1}^{k-1} \\mathsf{C}&#x27;_j - \\langle \\vec{x}&#x27;_j, \\vec{\\mathsf{D}}&#x27;_j \\rangle = \\mathsf{E}&#x27;_{\\mathbb{G}}</span> . With identical reasoning, we have that  <span class="math">\\langle \\mathbf{T}_k, \\vec{x}_k \\rangle - y = e_{\\mathbb{F}}</span>  and  <span class="math">\\langle \\mathbf{T}&#x27;_k, \\vec{x}&#x27;_k \\rangle - y&#x27; = e&#x27;_{\\mathbb{F}}</span> . Finally,</p>

    <p class="text-gray-300"><span class="math">$\\langle \\mathbf{T}_k&#x27;&#x27;, \\mathbf{H}_k \\rangle = \\langle (1 - \\alpha)\\mathbf{T}_k + \\alpha\\mathbf{T}_k, \\mathbf{H}_k \\rangle = (1 - \\alpha)\\langle \\mathbf{T}_k, \\mathbf{H}_k \\rangle + \\alpha\\langle \\mathbf{T}_k&#x27;, \\mathbf{H}_k \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{C}_{k-1}&#x27;&#x27; = (1-\\alpha)\\mathsf{C}_{k-1} + \\alpha\\mathsf{C}_{k-1}&#x27;</span>$</p>

    <p class="text-gray-300">which, as above, implies  <span class="math">C_{k-1} = \\langle \\mathbf{T}_k, \\mathbf{H}_k \\rangle</span> , and  <span class="math">C&#x27;_{k-1} = \\langle \\mathbf{T}&#x27;_k, \\mathbf{H}&#x27;_k \\rangle</span>  except with negligible probability. We conclude the extracted acc. w and acc'. w are valid witnesses. We now</p>

    <p class="text-gray-300">prove that if  <span class="math">\\mathsf{E}_\\mathbb{G} = e_\\mathbb{F} = 0</span> , we can extract a valid opening to  <span class="math">\\vec{c}</span> . That is,  <span class="math">(\\mathsf{acc}.x, \\mathsf{acc}.w)</span>  is a valid pair for the predicate  <span class="math">\\Phi</span> . Note that the first check by the decider is the same as  <span class="math">\\mathsf{KZH}&#x27;s</span>  verifier first check. Following above, from the second check we can extract that  <span class="math">\\sum_{j=1}^{k-1} \\mathsf{C}_j - \\langle \\vec{x}_j, \\mathsf{D}_j \\rangle = \\mathsf{E}_\\mathbb{G} = 0</span> . Since  <span class="math">\\mathsf{D}_j</span>  is base  <span class="math">\\mathsf{H}_j</span> , we have that  <span class="math">\\mathsf{C}_j - \\langle \\vec{x}_j, \\mathsf{D}_j \\rangle = 0</span>  for all  <span class="math">j \\in [k]</span> . Finally, the last check is  <span class="math">\\langle \\mathsf{T}_k, \\vec{x}_k \\rangle = y</span> , and we have extracted satisfying  <span class="math">\\mathsf{KZH}</span>  verifier checks, and thus can extract  <span class="math">p(\\vec{X}_1, \\ldots, \\vec{X}_k)</span>  such that  <span class="math">p(\\vec{x}_1, \\ldots, \\vec{x}_k) = y</span> .</p>

    <p class="text-gray-300">Background. Non-uniform IVC (N-IVC) <a href="#page-41-12">[KS22]</a> extends the definition of IVC by allowing each step to execute one of several predefined instructions F1, F2, . . . , F<sup>k</sup> instead of a single instruction F. Previously, non-uniform IVC was implemented using a universal circuit that contains subcircuits for all instructions F<sup>i</sup> . This circuit evaluates all subcircuits and selects the correct output based on the program counter. However, this approach is inefficient because the prover must perform computations for every instruction, even though only one instruction is needed at each step, and the witness size of the universal circuit scales linearly with the sum of the witness sizes of all instructions, making it non-ideal both computation-wise and memory-wise. Non-uniform PCD (N-PCD) <a href="#page-42-0">[Zhe+23]</a> is a similar work which extends the definition of PCD to support multiple instructions in the leaves instead of a single instruction.</p>

    <p class="text-gray-300">Previous work on non-uniform IVC. SuperNova <a href="#page-41-12">[KS22]</a> introduced a more efficient method for N-IVC where the step circuit maintains a running accumulator U<sup>i</sup> (a relaxed committed R1CS instance) for each instruction F<sup>i</sup> . When receiving a new, fresh accumulator instance u<sup>i</sup> , the prover uses memory techniques (e.g. a Merkle tree or offline memory techniques <a href="#page-43-11">[Blu+91]</a>) to select the appropriate running accumulator U<sup>i</sup> . Next, the prover accumulates U<sup>i</sup> with u<sup>i</sup> . This approach ensures the computational effort corresponds only to the selected instruction, but the witness size grows linearly with the sum of the witness sizes for all instructions F<sup>i</sup> .</p>

    <p class="text-gray-300">Protostar <a href="#page-39-9">[BC23]</a> offers a similar improvement to construct N-IVC, leveraging the fact that committing to zeros with Pederson commitment incurs no additional cost. While it also reduces computational overhead, like SuperNova, it still requires the prover to manage a witness size that scales linearly with the sum of all instruction witnesses. Another drawback, Protostar's approach, unlike SuperNova, is dependent on Pederson being homomorphic and may not be compatible with hash-based polynomial commitment schemes.</p>

    <p class="text-gray-300">N-IVC and N-PCD from PA. We observe that polynomial accumulation offers more flexibility than circuit-specific accumulation. For example, each polynomial of degree d &lt; D, can be seen as a polynomial of degree D by simply assuming the coefficients of x <sup>d</sup>+1, xd+2, . . . , x<sup>D</sup> are zero. As a result, given an accumulation scheme for a polynomial of degree D, different polynomials of degree d<sup>i</sup> &lt; D can be accumulated by considering them as degree D. Supernova directly translates each circuit as an R1CS instance and since two different R1CS instances cannot be accumulated, the prover must keep one running accumulator for each instruction F<sup>i</sup> . However, similar to IVC from Spartan+PA in Section <a href="#page-24-0">5,</a> we leverage Spartan PIOP to translate each instruction F<sup>i</sup> as polynomials. Recalling Section <a href="#page-24-1">5.1,</a> to accumulate circuit F<sup>i</sup> , we need to accumulate polynomial &omega;i(&middot;) corresponding to the R1CS witness and matrix evaluations of A<sup>i</sup> , B<sup>i</sup> and C<sup>i</sup> , corresponding to the R1CS construction of F<sup>i</sup> . Similar to Section <a href="#page-24-0">5,</a> we take two different strategies to handle the accumulation of witness polynomial &omega;i(&middot;) and matrices evaluations. For each F<sup>i</sup> , assume its witness polynomial is of degree d<sup>i</sup> . We consider a running polynomial of degree d<sup>i</sup> &lt; D, and in each step accumulate &omega;i(&middot;) with this running PCS accumulator. However, the same strategy cannot be applied to matrix evaluations. Accumulating different A<sup>i</sup> , B<sup>i</sup> , and C<sup>i</sup> evaluations via PCS accumulation is impractical because the resulting accumulated matrices may not be sparse. This would lead to matrices with O(kn) non-zero elements instead of O(n), where k is the number of instructions. To address this, we adopt an approach similar to SuperNova's to handle matrix evaluations efficiently. To elaborate further, the prover maintains a separate running accumulator for each matrix evaluation. Using memory techniques, the prover dynamically selects the appropriate running accumulator at each step and updates it with fresh matrix evaluations. Notably, these matrix evaluations scale logarithmically with the size of the original circuit, which is a key factor in the efficiency of our N-IVC and N-PCD schemes compared to SuperNova.</p>

    <p class="text-gray-300">Our N-PCD approach, apart from witness size and decider time, also improves the prover's time. As previously mentioned in Section <a href="#page-27-0">5.3,</a> both SuperNova and Protostar approaches fail to work for N-PCD since accumulating two sets of running accumulators takes linear time in the combined size of all instructions. However, this is not the case for us, a running accumulator in our N-PCD approach based on Spartan+PA, similar to N-IVC, consists of a single PCS accumulator and k instances of the matrix evaluation accumulator, i.e. one per instruction. Accumulating two running accumulators requires accumulating the two corresponding PCS accumulators, plus accumulating each instance of the matrix evaluation accumulator with its corresponding instance. The initial task requires Pacc(max<sup>i</sup> |F<sup>i</sup> |) computation and the latter takes P i log |F<sup>i</sup> |. To conclude, each step of our N-PCD prover costs Pacc(max<sup>i</sup> |F<sup>i</sup> |) + P i log |F<sup>i</sup> |. For example, when instantiated with a linear prover time accumulator such as KZH-fold, the prover time is max<sup>i</sup> |F<sup>i</sup> | + P i log |F<sup>i</sup> |, which is much smaller than P i |F<sup>i</sup> | compared to the previous approaches of building N-PCD. The decider algorithm for both N-IVC and N-PCD requires running the decider algorithm for the PCS accumulator, plus evaluating all polynomial extensions of A, B and C matrices. The former requires running Dacc on a polynomial of degree max<sup>i</sup> |F<sup>i</sup> | and the latter requires O( P i |F<sup>i</sup> |) field operations. Given that field operations are much less expensive than group operations, we expect the cost of the decider to be dominated by Dacc and hence our scheme has a much faster decider time than SuperNova and Protostar, which requires a linear number of scalar multiplications in the combined size of all circuits. We leave formalization and proofs to future work.</p>

`;
---

<BaseLayout title="KZH-Fold: Accountable Voting from Sublinear Accumulation (2025/144)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2025 &middot; eprint 2025/144
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">KZH multilinear polynomial commitment scheme</a></li>
            <li><a href="#sec-1.2" class="hover:text-white">Sublinear accumulation schemes</a></li>
            <li><a href="#sec-1.3" class="hover:text-white">Signature aggregation in consensus</a></li>
            <li><a href="#sec-1.4" class="hover:text-white">Contributions</a></li>
            <li><a href="#sec-1.5" class="hover:text-white">Additional related work</a></li>
          </ol>
        </li>
        <li><a href="#sec-2" class="hover:text-white">Technical Overview</a></li>
        <li>
          <a href="#sec-3" class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">Notation</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Polynomial commitment schemes</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">Accumulators</a></li>
            <li><a href="#sec-3.4" class="hover:text-white">Incrementally verifiable computation</a></li>
            <li><a href="#sec-3.5" class="hover:text-white">IVC from accumulators</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">KZH: An efficiently aggregatable polynomial commitment</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">KZH-fold: Accumulator with sublinear size</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">PIOP+PA: IVC/PCD from Polynomial Accumulation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">PIOP Accumulation: accumulating Spartan PIOP</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">Uniform IVC/PCD from polynomial accumulation</a></li>
            <li><a href="#sec-5.3" class="hover:text-white">N-IVC and N-PCD from polynomial accumulation</a></li>
          </ol>
        </li>
        <li><a href="#sec-6" class="hover:text-white">PIOP for signature aggregation protocol</a></li>
        <li>
          <a href="#sec-7" class="hover:text-white">Implementation and efficiency</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-7.1" class="hover:text-white">Efficiency of KZH</a></li>
            <li><a href="#sec-7.2" class="hover:text-white">Comparison with Halo Infinite</a></li>
            <li><a href="#sec-7.3" class="hover:text-white">Comparison with Nova</a></li>
            <li><a href="#sec-7.4" class="hover:text-white">Comparison with BLS aggregation</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a" class="hover:text-white">Deferred definitions</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-a.1" class="hover:text-white">Signature schemes</a></li>
          </ol>
        </li>
        <li>
          <a href="#app-b" class="hover:text-white">Deferred proofs</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-b.1" class="hover:text-white">Proof of theorem 3</a></li>
            <li><a href="#app-b.2" class="hover:text-white">Proof of theorem 4</a></li>
          </ol>
        </li>
        <li>
          <a href="#app-c" class="hover:text-white">Higher dimension PCS for smaller deciders</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-c.1" class="hover:text-white">KZH-k</a></li>
            <li><a href="#app-c.2" class="hover:text-white">KZH-k accumulation</a></li>
          </ol>
        </li>
        <li><a href="#app-d" class="hover:text-white">Non-Uniformity from Polynomial Accumulation</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#acknowledgements" class="hover:text-white">Acknowledgements</a></li>
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="kzh-fold-2025" />
  </article>
</BaseLayout>
