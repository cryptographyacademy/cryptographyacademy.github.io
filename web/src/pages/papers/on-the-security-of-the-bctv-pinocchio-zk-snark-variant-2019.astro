---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/119';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'On the security of the BCTV Pinocchio zk-SNARK variant';
const AUTHORS_HTML = 'Ariel Gabizon';

const CONTENT = `    <p class="text-gray-300">Ariel Gabizon</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">The main result of this note is a severe flaw in the description of the zk-SNARK in <em>[x1]</em>. The flaw stems from including redundant elements in the CRS, as compared to that of the original Pinocchio protocol <em>[x21]</em>, which are vital not to expose. The flaw enables creating a proof of knowledge for <em>any</em> public input given a valid proof for <em>some</em> public input. We also provide a proof of security for the <em>[x1]</em> zk-SNARK in the generic group model, when these elements are excluded from the CRS, provided a certain linear algebraic condition is satisfied by the QAP polynomials.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Parno et. al <em>[x21]</em> presented a zk-SNARK construction based on the breakthrough work of <em>[x12]</em> that they called Pinocchio. Ben-Sasson et. al <em>[x1]</em> presented a variant of Pinocchio with the advantage of shorter verification time and verification key length, at the expense of an arguably negligible increase in prover running time. However, <em>[x1]</em> did not present a security proof for this variant, and in fact Parno <em>[x22]</em> found an attack against the <em>[x1]</em> SNARK and suggested to mitigate it by imposing a certain linear independence condition on some of the public input polynomials – which <em>[x1]</em> did in a revised version of the paper and corresponding implementation <em>[x18]</em>. In this note, we show a more severe attack on <em>[x1]</em> that takes advantage of redundant elements in the proving key that should have been omitted.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Impacted work</h3>

    <p class="text-gray-300">The first proof of security for <em>[x1]</em> was given in <em>[x6]</em>. However, the proof has an error and in fact we discovered the attack while reviewing it. Other papers that leverage the <em>[x1]</em> construction inherit the flaw also; the ones we found are <em>[x3, x17]</em>.</p>

    <p class="text-gray-300">The (libsnark <em>[x18]</em>) implementation of the <em>[x1]</em> prover distributed alongside the paper expects that the elements of concern are removed from the CRS, apparently intended as one of several optimizations that deviated from the construction as described in the paper. (The elements are not used by the prover.) As a result, parameters constructed directly by libsnark are not vulnerable to this specific attack.</p>

    <p class="text-gray-300">However, the multi-party computation of <em>[x6]</em> follows the construction described in <em>[x1]</em> closely and so the elements are produced during the protocol’s execution, though they do not appear in the final parameters in order to be compatible with the libsnark prover. Unfortunately,</p>

    <p class="text-gray-300">the transcript of the protocol's execution must be distributed so that the resulting parameters can be verified, and so the elements are revealed.</p>

    <p class="text-gray-300">We also discovered an independent implementation of [BCTV14] which appears to inherit the flaw [sna], as unlike <code>libsnark</code> its key generation and proving routines match the paper closely.</p>

    <p class="text-gray-300">Lastly, we emphasize that the mitigation of Parno [Par15] for the attack presented there, does not mitigate the attack presented here.</p>

    <h2 id="sec-5" class="text-2xl font-bold">1.2 Notation</h2>

    <p class="text-gray-300">We will be working over bilinear groups  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">\\mathbb{G}_2</span> , and  <span class="math">\\mathbb{G}_t</span>  each of prime order  <span class="math">p</span> , together with respective generators  <span class="math">g_1</span> ,  <span class="math">g_2</span>  and  <span class="math">g_T</span> . These groups are equipped with a non-degenerate bilinear pairing  <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_t</span> , with  <span class="math">e(g_1, g_2) = g_T</span> . We write  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  additively, and  <span class="math">\\mathbb{G}_t</span>  multiplicatively. We denote by  <span class="math">\\mathbb{F}</span>  the field of the same order  <span class="math">p</span> . For  <span class="math">a \\in \\mathbb{F}</span> , we denote  <span class="math">[a]_1 := a \\cdot g_1, [a]_2 := a \\cdot g_2</span> .</p>

    <h2 id="sec-6" class="text-2xl font-bold">1.3 Description of [BCTV14] SNARK</h2>

    <p class="text-gray-300">We recall the zk-SNARK of [BCTV14] as described in that paper. We assume familiarity with quadratic arithmetic programs. See e.g., Section 2.3 in [Gro16] for definitions. We use similar notation to [BCTV14], denoting by  <span class="math">m</span>  the size of the QAP,  <span class="math">d</span>  the degree and  <span class="math">n</span>  the number of public inputs. More specifically, our QAP has the form  <span class="math">\\left\\{\\{A_i(X), B_i(X), C_i(X)\\}_{i \\in [0..m]}, Z(X)\\right\\}</span>  where  <span class="math">A_i, B_i, C_i \\in \\mathbb{F}[X]</span>  have degree at most  <span class="math">d</span> , and  <span class="math">Z \\in \\mathbb{F}[X]</span>  has degree exactly  <span class="math">d</span> .</p>

    <p class="text-gray-300">We proceed to describe the proving system of [BCTV14]. We assume we are already given a description of the groups  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_t</span> , the pairing  <span class="math">e</span> , and uniformly chosen generators  <span class="math">g_1 \\in \\mathbb{G}_1, g_2 \\in \\mathbb{G}_2</span> , and these are all public.</p>

    <h2 id="sec-7" class="text-2xl font-bold">BCTV key generation:</h2>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample random  <span class="math">\\tau, \\rho_A, \\rho_B, \\alpha_A, \\alpha_B, \\alpha_C, \\gamma, \\beta \\in \\mathbb{F}^*</span></li>

      <li>For  <span class="math">i\\in [0..d]</span>  output  <span class="math">\\mathsf{pk}_{H,i}\\coloneqq \\left[\\tau^i\\right]_1</span></li>

      <li>For  <span class="math">i\\in [0..m]</span>  output</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">\\mathsf{pk}_{A,i} := [\\rho_A A_i(\\tau)]_1</span> (b)  <span class="math">\\mathsf{pk}_{A,i}^{\\prime} := [\\alpha_{A}\\rho_{A}A_{i}(\\tau)]_{1},</span> (c)  <span class="math">\\mathsf{pk}_{B,i} := [\\rho_B B_i(\\tau)]_2,</span> (d)  <span class="math">\\mathsf{pk}_{B,i}^{\\prime} := [\\alpha_{B}\\rho_{B}B_{i}(\\tau)]_{1},</span> (e)  <span class="math">\\mathsf{pk}_{C,i} := [\\rho_A\\rho_B C_i(\\tau)]_1,</span> (f)  <span class="math">\\mathsf{pk}_{C,i}^{\\prime} := [\\alpha_{C}\\rho_{A}\\rho_{B}C_{i}(\\tau)]_{1}</span> (g)  <span class="math">\\mathsf{pk}_{K,i} := [\\beta (\\rho_A A_i(\\tau) + \\rho_B B_i(\\tau) + \\rho_A\\rho_B C_i(\\tau))]_1</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the additional verification key elements  <span class="math">([\\alpha_A]_2, [\\alpha_B]_1, [\\alpha_C]_2, [\\gamma]_2, [\\beta\\gamma]_1, [\\beta\\gamma]_2, [\\rho_A\\rho_BZ(\\tau)]_2)</span></li>

    </ol>

    <p class="text-gray-300">BCTV prover:</p>

    <p class="text-gray-300">The prover <span class="math">\\mathsf{P}</span> has in his hand a QAP solution <span class="math">(x_0 = 1, x_1, \\ldots, x_m)</span> that coincides with the public input <span class="math">x = (x_1, \\ldots, x_n)</span> and satisfies the following: If we define <span class="math">A := \\sum_{i=0}^{m} x_i \\cdot A_i</span>, <span class="math">B := \\sum_{i=0}^{m} x_i \\cdot B_i</span>, and <span class="math">C := \\sum_{i=0}^{m} x_i \\cdot C_i</span>; then the polynomial <span class="math">P := A \\cdot B - C</span> will be divisible by the target polynomial <span class="math">Z</span>, and <span class="math">\\mathsf{P}</span> can compute the polynomial <span class="math">H</span> of degree at most <span class="math">d</span> with <span class="math">P = H \\cdot Z</span>. Let <span class="math">A_{\\mathrm{mid}} := A - \\sum_{i=0}^{n} x_i \\cdot A_i</span>.</p>

    <p class="text-gray-300">Given the proving key, <span class="math">\\mathsf{P}</span> computes as linear combinations of the proving key elements</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi_A := [\\rho_A A_{\\mathrm{mid}}(\\tau)]_1</span>, <span class="math">\\pi_A&#x27; := [\\alpha_A \\rho_A A_{\\mathrm{mid}}(\\tau)]_1</span>.</li>

      <li><span class="math">\\pi_B := [\\rho_B B(\\tau)]_2</span>, <span class="math">\\pi_B&#x27; := [\\alpha_B \\rho_B B(\\tau)]_1</span>.</li>

      <li><span class="math">\\pi_C := [\\rho_A \\rho_B C(\\tau)]_1</span>, <span class="math">\\pi_C&#x27; := [\\alpha_C \\rho_A \\rho_B C(\\tau)]_1</span>.</li>

      <li><span class="math">\\pi_K := [\\beta (\\rho_A A(\\tau) + \\rho_B B(\\tau) + \\rho_A \\rho_B C(\\tau))]_1</span>.</li>

      <li><span class="math">\\pi_H := [H(\\tau)]_1</span>.</li>

    </ol>

    <p class="text-gray-300">and outputs <span class="math">\\pi = (\\pi_A, \\pi_B, \\pi_C, \\pi_A&#x27;, \\pi_B&#x27;, \\pi_C&#x27;, \\pi_H, \\pi_K)</span></p>

    <p class="text-gray-300">BCTV verifier:</p>

    <p class="text-gray-300">Denote the "public input component"</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{PI}(x) := \\mathsf{pk}_{A,0} + \\sum_{i=1}^{n} x_i \\mathsf{pk}_{A,i} = \\left[ \\rho_A A_0(\\tau) + \\sum_{i=1}^{n} x_i \\rho_A A_i(\\tau) \\right]_1</span></div>

    <p class="text-gray-300">The verifier, using pairings and the verification key, checks the following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">e(\\pi_A&#x27;, g_2) = e(\\pi_A, [\\alpha_A]_2)</span>.</li>

      <li><span class="math">e(\\pi_B&#x27;, g_2) = e([\\alpha_B]_1, \\pi_B)</span>.</li>

      <li><span class="math">e(\\pi_C&#x27;, g_2) = e(\\pi_C, [\\alpha_C]_2)</span>.</li>

      <li><span class="math">e(\\pi_K, [\\gamma]_2) = e(\\mathsf{PI}(x) + \\pi_A + \\pi_C, [\\beta\\gamma]_2) \\cdot e([\\beta\\gamma]_1, \\pi_B)</span>.</li>

      <li><span class="math">e(\\mathsf{PI}(x) + \\pi_A, \\pi_B) = e(\\pi_C, g_2) \\cdot e(\\pi_H, [Z(\\tau) \\rho_A \\rho_B]_2)</span>.</li>

    </ol>

    <p class="text-gray-300">2 Attack Description</p>

    <p class="text-gray-300">Note that the elements <span class="math">\\{\\mathsf{pk}_{A,i}&#x27;\\}_{i\\in [0..n]}</span> are not used at all by the verifier and honest prover, and thus could have been omitted from the key. We show that these elements allow a malicious prover to replace the public input arbitrarily when starting from a valid proof. Loosely speaking, we do this by adding a factor to <span class="math">\\pi_A</span> that "switches" the public input the proof is arguing about. The first verifier check - the "knowledge check" for <span class="math">\\pi_A</span> - should catch this, but the redundant elements allow the malicious prover to add the analogous factor to <span class="math">\\pi_A&#x27;</span> and pass the check. Details follow.</p>

    <p class="text-gray-300">Suppose we are given a valid proof <span class="math">\\pi = (\\pi_A, \\pi_B, \\pi_C, \\pi_A&#x27;, \\pi_B&#x27;, \\pi_C&#x27;, \\pi_H, \\pi_K)</span> for a public input <span class="math">x = (x_1, \\ldots, x_n) \\in \\mathbb{F}^n</span>. Choose any <span class="math">x&#x27; = (x_1&#x27;, \\ldots, x_n&#x27;) \\in \\mathbb{F}^n</span>.</p>

    <p class="text-gray-300">3</p>

    <p class="text-gray-300">Set</p>

    <p class="text-gray-300"><span class="math">\\eta_{A}:=\\pi_{A}+\\sum_{i=1}^{n}(x_{i}-x_{i}^{\\prime})\\mathsf{pk}_{A,i}</span></p>

    <p class="text-gray-300"><span class="math">\\eta_{A}^{\\prime}:=\\pi_{A}^{\\prime}+\\sum_{i=1}^{n}(x_{i}-x_{i}^{\\prime})\\mathsf{pk}_{A,i}^{\\prime}</span></p>

    <p class="text-gray-300">We claim that <span class="math">\\pi^{<em>}:=(\\eta_{A},\\pi_{B},\\pi_{C},\\eta_{A}^{\\prime},\\pi_{B}^{\\prime},\\pi_{C}^{\\prime},\\pi_{K},\\pi_{H})</span> is a valid proof for public input <span class="math">x^{\\prime}</span>. The verifier checks with public input <span class="math">x^{\\prime}</span> and proof <span class="math">\\pi^{</em>}</span> are</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">e(\\eta_{A}^{\\prime},g_{2})=e(\\eta_{A},[\\alpha_{A}]_{2})</span>.</li>

      <li><span class="math">e(\\pi_{B}^{\\prime},g_{2})=e([\\alpha_{B}]_{1}\\,,\\pi_{B})</span>.</li>

      <li><span class="math">e(\\pi_{C}^{\\prime},g_{2})=e(\\pi_{C},[\\alpha_{C}]_{2})</span>.</li>

      <li><span class="math">e(\\pi_{K},[\\gamma]_{2})=e(\\mathsf{PI}(x^{\\prime})+\\eta_{A}+\\pi_{C},[\\beta\\gamma]_{2})\\cdot e([\\beta\\gamma]_{1}\\,,\\pi_{B})</span>.</li>

      <li><span class="math">e(\\mathsf{PI}(x^{\\prime})+\\eta_{A},\\pi_{B})=e(\\pi_{C},g_{2})\\cdot e(\\pi_{H},[Z(\\tau)\\rho_{A}\\rho_{B}]_{2})</span>.</li>

    </ol>

    <p class="text-gray-300">We show that the five equations all hold.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The check <span class="math">e(\\eta_{A}^{\\prime},g_{2})=e(\\eta_{A},[\\alpha_{A}]_{2})</span>; this is where the redundant elements crucially come into play.</li>

    </ol>

    <p class="text-gray-300">We have</p>

    <p class="text-gray-300"><span class="math">\\eta_{A}^{\\prime}=\\pi_{A}^{\\prime}+\\sum_{i=1}^{n}(x_{i}-x_{i}^{\\prime})\\mathsf{pk}_{A,i}^{\\prime}</span></p>

    <p class="text-gray-300">So</p>

    <p class="text-gray-300"><span class="math">e(\\eta_{A}^{\\prime},g_{2})=e(\\pi_{A}^{\\prime},g_{2})\\cdot e\\left(\\sum_{i=1}^{n}(x_{i}-x_{i}^{\\prime})\\mathsf{pk}_{A,i}^{\\prime},g_{2}\\right)</span></p>

    <p class="text-gray-300">Since <span class="math">\\pi</span> is a valid proof, this is:</p>

    <p class="text-gray-300"><span class="math">=e(\\pi_{A},[\\alpha_{A}]_{2})\\cdot e\\left(\\sum_{i=1}^{n}(x_{i}-x_{i}^{\\prime})\\mathsf{pk}_{A,i}^{\\prime},g_{2}\\right)</span></p>

    <p class="text-gray-300">Using <span class="math">\\mathsf{pk}_{A,i}^{\\prime}=\\alpha_{A}\\cdot\\mathsf{pk}_{A,i}</span> for every <span class="math">i</span>,</p>

    <p class="text-gray-300"><span class="math">=e(\\pi_{A},[\\alpha_{A}]_{2})\\cdot e\\left(\\alpha_{A}\\cdot\\left(\\sum_{i=1}^{n}(x_{i}-x_{i}^{\\prime})\\mathsf{pk}_{A,i}\\right),g_{2}\\right)</span></p>

    <p class="text-gray-300">Using bi-linearity of the pairing:</p>

    <p class="text-gray-300"><span class="math">=e(\\pi_{A},[\\alpha_{A}]_{2})\\cdot e\\left(\\sum_{i=1}^{n}(x_{i}-x_{i}^{\\prime})\\mathsf{pk}_{A,i},[\\alpha_{A}]_{2}\\right)</span></p>

    <p class="text-gray-300"><span class="math">=e\\left(\\pi_{A}+\\sum_{i=1}^{n}(x_{i}-x_{i}^{\\prime})\\mathsf{pk}_{A,i},[\\alpha_{A}]_{2}\\right)=e(\\eta_{A},[\\alpha_{A}]_{2}).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The second and third checks involve the unchanged <span class="math">\\pi_B, \\pi_B&#x27;, \\pi_C, \\pi_C&#x27;</span> and thus pass since <span class="math">\\pi</span> was valid.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The fourth and fifth equations are also identical in <span class="math">\\pi</span> and <span class="math">\\pi^*</span>. The only difference is that the latter replaces the term <span class="math">\\mathsf{PI}(x) + \\pi_A</span> with <span class="math">\\mathsf{PI}(x&#x27;) + \\eta_A</span>. And</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{PI}(x) + \\pi_A = \\mathsf{pk}_{A,0} + \\sum_{i=1}^{n} x_i \\mathsf{pk}_{A,i} + \\pi_A = \\mathsf{pk}_{A,0} + \\sum_{i=1}^{n} x_i&#x27; \\mathsf{pk}_{A,i} + \\sum_{i=1}^{n} (x_i - x_i&#x27;) \\mathsf{pk}_{A,i} + \\pi_A = \\mathsf{PI}(x&#x27;) + \\eta_A.</span></div>

    <p class="text-gray-300">Let us denote by <span class="math">\\mathsf{BCTV}&#x27;</span> the scheme identical to the one in [BCTV14] described in Subsection 1.3, with two modifications:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The elements <span class="math">\\{\\mathsf{pk}_{A&#x27;,i}\\}_{i\\in [0..n]}</span> are excluded from the proving key.</li>

      <li>The scheme is only defined for QAPs where the polynomials <span class="math">\\{A_i\\}</span> satisfy</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The polynomials <span class="math">\\{A_i\\}_{i\\in [0..n]}</span> are linearly independent (this condition already appears in [BCTV14] at [Par15]'s suggestion).</li>

      <li><span class="math">\\operatorname{Span}_{\\mathbb{F}}\\left(\\{A_i\\}_{i\\in [0..n]}\\right) \\cap \\operatorname{Span}_{\\mathbb{F}}\\left(\\{A_i\\}_{i\\in [n+1..m]}\\right) = \\{0\\}</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We also assume, mainly as a convenience, that <span class="math">Z \\in \\{C_i\\}_{i \\in [n+1..m]}</span>. This is always the case if we want zero-knowledge, and the BCTV construction adds <span class="math">Z</span> to <span class="math">\\{A_i\\}, \\{B_i\\}, \\{C_i\\}</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Remark 3.1.</strong> We emphasize that the linear disjointness condition above is not just an artefact of the proof: The attack of the previous section can be carried out also without the redundant proving key elements, for public inputs <span class="math">x, x&#x27;</span> such that <span class="math">\\mathsf{PI}(x) - \\mathsf{PI}(x&#x27;) \\in \\operatorname{Span}_{\\mathbb{F}}\\left(\\{A_i\\}_{i \\in [n+1..m]}\\right)</span>.</p>

    <p class="text-gray-300">We show <span class="math">\\mathsf{BCTV}&#x27;</span> is knowledge sound in the generic group model. We will use the following simple linear algebra claim.</p>

    <p class="text-gray-300"><strong>Claim 3.2.</strong> Fix positive integers <span class="math">n &amp;lt; m</span>. Let <span class="math">v_0, \\ldots, v_m</span> be vectors in a vector space over <span class="math">\\mathbb{F}</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">v_0, \\ldots, v_n</span> are linearly independent.</li>

      <li>Defining <span class="math">V = \\operatorname{Span}_{\\mathbb{F}}(v_0, \\ldots, v_n)</span> and <span class="math">U = \\operatorname{Span}_{\\mathbb{F}}(v_{n+1}, \\ldots, v_m)</span>, we have <span class="math">V \\cap U = \\{0\\}</span>.</li>

    </ol>

    <p class="text-gray-300">Suppose we are given <span class="math">(x_0, \\ldots, x_m), (a_0, \\ldots, a_m) \\in \\mathbb{F}^m</span> such that <span class="math">\\sum_{i=0}^{m} x_i \\cdot v_i = \\sum_{i=0}^{m} a_i \\cdot v_i</span>. Then <span class="math">(x_0, \\ldots, x_n) = (a_0, \\ldots, a_n)</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Since <span class="math">\\sum_{i=0}^{m} x_i \\cdot v_i = \\sum_{i=0}^{m} a_i \\cdot v_i</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=0}^{n} (x_i - a_i) v_i = \\sum_{i=n+1}^{m} (a_i - x_i) v_i</span></div>

    <p class="text-gray-300">2In conversation with Alessandro Chiesa and Madars Virza, we learned that they were aware of the necessity of this condition, and it is satisfied by any QAP constructed in libsnark[lib]. It also already appears in [BGG17].</p>

    <p class="text-gray-300">The zero-intersection condition implies <span class="math">\\sum_{i=0}^{n}(x_i - a_i)v_i = 0</span> and the linear independence of <span class="math">v_0, \\ldots, v_n</span> now implies <span class="math">x_i - a_i = 0</span> for <span class="math">i \\in [0..n]</span>.</p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300">We proceed to prove knowledge soundness of <span class="math">\\mathsf{BCTV}&#x27;</span> in the generic group model. Following [Gro16] (see also Section 2 of [BG18] for formal details, and <span class="math">[\\mathrm{BCI}^{+}12]</span> for a more general treatment of this framework), it suffices to show knowledge soundness of <span class="math">\\mathsf{BCTV}&#x27;</span> as a Non-Interactive Linear Proof (NILP). That is,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The CRS elements are the field elements encoded in the SNARK CRS group elements, rather than the group elements.</li>

      <li>The malicious prover must output, given only the public input <span class="math">x \\in \\mathbb{F}^n</span>, <span class="math">\\pi = (\\pi_A, \\pi_B, \\pi_C, \\pi_A&#x27;, \\pi_B&#x27;, \\pi_C&#x27;, \\pi_H, \\pi_K)</span> as linear combinations of the CRS elements, such that the verifier equations hold as a polynomial identity in <span class="math">\\tau, \\rho_A, \\rho_B, \\alpha_A, \\alpha_B, \\alpha_C, \\gamma, \\beta</span> as formal variables.</li>

      <li>To prove knowledge soundness, it then suffices to efficiently derive from the coefficients of these linear combinations a QAP witness for <span class="math">x</span>.</li>

    </ul>

    <p class="text-gray-300">For <span class="math">\\mathsf{BCTV}&#x27;</span>, the NILP CRS is now the set of field elements</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i \\in [0..d]</span>, <span class="math">\\tau^i</span>.</li>

      <li>For <span class="math">i \\in [0..m]</span></li>

    </ol>

    <p class="text-gray-300">(a) <span class="math">\\rho_{A}A_{i}(\\tau)</span> (b) <span class="math">\\rho_{B}B_{i}(\\tau)</span> (c) <span class="math">\\alpha_{B}\\rho_{B}B_{i}(\\tau)</span> (d) <span class="math">\\rho_{A}\\rho_{B}C_{i}(\\tau)</span> (e) <span class="math">\\alpha_{C}\\rho_{A}\\rho_{B}C_{i}(\\tau)</span> (f) <span class="math">\\beta (\\rho_A A_i(\\tau) + \\rho_B B_i(\\tau) + \\rho_A\\rho_B C_i(\\tau))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i \\in [n + 1..m]</span>, <span class="math">\\alpha_{A}\\rho_{A}A_{i}(\\tau)</span>.</li>

      <li><span class="math">\\alpha_{A}, \\alpha_{B}, \\alpha_{C}, \\gamma, \\beta \\gamma, \\rho_{a} \\rho_{b} Z(\\tau)</span>.</li>

    </ol>

    <p class="text-gray-300">and our verification equations are now:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi_A&#x27; = \\alpha_A \\cdot \\pi_A</span>.</li>

      <li><span class="math">\\pi_B&#x27; = \\alpha_B \\cdot \\pi_B</span>.</li>

      <li><span class="math">\\pi_C&#x27; = \\alpha_C \\cdot \\pi_C</span>.</li>

      <li><span class="math">\\gamma \\cdot \\pi_{K} = \\beta \\gamma \\cdot (\\mathsf{PI}(x) + \\pi_{A} + \\pi_{B} + \\pi_{C})</span>.</li>

      <li><span class="math">(\\mathsf{PI}(x) + \\pi_A)\\cdot \\pi_B = \\pi_C + \\pi_H\\cdot Z(\\tau)\\rho_A\\rho_B,</span></li>

    </ol>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">\\mathsf{PI}(x):=\\rho_{A}A_{0}(\\tau)+\\sum_{i=1}^{n}x_{i}\\cdot\\rho_{A}A_{i}(\\tau).</span></p>

    <p class="text-gray-300">Suppose now a prover has indeed output a valid proof <span class="math">\\pi=(\\pi_{A},\\pi_{B},\\pi_{C},\\pi_{A}^{\\prime},\\pi_{B}^{\\prime},\\pi_{C}^{\\prime},\\pi_{H},\\pi_{K})</span> as linear combinations of the CRS elements, such that the verifier equations hold as polynomial identities. We show how to derive a QAP witness for <span class="math">x</span> from the coefficients of these linear combinations. It will be convenient here to think of the proof elements as polynomials only in <span class="math">\\rho_{A},\\rho_{B},\\alpha_{A},\\alpha_{B},\\alpha_{C},\\beta,\\gamma</span> over the ring <span class="math">\\mathbb{F}[\\tau]</span>; i.e. think of the coefficients of these polynomials (not to be confused with the coefficients of the linear combinations of CRS elements) as polynomials in <span class="math">\\tau</span>.</p>

    <p class="text-gray-300">The first equation implies that the linear combination for <span class="math">\\pi_{A}^{\\prime}</span> only has non-zero coefficients for elements with an <span class="math">\\alpha_{A}</span> component, i.e.</p>

    <p class="text-gray-300"><span class="math">\\pi_{A}^{\\prime}=\\sum_{i=n+1}^{m}a_{i}\\cdot\\alpha_{A}\\rho_{A}A_{i}(\\tau)+a^{*}\\cdot\\alpha_{A}</span></p>

    <p class="text-gray-300">for some <span class="math">a_{n+1},\\ldots,a_{m},a^{*}\\in\\mathbb{F}</span>. Which implies</p>

    <p class="text-gray-300"><span class="math">\\pi_{A}=\\sum_{i=n+1}^{m}a_{i}\\cdot\\rho_{A}A_{i}(\\tau)+a^{*}</span></p>

    <p class="text-gray-300">From the second and third checks, we can similarly conclude:</p>

    <p class="text-gray-300"><span class="math">\\pi_{B}=\\sum_{i=0}^{m}b_{i}\\cdot\\rho_{B}B_{i}(\\tau)+b^{<em>}</span> <span class="math">\\pi_{C}=\\sum_{i=0}^{m}c_{i}\\cdot\\rho_{A}\\rho_{B}C_{i}(\\tau)+c^{</em>}</span></p>

    <p class="text-gray-300">Similarly, the fourth equation tells us that <span class="math">\\pi_{K}</span> must only use with non-zero coefficient elements with a <span class="math">\\beta</span> factor, i.e. the elements <span class="math">\\left\\{\\gamma\\beta,\\left\\{\\beta(\\rho_{A}A_{i}(\\tau)+\\rho_{B}B_{i}(\\tau)+\\rho_{A}\\rho_{B}C_{i}(\\tau))\\right\\}_{i\\in[0..m]}\\right\\}</span>. Hence we can write</p>

    <p class="text-gray-300"><span class="math">\\pi_{K}=\\sum_{i=0}^{m}k_{i}\\cdot\\beta(\\rho_{A}A_{i}(\\tau)+\\rho_{B}B_{i}(\\tau)+\\rho_{A}\\rho_{B}C_{i}(\\tau))+k^{*}\\cdot\\gamma\\beta</span></p>

    <p class="text-gray-300">and therefore</p>

    <p class="text-gray-300"><span class="math">\\mathsf{PI}(x)+\\pi_{A}+\\pi_{B}+\\pi_{C}=\\sum_{i=0}^{m}k_{i}\\cdot(\\rho_{A}A_{i}(\\tau)+\\rho_{B}B_{i}(\\tau)+\\rho_{A}\\rho_{B}C_{i}(\\tau))+k^{*}\\cdot\\gamma.</span> (1)</p>

    <p class="text-gray-300">Looking at the <span class="math">\\rho_{A}</span> coefficient on both sides of (1), we have</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=0}^{n}x_{i}\\cdot\\rho_{A}A_{i}(\\tau)+\\sum_{i=n+1}^{m}a_{i}\\cdot\\rho_{A}A_{i}(\\tau)=\\sum_{i=0}^{m}k_{i}\\cdot\\rho_{A}A_{i}(\\tau),</span></p>

    <p class="text-gray-300">and so</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=0}^{n}x_{i}\\cdot A_{i}(\\tau)+\\sum_{i=n+1}^{m}a_{i}\\cdot A_{i}(\\tau)=\\sum_{i=0}^{m}k_{i}\\cdot A_{i}(\\tau).</span></p>

    <p class="text-gray-300">Invoking Claim 3.2, this implies <span class="math">k_{i}=x_{i}</span> for <span class="math">i\\in[0..n]</span>. Since the coefficients of <span class="math">\\rho_{B},\\rho_{A}\\rho_{B}</span> must also match, we have</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=0}^{m}b_{i}\\cdot\\rho_{B}B_{i}(\\tau)=\\sum_{i=0}^{m}k_{i}\\cdot\\rho_{B}B_{i}(\\tau),\\sum_{i=0}^{m}c_{i}\\cdot\\rho_{A}\\rho_{B}C_{i}(\\tau)=\\sum_{i=0}^{m}k_{i}\\cdot\\rho_{A}\\rho_{B}C_{i}(\\tau)</span></p>

    <p class="text-gray-300">So</p>

    <p class="text-gray-300"><span class="math">\\mathsf{PI}(x)+\\pi_{A}=\\sum_{i=0}^{m}k_{i}\\cdot\\rho_{A}A_{i}(\\tau)+a^{<em>},\\pi_{B}=\\sum_{i=0}^{m}k_{i}\\cdot\\rho_{B}B_{i}(\\tau)+b^{</em>},\\pi_{C}=\\sum_{i=0}^{m}k_{i}\\cdot\\rho_{A}\\rho_{B}C_{i}(\\tau)+c^{*}</span></p>

    <p class="text-gray-300">Now invoking the fifth equation we have</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{PI}(x)+\\pi_{A})\\cdot\\pi_{B}=\\pi_{C}+\\pi_{H}\\cdot Z(\\tau)\\rho_{A}\\rho_{B}.</span> (2)</p>

    <p class="text-gray-300">Denote by <span class="math">H(\\tau)</span> the degree at most <span class="math">d</span> polynomial which is the part of <span class="math">\\pi_{H}</span> involving the terms <span class="math">\\left\\{\\tau^{i}\\right\\}_{i\\in[0..d]}</span> (inspection shows in fact <span class="math">\\pi_{H}=H(\\tau)</span>, but this is not crucial for us). The <span class="math">\\rho_{A}\\rho_{B}</span> coefficient of each side in (2), giving</p>

    <p class="text-gray-300"><span class="math">\\left(\\sum_{i=0}^{m}k_{i}\\cdot A_{i}(\\tau)\\right)\\left(\\sum_{i=0}^{m}k_{i}\\cdot B_{i}(\\tau)\\right)=\\sum_{i=0}^{m}k_{i}\\cdot C_{i}(\\tau)+H(\\tau)Z(\\tau)</span></p>

    <p class="text-gray-300">Since <span class="math">k_{i}=x_{i}</span> for <span class="math">i\\in[0..n]</span>, this means <span class="math">k_{n+1},\\ldots,k_{m}</span> is a QAP witness for public input <span class="math">x</span>.</p>

    <h2 id="sec-9" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">We thank Sean Bowe and Alessandro Chiesa for useful discussions and a review of this note.</p>

    <h2 id="sec-10" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BBFR15] M. Backes, M. Barbosa, D. Fiore, and R. M. Reischuk. ADSNARK: nearly practical and privacy-preserving proofs on authenticated data. In 2015 IEEE Symposium on Security and Privacy, SP 2015, San Jose, CA, USA, May 17-21, 2015, pages 271–286, 2015.</li>

      <li>[BCI^{+}12] N. Bitansky, A. Chiesa, Y. Ishai, R. Ostrovsky, and O. Paneth. Succinct non-interactive arguments via linear interactive proofs. IACR Cryptology ePrint Archive, 2012:718, 2012.</li>

      <li>[BCTV14] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct non-interactive zero knowledge for a von neumann architecture. In Proceedings of the 23rd USENIX Security Symposium, San Diego, CA, USA, August 20-22, 2014., pages 781–796, 2014.</li>

      <li>[BG18] S. Bowe and A. Gabizon. Making Groth’s zk-SNARK simulation extractable in the random oracle model. IACR Cryptology ePrint Archive, 2018:187, 2018.</li>

      <li>[BGG17] S. Bowe, A. Gabizon, and M. D. Green. A multi-party protocol for constructing the public parameters of the pinocchio zk-snark. IACR Cryptology ePrint Archive, 2017:602, 2017.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[Fuc18] G. Fuchsbauer. Subversion-zero-knowledge snarks. In Public-Key Cryptography - PKC 2018 - 21st IACR International Conference on Practice and Theory of Public-Key Cryptography, Rio de Janeiro, Brazil, March 25-29, 2018, Proceedings, Part I, pages 315–347, 2018.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GGPR13] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct nizks without pcps. In Advances in Cryptology - EUROCRYPT 2013, 32nd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Athens, Greece, May 26-30, 2013. Proceedings, pages 626–645, 2013.</li>

      <li>[Gro16] J. Groth. On the size of pairing-based non-interactive arguments. In Advances in Cryptology - EUROCRYPT 2016 - 35th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Vienna, Austria, May 8-12, 2016, Proceedings, Part II, pages 305–326, 2016.</li>

      <li>[lib] https://github.com/scipr-lab/libsnark.</li>

      <li>[Par15] B. Parno. A note on the unsoundness of vntinyram’s SNARK. IACR Cryptology ePrint Archive, 2015:437, 2015.</li>

      <li>[PHGR16] B. Parno, J. Howell, C. Gentry, and M. Raykova. Pinocchio: nearly practical verifiable computation. Commun. ACM, 59(2):103–112, 2016.</li>

      <li>[sna] https://github.com/iden3/snarkjs.</li>

    </ul>`;
---

<BaseLayout title="On the security of the BCTV Pinocchio zk-SNARK variant (2019/119)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/119
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
