---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2025/937';
---

<BaseLayout title="Attacking Poseidon via Graeffe Root-Finding (2025/937)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Attacking Poseidon via Graeffe-Based Root-Finding
        over NTT-Friendly Fields
      </h1>
      <p class="text-gray-400 mb-2">
        Antonio Sanso, Giuseppe Vitto
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2025 &middot; Full Version &middot; eprint 2025/937
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">
            The Poseidon Permutation</a>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">Attack Strategy</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1"
                class="hover:text-white">
                Solving Univariate Systems</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">
            Root-finding Based on the Graeffe Transform</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-4.1"
                class="hover:text-white">
                Composition of Graeffe Transforms</a>
            </li>
            <li>
              <a href="#sec-4.2"
                class="hover:text-white">
                Roots Exponentiation</a>
            </li>
            <li>
              <a href="#sec-4.3"
                class="hover:text-white">
                Tangent Graeffe Transforms</a>
            </li>
            <li>
              <a href="#sec-4.4"
                class="hover:text-white">
                Heuristic Randomized Algorithm for Root
                Finding over NTT-friendly Fields</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">
            Attacking Poseidon and Poseidon2</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-5.1"
                class="hover:text-white">
                The Skip-Round Attack</a>
            </li>
            <li>
              <a href="#sec-5.2"
                class="hover:text-white">
                Accelerate Root-finding with Graeffe&rsquo;s
                Transform</a>
            </li>
            <li>
              <a href="#sec-5.3"
                class="hover:text-white">
                Breaking Reduced-Round Instances of Poseidon
                and Poseidon2</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-6"
            class="hover:text-white">Conclusion</a>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">
        This paper explores the algebraic structure of the Poseidon
        and Poseidon2 permutations over NTT-friendly finite fields,
        with a focus on preimage recovery via root-finding
        techniques. We introduce an algorithm for efficiently
        identifying single roots of high-degree univariate
        polynomials that emerge from these constructions, based on
        the <em>Graeffe transform</em> and the <em>tangent Graeffe
        method</em>. Our approach is evaluated on reduced-round
        bounty instances of these permutations at various security
        levels, as proposed by the Ethereum Foundation, demonstrating
        practical effectiveness. These results yield new insights
        into the security of permutation-based cryptographic
        primitives instantiated over NTT-friendly prime fields.
      </p>
      <p class="text-gray-300 text-sm mt-4">
        <strong>Keywords:</strong> Poseidon &middot; Poseidon2
        &middot; Cryptanalysis &middot; Root-finding &middot;
        Graeffe &middot; Interpolation &middot; CICO &middot;
        Zero-Knowledge &middot; Hash Break
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1. Introduction</h2>

      <p class="text-gray-300">
        Poseidon [GKR+21] is a family of cryptographic permutations
        specifically designed for arithmetization and optimized for
        use in zero-knowledge proof systems. These permutations
        operate over finite fields
        <span class="math">\mathbb&#123;F&#125;_p</span> and are
        defined as mappings on
        <span class="math">\mathbb&#123;F&#125;_p^t</span>. The
        construction of Poseidon follows a
        Substitution&ndash;Permutation Network (SPN) paradigm, where
        the nonlinear layer consists of parallel applications of
        low-degree power maps of the form
        <span class="math">x \mapsto x^d</span>, with
        <span class="math">\gcd(d, p-1) = 1</span>. The design of
        Poseidon incorporates the Hades strategy [GLR+20], which
        interleaves full and partial rounds to balance efficiency and
        security. Specifically, full rounds apply the S-box to every
        element in the state, while partial rounds apply it to only
        one element, reducing computational overhead while still
        increasing algebraic complexity. The full structure consists
        of <span class="math">\frac&#123;R_F&#125;&#123;2&#125;</span>
        full rounds, followed by
        <span class="math">R_P</span> partial rounds, and another
        <span class="math">\frac&#123;R_F&#125;&#123;2&#125;</span>
        full rounds, where
        <span class="math">R_F</span> and
        <span class="math">R_P</span> denote the number of full and
        partial rounds, respectively. Full rounds primarily provide
        resistance against statistical attacks, while partial rounds
        serve to raise the algebraic degree, mitigating algebraic
        attacks. An extension of the original design, Poseidon2 [GKS23],
        introduces an initial linear layer and employs optimized
        matrices, yielding improved performance in both theoretical
        and practical scenarios.
      </p>

      <p class="text-gray-300">
        The attack surface of Poseidon has been examined in recent
        cryptanalytic surveys [GRS+25], which outline the balance between
        statistical and algebraic vulnerabilities inherent to its
        design. Full rounds, by applying the S-box uniformly,
        effectively mitigate statistical distinguishers and enhance
        diffusion. However, partial rounds, which apply the nonlinear
        transformation more selectively, create structural nuances
        that may be exploited by algebraic attacks due to regions of
        lower nonlinearity within the state. The growth of the
        algebraic degree across the permutation is crucial in
        defending against attacks leveraging low-degree polynomial
        representations. While the use of low-degree power maps
        enables efficient computation, it requires careful round
        structuring to maintain resistance against algebraic
        cryptanalysis. Furthermore, the design and optimization of
        linear layers, including the MDS matrices, play a key role in
        maximizing diffusion and minimizing exploitable weaknesses.
      </p>

      <p class="text-gray-300">
        Some reduced-round instances of Poseidon have been
        successfully attacked using algebraic techniques,
        specifically by solving instances of the CICO-1 (Constrained
        Input &ndash; Constrained Output) problem, as demonstrated
        in [BBLP22]. This highlights the importance of careful parameter
        selection and the sensitivity of the design to the number and
        structure of rounds.
      </p>

      <h3 class="text-xl font-semibold mt-6 mb-3">
        Our Contribution
      </h3>

      <p class="text-gray-300">
        In this paper, we present a new type of algebraic attack
        targeting reduced-round instances of Poseidon and Poseidon2
        over NTT-friendly prime fields. By exploiting the structure
        of these fields and employing the Graeffe transform, our
        method achieves improved efficiency in the root-finding stage
        of interpolation attacks. This results in a streamlined
        algorithm for preimage recovery that outperforms existing
        approaches and reveals practical vulnerabilities in these
        permutation-based primitives when instantiated over
        NTT-friendly primes.
      </p>

      <h3 class="text-xl font-semibold mt-6 mb-3">
        Outline
      </h3>

      <p class="text-gray-300">
        This paper is organized as follows. In Section 2, we provide
        additional details on the Poseidon and Poseidon2 permutations
        and survey relevant cryptanalytic attacks. Section 3 presents
        the core strategy of the attack in the setting of generic
        prime fields. In Section 4, we introduce the Graeffe
        Transform and Graeffe Tangent root-finding method. Finally,
        in Section 5, we demonstrate how to employ them to
        efficiently find roots of polynomials defined over
        NTT-friendly prime fields, and we apply them to break
        reduced-round instances of Poseidon2 over 64-bit fields and
        Poseidon over 256-bit fields.
      </p>

      <h3 class="text-xl font-semibold mt-6 mb-3">
        Notation
      </h3>

      <p class="text-gray-300">
        We write
        <span class="math">\mathsf&#123;M&#125;(d)</span>
        to denote the time complexity of multiplying two polynomials
        in
        <span class="math">\mathbb&#123;F&#125;_p[x]</span>
        of degree less than
        <span class="math">d</span>. It is known that
        <span class="math">\mathsf&#123;M&#125;(d) \in \mathcal&#123;O&#125;(d \log d \log \log d)</span>
        using fast multiplication algorithms.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2. THE POSEIDON PERMUTATION                                  -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2. The Poseidon Permutation</h2>

      <p class="text-gray-300">
        The Poseidon permutation is a cryptographic primitive
        specifically designed for efficient implementation in finite
        fields, particularly within zero-knowledge proof systems and
        other proof-friendly cryptographic protocols. Its design
        strikes a careful balance between algebraic simplicity and
        resistance to cryptanalytic attacks. Unlike traditional
        permutations used in block ciphers (e.g., AES), Poseidon is
        optimized for settings where arithmetic over large prime
        fields is dominant and expensive operations like bitwise XOR
        or substitution tables are infeasible. Formally, Poseidon
        defines a permutation
        <span class="math">P: \mathbb&#123;F&#125;_p^T \to \mathbb&#123;F&#125;_p^T</span>
        over a vector of
        <span class="math">T</span> field elements, constructed
        through a sequence of carefully structured rounds. These
        rounds are divided into two types: full rounds and partial
        rounds, each comprising three essential transformation steps:
      </p>

      <ul class="list-disc list-inside text-gray-300 space-y-2
        ml-4">
        <li>
          <span class="math">R_F</span>: Number of
          <strong>full rounds</strong>, applied symmetrically at the
          beginning and end of the permutation
          (<span class="math">R_F / 2</span> each).
        </li>
        <li>
          <span class="math">R_P</span>: Number of
          <strong>partial rounds</strong>, applied in between the
          full rounds.
        </li>
      </ul>

      <p class="text-gray-300 mt-4">
        Each round executes the following sequence of
        transformations:
      </p>

      <p class="text-gray-300">
        <strong>1. Add Round Constants.</strong> A round-dependent
        constant vector
        <span class="math">C^&#123;(r)&#125; = (c_0^&#123;(r)&#125;, c_1^&#123;(r)&#125;, \dots, c_&#123;T-1&#125;^&#123;(r)&#125;) \in \mathbb&#123;F&#125;_p^T</span>
        is added component-wise to the current state vector
        <span class="math">w^&#123;(r)&#125; = (w_0^&#123;(r)&#125;, w_1^&#123;(r)&#125;, \dots, w_&#123;T-1&#125;^&#123;(r)&#125;)</span>,
        resulting in:
      </p>

      <div class="math-block">
        a \leftarrow w^&#123;(r)&#125; + C^&#123;(r)&#125;
      </div>

      <p class="text-gray-300">
        <strong>2. S-Box Layer.</strong> A non-linear transformation,
        given by raising state elements to a fixed power
        <span class="math">d</span>, is applied. During a full
        round, this operation is applied independently to every
        element:
      </p>

      <div class="math-block">
        b \leftarrow (a_0^d, a_1^d, \dots, a_&#123;T-1&#125;^d)
      </div>

      <p class="text-gray-300">
        Conversely, during a partial round, the operation is
        performed only on the first element of the state:
      </p>

      <div class="math-block">
        b \leftarrow (a_0^d, a_1, \dots, a_&#123;T-1&#125;)
      </div>

      <p class="text-gray-300">
        <strong>3. Mixing Layer.</strong> The state vector is updated
        by applying a linear transformation, represented as
        multiplication by an MDS (Maximum Distance Separable) matrix
        <span class="math">M \in \mathbb&#123;F&#125;_p^&#123;T \times T&#125;</span>:
      </p>

      <div class="math-block">
        w^&#123;(r+1)&#125; \leftarrow M \cdot b
      </div>

      <p class="text-gray-300">
        The complete permutation thus follows this structure:
      </p>

      <div class="math-block">
        \underbrace&#123;\text&#123;Full Rounds&#125;&#125;_&#123;R_F/2&#125;
        \to
        \underbrace&#123;\text&#123;Partial Rounds&#125;&#125;_&#123;R_P&#125;
        \to
        \underbrace&#123;\text&#123;Full Rounds&#125;&#125;_&#123;R_F/2&#125;
      </div>

      <p class="text-gray-300">
        The cryptographic strength of the Poseidon permutation hinges
        on the careful choice of its design parameters: the round
        constants
        <span class="math">C^&#123;(r)&#125;</span>, the S-Box
        exponent <span class="math">d</span>, the MDS matrix
        <span class="math">M</span>, and the round numbers
        <span class="math">R_F</span> and
        <span class="math">R_P</span>. These parameters are selected
        to ensure strong diffusion, non-linearity, and resistance to
        differential and linear cryptanalysis, while still being
        efficient in proof systems that rely on arithmetic circuits.
      </p>

      <h3 class="text-xl font-semibold mt-6 mb-3">
        Poseidon2
      </h3>

      <p class="text-gray-300">
        Poseidon2 is a refined version of the original Poseidon
        permutation, defined over the same family of prime fields
        <span class="math">\mathbb&#123;F&#125;_p</span>. It supports
        usage in both the sponge construction and the feed-forward
        (compression) mode, enhancing its versatility in
        cryptographic protocols. The core structure remains
        round-based, but several important changes distinguish
        Poseidon2:
      </p>

      <ul class="list-disc list-inside text-gray-300 space-y-2
        ml-4">
        <li>
          <strong>Pre-round Linear Layer.</strong> An additional
          linear layer
          <span class="math">M_&#123;\epsilon&#125;</span> is applied
          to the state before the first round. This strengthens
          resistance against algebraic attacks that attempt to bypass
          the first rounds.
        </li>
        <li>
          <strong>Non-MDS Matrices.</strong> Unlike Poseidon, which
          uses an MDS matrix with maximal branch number for each
          round, Poseidon2 employs two different non-MDS matrices
          <span class="math">M_&#123;\epsilon&#125;</span> and
          <span class="math">M_&#123;I&#125;</span> in the external
          and internal rounds, respectively. These matrices have a
          reduced branch number (less than
          <span class="math">T - 1</span>), offering performance
          benefits.
        </li>
        <li>
          <strong>Localized Round Constants.</strong> In internal
          rounds, round constants are not added to every element of
          the state. Instead, they are applied only at the position
          of the S-box application (typically the first element),
          simplifying the implementation and reducing the number of
          constraints in proof systems.
        </li>
      </ul>

      <p class="text-gray-300 mt-4">
        These changes provide better efficiency in circuit
        representations and improved resilience against certain
        classes of algebraic and statistical attacks, while
        maintaining cryptographic robustness in relevant security
        models.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 3. ATTACK STRATEGY                                           -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3. Attack Strategy</h2>

      <p class="text-gray-300">
        In this section, we present the core methodology underlying
        our analysis of the Poseidon and Poseidon2 permutations over
        NTT-friendly prime fields. Our focus lies on algebraic
        techniques that leverage the inherent polynomial structure of
        the permutation to recover inputs from constrained outputs, a
        fundamental step in evaluating the permutation&rsquo;s
        resistance to preimage and related attacks.
      </p>

      <p class="text-gray-300">
        Specifically, we frame our approach in terms of the
        Constrained Input &ndash; Constrained Output (CICO) problem.
        Given a permutation
        <span class="math">P: \mathbb&#123;F&#125;_p^T \to \mathbb&#123;F&#125;_p^T</span>,
        the CICO problem asks us to find pairs
        <span class="math">(w, v) \in \mathbb&#123;F&#125;_p^T \times \mathbb&#123;F&#125;_p^T</span>
        such that
        <span class="math">P(w) = v</span>, while certain
        coordinates of
        <span class="math">w</span> and
        <span class="math">v</span> are fixed according to
        predetermined constraints. This problem naturally arises in
        cryptanalysis scenarios where partial information about
        inputs and outputs is known or controlled.
      </p>

      <p class="text-gray-300">
        By exploiting the algebraic structure of
        <span class="math">P</span>, we reduce the CICO problem to
        finding roots of certain univariate polynomials over
        <span class="math">\mathbb&#123;F&#125;_p</span> derived
        from the permutation&rsquo;s internal relations. Our attack
        strategy centers on efficiently identifying these roots,
        which correspond to candidate inputs that satisfy the given
        constraints. This approach enables reconstruction of the
        corresponding outputs and facilitates preimage recovery in
        the constrained setting.
      </p>

      <!-- ======================================================== -->
      <!-- 3.1 SOLVING UNIVARIATE SYSTEMS                           -->
      <!-- ======================================================== -->

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8 mb-3">
        3.1 Solving Univariate Systems
      </h3>

      <p class="text-gray-300">
        We solve the CICO problem for reduced-round instances of the
        Poseidon permutation through the following stages:
      </p>

      <p class="text-gray-300">
        <strong>1. Univariate Transformation.</strong> We restrict the
        permutation&rsquo;s input by fixing all non-constrained input
        entries, except one, to random values
        <span class="math">r_i</span>. This transforms the output
        entries into evaluations of univariate polynomials
        <span class="math">f_j(x) \in \mathbb&#123;F&#125;_p[x]</span>,
        depending only on the single unknown input state
        <span class="math">x \in \mathbb&#123;F&#125;_p</span>. An
        upper bound for each polynomial&rsquo;s degree,
        <span class="math">\deg(f_j)</span>, can be derived from the
        permutation&rsquo;s internal structure and parameters. More
        specifically, if <span class="math">d</span> is the degree
        of the S-Box&rsquo;s non-linear power mapping, then
        <span class="math">\deg(f_j) \leq d^&#123;R_F + R_P&#125;</span>.
      </p>

      <p class="text-gray-300">
        <strong>2. Interpolation.</strong> We evaluate the univariate
        transformation of the permutation, as defined in the previous
        step, at
        <span class="math">\deg(f_j) + 1</span> consecutive powers
        of a suitably chosen root of unity in
        <span class="math">\mathbb&#123;F&#125;_p</span>. We then
        collect the outputs corresponding to the entries constrained
        by the CICO problem and apply an inverse Number Theoretic
        Transform (NTT) to interpolate the polynomials
        <span class="math">f_j(x)</span>. Note that, to solve a
        given CICO problem, it suffices to interpolate only those
        polynomials
        <span class="math">f_j(x)</span> corresponding to the
        indices <span class="math">j</span> for which the output
        entries
        <span class="math">\&#123;w_i\&#125;_j</span> are
        constrained.
      </p>

      <p class="text-gray-300">
        <strong>3. Root-Finding.</strong> When certain output entries
        <span class="math">\&#123;w_j\&#125;_j</span> are
        constrained by the CICO problem, local solutions can be found
        by solving the polynomial equations
        <span class="math">f_j(x) = w_j</span>. By Fermat&rsquo;s
        Little Theorem, all elements of
        <span class="math">\mathbb&#123;F&#125;_p</span> are roots
        of the polynomial
        <span class="math">\pi_p(x) = x^p - x \in \mathbb&#123;F&#125;_p[x]</span>.
        Therefore, each root in
        <span class="math">\mathbb&#123;F&#125;_p</span> of
        <span class="math">\tilde&#123;f&#125;_j(x) = f_j(x) - w_j</span>
        divides
        <span class="math">\gcd(\pi_p, \tilde&#123;f&#125;_j)</span>.
        If a linear polynomial
        <span class="math">x - x_0</span> divides the polynomial
      </p>

      <div class="math-block">
        \gcd\left(\gcd(\pi_p, \tilde&#123;f&#125;_&#123;j_1&#125;),
        \ldots, \gcd(\pi_p,
        \tilde&#123;f&#125;_&#123;j_n&#125;)\right)
      </div>

      <p class="text-gray-300">
        then <span class="math">x_0</span> is a solution to the
        original CICO problem.
      </p>

      <p class="text-gray-300">
        The root-finding stage can then be further divided into two
        sub-stages:
      </p>

      <p class="text-gray-300">
        <strong>1. Compute
        <span class="math">\tilde&#123;\pi&#125;_&#123;p,j&#125; = \pi_p \mod \tilde&#123;f&#125;_j</span>.</strong>
        Since direct computation of
        <span class="math">\pi_p</span> is impractical due to its
        large degree, we reduce the problem of computing
        <span class="math">\gcd(\pi_p, \tilde&#123;f&#125;_j)</span>
        to the equivalent task of computing
        <span class="math">\gcd(\tilde&#123;\pi&#125;_&#123;p,j&#125;, \tilde&#123;f&#125;_j)</span>,
        where
        <span class="math">\tilde&#123;\pi&#125;_&#123;p,j&#125; = \pi_p \mod \tilde&#123;f&#125;_j</span>
        has degree less than
        <span class="math">\deg(\tilde&#123;f&#125;_j)</span>. To
        achieve this, we first compute
        <span class="math">x^p \mod \tilde&#123;f&#125;_j</span>
        using a square-and-multiply approach based on the binary
        representation of <span class="math">p</span>. We then
        subtract
        <span class="math">x \mod \tilde&#123;f&#125;_j</span> from
        this result.
      </p>

      <p class="text-gray-300">
        <strong>2. GCD Computations.</strong> We compute
        <span class="math">g_j = \gcd(\tilde&#123;\pi&#125;_&#123;p,j&#125;, \tilde&#123;f&#125;_j)</span>.
        Assuming that Poseidon behaves similarly to a random
        permutation, the univariate transformation from the first
        step implies that each polynomial
        <span class="math">g_j</span> is expected to have an average
        degree close to 1. We then compute the polynomial
        <span class="math">g = \gcd(g_1, \ldots, g_n)</span>, and
        select any root of <span class="math">g</span> as a solution
        to the original CICO problem.
      </p>

      <p class="text-gray-300">
        The complexity of solving the CICO problem using the outlined
        root-finding technique is primarily determined by polynomial
        arithmetic operations. The most computationally demanding
        step is the Root-finding, specifically the computation of
        <span class="math">\tilde&#123;\pi&#125;_&#123;p,j&#125; = \pi_p \mod \tilde&#123;f&#125;_j</span>,
        which involves exponentiation modulo a polynomial of degree
        <span class="math">d = \deg(\tilde&#123;f&#125;_j)</span>.
        Applying a square-and-multiply method combined with fast
        polynomial multiplication, this step has a time complexity of
        approximately
        <span class="math">\mathcal&#123;O&#125;(\mathsf&#123;M&#125;(d) \log p)</span>,
        where
        <span class="math">\mathsf&#123;M&#125;(d)</span> denotes
        the cost of multiplying two polynomials of degree less than
        <span class="math">d</span> over
        <span class="math">\mathbb&#123;F&#125;_p</span>.
      </p>

      <p class="text-gray-300">
        The subsequent polynomial GCD computations have complexity
        bounded by
        <span class="math">\mathcal&#123;O&#125;(\mathsf&#123;M&#125;(d) \log d)</span>,
        which is generally less costly. Recall that
        <span class="math">\mathsf&#123;M&#125;(d) \in \mathcal&#123;O&#125;(d \log d \log \log d)</span>
        with state-of-the-art polynomial multiplication algorithms.
        Therefore, the root-finding process scales quasi-linearly
        with the polynomial degree, with the modular exponentiation
        step representing the computational bottleneck.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 4. ROOT-FINDING BASED ON THE GRAEFFE TRANSFORM               -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">
        4. Root-finding Based on the Graeffe Transform
      </h2>

      <p class="text-gray-300">
        The root-finding strategy outlined in Subsection 3.1 is a
        well-known method for identifying roots of polynomials over
        finite fields, with its origins tracing back to
        Berlekamp&rsquo;s polynomial factorization algorithm.
        However, this algorithm is generic in nature and does not
        rely on any specific structural properties of the fields in
        which the polynomials are defined to improve computational
        efficiency.
      </p>

      <p class="text-gray-300">
        In this section, we will introduce the Graeffe transform and
        examine its various properties. These properties will
        subsequently be used to accelerate polynomial root-finding
        over NTT-friendly fields &mdash; namely, finite fields
        <span class="math">\mathbb&#123;F&#125;_p</span> in which
        <span class="math">p - 1</span> is divisible by a large
        power of a small prime, such as 2.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="flex items-start justify-between mb-2">
          <span class="text-sm font-bold text-blue-400">
            Definition 1 (Graeffe Transform)
          </span>
        </div>
        <p class="text-sm text-gray-300">
          The Graeffe transform of order
          <span class="math">r > 0</span> of a monic polynomial
          <span class="math">P \in \mathbb&#123;F&#125;_p[x]</span>
          of degree <span class="math">d</span> is defined as the
          unique monic polynomial
          <span class="math">G(P) \in \mathbb&#123;F&#125;_p[x]</span>
          of degree <span class="math">d</span> satisfying
        </p>
        <div class="math-block">
          G_r(P)(x^r) = (-1)^&#123;(r-1)d&#125; \cdot P(x) \cdot
          P(\omega_r \cdot x) \cdot \ldots \cdot
          P(\omega_r^&#123;r-1&#125; \cdot x)
        </div>
        <p class="text-sm text-gray-300">
          with
          <span class="math">\omega_r \in \mathbb&#123;F&#125;</span>
          a primitive
          <span class="math">r</span>-th root of unity.
        </p>
      </div>

      <p class="text-gray-300">
        We are interested in exploring two properties of the Graeffe
        transform: composition and roots&rsquo; exponentiations.
      </p>

      <!-- ======================================================== -->
      <!-- 4.1 COMPOSITION OF GRAEFFE TRANSFORMS                    -->
      <!-- ======================================================== -->

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8 mb-3">
        4.1 Composition of Graeffe Transforms
      </h3>

      <p class="text-gray-300">
        A consequence of Definition 1 is that for integers
        <span class="math">r, s > 0</span>, the transforms satisfy
      </p>

      <div class="math-block">
        G_&#123;rs&#125;(P) = (G_r \circ G_s)(P) = (G_s \circ
        G_r)(P)
      </div>

      <p class="text-gray-300">
        This property allows efficient computation of Graeffe
        transforms of order
        <span class="math">r^k</span>, by iteratively applying
        <span class="math">k</span> times a transform of order
        <span class="math">r</span>.
      </p>

      <p class="text-gray-300">
        In practice, Graeffe transforms of order
        <span class="math">r</span>, with
        <span class="math">r</span> prime, are computed using fast
        NTT-based polynomial multiplication. We recall that a
        generic product polynomial
        <span class="math">f = f_0(x) \cdots f_&#123;r-1&#125;(x) \in \mathbb&#123;F&#125;_p[x]</span>
        can be efficiently computed in
        <span class="math">O(n \log n)</span> operations as
      </p>

      <div class="math-block">
        f = \text&#123;NTT&#125;_n^&#123;-1&#125;\left(
        \text&#123;NTT&#125;_n(f_0) \circ \text&#123;NTT&#125;_n(f_1)
        \circ \dots \circ
        \text&#123;NTT&#125;_n(f_&#123;r-1&#125;)\right)
      </div>

      <p class="text-gray-300">
        where
        <span class="math">n \geq 1 + \sum \deg(f_i)</span>,
        <span class="math">\mathbb&#123;F&#125;_p</span> admits an
        <span class="math">n</span>-th primitive root of unity,
        <span class="math">\text&#123;NTT&#125;_n</span> and
        <span class="math">\text&#123;NTT&#125;_n^&#123;-1&#125;</span>
        denote the forward and inverse NTT of size
        <span class="math">n</span>, and
        <span class="math">\circ</span> denotes element-wise product
        of the NTT results.
      </p>

      <p class="text-gray-300">
        It follows that naively computing a Graeffe transform of
        order <span class="math">r^k</span> as
      </p>

      <div class="math-block">
        G_&#123;r^k&#125;(P)(x^&#123;r^k&#125;) =
        (-1)^&#123;(r-1)d&#125; \cdot
        \text&#123;NTT&#125;_n^&#123;-1&#125;\left(
        \text&#123;NTT&#125;_n(P(x)) \circ
        \text&#123;NTT&#125;_n(P(\xi x)) \circ \dots \circ
        \text&#123;NTT&#125;_n(P(\xi^&#123;r^k - 1&#125; x))\right)
      </div>

      <p class="text-gray-300">
        with
        <span class="math">\omega_&#123;r^k&#125; \in \mathbb&#123;F&#125;_p</span>
        a primitive
        <span class="math">r^k</span>-th root of unity, requires at
        least
        <span class="math">O(r^k d \log(r^k d))</span> operations,
        a much worse complexity compared to the
        <span class="math">O(k r d \log(rd))</span> operations
        required by iteratively applying
        <span class="math">k</span> times a Graeffe transform of
        order <span class="math">r</span>.
      </p>

      <p class="text-gray-300">
        These observations imply that computing Graeffe transforms is
        particularly efficient over finite fields
        <span class="math">\mathbb&#123;F&#125;_p</span> with
        <span class="math">p - 1</span> divided by a large power of
        a small prime such as 2, in which cases the field is said to
        be NTT-friendly.
      </p>

      <!-- ======================================================== -->
      <!-- 4.2 ROOTS EXPONENTIATION                                 -->
      <!-- ======================================================== -->

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8 mb-3">
        4.2 Roots Exponentiation
      </h3>

      <p class="text-gray-300">
        From Definition 1, if
        <span class="math">\alpha \in \mathbb&#123;F&#125;_p</span>
        is a root of
        <span class="math">P(x)</span>, then
        <span class="math">(x - \omega_r^&#123;r-i&#125; \alpha)</span>
        divides
        <span class="math">P(\omega_r^i x)</span> for all
        <span class="math">i \in [0, r-1]</span>. Therefore,
        <span class="math">\prod_&#123;i=0&#125;^&#123;r-1&#125; (x - \omega_r^&#123;r-i&#125; \alpha) = x^r - \alpha^r</span>
        divides
        <span class="math">G_r(P)(x^r)</span>, and thus
        <span class="math">\alpha^r</span> is a root of
        <span class="math">G_r(P)(x)</span>.
      </p>

      <p class="text-gray-300">
        When working over a finite field
        <span class="math">\mathbb&#123;F&#125;_p</span> with
        <span class="math">p - 1 = r \cdot s</span> and
        <span class="math">\gcd(r, s) = 1</span>, the Graeffe
        transform of order <span class="math">r</span> of a
        polynomial
        <span class="math">P(x)</span> maps non-zero roots
        <span class="math">\alpha</span> of
        <span class="math">P(x)</span> to non-zero roots
        <span class="math">\alpha^r</span> of
        <span class="math">G_r(P)(x)</span>, with the latter lying
        in the subgroup of order <span class="math">s</span> of
        <span class="math">\mathbb&#123;F&#125;_p^&#123;\times&#125;</span>.
        This implies that
        <span class="math">\alpha^r = \omega_s^i</span> for some
        <span class="math">i \in [0, s-1]</span> and
        <span class="math">\omega_s \in \mathbb&#123;F&#125;_p</span>
        primitive <span class="math">s</span>-th root of unity.
      </p>

      <p class="text-gray-300">
        To efficiently find non-zero roots of
        <span class="math">G_r(P)(x)</span>, we can proceed as
        follows:
      </p>

      <ul class="list-disc list-inside text-gray-300 space-y-2
        ml-4">
        <li>
          If
          <span class="math">\deg G_r(P)(x) \leq s</span>, we
          compute in
          <span class="math">O(s \log s)</span> operations
          <span class="math">\text&#123;NTT&#125;_s(G_r(P))</span>,
          then perform an
          <span class="math">O(s)</span> search for zero entries in
          the NTT result. Indeed, computing
          <span class="math">\text&#123;NTT&#125;_s(G_r(P))</span>
          corresponds to evaluating
          <span class="math">G_r(P)(x)</span> at all powers of a
          primitive <span class="math">s</span>-th root of unity
          <span class="math">\omega_s</span>. Thus, a zero entry at
          index <span class="math">i</span> indicates that
          <span class="math">\omega_s^i</span> is a root of
          <span class="math">G_r(P)(x)</span>.
        </li>
        <li>
          If
          <span class="math">\deg G_r(P)(x) > s</span>, we compute
          <span class="math">\tilde&#123;g&#125;(x) = G_r(P)(x) \pmod&#123;x^s - 1&#125;</span>
          and we proceed as above to find a root of
          <span class="math">\tilde&#123;g&#125;(x)</span>. Since
          <span class="math">(x - \omega_s^i)</span> divides
          <span class="math">x^s - 1</span> for all
          <span class="math">i \in [0, s-1]</span>, whenever
          <span class="math">(x - \omega_s^i)</span> divides
          <span class="math">G_r(P)(x)</span>, then
          <span class="math">(x - \omega_s^i)</span> must
          necessarily divide
          <span class="math">\tilde&#123;g&#125;(x)</span>, hence
          <span class="math">\omega_s^i</span> is one of its roots.
        </li>
      </ul>

      <!-- ======================================================== -->
      <!-- 4.3 TANGENT GRAEFFE TRANSFORMS                           -->
      <!-- ======================================================== -->

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8 mb-3">
        4.3 Tangent Graeffe Transforms
      </h3>

      <p class="text-gray-300">
        The Graeffe transform, by itself, does not allow for the
        direct computation of the roots of a polynomial
        <span class="math">P(x) \in \mathbb&#123;F&#125;_p[x]</span>.
        However, a method known as the <em>Tangent Graeffe
        Transform</em> enables the extraction of such roots by
        operating over the ring of dual numbers. In this section, we
        will briefly sketch this method.
      </p>

      <p class="text-gray-300">
        Let <span class="math">\varepsilon</span> be a formal
        indeterminate such that
        <span class="math">\varepsilon^2 = 0</span>. Elements of the
        quotient ring
        <span class="math">\mathbb&#123;F&#125;_p[\varepsilon]/(\varepsilon^2)</span>
        are referred to as <em>tangent numbers</em>. These take the
        form
        <span class="math">a + b\varepsilon</span>, where
        <span class="math">a, b \in \mathbb&#123;F&#125;_p</span>,
        and the basic arithmetic operations are defined as follows:
      </p>

      <div class="math-block">
        (a + b\varepsilon) \pm (c + d\varepsilon) = (a \pm c) +
        (b \pm d)\varepsilon
      </div>

      <div class="math-block">
        (a + b\varepsilon)(c + d\varepsilon) = ac +
        (ad + bc)\varepsilon
      </div>

      <p class="text-gray-300">
        Let
        <span class="math">P \in \mathbb&#123;F&#125;_p[x]</span>
        be a monic polynomial of degree
        <span class="math">d</span> that splits completely over
        <span class="math">\mathbb&#123;F&#125;_p</span> as
        <span class="math">P(x) = \prod_&#123;i=1&#125;^d (x - \alpha_i)</span>,
        where the roots
        <span class="math">\alpha_1, \ldots, \alpha_d \in \mathbb&#123;F&#125;_p</span>
        are pairwise distinct. Define the tangent deformation
        <span class="math">\widetilde&#123;P&#125;(x) := P(x + \varepsilon)</span>.
        Using Taylor expansion, we obtain:
      </p>

      <div class="math-block">
        \widetilde&#123;P&#125;(x) = P(x) + P'(x)\varepsilon =
        \prod_&#123;i=1&#125;^d (x - (\alpha_i - \varepsilon))
      </div>

      <p class="text-gray-300">
        The Graeffe transform of order
        <span class="math">r \geq 2</span>, previously defined over
        <span class="math">\mathbb&#123;F&#125;_p</span>, extends
        naturally to polynomials with coefficients in
        <span class="math">\mathbb&#123;F&#125;_p[\varepsilon]</span>.
        We define the tangent Graeffe transform of order
        <span class="math">r</span> as
        <span class="math">G_r(\widetilde&#123;P&#125;)</span>,
        satisfying
      </p>

      <div class="math-block">
        G_r(\widetilde&#123;P&#125;)(x) = \prod_&#123;i=1&#125;^d
        (x - (\alpha_i - \varepsilon)^r)
      </div>

      <p class="text-gray-300">
        where each factor expands as
      </p>

      <div class="math-block">
        (\alpha_i - \varepsilon)^r = \alpha_i^r -
        r\alpha_i^&#123;r-1&#125;\varepsilon
      </div>

      <p class="text-gray-300">
        for <span class="math">i = 1, \dots, d</span>.
      </p>

      <p class="text-gray-300">
        Assume we have an efficient method for computing the roots
        <span class="math">\alpha_1^r, \ldots, \alpha_d^r</span> of
        <span class="math">G_r(P)</span> (see Subsection 4.2). Then
        <span class="math">G_r(\widetilde&#123;P&#125;)</span> may
        be written as:
      </p>

      <div class="math-block">
        G_r(\widetilde&#123;P&#125;)(x) = A(x) + B(x)\varepsilon
      </div>

      <p class="text-gray-300">
        for some polynomial
        <span class="math">B \in \mathbb&#123;F&#125;_p[x]</span>
        and <span class="math">A = G_r(P)</span>. For each root
        <span class="math">\alpha_i^r</span> of
        <span class="math">A</span>, we evaluate:
      </p>

      <div class="math-block">
        G_r(\widetilde&#123;P&#125;)(\alpha_i^r -
        r\alpha_i^&#123;r-1&#125;\varepsilon) = A(\alpha_i^r) +
        \left(B(\alpha_i^r) - A'(\alpha_i^r) \cdot
        r\alpha_i^&#123;r-1&#125;\right)\varepsilon = 0
      </div>

      <p class="text-gray-300">
        Since <span class="math">\alpha_i^r</span> is a root of
        <span class="math">A</span>, the above simplifies to:
      </p>

      <div class="math-block">
        \left(B(\alpha_i^r) - A'(\alpha_i^r) \cdot
        r\alpha_i^&#123;r-1&#125;\right) \varepsilon = 0
      </div>

      <p class="text-gray-300">
        Therefore, if <span class="math">\alpha_i^r</span> is a
        simple root of <span class="math">A</span>, it follows that
        <span class="math">r\alpha_i^&#123;r-1&#125; = \frac&#123;B(\alpha_i^r)&#125;&#123;A'(\alpha_i^r)&#125;</span>.
        Provided that
        <span class="math">\alpha_i^r \neq 0</span>, we can then
        recover the original root
        <span class="math">\alpha_i</span> of
        <span class="math">P(x)</span> as:
      </p>

      <div class="math-block">
        \alpha_i =
        \frac&#123;r\alpha_i^r&#125;&#123;r\alpha_i^&#123;r-1&#125;&#125;
        = r\alpha_i^r \cdot
        \frac&#123;A'(\alpha_i^r)&#125;&#123;B(\alpha_i^r)&#125;
      </div>

      <!-- ======================================================== -->
      <!-- 4.4 HEURISTIC RANDOMIZED ALGORITHM                       -->
      <!-- ======================================================== -->

      <h3 id="sec-4.4" class="text-xl font-semibold mt-8 mb-3">
        4.4 Heuristic Randomized Algorithm for Root Finding over
        NTT-friendly Fields
      </h3>

      <p class="text-gray-300">
        The Tangent Graeffe Method outlined in the previous section
        has been extensively analyzed in [GHL15], where the authors
        formalized a heuristic randomized algorithm for finding all
        roots of a polynomial over NTT-friendly fields. Their method
        has been successfully implemented in [HM20] and [HM21], where, for
        the prime
        <span class="math">p = 5 \cdot 2^&#123;55&#125; + 1</span>,
        it was used to compute the roots of polynomials of degree up
        to <span class="math">10^9</span>. In this section we will
        briefly review their algorithm as originally introduced
        in [GHL15].
      </p>

      <p class="text-gray-300">
        Let
        <span class="math">\mathbb&#123;F&#125;_p</span> be a finite
        field, where <span class="math">p</span> is a prime of the
        form
        <span class="math">p = \sigma \cdot 2^m + 1</span> for some
        small <span class="math">\sigma</span>. Suppose that
        <span class="math">\beta \in \mathbb&#123;F&#125;_p</span>
        is a primitive element of order
        <span class="math">p - 1</span> in the multiplicative group
        of <span class="math">\mathbb&#123;F&#125;_p</span>.
      </p>

      <p class="text-gray-300">
        Let
        <span class="math">P = (x - \alpha_1) \cdots (x - \alpha_d) \in \mathbb&#123;F&#125;_p[x]</span>
        be as defined in the previous subsection. The tangent Graeffe
        method can be used to efficiently compute those
        <span class="math">\alpha_k</span> for which
        <span class="math">\alpha_k^r</span> is a simple root of
        <span class="math">G_r(P)</span>. In order to ensure a
        sufficient number of such roots, the polynomial
        <span class="math">P(x)</span> is first replaced by
        <span class="math">P(x + \tau)</span>.
      </p>

      <p class="text-gray-300">
        Let <span class="math">r</span> be the largest power of two
        such that
        <span class="math">r \leq \frac&#123;p-1&#125;&#123;4d&#125;</span>,
        and define
        <span class="math">s = \frac&#123;p-1&#125;&#123;r&#125;</span>.
        By construction,
        <span class="math">s = O(d)</span>. The roots
        <span class="math">\alpha_1^r, \ldots, \alpha_d^r</span>
        of <span class="math">G_r(P)</span> are
        <span class="math">s</span>-th roots of unity and lie in the
        set
        <span class="math">\&#123;1, \omega, \ldots, \omega^&#123;s-1&#125;\&#125;</span>,
        where
        <span class="math">\omega = \beta^r</span>. These roots can
        be determined by evaluating
        <span class="math">G_r(P)</span> at
        <span class="math">\omega^i</span> for
        <span class="math">i = 0, \ldots, s-1</span>. Since
        <span class="math">s = O(d)</span>, this evaluation can be
        performed efficiently using a discrete Fourier transform.
        Combined with the tangent Graeffe method described in the
        previous subsection, this yields the following probabilistic
        algorithm for root finding:
      </p>

      <div class="formal-block formal-block-definition">
        <div class="flex items-start justify-between mb-2">
          <span class="text-sm font-bold text-blue-400">
            Algorithm 1: Randomized Root Finding Algorithm over
            NTT-Friendly Fields [GHL15]
          </span>
        </div>
        <p class="text-sm text-gray-300 mb-2">
          <strong>Input:</strong>
          <span class="math">P \in \mathbb&#123;F&#125;_p[x]</span>
          of degree <span class="math">d</span> and only order one
          factors,
          <span class="math">p = \sigma \cdot 2^m + 1</span>.
        </p>
        <p class="text-sm text-gray-300 mb-2">
          <strong>Output:</strong> The set
          <span class="math">\&#123;\alpha_1, \ldots, \alpha_d\&#125;</span>
          of roots of <span class="math">P</span>.
        </p>
        <ol class="list-decimal list-inside text-sm text-gray-300
          space-y-1 ml-2">
          <li>
            If <span class="math">d = 0</span> then return
            <span class="math">\emptyset</span>.
          </li>
          <li>
            Let
            <span class="math">r = 2^N \in \mathbb&#123;N&#125;</span>
            be the largest such that
            <span class="math">r \leq \frac&#123;p-1&#125;&#123;4d&#125;</span>,
            and let
            <span class="math">s := \frac&#123;p-1&#125;&#123;r&#125;</span>.
          </li>
          <li>
            Pick
            <span class="math">\tau \in \mathbb&#123;F&#125;_p</span>
            at random and compute
            <span class="math">P^* := P(x + \tau) \in \mathbb&#123;F&#125;_p[x]</span>.
            &emsp;
            <span class="math">\mathcal&#123;O&#125;(\mathsf&#123;M&#125;(d))</span>
          </li>
          <li>
            Compute
            <span class="math">\widetilde&#123;P&#125;(x) := P^*(x + \varepsilon) = P^*(x) + P^&#123;*\prime&#125;(x)\varepsilon \in (\mathbb&#123;F&#125;_p[\varepsilon]/(\varepsilon^2))[x]</span>.
          </li>
          <li>
            For
            <span class="math">i = 1, \ldots, N</span>, set
            <span class="math">\widetilde&#123;P&#125; := G_2(\widetilde&#123;P&#125;) \in (\mathbb&#123;F&#125;_p[\varepsilon]/(\varepsilon^2))[x]</span>.
            &emsp;
            <span class="math">\mathcal&#123;O&#125;(\mathsf&#123;M&#125;(d) \log p / s)</span>
          </li>
          <li>
            Let
            <span class="math">\omega \in \mathbb&#123;F&#125;_p^*</span>
            be of order <span class="math">s</span>, and write
            <span class="math">\widetilde&#123;P&#125; = A + B\varepsilon</span>.
          </li>
          <li>
            Compute
            <span class="math">A(\omega^i), A'(\omega^i), B(\omega^i)</span>
            for <span class="math">i = 0, \ldots, s - 1</span>.
            &emsp;
            <span class="math">\mathcal&#123;O&#125;(\mathsf&#123;M&#125;(s))</span>
          </li>
          <li>
            If <span class="math">P(\tau) = 0</span>, set
            <span class="math">S := \&#123;\tau\&#125;</span>;
            else set
            <span class="math">S := \emptyset</span>.
          </li>
          <li>
            For
            <span class="math">\beta \in \&#123;1, \omega, \ldots, \omega^&#123;s-1&#125;\&#125;</span>:
            if <span class="math">A(\beta) = 0</span> and
            <span class="math">A'(\beta) \neq 0</span>, set
            <span class="math">S := S \cup \left\&#123; r\beta \frac&#123;A'(\beta)&#125;&#123;B(\beta)&#125; + \tau \right\&#125;</span>.
          </li>
          <li>
            Compute
            <span class="math">Q := \prod_&#123;\alpha \in S&#125; (x - \alpha)</span>.
            &emsp;
            <span class="math">\mathcal&#123;O&#125;(\mathsf&#123;M&#125;(d) \log d)</span>
          </li>
          <li>
            Compute
            <span class="math">R := \frac&#123;P&#125;&#123;Q&#125;</span>.
            &emsp;
            <span class="math">\mathcal&#123;O&#125;(\mathsf&#123;M&#125;(d))</span>
          </li>
          <li>
            Recursively determine the set of roots
            <span class="math">S'</span> of
            <span class="math">R</span> and return
            <span class="math">S \cup S'</span>.
          </li>
        </ol>
      </div>

      <p class="text-gray-300">
        The computational complexity of the presented root-finding
        algorithm is dominated by polynomial arithmetic over the ring
        <span class="math">\mathbb&#123;F&#125;_p[\varepsilon]/(\varepsilon^2)</span>.
        The key cost arises from the repeated application of the
        operator <span class="math">G_2</span>, which involves
        <span class="math">N = \frac&#123;r&#125;&#123;2&#125;</span>
        iterations and contributes a time complexity of approximately
        <span class="math">\mathcal&#123;O&#125;\!\left(\mathsf&#123;M&#125;(d) \frac&#123;\log p&#125;&#123;s&#125;\right)</span>,
        where
        <span class="math">\mathsf&#123;M&#125;(d)</span> denotes
        the complexity of multiplying polynomials of degree at most
        <span class="math">d</span> over
        <span class="math">\mathbb&#123;F&#125;_p</span>. Evaluating
        the polynomials
        <span class="math">A</span>,
        <span class="math">A'</span>, and
        <span class="math">B</span> at
        <span class="math">s</span> points has complexity
        <span class="math">\mathcal&#123;O&#125;(\mathsf&#123;M&#125;(s))</span>,
        while polynomial division and multiplication steps incur
        complexities bounded by
        <span class="math">\mathcal&#123;O&#125;(\mathsf&#123;M&#125;(d) \log d)</span>
        and
        <span class="math">\mathcal&#123;O&#125;(\mathsf&#123;M&#125;(d))</span>,
        respectively. Given that
        <span class="math">\mathsf&#123;M&#125;(d) \in \mathcal&#123;O&#125;(d \log d \log \log d)</span>
        using fast multiplication techniques, the overall
        root-finding procedure runs quasi-linearly in
        <span class="math">d</span>, with the exponentiation steps
        via <span class="math">G_2</span> dominating the runtime.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 5. ATTACKING POSEIDON AND POSEIDON2                          -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">
        5. Attacking Poseidon and Poseidon2
      </h2>

      <!-- ======================================================== -->
      <!-- 5.1 THE SKIP-ROUND ATTACK                                -->
      <!-- ======================================================== -->

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8 mb-3">
        5.1 The Skip-Round Attack
      </h3>

      <p class="text-gray-300">
        Bariant et al. [BBLP22] introduced a univariate transformation
        that simplifies solving the CICO problem for Poseidon, when
        exactly one input state element is constrained. Without loss
        of generality, and for ease of exposition, we assume that
        this constraint sets the last input and output indices to 0.
      </p>

      <p class="text-gray-300">
        Their core strategy decomposes the full Poseidon permutation
        <span class="math">P</span> into two sub-permutations,
        <span class="math">P = P_2 \circ P_1</span>. This
        decomposition allows one to solve a simplified modified CICO
        problem for <span class="math">P_2</span> whose solution can
        be efficiently mapped to a solution to the original CICO
        problem for <span class="math">P</span>.
      </p>

      <p class="text-gray-300">
        Remarkably, their approach requires the application of a
        univariate transformation to
        <span class="math">P_2</span> (and consequently to
        <span class="math">P</span>), constraining the inputs to the
        particular form
      </p>

      <div class="math-block">
        (A_0 \cdot x + B_0,\; A_1 \cdot x + B_1,\; \dots,\;
        A_&#123;T-1&#125; \cdot x + B_&#123;T-1&#125;)
      </div>

      <p class="text-gray-300">
        for certain efficiently computable constants
        <span class="math">A_0, B_0, \ldots, A_&#123;T-1&#125;, B_&#123;T-1&#125; \in \mathbb&#123;F&#125;_p</span>.
        These constants satisfy
      </p>

      <div class="math-block">
        P_1^&#123;-1&#125;(A_0 \cdot x + B_0,\; A_1 \cdot x + B_1,\;
        \dots,\; A_&#123;T-1&#125; \cdot x + B_&#123;T-1&#125;) =
        (v_0, \dots, v_&#123;T-2&#125;, 0)
      </div>

      <p class="text-gray-300">
        for every possible choice of
        <span class="math">x \in \mathbb&#123;F&#125;_p</span>.
        Only one input entry can be constrained with this technique.
        Without loss of generality, we constrain the last entry
        to 0.
      </p>

      <p class="text-gray-300">
        Consequently, if <span class="math">x_0</span> solves the
        modified CICO problem given by
      </p>

      <div class="math-block">
        P_2(A_0 \cdot x + B_0,\; A_1 \cdot x + B_1,\; \dots,\;
        A_&#123;T-1&#125; \cdot x + B_&#123;T-1&#125;) =
        (w_0, \dots, w_&#123;T-2&#125;, 0)
      </div>

      <p class="text-gray-300">
        then the vector
      </p>

      <div class="math-block">
        (v_0, \dots, v_&#123;T-2&#125;, 0) =
        P_1^&#123;-1&#125;(A_0 \cdot x + B_0,\; A_1 \cdot x + B_1,\;
        \dots,\; A_&#123;T-1&#125; \cdot x + B_&#123;T-1&#125;)
      </div>

      <p class="text-gray-300">
        solves the original CICO problem
      </p>

      <div class="math-block">
        P(v_0, \ldots, v_&#123;T-2&#125;, 0) =
        (w_0, \ldots, w_&#123;T-2&#125;, 0)
      </div>

      <h4 class="text-lg font-semibold mt-6 mb-3">
        The 2-Round Attack for Poseidon
      </h4>

      <p class="text-gray-300">
        In the case of Poseidon, we define the permutation
        <span class="math">P_1</span> as comprising the first two
        full rounds, omitting the second mixing layer. The subsequent
        permutation <span class="math">P_2</span> includes this
        omitted mixing layer as well as all remaining rounds.
      </p>

      <p class="text-gray-300">
        The univariate representation of
        <span class="math">P_2</span> yields output polynomials
        <span class="math">f_j(x)</span> whose degrees are lower
        than those obtained from the full permutation
        <span class="math">P</span>. This reduction in degree is due
        to the absence of two S-Boxes in
        <span class="math">P_2</span> that are otherwise present in
        the complete permutation. As a result, we obtain the bound
        <span class="math">\deg(f_j) \leq d^&#123;R_F + R_P - 2&#125;</span>,
        which significantly simplifies both interpolation and
        root-finding when solving the CICO problem.
      </p>

      <h4 class="text-lg font-semibold mt-6 mb-3">
        The 1-Round Attack for Poseidon2
      </h4>

      <p class="text-gray-300">
        While the authors of [BBLP22] did not explicitly apply their
        technique to Poseidon2, the method can be adapted to skip one
        full round. For Poseidon2, we define the permutation
        <span class="math">P_1</span> to consist of the initial
        application of the external matrix
        <span class="math">M_&#123;\epsilon&#125;</span>, followed
        by the first full round, excluding the final mixing layer
        <span class="math">M_&#123;\epsilon&#125;</span>. The
        permutation <span class="math">P_2</span> then comprises the
        mixing layer of the first full round followed by all
        subsequent rounds.
      </p>

      <p class="text-gray-300">
        The corresponding univariate transformation of
        <span class="math">P_2</span> then results in output
        polynomials
        <span class="math">f_j(x)</span> satisfying the bound
        <span class="math">\deg(f_j) \leq d^&#123;R_F + R_P - 1&#125;</span>.
      </p>

      <!-- ======================================================== -->
      <!-- 5.2 ACCELERATE ROOT-FINDING WITH GRAEFFE'S TRANSFORM     -->
      <!-- ======================================================== -->

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8 mb-3">
        5.2 Accelerate Root-finding with Graeffe&rsquo;s Transform
      </h3>

      <p class="text-gray-300">
        In the previous section, we saw how the Graeffe Transform and
        the Tangent Graeffe method can be used to find roots of a
        polynomial over
        <span class="math">\mathbb&#123;F&#125;_p</span>. However,
        as discussed in Section 3, solving the CICO-1 problem for
        the univariate transformation requires finding a single root,
        thus we can optimize Algorithm 1 for the specific instances
        of Poseidon and Poseidon2 we want to attack.
      </p>

      <p class="text-gray-300">
        In this section, we describe the modifications made to obtain
        a more efficient algorithm tailored to finding a single root
        (if one exists) of a polynomial
        <span class="math">P(x) \in \mathbb&#123;F&#125;_p[x]</span>.
        We will first present it, and then examine its components in
        detail:
      </p>

      <div class="formal-block formal-block-definition">
        <div class="flex items-start justify-between mb-2">
          <span class="text-sm font-bold text-blue-400">
            Algorithm 2: Single Root Finding Algorithm
          </span>
        </div>
        <p class="text-sm text-gray-300 mb-2">
          <strong>Input:</strong>
          <span class="math">P \in \mathbb&#123;F&#125;_p[x]</span>
          of degree <span class="math">d</span>;
          <span class="math">r, s \in \mathbb&#123;N&#125;</span> so
          that
          <span class="math">p = rs + 1</span> and
          <span class="math">r = 2^k</span> for a certain
          <span class="math">k \in \mathbb&#123;N&#125;</span>,
          <span class="math">\omega_r</span> and
          <span class="math">\omega_s</span> primitive
          <span class="math">r</span>-th and
          <span class="math">s</span>-th, respectively, roots of
          unity of
          <span class="math">\mathbb&#123;F&#125;_p</span>.
        </p>
        <p class="text-sm text-gray-300 mb-2">
          <strong>Output:</strong> An
          <span class="math">\alpha \in \mathbb&#123;F&#125;_p</span>
          such that
          <span class="math">P(\alpha) = 0</span>, if one exists.
        </p>
        <ol class="list-decimal list-inside text-sm text-gray-300
          space-y-1 ml-2">
          <li>
            If <span class="math">d = 0</span> then return
            <span class="math">\emptyset</span>.
          </li>
          <li>
            If <span class="math">P(0) = 0</span> then return
            <span class="math">0</span>.
          </li>
          <li>
            Set <span class="math">G(x) = P(x)</span>. For
            <span class="math">i = 0, \ldots, k-1</span>, compute
            <span class="math">G(x) = G_2(G)(x)</span>.
            &emsp;
            <span class="math">\mathcal&#123;O&#125;(\mathsf&#123;M&#125;(d) \log r)</span>
          </li>
          <li>
            Set
            <span class="math">\tilde&#123;P&#125;(x) = G(x) \pmod&#123;x^s - 1&#125;</span>.
          </li>
          <li>
            Compute the vector
            <span class="math">V = \text&#123;NTT&#125;_s(\tilde&#123;P&#125;)</span>
            using
            <span class="math">\omega_s \in \mathbb&#123;F&#125;_p</span>.
            &emsp;
            <span class="math">\mathcal&#123;O&#125;(s \log s)</span>
          </li>
          <li>
            For <span class="math">i = 0, \ldots, s-1</span>: if
            <span class="math">V[i] = 0</span>, set
            <span class="math">\beta = \omega_s^i</span> and break.
            Otherwise return
            <span class="math">\emptyset</span>.
          </li>
          <li>
            For <span class="math">i = 0, \ldots, k-1</span>,
            compute
            <span class="math">\gamma = \sqrt&#123;\beta&#125;</span>.
          </li>
          <li>
            For <span class="math">i = 0, \ldots, r-1</span>: set
            <span class="math">\alpha = \omega_r^i \cdot \gamma</span>;
            if
            <span class="math">P(\alpha) = 0</span>, return
            <span class="math">\alpha</span>.
          </li>
          <li>
            Return <span class="math">\emptyset</span>.
          </li>
        </ol>
      </div>

      <p class="text-gray-300">
        Since we are interested in finding a single root of
        <span class="math">P(x)</span>, for the sake of exposition
        we will assume that it has at most one root and that this is
        non-zero.
      </p>

      <p class="text-gray-300">
        The main idea underlying the algorithm is that when working
        over a finite field
        <span class="math">\mathbb&#123;F&#125;_p</span> where
        <span class="math">p - 1 = r \cdot s = 2^k \cdot s</span>,
        we can iteratively apply the efficient Graeffe transform of
        order 2 exactly <span class="math">k</span> times to the
        polynomial <span class="math">P(x)</span> (line 3). This
        process effectively &ldquo;pushes&rdquo; the root
        <span class="math">\alpha</span> of
        <span class="math">P</span> to the root
        <span class="math">\alpha^r</span> of the transformed
        polynomial <span class="math">G_r(P)</span>, which lies in
        the multiplicative subgroup of order
        <span class="math">s</span> of
        <span class="math">\mathbb&#123;F&#125;_p</span>.
      </p>

      <p class="text-gray-300">
        Since all roots of <span class="math">G_r(P)</span> must
        have order dividing <span class="math">s</span>, they are
        also roots of
        <span class="math">x^s - 1</span>. Therefore, they are also
        roots of the polynomial
        <span class="math">\tilde&#123;P&#125;(x) = G_r(P)(x) \bmod (x^s - 1)</span>,
        which has degree less than <span class="math">s</span>
        (line 4). We note that this step can be computed in
        <span class="math">\max(d - s, 0)</span> operations by
        folding the coefficients of
        <span class="math">G(x)</span> according to the relation
        <span class="math">x^s = 1 \pmod&#123;x^s - 1&#125;</span>.
      </p>

      <p class="text-gray-300">
        At this stage, we apply
        <span class="math">\text&#123;NTT&#125;_s</span> to
        <span class="math">\tilde&#123;P&#125;</span> in order to
        evaluate it over the full subgroup of order
        <span class="math">s</span>. This allows us to efficiently
        locate its root
        <span class="math">\alpha^r</span>, if one exists (lines
        5&ndash;6).
      </p>

      <p class="text-gray-300">
        Once a root
        <span class="math">\beta = \omega_s^i = \alpha^r</span> of
        <span class="math">\tilde&#123;P&#125;(x)</span> is found,
        we can recover the original root
        <span class="math">\alpha</span> of
        <span class="math">P(x)</span> as follows:
      </p>

      <ul class="list-disc list-inside text-gray-300 space-y-2
        ml-4">
        <li>
          Extract an <span class="math">r</span>-th root
          <span class="math">\gamma = \sqrt[r]&#123;\omega_s^i&#125; \in \mathbb&#123;F&#125;_p</span>
          by iteratively computing
          <span class="math">k</span> square roots (line 7).
        </li>
        <li>
          For all
          <span class="math">i \in [0, r-1]</span>, check whether
          <span class="math">P(\omega_r^i \cdot \gamma) = 0</span>
          (line 8). This works because the values
          <span class="math">\omega_r^i \cdot \gamma</span> represent
          all roots of the polynomial
          <span class="math">x^r - \alpha^r</span>, and thus the
          true root <span class="math">\alpha</span> must equal one
          of these elements for some exponent
          <span class="math">i</span>.
        </li>
      </ul>

      <p class="text-gray-300">
        We note that the complexity of the final loop (line 8) is, in
        principle,
        <span class="math">O(dr)</span> for an arbitrary polynomial
        <span class="math">P(x) \in \mathbb&#123;F&#125;_p[x]</span>
        of degree <span class="math">d</span>. However, in the
        context of attacking Poseidon, the polynomial
        <span class="math">P(x)</span> corresponds to the univariate
        representation of the permutation
        <span class="math">P_2</span>, as defined in Subsection 5.1.
        Since the evaluation of
        <span class="math">P_2</span> can be performed with a
        constant number of operations once the targeted Poseidon
        instance is fixed, this approach is more efficient than
        evaluating the univariate polynomial directly, which would
        otherwise incur a cost of
        <span class="math">O(d)</span> operations per evaluation. In
        practical attacks, the last loop is then performed by
        evaluating the permutation
        <span class="math">P_2</span> over an input state evaluated
        at <span class="math">\alpha</span>, thus costing
        <span class="math">O(r)</span> operations overall.
      </p>

      <p class="text-gray-300">
        When applied to Poseidon and Poseidon2 permutations, the
        total cost of the optimized single root finding algorithm is
        then
        <span class="math">\mathcal&#123;O&#125;(\mathsf&#123;M&#125;(d) \log r + s \log s + r)</span>.
      </p>

      <h4 class="text-lg font-semibold mt-6 mb-3">
        Large Input Polynomials
      </h4>

      <p class="text-gray-300">
        We recall that the degree <span class="math">d</span> of the
        Graeffe transform <span class="math">G(x)</span> is equal to
        the degree of the input polynomial
        <span class="math">P(x)</span>. Since, in line 4,
        <span class="math">G(x)</span> will be reduced modulo
        <span class="math">x^s - 1</span>, it is
        advantageous &mdash; particularly when
        <span class="math">d \gg s</span> &mdash; to gradually
        reduce the size of the intermediate Graeffe transforms down
        to <span class="math">s</span> during the execution of
        line 3. This strategy helps to reduce the memory footprint of
        the algorithm without affecting correctness.
      </p>

      <p class="text-gray-300">
        The key observation is that if
        <span class="math">\alpha \neq 0</span> is a root of a
        polynomial <span class="math">P(x)</span>, then
        <span class="math">\alpha^&#123;2^i&#125;</span> is a root of
        the Graeffe transform
        <span class="math">G_&#123;2^i&#125;(P)</span>. Since this
        value lies in the multiplicative subgroup of order
        <span class="math">\frac&#123;p-1&#125;&#123;2^i&#125;</span>
        in
        <span class="math">\mathbb&#123;F&#125;_p^&#123;\times&#125;</span>,
        it follows that
        <span class="math">\alpha^&#123;2^i&#125;</span> is a root of
        the polynomial
        <span class="math">x^&#123;\frac&#123;p-1&#125;&#123;2^i&#125;&#125; - 1</span>,
        as well as of the reduced polynomial
      </p>

      <div class="math-block">
        \tilde&#123;G&#125;_&#123;2^i&#125;(x) =
        G_&#123;2^i&#125;(x) \pmod&#123;x^&#123;\frac&#123;p-1&#125;&#123;2^i&#125;&#125;
        - 1&#125;
      </div>

      <p class="text-gray-300">
        whose degree satisfies
      </p>

      <div class="math-block">
        \deg \tilde&#123;G&#125;_&#123;2^i&#125; = \min\!\left(
        \deg\!\left(G_&#123;2^i&#125;\right),\;
        \frac&#123;p-1&#125;&#123;2^i&#125; - 1 \right)
      </div>

      <p class="text-gray-300">
        Thus, as soon as
        <span class="math">d = \deg(G_&#123;2^i&#125;) > \frac&#123;p-1&#125;&#123;2^i&#125; - 1</span>,
        that is, starting from iteration
      </p>

      <div class="math-block">
        i = \left\lceil \log_2\!\left(
        \frac&#123;p-1&#125;&#123;d&#125; \right) \right\rceil
      </div>

      <p class="text-gray-300">
        we can begin reducing the size of the transformed polynomials
        at each step of line 3 by halving, continuing until their
        degree falls below the threshold
        <span class="math">s</span>.
      </p>

      <h4 class="text-lg font-semibold mt-6 mb-3">
        Large NTT-Friendly Fields
      </h4>

      <p class="text-gray-300">
        When the field is small, performing the NTT of size
        <span class="math">s</span> at line 5 poses no practical
        difficulties. However, for large fields &mdash; such as
        BLS12-381 &mdash; computing such an NTT is infeasible due to
        memory and computational constraints.
      </p>

      <p class="text-gray-300">
        To understand the necessity of computing such large NTTs, we
        observe that the goal is to find a root in the subgroup of
        order <span class="math">s</span> of
        <span class="math">\mathbb&#123;F&#125;_p^&#123;\times&#125;</span>
        for the Graeffe transform <span class="math">G</span> of
        order <span class="math">r</span> applied to
        <span class="math">P(x)</span> (since
        <span class="math">s \gg r</span>, we have
        <span class="math">\tilde&#123;P&#125; = G</span> in
        line 4).
      </p>

      <p class="text-gray-300">
        As a result, we may alternatively employ the classical
        root-finding strategy based on Berlekamp&rsquo;s polynomial
        factorization algorithm, as described in Subsection 3.1, but
        with a key adaptation: we compute
        <span class="math">\gcd(G(x),\; x^s - 1 \bmod G(x))</span>
        instead of
        <span class="math">\gcd(G(x),\; x^p - x \bmod G(x))</span>,
        thus saving
        <span class="math">\log r</span> exponentiation and modulo
        reduction steps. Once a root
        <span class="math">\alpha^r</span> to
        <span class="math">G</span> is found, we then proceed from
        line 8.
      </p>

      <!-- ======================================================== -->
      <!-- 5.3 BREAKING REDUCED-ROUND INSTANCES                     -->
      <!-- ======================================================== -->

      <h3 id="sec-5.3" class="text-xl font-semibold mt-8 mb-3">
        5.3 Breaking Reduced-Round Instances of Poseidon and
        Poseidon2
      </h3>

      <p class="text-gray-300">
        We now demonstrate how the techniques developed in the
        previous sections can be applied to break reduced-round
        instances of the Poseidon and Poseidon2 permutations over
        prime fields. Our focus is on instances defined over
        NTT-friendly fields
        <span class="math">\mathbb&#123;F&#125;_p</span>, where
        <span class="math">p = \sigma \cdot 2^m + 1</span> and
        efficient root-finding techniques are applicable. The
        reduced-round instances analyzed here originate from the
        Ethereum Foundation bug bounty program, as detailed on the
        official Poseidon initiative website [PI]. We apply our method
        to instances with 64-bit and 256-bit state sizes. In the
        64-bit setting, we employ the Graeffe-based root-finding
        approach described in Section 4, while for the 256-bit
        instances, we rely on the more traditional algebraic method
        outlined in Section 3. In both settings, we demonstrate that
        our root-finding strategy can recover a preimage (or
        equivalently, solve the CICO-1 problem).
      </p>

      <p class="text-gray-300">
        The remainder of this section details the specific parameters
        used, the reduction in rounds, and the computational results
        achieved by our attack. These primes were chosen for their
        NTT-friendly properties, enabling efficient polynomial
        operations and root-finding algorithms in our attack. The
        factorizations of
        <span class="math">p - 1</span> support the use of
        large-order multiplicative subgroups, which are essential for
        the Graeffe transform techniques discussed in Section 4.
      </p>

      <p class="text-gray-300">
        Attack running times were measured on a machine equipped with
        an AMD EPYC 9374F 32-core processor, 1.1 TB of RAM, and 8
        NVIDIA L4 GPUs, each with 23 GiB of memory. The AWS cloud
        instance closest to this hardware configuration is the
        g6.48xlarge, featuring 192 vCPUs, 768 GiB of memory, and 8
        NVIDIA L4 GPUs, priced at $13.35/h on-demand.
      </p>

      <h4 class="text-lg font-semibold mt-6 mb-3">
        Poseidon-256
      </h4>

      <p class="text-gray-300">
        The Poseidon bounty instances for the 256-bit state size are
        defined over the scalar field
        <span class="math">\mathbb&#123;F&#125;_p</span> of the
        BLS12-381 elliptic curve [Bow17], where
      </p>

      <div class="math-block">
        p - 1 = 2^&#123;32&#125; \cdot 3 \cdot 11 \cdot 19 \cdot
        10177 \cdot 125527 \cdot 859267 \cdot 906349^2 \cdot
        2508409 \cdot 2529403 \cdot 52437899 \cdot 254760293^2
      </div>

      <p class="text-gray-300">
        We examine the computational cost and resource demands of
        solving each bounty instance detailed in Table 1.
      </p>

      <!-- TABLE 1 -->

      <div class="overflow-x-auto my-6">
        <table class="w-full text-sm">
          <caption class="text-gray-400 text-xs mb-2 text-left">
            <strong>Table 1.</strong> Parameters and attack cost
            summary for Poseidon reduced-round instances at security
            level
            <span class="math">\kappa</span>. Running time measured
            on a machine equipped with an AMD EPYC 9374F 32-core
            processor, 1.1 TB of RAM, and 8 NVIDIA L4 GPUs, each
            with 23 GiB of memory.
          </caption>
          <thead>
            <tr class="border-b border-gray-700 text-gray-400">
              <th class="py-2 px-3 text-left">Instance</th>
              <th class="py-2 px-3 text-left">Field</th>
              <th class="py-2 px-3 text-right">Bits</th>
              <th class="py-2 px-3 text-right">
                <span class="math">d</span>
              </th>
              <th class="py-2 px-3 text-right">
                <span class="math">T</span>
              </th>
              <th class="py-2 px-3 text-right">
                <span class="math">R_F</span>
              </th>
              <th class="py-2 px-3 text-right">
                <span class="math">R_P</span>
              </th>
              <th class="py-2 px-3 text-right">
                <span class="math">\kappa</span>
              </th>
              <th class="py-2 px-3 text-right">CI</th>
              <th class="py-2 px-3 text-right">CO</th>
              <th class="py-2 px-3 text-center">GPU</th>
              <th class="py-2 px-3 text-right">Interp.</th>
              <th class="py-2 px-3 text-right">Root Find.</th>
            </tr>
          </thead>
          <tbody class="text-gray-300">
            <tr class="border-b border-gray-800">
              <td class="py-2 px-3">P_6_8</td>
              <td class="py-2 px-3">BLS12-381</td>
              <td class="py-2 px-3 text-right">256</td>
              <td class="py-2 px-3 text-right">5</td>
              <td class="py-2 px-3 text-right">3</td>
              <td class="py-2 px-3 text-right">6</td>
              <td class="py-2 px-3 text-right">8</td>
              <td class="py-2 px-3 text-right">24</td>
              <td class="py-2 px-3 text-right">1</td>
              <td class="py-2 px-3 text-right">1</td>
              <td class="py-2 px-3 text-center">Yes</td>
              <td class="py-2 px-3 text-right">45s</td>
              <td class="py-2 px-3 text-right">
                9h 17m*
              </td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 px-3">P_6_9</td>
              <td class="py-2 px-3">BLS12-381</td>
              <td class="py-2 px-3 text-right">256</td>
              <td class="py-2 px-3 text-right">5</td>
              <td class="py-2 px-3 text-right">3</td>
              <td class="py-2 px-3 text-right">6</td>
              <td class="py-2 px-3 text-right">9</td>
              <td class="py-2 px-3 text-right">24</td>
              <td class="py-2 px-3 text-right">1</td>
              <td class="py-2 px-3 text-right">1</td>
              <td class="py-2 px-3 text-center">Yes</td>
              <td class="py-2 px-3 text-right">45s</td>
              <td class="py-2 px-3 text-right">
                2d 18h 10m
              </td>
            </tr>
          </tbody>
        </table>
        <p class="text-gray-500 text-xs mt-1">
          *Our solution was not the first on this instance
          (P_6_8).
        </p>
      </div>

      <p class="text-gray-300">
        Since each scalar in the BLS12-381 implementation requires 32
        bytes of storage, applying the 2-round attack to each bounty
        instance involves interpolating a univariate polynomial of
        degree
        <span class="math">5^&#123;R_F + R_P - 2&#125;</span>.
        Specifically, the polynomials interpolating the instances 6_8
        and 6_9 require approximately 7.3 GiB and 36.4 GiB of
        memory, respectively.
      </p>

      <p class="text-gray-300">
        To benefit from the efficiency of radix-2 transforms, we pad
        polynomials with zeros to the nearest power-of-two length
        before applying the NTT. Consequently, the interpolated
        polynomials are represented as vectors of size
        <span class="math">2^&#123;28&#125;</span> and
        <span class="math">2^&#123;31&#125;</span> for instances 6_8
        and 6_9, respectively, each entry occupying 32 bytes. All
        implemented polynomial arithmetic primitives are optimized to
        use NTTs whose sizes are at most twice the size of their
        input polynomials. Therefore, for these bounty instances, we
        will handle multiple NTTs of sizes
        <span class="math">2^&#123;29&#125;</span> and
        <span class="math">2^&#123;32&#125;</span>, respectively,
        reaching the finite field supported 2-radix NTT size limit
        of <span class="math">2^&#123;32&#125;</span> for the
        application of the fast 2-radix algorithm.
      </p>

      <p class="text-gray-300">
        Unfortunately, execution-time measurements for the NTL-based
        GCD computations are no longer available. However, this step
        required a few hours of computation on a single CPU core for
        the 6_8 instance and around 3 days for 6_9. Since the GCD
        step does not require GPU acceleration, we estimate its
        computational cost independently, using a CPU-only AWS
        instance (r5.24xlarge), featuring 96 vCPUs, 768 GiB RAM,
        priced at $6.05/h on-demand. We remark that enabling parallel
        execution or optimizing further this GCD implementation could
        significantly reduce this machine cost overhead.
      </p>

      <p class="text-gray-300">
        This results in a total estimated attack cost of:
      </p>

      <ul class="list-disc list-inside text-gray-300 space-y-2
        ml-4">
        <li>
          Instance P_6_8: $185, computed as 9h17m at $13.35/h plus
          an additional 10h at $6.05/h. The bounty prize was set at
          $4000.
        </li>
        <li>
          Instance P_6_9: $1101, computed as 2d18h10m at $13.35/h
          plus an additional 36h at $6.05/h. The bounty prize was
          set at $6000.
        </li>
      </ul>

      <p class="text-gray-300 mt-4">
        We note that these attacks were performed using the classical
        strategy described in Subsection 3.1, without employing the
        potential optimizations afforded by the Graeffe transform, as
        outlined in Section 4. As a result, the reported cost and
        time estimates may be conservative. Investigating the
        potential improvements achievable through the use of
        Graeffe-based methods is left as future work.
      </p>

      <h4 class="text-lg font-semibold mt-6 mb-3">
        Poseidon2-64
      </h4>

      <p class="text-gray-300">
        The Poseidon2 bounty instances for 64-bit state size are
        defined over the Goldilocks prime field
        <span class="math">\mathbb&#123;F&#125;_p</span>, where
      </p>

      <div class="math-block">
        p - 1 = 2^&#123;32&#125; \cdot 3 \cdot 5 \cdot 17 \cdot
        257 \cdot 65537
      </div>

      <p class="text-gray-300">
        As presented in [SV25], our attacks targeted the CICO-1
        Poseidon2 bounty instance at the 24-bit security level,
        proposed as part of the Ethereum Foundation&rsquo;s bounty
        program. In Table 2 we summarize the relevant parameters for
        this instance, including its S-box degree
        <span class="math">d</span>, number of rounds, and
        constraint configuration, along with the measured running
        times of our attack on high-performance GPU-equipped
        hardware.
      </p>

      <!-- TABLE 2 -->

      <div class="overflow-x-auto my-6">
        <table class="w-full text-sm">
          <caption class="text-gray-400 text-xs mb-2 text-left">
            <strong>Table 2.</strong> Parameters and attack cost
            summary for Poseidon2 reduced-round instances. Running
            time measured on a machine equipped with an AMD EPYC
            9374F 32-core processor, 1.1 TB of RAM, and 8 NVIDIA
            L4 GPUs, each with 23 GiB of memory.
          </caption>
          <thead>
            <tr class="border-b border-gray-700 text-gray-400">
              <th class="py-2 px-3 text-left">Instance</th>
              <th class="py-2 px-3 text-left">Field</th>
              <th class="py-2 px-3 text-right">Bits</th>
              <th class="py-2 px-3 text-right">
                <span class="math">d</span>
              </th>
              <th class="py-2 px-3 text-right">
                <span class="math">T</span>
              </th>
              <th class="py-2 px-3 text-right">
                <span class="math">R_F</span>
              </th>
              <th class="py-2 px-3 text-right">
                <span class="math">R_P</span>
              </th>
              <th class="py-2 px-3 text-right">
                <span class="math">\kappa</span>
              </th>
              <th class="py-2 px-3 text-right">CI</th>
              <th class="py-2 px-3 text-right">CO</th>
              <th class="py-2 px-3 text-center">GPU</th>
              <th class="py-2 px-3 text-right">Interp.</th>
              <th class="py-2 px-3 text-right">Root Find.</th>
            </tr>
          </thead>
          <tbody class="text-gray-300">
            <tr class="border-b border-gray-800">
              <td class="py-2 px-3">P2_6_7</td>
              <td class="py-2 px-3">Goldilocks</td>
              <td class="py-2 px-3 text-right">64</td>
              <td class="py-2 px-3 text-right">7</td>
              <td class="py-2 px-3 text-right">8</td>
              <td class="py-2 px-3 text-right">6</td>
              <td class="py-2 px-3 text-right">7</td>
              <td class="py-2 px-3 text-right">24</td>
              <td class="py-2 px-3 text-right">1</td>
              <td class="py-2 px-3 text-right">1</td>
              <td class="py-2 px-3 text-center">Yes</td>
              <td class="py-2 px-3 text-right">20m</td>
              <td class="py-2 px-3 text-right">
                9h 38m*
              </td>
            </tr>
          </tbody>
        </table>
        <p class="text-gray-500 text-xs mt-1">
          *Our solution was not the first submitted for this
          instance (P2_6_7).
        </p>
      </div>

      <p class="text-gray-300">
        In contrast to Poseidon-256, only a single round can be
        skipped in Poseidon2 instances (see Subsection 5.1), and the
        higher S-Box degree further increases the memory requirements
        for polynomial arithmetic. The univariate transformation of
        the permutation
        <span class="math">P_2</span> yields a polynomial of degree
        <span class="math">7^&#123;6+7-1&#125; \approx 2^&#123;33.7&#125;</span>,
        which significantly exceeds the maximum size limit of a
        radix-2 NTT over the field, capped at
        <span class="math">2^&#123;32&#125;</span>. As a
        consequence, it becomes necessary to employ mixed-radix NTTs
        capable of handling sizes up to
        <span class="math">q \cdot 2^&#123;32&#125;</span>, with
        <span class="math">q</span> a small integer, allowing the
        efficient radix-2 NTT algorithm to be used for the radix-2
        component of the computation.
      </p>

      <p class="text-gray-300">
        However, <span class="math">q</span> must be chosen large
        enough to accommodate all NTT sizes required at various
        stages of Algorithm 2, including the Graeffe transforms, the
        NTT of size <span class="math">s</span> (we employ
        Bluestein&rsquo;s Algorithm to deal with NTT sizes not
        dividing
        <span class="math">q \cdot 2^&#123;32&#125;</span>), and
        any corresponding padded sizes needed during computation
        (for example, in order to perform NTT of size
        <span class="math">s</span> using Bluestein&rsquo;s
        algorithm, we must support sizes exceeding
        <span class="math">2s</span>). In order to attack the
        P2_6_7 instance, we chose
        <span class="math">q = 15</span>.
      </p>

      <p class="text-gray-300">
        Another important consideration is the choice of parameters
        <span class="math">r = 2^k</span> and
        <span class="math">s</span> such that
        <span class="math">r \cdot s = p - 1</span>. This selection
        is influenced by the resulting degree
        <span class="math">d</span> of the attacked polynomial,
        since each Graeffe transform of order 2 requires three NTTs
        of size <span class="math">d</span>, amounting to a total of
        <span class="math">3k</span> NTTs. This cumulative cost must
        be balanced against the single NTT of size
        <span class="math">s</span>, which can be treated as a
        constant overhead provided it falls within the limits
        supported by mixed-radix NTT implementations.
      </p>

      <p class="text-gray-300">
        In the attack on the P2_6_7 instance, we selected
        <span class="math">r = 2^&#123;30&#125;</span> and
        <span class="math">s = 4(2^&#123;32&#125; - 1)</span>,
        resulting in an approximate runtime of 17 minutes for each
        Graeffe transform of order 2, and about one hour for the
        final Bluestein&rsquo;s NTT of size
        <span class="math">s</span>. At the time of this attack, the
        Graeffe transform implementation was sub-optimal, as it
        followed the original definition: computing the product of
        two polynomials of degree
        <span class="math">d</span>, thereby requiring three NTTs of
        size <span class="math">2d</span>. However, by noting that
        the Graeffe transform of order 2 satisfies the identity
      </p>

      <div class="math-block">
        G_2(P) = (-1)^d \left( P_e(x)^2 - x P_o(x)^2 \right)
      </div>

      <p class="text-gray-300">
        where
        <span class="math">P(x) = P_e(x^2) + x \cdot P_o(x^2)</span>,
        we can reduce the computational cost by performing only three
        NTTs of size <span class="math">d</span> instead. As a
        result, we expect the total runtime of the attack to be
        reduced by approximately half compared to the time reported
        in Table 2. Verifying this performance improvement is left as
        future work.
      </p>

      <p class="text-gray-300 mt-4">
        This results in a total estimated attack cost of:
      </p>

      <ul class="list-disc list-inside text-gray-300 space-y-2
        ml-4">
        <li>
          Instance P2_6_7: $133, computed as 9h58m at $13.35/h. The
          bounty prize was set at $4000.
        </li>
      </ul>
    </section>

    <!-- ============================================================ -->
    <!-- 6. CONCLUSION                                                -->
    <!-- ============================================================ -->

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6. Conclusion</h2>

      <p class="text-gray-300">
        We have presented a root-finding strategy based on the
        Graeffe transform, tailored to instances of the Poseidon and
        Poseidon2 permutations instantiated over NTT-friendly prime
        fields. By exploiting the specific algebraic structure of
        these constructions, the proposed method streamlines the root
        recovery process in interpolation attacks and demonstrates
        its practical effectiveness by successfully solving the
        CICO-1 problem for reduced-round instances proposed by the
        Ethereum Foundation within the Poseidon Cryptanalysis
        Initiative.
      </p>

      <p class="text-gray-300">
        This work underscores the importance of comprehensive
        security evaluations for cryptographic permutations,
        particularly when deployed over structured fields that may
        enable specialized algebraic attacks. Future research
        directions include extending these techniques to broader
        parameter ranges and to other permutation-based primitives,
        with the aim of further understanding their security
        properties.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ul class="text-sm text-gray-400 space-y-3 ml-2 list-none">
        <li>
          <span class="text-gray-500">[BBLP22]</span>
          Bariant, A., Bouvier, C., Leurent, G., Perrin, L.:
          Algebraic attacks against some
          arithmetization-oriented primitives. IACR Transactions
          on Symmetric Cryptology 2022(3), 73&ndash;101 (9 2022).
          <a href="https://doi.org/10.46586/tosc.v2022.i3.73-101"
            target="_blank" rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300">
            doi:10.46586/tosc.v2022.i3.73-101</a>
        </li>
        <li>
          <span class="text-gray-500">[Bow17]</span>
          Bowe, S.: BLS12-381: New zk-SNARK Elliptic Curve
          Construction (2017).
          <a href="https://electriccoin.co/blog/new-snark-curve/"
            target="_blank" rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300">
            electriccoin.co/blog/new-snark-curve/</a>
        </li>
        <li>
          <span class="text-gray-500">[GHL15]</span>
          Grenet, B., van der Hoeven, J., Lecerf, G.: Randomized
          root finding over finite FFT-fields using tangent
          Graeffe transforms. In: Proceedings of the 2015 ACM
          International Symposium on Symbolic and Algebraic
          Computation. pp. 197&ndash;204. ISSAC &rsquo;15,
          ACM (2015).
          <a href="https://doi.org/10.1145/2755996.2756647"
            target="_blank" rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300">
            doi:10.1145/2755996.2756647</a>
        </li>
        <li>
          <span class="text-gray-500">[GKR+21]</span>
          Grassi, L., Khovratovich, D., Rechberger, C., Roy, A.,
          Schofnegger, M.: Poseidon: A new hash function for
          zero-knowledge proof systems. In: Bailey, M.,
          Greenstadt, R. (eds.) USENIX Security 2021.
          pp. 519&ndash;535. USENIX Association (Aug 2021)
          <a href="/papers/poseidon-2019"
            class="text-blue-400 hover:text-blue-300"
          >[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[GKS23]</span>
          Grassi, L., Khovratovich, D., Schofnegger, M.:
          Poseidon2: A faster version of the Poseidon hash
          function. In: El Mrabet, N., De Feo, L., Duquesne, S.
          (eds.) AFRICACRYPT 23. LNCS, vol. 14064,
          pp. 177&ndash;203. Springer, Cham (Jul 2023).
          <a href="https://doi.org/10.1007/978-3-031-37679-5_8"
            target="_blank" rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300">
            doi:10.1007/978-3-031-37679-5_8</a>
          <a href="/papers/poseidon2-2023"
            class="text-blue-400 hover:text-blue-300"
          >[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[GLR+20]</span>
          Grassi, L., L&uuml;ftenegger, R., Rechberger, C.,
          Rotaru, D., Schofnegger, M.: On a generalization of
          substitution-permutation networks: The HADES design
          strategy. In: Canteaut, A., Ishai, Y. (eds.)
          EUROCRYPT 2020, Part II. LNCS, vol. 12106,
          pp. 674&ndash;704. Springer, Cham (May 2020).
          <a href="https://doi.org/10.1007/978-3-030-45724-2_23"
            target="_blank" rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300">
            doi:10.1007/978-3-030-45724-2_23</a>
          <a href="/papers/hades-2019"
            class="text-blue-400 hover:text-blue-300"
          >[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[GRS+25]</span>
          Grassi, L., Rechberger, C., Schofnegger, M.,
          Khovratovich, D.: Survey of cryptanalytic attacks on
          Poseidon and Poseidon2 (2025), available at:
          <a href="https://drive.google.com/file/d/1bqmIk5I8s-4S9TQJO0xk26fnSSU0q_Hx/view"
            target="_blank" rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300">
            Google Drive</a>
        </li>
        <li>
          <span class="text-gray-500">[HM20]</span>
          van der Hoeven, J., Monagan, M.: Implementing the
          tangent Graeffe root finding method. In: Bigatti, A.M.,
          Carette, J., Davenport, J.H., Joswig, M., de Wolff, T.
          (eds.) Mathematical Software &ndash; ICMS 2020.
          pp. 482&ndash;492. Springer International Publishing,
          Cham (2020)
        </li>
        <li>
          <span class="text-gray-500">[HM21]</span>
          van der Hoeven, J., Monagan, M.: Computing one billion
          roots using the tangent Graeffe method. ACM Commun.
          Comput. Algebra 54(3), 65&ndash;85 (Mar 2021).
          <a href="https://doi.org/10.1145/3457341.3457342"
            target="_blank" rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300">
            doi:10.1145/3457341.3457342</a>
        </li>
        <li>
          <span class="text-gray-500">[PI]</span>
          Poseidon initiative.
          <a href="https://www.poseidon-initiative.info/"
            target="_blank" rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300">
            https://www.poseidon-initiative.info/</a>,
          accessed: 2025-05-16
        </li>
        <li>
          <span class="text-gray-500">[SV25]</span>
          Sanso, A., Vitto, G.: Poseidon over finite FFT-fields:
          Leveraging Graeffe transform FTW. Talk at Algebraic Hash
          Cryptanalysis Days, Eurocrypt Affiliated Event (2025),
          Madrid, Spain
        </li>
      </ul>
    </section>
  </article>
</BaseLayout>
