---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/907';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Proving the correct execution of concurrent services in zero-knowledge';
const AUTHORS_HTML = 'Srinath Setty, Sebastian Angel, Trinabh Gupta, Jonathan Lee';

const CONTENT = `    <p class="text-gray-300">Srinath Setty^{⋆}, Sebastian Angel^{⋆⋄}, Trinabh Gupta^{⋆†}, and Jonathan Lee^{⋆} ^{⋆}Microsoft Research ^{⋄}University of Pennsylvania ^{†}UCSB</p>

    <p class="text-gray-300">Abstract. This paper introduces Spice, a system for building <em>verifiable state machines (VSMs)</em>. A VSM is a request-processing service that produces proofs establishing that requests were executed correctly according to a specification. Such proofs are <em>succinct</em> (a verifier can check them efficiently without reexecution) and <em>zero-knowledge</em> (a verifier learns nothing about the content of the requests, responses, or the internal state of the service). Recent systems for proving the correct execution of stateful computations—Pantry <em>[25]</em>, Geppetto <em>[35]</em>, CTV <em>[31]</em>, vSQL <em>[88]</em>, etc.—implicitly implement VSMs, but they incur prohibitive costs. Spice reduces these costs significantly with a new storage primitive. More notably, Spice’s storage primitive supports multiple writers, making Spice the first system that can succinctly prove the correct execution of concurrent services. We find that Spice running on a cluster of 16 servers achieves 488–1167 transactions/second for a variety of applications including inter-bank transactions <em>[28]</em>, cloud-hosted ledgers <em>[29]</em>, and dark pools <em>[66]</em>. This represents an 18,000–685,000<span class="math">\\times</span> higher throughput than prior work.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">We are interested in a system for building <em>verifiable state machines (VSMs)</em>. A VSM is similar to a traditional state machine except that it produces correctness proofs of its state transitions. Such proofs can be checked efficiently by a verifier without locally reexecuting state transitions and without access to the (plaintext) content of requests, responses, or the internal state of the machine. Consequently, VSMs enable a wide class of real-world services to prove their correct operation—without compromising privacy. For example, by appropriately programming state transitions, VSMs can implement verifiable versions of payment networks <em>[28, 64]</em>, dark pools <em>[66]</em>, ad exchanges <em>[4]</em>, blockchains and smart contracts <em>[12, 30, 50, 62]</em>, and any request-processing application that interacts with a database.</p>

    <p class="text-gray-300">There is an elegant solution to build VSMs by employing <em>efficient arguments</em> <em>[41, 44, 48, 49, 58, 61]</em>, a primitive that composes probabilistically checkable proofs (PCPs) <em>[6, 7]</em> with cryptography. Specifically, an untrusted service can maintain state (e.g., in a key-value store), run appropriate computations that manipulate that state in response to clients’ requests, and produce proofs that it faithfully executed each request on the correct state. Such proofs are <em>succinct</em>, in the sense that the proofs are small (e.g., constant-sized) and are efficient to verify. In some constructions, the proofs are <em>zero-knowledge</em> <em>[43]</em>, meaning that they reveal nothing beyond their validity: the state maintained by the service, along with the content of requests and responses, is kept private from a verifier.</p>

    <p class="text-gray-300">While the original theory is too expensive to implement, recent systems <em>[8, 14, 18, 25, 34, 35, 39, 51, 67, 69, 70, 71, 73, 76, 80, 81, 82, 83, 84, 89, 77]</em> make significant progress. Beyond reducing the costs of the theory by over <span class="math">10^{20}\\times</span>, some of them can prove the correct execution of stateful computations like MapReduce jobs and database queries.</p>

    <p class="text-gray-300">Despite this progress, the costs remain prohibitive: the service incurs several CPU-seconds per storage operation (e.g., put, get on a key-value store) when generating a proof of correct execution (§2.1, §7). This is over <span class="math">10^{6}\\times</span> slower than an execution that does not produce proofs. Besides costs, storage primitives in prior systems support only a single writer, which limits them to a sequential model of execution. Consequently, they cannot scale out with additional resources by processing requests concurrently; this limits throughput that applications built atop prior systems can achieve.</p>

    <p class="text-gray-300">We address these issues with <em>Spice</em>, a new system for building VSMs. Spice introduces a storage primitive with a key-value store interface, called <em>SetKV</em>, that is considerably more efficient than storage primitives used by prior systems (§3). Furthermore, SetKV admits concurrent writers with sequential consistency <em>[54]</em> (and in some cases linearizability <em>[46]</em>) semantics, and supports serializable transactions <em>[21, 65]</em>. This makes Spice the first system to build VSMs with support for a concurrent execution model (§4). Finally, we compose SetKV with prior and new techniques to ensure that a verifier can check the correct execution of requests using only cryptographic commitments that hide the content of requests, responses, and the state of the service (§3–5).</p>

    <p class="text-gray-300">In more detail, SetKV extends a decades-old mechanism for verifying the correctness of memories <em>[5, 23, 32, 36]</em>. SetKV is based on set data structures whereas prior systems employ (Merkle) trees <em>[25, 31]</em> or commitments <em>[35, 88]</em>. This has two implications. First, the cost of a storage operation is a constant under SetKV (when amortized over a batch of operations) whereas in prior storage primitives it is logarithmic <em>[25, 31]</em> or linear <em>[35, 88]</em> in the size of the state. Second, SetKV allows concurrent writers since operations on sets—such</p>

    <p class="text-gray-300">*This is the full version of [68]. This version includes additional details and security proofs in the appendices.</p>

    <p class="text-gray-300">as adding an element to a set—commute.</p>

    <p class="text-gray-300">We implement Spice atop a prior framework [1, 83]. A programmer can express a VSM in a broad subset of C (augmented with APIs for SetKV and transactions), and compile it to executables of clients that generate requests, servers that process those requests and generate proofs, and verifiers that check the correctness of responses by verifying proofs. We build several realistic applications with Spice: an inter-bank transaction service [28], a cloud-hosted ledger [29], and a dark pool [66]. Our experimental evaluation shows that Spice's VSMs are  <span class="math">29 - 2,000 \\times</span>  more CPU-efficient than the same VSMs built with prior work. Furthermore, they achieve  <span class="math">18,000 - 685,000 \\times</span>  higher throughput than prior work by employing multiple CPUs. Concretely, Spice's VSMs support 488-1167 transactions/second on a cluster of 16 machines, each with 32 CPU cores and 256 GB of RAM.</p>

    <p class="text-gray-300">Despite these advances, Spice has limitations. To achieve high throughput, Spice proves state transitions in batches, so one must wait for a batch to be verified before determining the correctness of any individual request, which introduces latency (§3, §7.2). The CPU cost to produce proofs remains large (§7.1, §7.3) when compared to an execution that does not produce proofs. Nevertheless, Spice opens the door to VSMs that support a concurrent model of computation and to many exciting applications.</p>

    <p class="text-gray-300">Spice's goal is to produce verifiable state machines (VSMs). We begin by reviewing state machines, which we use as an abstraction to represent a request-processing service. A state machine is specified by a tuple  <span class="math">(\\Psi, S_0)</span> , where  <span class="math">\\Psi</span>  is a deterministic program that encodes state transitions, and  <span class="math">S_0</span>  is the initial state of the machine (e.g., a set of key-value pairs). The state machine maintains its state with  <span class="math">S_{cur}</span> , which is initialized to  <span class="math">S_0</span> . When the machine receives a request  <span class="math">x</span> , it executes  <span class="math">\\Psi</span>  with  <span class="math">x</span>  and its state  <span class="math">S_{cur}</span>  as inputs; this mutates the state of the machine and produces a response  <span class="math">y</span> . More formally, the machine executes a request  <span class="math">x</span>  to produce a response  <span class="math">y</span>  as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(S _ {i}, y\\right) \\leftarrow \\Psi \\left(S _ {c u r}, x\\right) \\\\ \\mathcal {S} _ {c u r} \\leftarrow \\mathcal {S} _ {i} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">A state machine may execute a batch of requests concurrently to achieve a higher throughput. In such a case, the behavior of the state machine (i.e., the state after executing a batch of requests, and the responses produced by the machine) depends on the desired correctness condition for concurrent operations. In this paper we focus on sequential consistency [54] as the correctness condition for concurrent operations on single objects, and serializability for multi-object transactions [21, 65].</p>

    <p class="text-gray-300">A verifiable state machine permits the verification of state transitions without reexecution and without access</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> FIGURE 1—Overview of verifiable state machines (see text).</p>

    <p class="text-gray-300">to the (plaintext) contents of requests, responses, and the state of the machine  <span class="math">(S_{cur})</span> . Specifically, a VSM is a protocol involving a prover  <span class="math">\\mathcal{P}</span> , a set of clients that issue requests, and one or more verifiers  <span class="math">\\{\\mathcal{V}_1,\\dots ,\\mathcal{V}_\\ell \\}</span>  that check the correctness of the execution (clients can be verifiers). We depict this protocol in Figure 1; it proceeds as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  runs a state machine  <span class="math">(\\Psi, S_0)</span>  that processes requests concurrently and maintains its state on a persistent storage service (e.g., a key-value store).</li>

      <li>Clients issue a set of requests,  <span class="math">x_{1},\\ldots ,x_{m}</span> , concurrently to  <span class="math">\\mathcal{P}</span>  and get back responses,  <span class="math">y_{1},\\ldots ,y_{m}</span> .</li>

      <li>Each verifier  <span class="math">\\mathcal{V}_j</span>  receives an opaque trace from  <span class="math">\\mathcal{P}</span>  and runs a local check on the trace that outputs accept or reject. Concretely, the trace contains a commitment to the initial state of the machine, a commitment to the final state after executing the batch of requests, and a commitment and proof for each request-response pair. An efficient VSM must satisfy the following properties.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness. If  <span class="math">\\mathcal{P}</span>  is honest (i.e.,  <span class="math">\\mathcal{P}</span> 's behavior is equivalent to a correct execution of requests in a sequential order) then  <span class="math">\\mathcal{P}</span>  can make a  <span class="math">\\nu_{j}</span>  output true.</li>

      <li>Soundness. If  <span class="math">\\mathcal{P}</span>  errs (e.g., it does not execute  <span class="math">\\Psi</span>  or violates semantics of storage), then  <span class="math">\\operatorname*{Pr}[\\mathcal{V}_j</span>  outputs true]  <span class="math">\\leq \\epsilon</span> , where  <span class="math">\\epsilon</span>  is small (e.g.,  <span class="math">1/2^{128}</span> ).</li>

      <li>Zero-knowledge. The trace does not reveal anything to a verifier  <span class="math">\\mathcal{V}_j</span>  beyond the correctness of  <span class="math">\\mathcal{P}</span> , the number of requests executed by  <span class="math">\\mathcal{P}</span> , and the size of  <span class="math">\\mathcal{P}</span> 's state.</li>

      <li>Succinctness. The size of each entry in the trace should be small, ideally a constant (e.g., a few hundred bytes). The cost to a  <span class="math">\\nu_{j}</span>  to verify an entry is linear in the size of the entry (e.g., a few milliseconds of CPU-time).</li>

      <li>Throughput.  <span class="math">\\mathcal{P}</span>  should be able to execute (and generate proofs for) hundreds of requests/second.</li>

    </ul>

    <p class="text-gray-300">VSMs are related to recent systems for proving the correct execution of stateful computations [8, 25, 31, 35, 39,</p>

    <p class="text-gray-300">88]*. However, in prior systems: (1) <span class="math">\\mathcal{P}</span> lacks mechanisms to prove that it correctly executed requests concurrently, and (2) <span class="math">\\mathcal{P}</span> incurs high CPU costs to produce proofs. Consequently, prior systems do not satisfy our throughput requirement. We provide an overview of a prior system below, but note that Spice addresses both issues.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">2.1 A prior instantiation of VSMs</h3>

    <p class="text-gray-300">We now describe a prior system that implements VSMs; our goal is to introduce concepts necessary to describe Spice and to highlight why prior systems are inefficient. We focus on Pantry <em>[25]</em>; Section 8 discusses other work.</p>

    <p class="text-gray-300">Programming model and API. Pantry <em>[25]</em> follows the VSM protocol structure introduced above. In Pantry, a state machine’s program (i.e., <span class="math">\\Psi</span>) is expressed in a subset of C, which includes functions, structs, typedefs, pre-processor macros, if-else statements, loops (with static bounds), explicit type conversions, and standard integer and bitwise operations. For <span class="math">\\Psi</span> to interact with a storage service, Pantry augments the above C subset with several storage APIs; an example is the get and put API of a key-value store. Also, Pantry supports commit (and decommit) APIs to convert blobs of data (e.g., a request) into commitments (and back)—to hide data from verifiers.</p>

    <p class="text-gray-300">Mechanics. Pantry meets the correctness, soundness, zero-knowledge, and succinctness properties of VSMs (§2). To explain how, we provide an overview of Pantry’s machinery; we start with a toy computation.</p>

    <p class="text-gray-300">⬇ int increment(int x) { int y = x + 1; return y; }</p>

    <p class="text-gray-300">Pantry proceeds in three steps to execute a computation.</p>

    <p class="text-gray-300">(1) Express and compile. A programmer expresses the desired computation in the above subset of C, and uses Pantry’s compiler to transform the program into a low-level mathematical model of computation called algebraic constraints. This is essentially a system of equations where variables can take values from a finite field <span class="math">\\mathbb{F}_{p}</span> over a large prime <span class="math">p</span> (i.e., the set <span class="math">\\{0,\\,1,\\,\\ldots,\\,p-1\\}</span>). For the above toy computation, Pantry’s compiler produces the following system of equations (uppercase letters denote variables and lowercase letters denote concrete values):</p>

    <p class="text-gray-300">\\[ \\mathcal{C}=\\left\\{\\begin{array}[]{rcl}X-x&=0\\\\ Y-(X+1)&=&0\\\\ Y-y&=&0\\end{array}\\right\\} \\]</p>

    <p class="text-gray-300">A crucial property of this transformation is that the set of equations is <em>satisfiable</em>—there exists a solution (a setting of values to variables) to the system of equations—<em>if and only if</em> the output is correct. For the above constraint set, observe that if <span class="math">y=x+1</span>, <span class="math">\\{X\\leftarrow x,Y\\leftarrow y\\}</span> is a solution. If <span class="math">y\\neq x+1</span>, then there does not exist any solution and the constraint set is not satisfiable.</p>

    <p class="text-gray-300">(2) Solve. The prover <em>solves</em> the equations using the input <span class="math">x</span> provided by the client. In other words, the prover obtains an assignment for each of the variables in the system of equations and sends the output <span class="math">y</span> to the client.</p>

    <p class="text-gray-300">(3) Argue. The prover <em>argues</em> (or proves) that the system of equations has a solution (which by the above transformation property establishes that <span class="math">y</span> is the correct output of the computation with <span class="math">x</span> as the input). To prove that a system of equations is satisfiable, the prover could send its solution (i.e., values for each of the variables in the equation) to a verifier, and the verifier could check that each equation is satisfiable. However, this approach meets neither the succinctness nor the zero-knowledge requirement of VSMs: the size of the proof is linear in the running time of the computation, and the solution reveals inputs, outputs, and the internal state of the computation.</p>

    <p class="text-gray-300">To guarantee both properties, Pantry employs an argument protocol referred to as a zkSNARK <em>[22]</em> to encode the prover’s solution to the system of equations as a short proof. Furthermore, a zkSNARK is <em>non-interactive</em> and often supports <em>public verifiability</em>, meaning that anyone (acting as a verifier) can check the correctness of proofs without having to interact with the prover. Details of how these protocols work are elsewhere <em>[14, 18, 25, 45, 67, 83, 86]</em>; we first focus on costs and then discuss a subset of mechanisms in Pantry that are relevant to our work.</p>

    <p class="text-gray-300"><em>Pantry’s costs.</em> Since costs depend on the choice of argument protocol and Pantry implements several <em>[67, 70]</em>, we assume a recent protocol due to Groth <em>[45]</em>. The costs to a <span class="math">\\mathcal{V}_{j}</span> are small: the proof produced by <span class="math">\\mathcal{P}</span> and sent over the network to <span class="math">\\mathcal{V}_{j}</span> per <span class="math">\\Psi</span> is short (128 bytes); <span class="math">\\mathcal{V}_{j}</span>’s cost to validate a proof is only a few milliseconds of CPU-time. <span class="math">\\mathcal{P}</span>’s costs to produce a proof scale (roughly) linearly with the number of constraints of the program; concretely, this cost is <span class="math">\\approx</span>150<span class="math">\\mu</span>s of CPU-time per constraint.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">2.1.1 Interacting with external resources</h4>

    <p class="text-gray-300">A key limitation of the above algebraic constraint formalism is that it cannot handle interactions with the external “world” such as accessing disk, or sending and receiving packets over a network. To address this, Pantry relies on the concept of <em>exogenous computations</em>.</p>

    <p class="text-gray-300">An exogenous computation is a remote procedure call (RPC) to an external service, which can be used to read from a disk or interact with remote servers (using OS services). Such an external service is executed outside of the constraint formalism (hence the name). The RPC simply returns a response that is then assigned to appro</p>

    <p class="text-gray-300">priate variables in the constraint set of a computation. We illustrate this concept with an example below.</p>

    <p class="text-gray-300">Suppose that the computation is <span class="math">y=\\sqrt{x}</span>, where <span class="math">x</span> is a perfect square. Of course, one could represent the square-root function using constraints and apply the above machinery, but the resulting constraint set is highly verbose (which increases the prover’s cost to solve and argue). Exogenous computations offer a way to express the equivalent (and much cheaper) computation with:</p>

    <p class="text-gray-300">⬇ int sqrt(int x) { int y = RPC(SQRT, x); //exogenous computation assert(y*y == x); return y; }</p>

    <p class="text-gray-300">The above code compiles to the following constraint set:</p>

    <p class="text-gray-300">\\[ \\mathcal{C}=\\left\\{\\begin{array}[]{rcl}X-x&=0\\\\ (Y_{exo}\\cdot Y_{exo})-X&=&0\\\\ Y_{exo}-y&=&0\\end{array}\\right\\} \\]</p>

    <p class="text-gray-300">The prover computes <span class="math">\\sqrt{x}</span> outside of constraints (e.g., by running a Python program) and assigns the result to <span class="math">Y_{exo}</span> when solving the equations (Step 2). The assert statement becomes an additional constraint that essentially forces the prover to prove that it has verified the correctness of <span class="math">Y_{exo}</span>. A similar approach can be used to interact with services like databases. The challenge is defining an appropriate assert statement, as we discuss next.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">2.1.2 Handling state</h4>

    <p class="text-gray-300">As discussed above, exogenous computations enable a program <span class="math">\\Psi</span> to interact with a key-value store by issuing an RPC. This alone is insufficient because the prover is untrusted and can return any response to RPCs. For example, if the prover maintains a key-value store with the tuple <span class="math">(k,v)</span>, and <span class="math">\\Psi</span> issues an RPC(GET, k); the prover could return <span class="math">v^{\\prime}\\neq v</span>. Consequently, as in the above sqrt example, <span class="math">\\Psi</span> must verify the result of every RPC.</p>

    <p class="text-gray-300">To enable this verification, Pantry borrows the idea of <em>self-verifying</em> data blocks from untrusted storage systems: it names data blocks using their collision-resistant hashes (or <em>digests</em>). The following example takes as input a digest and increments the value of the corresponding data.</p>

    <p class="text-gray-300">⬇ Digest increment(Digest d) { // prover supplies value of block named by d int block = RPC(GETBLOCK, d); assert(d == Hash(block)); int new_block = block + 1; // supply to prover a new block and get digest Digest new_d = RPC(PUTBLOCK, new_block); assert(new_d == Hash(new_block)); return new_d; }</p>

    <p class="text-gray-300">Pantry abstracts these operations with two APIs: (1) PutBlock which takes as input a block of data and returns its digest, and (2) GetBlock which returns a previously stored block of data given its digest (these APIs take care of the RPC call and the appropriate asserts and invocations of the hash function). Atop this API, Pantry builds more expressive storage abstractions using prior ideas <em>[23, 40, 56, 60]</em>. To support RAM, Pantry encodes the state in a Merkle tree <em>[23, 60]</em>. To support a key-value store, Pantry uses a <em>searchable</em> Merkle tree: an AVL tree where internal nodes store a hash of their children. To read (or update) state in these tree-based storage primitives, the program executes a series of GetBlock (and PutBlock) calls starting with the root of the tree.</p>

    <p class="text-gray-300"><em>Hiding requests and responses.</em> The above storage primitive can be used to hide requests and responses from a verifier. Specifically, the prover keeps the plaintext requests and responses in its persistent storage and releases cryptographic commitments to requests and responses to a verifier. As in the increment example, a C program must take as input a commitment to a request, obtain the plaintext version of it using an RPC, and produce a commitment to the response. This logic is abstracted with the commit and decommit APIs.</p>

    <p class="text-gray-300">Costs. We now assess the cost of a key-value store operation under Pantry. A get(<span class="math">k</span>) makes <span class="math">\\lceil\\log_{2}n\\rceil</span> calls to GetBlock (where <span class="math">n</span> is the number of key-value pairs), and each GetBlock call requires encoding a hash function as constraints (to represent the assert statement that verifies the return value of the RPC); a put requires twice as many operations. Thus, a single get on a key-value store that supports as few as <span class="math">n=1</span>,000 entries requires 44,000 constraints (§7.1); this translates to 6.6 CPU-seconds for producing a proof. Furthermore, in Pantry the root of a Merkle tree is a point of contention so a batch of operations cannot execute concurrently.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.2 Outlook and roadmap</h3>

    <p class="text-gray-300">Given the overwhelming expense to execute (and produce a proof for) a simple storage operation when using a tree-based data structure, we believe that making meaningful progress requires revisiting mechanisms for verifying interactions with storage. In Section 3.1, we describe an entirely different way to verify storage operations that relies on a set—rather than a tree—data structure. In Section 3.2, we show how to employ this set-based storage primitive to realize efficient VSMs, and in Section 4 we show how, unlike Merkle trees, this set-based primitive allows requests to be processed concurrently. Finally, Section 5 describes how to instantiate the set-based storage primitive efficiently such that each get and put operation can be represented with about a thousand constraints.</p>

    <h2 id="sec-8" class="text-2xl font-bold">3 Efficient storage operations in VSMs</h2>

    <p class="text-gray-300">This section presents a new mechanism to handle storage operations in VSMs. We first discuss the design of a</p>

    <p class="text-gray-300">verifiable key-value store based on set data structures; the design itself is orthogonal to VSMs and can be used to build a stand-alone untrusted storage service. We then show to how to compose the new key-value store with prior machinery to realize efficient VSMs.</p>

    <h2 id="sec-9" class="text-2xl font-bold">3.1 SetKV: A verifiable key-value store</h2>

    <p class="text-gray-300">The goal of a verifiable key-value store is to enable an entity <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> to outsource a key-value store <span class="math">\\mathcal{K}</span> to an untrusted server <span class="math">\\mathcal{P}_{\\mathcal{K}}</span>, while being able to verify that interactions with <span class="math">\\mathcal{K}</span> are correct. Specifically, <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> receives operations from <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> and executes them on <span class="math">\\mathcal{K}</span> such that <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> can check that a get on a key returns the value written by the most recent put to that key. This protocol proceeds as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}_{\\mathcal{K}}</span> calls init to obtain an object that encodes the initial empty state of <span class="math">\\mathcal{K}</span>.</li>

      <li><span class="math">\\mathcal{V}_{\\mathcal{K}}</span> issues inserts, gets, and puts sequentially to <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> and receives responses. <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> locally updates its object for every request-response pair.</li>

      <li>After a batch of operations, <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> runs audit that computes over its local object (and auxiliary responses from <span class="math">\\mathcal{P}_{\\mathcal{K}}</span>), and outputs whether or not <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> operated correctly.</li>

    </ol>

    <p class="text-gray-300">We desire the following properties from this protocol.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> correctly executes operations on <span class="math">\\mathcal{K}</span>, then it can make <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>'s audit output true.</li>

      <li>If <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> errs, then <span class="math">\\operatorname{Pr}\\{\\text{audit outputs true}\\} &amp;lt; \\theta</span>, where <span class="math">\\theta</span> is very small (e.g., <span class="math">1/2^{128}</span>).</li>

      <li><span class="math">\\mathcal{V}_{\\mathcal{K}}</span> maintains little state (e.g., tens of bytes).</li>

    </ul>

    <p class="text-gray-300">Figure 2 depicts our construction. We call this construction SetKV for ease of reference, but note that it introduces small—albeit critical—changes to the offline memory checking scheme of Blum et al. [23] (and its follow-up refinement [32]) and the Concerto key-value store [5]. We discuss our modifications at the end of this subsection; these changes are necessary to build VSMs using SetKV (§3.2). We prove that SetKV meets all desired properties in Appendix C.1. Below, we describe how SetKV works starting with a straw man design.</p>

    <p class="text-gray-300">A straw man design. Suppose <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> maintains a totally-ordered log where it records all key-value operations it issues to <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> along with the responses supplied by <span class="math">\\mathcal{P}_{\\mathcal{K}}</span>. <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> can execute the following audit procedure: for each get on a key <span class="math">k</span> recorded in the log, identify the most recent put to <span class="math">k</span> (by traversing the log backwards starting from the point at which the get is recorded) and check if the value returned by the get matches the value written by the put. If all the checks pass, <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> outputs true.</p>

    <p class="text-gray-300">There are two issues with this straw man: (1) <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>'s log size is proportional to the number of key-value store operations and it grows indefinitely; (2) the cost to verify</p>

    <p class="text-gray-300">1: function init() 2: return <span class="math">s \\leftarrow \\text{VKState}\\{0, 0, 0\\}</span> 3: function insert <span class="math">(s, k, v)</span> 4: <span class="math">ts&#x27; \\leftarrow s.ts + 1</span> 5: RPC(INSERT, <span class="math">k</span>, <span class="math">(v, ts&#x27;)</span> ) // <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> executes INSERT on <span class="math">\\mathcal{K}</span> 6: <span class="math">ws&#x27; \\leftarrow s.ws \\odot \\mathcal{H}(\\{(k, v, ts&#x27;)\\})</span> 7: return VKState <span class="math">\\{s.rs, ws&#x27;, ts&#x27;\\}</span> 8: function get <span class="math">(s, k)</span> 9: <span class="math">(v, t) \\leftarrow \\text{RPC(GET}, k)</span> // <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> executes GET on <span class="math">\\mathcal{K}</span> 10: <span class="math">rs&#x27; \\leftarrow s.rs \\odot \\mathcal{H}(\\{(k, v, t)\\})</span> 11: <span class="math">ts&#x27; \\leftarrow \\max(s.ts, t) + 1</span> 12: RPC(PUT, <span class="math">k</span>, <span class="math">(v, ts&#x27;)</span> ) // <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> executes PUT on <span class="math">\\mathcal{K}</span> 13: <span class="math">ws&#x27; \\leftarrow s.ws \\odot \\mathcal{H}(\\{(k, v, ts&#x27;)\\})</span> 14: return VKState <span class="math">\\{rs&#x27;, ws&#x27;, ts&#x27;\\}, v</span> 15: function audit <span class="math">(s)</span> 16: <span class="math">rs&#x27; \\leftarrow s.rs</span> 17: keys <span class="math">\\leftarrow</span> RPC(GETKEYS) // <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> returns a list of keys in <span class="math">\\mathcal{K}</span> 18: for <span class="math">k</span> in keys do 19: <span class="math">(v, t) \\leftarrow \\text{RPC(GET}, k)</span> // <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> executes GET on <span class="math">\\mathcal{K}</span> 20: <span class="math">rs&#x27; \\leftarrow rs&#x27; \\odot \\mathcal{H}(\\{(k, v, t)\\})</span> 21: if keys has duplicates or <span class="math">rs&#x27; \\neq s.ws</span> then return false 22: else return true</p>

    <p class="text-gray-300">FIGURE 2—SetKV: A verifiable key-value store based on set data structures [5, 23, 32, 36]. The logic depicted here is run by <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>; <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> responds to RPCs. <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>'s state consists of two set-digests and a timestamp <span class="math">ts</span>; <span class="math">\\mathcal{H}</span> is an incremental set collision-resistant hash function; see text for details. A put is similar to get except that lines 11 and 13 use the value being written instead of <span class="math">v</span>.</p>

    <p class="text-gray-300">the correctness of each get is linear in the size of the log.</p>

    <p class="text-gray-300">Mechanics of SetKV. SetKV addresses both issues associated with the straw man. It lowers verification cost by relying on two sets instead of an append-only log, and it reduces the size of the state maintained by <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> by leveraging a particular type of cryptographic hash function that operates on sets. We elaborate on these next.</p>

    <p class="text-gray-300">(1) Using sets. Instead of a totally-ordered log, suppose that <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> maintains a local timestamp counter <span class="math">ts</span> along with two sets, a "read set" (RS) and a "write set" (WS). SetKV's key idea is to design a mechanism that combines all the checks in the straw man design (performed on the return value of each get using a log) into a single check on these two sets; if the server executes any operation incorrectly, the check fails. Of course, unlike the above log-based checks, if the set-based check fails, <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> will not know which particular operation was executed incorrectly by <span class="math">\\mathcal{P}_{\\mathcal{K}}</span>, but this dramatically reduces verification costs.</p>

    <p class="text-gray-300">Details of the set-based check. First, we structure the key-value store <span class="math">\\mathcal{K}</span> so that each entry is of the form <span class="math">(k, v, t)</span> where <span class="math">k</span> is a key, <span class="math">v</span> is the associated value, and <span class="math">t</span> is a timestamp (more precisely a Lamport clock [53]) that indicates the last time the key was read (or updated). <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> initializes RS and WS to empty, and <span class="math">ts</span> to 0. When <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> wants to insert a new key-value pair <span class="math">(k, v)</span> into <span class="math">\\mathcal{K}</span>, it increments the local timestamp <span class="math">ts</span>, adds the tuple <span class="math">(k, v, ts)</span></p>

    <p class="text-gray-300">into WS, and sends this tuple to <span class="math">\\mathcal{P}_{\\mathcal{K}}</span>. Similarly, when <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> wishes to execute a get (or a put) operation on an existing key <span class="math">k</span>, <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> performs the following five steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Get from <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> via an RPC the current value <span class="math">v</span> and timestamp <span class="math">t</span> associated with key <span class="math">k</span></li>

      <li>Add the tuple <span class="math">(k,v,t)</span> into RS</li>

      <li>Update the local timestamp <span class="math">ts\\leftarrow\\max(ts,t)+1</span></li>

      <li>Add the tuple <span class="math">(k,v^{\\prime},ts)</span> into WS (where <span class="math">v^{\\prime}=v</span> for a get, or the new value for a put)</li>

      <li>Send the new tuple <span class="math">(k,v^{\\prime},ts)</span> to <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> via an RPC</li>

    </ol>

    <p class="text-gray-300">Observe that the sets maintained by <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> preserve two important invariants: (1) every element added to RS and WS is unique because <span class="math">ts</span> is incremented after each operation; and (2) RS “trails” WS by exactly the last write to each key (i.e., <span class="math">RS\\subseteq\\textit{WS}</span>). These lead to an efficient audit procedure: <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> can request the current state of <span class="math">\\mathcal{K}</span> (i.e., the set of key, value, and timestamp tuples) from <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> (denote this returned set as <span class="math">M</span>), and check if:</p>

    <p class="text-gray-300"><span class="math">RS\\cup M=\\textit{WS}</span></p>

    <p class="text-gray-300">There is also a check in audit that verifies whether all the keys in <span class="math">M</span> are unique. This check prevents the following double insertion attack: if <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> issues to <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> an insert operation with a key that already exists in <span class="math">\\mathcal{K}</span>, a correct <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> should return an error message. However, a malicious <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> could return success for both inserts, and in the future, return either value for a get on such a key.</p>

    <p class="text-gray-300">Correctness intuition. We now use an example to provide intuition about the set-based check. Suppose that after initialization, <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> inserts a new key-value pair <span class="math">(k,v)</span> into <span class="math">\\mathcal{K}</span> (via the above protocol). <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>’s state will be:</p>

    <p class="text-gray-300"><span class="math">RS{=}\\{\\},WS{=}\\{(k,v,1)\\},ts{=}1</span></p>

    <p class="text-gray-300">If <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> runs the audit procedure, then a correct <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> can return its state, which in this case is simply <span class="math">M=\\{(k,v,1)\\}</span>. This leads <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>’s audit to return true since <span class="math">RS\\cup M{=}WS</span>, and the set of keys in <span class="math">M</span> has no duplicates. Suppose that <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> then calls get(<span class="math">k</span>) and <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> misbehaves by returning <span class="math">(v^{\\prime},1)</span> where <span class="math">v^{\\prime}\\neq v</span>. <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>’s state will be updated to:</p>

    <p class="text-gray-300"><span class="math">RS{=}\\{(k,v^{\\prime},1)\\},WS{=}\\{(k,v,1),(k,v^{\\prime},2)\\},ts{=}2</span></p>

    <p class="text-gray-300">Observe that for any set <span class="math">M</span>, <span class="math">RS\\cup M\\neq\\textit{WS}</span> (this is because <span class="math">RS\\not\\subseteq\\textit{WS}</span>). By returning an incorrect response, <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> permanently damaged its ability to pass a future audit.</p>

    <p class="text-gray-300">(2) Compressing <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>’s state. <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> cannot track the two sets explicitly since they are larger than <span class="math">\\mathcal{K}</span>. Instead, <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> employs a particular type of hash function <span class="math">\\mathcal{H}(\\cdot)</span> that acts on sets and produces a succinct set-digest <em>[9, 32]</em>. <span class="math">\\mathcal{H}</span> meets two properties. First, it is set collision-resistant, meaning that it is computationally infeasible to find two different sets that hash to the same set-digest. Second, <span class="math">\\mathcal{H}</span> is incremental: given a set-digest <span class="math">d_{S}</span> for a set <span class="math">S</span>, and a set <span class="math">W</span>, one can efficiently compute a set-digest for <span class="math">S\\cup W</span>. Specifically, there is an operation <span class="math">\\odot</span> (that takes time linear in the number of elements in <span class="math">W</span>) such that:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{H}(S\\cup W)</span> <span class="math">=\\mathcal{H}(S)\\odot\\mathcal{H}(W)</span> <span class="math">=d_{S}\\odot\\mathcal{H}(W)</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}_{\\mathcal{K}}</span> leverages <span class="math">\\mathcal{H}</span> to create (and incrementally update) set-digests that encode <span class="math">RS</span> and <span class="math">WS</span>, and it keeps these digests and the local timestamp in a small data structure:</p>

    <p class="text-gray-300">⬇ struct VKState { SetDigest rs; // a set-digest of RS SetDigest ws; // a set-digest of WS int ts; }</p>

    <p class="text-gray-300">The same correctness argument (discussed above) applies except that we must account for the case where <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> identifies a collision in <span class="math">\\mathcal{H}</span>, which can allow it to misbehave and still pass the audit. Fortunately, the probability that <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> can find any collision is very small (<span class="math">\\theta\\leq 2^{-128}</span>).</p>

    <p class="text-gray-300">Note that while the audit procedure (Figure 2) appears to require <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> to keep state linear in the size of <span class="math">\\mathcal{K}</span> to store the set of all keys (to check for duplicates), this is not the case. If getkeys (Fig. 2, Line 17) returns a sorted list of keys, the uniqueness check can be expressed as a streaming computation. Consequently, <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> only needs enough state for VKState, and the metadata required to track the status of the streaming computation; all of this is tens of bytes, which meets our requirement.</p>

    <p class="text-gray-300">Differences with prior designs. SetKV supports inserting any number of keys, whereas offline memory checking protocols <em>[23, 32, 36]</em> have a fixed memory size. To support insertion, we add the insert procedure, the getkeys RPC, and the uniqueness check (Figure 2, Line 21). To prevent <span class="math">\\mathcal{P}</span> from denying that a particular key has been inserted, and to disallow <span class="math">\\mathcal{P}</span> from maintaining a key-value store with duplicate keys, we have additional checks (Appendix A.4). Concerto <em>[5]</em> also supports inserts but it is more expensive than SetKV since it requires <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> to issue two additional RPCs per insert (and two additional calls to <span class="math">\\mathcal{H}</span> to update <span class="math">rs</span> and <span class="math">ws</span>) to maintain an index of keys, so Concerto’s approach is up to <span class="math">3\\times</span> more expensive than SetKV for <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>.</p>

    <p class="text-gray-300">Several prior schemes <em>[5, 23, 36]</em> use instances of <span class="math">\\mathcal{H}</span> that require <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> to use cryptographic material that must be kept secret from <span class="math">\\mathcal{P}_{\\mathcal{K}}</span>. While this is not an issue in the standalone setting presented in this section (since <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> updates set-digests locally), it is problematic in the VSM context where the prover <span class="math">\\mathcal{P}</span> executes these operations on behalf of clients (§3.2). In contrast, our construction of <span class="math">\\mathcal{H}</span> does not require secret cryptographic material (§5.2). Finally, the audit procedure of SetKV does not modify</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}_{\\mathcal{K}}</span>’s set-digests (as is the case in Concerto’s), which lowers the costs of audit by <span class="math">2\\times</span>.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">3.2 Building VSMs using SetKV</h3>

    <p class="text-gray-300">Spice follows an approach similar to Pantry to build VSMs. As with the Pantry baseline discussed in the prior section, Spice uses Groth’s argument protocol <em>[45]</em> as a black box (Spice can also use many other argument protocols, as we discuss in Section 9). The principal difference between the two systems is in how they handle storage operations, which we discuss next.</p>

    <p class="text-gray-300">Recall from Section 2.1 that a VSM’s program <span class="math">\\Psi</span> interacts with external services (e.g., a storage service) by issuing RPCs. Since the prover is untrusted and can return incorrect responses to RPCs, <span class="math">\\Psi</span> must verify each RPC response via an assert; Section 2.1.2 discusses the verification mechanism in Pantry. We now discuss an alternate mechanism based on SetKV.</p>

    <p class="text-gray-300">At a high level, Spice’s idea is to employ SetKV’s verifier (i.e., <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>) to check the interactions of <span class="math">\\Psi</span> with a storage service. To accomplish this, we build a C library that implements the init, insert, get, put, and audit procedures in Figure 2. A VSM programmer uses this library to write <span class="math">\\Psi</span>, and compiles <span class="math">\\Psi</span> into algebraic constraints (and client, server, verifier executables). To illustrate this idea, we start with an example in which <span class="math">\\Psi</span> increments an integer value associated with a key requested by a client.</p>

    <pre><code class="language-text">Value increment(VKState* s, Key k) {
Value v;
// prover supplies value v for key k
get(s, k, &amp;v); //setkv library call (updates s)
v = (Value) ((int) v + 1);
put(s, k, v); // setkv library call (updates s)

// batch-verify all storage operations
assert(audit(*s) == true); // setkv library call
return v;
}</code></pre>

    <p class="text-gray-300">Observe that the high-level structure of the above program is nearly identical to the example we discussed in the context of Pantry. A key difference, however, is that under Pantry, <span class="math">\\Psi</span> verifies each storage operation (e.g., GetBlock) with an assert; under Spice, <span class="math">\\Psi</span> verifies all storage operations at the end with a single assert that calls SetKV’s audit procedure.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Costs.</h4>

    <p class="text-gray-300">Since init, insert, get, and put execute a constant number of arithmetic operations (Figure 2), Spice compiles them into a constant number of equations when transforming <span class="math">\\Psi</span> into the constraint formalism. audit, however, computes over the entire state of the key-value store, so it compiles to a constraint set with size linear in the number of objects in the key-value store (say <span class="math">n</span>). Fortunately, audit is called only once, so its costs are amortized over all storage operations in <span class="math">\\Psi</span>.</p>

    <p class="text-gray-300">In more detail, if <span class="math">\\Psi</span> executes <span class="math">O(n)</span> storage operations before calling audit, the (amortized) cost of each storage operation is a constant. However, for the services that Spice targets (§1, §6), <span class="math">\\Psi</span> executes far fewer storage operations than <span class="math">n</span>. This leads to an undesirable situation: the amortized cost of a storage operation can be worse than in Pantry (where each storage operation’s cost is logarithmic in <span class="math">n</span>). Spice addresses this by decoupling the call to audit from the rest of <span class="math">\\Psi</span>. We discuss this below.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Spice’s VSMs.</h4>

    <p class="text-gray-300">Let <span class="math">\\Psi</span> be a program with the same structure as the previous increment example: <span class="math">\\Psi</span> takes as input a request <span class="math">x</span> and a VKState <span class="math">s</span>, interacts with the storage via RPCs, verifies those interactions at the end via assert, updates <span class="math">s</span>, and outputs a response <span class="math">y</span>. Spice splits <span class="math">\\Psi</span> into two independent programs: <span class="math">\\Psi_{req}</span> and <span class="math">\\Psi_{audit}</span>, where <span class="math">\\Psi_{req}</span> is same as <span class="math">\\Psi</span> except that it does not have the assert statement at the end; <span class="math">\\Psi_{audit}</span> is the following program:</p>

    <pre><code class="language-text">void audit_batch(VKState s) {
assert(audit(s) == true);
}</code></pre>

    <p class="text-gray-300">This decomposition achieves the following: proving the correct execution of <span class="math">m</span> instances of <span class="math">\\Psi</span> is equivalent to proving the correct execution of the corresponding <span class="math">m</span> instances of <span class="math">\\Psi_{req}</span> and a single instance of <span class="math">\\Psi_{audit}</span>. By equivalent, we mean that a verifier <span class="math">\\mathcal{V}</span> outputs true to <span class="math">m+1</span> proofs (one per instance of <span class="math">\\Psi_{req}</span> and <span class="math">\\Psi_{audit}</span>) if and only if <span class="math">\\mathcal{V}</span> would have output true to the <span class="math">m</span> proofs produced by instances of <span class="math">\\Psi</span>. Thus, if <span class="math">m</span>=<span class="math">O(n)</span>, the <span class="math">O(n)</span> constraints needed to express <span class="math">\\Psi_{audit}</span> are effectively amortized over the <span class="math">m</span> requests, making the (amortized) number of constraints for each storage operation in <span class="math">\\Psi_{req}</span> a constant. Note that the costs of <span class="math">\\Psi_{audit}</span> can actually be amortized across different computations (they can be instances of different <span class="math">\\Psi_{req}</span>).</p>

    <p class="text-gray-300">This approach has two drawbacks. First, it increases latency since <span class="math">\\mathcal{V}</span> confirms the correct execution of any given instance <span class="math">\\Psi_{req}</span> only after it has verified all <span class="math">m+1</span> proofs. Second, if the proof of <span class="math">\\Psi_{audit}</span> fails, <span class="math">\\mathcal{V}</span> does not learn which of the storage operations (and therefore which instance of <span class="math">\\Psi_{req}</span>) returned an incorrect result. However, as we show in our evaluation (§7), this decomposition reduces the cost of storage operations by orders of magnitude over Pantry, even for modest values of <span class="math">m</span>.</p>

    <p class="text-gray-300">Trace. Recall from Section 2 that each verifier <span class="math">\\mathcal{V}_{i}</span> receives a trace from <span class="math">\\mathcal{P}</span> to verify a batch of <span class="math">m</span> instances of <span class="math">\\Psi_{req}</span>. This trace contains <span class="math">m</span> tuples and a proof for <span class="math">\\Psi_{audit}</span>:</p>

    <p class="text-gray-300"><span class="math">(x_{i},s_{i-1},y_{i},s_{i},\\pi_{i})\\;\\forall i\\in[1,m]\\quad\\text{and}\\quad\\pi_{audit}</span></p>

    <p class="text-gray-300">where <span class="math">\\pi_{i}</span> is the proof of correct execution of the <span class="math">i^{th}</span> instance of <span class="math">\\Psi_{req}</span> with <span class="math">(s_{i-1},x_{i})</span> as input and <span class="math">(s_{i},y_{i})</span> as output. Each state <span class="math">s_{i}</span> is an object of type VKState (<span class="math">s_{0}</span> is a VKState object for an empty key-value store), <span class="math">x_{i}</span> is a request, and <span class="math">y_{i}</span> is the corresponding response. <span class="math">\\pi_{audit}</span> establishes the correct execution of <span class="math">\\Psi_{audit}</span> with <span class="math">s_{m}</span> as input.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Observe that the above trace is sufficient to guarantee correctness and soundness (since each <span class="math">\\mathcal{V}_{j}</span> has all the information needed to verify the actions of <span class="math">\\mathcal{P}</span>), but it does not satisfy zero-knowledge or succinctness. This trace is not succinct since the sizes of requests and responses could be large (they depend on the application). The trace is not zero-knowledge since requests and responses appear in plaintext. Moreover, a VKState object leaks the timestamp field and the set-digests (unlike commitments, hashes bind the input but do not hide it; see Footnote 1).</p>

    <p class="text-gray-300">Commitments. To make the trace succinct and zero-knowledge, a programmer writes a VSM that takes as input (and produce as output) commitments to requests, responses, and VKState. For example, the programs <span class="math">\\Psi_{req}</span> and <span class="math">\\Psi_{audit}</span> discussed earlier are expressed as:</p>

    <p class="text-gray-300">⬇ Commitment incr_comm(Commitment<em> cs, Commitment ck) { // prover passes value via RPC (checked by assert) VKState s = (VKState) decommit(</em>cs); Key k = (Key) decommit(ck); Value v = increment(&s, k); // prior program logic *cs = commit(s); return commit(v); }</p>

    <p class="text-gray-300">void audit_batch_comm(Commitment cs) { VKState s = (VKState) decommit(cs); audit_batch(s); // prior program logic }</p>

    <p class="text-gray-300">In more detail, a client sends to <span class="math">\\mathcal{P}</span> the plaintext request <span class="math">x_{i}</span> (<span class="math">k</span> in the example). <span class="math">\\mathcal{P}</span> computes the program (without commitments) outside of the constraint formalism and sends back to the client the output <span class="math">y_{i}</span> (<span class="math">v</span> in the example). <span class="math">\\mathcal{P}</span> then generates a proof <span class="math">\\pi_{i}</span> for the version of the program that uses commitments (incr_comm in the example). Specifically, <span class="math">\\mathcal{P}</span> first generates a commitment to <span class="math">x_{i}</span> outside of the constraint formalism and uses it to solve the constraint set of <span class="math">\\Psi_{req}</span> (Section 9 discusses what prevents <span class="math">\\mathcal{P}</span> from omitting requests or generating an incorrect commitment). <span class="math">\\mathcal{P}</span> then adds to its trace commitments to each of <span class="math">(s_{i},x_{i},y_{i})</span> and the corresponding proof <span class="math">\\pi_{i}</span>. Each verifier <span class="math">\\mathcal{V}_{j}</span> uses these commitments—instead of their plaintext versions—when verifying proofs (including <span class="math">\\pi_{audit}</span>), since the above programs use commitments as inputs and outputs. Thus, a verifier <span class="math">\\mathcal{V}_{j}</span> does not learn anything about the requests, responses, or states beyond their correctness, the number of requests, and the size of the state. Also, since the size of each commitment and each proof is a constant, it satisfies the succinctness property of VSMs.</p>

    <h2 id="sec-13" class="text-2xl font-bold">4 Supporting concurrent services</h2>

    <p class="text-gray-300">Prior instantiations of VSMs—including our design in Section 3—do not support a prover <span class="math">\\mathcal{P}</span> that executes requests concurrently. A key challenge is producing proofs that establish that <span class="math">\\mathcal{P}</span> met a particular consistency semantic. Note that this problem is hard even without the zero-knowledge or succinctness requirements of VSMs <em>[75]</em>.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">4.1 Executing requests concurrently</h3>

    <p class="text-gray-300">To make <span class="math">\\mathcal{P}</span> execute requests concurrently, we introduce a concurrent version of SetKV, called C-SetKV, which we later integrate with Spice’s design from the prior section.</p>

    <p class="text-gray-300">C-SetKV’s prover <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> interacts with multiple instances of <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> (<span class="math">\\mathcal{V}_{\\mathcal{K}}^{(0)},\\ldots,\\mathcal{V}_{\\mathcal{K}}^{(\\ell)}</span>) that issue insert, put, and get requests concurrently. C-SetKV guarantees sequential consistency <em>[54]</em>: an audit returns true if and only if the concurrent execution is equivalent to a sequential execution of operations and the sequential execution respects the order of operations issued by individual instances of <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>. In a few cases, C-SetKV guarantees linearizability <em>[46]</em>. We formalize these guarantees and provide details in Appendix C.2, but the key differences between C-SetKV and SetKV are:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Enforcement of isolation. In SetKV (Figure 2), <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> issues two RPCs for each get and put; they are executed in isolation by a correct <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> because there is only one outstanding operation. In C-SetKV, <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> must explicitly ensure that both RPCs are executed in isolation since it receives and executes many concurrent operations.</li>

      <li>Support for independent VKStates. In SetKV, <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> maintains a single VKState object that encodes its key-value store operations since initialization. In C-SetKV, each <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(j)}</span> has its own independent VKState object that contains only the effects of operations issued by <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(j)}</span>.</li>

    </ol>

    <p class="text-gray-300">We discuss the details of these differences below.</p>

    <p class="text-gray-300">Enforcement of isolation. We now discuss how a correct <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> can execute C-SetKV’s four key-value store operations in isolation. It is straightforward to execute insert in isolation since it issues a single RPC. audit does not modify <span class="math">\\mathcal{P}_{\\mathcal{K}}</span>’s state, so <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> can executes it in isolation using a snapshot of its state. To ensure the two RPCs of put and get execute in isolation (in the presence of multiple instances of <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>), <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> can keep track of when the first RPC starts and block any other request that attempts to operate on the same key until the second RPC (for the same key) completes. A simple approach to achieve this is for <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> to lock a key during the first RPC and release the lock on the second RPC. A malicious <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> could of course choose not to guarantee isolation, but as we show in Appendix C.2, a future audit will fail. Note that in Spice, <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> corresponds to the external storage, so the mechanism that ensures isolation happens outside of the constraint formalism (i.e., it is not encoded in <span class="math">\\Psi</span>).</p>

    <p class="text-gray-300">Support for independent VKStates. Since each <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(j)}</span> issues requests independently, it maintains a local VKState object. This creates two issues. First, the set-digests and timestamp in the VKState object of <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(j)}</span> do not capture the operations issued by other instances of <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>. As a result, we need a mechanism to combine the VKState objects of</p>

    <p class="text-gray-300">all instances of <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> prior to invoking audit—since audit accepts a single VKState object. Second, the timestamp field <span class="math">ts</span> is no longer unique for each operation since each <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(j)}</span> initializes its VKState object with <span class="math">ts=0</span>. We discuss how we address these issues below.</p>

    <p class="text-gray-300">Combining VKState objects. To obtain a single VKState object, each <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(j)}</span> collects VKState objects from every other instance and locally combines all objects. Combining set-digests is possible because sets are unordered and the union operation is commutative. Moreover, <span class="math">\\mathcal{H}(\\cdot)</span> preserves this property since the operation <span class="math">\\odot</span> is commutative. As a result, each <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(j)}</span> constructs set-digests that capture the operations of all instances of <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> as if they were issued by a single entity. For example, the combined read set-digest is computed as <span class="math">rs=rs^{(0)}\\odot\\ldots\\odot rs^{(j)}</span> (similarly for <span class="math">ws</span>). Finally, the timestamp of the combined VKState object is simply 0 since it is not used in audit.</p>

    <p class="text-gray-300">Handling duplicate entries. Since different <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> instances start with the same timestamp <span class="math">ts</span>=0, it is possible for two different instances to add the same element into their local set-digests (in a VKState object); this creates a problem when multiple VKState objects are combined. We use an example to illustrate the problem. Suppose there are three instances of <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>: <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(1)},\\mathcal{V}_{\\mathcal{K}}^{(2)},\\mathcal{V}_{\\mathcal{K}}^{(3)}</span>. Suppose <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(1)}</span> calls insert<span class="math">(k,v)</span>, making its VKState:</p>

    <p class="text-gray-300"><span class="math">ws=\\mathcal{H}(\\{(k,v,1)\\}),rs=\\mathcal{H}(\\{\\}),ts=1</span></p>

    <p class="text-gray-300">Suppose <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(2)}</span> and <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(3)}</span> call get<span class="math">(k)</span> concurrently and <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> returns an incorrect value <span class="math">v^{\\prime}\\neq v</span>. Specifically, <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> returns <span class="math">(k,v^{\\prime},1)</span> to both, so their VKState object is:</p>

    <p class="text-gray-300"><span class="math">ws=\\mathcal{H}(\\{(k,v^{\\prime},2)\\}),rs=\\mathcal{H}(\\{(k,v^{\\prime},1)\\}),ts=2</span></p>

    <p class="text-gray-300">Now, if each <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> instance combines set-digests in the three VKState objects, they get the following (we use exponents to indicate the number of copies of an element):</p>

    <p class="text-gray-300"><span class="math">ws=\\mathcal{H}(\\{(k,v,1),(k,v^{\\prime},2)^{2}\\}),rs=\\mathcal{H}(\\{(k,v^{\\prime},1)^{2}\\})</span></p>

    <p class="text-gray-300">Unfortunately, since <span class="math">\\mathcal{H}(\\cdot)</span> is a set hash function the above leads to undefined behavior: <span class="math">\\mathcal{H}</span>’s input domain is a set, but the above is a multiset. Worse, some constructions <em>[5]</em> use XOR for <span class="math">\\odot</span>, so <span class="math">\\mathcal{H}(\\{(k,v^{\\prime},1)^{2}\\})=\\mathcal{H}(\\{\\})</span> (i.e., adding an element that already exists to a set-digest removes the element!). Such a hash function would lead to the following combined set-digests:</p>

    <p class="text-gray-300"><span class="math">ws=\\mathcal{H}(\\{(k,v,1)\\}),rs=\\mathcal{H}(\\{\\})</span></p>

    <p class="text-gray-300">For these set-digests, a <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> can make audit pass by returning <span class="math">M=\\{(k,v,1)\\}</span>—even though it misbehaved by returning an incorrect value to <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(2)}</span> and <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(3)}</span>.</p>

    <p class="text-gray-300">There are two solutions. First, we can use a <span class="math">\\mathcal{H}(\\cdot)</span> that is multiset collision-resistant (our construction in Section 5 satisfies this). In that case, even if different instances of <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> add the same elements to their set-digests, the aggregated set-digest will track the multiplicity of set members (i.e., the number of times an element is added to a set-digest). If <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> misbehaves, the aggregated <span class="math">rs</span> will not be a submultiset of the aggregated <span class="math">ws</span>, which prevents a future audit from passing (Appendix C.2). The second solution is to guarantee that there are no duplicate entries. We discuss this second solution in detail in Appendix A.1.</p>

    <p class="text-gray-300">Using C-SetKV to execute requests concurrently. <span class="math">\\mathcal{P}</span> executes (and generates proofs for) multiple instances of <span class="math">\\Psi_{req}</span> simultaneously using different threads of execution (e.g., on a cluster of VMs). As before, each instance of <span class="math">\\Psi_{req}</span> interacts with a storage service through exogenous computation. A key difference is that unlike the design in Section 3.2, each instance of <span class="math">\\Psi_{req}</span> checks the response from the storage service using a different instance of C-SetKV’s verifier. This is essentially the desired solution, but we now specify a few details.</p>

    <p class="text-gray-300">A verifier <span class="math">\\mathcal{V}_{j}</span> receives commitments to a set of VKState objects, one from each thread of execution, in <span class="math">\\mathcal{P}</span>’s trace. This means that <span class="math">\\mathcal{V}_{j}</span> cannot execute the <span class="math">\\odot</span> operator on the commitments sent by <span class="math">\\mathcal{P}</span>, since <span class="math">\\odot</span> works on set-digests and not on commitments. To address this, <span class="math">\\mathcal{P}</span> supports a computation <span class="math">\\Psi_{comb}</span> that takes as input commitments to VKState objects and outputs a commitment to the combined VKState object. That is, <span class="math">\\mathcal{P}</span> helps <span class="math">\\mathcal{V}_{j}</span> combine commitments to VKState objects—without revealing anything about the objects and without requiring <span class="math">\\mathcal{V}_{j}</span> to trust <span class="math">\\mathcal{P}</span> (<span class="math">\\mathcal{P}</span> produces a proof for <span class="math">\\Psi_{comb}</span>). <span class="math">\\mathcal{V}_{j}</span> then uses the resulting commitment in <span class="math">\\Psi_{audit}</span>.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">4.2 Supporting transactional semantics</h3>

    <p class="text-gray-300">Many services compute over multiple key-value tuples when processing a request, so they require transactional semantics. To support such services, we first build low-level mutual-exclusion primitives. We then use these primitives to build a transactional interface to C-SetKV that guarantees serializability <em>[21, 65]</em>. Finally, we show how those low-level primitives can be used to build other concurrency control protocols.</p>

    <p class="text-gray-300">Mutual-exclusion primitives. Spice supports two APIs: (1) lock takes as input a key and returns the current value associated with the key; and (2) unlock takes as input a key and an updated value, and associates the new value with the key before unlocking the key. Figure 3 depicts our implementation of these APIs by essentially decomposing SetKV’s get and put (Figure 2).</p>

    <p class="text-gray-300">In essence, these primitives provide mutual-exclusion semantics by leveraging the requirement that <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> in C-SetKV must execute GET and PUT RPCs on the same key</p>

    <p class="text-gray-300">1: function lock(s, k) 2:  <span class="math">(v,t)\\gets \\mathrm{RPC}(\\mathrm{GET},k)</span>  //  <span class="math">\\mathcal{P}_{\\mathcal{K}}</span>  executes GET and locks  <span class="math">k</span> 3:  <span class="math">rs^{\\prime}\\gets s.rs\\odot \\mathcal{H}(\\{(k,v,t)\\})</span> 4:  <span class="math">ts^{\\prime}\\gets \\max (s.ts,t)</span> 5: return VKState{rs',s.ws,ts'},v 6: function unlock(s,k,v) 7:  <span class="math">ts^{\\prime}\\gets s.ts + 1</span> 8: RPC(PUT,  <span class="math">k, (v, ts&#x27;))</span>  //  <span class="math">\\mathcal{P}_{\\mathcal{K}}</span>  executes PUT and unlocks  <span class="math">k</span> 9:  <span class="math">ws^{\\prime}\\gets s.ws\\odot \\mathcal{H}(\\{(k,v,ts^{\\prime})\\})</span> 10: return VKState{s.rs,ws',ts'}</p>

    <p class="text-gray-300">FIGURE 3—Mechanics of lock and unlock (see text).</p>

    <p class="text-gray-300">1: function beg_txn(s, keys) 2:  <span class="math">s^{\\prime}\\gets s,\\text{vals}\\gets []</span> 3: for  <span class="math">k</span>  in keys do 4:  <span class="math">(s&#x27;, v) \\gets \\text{lock}(s&#x27;, k)</span> 5:  <span class="math">\\text{vals} \\gets \\text{vals} + (v)</span>  // append the value 6: return  <span class="math">s&#x27;</span> , vals 7: function end_txn(s, tuples) 8:  <span class="math">s^{\\prime}\\gets s</span> 9: for  <span class="math">(k,v)</span>  in tuples do 10:  <span class="math">s^{\\prime}\\gets \\mathrm{unlock}(s^{\\prime},k,v)</span> 11: return  <span class="math">s&#x27;</span></p>

    <p class="text-gray-300">FIGURE 4—Mechanics of beg_txn and end_txn (see text).</p>

    <p class="text-gray-300">in isolation. Specifically, if a request executes lock on a key  <span class="math">k</span> ,  <span class="math">\\mathcal{P}_{\\mathcal{K}}</span>  must block all operations on  <span class="math">k</span>  until the lock-owner calls unlock (otherwise a future audit fails).</p>

    <p class="text-gray-300">Simple transactions. We now describe how the above mutual-exclusion primitives can be used to build transactions with known read/write sets: all the keys that will be accessed are known before the transaction execution begins. Spice abstracts this transactional primitive with two APIs: (1) beg_txn takes as input a list of keys on which a transaction wishes to operate and returns the values associated with those keys; (2) end_txn takes as input the list of keys and the values that the transaction wishes to commit. Between calls to these two APIs, a program  <span class="math">\\Psi_{req}</span>  can execute arbitrary computation in Spice's subset of C.</p>

    <p class="text-gray-300">Figure 4 depicts our implementation of these APIs. beg_txn calls lock on each key in its argument to get back the current value associated with the key. end_txn calls unlock on each key (which stores the updated value before releasing the lock). This guarantees serializability since lock and unlock ensure mutual-exclusion.[6]</p>

    <p class="text-gray-300">General transactions. We note that a transaction executed by  <span class="math">\\Psi_{req}</span>  does not need to acquire locks on all keys involved in the transaction at once. A programmer can write a  <span class="math">\\Psi_{req}</span>  that acquires locks on keys (using lock) over its lifetime and then releases locks (using unlock). This supports transactions with arbitrary read/write sets and guarantees serializability if  <span class="math">\\Psi_{req}</span>  implements two-phase</p>

    <p class="text-gray-300">locking: all locks on keys involved in the transaction are acquired before releasing any lock. Appendix A.3 discusses how to implement serializable transactions with optimistic concurrency control instead.</p>

    <p class="text-gray-300">We now describe an efficient implementation of  <span class="math">\\Psi_{\\text{audit}}</span>  and the cryptographic primitives necessary to build Spice.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall from Section 3.2 that  <span class="math">\\mathcal{P}</span>  periodically produces  <span class="math">\\pi_{\\text{audit}}</span>  to prove the correct execution of  <span class="math">\\Psi_{\\text{audit}}</span> . We observe that  <span class="math">\\Psi_{\\text{audit}}</span>  can be expressed as a MapReduce job; thus,  <span class="math">\\mathcal{P}</span>  can use existing verifiable MapReduce frameworks [25, 35, 39] to reduce the latency of producing  <span class="math">\\pi_{\\text{audit}}</span>  by orders of magnitude. The details (of what each mapper and reducer computes) are in Appendix A.2, but we discuss the costs. This approach increases each verifier's CPU costs and the size of  <span class="math">\\pi_{\\text{audit}}</span>  by a factor of  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{mappers}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{reducers}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . This is because each mapper and reducer generates a separate proof. This is an excellent trade-off since checking  </span>\\pi_{\\text{audit}}<span class="math">  is relatively cheap:  </span>3\\mathrm{ms}$  of CPU-time to check a mapper's (or a reducer's) proof, and each proof is 128 bytes.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Set hash function. Recall from Section 3.2 that Spice represents the logic of SetKV's  <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>  (Figure 2) in constraints. An important component is encoding  <span class="math">\\mathcal{H}(\\cdot)</span>  as a set of equations; all other operations in  <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>  (such as comparisons and integer arithmetic) are already supported by the existing framework ( <span class="math">\\S 6</span> ). Spice instantiates  <span class="math">\\mathcal{H}(\\cdot)</span>  using MSet-Mu-Hash [32] defined over an elliptic curve  <span class="math">EC</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {H} (\\{e _ {1}, \\dots e _ {\\ell} \\}) = \\sum_ {i = 1} ^ {\\ell} H (\\{e _ {i} \\})</span></div>

    <p class="text-gray-300">where  <span class="math">H(\\cdot)</span>  is a random oracle that maps a multiset of elements to a point in  <span class="math">EC</span> , and point addition is the group operation. We use an elliptic curve group since prior work [17, 35, 52] shows how to express elliptic curve operations with only a handful of constraints.</p>

    <p class="text-gray-300">However, one issue remains: we need a candidate for  <span class="math">H(\\cdot)</span>  with an efficient representation as a constraints set. Our starting point for  <span class="math">H(\\cdot)</span>  is  <span class="math">H(\\cdot) = \\phi(R(\\cdot))</span> , where  <span class="math">R(\\cdot)</span>  is a random oracle (instantiated using a collision-resistant hash function).  <span class="math">R</span>  takes as input a multiset of elements and outputs an element of a set  <span class="math">S</span>  (e.g., SHA-256 maps an arbitrary length binary string to a 256-bit string);  <span class="math">\\phi(\\cdot)</span>  maps elements in  <span class="math">S</span>  uniformly to a point in  <span class="math">EC</span> .</p>

    <p class="text-gray-300">A challenge is that building <span class="math">\\phi(\\cdot)</span> using prior techniques <em>[37]</em> is expensive; more critically, common hash functions (e.g., SHA-256, Keccak) perform bitwise operations (XOR, shift, etc.), which are expensive to express with algebraic constraints (it takes at least 1 constraint for each bit of the inputs) <em>[67, 72]</em>. We discuss our solution in detail in Appendix B, but we make the following contribution. We show that the requirement that <span class="math">H(\\cdot)</span> be a random oracle can be relaxed (we still require its constituent <span class="math">R(\\cdot)</span> to be a random oracle). We leverage this relaxation to construct an efficient <span class="math">\\phi(\\cdot)</span> from Elligator-2 <em>[20]</em>; to build <span class="math">R(\\cdot)</span>, we use a relatively new block cipher called MiMC <em>[2]</em>, which is more efficient than SHA-256 in the constraints formalism. In summary, our construction of <span class="math">\\mathcal{H}(\\cdot)</span> requires 10,000<span class="math">\\times</span> fewer constraints than using SHA-256 and a prior construction for <span class="math">\\phi(\\cdot)</span> <em>[37]</em>.</p>

    <p class="text-gray-300">Commitments. Pantry <em>[25]</em> employs HMAC-SHA256 to implement commit() but requires <span class="math">\\approx</span> 250,000 constraints to generate a commitment to a 150-byte message. Spice takes a different approach. For a message <span class="math">x\\in\\mathbb{F}_{p}</span> (recall from §2.1 that constraint variables are elements in <span class="math">\\mathbb{F}_{p}</span>), a commitment is <span class="math">(x+t,R(t))</span> where <span class="math">t\\in\\mathbb{F}_{p}</span> is a randomly-chosen value and <span class="math">R(\\cdot)</span> is the MiMC-based random oracle introduced above. This is binding because <span class="math">R(t)</span> binds <span class="math">t</span> due to the collision-resistance of <span class="math">R(\\cdot)</span>. It is hiding because <span class="math">x+t</span> is uniformly random; hence the tuple <span class="math">(x+t,R(t))</span> is independent of the message <span class="math">x</span>. Finally, the scheme generalizes to larger messages <span class="math">x\\in\\mathbb{F}_{p}^{k}</span> in two ways: commit to each component of <span class="math">x</span> independently (which increases the size of the commitment by <span class="math">k</span> times), or output <span class="math">(R(x)+t,R(t))</span>. Compared to Pantry’s HMAC-SHA256, Spice’s commitments require <span class="math">\\approx</span>300<span class="math">\\times</span> fewer constraints.</p>

    <h2 id="sec-19" class="text-2xl font-bold">6 Implementation and applications</h2>

    <p class="text-gray-300">We build Spice atop pequin <em>[1]</em>, which provides a compiler to convert a broad subset of C to constraints, and links to libsnark <em>[57]</em> for the argument protocol (step 3; §2.1). We extend this compiler with Spice’s SetKV API (including transactions and commitments) based on the design discussed in Sections 3–5. Spice uses leveldb <em>[42]</em> as its backing store to provide persistent state. In total, Spice adds about 2,000 LOC to Pequin. Our implementation of the applications discussed below consists of 1,300 lines of C and calls to Spice’s API.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">6.1 Applications of Spice</h3>

    <p class="text-gray-300">We built three applications atop Spice. These applications require strong integrity and privacy guarantees, and have transactions on state that can be executed concurrently. Furthermore, they tolerate batch verification (i.e., <span class="math">\\mathcal{P}</span> can produce <span class="math">\\pi_{audit}</span> after many requests) since clients can levy financial penalties if they detect misbehavior ex post facto.</p>

    <p class="text-gray-300">⬇ // pk_c is the public key of the caller issue(VKState* s, PK pk_c, PK pk, Asset as, int a) {</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">return insert(s, pk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">as, a); //</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is concatenation</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">}</p>

    <p class="text-gray-300">retire(VKState* s, PK pk, Asset as, int a) { Value v[1];</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">beg_txn(s, [pk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">as], v); // updates s and v</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">if (v[0] >= a) v[0] -= a;</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">end_txn(s, [(pk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">as, v[0])]); // updates s</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">}</p>

    <p class="text-gray-300">// pk1, pk2 are the keys of caller and recipient transfer(VKState* s, PK pk1, PK pk2, Asset as, int a) { Value v[2];</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">beg_txn(s, [pk1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">as, pk2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">as], v); // updates s, v</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">if (v[0] >= a) { v[0] -= a; v[1] += a; }</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">end_txn(s, [(pk1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">as, v[0]), (pk2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">as, v[1])]);</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">} ⬇</p>

    <p class="text-gray-300">Figure 5—Pseudocode for a Sequence-like app using Spice’s API (Figure 11). The requests, except the public key of the caller, are wrapped in commitments; however, this part is not depicted.</p>

    <p class="text-gray-300">Cloud-based ledger service. We consider a cloud-hosted service that maintains a ledger with balances of assets for different clients. Examples of assets include currency in a mobile wallet (e.g., Square, WeChat) and credits in a ride-sharing application. Clients submit three types of requests: transfer, issue, and retire. transfer moves an assert from one client to another, whereas issue and retire move external assets in and out of the ledger. For example, in WeChat, clients move currency from their bank accounts to their mobile wallets. This application is inspired by Sequence <em>[29]</em>. However, to verify the correct operation of Sequence, a verifier needs access to sensitive details of clients’ requests (e.g., the amount of money) and the service’s state. We address this limitation by implementing a Sequence-like service as a VSM using Spice. The ledger maintained by the service is the VSM’s state and the request types discussed above are state transitions. Figure 5 depicts our implementation of this application in Spice’s programming model.</p>

    <p class="text-gray-300">Payment networks. Our second application is a payment network inspired by Solidus <em>[28]</em>. Banks maintain customer balances, and customers submit requests to move money from their accounts to other accounts (in the same bank or a different bank). This is similar to the previous application except that it also supports an inter-bank transfer. For such a transfer, the sender and recipient’s banks must coordinate out-of-band: the sender’s bank executes the debit part of a transfer and the recipient’s bank executes the credit part. A verifier can check that banks are processing requests correctly without learning the content of requests: destination account, amount, etc.</p>

    <p class="text-gray-300">A securities exchange (dark pool). A securities exchange is a service that allows buyers to bid for securities</p>

    <p class="text-gray-300">(e.g., stock) sold by sellers. The service maintains an order book—a list of buy and sell orders sorted by price. Clients submit buy or sell orders to the service, who either fulfills the order if there is a match, or adds the order to the order book. Although traditional exchanges are public (clients can see the order book), private exchanges (or dark pools) have gained popularity in light of attacks such as "front-running" [66]. Dark pools, however, are opaque; indeed, there are prior incidents where dark pools have failed to match orders correctly [38, 63].</p>

    <p class="text-gray-300">We implement the exchange as a VSM: the order book is the state, and submit and withdraw order are state transitions. At a high level, we represent the sorted order book as a doubly-linked list using Spice's storage API. Then, submit removes or inserts nodes to the list depending on whether there is a match or not, and withdraw removes nodes from the list. With Spice, verifiers learn nothing about the orders beyond the identity of the submitter, and yet they can check the correct operation of the exchange.</p>

    <p class="text-gray-300">We answer the following questions in the context of our prototype implementation and applications (§6).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>How does Spice compare to prior work?</li>

      <li>How well does Spice scale with more CPUs?</li>

      <li>What is the performance of apps built with Spice?</li>

    </ol>

    <p class="text-gray-300">Baselines. We compare Spice to two prior systems for building VSMs: Pantry [25] and Geppetto [35]. Sections 2.1 and 8 provide details of their storage primitives, but briefly, Pantry's storage operations incur costs logarithmic in the size of the state (due its use of Merkle trees), and the costs are linear in the size of the state in Geppetto. Besides these baselines, we consider a Pantry variant, which we call Pantry+Jubjub, that uses a Merkle tree instantiated with a recent hash function [33]. Finally, we compare our payment network app ( <span class="math">\\S 7.3</span> ) to Solidus [28].</p>

    <p class="text-gray-300">Setup and metrics. We use a cluster of Azure D64s_v3 instances (32 physical CPUs, 2.4 GHz Intel Xeon E5-2673 v3, 256 GB RAM) running Ubuntu 17.04. We measure CPU-time, storage costs, and network transfers at the prover  <span class="math">\\mathcal{P}</span>  and each verifier  <span class="math">\\nu_{j}</span> , and the throughput and latency of  <span class="math">\\mathcal{P}</span> . Finally, we measure Spice's performance experimentally, but estimate baselines' performance through microbenchmarks and prior cost models; we use the same argument protocol for Spice and the baselines, so  <span class="math">\\mathcal{P}</span> 's CPU costs in all the systems scale (roughly) linearly with the number of constraints of a  <span class="math">\\Psi</span> .</p>

    <p class="text-gray-300">Microbenchmarks. To put our end-to-end results in context, we measure the costs to each  <span class="math">\\nu_{j}</span>  and  <span class="math">\\mathcal{P}</span>  in Spice's underlying argument protocol (§6), and the number of constraints needed to represent Spice's cryptographic primitives. Figure 6 depicts our results.</p>

    <p class="text-gray-300">|  costs of argument protocol (§2.1, §6)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">V's CPU-time to check a proof</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 3 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">size of a proof</td>

            <td class="px-3 py-2 border-b border-gray-700">128 bytes</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  #constraints for basic primitives (§5.2)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">random oracle R(·) on a 32-byte message</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">167</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">add two points in EC (i.e., ⊙ in §3.1)</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">commit to a 32-byte message</td>

            <td class="px-3 py-2 border-b border-gray-700">168</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">FIGURE 6—Microbenchmarks.</p>

    <p class="text-gray-300">We consider a computation  <span class="math">\\Psi</span>  that invokes a batch of get (or put) operations on a key-value store preloaded with a varying number of key-value pairs; each key and each value is 64 bits. Our metric here is the number of constraints required to represent a storage operation. Figure 7 depicts the cost of different key-value store operations under Spice and our baselines. For Spice, the reported costs include error-checking code that prevents  <span class="math">\\mathcal{P}</span>  from claiming that a key does not exist (Appendix A.4).</p>

    <p class="text-gray-300">We find that the cost of a storage operation is lower for Spice than prior works as long as  <span class="math">\\mathcal{P}</span> 's state contains at least a few hundred key-value pairs. As an example, for a get on 1M key-value pairs in  <span class="math">\\mathcal{P}</span> 's state, Spice requires  <span class="math">57 \\times</span>  fewer constraints than Pantry,  <span class="math">29 \\times</span>  fewer than Pantry+Jubjub, and  <span class="math">2,000 \\times</span>  fewer than Geppetto.</p>

    <p class="text-gray-300">However, Spice must execute (and produce a proof for)  <span class="math">\\Psi_{\\text{audit}}</span> , which requires constraints linear in the size of the state ( <span class="math">\\S 3.2</span> ). Fortunately, this can be amortized over a batch of  <span class="math">m</span>  operations on state. Naturally, if  <span class="math">m = 1</span>  (i.e., we run  <span class="math">\\Psi_{\\text{audit}}</span>  after every storage operation), then Spice's costs are higher than prior systems. But even for modest values of  <span class="math">m</span> , Spice comes out on top. For example, when the state is 1M key-value pairs,  <span class="math">m \\geq 6,920</span>  is sufficient to achieve per-operation costs that are lower than Pantry. Furthermore, each request in our applications (e.g., financial transactions) perform multiple storage operations; the number of requests per batch that must be verified to outperform the baselines is much smaller.</p>

    <p class="text-gray-300">We now assess how well Spice's prover  <span class="math">\\mathcal{P}</span>  can leverage multiple CPUs and concurrent execution to achieve better throughput. For these experiments, we assume  <span class="math">\\mathcal{P}</span>  executes  <span class="math">\\Psi_{\\text{audit}}</span>  periodically in the background (e.g., every minute). We discuss Spice's throughput, latency, and the amortized costs of operations as a function of audit frequency.</p>

    <p class="text-gray-300">Throughput. We setup  <span class="math">\\mathcal{P}</span>  with a key-value store preloaded with 1M key-value pairs. We then have  <span class="math">\\mathcal{P}</span>  run  <span class="math">\\Psi_{req}</span>  instances on a varying number of CPU cores, where each instance invokes a batch of get (or put) operations;  <span class="math">\\Psi_{req}</span>  selects keys according to two different distributions:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">size of state (# key-value pairs)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">get cost</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">put cost</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( 10^3 \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( 10^6 \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( 10^3 \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( 10^6 \\)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pantry</td>

            <td class="px-3 py-2 border-b border-gray-700">4.1K</td>

            <td class="px-3 py-2 border-b border-gray-700">44.9K</td>

            <td class="px-3 py-2 border-b border-gray-700">85.7K</td>

            <td class="px-3 py-2 border-b border-gray-700">8.2K</td>

            <td class="px-3 py-2 border-b border-gray-700">89.8K</td>

            <td class="px-3 py-2 border-b border-gray-700">171.5K</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Geppetto</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">3.0K</td>

            <td class="px-3 py-2 border-b border-gray-700">3.0M</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">4.0K</td>

            <td class="px-3 py-2 border-b border-gray-700">4.0M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pantry+Jubjub</td>

            <td class="px-3 py-2 border-b border-gray-700">2.1K</td>

            <td class="px-3 py-2 border-b border-gray-700">23.1K</td>

            <td class="px-3 py-2 border-b border-gray-700">44.1K</td>

            <td class="px-3 py-2 border-b border-gray-700">4.2K</td>

            <td class="px-3 py-2 border-b border-gray-700">46.2K</td>

            <td class="px-3 py-2 border-b border-gray-700">88.2K</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spice</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5K</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5K</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5K</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5K</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5K</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5K</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\( Ψ_{audit} \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">1250/m</td>

            <td class="px-3 py-2 border-b border-gray-700">561K/m</td>

            <td class="px-3 py-2 border-b border-gray-700">582M/m</td>

            <td class="px-3 py-2 border-b border-gray-700">561/m</td>

            <td class="px-3 py-2 border-b border-gray-700">561K/m</td>

            <td class="px-3 py-2 border-b border-gray-700">582M/m</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">FIGURE 7—Per-operation cost of get and put—in terms of number of algebraic constraints—for Spice and its baselines with varying number of key-value pairs in  <span class="math">\\mathcal{P}</span> 's state. We also depict the costs for Spice's  <span class="math">\\Psi_{\\text{audit}}</span> ;  <span class="math">m</span>  denotes the number of storage operations after which  <span class="math">\\mathcal{P}</span>  runs  <span class="math">\\Psi_{\\text{audit}}</span>  to produce  <span class="math">\\pi_{\\text{audit}}</span> . Figure 6 depicts  <span class="math">\\mathcal{P}</span> 's and each  <span class="math">\\nu_j</span> 's CPU-time as a function of the number of constraints.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> FIGURE 8—Benefits of Spice's concurrent request execution. The workload is a stream of gets or puts and  <span class="math">\\mathcal{P}</span> 's state contains 1M key-value pairs. The keys are chosen uniformly at random or follow a Zipfian distribution (exponent of 1.0).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">get</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">put</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pantry</td>

            <td class="px-3 py-2 border-b border-gray-700">0.078</td>

            <td class="px-3 py-2 border-b border-gray-700">0.039</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pantry+Jubjub</td>

            <td class="px-3 py-2 border-b border-gray-700">0.153</td>

            <td class="px-3 py-2 border-b border-gray-700">0.076</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Geppetto</td>

            <td class="px-3 py-2 border-b border-gray-700">0.002</td>

            <td class="px-3 py-2 border-b border-gray-700">0.002</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spice (1-thread)</td>

            <td class="px-3 py-2 border-b border-gray-700">3.6</td>

            <td class="px-3 py-2 border-b border-gray-700">3.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spice (512-threads)</td>

            <td class="px-3 py-2 border-b border-gray-700">1366</td>

            <td class="px-3 py-2 border-b border-gray-700">1370</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">FIGURE 9—Throughput (ops/sec) for get and put in Spice and its baselines. The size of the state is 1M key-value pairs.</p>

    <p class="text-gray-300">uniform and Zipfian (exponent of 1.0). We measure the number of storage operations performed (and proofs produced) by  <span class="math">\\mathcal{P}</span>  per second. Figure 8 depicts our results.</p>

    <p class="text-gray-300">We find that Spice's prover achieves a near-linear speedup with increasing number of cores. When keys are chosen uniformly,  <span class="math">\\mathcal{P}</span>  (with 512 cores) achieves  <span class="math">379\\times</span>  higher throughput compared to a single-core execution (for both get and put workloads). When the workload is Zipfian, the speedup is  <span class="math">180\\times</span>  due to higher contention (recall from Section 4.1 that  <span class="math">\\mathcal{P}</span>  locks keys outside of the constraint formalism to guarantee isolation). In absolute terms, Spice's prover executes 648-1,370 key-value store operations/second on 512 CPU cores.</p>

    <p class="text-gray-300">Compared to its baselines (Figure 9), Spice's throughput is  <span class="math">92 \\times</span>  that of Pantry,  <span class="math">47 \\times</span>  that of Pantry+Jubjub, and  <span class="math">1,800 \\times</span>  that of Geppetto for puts. The gap widens when Spice leverages 512 cores: Spice' throughput is  <span class="math">35,100 \\times</span>  higher than Pantry,  <span class="math">18,000 \\times</span>  higher than Pantry+Jubjub, and  <span class="math">685,000 \\times</span>  higher than Geppetto.</p>

    <p class="text-gray-300">Latency.  <span class="math">\\mathcal{P}</span>  needs additional resources to periodically produce  <span class="math">\\pi_{\\text{audit}}</span> . Meanwhile, the time that  <span class="math">\\mathcal{P}</span>  needs to gener</p>

    <p class="text-gray-300">ate  <span class="math">\\pi_{\\text{audit}}</span>  dictates the latency of storage operations—since a verifier  <span class="math">\\mathcal{V}_j</span>  must check  <span class="math">\\pi_{\\text{audit}}</span>  before establishing the correctness of prior storage operations (§3.2). We start by measuring  <span class="math">\\mathcal{P}</span> 's time to run  <span class="math">\\Psi_{\\text{audit}}</span>  and produce  <span class="math">\\pi_{\\text{audit}}</span> .</p>

    <p class="text-gray-300">Recall from Section 5.1 that the cost of generating  <span class="math">\\pi_{\\mathrm{audit}}</span>  scales linearly with the size of  <span class="math">\\mathcal{P}</span> 's state and we parallelize this using MapReduce (§5.1). We experiment with  <span class="math">\\mathcal{P}</span> 's state containing 1M key-value pairs. We run a MapReduce job on 1,024 CPU cores consisting of 1,024 mappers, where each mapper reads 1,024 key-value tuples and produces a single set-digest (the details of the MapReduce job are in Appendix A.2). We then run 33 reducers (split over two levels containing 32 and 1 reducers) and a final aggregator. We find that the job (including proof generation) takes 3.63 minutes. As a result, if  <span class="math">\\mathcal{P}</span>  runs  <span class="math">\\Psi_{\\mathrm{audit}}</span>  every  <span class="math">k</span>  minutes the latency of any key-value store operation is at most  <span class="math">k + 3.63</span>  minutes.</p>

    <p class="text-gray-300">Amortized costs of storage operations. Suppose we set  <span class="math">k = 10</span>  minutes, which covers a batch of 800,000 storage operations (recall that  <span class="math">\\mathcal{P}</span>  executes 1,360 ops/sec under a uniform distribution). The amortized cost of  <span class="math">\\Psi_{\\text{audit}}</span>  would be  <span class="math">582 \\cdot 10^6 / 800,000 \\approx 728</span>  constraints, and the per-operation storage cost (in terms of #constraints) would be  <span class="math">728 + 1500 \\approx 2228</span>  constraints. This is  <span class="math">76 \\times</span>  lower than Pantry,  <span class="math">39 \\times</span>  lower than Pantry+Jubjub, and  <span class="math">1790 \\times</span>  lower than Geppetto for put operations (1M key-value pairs in  <span class="math">\\mathcal{P}</span> 's state). With larger  <span class="math">k</span>  (larger latency), this gap widens.</p>

    <p class="text-gray-300">Verifier's costs. A verifier's costs to check a proof of correct execution for a  <span class="math">\\Psi_{req}</span>  is  <span class="math">3\\mathrm{ms}</span>  of CPU-time; the</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> FIGURE 10—Throughput (requests processed/second) for the various applications ( <span class="math">\\S 6</span> ). Requests of type issue, transfer, and retire are for the cloud-based ledger service (Figure 5); issue, transfer, retire, debit, and credit are for the payment network application; and, submit requests are for the dark pool application.</p>

    <p class="text-gray-300">proof itself is only 128 bytes (Figure 6). As we discuss in Section 5.1, the size of a proof and cost to verify  <span class="math">\\Psi_{\\text{audit}}</span>  depends on the chosen MapReduce parameters. In particular, the size of  <span class="math">\\pi_{\\text{audit}}</span>  is  <span class="math">(M + R + 1) \\cdot 128</span>  bytes since each mapper and each reducer produce a different proof, and verifying the entire proof takes  <span class="math">(M + R + 1) \\cdot 3</span>  ms. For the above MapReduce job  <span class="math">(M = 1024, R = 33)</span> , checking  <span class="math">\\pi_{\\text{audit}}</span>  takes 3.2 CPU-seconds.</p>

    <p class="text-gray-300">We now assess whether Spice's prover  <span class="math">\\mathcal{P}</span>  meets our throughput requirement (§2). We experiment with the applications that we built using Spice (§6). Specifically, we run a concurrent  <span class="math">\\mathcal{P}</span>  with a varying number of CPUs and measure its throughput for different transaction types (e.g., credit, debit). The keys for various requests are chosen according to both uniform and Zipfian distributions, and requests compute over a million key-value pairs.</p>

    <p class="text-gray-300">Figure 10 depicts our results for the uniform distribution case; for the Zipfian case, the throughput is  <span class="math">2 - 3.3 \\times</span>  lower due to higher contention. Across the board,  <span class="math">\\mathcal{P}</span>  achieves a near-linear speedup in transaction-processing throughput with a varying number of CPUs. Furthermore, when using 512 CPU cores,  <span class="math">\\mathcal{P}</span>  achieves 488-1167 requests/second, which exceeds our throughput requirement. We now discuss the specifics of each application.</p>

    <p class="text-gray-300">Cloud-based ledger service. Among the three transaction types supported by our first application, issue and retire involve a single storage operation whereas transfer requires two (to update the balances at the sender and the recipient of a transaction). Note that these storage operations are in addition to various checks on balances (see Figure 5). However, in terms of the number of constraints, storage operations dominate. As a result,  <span class="math">\\mathcal{P}</span> 's throughput for issue and retire is about  <span class="math">2 \\times</span>  higher than that of transfer. Furthermore, the throughput for issue and retire is roughly the throughput that Spice's prover achieves for a get (or a put) workload (Figure 8).</p>

    <p class="text-gray-300">Payment networks. We only experiment with interbank transaction types: credit and debit (intra-bank</p>

    <p class="text-gray-300">transfers are the same as in our first application). These transactions involve one storage operation, so  <span class="math">\\mathcal{P}</span> 's throughput is similar to issue and retire in the first application. We compare with Solidus [28], which achieves similar guarantees as our app with specialized machinery. Solidus with 32K accounts (i.e., key-value tuples) achieves 20 storage ops/sec and up to 10 tx/sec, whereas Spice's payment network on 512 CPU cores supports  <span class="math">&amp;gt;1,000</span>  tx/sec ( <span class="math">100 \\times</span>  higher throughput). Note that unlike our implementation, Solidus hides the sender's identity in a transaction from a verifier; achieving this in our context is future work.</p>

    <p class="text-gray-300">Dark pools. Our third app supports two transactions, submit and withdraw. We depict only submit because withdraw has similar costs.  <span class="math">\\mathcal{P}</span>  achieves 488 tx/second. This is lower than our other apps because the dark pool application is more complex: the state is a linked list layered on top of a key-value store (where each operation on the linked list is multiple storage operations), and transactions manipulate the linked list to process orders ( <span class="math">\\S 6.1</span> ).</p>

    <p class="text-gray-300">Proving correct executions via efficient arguments. The problem of proving the correct execution of a computation is decades old [7]; many systems have reduced the expense of this theory (see [86] for a survey of this progress). While early works [34, 51, 67, 69, 71, 73, 76, 77, 80] support only stateless computations, recent systems [8, 14, 18, 25, 31, 35, 39, 83, 88, 89] support state. Section 2.1 discusses the approach in Pantry [25]; below, we discuss other approaches and how they relate to Spice.</p>

    <p class="text-gray-300">Ben-Sasson et al. [14, 18], Buffet [83], and vRAM [89] propose a RAM abstraction based on permutation networks [13, 19, 85]. This technique can be more efficient than using Merkle trees. For example, Buffet [83] shows that each RAM operation (load, store, etc.) can be represented with several hundred constraints (compared to tens of thousands under Pantry's RAM). However, the permutation networks technique cannot be used to maintain state that persists across different request executions—a requirement of VSMs ( <span class="math">\\S 2</span> ).</p>

    <p class="text-gray-300">Geppetto <em>[35]</em> can transfer values associated with program variables (int, char, etc.) from one computation to another. To support this, Geppetto introduces custom machinery that requires a single constraint per value transferred, so this is more efficient than Pantry for certain scenarios (e.g., sending output of a mapper as input to a reducer in MapReduce). However, it is not a good substitute to Merkle trees for key-value stores (or RAM): each storage operation requires scanning all the state. Fiore et al. <em>[39]</em> hybridize Geppetto-style and Pantry-style storage primitives, but it incurs the same costs as Pantry to support a key-value store.</p>

    <p class="text-gray-300">ADSNARK <em>[8]</em> supports computations over state represented with an authenticated digest, but this approach does not support transferring state to other computations. vSQL <em>[88]</em> builds a storage primitive by representing state (e.g., a database table) as a polynomial. However, this storage primitive has the same issue as Geppetto: reading or updating a single value of the state (e.g., a row) inside a <span class="math">\\Psi_{req}</span> requires scanning the entire state.</p>

    <p class="text-gray-300">Compared to prior systems, Spice proposes a cheaper and more expressive storage primitive (under a batch verification setting): Spice supports a transactional key-value store (§3, §4), which makes it possible to build useful services with plausible performance (§6–§7). Two exceptions: (1) for random access over state within a single computation, permutation networks are more efficient (indeed, Spice relies on Buffet for RAM within threads); (2) for intermediate state in a MapReduce job, Geppetto-style state transfer can be more efficient.</p>

    <p class="text-gray-300">Concurrent systems with verifiability. Spice’s use of offline memory checking <em>[23, 32]</em> is inspired by Concerto <em>[5]</em>, but there are three differences. First, Concerto is limited to a key-value store whereas Spice supports (arbitrary) concurrent services expressed in a large subset of C. Second, Spice supports transactional semantics whereas Concerto is limited to single-object key-value operations. Finally, Concerto requires trusted hardware (e.g., Intel SGX) to run <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>. It is possible to avoid trusted hardware by letting clients act as verifiers, but the resulting system would expose the content of the key-value store (along with requests and responses); it would not guarantee zero-knowledge or succinctness (§2).</p>

    <p class="text-gray-300">Orochi <em>[75]</em> enables verifiability for concurrent applications (and the underlying data store) running on an untrusted server. Orochi’s key technique is a clever reexecution of all requests at the verifier—one that accommodates concurrent execution of requests at the server. Compared to Spice, Orochi imposes minimal overheads to the server. However, Orochi’s verifier must keep a full copy of the server’s state to verify requests along with contents of all requests and the corresponding responses. Consequently, Orochi does not satisfy the zero-knowledge or succinctness properties of VSMs (§2).</p>

    <h2 id="sec-26" class="text-2xl font-bold">9 Discussion and summary</h2>

    <p class="text-gray-300">Equivocation and omission. Spice’s <span class="math">\\mathcal{P}</span> proves its correct operation by producing a trace that is checked by verifiers. However, <span class="math">\\mathcal{P}</span> can equivocate: it can expose different traces to different verifiers. If the set of verifiers forms a <em>permissioned</em> group (i.e., admitting new verifiers requires approval from a quorum of existing verifiers), then verifiers can agree on a single trace by employing traditional distributed consensus <em>[27, 55]</em>, thus preventing equivocation. If the set of verifiers is unbounded, <span class="math">\\mathcal{P}</span> can embed metadata about its trace in a permissionless blockchain <em>[78]</em>. Besides equivocation, <span class="math">\\mathcal{P}</span> can omit clients’ requests. To address this, clients must check if their requests are included in the trace agreed upon by verifiers.</p>

    <p class="text-gray-300">Fault-tolerance. We can make Spice’s services fault-tolerant via standard techniques. This does not require implementing a replication protocol as a VSM. This is because Spice’s services maintains their internal state in a database (Spice uses leveldb), and interacts with it via RPCs (§2.1). Thus, the service could instead keep the state in a fault-tolerant storage system (e.g., DynamoDB).</p>

    <p class="text-gray-300">Trusted setup. Spice can use many different argument protocols, but our implementation employs an argument <em>[45]</em> that requires a <em>trusted setup</em>: a trusted party must create cryptographic material that depends on <span class="math">\\Psi</span> but not on inputs or outputs to <span class="math">\\Psi</span>. In our context (§6), such a trusted setup can be executed by a verifier (if there is a single verifier), or in a distributed protocol <em>[15]</em> (when there is more than one verifier). Recent arguments <em>[3, 10, 11, 16, 24, 84]</em> do not require such a trusted setup. We leave it to future work to integrate them with Spice and explore trade-offs.</p>

    <p class="text-gray-300">Summary. Spice is a substantial improvement over prior systems that implement VSMs: it improves transaction-processing throughput by over four orders of magnitude. And, although Spice’s absolute costs (e.g., prover’s CPU-time) are large, it enables a new set of realistic services by opening up a concurrent model of computation and achieving throughputs of over a thousand transactions/second.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">Acknowledgments</h4>

    <p class="text-gray-300">We thank Weidong Cui, Esha Ghosh, Jay Lorch, Ioanna Tzialla, Riad Wahby, Michael Walfish, the OSDI reviewers, and our shepherd, Raluca Ada Popa, for helpful comments that significantly improved the content and presentation of this work. We also thank Ben Braun for help with enhancing pequin. We benefited from insightful conversations with Arvind Arasu, Donald Kossmann, and Ravi Ramamurthy about Concerto <em>[5]</em>, and Melissa Chase and Michael Naehrig about multiset hash functions. Sebastian Angel was partially funded by AFOSR grant FA9550-15-1-0302, and NSF CNS-1514422.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">This appendix covers an alternate construction of Spice that uses C-SetKV without a multiset collision-resistant hash function (Appendix A.1), provides details of parallelizing audits with MapReduce (Appendix A.2), how to build transactions with optimistic concurrency control (Appendix A.3), and how to prevent a prover from denying that a key-value pair exists (Appendix A.4). The full API of all operations supported by Spice in its programming model is in Figure 11.</p>

    <p class="text-gray-300">In Section 4.1 we describe how C-SetKV can be implemented using either a multiset collision-resistant hash function, or a set collision-resistant hash function and guaranteeing that there are no duplicate entries. Here, we provide details of the latter approach.</p>

    <p class="text-gray-300">Recall that the goal is to ensure that every element that is inserted into a set-digest is unique. This is achieved by assigning to each  <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>  a unique identifier. The combination of the timestamp and the identifier acts as a Lamport clock [53] that replaces the timestamp field in SetKV (§3.1). In other words, the timestamp field is updated as before, but the key-value store now consists of tuples of the form  <span class="math">(k, \\nu, ts, tid)</span> , where  <span class="math">k</span>  is a key,  <span class="math">\\nu</span>  is a value,  <span class="math">ts</span>  is the timestamp, and  <span class="math">tid</span>  is the identifier of the last writer. A VKState object is:</p>

    <pre><code class="language-txt">struct VKState { SetDigest rs; // a set-digest of RS SetDigest ws; // a set-digest of WS int ts; // timestamp int tid; // a unique identifier }</code></pre>

    <p class="text-gray-300">Assigning thread identifiers. In C-SetKV, we assumed each instance of  <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>  is given a unique identifier; we now specify who does this and how uniqueness is enforced, in the context of Spice, where  <span class="math">\\mathcal{P}</span>  proves that it ran each instance of  <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>  correctly. Since  <span class="math">\\mathcal{P}</span>  spawns different threads of execution, we let  <span class="math">\\mathcal{P}</span>  pick identifiers. To accomplish this, we augment  <span class="math">\\Psi_{req}</span>  to call a library function init_vkstate as the first program statement: it sets the tid field in the input VKState object with an identifier (purported to be unique) that it obtains via an exogenous computation. Of course  <span class="math">\\Psi_{req}</span>  cannot verify the uniqueness of thread-identifiers across different requests, but the uniqueness is checked by  <span class="math">\\Psi_{aggr}</span>  ( <span class="math">\\S 4.1</span> ).</p>

    <p class="text-gray-300">Recall from Section 3.2 that  <span class="math">\\Psi_{\\text{audit}}</span>  takes as input a commitment to VKState object  <span class="math">cs</span> , and outputs a Boolean; note that it also takes as input, from  <span class="math">\\mathcal{P}</span>  (via exogenous computations), a set of tuples of the form  <span class="math">(k, \\nu, ts)</span>  (or of the form  <span class="math">(k, \\nu, ts, tid)</span> ) if threads are assigned unique identifiers, as discussed above). In more detail,  <span class="math">\\Psi_{\\text{audit}}</span>  checks</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">API</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">description</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">init(VKState*)</td>

            <td class="px-3 py-2 border-b border-gray-700">create a new key-value store</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">insert(VKState*, Key, Value)</td>

            <td class="px-3 py-2 border-b border-gray-700">insert a key-value pair</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">put(VKState*, Key, Value)</td>

            <td class="px-3 py-2 border-b border-gray-700">update a value</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">get(VKState<em>, Key, Value</em>)</td>

            <td class="px-3 py-2 border-b border-gray-700">retrieve a value</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">audit(VKState)</td>

            <td class="px-3 py-2 border-b border-gray-700">verify prior history</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">lock(VKState<em>, Key, Value</em>)</td>

            <td class="px-3 py-2 border-b border-gray-700">lock a key</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">unlock(VKState*, Key, Value)</td>

            <td class="px-3 py-2 border-b border-gray-700">unlock a key</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">beg_txn(VKState*, Key[], Value**)</td>

            <td class="px-3 py-2 border-b border-gray-700">begin one-shot txn</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">end_txn(VKState*, Key[], Value[])</td>

            <td class="px-3 py-2 border-b border-gray-700">end one-shot txn</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Commitment commit(Message)</td>

            <td class="px-3 py-2 border-b border-gray-700">commit to a message</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Message decommit(Commitment)</td>

            <td class="px-3 py-2 border-b border-gray-700">decommit a commitment</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">FIGURE 11—Spice's APIs. VSM programmers express  <span class="math">\\Psi_{req}</span>  in a subset of C augmented with the above API.</p>

    <p class="text-gray-300">the following conditions.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The keys given by  <span class="math">\\mathcal{P}</span> ,  <span class="math">[k_1, \\ldots, k_n]</span> , have no duplicates.</li>

      <li><span class="math">s.rs \\odot rs&#x27; = s.ws</span>  where  <span class="math">rs&#x27; \\gets \\mathcal{H}(\\{e_1, \\ldots, e_n\\})</span> ,  <span class="math">(e_1, \\ldots, e_n)</span>  are tuples supplied by  <span class="math">\\mathcal{P}</span> , and  <span class="math">s</span>  is a VKState object whose commitment is  <span class="math">cs</span> .</li>

    </ol>

    <p class="text-gray-300">We now discuss a MapReduce job that checks the above conditions. The job is organized as a tree (we discuss binary for simplicity) where mappers are leaves and reducers are internal nodes that read inputs from their children (there is no shuffling). Suppose there are  <span class="math">n</span>  tuples in  <span class="math">\\mathcal{P}</span> 's state (without loss of generality, let  <span class="math">n</span>  be a power of two).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each mapper takes as input two tuples  <span class="math">(e_i, e_j)</span> , asserts that  <span class="math">e_i \\cdot k &amp;lt; e_j \\cdot k</span> , and outputs commitments to  <span class="math">(\\mathcal{H}(\\{e_i, e_j\\}), e_i \\cdot k, e_j \\cdot k)</span> , say  <span class="math">(cd, ck_1, ck_2)</span> .</li>

      <li>Each reducer reads its input from its two children (e.g.,  <span class="math">(cd, ck_1, ck_2)</span>  and  <span class="math">(cd&#x27;, ck_1&#x27;, ck_2&#x27;)</span> ), asserts that  <span class="math">k_2 &amp;lt; k_1&#x27;</span> , and outputs commitments to  <span class="math">(d \\odot d&#x27;, k_1, k_2&#x27;)</span> , where  <span class="math">(d, k_1, k_2, d&#x27;, k_1&#x27;, k_2&#x27;)</span>  are plaintext values of commitments  <span class="math">(cd, ck_1, ck_2, cd&#x27;, ck_1&#x27;, ck_2&#x27;)</span>  respectively.</li>

    </ul>

    <p class="text-gray-300">Finally, a special program, called a final aggregator, takes as input a commitment to a VKState object  <span class="math">cs</span>  and the output of the root reducer of the MapReduce job ( <span class="math">cd_{root}, ck_1, ck_2</span> ), and asserts:  <span class="math">s.rs \\odot d_{root} = s.ws</span>  and  <span class="math">k_1 &amp;lt; k_2</span>  where  <span class="math">(s, d_{root}, k_1, k_2)</span>  are plaintext values of commitments ( <span class="math">cs, cd_{root}, ck_1, ck_2</span> ) respectively.</p>

    <p class="text-gray-300">We now discuss how to implement optimistic concurrency control using the lock and unlock primitives discussed in Section 4.2. This requires maintaining metadata alongside the value of a corresponding key. Specifically, each value contains a version counter that gets incremented when the rest of the value changes. With such a facility, a  <span class="math">\\Psi_{req}</span>  can issue get operations to obtain current values and version numbers associated with keys. Then, it exe</p>

    <p class="text-gray-300">cutes the logic of the transaction locally (without writing anything to the key-value store). To commit or abort this locally-executed transaction, <span class="math">\\Psi_{req}</span> proceeds as follows. <span class="math">\\Psi_{req}</span> acquires locks on all keys involved in the transaction (using lock), verifies that all keys it read did not change (by checking the version numbers in the values returned by lock operations); it then either commits (by updating values and releasing locks using unlock) or aborts (by simply releasing locks) the transaction. <span class="math">\\Psi_{req}</span> can retry executing the transaction, but the number of retries must be statically bounded (since Spice’s compiler only supports bounded loops in its programming model). Of course, a client can retry a transaction any number of times by simply submitting a new request for each retry.</p>

    <p class="text-gray-300">Finally, we leave it to future work to leverage metadata (similar to the version counter) inside a value to implement other mutual-exclusion primitives (e.g., read locks), and other isolation levels (e.g., snapshot isolation).</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">A.4 Error handling</h3>

    <p class="text-gray-300">In Concerto <em>[5]</em>, if <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> asks for a key that does not exist it receives an error and a proof showing that the key has not been inserted. But, Spice’s SetKV handles this differently as we discuss next. In particular, we discuss how Spice defends against a malicious <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> that can lie and report that a key does not exist when in fact it exists in its state.</p>

    <p class="text-gray-300">In SetKV, we introduce a function called InsertIfNotExists: it calls a new operation RPC(EXISTS) that returns an untrusted hint true (if the key already exists) or false (if the key does not exist). Depending on the untrusted hint, <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> executes insert or get. We essentially force <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> to choose between the two via the untrusted hint. Suppose the key exists but <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> pretends that it does not: this causes the key to be inserted twice, which is caught during audit (due to the uniqueness check). On the other hand, if the key does not exist but <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> claims that it does, InsertIfNotExists behaves like a get. This triggers an RPC(GET), which leads to a bogus entry being added to the read set <span class="math">RS</span> (<span class="math">\\mathcal{P}_{\\mathcal{K}}</span> cannot control the timestamp <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> uses when the key-value-timestamp tuple is added to <span class="math">RS</span>, which prevents it from reordering requests). Since this entry does not appear in <span class="math">WS</span>, audit fails.</p>

    <p class="text-gray-300">We take a similar error handling approach for put and get operations. We define PutIfExists and GetIfExists operations. If <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> erroneously claims that a key does not exist during a PutIfExists (or GetIfExists), a default value for the key is inserted (leading to a double insert), which prevents audit from passing. If, on the other hand, <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> correctly outputs an error when a key does not exist, the operation simply becomes a regular insert with a default value.</p>

    <h2 id="sec-33" class="text-2xl font-bold">Appendix B Multiset collision-resistant hash <span class="math">\\mathcal{H}(\\cdot)</span></h2>

    <p class="text-gray-300">This appendix discusses the details of our incremental multiset collision-resistant hash function, and how Spice encodes it as set of algebraic constraints. Section B.1 gives the high level construction of our hash function based on prior work. Section B.2 proves that we can relax some of the requirements of the underlying hash function; we leverage this new result to propose a more efficient construction in Section B.3.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">B.1 Multiset hash function construction</h3>

    <p class="text-gray-300"><em>Clarke et al. [32]</em> propose several (incremental) set and multiset collision-resistant hash functions. We borrow notation, definitions, and terminology from their paper.</p>

    <p class="text-gray-300">Multiset (respectively, set) hash functions map multisets (respectively, sets) of arbitrary finite size to digests of fixed length with the property that it is computationally infeasible to find two distinct multisets (respectively, sets) of polynomial size that map to the same digest. Any multiset collision-resistant hash function is a set collision-resistant hash function, so we focus on the latter.</p>

    <p class="text-gray-300">Suppose <span class="math">M</span> is a multiset of elements from a countable set <span class="math">B</span>. We denote the number of times an element <span class="math">b\\in B</span> appears in <span class="math">M</span> as <span class="math">M_{b}</span>, and call it the multiplicity of <span class="math">b</span> in <span class="math">M</span>. Suppose <span class="math">H(\\cdot)</span> is a function that maps elements of <span class="math">B</span> to an additive group <span class="math">\\mathbb{G}</span>, that is, <span class="math">H:B\\to\\mathbb{G}</span>. Furthermore, suppose <span class="math">H(\\cdot)</span> is a random oracle. We consider the incremental multiset collision resistant hash function Mset-Mu-Hash from <em>Clarke et al. [32, §5]</em>:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{H}_{H}(M)=\\sum_{b\\in B}H(b)\\cdot M_{b}</span></p>

    <p class="text-gray-300"><em>Clarke et al. [32]</em> prove that the above is a multiset collision-resistant hash function if the discrete logarithm problem is hard in <span class="math">\\mathbb{G}</span> and if <span class="math">H(\\cdot)</span> is a random oracle. Thus, to instantiate Mset-Mu-Hash, we must choose a candidate group <span class="math">\\mathbb{G}</span> where the discrete logarithm problem is hard and also choose a suitable <span class="math">H(\\cdot)</span>.</p>

    <p class="text-gray-300">In Spice’s context, it is more natural to work with <span class="math">\\mathbb{G}=E(\\mathbb{F}_{p})</span> an elliptic curve. Arithmetic over the curve is naturally expressed as arithmetic in <span class="math">\\mathbb{F}_{p}</span>, which is “natively” supported by Spice’s underlying arguments machinery, as observed by prior work <em>[17, 35, 52]</em>. Thus, we need to build a random oracle <span class="math">H:B\\to E(\\mathbb{F}_{p})</span>. This can be done in two steps. First we map from elements in <span class="math">B</span> to <span class="math">\\mathbb{F}_{p}</span> using a hash function <span class="math">R(\\cdot)</span> such as SHA-256, and then map the resulting elements to points in the curve using another function <span class="math">\\phi(\\cdot)</span>. In other words, <span class="math">H(\\cdot)=\\phi(R(\\cdot))</span>.</p>

    <p class="text-gray-300">While we could use many different candidates for <span class="math">R(\\cdot)</span> we want to keep the multiplicative complexity of the mapping <span class="math">B\\to\\mathbb{F}_{p}</span> low. We therefore build a hash function</p>

    <p class="text-gray-300">from an element in <span class="math">B</span> to <span class="math">\\mathbb{F}_{p}</span> using the MiMC block cipher <em>[2]</em>, which has a low multiplicative complexity (we discuss this in Appendix B.3).</p>

    <p class="text-gray-300">We could then use a prior function to map from a random element in <span class="math">\\mathbb{F}_{p}</span> to a point in the curve <em>[20, 47, 74, 79]</em>. However, these functions only map to a fraction of all of the points in <span class="math">E(\\mathbb{F}_{p})</span>, making them easy to differentiate from a random oracle; consequently, they are unsuitable for our purposes. Fortunately, Farashahi et al. <em>[37]</em> show that sums in <span class="math">E(\\mathbb{F}_{p})</span> of multiple invocations of these mapping functions are indifferentiable from a uniform random mapping to a point in <span class="math">E(\\mathbb{F}_{p})</span>. The drawback of this approach is that it requires computing mapping functions multiple times, which is expensive. We avoid this overhead by relaxing requirements on <span class="math">H(\\cdot)</span>. We then build a mapping function <span class="math">\\phi(\\cdot)</span> directly from the Elligator-2 map <em>[20]</em>, as we discuss next.</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">B.2 Relaxing requirements on <span class="math">H(\\cdot)</span></h3>

    <p class="text-gray-300">We now show that the random oracle requirement on <span class="math">H(\\cdot)</span> can be relaxed, while still ensuring that <span class="math">\\mathcal{H}_{H}</span> (based on Mset-Mu-Hash) remains an incremental multiset collision-resistant hash function. The relaxation that we present below allows us to use a more efficient construction for <span class="math">H(\\cdot)</span> (we give the details in Appendix B.3).</p>

    <p class="text-gray-300">Throughout, we assume <span class="math">\\mathbb{G}</span> is a group on which discrete logarithms take <span class="math">\\sim 2^{\\lambda}</span> steps, and all polynomial or negligible factors are functions of <span class="math">\\lambda</span> (i.e., <span class="math">\\lambda</span> is the security parameter). Recall from the prior section that <span class="math">H(\\cdot)</span> is a random oracle from a multiset to an element in <span class="math">\\mathbb{G}</span>. Furthermore, recall that we compute <span class="math">H:B\\to\\mathbb{G}</span> with a composition of two functions: <span class="math">R:B\\to S</span> and <span class="math">\\phi:S\\to\\mathbb{G}</span>. <span class="math">R</span> hashes multisets to some arbitrary set <span class="math">S</span> (e.g., binary strings, <span class="math">\\mathbb{F}_{p}</span>), and <span class="math">\\phi</span> maps elements in <span class="math">S</span> to an element in <span class="math">\\mathbb{G}</span>.</p>

    <p class="text-gray-300">Claim. We prove that <span class="math">\\mathcal{H}_{H}</span> remains multiset collision-resistant even when <span class="math">\\phi(\\cdot)</span> is not indifferentiable from a random oracle, assuming that <span class="math">R(\\cdot)</span> is a random oracle. Using the notation of <em>[59]</em>, we have:</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Theorem B.1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{G}=\\mathbb{G}_{1}\\oplus\\mathbb{G}_{2}</span> be a cyclic group with <span class="math">\\mathbb{G}_{1}</span> prime. Let <span class="math">S</span> be an arbitrary set, <span class="math">R:B\\to S</span> be a random oracle, and <span class="math">\\phi:S\\to\\mathbb{G}</span> be an efficiently computable partial function such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\forall x\\in\\mathbb{G}</span>, the set <span class="math">\\phi^{-1}(x)</span> is computable in polynomial time and has size <span class="math">\\leq\\alpha</span> for <span class="math">\\alpha\\in\\mathbb{N}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\mathbb{E}_{x}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi^{-1}(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\alpha)\\geq 1/\\beta<span class="math"> for </span>\\beta$ bounded.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then if the discrete logarithm problem in <span class="math">\\mathbb{G}_{1}</span> is hard, <span class="math">\\mathcal{H}_{\\phi\\circ R}</span> is a multiset collision resistant hash function</p>

    <p class="text-gray-300">This is a generalization of the results in <em>[59]</em>, which apply only to total functions. The intuition behind the proof is that if <span class="math">R(\\cdot)</span> is a random oracle, we can sample outputs of <span class="math">\\phi\\circ R</span> in <span class="math">\\mathbb{G}</span> with known logarithms, by first choosing the logarithm, choosing a random preimage under <span class="math">\\phi(\\cdot)</span> with some probability, and using these to fix the random oracle on certain inputs. Then if multiset collisions for <span class="math">\\mathcal{H}_{\\phi\\circ R}</span> are found, we recover a random linear relation between logarithms, which allows us to find discrete logarithms quickly in <span class="math">\\mathbb{G}</span>, resulting in a contradiction.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">G</span> be a generator of <span class="math">\\mathbb{G}</span>, and fix a point <span class="math">P\\in\\mathbb{G}</span> to be determined later. Consider the following randomized function <span class="math">F</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Sample $e,f\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}\\{0,\\ldots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1\\}<span class="math">, set </span>Y=eP+fG$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose <span class="math">h\\in\\phi^{-1}(Y)</span> uniformly at random.</li>

      <li>Return <span class="math">(h,e,f)</span>.</li>

    </ol>

    <h6 id="sec-38" class="text-base font-medium mt-4">Lemma B.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">(h,e,f)\\leftarrow F(P)</span>, then <span class="math">e</span> is uniformly random in $\\{0,\\ldots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1\\}<span class="math"> and independent of </span>h<span class="math">, and the distribution of </span>h<span class="math"> is within statistical distance </span>2\\epsilon<span class="math"> of uniform over </span>S$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-39" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As <span class="math">G</span> generates <span class="math">\\mathbb{G}</span>, <span class="math">Y</span> is independent of <span class="math">e</span> and uniform in <span class="math">\\mathbb{G}</span>. Since the probability of a sampled value for <span class="math">e</span> being returned as the output of <span class="math">S</span> is determined by <span class="math">Y</span>, and <span class="math">e</span> is sampled uniformly, the returned values of <span class="math">e</span> are uniform in $\\{0,\\ldots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1\\}<span class="math">. For a fixed </span>h<span class="math">, if a sample at (1) causes </span>h$ to be returned, the following events must occur:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Y=\\phi(h)</span></li>

      <li>We do not return to (1) at (2)</li>

      <li><span class="math">h</span> is chosen from <span class="math">\\phi^{-1}(Y)</span></li>

    </ul>

    <p class="text-gray-300">These are independent, and <span class="math">Y</span> is uniform in <span class="math">\\mathbb{G}</span> as discussed. So the probability that any given sample at (1) causes <span class="math">h</span> to be returned is:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\cdot\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi^{-1}(Y)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\alpha}\\cdot\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi^{-1}(Y)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}=\\frac{1}{\\alpha\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since the above is independent of <span class="math">h</span>, the returned values of <span class="math">h</span> are uniform over <span class="math">\\phi^{-1}(\\mathbb{G})</span>. Recall from our third requirement in Theorem B.1 that <span class="math">\\phi^{-1}(\\mathbb{G})</span> is a subset of <span class="math">S</span> of size greater than $(1-\\epsilon)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Hence, the statistical distance between the distribution of </span>h<span class="math"> and a uniform distribution over </span>S<span class="math"> is </span>\\leq 2\\epsilon$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We replace <span class="math">H(\\cdot)</span> with a function <span class="math">\\tilde{F}(\\cdot)</span>, which when called on a new input, samples <span class="math">(h,e,f)\\leftarrow F(P)</span>, retains <span class="math">(h,e,f)</span>, and returns <span class="math">h</span>. On later calls with the same input it returns the retained <span class="math">h</span>. Since the distribution of <span class="math">h</span> is within <span class="math">2\\epsilon</span> of uniform over <span class="math">S</span> and <span class="math">H</span> is invoked at most <span class="math">\\text{poly}(\\lambda)</span> times, this can be detected with advantage <span class="math">\\leq 2\\cdot\\epsilon\\cdot\\text{poly}(\\lambda)=\\text{negl}(\\lambda)</span>. Hence it suffices to show:</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Lemma B.2.</h6>

    <p class="text-gray-300">If the discrete logarithm problem in <span class="math">\\mathbb{G}</span> is hard, then it is infeasible to find two distinct multisets <span class="math">A,B</span> with multiplicities <span class="math">&lt;poly(\\lambda)</span> such that <span class="math">\\mathcal{H}_{\\phi\\circ\\tilde{F}}(A)=\\mathcal{H}_{\\phi\\circ\\tilde{F}}(B)</span>.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We give a reduction from finding logarithms in <span class="math">\\mathbb{G}</span> of elements of <span class="math">\\mathbb{G}_{1}</span> to finding collisions. This suffices to find logarithms in <span class="math">\\mathbb{G}_{1}</span>. We are given <span class="math">P\\in\\mathbb{G}_{1}</span>, and we wish to find <span class="math">s</span> such that <span class="math">s\\cdot G=P</span>. Construct <span class="math">\\tilde{F}</span> as above, and assume that a collision is found. Then we have:</p>

    <p class="text-gray-300"><span class="math">\\sum_{s\\in A}\\phi(\\tilde{F}(x))-\\sum_{x\\in B}\\phi(\\tilde{F}(x))=0</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Without loss of generality, we can assume <span class="math">A</span> and <span class="math">B</span> are disjoint, as removing an element from both <span class="math">A,B</span> yields a smaller pair of colliding multisets. Let <span class="math">\\{x_{1},\\ldots x_{k}\\}</span> be the set of distinct elements of <span class="math">A,B</span>, and let <span class="math">r_{i}=A_{x_{i}}-B_{x_{i}}</span> mod $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Then since </span>A_{x_{i}},B_{x_{i}}\\in\\{0,\\ldots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1\\}<span class="math">, these </span>r_{i}<span class="math"> are not all </span>0<span class="math">. Note also that </span>\\phi(\\tilde{F}(x_{i}))=e_{i}P+f_{i}G<span class="math">, for </span>e_{i},f_{i}$ known. Then:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\sum_{i}r_{i}\\phi(\\tilde{F}(x_{i}))=\\left(\\sum_{i}r_{i}e_{i}\\right)P+\\left(\\sum_{i}r_{i}f_{i}\\right)G=0</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">in the curve. The <span class="math">e_{i}</span> are independent, uniformly random in $\\{0,\\ldots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1\\}<span class="math">. Recall </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=p<span class="math"> a prime, so </span>p\\not</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{i}r_{i}e_{i}<span class="math"> with probability </span>1-1/p$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If <span class="math">\\sum_{i}r_{i}e_{i}</span> has an inverse <span class="math">c</span> modulo <span class="math">p</span>, we obtain:</p>

    <p class="text-gray-300"><span class="math">P=\\left(-c\\sum_{i}r_{i}f_{i}\\right)G\\Rightarrow s=-c\\sum_{i}r_{i}f_{i}.</span></p>

    <p class="text-gray-300">Hence a multiset collision in <span class="math">\\mathcal{H}_{\\phi\\circ\\tilde{F}}</span> recovers a logarithm in polynomial time with probability <span class="math">1-1/p&gt;1/2</span>. By repeating this process, we can amplify the success probability and recover a logarithm in polynomial time. ∎</p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">B.3 Instantiating <span class="math">H</span> (<span class="math">R</span> and <span class="math">\\phi</span>)</h3>

    <h6 id="sec-43" class="text-base font-medium mt-4">Corollary B.1.</h6>

    <p class="text-gray-300">Let <span class="math">E</span> be an elliptic curve with a point of order 2. Let <span class="math">\\phi</span> be the Elligator-2 map <em>[20]</em>. If <span class="math">R:B\\to\\mathbb{F}_{p}</span> is a random oracle and the discrete logarithm problem in <span class="math">E(\\mathbb{F}_{p})</span> is hard, then <span class="math">\\mathcal{H}_{\\phi\\circ R}</span> is multiset collision resistant.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We take <span class="math">S=\\mathbb{F}_{p}</span>, <span class="math">\\mathbb{G}=E(\\mathbb{F}_{p})</span>, and <span class="math">R</span> as discussed below. It suffices to check that <span class="math">\\phi</span> meets the conditions of Theorem B.1.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\phi</span> produces, for all but at most 6 points in <span class="math">\\mathbb{F}_{p}</span>, an element of <span class="math">E(\\mathbb{F}_{p})</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The preimage of any point <span class="math">(x,y)\\in Im(\\phi)</span> is guaranteed to be of form <span class="math">\\{r,-r\\}</span>. Hence $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Im(\\phi)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>(p-7)/2<span class="math">, and so </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi(S)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1/2+O(p^{-1/2})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Im(\\phi)</span> is the set of points <span class="math">(x,y)</span> in <span class="math">E(\\mathbb{F}_{p})</span> such that <span class="math">x\\neq-A</span>, <span class="math">y=0</span> implies <span class="math">x=0</span>, and <span class="math">-ux\\cdot(x+A)</span> is square in <span class="math">\\mathbb{F}_{p}</span>. On this set <span class="math">\\phi</span> is invertible <em>[20]</em>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Take <span class="math">\\alpha</span> = 2, and $\\mathbb{E}_{\\tau}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi^{-1}(r)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\alpha)\\geq 1-7/2p>\\beta<span class="math">. If discrete logarithms in </span>E(\\mathbb{F}_{p})<span class="math"> are hard, there must be a prime subgroup of </span>E(\\mathbb{F}_{p})<span class="math"> of order </span>q<span class="math"> on which the discrete logarithm problem is hard. Sampling </span>\\mathbb{G}_{2}<span class="math"> is trivial, as this is the set of multiples of </span>q<span class="math"> in </span>\\mathbb{G}$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In our case, we have <span class="math">E(\\mathbb{F}_{p})=4r</span> where <span class="math">r</span> is a prime since we choose <span class="math">E</span> to be a Twisted Edwards curve.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Instantiating <span class="math">R</span>.</h6>

    <p class="text-gray-300">The MiMC-<span class="math">n/n</span> block cipher <em>[2]</em>. is defined over <span class="math">\\mathbb{F}_{2^{n}}</span>; it iterates the following function:</p>

    <p class="text-gray-300"><span class="math">x\\to(x\\oplus k\\oplus c_{i})^{3},</span></p>

    <p class="text-gray-300">where <span class="math">c_{i}</span> are round constants and <span class="math">k</span> is the key. The number of rounds is chosen such that the degree of MiMC-<span class="math">n/n(x,k)</span> as a polynomial in <span class="math">x</span> is <span class="math">\\sim 2^{n}</span>.</p>

    <p class="text-gray-300">In Spice’s context, we instantiate the above block cipher over <span class="math">\\mathbb{F}_{p}</span>. Furthermore, in our choice of <span class="math">p</span>, <span class="math">\\gcd(3,p-1)&gt;1</span> so the above cubing function is not a permutation over <span class="math">\\mathbb{F}_{p}</span>. However, <span class="math">\\gcd(5,p-1)=1</span>, so we define the following keyed permutations:</p>

    <p class="text-gray-300"><span class="math">F_{i,k}(x)</span> <span class="math">=(x+k+c_{i})^{5}</span> <span class="math">F_{k}(x)</span> <span class="math">=(F_{r-1,k}\\circ F_{r-2,k}\\circ\\ldots\\circ F_{0,k})(x)+k</span></p>

    <p class="text-gray-300">where <span class="math">c_{i}</span> a sequence of round constants. We choose <span class="math">r</span> such that <span class="math">\\deg(F_{k})\\sim 2^{\\lambda}</span>. We then define a compression function by using <span class="math">F_{k}</span> in the Miyaguchi-Preneel construction, and build <span class="math">R(\\cdot)</span> from this compression function by the Merkle-Damgård construction. Specifically, it proceeds as follows:</p>

    <p class="text-gray-300"><span class="math">h_{0}</span> <span class="math">=\\mathrm{iv}</span> <span class="math">h_{i}</span> <span class="math">=h_{i-1}+m_{i}+F_{h_{i-1}}(m_{i})</span> <span class="math">R(\\{m_{i}\\}_{i=1}^{\\alpha})</span> <span class="math">=h_{\\ell}</span></p>

    <h2 id="sec-46" class="text-2xl font-bold">Appendix C Security of Spice</h2>

    <p class="text-gray-300">In Appendix C.1 we show that the SetKV protocol of Section 3.1 is correct and sound. Appendix C.2 then proves that C-SetKV and Spice (§4) provide sequential consistency (and in some cases, a notion of linearizability).</p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">C.1 Proof of SetKV</h3>

    <p class="text-gray-300">We adapt the proof given in Concerto <em>[5]</em> to our design. We assume throughout this section that all operations use the error handling procedures described in Appendix A.4. We denote RPC procedures (e.g., RPC(GET)) with capital letters (“GET”).</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Lemma C.1 (ideal audit).</h6>

    <p class="text-gray-300">If <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> tracks sets (i.e., read-set RS and write-set WS) instead of set-digests following the</p>

    <p class="text-gray-300">logic in Figure 2, then audit returns true if and only if SetKV returns, for every get operation on a key <span class="math">k</span>, the value written by the most recent put (or insert) to <span class="math">k</span>.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The reverse direction (i.e., that the protocol is correct) is straightforward. The timestamp field in VKState is updated after every operation so every element is unique. After <span class="math">k</span> successful insert operations, there are <span class="math">k</span> entries added to the write set WS. Each put and get adds exactly one entry to RS (in particular the entry with the highest timestamp for a given key in WS) and one entry to WS (the entry read but with a larger timestamp and a potentially new value). audit scans through all the elements in the key-value store (<span class="math">\\mathcal{K}</span>), and adds <span class="math">k</span> entries to RS (in particular the entries with the highest timestamp for each key in WS). As a result, RS and WS have the same number of entries, and these entries are the same when <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> behaves correctly.</p>

    <p class="text-gray-300">We prove the forward direction (i.e., that the protocol is sound) by contradiction. Suppose that <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> misbehaves and yet audit passes. Then there exists some GET(<span class="math">k</span>) call that returns a value inconsistent with the previous write to key <span class="math">k</span>. We show that this is not possible.</p>

    <p class="text-gray-300">The audit passes only when <span class="math">RS\\cup M=WS</span> and when keys has no duplicates. These two checks imply that there could be no two inserts with the same key (otherwise either <span class="math">RS\\cup M\\neq WS</span> or keys has duplicates). Let <span class="math">H</span> be the history of invocation/response pairs of INSERT, PUT, and GET RPCs. Consider the earliest inconsistent GET in <span class="math">H</span>, and call it <span class="math">g_{i}</span>. Let <span class="math">(k_{i},v_{i})</span> be the key-value pair associated with <span class="math">g_{i}</span>; consequently <span class="math">(k_{i},v_{i})\\in RS</span> due to Line 10 in Figure 2 (note that put also results in an GET, see the caption of Figure 2 for more details). If <span class="math">(k_{i},v_{i})\\not\\in WS</span>, then <span class="math">RS\\cup M\\neq WS</span> for any <span class="math">M</span>, so the audit could not have passed, which leads to a contradiction.</p>

    <p class="text-gray-300">If <span class="math">(k_{i},v_{i})</span> does occur in WS, then the unique PUT or INSERT that writes <span class="math">(k_{i},v_{i})</span> should occur in <span class="math">H</span> before <span class="math">g_{i}</span>. Call this operation <span class="math">w</span>. This is due to the fact that timestamps increase monotonically and that after Line 11 the timestamp associated with the value of key <span class="math">k_{i}</span> is incremented (so no further operation can add a value with a lower timestamp to WS). Consider <span class="math">g</span> to be the first GET for key <span class="math">k</span> after operation <span class="math">w</span>. If <span class="math">g=g_{i}</span>, then <span class="math">g_{i}</span> would be consistent which contradicts our setup. Hence, <span class="math">g</span> is a GET that occurs before <span class="math">g_{i}</span>. Furthermore, since <span class="math">g_{i}</span> is the earliest inconsistent GET, then <span class="math">g</span> must be consistent and as a result it must add <span class="math">(k_{i},v_{i})</span> to <span class="math">RS</span>. This means that <span class="math">(k_{i},v_{i})</span> occurs at least twice in <span class="math">RS</span>. Given that WS has no repeated entries, this implies that <span class="math">RS\\cup M\\neq WS</span> for any <span class="math">M</span> and audit fails, which yields a contradiction. ∎</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Lemma C.2 (Digest audit completeness).</h6>

    <p class="text-gray-300">If the ideal audit returns true, the audit using set-digests instead of sets returns true.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We assume that <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> uses a set (or a multiset) collision resistant hash function <span class="math">\\mathcal{H}(\\cdot)</span> to produce set-digests instead of keeping track of <span class="math">RS</span> and <span class="math">WS</span> explicitly. Correctness follows immediately from the correctness of <span class="math">\\mathcal{H}(\\cdot)</span> <em>[32]</em>. ∎</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Lemma C.3 (Digest audit soundness).</h6>

    <p class="text-gray-300">If the ideal audit returns false, the audit using set-digests instead of sets returns true with negligible probability.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove this by reduction to the set collision resistant property of <span class="math">\\mathcal{H}(\\cdot)</span>. Assume that for sets <span class="math">RS</span> and <span class="math">WS</span>, and a list of keys, audit returns false. Meanwhile, for <span class="math">rs\\leftarrow\\mathcal{H}(RS)</span>, <span class="math">ws\\leftarrow\\mathcal{H}(WS)</span>, and keys, audit returns true. Since keys is the same in both cases, and the uniqueness check ensures there are no duplicates, this means that the ideal audit returns false because <span class="math">RS\\neq WS</span> (and not because keys had duplicates, as otherwise the digest audit would fail too). Since the digest audit returns true, we have that <span class="math">rs=ws</span> despite <span class="math">RS\\neq WS</span>. This constitutes a collision in <span class="math">\\mathcal{H}(\\cdot)</span>, but the probability of finding any collision in <span class="math">\\mathcal{H}(\\cdot)</span> is negligible. ∎</p>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">C.2 Proof of C-SetKV and Spice</h3>

    <p class="text-gray-300">We reason about C-SetKV in isolation and prove that it ensures sequential consistency <em>[54]</em> when processing concurrent requests (§4.1). We then show that C-SetKV can also guarantee linearizability <em>[46]</em> under certain conditions. Finally, prior results (e.g., <em>[26, Appendix A]</em>) establish that composing a verifiable storage primitive, such as C-SetKV, with efficient arguments (e.g., as we do in Spice) preserves the above consistency semantics.</p>

    <p class="text-gray-300">To prove C-SetKV’s consistency semantics, we adapt the proof given in Appendix C.1 and a proof in Concerto <em>[5]</em> to our particular design. Unlike the prior section, there are multiple instances of <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>; we denote them as: <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(1)},\\ldots</span>, <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(\\ell)}</span>. Recall that each of these verifiers starts with a timestamp <span class="math">ts</span> initialized to 0, and executes a sequence of key-value store operations and maintain a local VKState object. To execute audit, they obtain the VKState of all other verifiers and combine them. That is, they compute <span class="math">rs_{comb}=rs_{1}\\odot rs_{2}\\odot\\ldots rs_{\\ell}</span>, where <span class="math">rs_{1},\\ldots,rs_{\\ell}</span> are the read set-digests of different verifiers. The same is done for the write set-digest (<span class="math">ws</span>). The timestamp of the combined VKState object is set to 0.</p>

    <p class="text-gray-300">We prove the two versions of C-SetKV: the one given in Appendix A.1 that uses a unique id and a set collision-resistant hash function, and the one described in the main text (§4) that relies on a multiset collision-resistant hash function. We denote RPC procedures (e.g., RPC(GET)) with capital letters (“GET”).</p>

    <h4 id="sec-55" class="text-lg font-semibold mt-6">C.2.1 Proof of C-SetKV with unique ids</h4>

    <h6 id="sec-56" class="text-base font-medium mt-4">Lemma C.4 (Ideal audit using unique ids).</h6>

    <p class="text-gray-300">If each <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(i)}</span> keeps track of sets (i.e., read-set <span class="math">RS^{(i)}</span> and write-set <span class="math">WS^{(i)}</span>)</p>

    <p class="text-gray-300">instead of set-digests following the logic in Figure 2 (and the unique ids modification in Appendix A.1), then audit returns true if and only if C-SetKV respects sequential consistency.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The reverse direction (i.e., that the protocol is correct) is straightforward and is similar to Lemma C.1. We prove the forward direction (i.e., that the protocol is sound) by contradiction.</p>

    <p class="text-gray-300">Suppose that <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> misbehaves, so C-SetKV does not provide sequential consistency, and yet audit passes. Then, there exists some GET RPC that returns a value inconsistent with the previous write to the same key. We show that this is not possible.</p>

    <p class="text-gray-300">Let <span class="math">RS</span> denote the union of read sets from all the threads; and <span class="math">WS</span> denote the union of write sets from all the instances of <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>. Since each <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(j)}</span> has a Lamport clock consisting of the unique identifier of <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(j)}</span> and a monotonically increasing timestamp, there are no duplicates in any of the local write sets and hence no duplicates in <span class="math">WS</span>. The audit passes only when <span class="math">RS\\cup M=WS</span> (for some set <span class="math">M</span>) and when keys has no duplicates. These two checks imply that there could be no two inserts with the same key (otherwise either <span class="math">RS\\cup M\\neq WS</span> or keys has duplicate).</p>

    <p class="text-gray-300">Let <span class="math">L^{(j)}</span> be the history of invocation/response pairs of INSERT, PUT, and GET requests associated with <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(j)}</span>. Consider the sequence <span class="math">L_{comb}</span> that contains all operations in <span class="math">L^{(j)}</span>, for all <span class="math">j\\in[1,\\ell]</span> ordered first by their timestamp field <span class="math">ts</span>, then PUT and INSERT precede GET, and finally by the <span class="math">tid</span> field to break ties. Within each <span class="math">L^{(j)}</span> timestamps increase monotonically; thus, the ordering of operations in <span class="math">L_{comb}</span> respects the ordering of operations issued by each <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> instance.</p>

    <p class="text-gray-300">By assumption, <span class="math">L_{comb}</span> does not obey sequential consistency. Consider the earliest inconsistent GET in <span class="math">L_{comb}</span>, and call it <span class="math">g_{i}</span>. Let <span class="math">(k_{i},v_{i},ts_{i},tid_{i})</span> be the key, value, timestamp and thread-id tuple associated with <span class="math">g_{i}</span>; consequently <span class="math">(k_{i},v_{i},ts_{i},tid_{i})\\in RS</span> due to Line 10 in Figure 2 (note that put requests also result in an GET operation, see the caption of Figure 2 for more details). If <span class="math">(k_{i},v_{i},ts_{i},tid_{i})\\not\\in WS</span>, then <span class="math">RS\\cup M\\neq WS</span> for any <span class="math">M</span>, so the audit could not have passed, which leads to a contradiction.</p>

    <p class="text-gray-300">If <span class="math">(k_{i},v_{i},ts_{i},tid_{i})</span> does occur in <span class="math">WS</span>, the unique PUT or INSERT that writes <span class="math">(k_{i},v_{i},ts_{i},tid_{i})</span> should occur in <span class="math">L_{comb}</span> before <span class="math">g_{i}</span>. Call this operation <span class="math">w</span>. This is due to the fact that timestamps increase after every operation: after <span class="math">g_{i}</span>, the timestamp of <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(tid_{i})}</span> is incremented in Line 11 so no further operation can add an element with thread id <span class="math">tid_{i}</span> and a timestamp that is less than or equal to <span class="math">ts_{i}</span> to the set <span class="math">WS</span>. Consider <span class="math">g</span> to be the first GET of key <span class="math">k</span> after operation <span class="math">w</span>. If <span class="math">g=g_{i}</span>, then <span class="math">g_{i}</span> would be consistent which contradicts our setup. Hence, <span class="math">g</span> is an GET that occurs before <span class="math">g_{i}</span>. Furthermore, since <span class="math">g_{i}</span> is the earliest inconsistent GET, then <span class="math">g</span> must be consistent and as a result it must add <span class="math">(k_{i},v_{i},ts_{i},tid_{i})</span> to <span class="math">RS</span>. This means that <span class="math">(k_{i},v_{i},t_{i},tid_{i})</span> occurs at least twice in <span class="math">RS</span>. Given that <span class="math">WS</span> has no repeated entries, this implies that <span class="math">RS\\cup M\\neq WS</span> for any <span class="math">M</span> and audit fails, which yields a contradiction.</p>

    <p class="text-gray-300">∎</p>

    <h4 id="sec-58" class="text-lg font-semibold mt-6">C.2.2 Proof of C-SetKV with multisets</h4>

    <h6 id="sec-59" class="text-base font-medium mt-4">Definition C.1 (<span class="math">t</span>-reachable submultiset).</h6>

    <p class="text-gray-300">Let <span class="math">M_{b}</span> denote the multiplicity of element <span class="math">b</span> in a multiset <span class="math">M</span>. Let <span class="math">X</span> and <span class="math">Y</span> be multisets of elements from a set <span class="math">D</span>. We say that <span class="math">X</span> is a <span class="math">t</span>-reachable submultiset of <span class="math">Y</span> if for all <span class="math">b\\in D</span>:</p>

    <p class="text-gray-300"><span class="math">Y_{b}\\geq X_{b}\\land Y_{b}-X_{b}\\leq t</span></p>

    <p class="text-gray-300">In other words, <span class="math">X\\subseteq Y</span> and it is possible to make <span class="math">X</span> equal to <span class="math">Y</span> by adding to <span class="math">X</span> at most <span class="math">t</span> copies of each element in <span class="math">D</span>.</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Lemma C.5 (Audit requires 1-reachable submultiset).</h6>

    <p class="text-gray-300">If the read multiset <span class="math">RS</span> is not a 1-reachable submultiset of the write multiset <span class="math">WS</span>, an ideal audit (that acts on multisets instead of digests) returns false.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Observe that if keys has duplicates then audit returns false (Figure 2, Line 21). Therefore for audit to return true, the state supplied by <span class="math">\\mathcal{P}_{\\mathcal{K}}</span>, call it <span class="math">M</span>, cannot contain duplicate entries since each key must be unique. As a result, the multiplicity of all elements in <span class="math">M</span> is 1, which implies that <span class="math">RS\\cup M=WS</span> only if <span class="math">RS</span> is a 1-reachable submultiset of <span class="math">WS</span>. Consequently, if <span class="math">RS</span> is not a 1-reachable submultiset of <span class="math">WS</span> audit returns false. ∎</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Lemma C.6 (At most one insert).</h6>

    <p class="text-gray-300">If there is more than one insert to a given key, audit returns false.</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">If there are two or more insert operations to a key <span class="math">k</span>, then the number of elements in the write set <span class="math">WS</span> that have key <span class="math">k</span> is at least 2 greater than the number of elements with key <span class="math">k</span> in the read set <span class="math">RS</span> (since insert does not add entries to <span class="math">RS</span>, and all other operations add entries to both). Therefore, <span class="math">RS</span> is not a 1-reachable submultiset of <span class="math">WS</span>, and as a result audit returns false. ∎</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Lemma C.7 (Ideal audit using multisets).</h6>

    <p class="text-gray-300">If each <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(i)}</span> keeps track of multisets (i.e., read multiset <span class="math">RS^{(i)}</span> and write multiset <span class="math">WS^{(i)}</span>) instead of set-digests following the logic in Figure 2, then audit returns true if and only if C-SetKV respects sequential consistency.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The reverse direction (i.e., that the protocol is correct) is straightforward and is similar to Lemma C.1. We now prove the forward direction (i.e., that the protocol is sound).</p>

    <p class="text-gray-300">We are given that audit returns true. Let <span class="math">RS</span> denote the union of read sets from all instances of <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>; and <span class="math">WS</span> denote the union of write-sets from all the instances of <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>. Since each <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(j)}</span> has a monotonically increasing timestamp, there are no duplicates in any of the local write sets, but there</p>

    <p class="text-gray-300">may be duplicates across different instances of <span class="math">\\mathcal{V}_{\\mathcal{K}}</span>, so <span class="math">WS</span> is a multiset. audit returns true only if there exists <span class="math">M</span> such that <span class="math">RS\\cup M=WS</span>, so <span class="math">RS\\subseteq WS</span>. Furthermore, since audit returns true there is at most one insert operation to the same key (Lemma C.6).</p>

    <p class="text-gray-300">Let <span class="math">L^{(j)}</span> be the history of invocation/response pairs of INSERT, PUT, and GET requests associated with a <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(j)}</span>. Consider the sequence <span class="math">L_{comb}</span> that contains all operations in <span class="math">L^{(j)}</span>, for all <span class="math">j\\in[1,\\ell]</span>, ordered first by their timestamp field <span class="math">ts</span>, then PUT and INSERT precede GET, and finally by the identifier of the history they came from (i.e., <span class="math">j</span> is the identifier of the history for <span class="math">L^{(j)}</span>). We now prove that <span class="math">L_{comb}</span> respects sequential consistency. This requires proving two conditions on <span class="math">L_{comb}</span>. First, the ordering of operations in <span class="math">L_{comb}</span> respects the ordering of operations issued by each <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> instance. Second, the history is read-write consistent (i.e., a get on a key returns the value written by the most recent put or insert on the same key). The first condition holds because within each <span class="math">L^{(j)}</span> timestamps increase monotonically; thus, the ordering of operations in <span class="math">L_{comb}</span> respects the ordering of operations issued by each <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(j)}</span>. We now prove the second condition.</p>

    <p class="text-gray-300">Since <span class="math">RS\\subseteq WS</span>, there exists an injective function that maps every element in <span class="math">RS</span> to an element in <span class="math">WS</span>. This is because GET adds an element into <span class="math">RS</span> and the other RPCs add an element to <span class="math">WS</span>. We now establish that this function respects the ordering of operations in <span class="math">L_{comb}</span>. What we mean by this is that we pair up each GET with a prior PUT (or INSERT) such that the GET appears later than the PUT (or INSERT) and GET returns the value written by PUT (or INSERT). We do this by induction.</p>

    <p class="text-gray-300"><em>Base case.</em> For each key <span class="math">k</span>, we find the earliest GET in <span class="math">L_{comb}</span>, call it <span class="math">g</span>; we then identify the unique INSERT that wrote the key-value-timestamp tuple returned by <span class="math">g</span>. If we cannot find such an INSERT, it leads to a contradiction as discussed next. If the tuple returned by <span class="math">g</span> is not written by a prior PUT or INSERT, then the tuple (which exists in <span class="math">RS</span>) does not belong to <span class="math">WS</span>, so <span class="math">RS\\not\\subseteq WS</span> (a contradiction). If the tuple returned by <span class="math">g</span> is written by a prior PUT, then observe that in Figure 2 PUT RPCs are always preceded by a GET to the same key. Therefore, <span class="math">g</span> is not the earliest GET to key <span class="math">k</span> (a contradiction).</p>

    <p class="text-gray-300"><em>Inductive hypothesis.</em> Assume that, for each key <span class="math">k</span>, there exists a sequence of <span class="math">i</span> alternating GET and PUT operations to key <span class="math">k</span> following an INSERT to key <span class="math">k</span> such that the sequence is read-write consistent.</p>

    <p class="text-gray-300"><em>Inductive step.</em> We now show that the <span class="math">(i+1)</span>th GET (call it <span class="math">q</span>) returns the value written by the <span class="math">i</span>th PUT. Suppose it does not. There are two cases. First, <span class="math">q</span> returns a value that is not in <span class="math">WS</span>, then <span class="math">RS\\not\\subseteq WS</span> (a contradiction). Second, <span class="math">q</span> returns a prior key-value-timestamp tuple. Then the corresponding PUT or INSERT must appear earlier in <span class="math">L_{comb}</span> because <span class="math">L_{comb}</span> is ordered by timestamp and PUT and INSERT precede GETs. Since all earlier operations have already been paired with a GET RPC (say <span class="math">q^{\\prime}\\neq q</span>) it means two GET RPCs (i.e., both <span class="math">q</span> and <span class="math">q^{\\prime}</span>) returned the same tuple. This implies that there exists two copies of the tuple in <span class="math">RS</span> and a single copy of the tuple in <span class="math">WS</span> (since there are no duplicate INSERTs). As a result, <span class="math">RS\\not\\subseteq WS</span>, so audit could not have passed. A contradiction. ∎</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Lemma C.8 (Digest audit completeness).</h6>

    <p class="text-gray-300">If the ideal audit returns true, the audit using set-digests instead of sets (and multisets) returns true.</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The argument is similar to Lemma C.2. ∎</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Lemma C.9 (Digest audit soundness).</h6>

    <p class="text-gray-300">If the ideal audit returns false, the audit using set-digests instead of sets (and multisets) returns true with negligible probability.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The argument is similar to Lemma C.3 when applied to Lemma C.4 or C.7. ∎</p>

    <h4 id="sec-70" class="text-lg font-semibold mt-6">C.2.3 C-SetKV’s linearizability semantics</h4>

    <p class="text-gray-300">We consider C-SetKV in the following setting: there is a sequence of batches where each batch contains a set of concurrent key-value store operations. <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> executes the operations in each batch concurrently and runs audit at the end of each batch.</p>

    <p class="text-gray-300">We now discuss when C-SetKV guarantees <em>linearizability</em> <em>[46]</em>, which, in addition to sequential consistency, preserves a notion of real-time as discussed next. Suppose <span class="math">x_{1}</span> and <span class="math">x_{2}</span> are two key-value store operations executed by <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> where <span class="math">x_{2}</span> was issued (by a <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> instance) after <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> has returned a response for <span class="math">x_{1}</span>. Linearizability requires not only that these operations execute atomically but also that <span class="math">x_{2}</span> <em>observes the effects</em> of <span class="math">x_{1}</span>. In other words, linearizability requires that the behavior of the key-value store (i.e., responses) be equivalent to the case where <span class="math">x_{1}</span> and <span class="math">x_{2}</span> were issued sequentially one after the other.</p>

    <p class="text-gray-300">In C-SetKV, requests in the same batch are concurrent (and hence have no real-time guarantees), but requests in batch <span class="math">i+1</span> execute after requests in batch <span class="math">i</span>, and hence must observe their effect. We prove this below.</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Lemma C.10.</h6>

    <p class="text-gray-300">C-SetKV satisfies linearizability across batches if and only if audit returns true.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof is by induction. The base case is that the key-value store is empty and no operations were issued. It satisfies linearizability trivially. Assume linearizability holds for the first <span class="math">i</span> batches. We now show that under the above definition of concurrent requests, audit returns true for the <span class="math">(i+1)</span>th batch if and only if C-SetKV satisfies linearizability. The reverse direction (i.e., if linearizability holds audit returns true) is simple and similar to Lemma C.1, so we omit it.</p>

    <p class="text-gray-300">By the inductive hypothesis, linearizability holds for the first <span class="math">i</span> batches. This means that there exists a linear</p>

    <p class="text-gray-300">ordering of all requests in the first <span class="math">i</span> batches such that: (1) if we executed operations in that linear order one by one, each operation returns a response consistent with the already observed output for that request, and (2) the linear ordering respects real-time constrains (i.e., if an operation <span class="math">x_{2}</span> was issued after <span class="math">x_{1}</span> and both belong to different batches, <span class="math">x_{1}</span> appears before <span class="math">x_{2}</span> in the linear order). We are also given audit returns true for the previous <span class="math">i</span> batches and the <span class="math">(i+1)</span>th batch. audit returns true for the <span class="math">(i+1)</span>th batch implies that there is a serial ordering of all requests consistent with external responses (Lemma C.4 or C.7).</p>

    <p class="text-gray-300">Given these two, we can construct a linear ordering of all operations such that (i) it satisfies requirement (1) above, and (ii) the operations in the <span class="math">(i+1)</span>th batch appear as a suffix (i.e., they happen in real-time after all operations in the first <span class="math">i</span> batches). Requirement (1) follows from the existence of a serial ordering of all requests. We prove requirement (2) by contradiction.</p>

    <p class="text-gray-300">There are two cases. First, an operation <span class="math">x</span> in batch <span class="math">(i+1)</span> reads from (or writes to) a tuple that was created in a prior batch. If <span class="math">x</span> must appear in the linear ordering before operations in prior batches, then it means <span class="math">x</span> must exist in prior batches for those batches to be sequentially consistent. A contradiction. Second, an operation <span class="math">x</span> in batch <span class="math">(i+1)</span> is an insert to a new key that never existed and must be placed in the linear ordering before an operation from a prior batch. In the linear ordering of all operations, this operation can occur anywhere in the past including the case where it is included after all operations from the first <span class="math">i</span> batches. A contradiction. Thus, C-SetKV preserves linearizability for operations in different batches. ∎</p>

    <p class="text-gray-300">An example. The above lemma shows that C-SetKV guarantees linearizability for operations across batches since the linearization point occurs after audit. But why must we consider operations within the same batch concurrent? In other words, why can we not have a finer slicing of time? To answer this, we use an example. Consider the case where a <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(i)}</span> issues a key-value store operation <span class="math">x_{1}=\\texttt{get}(k)</span> for a key <span class="math">k</span> that does not exist in <span class="math">\\mathcal{P}_{\\mathcal{K}}</span>’s key-value store. A correct <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> would respond with an error code. However, suppose a malicious <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> responds with <span class="math">(k,v,1)</span> for some <span class="math">v</span>. Naturally, if we run audit now, it will return false.</p>

    <p class="text-gray-300">However, suppose we do not run audit immediately and later a <span class="math">\\mathcal{V}_{\\mathcal{K}}^{(i)}</span> (<span class="math">j\\neq i</span>) issues <span class="math">x_{2}=\\texttt{insert}(k,v)</span> and suppose it assigns a timestamp of 1 (this is possible since, recall from Section 4.1, each <span class="math">\\mathcal{V}_{\\mathcal{K}}</span> instance starts with a timestamp of 0). Now, if we run audit, it returns true—even though <span class="math">x_{2}</span> is ordered before <span class="math">x_{1}</span> in the linear history despite the fact that <span class="math">x_{2}</span> was executed after <span class="math">x_{1}</span> in the real execution. In essence, <span class="math">\\mathcal{P}_{\\mathcal{K}}</span> violates the real-time constraint of linearizability and yet audit passes.</p>

    <h2 id="sec-73" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Pequin: An end-to-end toolchain for verifiable computation, SNARKs, and probabilistic proofs. https://github.com/pepper-project/pequin, 2016.</li>

      <li>[2] M. Albrecht, L. Grassi, C. Rechberger, A. Roy, and T. Tiessen. MiMC: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. In Proceedings of the International Conference on the Theory and Application of Cryptology and Information Security (ASIACRYPT), 2016.</li>

      <li>[3] S. Ames, C. Hazay, Y. Ishai, and M. Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In Proceedings of the ACM Conference on Computer and Communications Security (CCS), 2017.</li>

      <li>[4] S. Angel and M. Walfish. Verifiable auctions for online ad exchanges. In Proceedings of the ACM SIGCOMM Conference, 2013.</li>

      <li>[5] A. Arasu, K. Eguro, R. Kaushik, D. Kossmann, P. Meng, V. Pandey, and R. Ramamurthy. Concerto: A high concurrency key-value store with integrity. In Proceedings of the ACM International Conference on Management of Data (SIGMOD), 2017.</li>

      <li>[6] S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. Proof verification and the hardness of approximation problems. Journal of the ACM (JACM), 45(3), May 1998.</li>

      <li>[7] L. Babai, L. Fortnow, L. A. Levin, and M. Szegedy. Checking computations in polylogarithmic time. In Proceedings of the ACM Symposium on Theory of Computing (STOC), 1991.</li>

      <li>[8] M. Backes, M. Barbosa, D. Fiore, and R. M. Reischuk. ADSNARK: Nearly practical and privacy-preserving proofs on authenticated data. In Proceedings of the IEEE Symposium on Security and Privacy (S&P), 2015.</li>

      <li>[9] M. Bellare and D. Micciancio. A new paradigm for collision-free hashing: Incrementality at reduced cost. In Proceedings of the International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT), 1997.</li>

      <li>[10] E. Ben-Sasson, I. Ben-Tov, A. Chiesa, A. Gabizon, D. Genkin, M. Hamilis, E. Pergament, M. Riabzev, M. Silberstein, E. Tromer, and M. Virza. Computational integrity with a public random string from quasi-linear PCPs. In Proceedings of the International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT), 2017.</li>

      <li>[11] E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev. Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046, 2018.</li>

      <li>[12] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer, and M. Virza. Zerocash: Decentralized anonymous payments from Bitcoin. In Proceedings of the IEEE Symposium on Security and Privacy (S&P), 2014.</li>

      <li>[13] E. Ben-Sasson, A. Chiesa, D. Genkin, and E. Tromer. Fast reductions from RAMs to delegatable succinct constraint satisfaction problems: Extended abstract. In</li>

    </ul>

    <p class="text-gray-300">Proceedings of the Innovations in Theoretical Computer Science (ITCS) Conference, 2013.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[14] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In Proceedings of the International Cryptology Conference (CRYPTO), Aug. 2013.</li>

      <li>[15] E. Ben-Sasson, A. Chiesa, M. Green, E. Tromer, and M. Virza. Secure sampling of public parameters for succinct zero knowledge proofs. In Proceedings of the IEEE Symposium on Security and Privacy (S&P), 2015.</li>

      <li>[16] E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P. Ward. Aurora: Transparent succinct arguments for R1CS. Cryptology ePrint Archive, Report 2018/828, 2018.</li>

      <li>[17] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Scalable zero knowledge via cycles of elliptic curves. In Proceedings of the International Cryptology Conference (CRYPTO), 2014.</li>

      <li>[18] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct non-interactive zero knowledge for a von Neumann architecture. In Proceedings of the USENIX Security Symposium, 2014.</li>

      <li>[19] V. Beneš. Mathematical theory of connecting networks and telephone traffic. Mathematics in Science and Engineering. Elsevier Science, 1965.</li>

      <li>[20] D. J. Bernstein, M. Hamburg, A. Krasnova, and T. Lange. Elligator: Elliptic-curve points indistinguishable from uniform random strings. In Proceedings of the ACM Conference on Computer and Communications Security (CCS), 2013.</li>

      <li>[21] P. A. Bernstein, D. W. Shipman, and W. S. Wong. Formal aspects of serializability in database concurrency control. IEEE Transactions on Software Engineering, SE-5(3), May 1979.</li>

      <li>[22] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In Proceedings of the Innovations in Theoretical Computer Science (ITCS) Conference, 2012.</li>

      <li>[23] M. Blum, W. Evans, P. Gemmell, S. Kannan, and M. Naor. Checking the correctness of memories. In Proceedings of the IEEE Symposium on Foundations of Computer Science (FOCS), 1991.</li>

      <li>[24] J. Bootle, A. Cerulli, P. Chaidos, J. Groth, and C. Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In Proceedings of the International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT), 2016.</li>

      <li>[25] B. Braun, A. J. Feldman, Z. Ren, S. Setty, A. J. Blumberg, and M. Walfish. Verifying computations with state. In Proceedings of the ACM Symposium on Operating Systems Principles (SOSP), 2013.</li>

      <li>[26] B. Braun, A. J. Feldman, Z. Ren, S. Setty, A. J. Blumberg, and M. Walfish. Verifying computations with state (extended version). Cryptology ePrint Archive, Report 2013/356, 2013.</li>

      <li>[27] M. Castro and B. Liskov. Practical Byzantine fault tolerance and proactive recovery. ACM Transactions on Computer Systems (TOCS), 20(4):398–461, Nov. 2002.</li>

      <li>[28] E. Cecchetti, F. Zhang, Y. Ji, A. Kosba, A. Juels, and E. Shi. Solidus: Confidential distributed ledger transactions via PVORM. In Proceedings of the ACM Conference on Computer and Communications Security (CCS), 2017.</li>

      <li>[29] Chain. Introducing Sequence. https://blog.chain.com/introducing-sequence-e14ff70b730, 2017.</li>

      <li>[30] J. P. M. Chase. ZSL Proof of Concept. https://github.com/jpmorganchase/quorum/wiki/ZSL, 2017.</li>

      <li>[31] A. Chiesa, E. Tromer, and M. Virza. Cluster computing in zero knowledge. In Proceedings of the International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT), 2015.</li>

      <li>[32] D. Clarke, S. Devadas, M. V. Dijk, B. Gassend, G. Edward, and S. Mit. Incremental multiset hash functions and their application to memory integrity checking. In Proceedings of the International Conference on the Theory and Application of Cryptology and Information Security (ASIACRYPT), 2003.</li>

      <li>[33] Z. E. C. Company. What is Jubjub? https://z.cash/technology/jubjub.html, 2017.</li>

      <li>[34] G. Cormode, M. Mitzenmacher, and J. Thaler. Practical verified computation with streaming interactive proofs. In Proceedings of the Innovations in Theoretical Computer Science (ITCS) Conference, 2012.</li>

      <li>[35] C. Costello, C. Fournet, J. Howell, M. Kohlweiss, B. Kreuter, M. Naehrig, B. Parno, and S. Zahur. Geppetto: Versatile verifiable computation. In Proceedings of the IEEE Symposium on Security and Privacy (S&P), May 2015.</li>

      <li>[36] C. Dwork, M. Naor, G. N. Rothblum, and V. Vaikuntanathan. How efficient can memory checking be? In Theory of Cryptography Conference (TCC), 2009.</li>

      <li>[37] R. R. Farashahi, P. Fouque, I. E. Shparlinski, M. Tibouchi, and J. F. Voloch. Indifferentiable deterministic hashing to elliptic and hyperelliptic curves. Mathematics of Computation, 82(281), 2013.</li>

      <li>[38] Financial Industry Regulatory Authority. FINRA fines Goldman Sachs Execution &amp; Clearing, L.P. $800,000 for failing to prevent trade-throughs in its alternative trading system. https://www.finra.org/newsroom/2014/finra-fines-goldman-sachs-execution-clearing-lp-800000-failing-prevent-trade-throughs, July 2014.</li>

      <li>[39] D. Fiore, C. Fournet, E. Ghosh, M. Kohlweiss, O. Ohrimenko, and B. Parno. Hash first, argue later: Adaptive verifiable computations on outsourced data. In Proceedings of the ACM Conference on Computer and Communications Security (CCS), 2016.</li>

      <li>[40] K. Fu, M. F. Kaashoek, and D. Mazières. Fast and secure distributed read-only file system. In Proceedings of the USENIX Symposium on Operating Systems Design and Implementation (OSDI), 2000.</li>

      <li>[41] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct NIZKs without</li>

    </ul>

    <p class="text-gray-300">PCPs. In Proceedings of the International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT), 2013.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[42] S. Ghemawat and J. Dean. LevelDB: a fast and lightweight key/value database library by Google. https://github.com/google/leveldb, 2011.</li>

      <li>[43] S. Goldwasser, S. Micali, and C. Rackoff. The knowledge complexity of interactive proof-systems. In Proceedings of the ACM Symposium on Theory of Computing (STOC), 1985.</li>

      <li>[44] J. Groth. Short pairing-based non-interactive zero-knowledge arguments. In Proceedings of the International Conference on the Theory and Application of Cryptology and Information Security (ASIACRYPT), 2010.</li>

      <li>[45] J. Groth. On the size of pairing-based non-interactive arguments. In Proceedings of the International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT), 2016.</li>

      <li>[46] M. P. Herlihy and J. M. Wing. Linearizability: A correctness condition for concurrent objects. ACM Transactions on Programming Languages and Systems (TOPLAS), 12(3), July 1990.</li>

      <li>[47] T. Icart. How to hash into elliptic curves. In Proceedings of the International Cryptology Conference (CRYPTO), 2009.</li>

      <li>[48] Y. Ishai, E. Kushilevitz, and R. Ostrovsky. Efficient arguments without short PCPs. In IEEE Conference on Computational Complexity, 2007.</li>

      <li>[49] J. Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In Proceedings of the ACM Symposium on Theory of Computing (STOC), 1992.</li>

      <li>[50] A. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou. Hawk: The blockchain model of cryptography and privacy-preserving smart contracts. In Proceedings of the IEEE Symposium on Security and Privacy (S&P), 2016.</li>

      <li>[51] A. Kosba, D. Papadopoulos, C. Papamanthou, M. F. Sayed, E. Shi, and N. Triandopoulos. TRUESET: Faster verifiable set computations. In Proceedings of the USENIX Security Symposium, 2014.</li>

      <li>[52] A. Kosba, Z. Zhao, A. Miller, Y. Qian, H. Chan, C. Papamanthou, R. Pass, abhi shelat, and E. Shi. C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span>: A framework for building composable zero-knowledge proofs. Cryptology ePrint Archive, Report 2015/1093, 2015.</li>

      <li>[53] L. Lamport. Time, clocks, and the ordering of events in a distributed system. Communications of the ACM, 21, July 1978.</li>

      <li>[54] L. Lamport. How to make a multiprocessor computer that correctly executes multiprocess programs. IEEE Transactions on Computers, C-28(9), Sept. 1979.</li>

      <li>[55] L. Lamport. The part-time parliament. ACM Transactions on Computer Systems (TOCS), 16(2):133–169, May 1998.</li>

      <li>[56] J. Li, M. Krohn, D. Mazières, and D. Shasha. Secure untrusted data repository (SUNDR). In Proceedings of the USENIX Symposium on Operating Systems Design and Implementation (OSDI), 2004.</li>

      <li>[57] libsnark. A C++ library for zkSNARK proofs. https://github.com/scipr-lab/libsnark, 2012.</li>

      <li>[58] H. Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zeroknowledge arguments. In Theory of Cryptography Conference (TCC), 2012.</li>

      <li>[59] J. Maitin-Shepard, M. Tibouchi, and D. F. Aranha. Elliptic curve multiset hash. The Computer Journal, 60(4), 2017.</li>

      <li>[60] R. C. Merkle. A digital signature based on a conventional encryption function. In Proceedings of the International Cryptology Conference (CRYPTO), 1988.</li>

      <li>[61] S. Micali. CS proofs. In Proceedings of the IEEE Symposium on Foundations of Computer Science (FOCS), 1994.</li>

      <li>[62] I. Miers, C. Garman, M. Green, and A. D. Rubin. Zerocoin: Anonymous distributed e-cash from Bitcoin. In Proceedings of the IEEE Symposium on Security and Privacy (S&P), 2013.</li>

      <li>[63] L. Moyer. Regulators aren’t done with ‘dark pool’ investigations. https://www.nytimes.com/2016/02/02/business/dealbook/regulators-arent-done-with-dark-pool-investigations.html, Feb. 2016.</li>

      <li>[64] N. Narula, W. Vasquez, and M. Virza. zkLedger: Privacy-preserving auditing for distributed ledgers. In Proceedings of the USENIX Symposium on Networked Systems Design and Implementation (NSDI), 2018.</li>

      <li>[65] C. H. Papadimitriou. The serializability of concurrent database updates. Journal of the ACM (JACM), 26(4), Oct. 1979.</li>

      <li>[66] D. C. Parkes, C. Thorpe, and W. Li. Achieving trust without disclosure: Dark pools and a role for secrecy-preserving verification. In Proceedings of the Conference on Auctions, Market Mechanisms and Their Applications, 2015.</li>

      <li>[67] B. Parno, C. Gentry, J. Howell, and M. Raykova. Pinocchio: Nearly practical verifiable computation. In Proceedings of the IEEE Symposium on Security and Privacy (S&P), May 2013.</li>

      <li>[68] S. Setty, S. Angel, T. Gupta, and J. Lee. Proving the correct execution of concurrent services in zero-knowledge. In Proceedings of the USENIX Symposium on Operating Systems Design and Implementation (OSDI), Oct. 2018.</li>

      <li>[69] S. Setty, A. J. Blumberg, and M. Walfish. Toward practical and unconditional verification of remote computations. In Proceedings of the USENIX Workshop on Hot Topics in Operating Systems (HotOS), May 2011.</li>

      <li>[70] S. Setty, B. Braun, V. Vu, A. J. Blumberg, B. Parno, and M. Walfish. Resolving the conflict between generality and plausibility in verified computation. In Proceedings of the ACM European Conference on Computer Systems (EuroSys), Apr. 2013.</li>

      <li>[71] S. Setty, R. McPherson, A. J. Blumberg, and M. Walfish. Making argument systems for outsourced computation practical (sometimes). In Proceedings of the Network and Distributed System Security Symposium (NDSS), Feb. 2012.</li>

      <li>[72] S. Setty, V. Vu, N. Panpalia, B. Braun, M. Ali, A. J. Blumberg, and M. Walfish. Taking proof-based verified computation a few steps closer to practicality (extended version). Cryptology ePrint Archive, Report 2012/598,</li>

    </ul>

    <p class="text-gray-300">2012.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[73] S. Setty, V. Vu, N. Panpalia, B. Braun, A. J. Blumberg, and M. Walfish. Taking proof-based verified computation a few steps closer to practicality. In Proceedings of the USENIX Security Symposium, Aug. 2012.</li>

      <li>[74] A. Shallue and C. E. van de Woestijne. Construction of rational points on elliptic curves over finite fields. In Proceedings of the International Conference on Algorithmic Number Theory, 2006.</li>

      <li>[75] C. Tan, L. Yu, J. B. Leners, and M. Walfish. The efficient server audit problem, deduplicated re-execution, and the Web. In Proceedings of the ACM Symposium on Operating Systems Principles (SOSP), 2017.</li>

      <li>[76] J. Thaler. Time-optimal interactive proofs for circuit evaluation. In Proceedings of the International Cryptology Conference (CRYPTO), 2013.</li>

      <li>[77] J. Thaler, M. Roberts, M. Mitzenmacher, and H. Pfister. Verifiable computation with massively parallel interactive proofs. In Proceedings of the USENIX Workshop on Hot Topics in Cloud Computing (HotCloud), 2012.</li>

      <li>[78] A. Tomescu and S. Devadas. Catena: Efficient non-equivocation via Bitcoin, 2017.</li>

      <li>[79] M. Ulas. Rational points on certain hyperelliptic curves over finite fields. Bulletin of the Polish Academy of Sciences. Mathematics, 55(2), 2007.</li>

      <li>[80] V. Vu, S. Setty, A. J. Blumberg, and M. Walfish. A hybrid architecture for verifiable computation. In Proceedings of the IEEE Symposium on Security and Privacy (S&P), 2013.</li>

      <li>[81] R. S. Wahby, M. Howald, S. Garg, abhi shelat, and M. Walfish. Verifiable ASICs. In Proceedings of the IEEE Symposium on Security and Privacy (S&P), 2016.</li>

      <li>[82] R. S. Wahby, Y. Ji, A. J. Blumberg, abhi shelat, J. Thaler, M. Walfish, and T. Wies. Full accounting for verifiable outsourcing. In Proceedings of the ACM Conference on Computer and Communications Security (CCS), 2017.</li>

      <li>[83] R. S. Wahby, S. Setty, Z. Ren, A. J. Blumberg, and M. Walfish. Efficient RAM and control flow in verifiable outsourced computation. In Proceedings of the Network and Distributed System Security Symposium (NDSS), 2015.</li>

      <li>[84] R. S. Wahby, I. Tzialla, abhi shelat, J. Thaler, and M. Walfish. Doubly-efficient zkSNARKs without trusted setup. In Proceedings of the IEEE Symposium on Security and Privacy (S&P), 2018.</li>

      <li>[85] A. Waksman. A permutation network. Journal of the ACM (JACM), 15(1):159–163, Jan. 1968.</li>

      <li>[86] M. Walfish and A. J. Blumberg. Verifying computations without reexecuting them: From theoretical possibility to near practicality. Communications of the ACM, 58(2), Jan. 2015.</li>

      <li>[87] H. Wu, W. Zheng, A. Chiesa, R. A. Popa, and I. Stoica. DIZK: A distributed zero-knowledge proof system. In Proceedings of the USENIX Security Symposium, 2018.</li>

      <li>[88] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou. vSQL: Verifying arbitrary SQL queries over dynamic outsourced databases. In Proceedings of the IEEE Symposium on Security and Privacy (S&P), 2017.</li>

      <li>[89] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou. vRAM: Faster verifiable RAM with program-independent preprocessing. In Proceedings of the IEEE Symposium on Security and Privacy (S&P), 2018.</li>

    </ul>`;
---

<BaseLayout title="Proving the correct execution of concurrent services in zero... (2018/907)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/907
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
