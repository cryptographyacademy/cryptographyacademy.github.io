---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2012/546';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Rotational cryptanalysis of round-reduced Keccak';
const AUTHORS_HTML = 'Pawel Morawiecki, Josef Pieprzyk, Marian Srebrny';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">In this paper we attack round-reduced Keccak hash function with a technique called rotational cryptanalysis. We focus on Keccak variants proposed as SHA-3 candidates in the NIST&#x27;s contest for a new standard of cryptographic hash function. Our main result is a preimage attack on 4-round Keccak and a 5-round distinguisher on Keccak-f[1600] permutation --- the main building block of Keccak hash function.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> preimage attack &middot; Keccak &middot; rotational cryptanalysis &middot; SHA-3</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">In 2007, the U.S. National Institute of Standards and Technology (NIST) announced a public contest aiming at the selection of a new standard for a cryptographic hash function. The main motivation behind starting the contest has been the security flaws identified in the SHA-1 standard in 2005. Similarities between SHA-1 and the most recent standard SHA-2 were worrisome and NIST decided that a new, stronger hash function would be needed. Overall, 51 functions were submitted to the first round of the contest. In July 2009 out of the submitted functions, 14 were selected to the second round. At the end of 2010, the five finalists were announced and eventually in October 2012 the winner has been selected. The new SHA-3 standard will be KECCAK hash function [5]. In this paper we analyze KECCAK using a technique called rotational cryptanalysis.</p>

    <p class="text-gray-300">Rotational analysis is a relatively new type of attack. The technique was mentioned and applied in [2, 14, 16], and formally introduced in [12]. Unlike the differential analysis, where for a pair (x, y) the attacker follows the propagation of the difference  <span class="math">x \\oplus y</span>  through the cryptographic system, in the rotational analysis, the adversary investigates the propagation of the rotational relations through the cryptographic transformations. Khovratovich and Nikoli&#263; in [12] analyze the primitives composed of only three operations: addition, rotation, xor (ARX). For these primitives, they prove that the probability that a rotational pair of inputs will produce a rotational pair on the output depends on the number of additions only. In [17] a rotational distinguisher was designed for the keyed permutation of the Shabal hash function. Rotational cryptanalysis was combined with the rebound attack and applied to the compression function of the SHA-3 candidate Skein and its underlying cipher Threefish [13].</p>

    <p class="text-gray-300">The known cryptanalytic results on Keccak can be divided into two types. The first type is showing a non-random behaviour, weakness in the Keccak's internal permutation, such as our rotational distinguishers. The second type is attacking the core security properties of the whole function (a preimage attack and a collision attack). The distinguisher of Keccak's permutation with the highest number of rounds is the zero-sum distinguisher proposed in [1] and later improved in [6, 9]. However, the complexity of these distinguishers is very high. For example, the zero-sum distinguisher for all 24 rounds has the complexity of 2<sup>1579</sup>. A differential analysis of Keccak's internal permutation, given in [10], leads to distinguishers up to 8 rounds with complexity of 2<sup>491.47</sup> and for 5 rounds with complexity of 2<sup>8</sup>. Among the attacks on the Keccak hash function, the most rounds were reached by Bernstein in his 8-round preimage attack [3].</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;1</sup> Section of Informatics, University of Commerce, Kielce, Poland pawelm@wsh-kielce.edu.pl</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;2</sup> Department of Computing, Macquarie University, Australia josef.pieprzyk@mq.edu.au</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;3</sup> Institute of Computer Science, Polish Academy of Sciences, Poland marians@ipipan.waw.pl</p>

    <p class="text-gray-300">However, the attack is much slower than parallel exhaustive search and it is inherently memoryintensive. Also with the aid of differential analysis, Naya-Plasencia et al. mounted the preimage and collision attacks on 2-round Keccak [15]. In [11] the same result (2-round preimage and 2-round collision attacks) were obtained through the SAT-based attacks. The most successful collision attack was given in [8] where 4-round collisions were presented.</p>

    <p class="text-gray-300">In this paper we focus our analysis on the Keccak variants proposed as SHA-3 candidates. First we analyze the permutation Keccak-f[1600]. We mount the 4-round rotational distinguisher and then enhance it with a correlation analysis which improves the result to 5 rounds. We implement the distinguishers and verify the experimental results. Unlike the other rotational analysis we treat rotational relations between bits independently and we operate on probabilities of rotational relations. Our rotational cryptanalysis not only serves as a mean to show a non-random behaviour in the cryptographic primitive, but also for the first time the technique is used for mounting the preimage attack. A family of 4-round distinguishers is the base for our 4-round preimage attack with the complexity 64 times lower than exhaustive search. This is also the first 4-round preimage attack with a negligible amount of memory needed for the attack.</p>

    <p class="text-gray-300">Table 1. Best known preimage attacks on the Keccak variants proposed as SHA-3 candidates. The number in the column 'Variant' denotes a hash length.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Rounds Variant</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Time</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Memory</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Reference</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6/7/8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">512</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">506/2507/2511.5<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">176/2320/2508<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[3]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">224/256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">217.3<br>/2249.3<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">61<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[3]&lowast;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">384/512</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">377.3<br>/2505.3<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">61<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[3]&lowast;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">512</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">506<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">negligible</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 4.2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">384</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">378<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">negligible</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 4.2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">252<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">negligible</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 4.2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">224</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">221<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">negligible</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 4.2</td>
          </tr>
        </tbody>
      </table>
    </div>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 KECCAK</h2>

    <p class="text-gray-300">In this section we provide a description of Keccak to the extent necessary for understanding the attack described in the paper. For a complete specification, we refer the interested reader to the original specification [5].</p>

    <p class="text-gray-300">Keccak uses the sponge construction and hence is a member of the sponge function family [4]. Figure 1 shows the construction. It can be used as a hash function but also can be applied for generating infinite bit stream, making it suitable as a stream cipher or a pseudorandom bit generator. In this paper we focus on the sponge construction for cryptographic hashing. Keccak has two main parameters r and c, which are called bitrate and capacity, respectively. The sum of those two makes the state size, which Keccak operates on. For the SHA-3 proposal, the state size is 1600 bits. Different values for bitrate and capacity give the trade-off between speed and security. The higher bitrate gives the faster function that is less secure. Keccak follows the sponge two-phase processing.</p>

    <p class="text-gray-300">The initial 1600-bit state is filled with 0's. In the first phase (also called the absorbing phase), interleaved with applications of the permutation f (called Keccak-f in the specification). The</p>

    <p class="text-gray-300"><sup>&lowast;</sup>These results were provided for us by the author of the attack. Originally in [3] the results are given only for 6,7 and 8 rounds.</p>

    <p class="text-gray-300">Fig. 1. Sponge Construction [4]</p>

    <p class="text-gray-300">    <img src="_page_2_Picture_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">absorbing phase is finished when all message blocks have been processed. In the second phase (also called the squeezing phase), the first r bits of the state are returned as part of the output bits, interleaved with applications of the function f. The squeezing phase is finished after the desired length of output digest has been produced.</p>

    <p class="text-gray-300">For the variants proposed as SHA-3 candidates, the value of the parameter c is equal to a hash length multiplied by 2. For example, the SHA-3 candidate with 512-bit hash length is Keccak with c = 1024 and r = 576 (r + c = 1600). In this paper we denote variants proposed as SHA-3 candidates by Keccak-512, Keccak-384, Keccak-256, and Keccak-224. (The number is a hash length for a given variant.)</p>

    <p class="text-gray-300">Keccak can also operate on smaller states but through the whole paper we always refer to the default variant with 1600-bit state. The state can be visualised as an array of 5&times;5 lanes, each lane is 64-bit long. The state size determines the number of rounds in Keccak-f function. For the default 1600-bit state there are 24 rounds. All rounds are the same except for constants which are different for each round.</p>

    <p class="text-gray-300">Below there is a pseudo-code of a single round. In the latter part of the paper, we often refer to the algorithm steps (denoted by Greek letters) described in the following pseudo-code.</p>

    <h3 id="sec-misc-1" class="text-xl font-semibold mt-8">Round(A,RC) {</h3>

    <pre><code class="language-text">&theta; step
C[x] = A[x,0] xor A[x,1] xor A[x,2] xor
    A[x,3] xor A[x,4], forall x in (0...4)
D[x] = C[x-1] xor rot(C[x+1],1), forall x in (0...4)
A[x,y] = A[x,y] xor D[x], forall (x,y) in (0...4,0...4)
&rho; step forall (x,y) in (0...4,0...4)
A[x,y] = rot(A[x,y], r[x,y]),
&pi; step forall (x,y) in (0...4,0...4)
B[y,2*x+3*y] = A[x,y],
&chi; step forall (x,y) in (0...4,0...4)
</code></pre>

    <pre><code class="language-text">A[x,y] = B[x,y] xor ((not B[x+1,y]) and B[x+2,y]),
&iota; step
A[0,0] = A[0,0] xor RC
return A }
</code></pre>

    <p class="text-gray-300">All the operations on the indices shown in the pseudo-code are done modulo 5. A denotes the complete permutation state array and A[x,y] denotes a particular lane in that state. B[x,y], C[x], D[x] are 64-bit intermediate variables. The constants r[x,y] are the rotation offsets, while RC are the round constants. rot(W,m) is the usual bitwise rotation operation, moving bit at position i into position i + m in lane W (i + m are done modulo 64 &ndash; note that 64 is the lane size for the default variant of Keccak). &theta; is the linear operation intends to provide diffusion for the state. &rho; is a permutation between bits in the lanes and &pi; is a permutation between the whole lanes. The only non-linear operation is &chi; which can be treated as a layer of 5-bit Sboxes. Finally, &iota; xores the round constant with the first lane. The constants play a vital role in our analysis and it is worth mentioning that they have the very low Hamming weight. The constants for the first 5 rounds are: 0000000000000001, 0000000000008082, 800000000000808a, 8000000080008000, 000000000000808b (given respectively in hexadecimal using the little-endian format).</p>

    <p class="text-gray-300">In our work we often need to refer to a particular bit of the state and we do that by A(x,y,z) . The coordinates x, y range from 0 to 4 specifying the lane in the state and the coordinate z ranges from 0 to 63 specifying the bit number in the given lane. With this notation we can refer to a state by A, to a lane by A(3,2), to a value of a single bit by A(1,4,6), or to a position of a single bit by (3, 1, 60).</p>

    <p class="text-gray-300">In our analysis we follow the relation between two states (A, A&larr;) which change through subsequent steps of Keccak-f[1600] permutation. In particular we are interested in evolution of a rotational pair of states. Let us define the rotational pair in the context of the Keccak-f[1600] permutation.</p>

    <p class="text-gray-300">Definition 1. A pair of two 1600-bit states (A, A&larr;) is called a rotational pair when each lane in the state A<sup>&larr;</sup> is created by bitwise rotation operation of the corresponding lane in the state A. The operation moves the bit from the position (x, y, z) to the position (x, y, z + n), where z + n is done modulo 64. The coordinates x, y range from 0 to 4 specifying the lane in the state and the coordinate z ranges from 0 to 63 specifying the bit number in the given lane. n is called a rotational number and is the same for every lane. Thus in the rotational pair &forall;(x, y, z) : A(x,y,z) = A<sup>&larr;</sup> (x,y,z+n) .</p>

    <p class="text-gray-300">Remark 1. Following Definition 1, there are up to 64 possible rotational pairs including a pair, where A and A<sup>&larr;</sup> are the same (having n = 0). We will use this fact in the preimage attack described later in the paper.</p>

    <p class="text-gray-300">In some parts of this work we are interested in the probability that a given pair is a rotational one or a given pair of corresponding bits preserve the rotational relation. Two following definitions help to formally define this probability.</p>

    <p class="text-gray-300">Definition 2. Set S<sup>n</sup> is a set of 2 <sup>1600</sup> pairs of states which are created by an operation (some number of steps of Keccak-f[1600] or their inverse) applied to all possible rotational pairs. (All possible means 2 <sup>1600</sup> possible rotational pairs for a chosen rotational number n.)</p>

    <p class="text-gray-300"><strong>Definition 3.</strong> Probability  <span class="math">p_{(x,y,z)}^n</span>  is the probability that for a pair of states  <span class="math">(A, A^{\\leftarrow})</span>  randomly selected from the set  <span class="math">S_n</span>  we have  <span class="math">A_{(x,y,z)} \\neq A_{(x,y,z+n)}^{\\leftarrow}</span> .  <span class="math">p_{(x,y,z)}^n</span>  can be expressed as  <span class="math">p_{(x,y,z)}^n = 1/2 + \\epsilon_{(x,y,z)}^n</span> . Therefore if  <span class="math">\\epsilon_{(x,y,z)}^n = 1/2</span> , the corresponding bits have opposite values and if  <span class="math">\\epsilon_{(x,y,z)}^n = -1/2</span> , the corresponding bits are equal. In case  <span class="math">\\epsilon_{(x,y,z)}^n = 1/2</span> 0, the bits are independent.</p>

    <p class="text-gray-300"><strong>Fig. 2.</strong> Probabilistic relation between bits in a pair of states  <span class="math">(A, A^{\\leftarrow})</span></p>

    <p class="text-gray-300">    <img src="_page_4_Figure_3.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">When mounting distinguishers we refer to a random permutation which now we define for-</p>

    <p class="text-gray-300">Given a permutation of n-bit sequences, i.e  <span class="math">p:\\{0,1\\}^n \\to \\{0,1\\}^n</span> . The collection of all permutations over n bit sequences is denoted by  <span class="math">\\mathcal{P}_n</span> . The cardinality of the set  <span class="math">\\mathcal{P}_n</span>  is n!.</p>

    <p class="text-gray-300"><strong>Definition 4.</strong> Given a probability distribution  <span class="math">\\mathcal{D}_n</span>  that assigns the probability  <span class="math">\\frac{1}{n!}</span>  for each permutation  <span class="math">p \\in \\mathcal{P}_n</span> . A permutation is called random if it is chosen according to the (uniform) distribution  <span class="math">\\mathcal{D}_n</span> .</p>

    <p class="text-gray-300">For a random permutation we assume that  <span class="math">p_{(x,y,z)}^n</span>  follows the binomial distribution  <span class="math">\\mathcal{B}(t,s)</span> where t is a number of trials and s is a probability of success and is equal to 0.5. The mean for the binomial distribution equals  <span class="math">s \\cdot t</span>  and the standard deviation  <span class="math">\\sigma = \\sqrt{(1-s)s \\cdot t}</span> .</p>

    <p class="text-gray-300">To distinguish Keccak-f[1600] permutation from a random permutation we check whether the experimental results (for a chosen  <span class="math">p_{(x,y,z)}</span> ) follow the binomial distribution  <span class="math">\\mathcal{B}(t,0.5)</span> . We choose a typical 95% confidence interval and hence the mean from the experimental sample should be within the range  <span class="math">0.5t\\pm2\\sigma</span> . If the mean is beyond that range we conclude that experimental results do not follow the binomial distribution  <span class="math">\\mathcal{B}(t,0.5)</span>  and hence Keccak-f[1600] can be distinguished from a random permutation.</p>

    <p class="text-gray-300">To calculate how the probabilities change through the successive steps of the algorithm, let us first analyze two basic bitwise operations used in Keccak.</p>

    <p class="text-gray-300">For the following Lemmas it is assumed that each  <span class="math">p_{(x,y,z)}</span>  is independent. Also we assume that if corresponding bits from  <span class="math">(A, A^{\\leftarrow})</span>  are equal, both combinations ('00' or '11') have the same probability to be the actual values. The same applies for combinations with opposite bits ('01' or '10').</p>

    <p class="text-gray-300"><strong>Lemma 1 (AND).</strong> Given the bitwise AND operation, its input bits a, b and the output bit out. Then the probability</p>

    <p class="text-gray-300"><span class="math">$P_{out} = \\frac{1}{2}(p_a + p_b - p_a p_b),</span>$</p>

    <p class="text-gray-300">where the probabilities  <span class="math">p_a</span>  and  <span class="math">p_b</span>  are defined according to Definition 3.</p>

    <p class="text-gray-300"><strong>Lemma 2 (XOR).</strong> Given the bitwise XOR operation, its input bits a, b and the output bit out. Then the probability</p>

    <p class="text-gray-300"><span class="math">$P_{out} = p_a + p_b - 2p_a p_b,</span>$</p>

    <p class="text-gray-300">where the probabilities  <span class="math">p_a</span>  and  <span class="math">p_b</span>  are defined according to Definition 3.</p>

    <p class="text-gray-300">Proofs of the lemmas are given in Appendix.</p>

    <p class="text-gray-300">There is also the bitwise NOT operation in the algorithm but it does not affect the probabilities. NOT flips the values of the corresponding bits  <span class="math">A_{(x,y,z)}</span>  and  <span class="math">A_{(x,y,z+n)}^{\\leftarrow}</span>  but their relation (or precisely speaking the probability of relation  <span class="math">p_{(x,y,z)}^n</span> ) remains unchanged. Also the bitwise rotation operation (denoted in the pseudo-code as  <span class="math">\\mathsf{rot}(\\mathtt{W},\\mathtt{n})</span> ) does not change the values of probabilities. It rotates the bits in the lane so their positions (coordinates z in  <span class="math">p_{(x,y,z)}^n</span> ) change while their probabilities  <span class="math">p_{(x,y,z)}^n</span>  are not changed.</p>

    <p class="text-gray-300">Having explained how the basic bitwise operations change the rotation probabilities, the</p>

    <p class="text-gray-300">Having explained how the basic bitwise operations change the rotation probabilities, the analysis of the Keccak-f[1600] steps remains mostly straightforward. In the transformation  <span class="math">\\theta</span> , there is the XOR operation only, applied a number of times. Due to the linearity of the XOR operation, the repeated application of Lemma 2 will give the correct results of calculated probabilities. For the permutations  <span class="math">\\rho</span>  and  <span class="math">\\pi</span> , nothing needs to be calculated as only the positions of bits change. In the transformation  <span class="math">\\chi</span> , the two Lemma 1 and Lemma 2 are applied. The last step is the transformation  <span class="math">\\iota</span> , where the lane (0,0) is xored with a constant. Xoring with '0' does not change anything. However, if there is '1' at position m in the constant and a rotational number n &gt; 0, then xoring with a constant change the probabilities as follows</p>

    <p class="text-gray-300"><span class="math">$p^n_{(0,0,m)} := 1 - p^n_{(0,0,m)} \\text{ and } p^n_{(0,0,m-n)} := 1 - p^n_{(0,0,m-n)}</span>$</p>

    <p class="text-gray-300">Example 1. Let us consider two 8-bit lanes  <span class="math">A_{(0,0)}</span>  and  <span class="math">A_{(0,0)}^{\\leftarrow}</span>  with the rotational number n=3. The lanes have the following binary values:  <span class="math">A_{(0,0)}=00000010</span>  and  <span class="math">A_{(0,0)}^{\\leftarrow}=00010000</span> . Because  <span class="math">\\forall z\\colon A_{(0,0,z)}=A_{(0,0,z+3)}^{\\leftarrow}</span> , then  <span class="math">\\forall z\\colon p_{(x,y,z)}^3=0</span>  (according to Definition 3). Now if both lanes are xored with 8-bit constant C=00000001, new values of lanes are  <span class="math">A_{(0,0)}=00000011</span>  and  <span class="math">A_{(0,0)}^{\\leftarrow}=00010001</span> . Rotational relation has been spoilt at two positions (0 and 5), therefore the probabilities  <span class="math">p_{(0,0,0)}^3</span>  and  <span class="math">p_{(0,0,5)}^3</span>  are now equal to 1. In Keccak-f[1600] the constants are 64-bit long but the reasoning shown above is still valid.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 4-round distinguishers</h3>

    <p class="text-gray-300">We build a 4-round rotational distinguisher and show that after 4 rounds, there are some coordinates (x, y, z) and the rotational number n for which  <span class="math">p_{(x,y,z)}^n</span>  does not follow the binomial distribution  <span class="math">\\mathcal{B}(t, 0.5)</span> . Figure 3 illustrates an evolution of rotation probabilities. A single square represents a value (or a range of values) of the probability  <span class="math">p_{(x,y,z)}^n</span> . Usually in this paper, we refer to a lane by its two coordinates (x,y). However here for the sake of diagram readability instead of 5x5 matrix of lanes there are 25 rows, each representing a single lane. For example, a value of  <span class="math">p_{(0,1,0)}^n</span>  is represented by the leftmost square in the sixth row and  <span class="math">p_{(4,4,63)}^n</span>  is represented by the rightmost square in the last (25th) row.</p>

    <p class="text-gray-300">In the beginning, all corresponding bits from a rotational pair are equal so  <span class="math">\\forall (x,y,z) \\; p_{(x,y,z)}^n = 0</span> . After the first application of  <span class="math">\\iota</span> , some probabilities  <span class="math">p_{(x,y,z)}^n</span>  change and in the subsequent steps these changes propagate and influence other bits. For most rotational numbers n, there are some probabilities  <span class="math">p_{(x,y,z)}^n</span>  deviating from 0.5 until the end of the 4th round. According to our calculations, at the end of 4th round the probability  <span class="math">p_{(4,4,14)}^{54} = 0.5625</span> . To verify the distinguisher</p>

    <p class="text-gray-300">we chose randomly 10000 rotational pairs and ran them on the 4-round Keccak-f[1600]. The mean from that sample was equal to 5682 (for 5682 rotational pairs bits had different values). For a random permutation which follows the binomial distribution  <span class="math">\\mathcal{B}(10000, 0.5)</span> , the mean equals 5000 and the standard deviation equals 50. Thus the mean from the experiment on the 4-round Keccak-f[1600] should be within the range  <span class="math">5000 \\pm 2 \\cdot 50</span>  and clearly 5682 is beyond that range. Hence we conclude we have a distinguisher for the 4-round Keccak-f[1600] permutation.</p>

    <p class="text-gray-300">We could not directly extend the distinguisher to 5 rounds because after  <span class="math">\\theta</span>  in the 5th round all  <span class="math">p_{(x,y,z)}^n = 0.5</span> .</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Extension to 5-round distinguisher</h3>

    <p class="text-gray-300">To extend the distinguisher to 5 rounds, we show that correlation between some corresponding bits from A and  <span class="math">A^{\\leftarrow}</span>  deviates from what is expected from random permutation. Let us first give an observation which helps to mount the 5-round distinguisher.</p>

    <p class="text-gray-300">Observation 1 Consider two bits  <span class="math">(A_{(x,y,z)}, A_{(x,y&#x27;,z)})</span>  from state A which are in the same column and let us assume that we know the probability that  <span class="math">A_{(x,y,z)} \\neq A_{(x,y&#x27;,z)}</span> . Our point is that  <span class="math">\\theta</span>  does not change this probability. It is because  <span class="math">\\theta</span>  treats each bit within a column in the same way: either it flips all 5 of them or it leaves them unchanged.</p>

    <p class="text-gray-300">We can use this observation in our rotational analysis. The difference is that now we look at relations in one pair  <span class="math">(A_{(x,y,z)}, A_{(x,y,z+n)}^{\\leftarrow})</span>  and the second pair  <span class="math">(A_{(x,y&#x27;,z)}, A_{(x,y&#x27;,z+n)}^{\\leftarrow})</span> . Each of these two pairs has the relation between its bits (that is bits have either the same or opposite values). We are interested whether the relations are the same in both pairs, specifically the probability that relations are the same in both pairs. For a random permutation this probability has the binomial distribution  <span class="math">\\mathcal{B}(t,0.5)</span> . If we can show that for the 5-round Keccak-f[1600] experimental results do not follow this distribution, then we have a distinguisher.</p>

    <p class="text-gray-300">First we determine a rotational number n for which  <span class="math">p_{(x,y,z)}^n</span>  and  <span class="math">p_{(x,y&#x27;,z)}^n</span>  have the highest deviation from 0.5 at the end of the 4th round. It turns out that for n=63,  <span class="math">p_{(2,1,37)}^{63}</span>  and  <span class="math">p_{(2,2,37)}^{63}</span>  is the best pair*  <span class="math">(p_{(2,1,37)}^{63}=0.5625</span>  and  <span class="math">p_{(2,2,37)}^{63}=0.49219)</span> .</p>

    <p class="text-gray-300">Now let  <span class="math">P_c</span>  denotes a probability that in the first pair  <span class="math">(A_{(x,y,z)}, A_{(x,y,z+n)}^{\\leftarrow})</span>  and in the second pair  <span class="math">(A_{(x,y&#x27;,z)}, A_{(x,y&#x27;,z+n)}^{\\leftarrow})</span>  is the same relation. That is the probability:</p>

    <p class="text-gray-300"><span class="math">$P_c = p_{(x,y,z)}^n \\cdot p_{(x,y&#x27;,z)}^n + (1 - p_{(x,y,z)}^n)(1 - p_{(x,y&#x27;,z)}^n)</span>$</p>

    <p class="text-gray-300">We can calculate  <span class="math">P_c</span>  for the chosen pair  <span class="math">p_{(2,1,37)}^{63}</span>  and  <span class="math">p_{(2,2,37)}^{63}</span> .</p>

    <p class="text-gray-300"><span class="math">$P_c = 0.5625 \\cdot 0.49219 + (1 - 0.5625)(1 - 0.49219) = 0.49902375</span>$</p>

    <p class="text-gray-300">This is the  <span class="math">P_c</span>  value at the beginning of the 5th round. Then we have to examine how the steps in the algorithm change this probability. As explained in Observation 1,  <span class="math">\\theta</span>  does not change this value. Subsequent algorithm steps  <span class="math">\\rho</span>  and  <span class="math">\\pi</span>  also do not change  <span class="math">P_c</span>  value, they only change a position of  <span class="math">P_c</span>  which now refers to different pairs of bits  <span class="math">(A_{(1,2,43)}, A_{(1,2,44)}^{\\leftarrow})</span>  and  <span class="math">(A_{(2,0,16)}, A_{(2,0,17)}^{\\leftarrow})</span> . After that there is  <span class="math">\\chi</span>  which preserves the relation between the first pair and the second with a probability equals 0.53125. The reason that this value deviates from 0.5 is that  <span class="math">\\chi</span>  is a non-linear operation and precisely the bitwise AND operation which introduces the bias. All the details on how this value is calculated are given in Appendix. Finally,  <span class="math">\\iota</span>  does not affect our</p>

    <p class="text-gray-300"><sup>*</sup> An anonymous reviewer pointed that a better pair can be found, that is  <span class="math">p_{(0,0,3)}^{31}</span>  and  <span class="math">p_{(0,2,3)}^{31}</span> . It improves the distinguisher by a factor of 4.</p>

    <p class="text-gray-300">Fig. 3. Evolution of probabilities p 53 (x,y,z) through 4 rounds of Keccak-f[1600].</p>

    <p class="text-gray-300">p = 0 0.4 &ge; p &gt; 0 0.5 &gt; p &gt; 0.4 p = 0.5 0.6 &ge; p &gt; 0.5 1 &gt; p &gt; 0.6 p = 1</p>

    <p class="text-gray-300">    <img src="_page_7_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">analysis here. Therefore, to have our pairs with the same relation at the end of the 5th round, there are two ways this event may occur. Either the pairs enter into the 5th round with the same relation and  <span class="math">\\chi</span>  does not spoil it or they enter into the 5th round with the opposite relation and  <span class="math">\\chi</span>  'fixes' it. Then the total probability  <span class="math">P_c</span>  for the chosen pair at the end of the 5th round is:</p>

    <p class="text-gray-300"><span class="math">$P_c = 0.53125 \\cdot 0.49902375 + (1 - 0.53125) \\cdot (1 - 0.49902375) = 0.499938984</span>$</p>

    <p class="text-gray-300">For a random permutation,  <span class="math">P_c</span>  follows the binomial distribution with the probability of success s = 0.5 &mdash; very close to 0.499938984. Then the bias for 5-round Keccak-f[1600] is expected to be very small. To experimentally verify and observe the bias we need to check many rotational pairs. A sufficient number of rotational pairs m is calculated from Chernoff bound [7] and can be expressed as the following inequality:</p>

    <p class="text-gray-300"><span class="math">$m \\ge \\frac{1}{(P_c - 0.5)^2} \\ln \\frac{1}{\\sqrt{\\epsilon}},</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\epsilon</span>  is the probability of an error of the bound (typically set to 0.05). From the inequality we have  <span class="math">m \\ge 402\\,332\\,890 \\approx 2^{28.6}</span>  and in the experiment we checked  <span class="math">403\\,000\\,000</span>  rotational pairs. The distinguisher we implemented can be described in a few short steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate randomly 403 000 000 rotational pairs</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For each pair</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Run 5-round Keccak-f[1600] on the state A and the state  <span class="math">A^{\\leftarrow}</span> ;</li>
      <li>(b) if  <span class="math">(A_{(1,2,43)} \\oplus A_{(1,2,44)}^{\\leftarrow} \\oplus A_{(2,0,16)} \\oplus A_{(2,0,17)}^{\\leftarrow} = 0)</span>  then mean := mean + 1;</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">The mean from the experiment was equal to 201 450 503. For a random permutation which follows the binomial distribution  <span class="math">\\mathcal{B}(403\\,000\\,000,0.5)</span> , the mean equals  <span class="math">201\\,500\\,000</span>  and the standard deviation equals 10 037. Thus the mean from the experiment on the 5-round Keccak-f[1600]should be within the range  <span class="math">201\\,500\\,000\\pm2\\cdot10\\,037</span>  and  <span class="math">201\\,450\\,503</span>  is beyond that range. Hence we conclude we have a distinguisher for the 5-round Keccak-f[1600] permutation.</p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 5-round distinguisher with lower complexity</h3>

    <p class="text-gray-300">The idea allowing us to reduce the complexity of the 5-round distinguisher is to start not from a rotational pair of states but from the pair of states (called 'good' states) which after one round gives the rotational pair. First diagram in Figure 4 shows the structure which is used to generate a pair of 'good' states. Now we explain how we construct this structure. (A rotational number n is set to 63 in the following explanation but for any other n the logic of construction stays the same.)</p>

    <p class="text-gray-300">On the way to the rotational pair from a pair of 'good' states the following should happen:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300"><span class="math">\\iota</span>  from the first round flips the value of  <span class="math">p_{(0,0,0)}^{63}</span>  and  <span class="math">p_{(0,0,1)}^{63}</span> . Thus to get the rotational pair</p></li>
      <li><p class="text-gray-300">after  <span class="math">\\iota</span> , there have to be  <span class="math">p_{(0,0,0)}^{63}=1</span> ,  <span class="math">p_{(0,0,1)}^{63}=1</span>  and for all other  <span class="math">p_{(x,y,z)}^{63}=0</span>  before  <span class="math">\\iota</span>  step.</p>

    <p class="text-gray-300">We want that  <span class="math">p_{(0,0,0)}^{63}=1</span> ,  <span class="math">p_{(0,0,1)}^{63}=1</span>  and all other  <span class="math">p_{(x,y,z)}^{63}=0</span>  are going to  <span class="math">\\chi</span>  and  <span class="math">\\chi</span>  does not change any of  <span class="math">p_{(x,y,z)}^{63}</span> . This way  <span class="math">\\iota</span>  gets the right  <span class="math">p_{(x,y,z)}^{63}</span>  to produce the rotational pair.</p></li>
    </ul>

    <p class="text-gray-300">However  <span class="math">\\chi</span>  is a non-linear operation and to have the condition fulfilled, some  <span class="math">A_{(x,y,z)}</span>  and  <span class="math">A_{(x,y,z+n)}^{\\leftarrow}</span>  have to be fixed. To have values fixed at this point it has to be taken under consideration at the beginning of the first round. Once we know the relation of the states A and  <span class="math">A^{\\leftarrow}</span> before  <span class="math">\\chi</span>  step, it is easy to go back till the beginning of the round. It is because  <span class="math">\\pi</span> ,  <span class="math">\\rho</span>  and  <span class="math">\\theta</span>  are all linear operations and they change the rotational relation with probability 1. Thus we simply</p>

    <p class="text-gray-300"><strong>Fig. 4.</strong> 1-round transition to a rotational pair. A rotational number n set to 63.</p>

    <p class="text-gray-300">    <img src="_page_9_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">invert these three operations to get the rotational relation at the beginning of the first round. Figure 4 shows a 1-round transition to a rotational pair where exact positions of the fixed bits are marked. The values of fixed bits which lead to this transition are given in Appendix.</p>

    <p class="text-gray-300">We hoped that this 1-round transition to a rotational pair would give one more round in the distinguisher. However it is not the case and the problem is that the constant of the second round has the Hamming weight 3 (and not 1 as for the first round). More 1's in the round constant introduce more  <span class="math">p_{(x,y,z)}^n = 1</span>  which subsequently cause more  <span class="math">p_{(x,y,z)}^n</span>  with undesirable value of 0.5. Yet this 1-round transition can be used to lower the complexity of the 5-round distinguisher. Similarly as in the distinguisher from the previous section, we are interested in the pair of  <span class="math">p_{(x,y,z)}^n</span>  at the end of 4th round which are in the same column and whose values deviate from 0.5. For a rotational number n set to 63, we find an excellent pair where both  <span class="math">p_{(4,3,22)}^{63}</span>  and  <span class="math">p_{(4,4,22)}^{63}</span>  are equal to 0. We calculate  <span class="math">P_c</span>  in exactly the same way as in Section 3.2 but this time the total probability  <span class="math">P_c</span>  is much higher and is equal to 0.53125. Putting this value to the Chernoff inequality, we calculate the number of pairs m needed to detect the bias and obtain  <span class="math">m \\geq 1534 \\approx 2^{11}</span> . Around  <span class="math">2^{11}</span>  needed pairs make the complexity of the distinguisher roughly equal  <span class="math">2^{12}</span> .</p>

    <p class="text-gray-300">Trying to win more rounds by 'going backwards' by 2 (or more) rounds is problematic. Either we end up with all fixed bits at the beginning of the distinguisher (then in fact is not a structural distinguisher any more), or if we assume that transitions can be probabilistic the complexity of the distinguisher becomes much higher than the complexity of the generic 'attack'. We also tried</p>

    <p class="text-gray-300">the approach where each undesirable  <span class="math">p_{(x,y,z)}^n = 0.5</span>  becomes 0 with probability  <span class="math">2^{-1}</span> . However, we could not reach anything better than 5 rounds without exceeding the generic complexity.</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Preimage attacks on round-reduced Keccak</h2>

    <p class="text-gray-300">First, we describe the preimage attack on 3-round Keccak-512 which is based on the rotational distinguisher given in the previous section. Then we show how to extend the attack to 4 rounds. To have the attack working on Keccak hash function, we have to consider padding and Keccak parameters. Let us consider Keccak-512 which has r = 576, c = 1024 and a hash length set to 512 bits. For the preimage attack we propose the following structure of the message. A message length is 574 bits, where first 8 lanes (512 bits) are unknown (to be determined by the attacker). Last 62 bits of the message are set to 1. The message is padded with two 1's giving a block of 576 bits. This way we fulfil a condition that all lanes (except first 8 lanes) have all 0's or 1's. We would use similar constraints on a message when attacking Keccak with different parameters (including all Keccak variants proposed as SHA-3 candidates).</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 3-round preimage attack</h3>

    <p class="text-gray-300">The goal of our attack is to find a preimage for a given 512-bit hash h. In the structure of the message described above we have 512 unknown bits, then we can expect that among  <span class="math">2^{512}</span>  possible messages there is, on average, one with a given hash. The main idea of our attack is to find a rotational counterpart of the preimage and show that the workload for this task is below exhaustively trying all  <span class="math">2^{512}</span>  values. Once we have a rotational counterpart of the preimage, we simply rotate it back and get the preimage.</p>

    <p class="text-gray-300">As stated in Remark 1, for a given state there are up to 64 possible rotational pairs (including the identity function). There are 512 unknown preimage bits in the state A, then the probability that we guess one of the rotational counterpart  <span class="math">A^{\\leftarrow}</span>  is  <span class="math">2^{-512} \\cdot 64 = 2^{-506}</span> . Thus we need  <span class="math">2^{506}</span>  guesses. There is a subtlety here which should be mentioned. There are some messages which have fewer than 64 rotations. These 'special' messages have a cyclic pattern. For example a message starting with four 0's then four 1's, then four 0's and so on. However, the number of 'special' messages is relatively small in comparison to  <span class="math">2^{512}</span> . It can be shown there are  <span class="math">2^{256}</span>  such messages for our case. (See Appendix for detailed analysis.) For simplicity, we can start our attack with checking  <span class="math">2^{256}</span>  these special messages. Then there are still almost  <span class="math">2^{512}</span>  possibilities left, but at least we are sure that in this poll each state gives 64 rotational pairs.</p>

    <p class="text-gray-300">To make our attack working, at the end of the 3rd round we need some  <span class="math">p_{(x,y,z)}^n = 0</span>  or  <span class="math">p_{(x,y,z)}^n = 1</span>  for each rotational number n. In the precomputation phase of the attack we generate 64 diagrams (the same as shown in Figure 3), each with a different rotational number n. From these diagrams for each rotational number n we make a list of 10 sets of coordinates (x, y, z) for which  <span class="math">p_{(x,y,z)}^n</span>  equals 0 or 1 at the end of the 3rd round. Please note that we have to consider only (x,y,z) such that 64x + 320y + z &lt; 512 because the attacker knows only 512 bits of a hash (not the whole 1600-bit state).</p>

    <p class="text-gray-300">Here is the main loop of the attack given in the following pseudo-code:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>guess first 8 lanes (512 bits) of the state  <span class="math">A^{\\leftarrow}</span> , the other bits are fixed according to the structure of the message given above.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>run 3-round Keccak-f[1600] on the state  <span class="math">A^{\\leftarrow}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>for</strong> n := 0 <strong>to</strong> n &lt; 64 <strong>do</strong></li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a)  <span class="math">candidate := \\mathbf{true};</span></li>
      <li>(b) for all 10 sets of coordinates (x, y, z) being on the list created in precomputation do</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">if
<span class="math">$(p_{(x,y,z)}^n=0)</span>$
and  <span class="math">(A_{(x,y,z)}\\neq A_{(x,y,z+n)}^\\leftarrow)</span>  then  <span class="math">candidate:=</span>  false; if  <span class="math">(p_{(x,y,z)}^n=1)</span>  and  <span class="math">(A_{(x,y,z)}=A_{(x,y,z+n)}^\\leftarrow)</span>  then  <span class="math">candidate:=</span>  false;</p>

    <p class="text-gray-300">(c) if (candidate=true) then rotate back the guessed state by n bits and run 3-round Keccak-512 on it to check whether the state is the preimage of a given hash.</p>

    <p class="text-gray-300">The attacker compares the probabilities  <span class="math">p_{(x,y,z)}^n</span>  from the distinguisher with the actual values of A (the given hash) and  <span class="math">A^{\\leftarrow}</span>  state (a result of 3-round Keccak-512 on a guessed state). So, for example, if  <span class="math">p_{(2,3,1)}^n = 0</span> , then the bits  <span class="math">A_{(2,3,1)}</span>  and  <span class="math">A_{(2,3,1+n)}^{\\leftarrow}</span>  have to be the same. If the bits are different, then the candidate is rejected as a potential rotational counterpart of the preimage. (It is the point in the pseudo-code where a variable candidate becomes false.)</p>

    <p class="text-gray-300">As said earlier, running the main loop  <span class="math">2^{506}</span>  times, we should get one rotational counterpart of the preimage. It could be the case that our guess (candidate) of a rotational counterpart is not rejected, but in fact it is not a rotational counterpart. Let us call it a false positive candidate. There will be many such false positive candidates and the number of them is calculated as follows. For each rotational number n there is a list of 10 sets of (x, y, z) (created in precomputation) for which  <span class="math">p_{(x,y,z)}^n</span>  equals 0 or 1. A probability that we hit on a candidate for which all 10 values of  <span class="math">p_{(x,y,z)}^n</span>  are the same as on the list is  <span class="math">2^{-10}</span> . Hence there will be around  <span class="math">2^{512}/2^{10} = 2^{502}</span>  false positive candidates to check.</p>

    <p class="text-gray-300">Now let us analyze the workload of inner loops. For each candidate there are 64 rotational numbers n, and for each n there are 10 sets of coordinates to check. Checking one set of coordinates can be implemented with 3 bitwise XOR operations. So the workload of inner loops is roughly  <span class="math">64 \\cdot 10 \\cdot 3 = 1920</span>  XOR operations. This workload is negligibly small as in the single step  <span class="math">\\theta</span>  (in a single round) there are 3200 bitwise XOR operations.</p>

    <p class="text-gray-300">Summing up, the workload of the attack is  <span class="math">2^{256}</span>  (checking special messages) +  <span class="math">2^{506}</span>  (main loop) +  <span class="math">2^{502}</span>  (checking false positive candidates). Thus complexity of the attack is roughly  <span class="math">2^{506}</span>  Keccak-512 calls, 64 times better than the exhaustive search.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Extension to 4-round preimage attack</h3>

    <p class="text-gray-300">A direct extension of the attack to 4 rounds is not possible since there are not any  <span class="math">p_{(x,y,z)}^n = 0</span>  or  <span class="math">p_{(x,y,z)}^n = 1</span>  at the end of the 4th round of the rotational distinguisher. (As said earlier, we need some  <span class="math">p_{(x,y,z)}^n</span>  equals 0 or 1 for mounting the attack.)</p>

    <p class="text-gray-300">It is easy to notice from Figure 3 that  <span class="math">\\iota</span>  flips some  <span class="math">p^n_{(0,0,z)}</span>  and in consequence it leads to undesirable  <span class="math">p^n_{(x,y,z)} = 0.5</span> . Then if we could limit this effect, hopefully some  <span class="math">p^n_{(x,y,z)} = 0</span>  or  <span class="math">p^n_{(x,y,z)} = 1</span>  would be kept till the end of the 4th round and make the attack work for 4 rounds. To realize this, we do the following. We trace the rotational relations between A and  <span class="math">A^{\\leftarrow}</span>  (as in previous sections), but this time  <span class="math">A^{\\leftarrow}</span>  is run on the modified version of Keccak-f[1600] &mdash; Keccak-f[1600] without  <span class="math">\\iota</span> . Such a modification leads to the following observation.</p>

    <p class="text-gray-300">Observation 2 In Example 1, Section 3 it was shown that application of  <span class="math">\\iota</span>  to A and  <span class="math">A^{\\leftarrow}</span>  states flips the value  <span class="math">p_{(x,y,z)}^n</span>  for some triples (x,y,z). Our point is that if we do not apply  <span class="math">\\iota</span>  to an  <span class="math">A^{\\leftarrow}</span>  state, there will be half as many flips. (It is not a general rule but for constants with very low Hamming weight there are roughly half as many flips.) Let us see a simple example.</p>

    <p class="text-gray-300">Example 2. Let us consider two 8-bit lanes  <span class="math">A_{(0,0)}</span>  and  <span class="math">A_{(0,0)}^{\\leftarrow}</span>  with the rotational number n=3. The lanes have the following binary values:  <span class="math">A_{(0,0)}=00000010</span>  and  <span class="math">A_{(0,0)}^{\\leftarrow}=00010000</span> . Now  <span class="math">A_{(0,0)}</span>  is xored with 8-bit constant C=00000001 and  <span class="math">A_{(0,0)}^{\\leftarrow}</span>  is left without changes. Then we have  <span class="math">A_{(0,0)}=00000011</span>  and the unchanged  <span class="math">A_{(0,0)}^{\\leftarrow}=00010000</span> . Therefore a rotational relation has been spoilt at only one position so now  <span class="math">p_{(0,0,0)}^3</span>  is equal to 1. In Keccak-f[1600] the constants are 64-bit long but the reasoning shown here stays the same.</p>

    <p class="text-gray-300">Now is the key point. As stated earlier, fewer flips lead to fewer  <span class="math">p_{(x,y,z)}^n</span>  with undesirable 0.5 value. In consequence, now in the 4th round there are 9 triples (x,y,z) for which  <span class="math">p_{(x,y,z)}^n = 0</span>  or  <span class="math">p_{(x,y,z)}^n = 1</span> . These triples fulfil the condition 64x + 320y + z &lt; 512 as the attacker is given only 512 bits of a hash. In fact  <span class="math">p_{(x,y,z)}^n = 0</span>  or  <span class="math">p_{(x,y,z)}^n = 1</span>  are not at the end of the 4th round but before  <span class="math">\\chi</span>  in the 4th round. (Step  <span class="math">\\chi</span>  destroys these desirable probabilities.) Fortunately, we can invert  <span class="math">\\iota</span>  and  <span class="math">\\chi</span>  from the given hash as  <span class="math">\\chi</span>  operates on the rows independently and can be inverted on a row-by-row basis. In Appendix we give a diagram showing how the probabilities  <span class="math">p_{(x,y,z)}^n</span>  evolve and propagate in the modified version of Keccak-f[1600] without  <span class="math">\\iota</span> .</p>

    <p class="text-gray-300">In precomputation phase we generate the list of sets of coordinates in the very similar way as described for the 3-round attack. The only difference is that now we use the diagram dedicated to the modified version of Keccak-f[1600] (without  <span class="math">\\iota</span> ). The diagram and exact positions where  <span class="math">p^n_{(x,y,z)}</span>  equals 0 or 1 is given in Appendix. Also in precomputation we invert  <span class="math">\\iota</span>  and  <span class="math">\\chi</span>  of the 4th round from the given hash (since these desirable  <span class="math">p^n_{(x,y,z)}</span>  are before  <span class="math">\\chi</span>  in the 4th round,  <span class="math">\\chi</span>  destroys them). The result of the inversion is now our state A to which we refer in the pseudo-code of the attack.</p>

    <p class="text-gray-300">Here is the main loop of the attack given in the following pseudo-code:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>guess first 8 lanes (512 bits) of the state  <span class="math">A^{\\leftarrow}</span> , the other bits are fixed according to the structure of the message given above.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>run 4-round modified Keccak-f[1600] on the state  <span class="math">A^{\\leftarrow}</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>for</strong> n := 0 <strong>to</strong> n &lt; 64 <strong>do</strong></li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a)  <span class="math">candidate := \\mathbf{true};</span></li>
      <li>(b) for all 9 sets of coordinates (x,y,z) being on the list created in precomputation do if  <span class="math">(p^n_{(x,y,z)}=0)</span>  and  <span class="math">(A_{(x,y,z)}\\neq A^{\\leftarrow}_{(x,y,z+n)})</span>  then candidate:= false; if  <span class="math">(p^n_{(x,y,z)}=1)</span>  and  <span class="math">(A_{(x,y,z)}=A^{\\leftarrow}_{(x,y,z+n)})</span>  then candidate:= false;</li>
      <li>(c) if (candidate=true) then rotate back the guessed state by n bits and run 4-round Keccak-512 on it to check whether the state is the preimage of a given hash.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">The main loop of the 4-round preimage attack on Keccak-512 is very similar to the 3-round variant, they differ only in a few places. In Step 2 of the pseudo-code instead of running a normal, full 4-round Keccak-f[1600], we run the modified version without  <span class="math">\\iota</span>  (in all 4 rounds) up to  <span class="math">\\chi</span>  in the 4th round. Finally, there will two times more false positive candidates as there are only 9 triples (x, y, z) for which  <span class="math">p_{(x,y,z)}^n = 0</span>  or  <span class="math">p_{(x,y,z)}^n = 1</span> . The complexity of the attack stays the same as in the 3-round attack. That is  <span class="math">2^{256}</span>  (checking special messages) +  <span class="math">2^{506}</span>  (main loop) +  <span class="math">2^{503}</span>  (checking false positive candidates), which is amounts roughly to  <span class="math">2^{506}</span>  evaluations of the 4-round Keccak-512.</p>

    <p class="text-gray-300">For Keccak-512, the preimage attack is better than the exhaustive search by a factor of  <span class="math">2^6</span> . The same gain can be achieved in the attack on Keccak-384. Our preimage attack works also on Keccak-256 and Keccak-224 but the gain is slightly smaller for these variants. The reason is that there are more false positive candidates to check. It is because an attacker knows fewer bits of a hash (a hash is shorter in these variants) and hence there are fewer triples (x, y, z) (fewer than in Keccak-512 and Keccak-384) for which  <span class="math">p_{(x,y,z)}^n = 0</span>  or  <span class="math">p_{(x,y,z)}^n = 1</span> . Consequently, the complexities of the preimage attacks on Keccak-224 and Keccak-256 are  <span class="math">2^{221}</span>  and  <span class="math">2^{252}</span> , respectively.</p>

    <p class="text-gray-300">Please also note that if we try to attack KECCAK variant with higher bitrate r (e.g. a variant with r = 600, c = 1000, and a hash length equals 512), the claimed security for this variant is  <span class="math">2^{c/2} = 2^{500}</span> . In such a case our attack would not be actually an attack as its complexity is higher than the claimed security provided by designers.</p>

    <p class="text-gray-300">We could not extend the attack to 5 or more rounds because in the 5th round all p n (x,y,z) = 0.5, while for the attack we need some p n (x,y,z) = 0 or p n (x,y,z) = 1.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Conclusion</h2>

    <p class="text-gray-300">In this paper we have presented the rotational distinguisher for Keccak-f[1600] permutation &mdash; the main building block of the Keccak hash function. The distinguisher has been enhanced with the correlation analysis, allowing us to reach 5 rounds with the complexity of 212. We have implemented and verified the distinguisher and experimental results have been consistent with the theoretical model. A family of 4-round distinguishers helps us to mount the 4-round preimage attack on Keccak-512 variant with the complexity of 2506. All the presented attacks are valid for all the Keccak variants submitted as SHA-3 candidates. As future work, it would be interesting to investigate whether the differential rebound attack could improve the rotational distinguishers. These two types of analysis (rebound and rotational) were combined in the attacks on Skein hash function [13].</p>

    </section>

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgement</h2>

    <p class="text-gray-300">We would like to thank the Keccak Team for useful comments and discussion. We also thank Dmitry Khovratovich, Thomas Peyrin and anonymous reviewers for improving the quality of the paper. The research was cofounded by the European Union from resources of the European Social Fund, Project PO KL Information technologies: Research and their interdisciplinary applications, Agreement UDA-POKL.04.01.01-00-051/10-00. Josef Pieprzyk was supported by the Australian Research Council grant DP0987734.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Aumasson, J.P., Meier, W.: Zero-sum distinguishers for reduced Keccak-f and for the core functions of Luffa and Hamsi. Tech. rep., NIST mailing list (2009)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Bernstein, D.J.: Salsa20. Tech. rep., eSTREAM, ECRYPT Stream Cipher Project (2005), http://cr.yp.to/ snuffle.html</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Bernstein, D.J.: Second preimages for 6 (7? (8??)) rounds of Keccak? NIST mailing list (2010), http:// ehash.iaik.tugraz.at/uploads/6/65/NIST-mailing-list_Bernstein-Daemen.txt</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Bertoni, G., Daemen, J., Peeters, M., Van Assche, G.: Cryptographic sponges, http://sponge.noekeon.org</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Bertoni, G., Daemen, J., Peeters, M., Van Assche, G.: Keccak sponge function family main document, http: //keccak.noekeon.org/Keccak-main-2.1.pdf</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Boura, C., Canteaut, A.: Zero-Sum Distinguishers for Iterated Permutations and Application to Keccak-f and Hamsi-256. In: Biryukov, A., Gong, G., Stinson, D. (eds.) Selected Areas in Cryptography, Lecture Notes in Computer Science, vol. 6544, pp. 1&ndash;17. Springer Berlin Heidelberg (2011)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Chernoff, H.: A Note on an Inequality Involving the Normal Distribution. Annals of Probability 9, 533&ndash;535 (1981)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Dinur, I., Dunkelman, O., Shamir, A.: New Attacks on Keccak-224 and Keccak-256. In: Canteaut, A. (ed.) Fast Software Encryption, Lecture Notes in Computer Science, vol. 7549, pp. 442&ndash;461. Springer Berlin Heidelberg (2012)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Duan, M., Lai, X.: Improved zero-sum distinguisher for full round Keccak-f permutation. Chinese Science Bulletin 57, 694&ndash;697 (2012)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Duc, A., Guo, J., Peyrin, T., Wei, L.: Unaligned Rebound Attack Application to Keccak. Cryptology ePrint Archive, Report 2011/420 (2011)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Homsirikamol, E., Morawiecki, P., Rogawski, M., Srebrny, M.: Security margin evaluation of SHA-3 contest finalists through SAT-based attacks. In: 11th Int. Conf. on Information Systems and Industrial Management. LNCS, vol. 7564. Springer Berlin Heidelberg (2012)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Khovratovich, D., Nikoli&acute;c, I.: Rotational cryptanalysis of ARX. In: Proceedings of the 17th international conference on Fast software encryption. pp. 333&ndash;346. LNCS, Springer-Verlag (2010)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Khovratovich, D., Nikolic, I., Rechberger, C.: Rotational Rebound Attacks on Reduced Skein. In: ASI-ACRYPT'10. LNCS, vol. 6477, pp. 1&ndash;19 (2010)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Knudsen, L.R., Matusiewicz, K., Thomsen, S.S.: Observations on the Shabal keyed permutation. Available online (2009), http://www.mat.dtu.dk/people/S.Thomsen/shabal.pdf</li>
    </ul></li>
      <li><p class="text-gray-300">Naya-Plasencia, M., Rck, A., Meier, W.: Practical analysis of reduced-round keccak. In: Bernstein, D., Chatterjee, S. (eds.) Progress in Cryptology INDOCRYPT 2011, Lecture Notes in Computer Science, vol. 7107, pp. 236&ndash;254. Springer Berlin Heidelberg (2011)</p></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Standaert, F.X., Piret, G., Gershenfeld, N., Quisquater., J.J.: SEA: A Scalable Encryption Algorithm for Small Embedded Applications. In: CARDIS'06. LNCS, vol. 3928, pp. 222&ndash;236 (2006)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Van Assche, G.: A rotational distinguisher on Shabals keyed permutation and its impact on the security proofs. Available online, http://gva.noekeon.org/papers/ShabalRotation.pdf</li>
    </ul></li>
    </ul>

    <h3 id="sec-misc-2" class="text-xl font-semibold mt-8"><strong>Appendix</strong></h3>

    <h4 id="sec-misc-3" class="text-lg font-semibold mt-6">Proof of Lemma 1</h4>

    <p class="text-gray-300">Analyzing the AND operation we consider two pairs of input bits. A pair from an A state and its counterpart from an  <span class="math">A^{\\leftarrow}</span>  state. There are 16 possible combinations of pairs and we group them in fours. We assume that all pairs of bits inside the groups are uniformly distributed. It is shown in Figure 5. Probabilities of getting the given group are also shown. The most inner circles represents pair of output bits (one bit from an A state and its counterpart from an  <span class="math">A^{\\leftarrow}</span>  state). It is clear from Figure 5 that four paths lead to a circle with output bits having opposite values (pairs (0,1) and (1,0)). Actually, one path has probability 0 thus a calculation of  <span class="math">P_{out}</span>  (a probability that output bits have opposite values) comes down to adding probabilities of the three paths. We have:</p>

    <p class="text-gray-300"><span class="math">$P_{out} = p_a p_b \\cdot \\frac{1}{2} + (1 - p_a) p_b \\cdot \\frac{1}{2} + (1 - p_b) p_a \\cdot \\frac{1}{2} = \\frac{1}{2} (p_a + p_b - p_a p_b)</span>$</p>

    <p class="text-gray-300">Fig. 5. All possible 'paths' for the bitwise AND operation for rotational pairs of bits.</p>

    <p class="text-gray-300">    <img src="_page_14_Figure_9.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <h3 id="sec-misc-4" class="text-xl font-semibold mt-8">Proof of Lemma 2</h3>

    <p class="text-gray-300">Proof of Lemma 2 is the same as for Lemma 1. The only difference is that now there are only two paths leading to a circle with output bits having opposite values. It is shown in Figure 6. We have:</p>

    <p class="text-gray-300"><span class="math">$P_{out} = (1 - p_a)p_b \\cdot 1 + (1 - p_b)p_a \\cdot 1 = p_a + p_b - 2p_ap_b</span>$</p>

    <p class="text-gray-300">Fig. 6. All possible 'paths' for the bitwise XOR operation for rotational pairs of bits.</p>

    <p class="text-gray-300">    <img src="_page_15_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <h3 id="sec-misc-5" class="text-xl font-semibold mt-8">Probability of relation preservation by <span class="math">\\chi</span></h3>

    <p class="text-gray-300">We are given two pairs of bits  <span class="math">(A_{(1,2,43)}, A_{(1,2,44)}^{\\leftarrow})</span>  and  <span class="math">(A_{(2,0,16)}, A_{(2,0,17)}^{\\leftarrow})</span> . Each of these two pairs has the relation between its bits (that is bits have either the same or opposite values). We can also look at relation between pairs and there are two possibilities: either the same relation in both pairs or different relation in each pair. For example a pair (0,1) and a pair (1,0) means that relations in both pairs is the same (bits are different in pairs). We are interested in a probability that  <span class="math">\\chi</span>  preserves the relation between pairs.  <span class="math">\\chi</span>  changes the values of bits in the following way.</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{l} A_{(1,2,43)} := A_{(1,2,43)} \\ \\, \\text{XOR} \\, \\left( A_{(2,2,43)} \\ \\, \\text{AND} \\, \\, A_{(3,2,43)} \\right) \\\\ A_{(1,2,44)}^{\\leftarrow} := A_{(1,2,44)}^{\\leftarrow} \\ \\, \\text{XOR} \\, \\left( A_{(2,2,44)}^{\\leftarrow} \\ \\, \\text{AND} \\, \\, A_{(3,2,44)}^{\\leftarrow} \\right) \\end{array} \\right) \\quad \\text{first rotational pair} \\\\ A_{(2,0,16)} := A_{(2,0,16)} \\ \\, \\text{XOR} \\, \\left( A_{(3,0,16)} \\ \\, \\text{AND} \\, \\, A_{(4,0,16)}^{\\leftarrow} \\right) \\\\ A_{(2,0,17)}^{\\leftarrow} := A_{(2,0,17)}^{\\leftarrow} \\ \\, \\text{XOR} \\, \\left( A_{(3,0,17)}^{\\leftarrow} \\ \\, \\text{AND} \\, \\, A_{(4,0,17)}^{\\leftarrow} \\right) \\end{aligned} \\quad \\text{second rotational pair}</span>$</p>

    <p class="text-gray-300">To keep the relation between bits  <span class="math">A_{(1,2,43)}</span>  and  <span class="math">A_{(1,2,44)}^{\\leftarrow}</span>  from the first pair, the result of the AND operation has to be the same in both equations from the first pair. The probability of such event can be calculated from Figure 5. We add probabilities (paths) leading to the left, inner circle. (This circle represents the output bits with the same values.) Then a probability is:</p>

    <p class="text-gray-300"><span class="math">$P = (1 - p_a)(1 - p_b) \\cdot 1 + p_a p_b \\cdot \\frac{1}{2} + (1 - p_a)p_b \\cdot \\frac{1}{2} + (1 - p_b)p_a \\cdot \\frac{1}{2}</span>$</p>

    <p class="text-gray-300">In the 5th round, after  <span class="math">\\theta</span>  all  <span class="math">p_{(x,y,z)}^n = \\frac{1}{2}</span> , then a numerical value of p is:</p>

    <p class="text-gray-300"><span class="math">$P = (1 - \\frac{1}{2})(1 - \\frac{1}{2})1 + \\frac{1}{2}\\frac{1}{2}\\frac{1}{2} + (1 - \\frac{1}{2})\\frac{1}{2}\\frac{1}{2} + (1 - \\frac{1}{2})\\frac{1}{2}\\frac{1}{2} = \\frac{5}{8}</span>$</p>

    <p class="text-gray-300">For the second rotational pair calculations are exactly the same with the result of  <span class="math">\\frac{5}{8}</span> . The event that  <span class="math">\\chi</span>  preserves the relation between the first and second pair can happen either when the relation in each pair is preserved or the relation in each pair is spoilt. Thus the probability of this event is equal to:</p>

    <p class="text-gray-300"><span class="math">$P_{event} = \\frac{5}{8} \\cdot \\frac{5}{8} + (1 - \\frac{5}{8})(1 - \\frac{5}{8}) = \\frac{34}{64} = 0.53125</span>$</p>

    <h4 id="sec-misc-6" class="text-lg font-semibold mt-6">Values of fixed bits in the distinguisher from Section 3.3</h4>

    <p class="text-gray-300">Bits given in tables below are set to 1. All other fixed bits which are not listed below (but are marked as fixed in Figure 4) are set to 0.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Bit</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Value</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(4,4,50)}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(4,4,51)}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(4,4,51)}^{\\leftarrow}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(0,2,21)}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(0,3,21)}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(0,0,22)}^{\\leftarrow}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(0,2,22)}^{(0,0,22)}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(0,3,22)}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(0,4,22)}^{\\leftarrow}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(2,0,20)}^{(0,1,22)}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(2,3,20)}^{(2,3,20)}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(2,2,21)}^{\\leftarrow}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Bit</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Value</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(2,3,21)}^{\\leftarrow}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(3,2,51)}^{\\leftarrow}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(3,3,51)}^{\\leftarrow}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(3,0,50)}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(3,3,50)}^{\\leftarrow}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(3,0,52)}^{\\leftarrow}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(3,2,52)}^{\\leftarrow}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(3,3,52)}^{(3,3,52)}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(3,4,52)}^{(3,3,52)}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(0,2,51)}^{\\leftarrow}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{(0,3,51)}^{(0,2,51)}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(0,0,01)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">As a consequence of such settings, after  <span class="math">\\pi</span>  some bits have also fixed (known) values. Specifically,  <span class="math">A_{(1,0,0)}</span>  and  <span class="math">A_{(1,0,1)}</span>  with their rotational counterparts are equal to 0. Also  <span class="math">A_{(4,0,0)}</span>  and  <span class="math">A_{(4,0,1)}</span>  with their rotational counterparts are fixed, equal to 1. With this known values we are sure that the non-linear  <span class="math">\\chi</span>  changes the states into the desirable rotational relation, as shown in Figure 4.</p>

    <h4 id="sec-misc-7" class="text-lg font-semibold mt-6">Calculation of a number of special messages</h4>

    <p class="text-gray-300">According to Definition 1 and Remark 1, for a given state A there are up to 64 possible rotational pairs (including an identity function). There are some messages which have fewer than 64 rotations. These special messages must have a cyclic pattern (e.g. alternating four 1's and four 0's) in all lanes. All 0's or all 1's in the given lane are also considered cyclic here. Please note that if at least one lane in a state A is not cyclic then there are exactly 64 possible rotational pairs  <span class="math">(A, A^{\\leftarrow})</span> . It is because this non-cyclic lane is distinct for each rotational number n and consequently the whole  <span class="math">A^{\\leftarrow}</span>  will be distinct.</p>

    <p class="text-gray-300">For a 64-bit lane there are  <span class="math">2^{32}</span>  cyclic patterns. In our preimage attack there are 8 unknown lanes in the A state (remaining lanes are fixed and cyclic), so the number of combinations of cyclic patterns in these 8 lanes is:  <span class="math">2^{32} \\cdot 2^{32} \\cdot \\dots \\cdot 2^{32} = 2^{256}</span> . And hence the number of special 8 factors</p>

    <p class="text-gray-300">messages is  <span class="math">2^{256}</span> .</p>

    <p class="text-gray-300">Figure 7 shows how probabilities  <span class="math">p_{(x,y,z)}^n</span>  change in the modified KECCAK variant (without  <span class="math">\\iota</span> ). The variant was used in 4-round preimage attack. Please note that in the 4th round, after  <span class="math">\\theta</span> , there are still  <span class="math">p_{(x,y,z)}^n = 0</span>  or  <span class="math">p_{(x,y,z)}^n = 1</span>  which is the key observation for the 4-round preimage attack.</p>

    <p class="text-gray-300">Fig. 7. Evolution of probabilities p n (x,y,z) in the modified Keccak variant.</p>

    <p class="text-gray-300">p = 0 0.4 &ge; p &gt; 0 0.5 &gt; p &gt; 0.4 p = 0.5 0.6 &ge; p &gt; 0.5 1 &gt; p &gt; 0.6 p = 1</p>

    <p class="text-gray-300">    <img src="_page_17_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    </section>
`;
---

<BaseLayout title="Rotational cryptanalysis of round-reduced Keccak (2012/546)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2012 &middot; eprint 2012/546
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="rotational-cryptanalysis-of-round-reduced-keccak-2012" />
  </article>
</BaseLayout>
