---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2025/294';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Neo: Lattice-based folding scheme for CCS over small fields and pay-per-bit commitments';
const AUTHORS_HTML = 'Wilson Nguyen, Srinath Setty';

const CONTENT = `    <p class="text-gray-300">Wilson Nguyen Stanford University [This paper introduces Neo, a new lattice-based folding scheme for CCS, an NP-complete relation that generalizes R1CS, Plonkish, and AIR. Neo’s folding scheme can be viewed as adapting the folding scheme in HyperNova (CRYPTO’24), which assumes elliptic-curve based linearly homomorphic commitments, to the lattice setting. Unlike HyperNova, Neo can use “small” prime fields (e.g., over the Goldilocks prime). Additionally, Neo provides plausible post-quantum security. ]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">This paper introduces Neo, a new lattice-based folding scheme for CCS, an NP-complete relation that generalizes R1CS, Plonkish, and AIR. Neo’s folding scheme can be viewed as adapting the folding scheme in HyperNova (CRYPTO’24), which assumes elliptic-curve based linearly homomorphic commitments, to the lattice setting. Unlike HyperNova, Neo can use “small” prime fields (e.g., over the Goldilocks prime). Additionally, Neo provides plausible post-quantum security.</p>

    <p class="text-gray-300">Prior to Neo, folding schemes in the lattice setting, notably LatticeFold (ePrint 2024/257), worked with constraint systems defined over a cyclotomic polynomial ring. This structure allows packing a fixed batch of constraint systems over a small prime field into a single constraint system over a polynomial ring. However, it introduces significant overheads, both for committing to witnesses (e.g., the commitment scheme cannot take advantage of bit-width of values), and within the folding protocol itself (e.g., the sum-check protocol is run over cyclotomic polynomial rings). Additionally, the required ring structure places restrictions on the choice of primes (e.g., LatticeFold is not compatible with the Goldilocks field).</p>

    <p class="text-gray-300">Neo addresses these problems, by drawing inspiration from both HyperNova and LatticeFold. A key contribution is a folding-friendly instantiation of Ajtai’s commitments, with “pay-per-bit” commitment costs i.e., the commitment costs scale with the bit-width of the scalars (e.g., committing to a vector of bits is <span class="math">32\\times</span> cheaper than committing to a vector of 32-bit values). This scheme commits to vectors over a small prime field. It does so by transforming the provided vector into a matrix and committing to that matrix. We prove that this commitment scheme provides the desired linear homomorphism for building a folding scheme. Additionally, like HyperNova, Neo runs a single invocation of the sum-check protocol, where in HyperNova it is over the scalar field of an elliptic curve and in Neo it is over an extension of a small prime field.</p>

    <p class="text-gray-300">1 Introduction 3 1.1 Open problems and recent progress on those problems 5 1.2 Our work in a nutshell: Neo 7 1.3 A technical overview of Neo 8 1.4 Lattice-based folding scheme for lookups and read-write memory 10 1.5 Constructing an IVC/PCD scheme, with proof compression 11</p>

    <p class="text-gray-300">2 Preliminaries 12 2.1 Notation 12 2.2 Reductions of knowledge 13 2.3 Rings and Modules 15</p>

    <p class="text-gray-300">3 Neo's folding-friendly lattice-based commitments 16 3.1 Requirements 16 3.2 Neo's solution, part-1: A matrix commitment scheme 18 3.3 Neo's solution, part-2: linear homomorphism for folding multilinear evaluation claims 21 3.4 Challenge sets 22</p>

    <p class="text-gray-300">4 Neo's folding scheme for CCS 23 4.1 Relations 24 4.2 Constructing a folding scheme via reductions of knowledge 24 4.3 Reduction parameters 25 4.4 CCS Reduction - <span class="math">\\Pi_{\\mathrm{CCS}}</span> 25 4.5 Random linear combination reduction - <span class="math">\\Pi_{\\mathrm{RLC}}</span> 27 4.6 Decomposition reduction - <span class="math">\\Pi_{\\mathrm{DEC}}</span> 28</p>

    <p class="text-gray-300">5 Security analysis of reductions 29 5.1 New properties 30</p>

    <p class="text-gray-300">6 Concrete parameters 32 6.1 Almost Goldilocks: <span class="math">(2^{64} - 2^{32} + 1) - 32</span> 32 6.2 Goldilocks: <span class="math">2^{64} - 2^{32} + 1</span> 33 6.3 Mersenne 61: <span class="math">2^{61} - 1</span> 33</p>

    <p class="text-gray-300">A Additional Background 38 A.1 Polynomials and multilinear extensions 38</p>

    <p class="text-gray-300">B Deferred theorems and proofs 39 B.1 Proof of Theorem 2 39 B.2 Proof of Lemma 3 41 B.3 Proof of Theorem 3 41 B.4 Proof of Lemma 4 42 B.5 Proof of Lemma 5 44 B.6 Proof of Theorem 4 44 B.7 Proof of Lemma 6 46 B.8 Proof of Lemma 7 46 B.9 Proof of Lemma 8 49 B.10 Proof of Theorem 5 52 B.11 Finding choices of cyclotomic and fields 54 B.12 Lattice Estimator Script 57</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">A folding scheme <em>[44]</em> is a cryptographic primitive that reduces the task of checking that two instance-witness pairs are in some NP relation to the task of checking that a single instance-witness pair is in the same relation. As an example, for a circuit <span class="math">C</span> and two public inputs (i.e., instances) <span class="math">x_{1}</span> and <span class="math">x_{2}</span>, a folding scheme reduces the task of checking that there exists witnesses <span class="math">w_{1}</span> and <span class="math">w_{2}</span> such that <span class="math">C(w_{1},x_{1})=1</span> and <span class="math">C(w_{2},x_{2})=1</span> to the task of checking that there exists a single witness <span class="math">w</span> for a specific public input <span class="math">x</span> such that <span class="math">C(w,x)=1</span>. Furthermore, the verifier’s work in a folding scheme is limited to roughly taking the weighted sum of the commitments to underlying witnesses. By using a folding scheme in a recursive manner, one can continually fold many instance-witness pairs into a single instance-witness pair, providing powerful primitives such as incrementally verifiable computation (IVC) <em>[62]</em> and proof-carrying data (PCD) <em>[13]</em>.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Benefits of folding schemes.</h4>

    <p class="text-gray-300">Folding schemes provide a more efficient approach to construct SNARKs <em>[37, 49]</em> that can scale to large computations.</p>

    <p class="text-gray-300">A modern approach to construct SNARKs is to combine a polynomial interactive oracle proof (PIOP) <em>[19, 25, 57]</em> with a polynomial commitment scheme (PCS) <em>[36]</em>, and then apply the Fiat-Shamir transformation <em>[33]</em>. In particular, the PIOP reduces the task of checking the validity of an instance-witness pair in some relation (e.g., R1CS) to a collection of tasks where each task is to check if a (committed) polynomial evaluates to a certain value at a certain point in their domain (i.e., a set of polynomial evaluation instance-witness pairs). In turn, the polynomial evaluation argument provided by the PCS is used by the prover to prove those polynomial evaluation instances. However, this approach only provides a “monolithic” SNARK, meaning that a prover must prove a fixed-sized computation at once. To scale to larger computations, one typically breaks the computation into smaller pieces and then uses SNARK recursion (a la IVC or PCD) to produce a succinct argument in a scalable manner <em>[12]</em>.</p>

    <p class="text-gray-300">Folding schemes provide a more direct and a more efficient approach. In particular, folding schemes allow recursion to operate at the “statement” level (i.e., prior to producing a PIOP or a PCS evaluation argument). This has two concrete benefits. First, the overheads from recursion are far lower than traditional SNARK recursion. For example, even with one of the earliest folding schemes, Nova <em>[44]</em>, it only takes 10,000 R1CS gates to fold a proof. Whereas, traditional SNARK recursion takes millions of gates <em>[24, 26]</em>. Second, the prover incurs far less work from not having to produce a PIOP or a PCS evaluation argument. For instance, the prover in monolithic SNARKs such as Marlin <em>[25]</em> perform at least 20<span class="math">\\times</span> higher work over simply committing to a witness. In contrast, with state-of-the-art folding schemes <em>[17, 29, 42, 43]</em>, the prover’s work is dominated by the cost to commit to a witness. This results in at least an order of magnitude speedup over monolithic SNARKs, and up to two orders of magnitude speedup when the witness contains values from a small subset of the entire field.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">State-of-the-art folding schemes. Nova [44] formally introduced folding schemes. It also provides a folding scheme for R1CS, where the prover's work is dominated by two multi-scalar multiplications (MSMs) of size proportional to the circuit size, and the recursive verifier circuit is dominated by two group scalar multiplications and hashing a constant number of field elements. Folding schemes further developed in HyperNova [42], Protostar [17], ProtoGalaxy [29], and NeutronNova [43]. These works provide folding schemes for more expressive relations such as CCS [59], a generalization of R1CS, Plonkish, and AIR, including lookup checks. With recent works, the prover's work is dominated by a single MSM that commits to a purported witness, and the verifier circuit size is dominated by 3 group scalar multiplications and hashing a constant number of field elements.</p>

    <p class="text-gray-300">These state-of-the-art folding schemes [2, 17, 28, 29, 40-44, 52, 65] rely on cryptographic groups. Specifically, they leverage linearly homomorphic commitments for vectors over a finite field. In practice, these commitments are instantiated with Pedersen commitments over regular cycles of elliptic curves (e.g., Pallas/Vesta) or with KZG commitments over half pairing cycles of elliptic curves (e.g., BN254/Grumpkin).</p>

    <p class="text-gray-300">The area of folding schemes has witnessed significant progress in just the last year. There is a lot of recent work to extend folding schemes with additional constructs such as a read-only and a read-write memory [8,21,30,34], and some works prove non-uniform constraint systems (e.g., Plonkish) in a space-efficient manner [53] while others focus on providing an efficient on-chain verifier [64]. Due to their efficiency, some projects have adopted folding schemes as a foundation for proving virtual machine executions [3,4]. In a similar vein, a recent work [43] provides a systematic framework to build efficient folding schemes for complex relations in a composable manner, which can then be used to prove virtual machine executions more efficiently.</p>

    <p class="text-gray-300">up to  <span class="math">200 \\times</span>  less work than a monolithic SNARK prover such as Marlin [25] because Marlin ends up committing to "random" field elements as part of its PIOP and PCS evaluation argument, which are at least an order of magnitude more expensive than committing to a witness with "small" field elements. Proof systems such as Spartan and variants [57, 59] incur lower overheads than Marlin, but they must still produce a PIOP and PCS evaluation argument.</p>

    <p class="text-gray-300">2 Prior to Nova [44], Halo [16] provides a recursive SNARK for achieving IVC/PCD where the verifier circuit does not verify a full SNARK proof. However, this approach still requires producing a PIOP and a PCS evaluation argument. Furthermore, Halo's verifier circuit is significantly larger than Nova's. Folding schemes not only aim to minimize work in a recursive verifier circuit, but also aim to avoid producing a SNARK in the first place. Following Halo and in concurrent with Nova, Bunz et al. [18] achieve IVC/PCD while only requiring NARKs in which the verifier provides a split-accumulation scheme. Folding schemes offer a cleaner abstraction and a more efficient instantiation. They also lead to IVC/PCD without even arguments of knowledge. Nova [44] provides additional context on works that inspired folding schemes.</p>

    <p class="text-gray-300">1.1 Open problems and recent progress on those problems</p>

    <p class="text-gray-300">Despite the above progress, there are two downsides associated with the aforementioned state-of-the-art folding schemes.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>They rely on cryptographic groups based on elliptic curves. As a result, constraint systems that they work with are defined over the scalar field of an elliptic curve. For security (e.g., to ensure the hardness of DLOG), this field is a prime field where the modulus is approximately 256 bits. Even if the original computation is naturally represented with “small” numbers, the computation must be lifted to work with 256-bit fields. This incurs an “embedding” overhead. For example, computations on a real machine are naturally expressed with 32-bit or 64-bit field, but when using the aforementioned folding schemes, they must be expressed with 256-bit fields.</li>

      <li>Due to their reliance on the hardness of the discrete logarithm problem, they are not post-quantum secure.</li>

    </ol>

    <p class="text-gray-300">In the rest of this paper, when we say “small” prime fields, we refer to prime fields where the prime modulus <span class="math">q</span> fits within a machine register. Examples of such prime modulus include M61 (<span class="math">q=2^{61}-1</span>) and the Goldilocks prime (<span class="math">q=2^{64}-2^{32}+1</span>). Prime fields with such a modulus provide fast arithmetic; they also allow the use of vector instructions (SIMD) to perform multiple field operations at once.</p>

    <p class="text-gray-300">Research question. Can we construct a folding scheme that provides better efficiency than the aforementioned state-of-the-art folding schemes while addressing the two problems noted above?</p>

    <p class="text-gray-300">Recent progress and their downsides. Boneh and Chen <em>[14]</em> make significant progress toward addressing the above research question. They construct LatticeFold <em>[14]</em>, a new folding scheme for CCS <em>[59]</em>, where security holds under a structured lattice assumption. More recently, Lova <em>[31]</em> provides a Nova-like folding scheme using an unstructured lattice assumption. In another work, Arc <em>[20]</em> provides a folding scheme for general constraint systems including CCS while only relying on hash functions. However, compared to existing group-based folding schemes, all these works incur significant overheads.</p>

    <p class="text-gray-300">Lova <em>[31]</em> constructs a folding scheme for the subset sum problem defined over the integers. In particular, it does not provide a folding scheme for CCS or even R1CS. So, if one were to use Lova for real world problems of interest, one must transform their CCS or R1CS instance-witness pairs to instance-witness pairs in the subset sum relation over the integers. This likely incurs significant overheads. Even ignoring these overheads, based on Lova’s reported performance for the subset sum relation, Lova (for subset sum) is already multiple orders of magnitude slower than Nova (for R1CS). For a subset sum instance length of <span class="math">2^{19}</span>, Lova reports a prover time of <span class="math">\\approx</span>3,000 seconds <em>[31, Table 2]</em>. On a machine with the same number of vCPUs and lower speed, Nova reports 500 ms for an R1CS instance of size <span class="math">2^{19}</span>. Given this, Lova appears to be at least <span class="math">6,000\\times</span> slower</p>

    <p class="text-gray-300">than Nova. Representing R1CS with subset sum likely blows up the size of the corresponding subset sum instance substantially. If we include the overhead from R1CS to subset sum transformation (which could be at least <span class="math">10\\times</span> and likely far higher), Lova is more than four orders of magnitude slower than Nova.</p>

    <p class="text-gray-300">Arc <em>[20]</em> incurs high folding overheads. To fold two instances, Arc requires <span class="math">\\lambda/\\log(1/\\rho)</span> Merkle tree openings in the recursive verifier circuit, where <span class="math">\\lambda</span> is the security parameter and <span class="math">\\rho</span> is the Reed-Solomon code rate used. For <span class="math">\\lambda=128</span> and the widely used rate of <span class="math">\\rho=1/2</span> (which leads to the fastest encoding time for Reed-Solomon codes), Arc requires 128 Merkle tree openings. This translates to about <span class="math">800,000</span> constraints in R1CS when using a SNARK-friendly hash function such as Poseidon <em>[35]</em>. Note that this is a lower bound on the verifier circuit size as the verifier must perform other tasks besides verifying Merkle proofs. As a comparison point, Nova <em>[1, 44]</em> only needs <span class="math">\\approx</span>10,000 R1CS constraints in total for the entire verifier circuit.</p>

    <p class="text-gray-300">LatticeFold <em>[14]</em> is arguably more “practical” than Lova (for the prover) and Arc (for the verifier circuit). However, LatticeFold has many significant downsides, especially when compared to existing state-of-the-art group-based folding schemes. For instance, LatticeFold is not a replacement for existing group-based schemes (e.g., HyperNova <em>[42]</em>) unless one is willing to accept a significant prover slow down. We now provide details of these downsides.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>LatticeFold works with CCS defined over cyclotomic polynomial rings rather than over (small) prime fields. LatticeFold partially mitigates this issue with an approach to “pack” a batch of independent constraints defined over a “small” prime field into a single constraint over a cyclotomic polynomial ring <em>[14, Remark 4.1]</em>. However, this imposes a requirement that one must have a “data parallel” (or SIMD) constraint system. Additionally, “packing” introduces a significant performance problem: The prover’s cost to commit to a vector of values is the same regardless of the bit-width of the values. For example, for a given vector length, it costs the same to commit to a vector of 64-bit values or a vector of 1-bit values.</li>

      <li>For security and to support packing of constraint systems over a small prime field (see <em>[14, §3.3]</em>), LatticeFold requires a particular type of cyclotomic polynomial ring that is not “fully splitting”. This requires rephrasing LatticeFold’s relations and modifying the overall protocol to accommodate the</li>

    </ol>

    <p class="text-gray-300">smaller field, since the protocol descriptions assume a large prime field that causes the cyclotomic ring to fully split. Additionally, using small prime fields adds a <span class="math">\\tau</span> (extension field degree) multiplicative factor loss to the efficiency of LatticeFold’s protocols, due to the need to run a further <span class="math">\\tau</span> instances in parallel. In LatticeFold’s sample parameterization (see <em>[14, §5]</em>), despite the field being 64-bits in size, the extension field degree is required to be <span class="math">\\tau=4</span>. This leads to a <span class="math">4\\times</span> overhead in LatticeFold’s protocols (due to the required repetition) and requires the use of a much larger (extension) field <span class="math">\\mathbb{F}_{q^{4}}</span> (if the NTT representation is used).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>As part of its folding scheme, LatticeFold runs the sum-check protocol over cyclotomic polynomial rings. Cyclotomic polynomial ring operations are 10–100<span class="math">\\times</span> more expensive than (extension) field operations and even 256-bit fields, making the overall protocol significantly more expensive than desired.</li>

      <li>LatticeFold’s use of cyclotomic polynomial rings imposes many requirements on the ring structure. This in turn limits the choice of the underlying “small” prime field. We find that LatticeFold’s requirements do not allow one to use popular small field modulus such as Golidlocks’ prime or M61.</li>

    </ol>

    <p class="text-gray-300">Beyond these, there is a less fundamental issue. LatticeFold runs two sequential invocations of the sum-check protocol, making the verifier perform twice the work. LatticeFold addresses this problem with an optimization that rearranges the protocol steps, allowing the batching of the two sum-check invocations <em>[14, §4.3]</em>. However, this protocol does not fit within LatticeFold’s modular framework, so the security proofs provided in the paper do not cover this stand-alone protocol.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.2 Our work in a nutshell: Neo</h3>

    <p class="text-gray-300">We address the aforementioned problems with our work, which we refer to as Neo. Our work draws inspiration from prior works including HyperNova <em>[42]</em> and LatticeFold <em>[14]</em>, but introduces several new techniques. Before we introduce Neo’s underlying techniques, we provide a brief overview.</p>

    <p class="text-gray-300">Neo provides a folding scheme for CCS <em>[59]</em>, an NP-complete relation that generalizes widely used arithmetizations such as R1CS, Plonkish, and AIR. Unlike HyperNova (where constraints are defined over the scalar field of an elliptic curve group) and LatticeFold (where the constraints are defined over a cyclotomic polynomial ring), the constraints that Neo folds are defined natively over a small</p>

    <p class="text-gray-300">prime field. Specifically, our construction supports the use of popular fields such as M61 and the Goldilocks field. These fields feature extremely efficient field arithmetic implementations. Additionally, unlike LatticeFold, Neo does not have to pack multiple constraints over a prime field into a single constraint over a ring. So, Neo’s folding scheme, like HyperNova, runs a single invocation of the sum-check protocol. In Neo, the sum-check protocol is run over an extension of a small prime field.</p>

    <p class="text-gray-300">Beyond this, Neo provides a new folding-friendly lattice-based commitment scheme. Unlike the commitment scheme in LatticeFold, our scheme provides a key performance property: the commitment costs scale linearly with the bit width of the values in the vectors committed. For example, for <span class="math">n&gt;1</span>, it is <span class="math">64\\times</span> cheaper to commit to a length-<span class="math">n</span> vector of bits than it is to commit to a length-<span class="math">n</span> vector of 64-bit values. This commitment scheme may be of independent interest.</p>

    <p class="text-gray-300">Overall, Neo provides a folding scheme similar to HyperNova with the two added benefits: (1) Neo supports “small” prime fields (e.g., M61) and a light-weight commitment scheme, opening door for a faster prover; and (2) Neo is plausibly post-quantum secure.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.3 A technical overview of Neo</h3>

    <p class="text-gray-300">We now provide an overview of various components in Neo.</p>

    <p class="text-gray-300"><em>(1) Folding-friendly lattice-based commitments with pay-per-bit commitment costs.</em> A key contribution of our work is a new folding-friendly lattice-based commitment (Ajtai with a new embedding for elements). As discussed above, it works with vectors over a “small” prime field and provides a pay-per-bit commitment cost.</p>

    <p class="text-gray-300">A starting point for Neo’s commitment scheme is Ajtai commitments <em>[5]</em>, which commits to a vector of cyclotomic polynomial ring elements, and the security holds under a structured lattice assumption: Module SIS. In particular, to commit to a vector of small field elements, we provide a more efficient mapping from a vector of elements from a small field <span class="math">F_{q}</span> to a vector of cyclotomic polynomial ring elements, where the cyclotomic polynomial is defined over <span class="math">F_{q}</span>. The vector of ring elements is then committed with Ajtai’s commitment scheme.</p>

    <p class="text-gray-300">Our mapping provides two key properties. First, it provides the aforementioned pay-per-bit commitment costs. Discrete-log based commitment schemes such as Pedersen <em>[54]</em> and KZG <em>[15, 36, 64]</em>, which can be used with HyperNova <em>[42]</em>, also provide the property that it is cheaper to commit to a vector of bits than it is to commit to a vector of arbitrary field elements. But, as noted earlier, they do</p>

    <p class="text-gray-300">not provide post-quantum security. In other words, Neo’s commitment scheme allows porting a performance property that is currently available within the discrete-log setting to the lattice setting while providing post-quantum security.</p>

    <p class="text-gray-300">Second, we show that our commitment scheme provides the required linear homomorphism property. In particular, we treat a vector underneath a commitment as a multilinear polynomial represented in evaluation form over the Boolean hypercube. For example, a vector of size <span class="math">n</span> uniquely determines a multilinear polynomial in <span class="math">\\ell=\\log n</span> variables. The commitment scheme then provides a folding scheme for evaluation claims. Informally, suppose that we have a collection of <span class="math">\\beta\\geq 2</span> commitments and claimed multilinear evaluations at an evaluation point over their entire domain: <span class="math">\\{(C_{i},r,y_{i})\\}_{i\\in[\\beta]}</span>. Suppose we have the corresponding witnesses: <span class="math">\\{w_{i}\\}_{i\\in[\\beta]}</span>. That is, witnesses are satisfying if and only if for <span class="math">i\\in[\\beta]</span>, <span class="math">C_{i}</span> is a commitment to <span class="math">w_{i}</span> and that <span class="math">\\widetilde{w_{i}}(r)=y_{i}</span>. Neo’s commitment scheme provides a reduction of knowledge (RoK) that outputs a new instance <span class="math">(C,r,y)</span> and a witness <span class="math">w</span> such that the new instance-witness pair is satisfying if and only if all the original instances are satisfying. With discrete-log-based commitments, it is quite easy to construct such a RoK. Whereas, in the lattice setting, many challenges arise. We provide details of these challenges and how we address them in Section 3. In a nutshell, the RoK must tame the norm growth when taking a random linear combination of commitments, which we address by adapting prior decomposition techniques along with a use of “small norm” challenges.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">(2) A folding scheme for CCS</h4>

    <p class="text-gray-300">With the lattice-based commitment scheme in hand, devising a folding scheme for CCS is relatively straightforward. Our starting point here is the folding scheme in HyperNova <em>[42]</em>, which assumes a discrete-log-based linearly homomorphic commitments. Roughly speaking, we replace the commitment scheme in HyperNova with the aforementioned commitment scheme that provides the required linear homomorphism with respect to multilinear polynomial evaluation claims.</p>

    <p class="text-gray-300">There are however some challenges. As mentioned above, our commitment scheme relies on decomposition techniques to tame norm growth of committed vectors. This decomposition process requires the prover to establish that the prover indeed decomposed its vectors correctly. We phrase these checks as a sum-check claim that is then proven with the sum-check protocol. At a high level, this idea is similar to how LatticeFold proves norm checks of decomposed vectors.</p>

    <p class="text-gray-300">However, due to a different mapping that we use to map CCS witness vectors to cyclotomic polynomial ring elements, we are able to avoid running the sum-check protocol over cyclotomic polynomial rings. In fact, we simply batch the norm check claim with the sum-check claim arising from CCS, and run the sum-check protocol over an extension of a small prime field. Section 4 provides details.</p>

    <p class="text-gray-300">Note that this norm-check claim introduces additional work for the prover in the sum-check protocol as well as in the commitment scheme, relative to HyperNova. However, one can tame this with the following. Neo’s folding scheme, like HyperNova’s, can be naturally extended to a multi-folding scheme <em>[42]</em> i.e., it can fold multiple CCS instances at once. In particular, the additional work related to decomposition is performed only for the “running” instance-witness to which multiple CCS instance-witness pairs are folded. So, by folding multiple CCS instance-witness pairs at once, we can amortize the costs of decomposition.</p>

    <h5 id="sec-9" class="text-base font-semibold mt-4">(3) Security analysis</h5>

    <p class="text-gray-300">Proving the security of our commitment scheme as well as of the folding scheme for CCS is non-trivial. We structure our folding scheme for CCS with three reductions: (1) a reduction that allows decomposing an evaluation claim about a committed vector with a particular norm <span class="math">B</span> into a batch of <span class="math">k</span> instances with a lower norm <span class="math">b&amp;lt;B^{1/k}</span> (for some chosen value of <span class="math">k</span>); (2) a reduction that folds a batch of <span class="math">k+1</span> instances with norm <span class="math">b</span> into a single instance with norm at most <span class="math">B</span>; and (3) a reduction that transforms a claim about a CCS instance-witness pair into a claim about linearized form of CCS instance-witness pair (this reduction is inherited from HyperNova). The first one is a RoK with standard completeness and knowledge soundness properties. Unfortunately, the second and the third reductions are not. To formally capture their properties, we introduce relaxed notions of knowledge soundness. Additionally, we prove that by sequentially composing these reductions with relaxed knowledge soundness guarantees, we get a RoK with standard knowledge soundness. These proof techniques may be of independent interest. Ultimately, we obtain Neo’s folding scheme for CCS. Section 5 provides details.</p>

    <h5 id="sec-10" class="text-base font-semibold mt-4">(4) Concrete parameter choices</h5>

    <p class="text-gray-300">To instantiate Neo’s folding scheme, we must choose a prime <span class="math">q</span> as well as a suitable cyclotomic polynomial ring. The sum-check protocol will be run on an extension of a field <span class="math">F_{q}</span>. For efficiency, it is imperative to choose a value of <span class="math">q</span> that minimizes operations over these structures. We provide multiple different options for <span class="math">q</span> including the very efficient Mersenne-61 i.e., <span class="math">q=2^{61}-1</span>, the widely used Goldilocks field <span class="math">q=2^{64}-2^{32}+1</span>, and a third field that we refer to as “almost” Goldilocks field (AGL). The AGL field allows the use a power-of-2 cyclotomic polynomial ring. Section 6 provides details.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">1.4 Lattice-based folding scheme for lookups and read-write memory</h3>

    <p class="text-gray-300">Neo extends easily to support folding lookup checks. Specifically, Shout <em>[58]</em> is a recent sum-check-based lookup argument. It can be viewed as a RoK from the lookup relation to the multilinear polynomial evaluation relation. Similar to how Neo transforms HyperNova <em>[42]</em> to a lattice-based folding scheme for</p>

    <p class="text-gray-300">CCS, by leveraging our instantiation of Ajtai’s commitments, we can use Shout’s RoK to fold lookup relations alongside CCS, as both our folding scheme and Shout’s RoK use the sum-check protocol <em>[46]</em>. The same approach works with Twist <em>[58]</em> to support a lattice-based folding scheme for read-write memory. For high performance, Shout and Twist rely on commitment schemes that can commit to sparse vectors efficiently. Prior to this work, the choice of commitment schemes includes group-based commitment schemes such as Pedersen <em>[54]</em> and HyperKZG <em>[64]</em>, or hash-based commitment schemes over binary fields such as Binius <em>[27]</em>. Fortunately, Neo’s commitment scheme provides the required performance property in the lattice setting.</p>

    <p class="text-gray-300">Beyond this, supporting lookups alongside CCS opens up the possibility improving Neo further. In particular, within Neo’s folding scheme, the prover establishes that every value in a committed vector are within a certain range. For a range of <span class="math">[-b,b]</span>, our current approach, which is adapted from LatticeFold <em>[14]</em> to the prime field setting, is somewhat naive: the range check is performed by representing it with a degree-<span class="math">2b</span> sum-check instance. To minimize work in the sum-check protocol, <span class="math">b</span> must be chosen to be small (e.g., <span class="math">b=2</span>). Instead of the naive approach, by using our adaptation of Shout, the degree of the multivariate polynomial in the sum-check can be made independent of <span class="math">b</span>. We leave it to future work to incorporate these ideas into our folding scheme.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">1.5 Constructing an IVC/PCD scheme, with proof compression</h3>

    <p class="text-gray-300">By applying prior compilers from folding schemes to IVC <em>[42, 44]</em> and PCD <em>[65]</em> to Neo’s folding scheme, we immediately obtain a lattice-based IVC/PCD scheme. Note that operations in the folding scheme verifier (e.g., extension field operations) can be natively represented in the finite field over which the constraint system is defined. Also, constructing an IVC/PCD scheme using Neo’s folding schemes does not require any cycles of elliptic curves <em>[41, 52]</em>.</p>

    <p class="text-gray-300">With prior compilers, the IVC proof is a pair of instance-witness pairs, one in the CCS relation and another in a linearized version of the CCS relation (Section 4.1 provides details of the specific relations used in Neo). If IVC proof size is a concern, as in prior work <em>[44]</em>, Neo’s prover can instead provide a SNARK proof which proves the knowledge of a valid IVC proof. The SNARK proof can be exponentially smaller than the size of the underlying IVC proof. In particular, we can apply Neo’s folding scheme to fold the two instance-witness pairs in an IVC proof into a single instance-witness pair in the linearized variant of CCS. We can then apply (Super)Spartan <em>[57, 59]</em> to reduce the task of proving the knowledge of a valid witness to a linearized CCS relation to a set of multilinear polynomial evaluation claims. Unfortunately, our lattice-based commitment scheme does not provide an efficient procedure to prove polynomial evaluations directly. Fortunately, we can use Spartan with a FRI-based polynomial commitment scheme <em>[11]</em> to prove the multilinear polynomial evaluations. Note that this preserves plausible post-quantum security. It also does <em>not</em> require any non-native arithmetic or “wrong” field emulation, since we natively support SNARK friendly fields like Goldilocks. In particular, the size of the circuit proven with</p>

    <p class="text-gray-300">Spartan+FRI will be <span class="math">O(n)</span>, where <span class="math">n</span> is the size of the CCS witness polynomial. Note that the Spartan-based proof is an evaluation argument for our lattice-based commitment scheme, but a more direct approach would be preferable.</p>

    <h2 id="sec-13" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">In this section, we fix our notation and recall reductions of knowledge and the sum-check protocol. In Appendix A, we formally present multilinear polynomials and relevant properties. We adapt some preliminaries from a prior work <em>[43]</em>.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">2.1 Notation</h3>

    <p class="text-gray-300">We let <span class="math">\\lambda</span> to denote the security parameter. We let <span class="math">\\mathsf{negl}(\\lambda)</span> to denote a negligible function in <span class="math">\\lambda</span>. Throughout the paper, the depicted asymptotics depend on <span class="math">\\lambda</span>, but we elide this for brevity. We let PPT denote probabilistic polynomial time and let EPT denote expected probabilistic polynomial time. We let <span class="math">[n]</span> denote the set <span class="math">\\{1,\\ldots,n\\}</span>. We let <span class="math">\\{u_{i}\\}_{i\\in[n]}</span> denote the set <span class="math">\\{u_{1},\\ldots,u_{n}\\}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We let <span class="math">\\mathbb{F}</span> denote a prime field of order <span class="math">q</span>, and <span class="math">\\mathbb{K}\\supseteq\\mathbb{F}</span> be the smallest degree extension field of <span class="math">\\mathbb{F}</span> such that $1/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathsf{negl}(\\lambda)<span class="math">. Let </span>\\mathbb{F}^{n}<span class="math"> denote vectors of length </span>n<span class="math"> over elements in </span>\\mathbb{F}<span class="math">. For a scalar </span>s\\in\\mathbb{F}<span class="math">, we define the scalar matrix </span>\\overline{s}:=s\\cdot\\mathrm{I}_{d}<span class="math">, where </span>\\mathrm{I}_{d}<span class="math"> is the </span>d\\times d$ identity matrix.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We write <span class="math">\\mathbb{F}^{d}[X_{1},\\ldots,X_{n}]</span> to denote multivariate polynomials over field <span class="math">\\mathbb{F}</span> in the variables <span class="math">(X_{1},\\ldots,X_{n})</span> with degree bound <span class="math">\\leq d</span> for each variable. We omit the superscript if there is no degree bound. We let <span class="math">\\mathsf{eq}(x,y)\\in\\mathbb{F}^{1}[X_{1},\\ldots,X_{\\ell},Y_{1},\\ldots,Y_{\\ell}]</span> denote the polynomial that outputs <span class="math">1</span> if <span class="math">x=y</span> and <span class="math">0</span> otherwise for <span class="math">x,y\\in\\{0,1\\}^{\\ell}</span>. We define <span class="math">\\mathsf{ZS}_{\\ell}</span> as the set of all multivariate polynomials <span class="math">F\\in\\mathbb{F}[X_{1},\\ldots,X_{\\ell}]</span> such that for all <span class="math">x\\in\\{0,1\\}^{\\ell}</span>, <span class="math">F(x)=0</span> (i.e. vanish over the Boolean hypercube). For vector <span class="math">v\\in\\mathbb{F}^{n}</span> we let <span class="math">\\widetilde{v}\\in\\mathbb{F}^{1}[X_{1},\\ldots,X_{\\log n}]</span> denote the multilinear polynomial extension of <span class="math">v</span> (i.e., <span class="math">\\widetilde{v}(i)=\\sum_{j}\\mathsf{eq}(i,j)\\cdot v_{j}</span>). For matrix <span class="math">M\\in\\mathbb{F}^{d\\times n}</span> we let <span class="math">\\widetilde{M}\\in\\mathbb{F}^{1}[X_{1},\\ldots,X_{\\log(dn)}]</span> denote the multilinear polynomial extension of <span class="math">M</span> (i.e., <span class="math">\\widetilde{v}(i,j)=\\sum_{u,v}\\mathsf{eq}((i,j),(u,v))\\cdot M_{u,v}</span>). In other words, the multilinear extension of a matrix <span class="math">M</span> is the multilinear extension of the vector $m:=M^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^{(d)}<span class="math"> which is the concatenation of the rows of </span>M<span class="math">. For a vector </span>r\\in\\mathbb{K}^{\\log n}<span class="math"> (for </span>n<span class="math"> a power of two), we denote the tensor as </span>\\widehat{r}=\\bigotimes_{i=1}^{\\log n}(r_{i},1-r_{i})<span class="math">. Notably, for a vector </span>f\\in\\mathbb{F}^{n}<span class="math">, we have </span>\\widehat{f}(r)=\\langle\\,f,\\ \\widehat{r}\\,\\rangle<span class="math">. </span>M^{\\intercal}<span class="math"> is the transpose of the matrix </span>M$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Norm</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For an element <span class="math">a\\in\\mathbb{F}</span>, we define $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> as follows: Let </span>a^{\\prime}\\in[0,\\ q-1]<span class="math"> denote the integer representation of </span>a\\mod q<span class="math">. If </span>a^{\\prime}\\leq(q-1)/2<span class="math">, then </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=a^{\\prime}<span class="math">. Otherwise, if </span>a^{\\prime}>(q-1)/2<span class="math">, then </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=a^{\\prime}-q<span class="math">. This maps each </span>\\mathbb{F}<span class="math"> element into the interval </span>[-(q-1)/2,\\ (q-1)/2]\\subseteq\\mathbb{Z}<span class="math">. For a matrix </span>Z\\in\\mathbb{F}^{d\\times m}<span class="math">, we define the </span>\\ell_{\\infty}<span class="math">-norm </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}$ to be the max infinity norm of its elements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">The sum-check protocol <em>[46]</em></h4>

    <p class="text-gray-300">The sum-check protocol is a classic interactive proof protocol between two PPT algorithms <span class="math">(\\mathcal{P},\\mathcal{V})</span> that checks that the sum</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">of evaluations of a <span class="math">\\ell</span>-variate polynomial <span class="math">Q\\in\\mathbb{F}^{\\leq d}[X_{1},\\ldots,X_{\\ell}]</span> on the Boolean hypercube results in some value <span class="math">\\mathrm{T}</span>. The output of the sum-check protocol is a claim that <span class="math">v\\stackrel{{\\scriptstyle?}}{{=}}Q(r)</span> for some random point <span class="math">r\\in\\mathbb{F}^{\\ell}</span> and claimed evaluations <span class="math">v</span>, which the verifier <span class="math">\\mathcal{V}</span> can query <span class="math">Q</span> to check. The protocol is public-coin, has a completeness error of <span class="math">0</span>, and has a soundness error of $\\leq\\ell d/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. More generally, the field can be chosen to be an extension field </span>\\mathbb{K}<span class="math">. In this case, the soundness error is </span>\\leq\\ell d/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. A self-contained description of the sum-check protocol can be found in this note <em>[61]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">2.2 Reductions of knowledge</h3>

    <p class="text-gray-300">We now recall the reductions of knowledge framework, introduced by Kothapalli and Parno <em>[39]</em>. Reductions of knowledge are a generalization of arguments of knowledge, in which a verifier interactively <em>reduces</em> checking a prover’s knowledge of a witness in a relation <span class="math">\\mathcal{R}_{1}</span> to checking the prover’s knowledge of a witness in another (simpler) relation <span class="math">\\mathcal{R}_{2}</span>. In particular, both parties take as input a claimed instance <span class="math">u_{1}</span> to be checked, and the prover additionally takes as input a corresponding witness <span class="math">w_{1}</span> such that <span class="math">(u_{1},w_{1})\\in\\mathcal{R}_{1}</span>. After interaction, the prover and verifier together output a new instance <span class="math">u_{2}</span> to be checked in place of the original instance, and the prover additionally outputs a corresponding witness <span class="math">w_{2}</span> such that <span class="math">(u_{2},w_{2})\\in\\mathcal{R}_{2}</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 1 (Reduction of knowledge <em>[38, 39]</em>).</h6>

    <p class="text-gray-300">A reduction from <span class="math">\\mathcal{R}_{1}</span> to <span class="math">\\mathcal{R}_{2}</span> is defined by PPT algorithms <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> called the generator, encoder (deterministic), prover, and verifier respectively with the following interface.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(1^{\\lambda},\\mathsf{sz})\\to\\mathsf{pp}</span>: Takes as input a security parameter <span class="math">1^{\\lambda}</span> and size parameters <span class="math">\\mathsf{sz}</span>. Outputs public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">\\mathcal{K}(\\mathsf{pp},\\mathsf{s})\\to(\\mathsf{pk},\\mathsf{vk})</span>: Takes as input public parameters <span class="math">\\mathsf{pp}</span> and a structure <span class="math">\\mathsf{s}</span>. Outputs a prover key <span class="math">\\mathsf{pk}</span> and a verifier key <span class="math">\\mathsf{vk}</span>.</li>

      <li><span class="math">\\mathcal{P}(\\mathsf{pk},u_{1},w_{1})\\to(u_{2},w_{2})</span>: Takes as input a proving key <span class="math">\\mathsf{pk}</span> and an instance-witness pair <span class="math">(u_{1},w_{1})</span>. Interactively reduces the task of checking <span class="math">(\\mathsf{pp},\\mathsf{s},u_{1},w_{1})\\in\\mathcal{R}_{1}</span> to the task of checking <span class="math">(\\mathsf{pp},\\mathsf{s},u_{2},w_{2})\\in\\mathcal{R}_{2}</span>.</li>

      <li><span class="math">\\mathcal{V}(\\mathsf{vk},u_{1})\\to u_{2}</span>: Takes as input a verifier key <span class="math">\\mathsf{vk}</span> and an instance <span class="math">u_{1}</span> in <span class="math">\\mathcal{R}_{1}</span>. Interactively reduces the task of checking the instance <span class="math">u_{1}</span> to the task of checking a new instance <span class="math">u_{2}</span> in <span class="math">\\mathcal{R}_{2}</span>.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> denote the interaction between <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span>. We treat <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> as a function that takes as input <span class="math">((\\mathsf{pk},\\mathsf{vk}),u_{1},w_{1})</span> and runs the interaction on the prover’s input <span class="math">(\\mathsf{pk},u_{1},w_{1})</span> and the verifier’s input <span class="math">(\\mathsf{vk},u_{1})</span>. At the end of the interaction, <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> outputs the verifier’s instance <span class="math">u_{2}</span> and the prover’s witness <span class="math">w_{2}</span>. A reduction of knowledge is a reduction, <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>, that satisfies the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[label=()]</li>

      <li>Completeness: For any EPT adversary <span class="math">\\mathcal{A}</span>, given <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(1^{\\lambda},\\mathsf{sz})</span>, <span class="math">(\\mathsf{s},u_{1},w_{1})</span> <span class="math">\\leftarrow\\mathcal{A}(\\mathsf{pp})</span> such that <span class="math">(\\mathsf{pp},\\mathsf{s},u_{1},w_{1})\\in\\mathcal{R}_{1}</span>, we have that the prover’s output instance is equal to the verifier’s output instance <span class="math">u_{2}</span>, and that</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{pp},\\mathsf{s},\\langle\\mathcal{P},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),u_{1},w_{1}))\\in\\mathcal{R}_{2}.</span></p>

    <p class="text-gray-300">(i) Knowledge soundness: For any EPT adversary <span class="math">(\\mathcal{A},\\mathcal{P}^{*})</span>, there exists an EPT extractor <span class="math">\\mathcal{E}</span> such that if the success probability of the adversary</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\epsilon (\\mathcal {A}, \\mathcal {P} ^ {<em>}) := \\Pr \\left[ (\\mathsf {p p}, \\mathsf {s}, \\langle \\mathcal {P} ^ {</em>}, \\mathcal {V} \\rangle ((\\mathsf {p k}, \\mathsf {v k}), u _ {1}, \\mathsf {s t})) \\in \\mathcal {R} _ {2} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, \\mathsf {s z}) \\\\ (\\mathsf {s}, u _ {1}, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, \\mathsf {s}) \\end{array} \\right. \\right]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><span class="math">\\geq 1 / \\mathsf{poly}(\\lambda)</span>, then we have that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ (\\mathsf {p p}, \\mathsf {s}, u _ {1}, w _ {1}) \\in \\mathcal {R} _ {1} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, \\mathsf {s z}) \\\\ (\\mathsf {s}, u _ {1}, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, \\mathsf {s}) \\\\ w _ {1} \\leftarrow \\mathcal {E} (\\mathsf {p p}, \\mathsf {s}, u _ {1}, \\mathsf {s t}) \\end{array} \\right. \\right] \\geq \\epsilon (\\mathcal {A}, \\mathcal {P} ^ {*}) - \\mathsf {n e g l} (\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">(iii) Public Coin: All of the verifier's messages are uniformly random strings of some prescribed length. Furthermore, the verifier's messages contain all of the random coins (randomness) used by the verifier.[11]</p>

    <p class="text-gray-300">Typically, we are interested in reducing several relations at once. We can interpret several relations as a single relation using the following product operator.</p>

    <p class="text-gray-300">Definition 2 (Relation product). For relations <span class="math">\\mathcal{R}_1</span> and <span class="math">\\mathcal{R}_2</span> over public parameter, structure, instance, and witness pairs we define the relation product as follows.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {1} \\times \\mathcal {R} _ {2} = \\left\\{\\left(\\mathsf {p p}, \\mathsf {s}, (u _ {1}, u _ {2}), (w _ {1}, w _ {2})\\right) \\mid (\\mathsf {p p}, \\mathsf {s}, u _ {1}, w _ {1}) \\in \\mathcal {R} _ {1}, (\\mathsf {p p}, \\mathsf {s}, u _ {2}, w _ {2}) \\in \\mathcal {R} _ {2} \\right\\}.</span></div>

    <p class="text-gray-300">We let <span class="math">\\mathcal{R}^n</span> denote <span class="math">\\mathcal{R}\\times \\ldots \\times \\mathcal{R}</span> for <span class="math">n</span> times.</p>

    <p class="text-gray-300">A motivating property of reductions of knowledge is that they are composable, allowing us to build complex reductions by stitching together simpler ones. In particular, given reductions of knowledge <span class="math">\\Pi_1: \\mathcal{R}_1 \\to \\mathcal{R}_2</span> and <span class="math">\\Pi_2: \\mathcal{R}_2 \\to \\mathcal{R}_3</span> we have that <span class="math">\\Pi_2 \\circ \\Pi_1</span> (i.e., running <span class="math">\\Pi_1</span> first and then running <span class="math">\\Pi_2</span> on the outputs) is a reduction of knowledge from <span class="math">\\mathcal{R}_1</span> to <span class="math">\\mathcal{R}_3</span>. We define the formal semantics of the sequential composition operator <span class="math">\\circ</span>.</p>

    <p class="text-gray-300">Lemma 1 (Sequential composition [38,39]). For reductions of knowledge <span class="math">\\Pi_1 = (\\mathcal{G},\\mathcal{K},\\mathcal{P}_1,\\mathcal{V}_1):\\mathcal{R}_1\\to \\mathcal{R}_2</span> and <span class="math">\\Pi_2 = (\\mathcal{G},\\mathcal{K},\\mathcal{P}_2,\\mathcal{V}_2):\\mathcal{R}_2\\to \\mathcal{R}_3</span>, we have that <span class="math">\\Pi_2\\circ \\Pi_1 = (\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V}):\\mathcal{R}_1\\to \\mathcal{R}_3</span> is a reduction of knowledge where <span class="math">\\mathcal{K}(\\mathsf{pp},\\mathsf{s})</span> computes <span class="math">(\\mathsf{pk},\\mathsf{vk})</span> and where</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {P} (\\mathsf {p k}, u _ {1}, w _ {1}) = \\mathcal {P} _ {2} (\\mathsf {p k}, \\mathcal {P} _ {1} (\\mathsf {p k}, u _ {1}, w _ {1}))</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {V} (\\mathsf {v k}, u _ {1}) = \\mathcal {V} _ {2} (\\mathsf {v k}, \\mathcal {V} _ {1} (\\mathsf {v k}, u _ {1}, w _ {1}))</span></div>

    <p class="text-gray-300">In this work, we are primarily interested in building folding schemes, a particular type of reduction of knowledge that reduces the task of checking instances in some relation <span class="math">\\mathcal{R}_2</span> into a running instance in a relation <span class="math">\\mathcal{R}_1</span>.</p>

    <p class="text-gray-300">Definition 3 (Folding scheme). A folding scheme for <span class="math">\\mathcal{R}_1</span> and <span class="math">\\mathcal{R}_2</span> is a reduction of knowledge of type <span class="math">\\mathcal{R}_1 \\times \\mathcal{R}_2 \\to \\mathcal{R}_1</span>.</p>

    <p class="text-gray-300">[11] If a reduction of knowledge is public-coin, then it trivially satisfies the property of public reducibility described in [39] as the execution of the verifier <span class="math">\\mathcal{V}</span> can be emulated using the randomness from the transcript.</p>

    <p class="text-gray-300">Definition 4 (Modules). Modules are a generalization of vector spaces for which the field of scalars is replaced by a ring  <span class="math">R</span> . Suppose  <span class="math">R</span>  is a commutative ring with identity 1 and  <span class="math">G</span>  is an abelian (commutative) group. The group  <span class="math">G</span>  is an  <span class="math">R</span> -module if there is an operation  <span class="math">\\cdot : R \\times G \\to G</span>  such that for all  <span class="math">r, s \\in R</span>  and  <span class="math">x, y \\in G</span> ,  <span class="math">r \\cdot (x + y) = r \\cdot x + r \\cdot y</span> ,  <span class="math">(r + s) \\cdot x = r \\cdot x + s \\cdot x</span> ,  <span class="math">(rs) \\cdot x = r \\cdot (s \\cdot x)</span> ,  <span class="math">1 \\cdot x = x</span> . Suppose  <span class="math">G_1</span>  and  <span class="math">G_2</span>  are  <span class="math">R</span> -modules. Similarly, an  <span class="math">R</span> -module homomorphism is a map  <span class="math">\\mathcal{L} : G_1 \\to G_2</span>  that is a generalization of a linear map of vector spaces.  <span class="math">\\mathcal{L}</span>  is an  <span class="math">R</span> -module homomorphism if for all  <span class="math">x, y \\in G_1</span>  and  <span class="math">r \\in R</span> ,  <span class="math">f(x + y) = f(x) + f(y)</span> ,  <span class="math">f(r \\cdot x) = r \\cdot f(x)</span> .</p>

    <p class="text-gray-300">Definition 5 (Cyclotomic ring). Let  <span class="math">\\eta \\in \\mathbb{N}</span>  be a prime power, and  <span class="math">\\Phi_{\\eta}</span>  is the  <span class="math">\\eta</span> -th cyclotomic polynomial with degree  <span class="math">d</span> . We define the cyclotomic ring that we operate over as the quotient ring  <span class="math">R_{q} := \\mathbb{F}[X] / (\\Phi_{\\eta})</span> , whose elements can be viewed as polynomials over  <span class="math">\\mathbb{F}</span>  with degree less than  <span class="math">d</span> .</p>

    <p class="text-gray-300">Definition 6 (Coefficient maps). We denote the coefficient vector of an element  <span class="math">a \\in R_q</span>  as  <span class="math">a&#x27; = \\mathsf{cf}(a) \\in \\mathbb{F}^d</span>  and  <span class="math">a = \\mathsf{cf}^{-1}(a&#x27;) \\in R_q</span>  to be the inverse map which takes a vector of  <span class="math">d</span>  coefficients and outputs the corresponding ring element. Given a vector  <span class="math">z \\in R_q^m</span> , we denote  <span class="math">\\mathsf{cf}(z)</span>  to be the matrix  <span class="math">Z = \\left[ \\mathsf{cf}(z_1) \\mid \\mathsf{cf}(z_2) \\mid \\dots \\mid \\mathsf{cf}(z_m) \\right] \\in \\mathbb{F}^{d \\times m}</span>  and  <span class="math">\\mathsf{cf}^{-1}(Z)</span>  to be the inverse map which takes a matrix in  <span class="math">\\mathbb{F}^{d \\times m}</span>  and outputs the corresponding vector of ring elements.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Norm. For an element  <span class="math">a \\in R_q</span> , we define  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">  to be the  </span>\\ell_{\\infty}<span class="math"> -norm of the vector  </span>\\mathsf{cf}(a)<span class="math"> . Similarly, for a vector  </span>z \\in R_q^m<span class="math"> , we define  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">  to be the  </span>\\ell_{\\infty}<span class="math"> -norm of the matrix  </span>\\mathsf{cf}(Z)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 7 (Rotation matrices). We define a shift matrix  <span class="math">\\mathsf{F} \\in \\mathbb{F}^{d \\times d}</span>  and rotation matrix,  <span class="math">\\operatorname{rot}(a) \\in \\mathbb{F}^{d \\times d}</span>  for an element  <span class="math">a \\in R_q</span>  [50, pg. 11]:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {F} := \\left[ \\begin{array}{c c} \\mathbf {0} &amp;amp; - c _ {0} \\\\ \\hline &amp;amp; - c _ {1} \\\\ \\mathrm {I} _ {d - 1} &amp;amp; \\vdots \\\\ &amp;amp; - c _ {d - 1} \\end{array} \\right], \\mathsf {r o t} (a) := \\left[ \\mathsf {c f} (a) \\mid \\mathsf {F} \\cdot \\mathsf {c f} (a) \\mid \\dots \\mid \\mathsf {F} ^ {d - 1} \\cdot \\mathsf {c f} (a) \\right]</span></div>

    <p class="text-gray-300">where the coefficients of the cyclotomic polynomial are  <span class="math">\\Phi_{\\eta} = x^{d} + c_{d - 1}x^{d - 1} + c_{d - 2}x^{d - 2} + \\dots +c_{0}</span> . For all  <span class="math">a\\in R_q</span> , we have  <span class="math">\\mathsf{cf}(X\\cdot a) = \\mathsf{F}\\cdot \\mathsf{cf}(a)</span> . Hence, for all  <span class="math">a,b\\in R_q</span> ,  <span class="math">\\mathsf{rot}(a)\\cdot \\mathsf{cf}(b) = \\mathsf{cf}(ab)</span> .</p>

    <p class="text-gray-300">Remark 1 (Visualizing rotation matrices). The shift matrix  <span class="math">\\mathsf{F}</span>  effectively rotates a vector and shifts by the coefficients of the cyclotomic polynomial scaled by the</p>

    <p class="text-gray-300">last entry of the vector. Below, we have an example for a rotation matrix for an element  <span class="math">a \\in R_q</span>  where  <span class="math">\\Phi_{\\eta} = X^{d} + 1</span> .</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {F} \\cdot \\mathsf {c f} (a) = \\left[ \\begin{array}{c} 0 \\\\ a _ {0} \\\\ \\vdots \\\\ a _ {d - 2} \\end{array} \\right] + a _ {d - 1} \\left[ \\begin{array}{c} - c _ {0} \\\\ - c _ {1} \\\\ \\vdots \\\\ - c _ {d - 1} \\end{array} \\right], \\mathsf {r o t} (a) := \\left[ \\begin{array}{c c c c} a _ {0} &amp;amp; - a _ {d - 1} &amp;amp; \\ldots &amp;amp; - a _ {1} \\\\ a _ {1} &amp;amp; a _ {0} &amp;amp; \\ldots &amp;amp; - a _ {2} \\\\ \\vdots &amp;amp; \\vdots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ a _ {d - 1} &amp;amp; a _ {d - 2} &amp;amp; \\ldots &amp;amp; a _ {0} \\end{array} \\right]</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 8 (Module short integer solution [45,47,55]). Define the ring  <span class="math">R \\coloneqq \\mathbb{Z}[X] / (\\Phi_{\\eta})</span> . The  <span class="math">\\mathrm{MSIS}_{m,B}^{\\infty,\\kappa,q}</span>  problem is defined as follows: Given a matrix  <span class="math">M \\stackrel{\\S}{\\leftarrow} R_q^{\\kappa \\times m}</span>  sampled uniformly at random, find a non-zero vector  <span class="math">z \\in R</span>  such that  <span class="math">Mz = 0 \\mod q</span>  and  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq B$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 9 (Ajtai commitment scheme [5]). Assume the  <span class="math">\\mathsf{MSIS}_{m,2B}^{\\infty,\\kappa,q}</span>  problem is hard. Let message length  <span class="math">m \\in \\mathbb{N}</span> . The Ajtai commitment scheme  <span class="math">\\mathsf{com} := (\\mathsf{Setup}, \\mathsf{Commit})</span>  consists of the following algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup  <span class="math">(\\kappa, m) \\to \\mathbb{pp}</span> : Sample a random matrix  <span class="math">M \\stackrel{\\S}{\\leftarrow} R_q^{\\kappa \\times m}</span> . Output  <span class="math">\\mathbb{pp} \\gets M</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Commit  <span class="math">(\\mathsf{pp},z)\\to c</span>  : Given public parameters pp and vector  <span class="math">z\\in R_q^m</span>  such that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq B<span class="math">  , output  </span>Mz$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 1 (Low norm invertibility [48, Theorem 1.1]). Let  <span class="math">z \\in \\mathbb{N}</span>  such that  <span class="math">z \\mid \\eta</span> ,  <span class="math">q \\equiv 1 \\pmod{z}</span> , and  <span class="math">\\operatorname{ord}_{\\eta}(q) = \\eta / z</span> . Define  <span class="math">\\mathsf{b}_{\\mathrm{inv}} := 1 / \\sqrt{\\tau(z)} \\cdot q^{1 / \\phi(z)}</span>  where  <span class="math">\\tau(z) := z</span>  if  <span class="math">z</span>  is odd, otherwise  <span class="math">\\tau(z) = z / 2</span> . For an arbitrary  <span class="math">a \\in R_q</span> , if  $0 &lt; \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{cf}(a) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; \\mathsf{b}_{\\mathrm{inv}}<span class="math"> , then  </span>a<span class="math">  is invertible in  </span>R_q$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 10 (Strong sampling sets [23]). Define  <span class="math">\\mathcal{C}_R \\subseteq R_q</span>  to be any set of ring elements such that for any distinct elements  <span class="math">a, b \\in \\mathcal{C}_R</span> ,  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{cf}(a - b) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; \\mathsf{b}_{\\mathrm{inv}}$  (Theorem 1).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This section describes Neo's lattice-based commitment scheme that can be used to construct folding schemes. We begin with requirements on this commitment scheme and highlight challenges that must be addressed.</p>

    <p class="text-gray-300">To construct our lattice-based folding scheme for CCS, we need a lattice-based commitment scheme for a vector of field elements  <span class="math">z \\in \\mathbb{F}^m</span>  (e.g., a witness vector for CCS). We require this commitment scheme to satisfy several properties.</p>

    <p class="text-gray-300">(1) Linear homomorphism for folding multilinear evaluation claims. Given a collection of commitments  <span class="math">(c_{i})_{i\\in [k]}</span>  and the corresponding claimed evaluations  <span class="math">(r_i,y_i)_{i\\in [k]}</span> , we want to be able to reduce the task of proving that the commitments indeed open to corresponding vectors,  <span class="math">(z_{i})_{i\\in [k]}</span> , such that their multilinear</p>

    <p class="text-gray-300">extension polynomials evaluate to the claimed evaluations to the task of proving that a single commitment <span class="math">C</span> opens to a vector, <span class="math">z</span>, whose multilinear extension polynomial evaluates to some value <span class="math">y</span>.</p>

    <p class="text-gray-300">Challenges. For discrete-log based commitments (e.g., Pedersen <em>[54]</em>, HyperKZG <em>[64]</em>), this simply amounts to taking a random linear combination of the commitments to get a single commitment <span class="math">c</span>, and proving that a vector <span class="math">z</span> underneath <span class="math">c</span> evaluates to some <span class="math">y</span> at <span class="math">r</span>, where <span class="math">y</span> is the weighted sum of <span class="math">\\{y_{i}\\}_{i\\in[k]}</span> (the weights used for combining evaluations is the same as the weights used for combining commitments). However, for lattice-based commitments such as Ajtai (Definition 9), the binding of the commitment scheme depends on the norm of the vector <span class="math">z</span>. Thus, there are two main challenges when taking linear combinations. First, the norm of the vector <span class="math">z</span> may be larger than allowed for the binding of the commitment scheme, and the extraction procedure of the folding scheme (for knowledge soundness) may not preserve the original norm. Second, how can we even commit to arbitrary vectors <span class="math">z\\in\\mathbb{F}^{m}</span>, when the norm of <span class="math">z</span> may be large?</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">(2) Pay-per-bit costs.</h4>

    <p class="text-gray-300">We require that the cost to commit to a vector of values scales with the bit width of the values in the vector. This is not necessary for constructing a folding scheme for CCS, but it is a highly desirable property in practice as often times the witness values are in a small subset of the field.</p>

    <p class="text-gray-300">Challenges. With discrete-log based commitments, the cost of committing to a vector <span class="math">z</span> scales with the bit-width of its elements. When moving to Ajtai commitments, this is non-trivial to achieve. For example, prior works such as LatticeFold <em>[14]</em> do not provide such a cost profile. We now provide details.</p>

    <p class="text-gray-300">LatticeFold does not provide pay-per-bit commitment costs because of the way it embeds a vector <span class="math">z\\in\\mathbb{F}^{m}</span> into the cyclotomic ring <span class="math">z^{\\prime}\\in R_{q}^{m}</span> prior to committing with Ajtai’s commitment scheme. In particular, for certain choices of cyclotomic rings, the ring <span class="math">R_{q}\\simeq(\\mathbb{F}_{q^{\\tau}})^{t}</span> (for which <span class="math">t\\cdot\\tau=d</span> and <span class="math">d</span> is the degree of <span class="math">\\Phi_{\\eta}</span>) is isomorphic to multiple copies of an extension field <span class="math">\\mathbb{F}_{q^{\\tau}}</span>. This is often referred to as the NTT representation of an <span class="math">R_{q}</span> element. When committing to a vector <span class="math">z\\in\\mathbb{F}^{m}</span> (e.g., the CCS witness), LatticeFold first embeds the vector <span class="math">z</span> into the extension field <span class="math">\\mathbb{F}_{q^{\\tau}}</span>. Together with <span class="math">t-1</span> other vectors, LatticeFold applies the so-called NTT transformation to obtain a ring vector <span class="math">z^{\\prime}\\in R_{q}^{m}</span> whose NTT representation equals to those <span class="math">t</span> vectors. The important point here is that the NTT transformation does not preserve the norm of the input vectors. If <span class="math">z\\in\\mathbb{F}^{m}</span> has a low norm, then that does not mean <span class="math">z^{\\prime}\\in R_{q}^{m}</span> has a low norm. Hence, the final step to commit using Ajtai’s commitment scheme is to decompose <span class="math">z^{\\prime}\\in R_{q}^{m}</span> into a longer vector <span class="math">z^{\\prime\\prime}\\in R_{q}^{m\\cdot\\ell}</span> whose ring elements have low enough norm or into multiple vectors <span class="math">(z^{\\prime}_{i})_{i\\in[k]}</span>, which further increases the cost to commit. Thus, regardless of the bit-width of the original vectors, the cost to commit is the same (i.e., LatticeFold does not achieve pay-per-bit commitment costs).</p>

    <p class="text-gray-300">(3) Support for small fields and for folding linear transforms. To fold CCS instance-witness pairs, we need to fold evaluations of not only the multilinear extensions of CCS witness vector <span class="math">z</span>, but also evaluations of <span class="math">\\widetilde{M}z</span> for some CCS constraint matrix <span class="math">M</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Challenges. In prior work <em>[14]</em>, this is achieved by taking random linear combinations of the witness commitments and evaluations, where the witnesses are embedded in the NTT representation of ring elements. However, as noted <em>[14, Section 3.3]</em>, when supporting “small” fields (i.e., fields whose order is not <span class="math">2^{\\lambda}</span>), this strategy leads to a <span class="math">\\tau</span> multiplicative factor blow-up in the cost of the protocols, where <span class="math">\\tau</span> is the degree of the extension field in the NTT representation. For example, in LatticeFold’s example parameterization <em>[14, Sec. 5]</em> for 64-bit fields, one would need to set <span class="math">\\tau=4</span>. This is due to security requirements and a mapping between coefficient and NTT representation that loses a <span class="math">\\tau</span> factor of packing. Furthermore, this transformation between coefficient and NTT representation incurs another factor of 2, because evaluations over both NTT representation and coefficient representation need to be accounted for. In LatticeFold’s folding protocol, the prover and the verifier must execute the sum-check protocol over cyclotomic polynomial rings (instead of fields). When using the NTT representation <span class="math">(\\mathbb{F}_{q^{\\tau}})^{t}</span> for ring elements, this sum-check can be performed as operations over <span class="math">\\mathbb{F}_{q^{\\tau}}</span>. Despite the field being 64-bits in size, they must work over a larger extension field $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{q^{4}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{256}<span class="math">. As we describe later, Neo’s folding scheme does not have to operate over such a large extension field, since we avoid this security issue entirely. In our parameterization Section 6, the sum-check protocol can draw challenges over </span>\\mathbb{F}_{q^{2}}<span class="math"> instead when </span>q$ is about 64 bits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">3.2 Neo’s solution, part-1: A matrix commitment scheme</h3>

    <p class="text-gray-300">Research question. Can we construct a simple and efficient lattice-based commitment scheme that can satisfy all of our requirements and that works natively over small prime fields (e.g., M61)?</p>

    <p class="text-gray-300">Our starting point is Ajtai’s commitment scheme (Definition 9). This scheme commits to a vector of low-norm ring elements <span class="math">z\\in R_{q}^{m}</span> (i.e., the coefficients of ring elements have low-norm) by multiplying the vector with a matrix <span class="math">M</span> sampled in the setup algorithm. Looking ahead, we can view the vector <span class="math">z</span> of ring elements as a matrix of its coefficients.</p>

    <p class="text-gray-300">The first question that we need to resolve is the following: given a vector <span class="math">z\\in\\mathbb{F}^{m}</span>, how can we embed <span class="math">z</span> into a low-norm vector <span class="math">z^{\\prime}\\in R_{q}^{m}</span> such that <span class="math">z^{\\prime}</span> can be committed directly with Ajtai’s commitment scheme while preserving the required homomorphism properties?</p>

    <p class="text-gray-300">We map each element <span class="math">z_{i}\\in\\mathbb{F}</span> to a single ring element <span class="math">z^{\\prime}_{i}\\in R_{q}</span> by embedding the <span class="math">b</span>-bit words of <span class="math">z_{i}:=\\sum_{j=1}^{d}b^{j-1}z_{i,j}</span> into the coefficients <span class="math">z^{\\prime}_{i}:=\\sum_{j=1}^{d}z_{i,j}\\cdot X^{j-1}</span>. This embedding guarantees that <span class="math">z^{\\prime}_{i}</span> has low-norm. More formally, we define several decomposition mappings that we employ: (1) <span class="math">\\mathsf{Decomp}_{b}</span> maps <span class="math">z\\in\\mathbb{F}^{m}</span> into a matrix <span class="math">Z\\in\\mathbb{F}^{d\\times m}</span> with low-norm; and (2) Given a matrix <span class="math">Z\\in\\mathbb{F}^{d\\times m}</span>, <span class="math">\\mathsf{split}_{b}</span> splits <span class="math">Z</span> into multiple matrices with low-norm.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Definition 11 (Decomposition and splitting).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">b,m\\in\\mathbb{N}</span>. We define <span class="math">\\mathsf{Decomp}_{b}:\\mathbb{F}^{m}\\to\\mathbb{F}^{<em>\\times m}</span> as the map which takes a vector <span class="math">z</span> and performs the <span class="math">b</span>-ary decomposition into a matrix <span class="math">Z:=\\mathsf{Decomp}_{b}(z)\\in\\mathbb{F}^{</em>\\times m}</span>. For example, if <span class="math">z\\in\\mathbb{F}^{m}</span> such that $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<b^{d}$, then we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{Decomp}_{b}(z):=\\begin{bmatrix}\\frac{Z^{(1)}}{Z^{(2)}}\\cr\\cdots\\cr Z^{(d)}\\end{bmatrix}\\text{ such that }z=\\sum_{i=1}^{d}b^{i-1}\\cdot Z^{(i)}\\text{ and }\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z^{(i)}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<b$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">Z^{(i)}</span> is the <span class="math">i</span>-th row of <span class="math">Z</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We define <span class="math">\\mathsf{split}_{b}:\\mathbb{F}^{d\\times m}\\to(\\mathbb{F}^{d\\times m})^{<em>}</span> to be the <span class="math">b</span>-ary decomposition map, which performs the <span class="math">b</span>-ary decomposition of a matrix <span class="math">Z\\in\\mathbb{F}^{d\\times m}</span> into matrices <span class="math">Z_{1},Z_{2},\\ldots,Z_{</em>}</span>. For example, if <span class="math">Z\\in\\mathbb{F}^{d\\times m}</span> such that and $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<b^{k}$, then we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{split}_{b}(Z):=(Z_{1},Z_{2},\\ldots Z_{k})\\quad\\text{such that}\\quad Z=\\sum_{i=1}^{k}b^{i-1}\\cdot Z_{i}\\text{ and }\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{i}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<b$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We then apply Ajtai’s commitment scheme to commit to low-norm matrices <span class="math">Z\\in\\mathbb{F}^{d\\times m}</span> (Theorem 2). In particular, each column of a low-norm matrix gets mapped as the coefficients of a single ring element. Each ring element corresponds 1-to-1 with the decomposition of a single witness element. We refer to the resulting vector as <span class="math">z^{\\prime}\\leftarrow\\mathsf{cf}^{\\cdot 1}(Z)</span>. To compute the commitment to <span class="math">Z</span>, we compute the Ajtai commitment <span class="math">Mz^{\\prime}</span>. Since <span class="math">Z</span> is low-norm, Ajtai’s commitment scheme provides the desired binding property.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Bit-width scaling multiplication</h4>

    <p class="text-gray-300">We now discuss how the cost of Ajtai’s commitment scheme, with our particular embedding of witnesses into ring elements, scales linearly with the bit-width of the witness <span class="math">z</span>. Recall that Ajtai’s commitment scheme is merely a ring matrix multiplication <span class="math">Mz^{\\prime}</span>.</p>

    <p class="text-gray-300">We show how the cost of a ring multiplication for which <span class="math">a,b\\in R_{q}</span> where <span class="math">b</span> only has binary coefficients scales with the number of non-zero coefficients of <span class="math">b</span>. As a result, this shows that the cost of the matrix multiplication <span class="math">Mz^{\\prime}</span> scales with the bit-width of <span class="math">z^{\\prime}</span>. By the definition of rotation matrices (Definition 7),</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{cf}(a\\cdot b)=\\mathsf{rot}(a)\\cdot\\mathsf{cf}(b)=\\left[\\begin{array}[]{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c}\\boldsymbol{a}_{1}&&\\boldsymbol{a}_{2}&\\ldots&\\boldsymbol{a}_{d}\\end{array}\\right]\\begin{bmatrix}b_{1}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">b_{2}\\\\ \\vdots\\\\ b_{d}\\end{bmatrix}=\\sum_{i=1}^{d}b_{i}\\cdot\\boldsymbol{a}_{i}$</p>

    <p class="text-gray-300">where <span class="math">\\boldsymbol{a}_{i}</span> denotes the <span class="math">i</span>-th column of <span class="math">\\mathsf{rot}(a)</span>. Since coefficients <span class="math">(b_{i})_{i}</span> are bits, this amounts to just adding the columns which correspond to the <span class="math">b_{i}=1</span>. For a choice of cyclotomic ring (Definition 5) (with a cyclotomic polynomial containing a constant number of coefficients), computing these columns <span class="math">\\boldsymbol{a}_{i}</span> requires just a rotation of the prior column and adding a constant number of field elements (Remark 1).</p>

    <p class="text-gray-300">Homomorphism. When Ajtai's commitment scheme is viewed as a commitment scheme for vectors  <span class="math">z \\in R_q^m</span> , there is a natural understanding of taking linear combinations, namely the Ajtai commitment scheme is an  <span class="math">R_q</span> -module homomorphism  <span class="math">\\mathcal{L}: R_q^m \\to R_q^\\kappa</span>  (i.e.  <span class="math">c_1 + r \\cdot c_2 = \\mathcal{L}(z_1 + r \\cdot z_2)</span>  for  <span class="math">r \\in R_q</span> ). But, what is the analogue for matrices? We now provide details.</p>

    <p class="text-gray-300">Definition 12 (Ring of rotation matrices). Let  <span class="math">R_{q}</span>  be a cyclotomic ring. We define  <span class="math">S := \\{\\mathrm{rot}(a) \\mid a \\in R_{q}\\} \\subseteq \\mathbb{F}^{d \\times d}</span>  to be the ring of all rotation matrices for elements in  <span class="math">R_{q}</span> . For our purposes,  <span class="math">S</span>  can be thought of as a commutative subring of matrices  <span class="math">\\mathbb{F}^{d \\times d}</span> , which contains all scalar matrices (exactly the rotation matrices for the constant ring elements).</p>

    <p class="text-gray-300">It turns out that the ring  <span class="math">R_{q}</span>  is isomorphic to the ring of rotation matrices  <span class="math">S \\subseteq \\mathbb{F}^{d \\times d}</span>  (Theorem 7). Hence, instead of an  <span class="math">R_{q}</span> -module homomorphism, the commitment scheme can be viewed as a  <span class="math">S</span> -module homomorphism  <span class="math">\\mathcal{L}: \\mathbb{F}^{d \\times m} \\to \\mathbb{F}^{d \\times \\kappa}</span> , where the matrices  <span class="math">Z \\in \\mathbb{F}^{d \\times d}</span>  and commitments in  <span class="math">\\mathbb{F}^{d \\times \\kappa}</span>  (i.e., the coefficient matrix of the ring elements) are left multiplied by elements  <span class="math">r \\in S \\subseteq \\mathbb{F}^{d \\times d}</span> . We formalize this view with the following definition.</p>

    <p class="text-gray-300">Definition 13 (Matrix commitment scheme). Let  <span class="math">\\mathbb{F}</span>  be a field. A matrix commitment scheme  <span class="math">\\operatorname{com} := (\\text{Setup}, \\text{Commit})</span>  consists of two algorithms.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Setup}(1^{\\lambda}, d, m) \\to \\mathfrak{pp}</span> : Takes as input a security parameter  <span class="math">1^{\\lambda}</span>  and matrix dimensions  <span class="math">d, m \\in \\mathbb{N}</span> , outputs public parameters  <span class="math">\\mathfrak{pp}</span> .</li>

      <li>Commit  <span class="math">(\\mathfrak{pp}, Z) \\to c</span> : Takes as input public parameters  <span class="math">\\mathfrak{pp}</span>  and a matrix  <span class="math">Z \\in \\mathbb{F}^{d \\times m}</span> , outputs a commitment  <span class="math">c \\in \\mathbb{C}</span> .</li>

    </ul>

    <p class="text-gray-300">These algorithms can satisfy the following properties.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}</span> -homomorphic: Let space  <span class="math">\\mathcal{S} \\subset \\mathbb{F}^{d \\times d}</span>  be a commutative sub-ring of  <span class="math">d \\times d</span>  matrices. For all  <span class="math">m \\in \\mathbb{N}</span>  and public parameters  <span class="math">\\mathfrak{pp}</span>  output by  <span class="math">\\operatorname{Setup}(1^{\\lambda}, d, m)</span> , we have that for all matrices  <span class="math">Z_1, Z_2 \\in \\mathbb{F}^{d \\times m}</span>  and  <span class="math">\\rho_1, \\rho_2 \\in \\mathcal{S}</span>  that</p>

    <div class="my-4 text-center"><span class="math-block">\\rho_ {1} \\cdot \\operatorname {C o m m i t} (\\mathfrak {p p}, Z _ {1}) + \\rho_ {2} \\cdot \\operatorname {C o m m i t} (\\mathfrak {p p}, Z _ {2}) = \\operatorname {C o m m i t} (\\mathfrak {p p}, \\rho_ {1} \\cdot Z _ {1} + \\rho_ {2} \\cdot Z _ {2})</span></div>

    <p class="text-gray-300">More formally, the commitment algorithm  <span class="math">\\mathsf{Commit}(\\mathsf{pp},\\cdot):\\mathbb{F}^{d\\times m}\\to \\mathbb{C}</span>  is an  <span class="math">S</span>  -module homomorphism.</p>

    <p class="text-gray-300"><span class="math">(d,m,B)</span> -Binding: For all expected polynomial time adversaries  <span class="math">\\mathcal{A}</span> , we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname * {P r} \\left[ \\begin{array}{l l} \\operatorname {C o m m i t} (\\mathfrak {p p}, Z _ {1}) = \\operatorname {C o m m i t} (\\mathfrak {p p}, Z _ {2}) &amp; \\mathfrak {p p} \\leftarrow \\operatorname {S e t u p} (1 ^ {\\lambda}, d, m) \\\\ \\wedge Z _ {1} \\neq Z _ {2} &amp; Z _ {1}, Z _ {2} \\in \\mathbb {F} ^ {d \\times m} \\leftarrow \\mathcal {A} (\\mathfrak {p p}) \\\\ \\wedge \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z _ {1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty}, \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z _ {2} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} &lt;   B &amp; \\end{array} \\right]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><span class="math">\\leq \\epsilon_{\\mathrm{bind}}(\\mathsf{com},d,m,B)\\leq \\mathsf{negl}(\\lambda)</span> . We refer to the pair of messages  <span class="math">(Z_{1},Z_{2})</span>  which satisfies the conditions in the probability as an  <span class="math">(d,m,B)</span> -binding collision.</p>

    <p class="text-gray-300">Theorem 2. Let  <span class="math">R_{q}</span>  be a cyclotomic ring (Definition 5) and  <span class="math">S</span>  be the ring of all rotation matrices (Definition 7). If the  <span class="math">\\mathsf{MSIS}_{m,2B}^{\\infty, a, q}</span>  problem is hard then Ajtai's commitment scheme (Definition 9) is a matrix commitment scheme (Definition 13) that is  <span class="math">S</span> -homomorphic and  <span class="math">(d, m, B)</span> -binding.</p>

    <p class="text-gray-300">Proof. For brevity, we defer the proof to Appendix B.1.</p>

    <p class="text-gray-300">3.3 Neo’s solution, part-2: linear homomorphism for folding multilinear evaluation claims</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Based on the description thus far, we have a commitment scheme that commits to CCS witnesses $z:=x\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,w\\in\\mathds{F}^{m}<span class="math"> as low-norm matrices </span>Z:=X\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,W\\in\\mathds{F}^{d\\times m}<span class="math">. As discussed earlier, we want to be able to fold evaluations of the multilinear extensions </span>\\widetilde{Mz}<span class="math"> for some matrix </span>M$ (e.g., the CCS constraint matrices).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our starting point is the following lemma, which observes that linear combinations of commitments respect right multiplication of their openings. Looking ahead, we carefully choose the matrix <span class="math">V</span> to be <span class="math">M^{\\intercal}\\widehat{r}</span> which will allow us to fold the desired multilinear evaluations at a point <span class="math">r</span>. In particular, consider a vector <span class="math">Z\\leftarrow\\mathsf{Decomp}_{b}(z)\\in\\mathds{F}^{d\\times m}</span> (Definition 11). For a matrix <span class="math">M\\in\\mathds{F}^{n\\times m}</span> and <span class="math">r\\in\\mathds{K}^{\\log n}</span> (<span class="math">\\widehat{r}\\in\\mathds{K}^{n}</span>), observe that</p>

    <p class="text-gray-300"><span class="math">ZM^{\\intercal}\\widehat{r}</span> <span class="math">=[Z^{(1)}M^{\\intercal}\\widehat{r},\\,Z^{(2)}M^{\\intercal}\\widehat{r},\\,\\ldots,\\,Z^{(d)}M^{\\intercal}\\widehat{r}]</span> <span class="math">=[\\widetilde{MZ^{(1)}}(r),\\,\\,\\widetilde{MZ^{(2)}}(r),\\,\\,\\ldots,\\,\\,\\widetilde{MZ^{(d)}}(r)]</span></p>

    <p class="text-gray-300">where <span class="math">Z^{(i)}</span> is the <span class="math">i</span>-th row of <span class="math">Z</span>. To obtain the evaluation <span class="math">\\widetilde{Mz}(r)</span>, it suffices to compute the sum <span class="math">\\sum_{i=1}^{d}b^{i-1}Z^{(i)}M^{\\intercal}\\widehat{r}=(\\sum_{i=1}^{d}b^{i-1}Z^{(i)})M^{\\intercal}\\widehat{r}=zM^{\\intercal}\\widehat{r}=\\widetilde{Mz}(r)</span>. Another way to view <span class="math">ZM^{\\intercal}\\widehat{r}</span> is as a partial evaluation <span class="math">y\\in\\mathds{F}^{d}</span> such that <span class="math">\\widetilde{y}(X_{1},\\ldots,X_{d})=\\widetilde{ZM^{\\intercal}}(X_{1},\\ldots,X_{d},r)</span>.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Lemma 2 (Linear combination lemma).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{S}\\subseteq\\mathds{F}^{d\\times d}</span> be any commutative sub-ring of <span class="math">d\\times d</span> matrices and <span class="math">m,n,k\\in\\mathbb{N}</span>. Let <span class="math">\\mathcal{L}:\\mathds{F}^{d\\times m}\\to\\mathbb{C}</span> be a <span class="math">\\mathcal{S}</span>-module homomorphism. Consider arbitrary <span class="math">\\rho_{1},\\ldots,\\rho_{k}\\in\\mathcal{S}</span>, <span class="math">Z_{1},\\ldots,Z_{k}\\in\\mathds{F}^{d\\times m}</span>, and <span class="math">V\\in\\mathds{K}^{m\\times n}</span>. For all <span class="math">i\\in[k]</span>, define</p>

    <p class="text-gray-300"><span class="math">c_{i}:=\\mathcal{L}(Z_{i})\\in\\mathbb{C}\\qquad\\text{and}\\qquad v_{i}:=Z_{i}V\\in\\mathds{K}^{d\\times n}</span></p>

    <p class="text-gray-300">Define</p>

    <p class="text-gray-300"><span class="math">c:=\\sum_{i\\in[k]}\\rho_{i}c_{i}\\in\\mathbb{C}\\qquad Z:=\\sum_{i\\in[k]}\\rho_{i}Z_{i}\\in\\mathds{F}^{d\\times m}\\qquad v:=\\sum_{i\\in[k]}\\rho_{i}v_{i}\\in\\mathds{K}^{d\\times n}</span></p>

    <p class="text-gray-300">Then, <span class="math">c=\\mathcal{L}(Z)</span> and <span class="math">v=ZV</span>.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">First, we will prove that <span class="math">c=\\mathcal{L}(Z)</span>. Since <span class="math">\\mathcal{L}</span> is a <span class="math">\\mathcal{S}</span>-module homomorphism, the following holds</p>

    <p class="text-gray-300"><span class="math">c=\\sum_{i\\in[k]}\\rho_{i}c_{i}=\\sum_{i\\in[k]}\\rho_{i}\\mathcal{L}(Z_{i})=\\mathcal{L}\\left(\\sum_{i\\in[k]}\\rho_{i}Z_{i}\\right)=\\mathcal{L}(Z).</span></p>

    <p class="text-gray-300">Now, we will prove that <span class="math">v=ZV</span>, as follows</p>

    <p class="text-gray-300"><span class="math">v=\\sum_{i\\in[k]}\\rho_{i}v_{i}=\\sum_{i\\in[k]}\\rho_{i}Z_{i}V=\\left(\\sum_{i\\in[k]}\\rho_{i}Z_{i}\\right)V=ZV</span></p>

    <p class="text-gray-300">This concludes our proof. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">The following corollary can be immediately obtained from Lemma 2 by defining <span class="math">V := M_j^\\intercal \\widehat{r}</span> for each <span class="math">j \\in [t]</span> and choosing <span class="math">\\mathcal{L}_x</span> as the trivial <span class="math">\\mathcal{S}</span>-homomorphism, which projects the first <span class="math">m_{\\mathrm{in}}</span> columns of <span class="math">Z</span>.</p>

    <p class="text-gray-300"><strong>Corollary 1.</strong> Let <span class="math">\\mathcal{S} \\subseteq \\mathbb{F}^{d \\times d}</span> be any commutative sub-ring of <span class="math">d \\times d</span> matrices and <span class="math">m, n, k \\in \\mathbb{N}</span>. Let <span class="math">\\mathcal{L}: \\mathbb{F}^{d \\times m} \\to \\mathbb{C}</span> and <span class="math">\\mathcal{L}_x: \\mathbb{F}^{d \\times m} \\to \\mathbb{F}^{d \\times m_{\\mathrm{in}}}</span> be <span class="math">\\mathcal{S}</span>-module homomorphisms. Consider arbitrary <span class="math">\\rho_1, \\ldots, \\rho_k \\in \\mathcal{S}</span>, <span class="math">Z_1, \\ldots, Z_k \\in \\mathbb{F}^{d \\times m}</span>, <span class="math">M_1, \\ldots, M_t \\in \\mathbb{F}^{n \\times m}</span>, <span class="math">r \\in \\mathbb{K}^{\\log n}</span>. Define</p>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in [k], c_i := \\mathcal{L}(Z_i) \\in \\mathbb{C}, X_i := \\mathcal{L}_x(Z_i) \\in \\mathbb{F}^{d \\times m_{\\mathrm{in}}}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in [k], j \\in [t], y_{(i,j)} := Z_i M_j^\\intercal \\widehat{r} \\in \\mathbb{K}^d</span></div>

    <p class="text-gray-300">Define</p>

    <div class="my-4 text-center"><span class="math-block">c := \\sum_{i \\in [k]} \\rho_i c_i \\in \\mathbb{C} \\quad X := \\sum_{i \\in [k]} \\rho_i X_i \\in \\mathbb{C}</span></div>

    <div class="my-4 text-center"><span class="math-block">Z := \\sum_{i \\in [k]} \\rho_i Z_i \\in \\mathbb{F}^{d \\times m} \\quad y_j := \\sum_{i \\in [k]} \\rho_i \\cdot y_{(i,j)} \\in \\mathbb{K}^d</span></div>

    <p class="text-gray-300">Then, <span class="math">c = \\mathcal{L}(Z)</span>, <span class="math">X = \\mathcal{L}_x(Z)</span>, and for all <span class="math">j \\in [t]</span>, <span class="math">y_j = Z M_j^\\intercal \\widehat{r}</span>.</p>

    <h2 id="sec-28" class="text-2xl font-bold">3.4 Challenge sets</h2>

    <p class="text-gray-300">As hinted earlier, when taking random linear combinations of lattice-based commitments, there are two concerns: (1) the random combination of the openings might be larger than the norm-bound required for binding; and (2) for extraction (i.e., knowledge soundness of the folding scheme), we need the differences between challenges to be invertible. We formalize these requirements by lifting strong sampling sets over cyclotomic rings <span class="math">R_q</span> (Definition 10) to our setting.</p>

    <p class="text-gray-300"><strong>Definition 14 (Strong sampling set).</strong> Let <span class="math">\\mathcal{S} \\subseteq \\mathbb{F}^{d \\times d}</span> be any commutative sub-ring of <span class="math">d \\times d</span> matrices. A strong sampling set for <span class="math">\\mathcal{S}</span> is a subset <span class="math">\\mathcal{C} \\subseteq \\mathcal{S}</span> such that for any two distinct elements <span class="math">\\rho, \\rho&#x27; \\in \\mathcal{C}</span>, <span class="math">(\\rho - \\rho&#x27;)</span> is invertible in the ring <span class="math">\\mathcal{S}</span>. Furthermore, we define the</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{expansion\\ factor}\\ of\\ \\mathcal{C} := \\max_{\\substack{v \\in \\mathbb{F}^{d} \\\\ \\rho \\in \\mathcal{C}}}\\frac{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho v\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}}{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lattice instantiation.</strong> Consider a strong sampling set <span class="math">\\mathcal{C}_R</span> over the cyclotomic ring <span class="math">R_q</span> (Definition 10). By definition, for any distinct elements <span class="math">a, b \\in \\mathcal{C}_R</span>, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{cf}(a - b) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; \\mathsf{b}_{\\mathrm{inv}}<span class="math">. Thus, by Theorem 1, </span>a - b<span class="math"> is invertible in </span>R_q<span class="math">. Since </span>R_q<span class="math"> and </span>\\mathcal{S}<span class="math"> (Definition 12) are isomorphic, we can define a strong sampling set </span>\\mathcal{C} := \\{\\mathsf{rot}(c) \\mid c \\in \\mathcal{C}_R\\}<span class="math"> to be the correspond set of rotation matrices. Consider arbitrary distinct elements </span>\\mathsf{rot}(a), \\mathsf{rot}(b) \\in \\mathcal{C}<span class="math">. By Theorem 7, we have </span>(\\mathsf{rot}(a) - \\mathsf{rot}(b))^{-1} = \\mathsf{rot}((a - b)^{-1})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Theorem 3 (Expansion factors).</strong> Let <span class="math">\\mathcal{C}_R</span> be a strong sampling set over the cyclotomic ring <span class="math">R_q</span> (Definition 10), and <span class="math">\\mathcal{C} := \\{\\mathsf{rot}(c) \\mid c \\in \\mathcal{C}_R\\}</span> be the corresponding set of rotation matrices. We denote the Euler totient function as <span class="math">\\phi</span>. We</p>

    <p class="text-gray-300">must have that the expansion factor (Definition 14) of <span class="math">\\mathcal{C}</span> is</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\max_{\\substack{v\\in \\mathbb{F}^{d}\\\\ \\rho \\in \\mathcal{C}}}\\frac{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho v\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}}{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}}\\leq 2\\cdot \\phi (\\eta)\\cdot \\max_{\\rho^{\\prime}\\in \\mathcal{C}_{R}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho^{\\prime}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. For brevity, we defer the proof to Appendix B.3.</p>

    <p class="text-gray-300">Looking ahead, our security analysis will require a different notion of binding called relaxed binding. Here, we lift the notion from prior works to the matrix setting, where <span class="math">\\mathcal{C}</span> will be a challenge set with which we take linear combinations of commitments.</p>

    <p class="text-gray-300">Definition 15 <span class="math">((d,m,B,\\mathcal{C})</span>-relaxed binding [9,10,14]). Let <span class="math">\\operatorname{com} := (\\text{Setup}, \\text{Commit})</span> be an arbitrary matrix commitment scheme (Definition 13) that is <span class="math">\\mathcal{S}</span>-homomorphic. Let <span class="math">\\mathcal{C}</span> be any subset of <span class="math">\\mathcal{S}</span>. The commitment scheme <span class="math">\\operatorname{com}</span> satisfies <span class="math">(d,m,B,\\mathcal{C})</span>-relaxed binding if for all expected polynomial time adversaries <span class="math">\\mathcal{A}</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr}\\left[ \\begin{array}{c c} \\Delta_1 \\cdot c = \\mathsf{Commit}(\\mathsf{pp}, Z_1) \\\\ \\wedge \\Delta_2 \\cdot c = \\mathsf{Commit}(\\mathsf{pp}, Z_2) \\\\ \\wedge \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}, \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_2\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; B, \\\\ \\wedge \\Delta_1 Z_2 \\neq \\Delta_2 Z_1 &amp; \\begin{array}{c} \\mathsf{pp} \\leftarrow \\mathsf{Setup}(1^{\\lambda}, m) \\\\ c \\in \\mathbb{C}, \\\\ \\Delta_1, \\Delta_2 \\in (\\mathcal{C} - \\mathcal{C}), \\\\ Z_1, Z_2 \\in \\mathbb{F}^{d \\times m} \\end{array} \\end{array} \\right] \\leftarrow \\mathcal{A}(\\mathsf{pp})</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><span class="math">\\leq \\epsilon_{\\mathrm{relax}}(\\mathsf{com}, d, m, B, \\mathcal{C}) \\leq \\mathsf{negl}(\\lambda)</span>. We refer to a tuple of elements <span class="math">(c, \\Delta_1, \\Delta_2, Z_1, Z_2)</span> which satisfies the conditions in the probability as an <span class="math">(d, m, B, \\mathcal{C})</span>-relaxed binding collision.</p>

    <p class="text-gray-300">It turns out that regular binding implies relaxed binding. Here, we lift the corresponding lemmas from prior work to our setting.</p>

    <p class="text-gray-300">Lemma 3 (Binding implies relaxed binding [9,10,14]). Let <span class="math">\\operatorname{com} := (\\text{Setup}, \\text{Commit})</span> be an arbitrary matrix commitment scheme (Definition 13) that is <span class="math">\\mathcal{S}</span>-homomorphic and <span class="math">\\mathcal{C} \\subseteq \\mathcal{S}</span> be a strong-sampling set with expansion factor <span class="math">T</span> (Definition 14). If <span class="math">\\operatorname{com}</span> is <span class="math">(d, m, 2TB)</span>-binding (Definition 13), then <span class="math">\\operatorname{com}</span> is <span class="math">(d, m, B, \\mathcal{C})</span>-relaxed binding (Definition 15).</p>

    <p class="text-gray-300">Proof. For brevity, we defer the proof to Appendix B.2.</p>

    <h2 id="sec-29" class="text-2xl font-bold">4 Neo's folding scheme for CCS</h2>

    <p class="text-gray-300">This section describes Neo's folding scheme for CCS. At a high level, we leverage the commitment scheme we provided in Section 3 in conjunction with HyperNova's folding scheme for CCS [42]. To make this sketch work, we first lift the CCS relation [59] to the matrix setting, and provide three reductions. These reductions can also be viewed as adapting the ideas in LatticeFold [14] to the prime field setting in a way that natively supports "small" primes. The security analysis of some of our reductions will require new security definitions and a new composition theorem for reductions, which we provide in Section 5. By composing the three reductions, we obtain a lattice-based folding scheme for CCS.</p>

    <p class="text-gray-300">24</p>

    <p class="text-gray-300">The CCS structure contains the CCS constraint matrices <span class="math">\\{M_j\\}_{j\\in [t]}</span> and a constraint polynomial <span class="math">f</span>.</p>

    <p class="text-gray-300"><strong>Definition 16 (Structure).</strong> Let <span class="math">m, n, u, t \\in \\mathbb{N}</span>. We define a <strong>structure</strong> as a collection of elements</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{s} := \\left\\{ \\left\\{ M_j \\in \\mathbb{F}^{n \\times m} \\right\\}_{j \\in [t]}, \\; f \\in \\mathbb{F}^{&amp;lt; u}[X_1, \\ldots, X_t] \\right\\},</span></div>

    <p class="text-gray-300">which consists of matrices and a degree-<span class="math">u</span> polynomial.</p>

    <p class="text-gray-300">Below, we provide an analogue of the CCS relation updated to match our low norm requirement (which is enforced by decomposition) and a matrix commitment scheme (more generally, any <span class="math">\\mathcal{S}</span>-module homomorphism).</p>

    <p class="text-gray-300"><strong>Definition 17 (Matrix constraint system relation).</strong> Let <span class="math">\\mathcal{L}:\\mathbb{F}^{d\\times m}\\to \\mathbb{C}</span> be a <span class="math">\\mathcal{S}</span>-module homomorphism. Let <span class="math">\\mathsf{s}</span> be a structured as defined in Definition 17. We define the <strong>Matrix constraint system relation</strong> as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{MCS}(b, \\mathcal{L}) := \\left\\{ \\begin{array}{l l} &amp;amp; \\text{For } z := x \\mid \\mid w \\text{ and} \\\\ &amp;amp; Z := \\mathsf{Decomp}_b(z), \\\\ \\Big( \\mathsf{s}; \\; (c \\in \\mathbb{C}, \\; x \\in \\mathbb{F}^{m_{\\mathrm{in}}}); \\; w \\in \\mathbb{F}^{m - m_{\\mathrm{in}}} \\Big) \\; : \\; &amp;amp; c = \\mathcal{L}(Z) \\\\ &amp;amp; f \\left( \\widetilde{M_1 z}, \\ldots, \\widetilde{M_t z} \\right) \\in \\mathsf{ZS}_n \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">HyperNova's folding scheme [42] can be viewed as providing a reduction from CCS to linearized CCS, a variant of CCS that they define. In a nutshell, linearized CCS amounts to the multilinear evaluations of <span class="math">(M_1 z, \\ldots, M_t z)</span>. Here, we define the analogue of linearized CCS in our setting, where we get the partial evaluation instead. Ultimately, we fold these partial evaluations using random linear combinations as hinted in our linear combination lemma (Corollary 1).</p>

    <p class="text-gray-300"><strong>Definition 18 (Matrix evaluation relation).</strong> Let <span class="math">\\mathcal{L}:\\mathbb{F}^{d\\times m}\\to \\mathbb{C}</span> be a <span class="math">\\mathcal{S}</span>-module homomorphism. Let <span class="math">\\mathcal{L}_x:\\mathbb{F}^{d\\times m}\\to \\mathbb{F}^{d\\times m_{\\mathrm{in}}}</span> be the trivial <span class="math">\\mathcal{S}</span>-module homomorphism which projects the first <span class="math">m_{\\mathrm{in}}</span> columns. Let <span class="math">\\mathsf{s}</span> be a structure as defined in Definition 17.</p>

    <p class="text-gray-300">$$ \\mathsf{ME}(b, \\mathcal{L}) := \\left\\{ \\begin{array}{l l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Bigg( \\mathsf{s}; \\; \\begin{pmatrix} c \\in \\mathbb{C}, \\\\ X \\in \\mathbb{F}^{d \\times m_{\\mathrm{in}}}, \\\\ r \\in \\mathbb{K}^{\\log n}, \\\\ \\{y_j \\in \\mathbb{K}^d\\}_{j \\in [t]} \\end{pmatrix}; \\; Z \\in \\mathbb{F}^{d \\times m} \\Bigg) \\; : \\; \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_\\infty &lt; b \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">&amp; \\forall j \\in [t], \\; y_j = Z M_j^\\intercal \\widehat{r} \\end{array} \\right. $$</p>

    <p class="text-gray-300">The condition <span class="math">y_j = Z M_j^\\intercal \\widehat{r}</span> is equivalently expressed as <span class="math">\\widetilde{y}_j = \\widetilde{Z M_j^\\intercal} \\big( X_{[1, \\log d]}, r \\big)</span>.</p>

    <p class="text-gray-300">In this section, we provide an overview of three reductions. By sequentially composing the three, we obtain a lattice-based folding scheme for CCS.</p>

    <p class="text-gray-300">(1) CCS reduction <span class="math">\\Pi_{\\mathsf{CCS}}</span>. This reduction takes as input <span class="math">\\mathsf{ME}(b,\\mathcal{L})^{k}\\times\\mathsf{MCS}(b,\\mathcal{L})</span>, which contains <span class="math">k</span> <span class="math">b</span>-norm partial evaluation claims and one CCS claim, and reduces to <span class="math">k+1</span> <span class="math">b</span>-norm partial evaluation claims <span class="math">\\mathsf{ME}(b,\\mathcal{L})^{k+1}</span>. This reduction can be viewed as the lattice analogue of the CCS to linearized CCS reduction in HyperNova <em>[42]</em>, which reduces CCS claims to evaluation claims by invoking the sum-check protocol <em>[46]</em>.</p>

    <p class="text-gray-300">(2) Random linear combination reduction <span class="math">\\Pi_{\\mathsf{RLC}}</span>. This reduction takes as input <span class="math">k+1</span> <span class="math">b</span>-norm partial evaluation claims <span class="math">\\mathsf{ME}(b,\\mathcal{L})^{k+1}</span>, and reduces to a single <span class="math">(B=b^{k})</span>-norm partial evaluation claim <span class="math">\\mathsf{ME}(B,\\mathcal{L})</span>. This reduction simply takes linear combinations of the input commitments and claims using challenges from a strong sampling set (Definition 14).</p>

    <p class="text-gray-300">(3) Decomposition reduction <span class="math">\\Pi_{\\mathsf{DEC}}</span>. This reduction takes as input a single <span class="math">B</span>-norm partial evaluation claim <span class="math">\\mathsf{ME}(B,\\mathcal{L})</span> and reduces to <span class="math">k</span> <span class="math">b</span>-norm partial evaluation claims <span class="math">\\mathsf{ME}(b,\\mathcal{L})^{k}</span>. Informally, the prover effectively sends <span class="math">k</span> commitments which represent the decomposition of the original <span class="math">B</span> partial evaluation claim. This reduction does not use any randomness from the verifier, and is required to keep the norm of the commitments lower than the binding requirement for the commitment scheme.</p>

    <p class="text-gray-300">In terms of security, the composition <span class="math">\\Pi_{\\mathsf{RLC}}\\circ\\Pi_{\\mathsf{CCS}}</span> is a reduction of knowledge from <span class="math">\\mathsf{ME}(b,\\mathcal{L})^{k}\\times\\mathsf{MCS}(b,\\mathcal{L})</span> to <span class="math">\\mathsf{ME}(B,\\mathcal{L})</span>, and <span class="math">\\Pi_{\\mathsf{DEC}}</span> alone is a reduction of knowledge from <span class="math">\\mathsf{ME}(B,\\mathcal{L})</span> to <span class="math">\\mathsf{ME}(b,\\mathcal{L})^{k}</span>. All together, the composition <span class="math">\\Pi:=\\Pi_{\\mathsf{DEC}}\\circ\\Pi_{\\mathsf{RLC}}\\circ\\Pi_{\\mathsf{CCS}}</span> is a reduction of knowledge from <span class="math">\\mathsf{ME}(b,\\mathcal{L})^{k}\\times\\mathsf{MCS}(b,\\mathcal{L})</span> to <span class="math">\\mathsf{ME}(b,\\mathcal{L})^{k}</span>. This allows for the continual folding of <span class="math">\\mathsf{MCS}(b,\\mathcal{L})</span> claims. Thus, we obtain a folding scheme for CCS.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">4.3 Reduction parameters</h3>

    <p class="text-gray-300">Here, we define global parameters for all the three reductions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathcal{S}\\subseteq\\mathbb{F}^{d\\times d}</span> be a commutative subring of <span class="math">d\\times d</span> matrices (Definition 12) and <span class="math">m,n,b,k,B=b^{k}&lt;q/2\\in\\mathbb{N}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Let <span class="math">\\mathcal{C}\\subseteq\\mathcal{S}</span> be a strong sampling set (Definition 14) with expansion factor <span class="math">T</span> such that <span class="math">(k+1)T(b-1)&lt;B</span> and $1/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathsf{negl}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathsf{com}:=\\mathsf{(Setup,Commit)}</span> be an commitment scheme (Definition 13), which is <span class="math">\\mathcal{S}</span>-homomorphic and <span class="math">(d,m,2B,\\mathcal{C})</span>-relaxed binding (Definition 15). For <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Setup}(1^{\\lambda},d,m)</span>, define <span class="math">\\mathcal{L}:=\\mathsf{Commit}(\\mathsf{pp},\\,\\cdot\\,):\\mathbb{F}^{d\\times m}\\to\\mathbb{C}</span>, which is a <span class="math">\\mathcal{S}</span>-module homomorphism by definition.</li>

      <li>Let <span class="math">\\mathcal{L}_{x}:\\mathbb{F}^{d\\times m}\\to\\mathbb{F}^{d\\times m_{\\mathsf{in}}}</span> be the trivial <span class="math">\\mathcal{S}</span>-module homomorphism that projects the first <span class="math">m_{\\mathsf{in}}</span> columns.</li>

      <li>Let <span class="math">\\mathsf{s}</span> denote a structure as defined in Definition 17.</li>

    </ul>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">4.4 CCS Reduction – <span class="math">\\Pi_{\\mathsf{CCS}}</span></h3>

    <p class="text-gray-300">For notational simplicity, we describe the protocol as a reduction from <span class="math">\\mathsf{MCS}(b,\\mathcal{L})\\times\\mathsf{ME}(b,\\mathcal{L})^{k-1}</span> to <span class="math">\\mathsf{ME}(b,\\mathcal{L})^{k}</span> instead of <span class="math">\\mathsf{MCS}(b,\\mathcal{L})\\times\\mathsf{ME}(b,\\mathcal{L})^{k}</span> to <span class="math">\\mathsf{ME}(b,\\mathcal{L})^{k+1}</span>. This only affects indexing.</p>

    <p class="text-gray-300">Overview. In this reduction, we first construct a multivariate polynomial  <span class="math">Q(X_{1}, \\ldots, X_{\\log(dn)})</span>  such that we can encode the CCS constraints (encoded as the polynomial  <span class="math">\\mathsf{F}</span> ), norm constraints (encoded as polynomials  <span class="math">\\mathsf{NC}_i</span>  for  <span class="math">i \\in [k]</span> ), and evaluation claims  <span class="math">Z_{i}M_{j}^{\\intercal}\\widehat{r}</span>  (encoded as polynomials  <span class="math">\\mathsf{Eval}_{i,j}</span>  for  <span class="math">i \\in [k]</span> ,  <span class="math">j \\in [t]</span> ) to a claimed sum of a polynomial  <span class="math">Q(X_{1}, \\ldots, X_{\\log(dn)})</span>  over the Boolean hypercube  <span class="math">\\{0, 1\\}^{\\log(dn)}</span> . Then, we rely on the classic sum-check protocol [46] to reduce this sum claim to a single evaluation claim for  <span class="math">v \\stackrel{?}{=} Q((\\alpha&#x27;, r&#x27;))</span> , which can be derived by the partial evaluations of each sub-component polynomial on  <span class="math">r&#x27;</span> . This leaves  <span class="math">k</span>  new partial evaluation claims over  <span class="math">r&#x27;</span> .</p>

    <p class="text-gray-300">Without loss of generality, assume that  <span class="math">m = n</span>  and  <span class="math">n, d \\cdot n</span>  are both powers of two and that  <span class="math">M_1 = I_n</span>  is the identity matrix. By choosing  <span class="math">M_1 = I_n</span> , we simplify our notation as folding  <span class="math">M_1z</span>  evaluations is equivalent to folding  <span class="math">z</span>  evaluations.</p>

    <p class="text-gray-300">Parameters: Refer to Section 4.3.</p>

    <p class="text-gray-300">Input:  <span class="math">\\left(s; (c_{1} \\in \\mathbb{C}, x_{1} \\in \\mathbb{F}^{m_{\\mathrm{in}}}); w_{1} \\in \\mathbb{F}^{m - m_{\\mathrm{in}}}\\right)</span> ,</p>

    <p class="text-gray-300"><span class="math">\\left(\\mathsf{s}; c_i \\in \\mathbb{C}, X_i \\in \\mathbb{F}^{d \\times m_{\\mathrm{in}}}, r \\in \\mathbb{K}^{\\log n}, \\{y_{(i,j)} \\in \\mathbb{K}^d\\}_{j \\in [t]}; Z_i \\in \\mathbb{F}^{d \\times m}\\right)_{i=2}^k</span></p>

    <p class="text-gray-300"><span class="math">\\in \\mathsf{MCS}(b,\\mathcal{L})\\times \\mathsf{ME}(b,\\mathcal{L})^{k - 1}</span></p>

    <p class="text-gray-300">Output:  <span class="math">\\left(s; c_i \\in \\mathbb{C}, X_i \\in \\mathbb{F}^{d \\times m_{\\mathrm{in}}}, r&#x27; \\in \\mathbb{K}^{\\log n}, \\{y_{(i,j)}&#x27; \\in \\mathbb{K}^d\\}_{j \\in [t]}; Z_i \\in \\mathbb{F}^{d \\times m}\\right)_{i \\in [k]}</span></p>

    <p class="text-gray-300"><span class="math">\\in \\mathsf{ME}(b,\\mathcal{L})^k</span></p>

    <p class="text-gray-300">Setup  <span class="math">\\mathcal{G}(1^{\\lambda},\\mathsf{sz})\\to \\mathsf{pp}</span>  : Output  <span class="math">\\mathsf{pp}\\gets \\mathsf{Setup}(1^{\\lambda},\\mathsf{sz})</span>  , which defines  <span class="math">\\mathcal{L}:= \\mathrm{Commit}</span> <span class="math">(\\mathsf{pp},\\cdot):\\mathbb{F}^{d\\times m}\\to \\mathbb{C}</span></p>

    <p class="text-gray-300">Encoder  <span class="math">\\mathcal{K}(\\mathsf{pp},\\mathsf{s})\\to (\\mathsf{pk},\\mathsf{vk})</span>  : Output  <span class="math">((\\mathsf{pp},\\mathsf{s}),\\bot)</span></p>

    <p class="text-gray-300">Reduction  <span class="math">\\langle \\mathcal{P},\\mathcal{V}\\rangle ((\\mathsf{pk},\\mathsf{vk}),u_1,w_1)\\to (u_2;w_2)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> : Send challenges  <span class="math">\\alpha \\stackrel{\\S}{\\leftarrow} \\mathbb{K}^{\\log d}</span> ,  <span class="math">\\beta \\stackrel{\\S}{\\leftarrow} \\mathbb{K}^{\\log(dn)}</span> ,  <span class="math">\\gamma \\stackrel{\\S}{\\leftarrow} \\mathbb{K}</span>  to  <span class="math">\\mathcal{P}</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2.  <span class="math">\\mathcal{V} \\leftrightarrow \\mathcal{P}</span> : Define  $z_{1} \\coloneqq x_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w_{1}<span class="math"> ,  </span>X_{1} \\coloneqq \\operatorname{Decomp}_{b}(x_{1})<span class="math"> ,  </span>Z_{1} \\coloneqq \\operatorname{Decomp}_{b}(z_{1})<span class="math"> , for all  </span>i \\in [k], j \\in [t]<span class="math"> ,  </span>M_{(i,j)} \\coloneqq Z_{i}M_{j}^{\\intercal}$ , and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{F}\\left(X_{[1,\\log n]}\\right)\\coloneqq f\\left(\\widehat{M_1z_1},\\ldots ,\\widehat{M_tz_1}\\right)</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{NC}_i\\left(X_{[1,\\log (dn)]}\\right)\\coloneqq \\prod_{j = -b - 1}^{b - 1}\\left(\\widetilde{Z_i} (\\pmb {X}) - j\\right)\\qquad \\forall i\\in [k]</span></p>

    <p class="text-gray-300"><span class="math">\\operatorname{Eval}_{(i,j)}\\left(X_{[1,\\log (dn)]}\\right)\\coloneqq \\operatorname {eq}\\bigl (\\boldsymbol {X},(\\alpha ,r)\\bigr)\\cdot \\widehat{M}_{(i,j)}(\\boldsymbol {X})\\qquad \\forall i\\in [2,k],\\forall j\\in [t]</span></p>

    <div class="my-4 text-center"><span class="math-block">Q \\left(X _ {[ 1, \\log (d n) ]}\\right) := \\operatorname {e q} (\\boldsymbol {X}, \\beta) \\left(\\mathrm {F} \\left(X _ {[ \\log (d) + 1, \\log (d n) ]}\\right) + \\sum_ {i \\in [ k ]} \\gamma^ {i} \\mathrm {N C} _ {i} (\\boldsymbol {X})\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\gamma^ {k} \\sum_ {j = 1, i = 2} ^ {t, k} \\gamma^ {i + (j - 1) k - 1} \\cdot \\operatorname {E v a l} _ {(i, j)} (\\boldsymbol {X})</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Define claimed sum of  <span class="math">Q</span>  over  <span class="math">\\{0,1\\}^{\\log (dn)}</span>  as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathrm {T} := \\gamma^ {k} \\sum_ {j = 1, i = 2} ^ {t, k} \\gamma^ {i + (j - 1) k - 1} \\cdot \\widetilde {y} _ {(i, j)} (\\alpha)</span></div>

    <p class="text-gray-300">Perform SumCheck (T;  <span class="math">Q</span> ) which reduces to evaluation claim  <span class="math">v \\stackrel{?}{=} Q(\\alpha&#x27;, r&#x27;)</span>  for  <span class="math">(\\alpha&#x27;, r&#x27;) \\in \\mathbb{F}^{\\log d} \\times \\mathbb{F}^{\\log n}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> : For all  <span class="math">i\\in [k]</span>  and  <span class="math">j\\in [t]</span> , send  <span class="math">y_{(i,j)}&#x27; := Z_iM_j^\\top \\widehat{r}&#x27; \\in \\mathbb{K}^d</span>  (i.e.  <span class="math">\\widetilde{y}_{(i,j)}&#x27; = \\widetilde{M}_{(i,j)}\\big(X_{[1,\\log d]},r&#x27;\\big)</span> ).</li>

      <li><span class="math">\\mathcal{V}</span> : Check the evaluation claim  <span class="math">v \\stackrel{?}{=} Q(\\alpha&#x27;, r&#x27;)</span>  as follows,</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\forall j \\in [ t ], m _ {j} := \\sum_ {\\ell \\in [ d ]} b ^ {\\ell - 1} \\cdot y _ {(1, j), \\ell} ^ {\\prime}</span></div>

    <div class="my-4 text-center"><span class="math-block">F := f (m _ {1}, \\dots , m _ {t}), \\quad \\forall i \\in [ k ], N _ {i} := \\prod_ {j = - b - 1} ^ {b - 1} \\left(\\widetilde {y} _ {(i, 1)} ^ {\\prime} (\\alpha^ {\\prime}) - j\\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in [ 2, k ], \\forall j \\in [ t ], E _ {(i, j)} := \\operatorname {e q} \\left(\\left(\\alpha^ {\\prime}, r ^ {\\prime}\\right), (\\alpha , r)\\right) \\cdot \\widetilde {y} _ {(i, j)} ^ {\\prime} \\left(\\alpha^ {\\prime}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">v \\stackrel {?} {=} \\operatorname {e q} \\left(\\left(\\alpha^ {\\prime}, r ^ {\\prime}\\right), \\beta\\right) \\cdot \\left(F + \\sum_ {i \\in [ k ]} \\gamma^ {i} \\cdot N _ {i}\\right) + \\gamma^ {k} \\sum_ {j = 1, i = 2} ^ {t, k} \\gamma^ {i + (j - 1) k - 1} \\cdot E _ {(i, j)}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">\\left(\\mathbf{s};c_i,X_i,r&#x27;,\\{y_{(i,j)}&#x27;_{j\\in [t]};Z_i\\right)_{i\\in [k]}</span></li>

    </ol>

    <p class="text-gray-300">Lemma 4. The CCS reduction  <span class="math">\\Pi_{\\mathsf{CCS}}</span>  is a complete and public coin reduction from  <span class="math">\\mathsf{MCS}(b,\\mathcal{L})\\times \\mathsf{ME}(b,\\mathcal{L})^{k - 1}</span>  to  <span class="math">\\mathsf{ME}(b,\\mathcal{L})^k</span></p>

    <p class="text-gray-300">Proof. For brevity, we defer the proof to Appendix B.4.</p>

    <p class="text-gray-300">Security of  <span class="math">\\Pi_{\\mathsf{CCS}}</span> . We defer the formal security analysis of the reduction  <span class="math">\\Pi_{\\mathsf{CCS}}</span>  to Section 5, because the reduction by itself is not a reduction of knowledge (Definition 1). This is because  <span class="math">\\Pi_{\\mathsf{CCS}}</span>  is not directly knowledge sound (against arbitrary adversaries). Instead, in Section 5, we introduce new security properties which  <span class="math">\\Pi_{\\mathsf{CCS}}</span>  satisfies. In particular,  <span class="math">\\Pi_{\\mathsf{CCS}}</span>  is knowledge sound against restricted adversaries  <span class="math">(\\mathcal{A},\\mathcal{P}^{<em>})</span>  which can only output the same output witnesses  <span class="math">w_{2}</span>  with all but negligible probability. A trivial property of  <span class="math">\\Pi_{\\mathsf{CCS}}</span>  is that it always outputs the same commitments from the instance regardless of what the potentially malicious prover  <span class="math">\\mathcal{P}^</em></span>  does. This property will help with our composition with  <span class="math">\\Pi_{\\mathsf{RLC}}</span> . Ultimately, we prove that the composition  <span class="math">\\Pi_{\\mathsf{RLC}}\\circ \\Pi_{\\mathsf{CCS}}</span>  is a ROK.</p>

    <h2 id="sec-35" class="text-2xl font-bold">4.5 Random linear combination reduction -  <span class="math">\\Pi_{\\mathsf{RLC}}</span></h2>

    <p class="text-gray-300">Overview. This reduction takes a random linear combination of the inputs using challenges from a strong sampling set  <span class="math">\\mathcal{C}</span>  (Definition 14).</p>

    <p class="text-gray-300">|  Random linear combination reduction ΠRLC  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  Parameters: Refer to Section 4.3.  |</p>

    <p class="text-gray-300">|  Input: (s; ci ∈ C, Xi ∈ Fd×min, r ∈ Klogn, {y(i,j) ∈ Kd}j∈[t]; Zi ∈ Fd×m)i∈[k+1] ∈ ME(b, L)k+1  |</p>

    <p class="text-gray-300">|  Output: (s; c ∈ C, X ∈ Fd×min, r ∈ Klogn, {yj ∈ Kd}j∈[t]; Z ∈ Fd×m) ∈ ME(B, L)  |</p>

    <p class="text-gray-300">|  Setup G(1λ, sz) → pp: Output pp ← Setup(1λ, sz), which defines L := Commit(pp, ·): Fd×m → C.  |</p>

    <p class="text-gray-300">|  Encoder K(pp, s) → (pk, vk): Output ((pp, s), ⊥).  |</p>

    <p class="text-gray-300">|  Reduction ⟨P, V⟩((pk, vk), u1, w1) → (u2; w2):  |</p>

    <p class="text-gray-300">|  1. V: Sample ρ1, ..., ρk+1 ← C and compute:  |</p>

    <p class="text-gray-300">|  c ← ∑i∈[k+1] ρi ci, X ← ∑i∈[k+1] ρi Xi, and yj ← ∑i∈[k+1] ρi · y(i,j)  |</p>

    <p class="text-gray-300">|  Send ρ1, ..., ρk+1 to P.  |</p>

    <p class="text-gray-300">|  2. P: Compute Z ← ∑i∈[k+1] ρi Zi.  |</p>

    <p class="text-gray-300">|  3. Output (s; c, X, r, {yj}j∈[t]; Z).  |</p>

    <p class="text-gray-300">Lemma 5. The random linear combination protocol  <span class="math">\\Pi_{\\mathsf{RLC}}</span>  is a complete and public coin reduction from  <span class="math">\\mathsf{ME}(b,\\mathcal{L})^{k + 1}</span>  to  <span class="math">\\mathsf{ME}(B,\\mathcal{L})</span> .</p>

    <p class="text-gray-300">Proof. For brevity, we defer the proof to Appendix B.5.</p>

    <p class="text-gray-300">Security of  <span class="math">\\Pi_{\\mathsf{RLC}}</span> . As with  <span class="math">\\Pi_{\\mathsf{CCS}}</span> , the reduction  <span class="math">\\Pi_{\\mathsf{RLC}}</span>  is not knowledge-sound against arbitrary adversaries  <span class="math">(\\mathcal{A},\\mathcal{P}^{*})</span> . However, it satisfies a relaxed notion of knowledge-soundness for which the extractor is able to extract witnesses  <span class="math">(Z_{i})_{i\\in [k + 1]}</span>  such that  <span class="math">(\\mathsf{s},c_i,X_i,\\ldots ;Z_i)_{i\\in [k + 1]}</span>  belongs to  <span class="math">\\mathsf{ME}(q / 2,\\mathcal{L})^{k + 1}</span>  (which has a trivial norm bound) instead of  <span class="math">\\mathsf{ME}(b,\\mathcal{L})^{k + 1}</span> , which is the original input relation. Furthermore, this extractor can only output the same witnesses  <span class="math">(Z_{i})_{i}</span>  with all but negligible probability, or else we could use the extractor to construct a  <span class="math">(d,m,2B,\\mathcal{C})</span> -relaxed binding (Definition 15) adversary which succeeds with nonnegligible probability. These properties are formalized in Section 5. In particular, using this extractor, we will be able to construct a restricted adversary for  <span class="math">\\Pi_{\\mathsf{CCS}}</span> .</p>

    <p class="text-gray-300">Overview. Our final reduction aims to reduce the norm of claims from  <span class="math">B = b^{k}</span>  to  <span class="math">b</span> , which will allow us to continually fold CCS claims without increasing the norm of the openings  <span class="math">(Z_{i})_{i}</span>  to the commitments. Otherwise, the norm would eventually exceed the norm-bound requirement of the commitment scheme.</p>

    <p class="text-gray-300">This reduction works by having the prover do a bit-decomposition of the witness  <span class="math">Z</span>  into  <span class="math">k</span>  lower norm witnesses  <span class="math">(Z_{i})_{i}</span> . Then, the prover sends over new commitments and partial evaluation claims for this new witnesses. The verifier checks these new commitments and evaluations with respect to the original input commitment and evaluation.</p>

    <p class="text-gray-300">|  Decomposition reduction ΠDEC  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  Parameters: Refer to Section 4.3.  |</p>

    <p class="text-gray-300">|  Input: (s; c ∈ C, X ∈ Fd×min, r ∈ Klog n, {yj ∈ Kd}j∈[t]; Z ∈ Fd×m) ∈ ME(B, L)  |</p>

    <p class="text-gray-300">|  Output: (s; ci ∈ C, Xi ∈ Fd×min, r ∈ Klog n, {y(i,j) ∈ Kd}j∈[t]; Zi ∈ Fd×m)i∈[k] ∈ ME(b, L)k  |</p>

    <p class="text-gray-300">|  Setup G(1λ, sz) → pp: Output pp ← Setup(1λ, sz), which defines L := Commit(pp, ·): Fd×m → C.  |</p>

    <p class="text-gray-300">|  Encoder K(pp, s) → (pk, vk): Output ((pp, s), ⊥).  |</p>

    <p class="text-gray-300">|  Reduction ⟨P, V⟩((pk, vk), u1, w1) → (u2; w2):  |</p>

    <p class="text-gray-300">|  1. P: Compute (ci, {y(i,j)}j∈[t]; Zi)i∈[k] as follows,  |</p>

    <p class="text-gray-300">|  (Z1, ..., Zk) ← splitb(Z), ci ← L(Zi), y(i,j) ← ZiMjT r ∈ Kd  |</p>

    <p class="text-gray-300">|  Send (ci, {y(i,j)}j∈[t])i∈[k] to V.  |</p>

    <p class="text-gray-300">|  2. V: Compute (X1, ..., Xk) ← splitb(X). Check for all j ∈ [t],  |</p>

    <p class="text-gray-300">|  c = ∫i=1k b i-1 · ci and yj = ∫i=1k b i-1 · y(i,j)  |</p>

    <p class="text-gray-300">|  3. Output (s; ci, Xi, r, {y(i,j)}j∈[t]; Zi)i∈[k]  |</p>

    <p class="text-gray-300">Unlike  <span class="math">\\Pi_{\\mathsf{CCS}}</span>  and  <span class="math">\\Pi_{\\mathsf{RLC}}</span> , the reduction  <span class="math">\\Pi_{\\mathsf{DEC}}</span>  is directly a reduction of knowledge.</p>

    <p class="text-gray-300">Theorem 4. The reduction  <span class="math">\\Pi_{\\mathsf{DEC}}</span>  is a reduction of knowledge (Definition 1) from  <span class="math">\\mathsf{ME}(B,\\mathcal{L})</span>  to  <span class="math">\\mathsf{ME}(b,\\mathcal{L})^k</span> .</p>

    <p class="text-gray-300">Proof. For brevity, we defer the proof to Appendix B.6.</p>

    <p class="text-gray-300">This section provides a formal security analysis of the  <span class="math">\\Pi_{\\mathsf{CCS}}</span>  and  <span class="math">\\Pi_{\\mathsf{RLC}}</span>  reductions. In particular, we design new security properties that a reduction can satisfy, and prove that  <span class="math">\\Pi_{\\mathsf{CCS}}</span>  and  <span class="math">\\Pi_{\\mathsf{RLC}}</span>  satisfy these properties. Finally, we show that the composition  <span class="math">\\Pi_{\\mathsf{RLC}} \\circ \\Pi_{\\mathsf{CCS}}</span>  is a reduction of knowledge by using a new general composition theorem for reductions (Theorem 5).</p>

    <p class="text-gray-300">5.1 New properties</p>

    <p class="text-gray-300">We begin with an informal description of each of our new properties, and then provide their formal definitions (Definition 19)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\phi</span>-restricted. Regardless of the adversary, the evaluation of <span class="math">\\phi</span> on the output instance <span class="math">u_{2}</span> remains the same (with all but negligible probability). For example, in <span class="math">\\Pi_{\\sf CCS}</span>, the reduction always preserves the instance commitments <span class="math">(c_{i})_{i}</span>.</li>

      <li><span class="math">\\phi</span>-relaxed knowledge soundness. Nearly identical to knowledge soundness, but with two major differences: (1) the extractor only succeeds in extracting witnesses that satisfy a relaxed relation (a superset of the original relation); and (2) if the adversary is restricted in its choice of input instances by <span class="math">\\phi</span>, then the extractor can only output a single witness with all but negligible probability. For example, in <span class="math">\\Pi_{\\sf RLC}</span>, the extractor will only be able to extract witnesses with potentially large norm; furthermore, if the commitments in the instance remain the same across executions, then the extractor can only output at most one satisfying witness; otherwise, the extractor could break the relaxed binding of the commitment scheme.</li>

      <li>restricted knowledge soundness. Nearly identical to knowledge soundness, except that the extraction only succeeds against restricted adversaries. In particular, the potentially malicious prover <span class="math">\\mathcal{P}^{<em>}</span> is restricted to outputing the exact same witness <span class="math">w_{2}</span> with all but negligible probability. For example, in <span class="math">\\Pi_{\\sf CCS}</span>, the prover <span class="math">\\mathcal{P}^{</em>}</span> would be restricted to only one possible set of openings <span class="math">(Z_{i})_{i}</span> for the output commitments.</li>

    </ul>

    <h6 id="sec-38" class="text-base font-medium mt-4">Theorem 5 (Composition Theorem).</h6>

    <p class="text-gray-300">Let <span class="math">\\phi</span> be an arbitrary function. Consider relations <span class="math">\\mathcal{R}_{1}</span> and <span class="math">\\mathcal{R}_{2}\\subseteq\\mathcal{R}_{2}^{\\prime}</span> and <span class="math">\\mathcal{R}_{3}</span>. Given a reduction (Definition 1) <span class="math">\\Pi_{1}:=(\\mathcal{G},\\mathcal{K},\\mathcal{P}_{1},\\mathcal{V}_{1})</span> from <span class="math">\\mathcal{R}_{1}</span> to <span class="math">\\mathcal{R}_{2}</span> (<span class="math">\\mathcal{R}_{2}^{\\prime}</span>) such that <span class="math">\\Pi_{1}</span> is (1) complete and public-coin, (2) <span class="math">\\phi</span>-restricted, (3) and has restricted knowledge soundness and a reduction <span class="math">\\Pi_{2}:=(\\mathcal{G},\\mathcal{K},\\mathcal{P}_{2},\\mathcal{V}_{2})</span> from <span class="math">\\mathcal{R}_{2}</span> (<span class="math">\\mathcal{R}_{2}^{\\prime}</span>) to <span class="math">\\mathcal{R}_{3}</span> such that <span class="math">\\Pi_{2}</span> is (1) complete and public-coin (2) and has <span class="math">\\phi</span>-relaxed knowledge soundness then the composition <span class="math">\\Pi:=\\Pi_{2}\\circ\\Pi_{1}</span> is knowledge sound.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For brevity, we defer the proof to Appendix B.10. ∎</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Corollary 2.</h6>

    <p class="text-gray-300">The composition <span class="math">\\Pi:=\\Pi_{\\sf RLC}\\circ\\Pi_{\\sf CCS}</span> is a reduction of knowledge (Definition 1) from <span class="math">\\mathsf{ME}(b,\\mathcal{L})^{k}\\times\\mathsf{MCS}(b,\\mathcal{L})</span> to <span class="math">\\mathsf{ME}(B,\\mathcal{L})</span>.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Follows directly from <span class="math">\\Pi_{\\sf CCS}</span>’s completeness and public-coin (Lemma 4), <span class="math">\\Pi_{\\sf RLC}</span>’s completeness and public-coin (Lemma 5), the new composition theorem (Theorem 5), <span class="math">\\Pi_{\\sf CCS}</span>’s <span class="math">\\phi</span>-restricted (Lemma 6), <span class="math">\\Pi_{\\sf CCS}</span>’s restricted knowledge soundness (Lemma 7), and <span class="math">\\Pi_{\\sf RLC}</span>’s <span class="math">\\phi</span>-relaxed knowledge soundness (Lemma 8). ∎</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Corollary 3.</h6>

    <p class="text-gray-300">The composition <span class="math">\\Pi:=\\Pi_{\\sf DEC}\\circ\\Pi_{\\sf RLC}\\circ\\Pi_{\\sf CCS}</span> is a reduction of knowledge (Definition 1) from <span class="math">\\mathsf{ME}(b,\\mathcal{L})^{k}\\times\\mathsf{MCS}(b,\\mathcal{L})</span> to <span class="math">\\mathsf{ME}(b,\\mathcal{L})^{k}</span>.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Follows directly from Corollary 2, <span class="math">\\Pi_{\\sf DEC}</span> is a reduction of knowledge (Theorem 4), and the sequential composition of reductions (Lemma 1). ∎</p>

    <p class="text-gray-300">Definition 19. Consider relations  <span class="math">\\mathcal{R}_1</span>  and  <span class="math">\\mathcal{R}_2</span>  over public parameters, structure, instance, and witness tuples. Further, consider relations  <span class="math">\\mathcal{R}_1&#x27;</span>  and  <span class="math">\\mathcal{R}_2&#x27;</span>  such that  <span class="math">\\mathcal{R}_1 \\subseteq \\mathcal{R}_1&#x27;</span>  and  <span class="math">\\mathcal{R}_2 \\subseteq \\mathcal{R}_2&#x27;</span> . We will refer to these relations as the relaxed versions of  <span class="math">\\mathcal{R}_1</span>  and  <span class="math">\\mathcal{R}_2</span> , because they are supersets. Let  <span class="math">\\phi</span>  be an arbitrary function. A reduction  <span class="math">(\\mathcal{G}, \\mathcal{K}, \\mathcal{P}, \\mathcal{V})</span>  (Definition 1) from  <span class="math">\\mathcal{R}_1</span>  ( <span class="math">\\mathcal{R}_1&#x27;</span> ) to  <span class="math">\\mathcal{R}_2</span>  ( <span class="math">\\mathcal{R}_2&#x27;</span> ) can satisfy the following properties,</p>

    <p class="text-gray-300">(i)  <span class="math">\\phi</span> -restricted: For any expected polynomial-time adversary  <span class="math">(\\mathcal{A},\\mathcal{P}^*)</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {G e n} (1 ^ {\\lambda}) \\\\ u _ {2}, u _ {2} ^ {\\prime} \\neq \\bot &amp;amp; (\\mathsf {s}, u _ {1}, \\mathsf {s t} _ {1}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ \\Downarrow &amp;amp; (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, \\mathsf {s}) \\\\ \\phi (u _ {2}) = \\phi (u _ {2} ^ {\\prime}) &amp;amp; (u _ {2}, w _ {2}) \\leftarrow \\langle \\mathcal {P} ^ {*}, \\mathcal {V} \\rangle ((\\mathsf {p k}, \\mathsf {v k}), u _ {1}, \\mathsf {s t}) \\\\ &amp;amp; (u _ {2} ^ {\\prime}, w _ {2} ^ {\\prime}) \\leftarrow \\langle \\mathcal {P} ^ {*}, \\mathcal {V} \\rangle ((\\mathsf {p k}, \\mathsf {v k}), u _ {1}, \\mathsf {s t}) \\end{array} \\right] = 1</span></div>

    <p class="text-gray-300">(ii)  <span class="math">\\phi</span> -relaxed knowledge soundness: For any expected polynomial-time adversary  <span class="math">(\\mathcal{A},\\mathcal{P}^{<em>})</span> , there exists an expected polynomial-time extractor  <span class="math">\\mathcal{E}</span>  such that if the success probability of the adversary  <span class="math">\\epsilon (\\mathcal{A},\\mathcal{P}^{</em>})\\geq 1 / \\mathrm{poly}(\\lambda)</span> , then</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname * {P r} \\left[ (\\mathsf {p p}, \\mathsf {s}, u _ {1}, w _ {1}) \\in \\mathcal {R} _ {1} ^ {\\prime} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, \\mathsf {s z}) \\\\ (\\mathsf {s}, u _ {1}, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, \\mathsf {s}) \\\\ w _ {1} \\leftarrow \\mathcal {E} (\\mathsf {p p}, \\mathsf {s}, u _ {1}, \\mathsf {s t}) \\end{array} \\right. \\right] \\geq \\epsilon (\\mathcal {A}, \\mathcal {P} ^ {*}) - \\mathsf {n e g l} (\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and if  <span class="math">\\mathcal{A} \\coloneqq (\\mathcal{B}, \\mathcal{B}&#x27;)</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, \\mathsf {s z}) \\\\ &amp;amp; \\mathsf {s t} _ {1} \\leftarrow \\mathcal {B} (\\mathsf {p p}) \\\\ &amp;amp; \\phi (u _ {1}) = \\phi (u _ {1} ^ {\\prime}) \\end{array} \\right] = 1,</span></div>

    <p class="text-gray-300">then</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, \\mathsf {s z}) \\\\ &amp;amp; (\\mathsf {s}, \\mathsf {s t} ^ {*}) \\leftarrow \\mathcal {B} (\\mathsf {p p}) \\\\ w _ {1}, w _ {1} ^ {\\prime} \\neq \\bot &amp;amp; (u _ {1}, \\mathsf {s t}) \\leftarrow \\mathcal {B} ^ {\\prime} (\\mathsf {s t} ^ {*}) \\\\ \\wedge w _ {1} \\neq w _ {1} ^ {\\prime} &amp;amp; w _ {1} \\leftarrow \\mathcal {E} (\\mathsf {p p}, \\mathsf {s}, u _ {1}, \\mathsf {s t}) \\\\ &amp;amp; (u _ {1} ^ {\\prime}, \\mathsf {s t} ^ {\\prime}) \\leftarrow \\mathcal {B} ^ {\\prime} (\\mathsf {s t} ^ {*}) \\\\ &amp;amp; w _ {1} ^ {\\prime} \\leftarrow \\mathcal {E} (\\mathsf {p p}, \\mathsf {s}, u _ {1} ^ {\\prime}, \\mathsf {s t} ^ {\\prime}) \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">(iii) Restricted Knowledge Soundness: For any expected polynomial-time adversary  <span class="math">(\\mathcal{A},\\mathcal{P}^{*})</span> , there exists an expected polynomial-time extractor  <span class="math">\\mathcal{E}</span>  such that if the relaxed success probability of the adversary</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\epsilon^ {\\prime} (\\mathcal {A}, \\mathcal {P} ^ {<em>}) := \\operatorname </em> {P r} \\left[ (\\mathsf {p p}, \\mathsf {s}, \\langle \\mathcal {P} ^ {*}, \\mathcal {V} \\rangle ((\\mathsf {p k}, \\mathsf {v k}), u _ {1}, \\mathsf {s t})) \\in \\mathcal {R} _ {2} ^ {\\prime} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, \\mathsf {s z}) \\\\ (\\mathsf {s}, u _ {1}, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, \\mathsf {s}) \\end{array} \\right. \\right]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><span class="math">\\geq 1/\\mathsf{poly}(\\lambda)</span>, and</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} w _ {2}, w _ {2} ^ {\\prime} \\neq \\bot &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {G e n} (1 ^ {\\lambda}) \\\\ \\wedge &amp;amp; (\\mathsf {s}, u _ {1}, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ w _ {2} \\neq w _ {2} ^ {\\prime} &amp;amp; (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, \\mathsf {s}) \\\\ &amp;amp; (u _ {2}, w _ {2}) \\leftarrow \\langle \\mathcal {P} ^ {*}, \\mathcal {V} \\rangle ((\\mathsf {p k}, \\mathsf {v k}), u _ {1}, \\mathsf {s t}) \\\\ &amp;amp; (u _ {2} ^ {\\prime}, w _ {2} ^ {\\prime}) \\leftarrow \\langle \\mathcal {P} ^ {*}, \\mathcal {V} \\rangle ((\\mathsf {p k}, \\mathsf {v k}), u _ {1}, \\mathsf {s t}) \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">then we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, \\mathsf {s z}) \\\\ (\\mathsf {p p}, \\mathsf {s}, u _ {1}, w _ {1}) \\in \\mathcal {R} _ {1} &amp;amp; (\\mathsf {s}, u _ {1}, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ &amp;amp; (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, \\mathsf {s}) \\\\ &amp;amp; w _ {1} \\leftarrow \\mathcal {E} (\\mathsf {p p}, \\mathsf {s}, u _ {1}, \\mathsf {s t}) \\end{array} \\right] \\geq \\epsilon^ {\\prime} (\\mathcal {A}, \\mathcal {P} ^ {*}) - \\mathsf {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">Lemma 6. Let  <span class="math">\\phi</span>  be the function which projects commitments  <span class="math">(c_{i})_{i\\in [k]}</span>  from the instance. The reduction  <span class="math">\\Pi_{\\mathsf{CCS}}</span>  is  <span class="math">\\phi</span> -restricted.</p>

    <p class="text-gray-300">Proof. For brevity, we defer the proof to Appendix B.7.</p>

    <p class="text-gray-300">Lemma 7. The reduction  <span class="math">\\Pi_{\\mathsf{CCS}}</span>  is a restricted knowledge sound reduction from  <span class="math">\\mathsf{MCS}(b,\\mathcal{L})\\times \\mathsf{ME}(b,\\mathcal{L})^{k - 1}</span>  to  <span class="math">\\mathsf{ME}(b,\\mathcal{L})^k</span>  ( <span class="math">\\mathsf{ME}(q / 2,\\mathcal{L})^k</span> ).</p>

    <p class="text-gray-300">Proof. For brevity, we defer the proof to Appendix B.8.</p>

    <p class="text-gray-300">Lemma 8. Let  <span class="math">\\phi</span>  be the function which projects commitments  <span class="math">(c_{i})_{i\\in [k + 1]}</span>  from the instance. The reduction  <span class="math">\\Pi_{\\mathsf{RLC}}</span>  is a  <span class="math">\\phi</span> -relaxed knowledge sound reduction from  <span class="math">\\mathsf{ME}(b,\\mathcal{L})^{k + 1}</span>  ( <span class="math">\\mathsf{ME}(q / 2,\\mathcal{L})^{k + 1}</span> ) to  <span class="math">\\mathsf{ME}(B,\\mathcal{L})</span> .</p>

    <p class="text-gray-300">Proof. For brevity, we defer the proof to Appendix B.9.</p>

    <p class="text-gray-300">This section provides three efficient parameterizations over  <span class="math">\\leq 64</span> -bit fields. Additionally, Appendix B.11 and Appendix B.12. provide the corresponding sage scripts that we used to determine valid parameterizations. In Section 4.3, we require the commitment scheme to be  <span class="math">(d,m,2B,\\mathcal{C})</span> -relaxed binding (Definition 15). Thus, by Lemma 3, we need the commitment scheme to be  <span class="math">(d,m,4TB)</span> -binding (Definition 15). Finally, Ajtai's commitment scheme is  <span class="math">(d,m,4TB)</span> -binding if  <span class="math">\\mathsf{MSIS}_{m,8TB}^{\\infty,\\kappa,q}</span>  is hard. We estimate the hardness of Module-SIS using the lattice estimator library provided by [7] using our script (Appendix B.12).</p>

    <p class="text-gray-300">We provide a new field, which we refer to as Almost Goldilocks. This field's order is  <span class="math">q = (2^{64} - 2^{32} + 1) - 32</span> , which is close to the order of the Goldilocks field  <span class="math">2^{64} - 2^{32} + 1</span> . Because of this, the field admits an efficient implementation with a small change to the Solinas prime reduction algorithm (which is typically used for the Goldilocks field).</p>

    <p class="text-gray-300">.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Parameterization.</h6>

    <p class="text-gray-300"><span class="math">\\eta=128</span>, <span class="math">\\Phi_{\\eta}=X^{64}+1</span>, <span class="math">d=64</span>, <span class="math">R_{q}:=\\mathbb{F}_{q}[X]/(\\Phi_{\\eta})</span>, <span class="math">\\kappa=13</span>, <span class="math">m=2^{26}</span>, <span class="math">b=2</span>, <span class="math">k=11</span>, <span class="math">B=2^{11}</span>. Define <span class="math">\\mathcal{C}_{R}</span> to be the set polynomials in <span class="math">R_{q}</span> whose coefficients belong to <span class="math">[-1,0,1,2]</span>, and <span class="math">\\mathcal{C}=\\{\\mathsf{rot}(a)\\mid a\\in\\mathcal{C}_{R}\\}</span>. By Theorem 3, <span class="math">T=128</span>. By Theorem 1, <span class="math">\\mathsf{b}_{\\mathsf{inv}}\\approx 4</span>. <span class="math">\\mathbb{K}=\\mathbb{F}_{q^{2}}</span>.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Security.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{128}<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{128}<span class="math">, </span>\\mathsf{MSIS}^{\\infty,\\kappa,q}_{m,8TB}\\approx 127$ bits of security.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">6.2 Goldilocks: <span class="math">2^{64}-2^{32}+1</span></h3>

    <p class="text-gray-300">This is a popular choice of field for SNARKs as the field admits an efficient implementation: field operations can be implemented with essentially only bit-shifts and the field has high 2-adicity (<span class="math">2^{32}\\mid(p-1)</span>), which is useful for compressing Neo’s IVC proofs with SNARKs.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Parameterization.</h6>

    <p class="text-gray-300"><span class="math">\\eta=81</span>, <span class="math">\\Phi_{\\eta}=X^{54}+X^{27}+1</span>, <span class="math">d=54</span>, <span class="math">R_{q}:=\\mathbb{F}_{q}[X]/(\\Phi_{\\eta})</span>, <span class="math">\\kappa=16</span>, <span class="math">m=2^{24}</span>, <span class="math">b=2</span>, <span class="math">k=12</span>, <span class="math">B=2^{12}</span>. Define <span class="math">\\mathcal{C}_{R}</span> to be the set polynomials in <span class="math">R_{q}</span> whose coefficients belong to <span class="math">[-2,-1,0,1,2]</span>, and <span class="math">\\mathcal{C}=\\{\\mathsf{rot}(a)\\mid a\\in\\mathcal{C}_{R}\\}</span>. By Theorem 3, <span class="math">T=216</span>. By Theorem 1, <span class="math">\\mathsf{b}_{\\mathsf{inv}}\\approx 2.5\\cdot 10^{9}</span>. <span class="math">\\mathbb{K}=\\mathbb{F}_{q^{2}}</span>.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Security.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{125}<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{128}<span class="math">, </span>\\mathsf{MSIS}^{\\infty,\\kappa,q}_{m,8TB}\\approx 128$ bits of security.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-51" class="text-base font-medium mt-4">Remark 2 (Incompatibility with Latticefold <em>[14]</em>)</h6>

    <p class="text-gray-300">In LatticeFold <em>[14]</em>, the constructions and analysis are limited to power-of-two cyclotomic polynomials, namely of the form <span class="math">X^{d}+1</span> with <span class="math">d</span> being a power-of-two. Since the Goldilocks field has high 2-acidity, the cyclotomic polynomial completely factors into linear terms. This means that the ring <span class="math">R_{q}</span> is isomorphic to <span class="math">\\mathbb{F}_{q}^{d}</span> (the NTT representation). The security of LatticeFold’s construction depends on the size of the field in the NTT representation <em>[14, Sec 3.3]</em>, which here is only 64 bits.</p>

    <h3 id="sec-52" class="text-xl font-semibold mt-8">6.3 Mersenne 61: <span class="math">2^{61}-1</span></h3>

    <p class="text-gray-300">This field admits an incredibly efficient implementation as it is only one off from a power-of-two. Specifically, modular arithmetic over this field can be implemented with simple bit-shifts with an algorithm more efficient than Goldilocks.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Parameterization.</h6>

    <p class="text-gray-300"><span class="math">\\eta=81</span>, <span class="math">\\Phi_{\\eta}=X^{54}+X^{27}+1</span>, <span class="math">d=54</span>, <span class="math">R_{q}:=\\mathbb{F}_{q}[X]/(\\Phi_{\\eta})</span>, <span class="math">\\kappa=16</span>, <span class="math">m=2^{22}</span>, <span class="math">b=2</span>, <span class="math">k=12</span>, <span class="math">B=2^{12}</span>. Define <span class="math">\\mathcal{C}_{R}</span> to be the set polynomials in <span class="math">R_{q}</span> whose coefficients belong to <span class="math">[-2,-1,0,1,2]</span>, and <span class="math">\\mathcal{C}=\\{\\mathsf{rot}(a)\\mid a\\in\\mathcal{C}_{R}\\}</span>. By Theorem 3, <span class="math">T=216</span>. By Theorem 1, <span class="math">\\mathsf{b}_{\\mathsf{inv}}\\approx 383</span>. <span class="math">\\mathbb{K}=\\mathbb{F}_{q^{2}}</span>.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Security.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{125}<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{122}<span class="math">, </span>\\mathsf{MSIS}^{\\infty,\\kappa,q}_{m,8TB}\\approx 129$ bits of security.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-55" class="text-base font-medium mt-4">Remark 3 (Incompatibility with Latticefold <em>[14]</em>)</h6>

    <p class="text-gray-300">As stated earlier, LatticeFold’s constructions and analysis are limited to power-of-two cyclotomic polynomials, namely of the form <span class="math">X^{d}+1</span> for <span class="math">d</span> being a power-of-two. For Mersenne 61, there is no choice of power-of-two cyclotomic polynomials, which satisfies the requirements of Theorem 1. Hence, it cannot be determined whether a choice of parameters with <span class="math">\\Phi_{\\eta}=X^{d}+1</span> leads to a secure construction.</p>

    <p class="text-gray-300">##</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Nova: Recursive SNARKs without trusted setup. https://github.com/Microsoft/Nova</li>

      <li>[2] Ova: A slightly better Nova. https://hackmd.io/V4838nnlRKal9ZiTHiGYzw</li>

      <li>[3] Folding (Jolt Book). https://jolt.a16zcrypto.com/future/folding. (2024)</li>

      <li>[4] The Nexus zkVM. https://github.com/nexus-xyz/nexus-zkvm (2024)</li>

      <li>[5] Ajtai, M.: Generating hard instances of lattice problems (extended abstract). In: 28th Annual ACM Symposium on Theory of Computing. pp. 99–108. ACM Press, Philadephia, PA, USA (May 22–24, 1996). https://doi.org/10.1145/237814.237838</li>

      <li>[6] Albrecht, M.R., Lai, R.W.F.: Subtractive sets over cyclotomic rings - limits of Schnorr-like arguments over lattices. In: Malkin, T., Peikert, C. (eds.) Advances in Cryptology – CRYPTO 2021, Part II. Lecture Notes in Computer Science, vol. 12826, pp. 519–548. Springer, Cham, Switzerland, Virtual Event (Aug 16–20, 2021). https://doi.org/10.1007/978-3-030-84245-1_18</li>

      <li>[7] Albrecht, M.R., Player, R., Scott, S.: On the concrete hardness of learning with errors. Journal of Mathematical Cryptology 9(3), 169–203 (2015)</li>

      <li>[8] Arun, A., Setty, S.: Nebula: Efficient read-write memory and switchboard circuits for folding schemes. Cryptology ePrint Archive (2024)</li>

      <li>[9] Attema, T., Cramer, R., Kohl, L.: A compressed <span class="math">\\Sigma</span>-protocol theory for lattices. In: Malkin, T., Peikert, C. (eds.) Advances in Cryptology – CRYPTO 2021, Part II. Lecture Notes in Computer Science, vol. 12826, pp. 549–579. Springer, Cham, Switzerland, Virtual Event (Aug 16–20, 2021). https://doi.org/10.1007/978-3-030-84245-1_19</li>

      <li>[10] Attema, T., Lyubashevsky, V., Seiler, G.: Practical product proofs for lattice commitments. In: Micciancio, D., Ristenpart, T. (eds.) Advances in Cryptology – CRYPTO 2020, Part II. Lecture Notes in Computer Science, vol. 12171, pp. 470–499. Springer, Cham, Switzerland, Santa Barbara, CA, USA (Aug 17–21, 2020). https://doi.org/10.1007/978-3-030-56880-1_17</li>

      <li>[11] Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Scalable zero knowledge with no trusted setup. In: CRYPTO (2019)</li>

      <li>[12] Ben-Sasson, E., Chiesa, A., Tromer, E., Virza, M.: Scalable zero knowledge via cycles of elliptic curves. In: CRYPTO (2014)</li>

      <li>[13] Bitansky, N., Canetti, R., Chiesa, A., Tromer, E.: Recursive composition and bootstrapping for SNARKs and proof-carrying data. In: STOC (2013)</li>

      <li>[14] Boneh, D., Chen, B.: LatticeFold: A lattice-based folding scheme and its applications to succinct proof systems. Cryptology ePrint Archive, Paper 2024/257 (2024)</li>

      <li>[15] Bootle, J., Chiesa, A., Hu, Y., Orrú, M.: Gemini: Elastic snarks for diverse environments. In: Annual International Conference on the Theory and Applications of Cryptographic Techniques. pp. 427–457 (2022)</li>

      <li>[16] Bowe, S., Grigg, J., Hopwood, D.: Halo: Recursive proof composition without a trusted setup. Cryptology ePrint Archive, Report 2019/1021 (2019)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[17] Bünz, B., Chen, B.: Protostar: Generic efficient accumulation/folding for special sound protocols. Cryptology ePrint Archive, Paper 2023/620 (2023)</li>

      <li>[18] Bünz, B., Chiesa, A., Lin, W., Mishra, P., Spooner, N.: Proof-carrying data without succinct arguments. In: CRYPTO (2021)</li>

      <li>[19] Bünz, B., Fisch, B., Szepieniec, A.: Transparent SNARKs from DARK compilers. In: EUROCRYPT (2020)</li>

      <li>[20] Bunz, B., Mishra, P., Nguyen, W., Wang, W.: Arc: Accumulation for reed–solomon codes. Cryptology ePrint Archive, Paper 2024/1731 (2024)</li>

      <li>[21] Bünz, B., Chen, J.: Proofs for deep thought: Accumulation for large memories and deterministic computations. Cryptology ePrint Archive, Paper 2024/325 (2024)</li>

      <li>[22] Bünz, B., Mishra, P., Nguyen, W., Wang, W.: Accumulation without homomorphism. Cryptology ePrint Archive, Paper 2024/474 (2024)</li>

      <li>[23] Chen, S., Cheon, J.H., Kim, D., Park, D.: Verifiable computing for approximate computation. Cryptology ePrint Archive, Report 2019/762 (2019), https://eprint.iacr.org/2019/762</li>

      <li>[24] Chen, W., Chiesa, A., Dauterman, E., Ward, N.P.: Reducing participation costs via incremental verification for ledger systems. Cryptology ePrint Archive, Report 2020/1522 (2020)</li>

      <li>[25] Chiesa, A., Hu, Y., Maller, M., Mishra, P., Vesely, N., Ward, N.: Marlin: Pre-processing zkSNARKs with universal and updatable SRS. In: EUROCRYPT (2020)</li>

      <li>[26] Chiesa, A., Ojha, D., Spooner, N.: Fractal: Post-quantum and transparent recursive proofs from holography. In: EUROCRYPT (2020)</li>

      <li>[27] Diamond, B.E., Posen, J.: Succinct arguments over towers of binary fields. Cryptology ePrint Archive, Paper 2023/1784 (2023)</li>

      <li>[28] Dimitriou, N., Garreta, A., Manzur, I., Vlasov, I.: Mova: Nova folding without committing to error terms. Cryptology ePrint Archive, Paper 2024/1220 (2024)</li>

      <li>[29] Eagen, L., Gabizon, A.: Protogalaxy: Efficient protostar-style folding of multiple instances. Cryptology ePrint Archive, Paper 2023/1106 (2023)</li>

      <li>[30] Eagen, L., Gabizon, A., Sefranek, M., Towa, P., Williamson, Z.J.: Stackproofs: Private proofs of stack and contract execution using protogalaxy. Cryptology ePrint Archive, Paper 2024/1281 (2024)</li>

      <li>[31] Fenzi, G., Knabenhans, C., Nguyen, N.K., Pham, D.T.: Lova: Lattice-based folding scheme from unstructured lattices. Cryptology ePrint Archive, Paper 2024/1964 (2024)</li>

      <li>[32] Fenzi, G., Moghaddas, H., Nguyen, N.K.: Lattice-based polynomial commitments: Towards asymptotic and concrete efficiency. Journal of Cryptology 37(3), 31 (Jul 2024). https://doi.org/10.1007/s00145-024-09511-8</li>

      <li>[33] Fiat, A., Shamir, A.: How to prove yourself: Practical solutions to identification and signature problems. In: CRYPTO. pp. 186–194 (1986)</li>

      <li>[34] Garreta, A., Manzur, I.: FLI: Folding lookup instances. Cryptology ePrint Archive, Paper 2024/1531 (2024), https://eprint.iacr.org/2024/1531</li>

      <li>[35] Grassi, L., Khovratovich, D., Rechberger, C., Roy, A., Schofnegger, M.: Poseidon: A new hash function for zero-knowledge proof systems. Cryptology ePrint Archive, Paper 2019/458 (2019)</li>

    </ul>

    <p class="text-gray-300">[36] Kate, A., Zaverucha, G.M., Goldberg, I.: Constant-size commitments to polynomials and their applications. In: ASIACRYPT. pp. 177–194 (2010)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[37] Kilian, J.: A note on efficient zero-knowledge proofs and arguments (extended abstract). In: STOC (1992)</li>

      <li>[38] Kothapalli, A.: A Theory of Composition for Proofs of Knowledge. Ph.D. thesis, Carnegie Mellon University (2024)</li>

      <li>[39] Kothapalli, A., Parno, B.: Algebraic reductions of knowledge. In: CRYPTO (2023)</li>

      <li>[40] Kothapalli, A., Setty, S.: SuperNova: Proving universal machine executions without universal circuits. Cryptology ePrint Archive (2022)</li>

      <li>[41] Kothapalli, A., Setty, S.: Cyclefold: Folding-scheme-based recursive arguments over a cycle of elliptic curves. Cryptology ePrint Archive, Paper 2023/1192 (2023), https://eprint.iacr.org/2023/1192, https://eprint.iacr.org/2023/1192</li>

      <li>[42] Kothapalli, A., Setty, S.: HyperNova: Recursive arguments for customizable constraint systems. In: CRYPTO (2024)</li>

      <li>[43] Kothapalli, A., Setty, S.: NeutronNova: Folding everything that reduces to zero-check. Cryptology ePrint Archive (2024)</li>

      <li>[44] Kothapalli, A., Setty, S., Tzialla, I.: Nova: Recursive Zero-Knowledge Arguments from Folding Schemes. In: CRYPTO (2022)</li>

      <li>[45] Langlois, A., Stehlé, D.: Worst-case to average-case reductions for module lattices. Designs, Codes and Cryptography 75(3), 565–599 (2015). https://doi.org/10.1007/s10623-014-9938-4</li>

      <li>[46] Lund, C., Fortnow, L., Karloff, H., Nisan, N.: Algebraic methods for interactive proof systems. In: FOCS (Oct 1990)</li>

      <li>[47] Lyubashevsky, V., Micciancio, D.: Generalized compact Knapsacks are collision resistant. In: Bugliesi, M., Preneel, B., Sassone, V., Wegener, I. (eds.) ICALP 2006: 33rd International Colloquium on Automata, Languages and Programming, Part II. Lecture Notes in Computer Science, vol. 4052, pp. 144–155. Springer Berlin Heidelberg, Germany, Venice, Italy (Jul 10–14, 2006). https://doi.org/10.1007/11787006_13</li>

      <li>[48] Lyubashevsky, V., Seiler, G.: Short, invertible elements in partially splitting cyclotomic rings and applications to lattice-based zero-knowledge proofs. In: Nielsen, J.B., Rijmen, V. (eds.) Advances in Cryptology – EUROCRYPT 2018, Part I. Lecture Notes in Computer Science, vol. 10820, pp. 204–224. Springer, Cham, Switzerland, Tel Aviv, Israel (Apr 29 – May 3, 2018). https://doi.org/10.1007/978-3-319-78381-9_8</li>

      <li>[49] Micali, S.: CS proofs. In: FOCS (1994)</li>

      <li>[50] Micciancio, D., Regev, O.: Lattice-based cryptography. In: Post-quantum cryptography, pp. 147–191. Springer (2009)</li>

      <li>[51] Nethermind Research: Lattice-based operations performance report. https://nethermind.notion.site/Latticefold-and-lattice-based-operations-performance-report-153360fc38d080ac930cdeeffed69559 (2025)</li>

      <li>[52] Nguyen, W., Boneh, D., Setty, S.: Revisiting the Nova proof system on a cycle of curves. Cryptology ePrint Archive, Paper 2023/969 (2023)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[53] Nguyen, W., Datta, T., Chen, B., Tyagi, N., Boneh, D.: Mangrove: A scalable framework for folding-based SNARKs. In: CRYPTO (2024)</li>

      <li>[54] Pedersen, T.P.: Non-interactive and information-theoretic secure verifiable secret sharing. In: CRYPTO (1991)</li>

      <li>[55] Peikert, C., Rosen, A.: Efficient collision-resistant hashing from worst-case assumptions on cyclic lattices. In: Halevi, S., Rabin, T. (eds.) TCC 2006: 3rd Theory of Cryptography Conference. Lecture Notes in Computer Science, vol. 3876, pp. 145–166. Springer Berlin Heidelberg, Germany, New York, NY, USA (Mar 4–7, 2006). https://doi.org/10.1007/11681878_8</li>

      <li>[56] Schwartz, J.T.: Fast probabilistic algorithms for verification of polynomial identities. J. ACM 27(4) (1980)</li>

      <li>[57] Setty, S.: Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In: CRYPTO (2020)</li>

      <li>[58] Setty, S., Thaler, J.: Twist and Shout: Faster memory checking arguments via one-hot addressing and increments. Cryptology ePrint Archive, Paper 2025/105 (2025)</li>

      <li>[59] Setty, S., Thaler, J., Wahby, R.: Customizable constraint systems for succinct arguments. Cryptology ePrint Archive (2023)</li>

      <li>[60] Thaler, J.: Time-optimal interactive proofs for circuit evaluation. In: CRYPTO (2013)</li>

      <li>[61] Thaler, J.: The sum-check protocol. https://people.cs.georgetown.edu/jthaler/sumcheck.pdf (Sep 2017)</li>

      <li>[62] Valiant, P.: Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In: TCC. pp. 552–576 (2008)</li>

      <li>[63] Vu, V., Setty, S., Blumberg, A.J., Walfish, M.: A hybrid architecture for verifiable computation. In: S&P (2013)</li>

      <li>[64] Zhao, J., Setty, S., Cui, W.: MicroNova: Folding-based arguments with efficient (on-chain) verification. Cryptology ePrint Archive, Paper 2024/2099 (2024), https://eprint.iacr.org/2024/2099</li>

      <li>[65] Zhou, Z., Zhang, Z., Dong, J.: Proof-carrying data from multi-folding schemes. Cryptology ePrint Archive, Paper 2023/1282 (2023)</li>

    </ul>

    <p class="text-gray-300">Supplementary Material</p>

    <h2 id="sec-57" class="text-2xl font-bold">Appendix A Additional Background</h2>

    <h3 id="sec-58" class="text-xl font-semibold mt-8">A.1 Polynomials and multilinear extensions</h3>

    <p class="text-gray-300">We adapt this some of this subsection from prior work <em>[57]</em>. We recall several definitions and results regarding multivariate polynomials.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Definition 20 (Multilinear polynomial).</h6>

    <p class="text-gray-300">A multivariate polynomial is called a multilinear polynomial if the degree of the polynomial in each variable is at most one.</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Definition 21 (Multilinear polynomial extension).</h6>

    <p class="text-gray-300">Given a vector <span class="math">v\\in\\mathbb{F}^{n}</span> a <em>multilinear polynomial extension</em> of <span class="math">v</span> is an <span class="math">(\\log n)</span>-variate multilinear polynomial, denoted <span class="math">\\widetilde{v}</span>, such that <span class="math">\\widetilde{v}(x)=v_{x}</span> for all <span class="math">x\\in\\{0,1\\}^{\\log n}</span>. Specifically, <span class="math">\\widetilde{v}</span> can be computed as follows.</p>

    <p class="text-gray-300"><span class="math">\\widetilde{v}(x)=\\sum_{y\\in\\{0,1\\}^{\\ell}}v_{y}\\cdot\\mathsf{eq}(x,y)</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{eq}(x,y)=\\prod_{i=1}^{\\ell}(x_{i}\\cdot y_{i}+(1-x_{i})\\cdot(1-y_{i}))</span>, outputs <span class="math">1</span> if <span class="math">x=y</span> and <span class="math">0</span> otherwise for <span class="math">x,y\\in\\{0,1\\}^{\\log n}</span>.</p>

    <p class="text-gray-300">For any <span class="math">r\\in\\mathbb{F}^{\\ell}</span>, <span class="math">\\widetilde{v}(r)</span> can be computed in <span class="math">O(2^{\\ell})</span> operations in <span class="math">\\mathbb{F}</span> <em>[60, 63]</em>.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Lemma 9 (Schwartz-Zippel <em>[56]</em>).</h6>

    <p class="text-gray-300">let <span class="math">g:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span> be an <span class="math">\\ell</span>-variate polynomial of total degree at most <span class="math">d</span>. Then, on any finite set <span class="math">S\\subseteq\\mathbb{F}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{x\\leftarrow S^{t}}\\left[g(x)=0\\right]\\leq d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-62" class="text-base font-medium mt-4">Lemma 10.</h6>

    <p class="text-gray-300">Let <span class="math">Q\\in\\mathbb{F}[X_{1},\\ldots,X_{\\ell}]</span> be an arbitrary multivariate polynomial. Define multivariate polynomial <span class="math">Q^{\\prime}(\\bm{X},\\bm{Z}):=\\mathsf{eq}(\\bm{X},\\bm{Z})\\cdot Q(\\bm{X})</span>.</p>

    <p class="text-gray-300"><span class="math">0=\\sum_{\\bm{x}\\in\\{0,1\\}^{\\log\\ell}}Q^{\\prime}(\\bm{x},\\bm{Z})\\quad\\text{if and only if}\\quad Q(\\bm{X})\\in\\mathsf{ZS}_{\\ell}</span></p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Definition 22 (Special sets <em>[32]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}</span> be a set and <span class="math">\\ell\\in\\mathbb{N}</span>. Consider two vectors <span class="math">x,y\\in\\mathcal{C}^{\\ell}</span>. We define the relation <span class="math">\\equiv_{i}</span> for <span class="math">i\\in[\\ell]</span> as follows:</p>

    <p class="text-gray-300"><span class="math">x\\equiv_{i}y\\Longleftrightarrow\\ x_{i}\\neq y_{i}\\ \\wedge\\ x_{j}=y_{j}\\text{ for all }j\\in[\\ell]\\setminus\\{i\\}.</span></p>

    <p class="text-gray-300">A special set <span class="math">\\mathsf{SS}(\\mathcal{C},\\ell)</span> is as follows:</p>

    <p class="text-gray-300">\\[ \\mathsf{SS}(\\mathcal{C},\\ell)=\\left\\{(\\bm{c},\\bm{c}_{1},\\ldots,\\bm{c}_{\\ell})\\in(\\mathcal{C}^{\\ell})^{\\ell+1}\\ :\\begin{array}[]{l}\\forall\\,i\\in[\\ell],\\\\ \\bm{c}\\equiv_{i}\\bm{c}_{i}\\end{array}\\right\\}, \\]</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">Theorem 6 (Coordinate-wise extraction [32, Lemma 7.1]). Let <span class="math">\\mathcal{C}</span> be a finite set, <span class="math">\\ell \\in \\mathbb{N}</span>, and <span class="math">\\mathcal{C} \\coloneqq \\mathcal{C}^{\\ell}</span> be a challenge space. Let <span class="math">A: \\mathcal{C} \\to \\{0,1\\}^{<em>}</span> be an arbitrary (probabilistic) expected polynomial-time algorithm (adversary), and <span class="math">V: \\mathcal{C} \\times \\{0,1\\}^{</em>} \\to \\{0,1\\}</span> be an arbitrary (probabilistic) polynomial-time function (verification). Define the success probability of adversary <span class="math">A</span> as</p>

    <div class="my-4 text-center"><span class="math-block">\\epsilon^{V}(A) := \\Pr_{c \\in \\mathcal{C}} [V(\\boldsymbol{c}, A(\\boldsymbol{c})) = 1]</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then, there exists an expected polynomial-time oracle algorithm <span class="math">E_A</span> (extractor) that makes at most <span class="math">\\ell + 1</span> queries to <span class="math">A</span> in expectation and with probability at least $\\epsilon^V(A) - \\frac{\\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> outputs </span>\\ell + 1<span class="math"> pairs </span>(\\mathbf{c}, w), (\\mathbf{c}_1, w_1), \\ldots, (\\mathbf{c}_\\ell, w_\\ell)$ such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">V(\\mathbf{c}, w) = 1</span>,</li>

      <li>for all <span class="math">i \\in [\\ell]</span>, <span class="math">V(\\mathbf{c}_i, w_i) = 1</span>,</li>

      <li>and <span class="math">(\\mathbf{c}, \\mathbf{c}_1, \\ldots, \\mathbf{c}_\\ell) \\in \\mathsf{SS}(\\mathcal{C}, \\ell)</span>.</li>

    </ul>

    <h2 id="sec-64" class="text-2xl font-bold">B Deferred theorems and proofs</h2>

    <p class="text-gray-300">Theorem 7. The rings <span class="math">R_q</span> (Definition 5) and <span class="math">\\mathcal{S}</span> (Definition 7) are isomorphic. That is, the rotation matrix mapping <span class="math">\\operatorname{rot}: R_q \\to \\mathcal{S}</span> is an isomorphism.</p>

    <p class="text-gray-300">Proof. We first show that <span class="math">\\operatorname{rot}</span> is a homomorphism:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname{rot}(a) + \\operatorname{rot}(b) = \\left[ \\operatorname{cf}(a) + \\operatorname{cf}(b) \\mid \\mathsf{F} \\cdot \\operatorname{cf}(a) + \\mathsf{F} \\cdot \\operatorname{cf}(b) \\mid \\dots \\mid \\mathsf{F}^{d-1} \\cdot \\operatorname{cf}(a) + \\mathsf{F}^{d-1} \\cdot \\operatorname{cf}(b) \\right] \\\\ = \\left[ \\operatorname{cf}(a + b) \\mid \\mathsf{F} \\cdot \\operatorname{cf}(a + b) \\mid \\dots \\mid \\mathsf{F}^{d-1} \\cdot \\operatorname{cf}(a + b) \\right] \\\\ = \\operatorname{rot}(a + b) \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname{rot}(a) \\cdot \\operatorname{rot}(b) = \\operatorname{rot}(a) \\cdot \\left[ \\operatorname{cf}(b) \\mid \\mathsf{F} \\cdot \\operatorname{cf}(b) \\mid \\dots \\mid \\mathsf{F}^{d-1} \\cdot \\operatorname{cf}(b) \\right] \\\\ = \\left[ \\operatorname{rot}(a) \\cdot \\operatorname{cf}(b) \\mid \\operatorname{rot}(a) \\cdot \\mathsf{F} \\cdot \\operatorname{cf}(b) \\mid \\dots \\mid \\operatorname{rot}(a) \\cdot \\mathsf{F}^{d-1} \\cdot \\operatorname{cf}(b) \\right] \\\\ = \\left[ \\operatorname{rot}(a) \\cdot \\operatorname{cf}(b) \\mid \\operatorname{rot}(a) \\cdot \\operatorname{cf}(X \\cdot b) \\mid \\dots \\mid \\operatorname{rot}(a) \\cdot \\operatorname{cf}(X^{d-1} \\cdot b) \\right] \\\\ = \\left[ \\operatorname{cf}(ab) \\mid \\operatorname{cf}(X \\cdot ab) \\mid \\dots \\mid \\operatorname{cf}(X^{d-1} \\cdot ab) \\right] \\\\ = \\left[ \\operatorname{cf}(ab) \\mid \\mathsf{F} \\cdot \\operatorname{cf}(ab) \\mid \\dots \\mid \\mathsf{F}^{d-1} \\cdot \\operatorname{cf}(ab) \\right] \\\\ = \\operatorname{rot}(ab) \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname{rot}(1) = \\left[ \\operatorname{cf}(1) \\mid \\operatorname{cf}(X) \\mid \\dots \\mid \\operatorname{cf}(X^{d-1}) \\right] \\\\ = I_d \\end{array}</span></div>

    <p class="text-gray-300">We can observe that <span class="math">\\operatorname{rot}</span> is trivially a bijection because the first column contains the polynomial coefficients; hence <span class="math">\\operatorname{rot}</span> is additionally a ring isomorphism.</p>

    <h2 id="sec-65" class="text-2xl font-bold">B.1 Proof of Theorem 2</h2>

    <p class="text-gray-300">Proof. We make a small notational modification to Ajtai's commitment scheme to adapt it to our matrix setting. In particular, the commitment scheme is functionally exactly identical.</p>

    <p class="text-gray-300">Ajtai's commitment scheme. Let  <span class="math">m \\in \\mathbb{N}</span>  denote the message length. Ajtai's commitment scheme  <span class="math">\\mathsf{com} := (\\mathsf{Setup}, \\mathsf{Commit})</span>  consists of the following algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(\\kappa, m) \\to \\mathsf{pp}</span> : Sample a random matrix  <span class="math">M \\stackrel{\\S}{\\leftarrow} R_q^{\\kappa \\times m}</span> . Output  <span class="math">\\mathsf{pp} \\gets M</span> .</li>

      <li>Commit  <span class="math">(\\mathsf{pp}, Z \\in \\mathbb{F}^{d \\times m}) \\to c</span> : Parse  <span class="math">M \\gets \\mathsf{pp}</span> . Assign  <span class="math">z := \\mathsf{cf}^{-1}(Z) \\in R_q^m</span> . Output  <span class="math">c \\gets \\mathsf{cf}(Mz)</span> .</li>

    </ul>

    <p class="text-gray-300">We will first show that the commitment scheme is homomorphic. We can trivially observe that the groups  <span class="math">\\mathbb{F}^{d\\times m}</span>  and  <span class="math">\\mathbb{F}^{d\\times \\kappa}</span>  are  <span class="math">S</span> -modules by left multiplication, and  <span class="math">R_{q}^{m}</span>  and  <span class="math">R_{q}^{\\kappa}</span>  are isomorphic (as groups) to  <span class="math">\\mathbb{F}^{d\\times m}</span>  and  <span class="math">\\mathbb{F}^{d\\times \\kappa}</span> , respectively. That is, the coefficient map  <span class="math">\\mathsf{cf}(\\cdot)</span>  is a trivial group isomorphism. Consider two arbitrary matrices  <span class="math">A,B\\in \\mathbb{F}^{d\\times m}</span>  and  <span class="math">\\mathsf{rot}(s)\\in S</span> . We must have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname {C o m m i t} (\\mathfrak {p p}, A) + \\operatorname {C o m m i t} (\\mathfrak {p p}, B) = \\operatorname {c f} \\left(M \\operatorname {c f} ^ {- 1} (A)\\right) + \\operatorname {c f} \\left(M \\operatorname {c f} ^ {- 1} (B)\\right) (1) \\\\ = \\operatorname {c f} \\left(M \\operatorname {c f} ^ {- 1} (A) + M \\operatorname {c f} ^ {- 1} (B)\\right) (2) \\\\ = \\operatorname {c f} \\left(M \\left(\\operatorname {c f} ^ {- 1} (A) + \\operatorname {c f} ^ {- 1} (B)\\right)\\right) \\\\ = \\operatorname {c f} \\left(M \\operatorname {c f} ^ {- 1} (A + B)\\right) (3) \\\\ = \\operatorname {C o m m i t} (\\mathfrak {p p}, A + B) (4) \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname {r o t} (s) \\cdot \\operatorname {C o m m i t} (\\mathfrak {p p}, A) = \\operatorname {r o t} (s) \\cdot \\operatorname {c f} \\left(M \\operatorname {c f} ^ {- 1} (A)\\right) (5) \\\\ = \\operatorname {c f} (s \\cdot M \\operatorname {c f} ^ {- 1} (A)) (6) \\\\ = \\operatorname {c f} (M \\cdot s \\cdot \\operatorname {c f} ^ {- 1} (A)) \\\\ = \\operatorname {c f} (M \\cdot \\operatorname {c f} ^ {- 1} (\\operatorname {r o t} (s) \\cdot A)) (7) \\\\ = \\operatorname {C o m m i t} (\\mathfrak {p p}, \\operatorname {r o t} (s) \\cdot A) (8) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where (1), (4), and (5), (8) are by the definition of Ajtai's commitment scheme, (2) and (3) are by the homomorphism of the  <span class="math">\\mathsf{cf}(\\cdot)</span>  map, and (6) and (7) come from the fact that  <span class="math">\\mathsf{rot}(a)\\cdot \\mathsf{cf}(b) = \\mathsf{cf}(ab)</span>  for any  <span class="math">a,b\\in R_q</span></p>

    <p class="text-gray-300">Now, we will show that the commitment scheme is  <span class="math">(d,m,B)</span> -binding. For this, it suffices to show that a  <span class="math">(d,m,B)</span> -binding collision produces an  <span class="math">\\mathsf{MSIS}_{m,2B}^{\\infty,\\kappa,q}</span>  solution with respect to the uniformly sampled  <span class="math">M</span>  in the pubic parameters  <span class="math">\\mathsf{pp}</span> . Consider an arbitrary  <span class="math">(d,m,B)</span> -binding collision  <span class="math">Z_{1}, Z_{2} \\in \\mathbb{F}^{d \\times m}</span> . We will show  <span class="math">\\mathsf{cf}^{-1}(Z_{1} - Z_{2})</span>  is an  <span class="math">\\mathsf{MSIS}_{m,2B}^{\\infty,\\kappa,q}</span>  solution. By the definition of collision, we must have</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {C o m m i t} (\\mathfrak {p p}, Z _ {1}) = \\operatorname {C o m m i t} (\\mathfrak {p p}, Z _ {2})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {C o m m i t} (\\mathfrak {p p}, Z _ {1} - Z _ {2}) = 0 \\in \\mathbb {F} ^ {d \\times \\kappa} \\tag {9}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {c f} \\left(M \\operatorname {c f} ^ {- 1} \\left(Z _ {1} - Z _ {2}\\right)\\right) = 0 \\in \\mathbb {F} ^ {d \\times \\kappa} \\tag {10}</span></div>

    <div class="my-4 text-center"><span class="math-block">M \\operatorname {c f} ^ {- 1} \\left(Z _ {1} - Z _ {2}\\right) = 0 \\in R _ {q} ^ {\\kappa} \\tag {11}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where (9) is by homomorphism, (10) is by the definition of Ajtai's commitment scheme, and (11) is by applying the map  <span class="math">\\mathsf{cf}^{-1}(\\cdot)</span>  to both sides. Since  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty},\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_2\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; B<span class="math">  (from the definition of an  </span>(d,m,B)<span class="math"> -binding collision), we must have  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_1 - Z_2\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; 2B<span class="math"> , and therefore  </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{cf}^{-1}(Z_1 - Z_2)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_1 - Z_2\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; 2B$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">B.2 Proof of Lemma 3</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">It suffices to show that an arbitrary <span class="math">(d,m,B,\\mathcal{C})</span>-relaxed binding collision <span class="math">(c,\\Delta_{1},\\Delta_{2},Z_{1},Z_{2})</span> can be used to construct a <span class="math">(d,m,2TB)</span>-binding collision. Specifically, we will show the pair <span class="math">(\\Delta_{1}Z_{2},\\Delta_{2}Z_{1})</span> is an <span class="math">(d,m,2TB)</span>-binding collision. We must have</p>

    <p class="text-gray-300"><span class="math">\\Delta_{1}Z_{2}\\neq\\Delta_{2}Z_{1}</span> (12) <span class="math">\\Delta_{1}\\cdot c=\\mathsf{Commit}(\\mathsf{pp},Z_{1})</span> (13) <span class="math">\\Delta_{2}\\cdot\\Delta_{1}\\cdot c=\\Delta_{2}\\cdot\\mathsf{Commit}(\\mathsf{pp},Z_{1})</span> <span class="math">\\Delta_{1}\\cdot\\mathsf{Commit}(\\mathsf{pp},Z_{2})=\\Delta_{2}\\cdot\\mathsf{Commit}(\\mathsf{pp},Z_{1})</span> (14) <span class="math">\\mathsf{Commit}(\\mathsf{pp},\\Delta_{1}Z_{2})=\\mathsf{Commit}(\\mathsf{pp},\\Delta_{2}Z_{1})</span> (15) <span class="math">\\left\\lVert\\Delta_{1}Z_{2}\\right\\rVert_{\\infty},\\left\\lVert\\Delta_{2}Z_{1}\\right\\rVert_{\\infty}\\leq 2TB</span> (16)</p>

    <p class="text-gray-300">where (12) and (13) follow from the definition of relaxed binding collision, (14) is by commutativity and substitution, and (15) follows from <span class="math">\\mathcal{C}\\subseteq\\mathcal{S}</span> and homomorphism. Since expansion factor of <span class="math">\\mathcal{C}</span> is <span class="math">T</span> and <span class="math">\\Delta_{1},\\Delta_{2}\\in(\\mathcal{C}-\\mathcal{C})</span>, we must have that that <span class="math">\\left\\lVert\\Delta_{1}Z_{2}\\right\\rVert_{\\infty}\\leq 2T\\left\\lVert Z_{2}\\right\\rVert_{\\infty}</span> and <span class="math">\\left\\lVert\\Delta_{2}Z_{1}\\right\\rVert_{\\infty}\\leq 2T\\left\\lVert Z_{1}\\right\\rVert_{\\infty}</span>. Since <span class="math">\\left\\lVert Z_{1}\\right\\rVert_{\\infty},\\left\\lVert Z_{2}\\right\\rVert_{\\infty}&lt;B</span> by definition, we have (16) holds. From (12), (15), and (16), we have the pair <span class="math">(\\Delta_{1}Z_{2},\\Delta_{2}Z_{1})</span> is an <span class="math">(d,m,2TB)</span>-binding collision. ∎</p>

    <h3 id="sec-67" class="text-xl font-semibold mt-8">B.3 Proof of Theorem 3</h3>

    <h6 id="sec-68" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By <em>[6, Proposition 2]</em>, we have that</p>

    <p class="text-gray-300"><span class="math">\\max_{u,v\\in R_{q}}\\frac{\\left\\lVert uv\\right\\rVert_{\\infty}}{\\left\\lVert u\\right\\rVert_{\\infty}\\cdot\\left\\lVert v\\right\\rVert_{\\infty}}\\leq 2\\cdot\\phi(\\eta)</span> (17)</p>

    <p class="text-gray-300">For all <span class="math">u,v\\in R_{q}</span>, we must have that</p>

    <p class="text-gray-300"><span class="math">\\frac{\\left\\lVert uv\\right\\rVert_{\\infty}}{\\left\\lVert v\\right\\rVert_{\\infty}}\\leq 2\\cdot\\phi(\\eta)\\cdot\\left\\lVert u\\right\\rVert_{\\infty}</span> (18) <span class="math">\\frac{\\left\\lVert\\mathsf{rot}(u)\\cdot\\mathsf{cf}(v)\\right\\rVert_{\\infty}}{\\left\\lVert\\mathsf{cf}(v)\\right\\rVert_{\\infty}}\\leq 2\\cdot\\phi(\\eta)\\cdot\\left\\lVert u\\right\\rVert_{\\infty}</span> (19)</p>

    <p class="text-gray-300">where (18) follows from (17), and (19) follows from <span class="math">\\mathsf{rot}(u)\\cdot\\mathsf{cf}(v)=\\mathsf{cf}(uv)</span> and the definition of norm <span class="math">\\left\\lVert\\cdot\\right\\rVert_{\\infty}</span> for ring elements. Therefore, we must have for all <span class="math">u\\in R_{q},v\\in\\mathbb{F}^{d}</span> that</p>

    <p class="text-gray-300"><span class="math">\\frac{\\left\\lVert\\mathsf{rot}(u)\\cdot v\\right\\rVert_{\\infty}}{\\left\\lVert v\\right\\rVert_{\\infty}}\\leq 2\\cdot\\phi(\\eta)\\cdot\\left\\lVert u\\right\\rVert_{\\infty}</span> (20)</p>

    <p class="text-gray-300">Since <span class="math">\\mathcal{C}_{R}\\subseteq R_{q}</span>, we must also have the prior bound holds for all <span class="math">u\\in\\mathcal{C}_{R},v\\in\\mathbb{F}^{d}</span>. Since <span class="math">\\mathcal{C}:=\\{\\,\\mathsf{rot}(u)\\;\\mid\\;u\\in\\mathcal{C}_{R}\\,\\}</span>, we must have for all <span class="math">\\rho:=\\mathsf{rot}(u)\\in\\mathcal{C},v\\in\\mathbb{F}^{d}</span>,</p>

    <p class="text-gray-300"><span class="math">\\frac{\\left\\lVert\\rho\\cdot v\\right\\rVert_{\\infty}}{\\left\\lVert v\\right\\rVert_{\\infty}}\\leq 2\\cdot\\phi(\\eta)\\cdot\\left\\lVert u\\right\\rVert_{\\infty}\\leq 2\\cdot\\phi(\\eta)\\cdot\\max_{\\rho^{\\prime}\\in\\mathcal{C}_{R}}\\left\\lVert\\rho^{\\prime}\\right\\rVert_{\\infty}</span> (21)</p>

    <p class="text-gray-300">which is exactly what we wanted to show.</p>

    <p class="text-gray-300">B.4 Proof of Lemma 4</p>

    <p class="text-gray-300">We first provide a lemma that will be helpful for both the security and completeness of the reduction.</p>

    <p class="text-gray-300"><strong>Lemma 11.</strong> Consider an arbitrary structure <span class="math">\\mathfrak{s}</span>, a vector <span class="math">z_1 \\in \\mathbb{F}^m</span>, matrices <span class="math">\\left(Z_i \\in \\mathbb{F}^{d \\times m}\\right)_{i=2}^k</span>, a point <span class="math">r \\in \\mathbb{K}^{\\log n}</span>, and vectors <span class="math">\\left(\\{y_{(i,j)} \\in \\mathbb{K}^d\\}_{j \\in [t]}\\right)_{i=2}^k</span>. Define <span class="math">Z_1 := \\mathsf{Decomp}_b(z_1)</span>. For all <span class="math">i \\in [k], j \\in [t]</span>, define <span class="math">M_{(i,j)} := Z_i M_j^\\top</span>. Define <span class="math">\\delta := \\log d</span> and <span class="math">\\zeta := \\log(dn)</span>. Define polynomials <span class="math">\\mathsf{F}(X_{[1,n]})</span> and <span class="math">\\mathsf{NC}_i(X_{[1,\\zeta]})</span> for <span class="math">i \\in [k]</span> as in <span class="math">\\Pi_{\\mathsf{CCS}}</span>. Define indeterminates <span class="math">\\mathbf{X} := X_{[1,\\zeta]}</span>, <span class="math">\\mathbf{A} := A_{[1,\\delta]}</span>, and <span class="math">\\mathbf{B} := B_{[1,\\zeta]}</span>. Additionally, define polynomials</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{Eval}_{i,j}(\\mathbf{X}, \\mathbf{A}) := \\mathsf{eq}(\\mathbf{X}, \\mathbf{A}, r) \\cdot \\widetilde{M}_{i,j}(\\mathbf{X}) \\quad \\forall i \\in [k+1, 2k], \\quad \\forall j \\in [t] \\\\ Q(\\mathbf{X}, \\mathbf{A}, \\mathbf{B}, C) := \\mathsf{eq}(\\mathbf{X}, \\mathbf{B}) \\left(\\mathsf{F}(X_{[\\delta+1, \\zeta]}) + \\sum_{i \\in [k]} C^i \\cdot \\mathsf{NC}_i(\\mathbf{X})\\right) \\\\ \\quad + C^k \\sum_{j=1, i=2}^{t,k} C^{i+(j-1)k-1} \\cdot \\mathsf{Eval}_{(i,j)}(\\mathbf{X}) \\end{array}</span></div>

    <p class="text-gray-300">Further, define quantity <span class="math">\\mathrm{T} := C^k \\sum_{j=1, i=2}^{t,k} C^{i+(j-1)k-1} \\cdot \\widetilde{y}_{(i,j)}(\\mathbf{A})</span>. We must have <span class="math">T \\neq \\sum_{x \\in \\{0,1\\}^{\\zeta}} Q(x, \\mathbf{A}, \\mathbf{B}, C)</span> if and only if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{F}(X_{[\\delta+1,\\zeta]}) \\notin \\mathsf{ZS}_n</span> (identically, <span class="math">\\mathsf{F}(X_{[1,n]}) \\notin \\mathsf{ZS}_n</span>),</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. OR there exists an <span class="math">i \\in [k]</span> for which $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\geq b$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>OR there exists an <span class="math">i \\in [2, k]</span> for which <span class="math">\\widetilde{y}_{(i,j)}(\\mathbf{A}) \\neq \\widetilde{M}_{i,j}(\\mathbf{A}, r)</span> (identically, <span class="math">y_{(i,j)} = Z_i M_j^\\top \\widetilde{r}</span>)</li>

    </ol>

    <p class="text-gray-300"><strong>Proof.</strong> Since the powers of indeterminate <span class="math">C</span> are linearly independent, <span class="math">\\mathrm{T} \\neq \\sum_{x \\in \\{0,1\\}^{\\zeta}} Q(x, \\mathbf{A}, \\mathbf{B}, C)</span> if and only if</p>

    <div class="my-4 text-center"><span class="math-block">0 \\neq \\sum_{x \\in \\{0,1\\}^{\\zeta}} \\mathbf{eq}(x, \\mathbf{B}) \\cdot \\mathsf{F}(x_{[\\delta+1,\\zeta]}), \\tag{22}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathrm{OR} \\quad \\exists i \\in [k], \\quad 0 \\neq \\sum_{x \\in \\{0,1\\}^{\\zeta}} \\mathbf{eq}(x, \\mathbf{B}) \\cdot \\mathsf{NC}_i(x), \\tag{23}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathrm{OR} \\quad \\exists i \\in [2, k], j \\in [t] \\quad \\widetilde{y}_{(i,j)}(\\mathbf{A}) \\neq \\sum_{x \\in \\{0,1\\}^{\\zeta}} \\mathsf{Eval}_{i,j}(x, \\mathbf{A}) \\tag{24}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By Lemma 10, we must have (22) if and only if <span class="math">\\mathsf{F}(\\mathbf{X}) \\notin \\mathsf{ZS}_{dn}</span> (Item 1). Since, for all <span class="math">i \\in [k]</span>, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\geq b<span class="math"> if and only if </span>\\mathsf{NC}_i(\\mathbf{X}) \\notin \\mathsf{ZS}_{\\zeta}<span class="math">, by Lemma 10, we have that (23) if and only if there exists an </span>i \\in [k]<span class="math"> for which </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\geq b<span class="math"> (Item 2). Observe for all </span>i, j$ that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_{x \\in \\{0,1\\}^{\\zeta}} \\mathsf{Eval}_{i,j}(x, \\mathbf{A}) = \\sum_{x \\in \\{0,1\\}^{\\zeta}} \\mathbf{eq}(x, \\mathbf{A}, r) \\cdot \\widetilde{M}_{i,j}(x) \\\\ \\quad = \\sum_{x \\in \\{0,1\\}^{\\zeta}} \\mathbf{eq}(x, \\mathbf{A}, r) \\cdot \\widetilde{M}_{i,j}(x) \\end{array}</span></div>

    <p class="text-gray-300"><span class="math">=\\widetilde{M}_{i,j}(\\bm{A},r)</span> (25)</p>

    <p class="text-gray-300">where (25) follows from the definition of a multilinear extension. Thus, by (25), we have (24) if and only if there exists an <span class="math">i\\in[2,k]</span> for which <span class="math">\\widetilde{y}_{i,j}(\\bm{A})\\neq\\widetilde{M}_{i,j}(\\bm{A},r)</span> (Item 3).</p>

    <p class="text-gray-300">In conclusion, we have shown <span class="math">\\mathrm{T}\\neq\\sum_{x\\in\\{0,1\\}^{\\zeta}}Q(x,\\bm{A},\\bm{B},C)</span> if and only if (22), (23), or (24), which holds if and only if (Item 1), (Item 2), or (Item 3). This concludes our proof. ∎</p>

    <p class="text-gray-300">Now, we provide the proof of Lemma 4.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300"><em>Completeness:</em> We will first argue that the sum-check verifier does not reject if the original tuples belong to the input relations. Consider the contrapositive of Lemma 11,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{F}(X_{[\\delta+1,\\zeta]})\\in\\mathsf{ZS}_{n}</span> (identically, <span class="math">\\mathsf{F}(X_{[1,n]})\\in\\mathsf{ZS}_{n}</span>),</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. for all <span class="math">i\\in[k]</span>, $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{i}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<b$, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for all <span class="math">i\\in[2,k]</span>, <span class="math">\\widetilde{y}_{(i,j)}(\\bm{A})\\neq\\widetilde{M}_{i,j}(\\bm{A},r)</span> (identically, <span class="math">y_{(i,j)}=Z_{i}M_{j}^{\\intercal}\\widehat{r}</span>)</li>

    </ol>

    <p class="text-gray-300">if and only if <span class="math">\\mathrm{T}=\\sum_{x\\in\\{0,1\\}^{\\zeta}}Q(x,\\bm{A},\\bm{B},C)</span>. We will show each condition is guaranteed by the input tuples belonging to <span class="math">\\mathsf{MCS}(b,\\mathcal{L})\\times\\mathsf{ME}(b,\\mathcal{L})^{k-1}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the definition of <span class="math">\\mathsf{MCS}(b,\\mathcal{L})</span> (Definition 17), <span class="math">(\\mathsf{s};</span> <span class="math">(c_{1},x_{1});</span> <span class="math">w_{1})\\in\\mathsf{MCS}(b,\\mathcal{L})</span> guarantees that <span class="math">\\mathsf{F}(X_{[\\delta+1,\\zeta]})\\in\\mathsf{ZS}_{n}</span> and $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{1}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<b<span class="math">. By the definition of </span>\\mathsf{ME}(b,\\mathcal{L})$ (Definition 18),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\left(\\mathsf{s}; c_{i},\\ X_{i},\\ r,\\ \\{y_{(i,j)}\\}_{j\\in[t]};\\ Z_{i}\\right)_{i=2}^{k}\\in\\mathsf{ME}(b,\\mathcal{L})^{k-1}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">guarantees that for all <span class="math">i\\in[2,k]</span>, we have both $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{i}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<b<span class="math"> and </span>y_{(i,j)}=Z_{i}M_{j}^{\\intercal}\\widehat{r}<span class="math">. Thus, in total, we have by the contrapositive of Lemma 11 that </span>\\mathrm{T}=\\sum_{x\\in\\{0,1\\}^{\\zeta}}Q(x,\\bm{A},\\bm{B},C)<span class="math">, where </span>\\mathrm{T}:=C^{k}\\sum_{j=1,i=2}^{t,k}C^{i+(j-1)k-1}\\cdot\\widetilde{y}_{(i,j)}(\\bm{A})<span class="math">. Thus, since the sum holds for indeterminate variables </span>\\bm{A},\\bm{B},C<span class="math">, they must hold for the verifier challenges </span>\\alpha,\\beta,\\gamma<span class="math">. Therefore, the verifier will not reject during the honest execution of the sum-check protocol, since the </span>Q<span class="math"> does sum to </span>\\mathrm{T}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now, we will argue that the verifier’s evaluation check passes. Consider an arbitrary <span class="math">j\\in[t]</span>. By construction (Item 3), <span class="math">\\widetilde{y}_{(1,j)}^{\\prime}=Z_{1}M_{j}^{\\intercal}\\widehat{r}^{\\prime}</span>, where <span class="math">Z_{1}=\\mathsf{Decomp}_{b}(z_{1})</span>. By the definition of <span class="math">\\mathsf{Decomp}_{b}</span>, for all <span class="math">\\ell\\in[d]</span>, we have <span class="math">y_{(1,j),\\ell}^{\\prime}=Z_{1}^{(\\ell)}M_{j}^{\\intercal}\\widehat{r}^{\\prime}</span>, where <span class="math">Z_{1}^{(\\ell)}</span> is the <span class="math">\\ell</span>-th row of <span class="math">Z_{1}</span>. Therefore, we have</p>

    <p class="text-gray-300"><span class="math">m_{j}</span> <span class="math">=\\sum_{\\ell\\in[d]}b^{\\ell-1}y_{(1,j),\\ell}^{\\prime}=\\sum_{\\ell\\in[d]}b^{\\ell-1}Z_{1}^{(\\ell)}M_{j}\\widehat{r}^{\\prime}</span> <span class="math">\\sum_{\\ell\\in[d]}b^{\\ell-1}y_{(1,j),\\ell}^{\\prime}=\\left(\\sum_{\\ell\\in[d]}b^{\\ell-1}Z_{1}^{(\\ell)}\\right)M_{j}^{\\intercal}\\widehat{r}^{\\prime}</span> <span class="math">\\sum_{\\ell\\in[d]}b^{\\ell-1}y_{(1,j),\\ell}^{\\prime}=z\\cdot M_{j}^{\\intercal}\\widehat{r}^{\\prime}=\\widetilde{M_{j}z}(r^{\\prime})</span></p>

    <p class="text-gray-300">Therefore, the value <span class="math">F = \\mathsf{F}(r&#x27;) = f(m_1, \\ldots, m_t)</span>, since we considered an arbitrary <span class="math">j \\in [t]</span>. Since we required <span class="math">M_1 = I_n</span>, we must have for all <span class="math">i \\in [k]</span>, <span class="math">\\widetilde{y}_{(i,1)}&#x27;(\\alpha&#x27;) = \\widetilde{Z_i M_1^\\top}(\\alpha&#x27;, r&#x27;) = \\widetilde{Z_i}(\\alpha&#x27;, r&#x27;)</span>. Therefore, the value <span class="math">N_i = \\mathsf{NC}(\\alpha&#x27;, \\gamma&#x27;)</span> for all <span class="math">i \\in [k]</span>. By construction (Item 3), we can trivially observe that <span class="math">E_{(i,j)} = \\mathsf{Eval}_{(i,j)}(\\alpha&#x27;, r&#x27;)</span>. All together, the verifier's check in Item 4 must pass by construction, since the values <span class="math">F, N_i</span> for all <span class="math">i \\in [k]</span>, and <span class="math">E_{(i,j)}</span> for all <span class="math">i \\in [k]</span>, <span class="math">j \\in [t]</span>, exactly match their corresponding evaluations in the definition of <span class="math">Q(\\alpha&#x27;, r&#x27;)</span>.</p>

    <p class="text-gray-300">Now, we will argue the output tuple does belong to <span class="math">\\mathsf{ME}(b,\\mathcal{L})^k</span>. The condition that for all <span class="math">i\\in [2,k]</span>, <span class="math">c_{i} = \\mathcal{L}(Z_{i})</span> and <span class="math">X_{i} = \\mathcal{L}_{x}(Z_{i})</span> is trivially guaranteed by the input tuples belonging to <span class="math">\\mathsf{ME}(b,\\mathcal{L})^{k - 1}</span> (Definition 18). By the construction of <span class="math">X_{1}\\gets \\mathsf{Decomp}_{b}(x_{1})</span> and the first tuple belonging to MCS (Definition 17), we have <span class="math">c_{1} = \\mathcal{L}(Z_{1})</span> and <span class="math">X_{1} = \\mathcal{L}_{x}(Z_{1})</span>. Finally, by construction in step Item 3, we exactly have that <span class="math">y_{(i,j)}&#x27; = Z_iM_j^\\top \\widehat{r}&#x27;</span> for all <span class="math">i\\in [k]</span> and <span class="math">j\\in [t]</span>. All together, we have that all of the conditions are satisfied for the output tuples to belong to <span class="math">\\mathsf{ME}(b,\\mathcal{L})^k</span>.</p>

    <p class="text-gray-300">Public coin. The sum-check protocol itself is a public-coin protocol. The remaining randomness from the verifier are the challenges <span class="math">\\alpha \\in \\mathbb{K}^{\\log d}</span>, <span class="math">\\beta \\in \\mathbb{K}^{\\log (dn)}</span>, <span class="math">\\gamma \\in \\mathbb{K}</span>, which are sampled uniformly at random.</p>

    <h2 id="sec-70" class="text-2xl font-bold">B.5 Proof of Lemma 5</h2>

    <p class="text-gray-300">Completeness: Since <span class="math">(\\mathsf{s}; c_i, X_i, r, \\{y_{(i,j)}\\}_{j \\in [t]}; Z_i)_{i \\in [k+1]} \\in \\mathsf{ME}(b, \\mathcal{L})^{k+1}</span>, by Corollary 1, we must have <span class="math">c = \\mathcal{L}(Z)</span> and <span class="math">\\forall j \\in [t]</span>, <span class="math">y_j = Z M_j^\\top \\widehat{r}</span>. Furthermore, we must have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} = \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_ {i = 1} ^ {k + 1} \\rho_ {i} \\cdot Z _ {i} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq \\sum_ {i = 1} ^ {k + 1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_ {i} \\cdot Z _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq \\sum_ {i = 1} ^ {k + 1} T \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq (k + 1) T (b - 1) &lt; B,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where the second inequality is from the expansion factor of <span class="math">\\mathcal{C}</span> being <span class="math">T</span>, the third inequality is from the definition of <span class="math">\\mathsf{ME}(b,\\mathcal{L})^{k + 1}</span>, which enforces a norm bound of <span class="math">b</span>, and the last inequality is by assumption (Section 4.3). Hence, we must have that the output tuple <span class="math">(\\mathsf{s}; c, X, r, \\{y_j\\}_{j \\in [t]}; Z) \\in \\mathsf{ME}(B,\\mathcal{L})</span>.</p>

    <p class="text-gray-300">Public coin. The only randomness from the verifier is the challenges <span class="math">\\rho_1, \\ldots, \\rho_{k+1}</span>, which are sampled uniformly at random from <span class="math">\\mathcal{C}</span>.</p>

    <h2 id="sec-71" class="text-2xl font-bold">B.6 Proof of Theorem 4</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Completeness: First, we show that the verifier's checks pass. By the definition of <span class="math">\\mathsf{ME}(B,\\mathcal{L})</span>, we must have that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; B<span class="math">. Thus, by definition of </span>\\mathsf{split}_b<span class="math">, we must have </span>Z = \\sum_{i=1}^{k} b^{i-1} \\cdot Z_i$. Therefore, we must have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} Z = \\sum_ {i = 1} ^ {k} b ^ {i - 1} \\cdot Z _ {i} \\\\ Z = \\sum_ {i = 1} ^ {k} \\bar {b} ^ {i - 1} \\cdot Z _ {i} \\tag {26} \\\\ \\mathcal {L} (Z) = \\mathcal {L} \\left(\\sum_ {i = 1} ^ {k} \\bar {b} ^ {i - 1} \\cdot Z _ {i}\\right), \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">c = \\sum_{i=1}^{k} \\bar{b}^{i-1} \\cdot \\mathcal{L}(Z_i), \\tag{27}</span></div>

    <div class="my-4 text-center"><span class="math-block">c = \\sum_{i=1}^{k} \\bar{b}^{i-1} \\cdot c_i, \\tag{28}</span></div>

    <p class="text-gray-300">Since <span class="math">Z_i \\in \\mathbb{F}^{d \\times m}</span>, (26) follows from <span class="math">\\bar{b} \\in \\mathbb{F}^{d \\times d}</span> being a scalar matrix. Since all scalar matrices are contained in <span class="math">\\mathcal{S}</span>, (27) follows directly from <span class="math">\\mathcal{L}</span> being a <span class="math">\\mathcal{S}</span>-module homomorphism. (28) follows by construction, in step 1, <span class="math">c_i \\gets \\mathcal{L}(Z_i)</span>. Starting from equation (26), we must have for all <span class="math">j \\in [t]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">Z = \\sum_{i=1}^{k} \\bar{b}^{i-1} \\cdot Z_i</span></div>

    <div class="my-4 text-center"><span class="math-block">Z \\cdot M_j^{\\intercal} \\widehat{r} = \\left(\\sum_{i=1}^{k} \\bar{b}^{i-1} \\cdot Z_i\\right) \\cdot M_j^{\\intercal} \\widehat{r}</span></div>

    <div class="my-4 text-center"><span class="math-block">y_j = \\sum_{i=1}^{k} \\left(\\bar{b}^{i-1} \\cdot Z_i M_j^{\\intercal} \\widehat{r}\\right) \\tag{29}</span></div>

    <div class="my-4 text-center"><span class="math-block">y_j = \\sum_{i=1}^{k} \\bar{b}^{i-1} \\cdot y_{(i,j)} \\tag{30}</span></div>

    <p class="text-gray-300">(29) follows from the definition of <span class="math">\\mathsf{ME}(B, \\mathcal{L})</span> and distribution. (30) follows by construction, in step 1, <span class="math">y_{(i,j)} \\gets Z_i M_j^{\\intercal} \\widehat{r}</span>. Thus, by (28) and (30), we have the verifier's checks must pass.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, we show that the output tuple, <span class="math">(\\mathsf{s}; \\{c_i, X_i, r, \\{y_{(i,j)}\\}_{j \\in [t]}\\}_{i \\in [k]}; \\{Z_i\\}_{i \\in [k]})</span>, belongs to <span class="math">\\mathsf{ME}(b, \\mathcal{L})^k</span>. By the definition of <span class="math">\\mathsf{split}_b</span>, we must have that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; b<span class="math"> for all </span>i \\in [k]<span class="math">. Since </span>\\mathcal{L}_x<span class="math"> is the trivial </span>\\mathcal{S}<span class="math">-module homomorphism which projects the first </span>m_{\\mathrm{in}}<span class="math"> columns, we must have that, by construction in step 2, that </span>X_i = \\mathcal{L}_x(Z_i)<span class="math"> for all </span>i \\in [k]<span class="math">. Thus, in total, we must have, along with the construction of </span>\\left(c_i, \\{y_{(i,j)}\\}_{j \\in [t]}\\right)_{i \\in [k]}<span class="math"> in step 1, that the output tuple belongs to </span>\\mathsf{ME}(b, \\mathcal{L})^k$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Knowledge soundness</strong>: Consider an arbitrary expected-polynomial time adversary <span class="math">(\\mathcal{A}, \\mathcal{P}^<em>)</span> for <span class="math">\\Pi_{\\mathrm{DEC}}</span> with success probability, <span class="math">\\epsilon(\\mathcal{A}, \\mathcal{P}^</em>) \\geq 1 / \\mathrm{poly}(\\lambda)</span>. We construct an extractor <span class="math">\\mathcal{E}</span> for <span class="math">\\Pi_{\\mathrm{DEC}}</span> as follows,</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}\\big(\\mathsf{pp}, \\mathsf{s}, u_1 := \\{c, X, r, \\{y_j\\}_{j \\in [t]}\\}, \\mathsf{st}\\big)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Execute encoder <span class="math">(\\mathsf{pk}, \\mathsf{vk}) \\gets \\mathcal{K}(\\mathsf{pp}, \\mathsf{s})</span>.</li>

      <li>Simulate <span class="math">(u_2, w_2) \\gets \\langle \\mathcal{P}^*(\\mathsf{pk}, u_1, \\mathsf{st}), \\mathcal{V}(\\mathsf{vk}, u_1) \\rangle</span>.</li>

      <li>If <span class="math">u_2 = \\bot</span>, output <span class="math">\\bot</span>.</li>

      <li>Parse <span class="math">(Z_1, \\ldots, Z_k) \\gets w_2</span>.</li>

      <li>Output <span class="math">w_1 := \\sum_{i=1}^{k} \\bar{b}^{i-1} Z_i</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Extractor runtime</strong>: The extractor runs in expected polynomial time, since it simulates only one execution between the adversary <span class="math">\\mathcal{P}^*</span> and verifier <span class="math">\\mathcal{V}</span>, which both run in expected polynomial time.</p>

    <p class="text-gray-300"><strong>Extractor success probability</strong>: Assume that the simulated adversary <span class="math">(\\mathcal{A}, \\mathcal{P}^<em>)</span> succeeds in convincing the verifier <span class="math">\\mathcal{V}</span> and the parties jointly output <span class="math">(\\mathsf{s}, u_2, w_2) \\in \\mathsf{ME}(b, \\mathcal{L})^k</span>; note that this occurs with probability <span class="math">\\epsilon(\\mathcal{A}, \\mathcal{P}^</em>)</span>. Define $(c_i, X_i, r,</p>

    <p class="text-gray-300"><span class="math">\\{y_{(i,j)}\\}_{j\\in [t]})_{i\\in [k]}:=u_2</span> and <span class="math">Z_{1},\\ldots,Z_{k}:=w_{2}</span>. By the definition of <span class="math">\\mathsf{ME}(b,\\mathcal{L})^{k}</span>, we have for all <span class="math">i\\in[k]</span> and <span class="math">j\\in[t]</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {i} := \\mathcal {L} \\left(Z _ {i}\\right), \\quad X _ {i} := \\mathcal {L} _ {x} \\left(Z _ {i}\\right), \\quad \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} &lt;   b \\quad \\text {and} \\quad y _ {(i, j)} := Z _ {i} M _ {j} ^ {\\intercal} \\widehat {r} \\tag {31}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Since the adversary succeeds in convincing the verifier, we must have that for all <span class="math">j \\in [t]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">c = \\sum_ {i = 1} ^ {k} \\bar {b} ^ {i - 1} \\cdot c _ {i} \\quad \\text {and} \\quad y _ {j} = \\sum_ {i = 1} ^ {k} \\bar {b} ^ {i - 1} \\cdot y _ {(i, j)} \\tag {32}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By construction in step 2 (i.e. definition of <span class="math">\\mathsf{split}_b</span>), we also must have <span class="math">X = \\sum_{i=1}^{k} \\bar{b}^{i-1} \\cdot X_i</span>. By defining <span class="math">Z := \\sum_{i=1}^{k} \\bar{b}^{i-1} Z_i</span>, observe that <span class="math">X = \\sum_{i=1}^{k} \\bar{b}^{i-1} \\cdot X_i</span>, (31), and (32) satisfy the remaining conditions stated in Corollary 1. Since <span class="math">\\mathcal{S}</span> contains all scalar matrices, by Corollary 1, we must have <span class="math">c = \\mathcal{L}(Z)</span>, <span class="math">X = \\mathcal{L}_x(Z)</span>, and for all <span class="math">j \\in [t]</span>, <span class="math">y_j = Z M_j^\\top \\widehat{r}</span>. Since in (31), we have for all <span class="math">i \\in [k]</span>, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_\\infty &lt; b<span class="math">, we must also have </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_\\infty &lt; B = b^k<span class="math">. These are exactly the conditions for </span>(\\mathsf{s}; u_1 := \\{c, X, r, \\{y_j\\}_{j \\in [t]}\\}; w_1 := Z)<span class="math"> to belong to </span>\\mathsf{ME}(B, \\mathcal{L})<span class="math">. Therefore, since the adversary succeeds with probability </span>\\epsilon(\\mathcal{A}, \\mathcal{P}^<em>)<span class="math">, we must have by construction, that </span>\\mathcal{E}<span class="math"> outputs a satisfying witness such that </span>(\\mathsf{s}, u_1, w_1) \\in \\mathsf{ME}(B, \\mathcal{L})<span class="math"> with probability </span>\\epsilon(\\mathcal{A}, \\mathcal{P}^</em>)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Public coin:</strong> The verifier uses no randomness in this protocol. Thus, the protocol is trivially public coin.</p>

    <h2 id="sec-72" class="text-2xl font-bold">B.7 Proof of Lemma 6</h2>

    <p class="text-gray-300"><strong>Proof.</strong> By construction, the verifier trivially outputs the same commitments <span class="math">(c_{i})_{i\\in [k]}</span> from the original instance <span class="math">u_{1}</span> to <span class="math">u_{2}</span>. Hence, for repeated executions with respect to the same original instance <span class="math">u_{1}</span>, the commitments in the output instances <span class="math">u_{2}</span> must be the same.</p>

    <h2 id="sec-73" class="text-2xl font-bold">B.8 Proof of Lemma 7</h2>

    <p class="text-gray-300"><strong>Proof.</strong> Consider an arbitrary expected polynomial-time adversary <span class="math">(\\mathcal{A},\\mathcal{P}^<em>)</span>, such that the relaxed success probability of the adversary <span class="math">\\epsilon^{\\prime}(\\mathcal{A},\\mathcal{P}^{</em>})\\geq 1 / \\mathrm{poly}(\\lambda)</span> and</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} w _ {2}, w _ {2} ^ {\\prime} \\neq \\bot &amp;amp; \\mathrm {p p} \\leftarrow \\operatorname {G e n} \\left(1 ^ {\\lambda}\\right) \\\\ \\wedge &amp;amp; (\\mathrm {s}, u _ {1}, \\mathrm {s t}) \\leftarrow \\mathcal {A} (\\mathrm {p p}) \\\\ w _ {2} \\neq w _ {2} ^ {\\prime} &amp;amp; \\left(\\mathrm {p k}, \\mathrm {v k}\\right) \\leftarrow \\mathcal {K} (\\mathrm {p p}, \\mathrm {s}) \\\\ &amp;amp; \\left(u _ {2}, w _ {2}\\right) \\leftarrow \\langle \\mathcal {P} ^ {*}, \\mathcal {V} \\rangle \\left(\\left(\\mathrm {p k}, \\mathrm {v k}\\right), u _ {1}, \\mathrm {s t}\\right) \\\\ &amp;amp; \\left(u _ {2} ^ {\\prime}, w _ {2} ^ {\\prime}\\right) \\leftarrow \\langle \\mathcal {P} ^ {*}, \\mathcal {V} \\rangle \\left(\\left(\\mathrm {p k}, \\mathrm {v k}\\right), u _ {1}, \\mathrm {s t}\\right) \\end{array} \\right] \\leq \\operatorname {n e g l} (\\lambda) \\tag {33}</span></div>

    <p class="text-gray-300">then we will show that there exists an expected polynomial-time extractor <span class="math">\\mathcal{E}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ (\\mathsf {p p}, \\mathsf {s}, u _ {1}, w _ {1}) \\in \\mathcal {R} _ {1} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, \\mathsf {s z}) \\\\ (\\mathsf {s}, u _ {1}, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, \\mathsf {s}) \\\\ w _ {1} \\leftarrow \\mathcal {E} (\\mathsf {p p}, \\mathsf {s}, u _ {1}, \\mathsf {s t}) \\end{array} \\right. \\right] \\geq \\epsilon^ {\\prime} (\\mathcal {A}, \\mathcal {P} ^ {*}) - \\mathsf {n e g l} (\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Namely, the following extractor  <span class="math">\\mathcal{E}</span></p>

    <pre><code class="language-latex">$\\mathcal{E}(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})\\to w_1$  .. 1.  $(\\mathsf{pk},\\mathsf{vk})\\gets \\mathcal{K}(\\mathsf{pp},\\mathsf{s})$  2. Assign result  $\\coloneqq \\bot$  3. While result  $= \\bot$  .. - Simulate result  $\\leftarrow \\langle \\mathcal{P}_1^*,\\mathcal{V}_1\\rangle ((\\mathsf{pk},\\mathsf{vk}),u_1,\\mathsf{st}^*)$  - If result  $\\neq \\bot$  - Parse  $(u_{2},w_{2})\\gets$  result. - If  $(\\mathsf{pp},\\mathsf{s},u_2,w_2)\\notin \\mathcal{R}_2&#x27;$  , then set result  $= \\bot$  4. Simulate result&#x27;  $\\leftarrow \\langle \\mathcal{P}_1^*,\\mathcal{V}_1\\rangle ((\\mathsf{pk},\\mathsf{vk}),u_1,\\mathsf{st}^*)$  5. If result&#x27;  $\\neq \\bot$  .. - Parse  $(u_2&#x27;,w_2&#x27;)\\gets$  result&#x27;. - If  $(\\mathsf{pp},\\mathsf{s},u_2&#x27;,w_2&#x27;)\\notin \\mathcal{R}_2&#x27;$  , then set result&#x27;  $= \\bot$  6. If result&#x27;  $= \\bot$  , then output  $\\bot$  7. Parse  $(u_{2},w_{2})\\gets$  result and  $(u_2&#x27;,w_2&#x27;)\\gets$  result&#x27;. 8. If  $w_{2}\\neq w_{2}^{\\prime}$  , then output  $\\bot$  9. Parse  $(Z_{1},\\ldots ,Z_{k})\\gets w_{2}$  10. Assign  $z_{1}\\gets \\sum_{i = 1}^{d}b^{i - 1}\\cdot Z_{1}^{(i)}$  11. Output  $w_{1}\\coloneqq (z_{1},Z_{2},\\dots ,Z_{k})$</code></pre>

    <p class="text-gray-300">Extractor runtime. We will show that the extractor  <span class="math">\\mathcal{E}</span>  makes at most  <span class="math">1 + 1 / \\epsilon&#x27;(\\mathcal{A},\\mathcal{P}^<em>)</span>  calls to  <span class="math">\\mathcal{P}^</em></span>  in expectation. Since  <span class="math">\\epsilon&#x27;(\\mathcal{A},\\mathcal{P}^<em>) \\geq 1 / \\mathrm{poly}(\\lambda)</span> , we have that the extractor makes at most a polynomial number of calls to  <span class="math">\\mathcal{P}^</em></span>  in expectation. Hence, since  <span class="math">\\mathcal{K}</span>  and  <span class="math">\\mathcal{V}_1</span>  run in  <span class="math">\\mathrm{poly}(\\lambda)</span>  time, we have that overall the extractor runs in expected polynomial-time.</p>

    <p class="text-gray-300">By construction, the while loop (Item 3) terminates when the adversary  <span class="math">(\\mathcal{A},\\mathcal{P}^{<em>})</span>  succeeds. Since the relaxed success probability is  <span class="math">\\epsilon^{\\prime}(\\mathcal{A},\\mathcal{P}^{</em>})</span> , the while loop executes  <span class="math">1 / \\epsilon^{\\prime}(\\mathcal{A},\\mathcal{P}^{<em>})</span>  times in expectation. This implies the while loop performs  <span class="math">1 / \\epsilon^{\\prime}(\\mathcal{A},\\mathcal{P}^{</em>})</span>  calls to  <span class="math">\\mathcal{P}^{<em>}</span>  in expectation. Finally, Item 4 performs one call to  <span class="math">\\mathcal{P}^{</em>}</span> .</p>

    <p class="text-gray-300">Extractor success probability. First, we will show</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\operatorname {r e s u l t} ^ {\\prime} \\neq \\bot &amp;amp; \\mathrm {p p} \\leftarrow \\mathcal {G} \\left(1 ^ {\\lambda}, \\mathrm {s z}\\right) \\\\ \\wedge &amp;amp; (\\mathrm {s}, u _ {1}, \\mathrm {s t}) \\leftarrow \\mathcal {A} (\\mathrm {p p}) \\\\ w _ {2} = w _ {2} ^ {\\prime} &amp;amp; (\\mathrm {p k}, \\mathrm {v k}) \\leftarrow \\mathcal {K} (\\mathrm {p p}, \\mathrm {s}) \\\\ &amp;amp; w _ {1} \\leftarrow \\mathcal {E} (\\mathrm {p p}, \\mathrm {s}, u _ {1}, \\mathrm {s t}) \\end{array} \\right] \\geq \\epsilon^ {\\prime} (\\mathcal {A}, \\mathcal {P} ^ {*}) - \\operatorname {n e g l} (\\lambda). \\tag {34}</span></div>

    <p class="text-gray-300">Item 5 exactly checks that the simulated adversary in Item 4 succeeds. Thus, the event that  <span class="math">\\text{result}&#x27; \\neq \\bot</span>  occurs with probability  <span class="math">\\epsilon&#x27;(\\mathcal{A}, \\mathcal{P}^*)</span> . Assume that the event  <span class="math">\\text{result}&#x27; \\neq \\bot</span>  occurs. By (33),  <span class="math">w_2 \\neq w_2&#x27;</span>  with at most  <span class="math">\\text{negl}(\\lambda)</span>  probability. Thus, all together, we have (34) holds.</p>

    <p class="text-gray-300">Assume that the event  <span class="math">\\text{result}&#x27; \\neq \\bot \\wedge w_2 = w_2&#x27;</span>  occurs, which implies the extractor outputs a witness  <span class="math">w_1 := (z_1, Z_2, \\ldots, Z_k) \\neq \\bot</span>  (as the extractor passes the checks in Item 6 and Item 8). We will show that  <span class="math">(\\mathsf{pp}, \\mathsf{s}, u_1, w_1) \\notin \\mathcal{R}_1</span>  with probability at</p>

    <p class="text-gray-300">most <span class="math">\\mathsf{negl}(\\lambda)</span>. Hence,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ (\\mathsf{pp}, \\mathsf{s}, u_1, w_1) \\in \\mathcal{R}_1 \\begin{vmatrix} \\mathsf{pp} \\leftarrow \\mathcal{G}(1^\\lambda, \\mathsf{sz}) \\\\ (\\mathsf{s}, u_1, \\mathsf{st}) \\leftarrow \\mathcal{A}(\\mathsf{pp}) \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathcal{K}(\\mathsf{pp}, \\mathsf{s}) \\\\ w_1 \\leftarrow \\mathcal{E}(\\mathsf{pp}, \\mathsf{s}, u_1, \\mathsf{st}) \\end{vmatrix} \\right]</span></div>

    <p class="text-gray-300"><span class="math">\\geq \\left(\\epsilon&#x27;(\\mathcal{A},\\mathcal{P}^<em>) - \\mathsf{negl}(\\lambda)\\right) - \\mathsf{negl}(\\lambda) = \\epsilon&#x27;(\\mathcal{A},\\mathcal{P}^</em>) - \\mathsf{negl}(\\lambda).</span></p>

    <p class="text-gray-300">Since <span class="math">\\mathsf{result}&#x27; \\neq \\bot</span>, by construction (Item 5), we must have <span class="math">(\\mathsf{pp}, \\mathsf{s}, u_2&#x27;, w_2&#x27;) \\in \\mathcal{R}_2&#x27;</span> and during the simulation <span class="math">\\langle \\mathcal{P}_1^<em>, \\mathcal{V}_1 \\rangle((\\mathsf{pk}, \\mathsf{vk}), u_1, \\mathsf{st}^</em>)</span> in Item 4, the verifier <span class="math">\\mathcal{V}_1</span> did not abort. Namely, that the sum-check verifier in protocol (Item 2) did not abort and the evaluation checks Item 4 were satisfied. By definition of <span class="math">\\mathcal{R}_2&#x27; = \\mathsf{ME}(q/2, \\mathcal{L})^k</span>, we must know that for all <span class="math">i \\in [k]</span>, <span class="math">X_i := \\mathcal{L}_x(Z_i)</span> and <span class="math">c_i := \\mathcal{L}(Z_i)</span>. This also implies, by construction (Item 2 and Item 10), that <span class="math">X_1 := \\mathsf{Decomp}_b(x_1)</span> and <span class="math">c_1 = \\mathcal{L}(\\mathsf{Decomp}_b(z_1))</span>.</p>

    <p class="text-gray-300">Assume that <span class="math">(\\mathsf{pp}, \\mathsf{s}, u_1, w_1) \\notin \\mathcal{R}_1</span>. Recall that <span class="math">\\mathcal{R}_1 := \\mathsf{MCS}(b, \\mathcal{L}) \\times \\mathsf{ME}(b, \\mathcal{L})^{k-1}</span>. Since the commitments agree with the witnesses, we must have that <span class="math">(\\mathsf{pp}, \\mathsf{s}, u_1, w_1) \\notin \\mathcal{R}_1</span> implies that either (using notation from Lemma 11)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{F}(X_{[\\delta + 1, \\zeta]}) \\notin \\mathsf{ZS}_n</span> (identically, <span class="math">\\mathsf{F}(X_{[1,n]}) \\notin \\mathsf{ZS}_n</span>),</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. OR there exists an <span class="math">i \\in [k]</span> for which $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\geq b$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>OR there exists an <span class="math">i \\in [2, k]</span> for which <span class="math">\\widetilde{y}_{(i,j)}(\\mathbf{A}) \\neq \\widetilde{M}_{i,j}(\\mathbf{A}, r)</span> (identically, <span class="math">y_{(i,j)} = Z_i M_j^\\top \\widehat{r}</span>)</li>

    </ol>

    <p class="text-gray-300">By Lemma 11, we must have <span class="math">T \\neq \\sum_{x \\in \\{0,1\\}^\\zeta} Q(x, \\mathbf{A}, \\mathbf{B}, C)</span>. By the construction of the verifier's checks in Item 4 and definition of <span class="math">(\\mathsf{pp}, \\mathsf{s}, u_2&#x27;, w_2&#x27;) \\in \\mathcal{R}_2&#x27;</span>, we must have that the sum-check evaluation check <span class="math">v = Q(\\alpha&#x27;, r&#x27;)</span> is true. Note, that the randomness used in the second simulation of the protocol (Item 4) is fresh and independent of the first simulation of the protocol (Item 3). Additionally, note that the witness from the first execution, <span class="math">w_2</span>, agrees with the witness from the second execution, <span class="math">w_2&#x27; := (z_1, Z_2, \\ldots, Z_k)</span>. Thus, in order for the sum-check verifier to have passed, either the adversary <span class="math">\\mathcal{P}^*</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>violated the soundness of the sum-check protocol since <span class="math">T \\neq \\sum_{x \\in \\{0,1\\}^\\zeta} Q(x, \\mathbf{A}, \\mathbf{B}, C)</span></li>

      <li>OR the non-zero polynomial</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathrm{T} - \\sum_{x \\in \\{0,1\\}^\\zeta} Q(x, \\mathbf{A}, \\mathbf{B}, C)</span></div>

    <p class="text-gray-300">for <span class="math">\\mathrm{T} := C^k \\sum_{j=1, i=2}^{t,k} C^{i + (j-1)k-1} \\cdot \\widetilde{y}_{(i,j)}(\\mathbf{A})</span> evaluated to zero on random point <span class="math">(\\alpha \\in \\mathbb{K}^{\\log d}, \\beta \\in \\mathbb{K}^{\\log (dn)}, \\gamma \\in \\mathbb{K})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the soundness error of the sum-check protocol, the first event occurs with probability at most $\\epsilon_{\\mathsf{SC}} := \\max (u + 1, 2b + 1, 2) \\cdot \\log (dn) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. By the Schwartz-Zippel lemma, the second event occurs with probability at most </span>\\epsilon_{\\mathsf{SZ}} := \\max (\\log dn, (t + 1)k - 1) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Thus, all together, </span>(\\mathsf{pp}, \\mathsf{s}, u_1, w_1) \\notin \\mathcal{R}_1<span class="math"> with probability at most </span>\\mathsf{negl}(\\lambda) := \\epsilon_{\\mathsf{SC}} + \\epsilon_{\\mathsf{SZ}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Consider an arbitrary expected-polynomial time adversary  <span class="math">(\\mathcal{A},\\mathcal{P}^{<em>})</span>  for  <span class="math">\\Pi_{\\mathsf{RLC}}</span>  with success probability,  <span class="math">\\epsilon (\\mathcal{A},\\mathcal{P}^{</em>})\\geq 1 / \\mathsf{poly}(\\lambda)</span> . First, we can construct an adversary and verification function for Theorem 6,</p>

    <p class="text-gray-300"><span class="math">A_{(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})}(\\pmb {c}):</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Execute encoder  <span class="math">(\\mathsf{pk},\\mathsf{vk})\\gets \\mathcal{K}(\\mathsf{pp},\\mathsf{s})</span></li>

      <li>Simulate  <span class="math">(u_{2},w_{2})\\gets \\langle \\mathcal{P}^{*}(\\mathsf{pk},u_{1},\\mathsf{st}),\\mathcal{V}(\\mathsf{vk},u_{1})\\rangle</span>  with verifier randomness  <span class="math">c</span></li>

      <li>Output  <span class="math">w_{2}</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">V_{(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})}(\\pmb {c},w_2)\\to \\{0,1\\}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Execute encoder  <span class="math">(\\mathsf{pk},\\mathsf{vk})\\gets \\mathcal{K}(\\mathsf{pp},\\mathsf{s})</span></li>

      <li>Simulate  <span class="math">(u_{2},..)\\gets \\langle \\mathcal{P}^{*}(\\mathsf{pk},u_{1},\\mathsf{st}),\\mathcal{V}(\\mathsf{vk},u_{1})\\rangle</span>  with verifier randomness  <span class="math">c</span></li>

      <li>Output accept if and only if  <span class="math">(u_{2},w_{2})\\in \\mathsf{ME}(B,\\mathcal{L})</span></li>

    </ol>

    <p class="text-gray-300">Let  <span class="math">E_{(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})}</span>  be the corresponding extractor from Theorem 6. We define  <span class="math">E(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})</span>  as the trivial algorithm that executes  <span class="math">E_{(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})}</span>  by simulating calls to  <span class="math">A_{(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})}</span> . We construct an extractor for adversary  <span class="math">(\\mathcal{A},\\mathcal{P}^*)</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})</span>  ..</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>result  <span class="math">\\leftarrow E(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})</span></li>

      <li>If  <span class="math">u_{1} = \\bot</span>  or result  <span class="math">= \\bot</span> , output  <span class="math">\\bot</span> .</li>

      <li>Parse  <span class="math">(\\pmb {c},w_1^{\\prime}),(\\pmb {c}_1,w_1^{\\prime}),\\dots (\\pmb {c}_{k + 1},w_{k + 1}^{\\prime})\\gets</span>  result.</li>

      <li>Parse  <span class="math">\\rho_{1},\\ldots ,\\rho_{k + 1}\\gets c</span></li>

      <li>For  <span class="math">i\\in [k + 1]</span></li>

    </ol>

    <p class="text-gray-300">(a) Parse  <span class="math">\\rho_1^{(i)},\\ldots ,\\rho_{k + 1}^{(i)}\\gets c_i</span> (b) Parse  <span class="math">Z\\gets w_1^{\\prime}</span>  and  <span class="math">Z_{i}\\gets w_{i}^{\\prime}</span> (c) Assign  <span class="math">Z_{i}\\gets \\left(\\rho_{i} - \\rho_{i}^{(i)}\\right)^{-1}\\cdot (Z - Z^{(i)})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">(c_{i},X_{i},r,\\{y_{(i,j)}\\}_{j\\in [t]})_{i\\in [k + 1]}\\gets u_{1}</span></li>

      <li>Output  <span class="math">w_{1} \\coloneqq (Z_{i})_{i \\in [k + 1]}</span>  if and only if  <span class="math">(\\mathbf{s}; c_{i}, X_{i}, r, \\{y_{(i,j)}\\}_{j \\in [t]}; Z_{i})_{i \\in [k + 1]} \\in \\mathsf{ME}(q/2, \\mathcal{L})^{k + 1}</span></li>

    </ol>

    <p class="text-gray-300">Extractor runtime. By Theorem 6, we are guaranteed  <span class="math">E_{(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})}</span>  makes in expectation at most  <span class="math">k + 2</span>  calls to  <span class="math">A_{(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})}</span> . Hence, our overall extractor  <span class="math">\\mathcal{E}</span>  runs in expected polynomial time.</p>

    <p class="text-gray-300">Extractor success probability. By Theorem 6, we are guaranteed that  <span class="math">E(\\mathsf{pp}, \\mathsf{s}, u_1, \\mathsf{st})</span>  outputs  <span class="math">k + 2</span>  pairs  <span class="math">(\\pmb{c}, w_1&#x27;), (\\pmb{c}_1, w_1&#x27;), \\dots, (\\pmb{c}_{k+1}, w_{k+1}&#x27;)</span>  such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">V(\\pmb{c}, w_1&#x27;) = 1</span> ,</li>

      <li>for all  <span class="math">i \\in [k + 1]</span> ,  <span class="math">V(\\pmb{c}_i, w_i&#x27;) = 1</span> , and</li>

      <li><span class="math">(\\pmb{c}, \\pmb{c}_1, \\dots, \\pmb{c}_{k+1}) \\in \\mathsf{SS}(\\mathcal{C}, k+1)</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">with probability  $\\epsilon^{V_{(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})}}(A_{(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})}) - \\frac{k + 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> . Since  </span>A_{(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})}<span class="math">  and  </span>V_{(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})}<span class="math">  simulate the interaction between  </span>\\mathcal{P}^*<span class="math">  and  </span>\\mathcal{V}<span class="math">  and checks if the output pair  </span>(u_2,w_1')<span class="math">  belongs to  </span>\\mathsf{ME}(B,\\mathcal{L})<span class="math"> , we must have  </span>\\epsilon^{V_{(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})}}(A_{(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})}) - \\frac{k + 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\epsilon (\\mathcal{A},\\mathcal{P}^*) -$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(k + 1) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Assume that this event occurs. Since </span>V(\\pmb{c}, w_1') = 1<span class="math">, by construction of </span>\\Pi_{\\mathsf{RLC}}$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c c} c = \\sum_{i=1}^{k+1} \\rho_i c_i, &amp;amp; \\\\ s; \\quad X = \\sum_{i=1}^{k+1} \\rho_i X_i, &amp;amp; \\\\ r, &amp;amp; \\\\ \\left\\{y_j = \\sum_{i=1}^{k+1} \\rho_i y_{(i,j)} \\right\\}_{j \\in [t]} &amp;amp; \\end{array} ; Z \\right) \\in \\mathsf{ME}(B, \\mathcal{L}) \\tag{35}</span></div>

    <p class="text-gray-300">Furthermore, since <span class="math">V(\\pmb{c}_i, w_i&#x27;) = 1</span>, we have for all <span class="math">i \\in [k+1]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c c} c^{(i)} = \\sum_{i=1}^{k+1} \\rho_i^{(i)} c_i, &amp;amp; \\\\ s; \\quad X^{(i)} = \\sum_{i=1}^{k+1} \\rho_i^{(i)} X_i, &amp;amp; \\\\ r, &amp;amp; \\\\ \\left\\{y_j^{(i)} = \\sum_{i=1}^{k+1} \\rho_i^{(i)} y_{(i,j)} \\right\\}_{j \\in [t]} &amp;amp; \\end{array} ; Z^{(i)} \\right) \\in \\mathsf{ME}(B, \\mathcal{L}) \\tag{36}</span></div>

    <p class="text-gray-300">Since <span class="math">(\\pmb{c}, \\pmb{c}_1, \\dots, \\pmb{c}_{k+1}) \\in \\mathsf{SS}(\\mathcal{C}, k+1)</span>, we must have for all <span class="math">i \\in [k+1]</span> that</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\rho_1, \\dots, \\rho_{k+1}\\right) \\equiv_i \\left(\\rho_1^{(i)}, \\dots, \\rho_{k+1}^{(i)}\\right) \\tag{37}</span></div>

    <p class="text-gray-300">which means the challenges differ only on index <span class="math">i</span>. Thus, we have for all <span class="math">i \\in [k+1]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{k+1} \\rho_i c_i - \\sum_{i=1}^{k+1} \\rho_i^{(i)} c_i = \\mathcal{L}(Z) - \\mathcal{L}\\big(Z^{(i)}\\big),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{k+1} \\rho_i X_i - \\sum_{i=1}^{k+1} \\rho_i^{(i)} X_i = \\mathcal{L}_x(Z) - \\mathcal{L}_x\\big(Z^{(i)}\\big) \\tag{38}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\rho_i - \\rho_i^{(i)}\\right) \\cdot c_i = \\mathcal{L}(Z) - \\mathcal{L}\\big(Z^{(i)}\\big),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\rho_i - \\rho_i^{(i)}\\right) \\cdot X_i = \\mathcal{L}_x(Z) - \\mathcal{L}_x\\big(Z^{(i)}\\big) \\tag{39}</span></div>

    <div class="my-4 text-center"><span class="math-block">c_i = \\mathcal{L}\\Big(\\big(\\rho_i - \\rho_i^{(i)}\\big)^{-1} \\cdot \\big(Z - Z^{(i)}\\big)\\Big),</span></div>

    <div class="my-4 text-center"><span class="math-block">X_i = \\mathcal{L}_x\\Big(\\big(\\rho_i - \\rho_i^{(i)}\\big)^{-1} \\cdot \\big(Z - Z^{(i)}\\big)\\Big) \\tag{40}</span></div>

    <div class="my-4 text-center"><span class="math-block">c_i = \\mathcal{L}(Z_i), \\qquad X_i = \\mathcal{L}_x(Z_i)</span></div>

    <p class="text-gray-300">where equation (38) follows from the definition of <span class="math">\\mathsf{ME}(B, \\mathcal{L})</span> and both (35) and (36). Equation (39) follows from the equivalence (37). Equation (40) follows from <span class="math">\\mathcal{L}, \\mathcal{L}_x</span> being <span class="math">S</span>-homomorphisms and <span class="math">\\mathcal{C} \\subseteq S</span> being a strong sampling set (Definition 14) which because <span class="math">\\rho_i \\neq \\rho_i^{(i)}</span> (guaranteed by (37)) means <span class="math">\\rho_i - \\rho_i^{(i)}</span> is invertible. Similarly, we must have for all <span class="math">i \\in [k+1]</span> and <span class="math">j \\in [t]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{k+1} \\rho_i y_{(i,j)} - \\sum_{i=1}^{k+1} \\rho_i^{(i)} y_{(i,j)} = Z M_j^\\intercal \\widehat{r} - Z^{(i)} M_j^\\intercal \\widehat{r} \\tag{41}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\rho_i - \\rho_i^{(i)}\\right) \\cdot y_{(i,j)} = \\left(Z - Z^{(i)}\\right) M_j^\\intercal \\widehat{r} \\tag{42}</span></div>

    <div class="my-4 text-center"><span class="math-block">y_{(i,j)} = \\left(\\rho_i - \\rho_i^{(i)}\\right)^{-1} \\cdot \\left(Z - Z^{(i)}\\right) M_j^\\intercal \\widehat{r} = Z_i M_j^\\intercal \\widehat{r} \\tag{43}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where equation (41) follows from the definition of  <span class="math">\\mathsf{ME}(B,\\mathcal{L})</span>  and both (35) and (36), equations (42) follow from the equivalence (37), and (43) follows from  <span class="math">\\mathcal{C} \\subseteq \\mathcal{S}</span>  being a strong sampling set (Definition 14) which because  <span class="math">\\rho_{i} \\neq \\rho_{i}^{(i)}</span>  (guaranteed by (37)) means  <span class="math">\\rho_{i} - \\rho_{i}^{(i)}</span>  is invertible. Therefore, by (40) and (43), we must have with probability  $\\epsilon(\\mathcal{A},\\mathcal{P}^{*}) - (k + 1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , the extractor outputs  </span>Z_{1},\\ldots,Z_{k + 1}<span class="math">  such that  </span>(\\mathsf{s}; c_{i}, X_{i}, r, \\{y_{(i,j)}\\}_{j \\in [t]}; Z_{i})_{i \\in [k + 1]} \\in \\mathsf{ME}(q/2,\\mathcal{L})^{k + 1}<span class="math"> , which has the trivial norm bound of  </span>q/2$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now, assume that  <span class="math">\\mathcal{A} \\coloneqq (\\mathcal{B}, \\mathcal{B}&#x27;)</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} u _ {1}, u _ {1} ^ {\\prime} \\neq \\bot &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, \\mathsf {s z}) \\\\ \\Downarrow &amp;amp; (\\mathsf {s}, \\mathsf {s t} ^ {*}) \\leftarrow \\mathcal {B} (\\mathsf {p p}) \\\\ \\phi (u _ {1}) = \\phi (u _ {1} ^ {\\prime}) &amp;amp; (u _ {1}, \\mathsf {s t}) \\leftarrow \\mathcal {B} ^ {\\prime} (\\mathsf {s t} ^ {*}) \\\\ &amp;amp; (u _ {1} ^ {\\prime}, \\mathsf {s t} ^ {\\prime}) \\leftarrow \\mathcal {B} ^ {\\prime} (\\mathsf {s t} ^ {*}) \\end{array} \\right] = 1</span></div>

    <p class="text-gray-300">We will show that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, \\mathsf {s z}) \\\\ &amp;amp; (\\mathsf {s}, \\mathsf {s t} ^ {*}) \\leftarrow \\mathcal {B} (\\mathsf {p p}) \\\\ w _ {1}, w _ {1} ^ {\\prime} \\neq \\bot &amp;amp; (u _ {1}, \\mathsf {s t}) \\leftarrow \\mathcal {B} ^ {\\prime} (\\mathsf {s t} ^ {*}) \\\\ \\wedge w _ {1} \\neq w _ {1} ^ {\\prime} &amp;amp; w _ {1} \\leftarrow \\mathcal {E} (\\mathsf {p p}, \\mathsf {s}, u _ {1}, \\mathsf {s t}) \\\\ &amp;amp; (u _ {1} ^ {\\prime}, \\mathsf {s t} ^ {\\prime}) \\leftarrow \\mathcal {B} ^ {\\prime} (\\mathsf {s t} ^ {*}) \\\\ &amp;amp; w _ {1} ^ {\\prime} \\leftarrow \\mathcal {E} (\\mathsf {p p}, \\mathsf {s}, u _ {1} ^ {\\prime}, \\mathsf {s t} ^ {\\prime}) \\end{array} \\right] \\leq \\epsilon_ {\\mathsf {b i n d}} (d, m, 2 B, \\mathcal {C})</span></div>

    <p class="text-gray-300">Assume that the event  <span class="math">w_{1}, w_{1}^{\\prime} \\neq \\bot \\land w_{1} \\neq w_{1}^{\\prime}</span>  occurs. Since  <span class="math">w_{1}, w_{1}^{\\prime} \\neq \\bot</span> , we have that  <span class="math">u_{1}, u_{1}^{\\prime} \\neq \\bot</span> , since the extractor would have failed otherwise. Thus, we must have that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\phi(u_1) = \\phi(u_1&#x27;)</span> , which guarantees the instances share identical commitments  <span class="math">(c_i)_{i \\in [j]}</span> .</li>

      <li>Define  <span class="math">(f_i)_{i\\in [k + 1]} = w_1</span>  and  <span class="math">(f_i&#x27;)_{i\\in [k + 1]} = w_1&#x27;</span> . Then,  <span class="math">w_{1}\\neq w_{1}^{\\prime}</span>  implies that there exist an  <span class="math">i\\in [k + 1]</span>  such that  <span class="math">f_{i}\\neq f_{i}^{\\prime}</span> .</li>

    </ol>

    <p class="text-gray-300">During the execution of  <span class="math">\\mathcal{E}(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})</span> , the call to algorithm  <span class="math">E(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})</span>  produces  <span class="math">\\rho_{i},\\rho_{i}^{(i)},Z,Z^{(i)}</span>  and  <span class="math">\\mathcal{E}(\\mathsf{pp},\\mathsf{s}&#x27;,u_1&#x27;,\\mathsf{st}&#x27;)</span> , the call to algorithm  <span class="math">E(\\mathsf{pp},\\mathsf{s}&#x27;,u_1&#x27;,\\mathsf{st}&#x27;)</span>  produces  <span class="math">\\rho_i&#x27;,\\rho_i^{(i)&#x27;}</span> ,  <span class="math">Z^{\\prime},Z^{(i)&#x27;}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} f _ {i} \\neq f _ {i} ^ {\\prime} \\Longleftrightarrow \\left(\\rho_ {i} - \\rho_ {i} ^ {(i)}\\right) ^ {- 1} \\cdot \\left(Z - Z ^ {(i)}\\right) \\neq \\left(\\rho_ {i} ^ {\\prime} - \\rho_ {i} ^ {(i) \\prime}\\right) ^ {- 1} \\cdot \\left(Z ^ {\\prime} - Z ^ {(i) \\prime}\\right) \\quad (44) \\\\ \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty}, \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z ^ {(i)} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty}, \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z ^ {\\prime} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty}, \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z ^ {(i) \\prime} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} &lt;   B \\quad (45) \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where (44) follows from Item 2 and (45) follows from Theorem 6, which guarantees the verification function  <span class="math">V_{(\\mathsf{pp},\\mathsf{s},u_1,\\mathsf{st})}</span>  accepts (by construction, this verification function checks if the output tuples belong to  <span class="math">\\mathsf{ME}(B,\\mathcal{L})</span> , which checks the output witnesses have norm bound  <span class="math">B</span> ). By Item 1 and (40), we must have</p>

    <div class="my-4 text-center"><span class="math-block">c _ {i} = \\mathcal {L} \\Big (\\big (\\rho_ {i} - \\rho_ {i} ^ {(i)} \\big) ^ {- 1} \\cdot \\big (Z - Z ^ {(i)} \\big) \\Big) = \\mathcal {L} \\Big (\\big (\\rho_ {i} ^ {\\prime} - \\rho_ {i} ^ {(i) \\prime} \\big) ^ {- 1} \\cdot \\big (Z ^ {\\prime} - Z ^ {(i) \\prime} \\big) \\Big)</span></div>

    <p class="text-gray-300">Thus, since <span class="math">\\mathcal{L}</span> is a <span class="math">\\mathcal{S}</span>-homomorphism, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\rho_ {i} - \\rho_ {i} ^ {(i)}\\right) \\cdot c _ {i} = \\mathcal {L} \\left(Z - Z ^ {(i)}\\right) \\wedge \\left(\\rho_ {i} ^ {\\prime} - \\rho_ {i} ^ {(i) \\prime}\\right) \\cdot c _ {i} = \\mathcal {L} \\left(Z ^ {\\prime} - Z ^ {(i) \\prime}\\right) \\tag {46}</span></div>

    <p class="text-gray-300">All together, by (44), (45), and (46), we have that <span class="math">(c_{i},\\varDelta_{1}=\\rho_{i}-\\rho_{i}^{(i)},\\varDelta_{2}=\\rho_{i}^{\\prime}-\\rho_{i}^{(i)\\prime},Z_{1}=Z-Z^{(i)},Z_{2}=Z^{\\prime}-Z^{(i)\\prime})</span> is a <span class="math">2B</span>-relaxed binding collision. Thus, the probability of the original event must be less than or equal to <span class="math">\\epsilon_{\\mathrm{bind}}(d,m,2B,\\mathcal{C})</span>. Otherwise, we could construct a corresponding relaxed-binding adversary which executes the extractor <span class="math">\\mathcal{E}</span> twice to retrieve the corresponding elements for the <span class="math">2B</span>-relaxed binding collision with probability greater than <span class="math">\\epsilon_{\\mathrm{bind}}(d,m,2B,\\mathcal{C})</span>.</p>

    <h2 id="sec-75" class="text-2xl font-bold">B.10 Proof of Theorem 5</h2>

    <p class="text-gray-300">Proof. Consider an arbitrary expected polynomial-time adversary <span class="math">(\\mathcal{A},\\mathcal{P}^{<em>})</span> for the composition <span class="math">\\Pi \\coloneqq \\Pi_2\\circ \\Pi_1</span> with success probability <span class="math">\\epsilon (\\mathcal{A},\\mathcal{P}^{</em>})\\geq 1 / \\mathrm{poly}(\\lambda)</span>. Without loss of generality, the adversary <span class="math">\\mathcal{P}^<em></span> can be split into two adversaries <span class="math">(\\mathcal{P}_1^</em>,\\mathcal{P}_2^*)</span> such that given <span class="math">\\mathsf{pp}\\gets \\mathcal{G}(1^{\\lambda})</span>, <span class="math">(\\mathsf{s},u_{1},\\mathsf{st}_{1})\\gets \\mathcal{A}(\\mathsf{pp})</span>, and <span class="math">(\\mathsf{pk},\\mathsf{vk})\\gets \\mathcal{K}(\\mathsf{pp},\\mathsf{s})</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} - \\langle \\mathcal {P} _ {1} ^ {*}, \\mathcal {V} _ {1} \\rangle ((\\mathsf {p k}, \\mathsf {v k}), u _ {1}, \\mathsf {s t} _ {1}) \\rightarrow (u _ {2}, \\mathsf {s t} _ {2}) \\\\ - \\langle \\mathcal {P} _ {2} ^ {*}, \\mathcal {V} _ {2} \\rangle ((\\mathsf {p k}, \\mathsf {v k}), u _ {2}, \\mathsf {s t} _ {2}) \\rightarrow (u _ {3}, u _ {3}) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Furthermore, we assume that <span class="math">\\mathcal{A}</span> outputs <span class="math">\\mathsf{st}_1</span> which contains <span class="math">(\\mathsf{s},\\mathsf{pp})</span>; otherwise, we could trivially construct an adversary <span class="math">\\mathcal{A}&#x27;</span> with an identical distribution of prior outputs that does so. First, we construct an adversary <span class="math">\\mathcal{A}_2\\coloneqq (\\mathcal{B}_2,\\mathcal{B}_2&#x27;)</span> for <span class="math">\\Pi_2</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathcal {B} _ {2} (\\mathsf {p p}) \\rightarrow (\\mathsf {s}, \\mathsf {s t} ^ {*}): \\\\ 1. \\quad (\\mathsf {s}, u _ {1}, \\mathsf {s t} _ {1}) \\leftarrow A (\\mathsf {p p}). \\\\ 2. \\quad \\text {Output} (\\mathsf {s}, \\mathsf {s t} _ {1}). \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {B} _ {2} ^ {\\prime} \\left(\\mathrm {s t} ^ {*}\\right)\\rightarrow \\left(u _ {2}, \\mathrm {s t} _ {2}\\right):</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\mathsf{st}^*</span> to obtain (s, pp).</li>

      <li><span class="math">(\\mathsf{pk},\\mathsf{vk})\\gets \\mathcal{K}(\\mathsf{pp},\\mathsf{s})</span></li>

      <li>Simulate <span class="math">(u_{2},\\mathsf{st}_{2})\\gets \\langle \\mathcal{P}_{1}^{<em>},\\mathcal{V}_{1}\\rangle ((\\mathsf{pk},\\mathsf{vk}),u_{1},\\mathsf{st}^{</em>})</span></li>

      <li>Output <span class="math">(u_{2},\\mathsf{st}_{2})</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">A _ {2} (\\mathsf {p p}) \\rightarrow (\\mathsf {s}, u _ {2}, \\mathsf {s t} _ {2}):</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{s},\\mathsf{st}^{*})\\gets \\mathcal{B}_{2}(\\mathsf{pp})</span></li>

      <li><span class="math">(u_{2},\\mathsf{st}_{2})\\gets \\mathcal{B}_{2}^{\\prime}(\\mathsf{st}^{*})</span></li>

      <li>Output <span class="math">(s, u_2, st_2)</span>.</li>

    </ol>

    <p class="text-gray-300">Observe that, by construction, the success probability <span class="math">\\epsilon (\\mathcal{A}_2,\\mathcal{P}_2^<em>)</span> of adversary <span class="math">(\\mathcal{A}_2,\\mathcal{P}_2^</em>)</span> for <span class="math">\\Pi_2</span> is equal to the success probability <span class="math">\\epsilon (\\mathcal{A},\\mathcal{P}^{<em>})</span> of adversary <span class="math">(\\mathcal{A},\\mathcal{P}^{</em>})</span> for <span class="math">\\Pi</span>. Since <span class="math">\\Pi_1</span> is <span class="math">\\phi</span>-restricted, we must have</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} u _ {2}, u _ {2} ^ {\\prime} \\neq \\bot &amp;amp; \\mathrm {p p} \\leftarrow \\mathcal {G} \\left(1 ^ {\\lambda}, \\mathrm {s z}\\right) \\\\ \\Downarrow &amp;amp; (\\mathrm {s}, \\mathrm {s t} ^ {*}) \\leftarrow \\mathcal {B} _ {2} (\\mathrm {p p}) \\\\ \\phi (u _ {2}) = \\phi (u _ {2} ^ {\\prime}) &amp;amp; \\left(u _ {2}, \\mathrm {s t} _ {2}\\right) \\leftarrow \\mathcal {B} _ {2} ^ {\\prime} \\left(\\mathrm {s t} ^ {*}\\right) \\\\ &amp;amp; \\left(u _ {2} ^ {\\prime}, \\mathrm {s t} _ {2} ^ {\\prime}\\right) \\leftarrow \\mathcal {B} _ {2} ^ {\\prime} \\left(\\mathrm {s t} ^ {*}\\right) \\end{array} \\right] = 1, \\tag {47}</span></div>

    <p class="text-gray-300">Thus, we have by (47) and the <span class="math">\\phi</span>-relaxed knowledge soundness of <span class="math">\\Pi_2</span> that there exists an expected polynomial-time extractor <span class="math">\\mathcal{E}_2</span> such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ (\\mathsf{pp}, \\mathsf{s}, u_2, w_2) \\in \\mathcal{R}_2' \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf{pp} \\leftarrow \\mathcal{G}(1^\\lambda, \\mathsf{sz}) \\\\ (\\mathsf{s}, u_2, \\mathsf{st}_2) \\leftarrow \\mathcal{A}_2(\\mathsf{pp}) \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathcal{K}(\\mathsf{pp}, \\mathsf{s}) \\\\ w_2 \\leftarrow \\mathcal{E}_2(\\mathsf{pp}, \\mathsf{s}, u_2, \\mathsf{st}_2) \\end{array} \\right. \\right] \\geq \\epsilon(\\mathcal{A}, \\mathcal{P}^*) - \\mathsf{negl}(\\lambda) \\tag{48}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\mathsf{pp} \\leftarrow \\mathcal{G}(1^\\lambda, \\mathsf{sz}) \\\\ w_2, w_2&#x27; \\neq \\bot &amp;amp; (\\mathsf{s}, \\mathsf{st}^*) \\leftarrow \\mathcal{B}_2(\\mathsf{pp}) \\\\ \\wedge w_2 \\neq w_2&#x27; &amp;amp; (u_2, \\mathsf{st}) \\leftarrow \\mathcal{B}_2&#x27;(\\mathsf{st}^*) \\\\ &amp;amp; w_2 \\leftarrow \\mathcal{E}_2(\\mathsf{pp}, \\mathsf{s}, u_2, \\mathsf{st}) \\\\ &amp;amp; (u_2&#x27;, \\mathsf{st}&#x27;) \\leftarrow \\mathcal{B}_2&#x27;(\\mathsf{st}^*) \\\\ &amp;amp; w_2&#x27; \\leftarrow \\mathcal{E}_2(\\mathsf{pp}, \\mathsf{s}, u_2&#x27;, \\mathsf{st}&#x27;) \\end{array} \\right] \\leq \\mathsf{negl}(\\lambda) \\tag{49}</span></div>

    <p class="text-gray-300">Next, we will construct an adversary <span class="math">\\mathcal{P}_1^{**}</span> for <span class="math">\\Pi_1</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_1^{**}(\\mathsf{pk}, u_1, \\mathsf{st}_1) \\to w_2</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\mathsf{st}_1</span> to obtain <span class="math">(\\mathsf{s}, \\mathsf{pp})</span>.</li>

      <li><span class="math">(\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathcal{K}(\\mathsf{pp}, \\mathsf{s})</span>.</li>

      <li>Simulate <span class="math">(u_2, \\mathsf{st}_2) \\leftarrow \\langle \\mathcal{P}_1^*, \\mathcal{V}_1 \\rangle((\\mathsf{pk}, \\mathsf{vk}), u_1, \\mathsf{st}_1)</span>.</li>

      <li><span class="math">w_2 \\leftarrow \\mathcal{E}_2(\\mathsf{pp}, \\mathsf{s}, u_2, \\mathsf{st}_2)</span>.</li>

      <li>Output <span class="math">w_2</span>.</li>

    </ol>

    <p class="text-gray-300">Observe that, by construction, the relaxed success probability <span class="math">\\epsilon&#x27;(\\mathcal{A}, \\mathcal{P}_1^{<strong>})</span> of adversary <span class="math">(\\mathcal{A}, \\mathcal{P}_1^{</strong>})</span> for <span class="math">\\Pi_1</span> is equal to <span class="math">\\epsilon(\\mathcal{A}, \\mathcal{P}^*) - \\mathrm{negl}(\\lambda) \\geq 1 / \\mathrm{poly}(\\lambda)</span> which is the success probability of the relaxed extractor <span class="math">\\mathcal{E}_2</span> from equation (48). Furthermore, by equation (49) and construction of <span class="math">(\\mathcal{B}_2, \\mathcal{B}_2&#x27;)</span>, we must have that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} w_2, w_2&#x27; \\neq \\bot &amp;amp; \\mathsf{pp} \\leftarrow \\operatorname{Gen}(1^\\lambda) \\\\ \\wedge &amp;amp; (\\mathsf{s}, u_1, \\mathsf{st}_1) \\leftarrow \\mathcal{A}(\\mathsf{pp}) \\\\ w_2 \\neq w_2&#x27; &amp;amp; (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathcal{K}(\\mathsf{pp}, \\mathsf{s}) \\\\ &amp;amp; (u_2, w_2) \\leftarrow \\langle \\mathcal{P}_1^{**}, \\mathcal{V} \\rangle((\\mathsf{pk}, \\mathsf{vk}), u_1, \\mathsf{st}_1) \\\\ &amp;amp; (u_2&#x27;, w_2&#x27;) \\leftarrow \\langle \\mathcal{P}_1^{**}, \\mathcal{V} \\rangle((\\mathsf{pk}, \\mathsf{vk}), u_1, \\mathsf{st}_1) \\end{array} \\right] \\leq \\mathsf{negl}(\\lambda) \\tag{50}</span></div>

    <p class="text-gray-300">Thus, we have by (50) and the restricted knowledge soundness of <span class="math">\\Pi_1</span> that there exists an expected polynomial-time extractor <span class="math">\\mathcal{E}_1</span> such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ (\\mathsf{pp}, \\mathsf{s}, u_1, w_1) \\in \\mathcal{R}_1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf{pp} \\leftarrow \\mathcal{G}(1^\\lambda, \\mathsf{sz}) \\\\ (\\mathsf{s}, u_1, \\mathsf{st}_1) \\leftarrow \\mathcal{A}(\\mathsf{pp}) \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathcal{K}(\\mathsf{pp}, \\mathsf{s}) \\\\ w_1 \\leftarrow \\mathcal{E}_1(\\mathsf{pp}, \\mathsf{s}, u_1, \\mathsf{st}_1) \\end{array} \\right. \\right] \\geq \\epsilon(\\mathcal{A}, \\mathcal{P}^*) - \\mathsf{negl}(\\lambda) \\tag{51}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">In conclusion, we have constructed an extractor <span class="math">\\mathcal{E} \\coloneqq \\mathcal{E}_1</span> with respect to adversary <span class="math">(\\mathcal{A}, \\mathcal{P}^*)</span> such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ (\\mathsf{pp}, \\mathsf{s}, u_1, w_1) \\in \\mathcal{R}_1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf{pp} \\leftarrow \\mathcal{G}(1^\\lambda, \\mathsf{sz}) \\\\ (\\mathsf{s}, u_1, \\mathsf{st}_1) \\leftarrow \\mathcal{A}(\\mathsf{pp}) \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathcal{K}(\\mathsf{pp}, \\mathsf{s}) \\\\ w_1 \\leftarrow \\mathcal{E}(\\mathsf{pp}, \\mathsf{s}, u_1, \\mathsf{st}_1) \\end{array} \\right. \\geq \\epsilon(\\mathcal{A}, \\mathcal{P}^*) - \\mathsf{negl}(\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Thus, <span class="math">\\Pi:=\\Pi_{2}\\circ\\Pi_{1}</span> is knowledge sound. ∎</p>

    <h3 id="sec-76" class="text-xl font-semibold mt-8">B.11 Finding choices of cyclotomic and fields</h3>

    <pre><code class="language-text"># [LS18, eprint 2017-523] pg 6
# m is the cyclotomic polynomial index
def tau(m):
return m if (m % 2) != 0 else m / 2

# [LS18, eprint 2017-523] Thm 1.1, pg 4
# m is the cyclotomic polynomial index
# p is the prime
# z is any divisor of m
# This tests for the condition for thm 1.1 to hold
def thm1_1_cond(m, p, z):
cond1 = (p % z) == 1
cond2 = Mod(p,m).multiplicative_order() == m/z
return cond1 and cond2

# [LS18, eprint 2017-523] Thm 1.1, pg 4
# p is the prime
# z is any divisor of m
# lInf bound for elements to be invertible
# given that m,p,z satisfy thm 1.1 cond
def thm1_1_inv_bound(p, z):
return (1/s1(z)*p^(1/euler_phi(z))).n()

def thm1_1_num_factors(z):
return euler_phi(z)

# Output divisors of m
def divisors(m):
zs = list()
for i in range(1,m+1):
if m % i == 0:
zs.append(i)
return zs

# [LS18, eprint 2017-523] pg 6, pg 9
# We only consider prime power cyclotomics
# m is the cyclotomic polynomial index
def s1(m):
return sqrt(tau(m))

# checks if cyclotomic index m is power of two
def is_pow2(m):
return sum(m.digits(2)) == 1

# [MR09] lattice-based cryptography

# makes sure characteristic does not lead
# to trivial bound
def non_trivial(q, n, d, delta):
return (q/2).n() &gt;= (2^(2 * sqrt( n*d * log(q,2) * log(delta, 2)))).n()

# [AL21] eprint Prop 2. 2021/202
# for all u,v in R, |u*v| / |v| &lt;= gamma*|u|
# outputs T = gamma * |u|
# assumes we are only testing prime powers
def expansion_factor(m, norm):
if is_pow2(m):
return euler_phi(m) * norm
else:
return 2 * euler_phi(m) * norm

# p is prime
# max_idx is max cyclotomic index
# outputs list of (m, z)
def candidates(p, min_idx=10, max_idx=200):
# prime powers
possible_indices = [i for i in range(min_idx, max_idx) if len(factor(i)) == 1]
c = list()
for m in possible_indices:
zs = divisors(m)
for z in zs:
if thm1_1_cond(m, p, z):
c.append((Integer(m), Integer(z)))
return c

def pre_filter(q, cyclotomic_index, z, n, m, chals):
chals_norm = max({abs(c) for c in chals})
chals_max_diff = chals[-1] - chals[0]
delta = 1.0045 # root hermite factor, chosen from [ESSLL19] eprint 2018/773
phi = cyclotomic_polynomial(cyclotomic_index) # index cyclotomic polynomial
d = phi.degree() # degree of cyclotomic

# return non_trivial(q, n, d, delta) and chals_max_diff &lt; thm1_1_inv_bound(q, z) and log(len(chals)^d, 2).n() &gt;= 120

def info(q, cyclotomic_index, z, n, m, chals):
chals_norm = max({abs(c) for c in chals})
chals_max_diff = chals[-1] - chals[0]
delta = 1.0045 # root hermite factor, chosen from [ESSLL19] eprint 2018/773
phi = cyclotomic_polynomial(cyclotomic_index) # index cyclotomic polynomial
d = phi.degree() # degree of cyclotomic
T = expansion_factor(cyclotomic_index, chals_norm)

# Bounds for MSIS to be hard
# [MR09] lattice-based cryptography pg 6

# [CMNW24] pg 38 eprint 2024/281
MSIS_B_l2_bound = min(q, 2^(2 * sqrt( n*d * log(q,2) * log(delta, 2))))
MSIS_B_linf_bound = MSIS_B_l2_bound / sqrt(m*d)

# We need MSIS infinity bound 8TB to be hard
B = MSIS_B_linf_bound / (8*T)

print(”####“)
print(”Cyclotomic idx:”, cyclotomic_index)
print(”Cyclotomic Poly:”, phi)
print(”z:”, z)
#print(”Prime is non-trivial?”, non_trivial(q, n, d, delta))
print(”Csmall norm is small enough?”, chals_max_diff &lt; thm1_1_inv_bound(q, z))
print(”Csmall large enough?”, log(len(chals)^d,2).n() &gt;= 120)
print(”Degree of Cyclotomic:”, d)
# print(”log(B):”, log(B, 2).n())
print(”Expansion Factor T:”, T)
print(”Invertible Norm bound:”, thm1_1_inv_bound(q, z))
print(”log(|C_Small|):”, log(len(chals)^d,2).n())
print(”Factors of Cyclotomic:”, thm1_1_num_factors(z))
print()

def possible_settings(q, n, m, chals):
for (cyclotomic_index, z) in candidates(q):
if pre_filter(q, cyclotomic_index, z, n, m, chals):
info(q, cyclotomic_index, z, n, m, chals)
else:
delta = 1.0045
d = cyclotomic_polynomial(cyclotomic_index).degree()
print(&quot;[Does not satisfy security requirements] index: {}, degree: {}, z: {}, non_trivial

# Primes:
GL = 2^64 - 2^32 + 1
AGL = GL - 32
print(”####################################“)
print(”AGL ####################################“)
print(”####################################“)
# MSIS settings
n = 13 # rows, kappa in latticefold
m = 2^26 # cols
# Small Challenge set
chals = [-1, 0, 1, 2]
possible_settings(AGL, n, m, chals)
print(”####################################“)
print(”M61 ####################################“)
print(”####################################“)
# MSIS settings
n = 16 # rows, kappa in latticefold
m = 2^22 # cols
# Small Challenge set

chals = [-2, -1, 0, 1, 2]
possible_settings(2^61-1, n, m, chals)
print(&quot;########################################&quot;)
print(&quot;GL ########################################&quot;)
print(&quot;########################################&quot;)
# MSIS settings
n = 16 # rows, kappa in latticefold
m = 2^24 # cols
# Small Challenge set
chals = [-2, -1, 0, 1, 2]
possible_settings(GL, n, m, chals)
print(&quot;########################################&quot;)

### B.12 Lattice Estimator Script
</code></pre>

    <p class="text-gray-300">from estimator import * Logging.set_level(Logging.LEVELO)</p>

    <p class="text-gray-300">M61 = 2^61 -1 GL = 2^64 - 2^32 +1 AGL = GL - 32</p>

    <p class="text-gray-300">n = 13 d = 64 T = 128 k = 11 b = 2 B = b^k m = 2^26 q = AGL</p>

    <p class="text-gray-300">n_sis = n<em>d m_sis = m</em>d B_l2 = sqrt(m<em>d)</em>(8<em>T</em>B)</p>

    <p class="text-gray-300">params = SIS.Parameters(n=n_sis, q=q, m=m_sis,length_bound=B_l2, norm=2) _ = SIS.estimate(params) print((k+1)<em>T</em>(b-1) < B)</p>

    <p class="text-gray-300">n = 16 d = 54 T = 216 k = 12 b = 2 B = b^k m = 2^22 q = M61</p>

    <p class="text-gray-300">n_sis = n*d</p>

    <p class="text-gray-300">m_sis = m<em>d B_12 = sqrt(m</em>d)<em>(8</em>T*B)</p>

    <p class="text-gray-300">params = SIS.Parameters(n=n_sis, q=q, m=m_sis,length_bound=B_12, norm=2) _ = SIS.estimate(params) print((k+1)<em>T</em>(b-1) < B)</p>

    <p class="text-gray-300">n = 16 d = 54 T = 216 k = 12 b = 2 B = b~k m = 2^24 q = GL</p>

    <p class="text-gray-300">n_sis = n<em>d m_sis = m</em>d B_12 = sqrt(m<em>d)</em>(8<em>T</em>B)</p>

    <p class="text-gray-300">params = SIS.Parameters(n=n_sis, q=q, m=m_sis,length_bound=B_12, norm=2) _ = SIS.estimate(params) print((k+1)<em>T</em>(b-1) < B)</p>`;
---

<BaseLayout title="Neo: Lattice-based folding scheme for CCS over small fields ... (2025/294)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2025 &middot; eprint 2025/294
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
