---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/962';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Zexe: Enabling Decentralized Private Computation';
const AUTHORS_HTML = 'Sean Bowe, Alessandro Chiesa, Matthew Green, Ian Miers, Pratyush Mishra, Howard Wu';

const CONTENT = `    <p class="text-gray-300">Sean Bowe sean@z.cash Zcash</p>

    <p class="text-gray-300">Alessandro Chiesa alexch@berkeley.edu UC Berkeley</p>

    <p class="text-gray-300">Matthew Green mgreen@cs.jhu.edu Johns Hopkins University</p>

    <p class="text-gray-300">Ian Miers imiers@cs.cornell.edu Cornell Tech</p>

    <p class="text-gray-300">Pratyush Mishra pratyush@berkeley.edu UC Berkeley</p>

    <p class="text-gray-300">Howard Wu howardwu@berkeley.edu UC Berkeley</p>

    <p class="text-gray-300">First published: October 14, 2018</p>

    <p class="text-gray-300">Current revision: November 6, 2025</p>

    <p class="text-gray-300">Ledger-based systems that support rich applications often suffer from two limitations. First, validating a transaction requires re-executing the state transition that it attests to. Second, transactions not only reveal which application had a state transition but also reveal the application's internal state.</p>

    <p class="text-gray-300">We design, implement, and evaluate ZEXE, a ledger-based system where users can execute offline computations and subsequently produce transactions, attesting to the correctness of these computations, that satisfy two main properties. First, transactions hide all information about the offline computations. Second, transactions can be validated in constant time by anyone, regardless of the offline computation.</p>

    <p class="text-gray-300">The core of ZEXE is a construction for a new cryptographic primitive that we introduce, decentralized private computation (DPC) schemes. In order to achieve an efficient implementation of our construction, we leverage tools in the area of cryptographic proofs, including succinct zero knowledge proofs and recursive proof composition. Overall, transactions in ZEXE are 968 bytes regardless of the offline computation, and generating them takes less than a minute plus a time that grows with the offline computation.</p>

    <p class="text-gray-300">We demonstrate how to use ZEXE to realize privacy-preserving analogues of popular applications: private decentralized exchanges for user-defined fungible assets and regulation-friendly private stablecoins.</p>

    <p class="text-gray-300">Keywords: decentralized computation; zero knowledge proofs; succinct arguments</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 1.1 Our contributions  4 1.2 Related work  5</p>

    <p class="text-gray-300">2  Techniques  7 2.1 Achieving privacy for a single arbitrary function  7 2.2 Difficulties with achieving privacy for user-defined functions  8 2.3 The records nano-kernel: a minimalist shared execution environment  8 2.4 Decentralized private computation  11 2.5 Achieving an efficient implementation  13 2.6 Deployment considerations  15</p>

    <p class="text-gray-300">3  Definition of decentralized private computation schemes  17 3.1 Data structures  17 3.2 Algorithms  18 3.3 Security  19</p>

    <p class="text-gray-300">4  Construction of decentralized private computation schemes  23 4.1 Building blocks  23 4.2 Algorithms  23</p>

    <p class="text-gray-300">5  Delegating zero knowledge execution  27 5.1 Approach  27 5.2 Additional building block: randomizable signatures  27 5.3 A delegable DPC scheme  28 5.4 Threshold transactions and blind transactions  30</p>

    <p class="text-gray-300">6  Applications  31 6.1 User-defined assets  31 6.2 Decentralized exchanges  32 6.3 Stablecoins and centrally-managed assets  36</p>

    <p class="text-gray-300">7  Implementation strategy  38</p>

    <p class="text-gray-300">8  System implementation  43</p>

    <p class="text-gray-300">9  System evaluation  45 9.1 Cryptographic building blocks  45 9.2 The execute NP relation  45 9.3 DPC algorithms  45 9.4 DPC data structures  46 9.5 Applications  48</p>

    <p class="text-gray-300">A  Proof of security for our DPC scheme  49 A.1 Building blocks for the simulator  49 A.2 The ideal-world simulator  50 A.3 Proof of security by hybrid argument  53</p>

    <p class="text-gray-300">B  Construction of a delegable DPC scheme  55 B.1 Definition and construction of a randomizable signature scheme  55 B.2 Construction of a delegable DPC scheme  56</p>

    <p class="text-gray-300">C  Extensions in functionality and in security  59</p>

    <p class="text-gray-300">Acknowledgments  61</p>

    <p class="text-gray-300">References  61</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Distributed ledgers are a mechanism that maintains data across a distributed system while ensuring that every party has the same view of the data, even in the presence of corrupted parties. Ledgers can provide an indisputable history of all “events” logged in a system, thereby offering a mechanism for multiple parties to collaborate with minimal trust (any party can ensure the system’s integrity by auditing history). Interest in distributed ledgers has soared recently, catalyzed by their use in cryptocurrencies (peer-to-peer payment systems) and by their potential as a foundation for new forms of financial systems, governance, and data sharing. In this work we study two limitations of ledgers, one about privacy and the other about scalability.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">A privacy problem.</h4>

    <p class="text-gray-300">The main strength of distributed ledgers is also their main weakness: the history of all events is available for anyone to read. This severely limits a direct application of distributed ledgers.</p>

    <p class="text-gray-300">For example, in ledger-based payment systems such as Bitcoin <em>[x20]</em>, every payment transaction reveals the payment’s sender, receiver, and amount. This not only reveals private financial details of individuals and businesses using the system, but also violates fungibility, a fundamental economic property of money. This lack of privacy becomes more severe in smart contract systems like Ethereum <em>[x28]</em>, wherein transactions not only contain payment details, but also embed function calls to specific applications. In these systems, every application’s internal state is necessarily public, and so is the history of function calls associated to it.</p>

    <p class="text-gray-300">This problem has motivated prior work to find ways to achieve meaningful privacy guarantees on ledgers. For example, the Zerocash protocol <em>[BCG^{+}14]</em> provides privacy-preserving payments, and Hawk <em>[KMS^{+}16]</em> enables general state transitions with data privacy, that is, an application’s data is hidden from third parties.</p>

    <p class="text-gray-300">However, all prior work is limited to hiding the inputs and outputs of a state transition but not which transition function is being executed. That is, prior work achieves data privacy but not function privacy. In systems with a single transition function this is not a concern. In systems with multiple transition functions, however, this leakage is problematic. For example, Ethereum currently supports thousands of separate ERC-20 “token” contracts <em>[x11]</em>, each representing a distinct currency on the Ethereum ledger; even if these contracts each individually adopted a protocol such as Zerocash to hide details about token payments, the corresponding transactions would still reveal which token was being exchanged. Moreover, the leakage of this information would substantially reduce the anonymity set of those payments.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">A scalability problem.</h4>

    <p class="text-gray-300">Public auditability in the aforementioned systems (and many others) is achieved via direct verification of state transitions that re-executes the associated computation. This creates the following scalability issues. First, note that in a network consisting of devices with heterogeneous computing power, requiring every node to re-execute transactions makes the weakest node a bottleneck, and this effect persists even when the underlying ledger is “perfect”, that is, it confirms every valid transaction immediately. To counteract this and to discourage denial-of-service attacks whereby users send transactions that take a long time to validate, current systems introduce mechanisms such as gas to make users pay more for longer computations. However, such mechanisms can make it unprofitable to validate legitimate but expensive transactions, a problem known as the “Verifier’s Dilemma” <em>[x17]</em>. These problems have resulted in Bitcoin forks <em>[x5]</em> and Ethereum attacks <em>[x11]</em>.</p>

    <p class="text-gray-300">In sum, there is a dire need for techniques that facilitate the use of distributed ledgers for rich applications, without compromising privacy (of data or functions) or relying on unnecessary re-executions. Prior works only partially address this need, as discussed in Section 1.2 below.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">1.1 Our contributions</p>

    <p class="text-gray-300">We design, implement, and evaluate Zexe (Zero knowledge EXEcution), a ledger-based system that enables users to execute offline computations and subsequently produce publicly-verifiable transactions that attest to the correctness of these offline executions. Zexe simultaneously provides two main security properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Privacy: a transaction reveals no information about the offline computation, except (an upper bound on) the number of consumed inputs and created outputs. One cannot link together multiple transactions by the same user or involving related computations, nor selectively censor transactions based on such information.</li>

      <li>Succinctness: a transaction can be validated in time that is independent of the cost of the offline computation whose correctness it attests to. Since all transactions are indistinguishable, and are hence equally cheap to validate, there is no “Verifier’s Dilemma”, nor a need for mechanisms like Ethereum’s gas.</li>

    </ul>

    <p class="text-gray-300">Zexe also offers rich functionality, as offline computations in Zexe can be used to realize state transitions of multiple applications (such as tokens, elections, markets) simultaneously running atop the same ledger. The users participating in applications do not have to trust, or even know of, one another. Zexe supports this functionality by exposing a simple, yet powerful, shared execution environment with the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Extensibility: users may execute arbitrary functions of their choice, without seeking anyone’s permission.</li>

      <li>Isolation: functions of malicious users cannot interfere with the computations and data of honest users.</li>

      <li>Inter-process communication: functions may exchange data with one another.</li>

    </ul>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">DPC schemes.</h4>

    <p class="text-gray-300">The technical core of Zexe is a protocol for a new cryptographic primitive for performing computations on a ledger called decentralized private computation (DPC). Informally, a DPC scheme supports a simple, yet expressive, programming model in which units of data, which we call records, are bound to scripts (arbitrary programs) that specify the conditions under which a record can be created and consumed (this model is similar to the UTXO model; see Remark 2.3). The rules that dictate how these programs interact can be viewed as a “nano-kernel” that provides a shared execution environment upon which to build applications. From a technical perspective, DPC can be viewed as extending Zerocash <em>[BCG^{+}14]</em> to the foregoing programming model, while still providing strong privacy guarantees, not only within a single application (which is a straightforward extension) but also across multiple co-existing applications (which requires new ideas that we discuss later on). The security guarantees of DPC are captured via an ideal functionality, which our protocol provably achieves.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Applications.</h4>

    <p class="text-gray-300">To illustrate the expressivity of the RNK, we show how to use DPC schemes to construct privacy-preserving analogues of popular applications: private user-defined assets, private decentralized or non-custodial exchanges (DEXs), and private stablecoins. Our privacy guarantees in particular protect against vulnerabilities of current DEX designs such as front-running <em>[BDJT17, BBD^{+}17, EMC19, DGK^{+}20]</em>. Moreover, we sketch how to use DPC to construct a privacy-preserving smart contract system. See Sections 2.3 and 6 for details.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Techniques for efficient implementation.</h4>

    <p class="text-gray-300">We devise a set of techniques to achieve an efficient implementation of our DPC protocol, by drawing upon recent advances in zero knowledge succinct cryptographic proofs (namely, zkSNARKs) and in recursive proof composition (proofs attesting to the validity of other proofs).</p>

    <p class="text-gray-300">Overall, transactions in Zexe with two input records and two output records are <span class="math">968</span> bytes and can be verified in tens of milliseconds, <em>regardless of the offline computation</em>; generating these transactions takes less than a minute plus a time that grows with the offline computation (inevitably so). This implementation is achieved in a modular fashion via a collection of Rust libraries (see Fig. 15), in which the top-level one is libzexe. Our implementation also supports transactions with <em>any</em> number <span class="math">m</span> of input records and <span class="math">n</span> of output records; transactions size in this case is <span class="math">32m+32n+840</span> bytes (the transaction stores the serial number of each input record and the commitment of each output record).</p>

    <p class="text-gray-300">Delegating transactions. While verifying succinct cryptographic proofs is cheap, producing them can be expensive. As the offline computation grows, the (time and space) cost of producing a cryptographic proof of its correctness also grows, which could become infeasible for a user.</p>

    <p class="text-gray-300">To address this problem, we further obtain <em>delegable DPC</em>. The user communicates to an untrusted worker details about the desired transaction, then the worker produces the transaction, and finally the user authorizes it via a cheap computation (and in a way that does not violate indistinguishability of transactions). This feature is particularly relevant for prospective real-world deployments, because it enables support for weak devices, such as mobile phones or hardware tokens.</p>

    <p class="text-gray-300">In fact, our delegable DPC protocol also extends to support <em>threshold transactions</em>, which can be used to improve operational security, and also to support <em>blind transactions</em>, which can be used to realize lottery tickets for applications such as micropayments.</p>

    <p class="text-gray-300">All of these extensions are also part of our Rust library libzexe.</p>

    <p class="text-gray-300">A perspective on costs. Zexe is not a lightweight construction, but achieves, in our opinion, tolerable efficiency for the ambitious goals it sets out to achieve: <em>data and function privacy, and succinctness, with rich functionality, in a threat model that requires security against all efficient adversaries</em>. Relaxing any of these goals (assuming rational adversaries or hardware enclaves, or compromising on privacy) will lead to more efficient approaches.</p>

    <p class="text-gray-300">The primary cost in our system is, unsurprisingly, the cost of generating the cryptographic proofs that are included in transactions. We have managed to keep this cost to roughly a minute plus a cost that grows with the offline computation. For the applications mentioned above, these additional costs are negligible. Our system thus supports applications of real-world interest today (e.g., private DEXs) with reasonable costs.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">1.2 Related work</h3>

    <p class="text-gray-300">Avoiding naive re-execution. A number of proposals for improving the scalability of smart contract systems, such as TrueBit <em>[x21]</em>, Plasma <em>[x19]</em>, and Arbitrum <em>[KGC^{+}18]</em>, avoid naive re-execution by having users report the results of their computations <em>without</em> any cryptographic proofs, and instead putting in place incentive mechanisms wherein others can challenge reported results. The user and challenger engage in a so-called <em>refereed game</em> <em>[x6, x10, x11, x23, x24]</em>, mediated by a smart contract acting as the referee, that efficiently determines which of the two was “telling the truth”. In contrast, in this work correctness of computation is ensured by cryptography, regardless of any economic motives; we thus protect against all efficient adversaries rather than merely all rational and efficient ones. Also, unlike our DPC scheme, the above works do not provide formal guarantees of strong privacy (challengers must be able to re-execute the computation leading to a result and in particular must know its potentially private inputs).</p>

    <p class="text-gray-300">Private payments. Zerocash <em>[BCG^{+}14]</em>, building on earlier work <em>[x16]</em>, showed how to use distributed ledgers to achieve payment systems with strong privacy guarantees. The Zerocash protocol, with some modifications, is now commercially deployed in several cryptocurrencies, including Zcash <em>[x20]</em>. Solidus <em>[CZJ^{+}17]</em> enables customers of financial institutions (such as banks) to transfer funds to one another in</p>

    <p class="text-gray-300">a manner that ensures that only the banks of the sender and receiver learn the details of the transfer; all other parties (all other customers and banks) only learn that a transfer occurred, and nothing else. zkLedger <em>[x20]</em> enables anonymous payments between a small number of distinguished parties via the use of homomorphic commitments and Schnorr proofs. None of these protocols support scripts (small programs that dictate how funds can be spent), let alone arbitrary state transitions as in Zexe.</p>

    <p class="text-gray-300">Privacy beyond payments. Hawk <em>[KMS^{+}16]</em>, combining ideas from Zerocash and the notion of an evaluator-prover for multi-party computation, enables parties to conduct offline computations and then report their results via cryptographic proofs. Hawk’s privacy guarantee protects the private inputs used in a computation, but does not hide <em>which</em> computation was performed. That said, we view Hawk as complementary to our work: a user in our system could in particular be a semi-trusted manager that administers a multi-party computation and generates a transaction about its output. The privacy guarantees provided in this work would then additionally hide <em>which</em> computation was carried out offline.</p>

    <p class="text-gray-300">Zether <em>[x1]</em> is a system that enables <em>publicly known</em> smart contracts to reason about homomorphic commitments in zero knowledge, and in particular enables these to transact in a manner that hides transaction amounts; it does not hide the identities of parties involved in the transaction, beyond a small anonymity set. Furthermore, the cost of verifying a transaction scales linearly with the size of the anonymity set, whereas in Zexe this cost scales logarithmically with the size of anonymity set.</p>

    <p class="text-gray-300">Succinct blockchains. Coda <em>[x18]</em> uses arbitrary-depth recursive composition of SNARKs to enable blockchain nodes to verify the current blockchain state quickly. In contrast, Zexe uses depth-2 recursive composition to ensure that all blockchain transactions are equally cheap to verify (and are moreover indistinguishable from each other), regardless of the cost of the offline computation. In this respect, Coda and Zexe address orthogonal scalability concerns.</p>

    <p class="text-gray-300">MPC with ledgers. Several works <em>[x1, x2, x16, x15, x17, RCGJ^{+}17]</em> have applied ledgers to obtain secure multi-party protocols that have security properties that are difficult to achieve otherwise, such as <em>fairness</em>. These approaches are complementary to our work, as any set of parties wishing to jointly compute a certain function via one of these protocols could run the protocol “under” our DPC scheme in such a way that third parties would not learn any information that such a multi-party computation is happening.</p>

    <p class="text-gray-300">Hardware enclaves. Kaptchuk et al. <em>[x19]</em> and Ekiden <em>[CZK^{+}18]</em> combine ledgers with hardware enclaves, such as Intel Software Guard Extensions <em>[MAB^{+}13]</em>, to achieve various integrity and privacy goals for smart contracts. Beyond ledgers, several systems explore privacy goals in distributed systems by leveraging hardware enclaves; see for example M2R <em>[DSC^{+}15]</em>, VC3 <em>[SCF^{+}15]</em>, and Opaque <em>[ZDB^{+}17]</em>. All of these works are able to efficiently support rich and complex computations. In this work, we make no use of hardware enclaves, and instead rely entirely on cryptography. This means that on the one hand our performance overheads are more severe, while on the other hand we protect against a richer class of adversaries (all efficient ones). Moreover, the techniques above depend on a working <em>remote attestation capability</em>; we note that our techniques can be used to achieve stronger security guarantees, even in the face of a compromise in the remote attestation capabilities of an enclave system (as recently occurred with Intel SGX <em>[VBMW^{+}19]</em>).</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2 Techniques</p>

    <p class="text-gray-300">We now summarize the main ideas behind our contributions. Our goal is to design a ledger-based system in which transactions attest to offline computations while simultaneously providing privacy and succinctness.</p>

    <p class="text-gray-300">We first note that if privacy is not required, there is a straightforward folklore approach that provides succinctness and low verification cost: each user accompanies the result reported in a transaction with a succinct cryptographic proof (i.e., a SNARK) attesting to the result’s correctness. Others who validate the transaction can simply verify the cryptographic proof, and do not have to re-execute the computation. Even this limited approach rules out a number of cryptographic directions, such as the use of Bulletproofs <em>[BCC^{+}16, BBB^{+}18]</em> (which have verification time linear in the circuit complexity), but can be accomplished using a number of efficient SNARK techniques <em>[x13, x10, x11, x12]</em>. In light of this, we shall first discuss how to achieve privacy, and then how to additionally achieve succinctness.</p>

    <p class="text-gray-300">The rest of this section is organized as follows. In Sections 2.1 and 2.2 we explain why achieving privacy in our setting is challenging. In Section 2.3 we introduce the shared execution environment that we consider, and in Section 2.4 we introduce decentralized private computation (DPC), a cryptographic primitive that securely realizes it. In Section 2.5 we describe how we turn our ideas into an efficient implementation.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.1 Achieving privacy for a single arbitrary function</h3>

    <p class="text-gray-300">Zerocash <em>[BCG^{+}14]</em> is a protocol that achieves privacy for a specific functionality, namely, value transfers within a single currency. Therefore, it is natural to consider what happens if we extend Zerocash from this special case to the general case of a single arbitrary function that is known in advance to everybody.</p>

    <p class="text-gray-300">Sketch of Zerocash. Money in Zerocash is represented via coins. The commitment of a coin is published on the ledger when the coin is created, and its serial number is published when the coin is consumed. Each transaction on the ledger attests that some “old” coins were consumed in order to create some “new” coins: it contains the serial numbers of the consumed coins, commitments of the created coins, and a zero knowledge proof attesting that the serial numbers belong to coins created in the past (without identifying which ones), and that the commitments contain new coins of the same total value. A transaction is private because it only reveals how many coins were consumed and how many were created, but no other information (each coin’s value and owner address remain hidden). Also, revealing a coin’s serial number ensures that a coin cannot be consumed more than once (the same serial number would appear twice). In sum, data in Zerocash corresponds to coin values, and state transitions are the single invariant that monetary value is preserved.</p>

    <p class="text-gray-300">Extending to an arbitrary function. One way to extend Zerocash to a single arbitrary function <span class="math">\\Phi</span> (known in advance to everybody) is to think of a coin as a record that stores some arbitrary data payload, rather than just some integer value. The commitment of a record would then be published on the ledger when the record is created, and its unique serial number would be published when the record is consumed. A transaction would then contain serial numbers of consumed records, commitments of created records, and a proof attesting that invoking the function <span class="math">\\Phi</span> on (the payload of) the old records produces (the payload of) the new records.</p>

    <p class="text-gray-300">Data privacy holds because the ledger merely stores each record’s commitment (and its serial number once consumed), and transactions only reveal that some number of old records were consumed in order to create some number of new records in a way that is consistent with <span class="math">\\Phi</span>. Function privacy also holds but for trivial reasons: <span class="math">\\Phi</span> is known in advance to everybody, and every transaction is about computations of <span class="math">\\Phi</span>.</p>

    <p class="text-gray-300">Note that Zerocash is indeed a special case of the above: it corresponds to fixing <span class="math">\\Phi</span> to the particular (and publicly known) choice of a function <span class="math">\\Phi_{\\S}</span> that governs value transfers within a single currency. However the foregoing protocol supports only a single hard-coded function <span class="math">\\Phi</span>, while instead we want to enable users to select their own functions, as we discuss next.</p>

    <p class="text-gray-300">2.2 Difficulties with achieving privacy for user-defined functions</p>

    <p class="text-gray-300">We want to enable users to execute functions of their choice concurrently on the same ledger without seeking permission from anyone. That is, when preparing a transaction, a user should be able to pick <em>any</em> function <span class="math">\\Phi</span> of their choice for creating new records by consuming some old records. If function privacy is not a concern, then this is easy: just attach to the transaction a zero-knowledge proof that <span class="math">\\Phi</span> was correctly evaluated offline. However, because this approach reveals <span class="math">\\Phi</span>, we cannot use it because function privacy is a goal for us.</p>

    <p class="text-gray-300">An approach that <em>does</em> achieve function privacy would be to modify the sketch in Section 2.1 by fixing a single function that is <em>universal</em>, and then interpreting data payloads as user-defined functions that are provided as inputs. Indeed, zero knowledge would ensure function privacy in this case. However merely allowing users to define their own functions does <em>not</em> by itself yield meaningful functionality, as we explain next.</p>

    <p class="text-gray-300">The problem: malicious functions. A key challenge in this setting is that malicious users could devise functions to attack or disrupt other users’ functions and data, so that a particular user would not know whether to trust records created by other users; indeed, due to function privacy, a verifier would not know what functions were used to create those records. For a concrete example, suppose that we wanted to realize the special case of value transfers within a single currency (i.e., Zerocash). One may believe that it would suffice to instruct users to pick the function <span class="math">\\Phi_{\\S}</span> (or similar). But this does <em>not</em> work: a user receiving a record claiming to contain, say, <span class="math">1</span> unit of currency does not know if this record was created via the function <span class="math">\\Phi_{\\S}</span> from other such records and so on. A malicious user could have used a different function to create that record, for example, one that illegally “mints” records that appear valid to <span class="math">\\Phi_{\\S}</span>, and thus enables arbitrary inflation of the currency. More generally, the lack of any enforced rules about how user-defined functions can interact precludes productive cooperation between users that are mutually distrustful. We stress that this challenge arises specifically due to the requirement that functions be private: if the function that created (the commitment of) a record was public knowledge, users could decide for themselves if records they receive were generated by “good” functions.</p>

    <p class="text-gray-300">One way to address the foregoing problem is to augment records with a new attribute that identifies the function that “created” the record, and then impose the restriction that in a valid transaction only records created by the same function may participate. This new attribute is contained within a hiding commitment and thus is never revealed publicly on the ledger (just like a record’s payload); the zero knowledge proof is tasked with ensuring that records participating in the same transaction are all of the same “type”. This approach now <em>does</em> suffice to realize value transfers within a single currency, by letting users select the function <span class="math">\\Phi_{\\S}</span>. More generally, this approach generalizes that in Section 2.1, and can be viewed as running multiple segregated “virtual ledgers” each with a fixed function. Function privacy holds because one cannot tell if a transaction belongs to one virtual ledger or another.</p>

    <p class="text-gray-300">The problem: functions cannot communicate. The limitation of the above technique is that it forbids any “inter-process communication” between different functions, and so one cannot realize even simple functionalities like transferring value between different currencies on the same ledger. It also rules out more complex smart contract systems, as communication between contracts is a key part of such systems. It is thus clear that this crude “time sharing” of the ledger is too limiting.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.3 The records nano-kernel: a minimalist shared execution environment</h3>

    <p class="text-gray-300">The approaches in Section 2.2 lie at opposite extremes: unrestricted inter-process interaction prevents the secure construction of even basic applications such as a single currency, while complete process segregation limits the ability to construct complex applications that interact with with each other.</p>

    <p class="text-gray-300">Balancing these extremes requires a shared execution environment: one can think of this as an <em>operating system</em> for a shared ledger. This operating system manages user-defined functions: it provides process isolation, determines data ownership, handles inter-process communication, and so on. Overall, processes must be able to concurrently share a ledger, without violating the integrity or confidentiality of one another.</p>

    <p class="text-gray-300">However, function privacy (one of our goals) dictates that user-defined functions are hidden, which means that an operating system cannot be maintained publicly atop the ledger (as in current smart contract systems) but, instead, must be part of the statement proved in zero knowledge. This is unfortunate because designing an operating system that governs interactions across user-defined functions within a zero knowledge proof is not only a colossal design challenge but also entails many arbitrary design choices that we should not have to take.</p>

    <p class="text-gray-300">In light of the above, we choose to take the following approach: we formulate a <em>minimalist</em> shared execution environment that imposes simple, yet expressive, rules on how records may interact, and enables programming applications in the UTXO model (see Remark 2.3 for why we make this choice). This execution environment can be viewed as a “nano-kernel” that enables users to manage records containing data by programming two boolean functions (or predicates) associated with each record. These predicates control the two defining moments in a record’s life, namely creation (or “birth”) and consumption (or “death”), and are hence called the record’s <em>birth</em> and <em>death</em> predicates. A user can create and consume records in a transaction by satisfying the predicates of those records. In more detail,</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>The records nano-kernel (RNK) is an execution environment that operates over units of data called records. A record contains a <em>data payload</em>, a <em>birth predicate</em> <span class="math">\\Phi_{\\text{h}}</span>, and a <em>death predicate</em> <span class="math">\\Phi_{\\text{d}}</span>. Records are created and consumed by <em>valid transactions</em>. These are transactions where the death predicates of all consumed records and the birth predicates of all created records are simultaneously satisfied when given as input the transaction’s <em>local data</em> (see Fig. 3), which includes: (a) every record’s contents (such as its payload and the identity of its predicates); (b) a piece of shared memory that is publicly revealed, called <em>transaction memorandum</em>; (c) a piece of shared memory that is kept hidden, called <em>auxiliary input</em>; and (d) other construction specifics.</p>
    </blockquote>

    <p class="text-gray-300">The foregoing definition enables predicates to see the contents of the entire transaction and hence <em>to individually decide if the local data is valid according to its own logic</em>. This in turn enables predicates to communicate with each other in a secure manner without interference from malicious predicates. In more detail, a record <span class="math">\\mathbf{r}</span> can protect itself from other records that contain “bad” birth or death predicates because the <span class="math">\\mathbf{r}</span>’s predicates could refuse to accept when they detect (from reading the local data) that they are in a transaction with records having bad predicates. At the same time, a record can interact with other records in the same transaction when its predicates decide to accept, providing the flexibility that we seek.</p>

    <p class="text-gray-300">We briefly illustrate this via an example, <em>user-defined assets</em>, whereby one can use birth predicates to define and transact with their own assets, and also use death predicates to enforce custom access control policies over these assets.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Example 2.1 (user-defined assets).</h6>

    <p class="text-gray-300">Consider records whose payloads encode an asset identifier <span class="math">\\mathrm{id}</span>, the initial asset supply <span class="math">\\mathbb{v}</span>, and a value <span class="math">v</span>. Fix the birth predicate in all such records to be a <em>mint-or-conserve</em> function <span class="math">\\mathsf{MoC}</span> that is responsible for creating the initial supply of a new asset, and then subsequently conserving the value of the asset across all transactions. In more detail, <span class="math">\\mathsf{MoC}</span> can be invoked in one of two modes. In <em>mint mode</em>, given as input a desired initial supply <span class="math">\\mathbb{v}</span>, <span class="math">\\mathsf{MoC}</span> deterministically derives (in a way that we discuss later) a fresh unique identifier <span class="math">\\mathrm{id}</span> for a new asset and stores <span class="math">(\\mathrm{id},\\mathbb{v},v=\\mathbb{v})</span> in a <em>genesis record</em>. In <em>conserve mode</em>, <span class="math">\\mathsf{MoC}</span> inspects all records in a transaction whose birth predicates equal to <span class="math">\\mathsf{MoC}</span> and whose asset identifiers equal the identifier of the current record, and ensures that among these records, the asset values are conserved.</p>

    <p class="text-gray-300">Users can program death predicates of records to enforce conditions on how assets can be consumed, e.g., by realizing <em>conditional exchanges</em> with other counter-parties. Suppose that Alice wishes to exchange</p>

    <p class="text-gray-300">100 units of an asset <span class="math">\\mathrm{id}_{1}</span> for 50 units of another asset <span class="math">\\mathrm{id}_{2}</span>, but does not have a counter-party for the exchange. She creates a record <span class="math">\\mathbf{r}</span> with 100 units of <span class="math">\\mathrm{id}_{1}</span> whose death predicate enforces that any transaction consuming <span class="math">\\mathbf{r}</span> must also create another record, consumable by Alice, with 50 units of <span class="math">\\mathrm{id}_{2}</span>. She then publishes out of band information about <span class="math">\\mathbf{r}</span>, and anyone can subsequently claim it by creating a transaction doing the exchange.</p>

    <p class="text-gray-300">Since death predicates can be <em>arbitrary</em>, many different access policies can also be realized, e.g., to enforce that a transaction redeeming a record (a) must be authorized by two of three public keys, or (b) becomes valid only after a given amount of time, or (c) must reveal the pre-image of a hash function.</p>

    <p class="text-gray-300">One can generalize this basic example to show how the RNK can realize a specific class of smart contract systems, namely those in which the transaction creator knows both the contract code being executed, as well as the (public and secret) state of the contract. At a high level, these contracts can be executed within a single transaction, or across multiple transactions, by storing suitable intermediate state/message data in record payloads, or by publishing that data in transaction memoranda (as plaintext or ciphertext as needed). We discuss in more detail below.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Example 2.2 (smart contracts with caller-known state).</h6>

    <p class="text-gray-300">At the highest level, smart contract systems operate over a set of individual contracts, each of which consists of a function (or collection of functions), some state variables, and some form of <em>address</em> that serves to uniquely identify the contract. The contract address ensures that the same code/functions can be deployed multiple times by different individuals, without two contracts inadvertently sharing state. A standard feature of smart contract systems is that a contract can communicate with other contracts: that is, a contract can invoke a second smart contract as a subroutine, provided that the second contract provides an interface to allow this behavior. In our setting, we consider contracts in which the caller knows at least part of the state of each contract.</p>

    <p class="text-gray-300">In this setting, one can use the records nano-kernel to realize basic smart contracts as follows. Each contract can be implemented as a function <span class="math">\\Phi_{\\mathsf{sc}}</span>. The contract’s state variables can be stored in one or more records such that each record <span class="math">\\mathbf{r}_{i}</span> is labeled with <span class="math">\\Phi_{\\mathsf{sc}}</span> as the birth and death predicate. Using this labeling, <span class="math">\\Phi_{\\mathsf{sc}}</span> (via the RNK) can enforce that only it can update its state variables, thus fulfilling one requirement of a secure contract. Of course, while this serves to prevent <em>other functions</em> from updating the contract’s state, it does not address the situation where multiple users wish to deploy different instances of the same function <span class="math">\\Phi_{\\mathsf{sc}}</span>, each with isolated state. Fortunately (and validating our argument that the RNK realizes the <em>minimal</em> requirements needed for such a system), addressing this problem does not require changes to the RNK. Instead, one can devise the function <span class="math">\\Phi_{\\mathsf{sc}}</span> so that it reasons over a unique contract address identifier <span class="math">\\mathrm{id}</span>, which is recorded within the <em>payload</em> of every record. The function <span class="math">\\Phi_{\\mathsf{sc}}</span> can achieve contract state isolation by enforcing that each input and output state record considered by single execution of <span class="math">\\Phi_{\\mathsf{sc}}</span> shares the same contract address.</p>

    <p class="text-gray-300">To realize “inter-contract calls” between two functions <span class="math">\\Phi_{\\mathsf{sc}_{1}}</span> and <span class="math">\\Phi_{\\mathsf{sc}_{2}}</span>, one can use “ephemeral” records that communicate between the two functions. For example, if <span class="math">\\Phi_{\\mathsf{sc}_{1}}</span> wishes to call <span class="math">\\Phi_{\\mathsf{sc}_{2}}</span>, the caller may construct a record <span class="math">\\mathbf{r_{e}}</span> that contains the “arguments” to the called function <span class="math">\\Phi_{\\mathsf{sc}_{2}}</span>, as well as the result of the function call. A transaction would then show that both <span class="math">\\Phi_{\\mathsf{sc}_{1}}</span> and <span class="math">\\Phi_{\\mathsf{sc}_{2}}</span> are satisfied.</p>

    <p class="text-gray-300">The above example outlines how to implement a general smart contract system atop the RNK. We leave to future work the task of developing this outline into a full-fledged smart contract framework, and instead focus on constructing a scheme that implements the RNK, and on illustrating how to directly program the RNK</p>

    <p class="text-gray-300">to construct specific applications such as user-defined assets, private decentralized asset exchanges, and regulation-friendly private stablecoins. We discuss these applications in more detail in Section 6.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Remark 2.3 (working in the UTXO model).</h6>

    <p class="text-gray-300">In the records nano-kernel, applications update their state by consuming records containing the old state, and producing new records that contain the updated state. This programming model is popularly known as the “unspent transaction output” (UTXO) model. This is in contrast to the “account-based” model which is used by many other smart contract systems <em>[x11, x33, x13]</em>. At present, it is not known how to efficiently achieve strong privacy properties in this model even for the simple case of privacy-preserving payments among any number of users, as we explain below.</p>

    <p class="text-gray-300">In the account-based model, application state is stored in a persistent location associated with the application’s account, and updates to this state are applied in-place. A smart contract that implements a currency in this model would store user balances in a persistent table <span class="math">T</span> that maps user account identifiers to user balances. Transactions from a user <span class="math">A</span> to another user <span class="math">B</span> would then decrement <span class="math">A</span>’s balance in <span class="math">T</span> and increment <span class="math">B</span>’s balance by a corresponding amount. A straightforward way to make this contract data-private (i.e., to hide the transaction value and the identities of <span class="math">A</span> and <span class="math">B</span>) would be to replace the user balances in <span class="math">T</span> with hiding commitments to these balances; transactions would then update these commitments instead of directly updating the balances. However, while this hides transaction values, it does not hide user identities; to further hide these, every transaction would have to update all commitments in <span class="math">T</span>, which entails a cost that grows linearly with the number of users. This approach is taken by zkLedger <em>[x30]</em>, which enables private payments between a small number of known users (among other things).</p>

    <p class="text-gray-300">Even worse, achieving function privacy when running multiple applications in such a system would require each transaction to hide which application’s data was being updated, which means that the transaction would have to update the data of all applications at once, again severely harming the efficiency of the system.</p>

    <p class="text-gray-300">In sum, it is unclear how to efficiently achieve strong data and function privacy in the account-based model when users can freely join and leave the system without notifying other users. On the other hand, we show in this paper that these properties can be achieved in the UTXO model at a modest cost.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">2.4 Decentralized private computation</h3>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">A new cryptographic primitive.</h4>

    <p class="text-gray-300">We introduce a new cryptographic primitive called decentralized private computation (DPC) schemes, which capture the notion of a ledger-based system where privacy-preserving transactions attest to offline computations that follow the records nano-kernel. See Section 3 for the definition of DPC schemes, including the ideal functionality that we use to express security.</p>

    <p class="text-gray-300">We construct a DPC scheme in Section 4, and prove it secure in Appendix A. We take Zerocash <em>[BCG^{+}14]</em> as a starting point, and then extend the protocol to support the records nano-kernel and also to facilitate proving security in the simulation paradigm relative to an ideal functionality (rather than via a collection of separate game-based definitions as in <em>[BCG^{+}14]</em>). Below we sketch the construction.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Construction sketch.</h4>

    <p class="text-gray-300">Each transaction in the ledger consumes some old records and creates new records in a manner that is consistent with the records nano-kernel. To ensure privacy, a transaction only contains serial numbers of the consumed records, commitments of the created records, and a zero knowledge proof attesting that there exist records consistent with this information (and with the records nano-kernel). All commitments on the ledger are collected in a Merkle tree, which facilitates efficiently proving that a commitment appears on the ledger (by proving in zero knowledge the knowledge of a suitable authentication path). All serial numbers on the ledger are collected in a list that cannot contain duplicates. This implies that a record cannot be consumed twice because the same serial number is revealed each time a record is consumed. See Fig. 1.</p>

    <p class="text-gray-300">The record data structure is summarized in Fig. 2. Each record is associated to an address public key, which is a commitment to a seed for a pseudorandom function acting as the corresponding address secret key; addresses determine ownership of records, and in particular consuming a record requires knowing its secret key. A record consists of an address public key, a data payload, a birth predicate, a death predicate, and a serial number nonce; a record commitment is a commitment to all of these attributes. The serial number of a record is the evaluation of a pseudorandom function, whose seed is the secret key for the record's address public key, evaluated at the record's serial number nonce. A record's commitment and serial number, which appear on the ledger when the record is created and consumed, reveal no information about the record attributes. This follows from the hiding properties of the commitment, and the pseudorandom properties of the serial number. The derivation of a record's serial number ensures that a user can create a record for another in such a way that its serial number is fully determined and yet cannot be predicted without knowing the other user's secret key.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Construction of a transaction.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: Construction of a record.</p>

    <p class="text-gray-300">In order to produce a transaction, a user selects some previously-created records to consume, assembles some new records to create (including their payloads and predicates), and decides on other aspects of the local data such as the transaction memorandum (shared memory seen by all predicates and published on the ledger) and the auxiliary input (shared memory seen by all predicates but not published on the ledger); see Fig. 3. If the user knows the secret keys of the records to consume and if all relevant predicates are satisfied (death predicates of old records and birth predicates of new predicates), then the user can produce a zero knowledge proof to append to the transaction. See Fig. 4 for a summary of the NP statement being proved.</p>

    <p class="text-gray-300">In sum, a transaction only reveals the number of consumed records and number of created records, as well as any data that was deliberately revealed in the transaction memorandum (possibly nothing).</p>

    <p class="text-gray-300">Achieving succinctness. Our discussions so far have focused on achieving (data and function) privacy. However, we also want to achieve succinctness, namely, that a transaction can be validated in "constant time". This follows from a straightforward modification: we take the protocol that we have designed so far and use a zero knowledge succinct argument rather than just any zero knowledge proof. Indeed, the NP statement being proved (summarized in Fig. 4) involves attesting the satisfiability of all (old) death and (new) birth predicates, and thus we need to ensure that verifying the corresponding proof can be done in time that does not depend</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: Predicates receive local data.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 4: The execute statement.</p>

    <p class="text-gray-300">on the complexity of these predicates. While turning this idea into an efficient implementation requires more ideas (as we discuss in Section 2.5), the foregoing modification suffices from a theoretical point of view.</p>

    <p class="text-gray-300">Delegation to an untrusted worker. In our DPC scheme, a user must produce, and include in the transaction, a zero knowledge succinct argument that, among other things, attests that death predicates of consumed records are satisfied and, similarly, that birth predicates of created records are satisfied. This implies that the cost of creating a transaction grows with the complexity (and number of) predicates involved in the transaction. Such a cost can quickly become infeasible for weak devices such as mobile phones or hardware tokens.</p>

    <p class="text-gray-300">We address this problem by enabling a user to delegate to an untrusted worker, such as a remote server, the computation that produces a transaction. This notion, which we call a delegable DPC scheme, empowers weak devices to produce transactions that they otherwise could not have produced on their own.</p>

    <p class="text-gray-300">The basic idea is to augment address keys in such a way that the secret information needed to produce the cryptographic proof is separate from the secret information needed to authorize a transaction containing that proof. Thus, the user can communicate to the worker the secrets necessary to generate a cryptographic proof, while retaining the remaining secrets for authorizing this (and future) transactions. In particular, the worker has no way to produce valid transactions that have not been authorized by the user.</p>

    <p class="text-gray-300">We use randomizable signatures to achieve the foregoing functionality, without violating either privacy or succinctness. Informally, we modify a record's serial number to be an unlinkable randomization of (part of) the record's address public key, and a user's authorization of a transaction consists of signing the instance and proof relative to every randomized key (i.e., serial number) in that transaction. See Section 5 for details.</p>

    <p class="text-gray-300">Our system ZEXE (Zero knowledge EXEcution) provides an implementation of two constructions: our "plain" DPC protocol, and its extension to a delegable DPC protocol. Achieving efficiency in our system required overcoming several challenges. Below we highlight some of these challenges, and explain how we addressed them; see Sections 7 and 8 for details. The discussions below equally apply to both types of DPC protocols.</p>

    <p class="text-gray-300">Avoiding the cost of universality. The NP statement that we need to prove involves checking user-defined predicates, so it must support arbitrary computations that are not fixed in advance. However, state-of-the-art zkSNARKs for universal computations rely on expensive tools [BCG+13, BCTV14, WSR+15, BCTV17].</p>

    <p class="text-gray-300">We address this problem by relying on one layer of recursive proof composition [Val08, BCCT13]. Instead of tasking the NP statement with directly checking user-defined predicates, we only task it with checking succinct proofs attesting to this. Checking these inner succinct proofs is a (relatively) inexpensive computation</p>

    <p class="text-gray-300">that is fixed for all predicates, which can be “hardcoded” in the statement. Since the single outer succinct proof produced does not reveal information about the inner succinct proofs attesting to predicates’ satisfiability (thanks to zero knowledge), the inner succinct proofs do not have to hide what predicate was checked, so they can be for NP statements tailored to the computations of particular user-defined predicates.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">A bespoke recursion.</h4>

    <p class="text-gray-300">Recursive proof composition has been empirically demonstrated for pairing-based SNARKs <em>[x1]</em>. We thus focus our attention on these, and explain the challenges that arise in our setting. Recall that if we instantiate a SNARK’s pairing via an elliptic curve <span class="math">E</span> defined over a prime field <span class="math">\\mathbb{F}_{q}</span> and having a subgroup of prime order <span class="math">r</span>, then (a) the SNARK supports NP statements expressed as arithmetic circuits over <span class="math">\\mathbb{F}_{r}</span>, while (b) proof verification involves arithmetic operations over <span class="math">\\mathbb{F}_{q}</span>. Being part of the NP statement, the SNARK verifier must also be expressed as an arithmetic circuit over <span class="math">\\mathbb{F}_{r}</span>, which is problematic because the verifier’s “native” operations are over <span class="math">\\mathbb{F}_{q}</span>. Simulating <span class="math">\\mathbb{F}_{q}</span> operations via <span class="math">\\mathbb{F}_{r}</span> operations is expensive, and picking <span class="math">E</span> such that <span class="math">q=r</span> is impossible <em>[x1]</em>. Prior work thus uses multiple curves <em>[x1]</em>: a two-cycle of pairing-friendly elliptic curves, that is, two prime-order curves <span class="math">E_{1}</span> and <span class="math">E_{2}</span> such that the prime size of one’s base field is the prime order of the other’s group, and orchestrating SNARKs based on these so that fields “match up”. However, known cycles are inefficient at 128 bits of security <em>[x1, x2]</em>.</p>

    <p class="text-gray-300">We address this problem by noting that we merely need “a proof of a proof”, and thus, instead of relying on a cycle, we can use the Cocks–Pinch method <em>[x10]</em> to set up a bounded recursion <em>[x1]</em>. First we pick a pairing-friendly elliptic curve that not only is suitable for 128 bits of security according to standard considerations but, moreover, is compatible with efficient SNARK provers in both levels of the recursion. Namely, letting <span class="math">p</span> be the prime order of the base field and <span class="math">r</span> the prime order of the group, we need that both <span class="math">\\mathbb{F}_{r}</span> and <span class="math">\\mathbb{F}_{p}</span> have multiplicative subgroups whose orders are large powers of <span class="math">2</span>. The condition on <span class="math">\\mathbb{F}_{r}</span> ensures efficient proving for SNARKs over this curve, while the condition on <span class="math">\\mathbb{F}_{p}</span> ensures efficient proving for SNARKs that verify proofs over this curve. In light of the above, we select a curve <span class="math">E_{\\text{BLS}}</span> from the Barreto–Lynn–Scott (BLS) family <em>[x3, x4]</em> with embedding degree <span class="math">12</span>. This family not only enables parameters that conservatively achieve 128 bits of security, but also enjoys properties that facilitate very efficient implementation <em>[AFK^{+}12]</em>. We ensure that both <span class="math">\\mathbb{F}_{r}</span> and <span class="math">\\mathbb{F}_{p}</span> have multiplicative subgroups of order <span class="math">2^{\\alpha}</span> for <span class="math">\\alpha\\geq 40</span>, by a suitable condition on the parameter of the BLS family.</p>

    <p class="text-gray-300">Next we use the Cocks–Pinch method to pick a pairing-friendly elliptic curve <span class="math">E_{\\text{CP}}</span> over a field <span class="math">\\mathbb{F}_{q}</span> such that the curve group <span class="math">E_{\\text{CP}}(\\mathbb{F}_{q})</span> contains a subgroup of prime order <span class="math">p</span> (the size of <span class="math">E_{\\text{BLS}}</span>’s base field). Since the method outputs a prime <span class="math">q</span> that has about <span class="math">2\\times</span> more bits than the desired <span class="math">p</span>, and in turn <span class="math">p</span> has about <span class="math">1.5\\times</span> more bits than <span class="math">r</span> (due to properties of the BLS family), we only need <span class="math">E_{\\text{CP}}</span> to have embedding degree of <span class="math">6</span> in order to achieve 128 bits of security (as determined from the guidelines in <em>[x10]</em>). We note that this approach is similar to that in Geppetto <em>[CFH^{+}15]</em>, but adapted for BLS12 curves.</p>

    <p class="text-gray-300">In sum, a SNARK over <span class="math">E_{\\text{BLS}}</span> is used to generate proofs of predicates’ satisfiability; after that a zkSNARK over <span class="math">E_{\\text{CP}}</span> is used to generate proofs that these prior proofs are valid along with the remaining NP statement’s checks. The matching fields between the two curves ensure that the former proofs can be efficiently verified.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Minimizing operations over <span class="math">E_{\\text{CP}}</span>.</h4>

    <p class="text-gray-300">While the curve <span class="math">E_{\\text{CP}}</span> facilitates efficient checking of SNARK proofs over <span class="math">E_{\\text{BLS}}</span>, operations on it are at least <span class="math">2\\times</span> more costly (in time and space) than operations over <span class="math">E_{\\text{BLS}}</span>, simply because <span class="math">E_{\\text{CP}}</span>’s base field is twice the size of <span class="math">E_{\\text{BLS}}</span>’s base field. This makes checks in the NP relation <span class="math">\\mathcal{R}_{\\text{e}}</span> that are not related to proof checking unnecessarily expensive.</p>

    <p class="text-gray-300">To avoid this, we split <span class="math">\\mathcal{R}_{\\text{e}}</span> into two NP relations, <span class="math">\\mathcal{R}_{\\text{BLS}}</span> and <span class="math">\\mathcal{R}_{\\text{CP}}</span>. The latter is responsible only for verifying proofs of predicates’ satisfaction, while the former is responsible for all other checks. We minimize the number of <span class="math">E_{\\text{CP}}</span> operations by proving satisfaction of <span class="math">\\mathcal{R}_{\\text{BLS}}</span> and <span class="math">\\mathcal{R}_{\\text{CP}}</span> with zkSNARKs over <span class="math">E_{\\text{BLS}}</span> and <span class="math">E_{\\text{CP}}</span> respectively. A transaction now includes both proofs.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">Optimizing the NP statement.</h4>

    <p class="text-gray-300">We note that the remaining NP statement’s checks can themselves be</p>

    <p class="text-gray-300">quite expensive, as they range from verifying authentication paths in a Merkle tree to verifying commitment openings, and from evaluating pseudorandom functions to evaluating collision resistant functions. Prior work realizing similar collections of checks required upwards of four million gates <em>[BCG^{+}14]</em> to express such checks. This not only resulted in high latencies for producing transactions (several minutes) but also resulted in large public parameters for the system (hundreds of megabytes).</p>

    <p class="text-gray-300">Commitments and collision-resistant hashing can be expressed as very efficient arithmetic circuits if one opts for Pedersen-type constructions over suitable Edwards elliptic curves (and techniques derived from these ideas are now part of deployed systems <em>[x11]</em>). To achieve this, we pick two Edwards curves, <span class="math">E_{\\mathsf{Ed}/\\mathsf{BLS}}</span> over the field <span class="math">\\mathbb{F}_{r}</span> (thereby matching the group order of <span class="math">E_{\\mathsf{BLS}}</span>), and <span class="math">E_{\\mathsf{Ed}/\\mathsf{CP}}</span> over the field <span class="math">\\mathbb{F}_{p}</span> (thereby matching the group order of <span class="math">E_{\\mathsf{CP}}</span>). This allows to realise very efficient circuits for various primitives used in our NP relations, including commitments, collision-resistant hashing, and randomizable signatures. Overall, we obtain highly optimized realizations of all checks in Fig. 4.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">2.6 Deployment considerations</h3>

    <p class="text-gray-300">DPC schemes include a setup algorithm that specifies how to sample public parameters, which are used to produce transactions and to verify transactions. The setup algorithm in our DPC construction (see Section 4) simply consists of running the setup algorithms for the various cryptographic building blocks that we rely on: commitment schemes, collision-resistant hash functions, and zero knowledge proofs.</p>

    <p class="text-gray-300">In practice, deploying cryptography that relies on setup algorithms (such as DPC schemes) can be challenging because the entity running the setup algorithm may be able to break certain security properties of the scheme, by abusing knowledge of the randomness used to produce the public parameters. On the other hand, some setup algorithm is typically inevitable. For example, non-interactive zero knowledge proofs without any setup exist only for languages decidable in polynomial time <em>[x12]</em>. Nevertheless, one could still aim for a transparent setup, one that consists of public randomness, because in practice it is cheaper to realize.</p>

    <p class="text-gray-300">Our construction of a DPC scheme has a transparent setup algorithm whenever the setup algorithms for the underlying cryptographic building blocks also have transparent setups. For example, this would hold if we instantiated our construction via Pedersen commitments, Pedersen hash functions, and transparent zkSNARKs (as obtained from probabilistic checking tools in the random oracle model <em>[x21, x3]</em>).</p>

    <p class="text-gray-300">However, due to efficiency considerations described in Section 2.5, our implemented system relies on pairing-based zkSNARKs whose setup is not transparent. (We use the simulation-extractable zkSNARK of Groth and Maller <em>[x13]</em>.) We should thus discuss how one may deploy our implemented system, and in particular the effects of compromise in the trusted setup phase of these SNARKs. (All other primitives in our system use a transparent setup.)</p>

    <p class="text-gray-300">Recall that prior zkSNARK deployments have used secure multiparty computation <em>[BCG^{+}15, x30, x6, x7]</em>, so that the sampled public parameters are guaranteed to be secure as long as even a single participating party is honest. One could leverage these same ideas to sample “master” parameters for proving/verifying the two NP relations <span class="math">\\mathcal{R}_{\\mathsf{BLS}}</span> and <span class="math">\\mathcal{R}_{\\mathsf{CP}}</span> (over the two elliptic curves <span class="math">E_{\\mathsf{BLS}}</span> and <span class="math">E_{\\mathsf{CP}}</span>) mentioned in Section 2.5. Note that these public parameters do not depend on any user-defined functions (birth or death predicates), and can thus be sampled once and for all regardless of which applications will be run over the system. Note also that these public parameters must be trusted by everyone, because if they were compromised then the security (but not privacy) of all applications running over the system would be compromised as well.</p>

    <p class="text-gray-300">The foregoing public parameters are not the only ones that need to be sampled in order to use our implemented system. Every (birth or death) predicate requires its own public parameters, because (the verification key contained in) these public parameters is part of the record that contains it, and is ultimately</p>

    <p class="text-gray-300">used to recursively check a proof of the predicate’s satisfiability. Since an application relies only on the public parameters of certain predicates, we call such parameters as “application” parameters.</p>

    <p class="text-gray-300">Unlike “master” parameters, “application” parameters do not have to be sampled at the start of the system’s lifetime, and also do not have to be trusted by every user in the system. Indeed, interactions across records are overseen by the NP relations <span class="math">\\mathcal{R}_{\\text{BLS}}</span> and <span class="math">\\mathcal{R}_{\\text{CP}}</span> (which rely on the “master” parameters) and thus compromised parameters for one application will not affect (the security and privacy of) an application that does not rely on them. This means that a user only needs to trust the parameters that are relied upon by the applications that the user cares about. In turn this means that the sampling of application parameters can be viewed as an organic process, which occurs as applications are developed and deployed, and each application can be in charge of deciding whichever method is most suitable for securely sampling its own parameters.</p>

    <p class="text-gray-300">Very recent works <em>[x14, x7, CHM^{+}20, x10]</em> have proposed pairing-based SNARKs that have a universal setup that can be used for <em>any</em> circuit. Once such SNARK constructions mature into efficient implementations, our system can be easily modified to use these instead of <em>[x11]</em> to mitigate the above concerns, as both our construction and implementation make use of the underlying SNARKs in a modular and black-box manner.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">We define decentralized private computation (DPC) schemes, a cryptographic primitive in which parties with access to an ideal append-only ledger execute computations offline and subsequently post privacy-preserving, publicly-verifiable transactions that attest to the correctness of these offline executions. This primitive generalizes prior notions  <span class="math">\\left[\\mathrm{BCG}^{+}14\\right]</span>  that were limited to proving correctness of simple financial invariants.</p>

    <p class="text-gray-300">Below we introduce the data structures, interface, and security requirements for a DPC scheme: Section 3.1 describes the main data structures of a DPC scheme, Section 3.2 defines the syntax of the DPC algorithms, and finally in Section 3.3 we describe the security requirements for DPC schemes via an ideal functionality. We note that our definition of DPC schemes focuses on (correctness and) privacy, because we leave succinctness as a separate efficiency goal that easily follows from suitable building blocks (see Remark 4.1).</p>

    <p class="text-gray-300">In a DPC scheme there are three main data structures: records, transactions, and the ledger.</p>

    <p class="text-gray-300">Records. A record, denoted by the symbol  <span class="math">\\mathbf{r}</span> , is a data structure representing a unit of data. Records can be created or consumed, and these events denote state changes in the system. For example, in a currency application, records store units of the currency, and state changes represent the flow of units in that currency.</p>

    <p class="text-gray-300">In more detail, a record  <span class="math">\\mathbf{r}</span>  has the following attributes (see Fig. 5): (a) a commitment cm, which binds together all other attributes of  <span class="math">\\mathbf{r}</span>  while hiding all information about them; (b) an address public key apk, which specifies the record's owner; (c) a payload payload containing arbitrary application-dependent information; (d) a birth predicate  <span class="math">\\Phi_{\\mathrm{b}}</span>  that must be satisfied when  <span class="math">\\mathbf{r}</span>  is created; (e) a death predicate  <span class="math">\\Phi_{\\mathrm{d}}</span>  that must be satisfied when  <span class="math">\\mathbf{r}</span>  is consumed; and (f) other construction-specific information. Both  <span class="math">\\Phi_{\\mathrm{b}}</span>  and  <span class="math">\\Phi_{\\mathrm{d}}</span>  are arbitrary non-deterministic boolean-valued functions. The payload payload contains a designated subfield isDummy which denotes whether  <span class="math">\\mathbf{r}</span>  is dummy or not.</p>

    <p class="text-gray-300">Informally, the "life" of a (non-dummy) record  <span class="math">\\mathbf{r}</span>  is marked by two events: birth and death. The record  <span class="math">\\mathbf{r}</span>  is born (or is created) when its commitment  <span class="math">\\mathrm{cm}</span>  is posted to the ledger as part of a transaction. Then the record  <span class="math">\\mathbf{r}</span>  dies (or is consumed) when its serial number  <span class="math">\\mathrm{sn}</span>  appears on the ledger as part of a later transaction. At each of these times (birth or death) the corresponding predicate  <span class="math">(\\Phi_{\\mathrm{b}}</span>  or  <span class="math">\\Phi_{\\mathrm{d}})</span>  must be satisfied. Dummy records, on the other hand, can be created freely, but consuming them requires satisfaction of their death predicates. The purpose of dummy records is solely to enable the creation of new non-dummy records.</p>

    <p class="text-gray-300">To consume  <span class="math">\\mathbf{r}</span> , one must also know the address secret key ask corresponding to  <span class="math">\\mathbf{r}</span> 's address public key apk because the serial number sn to be revealed can only be computed from  <span class="math">\\mathbf{r}</span>  and ask. The ledger forbids the same serial number to appear more than once, so that: (a) a record cannot be consumed twice because it is associated to exactly one serial number; (b) others cannot prevent one from consuming a record because it is computationally infeasible to create two distinct records that share the same serial number sn but have distinct commitments cm and cm'.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 5: Diagram of a record.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 6: Diagram of a transaction.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Transactions.</h4>

    <p class="text-gray-300">A transaction, denoted by the symbol <span class="math">\\mathsf{tx}</span>, is a data structure representing a state change that involves the consumption and creation of records (see Fig. 6). It is a tuple <span class="math">([\\mathsf{sn}_{i}]_{1}^{m},[\\mathsf{cm}_{j}]_{1}^{n},\\mathsf{memo},\\star)</span> where (a) <span class="math">[\\mathsf{sn}_{i}]_{1}^{m}</span> is the list of serial numbers of the <span class="math">m</span> old records, (b) <span class="math">[\\mathsf{cm}_{j}]_{1}^{n}</span> is the list of commitments of the <span class="math">n</span> new records, (c) <span class="math">\\mathsf{memo}</span> is an arbitrary string associated with the transaction, and (d) <span class="math">\\star</span> is other construction-specific information. The transaction <span class="math">\\mathsf{tx}</span> reveals only the following information about old and new records: (i) the old records’ serial numbers; (ii) the new records’ commitments; and (iii) the fact that the death predicates of all consumed records and birth predicates of all new records were satisfied.</p>

    <p class="text-gray-300">Anyone can assemble a transaction and append it to the ledger, provided that it is “valid” in the sense that (all records are well-formed and) the death predicates of any consumed records and the birth predicates of any created records are satisfied. Note that all transactions reveal the number of old records (<span class="math">m</span>) and the number of new records (<span class="math">n</span>), but not how many of these were dummy or not.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">Ledger.</h4>

    <p class="text-gray-300">We consider a model where all parties have access to an append-only ledger, denoted <span class="math">\\mathbf{L}</span>, that stores all published transactions. Our definitions (and constructions) are <em>agnostic</em> to how this ledger is realized (e.g., the ledger may be centrally managed or a distributed protocol). When an algorithm needs to interact with the ledger, we specify <span class="math">\\mathbf{L}</span> in the algorithm’s superscript. The ledger exposes the following interface.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{L}.\\mathsf{Len}</span>: Return the number of transactions currently on the ledger.</li>

      <li><span class="math">\\mathbf{L}.\\mathsf{Push}(\\mathsf{tx})</span>: Append a (valid) transaction <span class="math">\\mathsf{tx}</span> to the ledger.</li>

      <li><span class="math">\\mathbf{L}.\\mathsf{Digest}\\rightarrow\\mathsf{st}_{\\mathbf{L}}</span>: Return a (short) digest of the current state of the ledger.</li>

      <li><span class="math">\\mathbf{L}.\\mathsf{ValidateDigest}(\\mathsf{st}_{\\mathbf{L}})\\rightarrow b</span>: Check that <span class="math">\\mathsf{st}_{\\mathbf{L}}</span> is a valid digest for some (past) ledger state.</li>

      <li><span class="math">\\mathbf{L}.\\mathsf{Contains}(\\mathsf{tx})\\rightarrow b</span>: Determine if <span class="math">\\mathsf{tx}</span> (or a subcomponent thereof) appears on the ledger or not.</li>

      <li><span class="math">\\mathbf{L}.\\mathsf{Prove}(\\mathsf{tx})\\rightarrow\\mathsf{w}_{\\mathbf{L}}</span>: If a transaction <span class="math">\\mathsf{tx}</span> (or a subcomponent thereof) appears on the ledger, return a proof of membership <span class="math">\\mathsf{w}_{\\mathbf{L}}</span> for it. If there are duplicates, return a proof for the lexicographically first one.</li>

      <li><span class="math">\\mathbf{L}.\\mathsf{Verify}(\\mathsf{st}_{\\mathbf{L}},\\mathsf{tx},\\mathsf{w}_{\\mathbf{L}})\\rightarrow b</span>: Check that <span class="math">\\mathsf{w}_{\\mathbf{L}}</span> certifies that <span class="math">\\mathsf{tx}</span> (or a subcomponent thereof) is in a ledger with digest <span class="math">\\mathsf{st}_{\\mathbf{L}}</span>.</li>

    </ul>

    <p class="text-gray-300">We stress that only “valid” transactions can be appended to the ledger. While the full definition of a valid transaction is implementation dependent, in all cases it must be that the commitments and serial numbers in a transaction (including any appearing in the <span class="math">\\star</span> field of a transaction) do not already appear on the ledger.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">3.2 Algorithms</h3>

    <p class="text-gray-300">A DPC scheme is a tuple of algorithms (some of which may read information from <span class="math">\\mathbf{L}</span>):</p>

    <p class="text-gray-300"><span class="math">\\mathsf{DPC}=(\\mathsf{Setup},\\mathsf{GenAddress},\\mathsf{Execute}^{\\mathbf{L}},\\mathsf{Verify}^{\\mathbf{L}})\\enspace.</span></p>

    <p class="text-gray-300">The syntax and semantics of these algorithms are informally described below.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">Setup:</h4>

    <p class="text-gray-300"><span class="math">\\mathsf{DPC}.\\mathsf{Setup}(1^{\\lambda})\\rightarrow\\mathsf{pp}.</span></p>

    <p class="text-gray-300">On input a security parameter <span class="math">1^{\\lambda}</span>, <span class="math">\\mathsf{DPC}.\\mathsf{Setup}</span> outputs public parameters <span class="math">\\mathsf{pp}</span> for the system. A trusted party runs this algorithm once and then publishes its output; afterwards the trusted party is not needed anymore.</p>

    <p class="text-gray-300">For some constructions, the trusted party can be replaced by an efficient multiparty computation that securely realizes the <span class="math">\\mathsf{DPC}.\\mathsf{Setup}</span> algorithm (see <em>[BCG^{+}15, x20, x1, x2]</em> for how this has been done in some systems); in other constructions, the trusted party may not be needed, as the public parameters may simply consist of a random string of a certain length.</p>

    <p class="text-gray-300">Create address: DPC.GenAddress(pp)  <span class="math">\\rightarrow</span>  (apk, ask).</p>

    <p class="text-gray-300">On input public parameters pp, DPC.GenAddress outputs an address key pair (apk, ask). Any user may run this algorithm to create an address key pair. Each record is bound to an address public key, and the corresponding secret key is used to consume it.</p>

    <p class="text-gray-300">Execute: Any user may invoke DPC.execute to consume records and create new ones.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a></p>

    <p class="text-gray-300">Given as input a list of old records  <span class="math">[\\mathbf{r}_i]_1^m</span>  with corresponding secret keys  <span class="math">[\\mathsf{ask}_i]_1^m</span> , attributes for new records, private auxiliary input aux to birth and death predicates of new and old records respectively, and an arbitrary transaction memorandum memo, DPC.execute produces new records  <span class="math">[\\mathbf{r}_j]_1^n</span>  and a transaction tx. The transaction attests that the input records' death predicates and the output records' birth predicates are all satisfied. The user subsequently pushes tx to the ledger by invoking L.Push(tx).</p>

    <p class="text-gray-300">Verify: DPC.Verify <span class="math">^{\\mathbf{L}}</span>  (pp, tx)  <span class="math">\\rightarrow</span>  b.</p>

    <p class="text-gray-300">On input public parameters pp and a transaction tx, and given oracle access to the ledger L, DPC.Verify outputs a bit  <span class="math">b</span>  denoting whether the transaction tx is valid relative to the ledger L.</p>

    <p class="text-gray-300">Informally, a DPC scheme achieves the following security goals.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Execution correctness. Malicious parties cannot create valid transactions if the death predicate of some consumed record or the birth predicate of some created record is not satisfied.</li>

      <li>Execution privacy. Transactions reveal only the information revealed in the memorandum field, a bound on the number of consumed records, and a bound on the number of created records. <span class="math">^{8}</span>  All other information is hidden, including the payloads and predicates of all involved records. For example, putting aside the information revealed in the memorandum (which is arbitrary), one cannot link a transaction that consumes a record with the prior transaction that created it.</li>

      <li>Consumability. Every record can be consumed at least once and at most once by parties that know its secrets. Thus, a malicious party cannot create two valid records for another party such that only one of them can be consumed. (This captures security against "faerie-gold" attacks [HBHW20].)</li>

      <li>Transaction non-malleability. Malicious parties cannot modify a transaction "in flight" to the ledger.</li>

    </ul>

    <p class="text-gray-300">Formally, we prove standalone security against static corruptions, in a model where every party has private anonymous channels to all other parties [IKOS06]. In Appendix C we discuss how to prove security under</p>

    <p class="text-gray-300">composition and against adaptive corruptions.) In more detail, we capture security of a DPC scheme via a <em>simulation-based</em> security definition that is akin to UC security <em>[x10]</em>, but restricted to a single execution.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Definition 3.1.</h6>

    <p class="text-gray-300">A DPC scheme <span class="math">\\mathsf{DPC}</span> is secure if for every efficient real-world adversary <span class="math">\\mathcal{A}</span> there exists an efficient ideal-world simulator <span class="math">\\mathcal{S}_{\\mathcal{A}}</span> such that for every efficient environment <span class="math">\\mathcal{E}</span> the following are computationally indistinguishable:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>the output of <span class="math">\\mathcal{E}</span> when interacting with the adversary <span class="math">\\mathcal{A}</span> in a real-world execution of <span class="math">\\mathsf{DPC}</span> in a model where parties can communicate with other parties via private anonymous channels; and</li>

      <li>the output of <span class="math">\\mathcal{E}</span> when interacting with the simulator <span class="math">\\mathcal{S}_{\\mathcal{A}}</span> in an ideal-world execution with the ideal functionality <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}</span> specified in Fig. 7 (and further described below).</li>

    </ul>

    <p class="text-gray-300">We describe the data structures used by the ideal functionality <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}</span>, the internal state of <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}</span>, and the interface offered by <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}</span> to parties in the ideal-world execution.</p>

    <p class="text-gray-300">Ideal data structures. The ideal functionality <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}</span> uses ideal counterparts of a DPC scheme’s data structures. An <em>address public key</em> <span class="math">\\mathsf{apk}</span> denotes the owner of an <em>ideal record</em> <span class="math">\\mathcal{r}</span>, which is a tuple <span class="math">(\\mathsf{cm},\\mathsf{apk},\\mathsf{payload},\\Phi_{\\mathsf{b}},\\Phi_{\\mathsf{d}})</span>, where <span class="math">\\mathsf{cm}</span> is its commitment, <span class="math">\\mathsf{apk}</span> is its address public key, <span class="math">\\mathsf{payload}</span> is its payload, and <span class="math">\\Phi_{\\mathsf{b}}</span> and <span class="math">\\Phi_{\\mathsf{d}}</span> are its birth and death predicates. The record is also associated with a unique identifier (or <em>serial number</em>) <span class="math">\\mathsf{sn}</span>. We require that <span class="math">\\mathsf{apk}</span>, <span class="math">\\mathsf{cm}</span>, and <span class="math">\\mathsf{sn}</span> are “globally unique”; this means that there cannot be two different ideal records <span class="math">\\mathcal{r}</span> and <span class="math">\\mathcal{r}^{\\prime}</span> having the same commitments or serial numbers.</p>

    <p class="text-gray-300">The distribution of these components is specified by the simulator <span class="math">\\mathcal{S}</span> as follows. Before the ideal execution begins, <span class="math">\\mathcal{S}</span> specifies three functions <span class="math">(\\mathsf{SampleAddrPk},\\mathsf{SampleCm},\\mathsf{SampleSn})</span> that, on input a random string, sample <span class="math">(\\mathsf{apk},\\mathsf{cm},\\mathsf{sn})</span> respectively. When <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}</span> needs to sample one of these, it invokes the respective functions. (Note that <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}</span> cannot directly ask <span class="math">\\mathcal{S}</span> to sample these because that would reveal to <span class="math">\\mathcal{S}</span> when an honest party was invoking <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}.\\mathsf{GenAddress}</span> or <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}.\\mathsf{Execute}</span>, and we cannot afford this leakage.)</p>

    <p class="text-gray-300">Internal state. The ideal functionality <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}</span> maintains several internal tables.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>Addr, which stores address public keys.</li>

      <li>AddrUsers, which maps an address public key to the set of parties that are authorized to use it.</li>

      <li>Records, which maps a record’s commitment to that record’s information (address public key, payload, birth predicate, and death predicates).</li>

      <li>RecUsers, which maps a record’s commitment to the set of parties that are authorized to consume it. Note that, for a record <span class="math">\\mathcal{r}</span>, the set <span class="math">\\mathsf{RecUsers}[\\mathcal{r}.\\mathsf{cm}]</span> can be different from the set in <span class="math">\\mathsf{AddrUsers}[\\mathcal{r}.\\mathsf{apk}]</span>, but a party <span class="math">\\mathcal{P}</span> has to be in both sets to consume <span class="math">\\mathcal{r}</span>.</li>

      <li>SerialNumbers, which maps a record’s commitment to that record’s (unique) serial number.</li>

      <li>State, which maps a record’s commitment to that record’s state, either alive or dead.</li>

    </ul>

    <p class="text-gray-300">Ideal algorithms. The ideal functionality <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}</span> provides the following interface to parties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>Address generation: <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}.\\mathsf{GenAddress}</span> outputs a new address public key <span class="math">\\mathsf{apk}</span>.</li>

      <li>Execution: <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}.\\mathsf{Execute}</span> performs an execution that consumes old records and creates new records. All parties are notified that an execution has occurred, and learn the serial numbers of input records, commitments of output records, and the transaction memorandum <span class="math">\\mathsf{memo}</span>. Concurrent <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}.\\mathsf{Execute}</span> calls are serialized arbitrarily.</li>

      <li>Record consumption authorization: <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}.\\mathsf{ShareRecord}</span> allows a party <span class="math">\\mathcal{P}</span> to authorize another party <span class="math">\\mathcal{P}^{\\prime}</span> to consume a record <span class="math">\\mathcal{r}</span> (provided that <span class="math">\\mathcal{P}^{\\prime}</span> is also authorized to use <span class="math">\\mathcal{r}</span>’s address public key).</li>

    </ul>

    <p class="text-gray-300">Operation of honest parties. In both the real and ideal executions, the environment <span class="math">\\mathcal{E}</span> can send instructions to honest parties. These instructions can be one of <span class="math">\\mathsf{GenAddress}</span>, <span class="math">\\mathsf{Execute}</span>, or <span class="math">\\mathsf{ShareRecord}</span>. In the real world honest parties translate these instructions into corresponding invocations of <span class="math">\\mathsf{DPC}</span> algorithms (or messages sent via private anonymous channels as in the case of <span class="math">\\mathsf{ShareRecord}</span>), while in the ideal world they translate</p>

    <p class="text-gray-300">them into corresponding invocations of <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}</span> algorithms. In both worlds, honest parties immediately invoke ShareRecord on records obtained from an Execute instruction. Finally, in the ideal world, when invoking <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}</span>, honest parties do not provide any inputs marked as optional; instead, they let <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}</span> sample these.</p>

    <p class="text-gray-300">Intuition. We explain how <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}</span> enforces the informal security notions described at this section’s beginning.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Execution correctness. <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}</span>. Execute ensures that the death predicates of consumed records and birth predicates of created records are satisfied by the local data. Note that each predicate receives its own position as input so that it knows to which record in the local data it belongs.</li>

      <li>Execution privacy. Transactions contain serial numbers <span class="math">[\\mathsf{sn}_{i}]_{1}^{m}</span> of consumed records, commitments <span class="math">[\\mathsf{cm}_{j}]_{1}^{n}</span> of created records, and a memorandum memo. Serial numbers and commitments are sampled via SampleSn and SampleCm, so they are independent of the contents of any record, and thus reveal no information about them. Transactions thus reveal no information (beyond what is contained in memo).</li>

      <li>Consumability. From the point of view of <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}</span>, two records are different if and only if they have different commitments. In such a case, both records can be consumed as long as their death predicates are satisfied. If a DPC scheme realizes <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}</span>, then it must satisfy this same requirement: if two valid records have distinct commitments, then they must both be consumable.</li>

      <li>Transaction non-malleability. The adversary has no power to modify the inputs to, or output of, an honest party’s invocation of <span class="math">\\mathcal{F}_{\\text{\\tiny DPC}}</span>. Execute.</li>

    </ul>

    <p class="text-gray-300">##</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_DPC.GenAddress[P] ((optional) address public key apk) 1. Sample randomness r for generating address public key. 2. If apk = ⊥ then apk ← SampleAddrPk(r). 3. Check that apk is unique: Addr[apk] = ⊥. 4. Set Addr[apk] := r. 5. If P is corrupted: set S to be the set of corrupted parties. 6. If P is honest: set S := {P}. 7. Set AddrUsers[apk] := AddrUsers[apk] ∪ S. 8. Send to P: address public key apk.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_DPC.ShareRecord[P] (record r recipient party P') 1. If Records[r.cm] ≠ ⊥: (a) Check that P ∈ RecUsers[r.cm]. (b) Retrieve ((cm, apk, payload, Φb, Φd), r) := Records[r.cm]. 2. If P' is corrupted: set S to be the set of corrupted parties. 3. If P' is honest: set S := {P'}. 4. Set RecUsers[r.cm] := RecUsers[r.cm] ∪ S. 5. If P is honest and P' isn't, Send to P': (RecordAuth, (r, r)). 6. Else, Send to P': (RecordAuth, r).</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F_DPC Execute[P] (old records (optional) old serial numbers (optional) new record commitments new address public keys new record payloads new record birth predicates new record death predicates auxiliary predicate input transaction memorandum</td>

            <td class="px-3 py-2 border-b border-gray-700">[ri]1m [sn]1m [cmj]1n [apkj]1n [payloadj]1n [Φb,j]1n [Φd,j]1n aux memo</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1. For each i ∈ {1,...,m}: (a) Sample randomness ri. (b) If sn_i = ⊥ then generate serial number: sn_i ← SampleSn(ri). (c) Check that sn_i is unique: SerialNumbers[sn_i] = ⊥. 2. For each j ∈ {1,...,n}: (a) Sample randomness rj. (b) If cmj = ⊥ then generate commitment: cmj ← SampleCm(rj). (c) Check that cmj is unique: Records[cmj] = ⊥. (d) Construct record: rj := (cmj, apkj, payloadj, Φb,j, Φd,j). 3. Define the local data ldata := ([ri]1m, [sn]1m, [rj]1n, aux, memo). 4. For each i ∈ {1,...,m}: (a) Parse ri as (cm_i, apki, payloadi, Φb,i, Φd,i). (b) Check that, for some randomness ri, old record ri exists: ((apki, payloadi, Φb,i, Φd,i), ri) = Records[cmj]. (c) Check that P is authorized to use apki: P ∈ AddrUsers[apki]. (d) If payloadi, isDummy = 0: i. Check that record is unconsumed: State[ri] = alive. ii. Check that P is authorized to consume ri: P ∈ RecUsers[cmj]. iii. Check that P is authorized to use apki: P ∈ AddrUsers[apki]. (e) Check that death predicate is satisfied: Φd,i(i</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ldata) = 1. (f) Mark it as consumed: State[cmj] := dead. 5. For each j ∈ {1,...,n}: (a) Check that birth predicate is satisfied: Φb,j(j</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ldata) = 1. (b) Insert new record rj: Records[cmj] := ((apki, payloadj, Φb,j, Φd,j), rj). (c) Mark new record as unconsumed: State[cmj] := alive. 6. Send to P: ([rj]1n). 7. Send to all parties: (Execute, [sn]1m, [cmj]1n, memo).</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 7: Ideal functionality  <span class="math">\\mathcal{F}_{\\mathrm{DPC}}</span>  of a DPC scheme.</p>

    <p class="text-gray-300">4 Construction of decentralized private computation schemes</p>

    <p class="text-gray-300">We describe our construction of a DPC scheme. In Section 4.1 we introduce the building blocks that we use, and in Section 4.2 we describe each algorithm in the scheme. The security proof is provided in Appendix A. We also describe some extensions of our construction, in functionality and in security, in Appendix C.</p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">4.1 Building blocks</h3>

    <p class="text-gray-300">CRHs. A collision-resistant hash function <span class="math">\\mathsf{CRH}=(\\mathsf{Setup},\\mathsf{Eval})</span> works as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Setup:</em> on input a security parameter, <span class="math">\\mathsf{CRH}.\\mathsf{Setup}</span> samples public parameters <span class="math">\\mathsf{pp}_{\\mathsf{CRH}}</span>.</li>

      <li><em>Hashing:</em> on input public parameters <span class="math">\\mathsf{pp}_{\\mathsf{CRH}}</span> and message <span class="math">m</span>, <span class="math">\\mathsf{CRH}.\\mathsf{Eval}</span> outputs a short hash <span class="math">h</span> of <span class="math">m</span>.</li>

    </ul>

    <p class="text-gray-300">Given public parameters <span class="math">\\mathsf{pp}_{\\mathsf{CRH}}\\leftarrow\\mathsf{CRH}.\\mathsf{Setup}(1^{\\lambda})</span>, it is computationally infeasible to find distinct inputs <span class="math">x</span> and <span class="math">y</span> such that <span class="math">\\mathsf{CRH}.\\mathsf{Eval}(\\mathsf{pp}_{\\mathsf{CRH}},x)=\\mathsf{CRH}.\\mathsf{Eval}(\\mathsf{pp}_{\\mathsf{CRH}},y)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PRFs. A pseudorandom function family $\\mathsf{PRF}=\\{\\mathsf{PRF}_{x}\\colon\\{0,1\\}^{*}\\to\\{0,1\\}^{O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\}_{x}<span class="math">, where </span>x$ denotes the seed, is computationally indistinguishable from a random function family.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Commitments. A commitment scheme <span class="math">\\mathsf{CM}=(\\mathsf{Setup},\\mathsf{Commit})</span> enables a party to generate a (perfectly) hiding and (computationally) binding commitment to a given message.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Setup:</em> on input a security parameter, <span class="math">\\mathsf{CM}.\\mathsf{Setup}</span> samples public parameters <span class="math">\\mathsf{pp}_{\\mathsf{CM}}</span>.</li>

      <li><em>Commitment:</em> on input public parameters <span class="math">\\mathsf{pp}_{\\mathsf{CM}}</span>, message <span class="math">m</span>, and randomness <span class="math">r_{\\mathsf{cm}}</span>, <span class="math">\\mathsf{CM}.\\mathsf{Commit}</span> outputs a commitment <span class="math">\\mathsf{cm}</span> to <span class="math">m</span>.</li>

    </ul>

    <p class="text-gray-300">We also use a <em>trapdoor</em> commitment scheme <span class="math">\\mathsf{TCM}=(\\mathsf{Setup},\\mathsf{Commit})</span>, with the same syntax as above. Auxiliary algorithms (beyond those in <span class="math">\\mathsf{CM}</span>) enable producing a trapdoor and using it to open a commitment, originally to an empty string, to an arbitrary message. These algorithms are used only in the proof of security, and so we introduce them there (see Appendix A).</p>

    <p class="text-gray-300">NIZKs. Non-interactive zero knowledge arguments of knowledge enable a party, known as the <em>prover</em>, to convince another party, known as the <em>verifier</em>, about knowledge of the witness for an <span class="math">\\mathsf{NP}</span> statement without revealing any information about the witness (besides what is already implied by the statement being true). This primitive is a tuple <span class="math">\\mathsf{NIZK}=(\\mathsf{Setup},\\mathsf{Prove},\\mathsf{Verify})</span> with the following syntax.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Setup:</em> on input a security parameter and the specification of an <span class="math">\\mathsf{NP}</span> relation <span class="math">\\mathcal{R}</span>, <span class="math">\\mathsf{NIZK}.\\mathsf{Setup}</span> outputs a set of public parameters <span class="math">\\mathsf{pp}_{\\mathsf{NIZK}}</span> (also known as a <em>common reference string</em>).</li>

      <li><em>Proving:</em> on input <span class="math">\\mathsf{pp}_{\\mathsf{NIZK}}</span> and an instance-witness pair <span class="math">(\\mathtt{x},\\mathtt{w})\\in\\mathcal{R}</span>, <span class="math">\\mathsf{NIZK}.\\mathsf{Prove}</span> outputs a proof <span class="math">\\pi</span>.</li>

      <li><em>Verifying:</em> on input <span class="math">\\mathsf{pp}_{\\mathsf{NIZK}}</span>, instance <span class="math">\\mathtt{x}</span>, and proof <span class="math">\\pi</span>, <span class="math">\\mathsf{NIZK}.\\mathsf{Verify}</span> outputs a decision bit.</li>

    </ul>

    <p class="text-gray-300"><em>Completeness</em> states that honestly generated proofs make the verifier accept; <em>(computational) proof of knowledge</em> states that if the verifier accepts a proof for an instance then the prover “knows” a witness for it; and <em>perfect zero knowledge</em> states that honestly generated proofs can be perfectly simulated, when given a trapdoor to the public parameters. In fact, we require a strong form of (computational) proof of knowledge known as <em>simulation-extractability</em>, which states that proofs continue to be proofs of knowledge even when the adversary has seen prior simulated proofs. For more details, see <em>[x28, DDO^{+}01, x10]</em>.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Remark 4.1.</h6>

    <p class="text-gray-300">If <span class="math">\\mathsf{NIZK}</span> is additionally <em>succinct</em> (i.e., it is a simulation-extractable zkSNARK) then the DPC scheme constructed in this section is also <em>succinct</em>. This is the case in our implementation; see Section 8.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">4.2 Algorithms</h3>

    <p class="text-gray-300">Pseudocode for our construction of a DPC scheme is in Fig. 8. The construction involves invoking zero knowledge proofs for the NP relation <span class="math">\\mathcal{R}_{\\mathsf{e}}</span> described in Fig. 9. The text below is a summary of the construction.</p>

    <p class="text-gray-300">System setup. DPC.Setup is a wrapper around the setup algorithms of cryptographic building blocks. It invokes CM.Setup, TCM.Setup, CRH.Setup, and NIZK.Setup to obtain (plain and trapdoor) commitment public parameters  <span class="math">\\mathsf{pp}_{\\mathsf{CM}}</span>  and  <span class="math">\\mathsf{pp}_{\\mathsf{TCM}}</span> , CRH public parameters  <span class="math">\\mathsf{pp}_{\\mathsf{CRH}}</span> , and NIZK public parameters for the NP relation  <span class="math">\\mathcal{R}_{\\mathrm{e}}</span>  (see Fig. 9). It then outputs  <span class="math">\\mathsf{pp} := (\\mathsf{pp}_{\\mathsf{CM}}, \\mathsf{pp}_{\\mathsf{TCM}}, \\mathsf{pp}_{\\mathsf{CRH}}, \\mathsf{pp}_{\\mathrm{e}})</span> .</p>

    <p class="text-gray-300">Address creation. DPC.GenAddress constructs an address key pair as follows. The address secret key ask = (skPRF,  <span class="math">r_{\\mathrm{pk}}</span> ) consists of a secret key skPRF for the pseudorandom function PRF, and commitment randomness  <span class="math">r_{\\mathrm{pk}}</span> . The address public key apk is a perfectly hiding commitment to skPRF with randomness  <span class="math">r_{\\mathrm{pk}}</span> .</p>

    <p class="text-gray-300">Execution. DPC.execute produces a transaction attesting that some old records  <span class="math">[\\mathbf{r}_i]_1^m</span>  were consumed and some new records  <span class="math">[\\mathbf{r}_j]_1^n</span>  were created, and that their death and birth predicates were satisfied. First, DPC.execute computes a ledger membership witness and serial number for every old record. Then, DPC.execute invokes the following auxiliary function to create record commitments for the new records.</p>

    <pre><code class="language-txt">DPC.ConstructRecord(pp, apk, payload,  $\\Phi_{\\mathrm{b}}, \\Phi_{\\mathrm{d}}, \\rho) \\rightarrow (\\mathbf{r}, \\mathbf{cm})$</code></pre>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample new commitment randomness  <span class="math">r</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Construct new record commitment: cm  <span class="math">\\leftarrow</span>  TCM.Commit(ppTCM, apk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">payload</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Φb</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Φd</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ; r).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Construct new record  <span class="math">\\mathbf{r} := \\left( \\begin{array}{cccccc} \\text{address public key} &amp;amp; \\text{apk} &amp;amp; \\text{payload} &amp;amp; \\text{payload} &amp;amp; \\text{comm. rand.} &amp;amp; r \\\\ \\text{serial number nonce} &amp;amp; \\rho &amp;amp; \\text{predicates} &amp;amp; (\\Phi_{\\mathrm{b}}, \\Phi_{\\mathrm{d}}) &amp;amp; \\text{commitment} &amp;amp; \\mathbf{cm} \\end{array} \\right)</span> .</li>

      <li>Output  <span class="math">(\\mathbf{r},\\mathbf{cm})</span></li>

    </ol>

    <p class="text-gray-300">Information about all records, secret addresses of old records, the desired transaction memorandum memo, and desired auxiliary predicate input aux are collected into the local data ldata (see Fig. 9).</p>

    <p class="text-gray-300">Finally, DPC.execute produces a proof that all records are well-formed and that several conditions hold.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Old records are properly consumed, namely, for every old record  <span class="math">\\mathbf{r}_i \\in [\\mathbf{r}_i]_1^m</span> :</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(if  <span class="math">\\mathbf{r}_i</span>  is not dummy)  <span class="math">\\mathbf{r}_i</span>  exists, demonstrated by checking a ledger membership witness for  <span class="math">\\mathbf{r}_i</span> 's commitment;</li>

      <li><span class="math">\\mathbf{r}_i</span>  has not been consumed, demonstrated by publishing  <span class="math">\\mathbf{r}_i</span> 's serial number  <span class="math">\\mathsf{sn}_i</span> ;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  <span class="math">\\mathbf{r}_i</span> 's death predicate  <span class="math">\\Phi_{\\mathrm{d},i}</span>  is satisfied, demonstrated by checking that  $\\Phi_{\\mathrm{d},i}(i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{ldata}) = 1$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>New records are property created, namely, for every new record  <span class="math">\\mathbf{r}_j \\in [\\mathbf{r}_j]_1^n</span> :</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  <span class="math">\\mathbf{r}_j</span> 's serial number is unique, achieved by generating the nonce  <span class="math">\\rho_j</span>  as CRH.Eval(ppCRH,  $j\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sn}_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sn}_m)$ ;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The serial number sn of a record  <span class="math">\\mathbf{r}</span>  relative to an address secret key ask = (skPRF,  <span class="math">r_{\\mathrm{pk}}</span> ) is derived by evaluating PRF at  <span class="math">\\mathbf{r}</span> 's serial number nonce  <span class="math">\\rho</span>  with seed skPRF. This ensures that sn is pseudorandom even to a party that knows all of  <span class="math">\\mathbf{r}</span>  but not ask (e.g., to a party that created the record for some other party). Note that each predicate receives its own position as input so that it knows to which record in the local data it belongs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DPC.Setup Input: security parameter 1^λ Output: public parameters pp</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DPC.GenAddress Input: public parameters pp Output: address key pair (apk, ask)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1. Generate commitment parameters: ppCM← CM.Setup(1^λ), ppTCM← TCM.Setup(1^λ).</td>

            <td class="px-3 py-2 border-b border-gray-700">1. Sample secret key skPRF for pseudorandom function PRF.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2. Generate CRH parameters: ppCRH← CRH.Setup(1^λ).</td>

            <td class="px-3 py-2 border-b border-gray-700">2. Sample randomness rpk for commitment scheme CM.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. Generate NIZK parameters for Re (see Figure 9): ppe← NIZK.Setup(1^λ, Re).</td>

            <td class="px-3 py-2 border-b border-gray-700">3. Set address public key apk := CM.Commit(ppCM, skPRF; rpk).</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4. Output pp := (ppCM, ppTCM, pPCRH, ppe).</td>

            <td class="px-3 py-2 border-b border-gray-700">4. Set address secret key ask := (skPRF, rpk).</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | 5. Output (apk, ask).  |</p>

    <p class="text-gray-300">|  DPC Execute^L Input: · public parameters pp · old { records [r_i]_1^m address secret keys [ask_i]_1^m · new { address public keys [apk_j]_1^n record payloads [payload_j]_1^n record birth predicates [Φb,j]_1^n record death predicates [Φd,j]_1^n · auxiliary predicate input aux · transaction memorandum memo Output: new records [r_j]_1^n and transaction tx  |   |</p>

    <p class="text-gray-300">|  1. For each i ∈ {1,...,m}, process the i-th old record as follows: (a) Parse old record ri as (address public key apki payload payloadi comm. rand. ri serial number nonce ρi predicates (Φb,i, Φd,i) commitment cm_i). (b) If payload_i.isDummy = 1, set ledger membership witness wL,i := ⊥. If payload_i.isDummy = 0, compute ledger membership witness for commitment: wL,i ← L.Prove(cmi). (c) Parse address secret key ask_i as (skPRF,i, rpk,i). (d) Compute serial number: sn_i ← PRFskPRF,i(ρi).  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. For each j ∈ {1,...,n}, construct the j-th new record as follows: (a) Compute serial number nonce: ρj := CRH.Eval(ppCRH, j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sn1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sn_m). (b) Construct new record: (rj, cmj) ← DPC.ConstructRecord(ppTCM, apkj, payloadj, Φb,j, Φd,j, ρj).</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  3. Retrieve current ledger digest: stL ← L.Digest.  |   |</p>

    <p class="text-gray-300">|  4. Construct instance x_e for Re: x_e := (stL, [sn_i]_1^m, [cm_j]_1^n, memo).  |   |</p>

    <p class="text-gray-300">|  5. Construct witness w_e for Re: w_e := ([r_i]_1^m, [w_L,i]_1^m, [ask_i]_1^m, [r_j]_1^n, aux).  |   |</p>

    <p class="text-gray-300">|  6. Generate proof for Re: π_e ← NIZK.Prove(pp_e, x_e, w_e).  |   |</p>

    <p class="text-gray-300">|  7. Construct transaction: tx := ([sn_i]_1^m, [cm_j]_1^n, memo, <em>), where </em> := (stL, π_e).  |   |</p>

    <p class="text-gray-300">|  8. Output ([r_j]_1^n, tx).  |   |</p>

    <p class="text-gray-300">|  DPC.Verify^L Input: public parameters pp and transaction tx Output: decision bit b  |   |</p>

    <p class="text-gray-300">|  1. Parse tx as ([sn_i]_1^m, [cm_j]_1^n, memo, <em>) and </em> as (stL, π_e).  |   |</p>

    <p class="text-gray-300">|  2. Check that there are no duplicate serial numbers (a) within the transaction tx: sn_i ≠ sn_j for every distinct i, j ∈ {1,...,m}; (b) on the ledger: L Contains(sn_i) = 0 for every i ∈ {1,...,m}.  |   |</p>

    <p class="text-gray-300">|  3. Check that the ledger state is valid: L.ValidateDigest(stL) = 1.  |   |</p>

    <p class="text-gray-300">|  4. Construct instance for the relation Re: x_e := (stL, [sn_i]_1^m, [cm_j]_1^n, memo).  |   |</p>

    <p class="text-gray-300">|  5. Check proof for the relation Re: NIZK.Verify(pp_e, x_e, π_e) = 1.  |   |</p>

    <p class="text-gray-300">Figure 8: Construction of a DPC scheme.</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Figure 9: The execute NP relation  <span class="math">\\mathcal{R}_{\\mathrm{e}}</span></p>

    <p class="text-gray-300">5 Delegating zero knowledge execution</p>

    <p class="text-gray-300">The cost of creating a transaction in the DPC scheme from Section 4 grows with the complexity (and number of) predicates involved in the transaction. The user must produce, and include in the transaction, a cryptographic proof that, among other things, attests that death predicates of consumed records are satisfied and, similarly, that birth predicates of created records are satisfied. This implies that producing transactions on weak devices such as mobile phones or hardware tokens quickly becomes infeasible.</p>

    <p class="text-gray-300">In Sections 5.1 to 5.3 we explain how to address this problem by enabling a user to <em>delegate</em> to an untrusted worker, such as a remote server, the computation that produces a transaction. This empowers weak devices to produce transactions that they otherwise could not have produced on their own. Then, in Section 5.4, we explain how the ideas that we use for delegating transactions also yield solutions for achieving <em>threshold transactions</em> and <em>blind transactions</em> in a DPC scheme, which are also valuable in applications. Techniques derived from these ideas are now part of deployed systems <em>[x11]</em>.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">5.1 Approach</h3>

    <p class="text-gray-300">A naive approach is for the user to simply ask the worker to produce the cryptographic proof on its behalf, and then include this proof in the transaction. The intuition behind this idea is that the user can check that the proof received from the worker is valid, by simply running the proof verification procedure. Indeed, whenever the DPC scheme uses a succinct argument (see Remark 4.1), the verification procedure is <em>succinct</em>.</p>

    <p class="text-gray-300">However, this approach is <em>insecure</em>, because the worker, in order to produce a proof, would have to learn not only the instance but also the secret witness for the NP statement being proved. Since the secret witness includes the user’s address secret key, if the worker learns this information then the worker can impersonate the user, e.g., by producing further transactions that the user never <em>authorized</em>. This naive approach also fails in prior proof-based ledger protocols, including Zerocash <em>[BCG^{+}14]</em>. New ideas are needed.</p>

    <p class="text-gray-300">Taking our construction of a DPC scheme from Section 4 as a starting point, we explain how to enable a user to delegate the expensive proof computation to a worker in such a way that the worker <em>cannot</em> produce valid transactions that have not been authorized by the user; see Fig. 11. (Additional security goals, such as ensuring that the worker learns no information about the user, are left to future work.)</p>

    <p class="text-gray-300">The basic idea is to augment address keys in such a way that the secret information needed to produce the cryptographic proof is separate from the secret information needed to authorize a transaction containing that proof. Thus, the user can communicate to the worker the secrets necessary to generate a cryptographic proof, while retaining the remaining secrets for authorizing this (and future) transactions. In particular, the worker has no way to produce valid transactions that have not been authorized by the user.</p>

    <p class="text-gray-300">We stress that the simplistic solution in which the user authorizes the proof produced by the worker by signing it via a secret key not shared with the worker <em>does not work</em> because it violates privacy. Indeed, others would have to use the same public key to verify signatures across multiple transactions containing signatures produced by the same secret key, thereby linking these transactions together.</p>

    <p class="text-gray-300">The next two sub-sections explain how we achieve delegation: first, in Section 5.2, we describe a variant of randomizable signatures, which we use as a building block; then, in Section 5.3, we provide a high-level description of a <em>delegable</em> DPC scheme. The detailed construction is provided in Appendix B.</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">5.2 Additional building block: randomizable signatures</h3>

    <p class="text-gray-300">A <em>randomizable</em> signature scheme is a tuple of algorithms <span class="math">\\mathsf{SIG}=(\\mathsf{Setup},\\mathsf{Keygen},\\mathsf{Sign},\\mathsf{Verify},\\mathsf{RandPk},\\mathsf{RandSig})</span> that enables a party to sign messages, while also allowing randomization of public keys and</p>

    <p class="text-gray-300">signatures to prevent linking across multiple signatures. We first discuss the syntax of the usual algorithms.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Setup:</em> on input a security parameter, SIG.Setup samples public parameters pp_{SIG}.</li>

      <li><em>Key generation:</em> on input public parameters pp_{SIG}, SIG.Keygen samples a key pair <span class="math">(\\mathsf{pk}_{\\mathsf{SIG}},\\mathsf{sk}_{\\mathsf{SIG}})</span>.</li>

      <li><em>Message signing:</em> on input public parameters pp_{SIG}, secret key <span class="math">\\mathsf{sk}_{\\mathsf{SIG}}</span>, and message <span class="math">m</span>, SIG.Sign produces a signature <span class="math">\\sigma</span>.</li>

      <li><em>Signature verification:</em> on input public parameters pp_{SIG}, public key <span class="math">\\mathsf{pk}_{\\mathsf{SIG}}</span>, message <span class="math">m</span>, and signature <span class="math">\\sigma</span>, SIG.Verify outputs a bit <span class="math">b</span> denoting whether <span class="math">\\sigma</span> is a valid signature for <span class="math">m</span> under public key <span class="math">\\mathsf{pk}_{\\mathsf{SIG}}</span>.</li>

    </ul>

    <p class="text-gray-300">In addition to the usual algorithms, SIG has two algorithms for randomizing public keys and signatures.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Public key randomization:</em> SIG.RandPk(<span class="math">\\mathsf{pp}_{\\mathsf{SIG}},\\mathsf{pk}_{\\mathsf{SIG}},r_{\\mathsf{SIG}}</span>) samples a randomized public key <span class="math">\\hat{\\mathsf{pk}}_{\\mathsf{SIG}}</span>.</li>

      <li><em>Signature randomization:</em> SIG.RandSig(<span class="math">\\mathsf{pp}_{\\mathsf{SIG}},\\sigma,r_{\\mathsf{SIG}}</span>) samples a randomized signature <span class="math">\\hat{\\sigma}</span>.</li>

    </ul>

    <p class="text-gray-300">The signature scheme SIG must satisfy the following security properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Existential unforgeability.</em> Given a public key <span class="math">\\mathsf{pk}_{\\mathsf{SIG}}</span>, it is infeasible to produce a forgery under <span class="math">\\mathsf{pk}_{\\mathsf{SIG}}</span> or <em>under under any randomization of <span class="math">\\mathsf{pk}_{\\mathsf{SIG}}</span></em>. This notion strengthens the standard unforgeability notion, and is similar to that of randomizable signatures in <em>[FKM^{+}16]</em>.</li>

      <li><em>Unlinkability.</em> Given a public key <span class="math">\\mathsf{pk}_{\\mathsf{SIG}}</span> and a tuple <span class="math">(\\hat{\\mathsf{pk}}_{\\mathsf{SIG}},m,\\hat{\\sigma})</span> where <span class="math">\\hat{\\sigma}</span> is a valid signature for <span class="math">m</span> under <span class="math">\\hat{\\mathsf{pk}}_{\\mathsf{SIG}}</span>, no efficient adversary can determine if <span class="math">\\hat{\\mathsf{pk}}_{\\mathsf{SIG}}</span> is a fresh public key and <span class="math">\\hat{\\sigma}</span> a fresh signature, or if instead <span class="math">\\hat{\\mathsf{pk}}_{\\mathsf{SIG}}</span> is a randomization of <span class="math">\\mathsf{pk}_{\\mathsf{SIG}}</span> and <span class="math">\\hat{\\sigma}</span> a randomization of a signature for <span class="math">\\mathsf{pk}_{\\mathsf{SIG}}</span>. This property is a computational relaxation of the perfect unlinkability property of randomizable signatures in <em>[FKM^{+}16]</em>.</li>

      <li><em>Injective randomization.</em> Randomization of public keys is <em>(computationally) injective</em> with respect to randomness. Informally, given public parameters <span class="math">\\mathsf{pp}_{\\mathsf{SIG}}</span>, it is infeasible to find a public key <span class="math">\\mathsf{pk}_{\\mathsf{SIG}}</span> and <span class="math">r_{1}\\neq r_{2}</span> such that SIG.RandPk(<span class="math">\\mathsf{pp}_{\\mathsf{SIG}},\\mathsf{pk}_{\\mathsf{SIG}},r_{1})=\\mathsf{SIG.RandPk}(\\mathsf{pp}_{\\mathsf{SIG}},\\mathsf{pk}_{\\mathsf{SIG}},r_{2})</span>.</li>

    </ul>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">5.3 A delegable DPC scheme</h3>

    <p class="text-gray-300">We describe how to construct a <em>delegable DPC scheme</em>, namely, a DPC scheme in which a user can delegate to an untrusted worker the expensive computations associated with producing a transaction. The security goal is that the worker should not be able to produce valid transactions that have not been authorized by the user. Below we assume familiarity with our “plain” DPC construction (see Section 4).</p>

    <p class="text-gray-300">The user will maintain (among other things) a key pair <span class="math">(\\mathsf{pk}_{\\mathsf{SIG}},\\mathsf{sk}_{\\mathsf{SIG}})</span> for a randomizable signature scheme SIG (see Section 5.2). The public key <span class="math">\\mathsf{pk}_{\\mathsf{SIG}}</span> will be embedded in the user’s public key apk and also be used to derive the serial numbers of records “owned” by apk. In contrast, the secret key <span class="math">\\mathsf{sk}_{\\mathsf{SIG}}</span> will not be a part of any data structures, and will <em>only</em> be used to <em>authorize</em> transactions by signing the cryptographic proofs produced by untrusted workers.</p>

    <p class="text-gray-300">In more detail, we first describe how addresses and records are generated (also see summary in Fig. 10).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Addresses. In Section 4 an address public key apk was a commitment to a secret key <span class="math">\\mathsf{sk}_{\\mathsf{PRF}}</span> for a pseudorandom function PRF. Now apk is a commitment to this same information <em>as well as</em> the public key of a key pair <span class="math">(\\mathsf{pk}_{\\mathsf{SIG}},\\mathsf{sk}_{\\mathsf{SIG}})</span> for SIG. The corresponding address secret key ask consists of all the committed information and the commitment randomness.</li>

      <li>Records. The structure of a record, including how a record commitment is computed, is as in Section 4. However, a record’s serial number sn is now derived in a different way: while previously <span class="math">\\mathsf{sn}:=\\mathsf{PRF}_{\\mathsf{sk}_{\\mathsf{PRF}}}(\\rho)</span> now we set <span class="math">\\mathsf{sn}:=\\mathsf{SIG.RandPk}(\\mathsf{pp}_{\\mathsf{SIG}},\\mathsf{pk}_{\\mathsf{SIG}},\\mathsf{PRF}_{\\mathsf{sk}_{\\mathsf{PRF}}}(\\rho))</span> where <span class="math">\\rho</span> is the record’s serial number nonce. Namely, while before serial numbers were outputs of a pseudorandom function keyed by <span class="math">\\mathsf{sk}_{\\mathsf{PRF}}</span>, now they are randomizations of the authorization public key <span class="math">\\mathsf{pk}_{\\mathsf{SIG}}</span> when using suitable pseudorandomness.</li>

    </ul>

    <p class="text-gray-300">Note that the foregoing new derivation of serial numbers does not break important security properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Unlinkability of serial numbers: serial numbers of different records that share the same authorization public  <span class="math">\\mathsf{pk}_{\\mathsf{SIG}}</span>  are computationally indistinguishable. This follows rather directly from the fact sn, being a randomization of  <span class="math">\\mathsf{pk}_{\\mathsf{SIG}}</span> , does not reveal information (to efficient distinguishers) about  <span class="math">\\mathsf{pk}_{\\mathsf{SIG}}</span>  itself.</li>

      <li>No double spending: a user cannot "spend" (i.e., consume)  <span class="math">\\mathbf{r}</span>  in two different transactions by revealing different serial numbers because  <span class="math">r_{\\mathrm{SIG}}</span>  (and thus sn) is generated deterministically from  <span class="math">\\mathbf{r}</span> . Since SIG is randomness-injective in SIG.RandPk, sn is (computationally) unique to  <span class="math">\\mathbf{r}</span> .</li>

    </ul>

    <p class="text-gray-300">Having described the modified data structures of addresses and serial numbers, we now explain how a user can task a worker to produce the cryptographic proofs that need to be included in a transaction. For simplicity, in this high-level discussion we focus on the case where the transaction involves only one input (old) record  <span class="math">\\mathbf{r}</span>  and one output (new) record  <span class="math">\\mathbf{r}&#x27;</span> . In this case, the transaction contains a serial number  <span class="math">\\mathfrak{sn}</span>  (supposedly corresponding to  <span class="math">\\mathbf{r}</span> ), and a commitment  <span class="math">\\mathfrak{cm}&#x27;</span>  (supposedly corresponding to  <span class="math">\\mathbf{r}&#x27;</span> ).</p>

    <p class="text-gray-300">Previously, the user had to generate a proof  <span class="math">\\pi_{\\mathrm{e}}</span>  that sn is consistent with r, that  <span class="math">\\mathsf{cm}&#x27;</span>  can be opened to  <span class="math">\\mathbf{r}&#x27;</span> , and that the death and birth predicates of r and  <span class="math">\\mathbf{r}&#x27;</span>  respectively are satisfied. Now the user can delegate to a worker the generation of the proof  <span class="math">\\pi_{\\mathrm{e}}</span>  because the modified derivation of apk and sn allows the user to communicate to the worker only r,  <span class="math">\\mathbf{r}&#x27;</span>  and a part of the address secret key of r. Namely, the user sends to the worker only the pseudorandom function key skPRF and the commitment randomness  <span class="math">r_{\\mathrm{pk}}</span> . Crucially, the user does not have to communicate to the worker the authorization secret key skSIG.</p>

    <p class="text-gray-300">After receiving the proof  <span class="math">\\pi_{\\mathrm{e}}</span>  from the worker, the user uses the authorization secret key  <span class="math">\\mathsf{sk}_{\\mathsf{SIG}}</span>  to sign  <span class="math">\\pi_{\\mathrm{e}}</span>  (along with the instance that  <span class="math">\\pi_{\\mathrm{e}}</span>  attests to), and then randomizes the resulting signature  <span class="math">\\sigma</span>  to obtain  <span class="math">\\hat{\\sigma}</span> . The final transaction tx not only includes the serial number sn (consuming the old record), the commitment  <span class="math">\\mathsf{cm}&#x27;</span>  (creating the new record), and  <span class="math">\\pi_{\\mathrm{e}}</span>  (attesting to the correct state transition) as before, but also includes  <span class="math">\\hat{\\sigma}</span> . Transaction verification involves checking the proof  <span class="math">\\pi_{\\mathrm{e}}</span>  and also checking that  <span class="math">\\hat{\\sigma}</span>  is valid with respect to the randomized public key sn.</p>

    <p class="text-gray-300">This completes our high-level description of our delegable DPC scheme; see Appendix B for details.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Plain DPC</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Delegable DPC</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Address secret key</td>

            <td class="px-3 py-2 border-b border-gray-700">(skPRF, rpk)</td>

            <td class="px-3 py-2 border-b border-gray-700">(skSIG, skPRF, rpk)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Address public key</td>

            <td class="px-3 py-2 border-b border-gray-700">apk := CM.Commit (ppCM, skPRF; rpk)</td>

            <td class="px-3 py-2 border-b border-gray-700">apk := CM.Commit (ppCM, pkSIG</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">skPRF; rpk)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Serial number derivation</td>

            <td class="px-3 py-2 border-b border-gray-700">sn ← PRFskPRF(ρ)</td>

            <td class="px-3 py-2 border-b border-gray-700">1. rSIG ← PRFskPRF(ρ)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   |  2. sn ← SIG.RandPk(ppSIG, pkSIG, rSIG)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Transaction construction</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">tx := ([sn1]m, [cmj]n, memo, <em>), where </em> := (stL, πe).</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Sign transaction contents: (a) σi ← SIG.Sign(ppSIG, skSIG,i, πe</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">πe), (b) σi ← SIG.RandSig(ppSIG, σi, rSIG,i).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   |  2. tx := ([sn1]m, [cmj]n, memo, <em>), where </em> := (stL, πe, [σi1i]).  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Transaction verification</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Check that serial numbers do not appear on ledger, that the ledger state digest is valid, and that the NIZK proof verifies.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As in plain DPC, but additionally check that each signature verifies: SIG.Verify(ppSIG, tx.sni, πe</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">πe, σi) = 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 10: Summary of differences between plain DPC and delegable DPC (highlighted).</p>

    <p class="text-gray-300">We explain how the delegable DPC scheme described above can be modified, in a straightforward way, to achieve additional features: threshold transactions or blind transactions.</p>

    <p class="text-gray-300">Threshold transactions. A DPC scheme has threshold transactions if the power to authorize transactions can be vested unto any  <span class="math">t</span>  out of  <span class="math">n</span>  parties, for any desired choice of  <span class="math">t</span>  and  <span class="math">n</span>  (as opposed to a single user as discussed thus far, which corresponds to the special case of  <span class="math">t = n = 1</span> ); see Fig. 12. Threshold transactions are useful in many settings, e.g., to enhance operational security by realizing two-factor authentication.</p>

    <p class="text-gray-300">We can achieve threshold transactions by simply using, in our delegable DPC scheme, a randomizable signature scheme SIG that also supports threshold key generation and threshold signing algorithms [DF91]. Such a threshold signature scheme distributes signing ability among  <span class="math">n</span>  parties such that at least  <span class="math">t</span>  of them are needed to authorize a signature. Threshold key generation would then be used to create an address, and threshold signing would be used to authorize a transaction by signing the corresponding cryptographic proof.</p>

    <p class="text-gray-300">Blind transactions. A DPC scheme has blind transactions if there is a way for a user to authorize a transaction without learning of its contents; see Fig. 13. Blind transactions, in conjunction with prior techniques  <span class="math">\\left[\\mathrm{CGL}^{+}17\\right]</span> , can be used to construct efficient lottery tickets and thereby probabilistic micropayments.</p>

    <p class="text-gray-300">We can achieve blind transactions by simply using, in our delegable DPC scheme, a randomizable signature scheme SIG that has a blind signing algorithm, which can then be used for signing the relevant cryptographic proof in order to authorize a transaction.</p>

    <p class="text-gray-300">Instantiating randomizable threshold and blind signatures. As we explain in Appendix B.1, we construct randomizable signature schemes by modifying Schnorr signatures. To further construct threshold or blind randomizable signatures, it is enough to note that public key and signature randomization occurs after the public key or signature has been created. Thus one can use existing protocols for threshold key-generation and signing [SS01, NKDM03, Dod07], and blind signing [PS00, SJ99] to obtain public keys and signatures, and then use the algorithms from Appendix B.1 to randomize these. A nice feature of this approach is that all these types of delegated transactions (regular, threshold, blind) cannot be distinguished from one another.</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Figure 11: Delegable transactions.</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> Figure 12: Threshold transactions.</p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Figure 13: Blind transactions.</p>

    <p class="text-gray-300">We describe example applications of DPC schemes, by showing how to "program" these within the records nano-kernel. We draw inspiration from current uses of smart contract systems (e.g., Ethereum), which largely focus on financial applications where privacy is an important goal. First, in Section 6.1 we describe how to enable users to privately create and transact with custom assets (expanding on Example 2.1). Second, in Section 6.2 we describe how to realize private DEXs, which enable users to privately trade assets while retaining custody of their assets. Finally, in Section 6.3, we describe how a central authority can issue assets with self-enforcing, and updatable, policies, and use these to realize regulation-friendly private stablecoins.</p>

    <p class="text-gray-300">One of the most basic applications of smart contract systems like Ethereum is the construction of assets (or tokens) that can be used for financial applications. For example, the Ethereum ERC20 specification [VB15] defines a general framework for such assets. These assets have two phases: asset minting (creation), and asset conservation (expenditure). We show below how to express such custom assets via the records nano-kernel.</p>

    <p class="text-gray-300">We consider records whose payloads encode: an asset identifier id, the initial asset supply  <span class="math">\\mathbb{V}</span> , a value  <span class="math">v</span> , and application-dependent data  <span class="math">c</span>  (we will use this in Sections 6.2 and 6.3). We fix the birth predicate in all such records to be a mint-or-conserve function MoC that is responsible for asset minting and conservation. In more detail, the birth predicate MoC can be invoked in two modes, mint mode or conserve mode.</p>

    <p class="text-gray-300">When invoked in mint mode, MoC creates the initial supply  <span class="math">\\mathbb{V}</span>  of the asset in, say, a single output record, by deterministically deriving a fresh unique identifier id for the asset (see below for how), and storing the tuple  <span class="math">(\\mathrm{id},\\mathbb{V},\\mathbb{V},\\bot)</span>  in the record's payload. The predicate MoC also ensures that the given transaction contains no input records or other output records (dummy records are allowed). If MoC is invoked in mint mode in other transactions, a different identifier id is created, ensuring that multiple assets can be distinguished even though anyone can use MoC as the birth predicate of a record.</p>

    <p class="text-gray-300">When invoked in conserve mode, MoC inspects all records in a transaction whose birth predicates all equal MoC (i.e., all the transaction's user-defined assets) and whose asset identifiers all equal to the identifier of the current record. For these records it ensures that no new value is created: that is, the sum of the value across all output records is less than or equal to the sum of the value in all input records.</p>

    <p class="text-gray-300">Below we provide pseudocode for MoC, making the informal discussion above more precise.</p>

    <p class="text-gray-300">Mint-or-conserve predicate MoC  <span class="math">(k,</span>  ldata; mode) (mode is the private input of the predicate)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Parse ldata as  $\\left( \\begin{array}{cccc}\\lfloor \\mathsf{cm}_i^{\\mathrm{in}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2 &amp; [\\mathsf{apk}_i^{\\mathrm{in}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2 &amp; [\\mathsf{payload}_i^{\\mathrm{in}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2 &amp; [\\Phi_{\\mathsf{d},i}^{\\mathrm{in}}]_{\\mathsf{i}}^2 &amp; [\\mathsf{Sn}_i^{\\mathrm{in}}]_{\\mathsf{i}}^2 &amp; [\\mathsf{m}_{\\mathsf{i}}^2]_{\\mathsf{i}}^2 &amp; [\\mathsf{sn}_i^{\\mathrm{in}}]_{\\mathsf{i}}^2 &amp; \\mathsf{numo}\\\\ \\lfloor \\mathsf{cm}_j^{\\mathrm{out}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2 &amp; [\\mathsf{apk}_j^{\\mathrm{out}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2 &amp; [\\mathsf{payload}_j^{\\mathrm{out}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2 &amp; [\\Phi_{\\mathsf{d},j}^{\\mathrm{out}}]_{\\mathsf{i}}^2 &amp; [\\Phi_{\\mathsf{h},j}^{\\mathrm{out}}]_{\\mathsf{i}}^2 &amp; \\mathsf{aux} \\end{array} \\right).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If mode  <span class="math">=</span>  (mint,  <span class="math">\\mathbb{V},r</span> ), ensure that the first output record contains the initial supply of the asset:</li>

    </ol>

    <p class="text-gray-300">(a) the index of the current output record is correct:  <span class="math">k = 1</span> . (b) all other records are dummy: payload <span class="math">_{1}</span> .isDummy = payload <span class="math">_{2}</span> .isDummy = payload <span class="math">_{3}</span> .isDummy = 1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(c) the asset identifier is derived correctly:  <span class="math">\\mathrm{id} = \\mathrm{CM}</span> . Commit  $(\\mathsf{pp}_{\\mathsf{CM}}, \\mathsf{sn}_1 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sn}_2; r)$ . (See explanation below.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(d) the current output record's payload is correct: payload  <span class="math">{}_{1}^{\\text{out}}</span>  .isDummy  <span class="math">= 0</span>  and payload  <span class="math">{}_{1}^{\\text{out}} = (\\mathrm{{id}},\\mathrm{v},\\mathrm{v},\\bot)</span>  .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If mode = conserve, check that the value of the current asset is conserved:</li>

    </ol>

    <p class="text-gray-300">(a) parse the current output record's payload payload  <span class="math">\\mathbf{\\Pi}_k^{\\mathrm{out}}</span>  as  <span class="math">(\\mathrm{id}^{<em>},\\mathbb{V}^{</em>},v^{<em>},c^{</em>})</span> (b) for  <span class="math">i\\in \\{1,2\\}</span> , parse the  <span class="math">i</span> -th input record's payload payload as  <span class="math">(\\mathrm{id}_i^{\\mathrm{in}},\\mathbb{V}_i^{\\mathrm{in}},\\mathbb{V}_i^{\\mathrm{in}},c_i^{\\mathrm{in}})</span> . (c) for  <span class="math">j\\in \\{1,2\\}</span> , parse the  <span class="math">i</span> -th output record's payload payload as  <span class="math">(\\mathrm{id}_j^{\\mathrm{out}},\\mathbb{V}_j^{\\mathrm{out}},v_j^{\\mathrm{out}},c_j^{\\mathrm{out}})</span> . (d) initialize  <span class="math">v^{\\mathrm{in}} \\coloneqq 0</span>  and  <span class="math">v^{\\mathrm{out}} \\coloneqq 0</span> , representing the value of asset id<em> consumed and created (respectively). (e) for  <span class="math">i\\in \\{1,2\\}</span> , if  <span class="math">\\Phi_{\\mathsf{b},i}^{\\mathrm{in}} = \\Phi_{\\mathsf{b}}^{</em>}</span> ,  <span class="math">\\mathsf{id}_i^{\\mathrm{in}} = \\mathsf{id}^<em></span> , payload  <span class="math">i</span>  is Dummy  <span class="math">= 0</span> , set  <span class="math">v^{\\mathrm{in}}\\coloneqq v^{\\mathrm{in}} + v_i^{\\mathrm{in}}</span>  and check that  <span class="math">\\mathbb{V}_i^{\\mathrm{in}} = \\mathbb{V}^</em></span> . (f) for  <span class="math">j\\in \\{1,2\\}</span> , if  <span class="math">\\Phi_{\\mathsf{b},j}^{\\mathrm{out}} = \\Phi_{\\mathsf{b}}^{<em>}</span> ,  <span class="math">\\mathsf{id}_j^{\\mathrm{out}} = \\mathsf{id}^</em></span> , payload  <span class="math">j</span>  is Dummy  <span class="math">= 0</span> , set  <span class="math">v^{\\mathrm{out}}\\coloneqq v^{\\mathrm{out}} + v_j^{\\mathrm{out}}</span>  and check that  <span class="math">\\mathbb{V}_j^{\\mathrm{out}} = \\mathbb{V}^<em></span> . (g) check that the value of asset id</em> is conserved:  <span class="math">v^{\\mathrm{in}} = v^{\\mathrm{out}}</span> .</p>

    <p class="text-gray-300">Most of the lines above are self-explanatory, but for the line that derives a fresh unique identifier in the “mint” case (Step 2c), which deserves an explanation. Informally, the idea is to derive the identifier from the (globally unique) serial numbers of records consumed in the minting transaction. In more detail, we set the identifier to be a commitment to the serial numbers of consumed input records. To see why this works, first note that the commitment scheme’s binding property guarantees that opening a commitment to two different messages is computationally difficult. Next, note that in our case these messages are the input records’ serial numbers, and hence <em>are</em> different. Together, these facts imply that the identifier is globally unique (and hence non-repeating). A benefit of this method is that the commitment scheme’s hiding property further guarantees that the identifier reveals no information about the underlying serial numbers, which in turn guarantees that the identifier hides all information about the initial minting transaction (given that <span class="math">r</span> is random).</p>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">6.2 Decentralized exchanges</h3>

    <p class="text-gray-300">We describe how to use death predicates that enforce custom-access policies to build <em>privacy-preserving decentralized exchanges</em>. These allow users to exchange custom assets with strong privacy guarantees without requiring users to give up custody of these assets. We proceed by first providing background on centralized and decentralized exchanges. Then, we formulate desirable privacy properties for decentralized exchanges. Finally, we describe constructions that achieve these properties.</p>

    <p class="text-gray-300">Motivation. Exchanging digital assets is a compelling use case of ledger-based systems. A straightforward method to exchange digital assets is via a <em>centralized exchange</em>: users entrust the exchange with custody of their assets via an on-chain transaction, and the exchange can then credit or debit assets to users’ accounts according to off-chain trades without any on-chain activity; users can “exit” by requesting to withdraw assets, which generates another on-chain transaction that transfers those assets from the exchange to the user. Examples of such exchanges include Coinbase <em>[x10]</em> and Binance <em>[x11]</em>. This architecture provides centralized exchanges with two attractive properties: (a) efficiency, namely, all trades occur in the exchange’s off-chain database, resulting in low latency and high throughput for all users; and (b) privacy, namely, only the exchange knows the details of individual trades, and only asset deposits and withdrawals require on-chain activity; this activity can further be concealed by using private (Zerocash-style) transactions to realize deposits/withdrawals. However, this centralized architecture has a serious drawback: having given up custody of their assets, users are exposed to the risk of security breaches, fraud, or front-running at the exchange. These risks are not hypothetical: users have lost funds deposited at centralized exchanges <em>[x22, x15, x30, x16]</em>.</p>

    <p class="text-gray-300">In light of the above, <em>decentralized exchanges</em> (DEXs) have been proposed as an alternative method for exchanging digital assets that enable users to retain custody of their assets. However, existing DEX constructions have poor efficiency and privacy guarantees. Below we describe how we can provide strong privacy for DEXs. (We leave improving the efficiency of DEXs to future work.)</p>

    <p class="text-gray-300">DEX architectures. A DEX is a ledger-based application that enables users to trade digital assets without giving up custody of these assets to a third party. There are different DEX architectures with different trade-offs; see <em>[x24]</em> for a survey. In the following, we consider DEX architectures where the exchange has no state or maintains its state off-chain. There are two main categories of such DEXs:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Intent-based DEX</em>. The DEX maintains an index, which is a table where makers publish their intention to trade (say, a particular asset pair) without committing any assets. A taker interested in a maker’s intention to trade can directly communicate with the maker to agree on terms. They can jointly produce a transaction for the trade, to be broadcast for on-chain processing. An example of such a DEX is AirSwap *[x1]</li>

    </ul>

    <p class="text-gray-300">An attractive feature of intent-based DEXs is that they reduce exposure to front-running because the information required for front-running (like prices or identities of the involved parties) has been finalized by the time the transaction representing the trade is broadcast for processing. Note that the aforementioned lack of information also makes it difficult for the market to discover appropriate exchange rates because listings in the index cannot directly be linked with completed transactions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Order-based DEX. The DEX maintains an order book, which is a table where makers can publish orders by committing the funds for those orders up front. A taker can then interact with the order book to fill orders. In an open-book DEX, the taker manually picks an order from the order book, while in a closed-book DEX, the taker is matched off-chain with a maker’s offer by the order book operator. An example of an open-book DEX is Radar Relay [rad], and an example of a closed-book DEX is Paradex [par].</li>

    </ul>

    <p class="text-gray-300">Note that order books (which are typically public) give more information about market activity than indexes, and hence enable better price discovery. However, existing constructions of order-based DEXs also allow other parties to link a standing order with a transaction that fills the order before the transaction is finalized, enabling them to front-run the order. Which parties can front-run depends on the kind of order-based DEX: in the open-book variant, anyone can front-run, while in the closed-book variant, only the order book operator can front-run (as it is the sole entity that can invoke the trade smart-contract).</p>

    <p class="text-gray-300">The architectures described above offer different trade-offs with respect to market price discovery and front-running exposure, and hence can be useful in different scenarios.</p>

    <p class="text-gray-300">Privacy shortcomings and goals. While the foregoing DEX architectures offer attractive security and functionality, they do not provide strong privacy guarantees, as we now explain. First, each transaction reveals information about the corresponding trade, such as the assets and amounts that were exchanged. Prior work <em>[BDJT17, BBD^{+}17, EMC19, DGK^{+}20]</em> shows that such leakage enables front-running that harms user experience and market transparency, and proposes mitigations that, while potentially useful, do not provide strong privacy guarantees. Even if one manages to hide these trade details, transactions in existing DEXs also reveal the identities of transacting parties. Onlookers can use this information to extract trading patterns and frequencies of users. This reduces the privacy of users, violates the fungibility of assets, and increases exposure to front-running, because onlookers can use the aforementioned patterns to infer when particular assets are being traded.</p>

    <p class="text-gray-300">These shortcomings motivate the following privacy goals for DEXs. Throughout, we assume that an order is defined by a pair of assets (that are to be exchanged), and their exchange rates.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Trade confidentiality: No efficient adversary <span class="math">\\mathcal{A}</span> should be able to learn the trade details of completed or cancelled trades. That is, a transaction that completes or cancels a trade should not reveal to <span class="math">\\mathcal{A}</span> the asset pairs or amounts involved in the trade.</li>

      <li>Trade anonymity: No efficient adversary <span class="math">\\mathcal{A}</span> should be able to learn the identities of parties involved in a trade. That is, a transaction that completes or cancels a trade should not reveal to <span class="math">\\mathcal{A}</span> any information about the maker or taker of the trade.</li>

    </ol>

    <p class="text-gray-300">A protocol that achieves trade confidentiality and trade anonymity against an adversary <span class="math">\\mathcal{A}</span> is secure against front-running by <span class="math">\\mathcal{A}</span>. The flip-side of this is that <span class="math">\\mathcal{A}</span> cannot easily discover the rates used in successful trades, leading to poorer visibility into the trading market. We now describe constructions of intent-based and order-based DEXs that achieve trade confidentiality and anonymity.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Record format. Recall from Section 6.1 that records representing units of an asset have payloads of the form  <span class="math">(\\mathrm{id},\\mathbb{V},v,c)</span> , where  <span class="math">\\mathrm{id}</span>  is the asset identifier,  <span class="math">\\mathbb{V}</span>  is the initial asset supply,  <span class="math">v</span>  is the asset amount, and  <span class="math">c</span>  is arbitrary auxiliary information. In the following, we make use of records that, in addition to the mint-or-conserve birth predicate MoC, have an exchange-or-cancel death predicate EoC described next. Informally, EoC allows a record  <span class="math">\\mathbf{r}</span>  to be consumed either by exchanging it for  <span class="math">v^{\\star}</span>  units of an asset with birth predicate  <span class="math">\\Phi_{\\mathrm{b}}^{\\star}</span>  and identifier  <span class="math">\\mathrm{id}^{\\star}</span>  ( <span class="math">\\mathrm{id}^{\\star}</span> ,  <span class="math">\\Phi_{\\mathrm{b}}^{\\star}</span>  and  <span class="math">v^{\\star}</span>  are specified in  <span class="math">c</span> ), or by "cancelling" the exchange and instead sending new records with  <span class="math">\\mathbf{r}</span> 's asset identifier to an address  <span class="math">\\mathsf{apk}^{\\star}</span>  (also specified in  <span class="math">c</span> ). The information required for the exchange includes the asset's birth predicate in addition to its identifier, as it enables users to interact with assets that have birth predicate different from MoC (such as the stablecoins in Section 6.3). The predicate is described below.</p>

    <p class="text-gray-300">Exchange-or-cancel predicate  <span class="math">\\mathsf{EoC}(k,\\mathsf{ldata};\\mathsf{mode})</span>  (mode is the private input for the predicate.)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse ldata as  <span class="math">\\left( \\begin{array}{cccc}\\lfloor \\mathsf{cm}_{i}^{in}\\rfloor_{1}^{2} &amp;amp; \\lfloor \\mathsf{apk}_{i}^{in}\\rfloor_{1}^{2} &amp;amp; \\lfloor \\mathsf{payload}_{i}^{in}\\rfloor_{1}^{2} &amp;amp; \\lfloor \\Phi_{d,i}^{in}\\rfloor_{1}^{2} &amp;amp; \\lfloor \\Phi_{b,i}^{in}\\rfloor_{1}^{2} &amp;amp; \\lfloor sn_{i}^{in}\\rfloor_{1}^{2} &amp;amp; \\mathsf{memo}\\\\ \\lfloor \\mathsf{cm}_{j}^{out}\\rfloor_{1}^{2} &amp;amp; \\lfloor \\mathsf{apk}_{j}^{out}\\rfloor_{1}^{2} &amp;amp; \\lfloor \\mathsf{payload}_{j}^{out}\\rfloor_{1}^{2} &amp;amp; \\lfloor \\Phi_{d,j}^{out}\\rfloor_{1}^{2} &amp;amp; \\lfloor \\Phi_{b,j}^{out}\\rfloor_{1}^{2} &amp;amp; \\mathsf{aux} \\end{array} \\right).</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Recall that  <span class="math">k \\in \\{1, 2\\}</span>  is the index of the current input record. Let  <span class="math">l \\in \\{1, 2\\}</span>  denote the index of the other input record. (If  <span class="math">k = 1</span>  then set  <span class="math">l := 2</span> ; if instead  <span class="math">k = 2</span>  then set  <span class="math">l := 1</span> .)</li>

      <li>Parse the current input record's payload payload  <span class="math">\\mathbf{\\Phi}_k^{in}</span>  as  <span class="math">(\\mathrm{id}_k^{in},\\mathbb{V}_k,v_k^{in},c_k^{in})</span>  , and the application data  <span class="math">c_{k}^{in}</span>  as  <span class="math">(\\Phi_{b,k}^{\\star},\\mathrm{id}_{k}^{\\star},v_{k}^{\\star},\\mathsf{apk}_{k}^{\\star})</span></li>

      <li>Parse the other input record's payload payload  <span class="math">\\mathbf{\\Phi}_k^{in}</span>  as  <span class="math">(\\mathrm{id}_l^{in},\\mathbb{V}_l,v_l^{in},c_l^{in})</span>  , and the application data  <span class="math">c_{l}^{in}</span>  as  <span class="math">(\\Phi_{b,l}^{\\star},\\mathrm{id}_{l}^{\\star},v_{l}^{\\star},\\mathsf{apk}_{l}^{\\star})</span></li>

      <li>If mode = exch, ensure that the assets are correctly exchanged, by checking the following.</li>

    </ol>

    <p class="text-gray-300">(a) the input records are not dummy: payload  <span class="math">\\mathbf{\\Phi}_1^{in}</span> .isDummy = payload  <span class="math">\\mathbf{\\Phi}_2^{in}</span> .isDummy = 0. (b) the conditions of the trade are satisfied:</p>

    <p class="text-gray-300">i. the current input record has the expected identifier, birth predicate, and value:  <span class="math">\\Phi_{\\mathrm{b},k}^{\\mathrm{in}} = \\Phi_{\\mathrm{b},l}^{\\star}</span> ,  <span class="math">\\mathrm{id}_k^{\\mathrm{in}} = \\mathrm{id}_l^{\\star}</span> , and  <span class="math">v_{k}^{\\mathrm{in}} = v_{l}^{\\star}</span> . ii. the other input record has the expected identifier, birth predicate, and value:  <span class="math">\\Phi_{\\mathrm{b},l}^{\\mathrm{in}} = \\Phi_{\\mathrm{b},k}^{\\star}</span> ,  <span class="math">\\mathrm{id}_l^{\\mathrm{in}} = \\mathrm{id}_k^{\\star}</span> , and  <span class="math">v_{l}^{\\mathrm{in}} = v_{k}^{\\star}</span> . iii. the output records' birth predicates are correctly swapped:  <span class="math">\\Phi_{\\mathrm{b},1}^{\\mathrm{in}} = \\Phi_{\\mathrm{b},2}^{\\mathrm{out}}</span>  and  <span class="math">\\Phi_{\\mathrm{b},2}^{\\mathrm{in}} = \\Phi_{\\mathrm{b},1}^{\\mathrm{out}}</span> . iv. the output records have the correct asset identifier, initial supply, and value:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{payload}_1^{\\mathrm{out}} = (\\mathsf{id}_2^{\\mathrm{in}},\\mathbb{V}_2,v_2^{\\mathrm{in}},\\bot)</span>  and  <span class="math">\\mathsf{payload}_2^{\\mathrm{out}} = (\\mathsf{id}_1^{\\mathrm{in}},\\mathbb{V}_1,v_1^{\\mathrm{in}},\\bot)</span> .</p>

    <p class="text-gray-300">v. the output records are addressed correctly:  <span class="math">\\mathsf{apk}_k^{\\mathrm{out}} = \\mathsf{apk}_k^{\\star}</span>  and  <span class="math">\\mathsf{apk}_l^{\\mathrm{out}} = \\mathsf{apk}_l^{\\star}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Else if mode = cancel, ensure that the trade is cancelled by checking that the  <span class="math">\\mathrm{id}_k</span> -value is transferred to the specified "redemption" address public key  <span class="math">\\mathsf{apk}_k^*</span> , by checking the following.</li>

    </ol>

    <p class="text-gray-300">(a) the current input record is non-dummy: payload  <span class="math">\\mathbf{\\Phi}_k</span>  isDummy  <span class="math">= 0</span> (b) the other input record is dummy: payload  <span class="math">\\mathbf{\\Phi}_l</span>  isDummy  <span class="math">= 1</span> (c) the output records are custom assets with identifier  <span class="math">\\mathrm{id}_k^{\\mathrm{in}}</span> :</p>

    <p class="text-gray-300">i. the output records have the correct birth predicate:  <span class="math">\\Phi_{\\mathrm{b},1}^{\\mathrm{out}} = \\Phi_{\\mathrm{b},2}^{\\mathrm{out}} = \\Phi_{\\mathrm{b},k}^{\\mathrm{in}}</span> ii. the output records have the correct asset identifier and initial supply:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{payload}_1^{\\mathrm{out}} = (\\mathsf{id}_k^{\\mathrm{in}},\\mathbb{V}_k,v_1^{\\mathrm{out}},\\bot)</span>  and  <span class="math">\\mathsf{payload}_2^{\\mathrm{out}} = (\\mathsf{id}_k^{\\mathrm{in}},\\mathbb{V}_k,v_2^{\\mathrm{out}},\\bot)</span> .</p>

    <p class="text-gray-300">(d) the output records preserve  <span class="math">\\mathrm{id}_k^{\\mathrm{in}}</span> -value:  <span class="math">v_1^{\\mathrm{out}} + v_2^{\\mathrm{out}} = v_k^{\\mathrm{in}}</span> . (e) the address public key of the output records is correct:  <span class="math">\\mathsf{apk}_1^{\\mathrm{out}} = \\mathsf{apk}_2^{\\mathrm{out}} = \\mathsf{apk}_k^*</span> .</p>

    <p class="text-gray-300">The case of intent-based DEXs. We describe an intent-based DEX that hides all information information about orders and transacting parties.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A maker  <span class="math">\\mathsf{M}</span>  can publish to the index an intention to trade, which is a tuple  <span class="math">(\\mathrm{id}_A,\\mathrm{id}_B,\\mathsf{pk}_{\\mathsf{M}})</span>  to be interpreted as: "I want to buy assets with identifier  <span class="math">\\mathrm{id}_B</span>  in exchange for assets with identifier  <span class="math">\\mathrm{id}_A</span> . Please contact me using the encryption public key  <span class="math">\\mathsf{pk}_{\\mathsf{M}}</span>  if you would like to discuss the terms."</li>

      <li>A taker  <span class="math">\\mathsf{T}</span>  who is interested in this offer can use  <span class="math">\\mathsf{pk}_{\\mathsf{M}}</span>  to privately communicate with  <span class="math">\\mathsf{M}</span>  and agree on the terms of the trade (the form of communication is irrelevant). If  <span class="math">\\mathsf{T}</span>  and  <span class="math">\\mathsf{M}</span>  do not reach an agreement, then  <span class="math">\\mathsf{T}</span>  can always pursue other entries in the index. So suppose that  <span class="math">\\mathsf{T}</span>  and  <span class="math">\\mathsf{M}</span>  do reach an agreement. For the sake of example,  <span class="math">\\mathsf{T}</span>  will give 10 units of asset  <span class="math">\\mathrm{id}_B</span>  to  <span class="math">\\mathsf{M}</span>  and will receive 5 units of asset  <span class="math">\\mathrm{id}_A</span>  from  <span class="math">\\mathsf{M}</span> .</li>

      <li>The taker  <span class="math">\\mathsf{T}</span>  creates a new record  <span class="math">\\mathbf{r}</span>  with payload  <span class="math">(\\mathrm{id}_B, \\mathbb{V}_B, 10, c)</span>  for auxiliary data  <span class="math">c = (\\mathrm{id}_A, 5, \\mathrm{apk}_{\\mathrm{new}})</span> , and with death predicate EoC. Then  <span class="math">\\mathsf{T}</span>  sends  <span class="math">\\mathbf{r}</span>  (along with the information necessary to redeem  <span class="math">\\mathbf{r}</span> ) to  <span class="math">\\mathsf{M}</span> .</li>

      <li>If  <span class="math">\\mathsf{M}</span>  possesses a record worth 5 units of asset  <span class="math">\\mathrm{id}_A</span> , he can use  <span class="math">\\mathsf{T}</span> 's message to construct a DPC transaction that completes the exchange by consuming  <span class="math">\\mathbf{r}</span>  and by producing appropriate new records for  <span class="math">\\mathsf{M}</span>  and  <span class="math">\\mathsf{T}</span> . (This</li>

    </ol>

    <p class="text-gray-300">step deviates from existing intent-based DEXs in that it is the <em>maker</em> that broadcasts the trade transaction.)</p>

    <p class="text-gray-300">The record <span class="math">\\mathbf{r}</span> produced by the taker <span class="math">\\mathsf{T}</span> can be redeemed by <span class="math">\\mathsf{M}</span> only via an appropriate record in exchange. If <span class="math">\\mathsf{M}</span> does not possess such a record, <span class="math">\\mathsf{T}</span> can cancel the trade (at any time) and retrieve his funds by satisfying the “cancel” branch of the predicate <span class="math">\\mathsf{EoC}</span> (which requires knowing the secret key corresponding to <span class="math">\\mathsf{apk}_{\\mathsf{new}}</span>).</p>

    <p class="text-gray-300">Note that regardless of whether the trade was successful or not, this protocol achieves trade anonymity and trade confidentiality against all parties (including the index operator). Indeed, the only information revealed in the final transaction is that some records were consumed and others created; no information is revealed about <span class="math">\\mathsf{M}</span>, <span class="math">\\mathsf{T}</span>, the assets involved in the trade (<span class="math">\\mathsf{id}_{A}</span> and <span class="math">\\mathsf{id}_{B}</span>), or the amounts exchanged.</p>

    <h5 id="sec-41" class="text-base font-semibold mt-4">The case of order-based DEXs.</h5>

    <p class="text-gray-300">We describe private order-based DEXs, with open or closed books.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Open-book DEX: The variant below hides all information about <span class="math">\\mathsf{M}</span> and <span class="math">\\mathsf{T}</span>, but reveals the assets and amounts involved. This implies achieving trade anonymity but not trade confidentiality.</li>

    </ul>

    <p class="text-gray-300">For the sake of example, assume again that the maker <span class="math">\\mathsf{M}</span> will trade <span class="math">5</span> units of asset <span class="math">\\mathsf{id}_{A}</span> for <span class="math">10</span> units of asset <span class="math">\\mathsf{id}_{B}</span>. <span class="math">\\mathsf{M}</span> constructs a record <span class="math">\\mathbf{r}</span> with payload <span class="math">(\\mathsf{id}_{B},\\mathbbm{v}_{B},v=10,c=(\\mathsf{id}_{A},5,\\mathsf{apk}))</span> and death predicate <span class="math">\\mathsf{EoC}</span>. He uses this to construct an order <span class="math">o=(\\mathbf{r},\\mathsf{info})</span> consisting of the record and the information necessary to consume it, and publishes <span class="math">o</span> to the order book. An interested taker <span class="math">\\mathsf{T}</span> can then construct and publish a transaction <span class="math">\\mathsf{tx}</span> that consumes <span class="math">\\mathbf{r}</span> and creates new records with the appropriate values and asset identifiers.</p>

    <p class="text-gray-300">The transaction <span class="math">\\mathsf{tx}</span> hides information about the maker <span class="math">\\mathsf{M}</span> and taker <span class="math">\\mathsf{T}</span>, but because it reveals <span class="math">\\mathbf{r}</span>’s serial number, it can be linked with its originating order <span class="math">o</span>. This allows onlookers to learn the assets and amounts of <span class="math">\\mathsf{tx}</span>. Hence, this protocol achieves trade anonymity, but not trade confidentiality.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Closed-book DEX: The variant below hides all order information from everyone but the order book operator. Hence it achieves trade anonymity and confidentiality against everyone but the order book operator.</li>

    </ul>

    <p class="text-gray-300">The maker <span class="math">\\mathsf{M}</span> creates a record <span class="math">\\mathbf{r}</span> as above, and sends the record and its consumption information <span class="math">\\mathsf{info}</span> to the order book. The order book does not publish these; it publishes only the terms of the order. Takers can publish orders of their own, and if two orders match then the order book operator constructs a transaction <span class="math">\\mathsf{tx}</span> that consumes both records and produces new records, completing the order. At no point does either party surrender custody of their funds, thus preserving the self-custodial nature of the exchange protocol.</p>

    <p class="text-gray-300">The foregoing achieves trade anonymity and confidentiality against everyone but the order book operator because only the order book operator learns the details of the records consumed by the transaction <span class="math">\\mathsf{tx}</span>, and <span class="math">\\mathsf{tx}</span> itself (which once published anyone can see) does not reveal any information about these records. As a consequence, this protocol also protects against front-running by everyone but the order book.</p>

    <p class="text-gray-300">Note that in our protocol, the maker acts as the taker’s counterparty (and vice versa), while in non-private closed-book DEXs, only the order book operator can act as the counterparty for both the maker and the taker. Our protocol can be modified to support such a flow by straightforward modifications to <span class="math">\\mathsf{EoC}</span>.</p>

    <h5 id="sec-42" class="text-base font-semibold mt-4">Operator fees.</h5>

    <p class="text-gray-300">In the foregoing we have omitted a discussion of fees due to the operators of DEX infrastructure (such as index or order book operators). Support for such fees can be achieved, in a straightforward way, by the following small modifications to the exchange-or-cancel predicate <span class="math">\\mathsf{EoC}</span>. First, one would need to increase the number of output records of DPC transactions to <span class="math">n=3</span>; the third record would be used to pay fees to the operator. Second, one would have to decide how these fees are calculated. This can be done, e.g., by hardcoding a fee percentage into the predicate or by allowing users to specify fees that they are willing to pay.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Remark 6.1 (preventing a denial-of-funds attack).</h6>

    <p class="text-gray-300">In the foregoing protocols, the maker <span class="math">\\mathsf{M}</span> could refuse to provide the taker <span class="math">\\mathsf{T}</span> with information about its output record, thus denying <span class="math">\\mathsf{T}</span> the ability to consume</p>

    <p class="text-gray-300">its exchanged record. A simple approach to prevent this is to modify the exchange-or-cancel predicate to additionally enforce that the memorandum field of the created transaction contains an encryption of the output record information under a public key specified by  <span class="math">\\mathsf{T}</span> .</p>

    <p class="text-gray-300">Recently there has been growing interest in custom assets that are managed by a central authority. These include stablecoins, which are assets whose value relative to an another is fixed (see [Har18] for an overview). Centrally-managed assets are more compatible with regulations like taxes or blacklists, because the central authority can enforce monetary policies that follow these regulations. Indeed, existing stablecoins like the Gemini dollar [gem] and the Paxos standard [pax] have mechanisms for reversing transactions or freezing funds in response to legal rulings. In this section, we show how to construct private centrally-managed assets that support arbitrary, and updatable, policies issued by the central authority; this in particular shows how to create and manage policies for private stablecoins. We stress that the ideas described below are compatible with applications that reason about other custom assets. For example, one can use DEXs from Section 6.2 to exchange units of a private stablecoin with units of any other user-defined asset (like one from Section 6.1).</p>

    <p class="text-gray-300">We enforce policies by extending the mint-or-conserve predicate MoC from Section 6.1 into a mint-or-enforce predicate  <span class="math">\\mathsf{MoE}_{\\Pi}</span>  whose "enforce" mode enforces a desired policy  <span class="math">\\Pi</span> . In more detail, say that a central authority A wishes to issue an asset satisfying policy  <span class="math">\\Pi</span>  (initially). To do so, A generates a signature public key  <span class="math">\\mathsf{pk}_{\\mathsf{A}}</span> , and then invokes  <span class="math">\\mathsf{MoE}_{\\Pi}</span>  in mint mode. In this mode,  <span class="math">\\mathsf{MoE}_{\\Pi}</span> , like MoC, generates the asset identifier id and creates the initial supply  <span class="math">\\mathbb{V}</span>  of the asset in a single output record whose payload stores the tuple  <span class="math">(\\mathrm{id},\\mathbb{V},\\mathbb{V},\\bot)</span> . Unlike MoC,  <span class="math">\\mathsf{MoE}_{\\Pi}</span>  binds id not only to the serial numbers of input records (to achieve uniqueness), but also to the public key  <span class="math">\\mathsf{pk}_{\\mathsf{A}}</span>  that authorized  <span class="math">\\Pi</span> . This means that, when receiving payments in such assets, the recipient can immediately deduce the asset's identifier and (authorized) policy.</p>

    <p class="text-gray-300">In a transaction with multiple records, policies are applied and updated by the enforce mode of  <span class="math">\\mathsf{MoE}_{\\Pi}</span> . In this mode,  <span class="math">\\mathsf{MoE}_{\\Pi}</span>  ensures that the new record's payload stores  <span class="math">(\\mathrm{id},\\mathbb{V},v,c)</span> , and that the policy  <span class="math">\\Pi</span>  is satisfied. To update a record  <span class="math">\\mathbf{r}</span>  having policy  <span class="math">\\Pi</span>  to a record  <span class="math">\\mathbf{r}&#x27;</span>  having policy  <span class="math">\\Pi&#x27;</span> , one can create a transaction that consumes  <span class="math">\\mathbf{r}</span>  and creates  <span class="math">\\mathbf{r}&#x27;</span>  such that  <span class="math">\\mathbf{r}&#x27;</span>  has birth predicate  <span class="math">\\mathsf{MoE}_{\\Pi&#x27;}</span> . To ensure that this update is authorized by A,  <span class="math">\\mathsf{MoE}_{\\Pi&#x27;}</span>  checks that a signature over  <span class="math">\\Pi&#x27;</span>  with respect to  <span class="math">\\mathsf{pk}_{\\mathsf{A}}</span>  has been provided, and that id has been correctly derived from  <span class="math">\\mathsf{pk}_{\\mathsf{A}}</span> . These checks ensure that every record with identifier id only has authorized policies.</p>

    <p class="text-gray-300">Below we provide pseudocode for  <span class="math">\\mathsf{MoE}_{\\Pi}</span> .</p>

    <p class="text-gray-300">Mint-or-enforce predicate  <span class="math">\\mathsf{MoE}_{\\Pi}(k,\\mathsf{ldata};\\mathsf{mode})</span>  (mode is the private input of the predicate)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Parse ldata as  $\\left( \\begin{array}{cccc</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c} &amp;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{apk}_{\\mathsf{v}}}^{\\mathsf{in}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2 &amp;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{payload}_\\mathsf{v}}^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2 &amp;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{фуload}_\\mathsf{v}}^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2 &amp;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\Phi_{\\mathsf{d},1}^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2} &amp;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\Phi_{\\mathsf{h},1}^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2} &amp;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{sn}_1^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2} &amp;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{mn}}^2 &amp; \\mathsf{m} &amp; \\mathsf{m} &amp; \\mathsf{n} &amp; \\mathsf{n} &amp; \\mathsf{n} &amp; \\mathsf{n} &amp; \\mathsf{n} &amp; \\mathsf{n} &amp; \\mathsf{n} &amp; \\mathsf{n} &amp; \\mathsf{n} &amp; \\mathsf{n} &amp; \\mathsf{n} &amp; \\mathsf{n} &amp; \\mathsf{n} &amp; \\mathsf{n} &amp; \\mathsf{n} &amp; \\mathsf{n} &amp; \\mathsf{n} &amp; \\mathsf{n}\\end{array} \\right)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If mode = (mint, v, r, pkSIG,  <span class="math">\\sigma_{\\Pi}</span> ), ensure that the first output record contains the initial supply of the asset:</li>

    </ol>

    <p class="text-gray-300">(a) the index of the current output record is correct:  <span class="math">k = 1</span> . (b) all other records are dummy: payload  <span class="math">\\mathbf{\\Pi}_{\\mathrm{i}}^{\\mathrm{in}}</span>  isDummy  <span class="math">=</span>  payload  <span class="math">\\mathbf{\\Pi}_{\\mathrm{2}}^{\\mathrm{in}}</span>  isDummy  <span class="math">=</span>  payload  <span class="math">\\mathbf{\\Pi}_{\\mathrm{2}}^{\\mathrm{out}}</span>  isDummy  <span class="math">= 1</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(c) the asset identifier is derived correctly:  $\\mathsf{id} = \\mathsf{CRH}(\\mathsf{pp}_{\\mathsf{CRH}},\\mathsf{CM},\\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{CM}},\\mathsf{sn}_1\\parallel \\mathsf{sn}_2;r)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{pk}_{\\mathsf{SIG}})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(d) the policy  <span class="math">\\Pi</span>  is authorized by  <span class="math">\\mathsf{pk}_{\\mathsf{SIG}}</span> : SIG.Verify  <span class="math">(\\mathsf{pp}_{\\mathsf{SIG}},\\mathsf{pk}_{\\mathsf{SIG}},\\Pi ,\\sigma_{\\Pi}) = 1</span> (e) the current output record's payload is correct: payload  <span class="math">\\mathbf{\\Pi}_{\\mathrm{out}}^{\\mathrm{out}}</span>  isDummy  <span class="math">= 0</span>  and payload  <span class="math">\\mathbf{\\Pi}_{\\mathrm{out}}^{\\mathrm{out}} = (\\mathrm{id},\\nabla ,\\nabla ,c = \\bot)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If mode = (enforce,  <span class="math">\\rho</span> ,  <span class="math">\\mathsf{pk}_{\\mathsf{SIG}}</span> ,  <span class="math">\\sigma_{\\Pi}</span> ), check that the policy  <span class="math">\\Pi</span>  is enforced:</li>

    </ol>

    <p class="text-gray-300">(a) parse the current output record's payload payload  <span class="math">\\mathbf{\\Pi}_{\\mathrm{out}}^{\\mathrm{out}}</span>  as  <span class="math">(\\mathrm{id}^{<em>},\\nabla^{</em>},v^{*},c)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(b) check that  <span class="math">\\mathsf{pk}_{\\mathsf{SIG}}</span>  is valid for the asset:  $\\mathsf{id}^{*} = \\mathsf{CRH}(\\mathsf{pp}_{\\mathsf{CRH}},\\rho \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{pk}_{\\mathsf{SIG}})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(c) check that the policy  <span class="math">\\Pi</span>  is authorized under pk: SIG.Verify  <span class="math">(\\mathsf{pp}_{\\mathsf{SIG}},\\mathsf{pk}_{\\mathsf{SIG}},\\Pi ,\\sigma_{\\Pi}) = 1.</span> (d) check that the policy  <span class="math">\\Pi</span>  is satisfied:  <span class="math">\\Pi (k,\\mathsf{ldata}) = 1</span></p>

    <p class="text-gray-300">By way of example, we now show how a central authority A can use the mint-or-enforce predicate to construct a stablecoin that enforces a blacklisting (in addition to the default value-conservation policy).</p>

    <p class="text-gray-300">Namely, if an address is on a blacklist <span class="math">B</span> of addresses, the address is not allowed to participate in transactions. To do so, A follows the above procedure to construct and publish a mint-or-enforce predicate <span class="math">\\mathsf{MoE}_{\\Pi_{B}}</span> implementing a policy <span class="math">\\Pi_{B}</span> that inspects the address public keys of consumed records, and ensures that none of them are in <span class="math">B</span>. Now suppose that later on A wishes to update <span class="math">B</span> into a new blacklist <span class="math">B^{\\prime}</span> that includes a new address apk. It does so by publishing a corresponding updated predicate <span class="math">\\mathsf{MoE}_{\\Pi_{B^{\\prime}}}</span> for this new blacklist, and users can use the above update mechanism to move their records from policy <span class="math">\\Pi_{B}</span> to policy <span class="math">\\Pi_{B^{\\prime}}</span>. Now, any funds stored at the newly-blacklisted address apk cannot be moved to the new policy.</p>

    <p class="text-gray-300">7 Implementation strategy</p>

    <p class="text-gray-300">The straightforward approach to implement our construction of a DPC scheme (described in Section 4) is to instantiate the proof system via a simulation-extractable zkSNARK (e.g., [GM17]) and then select the other cryptographic building blocks so that the circuit (more precisely, constraint system) for deciding the NP relation <span class="math">\\mathcal{R}_{\\mathrm{e}}</span> has as small a size as possible. While the straightforward approach sounds promising, closer inspection reveals significant costs that we need to somehow reduce. In this section we discuss, in a “problem and solution” format, the challenges that we encountered and how we addressed them. (The implementation strategy for plain DPC schemes directly ports over to delegable DPC schemes so we do not discuss them.)</p>

    <p class="text-gray-300"><strong>Problem 1: universality is expensive.</strong> The NP relation <span class="math">\\mathcal{R}_{\\mathrm{e}}</span> involves checking arbitrary predicates, which means that one must rely on proof systems for universal computations. However, checking universal computations via state-of-the-art zkSNARKs involves expensive tools for universal circuits/machines [BCG⁺13, BCTV14, WSR⁺15, BCTV17]. These tools would not only yield an expensive solution but would also penalize users who only produce transactions that attest to simple inexpensive predicates, because these users would have to incur the costs of using these “heavy duty” proof systems.</p>

    <p class="text-gray-300"><strong>Solution 1: recursive proof verification.</strong> We address this problem by relying on one layer of recursive proof composition [Val08, BCCT13]. Instead of tasking <span class="math">\\mathcal{R}_{\\mathrm{e}}</span> with checking satisfiability of general predicates, we only task it with checking succinct proofs attesting to this. Checking succinct proofs is a (relatively) inexpensive computation that is universal for all predicates, which can be “hardcoded” in <span class="math">\\mathcal{R}_{\\mathrm{e}}</span>. Crucially, since the “outer” succinct proofs produced for <span class="math">\\mathcal{R}_{\\mathrm{e}}</span> do not reveal information about the “inner” succinct proofs attesting to predicates’ satisfiability (thanks to zero knowledge), the inner succinct proofs do not have to hide what predicate was checked, removing the need for expensive universal circuits; in fact, inner proofs do not even have to be zero knowledge. Rather, these inner succinct proofs can be for NP relations tailored to the computations needed by particular birth and death predicates. Furthermore, this approach ensures that a user only has to incur the cost of proving satisfiability of the specific predicates involved in his transactions, regardless of the complexity of predicates used by other users in their transactions.</p>

    <p class="text-gray-300">In more detail, taking the case of one input and one output record as an example, we modify DPC-Execute to additionally take as input SNARK proofs <span class="math">\\pi_{\\mathrm{d}}</span> and <span class="math">\\pi_{\\mathrm{b}}</span>, and also modify the NP relation <span class="math">\\mathcal{R}_{\\mathrm{e}}</span> so that, instead of directly checking that <span class="math">\\Phi_{\\mathrm{d}}</span> and <span class="math">\\Phi_{\\mathrm{b}}</span> are satisfied, it instead checks that <span class="math">\\pi_{\\mathrm{d}}</span> and <span class="math">\\pi_{\\mathrm{b}}</span> attest to the satisfaction of <span class="math">\\Phi_{\\mathrm{d}}</span> and <span class="math">\\Phi_{\\mathrm{b}}</span>. That is, <span class="math">\\mathcal{R}_{\\mathrm{e}}</span> checks that NIZK.Verify <span class="math">(pp_{\\Phi_{\\mathrm{d}}}, \\pi_{\\mathrm{e}}, \\pi_{\\mathrm{d}}) = 1</span> and NIZK.Verify <span class="math">(pp_{\\Phi_{\\mathrm{b}}}, \\pi_{\\mathrm{e}}, \\pi_{\\mathrm{b}}) = 1</span>, where <span class="math">pp_{\\Phi_{\\mathrm{d}}}</span> are public parameters for the NP relation <span class="math">\\mathcal{R}_{\\Phi_{\\mathrm{d}}} := \\{(\\pi_{\\mathrm{e}}, \\pi_{\\mathrm{e}}) \\text{ s.t. } \\Phi_{\\mathrm{d}}(\\pi_{\\mathrm{e}}, \\pi_{\\mathrm{e}}) = 1\\}</span> and similarly for <span class="math">\\Phi_{\\mathrm{b}}</span>. The public parameters <span class="math">pp_{\\Phi_{\\mathrm{d}}}</span> and <span class="math">pp_{\\Phi_{\\mathrm{b}}}</span> are stored in the record, in place of (a description of) the predicates.¹²</p>

    <p class="text-gray-300">More generally, we modify DPC-Execute to additionally take as input SNARK proofs <span class="math">[\\pi_{\\mathrm{d},i}]_1^m</span> attesting that the old records’ death predicates are satisfied and SNARK proofs <span class="math">[\\pi_{\\mathrm{b},j}]_1^n</span> attesting that the new records’ birth predicates are satisfied. Moreover, we similarly modify the NP relation <span class="math">\\mathcal{R}_{\\mathrm{e}}</span> to check that these proofs are valid, instead of directly checking that the relevant predicates are satisfied.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In sum, <span class="math">\\mathcal{R}_{\\mathrm{e}}</span> is not tasked with checking general predicates. Instead, it merely has to check SNARK proofs, a fixed computation of size <span class="math">O_{\\lambda}(m + n)</span>. Separately, a user wishing to prove that a predicate <span class="math">\\Phi</span> is satisfied will invoke a SNARK on an NP statement of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (tailored for </span>\\Phi$).¹³ The approach described so far, however,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">¹²More precisely, to verify a proof for a predicate <span class="math">\\Phi</span>, the proof verifier does not need to read all of <span class="math">pp_{\\Phi}</span>, which has size $O_{\\lambda}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> in some zkSNARKs (i.e., it is large). Rather, the proof verifier only needs to read </span>O_{\\lambda}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathrm{e}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> bits of </span>pp_{\\Phi}<span class="math">, which are collectively known as the verification key. The record would then store this verification key (or a hash thereof) rather than </span>pp_{\\Phi}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">¹³An additional benefit of each predicate <span class="math">\\Phi</span> having its own public parameters <span class="math">pp_{\\Phi}</span> is flexible trust: users are not obliged to trust parameters used in each others’ transactions and, moreover, if some parameters are known to be compromised, predicates can safely refuse to interact with records associated with them. We view this isolation mechanism as a novel and valuable feature in practice.</p>

    <p class="text-gray-300">38</p>

    <p class="text-gray-300">hides additional costs that we need to overcome.</p>

    <h5 id="sec-45" class="text-base font-semibold mt-4">Problem 2: recursion is expensive.</h5>

    <p class="text-gray-300">Recursive proof composition has so far been empirically demonstrated for pairing-based SNARKs <em>[x1]</em>, whose proofs are extremely short and cheap to verify. We thus focus our attention on these, and explain the efficiency challenges that we must overcome in our setting.</p>

    <p class="text-gray-300">Recall that pairings are instantiated via elliptic curves of small embedding degree. If we instantiate a SNARK’s pairing via an elliptic curve <span class="math">E</span> defined over a prime field <span class="math">\\mathbb{F}_{q}</span> and having a subgroup of large prime order <span class="math">r</span>, then (a) the SNARK supports NP relations <span class="math">\\mathcal{R}</span> expressed as arithmetic circuits over <span class="math">\\mathbb{F}_{r}</span>, while (b) proof verification involves arithmetic operations over <span class="math">\\mathbb{F}_{q}</span>. This means that we need to express <span class="math">\\mathcal{R}_{\\mathbf{e}}</span> via arithmetic circuits over <span class="math">\\mathbb{F}_{r}</span>. In turn, since the SNARK verifier is part of <span class="math">\\mathcal{R}_{\\mathbf{e}}</span>, this means that we need to also express the verifier via an arithmetic circuit over <span class="math">\\mathbb{F}_{r}</span>, which is problematic because the verifier’s “native” operations are over <span class="math">\\mathbb{F}_{q}</span>. Simulating <span class="math">\\mathbb{F}_{q}</span> operations via <span class="math">\\mathbb{F}_{r}</span> operations introduces significant overheads, and picking <span class="math">E</span> such that <span class="math">q=r</span>, in order to avoid simulation, is impossible <em>[x1]</em>.</p>

    <p class="text-gray-300">Prior work thus suggests using multiple curves <em>[x1]</em>, such as a two-cycle of pairing-friendly elliptic curves, that is, two prime-order curves <span class="math">E_{1}</span> and <span class="math">E_{2}</span> such that the prime size of one’s base field is the prime order of the other’s group, and orchestrating SNARKs based on these so that fields always “match up”. Unfortunately, known curves with these properties are inefficient at 128 bits of security <em>[x1, x10]</em>.</p>

    <h5 id="sec-46" class="text-base font-semibold mt-4">Solution 2: tailored set of curves.</h5>

    <p class="text-gray-300">In our setting we merely need “a proof of a proof”, with the latter proof not itself depending on further proofs.</p>

    <p class="text-gray-300">This implies that we do not actually need a cycle of pairing-friendly elliptic curves (which enables recursion of arbitrary depth), but rather only a “two-chain” of two curves <span class="math">E_{1}</span> and <span class="math">E_{2}</span> such that the size of the base field of <span class="math">E_{1}</span> is the size of the prime order subgroup of <span class="math">E_{2}</span>. We can use the Cocks–Pinch method <em>[x12]</em> to set up such a bounded recursion <em>[x1]</em>. We now elaborate on this.</p>

    <p class="text-gray-300">First we pick a pairing-friendly elliptic curve <span class="math">E_{1}</span> that not only is suitable for 128 bits of security according to standard considerations (involving, e.g., its embedding degree and the ratio of the sizes of its base field and prime order group) but, moreover, is compatible with efficient SNARK provers in both levels of the recursion. Namely, letting <span class="math">p</span> be the prime order of the base field and <span class="math">r</span> the prime order of the group, we need that both <span class="math">\\mathbb{F}_{r}</span> and <span class="math">\\mathbb{F}_{p}</span> have multiplicative subgroups whose orders are large powers of <span class="math">2</span>. The condition on <span class="math">\\mathbb{F}_{r}</span> ensures efficient proving for SNARKs over <span class="math">E_{1}</span>, while the condition on <span class="math">\\mathbb{F}_{p}</span> ensures efficient proving for SNARKs that verify proofs over <span class="math">E_{1}</span>. In light of the above, we set <span class="math">E_{1}</span> to be <span class="math">E_{\\mathsf{BLS}}</span>, a curve from the Barreto–Lynn–Scott (BLS) family <em>[x2, x7]</em> with embedding degree <span class="math">12</span>. This family not only enables parameters that conservatively achieve 128 bits of security, but also enjoys properties that facilitate very efficient implementation <em>[AFK^{+}12]</em>. We ensure that both <span class="math">\\mathbb{F}_{r}</span> and <span class="math">\\mathbb{F}_{p}</span> have multiplicative subgroups of order <span class="math">2^{\\alpha}</span> for <span class="math">\\alpha\\geq 40</span>, by choosing the parameter <span class="math">x</span> of the BLS family to satisfy <span class="math">x\\equiv 1\\bmod 3\\cdot 2^{\\alpha}</span>; indeed, for such a choice of <span class="math">x</span> both <span class="math">r(x)=x^{3}-x^{2}+1</span> and <span class="math">p(x)=(x-1)^{2}r(x)/3+x</span> are divisible by <span class="math">2^{\\alpha}</span>. This also ensures that <span class="math">x\\equiv 1\\bmod 3</span>, which ensures that there are efficient towering options for the relevant fields <em>[x11]</em>.</p>

    <p class="text-gray-300">Next we use the Cocks–Pinch method to pick a pairing-friendly elliptic curve <span class="math">E_{2}=E_{\\mathsf{CP}}</span> over a field <span class="math">\\mathbb{F}_{q}</span> such that the curve group <span class="math">E_{\\mathsf{CP}}(\\mathbb{F}_{q})</span> contains a subgroup of prime order <span class="math">p</span> (the size of <span class="math">E_{\\mathsf{BLS}}</span>’s base field). Since the method outputs a prime <span class="math">q</span> that has about <span class="math">2\\times</span> more bits than the desired <span class="math">p</span>, and in turn <span class="math">p</span> has about <span class="math">1.5\\times</span> more bits than <span class="math">r</span> (due to properties of the BLS family), we only need <span class="math">E_{\\mathsf{CP}}</span> to have embedding degree <span class="math">6</span> in order to achieve 128 bits of security (as determined from the guidelines in <em>[x12]</em>).</p>

    <p class="text-gray-300">In sum, proofs of predicates’ satisfiability are produced via a SNARK over <span class="math">E_{\\mathsf{BLS}}</span>, and proofs for the NP relation <span class="math">\\mathcal{R}_{\\mathbf{e}}</span> are produced via a zkSNARK over <span class="math">E_{\\mathsf{CP}}</span>. The matching fields between the two curves ensure that the former proofs can be efficiently verified.</p>

    <h5 id="sec-47" class="text-base font-semibold mt-4">Problem 3: Cocks–Pinch curves are costly.</h5>

    <p class="text-gray-300">While the curve <span class="math">E_{\\mathsf{CP}}</span> was chosen to facilitate efficient checking of proofs over <span class="math">E_{\\mathsf{BLS}}</span>, the curve <span class="math">E_{\\mathsf{CP}}</span> is at least <span class="math">2\\times</span> more expensive (in time and space) than <span class="math">E_{\\mathsf{BLS}}</span> simply</p>

    <p class="text-gray-300">because <span class="math">E_{\\mathsf{CP}}</span>’s base field has about twice as many bits as <span class="math">E_{\\mathsf{BLS}}</span>’s base field. Checks in the NP relation <span class="math">\\mathcal{R}_{\\mathsf{e}}</span> that are not directly related to proof checking are now unnecessarily carried over a less efficient curve.</p>

    <p class="text-gray-300">Solution 3: split relations across two curves. We split <span class="math">\\mathcal{R}_{\\mathsf{e}}</span> into two NP relations <span class="math">\\mathcal{R}_{\\mathsf{BLS}}</span> and <span class="math">\\mathcal{R}_{\\mathsf{CP}}</span> (see Fig. 14), with the latter containing just the proof check and the former containing all other checks. We can then use a zkSNARK over the curve <span class="math">E_{\\mathsf{BLS}}</span> (an efficient curve) to produce proofs for <span class="math">\\mathcal{R}_{\\mathsf{BLS}}</span>, and a zkSNARK over <span class="math">E_{\\mathsf{CP}}</span> (the less efficient curve) to produce proofs for <span class="math">\\mathcal{R}_{\\mathsf{CP}}</span>. This approach significantly reduces the running time of DPC.Execute (producing proofs for the checks in <span class="math">\\mathcal{R}_{\\mathsf{BLS}}</span> is more efficient over <span class="math">E_{\\mathsf{BLS}}</span> than over <span class="math">E_{\\mathsf{CP}}</span>), at the expense of a modest increase in transaction size (a transaction now includes a zkSNARK proof over <span class="math">E_{\\mathsf{BLS}}</span> in addition to a proof over <span class="math">E_{\\mathsf{CP}}</span>). An important technicality that must be addressed is that the foregoing split relies on certain secret information to be shared across the NP relations, namely, the identities of relevant predicates and the local data. We can store this information in suitable commitments that are part of the NP instances for the two NP relations (doing this efficiently requires some care as we discuss below).</p>

    <p class="text-gray-300">Problem 4: the NP relations have many checks. Even using <span class="math">E_{\\mathsf{CP}}</span> only for SNARK verification and <span class="math">E_{\\mathsf{BLS}}</span> for all other checks does not suffice: the NP relations <span class="math">\\mathcal{R}_{\\mathsf{BLS}}</span> and <span class="math">\\mathcal{R}_{\\mathsf{CP}}</span> still have to perform expensive checks like verifying Merkle tree authentication paths and commitment openings, and evaluating pseudorandom functions and collision resistant functions. Similar NP relations, like the one in Zerocash <em>[BCG^{+}14]</em>, require upwards of four million gates to express such checks, resulting in high latencies for producing transactions (several minutes) and large public parameters for the system (hundreds of megabytes).</p>

    <p class="text-gray-300">Solution 4: efficient EC primitives. Commitments and collision-resistant hashing can be expressed as very efficient arithmetic circuits if one opts for Pedersen-type constructions over suitable Edwards elliptic curves (and techniques derived from these ideas are now part of deployed systems <em>[x11]</em>). To do this, we pick two Edwards curves, <span class="math">E_{\\mathsf{Ed}/\\mathsf{BLS}}</span> over the field <span class="math">\\mathbb{F}_{r}</span> (matching the group order of <span class="math">E_{\\mathsf{BLS}}</span>) and <span class="math">E_{\\mathsf{Ed}/\\mathsf{CP}}</span> over the field <span class="math">\\mathbb{F}_{p}</span> (matching the group order of <span class="math">E_{\\mathsf{CP}}</span>). This enables us to achieve very efficient circuits for primitives used in our NP relations, including commitments, collision-resistant hashing, and randomizable signatures. (Note that <span class="math">E_{\\mathsf{Ed}/\\mathsf{BLS}}</span> and <span class="math">E_{\\mathsf{Ed}/\\mathsf{CP}}</span> do not need to be pairing-friendly as the primitives only rely on their group structure.)</p>

    <p class="text-gray-300">Problem 5: sharing information between NP relations is costly. We have said that splitting <span class="math">\\mathcal{R}_{\\mathsf{e}}</span> into two NP relations <span class="math">\\mathcal{R}_{\\mathsf{BLS}}</span> and <span class="math">\\mathcal{R}_{\\mathsf{CP}}</span> relies on sharing secret information via commitments across NP statements; namely, a commitment <span class="math">\\mathsf{cm}_{\\Phi}</span> to the identities of predicates and a commitment <span class="math">\\mathsf{cm}_{\\mathsf{ldata}}</span> to the local data. But if both relations open these commitments, we cannot make an efficient use of Pedersen commitments because the two NP relations are over different fields: <span class="math">\\mathcal{R}_{\\mathsf{BLS}}</span> is over <span class="math">\\mathbb{F}_{r}</span>, while <span class="math">\\mathcal{R}_{\\mathsf{CP}}</span> is over <span class="math">\\mathbb{F}_{p}</span>. For example, if we used a Pedersen commitment over the order-<span class="math">r</span> subgroup of the Edwards curve <span class="math">E_{\\mathsf{Ed}/\\mathsf{BLS}}</span>, then: (a) opening a commitment in <span class="math">\\mathcal{R}_{\\mathsf{BLS}}</span> would be cheap, but (b) opening a commitment in <span class="math">\\mathcal{R}_{\\mathsf{CP}}</span> would involve expensive simulation of <span class="math">\\mathbb{F}_{r}</span>-arithmetic via <span class="math">\\mathbb{F}_{p}</span>-arithmetic. (And similarly if we used a Pedersen commitment over the order-<span class="math">p</span> subgroup of the Edwards curve <span class="math">E_{\\mathsf{Ed}/\\mathsf{CP}}</span>.) To make matters worse, the predicate identities and the local data are large, so an inefficient solution for committing to these would add significant costs to <span class="math">\\mathcal{R}_{\\mathsf{BLS}}</span> and <span class="math">\\mathcal{R}_{\\mathsf{CP}}</span>.</p>

    <p class="text-gray-300">Solution 5: hash predicate verification keys and commit to local data. In a record, instead of storing predicate verification keys, we store collision-resistant hashes of these. This reduces the cost of producing the commitment <span class="math">\\mathsf{cm}_{\\Phi}</span> in <span class="math">\\mathcal{R}_{\\mathsf{BLS}}</span> and <span class="math">\\mathcal{R}_{\\mathsf{CP}}</span>, as <span class="math">\\mathsf{cm}_{\\Phi}</span> contains hashes that are much smaller than verification keys. We realize <span class="math">\\mathsf{cm}_{\\Phi}</span> via Blake2s, a boolean primitive of modest cost in <span class="math">\\mathbb{F}_{r}</span> and <span class="math">\\mathbb{F}_{p}</span>. Crucially, only <span class="math">\\mathcal{R}_{\\mathsf{CP}}</span> needs to access the verification keys themselves, so we can efficiently use a Pedersen hash over the Edwards curve <span class="math">E_{\\mathsf{Ed}/\\mathsf{CP}}</span> to let <span class="math">\\mathcal{R}_{\\mathsf{CP}}</span> check the keys (supplied as non-deterministic advice) against the hashes inside <span class="math">\\mathsf{cm}_{\\Phi}</span>.</p>

    <p class="text-gray-300">We realize the local data commitment <span class="math">\\mathsf{cm}_{\\mathsf{ldata}}</span> via a Pedersen commitment over <span class="math">E_{\\mathsf{Ed}/\\mathsf{BLS}}</span>, and assume that predicates take <span class="math">\\mathsf{cm}_{\\mathsf{ldata}}</span> as input rather than local data in the clear. Since both <span class="math">\\mathcal{R}_{\\mathsf{BLS}}</span> and the predicate relations are defined over the field <span class="math">\\mathbb{F}_{r}</span> (the prime-order subgroup of the curve <span class="math">E_{\\mathsf{BLS}}</span>), non-deterministically openin</p>

    <p class="text-gray-300"><span class="math">\\mathsf{cm}_{\\mathsf{ldata}}</span> is efficient in both relations. This approach significantly reduces costs because <span class="math">\\mathcal{R}_{\\mathsf{CP}}</span> no longer needs to reason about the contents of <span class="math">\\mathsf{cm}_{\\mathsf{ldata}}</span>, and can simply pass <span class="math">\\mathsf{cm}_{\\mathsf{ldata}}</span> as input to the SNARK verifier.</p>

    <p class="text-gray-300">The NP relation  <span class="math">\\mathcal{R}_{\\mathrm{BLS}}</span>  has instances  <span class="math">\\mathbf{x}_{\\mathrm{BLS}}</span>  and witnesses  <span class="math">\\mathbf{w}_{\\mathrm{BLS}}</span>  of the form</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">xBLS =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ledger digest</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">stL</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and wBLS =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">old records</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[ri]1m</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">old record serial numbers</td>

            <td class="px-3 py-2 border-b border-gray-700">[sn1]1m</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">old record membership witnesses</td>

            <td class="px-3 py-2 border-b border-gray-700">[wL,i]1m</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">new record commitments</td>

            <td class="px-3 py-2 border-b border-gray-700">[cmj]1n</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">old address secret keys</td>

            <td class="px-3 py-2 border-b border-gray-700">[askj]1m</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">predicate commitment</td>

            <td class="px-3 py-2 border-b border-gray-700">cmΦ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">new records</td>

            <td class="px-3 py-2 border-b border-gray-700">[rj]1n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">local data commitment</td>

            <td class="px-3 py-2 border-b border-gray-700">cmldata</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">predicate comm. randomness</td>

            <td class="px-3 py-2 border-b border-gray-700">rΦ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">transaction memorandum</td>

            <td class="px-3 py-2 border-b border-gray-700">memo</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">local data randomness</td>

            <td class="px-3 py-2 border-b border-gray-700">rldata</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">auxiliary predicate input</td>

            <td class="px-3 py-2 border-b border-gray-700">aux</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for each  <span class="math">i \\in \\{1, \\dots, m\\}</span> ,  <span class="math">\\mathbf{r}_i = (\\mathsf{apk}_i, \\mathsf{payload}_i, h_{\\mathsf{b},i}, h_{\\mathsf{d},i}, \\rho_i, r_i, \\mathsf{cm}_i)</span> ;</li>

      <li>for each  <span class="math">j \\in \\{1, \\dots, n\\}</span> ,  <span class="math">\\mathbf{r}_j = (\\mathsf{apk}_j, \\mathsf{payload}_j, h_{\\mathsf{b},j}, h_{\\mathsf{d},j}, \\rho_j, r_j, \\mathsf{cm}_j)</span> .</li>

    </ul>

    <p class="text-gray-300">Define the local data  <span class="math">\\mathsf{ldata} := \\left( \\begin{array}{cccc} [cm_i]_1^m &amp;amp; [apk_i]_1^m &amp;amp; [payload_i]_1^m &amp;amp; [h_{d,i}]_1^m &amp;amp; [h_{b,i}]_1^m &amp;amp; [sn_i]_1^m &amp;amp; \\mathsf{memo} \\\\ [cm_j]_1^n &amp;amp; [apk_j]_1^n &amp;amp; [payload_j]_1^n &amp;amp; [h_{d,j}]_1^n &amp;amp; [h_{b,j}]_1^n &amp;amp; \\mathsf{aux} \\end{array} \\right)</span> .</p>

    <p class="text-gray-300">A witness  <span class="math">\\mathbf{w}_{\\mathrm{BLS}}</span>  is valid for an instance  <span class="math">\\mathbf{x}_{\\mathrm{BLS}}</span>  if the following conditions hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i \\in \\{i, \\dots, m\\}</span> :</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">\\mathbf{r}_i</span>  is not dummy,  <span class="math">\\mathbf{w}_{\\mathbf{L},i}</span>  proves that the commitment  <span class="math">\\mathbf{cm}_i</span>  is in a ledger with digest  <span class="math">\\mathbf{st}_{\\mathbf{L}}</span> :  <span class="math">\\mathbf{L}</span> . Verify  <span class="math">(\\mathbf{st}_{\\mathbf{L}}, \\mathbf{cm}_i, \\mathbf{w}_{\\mathbf{L},i}) = 1</span> .</li>

      <li>The address public key  <span class="math">\\mathsf{apk}_i</span>  and secret key  <span class="math">\\mathsf{ask}_i</span>  form a valid key pair:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{apk}_i = \\mathsf{CM}. \\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{CM}}, \\mathsf{sk}_{\\mathsf{PRF},i}; r_{\\mathsf{pk},i})</span>  and  <span class="math">\\mathsf{ask}_i = (\\mathsf{sk}_{\\mathsf{PRF},i}, r_{\\mathsf{pk},i})</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The serial number  <span class="math">\\mathsf{sn}_i</span>  is valid:  <span class="math">\\mathsf{sn}_i = \\mathsf{PRF}_{\\mathsf{w}_{\\mathsf{PRF},i}}(\\rho_i)</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The old record commitment  <span class="math">\\mathsf{cm}_i</span>  is valid:  $\\mathsf{cm}_i = \\mathsf{TCM}. \\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{TCM}}, \\mathsf{apk}_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{payload}_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h_{\\mathsf{b},i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h_{\\mathsf{d},i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_i; r_i)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">j \\in \\{1, \\dots, n\\}</span> :</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The serial number nonce  <span class="math">\\rho_{j}</span>  is computed correctly:  $\\rho_{j} = \\mathsf{CRH}. \\mathsf{Eval}(\\mathsf{pp}_{\\mathsf{CRH}}, j \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sn}_{1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sn}_{m})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. The predicate commitment  <span class="math">\\mathsf{cm}_{\\Phi}</span>  is valid:  $\\mathsf{cm}_{\\Phi} = \\mathsf{b2s}([h_{\\mathsf{d},i}]_1^m\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[h_{\\mathsf{b},j}]_1^n\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_{\\Phi})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The local data commitment  <span class="math">\\mathsf{cm}_{\\mathrm{ldata}}</span>  is valid:  <span class="math">\\mathsf{cm}_{\\mathrm{ldata}} = \\mathsf{CM}. \\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{CM}}, \\mathsf{ldata}; r_{\\mathrm{ldata}})</span></li>

    </ol>

    <p class="text-gray-300">The NP relation  <span class="math">\\mathcal{R}_{\\mathrm{CP}}</span>  has instances  <span class="math">\\mathbf{x}_{\\mathrm{CP}}</span>  and witnesses  <span class="math">\\mathbf{w}_{\\mathrm{CP}}</span>  of the form</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">xCP = (predicate commitment cmΦ local data commitment cmldata)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and wCP = (old death pred. ver. keys [vkd,i]1m old death pred. proofs [πd,i]1m new birth pred. ver. keys [vkb,j]1n new birth pred. proofs [πb,j]1n</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| predicate comm. randomness rΦ |</p>

    <p class="text-gray-300">A witness  <span class="math">\\mathbf{w}_{\\mathrm{CP}}</span>  is valid for an instance  <span class="math">\\mathbf{x}_{\\mathrm{CP}}</span>  if the following conditions hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i \\in \\{i, \\dots, m\\}</span> :</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The death predicate hash  <span class="math">h_{\\mathrm{d},i}</span>  is computed correctly:  <span class="math">h_{\\mathrm{d},i} = \\mathrm{CRH}. \\mathrm{Eval}(\\mathsf{pp}_{\\mathrm{CRH}}, \\mathsf{vk}_{\\mathrm{d},i})</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The death predicate proof  <span class="math">\\pi_{\\mathrm{d},i}</span>  is valid: NIZK.Verify(vkd,i,i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cmldata,  <span class="math">\\pi_{\\mathrm{d},i}</span> ).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">j \\in \\{1, \\dots, n\\}</span> :</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The birth predicate hash  <span class="math">h_{\\mathrm{b},j}</span>  is computed correctly:  <span class="math">h_{\\mathrm{b},j} = \\mathrm{CRH}. \\mathrm{Eval}(\\mathsf{pp}_{\\mathrm{CRH}}, \\mathsf{vk}_{\\mathrm{b},j})</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The birth predicate proof  <span class="math">\\pi_{\\mathrm{b},j}</span>  is valid: NIZK.Verify(vk <span class="math">_{\\mathrm{b},j}</span> , j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cmldata,  <span class="math">\\pi_{\\mathrm{b},j}</span> ).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. The predicate commitment  <span class="math">\\mathsf{cm}_{\\Phi}</span>  is valid:  $\\mathsf{cm}_{\\Phi} = \\mathsf{b2s}([h_{\\mathsf{d},i}]_1^m\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[h_{\\mathsf{b},j}]_1^n\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_{\\Phi})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 14: Splitting the NP relation  <span class="math">\\mathcal{R}_{\\mathrm{e}}</span>  into two NP relations  <span class="math">\\mathcal{R}_{\\mathrm{BLS}}</span>  and  <span class="math">\\mathcal{R}_{\\mathrm{CP}}</span> , over  <span class="math">\\mathbb{F}_r</span>  and  <span class="math">\\mathbb{F}_p</span>  respectively.</p>

    <p class="text-gray-300">We implemented our "plain" DPC scheme (Section 4) and our delegable DPC scheme (Section 5), by following the strategy described in Section 7. The resulting system, named ZEXE (Zero knowledge EXEcution), consists of several Rust libraries: (a) a library for finite field and elliptic curve arithmetic, adapted from [Bow17b]; (b) a library for cryptographic building blocks, including zkSNARKs for constraint systems (using components from [Bow17a]); (c) a library with constraints for many of these building blocks; and (d) a library that realizes our constructions of plain and delegable DPC. Our code base, like our construction, is written in terms of abstract building blocks, which allows to easily switch between different instantiations of the building blocks. In the rest of this section we describe the efficient instantiations used in the experiments reported in Section 9.</p>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a> Figure 15: Stack of libraries comprising ZEXE.</p>

    <p class="text-gray-300">Ledger. The ledger  <span class="math">\\mathbf{L}</span>  in our prototype is simply an ideal ledger, i.e., an append-only log of valid transactions that is stored in memory. Of course, in a real-world deployment, this ideal ledger would be replaced by a distributed protocol that realizes (a suitable approximation of) an ideal ledger. Recall from Section 3.1 that we require the ledger  <span class="math">\\mathbf{L}</span>  to provide a method to efficiently prove and verify membership of a transaction, or one of its subcomponents, in  <span class="math">\\mathbf{L}</span> . For this, we maintain a Merkle tree [Mer87] atop the list of transactions, using the collision-resistant hash function CRH described below. This results in the following algorithms for  <span class="math">\\mathbf{L}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>L.Push(tx): Append tx to the transaction list and update the Merkle tree.</li>

      <li>L.Digest  <span class="math">\\rightarrow</span>  stL: Return the root of the Merkle tree.</li>

      <li>L.Prove(tx)  <span class="math">\\rightarrow</span>  wL: Return the authentication path for tx in the Merkle tree.</li>

      <li>L.Verify  <span class="math">(\\mathsf{st}_{\\mathbf{L}},\\mathsf{tx},\\mathsf{w}_{\\mathbf{L}})\\to b</span>  : Check that  <span class="math">\\mathsf{w}_{\\mathbf{L}}</span>  is a valid authentication path for tx in a tree with root  <span class="math">\\mathsf{st}_{\\mathbf{L}}</span></li>

    </ul>

    <p class="text-gray-300">Our prototype maintains the Merkle tree in memory, but a real-world deployment would have to maintain it via a distributed protocol. (Such data structures atop distributed ledgers are used in existing systems [ZCa15].)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pseudorandom function. Fixing key length and input length at 256 bits, we instantiate PRF using the Blake2s hash function [ANWW13]:  $\\mathsf{PRF}_k(x) \\coloneqq \\mathsf{b2s}(k\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x)<span class="math">  for  </span>k, x \\in \\{0,1\\}^{256}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Elliptic curves. Our implementation strategy (see Section 7) involves several elliptic curves: two pairing-friendly curves  <span class="math">E_{\\mathrm{BLS}}</span>  and  <span class="math">E_{\\mathrm{CP}}</span> , and two "plain" curves  <span class="math">E_{\\mathrm{Ed/BLS}}</span>  and  <span class="math">E_{\\mathrm{Ed/CP}}</span>  whose base field respectively matches the prime-order subgroup of  <span class="math">E_{\\mathrm{BLS}}</span>  and  <span class="math">E_{\\mathrm{CP}}</span> . Details about these curves are in Figure 16; the parameter used to generate the BLS curve  <span class="math">E_{\\mathrm{BLS}}</span>  is  <span class="math">x = 3 \\cdot 2^{46} \\cdot (7 \\cdot 13 \\cdot 499) + 1</span>  (see Section 7 for why).</p>

    <p class="text-gray-300">NIZKs. We instantiate the NIZKs used for the NP relation  <span class="math">\\mathcal{R}_{\\mathrm{e}}</span>  via zero-knowledge succinct non-interactive arguments of knowledge (zk-SNARKs), which makes our DPC schemes succinct (see Remark 4.1). Concretely, we rely on the simulation-extractable zkSNARK of Groth and Maller [GM17], used over the pairing-friendly elliptic curves  <span class="math">E_{\\mathrm{BLS}}</span>  (for proving predicates' satisfiability) and  <span class="math">E_{\\mathrm{CP}}</span>  (for proving validity of these latter proofs).</p>

    <p class="text-gray-300">DLP-hard group. Several instantiations of cryptographic primitives introduced below rely on the hardness of extracting discrete logarithms in a prime order group. We generate these groups via a group generator SampleGrp, which on input a security parameter  <span class="math">\\lambda</span>  (represented in unary), outputs a tuple  <span class="math">(\\mathbb{G}, q, g)</span>  that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">name</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">curve type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">embedding degree</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">size of prime-order subgroup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">size of base field</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">size of compressed group elements (rounded to multiples of 8 bytes)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">EEd/BLS</td>

            <td class="px-3 py-2 border-b border-gray-700">twisted Edwards</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">s</td>

            <td class="px-3 py-2 border-b border-gray-700">r</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">EBLS</td>

            <td class="px-3 py-2 border-b border-gray-700">BLS</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">r</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">EEd/CP</td>

            <td class="px-3 py-2 border-b border-gray-700">twisted Edwards</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">t</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ECP</td>

            <td class="px-3 py-2 border-b border-gray-700">short Weierstrass</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">q</td>

            <td class="px-3 py-2 border-b border-gray-700">104</td>

            <td class="px-3 py-2 border-b border-gray-700">312</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">prime</td>

            <td class="px-3 py-2 border-b border-gray-700">value</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size in bits</td>

            <td class="px-3 py-2 border-b border-gray-700">2-adicity</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s</td>

            <td class="px-3 py-2 border-b border-gray-700">0x4aad957a68b2955982d1347970dec005293a3afc43c8afeb 95aee9ac33fd9ff</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">251</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">r</td>

            <td class="px-3 py-2 border-b border-gray-700">0x12ab655e9a2ca55660b44d1e5c37b00159aa76fed0000001 0a11800000000001</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">253</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t</td>

            <td class="px-3 py-2 border-b border-gray-700">0x35c748c2f8a21d58c760b80d94292763445b3e601ea271e1 d75fe7d6eeb84234066d10f5d893814103486497d95295</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">374</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">0x1ae3a4617c510eac63b05c06ca1493b1a22d9f300f5138f1 ef3622fba094800170b5d44300000008508c00000000001</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">377</td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">q</td>

            <td class="px-3 py-2 border-b border-gray-700">0x3848c4d2263babf8941fe959283d8f526663bc5d176b746a f0266a7223ee72023d07830c728d80f9d78bab3596c8617c57 9252a3fb77c79c13201ad533049cfe6a399c2f764a12c4024b ee135c065f4d26b7545d85c16dfd424adace79b57b942ae9</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">782</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">describes a group  <span class="math">\\mathbb{G}</span>  of prime order  <span class="math">q</span>  generated by  <span class="math">g</span> . The discrete-log problem is hard in  <span class="math">\\mathbb{G}</span> . In our prototype we fix  <span class="math">\\mathbb{G}</span>  to be the largest prime-order subgroup of either  <span class="math">E_{\\mathrm{Ed} / \\mathrm{BLS}}</span>  or  <span class="math">E_{\\mathrm{Ed} / \\mathrm{CP}}</span> , depending on the context.</p>

    <p class="text-gray-300">Commitments. We instantiate (plain and) trapdoor commitments via Pedersen commitments over  <span class="math">\\mathbb{G}</span> , as defined in Figure 17; note that the setup algorithm takes as additional input the message length  <span class="math">n</span> . Pedersen commitments are perfectly hiding, and are computationally binding if the discrete-log problem is hard in  <span class="math">\\mathbb{G}</span> .</p>

    <p class="text-gray-300">Collision-resistant hashing. We instantiate CRH via a Pedersen hash function over  <span class="math">\\mathbb{G}</span> , as specified in Figure 18; note that the setup algorithm takes as additional input the message length  <span class="math">n</span> . Collision resistance follows from hardness of the discrete-logarithm problem [MRK03].</p>

    <p class="text-gray-300">Remark 8.1. Hopwood et al. [HBHW20] note that projecting a twisted Edwards curve point  <span class="math">(x,y)</span>  to its  <span class="math">x</span> -coordinate is injective when the point is in the curve's largest prime-order subgroup. Our implementation uses this fact to reduce the output size of TCM and CRH by projecting their output to its  <span class="math">x</span> -coordinate.</p>

    <p class="text-gray-300">Figure 16: The elliptic curves  <span class="math">E_{\\mathrm{BLS}}</span> ,  <span class="math">E_{\\mathrm{CP}}</span> ,  <span class="math">E_{\\mathrm{Ed} / \\mathrm{BLS}}</span> ,  <span class="math">E_{\\mathrm{Ed} / \\mathrm{CP}}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">TCM.Setup(1^λ, n) → ppTCM: 1. Sample a group: (G, q, g) ← SampleGrp(1^λ). 2. For i ∈ {1, ..., n}, sample generator hi: ri ← Zq; hi := g^ri. 3. Output ppTCM := (G, q, g, [hi]1^n).</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CRH.Setup(1^λ, n) → ppCRH: 1. Sample a group: (G, q, g1) ← SampleGrp(1^λ). 2. For i ∈ {2, ..., n}, sample generator gi: ri ← Zq; gi := g^ri. 3. Output ppCRH := (G, q, [gi]1^n).</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">TCM.Commit(ppTCM, m ∈ {0, 1}^n; rcm) → cm: 1. Parse ppTCM as (G, q, g, [hi]1^n). 2. Output cm := g^rcm ∏i=1^nhi^mi.</td>

            <td class="px-3 py-2 border-b border-gray-700">CRH.Eval(ppCRH, m ∈ {0, 1}^n) → h: 1. Parse ppCRH as (G, q, [gi]1^n). 2. Output h := ∏i=1^n gi^mi.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 17: Pedersen commitment scheme.</p>

    <p class="text-gray-300">Figure 18: Pedersen collision-resistant hash.</p>

    <p class="text-gray-300">9 System evaluation</p>

    <p class="text-gray-300">In Section 9.1 we evaluate individual cryptographic building blocks. In Section 9.2 we evaluate the cost of NP relations expressed as constraints, as required by the underlying zkSNARK. In Section 9.3 we evaluate the running time of DPC algorithms. In Section 9.4 we evaluate the sizes of DPC data structures. All reported measurements were taken on a machine with an Intel Xeon 6136 CPU at <span class="math">3.0\\text{\\,}\\mathrm{GHz}</span> with <span class="math">252\\text{\\,}\\mathrm{GB}</span> of RAM.</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">9.1 Cryptographic building blocks</h3>

    <p class="text-gray-300">We are interested in two types of costs associated with a given cryptographic building block: the <em>native execution cost</em>, which are the running times of certain algorithms on a CPU; and the <em>constraint cost</em>, which are the numbers of constraints required to express certain invariants, to be used by the underlying zkSNARK.</p>

    <h4 id="sec-50" class="text-lg font-semibold mt-6">Native execution cost.</h4>

    <p class="text-gray-300">The zkSNARK dominates native execution cost, and the costs of all other building blocks are negligible in comparison. Therefore we separately report only the running times of the zkSNARK, which in our case is a protocol due to Groth and Maller <em>[x13]</em>, abbreviated as GM17. When instantiated over the elliptic curve <span class="math">E_{\\text{BLS}}</span>, the GM17 prover takes <span class="math">25\\text{\\,}\\mathrm{\\SIUnitSymbolMicro s}</span> per constraint (with <span class="math">12</span> threads), while the GM17 verifier takes <span class="math">250n\\text{\\,}\\mathrm{\\SIUnitSymbolMicro s}+9.5\\text{\\,}\\mathrm{ms}</span> on an input with <span class="math">n</span> field elements (with <span class="math">1</span> thread). When instantiated over the elliptic curve <span class="math">E_{\\text{CP}}</span>, the respective prover and verifier costs are <span class="math">147\\text{\\,}\\mathrm{\\SIUnitSymbolMicro s}</span> per constraint and <span class="math">1.6n\\text{\\,}\\mathrm{ms}+34\\text{\\,}\\mathrm{ms}</span>.</p>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">Constraint cost.</h4>

    <p class="text-gray-300">There are three building blocks that together account for the majority of the cost of NP statements that we use. These are: (a) the Blake2s PRF, which requires <span class="math">21792</span> constraints to map a <span class="math">64</span>-byte input to a <span class="math">32</span>-byte output; (b) the Pedersen collision-resistant hash, which requires <span class="math">5n</span> constraints for an input of <span class="math">n</span> bits; and (c) the GM17 verifier, which requires <span class="math">14n+52626</span> constraints for an <span class="math">n</span>-bit input.</p>

    <h3 id="sec-52" class="text-xl font-semibold mt-8">9.2 The execute NP relation</h3>

    <p class="text-gray-300">In many zkSNARK constructions, including the one that we use, one must express all the relevant checks in the given NP relation as (rank-1) <em>quadratic constraints</em> over a certain large prime field. The goal is to minimize the number of such constraints because the prover’s costs grow (quasi)linearly in this number.</p>

    <p class="text-gray-300">In our DPC scheme we use a zkSNARK for the NP relation <span class="math">\\mathcal{R}_{\\text{e}}</span> in Fig. 9 and, similarly, in our delegable DPC scheme we use it for the NP relation <span class="math">\\mathcal{R}_{\\text{e}}^{\\text{del}}</span> in Fig. 23. More precisely, for efficiency reasons explained in Section 7, we split <span class="math">\\mathcal{R}_{\\text{e}}</span> into the two NP relations <span class="math">\\mathcal{R}_{\\text{BLS}}</span> and <span class="math">\\mathcal{R}_{\\text{CP}}</span> in Fig. 14, which we prove via zkSNARKs over the pairing-friendly curves <span class="math">E_{\\text{BLS}}</span> and <span class="math">E_{\\text{CP}}</span>, respectively. (We also similarly split <span class="math">\\mathcal{R}_{\\text{e}}^{\\text{del}}</span>.)</p>

    <p class="text-gray-300">Table 3 reports the number of constraints that that we use to express <span class="math">\\mathcal{R}_{\\text{BLS}}</span>, as a function of the number of input (<span class="math">m</span>) and output (<span class="math">n</span>) records, and additionally reports its primary contributors. Table 4 does the same for <span class="math">\\mathcal{R}_{\\text{CP}}</span>. These tables show that for each input record costs are dominated by verification of a Merkle tree path and the verification of a (death predicate) proof; while for each output record costs are dominated by the verification of a (birth predicate) proof. We also report the cumulative number of constraints when setting <span class="math">m:=2</span> and <span class="math">n:=2</span> because this is a representative instantiation of <span class="math">m</span> and <span class="math">n</span> that enables useful applications.</p>

    <h3 id="sec-53" class="text-xl font-semibold mt-8">9.3 DPC algorithms</h3>

    <p class="text-gray-300">In Table 1 we report the running times of algorithms in our plain DPC and delegable DPC implementations for two input and two output records (i.e., <span class="math">m:=2</span> and <span class="math">n:=2</span>). Note that for Execute and Verify, we have excluded costs of ledger operations (such as retrieving an authentication path or scanning for duplicate serial numbers) because these depend on how a ledger is realized, which is orthogonal to our work. Also, we assume that Execute receives as inputs the application-specific SNARK proofs checked by the NP relation. Producing</p>

    <p class="text-gray-300">each of these proofs requires invoking the GM17 prover, over the elliptic curve  <span class="math">E_{\\mathrm{BLS}}</span> , for the relevant birth or death predicate; we describe the cost of doing so for representative applications in Section 9.5.</p>

    <p class="text-gray-300">Observe that the overhead incurred by delegable DPC over plain DPC is negligible, and that, as expected, Setup and Execute are the most costly algorithms, as they invoke costly zkSNARK setup and proving algorithms. To mitigate these costs, Setup and Execute are executed on 12 threads; everything else is executed with 1 thread. Overall, we learn that Execute takes less than a minute, and Verify takes tens of milliseconds. Furthermore, both Setup and Execute consume less than 5 GB of RAM. These costs are comparable with those of similar systems such as Zerocash  <span class="math">\\left[\\mathrm{BCG}^{+}14\\right]</span>  and Hawk  <span class="math">\\left[\\mathrm{KMS}^{+}16\\right]</span> .</p>

    <p class="text-gray-300">Addresses. An address public key in a DPC scheme is a point on the elliptic curve  <span class="math">E_{\\mathrm{Ed} / \\mathrm{BLS}}</span> , which is 32 bytes when compressed (see Fig. 16); the corresponding secret key is 64 bytes and consists of a PRF seed (32 bytes) and commitment randomness (32 bytes). In a delegable DPC scheme, address public keys do not change, but address secret keys are 96 bytes, because they additionally contain the 32-byte secret key of a randomizable signature scheme over the elliptic curve  <span class="math">E_{\\mathrm{Ed} / \\mathrm{BLS}}</span>  (see Fig. 10).</p>

    <p class="text-gray-300">Transactions. A transaction in a DPC scheme, with two input and two output records, is 968 bytes. It contains two zkSNARK proofs:  <span class="math">\\pi_{\\mathrm{BLS}}</span> , over the elliptic curve  <span class="math">E_{\\mathrm{BLS}}</span> , and  <span class="math">\\pi_{\\mathrm{CP}}</span> , over the curve  <span class="math">E_{\\mathrm{CP}}</span> . Each proof consists of two  <span class="math">\\mathbb{G}_1</span>  and one  <span class="math">\\mathbb{G}_2</span>  elements from its respective curve, amounting to 192 bytes for  <span class="math">\\pi_{\\mathrm{BLS}}</span>  and 520 for  <span class="math">\\pi_{\\mathrm{CP}}</span>  (both in compressed form). In general, for  <span class="math">m</span>  input records and  <span class="math">n</span>  output records, transactions are  <span class="math">32m + 32n + 840</span>  bytes. In a delegable DPC scheme, a transaction additionally contains a 64-byte signature for each input record. See Table 2 for a detailed break down of all of these costs.</p>

    <p class="text-gray-300">Record contents. We set a record's payload to be 32 bytes long; if a predicate needs longer data then it can set the payload to be the hash of this data, and use non-determinism to access the data. The foregoing choice means that all contents of a record add up to 224 bytes, since a record consists of an address public key (32 bytes), the 32-byte payload, hashes of birth and death predicates (48 bytes each), a serial number nonce (32 bytes), and commitment randomness (32 bytes).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Plain DPC</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Delegable DPC</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Setup</td>

            <td class="px-3 py-2 border-b border-gray-700">109.62 s</td>

            <td class="px-3 py-2 border-b border-gray-700">109.3 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GenAddress</td>

            <td class="px-3 py-2 border-b border-gray-700">380 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">780 μs</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Execute</td>

            <td class="px-3 py-2 border-b border-gray-700">52.5 s</td>

            <td class="px-3 py-2 border-b border-gray-700">53.4 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify</td>

            <td class="px-3 py-2 border-b border-gray-700">46 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">47 ms</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Cost of DPC algorithms for 2 inputs and 2 outputs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Plain DPC</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Delegable DPC</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2 inputs and 2 outputs</td>

            <td class="px-3 py-2 border-b border-gray-700">968</td>

            <td class="px-3 py-2 border-b border-gray-700">1096</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">m inputs and n outputs</td>

            <td class="px-3 py-2 border-b border-gray-700">32m + 32n + 840</td>

            <td class="px-3 py-2 border-b border-gray-700">96m + 32n + 840</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Per input record: |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Serial number</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">32</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">32</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Per output record: |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Commitment</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">32</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">32</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">zkSNARK proof over ECP</td>

            <td class="px-3 py-2 border-b border-gray-700">520</td>

            <td class="px-3 py-2 border-b border-gray-700">520</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">zkSNARK proof over EBLS</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Predicate commitment</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Local data commitment</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ledger digest</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Size of a DPC transaction (in bytes).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Plain DPC</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Delegable DPC</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Total with 2 inputs and 2 outputs</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">387412</td>

            <td class="px-3 py-2 border-b border-gray-700">414339</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Below we provide a breakdown of the number of constraints with m input and n output records.  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Per input record</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Total</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">117699</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">125401</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  Enforce validity of: |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Merkle tree path</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">81824</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">81824</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Serial number computation</td>

            <td class="px-3 py-2 border-b border-gray-700">22301</td>

            <td class="px-3 py-2 border-b border-gray-700">25390</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Record commitment</td>

            <td class="px-3 py-2 border-b border-gray-700">9752</td>

            <td class="px-3 py-2 border-b border-gray-700">9752</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Per output record</td>

            <td class="px-3 py-2 border-b border-gray-700">Total</td>

            <td class="px-3 py-2 border-b border-gray-700">15427</td>

            <td class="px-3 py-2 border-b border-gray-700">19523</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  Enforce validity of: |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Serial number nonce</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5417</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9513</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Other:</td>

            <td class="px-3 py-2 border-b border-gray-700">Enforce validity of:</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Predicate commitment</td>

            <td class="px-3 py-2 border-b border-gray-700">21792 · [3/4(m+n)+1/2]</td>

            <td class="px-3 py-2 border-b border-gray-700">21792 · [3/4(m+n)+1/2]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Local data commitment</td>

            <td class="px-3 py-2 border-b border-gray-700">7168 · m+6144 · n</td>

            <td class="px-3 py-2 border-b border-gray-700">8192 · m+6144 · n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Miscellaneous</td>

            <td class="px-3 py-2 border-b border-gray-700">7368</td>

            <td class="px-3 py-2 border-b border-gray-700">8651</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: Number of constraints for  <span class="math">{\\mathcal{R}}_{\\mathrm{{BLS}}}</span>  .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Plain DPC</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Delegable DPC</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Total with 2 inputs and 2 outputs</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">439224</td>

            <td class="px-3 py-2 border-b border-gray-700">439476</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Below we provide a breakdown of the number of constraints with m input and n output records.  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Per input record</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Total</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">87569</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">87569</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  Enforce validity of: |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Death predicate ver. key</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">45827</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">45827</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Per output record</td>

            <td class="px-3 py-2 border-b border-gray-700">Total</td>

            <td class="px-3 py-2 border-b border-gray-700">87569</td>

            <td class="px-3 py-2 border-b border-gray-700">87569</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  Enforce validity of: |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Birth predicate ver. key</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">45827</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">45827</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Other</td>

            <td class="px-3 py-2 border-b border-gray-700">Enforce validity of:</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Predicate commitment</td>

            <td class="px-3 py-2 border-b border-gray-700">21792 · [3/4(m+n)+1/2]</td>

            <td class="px-3 py-2 border-b border-gray-700">21792 · [3/4(m+n)+1/2]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Miscellaneous</td>

            <td class="px-3 py-2 border-b border-gray-700">1780</td>

            <td class="px-3 py-2 border-b border-gray-700">2032</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Number of constraints for  <span class="math">{\\mathcal{R}}_{\\mathrm{{CP}}}</span>  .</p>

    <p class="text-gray-300">9.5 Applications</p>

    <p class="text-gray-300">We do not report total costs for producing transactions for the applications in Section 6 because the additional application-specific costs are negligible compared to the base cost reported in Table 1. This is because all application-specific proofs are produced over the efficient elliptic curve <span class="math">E_{\\text{BLS}}</span>, and moreover, for each application we consider, the heaviest computation checked by these proofs is the relatively lightweight one of opening the local data commitment; the remaining costs consist of a few cheap range and equality checks. Indeed, with two input and two output records, these applications require fewer than <span class="math">35,000</span> constraints (compared to over <span class="math">350,000</span> for <span class="math">\\mathcal{R}_{\\text{BLS}}</span> and <span class="math">\\mathcal{R}_{\\text{CP}}</span>), and producing the corresponding proofs takes tens of milliseconds (compared to tens of seconds for the base cost of DPC.Execute).</p>

    <p class="text-gray-300">We prove that our DPC construction (see Section 4) satisfies the security definition in Section 3.3. To do this, for every real-world (efficient) adversary  <span class="math">\\mathcal{A}</span> , we construct an ideal-world (efficient) simulator  <span class="math">S</span>  such that the ideal-world and real-world executions are computationally indistinguishable with respect to any (efficient) environment  <span class="math">\\mathcal{E}</span> . We proceed in three parts: in Appendix A.1 we describe building blocks used to construct the simulator  <span class="math">S</span> ; in Appendix A.2 we describe the simulator  <span class="math">S</span> ; in Appendix A.3 we argue that the ideal-world and the real-world executions are computationally indistinguishable.</p>

    <p class="text-gray-300">We describe various algorithms that are used as sub-routines in the simulator  <span class="math">S</span> .</p>

    <p class="text-gray-300">Trapdoor commitments. Recall from Section 4.1 that a trapdoor commitment scheme is a commitment scheme with auxiliary algorithms (SimSetup, Equivocate) that enable one to open a commitment cm to any chosen message. Below we restrict cm to be a commitment to the empty string  <span class="math">\\varepsilon</span>  because this is sufficient for the proof of security of our DPC scheme.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Trapdoor setup: on input a security parameter, TCM.SimSetup samples public parameters  <span class="math">\\mathsf{pp}_{\\mathsf{TCM}}</span>  and a trapdoor  <span class="math">\\mathsf{td}_{\\mathsf{TCM}}</span>  such that  <span class="math">\\mathsf{pp}_{\\mathsf{TCM}}</span>  is indistinguishable from public parameters sampled by TCM.Setup.</li>

      <li>Equivocation: on input public parameters  <span class="math">\\mathsf{pp}_{\\mathsf{TCM}}</span> , trapdoor  <span class="math">\\mathsf{td}_{\\mathsf{TCM}}</span> , commitment  <span class="math">\\mathsf{cm}</span>  to  <span class="math">\\varepsilon</span> , corresponding commitment randomness  <span class="math">r_{\\mathsf{cm}}</span>  (so that TCM.Commit  <span class="math">(\\mathsf{pp}_{\\mathsf{TCM}}, \\varepsilon; r_{\\mathsf{cm}}) = \\mathsf{cm}</span> ), and target message  <span class="math">m&#x27;</span> , TCM.Equivocate outputs commitment randomness  <span class="math">r_{\\mathsf{cm}}&#x27;</span>  such that TCM.Commit  <span class="math">(\\mathsf{pp}_{\\mathsf{TCM}}, m&#x27;; r_{\\mathsf{cm}}&#x27;) = \\mathsf{cm}</span> . Moreover, if  <span class="math">r_{\\mathsf{cm}}</span>  is uniformly random then  <span class="math">r_{\\mathsf{cm}}&#x27;</span>  is statistically close to uniformly random.</li>

    </ul>

    <p class="text-gray-300">In Figure 19 we instantiate these algorithms for the Pedersen commitment scheme. Note that the real and simulated public parameters are identical; moreover, the trapdoor randomness  <span class="math">r_{\\mathrm{cm}}^{\\prime}</span>  is the real randomness  <span class="math">r_{\\mathrm{cm}}</span>  shifted by uniformly random field elements, and is hence statistically close to  <span class="math">r_{\\mathrm{cm}}</span> .</p>

    <p class="text-gray-300">TCM.SimSetup  <span class="math">(1^{\\lambda},n)\\to (\\mathsf{pp}_{\\mathsf{TCM}},\\mathsf{td}_{\\mathsf{TCM}})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample a group:  <span class="math">(\\mathbb{G},q,g)\\gets \\mathrm{SampleGrp}(1^{\\lambda})</span></li>

      <li>For  <span class="math">i\\in \\{1,\\dots ,n\\}</span>  sample  <span class="math">r_i</span>  uniformly from  <span class="math">\\mathbb{Z}_q</span>  , and set  <span class="math">h_i\\coloneqq g^{r_i}</span></li>

      <li>Output  <span class="math">(\\mathsf{pp}_{\\mathsf{TCM}}\\coloneqq (\\mathbb{G},q,g,[h_i]_1^n),\\mathsf{td}_{\\mathsf{TCM}}\\coloneqq [r_i]_1^n)</span></li>

    </ol>

    <p class="text-gray-300">TCM.Equivocate  <span class="math">(\\mathsf{pp}_{\\mathsf{TCM}},\\mathsf{td}_{\\mathsf{TCM}},\\mathsf{cm},r_{\\mathsf{cm}},m^{\\prime}\\in \\{0,1\\}^{n})\\to r_{\\mathsf{cm}}^{\\prime}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\mathsf{pp}_{\\mathsf{TCM}}</span>  as  <span class="math">(\\mathbb{G},q,g,[h_i]_1^n)</span></li>

      <li>Parse  <span class="math">\\mathsf{td}_{\\mathsf{TCM}}</span>  as  <span class="math">[r_i]_1^n</span></li>

      <li>Output  <span class="math">r_{\\mathrm{cm}}^{\\prime} \\coloneqq r_{\\mathrm{cm}} - \\sum_{i=1}^{n} r_i m_i&#x27; \\mod q</span> .</li>

    </ol>

    <p class="text-gray-300">Figure 19: Simulated setup and equivocation algorithms for the Pedersen commitment scheme.</p>

    <p class="text-gray-300">NIZKs. The scheme NIZK = (Setup, Prove, Verify) is a simulation-extractable non-interactive zero knowledge argument. Formally stating the properties of this scheme involves several auxiliary algorithms.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Trapdoor setup: on input a security parameter and a description of an NP relation  <span class="math">\\mathcal{R}</span> , NIZK.SimSetup outputs a set of public parameters  <span class="math">\\mathsf{pp}_{\\mathsf{NIZK}}</span>  and a trapdoor  <span class="math">\\mathsf{td}_{\\mathsf{NIZK}}</span> .</li>

      <li>Simulation: on input public parameters  <span class="math">\\mathsf{pp}_{\\mathsf{NIZK}}</span> , trapdoor  <span class="math">\\mathsf{td}_{\\mathsf{NIZK}}</span> , NP instance  <span class="math">\\mathbf{x}</span> , and (optionally) auxiliary information aux, NIZK.Simulate outputs a simulated proof  <span class="math">\\pi</span> .</li>

      <li>Extraction: on input public parameters  <span class="math">\\mathsf{pp}_{\\mathsf{NIZK}}</span> , trapdoor  <span class="math">\\mathsf{td}_{\\mathsf{NIZK}}</span> , NP instance  <span class="math">\\mathbf{x}</span> , and proof  <span class="math">\\pi</span> , NIZK.Extract outputs a witness  <span class="math">\\mathbf{w}</span>  such that  <span class="math">(\\mathbf{x},\\mathbf{w}) \\in \\mathcal{R}</span>  (allegedly).</li>

    </ul>

    <p class="text-gray-300">We can now state the properties satisfied by NIZK.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: for every NP relation  <span class="math">\\mathcal{R}</span>  and instance-witness pair  <span class="math">(\\mathbf{x},\\mathbf{w})\\in \\mathcal{R}</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\text {N I Z K . V e r i f y} (\\mathsf {p p} _ {\\mathsf {N I Z K}}, \\mathbf {x}, \\pi) = 1 &amp;amp; \\begin{array}{c} \\mathsf {p p} _ {\\mathsf {N I Z K}} \\leftarrow \\text {N I Z K . S e t u p} (1 ^ {\\lambda}, \\mathcal {R}) \\\\ (\\mathbf {x}, \\pi) \\leftarrow \\text {N I Z K . P r o v e} (\\mathsf {p p} _ {\\mathsf {N I Z K}}, \\mathbf {x}, \\mathbf {w}) \\end{array} \\end{array} \\right] = 1.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Perfect zero knowledge: for every relation <span class="math">\\mathcal{R}</span> and efficient adversary <span class="math">\\mathcal{A}</span>,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l} \\mathsf{pp}_{\\mathsf{NIZK}} \\leftarrow \\mathsf{NIZK.Setup}(1^{\\lambda}, \\mathcal{R}) \\\\ \\mathcal{A}^{S_1(\\cdot, \\cdot)}(\\mathsf{pp}_{\\mathsf{NIZK}}, \\mathsf{aux}) = 1 \\end{array} \\right] = \\Pr \\left[ \\begin{array}{l} (\\mathsf{pp}_{\\mathsf{NIZK}}, \\mathsf{td}_{\\mathsf{NIZK}}) \\leftarrow \\mathsf{NIZK.SimSetup}(1^{\\lambda}, \\mathcal{R}) \\\\ \\mathcal{A}^{S_2(\\cdot, \\cdot)}(\\mathsf{pp}_{\\mathsf{NIZK}}, \\mathsf{aux}) = 1 \\end{array} \\right]</span></div>

    <p class="text-gray-300">where the two oracles are defined as follows</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">S_{1}(\\pi, \\mathrm{w}) := \\text{&quot;if } (\\pi, \\mathrm{w}) \\in \\mathcal{R} \\text{ then } \\mathsf{NIZK.Prove}(\\mathsf{pp}_{\\mathsf{NIZK}}, \\pi, \\mathrm{w})</span>, else abort";</li>

      <li><span class="math">S_{2}(\\pi, \\mathrm{w}) := \\text{&quot;if } (\\pi, \\mathrm{w}) \\in \\mathcal{R} \\text{ then } \\mathsf{NIZK.Simulate}(\\mathsf{pp}_{\\mathsf{NIZK}}, \\mathsf{td}_{\\mathsf{NIZK}}, \\pi)</span>, else abort".</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulation extractability: for every relation <span class="math">\\mathcal{R}</span> and efficient adversary <span class="math">\\mathcal{A}</span>,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{l} (\\pi, \\pi) \\notin Q \\\\ (\\pi, \\mathrm{w}) \\notin \\mathcal{R} \\\\ \\mathsf{NIZK.Verify}(\\mathsf{pp}_{\\mathsf{NIZK}}, \\pi, \\pi) = 1 \\end{array} \\right] \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\mathsf{pp}_{\\mathsf{NIZK}}, \\mathsf{td}_{\\mathsf{NIZK}}) \\leftarrow \\mathsf{NIZK.SimSetup}(1^{\\lambda}, \\mathcal{R}) \\\\ (\\pi, \\pi) \\leftarrow \\mathcal{A}^{S(\\cdot)}(\\mathsf{pp}_{\\mathsf{NIZK}}) \\\\ \\mathrm{w} \\leftarrow \\mathsf{NIZK.Extract}(\\mathsf{pp}_{\\mathsf{NIZK}}, \\mathsf{td}_{\\mathsf{NIZK}}, \\pi) \\end{array} \\right] = \\operatorname{negl}(\\lambda),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">S(\\pi) := \\mathsf{NIZK.Simulate}(\\mathsf{pp}_{\\mathsf{NIZK}}, \\mathsf{td}_{\\mathsf{NIZK}}, \\pi)</span> and <span class="math">Q</span> is the set of query-answer pairs between the adversary <span class="math">\\mathcal{A}</span> and the simulated-proof oracle <span class="math">S</span>.</p>

    <h2 id="sec-57" class="text-2xl font-bold">A.2 The ideal-world simulator</h2>

    <p class="text-gray-300">The ideal-word simulator <span class="math">\\mathcal{S}</span> will interact with the ideal functionality <span class="math">\\mathcal{F}_{\\mathrm{DPC}}</span> and with the environment <span class="math">\\mathcal{E}</span>. Note that for UC security it suffices to show security against a dummy real-world adversary <span class="math">\\mathcal{A}</span> that simply forwards all instructions from the environment <span class="math">\\mathcal{E}</span> [Can01]. Since our security definition is a special case of UC security, we inherit this simplification, and thus only consider such an adversary <span class="math">\\mathcal{A}</span>. The pseudocode for <span class="math">\\mathcal{S}</span> is provided below; auxiliary subroutines are provided in Figure 20.</p>

    <h3 id="sec-58" class="text-xl font-semibold mt-8">Setup.</h3>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize an empty table <span class="math">\\mathcal{S}</span>. Records that maps record commitments to their contents.</li>

      <li>Initialize an empty table <span class="math">\\mathcal{S}</span>. AddrPk that maps address public keys to their secret keys.</li>

      <li>Initialize an empty transaction ledger <span class="math">\\mathbf{L}</span>.</li>

      <li>Sample simulated public parameters and trapdoor: <span class="math">(\\mathsf{pp}, \\mathsf{td}) \\leftarrow \\mathsf{DPC.SimSetup}(1^{\\lambda})</span>. (See Fig. 20.)</li>

      <li>Define</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\text{SampleAddrPk}(\\cdot) := \\mathsf{CM.Commit}(\\mathsf{pp}_{\\mathsf{CM}}, \\varepsilon; \\cdot), \\\\ \\text{SampleCm}(\\cdot) := \\mathsf{TCM.Commit}(\\mathsf{pp}_{\\mathsf{TCM}}, \\varepsilon; \\cdot), \\\\ \\text{SampleSn}(\\cdot) := \\text{&quot;sample uniformly random string of correct length&quot;}. \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Start ideal-world execution with the above (SampleAddrPk, SampleCm, SampleSn).</li>

    </ol>

    <p class="text-gray-300">At this point, the simulator will receive messages notifying it of transactions and of messages sharing contents of newly-created records. The simulator handles each case separately.</p>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">Transaction notifications.</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>From environment. When <span class="math">\\mathcal{E}</span> instructs a corrupted party to invoke <span class="math">\\mathbf{L}</span>. Push(tx):</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If DPC.Verify<span class="math">^{\\mathbf{L}}</span>(<span class="math">\\mathsf{pp}</span>, tx) <span class="math">\\neq 1</span>, abort.</li>

      <li>Parse the real-world transaction tx as <span class="math">([\\mathsf{sn}_i]_1^m, [\\mathsf{cm}_j]_1^n, \\mathsf{memo}, \\star)</span>.</li>

      <li>Compute <span class="math">([\\mathbf{r}_i]_1^m, [\\mathsf{ask}_i]_1^m, [\\mathbf{r}_j]_1^n, \\mathsf{aux}) \\leftarrow \\mathsf{DPC.ExtractExecute}(\\mathsf{pp}, \\mathsf{td}, \\mathsf{tx})</span>. [See Figure 20.]</li>

      <li>For every <span class="math">i \\in \\{1, \\ldots, m\\}</span>:</li>

    </ol>

    <p class="text-gray-300">50</p>

    <p class="text-gray-300">(a) Parse the real-world record <span class="math">\\mathbf{r}_i</span> as <span class="math">(\\mathsf{apk}_i, \\mathsf{payload}_i, \\Phi_{\\mathsf{b}, i}, \\Phi_{\\mathsf{d}, i}, \\rho_i, r_i, \\mathsf{cm}_i)</span>.</p>

    <p class="text-gray-300">(b) Parse the address secret key <span class="math">\\mathsf{ask}_i</span> as <span class="math">(\\mathsf{sk}_{\\mathsf{PRF},i},r_{\\mathsf{pk},i})</span>.</p>

    <p class="text-gray-300">(c) If <span class="math">S.Records[cm_i] \\neq \\mathbf{r}_i</span>, abort. (Note: Captures binding property of the commitment.)</p>

    <p class="text-gray-300">(d) If L.Contains(<span class="math">\\mathsf{cm}_i</span>) = 0, abort. (Note: Captures existence of record.)</p>

    <p class="text-gray-300">(e) Create the ideal-world record <span class="math">\\mathbb{r}_i := (\\mathsf{cm}_i, \\mathsf{apk}_i, \\mathsf{payload}_i, \\Phi_{\\mathsf{b}, i}, \\Phi_{\\mathsf{d}, i})</span>.</p>

    <p class="text-gray-300">(f) If <span class="math">S.AddrPk[\\mathsf{apk}_i] = \\bot</span>: i. Invoke <span class="math">\\mathcal{F}_{\\mathrm{DPC}}</span>. GenAddress(<span class="math">\\mathsf{apk}_i</span>). ii. Insert <span class="math">\\mathsf{apk}_i</span> into <span class="math">S.AddrPk</span>: <span class="math">S.AddrPk[\\mathsf{apk}_i] := \\mathsf{ask}_i</span>.</p>

    <p class="text-gray-300">(g) Else, if <span class="math">S.AddrPk[\\mathsf{apk}_i] \\neq \\mathsf{ask}_i</span>, abort. (Note: Captures uniqueness of secret key.)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">j \\in \\{1, \\ldots, n\\}</span>:</li>

    </ol>

    <p class="text-gray-300">(a) Parse the real-world record <span class="math">\\mathbf{r}_j</span> as <span class="math">(\\mathsf{apk}_j, \\mathsf{payload}_j, \\Phi_{\\mathsf{b}, j}, \\Phi_{\\mathsf{d}, j}, \\rho_j, r_j, \\mathsf{cm}_j)</span>.</p>

    <p class="text-gray-300">(b) If the serial number nonce <span class="math">\\rho_j</span> was seen in a prior extracted transaction, or if <span class="math">\\rho_j = \\rho_k</span> for <span class="math">k \\neq j</span>, abort. (Note: Captures uniqueness of nonce.)</p>

    <p class="text-gray-300">(c) Set <span class="math">S.Records[cm_j] := \\mathbf{r}_j</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Construct instance for <span class="math">\\mathcal{R}_{\\mathrm{e}}</span>: <span class="math">\\mathbb{x}_{\\mathrm{e}} := (\\mathsf{st}_{\\mathbf{L}}, [\\mathsf{sn}_i]_1^m, [\\mathsf{cm}_j]_1^n, \\mathsf{memo})</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Construct witness for <span class="math">\\mathcal{R}_{\\mathrm{e}}</span>: <span class="math">\\mathbb{w}_{\\mathrm{e}} := ([\\mathbf{r}_i]_1^m, [\\mathbb{w}_{\\mathbf{L},i}]_1^m, [\\mathsf{ask}_i]_1^m, [\\mathbf{r}_j]_1^n, \\mathsf{aux})</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">(\\mathbb{x}_{\\mathrm{e}}, \\mathbb{w}_{\\mathrm{e}}) \\notin \\mathcal{R}_{\\mathrm{e}}</span>, abort.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Invoke <span class="math">\\mathcal{F}_{\\mathrm{DPC}}</span>. Execute <span class="math">([\\mathbb{r}_i]_1^m, [\\mathsf{meta}_i]_1^m, [\\mathsf{sn}_i]_1^m, [\\mathsf{cm}_j]_1^n, [\\mathsf{apk}_j]_1^n, [\\mathsf{payload}_j]_1^n, [\\Phi_{\\mathsf{b}, j}]_1^n, [\\Phi_{\\mathsf{d}, j}]_1^n, \\mathsf{aux}, \\mathsf{memo})</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Receive from <span class="math">\\mathcal{F}_{\\mathrm{DPC}}</span>: <span class="math">[\\mathbf{r}_j]_1^n</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Receive from <span class="math">\\mathcal{F}_{\\mathrm{DPC}}</span>: (Execute, <span class="math">[\\mathsf{sn}_i]_1^m, [\\mathsf{cm}_j]_1^n, \\mathsf{memo})</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Append the real-world transaction tx to the ledger L.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>From ideal functionality. When <span class="math">\\mathcal{F}_{\\mathrm{DPC}}</span> broadcasts (Execute, <span class="math">[\\mathsf{sn}_i]_1^m, [\\mathsf{cm}_j]_1^n, \\mathsf{memo})</span>:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">([\\mathbf{r}_j]_1^n, \\mathbf{tx}) \\leftarrow \\text{DPC.SimExecute}^L(\\mathsf{pp}, \\mathsf{td}, [\\mathsf{sn}_i]_1^m, [\\mathsf{cm}_j]_1^n, \\mathsf{memo})</span>. (See Fig. 20.)</li>

      <li>For each <span class="math">j \\in \\{1, \\ldots, n\\}</span>, set <span class="math">S.Records[cm_j] := \\mathbf{r}_j</span>.</li>

      <li>Append the real-world transaction tx to the ledger L.</li>

    </ol>

    <h2 id="sec-60" class="text-2xl font-bold">Record authorization notification.</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>From environment. When <span class="math">\\mathcal{E}</span> instructs a corrupted party to send (RecordAuth, <span class="math">\\mathbf{r}</span>, <span class="math">\\mathcal{P}</span>) to <span class="math">\\mathcal{P}</span>:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse the real-world record <span class="math">\\mathbf{r}</span> as <span class="math">(\\mathsf{apk}, \\mathsf{payload}, \\Phi_{\\mathsf{b}}, \\Phi_{\\mathsf{d}}, \\rho, r, \\mathsf{cm})</span>.</li>

      <li>Invoke <span class="math">\\mathcal{F}_{\\mathrm{DPC}}</span>. ShareRecord(<span class="math">\\mathbb{r}</span>, <span class="math">\\mathcal{P}</span>) with <span class="math">\\mathbb{r} := (\\mathsf{cm}, \\mathsf{apk}, \\mathsf{payload}, \\Phi_{\\mathsf{b}}, \\Phi_{\\mathsf{d}})</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>From ideal functionality. When <span class="math">\\mathcal{F}_{\\mathrm{DPC}}</span> sends (RecordAuth, <span class="math">\\mathbb{r}</span>, <span class="math">r</span>):</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse the ideal record <span class="math">\\mathbb{r}</span> as <span class="math">(\\mathsf{cm}, \\mathsf{apk}, \\mathsf{payload}, \\Phi_{\\mathsf{b}}, \\Phi_{\\mathsf{d}})</span>.</li>

      <li>Retrieve the real-world record <span class="math">\\mathbf{r} = S.Records[cm]</span>, and set the serial number nonce <span class="math">\\rho := \\mathbf{r} \\cdot \\rho</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Define new record commitment message $m := (\\mathsf{apk} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{payload} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_{\\mathsf{b}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_{\\mathsf{d}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute new commitment randomness <span class="math">r&#x27; \\gets \\mathsf{TCM.Equivocate}(\\mathsf{pp}_{\\mathsf{TCM}}, \\mathsf{td}_{\\mathsf{TCM}}, \\mathsf{cm}, r, m)</span>.</li>

      <li>Construct the new real-world record <span class="math">\\mathbf{r}&#x27; := (\\mathsf{apk}, \\mathsf{payload}, \\Phi_{\\mathsf{b}}, \\Phi_{\\mathsf{d}}, \\rho, r&#x27;, \\mathsf{cm})</span>.</li>

      <li>Set <span class="math">S.Records[cm] := \\mathbf{r}&#x27;</span>.</li>

      <li>Send to <span class="math">\\mathcal{A}</span>: (RecordAuth, <span class="math">\\mathbf{r}&#x27;</span>).</li>

    </ol>

    <p class="text-gray-300">51</p>

    <p class="text-gray-300">!<a href="img-12.jpeg">img-12.jpeg</a> Figure 20: Several subroutines used by the ideal-world simulator  <span class="math">S</span> .</p>

    <p class="text-gray-300">A.3 Proof of security by hybrid argument</p>

    <p class="text-gray-300">We use a sequence of hybrids, each identified by a game <span class="math">\\mathcal{G}_{i}</span>, to prove that the outputs of the environment <span class="math">\\mathcal{E}</span> when interacting with the real-world (dummy) adversary <span class="math">\\mathcal{A}</span> and the ideal-world simulator <span class="math">\\mathcal{S}</span> are computationally indistinguishable. We denote by <span class="math">\\textsc{Output}_{i}(\\mathcal{E})</span> the output of <span class="math">\\mathcal{E}</span> in game <span class="math">\\mathcal{G}_{i}</span>, and by <span class="math">\\mathcal{G}_{0}</span> the real-world execution.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}_{1}</span> (sample parameters):</li>

    </ul>

    <p class="text-gray-300">This game is the real-world execution modified as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{E}</span> interacts with <span class="math">\\mathcal{S}</span> instead of <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathcal{S}</span> uses DPC.Setup to generate public parameters pp, and gives these to <span class="math">\\mathcal{E}</span>.</li>

      <li><span class="math">\\mathcal{S}</span> maintains the ledger <span class="math">\\mathbf{L}</span> for <span class="math">\\mathcal{E}</span> (it appends to <span class="math">\\mathbf{L}</span> any pushed transaction passing the checks in DPC.Verify).</li>

      <li><span class="math">\\mathcal{S}</span> forwards messages from <span class="math">\\mathcal{E}</span> to <span class="math">\\mathbf{L}</span> and other parties.</li>

      <li><span class="math">\\mathcal{S}</span> forwards messages from other honest parties to <span class="math">\\mathcal{E}</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\textsc{Output}_{1}(\\mathcal{E})</span> is perfectly indistinguishable from <span class="math">\\textsc{Output}_{0}(\\mathcal{E})</span> since <span class="math">\\mathcal{S}</span> samples the public parameters honestly, maintains the ledger identically to the ideal ledger, and otherwise behaves like the dummy adversary.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}_{2}</span> (simulate setup):</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{S}</span> invokes DPC.SimSetup instead of DPC.Setup. <span class="math">\\textsc{Output}_{2}(\\mathcal{E})</span> is perfectly indistinguishable from <span class="math">\\textsc{Output}_{1}(\\mathcal{E})</span> since NIZK is perfect zero knowledge.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}_{3}</span> (simulate proofs):</li>

    </ul>

    <p class="text-gray-300">In all honest party transactions, <span class="math">\\mathcal{S}</span> replaces NIZK proofs with simulated proofs produced via NIZK.Simulate. <span class="math">\\textsc{Output}_{3}(\\mathcal{E})</span> is perfectly indistinguishable from <span class="math">\\textsc{Output}_{2}(\\mathcal{E})</span> since NIZK is perfect zero knowledge.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}_{4}</span> (simulate serial numbers):</li>

    </ul>

    <p class="text-gray-300">In all honest party transactions, <span class="math">\\mathcal{S}</span> replaces all serial numbers with uniformly random elements sampled from PRF’s codomain. Since PRF is a pseudorandom function, and <span class="math">\\mathcal{E}</span> does not know the secret key used to compute it, <span class="math">\\textsc{Output}_{4}(\\mathcal{E})</span> is computationally indistinguishable from <span class="math">\\textsc{Output}_{3}(\\mathcal{E})</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}_{5}</span> (simulate commitments and equivocate commitment openings):</li>

    </ul>

    <p class="text-gray-300">In all honest party transactions, <span class="math">\\mathcal{S}</span> replaces record commitments with commitments to the empty string <span class="math">\\varepsilon</span>. In all messages from honest parties to corrupted parties containing record contents, <span class="math">\\mathcal{S}</span> replaces the actual commitment randomness with randomness produced by TCM.Equivocate. <span class="math">\\textsc{Output}_{5}(\\mathcal{E})</span> is perfectly indistinguishable from <span class="math">\\textsc{Output}_{4}(\\mathcal{E})</span> since TCM is perfectly hiding and equivocation produces commitment randomness that is statistically close to uniform.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}_{6}</span> (handle adversarial transactions):</li>

    </ul>

    <p class="text-gray-300">For every corrupted party transaction, <span class="math">\\mathcal{S}</span> extracts an NP instance <span class="math">\\mathbf{x_{e}}</span> and witness <span class="math">\\mathbf{w_{e}}</span> for <span class="math">\\mathcal{R_{e}}</span> from the included proof and then proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">(\\mathbf{x_{e}},\\mathbf{w_{e}})\\not\\in\\mathcal{R}</span>, <span class="math">\\mathcal{S}</span> aborts. If NIZK is simulation-extractable, this occurs with negligible probability.</li>

      <li>For all <span class="math">i\\in\\{1,\\ldots,m\\}</span>, if the contents of any <span class="math">\\mathbf{r}_{i}</span> are different from those seen in any RecordAuth from an honest party or in the output of a previously extracted transaction, <span class="math">\\mathcal{S}</span> aborts. If TCM is a binding commitment scheme, then this occurs with negligible probability.</li>

      <li>For all <span class="math">i\\in\\{1,\\ldots,m\\}</span>, if the extracted secret key <span class="math">\\mathsf{ask}_{i}</span> for <span class="math">\\mathsf{apk}_{i}</span> differs from the secret key extracted for <span class="math">\\mathsf{apk}_{i}</span> in a prior transaction, <span class="math">\\mathcal{S}</span> aborts. If CM is a binding commitment scheme, then this occurs with negligible probability.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all <span class="math">j\\in\\{1,\\ldots,n\\}</span>, if the serial number nonce <span class="math">\\rho_{j}</span> matches one extracted in a prior transaction, <span class="math">\\mathcal{S}</span> aborts. If <span class="math">\\mathsf{CRH}</span> is a collision-resistant hash, then this occurs with negligible probability because the serial number nonce is the output of <span class="math">\\mathsf{CRH}</span> evaluated (in part) over the serial numbers of the input records. If this input is distinct across two different invocations of <span class="math">\\mathsf{CRH}</span>, then collision resistance guarantees that a nonce collision happens with negligible probability. Now for the transaction to be valid, it must contain serial numbers not seen before on the ledger. Therefore, the inputs to <span class="math">\\mathsf{CRH}</span> are never repeated.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{Output}_{6}(\\mathcal{E})</span> is therefore computationally indistinguishable from <span class="math">\\mathsf{Output}_{5}(\\mathcal{E})</span>.</p>

    <p class="text-gray-300">The final game is distributed identically to the operation of <span class="math">\\mathcal{S}</span> from the point of view of <span class="math">\\mathcal{E}</span>. We have thus shown that <span class="math">\\mathcal{E}</span>’s advantage in distinguishing the interaction with <span class="math">\\mathcal{S}</span> from the interaction with <span class="math">\\mathcal{A}</span> is negligible.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">We provide more details on the delegable DPC scheme discussed in Section 5. First we give details on randomizable signatures (Appendix B.1), and then give pseudocode for the DPC construction (Appendix B.2).</p>

    <p class="text-gray-300">A randomizable signature scheme is a tuple of algorithms  <span class="math">\\mathrm{SIG} = (\\mathrm{Setup},\\mathrm{Keygen},\\mathrm{Sign},\\mathrm{Verify},\\mathrm{RandPk},</span>  RandSig) that enables a party to sign messages, while also allowing randomization of public keys and signatures to prevent linking across multiple signatures.</p>

    <p class="text-gray-300">We have already described the syntax of the scheme's algorithms, and summarized its security properties, in Section 5.2. Now we discuss in more detail the security properties, and the construction used in our code.</p>

    <p class="text-gray-300">Security properties. The signature scheme SIG satisfies the following security properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Existential unforgeability under randomization (EUR). For every efficient adversary  <span class="math">\\mathcal{A}</span> , the following probability is negligible:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l l} \\left(m ^ {*} \\notin Q \\text {a n d S I G . V e r i f y} (\\mathsf {p p} _ {\\mathsf {S I G}}, \\mathsf {p k} _ {\\mathsf {S I G}}, m ^ {*}, \\sigma^ {*})\\right) &amp;amp; \\mathsf {p p} _ {\\mathsf {S I G}} \\leftarrow \\mathsf {S I G . S e t u p} (1 ^ {\\lambda}) \\\\ \\text {o r} &amp;amp; (\\mathsf {p k} _ {\\mathsf {S I G}}, \\mathsf {s k} _ {\\mathsf {S I G}}) \\leftarrow \\mathsf {S I G . K e y g e n} (\\mathsf {p p} _ {\\mathsf {S I G}}) \\\\ \\left(m ^ {*} \\notin Q \\text {a n d S I G . V e r i f y} (\\mathsf {p p} _ {\\mathsf {S I G}}, \\hat {\\mathsf {p k}} _ {\\mathsf {S I G}}, m ^ {*}, \\sigma^ {*})\\right) &amp;amp; \\left(m ^ {*}, \\sigma^ {*}, r _ {\\mathsf {S I G}} ^ {*}\\right) \\leftarrow \\mathcal {A} ^ {S (\\cdot)} (\\mathsf {p p} _ {\\mathsf {S I G}}, \\mathsf {p k} _ {\\mathsf {S I G}}) \\\\ &amp;amp; \\hat {\\mathsf {p k}} _ {\\mathsf {S I G}} \\leftarrow \\mathsf {S I G . R a n d P k} (\\mathsf {p p} _ {\\mathsf {S I G}}, \\mathsf {p k} _ {\\mathsf {S I G}}, r _ {\\mathsf {S I G}} ^ {*}) \\end{array} \\right]</span></div>

    <p class="text-gray-300">where  <span class="math">S(m) \\coloneqq \\mathrm{SIG.Sign}(\\mathsf{pp}_{\\mathrm{SIG}}, \\mathsf{sk}_{\\mathrm{SIG}}, m)</span>  and  <span class="math">Q</span>  are the queries made by  <span class="math">\\mathcal{A}</span>  to the signing oracle  <span class="math">S</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Unlinkability. Every efficient adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span>  has at most negligible advantage in guessing the bit  <span class="math">b</span>  in the IND-RSIG game below.</li>

    </ul>

    <p class="text-gray-300">|  IND-RSIGA(SIG)(1λ):  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  1. Generate public parameters: ppSIG← SIG.Setup(1λ).  |   |</p>

    <p class="text-gray-300">|  2. Generate key pair: (pkSIG, skSIG)← SIG.Keygen(ppSIG).  |   |</p>

    <p class="text-gray-300">|  3. Obtain message from adversary: m← A1SIG.Sign(ppSIG, skSIG, ·) (ppSIG, pkSIG).  |   |</p>

    <p class="text-gray-300">|  4. Sample a bit b uniformly at random.  |   |</p>

    <p class="text-gray-300">|  5. If b = 0: (a) Sample new key pair: (pk'SIG, sk'SIG)← SIG.Keygen(ppSIG). (b) Sign message: σ← SIG.Sign(ppSIG, sk'SIG, m). (c) Set c := (pk'SIG, σ).  |   |</p>

    <p class="text-gray-300">|  6. If b = 1: (a) Sign message: σ← SIG.Sign(ppSIG, skSIG, m). (b) Sample randomness rsIG. (c) Randomize public key: pkSIG← SIG.RandPk(ppSIG, pkSIG, rsIG). (d) Randomize signature: σ← SIG.RandSig(ppSIG, σ, rsIG). (e) Set c := (pkSIG, σ).  |   |</p>

    <p class="text-gray-300">|  7. Output A2SIG.Sign(ppSIG, skSIG, ·) (ppSIG, pkSIG, c).  |   |</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Injective randomization. For every efficient adversary  <span class="math">\\mathcal{A}</span> , the following probability is negligible:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} r _ {1} \\neq r _ {2} &amp;amp; \\mathsf {p p} _ {\\mathsf {S I G}} \\leftarrow \\mathsf {S I G . S e t u p} (1 ^ {\\lambda}) \\\\ \\mathsf {S I G . R a n d P k} (\\mathsf {p p} _ {\\mathsf {S I G}}, \\mathsf {p k} _ {\\mathsf {S I G}}, r _ {1}) = \\mathsf {S I G . R a n d P k} (\\mathsf {p p} _ {\\mathsf {S I G}}, \\mathsf {p k} _ {\\mathsf {S I G}}, r _ {2}) &amp;amp; (\\mathsf {p k} _ {\\mathsf {S I G}}, r _ {1}, r _ {2}) \\leftarrow \\mathcal {A} (\\mathsf {p p} _ {\\mathsf {S I G}}) \\end{array} \\right]</span></div>

    <p class="text-gray-300">Construction. In Fig. 21 we provide a modification of the Schnorr signature scheme [Sch91] that is randomizable. We briefly explain why this modification satisfies the security properties above.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Existential unforgeability under randomization (EUR). Given an efficient adversary  <span class="math">\\mathcal{A}</span>  that breaks EUR of randomizable Schnorr signatures, we construct an efficient adversary  <span class="math">\\mathcal{A}&#x27;</span>  that breaks existential unforgeability of standard Schnorr signatures. In detail,  <span class="math">\\mathcal{A}&#x27;</span>  forwards signature queries from  <span class="math">\\mathcal{A}</span>  to its own signing oracle and returns the answers to  <span class="math">\\mathcal{A}</span>  and then, when  <span class="math">\\mathcal{A}</span>  outputs a tuple  <span class="math">(m^{<em>},\\sigma^{</em>},r_{\\mathrm{SIG}}^{<em>})</span> ,  <span class="math">\\mathcal{A}&#x27;</span>  outputs the tuple  <span class="math">(m^{</em>},\\sigma)</span>  where  <span class="math">\\sigma</span>  is computed as follows. If  <span class="math">\\sigma^{<em>}</span>  is a valid signature for  <span class="math">m^{</em>}</span>  under  <span class="math">\\mathsf{pk}_{\\mathrm{SIG}}</span>  then  <span class="math">\\sigma := \\sigma^{<em>}</span> . Otherwise,  <span class="math">\\mathcal{A}&#x27;</span>  "undoes" the randomization of  <span class="math">\\sigma^{</em>} = (s,e)</span>  by setting  <span class="math">\\sigma := (s + e \\cdot r_{\\mathrm{SIG}}^{*},e)</span> ; thus if  <span class="math">\\mathcal{A}</span>  outputs a forgery for a randomization of  <span class="math">\\mathsf{pk}_{\\mathrm{SIG}}</span> ,  <span class="math">\\mathcal{A}&#x27;</span>  translates it back into a forgery for  <span class="math">\\mathsf{pk}_{\\mathrm{SIG}}</span> . In sum, since standard Schnorr signatures are secure in the random oracle model assuming hardness of discrete logarithms [PS00], so is the randomizable variant under the same assumptions.</li>

      <li>Unlinkability of public keys. Public keys are unlinkable because SIG.RandPk multiplies the public key pk (which is a group element) by a random group element; the result is statistically independent of pk.</li>

      <li>Unlinkability of signatures. The only part of a Schnorr signature that depends on the public or secret key is the scalar  <span class="math">s</span> . Since SIG.RandSig adds a random shift to  <span class="math">s</span> , the result is statistically independent of the signature's original key pair.</li>

      <li>Injective randomization. Fixing all inputs but for  <span class="math">r_{\\mathrm{SIG}}</span> , SIG.RandPk is a permutation over  <span class="math">\\mathbb{G}</span> . Hence, finding collisions over the randomness is not possible.</li>

    </ul>

    <p class="text-gray-300">!<a href="img-13.jpeg">img-13.jpeg</a> Figure 21: Construction of a randomizable signature scheme based on the Schnorr signature scheme [Sch91].</p>

    <p class="text-gray-300">!<a href="img-14.jpeg">img-14.jpeg</a></p>

    <p class="text-gray-300">Fig. 22 provides pseudocode that, together with the modified NP relation  <span class="math">\\mathcal{R}_{\\mathrm{e}}^{\\mathrm{del}}</span>  given in Fig. 23, formalizes the high-level description of a delegable DPC scheme from Section 5.3. In both figures, we highlighted changes from the "plain" DPC scheme in Section 4.2. The only step in DPC. Execute that must be performed by the delegator is Step 7a; all other steps can be performed by the worker without knowing the signature secret key.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DPC.Setup Input: security parameter 1^A Output: public parameters pp</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DPC.GenAddress Input: public parameters pp Output: address key pair (apk, ask)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1. Generate commitment parameters: ppCM← CM.Setup(1^A), ppTCM← TCM.Setup(1^A).</td>

            <td class="px-3 py-2 border-b border-gray-700">1. Generate authorization key pair: (pkSIG, skSIG)← SIG.Keygen(ppSIG).</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2. Generate CRH parameters: ppCRH← CRH.Setup(1^A).</td>

            <td class="px-3 py-2 border-b border-gray-700">2. Sample secret key skPRF for pseudorandom function PRF.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. Generate signature parameters: ppSIG← SIG.Setup(1^A).</td>

            <td class="px-3 py-2 border-b border-gray-700">3. Sample randomness rpk for commitment scheme TCM.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4. Generate NIZK parameters for Re^del (Fig. 23): pp_e← NIZK.Setup(1^A, Re^del).</td>

            <td class="px-3 py-2 border-b border-gray-700">4. Set address public key apk := CM.Commit(ppCM, pkSIG</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">skPRF; rpk).</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5. Output pp := (ppCM, ppTCM, ppCRH, ppSIG, pp_e).</td>

            <td class="px-3 py-2 border-b border-gray-700">5. Set address secret key ask := (skSIG, skPRF, rpk).</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | 6. Output (apk, ask).  |</p>

    <p class="text-gray-300">|  DPC Execute^L Input: · public parameters pp · old { records [ri]1^m · address secret keys [ask]1^m · auxiliary predicate input aux · transaction memorandum memo Output: new records [rj]1^m and transaction tx  |   |</p>

    <p class="text-gray-300">|  1. For each i ∈ {1,...,m}, process the i-th old record as follows: (a) Parse old record ri as ri = (address public key apki payload payloadi comm. rand. ri serial number nonce ρi predicates (Φb,i, Φd,i) commitment cmi). (b) If payloadi.isDummy = 1, set ledger membership witness wL,i := ⊥. If payloadi.isDummy = 0, compute ledger membership witness for commitment: wL,i ← L.Prove(cmi). (c) Parse address secret key aski as (skSIG,i, skPRF,i, rpk,i) and derive pkSIG,i from skSIG,i. (d) Compute signature randomness: rSIG,i ← PRFskPRF,i(ρi). (e) Compute serial number: sn_i ← SIG.RandPk(ppSIG, pkSIG,i, rSIG,i).  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. For each j ∈ {1,...,n}, construct the j-th new record as follows: (a) Compute serial number nonce: ρj := CRH.Eval(ppCRH, j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sn1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">snm). (b) Construct new record: rj ← DPC.ConstructRecord(pp, apkj, payloadj, Φb,j, Φd,j, ρj).</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  3. Retrieve current ledger digest: stL← L.Digest.  |   |</p>

    <p class="text-gray-300">|  4. Construct instance for relation Re^del: xe := (stL, [sn1]1^m, [cmj]1^n, memo).  |   |</p>

    <p class="text-gray-300">|  5. Construct witness for relation Re^del: we := ([ri]1^m, [wL,i]1^m, [skPRF,i]1^m, [pkSIG,i]1^m, [meta]1^m, [rpk,i]1^m, [rj]1^n, aux).  |   |</p>

    <p class="text-gray-300">|  6. Generate proof for relation Re^del: πe ← NIZK.Prove(pp_e, xe, we).  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7. For each i ∈ {1,...,m}: (a) Sign message: σi ← SIG.Sign(ppSIG, skSIG,i, xe</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">πe). (b) Randomize signature: σi ← SIG.RandSig(ppSIG, σi, rSIG,i).</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  8. Construct transaction: tx := ([sn1]1^m, [cmj]1^n, memo, <em>), where </em> := (stL, πe, [σi]1^m).  |   |</p>

    <p class="text-gray-300">|  9. Output ([rj]1^n, tx).  |   |</p>

    <p class="text-gray-300">|  DPC.Verify^L Input: public parameters pp and transaction tx Output: decision bit b  |   |</p>

    <p class="text-gray-300">|  1. Parse tx as ([sn1]1^m, [cmj]1^n, memo, <em>) and </em> as (stL, πe, [σi]1^m).  |   |</p>

    <p class="text-gray-300">|  2. Check that there are no duplicate serial numbers (a) within the transaction tx: sn_i ≠ sn_j for every distinct i, j ∈ {1,...,m}; (b) on the ledger: L.Contains(sn_i) = 0 for every i ∈ {1,...,m}.  |   |</p>

    <p class="text-gray-300">|  3. Check that the ledger state is valid: L.ValidateDigest(stL) = 1.  |   |</p>

    <p class="text-gray-300">|  4. Construct instance for the relation Re^del: xe := (stL, [sn1]1^m, [cmj]1^n, memo).  |   |</p>

    <p class="text-gray-300">|  5. Check proof for the relation Re^del: NIZK.Verify(pp_e, xe, πe) = 1.  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6. For every i ∈ {1,...,m}, check that signature verifies: SIG.Verify(ppSIG, sn_i, xe</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">πe, σi) = 1.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 22: Construction of a delegable DPC scheme. Highlights denote differences from Figure 8.</p>

    <p class="text-gray-300">The NP relation  <span class="math">\\mathcal{R}_{\\mathrm{e}}^{\\mathrm{dul}}</span>  has instances  <span class="math">\\mathbf{x}_{\\mathrm{e}}</span>  and witnesses  <span class="math">\\mathbf{w}_{\\mathrm{e}}</span>  of the following form.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">xe=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ledger digest</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">stL</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">we=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">old records</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[ri]1m</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">old record serial numbers</td>

            <td class="px-3 py-2 border-b border-gray-700">[sn1]1m</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">old record authorization public keys</td>

            <td class="px-3 py-2 border-b border-gray-700">[wL,i]1m</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">new record commitments</td>

            <td class="px-3 py-2 border-b border-gray-700">[cmj]1m</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">old record serial number secret keys</td>

            <td class="px-3 py-2 border-b border-gray-700">[pkSIG,i]1m</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">transaction memorandum</td>

            <td class="px-3 py-2 border-b border-gray-700">memo</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">old record address randomness</td>

            <td class="px-3 py-2 border-b border-gray-700">[rja,i]1m</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">new records</td>

            <td class="px-3 py-2 border-b border-gray-700">[rj]1m</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">auxiliary predicate input</td>

            <td class="px-3 py-2 border-b border-gray-700">aux</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  |   |   |   |   |   |</p>

    <p class="text-gray-300">where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for each  <span class="math">i \\in \\{1, \\dots, m\\}</span> ,  <span class="math">\\mathbf{r}_i = (\\mathsf{apk}_i, \\mathsf{payload}_i, \\Phi_{\\mathsf{b},i}, \\Phi_{\\mathsf{d},i}, \\rho_i, r_i, \\mathsf{cm}_i)</span> ;</li>

      <li>for each  <span class="math">j \\in \\{1, \\dots, n\\}</span> ,  <span class="math">\\mathbf{r}_j = (\\mathsf{apk}_j, \\mathsf{payload}_j, \\Phi_{\\mathsf{b},j}, \\Phi_{\\mathsf{d},j}, \\rho_j, r_j, \\mathsf{cm}_j)</span> .</li>

    </ul>

    <p class="text-gray-300">Define the local data  <span class="math">\\mathsf{ldata} := \\left( \\begin{array}{cccc} [cm_i]_1^m &amp;amp; [apk_i]_1^m &amp;amp; [payload_i]_1^m &amp;amp; [\\Phi_{d,i}]_1^m &amp;amp; [\\Phi_{b,i}]_1^m &amp;amp; [sn_i]_1^m &amp;amp; \\mathsf{memo} \\\\ [cm_j]_1^n &amp;amp; [apk_j]_1^n &amp;amp; [payload_j]_1^n &amp;amp; [\\Phi_{d,j}]_1^n &amp;amp; [\\Phi_{b,j}]_1^n &amp;amp; \\mathsf{aux} \\end{array} \\right)</span> .</p>

    <p class="text-gray-300">A witness  <span class="math">\\mathbf{w}_{\\mathrm{e}}</span>  is valid for an instance  <span class="math">\\mathbf{x}_{\\mathrm{e}}</span>  if the following conditions hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i \\in \\{i, \\dots, m\\}</span> :</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">\\mathbf{r}_i</span>  is not dummy,  <span class="math">\\mathbf{w}_{\\mathbf{L},i}</span>  proves that the commitment  <span class="math">\\mathsf{cm}_i</span>  is in a ledger with digest  <span class="math">\\mathsf{st}_{\\mathbf{L}}</span> :  <span class="math">\\mathbf{L}</span> . Verify  <span class="math">(\\mathsf{st}_{\\mathbf{L}}, \\mathsf{cm}_i, \\mathbf{w}_{\\mathbf{L},i}) = 1</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The address public key  <span class="math">\\mathsf{apk}_i</span>  matches the authorization public key  <span class="math">\\mathsf{pk}_{\\mathsf{SIG},i}</span>  and the serial number secret key  <span class="math">\\mathsf{sk}_{\\mathsf{PRF},i}</span> :  $\\mathsf{apk}_i = \\mathsf{CM}.\\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{CM}}, \\mathsf{pk}_{\\mathsf{SIG},i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sk}_{\\mathsf{PRF},i}; r_{\\mathsf{pk},i})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The serial number  <span class="math">\\mathsf{sn}_i</span>  is valid:  <span class="math">r_{\\mathsf{SIG},i} = \\mathsf{PRF}_{\\mathsf{sk}_{\\mathsf{PRF},i}}(\\rho_i)</span>  and  <span class="math">\\mathsf{sn}_i = \\mathsf{SIG}.\\mathsf{RandPk}(\\mathsf{pp}_{\\mathsf{SIG}}, \\mathsf{pk}_{\\mathsf{SIG},i}, r_{\\mathsf{SIG},i})</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The old record commitment  <span class="math">\\mathsf{cm}_i</span>  is valid:  $\\mathsf{cm}_i = \\mathsf{TCM}.\\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{TCM}}, \\mathsf{apk}_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{payload}_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_{\\mathsf{b},i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_{\\mathsf{d},i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_i; r_i)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">j \\in \\{1, \\dots, n\\}</span> :</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The serial number nonce  <span class="math">\\rho_{j}</span>  is computed correctly:  $\\rho_{j} = \\mathsf{CRH.Eval}(\\mathsf{pp}_{\\mathsf{CRH}}, j \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sn}_{1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sn}_{m})$ .</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- The birth predicate  <span class="math">\\Phi_{\\mathrm{b},j}</span>  is satisfied by the local data:  $\\Phi_{\\mathrm{b},j}(j\\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathrm{ldata}) = 1$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 23: The NP relation  <span class="math">\\mathcal{R}_{\\mathrm{e}}^{\\mathrm{dul}}</span> . Highlights denote differences from Figure 9.</p>

    <p class="text-gray-300">C Extensions in functionality and in security</p>

    <p class="text-gray-300">We summarize some natural extensions of our DPC construction that give richer functionality, as well as methods to prove security notions beyond standalone non-adaptive security.</p>

    <h5 id="sec-64" class="text-base font-semibold mt-4">Storing data in addresses.</h5>

    <p class="text-gray-300">For some applications it can be useful to verifiably associate address public keys with additional metadata meta. One can easily modify our construction to achieve this by using the address public key commitment to additionally commit to meta. To prove that a given address public key is bound to the metadata string meta, one can use a standard non-interactive zero knowledge proof of knowledge.</p>

    <p class="text-gray-300">With such a mechanism in hand, we can realise various useful functionality like on-ledger encryption: a user stores an encryption public key in the metadata of one of her addresses, and others can later use this public key to encrypt information about records created for her, and store the resulting ciphertext in the transaction’s memorandum. This method, used for example in Zerocash <em>[BCG^{+}14]</em>, gives users the option to not use other out-of-band secure communication channels.</p>

    <h5 id="sec-65" class="text-base font-semibold mt-4">Selective disclosure.</h5>

    <p class="text-gray-300">For compliance purposes, it may be useful to selectively reveal information about about a transaction to certain parties. Our implementation can be extended to support this by changing how hashes of predicate verification keys are committed to in a transaction: instead of committing all the verification keys together, one can instead commit to them in separate commitments. To disclose the predicates that were invoked in a transaction, a user can then simply open the relevant commitments.</p>

    <h5 id="sec-66" class="text-base font-semibold mt-4">Ledger position.</h5>

    <p class="text-gray-300">In some applications it may be useful to know the unique ledger position of a record, i.e., to have this information be part of the local data ldata given as input to predicates. For example, one can use a record’s ledger position to implement a “time lock” that prevents the record’s consumption until a pre-specified amount of time has passed since the record’s creation. However, the ledger interface we described in Section 3.1 does not expose this functionality: L.Prove only returns a proof that a transaction (or a subcomponent thereof) appears on the ledger, and not its position. One can augment L.Prove to instead output the transaction’s ledger position pos_{L}, and a proof that pos_{L} is the transaction’s position on the ledger. Our instantiation of the ledger with a Merkle tree supports this augmentation inherently: the path to the transaction in the Merkle tree is also its position the tree.</p>

    <h5 id="sec-67" class="text-base font-semibold mt-4">Composable security.</h5>

    <p class="text-gray-300">The security definition in Section 3.3 is a restriction of UC security definitions to a single execution at any given time. We can avoid this restriction and prove our construction UC-secure by replacing our simulation-extractable NIZKs with UC-secure NIZKs. The remainder of the proof would go through unchanged, and this would achieve composition of multiple protocol instances.</p>

    <h5 id="sec-68" class="text-base font-semibold mt-4">Adaptive security.</h5>

    <p class="text-gray-300">We can prove adaptive security, with a minor modification to our protocol in Section 4. The barrier to proving security against adaptive corruptions (even in a standalone setting) is a lack of forward-secure privacy. Namely, when the adversary corrupts a party <span class="math">\\mathcal{P}</span>, it gets access to <span class="math">\\mathcal{P}</span>’s state, which includes contents of records held by <span class="math">\\mathcal{P}</span> and address secret keys belonging to <span class="math">\\mathcal{P}</span>. The adversary can then use this information to break unlinkability of <span class="math">\\mathcal{P}</span>’s transactions by deriving the serial numbers of consumed records and matching these against those present on the ledger.</p>

    <p class="text-gray-300">In the proof, this problem is reflected in how the simulator <span class="math">\\mathcal{S}</span> handles serial numbers in honest party transactions (see Appendix A.2). For honest party transactions, serial numbers are sampled uniformly at random via SampleSn. When the environment <span class="math">\\mathcal{E}</span> corrupts an honest party, it can attempt to carry out the aforementioned linking attack by computing serial numbers via the PRF. Since serial numbers already</p>

    <p class="text-gray-300">published in transactions were derived randomly, they would not match the output of the PRF, allowing <span class="math">\\mathcal{E}</span> to distinguish the ideal world from the real world.</p>

    <p class="text-gray-300">We address this issue as follows. First, we work in the secure-erasure model and ensure that honest parties delete (a) all records output from Execute (after sending their contents to the intended recipients), and (b) all records that have been consumed. Hence, at the time a party is corrupted, the state revealed to the adversary does not contain secrets of past records, so the adversary cannot derive those records’ serial numbers. Next, we have to convincingly match the address public keys of unconsumed records with corresponding address secret keys. To do this, we modify DPC.GenAddress to use trapdoor commitments to construct address public keys. The trapdoor property then allows us to open public keys to the correct secret keys.</p>

    <p class="text-gray-300">However, these measures by themselves are not enough. Consider the following scenario: the adversary corrupts an honest user and learns her secret key. For every transaction in the ledger, it computes the serial number nonces of the output records from the serial numbers of the input records. The adversary can then use these nonces along with the secret key to derive candidate serial numbers for the output records. If these candidate serial numbers appear on the ledger, then the adversary learns that the record has been consumed.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To prevent this, we randomize the serial number nonces of all records output by Execute by deriving them as $\\rho_{j}:=\\textsc{CRH}(j\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_{\\rho,j}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{sn}_{1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{sn}_{m})<span class="math"> for some randomness </span>r_{\\rho,j}$ that is deleted after invoking Execute. This randomization ensures that the serial number nonce of an output record cannot be derived deterministically from the (publicly visible) serial numbers of the input records.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above measures, however, are still insufficient: the adversary still knows the secrets of records that a corrupted party sent to an honest party. After corrupting this honest party, the adversary can learn its address secret key and therefore derive the serial number of those records. To overcome this obstacle, one can replace the PRF with a programmable PRF <em>[x23]</em>, for which the owner of the secret key can “program” the PRF to output pre-determined values on specific inputs: for all polynomial-sized sets <span class="math">S=\\{(x_{i},y_{i})\\}_{i}</span>, the owner of a PRF secret key sk can derive a second key <span class="math">\\textsf{sk}_{S}</span> such that <span class="math">\\textsf{PRF}_{\\textsf{sk}_{s}}(x_{i})=y_{i}</span> for each <span class="math">(x_{i},y_{i})\\in S</span>, while <span class="math">\\textsf{PRF}_{\\textsf{sk}_{S}}(x)=\\textsf{PRF}_{\\textsf{sk}}(x)</span> for other inputs <span class="math">x</span>. This fixes the foregoing issue because <span class="math">\\mathcal{S}</span> can now give <span class="math">\\mathcal{E}</span> a programmed PRF secret key for the set <span class="math">S=\\{(\\rho_{i},\\textsf{sn}_{i})\\}_{i}</span>, where <span class="math">\\rho_{i}</span> is the serial number nonce of the <span class="math">i</span>-th record received from a corrupted party.</p>

    <p class="text-gray-300">Acknowledgments</p>

    <p class="text-gray-300">We thank Samuel Steffen for bringing our attention to the “denial-of-funds” attack mentioned in Remark 6.1, which can be addressed as explained there. This work was supported in part by: a Google Faculty Award; the National Science Foundation under awards CNS-1653110 and CNS-1801479; the UC Berkeley Center for Long-Term Cybersecurity; and donations from the Ethereum Foundation, the Interchain Foundation, and Qtum.</p>

    <h2 id="sec-69" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ADMM14a] Marcin Andrychowicz, Stefan Dziembowski, Daniel Malinowski, and Lukasz Mazurek. Fair two-party computations via Bitcoin deposits. In Proceedings of the BITCOIN workshop at the 18th International Conference on Financial Cryptography and Data Security, FC ’14, pages 105–121, 2014.</li>

      <li>[ADMM14b] Marcin Andrychowicz, Stefan Dziembowski, Daniel Malinowski, and Lukasz Mazurek. Secure multiparty computations on Bitcoin. In Proceedings of the 35th IEEE Symposium on Security and Privacy, SP ’14, pages 443–458, 2014.</li>

      <li>[AFK^{+}12] Diego F. Aranha, Laura Fuentes-Castañeda, Edward Knapp, Alfred Menezes, and Francisco Rodríguez-Henríquez. Implementing pairings at the 192-bit security level. In Proceedings of the 5th International Conference on Pairing-Based Cryptography, Pairing ’12, pages 177–195, 2012.</li>

      <li>[air] AirSwap. https://www.airswap.io/. Accessed 2018-12-27.</li>

      <li>[AKR^{+}13] Elli Androulaki, Ghassan Karame, Marc Roeschlin, Tobias Scherer, and Srdjan Capkun. Evaluating user privacy in Bitcoin. In Proceedings of the 17th International Conference on Financial Cryptography and Data Security, FC ’13, pages 34–51, 2013.</li>

      <li>[ANWW13] Jean-Phillipe Aumasson, Samuel Neves, Zooko Wilcox-O’Hearn, and Christian Winnerlein. BLAKE2: simpler, smaller, fast as MD5. In Proceedings of the 11th International Conference on Applied Cryptography and Network Security, ACNS ’13, pages 119–135, 2013.</li>

      <li>[BAZB20] Benedikt Bünz, Shashank Agrawal, Mahdi Zamani, and Dan Boneh. Zether: Towards privacy in a smart contract world. In Proceedings of the 20th International Conference on Financial Cryptography and Data Security, FC ’20, pages 423–443, 2020.</li>

      <li>[BBB^{+}18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Gregory Maxwell. Bulletproofs: Short proofs for Confidential Transactions and more. In Proceedings of the 39th IEEE Symposium on Security and Privacy, S&P ’18, pages 315–334, 2018.</li>

      <li>[BBD^{+}17] Iddo Bentov, Lorenz Breidenbach, Phil Daian, Ari Juels, Yunqi Li, and Xueyuan Zhao. The cost of decentralization in 0x and EtherDelta. http://hackingdistributed.com/2017/08/13/cost-of-decent/, 2017. Accessed 2019-01-03.</li>

      <li>[BCC^{+}16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In Proceedings of the 35th Annual International Conference on the Theory and Applications of Cryptographic Techniques, EUROCRYPT ’16, pages 327–357, 2016.</li>

      <li>[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for SNARKs and proof-carrying data. In Proceedings of the 45th ACM Symposium on the Theory of Computing, STOC ’13, pages 111–120, 2013.</li>

      <li>[BCG^{+}13] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: verifying program executions succinctly and in zero knowledge. In Proceedings of the 33rd Annual International Cryptology Conference, CRYPTO ’13, pages 90–108, 2013.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCG^{+}14] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from Bitcoin. In Proceedings of the 2014 IEEE Symposium on Security and Privacy, SP ’14, pages 459–474, 2014.</li>

      <li>[BCG^{+}15] Eli Ben-Sasson, Alessandro Chiesa, Matthew Green, Eran Tromer, and Madars Virza. Secure sampling of public parameters for succinct zero knowledge proofs. In Proceedings of the 36th IEEE Symposium on Security and Privacy, SP ’15, pages 287–304, 2015.</li>

      <li>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Proceedings of the 14th Theory of Cryptography Conference, TCC ’16-B, pages 31–60, 2016.</li>

      <li>[BCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero knowledge for a von neumann architecture. In Proceedings of the 23rd USENIX Security Symposium, USENIX ’14, pages 781–796, 2014.</li>

      <li>[BCTV17] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Scalable zero knowledge via cycles of elliptic curves. Algorithmica, 79(4):1102–1160, 2017.</li>

      <li>[BDJT17] Lorenz Breidenbach, Phil Daian, Ari Juels, and Florian Tramèr. To sink frontrunners, send in the sub-marines. http://hackingdistributed.com/2017/08/28/submarine-sends/, 2017. Accessed 2019-01-03.</li>

      <li>[BGG18] Sean Bowe, Ariel Gabizon, and Matthew D. Green. A multi-party protocol for constructing the public parameters of the pinocchio zk-SNARK, 2018.</li>

      <li>[BGM17] Sean Bowe, Ariel Gabizon, and Ian Miers. Scalable multi-party computation for zk-SNARK parameters in the random beacon model. Cryptology ePrint Archive, Report 2017/1050, 2017.</li>

      <li>[bin] Binance. https://www.binance.com/. Accessed 2019-01-03.</li>

      <li>[Bit15] Bitcoin. Some miners generating invalid blocks. https://bitcoin.org/en/alert/2015-07-04-spv-mining, 2015.</li>

      <li>[BKM17] Iddo Bentov, Ranjit Kumaresan, and Andrew Miller. Instantaneous decentralized poker. In Proceedings of the 23rd Annual International Conference on the Theory and Application of Cryptology and Information Security, ASIACRYPT ’17, pages 410–440, 2017.</li>

      <li>[BLS02] Paulo S. L. M. Barreto, Ben Lynn, and Michael Scott. Constructing elliptic curves with prescribed embedding degrees. In Proceedings of the 3rd International Conference on Security in Communication Networks, SCN ’02, pages 257–267, 2002.</li>

      <li>[Bow17a] Sean Bowe. Bellman, 2017. URL: https://github.com/zkcrypto/bellman.</li>

      <li>[Bow17b] Sean Bowe. Pairing, 2017. URL: https://github.com/zkcrypto/pairing.</li>

      <li>[Can01] Ran Canetti. Universally composable security: A new paradigm for cryptographic protocols. In Proceedings of the 42nd Annual Symposium on Foundations of Computer Science, FOCS ’01, pages 136–145, 2001.</li>

      <li>[CCW19] Alessandro Chiesa, Lynn Chua, and Matthew Weidner. On cycles of pairing-friendly elliptic curves. SIAM Journal on Applied Algebra and Geometry, 3(2):175–192, 2019.</li>

      <li>[CFH^{+}15] Craig Costello, Cédric Fournet, Jon Howell, Markulf Kohlweiss, Benjamin Kreuter, Michael Naehrig, Bryan Parno, and Samee Zahur. Geppetto: Versatile verifiable computation. In Proceedings of the 2015 IEEE Symposium on Security and Privacy, IEEE S&P 2015, pages 253–270, 2015.</li>

      <li>[CFQ19] Matteo Campanelli, Dario Fiore, and Anaïs Querol. LegoSNARK: modular design and composition of succinct zero-knowledge proofs. In Proceedings of the 26th ACM Conference on Computer and Communications Security, CCS ’19, pages 2075–2092, 2019.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CGL^{+}17] Alessandro Chiesa, Matthew Green, Jingcheng Liu, Peihan Miao, Ian Miers, and Pratyush Mishra. Decentralized anonymous micropayments. In Proceedings of the 36th Annual International Conference on the Theory and Applications of Cryptographic Techniques, EUROCRYPT ’17, pages 609–642, 2017.</li>

      <li>[Cha14] Chainalysis. Chainalysis inc. https://chainalysis.com/, 2014.</li>

      <li>[CHM^{+}20] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques, EUROCRYPT ’20, pages 738–768, 2020.</li>

      <li>[Cim18] Catalin Cimpanu. Zaif cryptocurrency exchange loses $60 million in recent hack. https://www.zdnet.com/article/zaif-cryptocurrency-exchange-loses-60-million-in-july-hack/, 2018. Accessed 2018-12-27.</li>

      <li>[CLN11] Craig Costello, Kristin E. Lauter, and Michael Naehrig. Attractive subfamilies of BLS curves for implementing high-security pairings. In Proceedings of the 12th International Conference on Cryptology in India, INDOCRYPT ’11, pages 320–342, 2011.</li>

      <li>[coi] Coinbase. https://www.coinbase.com/. Accessed 2019-01-03.</li>

      <li>[Cos12] Craig Costello. Particularly friendly members of family trees. Cryptology ePrint Archive, Report 2012/072, 2012.</li>

      <li>[CRR11] Ran Canetti, Ben Riva, and Guy N. Rothblum. Practical delegation of computation using multiple servers. In Proceedings of the 19th ACM Conference on Computer and Communications Security, CCS ’11, pages 445–454, 2011.</li>

      <li>[CRR13] Ran Canetti, Ben Riva, and Guy N. Rothblum. Refereed delegation of computation. Information and Computation, 226:16–36, 2013.</li>

      <li>[CZJ^{+}17] Ethan Cecchetti, Fan Zhang, Yan Ji, Ahmed E. Kosba, Ari Juels, and Elaine Shi. Solidus: Confidential distributed ledger transactions via PVORM. In Proceedings of the 24th ACM Conference on Computer and Communications Security, CCS ’17, pages 701–717, 2017.</li>

      <li>[CZK^{+}18] Raymond Cheng, Fan Zhang, Jernej Kos, Warren He, Nichola Hynes, Noah Johnson, Ari Juels, Andrew Miller, and Dawn Song. Ekiden: A platform for confidentiality-preserving, trustworthy, and performant smart contract execution. arXiv cs.CR/1804.05141, 2018.</li>

      <li>[DDO^{+}01] Alfredo De Santis, Giovanni Di Crescenzo, Rafail Ostrovsky, Giuseppe Persiano, and Amit Sahai. Robust non-interactive zero knowledge. In Proceedings of the 21st Annual International Cryptology Conference, CRYPTO ’01, pages 566–598, 2001.</li>

      <li>[De18] Nikhilesh De. Coincheck confirms crypto hack loss larger than Mt. Gox. https://www.coindesk.com/coincheck-confirms-crypto-hack-loss-larger-than-mt-gox, 2018. Accessed 2018-12-27.</li>

      <li>[DF91] Yvo Desmedt and Yair Frankel. Shared generation of authenticators and signatures (extended abstract). In Proceedings of the 11th Annual International Cryptology Conference, CRYPTO ’91, pages 457–469, 1991.</li>

      <li>[DGK^{+}20] Philip Daian, Steven Goldfeder, Tyler Kell, Yunqi Li, Xueyuan Zhao, Iddo Bentov, Lorenz Breidenbach, and Ari Juels. Flash Boys 2.0: Frontrunning, transaction reordering, and consensus instability in decentralized exchanges. In Proceedings of the 41st IEEE Symposium on Security and Privacy, S&P ’20, pages 910–927, 2020.</li>

      <li>[Dod07] Yevgeniy Dodis. Lecture notes: Exposure-resilient cryptography, 2007. https://www.cs.nyu.edu/courses/spring07/G22.3033-013/.</li>

      <li>[DSC^{+}15] Tien Tuan Anh Dinh, Prateek Saxena, Ee-Chien Chang, Beng Chin Ooi, and Chunwang Zhang. M2R: enabling stronger privacy in MapReduce computation. In Proceedings of the 24th USENIX Security Symposium, USENIX Security ’15, pages 447–462, 2015.</li>

    </ul>

    <p class="text-gray-300">[Ell13] Elliptic. Elliptic enterprises limited. https://www.elliptic.co/, 2013.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[EMC19] Shayan Eskandari, Seyedehmahsa Moosavi, and Jeremy Clark. SoK: Transparent Dishonesty: front-running attacks on blockchain. arXiv cs.CR/1902.05164, 2019.</li>

      <li>[EOS18] EOS. EOS.IO technical white paper, 2018. https://github.com/EOSIO/Documentation/blob/master/TechnicalWhitePaper.md.</li>

      <li>[Eth16] Ethereum. I thikn the attacker is this miner - today he made over $50k. https://www.reddit.com/r/ethereum/comments/55xh2w/i_thikn_the_attacker_is_this_miner_today_he_made/, 2016.</li>

      <li>[Eth18] Etherscan. The ethereum block explorer. https://etherscan.io/tokens, 2018.</li>

      <li>[FK97] Uriel Feige and Joe Kilian. Making games short. In Proceedings of the 29th ACM Symposium on the Theory of Computing, STOC ’97, pages 506–516, 1997.</li>

      <li>[FKM^{+}16] Nils Fleischhacker, Johannes Krupp, Giulio Malavolta, Jonas Schneider, Dominique Schröder, and Mark Simkin. Efficient unlinkable sanitizable signatures from signatures with re-randomizable keys. In Proceedings of the 19th International Conference on Practice and Theory in Public-Key Cryptography, PKC ’16, pages 301–330, 2016.</li>

      <li>[FST10] David Freeman, Michael Scott, and Edlyn Teske. A taxonomy of pairing-friendly elliptic curves. Journal of Cryptology, 23(2):224–280, 2010.</li>

      <li>[gem] Gemini. https://gemini.com/dollar. Accessed 2019-01-24.</li>

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Proceedings of the 32nd Annual International Conference on Theory and Application of Cryptographic Techniques, EUROCRYPT ’13, pages 626–645, 2013.</li>

      <li>[GM17] Jens Groth and Mary Maller. Snarky signatures: Minimal signatures of knowledge from simulation-extractable snarks. In Proceedings of the 37th Conference on the Theory and Applications of Cryptographic Techniques, CRYPTO ’17, pages 581–612, 2017.</li>

      <li>[GO94] Oded Goldreich and Yair Oren. Definitions and properties of zero-knowledge proof systems. Journal of Cryptology, 7(1):1–32, 1994.</li>

      <li>[Goo14] L.M. Goodman. Tezos — a self-amending crypto-ledger, 2014. https://tezos.com/static/white_paper-2dc8c02267a8fb86bd67a108199441bf.pdf.</li>

      <li>[Gro06] Jens Groth. Simulation-sound NIZK proofs for a practical language and constant size group signatures. In Proceedings of the 12th International Conference on the Theory and Application of Cryptology and Information Security, ASIACRYPT ’06, pages 444–459, 2006.</li>

      <li>[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. Plonk: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953, 2019.</li>

      <li>[Har18] Colin Harper. In search of stability: An overview of the budding stablecoin ecosystem. https://bitcoinmagazine.com/articles/search-stability-overview-budding-stablecoin-ecosystem/, 2018. Accessed 2019-1-24.</li>

      <li>[HBHW20] Daira Hopwood, Sean Bowe, Taylor Hornby, and Nathan Wilcox. Zcash protocol specification, 2020. URL: https://github.com/zcash/zips/blob/master/protocol/protocol.pdf.</li>

      <li>[IKOS06] Yuval Ishai, Eyal Kushilevitz, Rafail Ostrovsky, and Amit Sahai. Cryptography from anonymity. In Proceedings of the 47th Annual Symposium on Foundations of Computer Science, FOCS ’06, pages 239–248, 2006.</li>

    </ul>

    <p class="text-gray-300">[JSST16] Sanjay Jain, Prateek Saxena, Frank Stephan, and Jason Teutsch. How to verify computation with a rational network. arXiv cs.GT/1606.05917, 2016.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[KB16] Ranjit Kumaresan and Iddo Bentov. Amortizing secure computation with penalties. In Proceedings of the 23rd ACM Conference on Computer and Communications Security, CCS ’16, pages 418–429, 2016.</li>

      <li>[KGC^{+}17] Harry Kalodner, Steven Goldfeder, Alishah Chator, Malte Möser, and Arvind Narayanan. BlockSci: design and applications of a blockchain analysis platform. arXiv cs.CR/1709.02489, 2017.</li>

      <li>[KGC^{+}18] Harry A. Kalodner, Steven Goldfeder, Xiaoqi Chen, S. Matthew Weinberg, and Edward W. Felten. Arbitrum: Scalable, private smart contracts. In Proceedings of the 27th USENIX Security Symposium, USENIX Security ’18, pages 1353–1370, 2018.</li>

      <li>[KGM19] Gabriel Kaptchuk, Matthew Green, and Ian Miers. Giving state to the stateless: Augmenting trustworthy computation with ledgers. In Proceedings of the 26th Annual Network and Distributed System Security Symposium, NDSS ’19, 2019.</li>

      <li>[KMB15] Ranjit Kumaresan, Tal Moran, and Iddo Bentov. How to use Bitcoin to play decentralized poker. In Proceedings of the 22nd ACM Conference on Computer and Communications Security, CCS ’15, pages 195–206, 2015.</li>

      <li>[KMS^{+}16] Ahmed E. Kosba, Andrew Miller, Elaine Shi, Zikai Wen, and Charalampos Papamanthou. Hawk: The blockchain model of cryptography and privacy-preserving smart contracts. In Proceedings of the 2016 IEEE Symposium on Security and Privacy, SP ’16, pages 839–858, 2016.</li>

      <li>[LTKS15] Loi Luu, Jason Teutsch, Raghav Kulkarni, and Prateek Saxena. Demystifying incentives in the consensus computer. In Proceedings of the 22nd ACM Conference on Computer and Communications Security, CCS ’15, pages 706–719, 2015.</li>

      <li>[MAB^{+}13] Frank McKeen, Ilya Alexandrovich, Alex Berenzon, Carlos V. Rozas, Hisham Shafi, Vedvyas Shanbhogue, and Uday R. Savagaonkar. Innovative instructions and software model for isolated execution. In Proceedings of the Second Workshop on Hardware and Architectural Support for Security and Privacy, HASP ’13, page 10, 2013.</li>

      <li>[MBKM19] Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. Sonic: Zero-knowledge SNARKs from linear-size universal and updateable structured reference strings. In Proceedings of the 26th ACM Conference on Computer and Communications Security, CCS ’19, 2019.</li>

      <li>[Mer87] Ralph C. Merkle. A digital signature based on a conventional encryption function. In Proceedings of the 7th Conference on the Theory and Applications of Cryptographic Techniques, CRYPTO ’87, pages 369–378, 1987.</li>

      <li>[MGGR13] Ian Miers, Christina Garman, Matthew Green, and Aviel D. Rubin. Zerocoin: Anonymous distributed e-cash from Bitcoin. In Proceedings of the 2013 IEEE Symposium on Security and Privacy, SP ’13, pages 397–411, 2013.</li>

      <li>[Mic00] Silvio Micali. Computationally sound proofs. SIAM Journal on Computing, 30(4):1253–1298, 2000. Preliminary version appeared in FOCS ’94.</li>

      <li>[MPJ^{+}13] Sarah Meiklejohn, Marjori Pomarole, Grant Jordan, Kirill Levchenko, Damon McCoy, Geoffrey M. Voelker, and Stefan Savage. A fistful of Bitcoins: characterizing payments among men with no names. In Proceedings of the 2013 Internet Measurement Conference, IMC ’13, pages 127–140, 2013.</li>

      <li>[MRK03] Silvio Micali, Michael O. Rabin, and Joe Kilian. Zero-knowledge sets. In Proceedings of the 44th Annual Symposium on Foundations of Computer Science, FOCS ’03, pages 80–91, 2003.</li>

      <li>[MS18] Izaak Meckler and Evan Shapiro. Coda: Decentralized cryptocurrency at scale, 2018. https://cdn.codaprotocol.com/v2/static/coda-whitepaper-05-10-2018-0.pdf.</li>

    </ul>

    <p class="text-gray-300">[Nak09] Satoshi Nakamoto. Bitcoin: a peer-to-peer electronic cash system, 2009. URL: http://www.bitcoin.org/bitcoin.pdf.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[NKDM03] Antonio Nicolosi, Maxwell N. Krohn, Yevgeniy Dodis, and David Mazières. Proactive two-party signatures for user authentication. In Proceedings of the Network and Distributed System Security Symposium, NDSS ’03, 2003.</li>

      <li>[NVV18] Neha Narula, Willy Vasquez, and Madars Virza. zkLedger: Privacy-preserving auditing for distributed ledgers. In Proceedings of the 15th USENIX Symposium on Networked Systems Design and Implementation, NSDI ’18, pages 65–80, 2018.</li>

      <li>[PA14] Nathaniel Popper and Rachel Abrams. Apparent theft at Mt. Gox shakes Bitcoin world. https://www.nytimes.com/2014/02/25/business/apparent-theft-at-mt-gox-shakes-bitcoin-world.html, 2014. Accessed 2018-12-27.</li>

      <li>[par] Paradex. https://paradex.io/. Accessed 2018-12-27.</li>

      <li>[pax] Paxos Standard. https://paxos.com/standard. Accessed 2019-01-24.</li>

      <li>[PB17] Joseph Poon and Vitalik Buterin. Plasma: Scalable autonomous smart contracts. https://plasma.io/, 2017.</li>

      <li>[Pro18] The Brooklyn Project. An overview of decentralized trading of digital assets. https://collaborate.thebkp.com/project/TL/document/9/version/10/, 2018. Accessed 2018-12-27.</li>

      <li>[PS00] David Pointcheval and Jacques Stern. Security arguments for digital signatures and blind signatures. Journal of Cryptology, 13(3):361–396, 2000.</li>

      <li>[PS18] Chris Peikert and Sina Shiehian. Privately constraining and programming PRFs, the LWE way. In Proceedings of the 21st International Conference on Practice and Theory in Public-Key Cryptography, PKC ’18, pages 675–701, 2018.</li>

      <li>[rad] Radar Relay. https://radarrelay.com/. Accessed 2018-12-27.</li>

      <li>[RCGJ^{+}17] Arka Rai Choudhuri, Matthew Green, Abhishek Jain, Gabriel Kaptchuk, and Ian Miers. Fairness in an unfair world: Fair multiparty computation from public bulletin boards. In Proceedings of the 24th ACM Conference on Computer and Communications Security, CCS ’17, pages 719–728, 2017.</li>

      <li>[Rei16] Christian Reiwießner. From smart contracts to courts with not so smart judges. https://blog.ethereum.org/2016/02/17/smart-contracts-courts-not-smart-judges/, 2016.</li>

      <li>[RH11] Fergal Reid and Martin Harrigan. An analysis of anonymity in the Bitcoin system. In Proceedings of the 3rd IEEE International Conference on Privacy, Security, Risk and Trust (PASSAT), and the 3rd IEEE International Conference on Social Computing (SocialCom), SocialCom/PASSAT ’11, pages 1318–1326, 2011.</li>

      <li>[RS13] Dorit Ron and Adi Shamir. Quantitative analysis of the full Bitcoin transaction graph. In Proceedings of the 17th International Conference on Financial Cryptography and Data Security, FC ’13, pages 6–24, 2013.</li>

      <li>[Sah99] Amit Sahai. Non-malleable non-interactive zero knowledge and adaptive chosen-ciphertext security. In Proceedings of the 40th Annual Symposium on Foundations of Computer Science, FOCS ’99, pages 543–553, 1999.</li>

      <li>[SCF^{+}15] Felix Schuster, Manuel Costa, Cédric Fournet, Christos Gkantsidis, Marcus Peinado, Gloria Mainar-Ruiz, and Mark Russinovich. VC3: Trustworthy data analytics in the cloud using SGX. In Proceedings of the 36th IEEE Symposium on Security and Privacy, SP ’15, pages 38–54, 2015.</li>

      <li>[Sch91] Claus-Peter Schnorr. Efficient signature generation by smart cards. Journal of Cryptology, 4(3):161–174, 1991.</li>

    </ul>

    <p class="text-gray-300">[SJ99] Claus-Peter Schnorr and Markus Jakobsson. Security of discrete log cryptosystems in the random oracle and the generic model. In The Mathematics of Public-Key Cryptography, MPKC ’99, 1999.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[SMZ14] Michele Spagnuolo, Federico Maggi, and Stefano Zanero. BitIodine: Extracting intelligence from the Bitcoin network. In Proceedings of the 18th International Conference on Financial Cryptography and Data Security, FC ’14, pages 457–468, 2014.</li>

      <li>[SS01] Douglas R. Stinson Stinson and Reto Strobl. Provably secure distributed Schnorr signatures and a <span class="math">(t,n)</span> threshold scheme for implicit certificates. In Proceedings of the 5th Australasian Conference on Information Security and Privacy, ACISP ’01, pages 417–434, 2001.</li>

      <li>[TR17] Jason Teutsch and Christian Reiwießner. A scalable verification solution for blockchains. https://people.cs.uchicago.edu/~teutsch/papers/truebit.pdf, 2017.</li>

      <li>[Val08] Paul Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In Proceedings of the 5th Theory of Cryptography Conference, TCC ’08, pages 1–18, 2008.</li>

      <li>[VB15] Fabian Vogelsteller and Vitalik Buterin. ERC-20 token standard. https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md, 2015.</li>

      <li>[VBMW^{+}19] Jo Van Bulck, Marina Minkin, Ofir Weisse, Daniel Genkin, Baris Kasikci, Frank Piessens, Mark Silberstein, Thomas F. Wenisch, Yuval Yarom, and Raoul Strackx. Breaking virtual memory protection and the SGX ecosystem with foreshadow. IEEE Micro, 39(3):66–74, 2019.</li>

      <li>[Woo17] Gavin Wood. Ethereum: A secure decentralised generalised transaction ledger, 2017. http://yellowpaper.io.</li>

      <li>[WSR^{+}15] Riad S. Wahby, Srinath T. V. Setty, Zuocheng Ren, Andrew J. Blumberg, and Michael Walfish. Efficient RAM and control flow in verifiable outsourced computation. In Proceedings of the 22nd Annual Network and Distributed System Security Symposium, NDSS ’15, 2015.</li>

      <li>[ZCa15] ZCash Company. https://z.cash/, 2015.</li>

      <li>[ZCa16] ZCash parameter generation. https://z.cash/technology/paramgen.html, 2016. Accessed: 2017-09-28.</li>

      <li>[ZDB^{+}17] Wenting Zheng, Ankur Dave, Jethro G. Beekman, Raluca Ada Popa, Joseph E. Gonzalez, and Ion Stoica. Opaque: An oblivious and encrypted distributed analytics platform. In Proceedings of the 14th USENIX Symposium on Networked Systems Design and Implementation, NSDI ’17, pages 283–298, 2017.</li>

      <li>[Zha18] Wolfie Zhao. Bithumb $31 million crypto exchange hack: What we know (and don’t). https://www.coindesk.com/bithumb-exchanges-31-million-hack-know-dont-know, 2018. Accessed 2018-12-27.</li>

    </ul>`;
---

<BaseLayout title="Zexe: Enabling Decentralized Private Computation (2018/962)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/962
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
