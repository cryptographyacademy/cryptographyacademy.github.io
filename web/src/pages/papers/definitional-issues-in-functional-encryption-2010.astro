---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2010/556';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Definitional Issues in Functional Encryption';
const AUTHORS_HTML = 'Adam O&#x27;Neill';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">We provide a formalization of the emergent notion of \`\`functional encryption,&#x27;&#x27; as well as introduce various security notions for it, and study relations among the latter. In particular, we show that indistinguishability and semantic security based notions of security are {\\em inequivalent} for functional encryption in general; in fact,  \`\`adaptive&#x27;&#x27; indistinguishability does not even imply \`\`non-adaptive&#x27;&#x27; semantic security. This is alarming given the large body of work employing (special cases of) the former. We go on to show, however, that in the \`\`non-adaptive&#x27;&#x27; case an equivalence does hold between indistinguishability and  semantic security for what we call {\\em preimage sampleable} schemes. We take this as evidence that for preimage sampleable schemes an indistinguishability based notion may be acceptable in practice.  We show that some common functionalities considered in the literature satisfy this requirement.</p>
    </section>

    <p class="text-gray-300">We investigate relations among the notions of security we introduced for FE. First, we note that when giving the adversary adaptive access to the token derivation oracle (i.e., what we call FULL security), one reason semantic security seems stronger than indistinguishability is that the simulator apparently needs to commit to a &quot;dummy&quot; ciphertext on which to run the adversary before knowing what values the challenge message should have when evaluated under the functions for which the adversary will later request tokens.</p>

    <p class="text-gray-300">But we show that there is actually a more subtle reason for inequivalence of the definitions. In fact, we show that in general IND-FULL security does not even imply SS-TNA security. To show the separation we start with a IND-FULL secure functional encryption scheme for any class of functions  <span class="math">\\mathcal{F}</span>  of a certain form. We then modify it to construct a new scheme that is still IND-FULL secure for  <span class="math">\\mathcal{F}</span>  but not SS-TNA secure. We show the latter by presenting a concrete attack. We first describe a concept our counter-example scheme employs.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;6</sup>We do not consider a notion of function hiding (cf. [SSW09]).</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;7</sup>On the other hand, in the case of FULL security this is not enforced by the definition. This was an oversight on our part that was not noticed until after seeing [BSW11], so we do not correct it here (all our results anyway concern the non-adaptive case). As in [BSW11] one could require that S and  <span class="math">A_3</span>  have the same query distribution. Other differences between the SS definition of [BSW11] and ours include: theirs considers only adaptive access to the key derivation oracle whereas ours distinguishes between adaptive and non-adaptive, and theirs considers the encryption of multiple messages whereas ours considers only a single message (in particular, the former is important for the proof of impossibility they give for meeting their notion without random oracles).</p>

    <p class="text-gray-300">HIDDEN FUNCTIONS. Let  <span class="math">\\mathcal{G} = \\{g_k\\}_{k \\in \\mathbb{N}}</span>  and  <span class="math">\\mathcal{F} = \\{f_k\\}_{k \\in \\mathbb{N}}</span>  be families of functions on a common domain D = D(k). We say  <span class="math">\\mathcal{G}</span>  is hidden by  <span class="math">\\mathcal{F}</span>  if any PPT adversary A on inputs  <span class="math">f_k</span> ,  <span class="math">f_k(x)</span>  where  <span class="math">x \\stackrel{\\</span>}{\\leftarrow} D$  outputs  <span class="math">g_k(x)</span>  with only negligible probability in k. Note that such functions can be constructed under standard assumptions; for example, let  <span class="math">f_k</span>  be a one-way function applied to the first half of the bits of the input and let  <span class="math">g_k</span>  just output these bits (that is, the first half of the bits of the input). We say  <span class="math">\\mathcal{F}</span>  and  <span class="math">\\mathcal{G}</span>  are isomorphic if  <span class="math">f_k</span>  and  <span class="math">g_k</span>  are isomorphic for every k, meaning</p>

    <p class="text-gray-300"><span class="math">$f_k(d_1) = f_k(d_2) \\Leftrightarrow g_k(d_1) = g_k(d_2)</span>$
.</p>

    <p class="text-gray-300">for all  <span class="math">d_1, d_2 \\in D</span> . In other words,  <span class="math">f_k</span>  and  <span class="math">g_k</span>  have the same equality pattern across the domain. This is the case, for example, if  <span class="math">f_k</span>  in the example above is an <em>injective</em> one-way function on the first half of the input bits. We supress dependence on k below for convenience, just talking of functions rather than function families.</p>

    <p class="text-gray-300">The counter-example scheme. Let  <span class="math">\\mathcal{AE}^* = (\\mathsf{KDer}^*, \\mathsf{Enc}^*, \\mathsf{Dec}^*)</span>  be a (standard) public-key encryption scheme, and let  <span class="math">\\mathcal{FE}&#x27; = (\\mathsf{Setup}&#x27;, \\mathsf{KDer}&#x27;, \\mathsf{Enc}&#x27;, \\mathsf{Eval}&#x27;)</span>  be a functional encryption scheme over message-space  <span class="math">\\Sigma</span>  for a class of functions  <span class="math">\\mathcal{F} = \\{f_1, \\ldots, f_n\\}</span>  satisfying the following: there is a function g on  <span class="math">\\Sigma</span>  such that the pointwise concatenated function g is isomorphic to g and moreover g is hidden by f. (For simplicity, we assume here that g is polynomial in g. The counter-example can easily be extended to larger function sets by instead requiring the forgoing condition on some fixed g subset of the g such that g is polynomial in g condition on some fixed g subset of the g such that g is polynomial in g such that g is polynomial in g such that g is polynomial in g such that g is polynomial in g such that g is polynomial in g such that g is polynomial in g is polynomial.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Setup on input  <span class="math">1^k</span>  first runs  <span class="math">(pk&#x27;, sk&#x27;) \\stackrel{\\</span>}{\\leftarrow} \\mathsf{Setup'}(1^k)$ , and  <span class="math">(pk^*, sk^*) \\stackrel{\\</span>}{\\leftarrow} \\mathsf{KDer}^<em>(1^k)$ . It then selects  <span class="math">w_1, \\ldots, w_{n-1} \\stackrel{\\</span>}{\\leftarrow} {0, 1}^{|sk^</em>|}$  and computes  <span class="math">w_n \\leftarrow sk^* \\oplus w_1 \\oplus \\cdots \\oplus w_{n-1}</span> . Finally, it returns master public key  <span class="math">pk = pk&#x27; \\| pk^*</span>  and master secret key  <span class="math">sk = sk&#x27; \\| w_1 \\| \\ldots \\| w_n</span> .</li>
      <li>KDer on input the master secret key  <span class="math">sk = sk&#x27; ||w_1|| \\dots ||w_k|</span>  and a (description of a) function  <span class="math">f_i \\in \\mathcal{F}</span>  first runs  <span class="math">\\mathsf{KDer}&#x27;_{sk&#x27;}(f_i)</span>  to obtain  <span class="math">sk&#x27;_{f_i}</span> . Then, it outputs  <span class="math">sk_{f_i} = sk&#x27;_{f_i} ||w_i|</span> .</li>
      <li>Enc on input the master public key  <span class="math">pk = pk&#x27; \\| pk^*</span>  and a message  <span class="math">m \\in \\Sigma</span>  first computes  <span class="math">c&#x27; \\stackrel{\\</span>}{\\leftarrow} \\operatorname{Enc}'(pk', m)$  and  <span class="math">c^* \\stackrel{\\</span>}{\\leftarrow} \\operatorname{Enc}^<em>(pk^</em>, g(m))$ . It returns  <span class="math">c&#x27; \\| c^*</span> .</li>
      <li>Eval on input a secret key  <span class="math">sk_{f_i} = sk&#x27;_{f_i} || w_i</span>  and a ciphertext  <span class="math">c = c&#x27; || c^*</span>  computes  <span class="math">d \\leftarrow \\text{Eval}&#x27;(sk&#x27;_{f_i}, c&#x27;)</span> , and outputs d.</li>
    </ul>

    <p class="text-gray-300"><strong>Theorem 3.1</strong> If  <span class="math">\\mathcal{AE}^*</span>  is IND-CPA secure and  <span class="math">\\mathcal{FE}&#x27;</span>  is IND-FULL secure for  <span class="math">\\mathcal{F} = \\{f_1, \\ldots, f_n\\}</span>  as above (i.e., where g is hidden by  <span class="math">f_1 \\| \\ldots \\| f_n</span> ), then  <span class="math">\\mathcal{FE}</span>  is also IND-FULL secure for  <span class="math">\\mathcal{F}</span> . However, it is not SS-TNA secure.</p>

    <p class="text-gray-300">Note that the assumptions of the theorem do not constitute any additional complexity assumptions beyond the (minimal) one of  <span class="math">\\mathcal{FE}&#x27;</span>  being IND-FULL secure for  <span class="math">\\mathcal{F}</span> , meaning based on the latter we can construct the other schemes and functions that are assumed.</p>

    <p class="text-gray-300">We also remark that the separation also holds in the case of &quot;selective-security,&quot; where the challenge messages are chosen up-front by the adversary, as considered in e.g. [BW07, KSW08]. It</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;8</sup>Indeed, a simpler example is to take  <span class="math">f_k</span>  to be a one-way function and  <span class="math">g_k</span>  to be the identity. However, in our counter-example this will prevent the adversary from even being able to <em>find</em> two messages that agree on  <span class="math">f_k</span> . We believe this points to a separate shortcoming of the IND definition.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;9</sup>By pointwise concatenation f || g of functions f and g on a set D we mean that f || g(x) = f(x) || g(x) for all  <span class="math">x \\in D</span> .</p>

    <p class="text-gray-300">also holds in the case of predicate encryption [BW07, KSW08], since we can take  <span class="math">f_i</span>  for  <span class="math">1 \\le i \\le n</span>  to output the <em>i</em>-th bit of a function f such that g is hidden by f (i.e., a function can always be decomposed bit-wise into predicates).</p>

    <p class="text-gray-300"><strong>Proof:</strong> (Sketch.) To see  <span class="math">\\mathcal{FE}</span>  is IND-FULL secure for  <span class="math">\\mathcal{F}</span> , first consider an adversary A that does not request tokens for all of  <span class="math">f_1, \\ldots, f_n</span> . Then in addition to interacting with  <span class="math">\\mathcal{FE}&#x27;</span>  in the IND-FULL experiment, the adversary is just given additional random strings when it requests tokens, which in particular are independent of b, so security of  <span class="math">\\mathcal{FE}</span>  follows from that of  <span class="math">\\mathcal{FE}&#x27;</span> . Now consider A that requests tokens for all of  <span class="math">f_1, \\ldots, f_n</span> . In this case, in addition to interacting with  <span class="math">\\mathcal{FE}&#x27;</span>  the adversary obtains  <span class="math">g(m_b)</span>  where  <span class="math">m_b</span>  is the challenge message. But by the rules of the experiment we know that  <span class="math">f_1(m_0) \\| \\ldots \\| f_n(m_0) = f_1(m_1) \\| \\ldots \\| f_n(m_1)</span>  and thus by assumption  <span class="math">g(m_0) = g(m_1)</span> , meaning again this information is independent of b and so IND security of  <span class="math">\\mathcal{FE}</span>  follows from that of  <span class="math">\\mathcal{FE}&#x27;</span> .</p>

    <p class="text-gray-300">To show that  <span class="math">\\mathcal{FE}</span>  is not SS-TNA secure, we describe an SS-TNA adversary  <span class="math">B = (B_1, B_2, B_3)</span>  for which there is no simulator with comparable probability of guessing t = t'. Namely,  <span class="math">B_1</span>  requests evaluation tokens for all of  <span class="math">f_1, \\ldots f_n</span>  and passes them along as the state, and  <span class="math">B_2</span>  chooses a random challenge message  <span class="math">m \\in \\Sigma</span> , sets  <span class="math">t \\leftarrow g(m)</span> , and outputs (m, t). Then, by construction  <span class="math">B_3</span>  can always output t = t' by decrypting the part of the challenge ciphertext formed by  <span class="math">\\mathcal{AE}^*</span>  (note that  <span class="math">B_3</span>  makes no queries itself as required). However, a simulator who outputs t = t' with non-negligible probability would contradict the fact that g is hidden by f since the simulator is not given any ciphertext but just the value of  <span class="math">f_1(m) \\| \\ldots \\| f_n(m)</span>  (also  <span class="math">p_k</span>  and the evaluation tokens for  <span class="math">f_1, \\ldots, f_n</span> , but a hidden function adversary can generate these itself).</p>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 An Equivalence under Preimage Sampleability</h2>

    <p class="text-gray-300">We show that for token non-adaptive (TNA) security the counter-example in Section 3 is tight. Namely, we show an <em>equivalence</em> between indistinguishability and semantic-security under TNA security for what we call <em>preimage sampleable</em> (PS) schemes. Note that TNA security seems reasonable in practical applications where what tokens a party receives does not depend on the encrypted messages.</p>

    <p class="text-gray-300">PREIMAGE SAMPLEABILITY. Let  <span class="math">\\mathcal{FE} = (\\text{Setup}, \\text{KDer}, \\text{Enc}, \\text{Eval})</span>  be a functional encryption scheme over message-space  <span class="math">\\Sigma</span>  for the class of functions  <span class="math">\\mathcal{F}</span> . We call  <span class="math">\\mathcal{FE}</span>  preimage sampleable (PS) if there is a PPT algorithm A such that, for every PPT algorithm B, the probability that the following experiment returns 0 is negligible in k:</p>

    <pre><code class="language-text">Experiment \\operatorname{Exp}_{\\mathcal{FE},A,B}^{ps}(k):
(m, f_1, \\dots, f_\\ell) \\overset{\\$}{\\leftarrow} B(1^k)
m&#x27; \\overset{\\$}{\\leftarrow} A(1^k, |m|, f_1(m), \\dots, f_\\ell(m))
If |m| = |m&#x27;| and f_i(m&#x27;) = f_i(m) for all 1 \\leq i \\leq \\ell
Then return 1
Else return 0
</code></pre>

    <p class="text-gray-300">Above, we require that  <span class="math">m, m&#x27; \\in \\Sigma</span>  and  <span class="math">f_1, \\ldots, f_\\ell \\in \\mathcal{F}</span> .</p>

    <p class="text-gray-300">We make a few remarks about our definition of preimage sampleability. First, we note that the inputs to A are always guaranteed to be consistent with <em>some</em> underlying m (and thus there is always at least one possible m' causing the PS experiment to return 1); on inputs that do</p>

    <p class="text-gray-300">not satisfy this requirement we do not need the output of <em>A</em> to be defined. We also note that preimage sampleability as we have defined it is really a property of <em>F</em> and we sometimes refer to it as such. Finally, requiring that the inputs to <em>A</em> be generated by another PPT algorithm (rather than quantifying over all such inputs) is important to leave open the possibility of PS for some functionalities, such as 3-CNF formulae. (The latter point was brought to our attention by De Caro and Fiore [CF].)</p>

    <p class="text-gray-300">In essence, we show that preimage sampleability provides a &quot;test&quot; of whether equivalence between the IND and SS definitions is maintained in the case of TNA security.</p>

    <p class="text-gray-300"><strong>Theorem 4.1</strong> Let <em>FE</em> be an PS functional encryption scheme. Then <em>FE</em> is SS-TNA secure if and only if it is IND-TNA secure.</p>

    <p class="text-gray-300"><strong>Proof:</strong> (Sketch.) (SS-TNA <em>&rArr;</em> IND-TNA) Suppose that <em>FE</em> is <em>not</em> IND-TNA secure, in particular let <em>A</em> = (<em>A</em>1<em>, A</em>2) be a successful IND-TNA adversary against it. Consider SS-TNA adversary <em>B</em> = (<em>B</em>1<em>, B</em>2<em>, B</em>3) that works as follows. <em>B</em><sup>1</sup> runs <em>A</em><sup>1</sup> on <em>pk</em> (answering key-derivation queries using its own oracle) to receive (<em>m</em>0<em>, m</em>1). It then chooses <em>b &isin; {</em>0<em>,</em> 1<em>}</em> at random and returns (<em>mb, b</em>). <em>B</em><sup>3</sup> runs <em>A</em><sup>2</sup> on its input and outputs the result. Note that no SS-TNA simulator can output <em>b</em> with probability better than 1<em>/</em>2 in the SS-TNA-IDEAL experiment because the simulator gets no information about <em>b</em> (since according to the rules of the IND-TNA experiment <em>A</em> may only makes token-derivation queries whose responses are independent of <em>b</em>, and the simulator makes no queries). So <em>FE</em> is not SS-TNA secure.</p>

    <p class="text-gray-300">(IND-TNA <em>&rArr;</em> SS-TNA) Now suppose <em>FE is</em> IND-TNA secure. Let <em>A</em> = (<em>A</em>1<em>, A</em>2<em>, A</em>3) be any SS-TNA adversary against <em>FE</em>. We construct a simulator <em>S</em> with comparable success probability in the SS-IDEAL-TNA experiment to <em>A</em> in the SS-REAL-TNA experiment, which implies <em>FE</em> is SS-TNA secure. Simulator <em>S</em> works as follows: given queries <em>f</em>1<em>, . . . , f<sup>q</sup></em> made by <em>A</em><sup>1</sup> and their values <em>y</em>1<em>, . . . , y<sup>q</sup></em> on the challenge message <em>m</em>, <em>S</em> will sample a &quot;dummy&quot; message <em>m&prime; &isin;</em> &Sigma; such that <em>f</em>1(<em>m&prime;</em> ) = <em>y</em>1<em>, . . . , fq</em>(<em>m&prime;</em> ) = <em>y<sup>q</sup></em> using the sampler <em>A</em> guaranteed by the definition of PS. (Here <em>B</em> in the definition of PS can be viewed as the entire experiment up to this point.) It runs <em>A</em><sup>3</sup> on the encryption of <em>m&prime;</em> and outputs the result. There are two cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>&bull;</em> <strong>Case 1:</strong> <em>m</em> = <em>m&prime;</em> with overwhelming probability. Then <em>A</em>3's success probability in the simulated environment remains negligibly different from the SS-TNA-REAL experiment.</li>
      <li><em>&bull;</em> <strong>Case 2:</strong> <em>m &#824;</em>= <em>m&prime;</em> with non-negligible probability. Then if <em>A</em>3's success probability also differs noticeably, we can construct a successful IND-TNA adversary <em>B</em> = (<em>B</em>1<em>, B</em>2) against <em>FE</em>, as follows. <em>B</em><sup>1</sup> first runs <em>A</em>1<em>, A</em><sup>2</sup> on the appropriate inputs to receive (<em>m, t</em>). Let <em>f</em>1<em>, . . . , f<sup>q</sup></em> be the queries made by <em>A</em>1. Using the sampler guaranteed by the definition of PS, <em>B</em><sup>1</sup> samples a message <em>m&prime;</em> such that <em>f</em>1(<em>m&prime;</em> ) = <em>f</em>1(<em>m</em>)<em>, . . . , fq</em>(<em>m&prime;</em> ) = <em>fq</em>(<em>m</em>), and returns (<em>m, m&prime; , t</em>) (i.e., <em>m</em> and <em>m&prime;</em> are the challenge messages and <em>t</em> is the state). <em>B</em><sup>2</sup> runs <em>A</em><sup>3</sup> on <em>pk, c</em> from its input to recieve output <em>t &prime;</em> ; if <em>t &prime;</em> = <em>t</em> it returns 0, and otherwise 1. Note that for <em>B</em> to be successful it is important that <em>m &#824;</em>= <em>m&prime;</em> , which holds with non-negligible probability in this case. This contradicts our initial assumption that <em>FE</em> is IND-TNA secure.</li>
    </ul>

    <p class="text-gray-300">Thus in either case the success probability of <em>S</em> is close to that of <em>A</em>.</p>

    <p class="text-gray-300">It is interesting to note how the proof of the second implication accounts for the fact that IND-TNA may be &quot;vacuously&quot; satisfied when the adversary is not able to find two messages that agree on the given functionality. Indeed, in this case, our simulator samples from the corresponding preimage set of size 1, and thus the simulation trivially works.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 On Preimage Sampleability of Some Functionalities</h2>

    <p class="text-gray-300">We examine whether specific functionalities considered in the literature satisfy our PS condition. For inner-product predicates [KSW08, LOS<sup>+</sup>10, OT10], IBE [BF03], and PEKS [BCOP04, ABC<sup>+</sup>08], we show that the answer is &quot;yes.&quot; On the other hand, for ABE [SW05, GPSW06, BSW07] it seems hard to show PS; we leave this as an open problem.</p>

    <p class="text-gray-300">INNER-PRODUCTS. We first show that PS is satisfied by the important class of inner-product predicates realized in prior work [KSW08, LOS<sup>+</sup>10, OT10]. Hence, by Theorem 4.1, schemes in the literature for this functionality proven secure relative to the IND notion also meet SS, at least under non-adaptive access to the token-derivation oracle. Namely, consider the evaluation of inner products over  <span class="math">\\mathbb{Z}_N</span>  for a composite N (of which it assumed hard to find a non-trivial factor; here N is generated by the PS experiment before being given to B, A). More formally, let  <span class="math">n \\in \\mathbb{N}</span>  be given and let N be such a composite. Let  <span class="math">\\Sigma = \\mathbb{Z}_N^n</span>  and define the associated class of inner-product predicates  <span class="math">\\mathcal{P}_{iprod} = \\{p_{\\mathbf{x}} \\mid \\mathbf{x} \\in \\mathbb{Z}_N^n\\}</span>  where  <span class="math">p_{\\mathbf{x}}(\\mathbf{y}) = 1</span>  if  <span class="math">\\langle \\mathbf{x}, \\mathbf{y} \\rangle = \\sum_{i=1}^n x_i \\cdot y_i = 0 \\mod N</span> , and 0 otherwise. (Note that in the terminology of [KSW08] we thus consider the &quot;predicate-only&quot; version of the scheme for simplicity.)</p>

    <p class="text-gray-300"><strong>Proposition 5.1</strong> The class  <span class="math">\\mathcal{P}_{iprod}</span>  as defined above is PS if it is hard to find a non-trivial factor of N.</p>

    <p class="text-gray-300"><strong>Proof:</strong> (Sketch.) We construct a PPT algorithm A that on input  <span class="math">(\\mathbf{x}_1, y_1 = p_{\\mathbf{x}_1}(\\mathbf{m})), \\dots, (\\mathbf{x}_r, y_r = p_{\\mathbf{x}_r}(\\mathbf{m}))</span>  for any polynomial r = r(k) and any  <span class="math">p_{\\mathbf{x}_1}, \\dots, p_{\\mathbf{x}_r} \\in \\mathcal{P}_{iprod}</span>  and  <span class="math">\\mathbf{m} \\in \\Sigma</span> , outputs a vector  <span class="math">\\mathbf{m}&#x27;</span>  causing the PS experiment to return 1 with overwhelming probability. (Here we just refer to the probability over A's own coins.) Let  <span class="math">I_b</span>  denote the set  <span class="math">\\{i \\in [r] \\mid y_i = b\\}</span>  for  <span class="math">b \\in \\{0, 1\\}</span> , and let B be the  <span class="math">|I_1| \\times n</span>  matrix where each row is a unique element of  <span class="math">\\{\\mathbf{x}_i \\mid i \\in I_1\\}</span> .</p>

    <p class="text-gray-300">Algorithm A works as follows. It first finds a basis  <span class="math">W = \\{\\mathbf{w}_1, \\dots, \\mathbf{w}_s\\}</span>  for  <span class="math">\\ker(B)</span>  in the space  <span class="math">\\mathbb{Z}_N^n</span> . This is done by solving the homogeneous system of equations  <span class="math">B\\mathbf{x} = \\mathbf{0}</span>  using Gaussian elimination over  <span class="math">\\mathbb{Z}_N</span> ; while  <span class="math">\\mathbb{Z}_N</span>  is not a field, if Gaussian elimination fails then A can find a non-trivial factor of N. It outputs a random  <span class="math">\\mathbb{Z}_N</span> -combination of the vectors in W. That is, it outputs  <span class="math">\\mathbf{m}&#x27; = r_1\\mathbf{w}_1 + \\ldots + r_s\\mathbf{w}_s</span>  where each  <span class="math">r_i \\in \\mathbb{Z}_N</span>  for  <span class="math">1 \\le j \\le s</span>  is chosen independently at random.</p>

    <p class="text-gray-300">For the analysis, we need to show that with overwhelming probability  <span class="math">\\langle \\mathbf{m}&#x27;, \\mathbf{x}_i \\rangle = 0 \\mod N</span>  for all  <span class="math">i \\in I_1</span>  and  <span class="math">\\langle \\mathbf{m}&#x27;, \\mathbf{x}_j \\rangle \\neq 0 \\mod N</span>  for all  <span class="math">j \\in I_0</span> . The first part is clear by construction. For the second part, we first claim that for every fixed  <span class="math">j \\in I_0</span> , the probability over the choice of  <span class="math">r_1, \\ldots, r_s \\in \\mathbb{Z}_N</span>  that  <span class="math">\\langle \\mathbf{m}&#x27;, \\mathbf{x}_j \\rangle = 0 \\mod N</span>  is negligible. To see this, observe that there must be some (not necessarily unique)  <span class="math">\\mathbf{w}_{i(j)} \\in W</span>  such that  <span class="math">\\langle \\mathbf{x}_j, \\mathbf{w}(j) \\rangle \\neq 0 \\mod N</span> , since otherwise there would be no  <span class="math">\\mathbf{m}&#x27;</span>  causing the PS experiment to return 1. So, given any outcome of the  <span class="math">r_i</span>  for  <span class="math">i \\neq i(j)</span>  and assuming  <span class="math">\\langle \\mathbf{x}_j, \\mathbf{w}(j) \\rangle</span>  is not a zero-divisor (otherwise A can find a non-trivial factor of N), there is exactly one possible choice for  <span class="math">r_{i(j)}</span>  such that  <span class="math">\\langle \\mathbf{m}&#x27;, \\mathbf{x}_j \\rangle = 0 \\mod N</span> . Now, by a union bound, the probability that  <span class="math">\\langle \\mathbf{m}&#x27;, \\mathbf{x}_j \\rangle = 0 \\mod N</span>  for any  <span class="math">j \\in I_0</span>  is negligible, which is what we needed to show.</p>

    <p class="text-gray-300">IBE AND PEKS. The functionalities for IBE [BF03] and PEKS [BCOP04, ABC<sup>+</sup>08] are also preimage sampleable. For example, in the case of IBE, given the functions and their values on the underlying &quot;message,&quot; there are two cases: if we know that <em>fID</em>(<em>ID&prime;&#8741;x</em>) = <em>x</em> then there is only one possible preimage, namely <em>ID&#8741;x</em>; otherwise, we can sample from the set of possible &quot;messages&quot; by choosing an identity other than those for which the adversary has requested secret keys and any payload (an analogous argument applies in the case of PEKS). We omit the formal statements. By Theorem 4.1, we conclude that such schemes in the literature proven secure under an IND notion also meet SS-TNA under this condition.</p>

    <p class="text-gray-300">Attribute-based encryption. For the functionalities of ABE [SW05, GPSW06, BSW07], we do not know if PS holds. For example, consider the case of (anonymous) Fuzzy IBE [SW05, KSW08]. Namely, let <em>U</em> be a finite set and let &Sigma; be the power-set of <em>U</em>, i.e., &Sigma; = <em>{S | S &sube; U}</em>. For 1 <em>&le; d &le; |U|</em> and <em>S, T &sube; U</em> define <em>pS,d</em>(<em>T</em>) = 1 if <em>S &cap; T &ge; d</em> and 0 otherwise. (As before, let us consider this &quot;predicate-only&quot; counterpart to Fuzzy IBE for simplicity.) Typically, one considers an FE scheme over &Sigma; for the class <em>P<sup>d</sup></em> = <em>{pS,d | S &sube; U}</em> where <em>d</em> is fixed. To show PS, we would basically need to give an efficient algorithm that, given &quot;good&quot; sets <em>G</em>1<em>, . . . G<sup>n</sup> &sube; U</em> and &quot;bad sets&quot; <em>B</em><sup>1</sup> <em>. . . , B<sup>m</sup> &sube; U</em> for polynomials <em>n</em> = <em>n</em>(<em>k</em>)<em>, m</em> = <em>m</em>(<em>k</em>), as well as <em>d</em> such that 1 <em>&le; d &le; |U|</em>, outputs a set <em>X &sube; U</em> such that <em>|X &cap; G<sup>i</sup> | &ge; d</em> for all 1 <em>&le; i &le; n</em> and <em>|X &cap; B<sup>j</sup> | &lt; d</em> for all 1 <em>&le; j &le; m</em>. We are not sure if such an algorithm exists and leave this for future work.</p>

    <p class="text-gray-300">We are very grateful to Alexandra Boldyreva for the initial conversations that led to this research, Mihir Bellare for discussions about the definitions and comments on the draft, and Nathan Chenette for discussions about preimage sampleability. We also thank Dario Fiore and Angelo De Caro for helpful feedback.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>References</strong></h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[ABC+08] Michel Abdalla, Mihir Bellare, Dario Catalano, Eike Kiltz, Tadayoshi Kohno, Tanja Lange, John Malone-Lee, Gregory Neven, Pascal Paillier, and Haixia Shi. Searchable encryption revisited: Consistency properties, relation to anonymous ibe, and extensions. <em>J. Cryptology</em>, 21(3):350&ndash;391, 2008.</p></li>
      <li><p class="text-gray-300">[BCOP04] Dan Boneh, Giovanni Di Crescenzo, Rafail Ostrovsky, and Giuseppe Persiano. Public key encryption with keyword search. In <em>EUROCRYPT</em>, pages 506&ndash;522, 2004.</p></li>
      <li><p class="text-gray-300">[BDPR98] Mihir Bellare, Anand Desai, David Pointcheval, and Phillip Rogaway. Relations among notions of security for public-key encryption schemes. In <em>CRYPTO</em>, pages 26&ndash;45, 1998.</p></li>
      <li><p class="text-gray-300">[BF03] Dan Boneh and Matthew K. Franklin. Identity-based encryption from the weil pairing. <em>SIAM J. Comput.</em>, 32(3), 2003.</p></li>
      <li><p class="text-gray-300">[BSW07] John Bethencourt, Amit Sahai, and Brent Waters. Ciphertext-policy attribute-based encryption. In <em>IEEE Symposium on Security and Privacy</em>, pages 321&ndash;334, 2007.</p></li>
      <li><p class="text-gray-300">[BSW11] Dan Boneh, Amit Sahai, and Brent Waters. Functional encryption: Definitions and challenges. In <em>TCC</em>, 2011.</p></li>
      <li><p class="text-gray-300">[BW07] Dan Boneh and Brent Waters. Conjunctive, subset, and range queries on encrypted data. In <em>TCC</em>, pages 535&ndash;554, 2007.</p></li>
      <li><p class="text-gray-300">[CF] Angelo De Caro and Dario Fiore. Personal correspondence, 2010.</p></li>
      <li><p class="text-gray-300">[CK10] Melissa Chase and Seny Kamara. Structured encryption and controlled disclosure. In <em>ASIACRYPT</em>, pages 577&ndash;594, 2010.</p></li>
      <li><p class="text-gray-300">[GM84] Shafi Goldwasser and Silvio Micali. Probabilistic encryption. <em>J. Comput. Syst. Sci.</em>, 28(2):270&ndash;299, 1984.</p></li>
      <li><p class="text-gray-300">[GPSW06] Vipul Goyal, Omkant Pandey, Amit Sahai, and Brent Waters. Attribute-based encryption for fine-grained access control of encrypted data. In <em>ACM Conference on Computer and Communications Security</em>, pages 89&ndash;98, 2006.</p></li>
      <li><p class="text-gray-300">[KSW08] Jonathan Katz, Amit Sahai, and Brent Waters. Predicate encryption supporting disjunctions, polynomial equations, and inner products. In <em>EUROCRYPT</em>, pages 146&ndash;162, 2008.</p></li>
      <li><p class="text-gray-300">[LOS+10] Allison B. Lewko, Tatsuaki Okamoto, Amit Sahai, Katsuyuki Takashima, and Brent Waters. Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption. In <em>EUROCRYPT</em>, pages 62&ndash;91, 2010.</p></li>
      <li><p class="text-gray-300">[MRS88] Silvio Micali, Charles Rackoff, and Bob Sloan. The notion of security for probabilistic cryptosystems. <em>SIAM J. Comput.</em>, 17(2), 1988.</p></li>
      <li><p class="text-gray-300">[Nie02] Jesper Buus Nielsen. Separating random oracle proofs from complexity theoretic proofs: The non-committing encryption case. In <em>CRYPTO</em>, pages 111&ndash;126, 2002.</p></li>
      <li><p class="text-gray-300">[OT10] Tatsuaki Okamoto and Katsuyuki Takashima. Fully secure functional encryption with general relations from the decisional linear assumption. In <em>CRYPTO</em>, pages 191&ndash;208, 2010.</p></li>
      <li><p class="text-gray-300">[SSW09] Emily Shen, Elaine Shi, and Brent Waters. Predicate privacy in encryption systems. In <em>TCC</em>, pages 457&ndash;473, 2009.</p></li>
      <li><p class="text-gray-300">[SW05] Amit Sahai and Brent Waters. Fuzzy identity-based encryption. In <em>EUROCRYPT</em>, pages 457&ndash;473, 2005.</p></li>
      <li><p class="text-gray-300">[Wat] Brent Waters. Functional encryption: Beyond public-key cryptography. Presentation available from http://userweb.cs.utexas.edu/bwaters.</p></li>
    </ul>

    </section>
`;
---

<BaseLayout title="Definitional Issues in Functional Encryption (2010/556)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2010 &middot; eprint 2010/556
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="definitional-issues-in-functional-encryption-2010" />
  </article>
</BaseLayout>
