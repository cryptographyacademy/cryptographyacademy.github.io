---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2010/556';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Definitional Issues in Functional Encryption';
const AUTHORS_HTML = 'Unknown authors';

const CONTENT = `    <h3 id="sec-1" class="text-xl font-semibold mt-8">Adam O'Neill<em>&lt;sup&gt;∗&lt;/sup&gt;</em></h3>

    <h4 id="sec-2" class="text-lg font-semibold mt-6"><strong>Abstract</strong></h4>

    <p class="text-gray-300">We provide a formalization of the emergent notion of &quot;functional encryption,&quot; as well as introduce various security notions for it, and study relations among the latter. In particular, we show that indistinguishability and semantic security based notions of security are <em>inequivalent</em> for functional encryption in general; in fact, &quot;adaptive&quot; indistinguishability does not even imply &quot;non-adaptive&quot; semantic security. This is alarming given the large body of work employing (special cases of) the former. We go on to show, however, that in the &quot;non-adaptive&quot; case an equivalence does hold between indistinguishability and semantic security for what we call <em>preimage sampleable</em> schemes. We take this as evidence that for preimage sampleable schemes an indistinguishability based notion may be acceptable in practice. We show that some common functionalities considered in the literature satisfy this requirement.</p>

    <h2 id="sec-3" class="text-2xl font-bold"><strong>1 Introduction</strong></h2>

    <p class="text-gray-300">Functional encryption. In recent years, a notion of &quot;functional encryption&quot; (FE) has emerged as a new paradigm for public-key encryption, wherein a receiver, given a ciphertext, is able to learn certain functions of the underlying message based on its secret keys (not necessarily the decryption). Special cases of FE include identity-based encryption [BF03], public-key encryption with keyword search [BCOP04, ABC+08], attribute-based encryption [SW05, GPSW06, BSW07], and predicate encryption [BW07, KSW08, LOS+10, OT10].&lt;sup&gt;1&lt;/sup&gt; However, a general study of FE and its security seems not to have appeared. Here we initiate one, and in doing so we uncover some interesting definitional issues that cause one to re-evaluate what exactly is being achieved by this body of work.</p>

    <p class="text-gray-300">Syntax and security notions. First we give a syntactic definition of FE, which extends that for predicate encryption introduced by Boneh and Waters [BW07]. We then formulate an &quot;indistinguishability based&quot; notion of privacy (IND), which again extends the security notion for predicate encryption introduced in [BW07]. Informally, the IND notion asks that it be hard for an adversary to distinguish between the encryptions of any two messages that agree on all the functions corresponding to the secret keys it requested. We go on to introduce a more complicated but more natural &quot;semantic security based&quot; (SS) notion of privacy in the spirit of the classical notion for public-key encryption [GM84], to capture the intuition that anything the adversary can compute from a ciphertext it could as well compute from the evaluations of the functions corresponding to</p>

    <p class="text-gray-300"><em>&lt;sup&gt;∗&lt;/sup&gt;</em>University of Texas at Austin. Work done in part while the author was a Ph.D. student at Georgia Institute of Technology.</p>

    <p class="text-gray-300">&lt;sup&gt;1&lt;/sup&gt;We do not mean here to claim credit for the general concept of functional encryption and its generalizing these primitives; indeed, this view was present in prior work (e.g., [SW05, BW07, KSW08]) and in a talk by Waters [Wat].</p>

    <p class="text-gray-300">the secret keys it requested on underlying message. We note that a novel feature of our definitions, which turns out to be important when considering relations among them, is that they distinguish between <em>adaptive</em> and <em>non-adaptive</em> access to the secret-key derivation oracle to aid in the adversary's task (roughly, this distinction is analogous to that between access to the decryption oracle in adaptive versus non-adaptive chosen-ciphertext attack, see e.g. [BDPR98]).</p>

    <p class="text-gray-300">Relations among security notions. In the classical setting of public-key encryption, semantic security and indistinguishability based formulations of security are well-known to be equivalent [MRS88]. We ask whether the same is true for FE. Surprisingly, we show that IND under adaptive access to the secret-key derivation oracle does not imply SS even under <em>non-adaptive</em> such access. To see why, consider a functional encryption scheme for a single function <em>f</em>. But suppose there is another function <em>g</em> that has the same &quot;equality pattern&quot; as <em>f</em> on the message space (i.e., two messages have the same <em>f</em>-value just when they have the same <em>g</em>-value). Furthermore, suppose <em>g</em>(<em>m</em>) is hard to compute given <em>f</em>(<em>m</em>). Now, if the functional encryption scheme is such that the secret keys created by the scheme, which are supposed to allow computing <em>f</em>, also allow computing <em>g</em>, the scheme is certainly not semantically secure. However, an IND adversary is &quot;bound&quot; to choosing messages that agree on <em>f</em>, hence also on <em>g</em>, and so cannot use computing <em>g</em> to its advantage. Our counter-example formalizes and generalizes this intuition. Another shortcoming of the IND notion we observe is that it is essentially vacuous&lt;sup&gt;2&lt;/sup&gt; for some functions, such as a collision-resistant hash function. Then, it is hard for the adversary to find two messages that agree on the function.</p>

    <p class="text-gray-300">Achievability. Finally, we ask the question of whether the SS notion for FE is <em>achievable</em>. In particular, we note that achieving SS under adaptive access to the key derivation oracle seems difficult. In the proof, the simulator seemingly must choose a &quot;dummy&quot; ciphertext on which to run the adversary <em>before</em> knowing what values the challenge message should have when evaluated under the functions for which the adversary will later request secret keys. Intuitively, this means the number of possible keys for a given function should at least be as large as the number of possible outputs of the latter. This situation is reminiscent of that for (non-interactive) non-committing encryption, for which impossiblity results are known [Nie02]. However, it is unclear to us how to formalize this connection since there could be other proof techniques.</p>

    <p class="text-gray-300">We do, however, obtain positive results in the case of <em>non-adaptive</em> SS. Here we identify a key property of functional encryption schemes that we call <em>preimage sampleability</em>. Intuitively, this means that, given the function values of some underlying message, it should always be possible to efficiently find <em>some</em> message consistent with them. We show that for preimage sampleable FE schemes, IND is <em>equivalent</em> to SS (both under non-adaptive access to the key-derivation oracle). (Thus, for non-adaptive securiy our above-mentioned counter-example is tight.) One reason we believe this is important is that non-adaptive SS suffices to rule out the &quot;pathological&quot; examples of schemes we gave that meet IND but not SS.&lt;sup&gt;3&lt;/sup&gt; We take this as evidence that, for preimage sampleable schemes, IND (under adaptive access to the key-derivation oracle) may be acceptable in practice. We conclude by showing that some common function classes considered in the literature, including the powerful inner-product predicates realized in [KSW08, LOS+10, OT10], are preimage sampleable.</p>

    <p class="text-gray-300">&lt;sup&gt;2&lt;/sup&gt;At least, it is vacuous with respect to attacks that require the adversary to query its key derivation oracle; i.e., attacks where the adversary actually uses the secret keys. A functional encryption scheme may of course already not be semantically secure in the classical sense.</p>

    <p class="text-gray-300">&lt;sup&gt;3&lt;/sup&gt;On the other hand, it is possible to extend them to even more extreme examples that violate SS only under adaptive access to the key-derivation oracle, but these start to really stretch plausibility.</p>

    <p class="text-gray-300">Concurrent and independent work. Independently of our work, Boneh et al. [BSW11] also undertake a general study of FE. In particular they give a syntactic definition as well as indistinguishability and semantic security based formulations of privacy. They also give a counter-example showing that IND does not imply SS.&lt;sup&gt;4&lt;/sup&gt; They also formalize the connection between SS under adaptive access to the key derivation oracle (although they do not distinguish between adaptive versus non-adaptive here) and non-committing encryption, showing via an argument in the style of [Nie02] that the former is not achievable at all without (programmable) random oracles but is achievable in the random oracle model. We feel this further highlights the importance of our results on the (standard model) achievability of non-adaptive SS.</p>

    <p class="text-gray-300">In another concurrent and independent work, Chase and Kamara [CK10] introduced and studied a notion of &quot;structural encryption,&quot; which they observe is similar to FE except that it is in the symmetric-key setting and secret keys &quot;work&quot; for only one specific ciphertext on which the former is dependent. They employ a semantic security based definition of security and also note a connection to non-committing encryption, namely that under their definition secret keys should be as long as the number of possible outputs of the associated function. Note that the reason that Boneh et al. [BSW11] obtain an impossibility result for FE is that a secret key must work for <em>all</em> ciphertexts.</p>

    <p class="text-gray-300">We define the syntax of functional encryption and various security notions for it.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8"><strong>2.1 Syntax</strong></h3>

    <p class="text-gray-300">A <em>functional encryption scheme</em> for the class of PT functions (aka. functionality) <em>F</em> on message-space Σ (both of which implicitly depend on <em>k</em>) is a tuple of algorithms <em>FE</em> = (Setup<em>,</em>KDer<em>,</em> Enc<em>,</em> Eval) such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>•</em> Setup on input 1<em>&lt;sup&gt;k&lt;/sup&gt;</em> outputs a <em>master public key pk</em> and <em>master secret key sk</em>.</li>
      <li><em>•</em> KDer on input the master secret key <em>sk</em> and a (description of a) function <em>f ∈ F</em> outputs an <em>evaluation token</em> (aka. secret key) <em>sk&lt;sup&gt;f&lt;/sup&gt;</em> for <em>f</em>.</li>
      <li><em>•</em> Enc on input a public key <em>pk</em> and a message (aka. attribute) <em>m ∈</em> Σ outputs a ciphertext <em>c</em>.</li>
      <li><em>•</em> Eval on input an evaluation token <em>sk&lt;sup&gt;f&lt;/sup&gt;</em> and a ciphertext <em>c</em> outputs a string <em>y</em> or <em>⊥</em>.</li>
    </ul>

    <p class="text-gray-300">For correctness we require that for all <em>k ∈</em> N, all <em>f ∈ F</em>, and all <em>m ∈</em> Σ,</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Eval}(sk_f,\\mathsf{Enc}(pk,m)) = f(m)</span>$</p>

    <p class="text-gray-300">with probability 1 over (<em>pk,sk</em>) $ <em>←</em> Setup(1<em>&lt;sup&gt;k&lt;/sup&gt;</em> ) and <em>sk&lt;sup&gt;f&lt;/sup&gt;</em> $ <em>←</em> KDer(<em>sk, f</em>).</p>

    <p class="text-gray-300">Note that this notion is in particular a generalization of identity-based encryption (IBE) [BF03], public-key encryption with keyword search (PEKS) [BCOP04, ABC+08], attribute-based encryption (ABE) [SW05, GPSW06, BSW07], and predicate encryption (PE) [BW07, KSW08, LOS+10, OT10]. For example, in the case of identity-based encryption, the &quot;message&quot; would consist of the identity concatenated with the actual payload, and the secret key would be associated with the function <em>fID</em>(<em>ID′∥x</em>) = <em>x</em> if <em>ID</em> = <em>ID′</em> and <em>⊥</em> otherwise.</p>

    <p class="text-gray-300">&lt;sup&gt;4&lt;/sup&gt;Our counter-example is slightly more general. In particular, we observe a separation even for schemes (such as those proposed in the literature) where the adversary can find two messages that agree on the functions corresponding to the secret keys it requested.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">2.2 Security Definitions</h4>

    <p class="text-gray-300">We present various formulations of privacy for functional encryption. Broadly, the definitions are either <em>indistinguishability based</em> or <em>semantic-security based</em>. In each case we also define a <em>token non-adaptive</em> (TNA) variant, where the adversary gets access to a token derivation oracle only before it sees the challenge ciphertext.</p>

    <p class="text-gray-300">Regarding special cases, we note that our security notions yield the <em>anonymous</em> (aka. attribute-hiding) versions of IBE, ABE, and PE, where the identity or attribute is hidden by the ciphertext (or their &quot;predicate-only&quot; counterparts following the terminology of [KSW08]). The contemporaneous work of [BSW11] provides a more general and comprehensive treatment.</p>

    <p class="text-gray-300">INDISTINGUISHABILITY BASED PRIVACY. The indistinguishability-based formulation follows [BW07] and tries to capture the intuition that the adversary is unable to distinguish between the encryptions of two different messages that it cannot trivially distinguish using its tokens. Let  <span class="math">\\mathcal{FE} = (\\text{Setup}, \\text{KDer}, \\text{Enc}, \\text{Eval})</span>  be a functional encryption scheme for the class of functions  <span class="math">\\mathcal{F}</span>  over message-space  <span class="math">\\Sigma</span>  and let  <span class="math">A = (A_1, A_2)</span>  be an adversary. For mode  <span class="math">\\in \\{\\text{full}, \\text{tna}\\}</span>  and  <span class="math">k \\in \\mathbb{N}</span>  we associate to  <span class="math">\\mathcal{FE}</span>  and A the experiments</p>

    <p class="text-gray-300">Experiment Exp
<span class="math">$^{\\text{ind-mode}}_{\\mathcal{F}\\mathcal{E},A}(k)</span>$
:
<span class="math">b \\overset{\\</span>}{\\leftarrow} {0,1}$
<span class="math">(pk,sk) \\overset{\\</span>}{\\leftarrow} \\text{Setup}(1^k)$
<span class="math">(m_0,m_1,st) \\overset{\\</span>}{\\leftarrow} A_1^{\\text{KDer}(sk,\\cdot)}(pk)$
<span class="math">c \\overset{\\</span>}{\\leftarrow} \\text{Enc}(pk,m_b)$
<span class="math">b&#x27; \\overset{\\</span>}{\\leftarrow} A_2^{\\mathcal{O}(sk,\\cdot)}(pk,c,st)$
If  <span class="math">b = b&#x27;</span>  return 1 also return 0</p>

    <p class="text-gray-300">where if mode = full then  <span class="math">\\mathcal{O}(sk,\\cdot) = \\mathsf{KDer}(sk,\\cdot)</span>  and if mode = tna then  <span class="math">\\mathcal{O}(sk,\\cdot) = \\varepsilon</span>  (the empty oracle). We require that  <span class="math">|m_0| = |m_1|</span>  and every query f that  <span class="math">A_1</span>  or  <span class="math">A_2</span>  makes to its oracle satisfies  <span class="math">f(m_0) = f(m_1)</span> . Denote by  <span class="math">\\Pr\\left[\\mathbf{Exp}_{\\mathcal{F}\\mathcal{E},A}^{\\mathrm{ind-mode}}(k) = 1\\right]</span>  the probability that the corresponding IND-MODE experiment outputs 1, and define</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{ind\\text{-}mode}}_{\\mathcal{FE},A}(k) = 2 \\cdot \\Pr \\left[ \\left. \\mathbf{Exp}^{\\mathrm{ind\\text{-}mode}}_{\\mathcal{FE},A}(k) = 1 \\right. \\right] - 1 \\; .</span>$</p>

    <p class="text-gray-300">We say that  <span class="math">\\mathcal{FE}</span>  is IND-MODE secure if  <span class="math">\\mathbf{Adv}^{\\mathrm{ind\\text{-}mode}}_{\\mathcal{FE},A}(\\cdot)</span>  is negligible for all PPT adversaries A.</p>

    <p class="text-gray-300">SEMANTIC-SECURITY BASED PRIVACY. The semantic-security formulation is new and tries to capture the intuition that anything the adversary can compute from a ciphertext and the tokens it can compute from the tokens and the values of the corresponding functions on the underlying message. Let  <span class="math">\\mathcal{FE} = (\\text{Setup}, \\text{KDer}, \\text{Enc}, \\text{Eval})</span>  be a functional encryption scheme for the class of functions  <span class="math">\\mathcal{F}</span>  over message-space  <span class="math">\\Sigma</span> , let  <span class="math">A = (A_1, A_2, A_3)</span>  be an adversary, let S be a simulator. For mode  <span class="math">\\in \\{\\text{full}, \\text{tna}\\}</span>  and  <span class="math">k \\in \\mathbb{N}</span>  we associate to  <span class="math">\\mathcal{FE}</span> , A, and S the experiments</p>

    <p class="text-gray-300">&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;5&lt;/sup&gt;We stress that our use of the terminology &quot;full&quot; security differs from the literature in that it refers to adaptive access to the key derivation oracle rather than adaptive choice of the challenge messages.</p>

    <pre><code class="language-text"> \\begin{array}{c|ccccccccccccccccccccccccccccccccccc
</code></pre>

    <p class="text-gray-300">where if mode = full then  <span class="math">\\mathcal{O}(sk,\\cdot) = \\mathsf{KDer}(sk,\\cdot)</span>  and for any f oracle  <span class="math">\\mathcal{O}&#x27;(sk,f)</span>  returns  <span class="math">(sk_f, f(m))</span>  where  <span class="math">sk_f \\leftarrow \\mathsf{KDer}(sk,f)</span> , and if mode = tna then  <span class="math">\\mathcal{O}(sk,\\cdot) = \\mathcal{O}&#x27;(sk,\\cdot) = \\varepsilon</span>  (the empty oracle). We assume for simplicity that  <span class="math">A_1</span> 's output (the state st) includes its oracle queries and the responses and that |m| in  <span class="math">A_2</span> 's output depends only on k. Think of the string  <span class="math">t \\in \\{0,1\\}^*</span>  in the output of  <span class="math">A_2</span>  as partial information on m. Note that in the above formalization of semantic security, even in the ideal experiment we run  <span class="math">A_1</span>  and  <span class="math">A_2</span> . A more standard formalization would have the simulator also run at these stages. However, we want to &quot;bind&quot; the simulator to making the same key derivation queries as the adversary. Denote by  <span class="math">\\Pr\\left[\\mathbf{Exp}_{\\mathcal{FE},A}^{\\mathrm{ss-real-mode}}(k) = 1\\right]</span>  the probability that the SS-REAL-MODE experiment outputs 1 and by  <span class="math">\\Pr\\left[\\mathbf{Exp}_{\\mathcal{FE},A,S}^{\\mathrm{ss-ideal-mode}}(k) = 1\\right]</span>  the probability that the SS-IDEAL-MODE experiment outputs 1. Define</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\text{ss-mode}}_{\\mathcal{FE},A,S}(k) = \\Pr \\left[ \\left. \\mathbf{Exp}^{\\text{ss-real-mode}}_{\\mathcal{FE},A}(k) = 1 \\right. \\right] - \\Pr \\left[ \\left. \\mathbf{Exp}^{\\text{ss-ideal-mode}}_{\\mathcal{FE},A,S}(k) = 1 \\right. \\right] \\ .</span>$</p>

    <p class="text-gray-300">We say that  <span class="math">\\mathcal{FE}</span>  is SS-MODE secure if for every PPT adversary A there exists a PPT simulator S such that  <span class="math">\\mathbf{Adv}_{\\mathcal{FE},A,S}^{\\mathrm{ss-mode}}(\\cdot)</span>  is negligible.</p>

    <p class="text-gray-300">We investigate relations among the notions of security we introduced for FE. First, we note that when giving the adversary adaptive access to the token derivation oracle (i.e., what we call FULL security), one reason semantic security seems stronger than indistinguishability is that the simulator apparently needs to commit to a &quot;dummy&quot; ciphertext on which to run the adversary before knowing what values the challenge message should have when evaluated under the functions for which the adversary will later request tokens.</p>

    <p class="text-gray-300">But we show that there is actually a more subtle reason for inequivalence of the definitions. In fact, we show that in general IND-FULL security does not even imply SS-TNA security. To show the separation we start with a IND-FULL secure functional encryption scheme for any class of functions  <span class="math">\\mathcal{F}</span>  of a certain form. We then modify it to construct a new scheme that is still IND-FULL secure for  <span class="math">\\mathcal{F}</span>  but not SS-TNA secure. We show the latter by presenting a concrete attack. We first describe a concept our counter-example scheme employs.</p>

    <p class="text-gray-300">&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;6&lt;/sup&gt;We do not consider a notion of function hiding (cf. [SSW09]).</p>

    <p class="text-gray-300">&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;7&lt;/sup&gt;On the other hand, in the case of FULL security this is not enforced by the definition. This was an oversight on our part that was not noticed until after seeing [BSW11], so we do not correct it here (all our results anyway concern the non-adaptive case). As in [BSW11] one could require that S and  <span class="math">A_3</span>  have the same query distribution. Other differences between the SS definition of [BSW11] and ours include: theirs considers only adaptive access to the key derivation oracle whereas ours distinguishes between adaptive and non-adaptive, and theirs considers the encryption of multiple messages whereas ours considers only a single message (in particular, the former is important for the proof of impossibility they give for meeting their notion without random oracles).</p>

    <p class="text-gray-300">HIDDEN FUNCTIONS. Let  <span class="math">\\mathcal{G} = \\{g_k\\}_{k \\in \\mathbb{N}}</span>  and  <span class="math">\\mathcal{F} = \\{f_k\\}_{k \\in \\mathbb{N}}</span>  be families of functions on a common domain D = D(k). We say  <span class="math">\\mathcal{G}</span>  is hidden by  <span class="math">\\mathcal{F}</span>  if any PPT adversary A on inputs  <span class="math">f_k</span> ,  <span class="math">f_k(x)</span>  where  <span class="math">x \\stackrel{\\</span>}{\\leftarrow} D$  outputs  <span class="math">g_k(x)</span>  with only negligible probability in k. Note that such functions can be constructed under standard assumptions; for example, let  <span class="math">f_k</span>  be a one-way function applied to the first half of the bits of the input and let  <span class="math">g_k</span>  just output these bits (that is, the first half of the bits of the input). We say  <span class="math">\\mathcal{F}</span>  and  <span class="math">\\mathcal{G}</span>  are isomorphic if  <span class="math">f_k</span>  and  <span class="math">g_k</span>  are isomorphic for every k, meaning</p>

    <p class="text-gray-300"><span class="math">$f_k(d_1) = f_k(d_2) \\Leftrightarrow g_k(d_1) = g_k(d_2)</span>$
.</p>

    <p class="text-gray-300">for all  <span class="math">d_1, d_2 \\in D</span> . In other words,  <span class="math">f_k</span>  and  <span class="math">g_k</span>  have the same equality pattern across the domain. This is the case, for example, if  <span class="math">f_k</span>  in the example above is an <em>injective</em> one-way function on the first half of the input bits. We supress dependence on k below for convenience, just talking of functions rather than function families.</p>

    <p class="text-gray-300">The counter-example scheme. Let  <span class="math">\\mathcal{AE}^* = (\\mathsf{KDer}^*, \\mathsf{Enc}^*, \\mathsf{Dec}^*)</span>  be a (standard) public-key encryption scheme, and let  <span class="math">\\mathcal{FE}&#x27; = (\\mathsf{Setup}&#x27;, \\mathsf{KDer}&#x27;, \\mathsf{Enc}&#x27;, \\mathsf{Eval}&#x27;)</span>  be a functional encryption scheme over message-space  <span class="math">\\Sigma</span>  for a class of functions  <span class="math">\\mathcal{F} = \\{f_1, \\ldots, f_n\\}</span>  satisfying the following: there is a function g on  <span class="math">\\Sigma</span>  such that the pointwise concatenated function g is isomorphic to g and moreover g is hidden by f. (For simplicity, we assume here that g is polynomial in g. The counter-example can easily be extended to larger function sets by instead requiring the forgoing condition on some fixed g subset of the g such that g is polynomial in g condition on some fixed g subset of the g such that g is polynomial in g such that g is polynomial in g such that g is polynomial in g such that g is polynomial in g such that g is polynomial in g such that g is polynomial in g is polynomial.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Setup on input  <span class="math">1^k</span>  first runs  <span class="math">(pk&#x27;, sk&#x27;) \\stackrel{\\</span>}{\\leftarrow} \\mathsf{Setup'}(1^k)$ , and  <span class="math">(pk^*, sk^*) \\stackrel{\\</span>}{\\leftarrow} \\mathsf{KDer}^<em>(1^k)$ . It then selects  <span class="math">w_1, \\ldots, w_{n-1} \\stackrel{\\</span>}{\\leftarrow} {0, 1}^{|sk^</em>|}$  and computes  <span class="math">w_n \\leftarrow sk^* \\oplus w_1 \\oplus \\cdots \\oplus w_{n-1}</span> . Finally, it returns master public key  <span class="math">pk = pk&#x27; \\| pk^*</span>  and master secret key  <span class="math">sk = sk&#x27; \\| w_1 \\| \\ldots \\| w_n</span> .</li>
      <li>KDer on input the master secret key  <span class="math">sk = sk&#x27; ||w_1|| \\dots ||w_k|</span>  and a (description of a) function  <span class="math">f_i \\in \\mathcal{F}</span>  first runs  <span class="math">\\mathsf{KDer}&#x27;_{sk&#x27;}(f_i)</span>  to obtain  <span class="math">sk&#x27;_{f_i}</span> . Then, it outputs  <span class="math">sk_{f_i} = sk&#x27;_{f_i} ||w_i|</span> .</li>
      <li>Enc on input the master public key  <span class="math">pk = pk&#x27; \\| pk^*</span>  and a message  <span class="math">m \\in \\Sigma</span>  first computes  <span class="math">c&#x27; \\stackrel{\\</span>}{\\leftarrow} \\operatorname{Enc}'(pk', m)$  and  <span class="math">c^* \\stackrel{\\</span>}{\\leftarrow} \\operatorname{Enc}^<em>(pk^</em>, g(m))$ . It returns  <span class="math">c&#x27; \\| c^*</span> .</li>
      <li>Eval on input a secret key  <span class="math">sk_{f_i} = sk&#x27;_{f_i} || w_i</span>  and a ciphertext  <span class="math">c = c&#x27; || c^*</span>  computes  <span class="math">d \\leftarrow \\text{Eval}&#x27;(sk&#x27;_{f_i}, c&#x27;)</span> , and outputs d.</li>
    </ul>

    <p class="text-gray-300"><strong>Theorem 3.1</strong> If  <span class="math">\\mathcal{AE}^*</span>  is IND-CPA secure and  <span class="math">\\mathcal{FE}&#x27;</span>  is IND-FULL secure for  <span class="math">\\mathcal{F} = \\{f_1, \\ldots, f_n\\}</span>  as above (i.e., where g is hidden by  <span class="math">f_1 \\| \\ldots \\| f_n</span> ), then  <span class="math">\\mathcal{FE}</span>  is also IND-FULL secure for  <span class="math">\\mathcal{F}</span> . However, it is not SS-TNA secure.</p>

    <p class="text-gray-300">Note that the assumptions of the theorem do not constitute any additional complexity assumptions beyond the (minimal) one of  <span class="math">\\mathcal{FE}&#x27;</span>  being IND-FULL secure for  <span class="math">\\mathcal{F}</span> , meaning based on the latter we can construct the other schemes and functions that are assumed.</p>

    <p class="text-gray-300">We also remark that the separation also holds in the case of &quot;selective-security,&quot; where the challenge messages are chosen up-front by the adversary, as considered in e.g. [BW07, KSW08]. It</p>

    <p class="text-gray-300">&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;8&lt;/sup&gt;Indeed, a simpler example is to take  <span class="math">f_k</span>  to be a one-way function and  <span class="math">g_k</span>  to be the identity. However, in our counter-example this will prevent the adversary from even being able to <em>find</em> two messages that agree on  <span class="math">f_k</span> . We believe this points to a separate shortcoming of the IND definition.</p>

    <p class="text-gray-300">&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;9&lt;/sup&gt;By pointwise concatenation f || g of functions f and g on a set D we mean that f || g(x) = f(x) || g(x) for all  <span class="math">x \\in D</span> .</p>

    <p class="text-gray-300">also holds in the case of predicate encryption [BW07, KSW08], since we can take  <span class="math">f_i</span>  for  <span class="math">1 \\le i \\le n</span>  to output the <em>i</em>-th bit of a function f such that g is hidden by f (i.e., a function can always be decomposed bit-wise into predicates).</p>

    <p class="text-gray-300"><strong>Proof:</strong> (Sketch.) To see  <span class="math">\\mathcal{FE}</span>  is IND-FULL secure for  <span class="math">\\mathcal{F}</span> , first consider an adversary A that does not request tokens for all of  <span class="math">f_1, \\ldots, f_n</span> . Then in addition to interacting with  <span class="math">\\mathcal{FE}&#x27;</span>  in the IND-FULL experiment, the adversary is just given additional random strings when it requests tokens, which in particular are independent of b, so security of  <span class="math">\\mathcal{FE}</span>  follows from that of  <span class="math">\\mathcal{FE}&#x27;</span> . Now consider A that requests tokens for all of  <span class="math">f_1, \\ldots, f_n</span> . In this case, in addition to interacting with  <span class="math">\\mathcal{FE}&#x27;</span>  the adversary obtains  <span class="math">g(m_b)</span>  where  <span class="math">m_b</span>  is the challenge message. But by the rules of the experiment we know that  <span class="math">f_1(m_0) \\| \\ldots \\| f_n(m_0) = f_1(m_1) \\| \\ldots \\| f_n(m_1)</span>  and thus by assumption  <span class="math">g(m_0) = g(m_1)</span> , meaning again this information is independent of b and so IND security of  <span class="math">\\mathcal{FE}</span>  follows from that of  <span class="math">\\mathcal{FE}&#x27;</span> .</p>

    <p class="text-gray-300">To show that  <span class="math">\\mathcal{FE}</span>  is not SS-TNA secure, we describe an SS-TNA adversary  <span class="math">B = (B_1, B_2, B_3)</span>  for which there is no simulator with comparable probability of guessing t = t'. Namely,  <span class="math">B_1</span>  requests evaluation tokens for all of  <span class="math">f_1, \\ldots f_n</span>  and passes them along as the state, and  <span class="math">B_2</span>  chooses a random challenge message  <span class="math">m \\in \\Sigma</span> , sets  <span class="math">t \\leftarrow g(m)</span> , and outputs (m, t). Then, by construction  <span class="math">B_3</span>  can always output t = t' by decrypting the part of the challenge ciphertext formed by  <span class="math">\\mathcal{AE}^*</span>  (note that  <span class="math">B_3</span>  makes no queries itself as required). However, a simulator who outputs t = t' with non-negligible probability would contradict the fact that g is hidden by f since the simulator is not given any ciphertext but just the value of  <span class="math">f_1(m) \\| \\ldots \\| f_n(m)</span>  (also  <span class="math">p_k</span>  and the evaluation tokens for  <span class="math">f_1, \\ldots, f_n</span> , but a hidden function adversary can generate these itself).</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">4 An Equivalence under Preimage Sampleability</h3>

    <p class="text-gray-300">We show that for token non-adaptive (TNA) security the counter-example in Section 3 is tight. Namely, we show an <em>equivalence</em> between indistinguishability and semantic-security under TNA security for what we call <em>preimage sampleable</em> (PS) schemes. Note that TNA security seems reasonable in practical applications where what tokens a party receives does not depend on the encrypted messages.</p>

    <p class="text-gray-300">PREIMAGE SAMPLEABILITY. Let  <span class="math">\\mathcal{FE} = (\\text{Setup}, \\text{KDer}, \\text{Enc}, \\text{Eval})</span>  be a functional encryption scheme over message-space  <span class="math">\\Sigma</span>  for the class of functions  <span class="math">\\mathcal{F}</span> . We call  <span class="math">\\mathcal{FE}</span>  preimage sampleable (PS) if there is a PPT algorithm A such that, for every PPT algorithm B, the probability that the following experiment returns 0 is negligible in k:</p>

    <pre><code class="language-text">Experiment \\operatorname{Exp}_{\\mathcal{FE},A,B}^{ps}(k):
(m, f_1, \\dots, f_\\ell) \\overset{\\$}{\\leftarrow} B(1^k)
m&#x27; \\overset{\\$}{\\leftarrow} A(1^k, |m|, f_1(m), \\dots, f_\\ell(m))
If |m| = |m&#x27;| and f_i(m&#x27;) = f_i(m) for all 1 \\leq i \\leq \\ell
Then return 1
Else return 0
</code></pre>

    <p class="text-gray-300">Above, we require that  <span class="math">m, m&#x27; \\in \\Sigma</span>  and  <span class="math">f_1, \\ldots, f_\\ell \\in \\mathcal{F}</span> .</p>

    <p class="text-gray-300">We make a few remarks about our definition of preimage sampleability. First, we note that the inputs to A are always guaranteed to be consistent with <em>some</em> underlying m (and thus there is always at least one possible m' causing the PS experiment to return 1); on inputs that do</p>

    <p class="text-gray-300">not satisfy this requirement we do not need the output of <em>A</em> to be defined. We also note that preimage sampleability as we have defined it is really a property of <em>F</em> and we sometimes refer to it as such. Finally, requiring that the inputs to <em>A</em> be generated by another PPT algorithm (rather than quantifying over all such inputs) is important to leave open the possibility of PS for some functionalities, such as 3-CNF formulae. (The latter point was brought to our attention by De Caro and Fiore [CF].)</p>

    <p class="text-gray-300">In essence, we show that preimage sampleability provides a &quot;test&quot; of whether equivalence between the IND and SS definitions is maintained in the case of TNA security.</p>

    <p class="text-gray-300"><strong>Theorem 4.1</strong> Let <em>FE</em> be an PS functional encryption scheme. Then <em>FE</em> is SS-TNA secure if and only if it is IND-TNA secure.</p>

    <p class="text-gray-300"><strong>Proof:</strong> (Sketch.) (SS-TNA <em>⇒</em> IND-TNA) Suppose that <em>FE</em> is <em>not</em> IND-TNA secure, in particular let <em>A</em> = (<em>A</em>1<em>, A</em>2) be a successful IND-TNA adversary against it. Consider SS-TNA adversary <em>B</em> = (<em>B</em>1<em>, B</em>2<em>, B</em>3) that works as follows. <em>B</em>&lt;sup&gt;1&lt;/sup&gt; runs <em>A</em>&lt;sup&gt;1&lt;/sup&gt; on <em>pk</em> (answering key-derivation queries using its own oracle) to receive (<em>m</em>0<em>, m</em>1). It then chooses <em>b ∈ {</em>0<em>,</em> 1<em>}</em> at random and returns (<em>mb, b</em>). <em>B</em>&lt;sup&gt;3&lt;/sup&gt; runs <em>A</em>&lt;sup&gt;2&lt;/sup&gt; on its input and outputs the result. Note that no SS-TNA simulator can output <em>b</em> with probability better than 1<em>/</em>2 in the SS-TNA-IDEAL experiment because the simulator gets no information about <em>b</em> (since according to the rules of the IND-TNA experiment <em>A</em> may only makes token-derivation queries whose responses are independent of <em>b</em>, and the simulator makes no queries). So <em>FE</em> is not SS-TNA secure.</p>

    <p class="text-gray-300">(IND-TNA <em>⇒</em> SS-TNA) Now suppose <em>FE is</em> IND-TNA secure. Let <em>A</em> = (<em>A</em>1<em>, A</em>2<em>, A</em>3) be any SS-TNA adversary against <em>FE</em>. We construct a simulator <em>S</em> with comparable success probability in the SS-IDEAL-TNA experiment to <em>A</em> in the SS-REAL-TNA experiment, which implies <em>FE</em> is SS-TNA secure. Simulator <em>S</em> works as follows: given queries <em>f</em>1<em>, . . . , f&lt;sup&gt;q&lt;/sup&gt;</em> made by <em>A</em>&lt;sup&gt;1&lt;/sup&gt; and their values <em>y</em>1<em>, . . . , y&lt;sup&gt;q&lt;/sup&gt;</em> on the challenge message <em>m</em>, <em>S</em> will sample a &quot;dummy&quot; message <em>m′ ∈</em> Σ such that <em>f</em>1(<em>m′</em> ) = <em>y</em>1<em>, . . . , fq</em>(<em>m′</em> ) = <em>y&lt;sup&gt;q&lt;/sup&gt;</em> using the sampler <em>A</em> guaranteed by the definition of PS. (Here <em>B</em> in the definition of PS can be viewed as the entire experiment up to this point.) It runs <em>A</em>&lt;sup&gt;3&lt;/sup&gt; on the encryption of <em>m′</em> and outputs the result. There are two cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>•</em> <strong>Case 1:</strong> <em>m</em> = <em>m′</em> with overwhelming probability. Then <em>A</em>3's success probability in the simulated environment remains negligibly different from the SS-TNA-REAL experiment.</li>
      <li><em>•</em> <strong>Case 2:</strong> <em>m ̸</em>= <em>m′</em> with non-negligible probability. Then if <em>A</em>3's success probability also differs noticeably, we can construct a successful IND-TNA adversary <em>B</em> = (<em>B</em>1<em>, B</em>2) against <em>FE</em>, as follows. <em>B</em>&lt;sup&gt;1&lt;/sup&gt; first runs <em>A</em>1<em>, A</em>&lt;sup&gt;2&lt;/sup&gt; on the appropriate inputs to receive (<em>m, t</em>). Let <em>f</em>1<em>, . . . , f&lt;sup&gt;q&lt;/sup&gt;</em> be the queries made by <em>A</em>1. Using the sampler guaranteed by the definition of PS, <em>B</em>&lt;sup&gt;1&lt;/sup&gt; samples a message <em>m′</em> such that <em>f</em>1(<em>m′</em> ) = <em>f</em>1(<em>m</em>)<em>, . . . , fq</em>(<em>m′</em> ) = <em>fq</em>(<em>m</em>), and returns (<em>m, m′ , t</em>) (i.e., <em>m</em> and <em>m′</em> are the challenge messages and <em>t</em> is the state). <em>B</em>&lt;sup&gt;2&lt;/sup&gt; runs <em>A</em>&lt;sup&gt;3&lt;/sup&gt; on <em>pk, c</em> from its input to recieve output <em>t ′</em> ; if <em>t ′</em> = <em>t</em> it returns 0, and otherwise 1. Note that for <em>B</em> to be successful it is important that <em>m ̸</em>= <em>m′</em> , which holds with non-negligible probability in this case. This contradicts our initial assumption that <em>FE</em> is IND-TNA secure.</li>
    </ul>

    <p class="text-gray-300">Thus in either case the success probability of <em>S</em> is close to that of <em>A</em>.</p>

    <p class="text-gray-300">It is interesting to note how the proof of the second implication accounts for the fact that IND-TNA may be &quot;vacuously&quot; satisfied when the adversary is not able to find two messages that agree on the given functionality. Indeed, in this case, our simulator samples from the corresponding preimage set of size 1, and thus the simulation trivially works.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">5 On Preimage Sampleability of Some Functionalities</h3>

    <p class="text-gray-300">We examine whether specific functionalities considered in the literature satisfy our PS condition. For inner-product predicates [KSW08, LOS&lt;sup&gt;+&lt;/sup&gt;10, OT10], IBE [BF03], and PEKS [BCOP04, ABC&lt;sup&gt;+&lt;/sup&gt;08], we show that the answer is &quot;yes.&quot; On the other hand, for ABE [SW05, GPSW06, BSW07] it seems hard to show PS; we leave this as an open problem.</p>

    <p class="text-gray-300">INNER-PRODUCTS. We first show that PS is satisfied by the important class of inner-product predicates realized in prior work [KSW08, LOS&lt;sup&gt;+&lt;/sup&gt;10, OT10]. Hence, by Theorem 4.1, schemes in the literature for this functionality proven secure relative to the IND notion also meet SS, at least under non-adaptive access to the token-derivation oracle. Namely, consider the evaluation of inner products over  <span class="math">\\mathbb{Z}_N</span>  for a composite N (of which it assumed hard to find a non-trivial factor; here N is generated by the PS experiment before being given to B, A). More formally, let  <span class="math">n \\in \\mathbb{N}</span>  be given and let N be such a composite. Let  <span class="math">\\Sigma = \\mathbb{Z}_N^n</span>  and define the associated class of inner-product predicates  <span class="math">\\mathcal{P}_{iprod} = \\{p_{\\mathbf{x}} \\mid \\mathbf{x} \\in \\mathbb{Z}_N^n\\}</span>  where  <span class="math">p_{\\mathbf{x}}(\\mathbf{y}) = 1</span>  if  <span class="math">\\langle \\mathbf{x}, \\mathbf{y} \\rangle = \\sum_{i=1}^n x_i \\cdot y_i = 0 \\mod N</span> , and 0 otherwise. (Note that in the terminology of [KSW08] we thus consider the &quot;predicate-only&quot; version of the scheme for simplicity.)</p>

    <p class="text-gray-300"><strong>Proposition 5.1</strong> The class  <span class="math">\\mathcal{P}_{iprod}</span>  as defined above is PS if it is hard to find a non-trivial factor of N.</p>

    <p class="text-gray-300"><strong>Proof:</strong> (Sketch.) We construct a PPT algorithm A that on input  <span class="math">(\\mathbf{x}_1, y_1 = p_{\\mathbf{x}_1}(\\mathbf{m})), \\dots, (\\mathbf{x}_r, y_r = p_{\\mathbf{x}_r}(\\mathbf{m}))</span>  for any polynomial r = r(k) and any  <span class="math">p_{\\mathbf{x}_1}, \\dots, p_{\\mathbf{x}_r} \\in \\mathcal{P}_{iprod}</span>  and  <span class="math">\\mathbf{m} \\in \\Sigma</span> , outputs a vector  <span class="math">\\mathbf{m}&#x27;</span>  causing the PS experiment to return 1 with overwhelming probability. (Here we just refer to the probability over A's own coins.) Let  <span class="math">I_b</span>  denote the set  <span class="math">\\{i \\in [r] \\mid y_i = b\\}</span>  for  <span class="math">b \\in \\{0, 1\\}</span> , and let B be the  <span class="math">|I_1| \\times n</span>  matrix where each row is a unique element of  <span class="math">\\{\\mathbf{x}_i \\mid i \\in I_1\\}</span> .</p>

    <p class="text-gray-300">Algorithm A works as follows. It first finds a basis  <span class="math">W = \\{\\mathbf{w}_1, \\dots, \\mathbf{w}_s\\}</span>  for  <span class="math">\\ker(B)</span>  in the space  <span class="math">\\mathbb{Z}_N^n</span> . This is done by solving the homogeneous system of equations  <span class="math">B\\mathbf{x} = \\mathbf{0}</span>  using Gaussian elimination over  <span class="math">\\mathbb{Z}_N</span> ; while  <span class="math">\\mathbb{Z}_N</span>  is not a field, if Gaussian elimination fails then A can find a non-trivial factor of N. It outputs a random  <span class="math">\\mathbb{Z}_N</span> -combination of the vectors in W. That is, it outputs  <span class="math">\\mathbf{m}&#x27; = r_1\\mathbf{w}_1 + \\ldots + r_s\\mathbf{w}_s</span>  where each  <span class="math">r_i \\in \\mathbb{Z}_N</span>  for  <span class="math">1 \\le j \\le s</span>  is chosen independently at random.</p>

    <p class="text-gray-300">For the analysis, we need to show that with overwhelming probability  <span class="math">\\langle \\mathbf{m}&#x27;, \\mathbf{x}_i \\rangle = 0 \\mod N</span>  for all  <span class="math">i \\in I_1</span>  and  <span class="math">\\langle \\mathbf{m}&#x27;, \\mathbf{x}_j \\rangle \\neq 0 \\mod N</span>  for all  <span class="math">j \\in I_0</span> . The first part is clear by construction. For the second part, we first claim that for every fixed  <span class="math">j \\in I_0</span> , the probability over the choice of  <span class="math">r_1, \\ldots, r_s \\in \\mathbb{Z}_N</span>  that  <span class="math">\\langle \\mathbf{m}&#x27;, \\mathbf{x}_j \\rangle = 0 \\mod N</span>  is negligible. To see this, observe that there must be some (not necessarily unique)  <span class="math">\\mathbf{w}_{i(j)} \\in W</span>  such that  <span class="math">\\langle \\mathbf{x}_j, \\mathbf{w}(j) \\rangle \\neq 0 \\mod N</span> , since otherwise there would be no  <span class="math">\\mathbf{m}&#x27;</span>  causing the PS experiment to return 1. So, given any outcome of the  <span class="math">r_i</span>  for  <span class="math">i \\neq i(j)</span>  and assuming  <span class="math">\\langle \\mathbf{x}_j, \\mathbf{w}(j) \\rangle</span>  is not a zero-divisor (otherwise A can find a non-trivial factor of N), there is exactly one possible choice for  <span class="math">r_{i(j)}</span>  such that  <span class="math">\\langle \\mathbf{m}&#x27;, \\mathbf{x}_j \\rangle = 0 \\mod N</span> . Now, by a union bound, the probability that  <span class="math">\\langle \\mathbf{m}&#x27;, \\mathbf{x}_j \\rangle = 0 \\mod N</span>  for any  <span class="math">j \\in I_0</span>  is negligible, which is what we needed to show.</p>

    <p class="text-gray-300">IBE AND PEKS. The functionalities for IBE [BF03] and PEKS [BCOP04, ABC&lt;sup&gt;+&lt;/sup&gt;08] are also preimage sampleable. For example, in the case of IBE, given the functions and their values on the underlying &quot;message,&quot; there are two cases: if we know that <em>fID</em>(<em>ID′∥x</em>) = <em>x</em> then there is only one possible preimage, namely <em>ID∥x</em>; otherwise, we can sample from the set of possible &quot;messages&quot; by choosing an identity other than those for which the adversary has requested secret keys and any payload (an analogous argument applies in the case of PEKS). We omit the formal statements. By Theorem 4.1, we conclude that such schemes in the literature proven secure under an IND notion also meet SS-TNA under this condition.</p>

    <p class="text-gray-300">Attribute-based encryption. For the functionalities of ABE [SW05, GPSW06, BSW07], we do not know if PS holds. For example, consider the case of (anonymous) Fuzzy IBE [SW05, KSW08]. Namely, let <em>U</em> be a finite set and let Σ be the power-set of <em>U</em>, i.e., Σ = <em>{S | S ⊆ U}</em>. For 1 <em>≤ d ≤ |U|</em> and <em>S, T ⊆ U</em> define <em>pS,d</em>(<em>T</em>) = 1 if <em>S ∩ T ≥ d</em> and 0 otherwise. (As before, let us consider this &quot;predicate-only&quot; counterpart to Fuzzy IBE for simplicity.) Typically, one considers an FE scheme over Σ for the class <em>P&lt;sup&gt;d&lt;/sup&gt;</em> = <em>{pS,d | S ⊆ U}</em> where <em>d</em> is fixed. To show PS, we would basically need to give an efficient algorithm that, given &quot;good&quot; sets <em>G</em>1<em>, . . . G&lt;sup&gt;n&lt;/sup&gt; ⊆ U</em> and &quot;bad sets&quot; <em>B</em>&lt;sup&gt;1&lt;/sup&gt; <em>. . . , B&lt;sup&gt;m&lt;/sup&gt; ⊆ U</em> for polynomials <em>n</em> = <em>n</em>(<em>k</em>)<em>, m</em> = <em>m</em>(<em>k</em>), as well as <em>d</em> such that 1 <em>≤ d ≤ |U|</em>, outputs a set <em>X ⊆ U</em> such that <em>|X ∩ G&lt;sup&gt;i&lt;/sup&gt; | ≥ d</em> for all 1 <em>≤ i ≤ n</em> and <em>|X ∩ B&lt;sup&gt;j&lt;/sup&gt; | &lt; d</em> for all 1 <em>≤ j ≤ m</em>. We are not sure if such an algorithm exists and leave this for future work.</p>

    <p class="text-gray-300">We are very grateful to Alexandra Boldyreva for the initial conversations that led to this research, Mihir Bellare for discussions about the definitions and comments on the draft, and Nathan Chenette for discussions about preimage sampleability. We also thank Dario Fiore and Angelo De Caro for helpful feedback.</p>

    <h2 id="sec-8" class="text-2xl font-bold"><strong>References</strong></h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[ABC+08] Michel Abdalla, Mihir Bellare, Dario Catalano, Eike Kiltz, Tadayoshi Kohno, Tanja Lange, John Malone-Lee, Gregory Neven, Pascal Paillier, and Haixia Shi. Searchable encryption revisited: Consistency properties, relation to anonymous ibe, and extensions. <em>J. Cryptology</em>, 21(3):350–391, 2008.</p></li>
      <li><p class="text-gray-300">[BCOP04] Dan Boneh, Giovanni Di Crescenzo, Rafail Ostrovsky, and Giuseppe Persiano. Public key encryption with keyword search. In <em>EUROCRYPT</em>, pages 506–522, 2004.</p></li>
      <li><p class="text-gray-300">[BDPR98] Mihir Bellare, Anand Desai, David Pointcheval, and Phillip Rogaway. Relations among notions of security for public-key encryption schemes. In <em>CRYPTO</em>, pages 26–45, 1998.</p></li>
      <li><p class="text-gray-300">[BF03] Dan Boneh and Matthew K. Franklin. Identity-based encryption from the weil pairing. <em>SIAM J. Comput.</em>, 32(3), 2003.</p></li>
      <li><p class="text-gray-300">[BSW07] John Bethencourt, Amit Sahai, and Brent Waters. Ciphertext-policy attribute-based encryption. In <em>IEEE Symposium on Security and Privacy</em>, pages 321–334, 2007.</p></li>
      <li><p class="text-gray-300">[BSW11] Dan Boneh, Amit Sahai, and Brent Waters. Functional encryption: Definitions and challenges. In <em>TCC</em>, 2011.</p></li>
      <li><p class="text-gray-300">[BW07] Dan Boneh and Brent Waters. Conjunctive, subset, and range queries on encrypted data. In <em>TCC</em>, pages 535–554, 2007.</p></li>
      <li><p class="text-gray-300">[CF] Angelo De Caro and Dario Fiore. Personal correspondence, 2010.</p></li>
      <li><p class="text-gray-300">[CK10] Melissa Chase and Seny Kamara. Structured encryption and controlled disclosure. In <em>ASIACRYPT</em>, pages 577–594, 2010.</p></li>
      <li><p class="text-gray-300">[GM84] Shafi Goldwasser and Silvio Micali. Probabilistic encryption. <em>J. Comput. Syst. Sci.</em>, 28(2):270–299, 1984.</p></li>
      <li><p class="text-gray-300">[GPSW06] Vipul Goyal, Omkant Pandey, Amit Sahai, and Brent Waters. Attribute-based encryption for fine-grained access control of encrypted data. In <em>ACM Conference on Computer and Communications Security</em>, pages 89–98, 2006.</p></li>
      <li><p class="text-gray-300">[KSW08] Jonathan Katz, Amit Sahai, and Brent Waters. Predicate encryption supporting disjunctions, polynomial equations, and inner products. In <em>EUROCRYPT</em>, pages 146–162, 2008.</p></li>
      <li><p class="text-gray-300">[LOS+10] Allison B. Lewko, Tatsuaki Okamoto, Amit Sahai, Katsuyuki Takashima, and Brent Waters. Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption. In <em>EUROCRYPT</em>, pages 62–91, 2010.</p></li>
      <li><p class="text-gray-300">[MRS88] Silvio Micali, Charles Rackoff, and Bob Sloan. The notion of security for probabilistic cryptosystems. <em>SIAM J. Comput.</em>, 17(2), 1988.</p></li>
      <li><p class="text-gray-300">[Nie02] Jesper Buus Nielsen. Separating random oracle proofs from complexity theoretic proofs: The non-committing encryption case. In <em>CRYPTO</em>, pages 111–126, 2002.</p></li>
      <li><p class="text-gray-300">[OT10] Tatsuaki Okamoto and Katsuyuki Takashima. Fully secure functional encryption with general relations from the decisional linear assumption. In <em>CRYPTO</em>, pages 191–208, 2010.</p></li>
      <li><p class="text-gray-300">[SSW09] Emily Shen, Elaine Shi, and Brent Waters. Predicate privacy in encryption systems. In <em>TCC</em>, pages 457–473, 2009.</p></li>
      <li><p class="text-gray-300">[SW05] Amit Sahai and Brent Waters. Fuzzy identity-based encryption. In <em>EUROCRYPT</em>, pages 457–473, 2005.</p></li>
      <li><p class="text-gray-300">[Wat] Brent Waters. Functional encryption: Beyond public-key cryptography. Presentation available from http://userweb.cs.utexas.edu/bwaters.</p></li>
    </ul>

`;
---

<BaseLayout title="Definitional Issues in Functional Encryption (2010/556)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2010 &middot; eprint 2010/556
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="definitional-issues-in-functional-encryption-2010" />
  </article>
</BaseLayout>
