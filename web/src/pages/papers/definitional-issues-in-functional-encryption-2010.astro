---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2010/556';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Definitional Issues in Functional Encryption';
const AUTHORS_HTML = 'Adam O&#x27;Neill';

const CONTENT = `    <p class="text-gray-300">Definitional Issues in Functional Encryption</p>

    <p class="text-gray-300">Adam O'Neill*</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">We provide a formalization of the emergent notion of “functional encryption,” as well as introduce various security notions for it, and study relations among the latter. In particular, we show that indistinguishability and semantic security based notions of security are inequivalent for functional encryption in general; in fact, “adaptive” indistinguishability does not even imply “non-adaptive” semantic security. This is alarming given the large body of work employing (special cases of) the former. We go on to show, however, that in the “non-adaptive” case an equivalence does hold between indistinguishability and semantic security for what we call preimage sampleable schemes. We take this as evidence that for preimage sampleable schemes an indistinguishability based notion may be acceptable in practice. We show that some common functionalities considered in the literature satisfy this requirement.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">FUNCTIONAL ENCRYPTION. In recent years, a notion of “functional encryption” (FE) has emerged as a new paradigm for public-key encryption, wherein a receiver, given a ciphertext, is able to learn certain functions of the underlying message based on its secret keys (not necessarily the decryption). Special cases of FE include identity-based encryption [BF03], public-key encryption with keyword search [BCOP04, ABC+08], attribute-based encryption [SW05, GPSW06, BSW07], and predicate encryption [BW07, KSW08, LOS+10, OT10]. However, a general study of FE and its security seems not to have appeared. Here we initiate one, and in doing so we uncover some interesting definitional issues that cause one to re-evaluate what exactly is being achieved by this body of work.</p>

    <p class="text-gray-300">SYNTAX AND SECURITY NOTIONS. First we give a syntactic definition of FE, which extends that for predicate encryption introduced by Boneh and Waters [BW07]. We then formulate an “indistinguishability based” notion of privacy (IND), which again extends the security notion for predicate encryption introduced in [BW07]. Informally, the IND notion asks that it be hard for an adversary to distinguish between the encryptions of any two messages that agree on all the functions corresponding to the secret keys it requested. We go on to introduce a more complicated but more natural “semantic security based” (SS) notion of privacy in the spirit of the classical notion for public-key encryption [GM84], to capture the intuition that anything the adversary can compute from a ciphertext it could as well compute from the evaluations of the functions corresponding to</p>

    <p class="text-gray-300">*University of Texas at Austin. Work done in part while the author was a Ph.D. student at Georgia Institute of Technology.</p>

    <p class="text-gray-300">1We do not mean here to claim credit for the general concept of functional encryption and its generalizing these primitives; indeed, this view was present in prior work (e.g., [SW05, BW07, KSW08]) and in a talk by Waters [Wat].</p>

    <p class="text-gray-300">the secret keys it requested on underlying message. We note that a novel feature of our definitions, which turns out to be important when considering relations among them, is that they distinguish between adaptive and non-adaptive access to the secret-key derivation oracle to aid in the adversary’s task (roughly, this distinction is analogous to that between access to the decryption oracle in adaptive versus non-adaptive chosen-ciphertext attack, see e.g. <em>[x1]</em>).</p>

    <p class="text-gray-300">Relations among security notions. In the classical setting of public-key encryption, semantic security and indistinguishability based formulations of security are well-known to be equivalent <em>[x12]</em>. We ask whether the same is true for FE. Surprisingly, we show that IND under adaptive access to the secret-key derivation oracle does not imply SS even under non-adaptive such access. To see why, consider a functional encryption scheme for a single function <span class="math">f</span>. But suppose there is another function <span class="math">g</span> that has the same “equality pattern” as <span class="math">f</span> on the message space (i.e., two messages have the same <span class="math">f</span>-value just when they have the same <span class="math">g</span>-value). Furthermore, suppose <span class="math">g(m)</span> is hard to compute given <span class="math">f(m)</span>. Now, if the functional encryption scheme is such that the secret keys created by the scheme, which are supposed to allow computing <span class="math">f</span>, also allow computing <span class="math">g</span>, the scheme is certainly not semantically secure. However, an IND adversary is “bound” to choosing messages that agree on <span class="math">f</span>, hence also on <span class="math">g</span>, and so cannot use computing <span class="math">g</span> to its advantage. Our counter-example formalizes and generalizes this intuition. Another shortcoming of the IND notion we observe is that it is essentially vacuous for some functions, such as a collision-resistant hash function. Then, it is hard for the adversary to find two messages that agree on the function.</p>

    <p class="text-gray-300">Achievability. Finally, we ask the question of whether the SS notion for FE is achievable. In particular, we note that achieving SS under adaptive access to the key derivation oracle seems difficult. In the proof, the simulator seemingly must choose a “dummy” ciphertext on which to run the adversary before knowing what values the challenge message should have when evaluated under the functions for which the adversary will later request secret keys. Intuitively, this means the number of possible keys for a given function should at least be as large as the number of possible outputs of the latter. This situation is reminiscent of that for (non-interactive) non-committing encryption, for which impossiblity results are known <em>[x16]</em>. However, it is unclear to us how to formalize this connection since there could be other proof techniques.</p>

    <p class="text-gray-300">We do, however, obtain positive results in the case of non-adaptive SS. Here we identify a key property of functional encryption schemes that we call preimage sampleability. Intuitively, this means that, given the function values of some underlying message, it should always be possible to efficiently find some message consistent with them. We show that for preimage sampleable FE schemes, IND is equivalent to SS (both under non-adaptive access to the key-derivation oracle). (Thus, for non-adaptive securiy our above-mentioned counter-example is tight.) One reason we believe this is important is that non-adaptive SS suffices to rule out the “pathological” examples of schemes we gave that meet IND but not SS. We take this as evidence that, for preimage sampleable schemes, IND (under adaptive access to the key-derivation oracle) may be acceptable in practice. We conclude by showing that some common function classes considered in the literature, including the powerful inner-product predicates realized in <em>[x11, LOS^{+}10, x10]</em>, are preimage sampleable.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Concurrent and independent work. Independently of our work, Boneh et al. [BSW11] also undertake a general study of FE. In particular they give a syntactic definition as well as indistinguishability and semantic security based formulations of privacy. They also give a counter-example showing that IND does not imply SS. They also formalize the connection between SS under adaptive access to the key derivation oracle (although they do not distinguish between adaptive versus non-adaptive here) and non-committing encryption, showing via an argument in the style of [Nie02] that the former is not achievable at all without (programmable) random oracles but is achievable in the random oracle model. We feel this further highlights the importance of our results on the (standard model) achievability of non-adaptive SS.</p>

    <p class="text-gray-300">In another concurrent and independent work, Chase and Kamara [CK10] introduced and studied a notion of “structural encryption,” which they observe is similar to FE except that it is in the symmetric-key setting and secret keys “work” for only one specific ciphertext on which the former is dependent. They employ a semantic security based definition of security and also note a connection to non-committing encryption, namely that under their definition secret keys should be as long as the number of possible outputs of the associated function. Note that the reason that Boneh et al. [BSW11] obtain an impossibility result for FE is that a secret key must work for <em>all</em> ciphertexts.</p>

    <h2 id="sec-1" class="text-2xl font-bold">2 Functional Encryption and its Security</h2>

    <p class="text-gray-300">We define the syntax of functional encryption and various security notions for it.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">2.1 Syntax</h3>

    <p class="text-gray-300">A <em>functional encryption scheme</em> for the class of PT functions (aka. functionality) <span class="math">\\mathcal{F}</span> on message-space <span class="math">\\Sigma</span> (both of which implicitly depend on <span class="math">k</span>) is a tuple of algorithms <span class="math">\\mathcal{F}\\mathcal{E}=(\\mathsf{Setup},\\mathsf{KDer},\\mathsf{Enc},\\mathsf{Eval})</span> such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}</span> on input <span class="math">1^{k}</span> outputs a <em>master public key</em> <span class="math">pk</span> and <em>master secret key</em> <span class="math">sk</span>.</li>

      <li><span class="math">\\mathsf{KDer}</span> on input the master secret key <span class="math">sk</span> and a (description of a) function <span class="math">f\\in\\mathcal{F}</span> outputs an <em>evaluation token</em> (aka. secret key) <span class="math">sk_{f}</span> for <span class="math">f</span>.</li>

      <li><span class="math">\\mathsf{Enc}</span> on input a public key <span class="math">pk</span> and a message (aka. attribute) <span class="math">m\\in\\Sigma</span> outputs a ciphertext <span class="math">c</span>.</li>

      <li><span class="math">\\mathsf{Eval}</span> on input an evaluation token <span class="math">sk_{f}</span> and a ciphertext <span class="math">c</span> outputs a string <span class="math">y</span> or <span class="math">\\bot</span>.</li>

    </ul>

    <p class="text-gray-300">For correctness we require that for all <span class="math">k\\in\\mathbb{N}</span>, all <span class="math">f\\in\\mathcal{F}</span>, and all <span class="math">m\\in\\Sigma</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Eval}(sk_{f},\\mathsf{Enc}(pk,m))=f(m)</span></p>

    <p class="text-gray-300">with probability <span class="math">1</span> over <span class="math">(pk,sk)\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathsf{Setup}(1^{k})<span class="math"> and </span>sk_{f}\\stackrel{{\\scriptstyle\\<span class="math">}}{{\\leftarrow}}\\mathsf{KDer}(sk,f)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that this notion is in particular a generalization of identity-based encryption (IBE) [BF03], public-key encryption with keyword search (PEKS) [BCOP04, ABC^{+}08], attribute-based encryption (ABE) [SW05, GPSW06, BSW07], and predicate encryption (PE) [BW07, KSW08, LOS^{+}10, OT10]. For example, in the case of identity-based encryption, the “message” would consist of the identity concatenated with the actual payload, and the secret key would be associated with the function $f_{ID}(ID^{\\prime}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x)=x<span class="math"> if </span>ID=ID^{\\prime}<span class="math"> and </span>\\bot$ otherwise.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">4</p>

    <h2 id="sec-3" class="text-2xl font-bold">2.2 Security Definitions</h2>

    <p class="text-gray-300">We present various formulations of privacy for functional encryption. Broadly, the definitions are either indistinguishability based or semantic-security based. In each case we also define a token non-adaptive (TNA) variant, where the adversary gets access to a token derivation oracle only before it sees the challenge ciphertext.</p>

    <p class="text-gray-300">Regarding special cases, we note that our security notions yield the anonymous (aka. attribute-hiding) versions of IBE, ABE, and PE, where the identity or attribute is hidden by the ciphertext (or their “predicate-only” counterparts following the terminology of [KSW08]). The contemporaneous work of [BSW11] provides a more general and comprehensive treatment.</p>

    <p class="text-gray-300"><strong>INDISTINGUISHABILITY BASED PRIVACY.</strong> The indistinguishability-based formulation follows [BW07] and tries to capture the intuition that the adversary is unable to distinguish between the encryptions of two different messages that it cannot trivially distinguish using its tokens. Let <span class="math">\\mathcal{F}\\mathcal{E} = (\\mathsf{Setup},\\mathsf{KDer},\\mathsf{Enc},\\mathsf{Eval})</span> be a functional encryption scheme for the class of functions <span class="math">\\mathcal{F}</span> over message-space <span class="math">\\Sigma</span> and let <span class="math">A = (A_{1},A_{2})</span> be an adversary. For mode <span class="math">\\in \\{\\mathrm{full},\\mathrm{tna}\\}^5</span> and <span class="math">k\\in \\mathbb{N}</span> we associate to <span class="math">\\mathcal{F}\\mathcal{E}</span> and <span class="math">A</span> the experiments</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{c} \\text{Experiment } \\operatorname{Exp}_{\\mathcal{F}\\mathcal{E},A}^{\\text{ind-mode}}(k): \\\\ b \\stackrel{\\S}{\\leftarrow} \\{0,1\\} \\\\ (pk,sk) \\stackrel{\\S}{\\leftarrow} \\operatorname{Setup}(1^k) \\\\ (m_0, m_1, st) \\stackrel{\\S}{\\leftarrow} A_1^{\\mathsf{KDer}(sk,:)}(pk) \\\\ c \\stackrel{\\S}{\\leftarrow} \\mathsf{Enc}(pk, m_b) \\\\ b&#x27; \\stackrel{\\S}{\\leftarrow} A_2^{\\mathcal{O}(sk,:)}(pk, c, st) \\\\ \\text{If } b = b&#x27; \\text{ return 1 else return 0} \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where if mode = full then <span class="math">\\mathcal{O}(sk,\\cdot) = \\mathsf{KDer}(sk,\\cdot)</span> and if mode = tna then <span class="math">\\mathcal{O}(sk,\\cdot) = \\varepsilon</span> (the empty oracle). We require that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and every query </span>f<span class="math"> that </span>A_{1}<span class="math"> or </span>A_{2}<span class="math"> makes to its oracle satisfies </span>f(m_0) = f(m_1)<span class="math">. Denote by </span>\\operatorname*{Pr}\\left[\\mathbf{Exp}_{\\mathcal{F}\\mathcal{E},A}^{\\mathrm{ind - mode}}(k) = 1\\right]$ the probability that the corresponding IND-MODE experiment outputs 1, and define</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Adv}_{\\mathcal{F}\\mathcal{E},A}^{\\text{ind-mode}}(k) = 2 \\cdot \\operatorname*{Pr}\\left[\\mathbf{Exp}_{\\mathcal{F}\\mathcal{E},A}^{\\text{ind-mode}}(k) = 1\\right] - 1.</span></div>

    <p class="text-gray-300">We say that <span class="math">\\mathcal{F}\\mathcal{E}</span> is IND-MODE secure if <span class="math">\\mathbf{Adv}_{\\mathcal{F}\\mathcal{E},A}^{\\mathrm{ind - mode}}(\\cdot)</span> is negligible for all PPT adversaries <span class="math">A</span>.</p>

    <p class="text-gray-300"><strong>SEMANTIC-SECURITY BASED PRIVACY.</strong> The semantic-security formulation is new and tries to capture the intuition that anything the adversary can compute from a ciphertext and the tokens it can compute from the tokens and the values of the corresponding functions on the underlying message. Let <span class="math">\\mathcal{F}\\mathcal{E} = (\\mathsf{Setup},\\mathsf{KDer},\\mathsf{Enc},\\mathsf{Eval})</span> be a functional encryption scheme for the class of functions <span class="math">\\mathcal{F}</span> over message-space <span class="math">\\Sigma</span>, let <span class="math">A = (A_{1},A_{2},A_{3})</span> be an adversary, let <span class="math">S</span> be a simulator. For mode <span class="math">\\in \\{\\mathrm{full},\\mathrm{tna}\\}</span> and <span class="math">k\\in \\mathbb{N}</span> we associate to <span class="math">\\mathcal{F}\\mathcal{E}</span>, <span class="math">A</span>, and <span class="math">S</span> the experiments</p>

    <p class="text-gray-300">5We stress that our use of the terminology “full” security differs from the literature in that it refers to adaptive access to the key derivation oracle rather than adaptive choice of the challenge messages.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Experiment ExpS-real-mode(k):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Experiment ExpS-ideal-mode(k):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(pk,sk)← Setup(1k)</td>

            <td class="px-3 py-2 border-b border-gray-700">(pk,sk)← Setup(1k)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">st← A1KDer(sk,·)(pk)</td>

            <td class="px-3 py-2 border-b border-gray-700">st← A1KDer(sk,·)(pk)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(m,t)← A2(pk,st)</td>

            <td class="px-3 py-2 border-b border-gray-700">(m,t)← A2(pk,st)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">c← Enc(pk,m)</td>

            <td class="px-3 py-2 border-b border-gray-700">Let f1,...,fq be the queries made by A1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t'← A3O(sk,·)(pk,c,st)</td>

            <td class="px-3 py-2 border-b border-gray-700">t'← S'O'(sk,·)(pk,f1(m),...,fq(m),st)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">If t=t' return 1 else return 0</td>

            <td class="px-3 py-2 border-b border-gray-700">If t=t' return 1 else return 0</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where if mode = full then  <span class="math">\\mathcal{O}(sk,\\cdot) = \\mathsf{KDer}(sk,\\cdot)</span>  and for any  <span class="math">f</span>  oracle  <span class="math">\\mathcal{O}&#x27;(sk,f)</span>  returns  <span class="math">(sk_f,f(m))</span>  where  <span class="math">sk_{f}\\stackrel {\\S}{\\leftarrow}\\mathsf{KDer}(sk,f)</span> , and if mode = tna then  <span class="math">\\mathcal{O}(sk,\\cdot) = \\mathcal{O}&#x27;(sk,\\cdot) = \\varepsilon</span>  (the empty oracle). We assume for simplicity that  <span class="math">A_{1}</span> 's output (the state  <span class="math">st</span> ) includes its oracle queries and the responses and that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  in  </span>A_{2}<span class="math"> &#x27;s output depends only on  </span>k<span class="math"> . Think of the string  </span>t\\in \\{0,1\\}^<em><span class="math">  in the output of  </span>A_{2}<span class="math">  as partial information on  </span>m<span class="math"> . Note that in the above formalization of semantic security, even in the ideal experiment we run  </span>A_{1}<span class="math">  and  </span>A_{2}<span class="math"> . A more standard formalization would have the simulator also run at these stages. However, we want to &quot;bind&quot; the simulator to making the same key derivation queries as the adversary. Denote by  </span>\\operatorname</em>{Pr}\\left[\\mathbf{Exp}_{\\mathcal{F}\\mathcal{E},A}^{\\mathrm{ss - real - mode}}(k) = 1\\right]<span class="math">  the probability that the SS-REAL-MODE experiment outputs 1 and by  </span>\\operatorname*{Pr}\\left[\\mathbf{Exp}_{\\mathcal{F}\\mathcal{E},A,S}^{\\mathrm{ss - ideal - mode}}(k) = 1\\right]$  the probability that the SS-IDEAL-MODE experiment outputs 1. Define</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathcal {F E}, A, S} ^ {\\mathrm {s s - m o d e}} (k) = \\Pr \\left[ \\mathbf {E x p} _ {\\mathcal {F E}, A} ^ {\\mathrm {s s - r e a l - m o d e}} (k) = 1 \\right] - \\Pr \\left[ \\mathbf {E x p} _ {\\mathcal {F E}, A, S} ^ {\\mathrm {s s - i d e a l - m o d e}} (k) = 1 \\right].</span></div>

    <p class="text-gray-300">We say that  <span class="math">\\mathcal{F}\\mathcal{E}</span>  is SS-MODE secure if for every PPT adversary  <span class="math">A</span>  there exists a PPT simulator  <span class="math">S</span>  such that  <span class="math">\\mathbf{Adv}_{\\mathcal{F}\\mathcal{E},A,S}^{\\mathrm{ss - mode}}(\\cdot)</span>  is negligible.</p>

    <p class="text-gray-300">We investigate relations among the notions of security we introduced for FE. First, we note that when giving the adversary adaptive access to the token derivation oracle (i.e., what we call FULL security), one reason semantic security seems stronger than indistinguishability is that the simulator apparently needs to commit to a "dummy" ciphertext on which to run the adversary before knowing what values the challenge message should have when evaluated under the functions for which the adversary will later request tokens.</p>

    <p class="text-gray-300">But we show that there is actually a more subtle reason for inequivalence of the definitions. In fact, we show that in general IND-FULL security does not even imply SS-TNA security. To show the separation we start with a IND-FULL secure functional encryption scheme for any class of functions  <span class="math">\\mathcal{F}</span>  of a certain form. We then modify it to construct a new scheme that is still IND-FULL secure for  <span class="math">\\mathcal{F}</span>  but not SS-TNA secure. We show the latter by presenting a concrete attack. We first describe a concept our counter-example scheme employs.</p>

    <p class="text-gray-300">HIDDEN FUNCTIONS. Let <span class="math">\\mathcal{G} = \\{g_k\\}_{k\\in \\mathbb{N}}</span> and <span class="math">\\mathcal{F} = \\{f_k\\}_{k\\in \\mathbb{N}}</span> be families of functions on a common domain <span class="math">D = D(k)</span>. We say <span class="math">\\mathcal{G}</span> is hidden by <span class="math">\\mathcal{F}</span> if any PPT adversary <span class="math">A</span> on inputs <span class="math">f_{k},f_{k}(x)</span> where <span class="math">x\\stackrel {\\S}{\\leftarrow}D</span> outputs <span class="math">g_{k}(x)</span> with only negligible probability in <span class="math">k</span>. Note that such functions can be constructed under standard assumptions; for example, let <span class="math">f_{k}</span> be a one-way function applied to the first half of the bits of the input and let <span class="math">g_{k}</span> just output these bits (that is, the first half of the bits of the input). We say <span class="math">\\mathcal{F}</span> and <span class="math">\\mathcal{G}</span> are isomorphic if <span class="math">f_{k}</span> and <span class="math">g_{k}</span> are isomorphic for every <span class="math">k</span>, meaning</p>

    <div class="my-4 text-center"><span class="math-block">f _ {k} (d _ {1}) = f _ {k} (d _ {2}) \\Leftrightarrow g _ {k} (d _ {1}) = g _ {k} (d _ {2}).</span></div>

    <p class="text-gray-300">for all <span class="math">d_1, d_2 \\in D</span>. In other words, <span class="math">f_k</span> and <span class="math">g_k</span> have the same equality pattern across the domain. This is the case, for example, if <span class="math">f_k</span> in the example above is an injective one-way function on the first half of the input bits. We suppress dependence on <span class="math">k</span> below for convenience, just talking of functions rather than function families.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">THE COUNTER-EXAMPLE SCHEME. Let <span class="math">\\mathcal{A}\\mathcal{E}^<em> = (\\mathsf{KDer}^</em>,\\mathsf{Enc}^<em>,\\mathsf{Dec}^</em>)</span> be a (standard) public-key encryption scheme, and let <span class="math">\\mathcal{F}\\mathcal{E}&#x27; = (\\mathsf{Setup}&#x27;,\\mathsf{KDer}&#x27;,\\mathsf{Enc}&#x27;,\\mathsf{Eval}&#x27;)</span> be a functional encryption scheme over message-space <span class="math">\\Sigma</span> for a class of functions <span class="math">\\mathcal{F} = \\{f_1,\\ldots ,f_n\\}</span> satisfying the following: there is a function <span class="math">g</span> on <span class="math">\\Sigma</span> such that the pointwise concatenated function $f = f_{1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{n}<span class="math"> is isomorphic to </span>g<span class="math"> and moreover </span>g<span class="math"> is hidden by </span>f<span class="math">. (For simplicity, we assume here that </span>n<span class="math"> is polynomial in </span>k<span class="math">. The counter-example can easily be extended to larger function sets by instead requiring the forgoing condition on some fixed subset of the </span>f_{i}<span class="math">&#x27;s.) Then we define a new functional encryption scheme </span>\\mathcal{F}\\mathcal{E} = (\\mathsf{Setup},\\mathsf{KDer},\\mathsf{Enc},\\mathsf{Eval})<span class="math"> over </span>\\Sigma<span class="math"> for </span>\\mathcal{F}$ as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Setup on input <span class="math">1^{k}</span> first runs <span class="math">(pk&#x27;, sk&#x27;) \\stackrel{\\S}{\\leftarrow} \\mathsf{Setup}&#x27;(1^{k})</span>, and <span class="math">(pk^{<em>}, sk^{</em>}) \\stackrel{\\S}{\\leftarrow} \\mathsf{KDer}^{*}(1^{k})</span>. It then selects $w_{1}, \\ldots, w_{n-1} \\stackrel{\\S}{\\leftarrow} \\{0, 1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sk^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and computes </span>w_{n} \\gets sk^{*} \\oplus w_{1} \\oplus \\dots \\oplus w_{n-1}<span class="math">. Finally, it returns master public key </span>pk = pk' \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pk^{*}<span class="math"> and master secret key </span>sk = sk' \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w_{1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w_{n}$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Enc on input the master public key $pk = pk' \\</td>

            <td class="px-3 py-2 border-b border-gray-700">pk^<em><span class="math"> and a message </span>m \\in \\Sigma<span class="math"> first computes </span>c' \\stackrel{\\S}{\\leftarrow} \\mathsf{Enc}'(pk', m)<span class="math"> and </span>c^</em> \\stackrel{\\S}{\\leftarrow} \\mathsf{Enc}^<em>(pk^</em>, g(m))<span class="math">. It returns </span>c' \\</td>

            <td class="px-3 py-2 border-b border-gray-700">c^*$.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Eval on input a secret key $sk_{f_i} = sk_{f_i}' \\</td>

            <td class="px-3 py-2 border-b border-gray-700">w_i<span class="math"> and a ciphertext </span>c = c' \\</td>

            <td class="px-3 py-2 border-b border-gray-700">c^*<span class="math"> computes </span>d \\gets \\mathsf{Eval}'(sk_{f_i}', c')<span class="math">, and outputs </span>d$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 3.1 If <span class="math">\\mathcal{A}\\mathcal{E}^*</span> is IND-CPA secure and <span class="math">\\mathcal{F}\\mathcal{E}&#x27;</span> is IND-FULL secure for <span class="math">\\mathcal{F} = \\{f_1, \\ldots, f_n\\}</span> as above (i.e., where <span class="math">g</span> is hidden by $f_1 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_n<span class="math">), then </span>\\mathcal{F}\\mathcal{E}<span class="math"> is also IND-FULL secure for </span>\\mathcal{F}$. However, it is not SS-TNA secure.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that the assumptions of the theorem do not constitute any additional complexity assumptions beyond the (minimal) one of <span class="math">\\mathcal{F}\\mathcal{E}&#x27;</span> being IND-FULL secure for <span class="math">\\mathcal{F}</span>, meaning based on the latter we can construct the other schemes and functions that are assumed.</p>

    <p class="text-gray-300">We also remark that the separation also holds in the case of "selective-security," where the challenge messages are chosen up-front by the adversary, as considered in e.g. [BW07, KSW08]. It</p>

    <p class="text-gray-300">8Indeed, a simpler example is to take <span class="math">f_{k}</span> to be a one-way function and <span class="math">g_{k}</span> to be the identity. However, in our counter-example this will prevent the adversary from even being able to find two messages that agree on <span class="math">f_{k}</span>. We believe this points to a separate shortcoming of the IND definition.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9By pointwise concatenation $f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g<span class="math"> of functions </span>f<span class="math"> and </span>g<span class="math"> on a set </span>D<span class="math"> we mean that </span>f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g(x) = f(x)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g(x)<span class="math"> for all </span>x\\in D$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">also holds in the case of predicate encryption <em>[x1, x10]</em>, since we can take <span class="math">f_{i}</span> for <span class="math">1\\leq i\\leq n</span> to output the <span class="math">i</span>-th bit of a function <span class="math">f</span> such that <span class="math">g</span> is hidden by <span class="math">f</span> (i.e., a function can always be decomposed bit-wise into predicates).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof: (Sketch.) To see <span class="math">\\mathcal{F}\\mathcal{E}</span> is IND-FULL secure for <span class="math">\\mathcal{F}</span>, first consider an adversary <span class="math">A</span> that does not request tokens for all of <span class="math">f_{1},\\ldots,f_{n}</span>. Then in addition to interacting with <span class="math">\\mathcal{F}\\mathcal{E}^{\\prime}</span> in the IND-FULL experiment, the adversary is just given additional random strings when it requests tokens, which in particular are independent of <span class="math">b</span>, so security of <span class="math">\\mathcal{F}\\mathcal{E}</span> follows from that of <span class="math">\\mathcal{F}\\mathcal{E}^{\\prime}</span>. Now consider <span class="math">A</span> that requests tokens for all of <span class="math">f_{1},\\ldots,f_{n}</span>. In this case, in addition to interacting with <span class="math">\\mathcal{F}\\mathcal{E}^{\\prime}</span> the adversary obtains <span class="math">g(m_{b})</span> where <span class="math">m_{b}</span> is the challenge message. But by the rules of the experiment we know that $f_{1}(m_{0})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{n}(m_{0})=f_{1}(m_{1})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{n}(m_{1})<span class="math"> and thus by assumption </span>g(m_{0})=g(m_{1})<span class="math">, meaning again this information is independent of </span>b<span class="math"> and so IND security of </span>\\mathcal{F}\\mathcal{E}<span class="math"> follows from that of </span>\\mathcal{F}\\mathcal{E}^{\\prime}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To show that <span class="math">\\mathcal{F}\\mathcal{E}</span> is not SS-TNA secure, we describe an SS-TNA adversary <span class="math">B=(B_{1},B_{2},B_{3})</span> for which there is no simulator with comparable probability of guessing <span class="math">t=t^{\\prime}</span>. Namely, <span class="math">B_{1}</span> requests evaluation tokens for all of <span class="math">f_{1},\\ldots f_{n}</span> and passes them along as the state, and <span class="math">B_{2}</span> chooses a random challenge message <span class="math">m\\in\\Sigma</span>, sets <span class="math">t\\leftarrow g(m)</span>, and outputs <span class="math">(m,t)</span>. Then, by construction <span class="math">B_{3}</span> can always output <span class="math">t=t^{\\prime}</span> by decrypting the part of the challenge ciphertext formed by <span class="math">\\mathcal{A}\\mathcal{E}^{*}</span> (note that <span class="math">B_{3}</span> makes no queries itself as required). However, a simulator who outputs <span class="math">t=t^{\\prime}</span> with non-negligible probability would contradict the fact that <span class="math">g</span> is hidden by <span class="math">f</span> since the simulator is not given any ciphertext but just the value of $f_{1}(m)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{n}(m)<span class="math"> (also </span>pk<span class="math"> and the evaluation tokens for </span>f_{1},\\ldots,f_{n}$, but a hidden function adversary can generate these itself).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-5" class="text-2xl font-bold">4 An Equivalence under Preimage Sampleability</h2>

    <p class="text-gray-300">We show that for token non-adaptive (TNA) security the counter-example in Section 3 is tight. Namely, we show an <em>equivalence</em> between indistinguishability and semantic-security under TNA security for what we call <em>preimage sampleable</em> (PS) schemes. Note that TNA security seems reasonable in practical applications where what tokens a party receives does not depend on the encrypted messages.</p>

    <p class="text-gray-300">Preimage sampleability. Let <span class="math">\\mathcal{F}\\mathcal{E}=(\\mathsf{Setup},\\mathsf{KDer},\\mathsf{Enc},\\mathsf{Eval})</span> be a functional encryption scheme over message-space <span class="math">\\Sigma</span> for the class of functions <span class="math">\\mathcal{F}</span>. We call <span class="math">\\mathcal{F}\\mathcal{E}</span> <em>preimage sampleable</em> (PS) if there is a PPT algorithm <span class="math">A</span> such that, for every PPT algorithm <span class="math">B</span>, the probability that the following experiment returns <span class="math">0</span> is negligible in <span class="math">k</span>:</p>

    <p class="text-gray-300">Experiment <span class="math">\\mathbf{Exp}^{ps}_{\\mathcal{F}\\mathcal{E},A,B}(k)</span>:</p>

    <p class="text-gray-300"><span class="math">(m,f_{1},\\ldots,f_{\\ell})\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}B(1^{k})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$m^{\\prime}\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}A(1^{k},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,f_{1}(m),\\ldots,f_{\\ell}(m))$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>f_{i}(m^{\\prime})=f_{i}(m)<span class="math"> for all </span>1\\leq i\\leq\\ell$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then return <span class="math">1</span></p>

    <p class="text-gray-300">Else return <span class="math">0</span></p>

    <p class="text-gray-300">Above, we require that <span class="math">m,m^{\\prime}\\in\\Sigma</span> and <span class="math">f_{1},\\ldots,f_{\\ell}\\in\\mathcal{F}</span>.</p>

    <p class="text-gray-300">We make a few remarks about our definition of preimage sampleability. First, we note that the inputs to <span class="math">A</span> are always guaranteed to be consistent with <em>some</em> underlying <span class="math">m</span> (and thus there is always at least one possible <span class="math">m^{\\prime}</span> causing the PS experiment to return <span class="math">1</span>); on inputs that do</p>

    <p class="text-gray-300">not satisfy this requirement we do not need the output of <span class="math">A</span> to be defined. We also note that preimage sampleability as we have defined it is really a property of <span class="math">\\mathcal{F}</span> and we sometimes refer to it as such. Finally, requiring that the inputs to <span class="math">A</span> be generated by another PPT algorithm (rather than quantifying over all such inputs) is important to leave open the possibility of PS for some functionalities, such as 3-CNF formulae. (The latter point was brought to our attention by De Caro and Fiore <em>[x1]</em>.)</p>

    <p class="text-gray-300">In essence, we show that preimage sampleability provides a “test” of whether equivalence between the IND and SS definitions is maintained in the case of TNA security.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Theorem 4.1</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{F}\\mathcal{E}</span> be an PS functional encryption scheme. Then <span class="math">\\mathcal{F}\\mathcal{E}</span> is SS-TNA secure if and only if it is IND-TNA secure.</p>

    <p class="text-gray-300">Proof: (Sketch.) (SS-TNA <span class="math">\\Rightarrow</span> IND-TNA) Suppose that <span class="math">\\mathcal{F}\\mathcal{E}</span> is not IND-TNA secure, in particular let <span class="math">A=(A_{1},A_{2})</span> be a successful IND-TNA adversary against it. Consider SS-TNA adversary <span class="math">B=(B_{1},B_{2},B_{3})</span> that works as follows. <span class="math">B_{1}</span> runs <span class="math">A_{1}</span> on <span class="math">pk</span> (answering key-derivation queries using its own oracle) to receive <span class="math">(m_{0},m_{1})</span>. It then chooses <span class="math">b\\in\\{0,1\\}</span> at random and returns <span class="math">(m_{b},b)</span>. <span class="math">B_{3}</span> runs <span class="math">A_{2}</span> on its input and outputs the result. Note that no SS-TNA simulator can output <span class="math">b</span> with probability better than <span class="math">1/2</span> in the SS-TNA-IDEAL experiment because the simulator gets no information about <span class="math">b</span> (since according to the rules of the IND-TNA experiment <span class="math">A</span> may only makes token-derivation queries whose responses are independent of <span class="math">b</span>, and the simulator makes no queries). So <span class="math">\\mathcal{F}\\mathcal{E}</span> is not SS-TNA secure.</p>

    <p class="text-gray-300">(IND-TNA <span class="math">\\Rightarrow</span> SS-TNA) Now suppose <span class="math">\\mathcal{F}\\mathcal{E}</span> is IND-TNA secure. Let <span class="math">A=(A_{1},A_{2},A_{3})</span> be any SS-TNA adversary against <span class="math">\\mathcal{F}\\mathcal{E}</span>. We construct a simulator <span class="math">S</span> with comparable success probability in the SS-IDEAL-TNA experiment to <span class="math">A</span> in the SS-REAL-TNA experiment, which implies <span class="math">\\mathcal{F}\\mathcal{E}</span> is SS-TNA secure. Simulator <span class="math">S</span> works as follows: given queries <span class="math">f_{1},\\ldots,f_{q}</span> made by <span class="math">A_{1}</span> and their values <span class="math">y_{1},\\ldots,y_{q}</span> on the challenge message <span class="math">m</span>, <span class="math">S</span> will sample a “dummy” message <span class="math">m^{\\prime}\\in\\Sigma</span> such that <span class="math">f_{1}(m^{\\prime})=y_{1},\\ldots,f_{q}(m^{\\prime})=y_{q}</span> using the sampler <span class="math">A</span> guaranteed by the definition of PS. (Here <span class="math">B</span> in the definition of PS can be viewed as the entire experiment up to this point.) It runs <span class="math">A_{3}</span> on the encryption of <span class="math">m^{\\prime}</span> and outputs the result. There are two cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">m=m^{\\prime}</span> with overwhelming probability. Then <span class="math">A_{3}</span>’s success probability in the simulated environment remains negligibly different from the SS-TNA-REAL experiment.</li>

      <li>Case 2: <span class="math">m\\neq m^{\\prime}</span> with non-negligible probability. Then if <span class="math">A_{3}</span>’s success probability also differs noticeably, we can construct a successful IND-TNA adversary <span class="math">B=(B_{1},B_{2})</span> against <span class="math">\\mathcal{F}\\mathcal{E}</span>, as follows. <span class="math">B_{1}</span> first runs <span class="math">A_{1},A_{2}</span> on the appropriate inputs to receive <span class="math">(m,t)</span>. Let <span class="math">f_{1},\\ldots,f_{q}</span> be the queries made by <span class="math">A_{1}</span>. Using the sampler guaranteed by the definition of PS, <span class="math">B_{1}</span> samples a message <span class="math">m^{\\prime}</span> such that <span class="math">f_{1}(m^{\\prime})=f_{1}(m),\\ldots,f_{q}(m^{\\prime})=f_{q}(m)</span>, and returns <span class="math">(m,m^{\\prime},t)</span> (i.e., <span class="math">m</span> and <span class="math">m^{\\prime}</span> are the challenge messages and <span class="math">t</span> is the state). <span class="math">B_{2}</span> runs <span class="math">A_{3}</span> on <span class="math">pk,c</span> from its input to recieve output <span class="math">t^{\\prime}</span>; if <span class="math">t^{\\prime}=t</span> it returns <span class="math">0</span>, and otherwise <span class="math">1</span>. Note that for <span class="math">B</span> to be successful it is important that <span class="math">m\\neq m^{\\prime}</span>, which holds with non-negligible probability in this case. This contradicts our initial assumption that <span class="math">\\mathcal{F}\\mathcal{E}</span> is IND-TNA secure.</li>

    </ul>

    <p class="text-gray-300">Thus in either case the success probability of <span class="math">S</span> is close to that of <span class="math">A</span>.</p>

    <p class="text-gray-300">It is interesting to note how the proof of the second implication accounts for the fact that IND-TNA may be “vacuously” satisfied when the adversary is not able to find two messages that agree on the</p>

    <p class="text-gray-300">given functionality. Indeed, in this case, our simulator samples from the corresponding preimage set of size 1, and thus the simulation trivially works.</p>

    <h2 id="sec-7" class="text-2xl font-bold">5 On Preimage Sampleability of Some Functionalities</h2>

    <p class="text-gray-300">We examine whether specific functionalities considered in the literature satisfy our PS condition. For inner-product predicates <em>[x11, LOS^{+}10, x13]</em>, IBE <em>[x2]</em>, and PEKS <em>[x4, ABC^{+}08]</em>, we show that the answer is “yes.” On the other hand, for ABE <em>[x17, x10, x3]</em> it seems hard to show PS; we leave this as an open problem.</p>

    <p class="text-gray-300">Inner-products. We first show that PS is satisfied by the important class of <em>inner-product predicates</em> realized in prior work <em>[x11, LOS^{+}10, x13]</em>. Hence, by Theorem 4.1, schemes in the literature for this functionality proven secure relative to the IND notion also meet SS, at least under non-adaptive access to the token-derivation oracle. Namely, consider the evaluation of inner products over <span class="math">\\mathbb{Z}_{N}</span> for a composite <span class="math">N</span> (of which it assumed hard to find a non-trivial factor; here <span class="math">N</span> is generated by the PS experiment before being given to <span class="math">B,A</span>). More formally, let <span class="math">n\\in\\mathbb{N}</span> be given and let <span class="math">N</span> be such a composite. Let <span class="math">\\Sigma=\\mathbb{Z}_{N}^{n}</span> and define the associated class of <em>inner-product predicates</em> <span class="math">\\mathcal{P}_{iprod}=\\{p_{\\mathbf{x}}\\mid\\mathbf{x}\\in\\mathbb{Z}_{N}^{n}\\}</span> where <span class="math">p_{\\mathbf{x}}(\\mathbf{y})=1</span> if <span class="math">\\langle\\mathbf{x},\\mathbf{y}\\rangle=\\sum_{i=1}^{n}x_{i}\\cdot y_{i}=0\\bmod N</span>, and <span class="math">0</span> otherwise. (Note that in the terminology of <em>[x11]</em> we thus consider the “predicate-only” version of the scheme for simplicity.)</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Proposition 5.1</h6>

    <p class="text-gray-300">The class <span class="math">\\mathcal{P}_{iprod}</span> as defined above is PS if it is hard to find a non-trivial factor of <span class="math">N</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof: (Sketch.) We construct a PPT algorithm <span class="math">A</span> that on input <span class="math">(\\mathbf{x}_{1},y_{1}=p_{\\mathbf{x}_{1}}(\\mathbf{m})),\\ldots,(\\mathbf{x}_{r},y_{r}=p_{\\mathbf{x}_{r}}(\\mathbf{m}))</span> for any polynomial <span class="math">r=r(k)</span> and any <span class="math">p_{\\mathbf{x}_{1}},\\ldots,p_{\\mathbf{x}_{r}}\\in\\mathcal{P}_{iprod}</span> and <span class="math">\\mathbf{m}\\in\\Sigma</span>, outputs a vector <span class="math">\\mathbf{m}^{\\prime}</span> causing the PS experiment to return <span class="math">1</span> with overwhelming probability. (Here we just refer to the probability over <span class="math">A</span>’s own coins.) Let <span class="math">I_{b}</span> denote the set <span class="math">\\{i\\in[r]\\mid y_{i}=b\\}</span> for <span class="math">b\\in\\{0,1\\}</span>, and let <span class="math">B</span> be the $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times n<span class="math"> matrix where each row is a unique element of </span>\\{\\mathbf{x}_{i}\\mid i\\in I_{1}\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Algorithm <span class="math">A</span> works as follows. It first finds a basis <span class="math">W=\\{\\mathbf{w}_{1},\\ldots,\\mathbf{w}_{s}\\}</span> for <span class="math">\\ker(B)</span> in the space <span class="math">\\mathbb{Z}_{N}^{n}</span>. This is done by solving the homogeneous system of equations <span class="math">B\\mathbf{x=0}</span> using Gaussian elimination over <span class="math">\\mathbb{Z}_{N}</span>; while <span class="math">\\mathbb{Z}_{N}</span> is not a field, if Gaussian elimination fails then <span class="math">A</span> can find a non-trivial factor of <span class="math">N</span>. It outputs a random <span class="math">\\mathbb{Z}_{N}</span>-combination of the vectors in <span class="math">W</span>. That is, it outputs <span class="math">\\mathbf{m}^{\\prime}=r_{1}\\mathbf{w}_{1}+\\ldots+r_{s}\\mathbf{w}_{s}</span> where each <span class="math">r_{i}\\in\\mathbb{Z}_{N}</span> for <span class="math">1\\leq j\\leq s</span> is chosen independently at random.</p>

    <p class="text-gray-300">For the analysis, we need to show that with overwhelming probability <span class="math">\\langle\\mathbf{m}^{\\prime},\\mathbf{x}_{i}\\rangle=0\\bmod N</span> for all <span class="math">i\\in I_{1}</span> and <span class="math">\\langle\\mathbf{m}^{\\prime},\\mathbf{x}_{j}\\rangle\\neq 0\\bmod N</span> for all <span class="math">j\\in I_{0}</span> . The first part is clear by construction. For the second part, we first claim that for every <em>fixed</em> <span class="math">j\\in I_{0}</span>, the probablity over the choice of <span class="math">r_{1},\\ldots,r_{s}\\in\\mathbb{Z}_{N}</span> that <span class="math">\\langle\\mathbf{m}^{\\prime},\\mathbf{x}_{j}\\rangle=0\\bmod N</span> is negligible. To see this, observe that there must be <em>some</em> (not necessarily unique) <span class="math">\\mathbf{w}_{i(j)}\\in W</span> such that <span class="math">\\langle\\mathbf{x}_{j},\\mathbf{w}(j)\\rangle\\neq 0\\bmod N</span>, since otherwise there would be no <span class="math">\\mathbf{m}^{\\prime}</span> causing the PS experiment to return <span class="math">1</span>. So, given any outcome of the <span class="math">r_{i}</span> for <span class="math">i\\neq i(j)</span> and assuming <span class="math">\\langle\\mathbf{x}_{j},\\mathbf{w}(j)\\rangle</span> is not a zero-divisor (otherwise <span class="math">A</span> can find a non-trivial factor of <span class="math">N</span>), there is exactly <em>one</em> possible choice for <span class="math">r_{i(j)}</span> such that <span class="math">\\langle\\mathbf{m}^{\\prime},\\mathbf{x}_{j}\\rangle=0\\bmod N</span>. Now, by a union bound, the probability that <span class="math">\\langle\\mathbf{m}^{\\prime},\\mathbf{x}_{j}\\rangle=0\\bmod N</span> for <em>any</em> <span class="math">j\\in I_{0}</span> is negligible, which is what we needed to show.</p>

    <p class="text-gray-300">IBE and PEKS. The functionalities for IBE <em>[x2]</em> and PEKS <em>[x4, ABC^{+}08]</em> are also preimage sampleable. For example, in the case of IBE, given the functions and their values on the</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">underlying “message,” there are two cases: if we know that $f_{ID}(ID^{\\prime}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x)=x<span class="math"> then there is only one possible preimage, namely </span>ID\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x$; otherwise, we can sample from the set of possible “messages” by choosing an identity other than those for which the adversary has requested secret keys and any payload (an analogous argument applies in the case of PEKS). We omit the formal statements. By Theorem 4.1, we conclude that such schemes in the literature proven secure under an IND notion also meet SS-TNA under this condition.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Attribute-based encryption. For the functionalities of ABE <em>[x21, x10, x3]</em>, we do not know if PS holds. For example, consider the case of (anonymous) Fuzzy IBE <em>[x21, x15]</em>. Namely, let <span class="math">U</span> be a finite set and let <span class="math">\\Sigma</span> be the power-set of <span class="math">U</span>, i.e., <span class="math">\\Sigma=\\{S\\mid S\\subseteq U\\}</span>. For $1\\leq d\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>S,T\\subseteq U<span class="math"> define </span>p_{S,d}(T)=1<span class="math"> if </span>S\\cap T\\geq d<span class="math"> and </span>0<span class="math"> otherwise. (As before, let us consider this “predicate-only” counterpart to Fuzzy IBE for simplicity.) Typically, one considers an FE scheme over </span>\\Sigma<span class="math"> for the class </span>\\mathcal{P}_{d}=\\{p_{S,d}\\mid S\\subseteq U\\}<span class="math"> where </span>d<span class="math"> is fixed. To show PS, we would basically need to give an efficient algorithm that, given “good” sets </span>G_{1},\\ldots G_{n}\\subseteq U<span class="math"> and “bad sets” </span>B_{1}\\ldots,B_{m}\\subseteq U<span class="math"> for polynomials </span>n=n(k),m=m(k)<span class="math">, as well as </span>d<span class="math"> such that </span>1\\leq d\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, outputs a set </span>X\\subseteq U<span class="math"> such that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X\\cap G_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq d<span class="math"> for all </span>1\\leq i\\leq n<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X\\cap B_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt;d<span class="math"> for all </span>1\\leq j\\leq m$. We are not sure if such an algorithm exists and leave this for future work.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-9" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">We are very grateful to Alexandra Boldyreva for the initial conversations that led to this research, Mihir Bellare for discussions about the definitions and comments on the draft, and Nathan Chenette for discussions about preimage sampleability. We also thank Dario Fiore and Angelo De Caro for helpful feedback.</p>

    <h2 id="sec-10" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ABC^{+}08] Michel Abdalla, Mihir Bellare, Dario Catalano, Eike Kiltz, Tadayoshi Kohno, Tanja Lange, John Malone-Lee, Gregory Neven, Pascal Paillier, and Haixia Shi. Searchable encryption revisited: Consistency properties, relation to anonymous ibe, and extensions. J. Cryptology, 21(3):350–391, 2008.</li>

      <li>[BCOP04] Dan Boneh, Giovanni Di Crescenzo, Rafail Ostrovsky, and Giuseppe Persiano. Public key encryption with keyword search. In EUROCRYPT, pages 506–522, 2004.</li>

      <li>[BDPR98] Mihir Bellare, Anand Desai, David Pointcheval, and Phillip Rogaway. Relations among notions of security for public-key encryption schemes. In CRYPTO, pages 26–45, 1998.</li>

      <li>[BF03] Dan Boneh and Matthew K. Franklin. Identity-based encryption from the weil pairing. SIAM J. Comput., 32(3), 2003.</li>

      <li>[BSW07] John Bethencourt, Amit Sahai, and Brent Waters. Ciphertext-policy attribute-based encryption. In IEEE Symposium on Security and Privacy, pages 321–334, 2007.</li>

      <li>[BSW11] Dan Boneh, Amit Sahai, and Brent Waters. Functional encryption: Definitions and challenges. In TCC, 2011.</li>

    </ul>

    <p class="text-gray-300">[BW07] Dan Boneh and Brent Waters. Conjunctive, subset, and range queries on encrypted data. In TCC, pages 535–554, 2007.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CF] Angelo De Caro and Dario Fiore. Personal correspondence, 2010.</li>

      <li>[CK10] Melissa Chase and Seny Kamara. Structured encryption and controlled disclosure. In ASIACRYPT, pages 577–594, 2010.</li>

      <li>[GM84] Shafi Goldwasser and Silvio Micali. Probabilistic encryption. J. Comput. Syst. Sci., 28(2):270–299, 1984.</li>

      <li>[GPSW06] Vipul Goyal, Omkant Pandey, Amit Sahai, and Brent Waters. Attribute-based encryption for fine-grained access control of encrypted data. In ACM Conference on Computer and Communications Security, pages 89–98, 2006.</li>

      <li>[KSW08] Jonathan Katz, Amit Sahai, and Brent Waters. Predicate encryption supporting disjunctions, polynomial equations, and inner products. In EUROCRYPT, pages 146–162, 2008.</li>

      <li>[LOS^{+}10] Allison B. Lewko, Tatsuaki Okamoto, Amit Sahai, Katsuyuki Takashima, and Brent Waters. Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption. In EUROCRYPT, pages 62–91, 2010.</li>

      <li>[MRS88] Silvio Micali, Charles Rackoff, and Bob Sloan. The notion of security for probabilistic cryptosystems. SIAM J. Comput., 17(2), 1988.</li>

      <li>[Nie02] Jesper Buus Nielsen. Separating random oracle proofs from complexity theoretic proofs: The non-committing encryption case. In CRYPTO, pages 111–126, 2002.</li>

      <li>[OT10] Tatsuaki Okamoto and Katsuyuki Takashima. Fully secure functional encryption with general relations from the decisional linear assumption. In CRYPTO, pages 191–208, 2010.</li>

      <li>[SSW09] Emily Shen, Elaine Shi, and Brent Waters. Predicate privacy in encryption systems. In TCC, pages 457–473, 2009.</li>

      <li>[SW05] Amit Sahai and Brent Waters. Fuzzy identity-based encryption. In EUROCRYPT, pages 457–473, 2005.</li>

      <li>[Wat] Brent Waters. Functional encryption: Beyond public-key cryptography. Presentation available from http://userweb.cs.utexas.edu/bwaters.</li>

    </ul>`;
---

<BaseLayout title="Definitional Issues in Functional Encryption (2010/556)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2010 &middot; eprint 2010/556
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
