---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/1048';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-21';
const TITLE_HTML = 'The Bitcoin Backbone Protocol with Chains of Variable Difficulty';
const AUTHORS_HTML = 'Juan A.  Garay, Aggelos Kiayias, Nikos Leonardos';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Bitcoin&rsquo;s innovative and distributedly maintained blockchain data structure hinges on the adequate degree of difficulty of so-called &ldquo;proofs of work,&rdquo; which miners have to produce in order for transactions to be inserted. Importantly, these proofs of work have to be hard enough so that miners have an opportunity to unify their views in the presence of an adversary who interferes but has bounded computational power, but easy enough to be solvable regularly and enable the miners to make progress. As such, as the miners&rsquo; population evolves over time, so should the difficulty of these proofs. Bitcoin provides this adjustment mechanism, with empirical evidence of a constant block generation rate against such population changes.

In this paper we provide the first (to our knowledge) formal analysis of Bitcoin&rsquo;s target (re)calculation function in the cryptographic setting, i.e., against all possible adversaries aiming to subvert the protocol&rsquo;s properties. We extend the q-bounded synchronous model of the Bitcoin backbone protocol [Eurocrypt 2015], which posed the basic properties of Bitcoin&rsquo;s underlying blockchain data structure and shows how a robust public transaction ledger can be built on top of them, to environments that may introduce or suspend parties in each round. We provide a set of necessary conditions with respect to the way the population evolves under which the &ldquo;Bitcoin backbone with chains of variable difficulty&rdquo; provides a robust transaction ledger in the presence of an actively malicious adversary controlling a fraction of the miners strictly below 50% in each instant of the execution. Our work introduces new analysis techniques and tools to the area of blockchain systems that may prove useful in analyzing other blockchain protocols.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> bitcoin</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">The Bitcoin backbone <a href="#page-24-0">[11]</a> extracts and analyzes the basic properties of Bitcoin's underlying blockchain data structure, such as &quot;common prefix&quot; and &quot;chain quality,&quot; which parties (&quot;miners&quot;) maintain and try to extend by generating &quot;proofs of work&quot; (POW, aka &quot;cryptographic puzzles&quot; <a href="#page-24-1">[8,</a> <a href="#page-25-0">22,</a> <a href="#page-24-2">1,</a> <a href="#page-24-3">13]</a>)<a href="#page-0-0">1</a> . It is then formally shown in <a href="#page-24-0">[11]</a> how fundamental applications including consensus <a href="#page-25-1">[21,</a> <a href="#page-25-2">16]</a> and a robust public transaction ledger realizing a decentralized cryptocurrency (e.g., Bitcoin <a href="#page-25-3">[19]</a>) can be built on top of them, assuming that the hashing power of an adversary controlling a fraction of the parties is strictly less than 1/2.</p>

    <p class="text-gray-300">The results in <a href="#page-24-0">[11]</a>, however, hold for a static setting, where the protocol is executed by a fixed number of parties (albeit not necessarily known to the participants), and therefore with POWs (and hence blockchains) of fixed difficulty. This is in contrast to the actual deployment of the Bitcoin protocol where a &quot;target (re)calculation&quot; mechanism adjusts the hardness level of POWs as the number of parties varies during the</p>

    <p class="text-gray-300"><sup>&lowast;</sup>An abridged version of this paper was published in Crypto 2017.</p>

    <p class="text-gray-300"><sup>&dagger;</sup>Part of this work was done while the authors were visiting the Simons Institute for the Theory of Computing, supported by the Simons Foundation and by the DIMACS/Simons Collaboration in Cryptography through NSF grant #CNS-1523467.</p>

    <p class="text-gray-300"><sup>&Dagger;</sup>Research partly supported by ERC project CODAMODA, No. 259152, and Horizon 2020 project PANORAMIX, No. 653497.</p>

    <p class="text-gray-300"><sup>1</sup> In Bitcoin, solving a proof of work essentially amounts to brute-forcing a hash inequality based on SHA-256.</p>

    <p class="text-gray-300">protocol execution. In more detail, in <a href="#page-24-0">[11]</a> the target T that the hash function output must not exceed, is set and hardcoded at the beginning of the protocol, and in such a way that a specific relation to the number of parties running the protocol is satisfied, namely, that a ratio f roughly equal to qnT /2 &kappa; is small, where q is the number of queries to the hash function that each party is allowed per round, n is the number of parties, and &kappa; is the length of the hash function output. Security was only proven when the number of parties is n and the choice of target T is never recalculated, thus leaving as open question the full analysis of the protocol in a setting where, as in the real world, parties change dynamically over time.</p>

    <p class="text-gray-300">In this paper, we abstract for the first time the target recalculation algorithm from the Bitcoin system, and present a generalization and analysis of the Bitcoin backbone protocol with chains of variable difficulty, as produced by an evolving population of parties, thus answering the aforementioned open question.</p>

    <p class="text-gray-300">In this setting, there is a parameter m which determines the length of an &quot;epoch&quot; in number of blocks.<a href="#page-1-0">2</a> When a party prepares to compute the j-th block of a chain with j mod m = 1, it uses a target calculation algorithm that determines the proper target value to use, based on the party's local view about the total number of parties that are present in the system, as reflected by the rate of blocks that have been created so far and are part of the party's chain. (Each block contains a timestamp of when it was created; in our synchronous setting, timestamps will correspond to the round numbers when blocks are created&mdash;see Section <a href="#page-2-0">2.</a>) To accomodate the evolving population of parties, we extend the model of <a href="#page-24-0">[11]</a> to environments that are free to introduce and suspend parties in each round. In other respects, we follow the model of <a href="#page-24-0">[11]</a>, where all parties have the same &quot;hashing power,&quot; with each one allowed to pose q queries to the hash function that is modeled as a &quot;random oracle&quot; <a href="#page-24-4">[3]</a>. We refer to our setting as the dynamic q-bounded synchronous setting.</p>

    <p class="text-gray-300">In order to give an idea of the issues involved, we note that without a target calculation mechanism, in the dynamic setting the backbone protocol is not secure even if all parties are honest and follow the protocol faithfully. Indeed, it is easy to see that a combination of an environment that increases the number of parties and adversarial network conditions can lead to substantial divergence (a.k.a. &quot;forks&quot;) in the chains of the honest parties, leading to the violation of the agreement-type properties that are needed for the applications of the protocol, such as maintaining a robust transaction ledger. The attack is simple: the environment increases the number of parties constantly so that the block production rate per round increases (which is roughly the parameter f mentioned above); then, adversarial network conditions may divide the parties into two sets, A and B, and schedule message delivery so that parties in set A receive blocks produced by parties in A first, and similarly for set B. According to the Bitcoin protocol, parties adopt the block they see first, and thus the two sets will maintain two separate blockchains.</p>

    <p class="text-gray-300">While this specific attack could in principle be thwarted by modifying the Bitcoin backbone (e.g., by randomizing which block a party adopts when they receive in the same round two blocks of the same index in the chain), it certainly would not cope with all possible attacks in the presence of a full-blown adversary and target recalculation mechanism. Indeed, such an attack was shown in <a href="#page-24-5">[2]</a>, where by mining &quot;privately&quot; with timestamps in rapid succession, corrupt miners are able to induce artificially high targets in their private chain; even though such chain may grow slower than the main chain, it will still make progress and, via an anti-concentration argument, a sudden adversarial advance that can break agreement amongst honest parties cannot be ruled out.</p>

    <p class="text-gray-300">Given the above, our main goal is to show that the backbone protocol with a Bitcoin-like target recalculation function satisfies the common prefix and chain quality properties, as an intermediate step towards proving that the protocol implements a robust transaction ledger. Expectedly, the class of protocols we will analyze will not preserve its properties for arbitrary ways in which the number of parties may change over time. In order to bound the error in the calibration of the block generation rate that the target recalculation function attempts, we will need some bounds on the way the number of parties may vary. For &gamma; &isin; R <sup>+</sup> and s &isin; N, we will call a sequence (nr)r&isin;<sup>N</sup> of parties (&gamma;, s)-respecting if it holds that in a sequence of rounds S with |S| &le; s, maxr&isin;<sup>S</sup> n<sup>r</sup> &le; &gamma; &middot; minr&isin;<sup>S</sup> nr, and will determine for what values of these parameters the</p>

    <p class="text-gray-300"><sup>2</sup> In Bitcoin, m is set to 2016 and roughly corresponds to 2 weeks in real time&mdash;assuming the number of parties does not change much.</p>

    <p class="text-gray-300">backbone protocol is secure.</p>

    <p class="text-gray-300">After formally describing blockchains of variable difficulty and the Bitcoin backbone protocol in this setting, at a high level our analysis goes as follows. We first introduce the notion of goodness regarding the approximation that is performed on f in an epoch. In more detail, we call a round r (&eta;, &theta;)-good, for some parameters &eta;, &theta; &isin; R <sup>+</sup>, if the value f<sup>r</sup> computed for the actual number of parties and target used in round r by some honest party, falls in the range [&eta;f, &theta;f], where f is the initial block production rate (note that the first round is always assumed good). Together with &quot;goodness&quot; we introduce the notion of typical executions, in which, informally, for any set S of consecutive rounds the successes of the adversary and the honest parties do not deviate too much from their expectations as well as no &quot;bad&quot; event concerning the hash function occurs (such as a collision). Using a martingale bound we demonstrate that almost all polynomially bounded (in &kappa;) executions are typical.</p>

    <p class="text-gray-300">Next, we proceed to show that in a typical execution any chain that an honest party adopts (1) contains timestamps that are approximately accurate (i.e., no adversarial block has a timestamp that differs too much from its real creation time), and (2) it has a target such that the probability of block production remains near the fixed constant f, i.e., it is &quot;good.&quot; Finally, these properties allow us to demonstrate that a typical execution enjoys the common prefix and chain quality properties, which is a stepping stone towards the ultimate goal, that of establishing that the backbone protocol with variable difficulty implements a robust transaction ledger. Specifically, we show the following:</p>

    <p class="text-gray-300">Main result (Informal&mdash;see Theorems <a href="#page-23-0">5</a> and <a href="#page-29-0">6)</a>. The Bitcoin backbone protocol with chains of variable difficulty, suitably parameterized, satisfies with overwhelming probability in m and &kappa; the properties of (1) persistence&mdash;if a transaction tx is confirmed by an honest party, no honest party will ever disagree about the position of tx in the ledger, and (2) liveness&mdash;if a transaction tx is broadcast, it will eventually become confirmed by all honest parties.</p>

    <p class="text-gray-300">Remark. Regarding the actual parameterization of the Bitcoin system (that uses epochs of m = 2016 blocks), even though it is consistent with all the constraints of our theorems (cf. Remark <a href="#page-13-0">3</a> in Section <a href="#page-10-0">6.1)</a>, it cannot be justified by our martingale analysis. In fact, our probabilistic analysis would require much longer epochs to provide a sufficiently small probability of attack. Tightening the analysis or discovering attacks for parameterizations beyond our security theorems is an interesting open question.</p>

    <p class="text-gray-300">Finally, we note that various extensions to our model are relevant to the Bitcoin system and constitute interesting directions for further research. Importantly, a security analysis in the &quot;rational&quot; setting (see, e.g., <a href="#page-24-6">[9,</a> <a href="#page-25-4">23,</a> <a href="#page-24-7">14]</a>), and in the &quot;partially synchronous,&quot; or &quot;bounded-delay&quot; network model <a href="#page-24-8">[7,</a> <a href="#page-25-5">20]</a><a href="#page-2-1">3</a> .</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Model and Definitions</h2>

    <p class="text-gray-300">We describe our protocols in a model that extends the synchronous communication network model presented in <a href="#page-24-9">[10,</a> <a href="#page-24-0">11]</a> for the analysis of the Bitcoin backbone protocol in the static setting with a fixed number of parties (which in turn is based on Canetti's formulation of &quot;real world&quot; notion of protocol execution <a href="#page-24-10">[4,</a> <a href="#page-24-11">5,</a> <a href="#page-24-12">6]</a> for multi-party protocols) to the dynamic setting with a varying number of parties. In this section we provide a high-level overview of the model, highlighting the differences that are intrinsic to our dynamic setting.</p>

    <p class="text-gray-300">Round structure and protocol execution. As in <a href="#page-24-9">[10]</a>, the protocol execution proceeds in rounds with inputs provided by an environment program denoted by Z to parties that execute the protocol &Pi;, and our adversarial model in the network is &quot;adaptive,&quot; meaning that the adversary A is allowed to take control of parties on the fly, and &quot;rushing,&quot; meaning that in any given round the adversary gets to see all honest players' messages before deciding his strategy. The parties' access to the hash function and their communication mechanism are captured by a joint random oracle / diffusion functionality which reflects Bitcoin's peer</p>

    <p class="text-gray-300"><sup>3</sup> In the latest version of <a href="#page-24-9">[10]</a>, we show that in the case of fixed difficulty, the analysis of the Bitcoin backbone in the synchronous model extends with relative ease to partial synchrony. We leave the extension of the variable-difficulty case for future work.</p>

    <p class="text-gray-300">structure. The diffusion functionality, <a href="#page-24-9">[10]</a>, allows the order of messages to be controlled by A, i.e., there is no atomicity guarantees in message broadcast <a href="#page-24-13">[12]</a>, and, furthermore, the adversary is allowed to spoof the source information on every message (i.e., communication is not authenticated). Still, the adversary cannot change the contents of the messages nor prevent them from being delivered. We will use Diffuse as the message transmission command that captures this &quot;send-to-all&quot; functionality.</p>

    <p class="text-gray-300">The parties that may become active in a protocol execution are encoded as part of a control program C and come from a universe U of parties.</p>

    <p class="text-gray-300">The protocol execution is driven by an environment program Z that interacts with other instances of programs that it spawns at the discretion of the control program C. The pair (Z, C) forms of a system of interactive Turing machines (ITM's) in the sense of <a href="#page-24-11">[5]</a>. The execution is with respect to a program &Pi;, an adversary A (which is another ITM) and the universe of parties U. Assuming the control program C allows it, the environment Z can activate a party by writing to its input tape. Note that the environment Z also receives the parties' outputs when they are produced in a standard subroutine-like interaction. Additionally, the control program maintains a flag for each instance of an ITM, (abbreviated as ITI in the terminology of <a href="#page-24-11">[5]</a>), that is called the ready flag and is initially set to false for all parties.</p>

    <p class="text-gray-300">The environment Z, initially is restricted by C to spawn the adversary A. Each time the adversary is activated, it may send one or more messages of the form (Corrupt, Pi) to C and C will mark the corresponding party as corrupted.</p>

    <p class="text-gray-300">Functionalities available to the protocol. The ITI's of protocol &Pi; will have access to a joint ideal functionality capturing the random oracle and the diffusion mechanism which is defined in a similar way as <a href="#page-24-9">[10]</a> and is explained below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The random oracle functionality. Given a query with a value x marked for &quot;calculation&quot; for the function H(&middot;) from an honest party P<sup>i</sup> and assuming x has not been queried before, the functionality returns a value y which is selected at random from {0, 1} &kappa; ; furthermore, it stores the pair (x, y) in the table of H(&middot;), in case the same value x is queried in the future. Each honest party P<sup>i</sup> is allowed to ask q queries in each round as determined by the diffusion functionality (see below). On the other hand, each honest party is given unlimited queries for &quot;verification&quot; for the function H(&middot;). The adversary A, on the other hand, is given a bounded number queries in each round as determined by diffusion functionality with a bound that is initialized to 0 and determined as follows: whenever a corrupted party is activated, the party can ask the bound to be increased by q; each time a query is asked by the adversary the bound is decreased by 1. No verification queries are provided to A. Note that the value q is a polynomial function of &kappa;, the security parameter. The functionality can maintain tables for functions other than H(&middot;) but, by convention, the functionality will impose query quotas to function H(&middot;) only.</li>
      <li>The diffusion functionality. This functionality keeps track of rounds in the protocol execution; for this purpose it initially sets a variable round to be 1. It also maintains a Receive() string defined for each party P<sup>i</sup> in U. A party that is activated is allowed to query the functionality and fetch the contents of its personal Receive() string. Moreover, when the functionality receives a message (Diffuse, m) from party P<sup>i</sup> it records the message m. A party P<sup>i</sup> can signal when it is complete for the round by sending a special message (RoundComplete). With respect to the adversary A, the functionality allows it to receive the contents of all contents sent in Diffuse messages for the round and specify the contents of the Receive() string for each party P<sup>i</sup> . The adversary has to specify when it is complete for the current round. When all parties are complete for the current round, the functionality inspects the contents of all Receive() strings and includes any messages m that were diffused by the parties in the current round but not contributed by the adversary to the Receive() tapes (in this way guaranteeing message delivery). It also flushes any old messages that were diffused in previous rounds and not diffused again. The variable round is then incremented.</li>
    </ul>

    <p class="text-gray-300">The dynamic q-bounded synchronous setting. Consider n = {nr}r&isin;<sup>N</sup> and t = {tr}r&isin;<sup>N</sup> two series of</p>

    <p class="text-gray-300">natural numbers. As mentioned, the first instance that is spawned by  <span class="math">\\mathcal{Z}</span>  is the adversary  <span class="math">\\mathcal{A}</span> . Subsequently the environment may spawn (or activate if they are already spawned) parties  <span class="math">P_i \\in \\mathcal{U}</span> . The control program maintains a counter in each sequence of activations and matches it with the current round that is maintained by the diffusion functionality. Each time an honest party diffuses a message containing the label &quot;ready&quot; the control program C increases the ready counter for the round. In round r, the control program C will enable the adversary  <span class="math">\\mathcal{A}</span>  to complete the round, only provided that (i) exactly  <span class="math">n_r</span>  parties have transmitted ready message, (ii) the number of (&quot;corrupt&quot;) parties controlled by  <span class="math">\\mathcal{A}</span>  should match  <span class="math">t_r</span> .</p>

    <p class="text-gray-300">Parties, when activated, are able to read their input tape INPUT() and communication tape RECEIVE() from the diffusion functionality. Observe that parties are unaware of the set of activated parties. The Bitcoin backbone protocol requires from parties (miners) to calculate a POW. This is modeled in [11] as parties having access to the oracle  <span class="math">H(\\cdot)</span> . The fact that (active) parties have limited ability to produce such POWs, is captured as in [11] by the random oracle functionality and the fact that it paces parties to query a limited number of queries per round. The bound, q, is a function of the security parameter  <span class="math">\\kappa</span> ; in this sense the parties may be called q-bounded<sup>4</sup>. We refer to the above restrictions on the environment, the parties and the adversary as the dynamic q-bounded synchronous setting.</p>

    <p class="text-gray-300">The term  <span class="math">\\{\\text{VIEW}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{P,\\mathbf{t},\\mathbf{n}}(z)\\}_{z\\in\\{0,1\\}^*}</span>  denotes the random variable ensemble describing the view of party P after the completion of an execution running protocol  <span class="math">\\Pi</span>  with environment  <span class="math">\\mathcal{Z}</span>  and adversary  <span class="math">\\mathcal{A}</span> , on input  <span class="math">z\\in\\{0,1\\}^*</span> . We will only consider a &quot;standalone&quot; execution without any auxiliary information and we will thus restrict ourselves to executions with  <span class="math">z=1^\\kappa</span> . For this reason we will simply refer to the ensemble by  <span class="math">\\text{VIEW}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{P,\\mathbf{t},\\mathbf{n}}</span> . The concatenation of the view of all parties ever activated in the execution is denoted by  <span class="math">\\text{VIEW}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{\\mathbf{t},\\mathbf{n}}</span> .</p>

    <p class="text-gray-300"><strong>Properties of protocols.</strong> In our theorems we will be concerned with <em>properties</em> of protocols  <span class="math">\\Pi</span>  running in the above setting. Such properties will be defined as predicates over the random variable  <span class="math">\\text{VIEW}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{\\mathbf{t},\\mathbf{n}}</span>  by quantifying over all possible adversaries  <span class="math">\\mathcal{A}</span>  and environments  <span class="math">\\mathcal{Z}</span> . Note that all our protocols will only satisfy properties with a small probability of error in  <span class="math">\\kappa</span>  as well as in a parameter k that is selected from  <span class="math">\\{1,\\ldots,\\kappa\\}</span>  (with foresight we note that in practice would be able to choose k to be much smaller than  <span class="math">\\kappa</span> , e.g., k=6).</p>

    <p class="text-gray-300">The protocol class that we will analyze will not be able to preserve its properties for arbitrary sequences of parties. To restrict the way the sequence  <span class="math">\\mathbf{n}</span>  is fluctuating we will introduce the following class of sequences.</p>

    <p class="text-gray-300"><strong>Definition 1.</strong> For  <span class="math">\\gamma \\in \\mathbb{R}^+</span> , we call a sequence  <span class="math">(n_r)_{r \\in \\mathbb{N}}</span>   <span class="math">(\\gamma, s)</span> -respecting if for any set S of at most s consecutive rounds,  <span class="math">\\max_{r \\in S} n_r \\leq \\gamma \\cdot \\min_{r \\in S} n_r</span> .</p>

    <p class="text-gray-300">Observe that the above definition is fairly general and also can capture exponential growth; e.g., by setting  <span class="math">\\gamma = 2</span>  and s = 10, it follows that every 10 rounds the number of ready parties may double. Note that this will not lead to an exponential running time overall since the total run time is bounded by a polynomial in  <span class="math">\\kappa</span> , (due to the fact that  <span class="math">(\\mathcal{Z}, C)</span>  is a system of ITM's,  <span class="math">\\mathcal{Z}</span>  is locally polynomial bounded, C is a polynomial-time program, and thus [5, Proposition 3] applies).</p>

    <p class="text-gray-300">More formally, a protocol  <span class="math">\\Pi</span>  would satisfy a property Q for a certain class of sequences  <span class="math">\\mathbf{n}, \\mathbf{t}</span> , provided that for all PPT  <span class="math">\\mathcal{A}</span>  and locally polynomial bounded  <span class="math">\\mathcal{Z}</span> , it holds that  <span class="math">Q(\\text{VIEW}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{\\mathbf{t},\\mathbf{n}})</span>  is true with overwhelming probability of the coins of  <span class="math">\\mathcal{A}, \\mathcal{Z}</span>  and the random oracle functionality.</p>

    <p class="text-gray-300">In this paper, we will be interested in  <span class="math">(\\gamma, s)</span> -respecting sequences  <span class="math">\\mathbf{n}</span> , sequences  <span class="math">\\mathbf{t}</span>  suitably restricted by  <span class="math">\\mathbf{n}</span> , and protocols  <span class="math">\\Pi</span>  suitably parameterized given  <span class="math">\\mathbf{n}</span> ,  <span class="math">\\mathbf{t}</span> .</p>

    <p class="text-gray-300">We start by introducing blockchain notation; we use similar notation to [10], and expand the notion of blockchain to explicitly include timestamps (in the form of a round indicator). Let  <span class="math">G(\\cdot)</span>  and  <span class="math">H(\\cdot)</span>  be</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;4</sup>In [11] this is referred to as the &quot;flat-model&quot; in terms of computational power, where all parties are assumed equal. In practice, different parties may have different &quot;hashing power&quot;; note that this does not sacrifice generality since one can imagine that real parties are simply clusters of some arbitrary number of flat-model parties.</p>

    <p class="text-gray-300">cryptographic hash functions with output in {0, 1} &kappa; . A block with target T &isin; N is a quadruple of the form B = hr, st, x, ctri where st &isin; {0, 1} &kappa; , x &isin; {0, 1} &lowast; , and r, ctr &isin; N are such that they satisfy the predicate validblock<sup>T</sup> q (B) defined as</p>

    <p class="text-gray-300"><span class="math">$(H(ctr, G(r, st, x)) &lt; T) \\land (ctr \\le q).</span>$</p>

    <p class="text-gray-300">The parameter q &isin; N is a bound that in the Bitcoin implementation determines the size of the register ctr; as in <a href="#page-24-9">[10]</a>, in our treatment we allow q to be arbitrary, and use it to denote the maximum allowed number of hash queries in a round (cf. Section <a href="#page-2-0">2)</a>. We do this for convenience and our analysis applies in a straightforward manner to the case that ctr is restricted to the range 0 &le; ctr &lt; 2 <sup>32</sup> and q is independent of ctr.</p>

    <p class="text-gray-300">A blockchain, or simply a chain is a sequence of blocks. The rightmost block is the head of the chain, denoted head(C). Note that the empty string &epsilon; is also a chain; by convention we set head(&epsilon;) = &epsilon;. A chain C with head(C) = hr, st, x, ctri can be extended to a longer chain by appending a valid block B = hr 0 , st<sup>0</sup> , x<sup>0</sup> , ctr<sup>0</sup> i that satisfies st<sup>0</sup> = H(ctr, G(r, st, x)) and r <sup>0</sup> &gt; r, where r 0 is called the timestamp of block B. In case C = &epsilon;, by convention any valid block of the form hr 0 , st<sup>0</sup> , x<sup>0</sup> , ctr<sup>0</sup> i may extend it. In either case we have an extended chain Cnew = CB that satisfies head(Cnew) = B.</p>

    <p class="text-gray-300">The length of a chain len(C) is its number of blocks. Consider a chain C of length \` and any nonnegative integer k. We denote by C dk the chain resulting from &quot;pruning&quot; the k rightmost blocks. Note that for k &ge; len(C), C <sup>d</sup><sup>k</sup> = &epsilon;. If C<sup>1</sup> is a prefix of C<sup>2</sup> we write C<sup>1</sup> C2.</p>

    <p class="text-gray-300">Given a chain C of length len(C) = <code>, we let x&lt;sup&gt;C&lt;/sup&gt; denote the vector of </code> values that is stored in C and starts with the value of the first block. Similarly, r<sup>C</sup> is the vector that contains the timestamps of the blockchain C.</p>

    <p class="text-gray-300">For a chain of variable difficulty, the target T is recalculated for each block based on the round timestamps of the previous blocks. Specifically, there is a function D : Z <sup>&lowast;</sup> &rarr; R which receives an arbitrary vector of round timestamps and produces the next target. The value D(&epsilon;) is the initial target of the system. The difficulty of each block is measured in terms of how many times the block is harder to obtain than a block of target T0. In more detail, the difficulty of a block with target T is equal to T0/T; without loss of generality we will adopt the simpler expression 1/T (as T<sup>0</sup> will be a constant across all executions). We will use diff(C) to denote the difficulty of a chain. This is equal to the sum of the difficulties of all the blocks that comprise the chain.</p>

    <p class="text-gray-300">The target calculation function. Intuitively, the target calculation function D(&middot;) aims at maintaining the block production rate constant. It is parameterized by m &isin; N and f &isin; (0, 1); Its goal is that m blocks will be produced every m/f rounds. We will see in Section <a href="#page-10-1">6</a> that the probability f(T, n) with which n parties produce a new block with target T is approximated by</p>

    <p class="text-gray-300"><span class="math">$f(T,n) \\approx \\frac{qTn}{2^{\\kappa}}.</span>$</p>

    <p class="text-gray-300">(Note that T /2 &kappa; is the probability that a single player produces a block in a single query.)</p>

    <p class="text-gray-300">To achieve the above goal Bitcoin tries to keep qT n/2 &kappa; close to f. To that end, Bitcoin waits for m blocks to be produced and based on their difficulty and how fast these blocks were computed it computes the next target. More specifically, say the last m blocks of a chain C are for target T and were produced in &#8710; rounds. Consider the case where a number of players</p>

    <p class="text-gray-300"><span class="math">$n(T, \\Delta) = \\frac{2^{\\kappa} m}{qT\\Delta}</span>$</p>

    <p class="text-gray-300">attempts to produce m blocks of target T; note that it will take them approximately &#8710; rounds in expectation. Intuitively, the number of players at the point when m blocks were produced is estimated by n(T, &#8710;); then the next target T 0 is set so that n(T, &#8710;) players would need m/f rounds in expectation to produce m blocks of target T 0 . Therefore, it makes sense to set</p>

    <p class="text-gray-300"><span class="math">$T&#x27; = \\frac{\\Delta}{m/f} \\cdot T,</span>$</p>

    <p class="text-gray-300">because if the number of players is indeed  <span class="math">n(T, \\Delta)</span>  and remains unchanged, it will take them m/f rounds in expectation to produce m blocks. If the initial estimate of the number parties is  <span class="math">n_0</span> , we will assume  <span class="math">T_0</span>  is appropriately set so that  <span class="math">f \\approx qT_0n_0/2^{\\kappa}</span>  and then</p>

    <p class="text-gray-300"><span class="math">$T&#x27; = \\frac{n_0}{n(T, \\Delta)} \\cdot T_0.</span>$</p>

    <p class="text-gray-300"><strong>Remark 1.</strong> Recall that in the flat q-bounded setting all parties have the same hashing power (q-queries per round). It follows that  <span class="math">n_0</span>  represents the estimated initial hashing power while  <span class="math">n(T, \\Delta)</span>  the estimated hashing power during the last m blocks of the chain C. As a result the new target is equal to the initial target  <span class="math">T_0</span>  multiplied by the factor  <span class="math">n_0/n(T, \\Delta)</span> , reflecting the change of hashing power in the last m blocks.</p>

    <p class="text-gray-300">Based on the above we give the formal definition of the target (re)calculation function, which is as follows.</p>

    <p class="text-gray-300"><strong>Definition 2.</strong> For fixed constants  <span class="math">\\kappa, \\tau, m, n_0, T_0</span> , the target calculation function  <span class="math">D: \\mathbb{Z}^* \\to \\mathbb{R}</span>  is defined as</p>

    <p class="text-gray-300"><span class="math">$D(\\varepsilon) = T_0 \\quad and \\quad D(r_1, \\dots, r_v) = \\begin{cases} \\frac{1}{\\tau} \\cdot T &amp; \\text{if } \\frac{n_0}{n(T, \\Delta)} \\cdot T_0 &lt; \\frac{1}{\\tau} \\cdot T; \\\\ \\tau \\cdot T &amp; \\text{if } \\frac{n_0}{n(T, \\Delta)} \\cdot T_0 &gt; \\tau \\cdot T; \\\\ \\frac{n_0}{n(T, \\Delta)} \\cdot T_0 &amp; \\text{otherwise,} \\end{cases}</span>$</p>

    <p class="text-gray-300">where  <span class="math">n(T, \\Delta) = 2^{\\kappa} m/qT\\Delta</span> , with  <span class="math">\\Delta = r_{m&#x27;} - r_{m&#x27;-m}</span> ,  <span class="math">T = D(r_1, \\ldots, r_{m&#x27;-1})</span> , and  <span class="math">m&#x27; = m \\cdot |v/m|</span> .</p>

    <p class="text-gray-300">In the definition,  <span class="math">(r_1, \\ldots, r_v)</span>  corresponds to a chain of v blocks with  <span class="math">r_i</span>  the timestamp of the ith block;  <span class="math">m&#x27;, \\Delta</span> , and T correspond to the last block, duration, and target of the last completed epoch, respectively.</p>

    <p class="text-gray-300"><strong>Remark 2.</strong> A remark is in order about the case  <span class="math">\\frac{n_0}{n(T,\\Delta)} \\cdot T_0 \\notin [\\frac{1}{\\tau}T, \\tau T]</span> , since this aspect of the definition is not justified by the discussion preceding Definition 2. At first there may seem to be no reason to introduce such a &quot;dampening filter&quot; in Bitcoin's target recalculation function and one should let the parties to try collectively to approximate the proper target. Interestingly, in the absence of such dampening, an efficient attack is known [2] (against the common-prefix property). As we will see, this dampening is sufficient for us to prove security against all attackers, including those considered in [2] (with foresight, we can say that the attack still holds but it will take exponential time to mount).</p>

    <p class="text-gray-300">In this section we give a high-level description of the Bitcoin backbone protocol with chains of variable difficulty; a more detailed description, including the pseudocode of the algorithms, is given in Appendix A. The presentation is based on the description in [11]. We then formulate two desired properties of the blockchain&mdash;common prefix and chain quality&mdash;for the dynamic setting.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 The Protocol</h3>

    <p class="text-gray-300">As in [11], in our description of the backbone protocol we intentionally avoid specifying the type of values/content that parties try to insert in the chain, the type of chain validation they perform (beyond checking for its structural properties with respect to the hash functions  <span class="math">G(\\cdot), H(\\cdot)</span> ), and the way they interpret the chain. These checks and operations are handled by the external functions  <span class="math">V(\\cdot), I(\\cdot)</span>  and  <span class="math">R(\\cdot)</span>  (the content validation function, the input contribution function and the chain reading function, resp.) which are specified by the application that runs &quot;on top&quot; of the backbone protocol. The Bitcoin backbone protocol in the dynamic setting comprises three algorithms.</p>

    <p class="text-gray-300">Chain validation. The validate algorithm performs a validation of the structural properties of a given chain C. It is given as input the value q, as well as hash functions  <span class="math">H(\\cdot), G(\\cdot)</span> . It is parameterized by the</p>

    <p class="text-gray-300">content validation predicate  <span class="math">V(\\cdot)</span>  as well as by  <span class="math">D(\\cdot)</span> , the target calculation function (Section 3). For each block of the chain, the algorithm checks that the proof of work is properly solved (with a target that is suitable as determined by the target calculation function), and that the counter ctr does not exceed q. Furthermore it collects the inputs from all blocks,  <span class="math">\\mathbf{x}_{\\mathcal{C}}</span> , and tests them via the predicate  <span class="math">V(\\mathbf{x}_{\\mathcal{C}})</span> . Chains that fail these validation procedure are rejected.</p>

    <p class="text-gray-300">Chain comparison. The objective of the second algorithm, called maxvalid, is to find the &quot;best possible&quot; chain when given a set of chains. The algorithm is straightforward and is parameterized by a  <span class="math">\\max(\\cdot)</span>  function that applies some ordering to the space of blockchains. The most important aspect is the chains' difficulty in which case  <span class="math">\\max(\\mathcal{C}_1, \\mathcal{C}_2)</span>  will return the most difficult of the two. In case  <span class="math">\\operatorname{diff}(\\mathcal{C}_1) = \\operatorname{diff}(\\mathcal{C}_2)</span> , some other characteristic can be used to break the tie. In our case,  <span class="math">\\max(\\cdot, \\cdot)</span>  will always return the first operand to reflect the fact that parties adopt the first chain they obtain from the network.</p>

    <p class="text-gray-300"><strong>Proof of work.</strong> The third algorithm, called pow, is the proof of work-finding procedure. It takes as input a chain and attempts to extend it via solving a proof of work. This algorithm is parameterized by two hash functions  <span class="math">H(\\cdot), G(\\cdot)</span>  as well as the parameter q. Moreover, the algorithm calls the target calculation function  <span class="math">D(\\cdot)</span>  in order to determine the value T that will be used for the proof of work. The procedure, given a chain C and a value C to be inserted in the chain, hashes these values to obtain C and initializes a counter C subsequently, it increments C and checks to see whether C in case a suitable C is found then the algorithm succeeds in solving the POW and extends chain C by one block.</p>

    <p class="text-gray-300">The Bitcoin backbone protocol. The core of the backbone protocol with variable difficulty is similar to that in [11], with several important distinctions. First is the procedure to follow when the parties become active. Parties check the ready flag they possess, which is false if and only if they have been inactive in the previous round. In case the ready flag is false, they diffuse a special message 'Join' to request the most recent version of the blockchain(s). Similarly, parties that receive the special request message in their Receive() tape broadcast their chains. As before parties, run &quot;indefinitely&quot; (our security analysis will apply when the total running time is polynomial in  <span class="math">\\kappa</span> ). The input contribution function  <span class="math">I(\\cdot)</span>  and the chain reading function  <span class="math">R(\\cdot)</span>  are applied to the values stored in the chain. Parties check their communication tape Receive() to see whether any necessary update of their local chain is due; then they attempt to extend it via the POW algorithm pow. The function  <span class="math">I(\\cdot)</span>  determines the input to be added in the chain given the party's state st, the current chain c, the contents of the party's input tape INPUT() and communication tape Receive(). The input tape contains two types of symbols, Read and (Insert, value); other inputs are ignored. In case the local chain c is extended the new chain is diffused to the other parties. Finally, in case a Read symbol is present in the communication tape, the protocol applies function  <span class="math">R(\\cdot)</span>  to its current chain and writes the result onto the output tape Output().</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Properties of the Backbone Protocol with Variable Difficulty</h3>

    <p class="text-gray-300">Next, we define the two properties of the backbone protocol that the protocol will establish. They are close variants of the properties in [11], suitably modified for the dynamic q-bounded synchronous setting.</p>

    <p class="text-gray-300">The common prefix property essentially remains the same. It is parameterized by a value  <span class="math">k \\in \\mathbb{N}</span> , considers an arbitrary environment and adversary, and it holds as long as any two parties' chains are different only in their most recent k blocks. It is actually helpful to define the property between an honest party's chain and another chain that may be adversarial. The definition is as follows.</p>

    <p class="text-gray-300"><strong>Definition 3</strong> (Common-Prefix Property). The common-prefix property  <span class="math">Q_{\\sf cp}</span>  with parameter  <span class="math">k \\in \\mathbb{N}</span>  states that for any pair of honest players  <span class="math">P_1</span> ,  <span class="math">P_2</span>  adopting the chains  <span class="math">C_1</span> ,  <span class="math">C_2</span>  at rounds  <span class="math">r_1 \\leq r_2</span>  respectively in VIEW <span class="math">_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{\\sf t}</span> , it holds that  <span class="math">C_1^{\\lceil k} \\leq C_2</span> .</p>

    <p class="text-gray-300">The second property, called <em>chain quality</em>, expresses the number of honest-party contributions that are contained in a sufficiently long and continuous part of a party's chain. Because we consider chains of variable difficulty it is more convenient to think of parties' contributions in terms of the total difficulty they add to the chain as opposed to the number of blocks they add (as done in [11]). The property states that adversarial</p>

    <p class="text-gray-300">parties are bounded in the amount of difficulty they can contribute to any sufficiently long segment of the chain.</p>

    <p class="text-gray-300"><strong>Definition 4</strong> (Chain-Quality Property). The chain quality property  <span class="math">Q_{cq}</span>  with parameters  <span class="math">\\mu \\in \\mathbb{R}</span>  and  <span class="math">\\ell \\in \\mathbb{N}</span>  states that for any honest party P with chain C in  <span class="math">VIEW_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{\\mathbf{t},\\mathbf{n}}</span> , it holds that for any  <span class="math">\\ell</span>  consecutive blocks of C with total difficulty d, the honest blocks contribute difficulty at least  <span class="math">\\mu \\cdot d</span> .</p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8">4.3 Application: Robust Transaction Ledger</h3>

    <p class="text-gray-300">We now come to the (main) application the Bitcoin backbone protocol was designed to solve. A robust transaction ledger is a protocol maintaining a ledger of transactions organized in the form of a chain C, satisfying the following two properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Persistence: Parameterized by  <span class="math">k \\in \\mathbb{N}</span>  (the &quot;depth&quot; parameter), if an honest party P, maintaining a chain C, reports that a transaction tx is in  <span class="math">C^{\\lceil k}</span> , then it holds for every other honest party P' maintaining a chain C' then C' contains tx in exactly the same position.</li>
      <li>Liveness: Parameterized by  <span class="math">u, k \\in \\mathbb{N}</span>  (the &quot;wait time&quot; and &quot;depth&quot; parameters, resp.), if a transaction tx is provided to all honest parties for u consecutive rounds, then it holds that for any player P, maintaining a chain C, tx will be in  <span class="math">C^{\\lceil k \\rceil}</span> .</li>
    </ul>

    <p class="text-gray-300">We note that, as in [11], Liveness is applicable to either &quot;neutral&quot; transactions (i.e., those that they are never in &quot;conflict&quot; with other transactions in the ledger), or transactions that are produced by an oracle Txgen that produces honestly generated transactions.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Overview of the Analysis</h2>

    <p class="text-gray-300">Our main goal is to show that the backbone protocol satisfies the properties common prefix and chain quality (Section 4.2) in a  <span class="math">(\\gamma, s)</span> -respecting environment as an intermediate step towards proving, eventually, that the protocol implements a robust transaction ledger. In this section we present a high-level overview of our approach; the full analysis is then presented in Section 6. To prove the aforementioned properties we first characterize the set of typical executions. Informally, an execution is typical if for any set S of consecutive rounds the successes of the adversary and the honest parties do not deviate too much from their expectations and no bad event occurs with respect to the hash function (which we model as a &quot;random oracle&quot;). Using the martingale bound of Theorem 7 we demonstrate that almost all polynomially bounded executions are typical. We then proceed to show that in a typical execution any chain that an honest party adopts (1) contains timestamps that are approximately accurate (i.e., no adversarial block has a timestamp that differs too much by its real creation time) and (2) has a target such that the probability of block production remains near a fixed constant f. Finally, these properties of a typical execution will bring us to our ultimate goal: to demonstrate that a typical execution enjoys the common prefix and the chain quality properties, and therefore one can build on the blockchain a robust transaction ledger (Section 4.3). Here we highlight the main steps and the novel concepts that we introduce.</p>

    <p class="text-gray-300">&quot;Good&quot; executions. In order to be able to talk quantitavely about typical executions, we first introduce the notion of  <span class="math">(\\eta, \\theta)</span> -good executions, which expresses how well the parties approximate f. Suppose at round r exactly n parties query the oracle with target T. The probability at least one of them will succeed is</p>

    <p class="text-gray-300"><span class="math">$f(T,n) = 1 - \\left(1 - \\frac{T}{2^{\\kappa}}\\right)^{qn}.</span>$</p>

    <p class="text-gray-300">For the initial target  <span class="math">T_0</span>  and the initial estimate of the number of parties  <span class="math">n_0</span> , we denote  <span class="math">f_0 = f(T_0, n_0)</span> . Looking ahead, the objective of the target recalculation mechanism is to maintain a target T for each party such that  <span class="math">f(T, n_r) \\approx f_0</span>  for all rounds r. (For succintness, we will drop the subscript and simply refer to it as f.) Now, at a round r of an execution E the honest parties might be querying the random oracle for various targets. We denote by  <span class="math">T_r^{\\min}(E)</span>  and  <span class="math">T_r^{\\max}(E)</span>  the minimum and maximum over those targets. We say r is a target-recalculation point of a valid chain  <span class="math">\\mathcal{C}</span> , if there is a block with timestamp r and m exactly divides the number of blocks up to (and including) this block. Consider constants  <span class="math">\\eta \\in (0,1]</span>  and  <span class="math">\\theta \\in [1,\\infty)</span>  and an execution E:</p>

    <p class="text-gray-300"><strong>Definition 5 (Abridged).</strong> A round r is  <span class="math">(\\eta, \\theta)</span> -good in E if  <span class="math">\\eta f \\leq f(T_r^{\\min}(E), n_r)</span>  and  <span class="math">f(T_r^{\\max}(E), n_r) \\leq \\theta f</span> . An execution E is  <span class="math">(\\eta, \\theta)</span> -good if every round of E was  <span class="math">(\\eta, \\theta)</span> -good.</p>

    <p class="text-gray-300">We are going to study the progress of the honest parties only when their targets lie in a reasonable range. It will turn out that, with high probability, the honest parties always work with reasonable targets. The following bound will be useful because it gives an estimate of the progress the honest parties have made in an  <span class="math">(\\eta, \\theta)</span> -good execution. We will be interested in the progress coming from uniquely successful rounds, where exactly one honest party computed a POW. Let  <span class="math">Q_r</span>  be the random variable equal to the (maximum) difficulty of such rounds (recall a block with target T has difficulty 1/T); 0 otherwise. We refer to  <span class="math">Q_r</span>  also as &quot;unique&quot; difficulty. We are able to show the following.</p>

    <p class="text-gray-300"><strong>Proposition 2 (Informal).</strong> If r is an  <span class="math">(\\eta, \\theta)</span> -good round in an execution E, then  <span class="math">\\mathbf{E}[Q_r(E_{r-1})] \\geq (1-\\theta f)pn_r</span> , where  <span class="math">Q_r(E_{r-1})</span>  is the unique difficulty conditioned on the execution so far, and  <span class="math">p = \\frac{q}{2\\kappa}</span> .</p>

    <p class="text-gray-300">&quot;Per round&quot; arguments regarding relevant random variables are not sufficient, as we need executions with &quot;good&quot; behavior over a sequence of rounds&mdash;i.e., variables should be concentrated around their means. It turns out that this is not easy to get, as the probabilities of the experiments performed per round depend on the history (due to target recalculation). To deal with this lack of concentration/variance problem, we introduce the following measure.</p>

    <p class="text-gray-300">Typical executions. Intuitively, the idea that this notion captures is as follows. Note that at each round of a given execution E the parties perform Bernoulli trials with success probabilities possibly affected by the adversary. Given the execution, these trials are determined and we may calculate the expected progress the parties make given the corresponding probabilities. We then compare this value to the actual progress and if the difference is &quot;reasonable&quot; we declare E typical. Note, however, that considering this difference by itself will not always suffice, because the variance of the process might be too high. Our definition, in view of Theorem 7 (App. C), says that either the variance is high with respect to the set of rounds we are considering, or the parties have made progress during these rounds as expected. A bit more formally, for a given random oracle query in an execution E, the history of the execution just before the query takes place, determines the parameters of the distribution that the outcome of this query follows as a POW (a Bernoulli trial). For the queries performed in a set of rounds S, let V(S) denote the sum of the variances of these trials.</p>

    <p class="text-gray-300"><strong>Definition 8 (Abridged).</strong> An execution E is  <span class="math">(\\epsilon, \\eta, \\theta)</span> -typical if, for any given set S of consecutive rounds such that V(S) is appropriately bounded from above:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The average unique difficulty is <em>lower</em>-bounded by  <span class="math">\\frac{1}{|S|}(\\sum_{r\\in S} \\mathbf{E}[Q_r(E_{r-1})] \\epsilon(1-\\theta f)p\\sum_{r\\in S} n_r);</span></li>
      <li>the average maximum difficulty is upper-bounded by  <span class="math">\\frac{1}{|S|}(1+\\epsilon)p\\sum_{r\\in S}n_r;</span></li>
      <li>the adversary's average difficulty of blocks with &quot;easy&quot; targets is <em>upper</em>-bounded by  <span class="math">\\frac{1}{|S|}(1+\\epsilon)p\\sum_{r\\in S}t_r</span> , while the <em>number</em> of blocks with &quot;hard&quot; targets is bounded below m by a suitable constant; and</li>
      <li>no &quot;bad events&quot; with respect to the hash function occur (e.g., collisions).</li>
    </ul>

    <p class="text-gray-300">The following is one of the main steps in our analysis.</p>

    <p class="text-gray-300"><strong>Proposition 4 (Informal).</strong> Almost all polynomially bounded executions (in  <span class="math">\\kappa</span> ) are typical. The probability of an execution not being typical is bounded by  <span class="math">\\exp(-\\Omega(\\min\\{m,\\kappa\\}) + \\ln L)</span>  where L is the total run-time.</p>

    <p class="text-gray-300">Recall (Remark 2) that the dynamic setting (specifically, the use of target recalculation functions) offers more opportunities for adversarial attacks [2]. The following important intermediate lemma shows that if a</p>

    <p class="text-gray-300">typical execution is good up to a certain point, chains that are privately mined for long periods of time by the adversary will not be adopted by honest parties.</p>

    <p class="text-gray-300"><strong>Lemma 2 (Informal).</strong> Let E be a typical execution in a  <span class="math">(\\gamma, s)</span> -respecting environment. If  <span class="math">E_r</span>  is  <span class="math">(\\eta, \\theta)</span> -good, then, no honest party adopts at round r+1 a chain that has not been extended by an honest party for at least  <span class="math">O(\\frac{m}{\\tau f})</span>  consecutive rounds.</p>

    <p class="text-gray-300">An easy corollary of the above is that in typical executions, the honest parties' chains cannot contain blocks with timestamps that differ too much from the blocks' actual creation times.</p>

    <p class="text-gray-300">Corollary 1 (Informal). Let E be a typical execution in a  <span class="math">(\\gamma, s)</span> -respecting environment. If  <span class="math">E_{r-1}</span>  is  <span class="math">(\\eta, \\theta)</span> -good, then the timestamp of any block in  <span class="math">E_r</span>  is at most  <span class="math">O(\\frac{m}{\\tau f})</span>  away from its actual creation time (cf. the notion of accuracy in Definition 6).</p>

    <p class="text-gray-300">Additional important results we obtain regarding  <span class="math">(\\eta, \\theta)</span> -good executions are that their epochs last about as much as they should (Lemma 3), as well as a &quot;self-correcting&quot; property, which essentially says that if every chain adopted by an honest party is  <span class="math">(\\eta \\gamma, \\frac{\\theta}{\\gamma})</span> -good in  <span class="math">E_{r-1}</span>  (cf. the notion of a good chain in Definition 5), then  <span class="math">E_r</span>  is  <span class="math">(\\eta, \\theta)</span> -good (Corollary 2). The above (together with several smaller intermediate steps that we omit from this high-level overview) allow us to conclude:</p>

    <p class="text-gray-300"><strong>Theorem 1 (Informal).</strong> A typical execution in a  <span class="math">(\\gamma, s)</span> -respecting environment is  <span class="math">O(\\frac{m}{\\tau f})</span> -accurate and  <span class="math">(\\eta, \\theta)</span> -good.</p>

    <p class="text-gray-300">Common prefix and chain quality. Typical executions give us the two desired low-level properties of the blockchain:</p>

    <p class="text-gray-300">Theorems 2 and 4 (Informal). Let E be a typical execution in a  <span class="math">(\\gamma, s)</span> -respecting environment. Under the requirements of Table 1 (Section 6.1), common prefix holds for any  <span class="math">k \\ge \\theta \\gamma m/8\\tau</span>  and chain quality holds for  <span class="math">\\ell = m/16\\tau f</span>  and  <span class="math">\\mu \\le 1 - \\delta/2</span> , where for all  <span class="math">r, t_r &lt; n_r(1 - \\delta)</span> .</p>

    <p class="text-gray-300">Robust transaction ledger. Given the above we then prove the properties of the robust transaction ledger:</p>

    <p class="text-gray-300">Theorems 5 and 6 (Informal) Under the requirements of Table 1, the backbone protocol satisfies persistence with parameter  <span class="math">k = \\Theta(m)</span>  and liveness with wait time  <span class="math">u = \\Omega(m + k)</span>  for depth k.</p>

    <p class="text-gray-300">We refer to Section 6 for the full analysis of the protocol.</p>

    <p class="text-gray-300">In this section we present the full analysis and proofs of the backbone protocol and robust transaction ledger application with chains of variable difficulty. The analysis follows at a high level the roadmap presented in Section 5.</p>

      <h3 id="sec-6.1" class="text-xl font-semibold mt-8">6.1 Additional notation, definitions, and preliminary propositions</h3>

    <p class="text-gray-300">Our probability space is over all executions of length at most some polynomial in  <span class="math">\\kappa</span> . Formally, the set of elementary outcomes can be defined as a set of strings that encode every variable of every party during each round of a polynomially bounded execution. We won't delve into such formalism and leave the details unspecified. We will denote by  <span class="math">\\mathbf{Pr}</span>  the probability measure of this space. Define also the random variable  <span class="math">\\mathcal{E}</span>  taking values on this space and with distribution induced by the random coins of all entities (adversary, environment, parties) and the random oracle.</p>

    <p class="text-gray-300">Suppose at round r exactly n parties query the oracle with target T. The probability at least one of them will succeed is</p>

    <p class="text-gray-300"><span class="math">f(T,n) = 1 - \\left(1 - \\frac{T}{2^{\\kappa}}\\right)^{qn}.</span></p>

    <p class="text-gray-300">For the initial target T<sup>0</sup> and the initial estimate of the number of parties n0, we denote f<sup>0</sup> = f(T0, n0). Looking ahead, the objective of the target recalculation mechanism would be to maintain a target T for each party such that f(T, nr) &asymp; f<sup>0</sup> for all rounds r. For this reason, we will drop the subscript from f<sup>0</sup> and simply refer to it as f; to avoid confusion, whenever we refer to the function f(&middot;, &middot;), we will specify its two operands.</p>

    <p class="text-gray-300">Note that f(T, n) is concave and increasing in n and T. In particular, Fact <a href="#page-29-2">2</a> applies. The following proposition provides useful bounds on f(T, n). For convenience, define p = q/2 &kappa; .</p>

    <p class="text-gray-300">Proposition 1. For positive integers &kappa;, q, T, n and f(T, n) defined as above,</p>

    <p class="text-gray-300"><span class="math">$\\frac{pTn}{1+pTn} \\leq f(T,n) \\leq pTn \\leq \\frac{f(T,n)}{1-f(T,n)}, \\ \\ where \\ \\ p = \\frac{q}{2^{\\kappa}}.</span>$</p>

    <p class="text-gray-300">Proof. The bounds can be obtained using the inequalities (1 &minus; x) <sup>&alpha;</sup> &ge; 1 &minus; x&alpha;, valid for x &le; 1 and &alpha; &ge; 1, and e <sup>&minus;</sup><sup>x</sup> &le; 1 1+x , valid for x &ge; 0.</p>

    <p class="text-gray-300">At a round r of an execution E the honest parties might be querying the random oracle for various targets. We denote by T min r (E) and T max r (E) the minimum and maximum over those targets. We say r is a target-recalculation point of a valid chain C, if there is a block with timestamp r and m exactly divides the number of blocks up to (and including) this block.</p>

    <p class="text-gray-300">We now define two desirable properties of executions which will be crucial in the analysis. We will show later that most executions have these properties.</p>

    <p class="text-gray-300">Definition 5. Consider an execution E and constants &eta; &isin; (0, 1] and &theta; &isin; [1, &infin;). A target-recalculation point r in a chain C in E is (&eta;, &theta;)-good if the new target T satisfies &eta;f &le; f(T, nr) &le; &theta;f. A chain C in E is (&eta;, &theta;)-good if all its target-recalculation points are (&eta;, &theta;)-good. A round r is (&eta;, &theta;)-good in E if &eta;f &le; f(T min r (E), nr) and f(T max r (E), nr) &le; &theta;f. We say that E is (&eta;, &theta;)-good if every round of E was (&eta;, &theta;)-good.</p>

    <p class="text-gray-300">For a round r, the following set of chains is of interest. It contains, besides the chains that the honest parties have, those chains that could potentially belong to an honest party.</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{S}_r = \\left\\{ \\mathcal{C} \\in E_r \\middle| \\begin{array}{l} \\text{\`\`</span>\\mathcal{C}$ belongs to an honest party&quot; or} \\ \\text{<code>for some chain $\\mathcal{C}'$ of an honest party $diff($\\mathcal{C}'$)&quot; or} \\\\ \\text{</code>for some chain <span class="math">\\mathcal{C}&#x27;</span> of an honest party <span class="math">diff(</span>\\mathcal{C}'<span class="math">) = </span>diff(<span class="math">\\mathcal{C}&#x27;</span>)&quot; and} \\ \\text{head}(<span class="math">\\mathcal{C}</span>) was computed no later than head}(<span class="math">\\mathcal{C}&#x27;</span>)&quot; \\end{array} \\right},$$</p>

    <p class="text-gray-300">where C &isin; E<sup>r</sup> means that C exists and is valid at round r.</p>

    <p class="text-gray-300">Definition 6. Consider an execution E. For &isin; [0, &infin;), a block created at round r is -accurate if it has a timestamp r 0 such that |r <sup>0</sup> &minus; r| &le; m/f. We say that E<sup>r</sup> is -accurate if no chain in S<sup>r</sup> contains a block that is not -accurate. We say that E is -accurate if for every round r in the execution, E<sup>r</sup> is -accurate.</p>

    <p class="text-gray-300">Our next step is to define the typical set of executions. To this end we define a few more quantities and random variables.</p>

    <p class="text-gray-300">In an actual execution E the honest parties may be split across different chains with possibly different targets. We are going to study the progress of the honest parties only when their targets lie in a reasonable range. It will turn out that, with high probability, the honest parties always work with reasonable targets. For a round r, a set of consecutive rounds S, and constant &eta; &isin; (0, 1), let</p>

    <p class="text-gray-300"><span class="math">$T^{(r,\\eta)} = \\frac{\\eta f}{pn_r} \\quad \\text{and} \\quad T^{(S,\\eta)} = \\min_{r \\in S} T^{(r,\\eta)}.</span>$</p>

    <p class="text-gray-300">To expunge the mystery from the definition of T (r,&eta;) , note that in an (&eta;, &theta;)-good round all honest parties query for target at least T (r,&eta;) . We now define for each round r a real random variable D<sup>r</sup> equal to the maximum difficulty among all blocks with targets at least  <span class="math">T^{(r,\\eta)}</span>  computed by honest parties at round r. Define also  <span class="math">Q_r</span>  to equal  <span class="math">D_r</span>  when exactly one block was computed by an honest party and 0 otherwise.</p>

    <p class="text-gray-300">Regarding the adversary, we are going to be interested in periods of time during which he has gathered a number of blocks in the order of m. Given that the targets of blocks are variable themselves, it is appropriate to consider the difficulty acquired by the adversary not in a set of consecutive rounds, but rather in a set of consecutive adversarial queries that may span a number of rounds and are not necessarily a multiple of q.</p>

    <p class="text-gray-300">For a set of consecutive queries indexed by a set J, we define the following value that will act as a threshold for targets of blocks that are attempted by the adversary.</p>

    <p class="text-gray-300"><span class="math">$T^{(J)} = \\frac{\\eta(1-\\delta)(1-2\\epsilon)(1-\\theta f)}{32\\tau^3\\gamma} \\cdot \\frac{m}{|J|} \\cdot 2^{\\kappa}.</span>$</p>

    <p class="text-gray-300">Given the above threshold, for  <span class="math">j \\in J</span> , if the adversary computed at his j-th query a block of difficulty at most  <span class="math">1/T^{(J)}</span> , then let the random variable  <span class="math">A_j^{(J)}</span>  be equal to the difficulty of this block; otherwise, let  <span class="math">A_j^{(J)} = 0</span> . The above definition suggests that we collect in  <span class="math">A_j^{(J)}</span>  the difficulty acquired by the adversary as long as it corresponds to blocks that are not too difficult (i.e., those with targets less than  <span class="math">T^{(J)}</span> ). With foresight we note that this will enable a concentration argument for random variable  <span class="math">A_j^{(J)}</span> . We will usually drop the superscript (J) from A.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{E}_{r-1}</span>  contain the information of the execution just before round r. In particular, a value  <span class="math">E_{r-1}</span>  of  <span class="math">\\mathcal{E}_{r-1}</span>  determines the targets against which every party will query the oracle at round r, but it does not determine  <span class="math">D_r</span>  or  <span class="math">Q_r</span> . If E is a fixed execution (i.e.,  <span class="math">\\mathcal{E} = E</span> ), denote by  <span class="math">D_r(E)</span>  and  <span class="math">Q_r(E)</span>  the value of  <span class="math">D_r</span>  and  <span class="math">Q_r</span>  in E. If a set of consecutive queries J is considered, then, for  <span class="math">j \\in J</span> ,  <span class="math">A_j^{(J)}(E)</span>  is defined analogously. In this case we will also write  <span class="math">\\mathcal{E}_j^{(J)}</span>  for the execution just before the j-th query of the adversary.</p>

    <p class="text-gray-300">With respect to the random variables defined above, the following bound will be useful because it gives an estimate of the progress the honest parties have made in an  <span class="math">(\\eta, \\theta)</span> -good execution. Note that we are interested in the progress coming from uniquely successful rounds, where exactly one honest party computed a POW. The expected difficulty that will be computed by the  <span class="math">n_r</span>  honest parties at round r is  <span class="math">pn_r</span> . However, the easier the POW computation is, the smaller  <span class="math">\\mathbf{E}[Q_r|\\mathcal{E}_{r-1}=E_{r-1}]</span>  will be with respect to this value. Since the execution is  <span class="math">(\\eta, \\theta)</span> -good, a POW is computed by the honest parties with probability at most  <span class="math">\\theta f</span> . This justifies the appearance of  <span class="math">(1-\\theta f)</span>  in the bound.</p>

    <p class="text-gray-300"><strong>Proposition 2.</strong> If round r is  <span class="math">(\\eta, \\theta)</span> -good in E, then  <span class="math">\\mathbf{E}[Q_r | \\mathcal{E}_{r-1} = E_{r-1}] \\geq (1 - \\theta f) pn_r</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Let us drop the subscript r for convenience. Suppose the honest parties query for targets  <span class="math">T_1, T_2, \\ldots, T_n</span>  respectively. We are going to provide a lower bound pretending that honest parties make all q queries (even after a success) and summing over each query the probability that it is the only successful one. We have</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{E}[Q_r | \\mathcal{E}_{r-1} = E_{r-1}] \\ge \\sum_{i \\in [n]} q \\cdot \\frac{1}{T_i} \\cdot \\frac{T_i}{2^{\\kappa}} \\left( 1 - \\frac{T_i}{2^{\\kappa}} \\right)^{q-1} \\prod_{i \\ne j \\in [n]} \\left[ 1 - f(T_j, 1) \\right] \\ge \\sum_{i \\in [n]} p \\prod_{j \\in [n]} \\left[ 1 - f(T_j, 1) \\right]</span>$</p>

    <p class="text-gray-300"><span class="math">$\\ge \\sum_{i \\in [n]} p \\prod_{j \\in [n]} \\left[ 1 - f(T^{\\max}, 1) \\right] = \\sum_{i \\in [n]} p \\left[ 1 - f(T^{\\max}, n) \\right] \\ge \\sum_{i \\in [n]} p \\left[ 1 - \\theta f \\right) p n,</span>$</p>

    <p class="text-gray-300">where the third inequality holds because f(T, n) is increasing in T.</p>

    <p class="text-gray-300">The properties we have defined will be shown to hold in a  <span class="math">(\\gamma, s)</span> -respecting environment, for suitable  <span class="math">\\gamma</span>  and s. The following simple fact is a consequence of the definition.</p>

    <p class="text-gray-300"><strong>Fact 1.</strong> In a  <span class="math">(\\gamma, s)</span> -respecting environment, for any set S of consecutive rounds with  <span class="math">|S| \\leq s</span> , any  <span class="math">S&#x27; \\subseteq S</span> , and any  <span class="math">n \\in \\{n_r : r \\in S\\}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\frac{1}{\\gamma} \\cdot n \\leq \\frac{1}{|S&#x27;|} \\cdot \\sum_{r \\in S&#x27;} n_r \\leq \\gamma \\cdot n.</span>$</p>

    <p class="text-gray-300"><span class="math">n_r</span> : number of honest parties mining in round r.</p>

    <p class="text-gray-300"><span class="math">t_r</span> : number of activated parties that are corrupted.</p>

    <p class="text-gray-300"><span class="math">\\delta</span> : advantage of honest parties,  <span class="math">\\forall r(t_r/n_r &lt; 1 - \\delta)</span></p>

    <p class="text-gray-300"><span class="math">(\\gamma, s)</span> : determines how the number of parties fluctuates across rounds, cf. Definition 1.</p>

    <p class="text-gray-300">f: probability at least one honest party succeeds in a round assuming  <span class="math">n_0</span>  parties and target  <span class="math">T_0</span>  (the protocol's initialization parameters).</p>

    <p class="text-gray-300"><span class="math">\\tau</span> : the dampening filter, see Definition 2.</p>

    <p class="text-gray-300"><span class="math">(\\eta,\\theta):</span>  lower and upper bound determining the goodness of an execution, cf. Definition 5.</p>

    <p class="text-gray-300"><span class="math">\\epsilon</span> : quality of concentration of random variables in typical executions, cf. Definition 8.</p>

    <p class="text-gray-300">m: the length of an epoch in number of blocks.</p>

    <p class="text-gray-300">L: the total run-time of the system.</p>

    <p class="text-gray-300">Table 1: System parameters and requirements on them. The parameters are as follows: positive integers s, m, L; positive reals  <span class="math">f, \\gamma, \\delta, \\epsilon, \\tau, \\eta, \\theta</span> , where  <span class="math">f, \\epsilon, \\delta \\in (0, 1)</span> , and  <span class="math">0 &lt; \\eta \\le 1 \\le \\theta</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The average of several numbers is bounded by their min and max. Furthermore, the definition of  <span class="math">(\\gamma, s)</span> -respecting implies  <span class="math">\\min_{r \\in S} n_r \\ge \\frac{1}{\\gamma} \\max_{r \\in S} n_r \\ge \\frac{1}{\\gamma} n</span>  and  <span class="math">\\max_{r \\in S} n_r \\le \\gamma \\min_{r \\in S} \\le \\gamma n</span> . Thus,</p>

    <p class="text-gray-300"><span class="math">$\\frac{1}{\\gamma} \\cdot n \\le \\min_{r \\in S} n_r \\le \\min_{r \\in S&#x27;} n_r \\le \\frac{1}{|S&#x27;|} \\cdot \\sum_{r \\in S&#x27;} n_r \\le \\max_{r \\in S&#x27;} n_r \\le \\max_{r \\in S} n_r \\le \\gamma \\cdot n.</span>$</p>

    <p class="text-gray-300">Our analysis involves a number of parameters that are suitably related. Table 1 summarizes them, recalls their definitions and lists all the constraints that they should satisfy.</p>

    <p class="text-gray-300">Remark 3. We remark that for the actual parameterization of the parameters  <span class="math">\\tau</span> , m, f of  <span class="math">Bitcoin^5</span> , i.e.,  <span class="math">\\tau = 4, m = 2016, f = 0.03</span> , vis-&agrave;-vis the constraints of Table 1, they can be satisfied for  <span class="math">\\delta = 0.99, \\eta = 0.268, \\theta = 1.995, \\epsilon = 2.93 \\cdot 10^{-8}</span> , for  <span class="math">\\gamma = 1.281</span>  and  <span class="math">s = 2.71 \\cdot 10^{5}</span> . Given that s measures the number of rounds within which a fluctuation of  <span class="math">\\gamma</span>  may take place, we have that the constraints are satisfiable for a fluctuation of up to 28% every approximately 2 months (considering a round to last 18 seconds).</p>

      <h3 id="sec-6.2" class="text-xl font-semibold mt-8">6.2 Chain-Growth Lemma</h3>

    <p class="text-gray-300">We now prove the Chain-growth lemma. This lemma appears already in [11], but it refers to number of blocks instead of difficulty. In [15] the name &quot;chain growth&quot; appears for the first time and the authors explicitly state a chain-growth property.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup>Note that in order to calculate f, we can consider that a round of full interaction lasts 18 seconds; if this is combined with the fact that the target is set for a POW to be discovered approximately every 10 minutes, we have that 18/600 = 0.3 is a good estimate for f.</p>

    <p class="text-gray-300">Informally, this lemma says that honest parties will make as much progress as how many POWs they obtain. Although simple to prove, the chain-growth lemma is very important, because it shows that no matter what the adversary does the honest parties will advance (in terms of accumulated difficulty) by at least the difficulty of the POWs they have acquired.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Let E be any execution. Suppose that at round u an honest party has a chain of difficulty d. Then, by round  <span class="math">v \\ge u</span> , every honest party will have received a chain of difficulty at least</p>

    <p class="text-gray-300"><span class="math">$d + \\sum_{u \\le r &lt; v} D_r(E).</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> By induction on v-u. For the basis, v=u and  <span class="math">d+\\sum_{r=u}^{v-1}D_r(E)=d</span> . Observe that if at round u an honest party has a chain  <span class="math">\\mathcal{C}</span>  of difficulty d, then that party broadcast  <span class="math">\\mathcal{C}</span>  at a round earlier than u. It follows that every honest party will receive  <span class="math">\\mathcal{C}</span>  by round u.</p>

    <p class="text-gray-300">For the inductive step, note that by the inductive hypothesis every honest party has received a chain of difficulty at least  <span class="math">d&#x27; = d + \\sum_{r=u}^{v-1} D_r</span>  by round v. When  <span class="math">D_v = 0</span>  the statement follows directly, so assume  <span class="math">D_v &gt; 0</span> . Since every honest party queried the oracle with a chain of difficulty at least d' at round v, if follows that an honest party successful at round v broadcast a chain of difficulty at least  <span class="math">d&#x27; + D_v = d + \\sum_{r=u}^{v} D_r</span> .  <span class="math">\\square</span></p>

      <h3 id="sec-6.3" class="text-xl font-semibold mt-8">6.3 Typical Executions: Definition and Related Proofs</h3>

    <p class="text-gray-300">We can now define formally our notion of typical executions. Intuitively, the idea that this definition captures is as follows. Suppose that we examine a certain execution E. Note that at each round of E the parties perform Bernoulli trials with success probabilities possibly affected by the adversary. Given the execution, these trials are determined and we may calculate the expected progress the parties make given the corresponding probabilities. We then compare this value to the actual progress and if the difference is reasonable we declare E typical. Note, however, that considering this difference by itself will not always suffice, because the variance of the process might be too high. Our definition, in view of Theorem 7, says that either the variance is high with respect to the set of rounds we are considering, or the parties have made progress during these rounds as expected.</p>

    <p class="text-gray-300">Beyond the behavior of random variables described above, a typical execution will also be characterized by the absence of a number of bad events about the underlying hash function  <span class="math">H(\\cdot)</span>  which is used in proofs of work and is modeled as a random oracle. The bad events that are of concern to us are defined as follows (recall that a block's creation time is the round that it has been successfully produced by a query to the random oracle either by the adversary or an honest party).</p>

    <p class="text-gray-300"><strong>Definition 7.</strong> An insertion occurs when, given a chain C with two consecutive blocks B and B', a block  <span class="math">B^*</span>  created after B' is such that  <span class="math">B, B^*, B&#x27;</span>  form three consecutive blocks of a valid chain. A copy occurs if the same block exists in two different positions. A prediction occurs when a block extends one with later creation time.</p>

    <p class="text-gray-300">Given the above we are now ready to specify what is a typical execution.</p>

    <p class="text-gray-300"><strong>Definition 8</strong> (Typical execution). An execution E is  <span class="math">(\\epsilon, \\eta, \\theta)</span> -typical if the following hold:</p>

    <p class="text-gray-300">(a) If, for any set S of consecutive rounds,  <span class="math">pT^{(S,\\eta)}\\sum_{r\\in S}n_r\\geq \\frac{\\eta m}{16\\tau\\gamma}</span> , then</p>

    <p class="text-gray-300"><span class="math">$\\sum_{r \\in S} Q_r(E) &gt; \\sum_{r \\in S} \\mathbf{E}[Q_r | \\mathcal{E}_{r-1} = E_{r-1}] - \\epsilon (1 - \\theta f) p \\sum_{r \\in S} n_r</span>$
and
<span class="math">$\\sum_{r \\in S} D_r(E) &lt; (1 + \\epsilon) p \\sum_{r \\in S} n_r.</span>$</p>

    <p class="text-gray-300">(b) For any set I indexing a set of consecutive queries of the adversary we have</p>

    <p class="text-gray-300"><span class="math">$\\sum_{j \\in J} A_j(E) &lt; (1 + \\epsilon)2^{-\\kappa} |J|</span>$</p>

    <p class="text-gray-300">and the blocks with targets less than  <span class="math">\\tau T^{(J)}</span>  that the adversary acquired are less than  <span class="math">\\frac{\\eta(1-\\epsilon)(1-\\theta f)}{32\\tau^2\\gamma}\\cdot m</span> .</p>

    <p class="text-gray-300">(c) No insertions, no copies, and no predictions occurred in E.</p>

    <p class="text-gray-300"><strong>Remark 4.</strong> Note that if J indexes the queries of the adversary in a set S of consecutive rounds, then  <span class="math">|J| = q \\sum_{r \\in S} t_r</span>  and the inequality in Definition 8(b) reads  <span class="math">\\sum_{j \\in J} A_j(E) &lt; (1+\\epsilon)p \\sum_{r \\in S} t_r</span> .</p>

    <p class="text-gray-300">The next proposition simplifies our applications of Definition 8(a).</p>

    <p class="text-gray-300"><strong>Proposition 3.</strong> Assume E is a typical execution in a  <span class="math">(\\gamma, s)</span> -respecting environment. For any set S of consecutive rounds with  <span class="math">|S| \\ge \\frac{m}{16\\tau f}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\sum_{r \\in S} D_r &lt; (1 + \\epsilon) p \\sum_{r \\in S} n_r.</span>$</p>

    <p class="text-gray-300">If in addition, E is  <span class="math">(\\eta, \\theta)</span> -good, then</p>

    <p class="text-gray-300"><span class="math">$\\sum_{r \\in S} Q_r &gt; (1 - \\epsilon)(1 - \\theta f)p \\sum_{r \\in S} n_r</span>$</p>

    <p class="text-gray-300">and any block computed by an honest party at any round r corresponds to target at least  <span class="math">T^{(r,\\eta)}</span> , and so contributes to the random variables  <span class="math">D_r</span>  and  <span class="math">Q_r</span>  (if the r was uniquely successful).</p>

    <p class="text-gray-300"><em>Proof.</em> We first partition S into several parts with size at least  <span class="math">\\frac{m}{16\\tau f}</span>  and at most s. In view of Proposition 2, for both of the inequalities, we only need to verify the 'if' part of Definition 8(a) for each part S' of S. Indeed, by the definition of  <span class="math">T^{(S&#x27;,\\eta)}</span>  and Fact 1,  <span class="math">pT^{(S&#x27;,\\eta)}\\sum_{r\\in S&#x27;}n_r\\geq \\eta f|S&#x27;|/\\gamma\\geq \\frac{\\eta m}{16\\tau\\gamma}</span> . The last part, in view of the definition of  <span class="math">T^{(r,\\eta)}</span> , is equivalent to r being  <span class="math">(\\eta,\\theta)</span> -good.</p>

    <p class="text-gray-300">Almost all polynomially bounded executions (in  <span class="math">\\kappa</span> ) are typical:</p>

    <p class="text-gray-300"><strong>Proposition 4.</strong> Assuming the ITM system  <span class="math">(\\mathcal{Z},C)</span>  runs for L steps, the event &quot; <span class="math">\\mathcal{E}</span>  is not typical&quot; is bounded by  <span class="math">\\exp(-\\Omega(\\min\\{m,\\kappa\\}) + \\ln L)</span> . Specifically, the bound is  <span class="math">\\exp\\{-\\frac{\\eta\\epsilon^2(1-2\\delta)}{64\\tau^3\\gamma}m - \\ln(2)(\\kappa-1) + 4\\ln L + 2\\ln 2\\}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Since the length of the execution, L, is fixed we will prove the stated bound for a fixed set of consecutive rounds S and then apply a union bound over all such sets in the length of the execution. Let k be the size of S and identify it, without loss of generality, with  <span class="math">[k] = \\{1, 2, ..., k\\}</span> . For part (a), define a sequence of random variables by</p>

    <p class="text-gray-300"><span class="math">$X_0 = 0; \\ X_r = \\sum_{i \\in [r]} Q_i - \\sum_{i \\in [r]} \\mathbf{E}[Q_i | \\mathcal{E}_{i-1}], \\ r \\in [k].</span>$</p>

    <p class="text-gray-300">This forms a martingale with respect to the sequence  <span class="math">\\mathcal{E}_0, \\mathcal{E}_1, \\dots, \\mathcal{E}_k</span> , because (recalling basic properties of conditional expectation [17]),</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{E}[X_r|\\mathcal{E}_{r-1}] = \\mathbf{E}[Q_r - \\mathbf{E}[Q_r|\\mathcal{E}_{r-1}]|\\mathcal{E}_{r-1}] + \\mathbf{E}[X_{r-1}|\\mathcal{E}_{r-1}] = X_{r-1}.</span>$</p>

    <p class="text-gray-300">Specifically, the above follows from linearity of conditional expectation, and the fact that  <span class="math">X_{r-1}</span>  is a deterministic function of  <span class="math">\\mathcal{E}_{r-1}</span> .</p>

    <p class="text-gray-300">Now suppose the first inequality of Definition 8(a) fails. The probability of this event is equal to</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Pr}[X_k \\le X_0 - t], \\text{ for } t = \\epsilon (1 - \\theta f) p \\sum_{r \\in S} n_r.</span>$</p>

    <p class="text-gray-300">For b and V defined with respect to Theorem 7, we have  <span class="math">b \\leq 1/T^{(S,\\eta)}</span>  and  <span class="math">V \\leq v</span> , where  <span class="math">v = p \\sum_{r \\in S} n_r/T^{(S,\\eta)}</span> . To prove the bound on V, note that</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{var}(X_r - X_{r-1}|\\mathcal{E}_{r-1}) = \\mathbf{E}\\left[\\left(Q_r - \\mathbf{E}[Q_r|\\mathcal{E}_{r-1}]\\right)^2 \\middle| \\mathcal{E}_{r-1}\\right] = \\mathbf{E}[Q_r^2|\\mathcal{E}_{r-1}] - \\left(\\mathbf{E}[Q_r|\\mathcal{E}_{r-1}]\\right)^2.</span>$</p>

    <p class="text-gray-300">Thus, it suffices to show  <span class="math">\\mathbf{E}[Q_r^2|\\mathcal{E}_{r-1}] \\leq pn_r/T^{(r,\\eta)} \\leq pn_r/T^{(S,\\eta)}</span> . To this end, suppose that the honest parties at round r were split into  <span class="math">\\ell</span>  chains with corresponding targets  <span class="math">T^{(r,\\eta)} \\leq T_1 \\leq T_2 \\leq \\cdots \\leq T_\\ell</span> . Let also  <span class="math">\\hat{n}_1, \\hat{n}_2, \\ldots, \\hat{n}_\\ell</span> , with  <span class="math">\\hat{n}_1 + \\cdots + \\hat{n}_\\ell \\leq n_r</span> , be the corresponding number of parties with each chain. Then, for any  <span class="math">E_{r-1}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{E}[Q_r^2 | \\mathcal{E}_{r-1} = E_{r-1})] \\le \\sum_{i \\in [\\ell]} \\frac{1}{T_i^2} \\cdot f(T_i, \\hat{n}_i) \\cdot \\prod_{j \\ne i} \\left[ 1 - f(T_j, \\hat{n}_j) \\right] \\le \\sum_{i \\in [\\ell]} \\frac{p \\hat{n}_i}{T_i} \\le \\frac{p n_r}{T^{(r, \\eta)}}.</span>$</p>

    <p class="text-gray-300">We apply Theorem 7 on  <span class="math">-X_0, -X_1, \\ldots</span> , noting that  <span class="math">V \\leq v</span>  always holds. Recalling Requirement (R2) and that  <span class="math">pT^{(S,\\eta)} \\sum_{r \\in S} n_r \\geq \\frac{\\eta m}{16\\tau\\gamma}</span> , we obtain</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Pr}[X_k \\le X_0 - t] \\le \\exp\\left\\{-\\frac{3\\epsilon^2 (1 - \\theta f)^2 \\eta m}{32(3 + \\epsilon)\\tau\\gamma}\\right\\} \\le \\exp\\left\\{-\\frac{\\epsilon^2 (1 - \\delta) \\eta m}{32\\tau\\gamma}\\right\\}.</span>$</p>

    <p class="text-gray-300">For the bounds on  <span class="math">\\sum_{r \\in S} D_r(E)</span>  and  <span class="math">\\sum_{j \\in J} A_j(E)</span>  the proof follows the same lines. In particular, replace Q by D and A (in the case of A the martingale will be indexed by J) and note that in these cases the martingale need not be negated.</p>

    <p class="text-gray-300">In more details, regarding the bound on D in part (a), using the same notation as above, we have that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{E}[D_r | \\mathcal{E}_{r-1} = E_{r-1})] = \\sum_{i \\in [\\ell]} \\frac{1}{T_i} \\cdot f(T_i, \\hat{n}_i) \\cdot \\prod_{j=1}^{i-1} [1 - f(T_j, \\hat{n}_j)] \\le \\sum_{i \\in [\\ell]} p \\hat{n}_i \\le p n_r</span>$</p>

    <p class="text-gray-300">and so</p>

    <p class="text-gray-300"><span class="math">$\\sum_{r \\in S} \\mathbf{E}[D_r | \\mathcal{E}_{r-1}] \\le p \\sum_{r \\in S} n_r.</span>$</p>

    <p class="text-gray-300">A similar argument provides the bound  <span class="math">\\mathbf{E}[D_r^2|\\mathcal{E}_{r-1}=E_{r-1})] \\leq pn_r/T^{(r,\\eta)}</span>  from which we can obtain the bound  <span class="math">V \\leq v = p \\sum_{r \\in S} n_r/T^{(S,\\eta)}</span> .</p>

    <p class="text-gray-300">We next focus on part (b). Note first that if  <span class="math">|J| \\leq \\frac{\\eta(1-\\delta)(1-2\\epsilon)(1-\\theta f)}{32\\tau^3\\gamma} \\cdot m</span> , then  <span class="math">T^{(J)} \\geq 2^{\\kappa}</span>  and the inequalities hold trivially. First we will show that for the martingale  <span class="math">X_0, X_1, X_2, \\ldots</span>  with respect to  <span class="math">\\mathcal{E}_0^{(J)}, \\mathcal{E}_1^{(J)}, \\mathcal{E}_2^{(J)}, \\ldots</span>  that is defined as</p>

    <p class="text-gray-300"><span class="math">$X_0 = 0; \\ X_j = \\sum_{i \\in [j]} A_i - \\sum_{i \\in [j]} \\mathbf{E}[A_i | \\mathcal{E}_{i-1}^{(J)}], \\ j \\in J,</span>$</p>

    <p class="text-gray-300">it holds that  <span class="math">b \\leq 1/T^{(J)}</span>  and  <span class="math">V \\leq v</span>  for  <span class="math">v = 2^{-\\kappa}|J|/T^{(J)}</span> , for the quantities b and V defined as in Theorem 7. Consider an execution prefix  <span class="math">E_{j-1}^{(J)}</span>  and the target that is selected by the adversary in its j-th query. Note that we can associate such value to any query of the form (ctr,g) where g = G(r,st,x) by recovering the chain that corresponds to st. If such value is below  <span class="math">T^{(J)}</span> , or is not defined,  <span class="math">A_j = 0</span> . Thus, we have  <span class="math">\\mathbf{E}[A_j|\\mathcal{E}_{j-1}^{(J)} = E_{j-1}^{(J)}] \\leq 2^{-\\kappa}</span>  and  <span class="math">\\mathbf{E}[A_j^2|\\mathcal{E}_{j-1}^{(J)} = E_{j-1}^{(J)}] \\leq 2^{-\\kappa}/T^{(J)}</span> , obtaining</p>

    <p class="text-gray-300"><span class="math">$\\sum_{j\\in J} \\mathbf{E}[A_j|\\mathcal{E}_{j-1}^{(J)}] \\le 2^{-\\kappa}|J| \\quad \\text{and} \\quad V \\le v.</span>$</p>

    <p class="text-gray-300">We now have the following by setting  <span class="math">t = \\epsilon 2^{-\\kappa} |J|</span> .</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Pr}\\Big[\\sum_{j\\in J} A_j \\ge (1+\\epsilon)2^{-\\kappa}|J|\\Big] = \\mathbf{Pr}\\Big[\\sum_{j\\in J} A_j \\ge t + 2^{-\\kappa}|J|\\Big] \\le \\mathbf{Pr}\\Big[\\sum_{j\\in J} A_j \\ge t + \\sum_{j\\in J} \\mathbf{E}[A_j|\\mathcal{E}_{j-1}^{(J)}]\\Big]</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\mathbf{Pr}\\Big[\\sum_{j\\in J} (A_j - \\mathbf{E}[A_j|\\mathcal{E}_{j-1}^{(J)}]) \\ge t\\Big] \\le \\exp\\Big\\{-\\frac{t^2}{2v + 2bt/3}\\Big\\} \\le \\exp\\Big\\{-\\frac{3\\epsilon^2 2^{-\\kappa}|J|T^{(J)}}{(6+2\\epsilon)}\\Big\\}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\le \\exp\\Big\\{-\\frac{3\\eta\\epsilon^2 (1-\\delta)(1-\\theta f)(1-2\\epsilon)m}{64(3+\\epsilon)\\tau^3\\gamma}\\Big\\} \\le \\exp\\Big\\{-\\frac{\\eta\\epsilon^2 (1-2\\delta)m}{64\\tau^3\\gamma}\\Big\\}.</span>$</p>

    <p class="text-gray-300">To verify the inequalities in the last line, recall  <span class="math">T^{(J)} = \\frac{\\eta(1-\\delta)(1-2\\epsilon)(1-\\theta f)}{32\\tau^3\\gamma} \\cdot \\frac{m}{|J|} \\cdot 2^{\\kappa}</span>  and Requirement (R2).</p>

    <p class="text-gray-300">Regarding the second part of (b), in order to bound the number of blocks of target less than  <span class="math">\\tau T^{(J)}</span>  the adversary can acquire, define a Boolean random variable  <span class="math">Z_j</span> , for each  <span class="math">j \\in J</span>  as follows. If the corresponding target is less than  <span class="math">\\tau T^{(J)}</span>  and the query was successful, then  <span class="math">Z_j = 1</span> , otherwise  <span class="math">Z_j = 0</span> . We can then define a martingale as in part (a), by letting k = |J| and replacing Q with Z. We have  <span class="math">b \\leq 1</span>  and  <span class="math">V \\leq 2^{-\\kappa} \\tau T^{(J)}</span> . Since</p>

    <p class="text-gray-300"><span class="math">$\\sum_{j \\in [|J|]} \\mathbf{E}[Z_j | \\mathcal{E}_{j-1}^{(J)}] \\le 2^{-\\kappa} \\tau T^{(J)} |J| = \\frac{\\eta (1 - 2\\epsilon) (1 - \\theta f)}{32\\tau^2 \\gamma} \\cdot m</span>$</p>

    <p class="text-gray-300">and  <span class="math">(1+\\epsilon)(1-2\\epsilon) &lt; (1-\\epsilon)</span> , for  <span class="math">t = \\epsilon \\cdot \\frac{\\eta(1-2\\epsilon)(1-\\theta f)}{32\\tau^2\\gamma} \\cdot m</span>  we have (using Requirement (R2) to simplify in the last step)</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Pr}\\bigg[\\sum_{j\\in[|J|]} Z_j \\geq \\frac{\\eta(1-\\epsilon)(1-\\theta f)}{32\\tau^2\\gamma} \\cdot m\\bigg] \\leq \\mathbf{Pr}[X_k \\geq X_0 + t] \\leq \\exp\\Big\\{-\\frac{\\eta\\epsilon^2(1-\\delta/2)m}{32\\tau^2\\gamma}\\Big\\}.</span>$</p>

    <p class="text-gray-300">For part (c) and  <span class="math">i \\in \\{0, 1, 2, 3\\}</span> , let  <span class="math">B_i = \\langle r_i, st_i, x_i, ctr_i \\rangle</span>  and  <span class="math">g_i = G(r_i, st_i, x_i)</span> . If a block extends two distinct blocks, then a collision has occurred. To see this, suppose block  <span class="math">B_3</span>  extents two distinct blocks  <span class="math">B_1</span>  and  <span class="math">B_2</span> . Then  <span class="math">st_3 = H(ctr_1, g_1) = H(ctr_2, g_2)</span> ; implying a collision either in H or in G, since  <span class="math">B_1</span>  and  <span class="math">B_2</span>  are distinct.</p>

    <p class="text-gray-300">The existence of an insertion or a copy implies a collision as well. Suppose the adversary inserts a block  <span class="math">B_2</span>  among two existing blocks  <span class="math">B_1</span>  and  <span class="math">B_3</span> . Then,  <span class="math">B_3</span>  extends both  <span class="math">B_1</span>  and  <span class="math">B_2</span>  and since  <span class="math">B_2</span>  extends  <span class="math">B_1</span> ,  <span class="math">r_1 &lt; r_2</span>  and the blocks are distinct. Similarly, if  <span class="math">B_3</span>  is a copy of  <span class="math">B_1</span>  (i.e.,  <span class="math">B_3 = B_1</span> ), then there exist two distinct blocks  <span class="math">B_2</span>  and  <span class="math">B_0</span>  that are both extended by the same block. To see this, note that either  <span class="math">B_0</span>  and  <span class="math">B_2</span>  are the ones that  <span class="math">B_1</span>  and  <span class="math">B_3</span>  extend, or if these are not distinct, then  <span class="math">B_2</span>  is a copy of  <span class="math">B_0</span>  and so on. Eventually, two distinct blocks will be reached, since  <span class="math">B_1</span>  and  <span class="math">B_3</span>  are assumed to be on different chains. If the total running time of the system of ITM's is L then it holds that there are at most L queries posed to G, H. It follows that the probability of a collision occurring is  <span class="math">\\binom{L}{2} 2^{-\\kappa+1} \\leq 2^{-\\kappa+1+2\\log L}</span> .</p>

    <p class="text-gray-300">Finally, note that, for polynomially many rounds in  <span class="math">\\kappa</span> , the probability that a guessed block occurs is exponentially small in  <span class="math">\\kappa</span> .</p>

      <h3 id="sec-6.4" class="text-xl font-semibold mt-8">6.4 Typical Executions are Good and Accurate</h3>

    <p class="text-gray-300"><strong>Lemma 2.</strong> Let E be a typical execution in a  <span class="math">(\\gamma, s)</span> -respecting environment. If  <span class="math">E_r</span>  is  <span class="math">(\\eta, \\theta)</span> -good, then  <span class="math">S_{r+1}</span>  contains no chain that has not been extended by an honest party for at least  <span class="math">\\frac{m}{16\\tau f}</span>  consecutive rounds.</p>

    <p class="text-gray-300"><em>Proof.</em> Suppose&mdash;towards a contradiction&mdash; <span class="math">C \\in S_{r+1}</span>  and has not been extended by an honest party for at least  <span class="math">\\frac{m}{16\\tau f}</span>  rounds. Without loss of generality we may assume that r+1 is the first such round.</p>

    <p class="text-gray-300">Let  <span class="math">r^* \\leq r</span>  denote the greatest timestamp among the blocks of  <span class="math">\\mathcal{C}</span>  computed by honest parties (let  <span class="math">r^* = 0</span>  if none exists). Define  <span class="math">S = \\{r^* + 1, \\ldots, r\\}</span>  and note that, by our assumption for  <span class="math">\\mathcal{C}</span> ,  <span class="math">|S| \\geq \\frac{m}{16\\tau f}</span> . Let  <span class="math">J = \\{1, \\ldots, q \\sum_{r \\in S} t_r\\}</span>  be the index-set of the adversarial queries during the rounds in S. Suppose that the blocks of  <span class="math">\\mathcal{C}</span>  with timestamps in S span k epochs with corresponding targets  <span class="math">T_1, \\ldots, T_k</span> . For  <span class="math">i \\in [k]</span>  let  <span class="math">m_i</span>  be the number of blocks with target  <span class="math">T_i</span>  and set  <span class="math">M = m_1 + \\cdots + m_k</span> .</p>

    <p class="text-gray-300">Our plan is to contradict the assumption that  <span class="math">C \\in S_{r+1}</span> , by showing that the honest parties have accumulated more difficulty than the adversary. To be precise, note that the blocks C has gained in S sum to  <span class="math">\\sum_{i \\in [k]} \\frac{m_i}{T_i}</span>  difficulty. On the other hand, by the Chain-Growth Lemma 1, all the honest parties have advanced during the rounds in S by  <span class="math">\\sum_{r \\in S} D_r(E) \\ge \\sum_{r \\in S} Q_r(E)</span> . Since  <span class="math">|S| \\ge \\frac{m}{16\\tau f}</span> , Proposition 3 implies that  <span class="math">\\sum_{r \\in S} Q_r(E)</span>  is greater than  <span class="math">(1 - \\epsilon)(1 - \\theta f)p\\sum_{r \\in S} n_r</span> . Therefore, to obtain a contradiction, it suffices to show that</p>

    <p class="text-gray-300">
<span class="math">$\\sum_{i \\in [k]} \\frac{m_i}{T_i} \\le (1 - \\epsilon)(1 - \\theta f)p \\sum_{r \\in S} n_r. \\tag{1}</span>$</p>

    <p class="text-gray-300">We proceed by considering cases on M.</p>

    <p class="text-gray-300">First, suppose  <span class="math">M \\geq 2M&#x27;</span> , where  <span class="math">M&#x27; = \\frac{\\eta(1-\\epsilon)(1-\\theta f)}{32\\tau^2\\gamma} \\cdot m</span>  (see Definition 8(b)). Partition the part of  <span class="math">\\mathcal{C}</span>  with these M blocks into  <span class="math">\\ell</span>  parts, so that each part has the following properties: (1) it contains at most one target-calculation point, and (2) it contains at least M' blocks with the same target. Note that such a partition exists because  <span class="math">M \\geq 2M&#x27;</span>  and M' &lt; m. For  <span class="math">i \\in [\\ell]</span> , let  <span class="math">j_i \\in J</span>  be the index of the query during which the last block of the i-th part was computed. Set  <span class="math">J_i = \\{j_{i-1} + 1, \\ldots, j_i\\}</span> , with  <span class="math">j_0 = 0</span> . Note that Definition 8(c) implies  <span class="math">j_{i-1} &lt; j_i</span> , and this is a partition of J. Recalling Definition 8(b), the sum of the difficulties of all the blocks in the i-th part is at most  <span class="math">\\sum_{j \\in J_i} A_j(E)</span> . This holds because for one of the targets more than M' blocks have been computed in  <span class="math">J_i</span>  and so is at least  <span class="math">\\tau T^{(J_i)}</span>  and targets with at most one calculation point between them can differ by a factor at most  <span class="math">\\tau</span> . Thus,</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i \\in [k]} \\frac{m_i}{T_i} \\le \\sum_{\\substack{i \\in [\\ell] \\\\ j \\in J_i}} A_j(E) &lt; \\sum_{i \\in [\\ell]} (1+\\epsilon) 2^{-\\kappa} |J_i| = (1+\\epsilon) p \\sum_{r \\in S} t_r \\le (1+\\epsilon) (1-\\delta) p \\sum_{r \\in S} n_r,</span>$</p>

    <p class="text-gray-300">where in the last step we used Requirement (R0). Requirement (R1) implies  <span class="math">(1+\\epsilon)(1-\\delta) \\le (1-\\epsilon)(1-\\theta f)</span> ; thus, Equation (1) holds concluding the case  <span class="math">M \\ge 2M&#x27;</span> .</p>

    <p class="text-gray-300">Otherwise,  <span class="math">k \\leq 2</span>  and  <span class="math">m_1 + m_2 &lt; 2M&#x27;</span> . Let S' consist of the first  <span class="math">\\frac{m}{16\\tau f}</span>  rounds of S. We are going to argue that in this case Equation (1) holds even for S' in the place of S. Since we are in a  <span class="math">(\\gamma, s)</span> -respecting environment, by Fact 1,  <span class="math">\\gamma \\sum_{r \\in S&#x27;} n_r \\geq n_{r^*} |S&#x27;|</span> . Furthermore, since  <span class="math">r^*</span>  is  <span class="math">(\\eta, \\theta)</span> -good,  <span class="math">T_1 \\geq T^{(r^*, \\eta)} = \\eta f/pn_{r^*}</span> . Recalling also that  <span class="math">T_2 \\geq T_1/\\tau</span> , we have  <span class="math">\\frac{m_1}{T_1} + \\frac{m_2}{T_2} \\leq \\frac{m_1 + \\tau m_2}{T_1}</span> , which in turn is at most</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\tau M}{T^{(r^*,\\eta)}} &lt; \\frac{2\\tau M&#x27;pn_{r^*}}{\\eta f} \\leq \\frac{2\\tau \\gamma M&#x27;p\\sum_{r\\in S&#x27;}n_r}{\\eta f|S&#x27;|} \\leq \\frac{32\\tau^2\\gamma M&#x27;p\\sum_{r\\in S}n_r}{\\eta m}</span>$</p>

    <p class="text-gray-300">and, after substituting M', Equation (1) holds concluding this case and the proof.</p>

    <p class="text-gray-300">Corollary 1. Let E be a typical execution in a  <span class="math">(\\gamma, s)</span> -respecting environment. If  <span class="math">E_{r-1}</span>  is  <span class="math">(\\eta, \\theta)</span> -good, then  <span class="math">E_r</span>  is  <span class="math">\\frac{m}{16\\tau f}</span> -accurate.</p>

    <p class="text-gray-300">Proof. Suppose&mdash;towards a contradiction&mdash;that, for some  <span class="math">r^* \\leq r</span> ,  <span class="math">C \\in \\mathcal{S}_{r^*}</span>  contains a block which is not  <span class="math">\\frac{m}{16\\tau f}</span> -accurate and let  <span class="math">u \\leq r^* \\leq r</span>  be the timestamp of this block and v its creation time. If  <span class="math">u - v &gt; \\frac{m}{16\\tau f}</span> , then every honest party would consider C to be invalid during rounds  <span class="math">v, v + 1, \\ldots, u</span> . If  <span class="math">v - u &gt; \\frac{m}{16\\tau f}</span> , then in order for C to be valid it should not contain any honest block with timestamp in  <span class="math">u, u + 1, \\ldots, v</span> . (Note that we are using Definition 8(c) here as a block could be inserted later.) In either case,  <span class="math">C \\in \\mathcal{S}_{r^*}</span> , but has not been extended by an honest party for at least  <span class="math">\\frac{m}{16\\tau f}</span>  rounds. Since  <span class="math">E_{r^*-1}</span>  is  <span class="math">(\\eta, \\theta)</span> -good, the statement follows from Lemma 2.</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> Let E be a typical execution in a  <span class="math">(\\gamma, s)</span> -respecting environment and  <span class="math">r^*</span>  an  <span class="math">(\\eta \\gamma, \\frac{\\theta}{\\gamma})</span> -good target-recalculation point of a valid chain C. For  <span class="math">r &gt; r^* + \\frac{\\tau m}{f}</span> , assume  <span class="math">E_{r-1}</span>  is  <span class="math">(\\eta, \\theta)</span> -good. Then, either the duration  <span class="math">\\Delta</span>  of the epoch of C starting at  <span class="math">r^*</span>  satisfies</p>

    <p class="text-gray-300"><span class="math">$\\frac{m}{\\tau f} \\leq \\Delta \\leq \\frac{\\tau m}{f},</span>$</p>

    <p class="text-gray-300">or  <span class="math">C \\notin S_u</span>  for each  <span class="math">u \\in \\{r^* + \\frac{\\tau m}{f}, \\dots, r\\}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Let T be the target of the epoch in question.</p>

    <p class="text-gray-300">For the upper bound, assume  <span class="math">\\Delta &gt; \\frac{\\tau m}{f}</span> . We show first that in the rounds  <span class="math">S = \\{r^* + \\frac{m}{16\\tau f}, \\dots, r^* + \\frac{\\tau m}{f} - \\frac{m}{16\\tau f}\\}</span>  the honest parties have acquired more than  <span class="math">\\frac{m}{T}</span>  difficulty. Note that the rounds of S are  <span class="math">(\\eta, \\theta)</span> -good as they come before r. Thus, by Proposition 3, the difficulty acquired in S by the honest parties is at least</p>

    <p class="text-gray-300"><span class="math">$(1 - \\epsilon)(1 - \\theta f)p \\sum_{r \\in S} n_r \\ge (1 - \\epsilon)(1 - \\theta f)p \\cdot \\frac{|S|n_{r^*}}{\\gamma} \\ge (1 - \\epsilon)(1 - \\theta f)|S| \\frac{\\eta f}{T} &gt; \\frac{m}{T}.</span>$</p>

    <p class="text-gray-300">For the first inequality, we used Fact 1. For the second, recall that  <span class="math">r^*</span>  is  <span class="math">(\\eta \\gamma, \\theta/\\gamma)</span> -good and so  <span class="math">pTn_{r^*} \\ge f(T, n_{r^*}) \\ge \\eta \\gamma f</span> . For the last inequality observe that  <span class="math">|S| = \\frac{m}{f}(\\tau - 1/8\\tau)</span>  and thus follows from Requirement (R3).</p>

    <p class="text-gray-300">Next, we observe that chain  <span class="math">\\mathcal{C}</span>  either has a block within the epoch in question that is computed by an honest party in a round within the period  <span class="math">[r^*, r^* + \\frac{m}{16\\tau f})</span> , or by Lemma 2,  <span class="math">\\mathcal{C} \\notin \\mathcal{S}_u</span>  for each  <span class="math">u \\in \\{r^* + \\frac{m}{16\\tau f}, \\ldots, r\\} \\supseteq \\{r^* + \\frac{\\tau m}{f}, \\ldots, r\\}</span> . Assuming the first happens, it follows that by round  <span class="math">r^* + \\frac{\\tau m}{f} - \\frac{m}{16\\tau f}</span>  the honest parties' chains have advanced by an amount of difficulty which exceeds the total difficulty of the epoch in question. This means that no honest party will extend  <span class="math">\\mathcal{C}</span>  during the rounds  <span class="math">\\{r^* + \\frac{\\tau m}{f} - \\frac{m}{16\\tau f} + 1, \\ldots, \\Delta\\}</span> . Since it is assumed  <span class="math">\\Delta &gt; r^* + \\frac{\\tau m}{f}</span> , Lemma 2 can then be applied to imply that  <span class="math">\\mathcal{C} \\notin \\mathcal{S}_u</span>  for  <span class="math">u \\in \\{r^* + \\frac{\\tau m}{f}, \\ldots, r\\}</span> .</p>

    <p class="text-gray-300">For the lower bound, we assume  <span class="math">\\Delta &lt; \\frac{m}{\\tau f}</span>  and that  <span class="math">\\mathcal{C} \\in \\mathcal{S}_u</span>  for some  <span class="math">u \\in \\{r^* + \\Delta + 1, \\dots, r\\}</span> , and seek a contradiction. Clearly, the honest parties contributed only during the set of rounds  <span class="math">S = \\{r^*, \\dots, r^* + \\Delta\\}</span> . The adversary, by Lemma 2, may have contributed only during  <span class="math">S&#x27; = \\{r^* - \\frac{m}{16\\tau f}, \\dots, r^* + \\Delta + \\frac{m}{16\\tau f}\\}</span> . Let J be the set of queries available to the adversary during the rounds in S'. We show that in a typical execution the honest parties together with the adversary cannot acquire difficulty  <span class="math">\\frac{m}{T}</span>  in the rounds in the sets S and S' respectively. With respect to the honest parties, Proposition 3 applies. Regarding the adversary, assume first  <span class="math">T \\geq T^{(J)}</span>  (it is not hard to verify that the case  <span class="math">T &lt; T^{(J)}</span>  leads to a more favorable bound). It follows that the total difficulty contributed to the epoch is at most</p>

    <p class="text-gray-300"><span class="math">$(1+\\epsilon)p\\left(\\sum_{r\\in S}n_r + \\sum_{r\\in S&#x27;}t_r\\right) \\le (1+\\epsilon)p\\gamma n_{r^*}(|S|+|S&#x27;|) &lt; (1+\\epsilon)p\\gamma n_{r^*} \\cdot \\frac{17m}{8\\tau f}.</span>$</p>

    <p class="text-gray-300">The first inequality follows from Fact 1 using  <span class="math">t_r &lt; (1 - \\delta)n_r</span> . For the second substitute the upper bounds on the sizes of S and S'. Next, note that  <span class="math">r^*</span>  is an  <span class="math">(\\eta\\gamma,\\theta/\\gamma)</span> -good recalculation point and so  <span class="math">f(T,n_{r^*}) \\leq \\theta f/\\gamma</span> . By Proposition 1,  <span class="math">pTn_{r^*} &lt; f(T,n_{r^*})/(1-f(T,n_{r^*})) \\leq (\\theta f/\\gamma)/(1-\\theta f/\\gamma)</span> . It follows that the last displayed quantity is at most  <span class="math">\\frac{17(1+\\epsilon)\\theta}{8\\tau(\\gamma-\\theta f)} \\cdot \\frac{m}{T}</span>  and recalling Requirement (R4) this less than  <span class="math">\\frac{m}{T}</span>  as desired.</p>

    <p class="text-gray-300"><strong>Proposition 5.</strong> Assume E is a typical execution in a  <span class="math">(\\gamma, s)</span> -respecting environment. Let r be a round such that  <span class="math">E_{r-1}</span>  is  <span class="math">(\\eta, \\theta)</span> -good, S a set of consecutive rounds in  <span class="math">E_r</span>  with  <span class="math">|S| \\ge \\frac{m}{32\\tau^2 f}</span> , and S the set of adversarial queries during the rounds in S. Then, the adversary during the rounds in S has contributed at most  <span class="math">\\sum_{j \\in J} A_j</span>  difficulty to  <span class="math">\\bigcup_{v \\le r} S_r</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Without loss of generality, we will assume in this proof that  <span class="math">t_r = (1 - \\delta)n_r</span>  for each  <span class="math">r \\in S</span> . Furthermore, we assume  <span class="math">|S| \\leq \\frac{\\tau m}{f}</span> . If this is not the case, then we can partition S to parts of appropriate sizes and apply the arguments that follow to each sum. The statement will follow upon summing over all parts.</p>

    <p class="text-gray-300">By Lemma 2, for any block B in  <span class="math">S_v</span>  for some  <span class="math">v \\leq r</span> , there is a block B' in the same chain and computed at most  <span class="math">\\frac{m}{16\\tau f}</span>  rounds earlier than it by an honest party. Let u be the round the honest party computed B and T its target. Note that since E is  <span class="math">(\\eta, \\theta)</span> -good,  <span class="math">T \\geq T^{(u,\\eta)} = \\frac{\\eta f}{pn_u}</span> . By Lemma 3, there is at most one recalculation point between B and B', and so the target of B is at least  <span class="math">T/\\tau</span> . We need to show that  <span class="math">T/\\tau \\geq T^{(J)}</span> . This implies all difficulty contributed by the adversary is accounted for in  <span class="math">\\sum_{j\\in J} A_j</span>  and by Definition 8 we are done.</p>

    <p class="text-gray-300">Using Fact 1 and the lower-bound on |S|.</p>

    <p class="text-gray-300"><span class="math">$2^{-\\kappa}|J| = (1-\\delta)p \\sum_{r \\in S} n_r \\ge (1-\\delta)p \\cdot \\frac{|S|n_u}{\\gamma} \\ge (1-\\delta)p \\cdot \\frac{mn_u}{32\\tau^3 f\\gamma}.</span>$</p>

    <p class="text-gray-300">Recalling the definition of  <span class="math">T^{(J)}</span>  and using this bound,</p>

    <p class="text-gray-300"><span class="math">$T^{(J)} = \\frac{\\eta(1-\\delta)(1-2\\epsilon)(1-\\theta f)}{32\\tau^3\\gamma} \\cdot \\frac{m}{|J|} \\cdot 2^{\\kappa} \\le \\frac{\\eta f(1-2\\epsilon)(1-\\theta f)}{\\tau p n_u} &lt; \\frac{T^{(u,\\eta)}}{\\tau} \\le \\frac{T}{\\tau},</span>$</p>

    <p class="text-gray-300">as desired.</p>

    <p class="text-gray-300"><strong>Lemma 4.</strong> Let E be a typical execution in a  <span class="math">(\\gamma, s)</span> -respecting environment and assume  <span class="math">E_{r-1}</span>  is  <span class="math">(\\eta, \\theta)</span> -good. If  <span class="math">C \\in S_r</span> , then C is  <span class="math">(\\eta \\gamma, \\theta/\\gamma)</span> -good in  <span class="math">E_r</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Note that it is our assumption that every chain is  <span class="math">(\\eta \\gamma, \\theta/\\gamma)</span> -good at the first round. Therefore, to prove the statement, it suffices to show that if a chain is  <span class="math">(\\eta \\gamma, \\theta/\\gamma)</span> -good at a recalculation point  <span class="math">r^*</span> , then it will also be  <span class="math">(\\eta \\gamma, \\theta/\\gamma)</span> -good at then next recalculation point  <span class="math">r^* + \\Delta</span> .</p>

    <p class="text-gray-300">Let  <span class="math">r^*</span>  and  <span class="math">r^* + \\Delta \\leq r</span>  be two consecutive target-calculation points of a chain  <span class="math">\\mathcal{C}</span>  and T the target of the corresponding epoch. By Lemma 3 and Definition 2 of the target-recalculation function, the new target will be</p>

    <p class="text-gray-300"><span class="math">$T&#x27; = \\frac{\\Delta}{m/f} \\cdot T,</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\Delta</span>  is the duration of the epoch.</p>

    <p class="text-gray-300">We wish to show that</p>

    <p class="text-gray-300"><span class="math">$\\eta \\gamma f \\le f(T&#x27;, n_{r^* + \\Delta}) \\le \\theta f / \\gamma.</span>$</p>

    <p class="text-gray-300">To this end, let  <span class="math">S = \\{r^*, \\dots, r^* + \\Delta\\}</span> ,  <span class="math">S&#x27; = \\{\\max\\{0, r^* - \\frac{m}{16\\tau f}\\}, \\dots, \\min\\{r^* + \\Delta + \\frac{m}{16\\tau f}, r\\}\\}</span> , and let J index the queries available to the adversary in S'. Note that, by Corollary 1, every block in the epoch was computed either by an honest party during a round in S or by the adversary during a round in S'.</p>

    <p class="text-gray-300">Suppose&mdash;towards a contradiction&mdash;that  <span class="math">f(T&#x27;, n_{r^*+\\Delta}) &lt; \\eta \\gamma f</span> . Using the definition of f(T, n), this implies  <span class="math">qn_{r^*+\\Delta} \\ln(1 - \\frac{T&#x27;}{2^{\\kappa}}) &gt; \\ln(1 - \\eta \\gamma f)</span> . Applying the inequality  <span class="math">-\\frac{x}{1-x} &lt; \\ln(1-x) &lt; -x</span> , valid for  <span class="math">x \\in (0, 1)</span> , substituting the expression for T' above and rearranging, we obtain</p>

    <p class="text-gray-300"><span class="math">$\\frac{m}{T} &gt; \\frac{1 - \\eta \\gamma f}{\\eta \\gamma} \\cdot p \\Delta n_{r^* + \\Delta}.</span>$</p>

    <p class="text-gray-300">By Propositions 3 and 5 it follows that</p>

    <p class="text-gray-300"><span class="math">$\\frac{m}{T} \\le 2(1+\\epsilon)p \\sum_{r \\in S&#x27;} n_r \\le 2(1+\\epsilon)p \\cdot \\frac{\\Delta + \\frac{m}{8\\tau f}}{|S&#x27;|} \\cdot \\sum_{r \\in S&#x27;} n_r.</span>$</p>

    <p class="text-gray-300">By Lemma 3,  <span class="math">\\Delta \\geq \\frac{m}{\\tau f}</span> . Thus,  <span class="math">\\frac{\\Delta + \\frac{m}{8\\tau f}}{\\Delta} \\leq \\frac{9}{8}</span> . Using this, Requirement (R5), and combining the inequalities on  <span class="math">\\frac{m}{T}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\gamma n_{r^* + \\Delta} &lt; \\frac{9(1+\\epsilon)\\eta\\gamma^2}{4(1-\\eta\\gamma f)} \\cdot \\frac{1}{|S&#x27;|} \\sum_{r \\in S&#x27;} n_r \\le \\frac{1}{|S&#x27;|} \\sum_{r \\in S&#x27;} n_r,</span>$</p>

    <p class="text-gray-300">contradicting Fact 1.</p>

    <p class="text-gray-300">For the upper bound, assume  <span class="math">f(T&#x27;, n_{r^*+\\Delta}) &gt; \\theta f/\\gamma</span> , which (see Proposition 1) implies</p>

    <p class="text-gray-300"><span class="math">$\\frac{m}{T} &lt; \\frac{\\gamma}{\\theta} \\cdot p\\Delta n_{r^* + \\Delta}.</span>$</p>

    <p class="text-gray-300">Set  <span class="math">S = \\{r^* + \\frac{m}{16\\tau f}, \\dots, r^* + \\Delta - \\frac{m}{16\\tau f}\\}</span> . Since an honest party posses  <span class="math">\\mathcal C</span>  at round r, it follows by Lemma 2 that there is a block computed by an honest party in  <span class="math">\\mathcal C</span>  during  <span class="math">\\{r^*, \\dots, r^* + \\frac{m}{16\\tau f} - 1\\}</span>  and one during  <span class="math">\\{r^* + \\Delta - \\frac{m}{16\\tau f} + 1, \\dots, r^* + \\Delta\\}</span> . By the Chain-Growth Lemma 1, it follows that the honest parties computed less than  <span class="math">\\frac{m}{T}</span>  difficulty during S. In particular,</p>

    <p class="text-gray-300"><span class="math">$\\frac{m}{T} &gt; (1 - \\epsilon)(1 - \\theta f)p \\sum_{r \\in S} n_r \\ge (1 - \\epsilon)(1 - \\theta f)p \\cdot \\frac{\\Delta - \\frac{m}{8\\tau f}}{|S|} \\cdot \\sum_{r \\in S} n_r.</span>$</p>

    <p class="text-gray-300">By Lemma 3,  <span class="math">\\Delta \\geq \\frac{m}{\\tau f}</span> . Thus,  <span class="math">\\frac{\\Delta - \\frac{m}{8\\tau f}}{\\Delta} \\geq \\frac{7}{8}</span> . Using this, Requirement (R6), and combining the inequalities on  <span class="math">\\frac{m}{T}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\frac{n_{r^*+\\Delta}}{\\gamma} &gt; \\frac{7\\theta}{8\\gamma^2} (1 - \\epsilon)(1 - \\theta f) \\cdot \\frac{1}{|S|} \\sum_{r \\in S} n_r \\ge \\frac{1}{|S|} \\sum_{r \\in S} n_r,</span>$</p>

    <p class="text-gray-300">contradicting Fact 1.  <span class="math">\\Box</span></p>

    <p class="text-gray-300">Corollary 2. Let E be a typical execution in a  <span class="math">(\\gamma, s)</span> -respecting environment and  <span class="math">E_{r-1}</span>  be  <span class="math">(\\eta, \\theta)</span> -good. If every chain in  <span class="math">S_{r-1}</span>  is  <span class="math">(\\eta \\gamma, \\frac{\\theta}{\\gamma})</span> -good, then  <span class="math">E_r</span>  is  <span class="math">(\\eta, \\theta)</span> -good.</p>

    <p class="text-gray-300">Proof. We use notations and definitions of Lemma 3. Let  <span class="math">C \\in \\mathcal{S}_r</span>  and let  <span class="math">r^*</span>  be its last recalculation point in  <span class="math">E_{r-1}</span> . Let T be the target after  <span class="math">r^*</span>  and T' the one at r. We need to show that  <span class="math">f(T&#x27;, n_r) \\in [\\eta f, \\theta f]</span> . Note that if r is a recalculation point, this follows by Lemma 4. Otherwise, T' = T and  <span class="math">\\eta \\gamma \\leq f(T, n_{r^*}) \\leq \\theta f/\\gamma</span> . Using Lemma 3,  <span class="math">r - r^* \\leq \\Delta \\leq \\frac{\\tau m}{f}</span> . Thus,  <span class="math">\\frac{1}{\\gamma} n_{r^*} \\leq n_r \\leq \\gamma n_{r^*}</span> . By Fact 2 we have  <span class="math">f(T, n_r) \\leq f(T, \\gamma n_{r^*}) \\leq \\gamma f(T, n_{r^*}) \\leq \\theta f</span>  and  <span class="math">f(T, n_r) \\geq f(T, \\frac{1}{\\gamma} n_{r^*}) \\geq \\frac{1}{\\gamma} f(T, n_{r^*}) \\geq \\eta f</span> .</p>

    <p class="text-gray-300">Corollary 3. Let E be a typical execution in a  <span class="math">(\\gamma, s)</span> -respecting environment. Then every round is  <span class="math">(\\eta, \\theta)</span> -good in E.</p>

    <p class="text-gray-300"><em>Proof.</em> For the sake of contradiction, let r be the smallest round of E that is not  <span class="math">(\\eta, \\theta)</span> -good. This means that there is a chain  <span class="math">\\mathcal{C}</span>  and an honest party that possesses this chain in round r and the corresponding target T is such that  <span class="math">f(T, n_r) \\notin [\\eta f, \\theta f]</span> . Note that  <span class="math">E_{r-1}</span>  is  <span class="math">(\\eta, \\theta)</span> -good, and so, by Corollary 1,  <span class="math">E_r</span>  is  <span class="math">\\frac{m}{16\\tau f}</span> -accurate. Let  <span class="math">r^* &lt; r</span>  be the last  <span class="math">(\\eta \\gamma, \\theta/\\gamma)</span> -good recalculation point of  <span class="math">\\mathcal{C}</span>  (let  <span class="math">r^*</span>  be 0 in case there is no such point).</p>

    <p class="text-gray-300">First suppose that there is another recalculation point  <span class="math">r&#x27; \\in (r^*, r]</span> . By the definition of  <span class="math">r^*</span> , r' is not  <span class="math">(\\eta \\gamma, \\theta/\\gamma)</span> -good. However, the assumptions of Lemma 4 hold, implying that  <span class="math">\\mathcal{C}</span>  is  <span class="math">(\\eta \\gamma, \\theta/\\gamma)</span> -good. We have reached a contradiction.</p>

    <p class="text-gray-300">We may now assume that there is no recalculation point in  <span class="math">(r^*, r]</span>  and so the points  <span class="math">r^*</span>  and r correspond to the same target T with  <span class="math">\\eta \\gamma \\leq f(T, n_{r^*}) \\leq \\theta f/\\gamma</span> . Note that since  <span class="math">r^*</span>  is an  <span class="math">(\\eta \\gamma, \\theta/\\gamma)</span> -good recalculation point and  <span class="math">E_{r-1}</span>  is  <span class="math">(\\eta, \\theta)</span> -good, we have  <span class="math">r - r^* \\leq \\frac{\\tau m}{f}</span> . This follows from Lemma 3, because  <span class="math">\\mathcal{C}</span>  belongs to an honest party at round r. Thus,  <span class="math">\\frac{1}{\\gamma}n_{r^*} \\leq n_r \\leq \\gamma n_{r^*}</span> , and so (by Fact 2)  <span class="math">f(T, n_r) \\leq f(T, \\gamma n_{r^*}) \\leq \\gamma f(T, n_{r^*}) \\leq \\theta f</span>  and  <span class="math">f(T, n_r) \\geq f(T, \\frac{1}{\\gamma}n_{r^*}) \\geq \\frac{1}{\\gamma}f(T, n_{r^*}) \\geq \\eta f</span> .</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> A typical execution in a  <span class="math">(\\gamma, s)</span> -respecting environment is  <span class="math">\\frac{m}{16\\tau f}</span> -accurate and  <span class="math">(\\eta, \\theta)</span> -good.</p>

    <p class="text-gray-300"><em>Proof.</em> This follows from Corollaries 3 and 1.</p>

      <h3 id="sec-6.5" class="text-xl font-semibold mt-8">6.5 Common Prefix and Chain Quality</h3>

    <p class="text-gray-300"><strong>Proposition 6.</strong> Let E be a typical execution in a  <span class="math">(\\gamma, s)</span> -respecting environment. Any  <span class="math">\\frac{\\theta \\gamma m}{8\\tau}</span>  consecutive blocks in an epoch of a chain  <span class="math">C \\in \\mathcal{S}_r</span>  have been computed in at least  <span class="math">\\frac{m}{16\\tau f}</span>  rounds.</p>

    <p class="text-gray-300"><em>Proof.</em> Suppose&mdash;towards a contradiction&mdash;that the blocks of  <span class="math">\\mathcal{C}</span>  where computed during the rounds in  <span class="math">S^*</span> , for some  <span class="math">S^*</span>  such that  <span class="math">|S^*| &lt; \\frac{m}{16\\tau f}</span> . Consider an S such that  <span class="math">S^* \\subseteq S</span>  and  <span class="math">|S| = \\frac{m}{16\\tau f}</span>  and the property that a block of target T in  <span class="math">\\mathcal{C}</span>  was computed by an honest party in some round  <span class="math">v \\in S</span> . Such an S exists by Lemmas 2 and 3. By Propositions 3 and 5, the number of blocks of target T computed in S is at most</p>

    <p class="text-gray-300"><span class="math">$(1+\\epsilon)(2-\\delta)pT\\sum_{u\\in S}n_u\\leq (1+\\epsilon)(2-\\delta)pT\\gamma n_v|S|\\leq \\frac{(1+\\epsilon)(2-\\delta)\\gamma|S|\\theta f}{1-\\theta f}\\leq \\frac{\\theta\\gamma m}{8\\tau}.</span>$</p>

    <p class="text-gray-300">For the first inequality we used Fact 1, for the second Fact 1 and that round v is  <span class="math">(\\eta, \\theta)</span> -good, and for the last one Requirement (R2).</p>

    <p class="text-gray-300"><strong>Theorem 2</strong> (Common Prefix). In any typical execution of a  <span class="math">(\\gamma, s)</span> -respecting environment, the common-prefix property holds for  <span class="math">k \\geq \\frac{\\theta \\gamma m}{4\\tau}</span> .</p>

    <p class="text-gray-300">Proof. Consider&mdash;towards a contradiction&mdash;honest parties  <span class="math">P_1</span>  and  <span class="math">P_2</span>  with adopted chains  <span class="math">C_1</span>  and  <span class="math">C_2</span>  at rounds  <span class="math">r_1 \\leq r_2</span>  respectively, such that  <span class="math">C_1^{\\lceil k} \\nleq C_2</span> . Define  <span class="math">r \\geq r_1</span>  as the least round in which an honest party P adopts a chain C such that  <span class="math">C_1^{\\lceil k} \\nleq C</span> . Consider the last block on the common prefix of  <span class="math">C_1</span>  and C that was computed by an honest party and let  <span class="math">r^*</span>  be the round on which it was computed (set  <span class="math">r^* = 0</span>  if no such block exists). Denote by  <span class="math">C^*</span>  the common part of  <span class="math">C_1</span>  and C up to (and including) this block. Let also  <span class="math">S = \\{u : r^* &lt; u &lt; r\\}</span>  and J the set of adversarial queries in S. By Proposition 6,  <span class="math">|S| \\geq \\frac{m}{16\\tau f}</span> ; it is not hard to verify that the bounds on |J| and |S| of Definition 8 and Proposition 3 hold. We are going to argue that</p>

    <p class="text-gray-300">
<span class="math">$(1+\\epsilon)p\\sum_{u\\in S}t_u \\ge \\sum_{j\\in J}A_j \\ge \\sum_{u\\in S}Q_u \\ge (1-\\epsilon)(1-\\theta f)p\\sum_{u\\in S}n_u.</span>$
(2)</p>

    <p class="text-gray-300">Note that this provides a contradiction, since Requirements (R0) and (R2) imply  <span class="math">t_u &lt; (1 - \\delta)n_u \\le (1 - 4\\epsilon - 2\\theta f)n_u &lt; (1 - 2\\epsilon)(1 - \\theta f)n_u \\le \\frac{1-\\epsilon}{1+\\epsilon} \\cdot (1-\\theta f)n_u</span> . The first and third inequalities hold in any typical execution; we proceed to show the middle one.</p>

    <p class="text-gray-300">We first make a simple but crucial observation. Consider any block B extending a chain  <span class="math">\\mathcal{C}&#x27;</span>  that was computed by an honest party in a uniquely successful round  <span class="math">u \\in S</span> . For any  <span class="math">d \\in \\mathbb{R}</span>  such that  <span class="math">\\operatorname{diff}(\\mathcal{C}&#x27;) \\leq d &lt; \\operatorname{diff}(\\mathcal{C}&#x27;B)</span> , let us write  <span class="math">d \\in B</span> . We are going to argue that if another chain of difficulty at least d exists, then the block that &quot;contains&quot; the point of difficulty d was computed by the adversary. More formally, suppose a chain  <span class="math">\\mathcal{C}&#x27;&#x27;B&#x27;</span>  exists such that  <span class="math">B&#x27; \\neq B</span>  and  <span class="math">d \\in B&#x27;</span> . We observe that B' was computed by the adversary. This is because no honest party would extend  <span class="math">\\mathcal{C}&#x27;&#x27;</span>  at a round later than u since  <span class="math">\\operatorname{diff}(\\mathcal{C}&#x27;&#x27;) \\leq d &lt; \\operatorname{diff}(\\mathcal{C}&#x27;B)</span> ; on the other hand, if an honest party computed B' at some round u' &lt; u, then no honest party would have extended  <span class="math">\\mathcal{C}&#x27;</span>  at round u since  <span class="math">\\operatorname{diff}(\\mathcal{C}&#x27;) \\leq d &lt; \\operatorname{diff}(\\mathcal{C}&#x27;&#x27;B&#x27;&#x27;)</span> ; finally, note that u is also ruled out since it was uniquely successful.</p>

    <p class="text-gray-300">Let us now return to the proof of (2). By the Chain-Growth Lemma (Lemma 1),  <span class="math">\\operatorname{diff}(\\mathcal{C}) \\geq \\operatorname{diff}(\\mathcal{C}^*) + \\sum_{u \\in S} Q_u</span> . The observation in the previous paragraph implies that there is an injection from the set</p>

    <p class="text-gray-300"><span class="math">U = \\{d \\in B : B \\text{ was computed in a uniquely successful round in } S\\}</span></p>

    <p class="text-gray-300">into the set</p>

    <p class="text-gray-300"><span class="math">$W = \\{d \\in B&#x27; : B&#x27; \\text{ was computed by the adversary in a round in } S\\}.</span>$</p>

    <p class="text-gray-300">To see this, note first that both sets are subsets of  <span class="math">(\\operatorname{diff}(\\mathcal{C}^*), \\operatorname{diff}(\\mathcal{C}))</span> . We claim that for any  <span class="math">d \\in U</span>  and B such that  <span class="math">d \\in B</span> , there is always a  <span class="math">B&#x27; \\neq B</span>  that lies either on  <span class="math">\\mathcal{C}_1</span> , or on  <span class="math">\\mathcal{C}</span> , or on their common prefix. Indeed, B cannot be both on  <span class="math">\\mathcal{C}</span>  and  <span class="math">\\mathcal{C}&#x27;</span> ; by the definition of  <span class="math">r^*</span> , B cannot be on their common prefix; by the definition of r, B cannot be on the part of  <span class="math">\\mathcal{C}</span>  of greater difficulty than  <span class="math">\\operatorname{diff}(\\mathcal{C}_1)</span> .</p>

    <p class="text-gray-300">Since the size of the first set is  <span class="math">\\sum_{u \\in S} Q_u</span>  and the size of the second&mdash;by Proposition 5&mdash;is at most  <span class="math">\\sum_{i \\in J} A_i</span> , the inequality in (2) follows.</p>

    <p class="text-gray-300"><strong>Theorem 3</strong> (Chain Quality). In any typical execution of a  <span class="math">(\\gamma, s)</span> -respecting environment, the chain-quality property holds for  <span class="math">\\ell \\geq \\frac{\\theta \\gamma m}{8\\tau}</span>  and  <span class="math">\\mu = \\delta - 2\\epsilon - \\theta f \\geq \\delta/2</span> .</p>

    <p class="text-gray-300">Proof. Let us denote by  <span class="math">B_i</span>  the <em>i</em>-th block of  <span class="math">\\mathcal{C}</span>  so that  <span class="math">\\mathcal{C} = B_1 \\dots B_{\\operatorname{len}(\\mathcal{C})}</span>  and consider L consecutive blocks  <span class="math">B_u, \\dots, B_v</span> . Define L' as the least number of consecutive blocks  <span class="math">B_{u&#x27;}, \\dots, B_{v&#x27;}</span>  that include the L given ones (i.e.,  <span class="math">u&#x27; \\leq u</span>  and  <span class="math">v \\leq v&#x27;</span> ) and have the properties (1) that the block  <span class="math">B_{u&#x27;}</span>  was computed by an honest party or is  <span class="math">B_1</span>  in case such block does not exist, and (2) that there exists a round at which an honest party was trying to extend the chain ending at block  <span class="math">B_{v&#x27;}</span> . Observe that number L' is well defined since  <span class="math">B_{\\operatorname{len}(\\mathcal{C})}</span>  is at the head of a chain that an honest party is trying to extend. Denote by d' the total difficulty of these L' blocks. Define also  <span class="math">r_1</span>  as the round that  <span class="math">B_{u&#x27;}</span>  was created (set  <span class="math">r_1 = 0</span>  if  <span class="math">B_{u&#x27;}</span>  is the genesis block),  <span class="math">r_2</span>  as the first round that an honest party attempts to extend  <span class="math">B_{v&#x27;}</span> , and let  <span class="math">S = \\{r : r_1 \\leq r \\leq r_2\\}</span> . Note that, by Proposition  <span class="math">6, |S| \\geq \\frac{m}{16\\tau f}</span> .</p>

    <p class="text-gray-300">Now let x denote the total difficulty of all the blocks from honest parties that are included in the L blocks and&mdash;towards a contradiction&mdash;assume that</p>

    <p class="text-gray-300">
<span class="math">$x &lt; \\mu d \\le \\mu d&#x27;. \\tag{3}</span>$</p>

    <p class="text-gray-300">Suppose first that all the L' blocks  <span class="math">\\{B_j : u&#x27; \\leq j \\leq v&#x27;\\}</span>  have been computed during the rounds in the set S. We now argue the following sequence of inequalities.</p>

    <p class="text-gray-300">
<span class="math">$(1+\\epsilon)(1-\\delta)p\\sum_{u\\in S}n_u \\ge (1+\\epsilon)p\\sum_{u\\in S}t_u &gt; \\sum_{j\\in J}A_j \\ge d&#x27;-x \\ge (1-\\mu)d&#x27; \\ge (1-\\mu)\\sum_{u\\in S}Q_u.</span>$
(4)</p>

    <p class="text-gray-300">The first inequality is due to our requirement that  <span class="math">t_u \\leq (1-\\delta)n_u</span>  holds for any round u. The second one holds in any typical execution and Remark ??. The third one follows from the definition of x and d' and Proposition 5. The fourth one comes from the relation between x and d' outlined in (3). To see the last inequality, assume  <span class="math">\\sum_{u \\in S} Q_u &gt; d&#x27;</span> . But then, by the Chain-Growth Lemma 1, the assumption than an honest party is on  <span class="math">B_{v&#x27;}</span>  at round  <span class="math">r_2</span>  is contradicted as all honest parties should be at chains of greater length. We now observe that (4) contradicts Proposition 3, since</p>

    <p class="text-gray-300"><span class="math">$(1-\\mu)\\sum_{u\\in S} Q_u &gt; (1-\\mu)(1-\\epsilon)(1-\\theta f)p\\sum_{u\\in S} n_u \\ge (1+\\epsilon)(1-\\delta)p\\sum_{u\\in S} n_u,</span>$</p>

    <p class="text-gray-300">where the last inequality follows by Requirement (R2).</p>

    <p class="text-gray-300">To finish the proof we need to consider the case in which these L' blocks contain blocks that the adversary computed in rounds outside S. It is not hard to see that this case implies either a prediction or an insertion and cannot occur in a typical execution.</p>

      <h3 id="sec-6.6" class="text-xl font-semibold mt-8">6.6 Persistence and Liveness</h3>

    <p class="text-gray-300"><strong>Theorem 4.</strong> Let E be a typical execution in a  <span class="math">(\\gamma, s)</span> -respecting environment. Persistence is satisfied with depth  <span class="math">k \\geq \\frac{\\theta \\gamma m}{4\\tau}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> If the chain  <span class="math">\\mathcal{C}</span>  of an honest party at round r contains a transaction in  <span class="math">\\mathcal{C}^{\\lceil k}</span> , it follows by the commonprefix property that for the chain  <span class="math">\\mathcal{C}&#x27;</span>  of another honest party at any round  <span class="math">r&#x27; \\geq r</span>  it holds  <span class="math">\\mathcal{C}^{\\lceil k} \\leq \\mathcal{C}&#x27;</span> .</p>

    <p class="text-gray-300"><strong>Proposition 7.</strong> Let E be a typical execution in a  <span class="math">(\\gamma, s)</span> -respecting environment. Suppose an honest party has a prefix of C at a round u and an honest party adopted a prefix of C at round  <span class="math">v \\ge u + \\frac{m}{16\\tau f}</span> . During the set of consecutive rounds  <span class="math">S = \\{r : u \\le r &lt; v\\}</span> , C acquired at least  <span class="math">(1 - \\epsilon)(1 - \\theta f)\\eta f|S|/\\gamma</span>  blocks.</p>

    <p class="text-gray-300">Proof. Assume first that  <span class="math">|S| \\leq s - \\frac{m}{8\\tau f}</span> . Suppose  <span class="math">\\mathcal C</span>  at round u has difficulty d. By the Chain Growth Lemma 1,  <span class="math">\\mathcal C</span>  has difficulty at least  <span class="math">d&#x27; = d + \\sum_{r \\in S} D_r</span>  by round v. Let T be the least target among the targets of the blocks acquired during the rounds in S. By Lemmas 2 and 3, there is an honest block on  <span class="math">\\mathcal C</span>  computed in  <span class="math">S&#x27; = \\{r : u - \\frac{m}{16\\tau f} \\leq r &lt; v + \\frac{m}{16\\tau f}\\}</span>  that lies in the same epoch and so has target T. Since the execution is good (Theorem 1),  <span class="math">S \\subseteq S&#x27;</span> , and  <span class="math">|S&#x27;| \\leq s</span> , we obtain (Fact 1)  <span class="math">pTn_r \\geq \\eta f/\\gamma</span> , for any  <span class="math">r \\in S</span> . It follows that  <span class="math">\\mathcal C</span>  acquired at least</p>

    <p class="text-gray-300"><span class="math">$T(d&#x27;-d) = T \\sum_{r \\in S} D_r \\ge T \\sum_{r \\in S} Q_r &gt; (1-\\epsilon)(1-\\theta f) \\sum_{r \\in S} pT n_r \\ge (1-\\epsilon)(1-\\theta f)\\eta f |S|/\\gamma</span>$</p>

    <p class="text-gray-300">blocks during the rounds in S.</p>

    <p class="text-gray-300">To avoid the upper bound on S and obtain the statement, observe that by Lemma 2 we can partition S so that each part  <span class="math">S_i</span>  satisfies  <span class="math">\\frac{m}{16\\tau f} \\leq |S| \\leq s - \\frac{m}{8\\tau f}</span> , an honest party has (a prefix of) C at the beginning of  <span class="math">S_i</span> , and an honest party has adopted (a prefix of) C at the end of  <span class="math">S_i</span> . Summing over each part we obtain the general statement.</p>

    <p class="text-gray-300"><strong>Theorem 5.</strong> Let E be a typical execution in a  <span class="math">(\\gamma, s)</span> -respecting environment. Liveness is satisfied for depth  <span class="math">k \\geq \\frac{\\theta \\gamma m}{8\\tau}</span>  and wait-time  <span class="math">\\frac{m}{16\\tau f} + \\frac{\\gamma k}{\\eta f(1-\\epsilon)(1-\\theta f)}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Suppose a transaction tx is included in any block computed by an honest party for  <span class="math">\\frac{m}{16\\tau f}</span>  consecutive rounds and consider the chain  <span class="math">\\mathcal C</span>  of an arbitrary honest party after these rounds. By Lemma 2,  <span class="math">\\mathcal C</span>  contains an honest block computed in the  <span class="math">\\frac{m}{16\\tau f}</span>  rounds and this block contains tx. Denote by S the set of at least  <span class="math">\\gamma k/[\\eta f(1-\\epsilon)(1-\\theta f)]</span>  rounds that follow the round that this honest block was computed. By Proposition ??, on top of this block there has been accumulated at least k blocks.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[1] Back, A.: Hashcash. http://www.cypherspace.org/hashcash (1997)</p></li>
      <li><p class="text-gray-300">[2] Bahack, L.: Theoretical bitcoin attacks with less than half of the computational power (draft). IACR Cryptology ePrint Archive 2013, 868 (2013), <a href="http://eprint.iacr.org/2013/868" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2013/868</a></p></li>
      <li><p class="text-gray-300">[3] Bellare, M., Rogaway, P.: Random oracles are practical: A paradigm for designing efficient protocols. In: Denning, D.E., Pyle, R., Ganesan, R., Sandhu, R.S., Ashby, V. (eds.) CCS '93, Proceedings of the 1st ACM Conference on Computer and Communications Security, Fairfax, Virginia, USA, November 3-5, 1993. pp. 62&ndash;73. ACM (1993), <a href="http://doi.acm.org/10.1145/168588.168596" target="_blank" rel="noopener noreferrer">http://doi.acm.org/10.1145/168588.168596</a></p></li>
      <li><p class="text-gray-300">[4] Canetti, R.: Security and composition of multiparty cryptographic protocols. J. Cryptology 13(1), 143&ndash;202 (2000)</p></li>
      <li><p class="text-gray-300">[5] Canetti, R.: Universally composable security: A new paradigm for cryptographic protocols. Cryptology ePrint Archive, Report 2000/067 (2000), <a href="http://eprint.iacr.org/2000/067" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2000/067</a></p></li>
      <li><p class="text-gray-300">[6] Canetti, R.: Universally composable security: A new paradigm for cryptographic protocols. In: 42nd Annual Symposium on Foundations of Computer Science, FOCS 2001, 14-17 October 2001, Las Vegas, Nevada, USA. pp. 136&ndash;145. IEEE Computer Society (2001), <a href="http://dx.doi.org/10.1109/SFCS.2001.959888" target="_blank" rel="noopener noreferrer">http://dx.doi.org/10.1109/SFCS.2001.</a> <a href="http://dx.doi.org/10.1109/SFCS.2001.959888" target="_blank" rel="noopener noreferrer">959888</a></p></li>
      <li><p class="text-gray-300">[7] Dwork, C., Lynch, N.A., Stockmeyer, L.J.: Consensus in the presence of partial synchrony. J. ACM 35(2), 288&ndash;323 (1988), <a href="http://doi.acm.org/10.1145/42282.42283" target="_blank" rel="noopener noreferrer">http://doi.acm.org/10.1145/42282.42283</a></p></li>
      <li><p class="text-gray-300">[8] Dwork, C., Naor, M.: Pricing via processing or combatting junk mail. In: Brickell, E.F. (ed.) CRYPTO. Lecture Notes in Computer Science, vol. 740, pp. 139&ndash;147. Springer (1992)</p></li>
      <li><p class="text-gray-300">[9] Eyal, I., Sirer, E.G.: Majority is not enough: Bitcoin mining is vulnerable. In: Keromytis, A.D. (ed.) Financial Cryptography. Lecture Notes in Computer Science, vol. 7397. Springer (2014), <a href="http://dx.doi.org/10.1007/978-3-642-32946-3" target="_blank" rel="noopener noreferrer">http:</a> <a href="http://dx.doi.org/10.1007/978-3-642-32946-3" target="_blank" rel="noopener noreferrer">//dx.doi.org/10.1007/978-3-642-32946-3</a></p></li>
      <li><p class="text-gray-300">[10] Garay, J.A., Kiayias, A., Leonardos, N.: The Bitcoin Backbone Protocol: Analysis and Applications. IACR Cryptology ePrint Archive 2014, 765 (2014), <a href="http://eprint.iacr.org/2014/765" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2014/765</a></p></li>
      <li><p class="text-gray-300">[11] Garay, J.A., Kiayias, A., Leonardos, N.: The bitcoin backbone protocol: Analysis and applications. In: Oswald, E., Fischlin, M. (eds.) Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part II. Lecture Notes in Computer Science, vol. 9057, pp. 281&ndash;310. Springer (2015), <a href="http://dx.doi.org/10.1007/978-3-662-46803-6_10" target="_blank" rel="noopener noreferrer">http://dx.doi.org/10.1007/978-3-662-46803-6\\_10</a></p></li>
      <li><p class="text-gray-300">[12] Hadzilacos, V., Toueg, S.: A modular approach to fault-tolerant broadcasts and related problems. Tech. rep. (1994)</p></li>
      <li><p class="text-gray-300">[13] Juels, A., Brainard, J.G.: Client puzzles: A cryptographic countermeasure against connection depletion attacks. In: NDSS. The Internet Society (1999)</p></li>
      <li><p class="text-gray-300">[14] Kiayias, A., Koutsoupias, E., Kyropoulou, M., Tselekounis, Y.: Blockchain mining games. In: Conitzer, V., Bergemann, D., Chen, Y. (eds.) Proceedings of the 2016 ACM Conference on Economics and Computation, EC '16, Maastricht, The Netherlands, July 24-28, 2016. pp. 365&ndash;382. ACM (2016), <a href="http://doi.acm.org/10.1145/2940716.2940773" target="_blank" rel="noopener noreferrer">http://doi.acm.org/10.1145/2940716.2940773</a></p></li>
      <li><p class="text-gray-300">[15] Kiayias, A., Panagiotakos, G.: Speed-security tradeoffs in blockchain protocols. IACR Cryptology ePrint Archive 2015, 1019 (2015), <a href="http://eprint.iacr.org/2015/1019" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2015/1019</a></p></li>
      <li><p class="text-gray-300">[16] Lamport, L., Shostak, R.E., Pease, M.C.: The byzantine generals problem. ACM Trans. Program. Lang. Syst. 4(3), 382&ndash;401 (1982)</p></li>
      <li><p class="text-gray-300">[17] McDiarmid, C.: Probabilistic Methods for Algorithmic Discrete Mathematics, chap. Concentration, pp. 195&ndash;248. Springer Berlin Heidelberg, Berlin, Heidelberg (1998), <a href="http://dx.doi.org/10.1007/978-3-662-12788-9_6" target="_blank" rel="noopener noreferrer">http://dx.doi.org/10.1007/</a> <a href="http://dx.doi.org/10.1007/978-3-662-12788-9_6" target="_blank" rel="noopener noreferrer">978-3-662-12788-9\\_6</a></p></li>
      <li><p class="text-gray-300">[18] Mitzenmacher, M., Upfal, E.: Probability and computing - randomized algorithms and probabilistic analysis. Cambridge University Press (2005)</p></li>
      <li><p class="text-gray-300">[19] Nakamoto, S.: Bitcoin open source implementation of p2p currency. http://p2pfoundation.ning.com/forum/topics/bitcoin-open-source (February 2009)</p></li>
      <li><p class="text-gray-300">[20] Pass, R., Seeman, L., Shelat, A.: Analysis of the blockchain protocol in asynchronous networks. In: Coron, J., Nielsen, J.B. (eds.) Advances in Cryptology - EUROCRYPT 2017 - 36th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Paris, France, April 30 - May 4, 2017, Proceedings, Part II. Lecture Notes in Computer Science, vol. 10211, pp. 643&ndash;673 (2017), <a href="https://doi.org/10.1007/978-3-319-56614-6_22" target="_blank" rel="noopener noreferrer">https://doi.org/10.1007/978-3-319-56614-6\\_22</a></p></li>
      <li><p class="text-gray-300">[21] Pease, M.C., Shostak, R.E., Lamport, L.: Reaching agreement in the presence of faults. J. ACM 27(2), 228&ndash;234 (1980)</p></li>
      <li><p class="text-gray-300">[22] Rivest, R.L., Shamir, A., Wagner, D.A.: Time-lock puzzles and timed-release crypto. Tech. rep., Cambridge, MA, USA (1996)</p></li>
      <li><p class="text-gray-300">[23] Sapirshtein, A., Sompolinsky, Y., Zohar, A.: Optimal selfish mining strategies in bitcoin. CoRR abs/1507.06183 (2015), <a href="http://arxiv.org/abs/1507.06183" target="_blank" rel="noopener noreferrer">http://arxiv.org/abs/1507.06183</a></p></li>
    </ul>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A The Bitcoin Backbone Protocol with Variable Difficulty (cont'd)</h2>

    <p class="text-gray-300">In this section we give a a more detailed description of the Bitcoin backbone protocol with chains of variable difficulty. The presentation is based on the description in <a href="#page-24-0">[11]</a>.</p>

      <h3 id="app-a.1" class="text-xl font-semibold mt-8">A.1 The protocol</h3>

    <p class="text-gray-300">As in <a href="#page-24-0">[11]</a> in our description oof the backbone protocol we intentionally avoid specifying the type of values/content that parties try to insert in the chain, the type of chain validation they perform (beyond checking for its structural properties with respect to the hash functions G(&middot;), H(&middot;)), and the way they interpret the chain. These checks and operations are handled by the external functions V (&middot;), I(&middot;) and R(&middot;) (the content validation function, the input contribution function and the chain reading function, resp.) which are specified by the application that runs &quot;on top&quot; of the backbone protocol.</p>

    <p class="text-gray-300">The Bitcoin backbone protocol in the dynamic setting is specified as Algorithm <a href="#page-28-0">4</a> and depends on three sub-procedures.</p>

    <p class="text-gray-300">Chain validation. The validate algorithm performs a validation of the structural properties of a given chain C. It is given as input the value q, as well as hash functions H(&middot;), G(&middot;). It is parameterized by the content validation predicate predicate V (&middot;) as well as by D(&middot;), the target calculation function (see Section <a href="#page-4-1">3)</a>. For each block of the chain, the algorithm checks that the proof of work is properly solved (with a target that is suitable as determined by the target calculation function), and that the counter ctr does not exceed q. Furthermore it collects the inputs from all blocks, xC, and tests them via the predicate V (xC); note that V (&epsilon;) = true. Chains that fail these validation procedure are rejected. (Algorithm <a href="#page-26-0">1.</a>)</p>

    <p class="text-gray-300"><strong>Algorithm 1</strong> The <em>chain validation predicate</em>, parameterized by q, D, the hash functions  <span class="math">G(\\cdot), H(\\cdot)</span> , and the input validation predicate  <span class="math">V(\\cdot)</span> . The input is chain C.</p>

    <pre><code class="language-text">1: function validate(r_{now}, C)
            valid \\leftarrow V(\\mathbf{x}_{\\mathcal{C}})
 2:
            if valid = \\text{True} \\land (C \\neq \\varepsilon) then
                                                                                                             \\triangleright C is non-empty and meaningful w.r.t. V(\\cdot)
 3:
                  r&#x27; \\leftarrow r_{\\text{now}}
 4:
                  \\langle r, st, x, ctr \\rangle \\leftarrow \\text{head}(\\mathcal{C})
 5:
                  st&#x27; \\leftarrow H(ctr, G(r, st, x))
 6:
                  repeat
 7:
                         \\langle r, st, x, ctr \\rangle \\leftarrow \\text{head}(\\mathcal{C})
 8:
                                                                                                                                     \\triangleright Calculate target based on \\mathcal{C}^{\\lceil 1 \\rceil}
                        T \\leftarrow D(\\mathbf{r}_{\\mathcal{C}^{\\lceil 1}})
 9:
                        if validblock _{a}^{T}(\\langle st, x, ctr \\rangle) \\wedge (H(ctr, G(r, st, x)) = st&#x27;) \\wedge (r &lt; r&#x27;) then
10:
                                                                                                                                             &#9654; Retain round timestamp
11:
                              st&#x27; \\leftarrow st
                                                                                                                                                          &#9654; Retain hash value
12:
                              \\mathcal{C} \\leftarrow \\mathcal{C}^{\\lceil 1 \\rceil}
                                                                                                                                             \\triangleright Remove the head from \\mathcal{C}
13:
                        else
14:
                               valid \\leftarrow False
15:
                        end if
16:
                  until (\\mathcal{C} = \\varepsilon) \\vee (valid = False)
17:
            end if
18:
19:
            return valid
20: end function
</code></pre>

    <p class="text-gray-300">Chain comparison. The objective of the second algorithm, called maxvalid, is to find the &quot;best possible&quot; chain when given a set of chains. The algorithm is straightforward and is parameterized by a  <span class="math">\\max(\\cdot)</span>  function that applies some ordering in the space of chains. The most important aspect is the chains' difficulty in which case  <span class="math">\\max(\\mathcal{C}_1, \\mathcal{C}_2)</span>  will return the most difficult of the two. In case  <span class="math">\\operatorname{diff}(\\mathcal{C}_1) = \\operatorname{diff}(\\mathcal{C}_2)</span> , some other characteristic can be used to break the tie. In our case,  <span class="math">\\max(\\cdot, \\cdot)</span>  will always return the first operand to reflect the fact that parties adopt the first chain they obtain from the network. (Algorithm 2.)</p>

    <p class="text-gray-300"><strong>Algorithm 2</strong> The function that finds the &quot;best&quot; chain, parameterized by function  <span class="math">\\max(\\cdot)</span> . The input is  <span class="math">\\{C_1, \\ldots, C_k\\}</span> .</p>

    <pre><code class="language-text">1: function maxvalid(r, C_1, \\dots, C_k)

2: temp \\leftarrow \\varepsilon

3: for i = 1 to k do

4: if validate(r, C_i) then

5: temp \\leftarrow \\max(C, temp)

6: end if

7: end for

8: return temp

9: end function
</code></pre>

    <p class="text-gray-300"><strong>Proof of work.</strong> The third algorithm, called pow, is the proof of work-finding procedure. It takes as input a chain and attempts to extend it via solving a proof of work. This algorithm is parameterized by two hash functions  <span class="math">H(\\cdot), G(\\cdot)</span>  as well as the parameter q. Moreover, the algorithm calls the target calculation function  <span class="math">D(\\cdot)</span>  om prder to determine the value T that will be used for the proof of work. The procedure, given a chain C and a value x to be inserted in the chain, hashes these values to obtain h and initializes a counter ctr. Subsequently, it increments ctr and checks to see whether H(ctr,h) &lt; T; in case a suitable ctr is found then the algorithm succeeds in solving the POW and extends chain C by one block. (Algorithm 3.)</p>

    <p class="text-gray-300">Algorithm 3 The proof of work function, parameterized by q and hash functions H(&middot;), G(&middot;). The input is (x, C).</p>

    <pre><code class="language-text">1: function pow(r, x, C)
2: if C = &epsilon; then . Determine proof of work instance.
3: st &larr; 0
4: else
5: hr
        0
        , st0
           , x0
             , ctr0
                i &larr; head(C)
6: st &larr; H(ctr0
               , G(r
                  0
                  , st0
                     , x0
                       ))
7: end if
8: ctr &larr; 1
9: B &larr; &epsilon;
10: T &larr; D(rC) . Calculate target for next block based on timestamps.
11: h &larr; G(r, st, x)
12: while (ctr &le; q) do
13: if (H(ctr, h) &lt; T) then . This H(&middot;) invocation is subject to the q-bound.
14: B &larr; hr, st, x, ctri
15: break
16: end if
17: ctr &larr; ctr + 1
18: end while
19: C &larr; CB . Chain is extended
20: return C
21: end function
</code></pre>

    <p class="text-gray-300">The backbone protocol. The core of the protocol is similar to that of <a href="#page-24-0">[11]</a>, with several important distinctions. First is the procedure to follow when they become active. Parties check the ready flag they possess that is false if and only if they have been inactive in the previous round. In case the ready flag is false, they broadcast a special message 'Join' to request the most recent version of the blockchain(s). Similarly, parties that receive the special request message in their Receive() tape they broadcast their chain. As before, parties run &quot;indefinitely&quot; (our security analysis will apply when the total running time is polynomial in &kappa;). The input contribution function I(&middot;) and the chain reading function R(&middot;) are applied to the values stored in the chain. Parties check their communication tape Receive() to see whether any necessary update of their local chain is due; then they attempt to extend it via the POW algorithm pow. The function I(&middot;) determines the input to be added in the chain given the party's state st, the current chain C, the contents of the party's input tape Input() and communication tape Receive(). The input tape contains two types of symbols, Read and (Insert, value); other inputs are ignored. In case the local chain C is extended the new chain is broadcast to the other parties. Finally, in case a Read symbol is present in the communication tape, the protocol applies function R(&middot;) to its current chain and writes the result onto the output tape Output(). The pseudocode of the backbone protocol is presented in Algorithm <a href="#page-28-0">4.</a></p>

    <p class="text-gray-300"><strong>Algorithm 4</strong> The Bitcoin backbone protocol in the dynamic setting at round &quot;round&quot; on local state  <span class="math">(st, \\mathcal{C})</span>  parameterized by the <em>input contribution function</em>  <span class="math">I(\\cdot)</span>  and the <em>chain reading function</em>  <span class="math">R(\\cdot)</span> . The &quot;ready&quot; flag is False if and only if the party was inactive in the previous round.</p>

    <pre><code class="language-text">1: if ready = True then
            DIFFUSE(Ready)
 2:
           \\tilde{\\mathcal{C}} \\leftarrow \\mathsf{maxvalid}(\\mathcal{C}, \\mathsf{all\\ chains}\\ \\mathcal{C}&#x27; \\ \\mathsf{found\\ in\\ Receive}())
 3:
           if Input() contains Read then
 4:
                   write R(\\mathbf{x}_{\\mathcal{C}}) to Output()
 5:
            end if
 6:
            \\langle st, x \\rangle \\leftarrow I(st, \\tilde{\\mathcal{C}}, \\mathtt{round}, \\mathtt{INPUT}(), \\mathtt{RECEIVE}())
 7:
           C_{\\mathsf{new}} \\leftarrow \\mathsf{pow}(\\mathsf{round}, x, \\mathcal{C})
 8:
           if (\\mathcal{C} \\neq \\mathcal{C}_{new}) \\vee (\\mathsf{Join} \\in \\mathsf{Receive}()) then
 9:
                 \\mathcal{C} \\leftarrow \\mathcal{C}_{\\mathsf{new}}
10:
11:
                 Diffuse(\\mathcal{C})
                                                                                   b chain is diffused when updated or when someone joins.
12:
           end if
            DIFFUSE(RoundComplete)
13:
14: else
           ready \\leftarrow True
15:
            DIFFUSE(Join, RoundComplete)
16:
17: end if
</code></pre>

    </section>

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>B</strong> Robust Public Transaction Ledgers</h2>

    <p class="text-gray-300">In this section we reproduce the presentation of public transaction ledgers given in [10, 11]. A public transaction ledger is defined with respect to a set of valid ledgers  <span class="math">\\mathcal{L}</span>  and a set of valid transactions  <span class="math">\\mathcal{T}</span> , each one possessing an efficient membership test. A ledger  <span class="math">\\mathbf{x} \\in \\mathcal{L}</span>  is a vector of sequences of transactions  <span class="math">\\mathbf{tx} \\in \\mathcal{T}</span> . Each transaction  <span class="math">\\mathbf{tx}</span>  may be associated with one or more accounts, denoted  <span class="math">a_1, a_2, \\ldots</span>  etc.</p>

    <p class="text-gray-300">The backbone protocol parties, called <em>miners</em> in the context of this section, process sequences of transactions of the form  <span class="math">x = \\mathrm{tx}_1 \\dots \\mathrm{tx}_e</span>  that are supposed to be incorporated into their local chain  <span class="math">\\mathcal{C}</span> . The input inserted at each block of the chain  <span class="math">\\mathcal{C}</span>  is the sequence x of transactions. Thus, a ledger is a vector of transaction sequences  <span class="math">\\langle x_1, \\dots, x_m \\rangle</span> , and a chain  <span class="math">\\mathcal{C}</span>  of length m contains the ledger  <span class="math">\\mathbf{x}_{\\mathcal{C}} = \\langle x_1, \\dots, x_m \\rangle</span>  if the input of the j-th block in  <span class="math">\\mathcal{C}</span>  is  <span class="math">x_j</span> .</p>

    <p class="text-gray-300">The description and properties of the ledger protocol will be expressed relative to an oracle Txgen which will control a set of accounts by creating them and issuing transactions on their behalf. In an execution of the backbone protocol, the environment  <span class="math">\\mathcal{Z}</span>  as well as the miners will have access to Txgen. Specifically, Txgen is a stateful oracle that responds to two types of queries (which we purposely only describe at a high level):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>GenAccount( <span class="math">1^{\\kappa}</span> ): It generates an account a.</li>
      <li>Issue Trans <span class="math">(1^{\\kappa}, \\tilde{tx})</span> : It returns a transaction tx provided that  <span class="math">\\tilde{tx}</span>  is some suitably formed string, or  <span class="math">\\perp</span> .</li>
    </ul>

    <p class="text-gray-300">We also consider a symmetric relation on  <span class="math">\\mathcal{T}</span> , denoted by  <span class="math">C(\\cdot, \\cdot)</span> , which indicates when two transactions  <span class="math">\\mathrm{tx}_1, \\mathrm{tx}_2</span>  are conflicting. Valid ledgers  <span class="math">\\mathbf{x} \\in \\mathcal{L}</span>  can never contain two conflicting transactions. We call oracle Txgen <em>unambiguous</em> if it holds that for all PPT  <span class="math">\\mathcal{A}</span> , the probability that  <span class="math">\\mathcal{A}^{\\mathsf{Txgen}}</span>  produces a transaction  <span class="math">\\mathrm{tx}&#x27;</span>  such that  <span class="math">C(\\mathrm{tx}&#x27;,\\mathrm{tx}) = 1</span> , for tx issued by Txgen, is negligible in  <span class="math">\\kappa</span> .</p>

    <p class="text-gray-300">Finally, a transaction tx is called <em>neutral</em> if  <span class="math">C(\\mathsf{tx}, \\mathsf{tx}&#x27;) = 0</span>  for any other transaction  <span class="math">\\mathsf{tx}&#x27;</span> . The presence of neutral transactions in the ledger can be helpful for a variety of purposes, as we will see next and in the BA protocol that we build on top of the ledger. For convenience we will assume that a single random nonce  <span class="math">\\rho \\in \\{0,1\\}^{\\kappa}</span>  is also a valid transaction. Nonces will be neutral transactions and may be included in the ledger for the sole purpose of ensuring independence between the POW instances solved by the honest parties.</p>

    <p class="text-gray-300">Next, we determine the three functions  <span class="math">V(\\cdot)</span> ,  <span class="math">I(\\cdot)</span> ,  <span class="math">R(\\cdot)</span>  that will turn the backbone protocol into  <span class="math">\\Pi_{PL}</span> , a protocol realizing a public transaction ledger. See Figure 1.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Content validation predi-</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">V(\\langle x_1,\\ldots,x_m\\rangle)</span> is true if and only if the vector <span class="math">\\langle x_1,\\ldots,x_m\\rangle</span> is a valid ledger,</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">cate <span class="math">V(\\cdot)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">i.e., <span class="math">\\langle x_1, \\ldots, x_m \\rangle \\in \\mathcal{L}</span> .</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Chain reading function</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">If <span class="math">V(\\langle x_1, \\ldots, x_m \\rangle)</span> = True, the value <span class="math">R(\\mathcal{C})</span> is equal to <span class="math">\\langle x_1, \\ldots, x_m \\rangle</span> ; unde-</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">R(\\cdot)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">fined otherwise.</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Input contribution func-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">I(st, C, round, Input) operates as follows: if the input tape contains</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">tion <span class="math">I(\\cdot)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(Insert, <span class="math">v</span> ), it parses <span class="math">v</span> as a sequence of transactions and retains the largest</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">subsequence <span class="math">x&#x27; \\leq v</span> that is valid with respect to <span class="math">\\mathbf{x}_{\\mathcal{C}}</span> (and whose transactions</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">are not already included in <span class="math">\\mathbf{x}_{\\mathcal{C}}</span> ). Finally, <span class="math">x = \\mathrm{tx}_0 x&#x27;</span> where <span class="math">\\mathrm{tx}_0</span> is a neutral</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">random nonce transaction.</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 1: The public transaction ledger protocol  <span class="math">\\Pi_{PL}</span> , built on the Bitcoin backbone.</p>

    <p class="text-gray-300">In Section 4.3 we introduced two essential properties for a protocol maintaining a public transaction ledger: (i) <em>Persistence</em> and (ii) <em>Liveness</em>. In a nutshell, Persistence states that once an honest player reports a transaction &quot;deep enough&quot; in the ledger, then all other honest players will report it indefinitely whenever they are asked, and at exactly the same position in the ledger (essentially, this means that all honest players agree on all the transactions that took place and in what order). In a more concrete Bitcoin-like setting, Persistence is essential to ensure that credits are final and that they happened at a certain &quot;time&quot; in the system's timeline (which is implicitly defined by the ledger itself).</p>

    <p class="text-gray-300">Persistence is useful but not enough to ensure that the ledger makes progress, i.e., that transactions are eventually inserted in a chain. This is captured by the Liveness property, which states that as long as a transaction comes from an honest account holder and is provided by the environment to all honest players, then it will be inserted into the honest players' ledgers, assuming the environment keeps providing it as an input for a sufficient number of rounds.</p>

    <p class="text-gray-300">For more details about the specification of a robust transaction ledger, in particular Bitcoin-like transactions and ledger, refer to [10, 11].</p>

    <p class="text-gray-300"><strong>Definition 9.</strong> [18, Chapter 12] A sequence of random variables  <span class="math">X_0, X_1, \\ldots</span>  is a martingale with respect to the sequence  <span class="math">Y_0, Y_1, \\ldots</span> , if, for all  <span class="math">n \\geq 0</span> , (1)  <span class="math">X_n</span>  is a function of  <span class="math">Y_0, \\ldots, Y_n</span> , (2)  <span class="math">\\mathbf{E}[|X_n|] &lt; \\infty</span> , and (3)  <span class="math">\\mathbf{E}[X_{n+1}|Y_0, \\ldots, Y_n] = X_n</span> .</p>

    <p class="text-gray-300"><strong>Theorem 6.</strong> [17, Theorem 3.15] Let  <span class="math">X_0, X_1, \\ldots</span>  be a martingale with respect to the sequence  <span class="math">Y_0, Y_1, \\ldots</span>  For  <span class="math">n \\geq 0</span> , let</p>

    <p class="text-gray-300"><span class="math">$V = \\sum_{i=1}^{n} \\operatorname{var}(X_i - X_{i-1} | Y_0, \\dots, Y_{i-1}) \\text{ and } b = \\max_{1 \\le i \\le n} \\sup(X_i - X_{i-1} | Y_0, \\dots, Y_{i-1}),</span>$</p>

    <p class="text-gray-300">where sup is taken over all possible assignments to  <span class="math">Y_0, \\ldots, Y_{i-1}</span> . Then, for any  <span class="math">t, v \\ge 0</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Pr}\\big[(X_n \\ge X_0 + t) \\land (V \\le v)\\big] \\le \\exp\\bigg\\{-\\frac{t^2}{2v + 2bt/3}\\bigg\\}.</span>$</p>

    <p class="text-gray-300"><strong>Fact 2.</strong> Suppose  <span class="math">f: \\mathbb{R}_{\\geq 0} \\to \\mathbb{R}_{\\geq 0}</span>  is concave and  <span class="math">f(0) \\geq 0</span> . Then, for any  <span class="math">x, y \\in [0, \\infty)</span>  and  <span class="math">\\lambda \\in [1, \\infty)</span> ,  <span class="math">f(x/\\lambda) \\geq f(x)/\\lambda</span> ,  <span class="math">f(\\lambda x) \\leq \\lambda f(x)</span> ,  <span class="math">f(x+y) \\leq f(x) + f(y)</span> .</p>

    <p class="text-gray-300">The following well-known inequalities may be used without reference.</p>

    <p class="text-gray-300">Fact 3. (1)  <span class="math">1 + x &lt; e^x</span> , for all x. (2)  <span class="math">-\\frac{x}{1-x} &lt; \\ln(1-x)</span> , for  <span class="math">x \\in (0,1)</span> . (3)  <span class="math">\\frac{x}{1+x/2} &lt; \\ln(1+x) &lt; x</span> , for x &gt; 0.</p>

    </section>
`;
---

<BaseLayout title="The Bitcoin Backbone Protocol with Chains of Variable Diffic... (2016/1048)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/1048
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li><a href="#sec-2" class="hover:text-white">Model and Definitions</a></li>
        <li><a href="#sec-3" class="hover:text-white">Blockchains of Variable Difficulty</a></li>
        <li>
          <a href="#sec-4" class="hover:text-white">The Bitcoin Backbone Protocol with Variable Difficulty</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">The Protocol</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">Properties of the Backbone Protocol with Variable Difficulty</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">Application: Robust Transaction Ledger</a></li>
          </ol>
        </li>
        <li><a href="#sec-5" class="hover:text-white">Overview of the Analysis</a></li>
        <li>
          <a href="#sec-6" class="hover:text-white">Full Analysis</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-6.1" class="hover:text-white">Additional notation, definitions, and preliminary propositions</a></li>
            <li><a href="#sec-6.2" class="hover:text-white">Chain-Growth Lemma</a></li>
            <li><a href="#sec-6.3" class="hover:text-white">Typical Executions: Definition and Related Proofs</a></li>
            <li><a href="#sec-6.4" class="hover:text-white">Typical Executions are Good and Accurate</a></li>
            <li><a href="#sec-6.5" class="hover:text-white">Common Prefix and Chain Quality</a></li>
            <li><a href="#sec-6.6" class="hover:text-white">Persistence and Liveness</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a" class="hover:text-white">The Bitcoin Backbone Protocol with Variable Difficulty (cont&#x27;d)</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-a.1" class="hover:text-white">The protocol</a></li>
          </ol>
        </li>
        <li><a href="#app-b" class="hover:text-white">Robust Public Transaction Ledgers</a></li>
        <li><a href="#app-c" class="hover:text-white">Martingale Sequences and Other Mathematical Facts</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="the-bitcoin-backbone-protocol-with-chains-of-variable-2016" />
  </article>
</BaseLayout>
