---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/1048';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'The Bitcoin Backbone Protocol with Chains of Variable Difficulty';
const AUTHORS_HTML = 'Juan A.  Garay, Aggelos Kiayias, Nikos Leonardos';

const CONTENT = `    <p class="text-gray-300">The Bitcoin Backbone Protocol with Chains of Variable Difficulty*</p>

    <p class="text-gray-300">Juan A. Garay† Texas A&amp;M University College Station, TX, USA. garay@cse.tamu.edu</p>

    <p class="text-gray-300">Aggelos Kiayias*†‡ University of Edinburgh &amp; IOHK, Edinburgh, UK akiayias@inf.ed.ac.uk</p>

    <p class="text-gray-300">Nikos Leonardos National and Kapodistrian University of Athens, Greece nikos.leonardos@gmail.com</p>

    <p class="text-gray-300">August 25, 2019</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">Bitcoin’s innovative and distributedly maintained blockchain data structure hinges on the adequate degree of difficulty of so-called “proofs of work,” which miners have to produce in order for transactions to be inserted. Importantly, these proofs of work have to be hard enough so that miners have an opportunity to unify their views in the presence of an adversary who interferes but has bounded computational power, but easy enough to be solvable regularly and enable the miners to make progress. As such, as the miners’ population evolves over time, so should the difficulty of these proofs. Bitcoin provides this adjustment mechanism, with empirical evidence of a constant block generation rate against such population changes.</p>

    <p class="text-gray-300">In this paper we provide the first formal analysis of Bitcoin’s target (re)calculation function in the cryptographic setting, i.e., against all possible adversaries aiming to subvert the protocol’s properties. We extend the <span class="math">q</span>-bounded synchronous model of the Bitcoin backbone protocol [Eurocrypt 2015], which posed the basic properties of Bitcoin’s underlying blockchain data structure and shows how a robust public transaction ledger can be built on top of them, to environments that may introduce or suspend parties in each round.</p>

    <p class="text-gray-300">We provide a set of necessary conditions with respect to the way the population evolves under which the “Bitcoin backbone with chains of variable difficulty” provides a robust transaction ledger in the presence of an actively malicious adversary controlling a fraction of the miners strictly below 50% at each instant of the execution. Our work introduces new analysis techniques and tools to the area of blockchain systems that may prove useful in analyzing other blockchain protocols.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">The Bitcoin backbone [11] extracts and analyzes the basic properties of Bitcoin’s underlying blockchain data structure, such as “common prefix” and “chain quality,” which parties (“miners”) maintain and try to extend by generating “proofs of work” (POW, aka “cryptographic puzzles” [8, 22, 1, 13])¹. It is then formally shown in [11] how fundamental applications including consensus [21, 16] and a robust public transaction ledger realizing a decentralized cryptocurrency (e.g., Bitcoin [19]) can be built on top of them, assuming that the hashing power of an adversary controlling a fraction of the parties is strictly less than 1/2.</p>

    <p class="text-gray-300">The results in [11], however, hold for a static setting, where the protocol is executed by a fixed number of parties (albeit not necessarily known to the participants), and therefore with POWs (and hence blockchains) of fixed difficulty. This is in contrast to the actual deployment of the Bitcoin protocol where a “target (re)calculation” mechanism adjusts the hardness level of POWs as the number of parties varies during the</p>

    <p class="text-gray-300">*An abridged version of this paper was published in Crypto 2017.</p>

    <p class="text-gray-300">†Part of this work was done while the authors were visiting the Simons Institute for the Theory of Computing, supported by the Simons Foundation and by the DIMACS/Simons Collaboration in Cryptography through NSF grant #CNS-1523467.</p>

    <p class="text-gray-300">‡Research partly supported by ERC project CODAMODA, No. 259152, and Horizon 2020 project PANORAMIX, No. 653497.</p>

    <p class="text-gray-300">¹In Bitcoin, solving a proof of work essentially amounts to brute-forcing a hash inequality based on SHA-256.</p>

    <p class="text-gray-300">protocol execution. In more detail, in <em>[11]</em> the target <span class="math">T</span> that the hash function output must not exceed, is set and hardcoded at the beginning of the protocol, and in such a way that a specific relation to the number of parties running the protocol is satisfied, namely, that a ratio <span class="math">f</span> roughly equal to <span class="math">qnT/2^{\\kappa}</span> is small, where <span class="math">q</span> is the number of queries to the hash function that each party is allowed per round, <span class="math">n</span> is the number of parties, and <span class="math">\\kappa</span> is the length of the hash function output. Security was only proven when the number of parties is <span class="math">n</span> and the choice of target <span class="math">T</span> is never recalculated, thus leaving as open question the full analysis of the protocol in a setting where, as in the real world, parties change dynamically over time.</p>

    <p class="text-gray-300">In this paper, we abstract for the first time the target recalculation algorithm from the Bitcoin system, and present a generalization and analysis of the Bitcoin backbone protocol with chains of variable difficulty, as produced by an evolving population of parties, thus answering the aforementioned open question.</p>

    <p class="text-gray-300">In this setting, there is a parameter <span class="math">m</span> which determines the length of an “epoch” in number of blocks. When a party prepares to compute the <span class="math">j</span>-th block of a chain with <span class="math">j\\bmod m=1</span>, it uses a target calculation algorithm that determines the proper target value to use, based on the party’s local view about the total number of parties that are present in the system, as reflected by the rate of blocks that have been created so far and are part of the party’s chain. (Each block contains a timestamp of when it was created; in our synchronous setting, timestamps will correspond to the round numbers when blocks are created—see Section 2.) To accomodate the evolving population of parties, we extend the model of <em>[11]</em> to environments that are free to introduce and suspend parties in each round. In other respects, we follow the model of <em>[11]</em>, where all parties have the same “hashing power,” with each one allowed to pose <span class="math">q</span> queries to the hash function that is modeled as a “random oracle” <em>[3]</em>. We refer to our setting as the dynamic <span class="math">q</span>-bounded synchronous setting.</p>

    <p class="text-gray-300">In order to give an idea of the issues involved, we note that without a target calculation mechanism, in the dynamic setting the backbone protocol is not secure even if all parties are honest and follow the protocol faithfully. Indeed, it is easy to see that a combination of an environment that increases the number of parties and adversarial network conditions can lead to substantial divergence (a.k.a. “forks”) in the chains of the honest parties, leading to the violation of the agreement-type properties that are needed for the applications of the protocol, such as maintaining a robust transaction ledger. The attack is simple: the environment increases the number of parties constantly so that the block production rate per round increases (which is roughly the parameter <span class="math">f</span> mentioned above); then, adversarial network conditions may divide the parties into two sets, <span class="math">A</span> and <span class="math">B</span>, and schedule message delivery so that parties in set <span class="math">A</span> receive blocks produced by parties in <span class="math">A</span> first, and similarly for set <span class="math">B</span>. According to the Bitcoin protocol, parties adopt the block they see first, and thus the two sets will maintain two separate blockchains.</p>

    <p class="text-gray-300">While this specific attack could in principle be thwarted by modifying the Bitcoin backbone (e.g., by randomizing which block a party adopts when they receive in the same round two blocks of the same index in the chain), it certainly would not cope with all possible attacks in the presence of a full-blown adversary and target recalculation mechanism. Indeed, such an attack was shown in <em>[2]</em>, where by mining “privately” with timestamps in rapid succession, corrupt miners are able to induce artificially high targets in their private chain; even though such chain may grow slower than the main chain, it will still make progress and, via an anti-concentration argument, a sudden adversarial advance that can break agreement amongst honest parties cannot be ruled out.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given the above, our main goal is to show that the backbone protocol with a Bitcoin-like target recalculation function satisfies the common prefix and chain quality properties, as an intermediate step towards proving that the protocol implements a robust transaction ledger. Expectedly, the class of protocols we will analyze will not preserve its properties for arbitrary ways in which the number of parties may change over time. In order to bound the error in the calibration of the block generation rate that the target recalculation function attempts, we will need some bounds on the way the number of parties may vary. For <span class="math">\\gamma\\in\\mathbb{R}^{+}</span> and <span class="math">s\\in\\mathbb{N}</span>, we will call a sequence <span class="math">(n_{r})_{r\\in\\mathbb{N}}</span> of parties <span class="math">(\\gamma,s)</span>-respecting if it holds that in a sequence of rounds <span class="math">S</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq s<span class="math">, </span>\\max_{r\\in S}n_{r}\\leq\\gamma\\cdot\\min_{r\\in S}n_{r}$, and will determine for what values of these parameters the</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">backbone protocol is secure.</p>

    <p class="text-gray-300">After formally describing blockchains of variable difficulty and the Bitcoin backbone protocol in this setting, at a high level our analysis goes as follows. We first introduce the notion of goodness regarding the approximation that is performed on <span class="math">f</span> in an epoch. In more detail, we call a round <span class="math">r</span> (<span class="math">\\eta,\\theta</span>)-good, for some parameters <span class="math">\\eta,\\theta\\in\\mathbb{R}^{+}</span>, if the value <span class="math">f_{r}</span> computed for the actual number of parties and target used in round <span class="math">r</span> by some honest party, falls in the range <span class="math">[\\eta f,\\theta f]</span>, where <span class="math">f</span> is the initial block production rate (note that the first round is always assumed good). Together with “goodness” we introduce the notion of typical executions, in which, informally, for any set <span class="math">S</span> of consecutive rounds the successes of the adversary and the honest parties do not deviate too much from their expectations as well as no “bad” event concerning the hash function occurs (such as a collision). Using a martingale bound we demonstrate that almost all polynomially bounded (in <span class="math">\\kappa</span>) executions are typical.</p>

    <p class="text-gray-300">Next, we proceed to show that in a typical execution any chain that an honest party adopts (1) contains timestamps that are approximately accurate (i.e., no adversarial block has a timestamp that differs too much from its real creation time), and (2) it has a target such that the probability of block production remains near the fixed constant <span class="math">f</span>, i.e., it is “good.” Finally, these properties allow us to demonstrate that a typical execution enjoys the common prefix and chain quality properties, which is a stepping stone towards the ultimate goal, that of establishing that the backbone protocol with variable difficulty implements a robust transaction ledger. Specifically, we show the following:</p>

    <p class="text-gray-300">Main result (Informal—see Theorems 5 and 6). The Bitcoin backbone protocol with chains of variable difficulty, suitably parameterized, satisfies with overwhelming probability in <span class="math">m</span> and <span class="math">\\kappa</span> the properties of (1) persistence—if a transaction tx is confirmed by an honest party, no honest party will ever disagree about the position of tx in the ledger, and (2) liveness—if a transaction tx is broadcast, it will eventually become confirmed by all honest parties.</p>

    <p class="text-gray-300">Remark. Regarding the actual parameterization of the Bitcoin system (that uses epochs of <span class="math">m=2016</span> blocks), even though it is consistent with all the constraints of our theorems (cf. Remark 3 in Section 6.1), it cannot be justified by our martingale analysis. In fact, our probabilistic analysis would require much longer epochs to provide a sufficiently small probability of attack. Tightening the analysis or discovering attacks for parameterizations beyond our security theorems is an interesting open question.</p>

    <p class="text-gray-300">Finally, we note that various extensions to our model are relevant to the Bitcoin system and constitute interesting directions for further research. Importantly, a security analysis in the “rational” setting (see, e.g., <em>[9, 23, 14]</em>), and in the “partially synchronous,” or “bounded-delay” network model <em>[7, 20]</em>.</p>

    <h2 id="sec-1" class="text-2xl font-bold">2 Model and Definitions</h2>

    <p class="text-gray-300">We describe our protocols in a model that extends the synchronous communication network model presented in <em>[10, 11]</em> for the analysis of the Bitcoin backbone protocol in the static setting with a fixed number of parties (which in turn is based on Canetti’s formulation of “real world” notion of protocol execution <em>[4, 5, 6]</em> for multi-party protocols) to the dynamic setting with a varying number of parties. In this section we provide a high-level overview of the model, highlighting the differences that are intrinsic to our dynamic setting.</p>

    <p class="text-gray-300">Round structure and protocol execution. As in <em>[10]</em>, the protocol execution proceeds in rounds with inputs provided by an environment program denoted by <span class="math">\\mathcal{Z}</span> to parties that execute the protocol <span class="math">\\Pi</span>, and our adversarial model in the network is “adaptive,” meaning that the adversary <span class="math">\\mathcal{A}</span> is allowed to take control of parties on the fly, and “rushing,” meaning that in any given round the adversary gets to see all honest players’ messages before deciding his strategy. The parties’ access to the hash function and their communication mechanism are captured by a joint random oracle / diffusion functionality which reflects Bitcoin’s peer</p>

    <p class="text-gray-300">structure. The diffusion functionality, <em>[10]</em>, allows the order of messages to be controlled by <span class="math">\\mathcal{A}</span>, i.e., there is no atomicity guarantees in message broadcast <em>[12]</em>, and, furthermore, the adversary is allowed to spoof the source information on every message (i.e., communication is not authenticated). Still, the adversary cannot change the contents of the messages nor prevent them from being delivered. We will use Diffuse as the message transmission command that captures this “send-to-all” functionality.</p>

    <p class="text-gray-300">The parties that <em>may</em> become active in a protocol execution are encoded as part of a control program <span class="math">C</span> and come from a universe <span class="math">\\mathcal{U}</span> of parties.</p>

    <p class="text-gray-300">The protocol execution is driven by an environment program <span class="math">\\mathcal{Z}</span> that interacts with other instances of programs that it spawns at the discretion of the control program <span class="math">C</span>. The pair <span class="math">(\\mathcal{Z},C)</span> forms of a <em>system of interactive Turing machines</em> (ITM’s) in the sense of <em>[5]</em>. The execution is with respect to a program <span class="math">\\Pi</span>, an adversary <span class="math">\\mathcal{A}</span> (which is another ITM) and the universe of parties <span class="math">\\mathcal{U}</span>. Assuming the control program <span class="math">C</span> allows it, the environment <span class="math">\\mathcal{Z}</span> can activate a party by writing to its input tape. Note that the environment <span class="math">\\mathcal{Z}</span> also receives the parties’ outputs when they are produced in a standard subroutine-like interaction. Additionally, the control program maintains a flag for each instance of an ITM, (abbreviated as ITI in the terminology of <em>[5]</em>), that is called the ready flag and is initially set to false for all parties.</p>

    <p class="text-gray-300">The environment <span class="math">\\mathcal{Z}</span>, initially is restricted by <span class="math">C</span> to spawn the adversary <span class="math">\\mathcal{A}</span>. Each time the adversary is activated, it may send one or more messages of the form <span class="math">(\\textsf{Corrupt},P_{i})</span> to <span class="math">C</span> and <span class="math">C</span> will mark the corresponding party as corrupted.</p>

    <p class="text-gray-300">Functionalities available to the protocol. The ITI’s of protocol <span class="math">\\Pi</span> will have access to a joint ideal functionality capturing the random oracle and the diffusion mechanism which is defined in a similar way as <em>[10]</em> and is explained below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The random oracle functionality. Given a query with a value <span class="math">x</span> marked for “calculation” for the function <span class="math">H(\\cdot)</span> from an honest party <span class="math">P_{i}</span> and assuming <span class="math">x</span> has not been queried before, the functionality returns a value <span class="math">y</span> which is selected at random from <span class="math">\\{0,1\\}^{\\kappa}</span>; furthermore, it stores the pair <span class="math">(x,y)</span> in the table of <span class="math">H(\\cdot)</span>, in case the same value <span class="math">x</span> is queried in the future. Each honest party <span class="math">P_{i}</span> is allowed to ask <span class="math">q</span> queries in each round as determined by the diffusion functionality (see below). On the other hand, each honest party is given unlimited queries for “verification” for the function <span class="math">H(\\cdot)</span>. The adversary <span class="math">\\mathcal{A}</span>, on the other hand, is given a bounded number queries in each round as determined by diffusion functionality with a bound that is initialized to <span class="math">0</span> and determined as follows: whenever a corrupted party is activated, the party can ask the bound to be increased by <span class="math">q</span>; each time a query is asked by the adversary the bound is decreased by <span class="math">1</span>. No verification queries are provided to <span class="math">\\mathcal{A}</span>. Note that the value <span class="math">q</span> is a polynomial function of <span class="math">\\kappa</span>, the security parameter. The functionality can maintain tables for functions other than <span class="math">H(\\cdot)</span> but, by convention, the functionality will impose query quotas to function <span class="math">H(\\cdot)</span> only.</li>

      <li>The diffusion functionality. This functionality keeps track of rounds in the protocol execution; for this purpose it initially sets a variable <span class="math">round</span> to be <span class="math">1</span>. It also maintains a Receive() string defined for each party <span class="math">P_{i}</span> in <span class="math">\\mathcal{U}</span>. A party that is activated is allowed to query the functionality and fetch the contents of its personal Receive() string. Moreover, when the functionality receives a message <span class="math">(\\textsf{Diffuse},m)</span> from party <span class="math">P_{i}</span> it records the message <span class="math">m</span>. A party <span class="math">P_{i}</span> can signal when it is complete for the round by sending a special message (RoundComplete). With respect to the adversary <span class="math">\\mathcal{A}</span>, the functionality allows it to receive the contents of all contents sent in Diffuse messages for the round and specify the contents of the Receive() string for each party <span class="math">P_{i}</span>. The adversary has to specify when it is complete for the current round. When all parties are complete for the current round, the functionality inspects the contents of all Receive() strings and includes any messages <span class="math">m</span> that were diffused by the parties in the current round but not contributed by the adversary to the Receive() tapes (in this way guaranteeing message delivery). It also flushes any old messages that were diffused in previous rounds and not diffused again. The variable <span class="math">round</span> is then incremented.</li>

    </ul>

    <p class="text-gray-300">The dynamic <span class="math">q</span>-bounded synchronous setting. Consider <span class="math">\\mathbf{n}=\\{n_{r}\\}_{r\\in\\mathbb{N}}</span> and <span class="math">\\mathbf{t}=\\{t_{r}\\}_{r\\in\\mathbb{N}}</span> two series of</p>

    <p class="text-gray-300">natural numbers. As mentioned, the first instance that is spawned by <span class="math">\\mathcal{Z}</span> is the adversary <span class="math">\\mathcal{A}</span>. Subsequently the environment may spawn (or activate if they are already spawned) parties <span class="math">P_{i} \\in \\mathcal{U}</span>. The control program maintains a counter in each sequence of activations and matches it with the current round that is maintained by the diffusion functionality. Each time an honest party diffuses a message containing the label “ready” the control program <span class="math">C</span> increases the ready counter for the round. In round <span class="math">r</span>, the control program <span class="math">C</span> will enable the adversary <span class="math">\\mathcal{A}</span> to complete the round, only provided that (i) exactly <span class="math">n_r</span> parties have transmitted ready message, (ii) the number of (“corrupt”) parties controlled by <span class="math">\\mathcal{A}</span> should match <span class="math">t_r</span>.</p>

    <p class="text-gray-300">Parties, when activated, are able to read their input tape INPUT() and communication tape RECEIVE() from the diffusion functionality. Observe that parties are unaware of the set of activated parties. The Bitcoin backbone protocol requires from parties (miners) to calculate a POW. This is modeled in [11] as parties having access to the oracle <span class="math">H(\\cdot)</span>. The fact that (active) parties have limited ability to produce such POWs, is captured as in [11] by the random oracle functionality and the fact that it paces parties to query a limited number of queries per round. The bound, <span class="math">q</span>, is a function of the security parameter <span class="math">\\kappa</span>; in this sense the parties may be called <span class="math">q</span>-bounded<span class="math">^4</span>. We refer to the above restrictions on the environment, the parties and the adversary as the dynamic <span class="math">q</span>-bounded synchronous setting.</p>

    <p class="text-gray-300">The term <span class="math">\\{\\mathrm{view}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{\\mathbf{P},\\mathbf{t},\\mathbf{n}}(z)\\}_{z\\in \\{0,1\\}^<em>}</span> denotes the random variable ensemble describing the view of party <span class="math">P</span> after the completion of an execution running protocol <span class="math">\\Pi</span> with environment <span class="math">\\mathcal{Z}</span> and adversary <span class="math">\\mathcal{A}</span>, on input <span class="math">z\\in \\{0,1\\}^</em></span>. We will only consider a “standalone” execution without any auxiliary information and we will thus restrict ourselves to executions with <span class="math">z = 1^{\\kappa}</span>. For this reason we will simply refer to the ensemble by <span class="math">\\mathrm{view}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{\\mathbf{P},\\mathbf{t},\\mathbf{n}}</span>. The concatenation of the view of all parties ever activated in the execution is denoted by <span class="math">\\mathrm{view}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{\\mathbf{t},\\mathbf{n}}</span>.</p>

    <p class="text-gray-300">Properties of protocols. In our theorems we will be concerned with properties of protocols <span class="math">\\Pi</span> running in the above setting. Such properties will be defined as predicates over the random variable <span class="math">\\mathrm{view}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{\\mathbf{t},\\mathbf{n}}</span> by quantifying over all possible adversaries <span class="math">\\mathcal{A}</span> and environments <span class="math">\\mathcal{Z}</span>. Note that all our protocols will only satisfy properties with a small probability of error in <span class="math">\\kappa</span> as well as in a parameter <span class="math">k</span> that is selected from <span class="math">\\{1,\\dots,\\kappa\\}</span> (with foresight we note that in practice would be able to choose <span class="math">k</span> to be much smaller than <span class="math">\\kappa</span>, e.g., <span class="math">k = 6</span>).</p>

    <p class="text-gray-300">The protocol class that we will analyze will not be able to preserve its properties for arbitrary sequences of parties. To restrict the way the sequence <span class="math">\\mathbf{n}</span> is fluctuating we will introduce the following class of sequences.</p>

    <p class="text-gray-300"><strong>Definition 1.</strong> For <span class="math">\\gamma \\in \\mathbb{R}^{+}</span>, we call a sequence <span class="math">(n_r)_{r\\in \\mathbb{N}}</span> <span class="math">(\\gamma, s)</span>-respecting if for any set <span class="math">S</span> of at most <span class="math">s</span> consecutive rounds, <span class="math">\\max_{r\\in S}n_r\\leq \\gamma \\cdot \\min_{r\\in S}n_r</span>.</p>

    <p class="text-gray-300">Observe that the above definition is fairly general and also can capture exponential growth; e.g., by setting <span class="math">\\gamma = 2</span> and <span class="math">s = 10</span>, it follows that every 10 rounds the number of ready parties may double. Note that this will not lead to an exponential running time overall since the total run time is bounded by a polynomial in <span class="math">\\kappa</span>, (due to the fact that <span class="math">(\\mathcal{Z}, C)</span> is a system of ITM's, <span class="math">\\mathcal{Z}</span> is locally polynomial bounded, <span class="math">C</span> is a polynomial-time program, and thus [5, Proposition 3] applies).</p>

    <p class="text-gray-300">More formally, a protocol <span class="math">\\Pi</span> would satisfy a property <span class="math">Q</span> for a certain class of sequences <span class="math">\\mathbf{n}, \\mathbf{t}</span>, provided that for all PPT <span class="math">\\mathcal{A}</span> and locally polynomial bounded <span class="math">\\mathcal{Z}</span>, it holds that <span class="math">Q(\\mathrm{view}_{\\Pi, \\mathcal{A}, \\mathcal{Z}}^{\\mathbf{t}, \\mathbf{n}})</span> is true with overwhelming probability of the coins of <span class="math">\\mathcal{A}, \\mathcal{Z}</span> and the random oracle functionality.</p>

    <p class="text-gray-300">In this paper, we will be interested in <span class="math">(\\gamma, s)</span>-respecting sequences <span class="math">\\mathbf{n}</span>, sequences <span class="math">\\mathbf{t}</span> suitably restricted by <span class="math">\\mathbf{n}</span>, and protocols <span class="math">\\Pi</span> suitably parameterized given <span class="math">\\mathbf{n}, \\mathbf{t}</span>.</p>

    <p class="text-gray-300">We start by introducing blockchain notation; we use similar notation to [10], and expand the notion of blockchain to explicitly include timestamps (in the form of a round indicator). Let <span class="math">G(\\cdot)</span> and <span class="math">H(\\cdot)</span> be</p>

    <p class="text-gray-300"><span class="math">^4</span>In [11] this is referred to as the “flat-model” in terms of computational power, where all parties are assumed equal. In practice, different parties may have different “hashing power”; note that this does not sacrifice generality since one can imagine that real parties are simply clusters of some arbitrary number of flat-model parties.</p>

    <p class="text-gray-300">cryptographic hash functions with output in <span class="math">\\{0,1\\}^{\\kappa}</span>. A block with target <span class="math">T\\in\\mathbb{N}</span> is a quadruple of the form <span class="math">B=\\langle r,st,x,ctr\\rangle</span> where <span class="math">st\\in\\{0,1\\}^{\\kappa},x\\in\\{0,1\\}^{*}</span>, and <span class="math">r,ctr\\in\\mathbb{N}</span> are such that they satisfy the predicate <span class="math">\\mathsf{validblock}_{q}^{T}(B)</span> defined as</p>

    <p class="text-gray-300"><span class="math">(H(ctr,G(r,st,x))&lt;T)\\wedge(ctr\\leq q).</span></p>

    <p class="text-gray-300">The parameter <span class="math">q\\in\\mathbb{N}</span> is a bound that in the Bitcoin implementation determines the size of the register <span class="math">ctr</span>; as in <em>[10]</em>, in our treatment we allow <span class="math">q</span> to be arbitrary, and use it to denote the maximum allowed number of hash queries in a round (cf. Section 2). We do this for convenience and our analysis applies in a straightforward manner to the case that <span class="math">ctr</span> is restricted to the range <span class="math">0\\leq ctr&lt;2^{32}</span> and <span class="math">q</span> is independent of <span class="math">ctr</span>.</p>

    <p class="text-gray-300">A blockchain, or simply a chain is a sequence of blocks. The rightmost block is the head of the chain, denoted <span class="math">\\text{head}(\\mathcal{C})</span>. Note that the empty string <span class="math">\\varepsilon</span> is also a chain; by convention we set <span class="math">\\text{head}(\\varepsilon)=\\varepsilon</span>. A chain <span class="math">\\mathcal{C}</span> with <span class="math">\\text{head}(\\mathcal{C})=\\langle r,st,x,ctr\\rangle</span> can be extended to a longer chain by appending a valid block <span class="math">B=\\langle r^{\\prime},st^{\\prime},x^{\\prime},ctr^{\\prime}\\rangle</span> that satisfies <span class="math">st^{\\prime}=H(ctr,G(r,st,x))</span> and <span class="math">r^{\\prime}&gt;r</span>, where <span class="math">r^{\\prime}</span> is called the timestamp of block <span class="math">B</span>. In case <span class="math">\\mathcal{C}=\\varepsilon</span>, by convention any valid block of the form <span class="math">\\langle r^{\\prime},st^{\\prime},x^{\\prime},ctr^{\\prime}\\rangle</span> may extend it. In either case we have an extended chain <span class="math">\\mathcal{C}_{\\mathsf{new}}=\\mathcal{C}B</span> that satisfies <span class="math">\\text{head}(\\mathcal{C}_{\\mathsf{new}})=B</span>.</p>

    <p class="text-gray-300">The length of a chain <span class="math">\\text{len}(\\mathcal{C})</span> is its number of blocks. Consider a chain <span class="math">\\mathcal{C}</span> of length <span class="math">\\ell</span> and any nonnegative integer <span class="math">k</span>. We denote by <span class="math">\\mathcal{C}^{\\lceil k}</span> the chain resulting from “pruning” the <span class="math">k</span> rightmost blocks. Note that for <span class="math">k\\geq\\text{len}(\\mathcal{C})</span>, <span class="math">\\mathcal{C}^{\\lceil k}=\\varepsilon</span>. If <span class="math">\\mathcal{C}_{1}</span> is a prefix of <span class="math">\\mathcal{C}_{2}</span> we write <span class="math">\\mathcal{C}_{1}\\preceq\\mathcal{C}_{2}</span>.</p>

    <p class="text-gray-300">Given a chain <span class="math">\\mathcal{C}</span> of length <span class="math">\\text{len}(\\mathcal{C})=\\ell</span>, we let <span class="math">\\mathbf{x}_{\\mathcal{C}}</span> denote the vector of <span class="math">\\ell</span> values that is stored in <span class="math">\\mathcal{C}</span> and starts with the value of the first block. Similarly, <span class="math">\\mathbf{r}_{\\mathcal{C}}</span> is the vector that contains the timestamps of the blockchain <span class="math">\\mathcal{C}</span>.</p>

    <p class="text-gray-300">For a chain of variable difficulty, the target <span class="math">T</span> is recalculated for each block based on the round timestamps of the previous blocks. Specifically, there is a function <span class="math">D:\\mathbb{Z}^{*}\\to\\mathbb{R}</span> which receives an arbitrary vector of round timestamps and produces the next target. The value <span class="math">D(\\varepsilon)</span> is the initial target of the system. The difficulty of each block is measured in terms of how many times the block is harder to obtain than a block of target <span class="math">T_{0}</span>. In more detail, the difficulty of a block with target <span class="math">T</span> is equal to <span class="math">T_{0}/T</span>; without loss of generality we will adopt the simpler expression <span class="math">1/T</span> (as <span class="math">T_{0}</span> will be a constant across all executions). We will use <span class="math">\\text{diff}(\\mathcal{C})</span> to denote the difficulty of a chain. This is equal to the sum of the difficulties of all the blocks that comprise the chain.</p>

    <p class="text-gray-300">The target calculation function. Intuitively, the target calculation function <span class="math">D(\\cdot)</span> aims at maintaining the block production rate constant. It is parameterized by <span class="math">m\\in\\mathbb{N}</span> and <span class="math">f\\in(0,1)</span>; Its goal is that <span class="math">m</span> blocks will be produced every <span class="math">m/f</span> rounds. We will see in Section 6 that the probability <span class="math">f(T,n)</span> with which <span class="math">n</span> parties produce a new block with target <span class="math">T</span> is approximated by</p>

    <p class="text-gray-300"><span class="math">f(T,n)\\approx\\frac{qTn}{2^{\\kappa}}.</span></p>

    <p class="text-gray-300">(Note that <span class="math">T/2^{\\kappa}</span> is the probability that a single player produces a block in a single query.)</p>

    <p class="text-gray-300">To achieve the above goal Bitcoin tries to keep <span class="math">qTn/2^{\\kappa}</span> close to <span class="math">f</span>. To that end, Bitcoin waits for <span class="math">m</span> blocks to be produced and based on their difficulty and how fast these blocks were computed it computes the next target. More specifically, say the last <span class="math">m</span> blocks of a chain <span class="math">\\mathcal{C}</span> are for target <span class="math">T</span> and were produced in <span class="math">\\Delta</span> rounds. Consider the case where a number of players</p>

    <p class="text-gray-300"><span class="math">n(T,\\Delta)=\\frac{2^{\\kappa}m}{qT\\Delta}</span></p>

    <p class="text-gray-300">attempts to produce <span class="math">m</span> blocks of target <span class="math">T</span>; note that it will take them approximately <span class="math">\\Delta</span> rounds in expectation. Intuitively, the number of players at the point when <span class="math">m</span> blocks were produced is estimated by <span class="math">n(T,\\Delta)</span>; then the next target <span class="math">T^{\\prime}</span> is set so that <span class="math">n(T,\\Delta)</span> players would need <span class="math">m/f</span> rounds in expectation to produce <span class="math">m</span> blocks of target <span class="math">T^{\\prime}</span>. Therefore, it makes sense to set</p>

    <p class="text-gray-300"><span class="math">T^{\\prime}=\\frac{\\Delta}{m/f}\\cdot T,</span></p>

    <p class="text-gray-300">because if the number of players is indeed <span class="math">n(T,\\Delta)</span> and remains unchanged, it will take them <span class="math">m/f</span> rounds in expectation to produce <span class="math">m</span> blocks. If the initial estimate of the number parties is <span class="math">n_{0}</span>, we will assume <span class="math">T_{0}</span> is appropriately set so that <span class="math">f\\approx qT_{0}n_{0}/2^{\\kappa}</span> and then</p>

    <p class="text-gray-300"><span class="math">T^{\\prime}=\\frac{n_{0}}{n(T,\\Delta)}\\cdot T_{0}.</span></p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">Recall that in the flat <span class="math">q</span>-bounded setting all parties have the same hashing power (<span class="math">q</span>-queries per round). It follows that <span class="math">n_{0}</span> represents the estimated initial hashing power while <span class="math">n(T,\\Delta)</span> the estimated hashing power during the last <span class="math">m</span> blocks of the chain <span class="math">\\mathcal{C}</span>. As a result the new target is equal to the initial target <span class="math">T_{0}</span> multiplied by the factor <span class="math">n_{0}/n(T,\\Delta)</span>, reflecting the change of hashing power in the last <span class="math">m</span> blocks.</p>

    <p class="text-gray-300">Based on the above we give the formal definition of the target (re)calculation function, which is as follows.</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">For fixed constants <span class="math">\\kappa,\\tau,m,n_{0},T_{0}</span>, the target calculation function <span class="math">D:\\mathbb{Z}^{*}\\rightarrow\\mathbb{R}</span> is defined as</p>

    <p class="text-gray-300">\\[ D(\\varepsilon)=T_{0}\\quad\\text{and}\\quad D(r_{1},\\ldots,r_{v})=\\begin{cases}\\frac{1}{\\tau}\\cdot T&\\text{if }\\frac{n_{0}}{n(T,\\Delta)}\\cdot T_{0}<\\frac{1}{\\tau}\\cdot T;\\\\ \\tau\\cdot T&\\text{if }\\frac{n_{0}}{n(T,\\Delta)}\\cdot T_{0}>\\tau\\cdot T;\\\\ \\frac{n_{0}}{n(T,\\Delta)}\\cdot T_{0}&\\text{otherwise},\\end{cases} \\]</p>

    <p class="text-gray-300">where <span class="math">n(T,\\Delta)=2^{\\kappa}m/qT\\Delta</span>, with <span class="math">\\Delta=r_{m^{\\prime}}-r_{m^{\\prime}-m}</span>, <span class="math">T=D(r_{1},\\ldots,r_{m^{\\prime}-1})</span>, and <span class="math">m^{\\prime}=m\\cdot\\lfloor v/m\\rfloor</span>.</p>

    <p class="text-gray-300">In the definition, <span class="math">(r_{1},\\ldots,r_{v})</span> corresponds to a chain of <span class="math">v</span> blocks with <span class="math">r_{i}</span> the timestamp of the <span class="math">i</span>th block; <span class="math">m^{\\prime},\\Delta</span>, and <span class="math">T</span> correspond to the last block, duration, and target of the last completed epoch, respectively.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">A remark is in order about the case <span class="math">\\frac{n_{0}}{n(T,\\Delta)}\\cdot T_{0}\\notin[\\frac{1}{\\tau}T,\\tau T]</span>, since this aspect of the definition is not justified by the discussion preceeding Definition 2. At first there may seem to be no reason to introduce such a “dampening filter” in Bitcoin’s target recalculation function and one should let the parties to try collectively to approximate the proper target. Interestingly, in the absence of such dampening, an efficient attack is known <em>[2]</em> (against the common-prefix property). As we will see, this dampening is sufficient for us to prove security against all attackers, including those considered in <em>[2]</em> (with foresight, we can say that the attack still holds but it will take exponential time to mount).</p>

    <h2 id="sec-6" class="text-2xl font-bold">4 The Bitcoin Backbone Protocol with Variable Difficulty</h2>

    <p class="text-gray-300">In this section we give a high-level description of the Bitcoin backbone protocol with chains of variable difficulty; a more detailed description, including the pseudocode of the algorithms, is given in Appendix A. The presentation is based on the description in <em>[11]</em>. We then formulate two desired properties of the blockchain—common prefix and chain quality—for the dynamic setting.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">4.1 The Protocol</h3>

    <p class="text-gray-300">As in <em>[11]</em>, in our description of the backbone protocol we intentionally avoid specifying the type of values/content that parties try to insert in the chain, the type of chain validation they perform (beyond checking for its structural properties with respect to the hash functions <span class="math">G(\\cdot),H(\\cdot)</span>), and the way they interpret the chain. These checks and operations are handled by the external functions <span class="math">V(\\cdot),I(\\cdot)</span> and <span class="math">R(\\cdot)</span> (the content validation function, the input contribution function and the chain reading function, resp.) which are specified by the application that runs “on top” of the backbone protocol. The Bitcoin backbone protocol in the dynamic setting comprises three algorithms.</p>

    <p class="text-gray-300">Chain validation. The validate algorithm performs a validation of the structural properties of a given chain <span class="math">\\mathcal{C}</span>. It is given as input the value <span class="math">q</span>, as well as hash functions <span class="math">H(\\cdot),G(\\cdot)</span>. It is parameterized by the</p>

    <p class="text-gray-300">content validation predicate predicate <span class="math">V(\\cdot)</span> as well as by <span class="math">D(\\cdot)</span>, the target calculation function (Section 3). For each block of the chain, the algorithm checks that the proof of work is properly solved (with a target that is suitable as determined by the target calculation function), and that the counter <span class="math">ctr</span> does not exceed <span class="math">q</span>. Furthermore it collects the inputs from all blocks, <span class="math">\\mathbf{x}_{\\mathcal{C}}</span>, and tests them via the predicate <span class="math">V(\\mathbf{x}_{\\mathcal{C}})</span>. Chains that fail these validation procedure are rejected.</p>

    <p class="text-gray-300">Chain comparison. The objective of the second algorithm, called maxvalid, is to find the “best possible” chain when given a set of chains. The algorithm is straightforward and is parameterized by a <span class="math">\\mathsf{max}(\\cdot)</span> function that applies some ordering to the space of blockchains. The most important aspect is the chains’ difficulty in which case <span class="math">\\mathsf{max}(\\mathcal{C}_{1},\\mathcal{C}_{2})</span> will return the most difficult of the two. In case <span class="math">\\text{diff}(\\mathcal{C}_{1})=\\text{diff}(\\mathcal{C}_{2})</span>, some other characteristic can be used to break the tie. In our case, <span class="math">\\mathsf{max}(\\cdot,\\cdot)</span> will always return the first operand to reflect the fact that parties adopt the first chain they obtain from the network.</p>

    <p class="text-gray-300">Proof of work. The third algorithm, called pow, is the proof of work-finding procedure. It takes as input a chain and attempts to extend it via solving a proof of work. This algorithm is parameterized by two hash functions <span class="math">H(\\cdot),G(\\cdot)</span> as well as the parameter <span class="math">q</span>. Moreover, the algorithm calls the target calculation function <span class="math">D(\\cdot)</span> in order to determine the value <span class="math">T</span> that will be used for the proof of work. The procedure, given a chain <span class="math">\\mathcal{C}</span> and a value <span class="math">x</span> to be inserted in the chain, hashes these values to obtain <span class="math">h</span> and initializes a counter <span class="math">ctr</span>. Subsequently, it increments <span class="math">ctr</span> and checks to see whether <span class="math">H(ctr,h)&lt;T</span>; in case a suitable <span class="math">ctr</span> is found then the algorithm succeeds in solving the POW and extends chain <span class="math">\\mathcal{C}</span> by one block.</p>

    <p class="text-gray-300">The Bitcoin backbone protocol. The core of the backbone protocol with variable difficulty is similar to that in <em>[11]</em>, with several important distinctions. First is the procedure to follow when the parties become active. Parties check the ready flag they possess, which is false if and only if they have been inactive in the previous round. In case the ready flag is false, they diffuse a special message ‘Join’ to request the most recent version of the blockchain(s). Similarly, parties that receive the special request message in their Receive() tape broadcast their chains. As before parties, run “indefinitely” (our security analysis will apply when the total running time is polynomial in <span class="math">\\kappa</span>). The input contribution function <span class="math">I(\\cdot)</span> and the chain reading function <span class="math">R(\\cdot)</span> are applied to the values stored in the chain. Parties check their communication tape Receive() to see whether any necessary update of their local chain is due; then they attempt to extend it via the POW algorithm pow. The function <span class="math">I(\\cdot)</span> determines the input to be added in the chain given the party’s state <span class="math">st</span>, the current chain <span class="math">\\mathcal{C}</span>, the contents of the party’s input tape Input() and communication tape Receive(). The input tape contains two types of symbols, Read and (Insert,<em>value</em>); other inputs are ignored. In case the local chain <span class="math">\\mathcal{C}</span> is extended the new chain is diffused to the other parties. Finally, in case a Read symbol is present in the communication tape, the protocol applies function <span class="math">R(\\cdot)</span> to its current chain and writes the result onto the output tape Output().</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">4.2 Properties of the Backbone Protocol with Variable Difficulty</h3>

    <p class="text-gray-300">Next, we define the two properties of the backbone protocol that the protocol will establish. They are close variants of the properties in <em>[11]</em>, suitably modified for the dynamic <span class="math">q</span>-bounded synchronous setting.</p>

    <p class="text-gray-300">The common prefix property essentially remains the same. It is parameterized by a value <span class="math">k\\in\\mathbb{N}</span>, considers an arbitrary environment and adversary, and it holds as long as any two parties’ chains are different only in their most recent <span class="math">k</span> blocks. It is actually helpful to define the property between an honest party’s chain and another chain that may be adversarial. The definition is as follows.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 3 (Common-Prefix Property).</h6>

    <p class="text-gray-300">The <em>common-prefix</em> property <span class="math">Q_{\\mathsf{cp}}</span> with parameter <span class="math">k\\in\\mathbb{N}</span> states that for any pair of honest players <span class="math">P_{1},P_{2}</span> adopting the chains <span class="math">\\mathcal{C}_{1},\\mathcal{C}_{2}</span> at rounds <span class="math">r_{1}\\leq r_{2}</span> respectively in view<span class="math">{}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{\\mathbf{t},\\mathbf{n}}</span>, it holds that <span class="math">\\mathcal{C}_{1}^{\\lceil k}\\preceq\\mathcal{C}_{2}</span>.</p>

    <p class="text-gray-300">The second property, called chain quality, expresses the number of honest-party contributions that are contained in a sufficiently long and continuous part of a party’s chain. Because we consider chains of variable difficulty it is more convenient to think of parties’ contributions in terms of the total difficulty they add to the chain as opposed to the number of blocks they add (as done in <em>[11]</em>). The property states that adversarial</p>

    <p class="text-gray-300">parties are bounded in the amount of difficulty they can contribute to any sufficiently long segment of the chain.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 4 (Chain-Quality Property).</h6>

    <p class="text-gray-300">The chain quality property <span class="math">Q_{\\mathsf{cq}}</span> with parameters <span class="math">\\mu\\in\\mathbb{R}</span> and <span class="math">\\ell\\in\\mathbb{N}</span> states that for any honest party <span class="math">P</span> with chain <span class="math">\\mathcal{C}</span> in <span class="math">\\operatorname{view}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{\\mathbf{t},\\mathbf{n}}</span>, it holds that for any <span class="math">\\ell</span> consecutive blocks of <span class="math">\\mathcal{C}</span> with total difficulty <span class="math">d</span>, the honest blocks contribute difficulty at least <span class="math">\\mu\\cdot d</span>.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">4.3 Application: Robust Transaction Ledger</h3>

    <p class="text-gray-300">We now come to the (main) application the Bitcoin backbone protocol was designed to solve. A robust transaction ledger is a protocol maintaining a ledger of transactions organized in the form of a chain <span class="math">\\mathcal{C}</span>, satisfying the following two properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Persistence: Parameterized by <span class="math">k\\in\\mathbb{N}</span> (the “depth” parameter), if an honest party <span class="math">P</span>, maintaining a chain <span class="math">\\mathcal{C}</span>, reports that a transaction <span class="math">tx</span> is in <span class="math">\\mathcal{C}^{\\lceil k}</span>, then it holds for every other honest party <span class="math">P^{\\prime}</span> maintaining a chain <span class="math">\\mathcal{C}^{\\prime}</span> then <span class="math">\\mathcal{C}^{\\prime}</span> contains tx in exactly the same position.</li>

      <li>Liveness: Parameterized by <span class="math">u,k\\in\\mathbb{N}</span> (the “wait time” and “depth” parameters, resp.), if a transaction <span class="math">tx</span> is provided to all honest parties for <span class="math">u</span> consecutive rounds, then it holds that for any player <span class="math">P</span>, maintaining a chain <span class="math">\\mathcal{C}</span>, <span class="math">tx</span> will be in <span class="math">\\mathcal{C}^{\\lceil k}</span>.</li>

    </ul>

    <p class="text-gray-300">We note that, as in <em>[11]</em>, Liveness is applicable to either “neutral” transactions (i.e., those that they are never in “conflict” with other transactions in the ledger), or transactions that are produced by an oracle Txgen that produces honestly generated transactions.</p>

    <h2 id="sec-12" class="text-2xl font-bold">5 Overview of the Analysis</h2>

    <p class="text-gray-300">Our main goal is to show that the backbone protocol satisfies the properties common prefix and chain quality (Section 4.2) in a <span class="math">(\\gamma,s)</span>-respecting environment as an intermediate step towards proving, eventually, that the protocol implements a robust transaction ledger. In this section we present a high-level overview of our approach; the full analysis is then presented in Section 6. To prove the aforementioned properties we first characterize the set of typical executions. Informally, an execution is typical if for any set <span class="math">S</span> of consecutive rounds the successes of the adversary and the honest parties do not deviate too much from their expectations and no bad event occurs with respect to the hash function (which we model as a “random oracle”). Using the martingale bound of Theorem 7 we demonstrate that almost all polynomially bounded executions are typical. We then proceed to show that in a typical execution any chain that an honest party adopts (1) contains timestamps that are approximately accurate (i.e., no adversarial block has a timestamp that differs too much by its real creation time) and (2) has a target such that the probability of block production remains near a fixed constant <span class="math">f</span>. Finally, these properties of a typical execution will bring us to our ultimate goal: to demonstrate that a typical execution enjoys the common prefix and the chain quality properties, and therefore one can build on the blockchain a robust transaction ledger (Section 4.3). Here we highlight the main steps and the novel concepts that we introduce.</p>

    <p class="text-gray-300">“Good” executions. In order to be able to talk quantitavely about typical executions, we first introduce the notion of <span class="math">(\\eta,\\theta)</span>-good executions, which expresses how well the parties approximate <span class="math">f</span>. Suppose at round <span class="math">r</span> exactly <span class="math">n</span> parties query the oracle with target <span class="math">T</span>. The probability at least one of them will succeed is</p>

    <p class="text-gray-300"><span class="math">f(T,n)=1-\\Big{(}1-\\frac{T}{2^{n}}\\Big{)}^{qn}.</span></p>

    <p class="text-gray-300">For the initial target <span class="math">T_{0}</span> and the initial estimate of the number of parties <span class="math">n_{0}</span>, we denote <span class="math">f_{0}=f(T_{0},n_{0})</span>. Looking ahead, the objective of the target recalculation mechanism is to maintain a target <span class="math">T</span> for each party such that <span class="math">f(T,n_{r})\\approx f_{0}</span> for all rounds <span class="math">r</span>. (For succintness, we will drop the subscript and simply refer to it as <span class="math">f</span></p>

    <p class="text-gray-300">Now, at a round <span class="math">r</span> of an execution <span class="math">E</span> the honest parties might be querying the random oracle for various targets. We denote by <span class="math">T_{r}^{\\min}(E)</span> and <span class="math">T_{r}^{\\max}(E)</span> the minimum and maximum over those targets. We say <span class="math">r</span> is a target-recalculation point of a valid chain <span class="math">\\mathcal{C}</span>, if there is a block with timestamp <span class="math">r</span> and <span class="math">m</span> exactly divides the number of blocks up to (and including) this block. Consider constants <span class="math">\\eta\\in(0,1]</span> and <span class="math">\\theta\\in[1,\\infty)</span> and an execution <span class="math">E</span>:</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 5 (Abridged).</h6>

    <p class="text-gray-300">A round <span class="math">r</span> is <em><span class="math">(\\eta,\\theta)</span>-good</em> in <span class="math">E</span> if <span class="math">\\eta f\\leq f(T_{r}^{\\min}(E),n_{r})</span> and <span class="math">f(T_{r}^{\\max}(E),n_{r})\\leq\\theta f</span>. An execution <span class="math">E</span> is <em><span class="math">(\\eta,\\theta)</span>-good</em> if every round of <span class="math">E</span> was <span class="math">(\\eta,\\theta)</span>-good.</p>

    <p class="text-gray-300">We are going to study the progress of the honest parties only when their targets lie in a reasonable range. It will turn out that, with high probability, the honest parties always work with reasonable targets. The following bound will be useful because it gives an estimate of the progress the honest parties have made in an <span class="math">(\\eta,\\theta)</span>-good execution. We will be interested in the progress coming from <em>uniquely successful rounds</em>, where exactly one honest party computed a POW. Let <span class="math">Q_{r}</span> be the random variable equal to the (maximum) difficulty of such rounds (recall a block with target <span class="math">T</span> has difficulty <span class="math">1/T</span>); 0 otherwise. We refer to <span class="math">Q_{r}</span> also as “unique” difficulty. We are able to show the following.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Proposition 2 (Informal).</h6>

    <p class="text-gray-300">If <span class="math">r</span> is an <span class="math">(\\eta,\\theta)</span>-good round in an execution <span class="math">E</span>, then <span class="math">\\mathbf{E}[Q_{r}(E_{r-1})]\\geq(1-\\theta f)pn_{r}</span>, where <span class="math">Q_{r}(E_{r-1})</span> is the unique difficulty conditioned on the execution so far, and <span class="math">p=\\frac{q}{2^{n}}</span>.</p>

    <p class="text-gray-300">“Per round” arguments regarding relevant random variables are not sufficient, as we need executions with “good” behavior over a sequence of rounds—i.e., variables should be concentrated around their means. It turns out that this is not easy to get, as the probabilities of the experiments performed per round depend on the history (due to target recalculation). To deal with this lack of concentration/variance problem, we introduce the following measure.</p>

    <p class="text-gray-300">Typical executions. Intuitively, the idea that this notion captures is as follows. Note that at each round of a given execution <span class="math">E</span> the parties perform Bernoulli trials with success probabilities possibly affected by the adversary. Given the execution, these trials are determined and we may calculate the expected progress the parties make given the corresponding probabilities. We then compare this value to the actual progress and if the difference is “reasonable” we declare <span class="math">E</span> <em>typical</em>. Note, however, that considering this difference by itself will not always suffice, because the variance of the process might be too high. Our definition, in view of Theorem 7 (App. C), says that either the variance is high with respect to the set of rounds we are considering, or the parties have made progress during these rounds as expected. A bit more formally, for a given random oracle query in an execution <span class="math">E</span>, the history of the execution just before the query takes place, determines the parameters of the distribution that the outcome of this query follows as a POW (a Bernoulli trial). For the queries performed in a set of rounds <span class="math">S</span>, let <span class="math">V(S)</span> denote the sum of the variances of these trials.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 8 (Abridged).</h6>

    <p class="text-gray-300">An execution <span class="math">E</span> is <em><span class="math">(\\epsilon,\\eta,\\theta)</span>-typical</em> if, for any given set <span class="math">S</span> of consecutive rounds such that <span class="math">V(S)</span> is appropriately bounded from above:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The average unique difficulty is <em>lower</em>-bounded by $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}(\\sum_{r\\in S}\\mathbf{E}[Q_{r}(E_{r-1})]-\\epsilon(1-\\theta f)p\\sum_{r\\in S}n_{r})$;</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- the adversary’s average difficulty of blocks with “easy” targets is <em>upper</em>-bounded by $\\frac{1}{</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">}(1+\\epsilon)p\\sum_{r\\in S}t_{r}<span class="math">, while the <em>number</em> of blocks with “hard” targets is bounded below </span>m$ by a suitable constant; and</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>no “bad events” with respect to the hash function occur (e.g., collisions).</li>

    </ul>

    <p class="text-gray-300">The following is one of the main steps in our analysis.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Proposition 4 (Informal).</h6>

    <p class="text-gray-300">Almost all polynomially bounded executions (in <span class="math">\\kappa</span>) are typical. The probability of an execution not being typical is bounded by <span class="math">\\exp(-\\Omega(\\min\\{m,\\kappa\\})+\\ln L)</span> where <span class="math">L</span> is the total run-time.</p>

    <p class="text-gray-300">Recall (Remark 2) that the dynamic setting (specifically, the use of target recalculation functions) offers more opportunities for adversarial attacks <em>[2]</em>. The following important intermediate lemma shows that if a</p>

    <p class="text-gray-300">typical execution is good up to a certain point, chains that are privately mined for long periods of time by the adversary will not be adopted by honest parties.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Lemma 2 (Informal).</h6>

    <p class="text-gray-300">Let <span class="math">E</span> be a typical execution in a <span class="math">(\\gamma,s)</span>-respecting environment. If <span class="math">E_{r}</span> is <span class="math">(\\eta,\\theta)</span>-good, then, no honest party adopts at round <span class="math">r+1</span> a chain that has not been extended by an honest party for at least <span class="math">O(\\frac{m}{\\tau f})</span> consecutive rounds.</p>

    <p class="text-gray-300">An easy corollary of the above is that in typical executions, the honest parties’ chains cannot contain blocks with timestamps that differ too much from the blocks’ actual creation times.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Corollary 1 (Informal).</h6>

    <p class="text-gray-300">Let <span class="math">E</span> be a typical execution in a <span class="math">(\\gamma,s)</span>-respecting environment. If <span class="math">E_{r-1}</span> is <span class="math">(\\eta,\\theta)</span>-good, then the timestamp of any block in <span class="math">E_{r}</span> is at most <span class="math">O(\\frac{m}{\\tau f})</span> away from its actual creation time (cf. the notion of <em>accuracy</em> in Definition 6).</p>

    <p class="text-gray-300">Additional important results we obtain regarding <span class="math">(\\eta,\\theta)</span>-good executions are that their epochs last about as much as they should (Lemma 3), as well as a “self-correcting” property, which essentially says that if every chain adopted by an honest party is <span class="math">(\\eta\\gamma,\\frac{\\theta}{\\gamma})</span>-good in <span class="math">E_{r-1}</span> (cf. the notion of a <em>good chain</em> in Definition 5), then <span class="math">E_{r}</span> is <span class="math">(\\eta,\\theta)</span>-good (Corollary 2). The above (together with several smaller intermediate steps that we omit from this high-level overview) allow us to conclude:</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Theorem 1 (Informal).</h6>

    <p class="text-gray-300">A typical execution in a <span class="math">(\\gamma,s)</span>-respecting environment is <span class="math">O(\\frac{m}{\\tau f})</span>-accurate and <span class="math">(\\eta,\\theta)</span>-good.</p>

    <p class="text-gray-300">Common prefix and chain quality. Typical executions give us the two desired low-level properties of the blockchain:</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Theorems 2 and 4 (Informal).</h6>

    <p class="text-gray-300">Let <span class="math">E</span> be a typical execution in a <span class="math">(\\gamma,s)</span>-respecting environment. Under the requirements of Table 1 (Section 6.1), common prefix holds for any <span class="math">k\\geq\\theta\\gamma m/8\\tau</span> and chain quality holds for <span class="math">\\ell=m/16\\tau f</span> and <span class="math">\\mu\\leq 1-\\delta/2</span>, where for all <span class="math">r</span>, <span class="math">t_{r}&lt;n_{r}(1-\\delta)</span>.</p>

    <p class="text-gray-300">Robust transaction ledger. Given the above we then prove the properties of the robust transaction ledger:</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Theorems 5 and 6 (Informal)</h6>

    <p class="text-gray-300">Under the requirements of Table 1, the backbone protocol satisfies persistence with parameter <span class="math">k=\\Theta(m)</span> and liveness with wait time <span class="math">u=\\Omega(m+k)</span> for depth <span class="math">k</span>.</p>

    <p class="text-gray-300">We refer to Section 6 for the full analysis of the protocol.</p>

    <h2 id="sec-22" class="text-2xl font-bold">6 Full Analysis</h2>

    <p class="text-gray-300">In this section we present the full analysis and proofs of the backbone protocol and robust transaction ledger application with chains of variable difficulty. The analysis follows at a high level the roadmap presented in Section 5.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">6.1 Additional notation, definitions, and preliminary propositions</h3>

    <p class="text-gray-300">Our probability space is over all executions of length at most some polynomial in <span class="math">\\kappa</span>. Formally, the set of elementary outcomes can be defined as a set of strings that encode every variable of every party during each round of a polynomially bounded execution. We won’t delve into such formalism and leave the details unspecified. We will denote by <span class="math">\\mathbf{Pr}</span> the probability measure of this space. Define also the random variable <span class="math">\\mathcal{E}</span> taking values on this space and with distribution induced by the random coins of all entities (adversary, environment, parties) and the random oracle.</p>

    <p class="text-gray-300">Suppose at round <span class="math">r</span> exactly <span class="math">n</span> parties query the oracle with target <span class="math">T</span>. The probability at least one of them will succeed is</p>

    <p class="text-gray-300"><span class="math">f(T,n)=1-\\left(1-\\frac{T}{2^{\\kappa}}\\right)^{qn}.</span></p>

    <p class="text-gray-300">For the initial target <span class="math">T_{0}</span> and the initial estimate of the number of parties <span class="math">n_{0}</span>, we denote <span class="math">f_{0}=f(T_{0},n_{0})</span>. Looking ahead, the objective of the target recalculation mechanism would be to maintain a target <span class="math">T</span> for each party such that <span class="math">f(T,n_{r})\\approx f_{0}</span> for all rounds <span class="math">r</span>. For this reason, we will drop the subscript from <span class="math">f_{0}</span> and simply refer to it as <span class="math">f</span>; to avoid confusion, whenever we refer to the function <span class="math">f(\\cdot,\\cdot)</span>, we will specify its two operands.</p>

    <p class="text-gray-300">Note that <span class="math">f(T,n)</span> is concave and increasing in <span class="math">n</span> and <span class="math">T</span>. In particular, Fact 2 applies. The following proposition provides useful bounds on <span class="math">f(T,n)</span>. For convenience, define <span class="math">p=q/2^{\\kappa}</span>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proposition 1.</h6>

    <p class="text-gray-300">For positive integers <span class="math">\\kappa,q,T,n</span> and <span class="math">f(T,n)</span> defined as above,</p>

    <p class="text-gray-300"><span class="math">\\frac{pTn}{1+pTn}\\leq f(T,n)\\leq pTn\\leq\\frac{f(T,n)}{1-f(T,n)},\\;\\;\\text{where}\\;\\;p=\\frac{q}{2^{\\kappa}}.</span></p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The bounds can be obtained using the inequalities <span class="math">(1-x)^{\\alpha}\\geq 1-x\\alpha</span>, valid for <span class="math">x\\leq 1</span> and <span class="math">\\alpha\\geq 1</span>, and <span class="math">e^{-x}\\leq\\frac{1}{1+x}</span>, valid for <span class="math">x\\geq 0</span>. ∎</p>

    <p class="text-gray-300">At a round <span class="math">r</span> of an execution <span class="math">E</span> the honest parties might be querying the random oracle for various targets. We denote by <span class="math">T_{r}^{\\min}(E)</span> and <span class="math">T_{r}^{\\max}(E)</span> the minimum and maximum over those targets. We say <span class="math">r</span> is a target-recalculation point of a valid chain <span class="math">\\mathcal{C}</span>, if there is a block with timestamp <span class="math">r</span> and <span class="math">m</span> exactly divides the number of blocks up to (and including) this block.</p>

    <p class="text-gray-300">We now define two desirable properties of executions which will be crucial in the analysis. We will show later that most executions have these properties.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Definition 5.</h6>

    <p class="text-gray-300">Consider an execution <span class="math">E</span> and constants <span class="math">\\eta\\in(0,1]</span> and <span class="math">\\theta\\in[1,\\infty)</span>. A target-recalculation point <span class="math">r</span> in a chain <span class="math">\\mathcal{C}</span> in <span class="math">E</span> is <span class="math">(\\eta,\\theta)</span>-good if the new target <span class="math">T</span> satisfies <span class="math">\\eta f\\leq f(T,n_{r})\\leq\\theta f</span>. A chain <span class="math">\\mathcal{C}</span> in <span class="math">E</span> is <span class="math">(\\eta,\\theta)</span>-good if all its target-recalculation points are <span class="math">(\\eta,\\theta)</span>-good. A round <span class="math">r</span> is <span class="math">(\\eta,\\theta)</span>-good in <span class="math">E</span> if <span class="math">\\eta f\\leq f(T_{r}^{\\min}(E),n_{r})</span> and <span class="math">f(T_{r}^{\\max}(E),n_{r})\\leq\\theta f</span>. We say that <span class="math">E</span> is <span class="math">(\\eta,\\theta)</span>-good if every round of <span class="math">E</span> was <span class="math">(\\eta,\\theta)</span>-good.</p>

    <p class="text-gray-300">For a round <span class="math">r</span>, the following set of chains is of interest. It contains, besides the chains that the honest parties have, those chains that could potentially belong to an honest party.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathcal{S}_{r}=\\left\\{\\mathcal{C}\\in E_{r}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{l}\\text{\`\`}\\mathcal{C}\\text{ belongs to an honest party'' or}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\text{\`<code>for some chain &lt;span class=&quot;math&quot;&gt;\\mathcal{C}^{\\prime}&lt;/span&gt; of an honest party diff}(\\mathcal{C})&gt;\\text{diff}(\\mathcal{C}^{\\prime})\\text{&#x27;&#x27; or}\\\\ \\text{</code>\`for some chain <span class="math">\\mathcal{C}^{\\prime}</span> of an honest party diff}(\\mathcal{C})=\\text{diff}(\\mathcal{C}^{\\prime})\\text{ and}\\\\ \\text{head}(\\mathcal{C})\\text{ was computed no later than head}(\\mathcal{C}^{\\prime})\\text{''}\\end{array}\\right.\\right\\}, \\]</p>

    <p class="text-gray-300">where <span class="math">\\mathcal{C}\\in E_{r}</span> means that <span class="math">\\mathcal{C}</span> exists and is valid at round <span class="math">r</span>.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Definition 6.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider an execution <span class="math">E</span>. For <span class="math">\\epsilon\\in[0,\\infty)</span>, a block created at round <span class="math">r</span> is <span class="math">\\epsilon</span>-accurate if it has a timestamp <span class="math">r^{\\prime}</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r^{\\prime}-r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\epsilon m/f<span class="math">. We say that </span>E_{r}<span class="math"> is </span>\\epsilon<span class="math">-accurate if no chain in </span>\\mathcal{S}_{r}<span class="math"> contains a block that is not </span>\\epsilon<span class="math">-accurate. We say that </span>E<span class="math"> is </span>\\epsilon<span class="math">-accurate if for every round </span>r<span class="math"> in the execution, </span>E_{r}<span class="math"> is </span>\\epsilon$-accurate.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our next step is to define the typical set of executions. To this end we define a few more quantities and random variables.</p>

    <p class="text-gray-300">In an actual execution <span class="math">E</span> the honest parties may be split across different chains with possibly different targets. We are going to study the progress of the honest parties only when their targets lie in a reasonable range. It will turn out that, with high probability, the honest parties always work with reasonable targets. For a round <span class="math">r</span>, a set of consecutive rounds <span class="math">S</span>, and constant <span class="math">\\eta\\in(0,1)</span>, let</p>

    <p class="text-gray-300"><span class="math">T^{(r,\\eta)}=\\frac{\\eta f}{pn_{r}}\\quad\\text{and}\\quad T^{(S,\\eta)}=\\min_{r\\in S}T^{(r,\\eta)}.</span></p>

    <p class="text-gray-300">To expunge the mystery from the definition of <span class="math">T^{(r,\\eta)}</span>, note that in an <span class="math">(\\eta,\\theta)</span>-good round all honest parties query for target at least <span class="math">T^{(r,\\eta)}</span>. We now define for each round <span class="math">r</span> a real random variable <span class="math">D_{r}</span> equal to the</p>

    <p class="text-gray-300">maximum difficulty among all blocks with targets at least <span class="math">T^{(r,\\eta)}</span> computed by honest parties at round <span class="math">r</span>. Define also <span class="math">Q_{r}</span> to equal <span class="math">D_{r}</span> when exactly one block was computed by an honest party and <span class="math">0</span> otherwise.</p>

    <p class="text-gray-300">Regarding the adversary, we are going to be interested in periods of time during which he has gathered a number of blocks in the order of <span class="math">m</span>. Given that the targets of blocks are variable themselves, it is appropriate to consider the difficulty acquired by the adversary not in a set of consecutive rounds, but rather in a set of consecutive adversarial queries that may span a number of rounds and are not necessarily a multiple of <span class="math">q</span>.</p>

    <p class="text-gray-300">For a set of consecutive queries indexed by a set <span class="math">J</span>, we define the following value that will act as a threshold for targets of blocks that are attempted by the adversary.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$T^{(J)}=\\frac{\\eta(1-\\delta)(1-2\\epsilon)(1-\\theta f)}{32\\tau^{3}\\gamma}\\cdot\\frac{m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\cdot 2^{\\kappa}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Given the above threshold, for <span class="math">j\\in J</span>, if the adversary computed at his <span class="math">j</span>-th query a block of difficulty at most <span class="math">1/T^{(J)}</span>, then let the random variable <span class="math">A^{(J)}_{j}</span> be equal to the difficulty of this block; otherwise, let <span class="math">A^{(J)}_{j}=0</span>. The above definition suggests that we collect in <span class="math">A^{(J)}_{j}</span> the difficulty acquired by the adversary as long as it corresponds to blocks that are not too difficult (i.e., those with targets less than <span class="math">T^{(J)}</span>). With foresight we note that this will enable a concentration argument for random variable <span class="math">A^{(J)}_{j}</span>. We will usually drop the superscript <span class="math">(J)</span> from <span class="math">A</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{E}_{r-1}</span> contain the information of the execution just before round <span class="math">r</span>. In particular, a value <span class="math">E_{r-1}</span> of <span class="math">\\mathcal{E}_{r-1}</span> determines the targets against which every party will query the oracle at round <span class="math">r</span>, but it does not determine <span class="math">D_{r}</span> or <span class="math">Q_{r}</span>. If <span class="math">E</span> is a fixed execution (i.e., <span class="math">\\mathcal{E}=E</span>), denote by <span class="math">D_{r}(E)</span> and <span class="math">Q_{r}(E)</span> the value of <span class="math">D_{r}</span> and <span class="math">Q_{r}</span> in <span class="math">E</span>. If a set of consecutive queries <span class="math">J</span> is considered, then, for <span class="math">j\\in J</span>, <span class="math">A^{(J)}_{j}(E)</span> is defined analogously. In this case we will also write <span class="math">\\mathcal{E}^{(J)}_{j}</span> for the execution just before the <span class="math">j</span>-th query of the adversary.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">With respect to the random variables defined above, the following bound will be useful because it gives an estimate of the progress the honest parties have made in an <span class="math">(\\eta,\\theta)</span>-good execution. Note that we are interested in the progress coming from uniquely successful rounds, where exactly one honest party computed a POW. The expected difficulty that will be computed by the <span class="math">n_{r}</span> honest parties at round <span class="math">r</span> is <span class="math">pn_{r}</span>. However, the easier the POW computation is, the smaller $\\mathbf{E}[Q_{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{r-1}=E_{r-1}]<span class="math"> will be with respect to this value. Since the execution is </span>(\\eta,\\theta)<span class="math">-good, a POW is computed by the honest parties with probability at most </span>\\theta f<span class="math">. This justifies the appearance of </span>(1-\\theta f)$ in the bound.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-28" class="text-base font-medium mt-4">Proposition 2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If round <span class="math">r</span> is <span class="math">(\\eta,\\theta)</span>-good in <span class="math">E</span>, then $\\mathbf{E}[Q_{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{r-1}=E_{r-1}]\\geq(1-\\theta f)pn_{r}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let us drop the subscript <span class="math">r</span> for convenience. Suppose the honest parties query for targets <span class="math">T_{1},T_{2},\\ldots,T_{n}</span> respectively. We are going to provide a lower bound pretending that honest parties make all <span class="math">q</span> queries (even after a success) and summing over each query the probability that it is the only successful one. We have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbf{E}[Q_{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{r-1}=E_{r-1}]<span class="math"> </span>\\geq\\sum_{i\\in[n]}q\\cdot\\frac{1}{T_{i}}\\cdot\\frac{T_{i}}{2^{\\kappa}}\\Big{(}1-\\frac{T_{i}}{2^{\\kappa}}\\Big{)}^{q-1}\\prod_{i\\neq j\\in[n]}\\big{[}1-f(T_{j},1)\\big{]}\\geq\\sum_{i\\in[n]}p\\prod_{j\\in[n]}\\big{[}1-f(T_{j},1)\\big{]}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\geq\\sum_{i\\in[n]}p\\prod_{j\\in[n]}\\big{[}1-f(T^{\\max},1)\\big{]}=\\sum_{i\\in[n]}p[1-f(T^{\\max},n)]\\geq\\sum_{i\\in[n]}p(1-\\theta f)=(1-\\theta f)pn,</span></p>

    <p class="text-gray-300">where the third inequality holds because <span class="math">f(T,n)</span> is increasing in <span class="math">T</span>. ∎</p>

    <p class="text-gray-300">The properties we have defined will be shown to hold in a <span class="math">(\\gamma,s)</span>-respecting environment, for suitable <span class="math">\\gamma</span> and <span class="math">s</span>. The following simple fact is a consequence of the definition.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Fact 1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In a <span class="math">(\\gamma,s)</span>-respecting environment, for any set <span class="math">S</span> of consecutive rounds with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq s<span class="math">, any </span>S^{\\prime}\\subseteq S<span class="math">, and any </span>n\\in\\{n_{r}:r\\in S\\}$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{1}{\\gamma}\\cdot n\\leq\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\cdot\\sum_{r\\in S^{\\prime}}n_{r}\\leq\\gamma\\cdot n.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  n_r: number of honest parties mining in round r.  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  tr: number of activated parties that are corrupted.  |</p>

    <p class="text-gray-300">|  δ: advantage of honest parties, ∀r(tr/n_r < 1 - δ)  |</p>

    <p class="text-gray-300">|  (γ,s): determines how the number of parties fluctuates across rounds, cf. Definition 1.  |</p>

    <p class="text-gray-300">|  f: probability at least one honest party succeeds in a round assuming n0 parties and target T0 (the protocol's initialization parameters).  |</p>

    <p class="text-gray-300">|  τ: the dampening filter, see Definition 2.  |</p>

    <p class="text-gray-300">|  (η,θ): lower and upper bound determining the goodness of an execution, cf. Definition 5.  |</p>

    <p class="text-gray-300">|  ε: quality of concentration of random variables in typical executions, cf. Definition 8.  |</p>

    <p class="text-gray-300">|  m: the length of an epoch in number of blocks.  |</p>

    <p class="text-gray-300">|  L: the total run-time of the system.  |</p>

    <p class="text-gray-300">|  [(R0)] ∀r: tr ≤ (1 - δ)n_r  |</p>

    <p class="text-gray-300">|  [(R1)] s ≥ τm/f + m/8τf  |</p>

    <p class="text-gray-300">|  [(R2)] δ/2 ≥ 2ε + θf  |</p>

    <p class="text-gray-300">|  [(R3)] τ - 1/sτ > 1/(1 - ε)(1 - θf)η  |</p>

    <p class="text-gray-300">|  [(R4)] 17(1 + ε)θ ≤ 8τ(γ - θf)  |</p>

    <p class="text-gray-300">|  [(R5)] 9(1 + ε)ηγ2 ≤ 4(1 - ηγf)  |</p>

    <p class="text-gray-300">|  [(R6)] 7θ(1 - ε)(1 - θf) ≥ 8γ2  |</p>

    <p class="text-gray-300">Table 1: System parameters and requirements on them. The parameters are as follows: positive integers  <span class="math">s, m, L</span> ; positive reals  <span class="math">f, \\gamma, \\delta, \\epsilon, \\tau, \\eta, \\theta</span> , where  <span class="math">f, \\epsilon, \\delta \\in (0,1)</span> , and  <span class="math">0 &amp;lt; \\eta \\leq 1 \\leq \\theta</span> .</p>

    <p class="text-gray-300">Proof. The average of several numbers is bounded by their min and max. Furthermore, the definition of  <span class="math">(\\gamma, s)</span> -respecting implies  <span class="math">\\min_{r \\in S} n_r \\geq \\frac{1}{\\gamma} \\max_{r \\in S} n_r \\geq \\frac{1}{\\gamma} n</span>  and  <span class="math">\\max_{r \\in S} n_r \\leq \\gamma \\min_{r \\in S} \\leq \\gamma n</span> . Thus,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {1}{\\gamma} \\cdot n \\leq \\min  _ {r \\in S} n _ {r} \\leq \\min  _ {r \\in S ^ {\\prime}} n _ {r} \\leq \\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S ^ {\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot \\sum_ {r \\in S ^ {\\prime}} n _ {r} \\leq \\max  _ {r \\in S ^ {\\prime}} n _ {r} \\leq \\max  _ {r \\in S} n _ {r} \\leq \\gamma \\cdot n.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Our analysis involves a number of parameters that are suitably related. Table 1 summarizes them, recalls their definitions and lists all the constraints that they should satisfy.</p>

    <p class="text-gray-300">Remark 3. We remark that for the actual parameterization of the parameters  <span class="math">\\tau, m, f</span>  of Bitcoin <span class="math">^5</span> , i.e.,  <span class="math">\\tau = 4, m = 2016, f = 0.03</span> , vis-à-vis the constraints of Table 1, they can be satisfied for  <span class="math">\\delta = 0.99, \\eta = 0.268, \\theta = 1.995, \\epsilon = 2.93 \\cdot 10^{-8}</span> , for  <span class="math">\\gamma = 1.281</span>  and  <span class="math">s = 2.71 \\cdot 10^5</span> . Given that  <span class="math">s</span>  measures the number of rounds within which a fluctuation of  <span class="math">\\gamma</span>  may take place, we have that the constraints are satisfiable for a fluctuation of up to  <span class="math">28\\%</span>  every approximately 2 months (considering a round to last 18 seconds).</p>

    <p class="text-gray-300">We now prove the Chain-growth lemma. This lemma appears already in [11], but it refers to number of blocks instead of difficulty. In [15] the name "chain growth" appears for the first time and the authors explicitly state a chain-growth property.</p>

    <p class="text-gray-300">Informally, this lemma says that honest parties will make as much progress as how many POWs they obtain. Although simple to prove, the chain-growth lemma is very important, because it shows that no matter what the adversary does the honest parties will advance (in terms of accumulated difficulty) by at least the difficulty of the POWs they have acquired.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Let <span class="math">E</span> be any execution. Suppose that at round <span class="math">u</span> an honest party has a chain of difficulty <span class="math">d</span>. Then, by round <span class="math">v\\geq u</span>, every honest party will have received a chain of difficulty at least</p>

    <p class="text-gray-300"><span class="math">d+\\sum_{u\\leq r&lt;v}D_{r}(E).</span></p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By induction on <span class="math">v-u</span>. For the basis, <span class="math">v=u</span> and <span class="math">\\,d+\\sum_{r=u}^{v-1}D_{r}(E)=d</span>. Observe that if at round <span class="math">u</span> an honest party has a chain <span class="math">\\mathcal{C}</span> of difficulty <span class="math">d</span>, then that party broadcast <span class="math">\\mathcal{C}</span> at a round earlier than <span class="math">u</span>. It follows that every honest party will receive <span class="math">\\mathcal{C}</span> by round <span class="math">u</span>.</p>

    <p class="text-gray-300">For the inductive step, note that by the inductive hypothesis every honest party has received a chain of difficulty at least <span class="math">d^{\\prime}=d+\\sum_{r=u}^{v-1}D_{r}</span> by round <span class="math">v</span>. When <span class="math">D_{v}=0</span> the statement follows directly, so assume <span class="math">D_{v}&gt;0</span>. Since every honest party queried the oracle with a chain of difficulty at least <span class="math">d^{\\prime}</span> at round <span class="math">v</span>, if follows that an honest party successful at round <span class="math">v</span> broadcast a chain of difficulty at least <span class="math">d^{\\prime}+D_{v}=d+\\sum_{r=u}^{v}D_{r}</span>. ∎</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">6.3 Typical Executions: Definition and Related Proofs</h3>

    <p class="text-gray-300">We can now define formally our notion of typical executions. Intuitively, the idea that this definition captures is as follows. Suppose that we examine a certain execution <span class="math">E</span>. Note that at each round of <span class="math">E</span> the parties perform Bernoulli trials with success probabilities possibly affected by the adversary. Given the execution, these trials are determined and we may calculate the expected progress the parties make given the corresponding probabilities. We then compare this value to the actual progress and if the difference is reasonable we declare <span class="math">E</span> typical. Note, however, that considering this difference by itself will not always suffice, because the variance of the process might be too high. Our definition, in view of Theorem 7, says that either the variance is high with respect to the set of rounds we are considering, or the parties have made progress during these rounds as expected.</p>

    <p class="text-gray-300">Beyond the behavior of random variables described above, a typical execution will also be characterized by the absence of a number of bad events about the underlying hash function <span class="math">H(\\cdot)</span> which is used in proofs of work and is modeled as a random oracle. The bad events that are of concern to us are defined as follows (recall that a block’s creation time is the round that it has been successfully produced by a query to the random oracle either by the adversary or an honest party).</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Definition 7.</h6>

    <p class="text-gray-300">An <em>insertion</em> occurs when, given a chain <span class="math">\\mathcal{C}</span> with two consecutive blocks <span class="math">B</span> and <span class="math">B^{\\prime}</span>, a block <span class="math">B^{<em>}</span> created after <span class="math">B^{\\prime}</span> is such that <span class="math">B,B^{</em>},B^{\\prime}</span> form three consecutive blocks of a valid chain. A <em>copy</em> occurs if the same block exists in two different positions. A <em>prediction</em> occurs when a block extends one with later creation time.</p>

    <p class="text-gray-300">Given the above we are now ready to specify what is a typical execution.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Definition 8 (Typical execution).</h6>

    <p class="text-gray-300">An execution <span class="math">E</span> is <span class="math">(\\epsilon,\\eta,\\theta)</span>-typical if the following hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If, for any set <span class="math">S</span> of consecutive rounds, <span class="math">pT^{(S,\\eta)}\\sum_{r\\in S}n_{r}\\geq\\frac{\\eta m}{16\\tau\\gamma}</span>, then</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\sum_{r\\in S}Q_{r}(E)</span> $>\\sum_{r\\in S}\\mathbf{E}[Q_{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{r-1}=E_{r-1}]-\\epsilon(1-\\theta f)p\\sum_{r\\in S}n_{r}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\text{and}\\ \\ \\sum_{r\\in S}D_{r}(E)&lt;(1+\\epsilon)p\\sum_{r\\in S}n_{r}.</span></p>

    <p class="text-gray-300">For any set <span class="math">J</span> indexing a set of consecutive queries of the adversary we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sum_{j\\in J}A_{j}(E)<(1+\\epsilon)2^{-\\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and the blocks with targets less than <span class="math">\\tau T^{(J)}</span> that the adversary acquired are less than <span class="math">\\frac{\\eta(1-\\epsilon)(1-\\theta f)}{32\\tau^{2}\\gamma}\\cdot m</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>No insertions, no copies, and no predictions occurred in <span class="math">E</span>.</li>

    </ul>

    <h6 id="sec-37" class="text-base font-medium mt-4">Remark 4.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that if <span class="math">J</span> indexes the queries of the adversary in a set <span class="math">S</span> of consecutive rounds, then $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=q\\sum_{r\\in S}t_{r}<span class="math"> and the inequality in Definition 8(b) reads </span>\\sum_{j\\in J}A_{j}(E)<(1+\\epsilon)p\\sum_{r\\in S}t_{r}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The next proposition simplifies our applications of Definition 8(a).</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Proposition 3.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assume <span class="math">E</span> is a typical execution in a <span class="math">(\\gamma,s)</span>-respecting environment. For any set <span class="math">S</span> of consecutive rounds with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{m}{16\\tau f}$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\sum_{r\\in S}D_{r}&lt;(1+\\epsilon)p\\sum_{r\\in S}n_{r}.</span></p>

    <p class="text-gray-300">If in addition, <span class="math">E</span> is <span class="math">(\\eta,\\theta)</span>-good, then</p>

    <p class="text-gray-300"><span class="math">\\sum_{r\\in S}Q_{r}&gt;(1-\\epsilon)(1-\\theta f)p\\sum_{r\\in S}n_{r}</span></p>

    <p class="text-gray-300">and any block computed by an honest party at any round <span class="math">r</span> corresponds to target at least <span class="math">T^{(r,\\eta)}</span>, and so contributes to the random variables <span class="math">D_{r}</span> and <span class="math">Q_{r}</span> (if the <span class="math">r</span> was uniquely successful).</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We first partition <span class="math">S</span> into several parts with size at least <span class="math">\\frac{m}{16\\tau f}</span> and at most <span class="math">s</span>. In view of Proposition 2, for both of the inequalities, we only need to verify the ‘if’ part of Definition 8(a) for each part <span class="math">S^{\\prime}</span> of <span class="math">S</span>. Indeed, by the definition of <span class="math">T^{(S^{\\prime},\\eta)}</span> and Fact 1, $pT^{(S^{\\prime},\\eta)}\\sum_{r\\in S^{\\prime}}n_{r}\\geq\\eta f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\gamma\\geq\\frac{\\eta m}{16\\tau\\gamma}<span class="math">. The last part, in view of the definition of </span>T^{(r,\\eta)}<span class="math">, is equivalent to </span>r<span class="math"> being </span>(\\eta,\\theta)$-good. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Almost all polynomially bounded executions (in <span class="math">\\kappa</span>) are typical:</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Proposition 4.</h6>

    <p class="text-gray-300">Assuming the ITM system <span class="math">(\\mathcal{Z},C)</span> runs for <span class="math">L</span> steps, the event “<span class="math">\\mathcal{E}</span> is not typical” is bounded by <span class="math">\\exp(-\\Omega(\\min\\{m,\\kappa\\})+\\ln L)</span>. Specifically, the bound is <span class="math">\\exp\\bigl{\\{}-\\frac{\\eta\\epsilon^{2}(1-2\\delta)}{64\\tau^{3}\\gamma}m-\\ln(2)(\\kappa-1)+4\\ln L+2\\ln 2\\bigr{\\}}</span>.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Since the length of the execution, <span class="math">L</span>, is fixed we will prove the stated bound for a fixed set of consecutive rounds <span class="math">S</span> and then apply a union bound over all such sets in the length of the execution. Let <span class="math">k</span> be the size of <span class="math">S</span> and identify it, without loss of generality, with <span class="math">[k]=\\{1,2,\\ldots,k\\}</span>. For part (a), define a sequence of random variables by</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$X_{0}=0;\\;\\;X_{r}=\\sum_{i\\in[r]}Q_{i}-\\sum_{i\\in[r]}\\mathbf{E}[Q_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{i-1}],\\ r\\in[k].$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This forms a martingale with respect to the sequence <span class="math">\\mathcal{E}_{0},\\mathcal{E}_{1},\\ldots,\\mathcal{E}_{k}</span>, because (recalling basic properties of conditional expectation <em>[17]</em>),</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbf{E}[X_{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{r-1}]=\\mathbf{E}\\bigl{[}Q_{r}-\\mathbf{E}[Q_{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{r-1}]\\bigr{]}\\mathcal{E}_{r-1}\\bigr{]}+\\mathbf{E}[X_{r-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{r-1}]=X_{r-1}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Specifically, the above follows from linearity of conditional expectation, and the fact that <span class="math">X_{r-1}</span> is a deterministic function of <span class="math">\\mathcal{E}_{r-1}</span>.</p>

    <p class="text-gray-300">Now suppose the first inequality of Definition 8(a) fails. The probability of this event is equal to</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Pr}[X_{k}\\leq X_{0}-t],\\quad\\text{for }t=\\epsilon(1-\\theta f)p\\sum_{r\\in S}n_{r}.</span></p>

    <p class="text-gray-300"><span class="math">V</span> defined with respect to Theorem 7, we have <span class="math">b\\leq 1/T^{(S,\\eta)}</span> and <span class="math">V\\leq v</span>, where <span class="math">v=p\\sum_{r\\in S}n_{r}/T^{(S,\\eta)}</span>. To prove the bound on <span class="math">V</span>, note that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathrm{var}(X_{r}-X_{r-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{r-1})=\\mathbf{E}\\big{[}\\big{(}Q_{r}-\\mathbf{E}[Q_{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{r-1}]\\big{)}^{2}\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\mathcal{E}_{r-1}\\big{]}=\\mathbf{E}[Q_{r}^{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{r-1}]-\\big{(}\\mathbf{E}[Q_{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{r-1}]\\big{)}^{2}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus, it suffices to show $\\mathbf{E}[Q_{r}^{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{r-1}]\\leq pn_{r}/T^{(r,\\eta)}\\leq pn_{r}/T^{(S,\\eta)}<span class="math">. To this end, suppose that the honest parties at round </span>r<span class="math"> were split into </span>\\ell<span class="math"> chains with corresponding targets </span>T^{(r,\\eta)}\\leq T_{1}\\leq T_{2}\\leq\\cdots\\leq T_{\\ell}<span class="math">. Let also </span>\\hat{n}_{1},\\hat{n}_{2},\\ldots,\\hat{n}_{\\ell}<span class="math">, with </span>\\hat{n}_{1}+\\cdots+\\hat{n}_{\\ell}\\leq n_{r}<span class="math">, be the corresponding number of parties with each chain. Then, for any </span>E_{r-1}$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbf{E}[Q_{r}^{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{r-1}=E_{r-1})]\\leq\\sum_{i\\in[\\ell]}\\frac{1}{T_{i}^{2}}\\cdot f(T_{i},\\hat{n}_{i})\\cdot\\prod_{j\\neq i}\\big{[}1-f(T_{j},\\hat{n}_{j})\\big{]}\\leq\\sum_{i\\in[\\ell]}\\frac{p\\hat{n}_{i}}{T_{i}}\\leq\\frac{pn_{r}}{T^{(r,\\eta)}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We apply Theorem 7 on <span class="math">-X_{0},-X_{1},\\ldots,</span> noting that <span class="math">V\\leq v</span> always holds. Recalling Requirement (R2) and that <span class="math">pT^{(S,\\eta)}\\sum_{r\\in S}n_{r}\\geq\\frac{\\eta m}{16\\tau\\gamma}</span>, we obtain</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Pr}[X_{k}\\leq X_{0}-t]\\leq\\exp\\Bigl{\\{}-\\frac{3\\epsilon^{2}(1-\\theta f)^{2}\\eta m}{32(3+\\epsilon)\\tau\\gamma}\\Bigr{\\}}\\leq\\exp\\Bigl{\\{}-\\frac{\\epsilon^{2}(1-\\delta)\\eta m}{32\\tau\\gamma}\\Bigr{\\}}.</span></p>

    <p class="text-gray-300">For the bounds on <span class="math">\\sum_{r\\in S}D_{r}(E)</span> and <span class="math">\\sum_{j\\in J}A_{j}(E)</span> the proof follows the same lines. In particular, replace <span class="math">Q</span> by <span class="math">D</span> and <span class="math">A</span> (in the case of <span class="math">A</span> the martingale will be indexed by <span class="math">J</span>) and note that in these cases the martingale need not be negated.</p>

    <p class="text-gray-300">In more details, regarding the bound on <span class="math">D</span> in part (a), using the same notation as above, we have that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbf{E}[D_{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{r-1}=E_{r-1})]=\\sum_{i\\in[\\ell]}\\frac{1}{T_{i}}\\cdot f(T_{i},\\hat{n}_{i})\\cdot\\prod_{j=1}^{i-1}\\big{[}1-f(T_{j},\\hat{n}_{j})\\big{]}\\leq\\sum_{i\\in[\\ell]}p\\hat{n}_{i}\\leq pn_{r}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and so</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sum_{r\\in S}\\mathbf{E}[D_{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{r-1}]\\leq p\\sum_{r\\in S}n_{r}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A similar argument provides the bound $\\mathbf{E}[D_{r}^{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{r-1}=E_{r-1})]\\leq pn_{r}/T^{(r,\\eta)}<span class="math"> from which we can obtain the bound </span>V\\leq v=p\\sum_{r\\in S}n_{r}/T^{(S,\\eta)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We next focus on part (b). Note first that if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\frac{\\eta(1-\\delta)(1-2\\epsilon)(1-\\theta f)}{32\\tau^{3}\\gamma}\\cdot m<span class="math">, then </span>T^{(J)}\\geq 2^{\\kappa}<span class="math"> and the inequalities hold trivially. First we will show that for the martingale </span>X_{0},X_{1},X_{2},\\ldots<span class="math"> with respect to </span>\\mathcal{E}_{0}^{(J)},\\mathcal{E}_{1}^{(J)},\\mathcal{E}_{2}^{(J)},\\ldots$ that is defined as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$X_{0}=0;\\;\\;X_{j}=\\sum_{i\\in[j]}A_{i}-\\sum_{i\\in[j]}\\mathbf{E}[A_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{i-1}^{(J)}],\\;j\\in J,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">it holds that <span class="math">b\\leq 1/T^{(J)}</span> and <span class="math">V\\leq v</span> for $v=2^{-\\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/T^{(J)}<span class="math">, for the quantities </span>b<span class="math"> and </span>V<span class="math"> defined as in Theorem 7. Consider an execution prefix </span>E_{j-1}^{(J)}<span class="math"> and the target that is selected by the adversary in its </span>j<span class="math">-th query. Note that we can associate such value to any query of the form </span>(ctr,g)<span class="math"> where </span>g=G(r,st,x)<span class="math"> by recovering the chain that corresponds to </span>st<span class="math">. If such value is below </span>T^{(J)}<span class="math">, or is not defined, </span>A_{j}=0<span class="math">. Thus, we have </span>\\mathbf{E}[A_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{j-1}^{(J)}=E_{j-1}^{(J)}]\\leq 2^{-\\kappa}<span class="math"> and </span>\\mathbf{E}[A_{j}^{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{j-1}^{(J)}=E_{j-1}^{(J)}]\\leq 2^{-\\kappa}/T^{(J)}$, obtaining</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sum_{j\\in J}\\mathbf{E}[A_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{j-1}^{(J)}]\\leq 2^{-\\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\quad\\text{and}\\quad V\\leq v.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now have the following by setting $t = \\epsilon 2^{-\\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Pr}\\Big[\\sum_{j \\in J} A_j &amp;\\geq (1 + \\epsilon) 2^{-\\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Big] = \\mathbf{Pr}\\Big[\\sum_{j \\in J} A_j \\geq t + 2^{-\\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Big] \\leq \\mathbf{Pr}\\Big[\\sum_{j \\in J} A_j \\geq t + \\sum_{j \\in J} \\mathbf{E}[A_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{j-1}^{(J)}] \\Big] \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">&amp;\\leq \\exp\\left\\{ -\\frac{3 \\eta \\epsilon^2 (1 - \\delta) (1 - \\theta f) (1 - 2\\epsilon)m}{64 (3 + \\epsilon) \\tau^3 \\gamma} \\right\\} \\leq \\exp\\left\\{ -\\frac{\\eta \\epsilon^2 (1 - 2\\delta) m}{64 \\tau^3 \\gamma} \\right\\}. \\end{aligned} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To verify the inequalities in the last line, recall $T^{(J)} = \\frac{\\eta(1 - \\delta)(1 - 2\\epsilon)(1 - \\theta f)}{32\\tau^3\\gamma} \\cdot \\frac{m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot 2^\\kappa$ and Requirement (R2).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Regarding the second part of (b), in order to bound the number of blocks of target less than <span class="math">\\tau T^{(J)}</span> the adversary can acquire, define a Boolean random variable <span class="math">Z_j</span>, for each <span class="math">j \\in J</span> as follows. If the corresponding target is less than <span class="math">\\tau T^{(J)}</span> and the query was successful, then <span class="math">Z_j = 1</span>, otherwise <span class="math">Z_j = 0</span>. We can then define a martingale as in part (a), by letting $k =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and replacing </span>Q<span class="math"> with </span>Z<span class="math">. We have </span>b \\leq 1<span class="math"> and </span>V \\leq 2^{-\\kappa} \\tau T^{(J)}$. Since</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{j \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]} \\mathbf{E}[Z_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{j-1}^{(J)}] \\leq 2^{-\\kappa} \\tau T^{(J)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\frac{\\eta (1 - 2\\epsilon) (1 - \\theta f)}{32 \\tau^2 \\gamma} \\cdot m</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and <span class="math">(1 + \\epsilon)(1 - 2\\epsilon) &amp;lt; (1 - \\epsilon)</span>, for <span class="math">t = \\epsilon \\cdot \\frac{\\eta(1 - 2\\epsilon)(1 - \\theta f)}{32\\tau^2\\gamma} \\cdot m</span> we have (using Requirement (R2) to simplify in the last step)</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Pr}\\left[ \\sum_{j \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]} Z_j \\geq \\frac{\\eta (1 - \\epsilon) (1 - \\theta f)}{32 \\tau^2 \\gamma} \\cdot m \\right] \\leq \\mathbf{Pr}[X_k \\geq X_0 + t] \\leq \\exp\\left\\{ -\\frac{\\eta \\epsilon^2 (1 - \\delta/2) m}{32 \\tau^2 \\gamma} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">For part (c) and <span class="math">i \\in \\{0,1,2,3\\}</span>, let <span class="math">B_i = \\langle r_i, st_i, x_i, ctr_i \\rangle</span> and <span class="math">g_i = G(r_i, st_i, x_i)</span>. If a block extends two distinct blocks, then a collision has occurred. To see this, suppose block <span class="math">B_3</span> extends two distinct blocks <span class="math">B_1</span> and <span class="math">B_2</span>. Then <span class="math">st_3 = H(ctr_1, g_1) = H(ctr_2, g_2)</span>; implying a collision either in <span class="math">H</span> or in <span class="math">G</span>, since <span class="math">B_1</span> and <span class="math">B_2</span> are distinct.</p>

    <p class="text-gray-300">The existence of an insertion or a copy implies a collision as well. Suppose the adversary inserts a block <span class="math">B_2</span> among two existing blocks <span class="math">B_1</span> and <span class="math">B_3</span>. Then, <span class="math">B_3</span> extends both <span class="math">B_1</span> and <span class="math">B_2</span> and since <span class="math">B_2</span> extends <span class="math">B_1</span>, <span class="math">r_1 &amp;lt; r_2</span> and the blocks are distinct. Similarly, if <span class="math">B_3</span> is a copy of <span class="math">B_1</span> (i.e., <span class="math">B_3 = B_1</span>), then there exist two distinct blocks <span class="math">B_2</span> and <span class="math">B_0</span> that are both extended by the same block. To see this, note that either <span class="math">B_0</span> and <span class="math">B_2</span> are the ones that <span class="math">B_1</span> and <span class="math">B_3</span> extend, or if these are not distinct, then <span class="math">B_2</span> is a copy of <span class="math">B_0</span> and so on. Eventually, two distinct blocks will be reached, since <span class="math">B_1</span> and <span class="math">B_3</span> are assumed to be on different chains. If the total running time of the system of ITM's is <span class="math">L</span> then it holds that there are at most <span class="math">L</span> queries posed to <span class="math">G, H</span>. It follows that the probability of a collision occurring is <span class="math">\\binom{L}{2} 2^{-\\kappa+1} \\leq 2^{-\\kappa+1+2\\log L}</span>.</p>

    <p class="text-gray-300">Finally, note that, for polynomially many rounds in <span class="math">\\kappa</span>, the probability that a guessed block occurs is exponentially small in <span class="math">\\kappa</span>.</p>

    <h2 id="sec-42" class="text-2xl font-bold">6.4 Typical Executions are Good and Accurate</h2>

    <p class="text-gray-300"><strong>Lemma 2.</strong> Let <span class="math">E</span> be a typical execution in a <span class="math">(\\gamma, s)</span>-respecting environment. If <span class="math">E_r</span> is <span class="math">(\\eta, \\theta)</span>-good, then <span class="math">S_{r+1}</span> contains no chain that has not been extended by an honest party for at least <span class="math">\\frac{m}{16\\tau f}</span> consecutive rounds.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Suppose—towards a contradiction—<span class="math">\\mathcal{C} \\in \\mathcal{S}_{r+1}</span> and has not been extended by an honest party for at least <span class="math">\\frac{m}{16\\tau f}</span> rounds. Without loss of generality we may assume that <span class="math">r + 1</span> is the first such round.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">r^<em> \\leq r</span> denote the greatest timestamp among the blocks of <span class="math">\\mathcal{C}</span> computed by honest parties (let <span class="math">r^</em> = 0</span> if none exists). Define <span class="math">S = \\{r^* + 1, \\ldots, r\\}</span> and note that, by our assumption for <span class="math">\\mathcal{C}</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\frac{m}{16\\tau f}<span class="math">. Let </span>J = \\{1, \\ldots, q \\sum_{r \\in S} t_r\\}<span class="math"> be the index-set of the adversarial queries during the rounds in </span>S<span class="math">. Suppose that the blocks of </span>\\mathcal{C}<span class="math"> with timestamps in </span>S<span class="math"> span </span>k<span class="math"> epochs with corresponding targets </span>T_1, \\ldots, T_k<span class="math">. For </span>i \\in [k]<span class="math"> let </span>m_i<span class="math"> be the number of blocks with target </span>T_i<span class="math"> and set </span>M = m_1 + \\dots + m_k$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our plan is to contradict the assumption that <span class="math">\\mathcal{C} \\in \\mathcal{S}_{r+1}</span>, by showing that the honest parties have accumulated more difficulty than the adversary. To be precise, note that the blocks <span class="math">\\mathcal{C}</span> has gained in <span class="math">S</span> sum to <span class="math">\\sum_{i \\in [k]} \\frac{m_i}{T_i}</span> difficulty. On the other hand, by the Chain-Growth Lemma 1, all the honest parties have advanced during the rounds in <span class="math">S</span> by <span class="math">\\sum_{r \\in S} D_r(E) \\geq \\sum_{r \\in S} Q_r(E)</span>. Since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\frac{m}{16\\tau f}<span class="math">, Proposition 3 implies that </span>\\sum_{r \\in S} Q_r(E)<span class="math"> is greater than </span>(1 - \\epsilon)(1 - \\theta f)p\\sum_{r \\in S} n_r$. Therefore, to obtain a contradiction, it suffices to show that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i \\in [k]} \\frac{m_i}{T_i} \\leq (1 - \\epsilon)(1 - \\theta f) p \\sum_{r \\in S} n_r. \\tag{1}</span></div>

    <p class="text-gray-300">We proceed by considering cases on <span class="math">M</span>.</p>

    <p class="text-gray-300">First, suppose <span class="math">M \\geq 2M&#x27;</span>, where <span class="math">M&#x27; = \\frac{\\eta(1 - \\epsilon)(1 - \\theta f)}{32\\tau^2\\gamma} \\cdot m</span> (see Definition 8(b)). Partition the part of <span class="math">\\mathcal{C}</span> with these <span class="math">M</span> blocks into <span class="math">\\ell</span> parts, so that each part has the following properties: (1) it contains at most one target-calculation point, and (2) it contains at least <span class="math">M&#x27;</span> blocks with the same target. Note that such a partition exists because <span class="math">M \\geq 2M&#x27;</span> and <span class="math">M&#x27; &amp;lt; m</span>. For <span class="math">i \\in [\\ell]</span>, let <span class="math">j_i \\in J</span> be the index of the query during which the last block of the <span class="math">i</span>-th part was computed. Set <span class="math">J_i = \\{j_{i-1} + 1, \\ldots, j_i\\}</span>, with <span class="math">j_0 = 0</span>. Note that Definition 8(c) implies <span class="math">j_{i-1} &amp;lt; j_i</span>, and this is a partition of <span class="math">J</span>. Recalling Definition 8(b), the sum of the difficulties of all the blocks in the <span class="math">i</span>-th part is at most <span class="math">\\sum_{j \\in J_i} A_j(E)</span>. This holds because for one of the targets more than <span class="math">M&#x27;</span> blocks have been computed in <span class="math">J_i</span> and so is at least <span class="math">\\tau T^{(J_i)}</span> and targets with at most one calculation point between them can differ by a factor at most <span class="math">\\tau</span>. Thus,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{i\\in [k]}\\frac{m_{i}}{T_{i}}\\leq \\sum_{\\substack{i\\in [\\ell ]\\\\ j\\in J_{i}}}A_{j}(E) &lt; \\sum_{i\\in [\\ell ]}(1 + \\epsilon)2^{-\\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= (1 + \\epsilon)p\\sum_{r\\in S}t_{r}\\leq (1 + \\epsilon)(1 - \\delta)p\\sum_{r\\in S}n_{r},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where in the last step we used Requirement (R0). Requirement (R1) implies <span class="math">(1 + \\epsilon)(1 - \\delta) \\leq (1 - \\epsilon)(1 - \\theta f)</span>; thus, Equation (1) holds concluding the case <span class="math">M \\geq 2M&#x27;</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Otherwise, <span class="math">k \\leq 2</span> and <span class="math">m_{1} + m_{2} &amp;lt; 2M&#x27;</span>. Let <span class="math">S&#x27;</span> consist of the first <span class="math">\\frac{m}{16\\tau f}</span> rounds of <span class="math">S</span>. We are going to argue that in this case Equation (1) holds even for <span class="math">S&#x27;</span> in the place of <span class="math">S</span>. Since we are in a <span class="math">(\\gamma, s)</span>-respecting environment, by Fact 1, $\\gamma \\sum_{r \\in S'} n_r \\geq n_{r^*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Furthermore, since </span>r^<em><span class="math"> is </span>(\\eta, \\theta)<span class="math">-good, </span>T_1 \\geq T^{(r^</em>, \\eta)} = \\eta f / p n_{r^*}<span class="math">. Recalling also that </span>T_2 \\geq T_1 / \\tau<span class="math">, we have </span>\\frac{m_1}{T_1} + \\frac{m_2}{T_2} \\leq \\frac{m_1 + \\tau m_2}{T_1}$, which in turn is at most</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{\\tau M}{T^{(r^<em>, \\eta)}} &lt; \\frac{2 \\tau M' p n_{r^</em>}}{\\eta f} \\leq \\frac{2 \\tau \\gamma M' p \\sum_{r \\in S'} n_r}{\\eta f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\leq \\frac{32 \\tau^2 \\gamma M' p \\sum_{r \\in S} n_r}{\\eta m}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and, after substituting <span class="math">M&#x27;</span>, Equation (1) holds concluding this case and the proof.</p>

    <p class="text-gray-300">Corollary 1. Let <span class="math">E</span> be a typical execution in a <span class="math">(\\gamma, s)</span>-respecting environment. If <span class="math">E_{r-1}</span> is <span class="math">(\\eta, \\theta)</span>-good, then <span class="math">E_r</span> is <span class="math">\\frac{m}{16\\tau f}</span>-accurate.</p>

    <p class="text-gray-300">Proof. Suppose—towards a contradiction—that, for some <span class="math">r^<em> \\leq r</span>, <span class="math">\\mathcal{C} \\in \\mathcal{S}_{r^</em>}</span> contains a block which is not <span class="math">\\frac{m}{16\\tau f}</span>-accurate and let <span class="math">u \\leq r^<em> \\leq r</span> be the timestamp of this block and <span class="math">v</span> its creation time. If <span class="math">u - v &amp;gt; \\frac{m}{16\\tau f}</span>, then every honest party would consider <span class="math">\\mathcal{C}</span> to be invalid during rounds <span class="math">v, v + 1, \\ldots, u</span>. If <span class="math">v - u &amp;gt; \\frac{m}{16\\tau f}</span>, then in order for <span class="math">\\mathcal{C}</span> to be valid it should not contain any honest block with timestamp in <span class="math">u, u + 1, \\ldots, v</span>. (Note that we are using Definition 8(c) here as a block could be inserted later.) In either case, <span class="math">\\mathcal{C} \\in \\mathcal{S}_{r^</em>}</span>, but has not been extended by an honest party for at least <span class="math">\\frac{m}{16\\tau f}</span> rounds. Since <span class="math">E_{r^* - 1}</span> is <span class="math">(\\eta, \\theta)</span>-good, the statement follows from Lemma 2.</p>

    <p class="text-gray-300">Lemma 3. Let <span class="math">E</span> be a typical execution in a <span class="math">(\\gamma, s)</span>-respecting environment and <span class="math">r^<em></span> an <span class="math">(\\eta \\gamma, \\frac{\\theta}{\\gamma})</span>-good target-recalculation point of a valid chain <span class="math">\\mathcal{C}</span>. For <span class="math">r &amp;gt; r^</em> + \\frac{\\tau m}{f}</span>, assume <span class="math">E_{r-1}</span> is <span class="math">(\\eta, \\theta)</span>-good. Then, either the duration <span class="math">\\Delta</span> of the epoch of <span class="math">\\mathcal{C}</span> starting at <span class="math">r^*</span> satisfies</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{m}{\\tau f} \\leq \\Delta \\leq \\frac{\\tau m}{f},</span></div>

    <p class="text-gray-300">or <span class="math">\\mathcal{C} \\notin \\mathcal{S}_u</span> for each <span class="math">u \\in \\{r^* + \\frac{\\tau m}{f}, \\ldots, r\\}</span>.</p>

    <p class="text-gray-300">19</p>

    <p class="text-gray-300">Let <span class="math">T</span> be the target of the epoch in question.</p>

    <p class="text-gray-300">For the upper bound, assume <span class="math">\\Delta&gt;\\frac{\\tau m}{f}</span>. We show first that in the rounds <span class="math">S=\\{r^{<em>}+\\frac{m}{16\\tau f},\\ldots,r^{</em>}+\\frac{\\tau m}{f}-\\frac{m}{16\\tau f}\\}</span> the honest parties have acquired more than <span class="math">\\frac{m}{T}</span> difficulty. Note that the rounds of <span class="math">S</span> are <span class="math">(\\eta,\\theta)</span>-good as they come before <span class="math">r</span>. Thus, by Proposition 3, the difficulty acquired in <span class="math">S</span> by the honest parties is at least</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(1-\\epsilon)(1-\\theta f)p\\sum_{r\\in S}n_{r}\\geq(1-\\epsilon)(1-\\theta f)p\\cdot\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n_{r^{*}}}{\\gamma}\\geq(1-\\epsilon)(1-\\theta f)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{\\eta f}{T}>\\frac{m}{T}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the first inequality, we used Fact 1. For the second, recall that <span class="math">r^{<em>}</span> is <span class="math">(\\eta\\gamma,\\nicefrac{{\\theta}}{{\\gamma}})</span>-good and so <span class="math">pTn_{r^{</em>}}\\geq f(T,n_{r^{*}})\\geq\\eta\\gamma f</span>. For the last inequality observe that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\frac{m}{f}(\\tau-\\nicefrac{{1}}{{\\pi\\tau}})$ and thus follows from Requirement (R3).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, we observe that chain <span class="math">\\mathcal{C}</span> either has a block within the epoch in question that is computed by an honest party in a round within the period <span class="math">[r^{<em>},r^{</em>}+\\frac{m}{16\\tau f})</span>, or by Lemma 2, <span class="math">\\mathcal{C}\\notin\\mathcal{S}_{u}</span> for each <span class="math">u\\in\\{r^{<em>}+\\frac{m}{16\\tau f},\\ldots,r\\}\\supseteq\\{r^{</em>}+\\frac{\\tau m}{f},\\ldots,r\\}</span>. Assuming the first happens, it follows that by round <span class="math">r^{<em>}+\\frac{\\tau m}{f}-\\frac{m}{16\\tau f}</span> the honest parties’ chains have advanced by an amount of difficulty which exceeds the total difficulty of the epoch in question. This means that no honest party will extend <span class="math">\\mathcal{C}</span> during the rounds <span class="math">\\{r^{</em>}+\\frac{\\tau m}{f}-\\frac{m}{16\\tau f}+1,\\ldots,\\Delta\\}</span>. Since it is assumed <span class="math">\\Delta&gt;r^{<em>}+\\frac{\\tau m}{f}</span>, Lemma 2 can then be applied to imply that <span class="math">\\mathcal{C}\\notin\\mathcal{S}_{u}</span> for <span class="math">u\\in\\{r^{</em>}+\\frac{\\tau m}{f},\\ldots,r\\}</span>.</p>

    <p class="text-gray-300">For the lower bound, we assume <span class="math">\\Delta&lt;\\frac{m}{\\tau f}</span> and that <span class="math">\\mathcal{C}\\in\\mathcal{S}_{u}</span> for some <span class="math">u\\in\\{r^{<em>}+\\Delta+1,\\ldots,r\\}</span>, and seek a contradiction. Clearly, the honest parties contributed only during the set of rounds <span class="math">S=\\{r^{</em>},\\ldots,r^{<em>}+\\Delta\\}</span>. The adversary, by Lemma 2, may have contributed only during <span class="math">S^{\\prime}=\\{r^{</em>}-\\frac{m}{16\\tau f},\\ldots,r^{*}+\\Delta+\\frac{m}{16\\tau f}\\}</span>. Let <span class="math">J</span> be the set of queries available to the adversary during the rounds in <span class="math">S^{\\prime}</span>. We show that in a typical execution the honest parties together with the adversary cannot acquire difficulty <span class="math">\\frac{m}{T}</span> in the rounds in the sets <span class="math">S</span> and <span class="math">S^{\\prime}</span> respectively. With respect to the honest parties, Proposition 3 applies. Regarding the adversary, assume first <span class="math">T\\geq T^{(J)}</span> (it is not hard to verify that the case <span class="math">T&lt;T^{(J)}</span> leads to a more favorable bound). It follows that the total difficulty contributed to the epoch is at most</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(1+\\epsilon)p\\bigg{(}\\sum_{r\\in S}n_{r}+\\sum_{r\\in S^{\\prime}}t_{r}\\bigg{)}\\leq(1+\\epsilon)p\\gamma n_{r^{*}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<(1+\\epsilon)p\\gamma n_{r^{*}}\\cdot\\frac{17m}{8\\tau f}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The first inequality follows from Fact 1 using <span class="math">t_{r}&lt;(1-\\delta)n_{r}</span>. For the second substitute the upper bounds on the sizes of <span class="math">S</span> and <span class="math">S^{\\prime}</span>. Next, note that <span class="math">r^{<em>}</span> is an <span class="math">(\\eta\\gamma,\\nicefrac{{\\theta}}{{\\gamma}})</span>-good recalculation point and so <span class="math">f(T,n_{r^{</em>}})\\leq\\nicefrac{{\\theta f}}{{\\gamma}}</span>. By Proposition 1, <span class="math">pTn_{r^{<em>}}&lt;f(T,n_{r^{</em>}})/(1-f(T,n_{r^{*}}))\\leq(\\nicefrac{{\\theta f}}{{\\gamma}})/(1-\\nicefrac{{\\theta f}}{{\\gamma}})</span>. It follows that the last displayed quantity is at most <span class="math">\\frac{17(1+\\epsilon)\\theta}{8\\tau(\\gamma-\\theta f)}\\cdot\\frac{m}{T}</span> and recalling Requirement (R4) this less than <span class="math">\\frac{m}{T}</span> as desired. ∎</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Proposition 5.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assume <span class="math">E</span> is a typical execution in a <span class="math">(\\gamma,s)</span>-respecting environment. Let <span class="math">r</span> be a round such that <span class="math">E_{r-1}</span> is <span class="math">(\\eta,\\theta)</span>-good, <span class="math">S</span> a set of consecutive rounds in <span class="math">E_{r}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{m}{32\\tau^{2}f}<span class="math">, and </span>J<span class="math"> the set of adversarial queries during the rounds in </span>S<span class="math">. Then, the adversary during the rounds in </span>S<span class="math"> has contributed at most </span>\\sum_{j\\in J}A_{j}<span class="math"> difficulty to </span>\\bigcup_{v\\leq r}\\mathcal{S}_{r}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Without loss of generality, we will assume in this proof that <span class="math">t_{r}=(1-\\delta)n_{r}</span> for each <span class="math">r\\in S</span>. Furthermore, we assume $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\frac{\\tau m}{f}<span class="math">. If this is not the case, then we can partition </span>S$ to parts of appropriate sizes and apply the arguments that follow to each sum. The statement will follow upon summing over all parts.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By Lemma 2, for any block <span class="math">B</span> in <span class="math">\\mathcal{S}_{v}</span> for some <span class="math">v\\leq r</span>, there is a block <span class="math">B^{\\prime}</span> in the same chain and computed at most <span class="math">\\frac{m}{16\\tau f}</span> rounds earlier than it by an honest party. Let <span class="math">u</span> be the round the honest party computed <span class="math">B</span> and <span class="math">T</span> its target. Note that since <span class="math">E</span> is <span class="math">(\\eta,\\theta)</span>-good, <span class="math">T\\geq T^{(u,\\eta)}=\\frac{\\eta f}{pn_{u}}</span>. By Lemma 3, there is at most one recalculation point between <span class="math">B</span> and <span class="math">B^{\\prime}</span>, and so the target of <span class="math">B</span> is at least <span class="math">T/\\tau</span>. We need to show that <span class="math">T/\\tau\\geq T^{(J)}</span>. This implies all difficulty contributed by the adversary is accounted for in <span class="math">\\sum_{j\\in J}A_{j}</span> and by Definition 8 we are done.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using Fact 1 and the lower-bound on $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$2^{-\\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=(1-\\delta)p\\sum_{r\\in S}n_{r}\\geq(1-\\delta)p\\cdot\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n_{u}}{\\gamma}\\geq(1-\\delta)p\\cdot\\frac{mn_{u}}{32\\tau^{3}f\\gamma}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Recalling the definition of <span class="math">T^{(J)}</span> and using this bound,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$T^{(J)}=\\frac{\\eta(1-\\delta)(1-2\\epsilon)(1-\\theta f)}{32\\tau^{3}\\gamma}\\cdot\\frac{m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\cdot 2^{\\kappa}\\leq\\frac{\\eta f(1-2\\epsilon)(1-\\theta f)}{\\tau pn_{u}}<\\frac{T^{(u,\\eta)}}{\\tau}\\leq\\frac{T}{\\tau},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">as desired. ∎</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">Let <span class="math">E</span> be a typical execution in a <span class="math">(\\gamma,s)</span>-respecting environment and assume <span class="math">E_{r-1}</span> is <span class="math">(\\eta,\\theta)</span>-good. If <span class="math">\\mathcal{C}\\in\\mathcal{S}_{r}</span>, then <span class="math">\\mathcal{C}</span> is <span class="math">(\\eta\\gamma,\\nicefrac{{\\theta}}{{\\gamma}})</span>-good in <span class="math">E_{r}</span>.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Note that it is our assumption that every chain is <span class="math">(\\eta\\gamma,\\nicefrac{{\\theta}}{{\\gamma}})</span>-good at the first round. Therefore, to prove the statement, it suffices to show that if a chain is <span class="math">(\\eta\\gamma,\\nicefrac{{\\theta}}{{\\gamma}})</span>-good at a recalculation point <span class="math">r^{<em>}</span>, then it will also be <span class="math">(\\eta\\gamma,\\nicefrac{{\\theta}}{{\\gamma}})</span>-good at then next recalculation point <span class="math">r^{</em>}+\\Delta</span>.</p>

    <p class="text-gray-300">Let <span class="math">r^{<em>}</span> and <span class="math">r^{</em>}+\\Delta\\leq r</span> be two consecutive target-calculation points of a chain <span class="math">\\mathcal{C}</span> and <span class="math">T</span> the target of the corresponding epoch. By Lemma 3 and Definition 2 of the target-recalculation function, the new target will be</p>

    <p class="text-gray-300"><span class="math">T^{\\prime}=\\frac{\\Delta}{m/f}\\cdot T,</span></p>

    <p class="text-gray-300">where <span class="math">\\Delta</span> is the duration of the epoch.</p>

    <p class="text-gray-300">We wish to show that</p>

    <p class="text-gray-300"><span class="math">\\eta\\gamma f\\leq f(T^{\\prime},n_{r^{*}+\\Delta})\\leq\\theta f/\\gamma.</span></p>

    <p class="text-gray-300">To this end, let <span class="math">S=\\{r^{<em>},\\ldots,r^{</em>}+\\Delta\\}</span>, <span class="math">S^{\\prime}=\\big{\\{}\\max\\{0,r^{<em>}-\\frac{m}{16\\tau f}\\},\\ldots,\\min\\{r^{</em>}+\\Delta+\\frac{m}{16\\tau f},r\\}\\big{\\}}</span>, and let <span class="math">J</span> index the queries available to the adversary in <span class="math">S^{\\prime}</span>. Note that, by Corollary 1, every block in the epoch was computed either by an honest party during a round in <span class="math">S</span> or by the adversary during a round in <span class="math">S^{\\prime}</span>.</p>

    <p class="text-gray-300">Suppose—towards a contradiction—that <span class="math">f(T^{\\prime},n_{r^{<em>}+\\Delta})&lt;\\eta\\gamma f</span>. Using the definition of <span class="math">f(T,n)</span>, this implies <span class="math">qn_{r^{</em>}+\\Delta}\\ln\\bigl{(}1-\\frac{T^{\\prime}}{2^{\\kappa}}\\bigr{)}&gt;\\ln(1-\\eta\\gamma f).</span> Applying the inequality <span class="math">-\\frac{x}{1-x}&lt;\\ln(1-x)&lt;-x</span>, valid for <span class="math">x\\in(0,1)</span>, substituting the expression for <span class="math">T^{\\prime}</span> above and rearranging, we obtain</p>

    <p class="text-gray-300"><span class="math">\\frac{m}{T}&gt;\\frac{1-\\eta\\gamma f}{\\eta\\gamma}\\cdot p\\Delta n_{r^{*}+\\Delta}.</span></p>

    <p class="text-gray-300">By Propositions 3 and 5 it follows that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{m}{T}\\leq 2(1+\\epsilon)p\\sum_{r\\in S^{\\prime}}n_{r}\\leq 2(1+\\epsilon)p\\cdot\\frac{\\Delta+\\frac{m}{8\\tau f}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\cdot\\sum_{r\\in S^{\\prime}}n_{r}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By Lemma 3, <span class="math">\\Delta\\geq\\frac{m}{rf}</span>. Thus, <span class="math">\\frac{\\Delta+\\frac{m}{8\\tau f}}{\\Delta}\\leq\\frac{9}{8}</span>. Using this, Requirement (R5), and combining the inequalities on <span class="math">\\frac{m}{T}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\gamma n_{r^{*}+\\Delta}<\\frac{9(1+\\epsilon)\\eta\\gamma^{2}}{4(1-\\eta\\gamma f)}\\cdot\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\sum_{r\\in S^{\\prime}}n_{r}\\leq\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\sum_{r\\in S^{\\prime}}n_{r},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">contradicting Fact 1.</p>

    <p class="text-gray-300">For the upper bound, assume <span class="math">f(T^{\\prime},n_{r^{*}+\\Delta})&gt;\\nicefrac{{\\theta f}}{{\\gamma}}</span>, which (see Proposition 1) implies</p>

    <p class="text-gray-300"><span class="math">\\frac{m}{T}&lt;\\frac{\\gamma}{\\theta}\\cdot p\\Delta n_{r^{*}+\\Delta}.</span></p>

    <p class="text-gray-300">Set <span class="math">S=\\{r^{<em>}+\\frac{m}{16\\tau f},\\ldots,r^{</em>}+\\Delta-\\frac{m}{16\\tau f}\\}</span>. Since an honest party posses <span class="math">\\mathcal{C}</span> at round <span class="math">r</span>, it follows by Lemma 2 that there is a block computed by an honest party in <span class="math">\\mathcal{C}</span> during <span class="math">\\{r^{<em>},\\ldots,r^{</em>}+\\frac{m}{16\\tau f}-1\\}</span> and one during <span class="math">\\{r^{<em>}+\\Delta-\\frac{m}{16\\tau f}+1,\\ldots,r^{</em>}+\\Delta\\}</span>. By the Chain-Growth Lemma 1, it follows that the honest parties computed less than <span class="math">\\frac{m}{T}</span> difficulty during <span class="math">S</span>. In particular,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{m}{T}>(1-\\epsilon)(1-\\theta f)p\\sum_{r\\in S}n_{r}\\geq(1-\\epsilon)(1-\\theta f)p\\cdot\\frac{\\Delta-\\frac{m}{8\\tau f}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\cdot\\sum_{r\\in S}n_{r}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By Lemma 3, <span class="math">\\Delta \\geq \\frac{m}{\\tau f}</span>. Thus, <span class="math">\\frac{\\Delta - \\frac{m}{8\\tau f}}{\\Delta} \\geq \\frac{7}{8}</span>. Using this, Requirement (R6), and combining the inequalities on <span class="math">\\frac{m}{T}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {n _ {r ^ {*} + \\Delta}}{\\gamma} &gt; \\frac {7 \\theta}{8 \\gamma^ {2}} (1 - \\epsilon) (1 - \\theta f) \\cdot \\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_ {r \\in S} n _ {r} \\geq \\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_ {r \\in S} n _ {r},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">contradicting Fact 1.</p>

    <p class="text-gray-300">Corollary 2. Let <span class="math">E</span> be a typical execution in a <span class="math">(\\gamma, s)</span>-respecting environment and <span class="math">E_{r-1}</span> be <span class="math">(\\eta, \\theta)</span>-good. If every chain in <span class="math">S_{r-1}</span> is <span class="math">(\\eta \\gamma, \\frac{\\theta}{\\gamma})</span>-good, then <span class="math">E_r</span> is <span class="math">(\\eta, \\theta)</span>-good.</p>

    <p class="text-gray-300">Proof. We use notations and definitions of Lemma 3. Let <span class="math">\\mathcal{C} \\in S_r</span> and let <span class="math">r^<em></span> be its last recalculation point in <span class="math">E_{r-1}</span>. Let <span class="math">T</span> be the target after <span class="math">r^</em></span> and <span class="math">T&#x27;</span> the one at <span class="math">r</span>. We need to show that <span class="math">f(T&#x27;, n_r) \\in [\\eta f, \\theta f]</span>. Note that if <span class="math">r</span> is a recalculation point, this follows by Lemma 4. Otherwise, <span class="math">T&#x27; = T</span> and <span class="math">\\eta \\gamma \\leq f(T, n_{r^<em>}) \\leq \\theta f / \\gamma</span>. Using Lemma 3, <span class="math">r - r^</em> \\leq \\Delta \\leq \\frac{\\tau m}{f}</span>. Thus, <span class="math">\\frac{1}{\\gamma} n_{r^<em>} \\leq n_r \\leq \\gamma n_{r^</em>}</span>. By Fact 2 we have <span class="math">f(T, n_r) \\leq f(T, \\gamma n_{r^<em>}) \\leq \\gamma f(T, n_{r^</em>}) \\leq \\theta f</span> and <span class="math">f(T, n_r) \\geq f(T, \\frac{1}{\\gamma} n_{r^<em>}) \\geq \\frac{1}{\\gamma} f(T, n_{r^</em>}) \\geq \\eta f</span>.</p>

    <p class="text-gray-300">Corollary 3. Let <span class="math">E</span> be a typical execution in a <span class="math">(\\gamma, s)</span>-respecting environment. Then every round is <span class="math">(\\eta, \\theta)</span>-good in <span class="math">E</span>.</p>

    <p class="text-gray-300">Proof. For the sake of contradiction, let <span class="math">r</span> be the smallest round of <span class="math">E</span> that is not <span class="math">(\\eta, \\theta)</span>-good. This means that there is a chain <span class="math">\\mathcal{C}</span> and an honest party that possesses this chain in round <span class="math">r</span> and the corresponding target <span class="math">T</span> is such that <span class="math">f(T, n_r) \\notin [\\eta f, \\theta f]</span>. Note that <span class="math">E_{r-1}</span> is <span class="math">(\\eta, \\theta)</span>-good, and so, by Corollary 1, <span class="math">E_r</span> is <span class="math">\\frac{m}{16\\tau f}</span>-accurate. Let <span class="math">r^<em> &amp;lt; r</span> be the last <span class="math">(\\eta \\gamma, \\theta / \\gamma)</span>-good recalculation point of <span class="math">\\mathcal{C}</span> (let <span class="math">r^</em></span> be 0 in case there is no such point).</p>

    <p class="text-gray-300">First suppose that there is another recalculation point <span class="math">r&#x27; \\in (r^<em>, r]</span>. By the definition of <span class="math">r^</em></span>, <span class="math">r&#x27;</span> is not <span class="math">(\\eta \\gamma, \\theta / \\gamma)</span>-good. However, the assumptions of Lemma 4 hold, implying that <span class="math">\\mathcal{C}</span> is <span class="math">(\\eta \\gamma, \\theta / \\gamma)</span>-good. We have reached a contradiction.</p>

    <p class="text-gray-300">We may now assume that there is no recalculation point in <span class="math">(r^{<em>}, r]</span> and so the points <span class="math">r^{</em>}</span> and <span class="math">r</span> correspond to the same target <span class="math">T</span> with <span class="math">\\eta \\gamma \\leq f(T, n_{r^{<em>}}) \\leq \\theta f / \\gamma</span>. Note that since <span class="math">r^{</em>}</span> is an <span class="math">(\\eta \\gamma, \\theta / \\gamma)</span>-good recalculation point and <span class="math">E_{r-1}</span> is <span class="math">(\\eta, \\theta)</span>-good, we have <span class="math">r - r^{<em>} \\leq \\frac{\\tau m}{f}</span>. This follows from Lemma 3, because <span class="math">\\mathcal{C}</span> belongs to an honest party at round <span class="math">r</span>. Thus, <span class="math">\\frac{1}{\\gamma} n_{r^{</em>}} \\leq n_{r} \\leq \\gamma n_{r^{<em>}}</span>, and so (by Fact 2) <span class="math">f(T, n_{r}) \\leq f(T, \\gamma n_{r^{</em>}}) \\leq \\gamma f(T, n_{r^{<em>}}) \\leq \\theta f</span> and <span class="math">f(T, n_{r}) \\geq f(T, \\frac{1}{\\gamma} n_{r^{</em>}}) \\geq \\frac{1}{\\gamma} f(T, n_{r^{*}}) \\geq \\eta f</span>.</p>

    <p class="text-gray-300">Theorem 1. A typical execution in a <span class="math">(\\gamma, s)</span>-respecting environment is <span class="math">\\frac{m}{16\\tau f}</span>-accurate and <span class="math">(\\eta, \\theta)</span>-good.</p>

    <p class="text-gray-300">Proof. This follows from Corollaries 3 and 1.</p>

    <p class="text-gray-300">6.5 Common Prefix and Chain Quality</p>

    <p class="text-gray-300">Proposition 6. Let <span class="math">E</span> be a typical execution in a <span class="math">(\\gamma, s)</span>-respecting environment. Any <span class="math">\\frac{\\theta \\gamma m}{8\\tau}</span> consecutive blocks in an epoch of a chain <span class="math">\\mathcal{C} \\in S_r</span> have been computed in at least <span class="math">\\frac{m}{16\\tau f}</span> rounds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Suppose—towards a contradiction—that the blocks of <span class="math">\\mathcal{C}</span> where computed during the rounds in <span class="math">S^<em></span>, for some <span class="math">S^</em></span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; \\frac{m}{16\\tau f}<span class="math">. Consider an </span>S<span class="math"> such that </span>S^* \\subseteq S<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\frac{m}{16\\tau f}<span class="math"> and the property that a block of target </span>T<span class="math"> in </span>\\mathcal{C}<span class="math"> was computed by an honest party in some round </span>v \\in S<span class="math">. Such an </span>S<span class="math"> exists by Lemmas 2 and 3. By Propositions 3 and 5, the number of blocks of target </span>T<span class="math"> computed in </span>S$ is at most</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(1 + \\epsilon) (2 - \\delta) p T \\sum_ {u \\in S} n _ {u} \\leq (1 + \\epsilon) (2 - \\delta) p T \\gamma n _ {v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac {(1 + \\epsilon) (2 - \\delta) \\gamma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\theta f}{1 - \\theta f} \\leq \\frac {\\theta \\gamma m}{8 \\tau}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">For the first inequality we used Fact 1, for the second Fact 1 and that round <span class="math">v</span> is <span class="math">(\\eta, \\theta)</span>-good, and for the last one Requirement (R2).</p>

    <p class="text-gray-300">Theorem 2 (Common Prefix). In any typical execution of a <span class="math">(\\gamma, s)</span>-respecting environment, the common-prefix property holds for <span class="math">k \\geq \\frac{\\theta \\gamma m}{4\\tau}</span>.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider—towards a contradiction—honest parties <span class="math">P_{1}</span> and <span class="math">P_{2}</span> with adopted chains <span class="math">\\mathcal{C}_{1}</span> and <span class="math">\\mathcal{C}_{2}</span> at rounds <span class="math">r_{1}\\leq r_{2}</span> respectively, such that <span class="math">\\mathcal{C}_{1}^{\\lceil k\\rfloor}\\not\\preceq\\mathcal{C}_{2}</span>. Define <span class="math">r\\geq r_{1}</span> as the least round in which an honest party <span class="math">P</span> adopts a chain <span class="math">\\mathcal{C}</span> such that <span class="math">\\mathcal{C}_{1}^{\\lceil k\\rfloor}\\not\\preceq\\mathcal{C}</span>. Consider the last block on the common prefix of <span class="math">\\mathcal{C}_{1}</span> and <span class="math">\\mathcal{C}</span> that was computed by an honest party and let <span class="math">r^{<em>}</span> be the round on which it was computed (set <span class="math">r^{</em>}=0</span> if no such block exists). Denote by <span class="math">\\mathcal{C}^{<em>}</span> the common part of <span class="math">\\mathcal{C}_{1}</span> and <span class="math">\\mathcal{C}</span> up to (and including) this block. Let also <span class="math">S=\\{u:r^{</em>}&lt;u&lt;r\\}</span> and <span class="math">J</span> the set of adversarial queries in <span class="math">S</span>. By Proposition 6, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{m}{16\\tau f}<span class="math">; it is not hard to verify that the bounds on </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ of Definition 8 and Proposition 3 hold. We are going to argue that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">(1+\\epsilon)p\\sum_{u\\in S}t_{u}\\geq\\sum_{j\\in J}A_{j}\\geq\\sum_{u\\in S}Q_{u}\\geq(1-\\epsilon)(1-\\theta f)p\\sum_{u\\in S}n_{u}.</span> (2)</p>

    <p class="text-gray-300">Note that this provides a contradiction, since Requirements (R0) and (R2) imply <span class="math">t_{u}&lt;(1-\\delta)n_{u}\\leq(1-4\\epsilon-2\\theta f)n_{u}&lt;(1-2\\epsilon)(1-\\theta f)n_{u}\\leq\\frac{1-\\epsilon}{1+\\epsilon}\\cdot(1-\\theta f)n_{u}</span>. The first and third inequalities hold in any typical execution; we proceed to show the middle one.</p>

    <p class="text-gray-300">We first make a simple but crucial observation. Consider any block <span class="math">B</span> extending a chain <span class="math">\\mathcal{C}^{\\prime}</span> that was computed by an honest party in a uniquely successful round <span class="math">u\\in S</span>. For any <span class="math">d\\in\\mathbb{R}</span> such that <span class="math">\\text{diff}(\\mathcal{C}^{\\prime})\\leq d&lt;\\text{diff}(\\mathcal{C}^{\\prime}B)</span>, let us write <span class="math">d\\in B</span>. We are going to argue that if another chain of difficulty at least <span class="math">d</span> exists, then the block that “contains” the point of difficulty <span class="math">d</span> was computed by the adversary. More formally, suppose a chain <span class="math">\\mathcal{C}^{\\prime\\prime}B^{\\prime}</span> exists such that <span class="math">B^{\\prime}\\neq B</span> and <span class="math">d\\in B^{\\prime}</span>. We observe that <span class="math">B^{\\prime}</span> was computed by the adversary. This is because no honest party would extend <span class="math">\\mathcal{C}^{\\prime\\prime}</span> at a round later than <span class="math">u</span> since <span class="math">\\text{diff}(\\mathcal{C}^{\\prime\\prime})\\leq d&lt;\\text{diff}(\\mathcal{C}^{\\prime}B)</span>; on the other hand, if an honest party computed <span class="math">B^{\\prime}</span> at some round <span class="math">u^{\\prime}&lt;u</span>, then no honest party would have extended <span class="math">\\mathcal{C}^{\\prime}</span> at round <span class="math">u</span> since <span class="math">\\text{diff}(\\mathcal{C}^{\\prime})\\leq d&lt;\\text{diff}(\\mathcal{C}^{\\prime\\prime}B^{\\prime\\prime})</span>; finally, note that <span class="math">u</span> is also ruled out since it was uniquely successful.</p>

    <p class="text-gray-300">Let us now return to the proof of (2). By the Chain-Growth Lemma (Lemma 1), <span class="math">\\text{diff}(\\mathcal{C})\\geq\\text{diff}(\\mathcal{C}^{*})+\\sum_{u\\in S}Q_{u}</span>. The observation in the previous paragraph implies that there is an injection from the set</p>

    <p class="text-gray-300"><span class="math">U=\\{d\\in B:B\\text{ was computed in a uniquely successful round in }S\\}</span></p>

    <p class="text-gray-300">into the set</p>

    <p class="text-gray-300"><span class="math">W=\\{d\\in B^{\\prime}:B^{\\prime}\\text{ was computed by the adversary in a round in }S\\}.</span></p>

    <p class="text-gray-300">To see this, note first that both sets are subsets of <span class="math">(\\text{diff}(\\mathcal{C}^{<em>}),\\text{diff}(\\mathcal{C}))</span>. We claim that for any <span class="math">d\\in U</span> and <span class="math">B</span> such that <span class="math">d\\in B</span>, there is always a <span class="math">B^{\\prime}\\neq B</span> that lies either on <span class="math">\\mathcal{C}_{1}</span>, or on <span class="math">\\mathcal{C}</span>, or on their common prefix. Indeed, <span class="math">B</span> cannot be both on <span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{C}^{\\prime}</span>; by the definition of <span class="math">r^{</em>}</span>, <span class="math">B</span> cannot be on their common prefix; by the definition of <span class="math">r</span>, <span class="math">B</span> cannot be on the part of <span class="math">\\mathcal{C}</span> of greater difficulty than <span class="math">\\text{diff}(\\mathcal{C}_{1})</span>.</p>

    <p class="text-gray-300">Since the size of the first set is <span class="math">\\sum_{u\\in S}Q_{u}</span> and the size of the second—by Proposition 5—is at most <span class="math">\\sum_{j\\in J}A_{j}</span>, the inequality in (2) follows. ∎</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Theorem 3 (Chain Quality).</h6>

    <p class="text-gray-300">In any typical execution of a <span class="math">(\\gamma,s)</span>-respecting environment, the chain-quality property holds for <span class="math">\\ell\\geq\\frac{\\theta\\gamma m}{8\\tau}</span> and <span class="math">\\mu=\\delta-2\\epsilon-\\theta f\\geq\\nicefrac{{\\delta}}{{2}}</span>.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let us denote by <span class="math">B_{i}</span> the <span class="math">i</span>-th block of <span class="math">\\mathcal{C}</span> so that <span class="math">\\mathcal{C}=B_{1}\\ldots B_{\\text{len}(\\mathcal{C})}</span> and consider <span class="math">L</span> consecutive blocks <span class="math">B_{u},\\ldots,B_{v}</span>. Define <span class="math">L^{\\prime}</span> as the least number of consecutive blocks <span class="math">B_{u^{\\prime}},\\ldots,B_{v^{\\prime}}</span> that include the <span class="math">L</span> given ones (i.e., <span class="math">u^{\\prime}\\leq u</span> and <span class="math">v\\leq v^{\\prime}</span>) and have the properties (1) that the block <span class="math">B_{u^{\\prime}}</span> was computed by an honest party or is <span class="math">B_{1}</span> in case such block does not exist, and (2) that there exists a round at which an honest party was trying to extend the chain ending at block <span class="math">B_{v^{\\prime}}</span>. Observe that number <span class="math">L^{\\prime}</span> is well defined since <span class="math">B_{\\text{len}(\\mathcal{C})}</span> is at the head of a chain that an honest party is trying to extend. Denote by <span class="math">d^{\\prime}</span> the total difficulty of these <span class="math">L^{\\prime}</span> blocks. Define also <span class="math">r_{1}</span> as the round that <span class="math">B_{u^{\\prime}}</span> was created (set <span class="math">r_{1}=0</span> if <span class="math">B_{u^{\\prime}}</span> is the genesis block), <span class="math">r_{2}</span> as the first round that an honest party attempts to extend <span class="math">B_{v^{\\prime}}</span>, and let <span class="math">S=\\{r:r_{1}\\leq r\\leq r_{2}\\}</span>. Note that, by Proposition 6, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{m}{16\\tau f}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now let <span class="math">x</span> denote the total difficulty of all the blocks from honest parties that are included in the <span class="math">L</span> blocks and—towards a contradiction—assume that</p>

    <p class="text-gray-300"><span class="math">x&lt;\\mu d\\leq\\mu d^{\\prime}.</span> (3)</p>

    <p class="text-gray-300">Suppose first that all the <span class="math">L^{\\prime}</span> blocks <span class="math">\\{B_{j}:u^{\\prime}\\leq j\\leq v^{\\prime}\\}</span> have been computed during the rounds in the set <span class="math">S</span>. We now argue the following sequence of inequalities.</p>

    <p class="text-gray-300"><span class="math">(1+\\epsilon)(1-\\delta)p\\sum_{u\\in S}n_{u}\\geq(1+\\epsilon)p\\sum_{u\\in S}t_{u}&gt;\\sum_{j\\in J}A_{j}\\geq d^{\\prime}-x\\geq(1-\\mu)d^{\\prime}\\geq(1-\\mu)\\sum_{u\\in S}Q_{u}.</span> (4)</p>

    <p class="text-gray-300">The first inequality is due to our requirement that <span class="math">t_{u}\\leq(1-\\delta)n_{u}</span> holds for any round <span class="math">u</span>. The second one holds in any typical execution and Remark LABEL:R1. The third one follows from the definition of <span class="math">x</span> and <span class="math">d^{\\prime}</span> and Proposition 5. The fourth one comes from the relation between <span class="math">x</span> and <span class="math">d^{\\prime}</span> outlined in (3). To see the last inequality, assume <span class="math">\\sum_{u\\in S}Q_{u}&gt;d^{\\prime}</span>. But then, by the Chain-Growth Lemma 1, the assumption than an honest party is on <span class="math">B_{v^{\\prime}}</span> at round <span class="math">r_{2}</span> is contradicted as all honest parties should be at chains of greater length. We now observe that (4) contradicts Proposition 3, since</p>

    <p class="text-gray-300"><span class="math">(1-\\mu)\\sum_{u\\in S}Q_{u}&gt;(1-\\mu)(1-\\epsilon)(1-\\theta f)p\\sum_{u\\in S}n_{u}\\geq(1+\\epsilon)(1-\\delta)p\\sum_{u\\in S}n_{u},</span></p>

    <p class="text-gray-300">where the last inequality follows by Requirement (R2).</p>

    <p class="text-gray-300">To finish the proof we need to consider the case in which these <span class="math">L^{\\prime}</span> blocks contain blocks that the adversary computed in rounds outside <span class="math">S</span>. It is not hard to see that this case implies either a prediction or an insertion and cannot occur in a typical execution. ∎</p>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">6.6 Persistence and Liveness</h3>

    <h6 id="sec-51" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">Let <span class="math">E</span> be a typical execution in a <span class="math">(\\gamma,s)</span>-respecting environment. Persistence is satisfied with depth <span class="math">k\\geq\\frac{\\theta\\gamma m}{4\\tau}</span>.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">If the chain <span class="math">\\mathcal{C}</span> of an honest party at round <span class="math">r</span> contains a transaction in <span class="math">\\mathcal{C}^{\\lceil k}</span>, it follows by the common-prefix property that for the chain <span class="math">\\mathcal{C}^{\\prime}</span> of another honest party at any round <span class="math">r^{\\prime}\\geq r</span> it holds <span class="math">\\mathcal{C}^{\\lceil k}\\preceq\\mathcal{C}^{\\prime}</span>. ∎</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Proposition 7.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">E</span> be a typical execution in a <span class="math">(\\gamma,s)</span>-respecting environment. Suppose an honest party has a prefix of <span class="math">\\mathcal{C}</span> at a round <span class="math">u</span> and an honest party adopted a prefix of <span class="math">\\mathcal{C}</span> at round <span class="math">v\\geq u+\\frac{m}{16\\tau f}</span>. During the set of consecutive rounds <span class="math">S=\\{r:u\\leq r&lt;v\\}</span>, <span class="math">\\mathcal{C}</span> acquired at least $(1-\\epsilon)(1-\\theta f)\\eta f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\gamma$ blocks.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-54" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assume first that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq s-\\frac{m}{8\\tau f}<span class="math">. Suppose </span>\\mathcal{C}<span class="math"> at round </span>u<span class="math"> has difficulty </span>d<span class="math">. By the Chain Growth Lemma 1, </span>\\mathcal{C}<span class="math"> has difficulty at least </span>d^{\\prime}=d+\\sum_{r\\in S}D_{r}<span class="math"> by round </span>v<span class="math">. Let </span>T<span class="math"> be the least target among the targets of the blocks acquired during the rounds in </span>S<span class="math">. By Lemmas 2 and 3, there is an honest block on </span>\\mathcal{C}<span class="math"> computed in </span>S^{\\prime}=\\{r:u-\\frac{m}{16\\tau f}\\leq r<v+\\frac{m}{16\\tau f}\\}<span class="math"> that lies in the same epoch and so has target </span>T<span class="math">. Since the execution is good (Theorem 1), </span>S\\subseteq S^{\\prime}<span class="math">, and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq s<span class="math">, we obtain (Fact 1) </span>pTn_{r}\\geq\\eta f/\\gamma<span class="math">, for any </span>r\\in S<span class="math">. It follows that </span>\\mathcal{C}$ acquired at least</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$T(d^{\\prime}-d)=T\\sum_{r\\in S}D_{r}\\geq T\\sum_{r\\in S}Q_{r}>(1-\\epsilon)(1-\\theta f)\\sum_{r\\in S}pTn_{r}\\geq(1-\\epsilon)(1-\\theta f)\\eta f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\gamma$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">blocks during the rounds in <span class="math">S</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To avoid the upper bound on <span class="math">S</span> and obtain the statement, observe that by Lemma 2 we can partition <span class="math">S</span> so that each part <span class="math">S_{i}</span> satisfies $\\frac{m}{16\\tau f}\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq s-\\frac{m}{8\\tau f}<span class="math">, an honest party has (a prefix of) </span>\\mathcal{C}<span class="math"> at the beginning of </span>S_{i}<span class="math">, and an honest party has adopted (a prefix of) </span>\\mathcal{C}<span class="math"> at the end of </span>S_{i}$. Summing over each part we obtain the general statement. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-55" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">Let <span class="math">E</span> be a typical execution in a <span class="math">(\\gamma,s)</span>-respecting environment. Liveness is satisfied for depth <span class="math">k\\geq\\frac{\\theta\\gamma m}{8\\tau}</span> and wait-time <span class="math">\\frac{m}{16\\tau f}+\\frac{\\gamma k}{\\eta f(1-\\epsilon)(1-\\theta f)}</span>.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose a transaction tx is included in any block computed by an honest party for <span class="math">\\frac{m}{16\\tau f}</span> consecutive rounds and consider the chain <span class="math">\\mathcal{C}</span> of an arbitrary honest party after these rounds. By Lemma 2, <span class="math">\\mathcal{C}</span> contains an honest block computed in the <span class="math">\\frac{m}{16\\tau f}</span> rounds and this block contains tx. Denote by <span class="math">S</span> the set of at least <span class="math">\\gamma k/[\\eta f(1-\\epsilon)(1-\\theta f)]</span> rounds that follow the round that this honest block was computed. By Proposition LABEL:R2, on top of this block there has been accumulated at least <span class="math">k</span> blocks. ∎</p>

    <p class="text-gray-300">##</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Back, A.: Hashcash. http://www.cypherspace.org/hashcash (1997)</li>

      <li>[2] Bahack, L.: Theoretical bitcoin attacks with less than half of the computational power (draft). IACR Cryptology ePrint Archive 2013, 868 (2013), http://eprint.iacr.org/2013/868</li>

      <li>[3] Bellare, M., Rogaway, P.: Random oracles are practical: A paradigm for designing efficient protocols. In: Denning, D.E., Pyle, R., Ganesan, R., Sandhu, R.S., Ashby, V. (eds.) CCS ’93, Proceedings of the 1st ACM Conference on Computer and Communications Security, Fairfax, Virginia, USA, November 3-5, 1993. pp. 62–73. ACM (1993), http://doi.acm.org/10.1145/168588.168596</li>

      <li>[4] Canetti, R.: Security and composition of multiparty cryptographic protocols. J. Cryptology 13(1), 143–202 (2000)</li>

      <li>[5] Canetti, R.: Universally composable security: A new paradigm for cryptographic protocols. Cryptology ePrint Archive, Report 2000/067 (2000), http://eprint.iacr.org/2000/067</li>

      <li>[6] Canetti, R.: Universally composable security: A new paradigm for cryptographic protocols. In: 42nd Annual Symposium on Foundations of Computer Science, FOCS 2001, 14-17 October 2001, Las Vegas, Nevada, USA. pp. 136–145. IEEE Computer Society (2001), http://dx.doi.org/10.1109/SFCS.2001.959888</li>

      <li>[7] Dwork, C., Lynch, N.A., Stockmeyer, L.J.: Consensus in the presence of partial synchrony. J. ACM 35(2), 288–323 (1988), http://doi.acm.org/10.1145/42282.42283</li>

      <li>[8] Dwork, C., Naor, M.: Pricing via processing or combatting junk mail. In: Brickell, E.F. (ed.) CRYPTO. Lecture Notes in Computer Science, vol. 740, pp. 139–147. Springer (1992)</li>

      <li>[9] Eyal, I., Sirer, E.G.: Majority is not enough: Bitcoin mining is vulnerable. In: Keromytis, A.D. (ed.) Financial Cryptography. Lecture Notes in Computer Science, vol. 7397. Springer (2014), http://dx.doi.org/10.1007/978-3-642-32946-3</li>

      <li>[10] Garay, J.A., Kiayias, A., Leonardos, N.: The Bitcoin Backbone Protocol: Analysis and Applications. IACR Cryptology ePrint Archive 2014, 765 (2014), http://eprint.iacr.org/2014/765</li>

      <li>[11] Garay, J.A., Kiayias, A., Leonardos, N.: The bitcoin backbone protocol: Analysis and applications. In: Oswald, E., Fischlin, M. (eds.) Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part II. Lecture Notes in Computer Science, vol. 9057, pp. 281–310. Springer (2015), http://dx.doi.org/10.1007/978-3-662-46803-6_10</li>

      <li>[12] Hadzilacos, V., Toueg, S.: A modular approach to fault-tolerant broadcasts and related problems. Tech. rep. (1994)</li>

      <li>[13] Juels, A., Brainard, J.G.: Client puzzles: A cryptographic countermeasure against connection depletion attacks. In: NDSS. The Internet Society (1999)</li>

      <li>[14] Kiayias, A., Koutsoupias, E., Kyropoulou, M., Tselekounis, Y.: Blockchain mining games. In: Conitzer, V., Bergemann, D., Chen, Y. (eds.) Proceedings of the 2016 ACM Conference on Economics and Computation, EC ’16, Maastricht, The Netherlands, July 24-28, 2016. pp. 365–382. ACM (2016), http://doi.acm.org/10.1145/2940716.2940773</li>

      <li>[15] Kiayias, A., Panagiotakos, G.: Speed-security tradeoffs in blockchain protocols. IACR Cryptology ePrint Archive 2015, 1019 (2015), http://eprint.iacr.org/2015/1019</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[16] Lamport, L., Shostak, R.E., Pease, M.C.: The byzantine generals problem. ACM Trans. Program. Lang. Syst. 4(3), 382–401 (1982)</li>

      <li>[17] McDiarmid, C.: Probabilistic Methods for Algorithmic Discrete Mathematics, chap. Concentration, pp. 195–248. Springer Berlin Heidelberg, Berlin, Heidelberg (1998), http://dx.doi.org/10.1007/978-3-662-12788-9_6</li>

      <li>[18] Mitzenmacher, M., Upfal, E.: Probability and computing - randomized algorithms and probabilistic analysis. Cambridge University Press (2005)</li>

      <li>[19] Nakamoto, S.: Bitcoin open source implementation of p2p currency. http://p2pfoundation.ning.com/forum/topics/bitcoin-open-source (February 2009)</li>

      <li>[20] Pass, R., Seeman, L., Shelat, A.: Analysis of the blockchain protocol in asynchronous networks. In: Coron, J., Nielsen, J.B. (eds.) Advances in Cryptology - EUROCRYPT 2017 - 36th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Paris, France, April 30 - May 4, 2017, Proceedings, Part II. Lecture Notes in Computer Science, vol. 10211, pp. 643–673 (2017), https://doi.org/10.1007/978-3-319-56614-6_22</li>

      <li>[21] Pease, M.C., Shostak, R.E., Lamport, L.: Reaching agreement in the presence of faults. J. ACM 27(2), 228–234 (1980)</li>

      <li>[22] Rivest, R.L., Shamir, A., Wagner, D.A.: Time-lock puzzles and timed-release crypto. Tech. rep., Cambridge, MA, USA (1996)</li>

      <li>[23] Sapirshtein, A., Sompolinsky, Y., Zohar, A.: Optimal selfish mining strategies in bitcoin. CoRR abs/1507.06183 (2015), http://arxiv.org/abs/1507.06183</li>

    </ul>

    <h2 id="sec-58" class="text-2xl font-bold">Appendix A The Bitcoin Backbone Protocol with Variable Difficulty (cont’d)</h2>

    <p class="text-gray-300">In this section we give a a more detailed description of the Bitcoin backbone protocol with chains of variable difficulty. The presentation is based on the description in <em>[11]</em>.</p>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">A.1 The protocol</h3>

    <p class="text-gray-300">As in <em>[11]</em> in our description oof the backbone protocol we intentionally avoid specifying the type of values/content that parties try to insert in the chain, the type of chain validation they perform (beyond checking for its structural properties with respect to the hash functions <span class="math">G(\\cdot),H(\\cdot)</span>), and the way they interpret the chain. These checks and operations are handled by the external functions <span class="math">V(\\cdot),I(\\cdot)</span> and <span class="math">R(\\cdot)</span> (the content validation function, the input contribution function and the chain reading function, resp.) which are specified by the application that runs “on top” of the backbone protocol.</p>

    <p class="text-gray-300">The Bitcoin backbone protocol in the dynamic setting is specified as Algorithm 4 and depends on three sub-procedures.</p>

    <p class="text-gray-300">Chain validation. The validate algorithm performs a validation of the structural properties of a given chain <span class="math">\\mathcal{C}</span>. It is given as input the value <span class="math">q</span>, as well as hash functions <span class="math">H(\\cdot),G(\\cdot)</span>. It is parameterized by the content validation predicate predicate <span class="math">V(\\cdot)</span> as well as by <span class="math">D(\\cdot)</span>, the target calculation function (see Section 3). For each block of the chain, the algorithm checks that the proof of work is properly solved (with a target that is suitable as determined by the target calculation function), and that the counter <span class="math">ctr</span> does not exceed <span class="math">q</span>. Furthermore it collects the inputs from all blocks, <span class="math">\\mathbf{x}_{\\mathcal{C}}</span>, and tests them via the predicate <span class="math">V(\\mathbf{x}_{\\mathcal{C}})</span>; note that <span class="math">V(\\varepsilon)=\\mathbf{true}</span>. Chains that fail these validation procedure are rejected. (Algorithm 1.)</p>

    <p class="text-gray-300">|  Algorithm 1 The chain validation predicate, parameterized by q, D, the hash functions G(·), H(·), and the input validation predicate V(·). The input is chain C.  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  1: function validate(rnow, C)  |   |</p>

    <p class="text-gray-300">|  2: valid ← V(xC)  |   |</p>

    <p class="text-gray-300">|  3: if valid = True ∧ (C ≠ ε) then ▷ C is non-empty and meaningful w.r.t. V(·)  |   |</p>

    <p class="text-gray-300">|  4: r' ← rnow  |   |</p>

    <p class="text-gray-300">|  5: ⟨r, st, x, ctr⟩ ← head(C)  |   |</p>

    <p class="text-gray-300">|  6: st' ← H(ctr, G(r, st, x))  |   |</p>

    <p class="text-gray-300">|  7: repeat  |   |</p>

    <p class="text-gray-300">|  8: ⟨r, st, x, ctr⟩ ← head(C)  |   |</p>

    <p class="text-gray-300">|  9: T ← D(rC[1]) ▷ Calculate target based on C[1]  |   |</p>

    <p class="text-gray-300">|  10: if validblockqT(⟨st, x, ctr⟩) ∧ (H(ctr, G(r, st, x)) = st') ∧ (r < r') then  |   |</p>

    <p class="text-gray-300">|  11: r' ← r ▷ Retain round timestamp  |   |</p>

    <p class="text-gray-300">|  12: st' ← st ▷ Retain hash value  |   |</p>

    <p class="text-gray-300">|  13: C ← C[1] ▷ Remove the head from C  |   |</p>

    <p class="text-gray-300">|  14: else  |   |</p>

    <p class="text-gray-300">|  15: valid ← False  |   |</p>

    <p class="text-gray-300">|  16: end if  |   |</p>

    <p class="text-gray-300">|  17: until (C = ε) ∨ (valid = False)  |   |</p>

    <p class="text-gray-300">|  18: end if  |   |</p>

    <p class="text-gray-300">|  19: return valid  |   |</p>

    <p class="text-gray-300">|  20: end function  |   |</p>

    <p class="text-gray-300">Chain comparison. The objective of the second algorithm, called maxvalid, is to find the "best possible" chain when given a set of chains. The algorithm is straightforward and is parameterized by a  <span class="math">\\max(\\cdot)</span>  function that applies some ordering in the space of chains. The most important aspect is the chains' difficulty in which case  <span class="math">\\max(\\mathcal{C}_1, \\mathcal{C}_2)</span>  will return the most difficult of the two. In case  <span class="math">\\text{diff}(\\mathcal{C}_1) = \\text{diff}(\\mathcal{C}_2)</span> , some other characteristic can be used to break the tie. In our case,  <span class="math">\\max(\\cdot, \\cdot)</span>  will always return the first operand to reflect the fact that parties adopt the first chain they obtain from the network. (Algorithm 2.)</p>

    <p class="text-gray-300">Algorithm 2 The function that finds the "best" chain, parameterized by function  <span class="math">\\max (\\cdot)</span> . The input is  <span class="math">\\{\\mathcal{C}_1,\\ldots ,\\mathcal{C}_k\\}</span> . 1: function maxvalid(r, C1, ..., Ck) 2: temp ← ε 3: for i = 1 to k do 4: if validate(r, Ci) then 5: temp ← max(C, temp) 6: end if 7: end for 8: return temp 9: end function</p>

    <p class="text-gray-300">Proof of work. The third algorithm, called pow, is the proof of work-finding procedure. It takes as input a chain and attempts to extend it via solving a proof of work. This algorithm is parameterized by two hash functions  <span class="math">H(\\cdot), G(\\cdot)</span>  as well as the parameter  <span class="math">q</span> . Moreover, the algorithm calls the target calculation function  <span class="math">D(\\cdot)</span>  on prder to determine the value  <span class="math">T</span>  that will be used for the proof of work. The procedure, given a chain  <span class="math">\\mathcal{C}</span>  and a value  <span class="math">x</span>  to be inserted in the chain, hashes these values to obtain  <span class="math">h</span>  and initializes a counter  <span class="math">ctr</span> . Subsequently, it increments  <span class="math">ctr</span>  and checks to see whether  <span class="math">H(ctr, h) &amp;lt; T</span> ; in case a suitable  <span class="math">ctr</span>  is found then the algorithm succeeds in solving the POW and extends chain  <span class="math">\\mathcal{C}</span>  by one block. (Algorithm 3.)</p>

    <p class="text-gray-300">|  Algorithm 3 The proof of work function, parameterized by q and hash functions H(·), G(·). The input is (x, C).  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  1: function pow(r, x, C)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2: if C = ε then</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Determine proof of work instance.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  3: st ← 0 |   |</p>

    <p class="text-gray-300">|  4: else |   |</p>

    <p class="text-gray-300">|  5: ⟨r', st', x', ctr'⟩ ← head(C) |   |</p>

    <p class="text-gray-300">|  6: st ← H(ctr', G(r', st', x')) |   |</p>

    <p class="text-gray-300">|  7: end if |   |</p>

    <p class="text-gray-300">|  8: ctr ← 1 |   |</p>

    <p class="text-gray-300">|  9: B ← ε |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">10: T ← D(rC)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Calculate target for next block based on timestamps.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  11: h ← G(r, st, x) |   |</p>

    <p class="text-gray-300">|  12: while (ctr ≤ q) do |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">13: if (H(ctr, h) < T) then</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ This H(·) invocation is subject to the q-bound.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  14: B ← ⟨r, st, x, ctr⟩ |   |</p>

    <p class="text-gray-300">|  15: break |   |</p>

    <p class="text-gray-300">|  16: end if |   |</p>

    <p class="text-gray-300">|  17: ctr ← ctr + 1 |   |</p>

    <p class="text-gray-300">|  18: end while |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">19: C ← CB</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Chain is extended</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  20: return C |   |</p>

    <p class="text-gray-300">|  21: end function |   |</p>

    <p class="text-gray-300">The backbone protocol. The core of the protocol is similar to that of [11], with several important distinctions. First is the procedure to follow when they become active. Parties check the ready flag they possess that is false if and only if they have been inactive in the previous round. In case the ready flag is false, they broadcast a special message 'Join' to request the most recent version of the blockchain(s). Similarly, parties that receive the special request message in their RECEIVE() tape they broadcast their chain. As before, parties run "indefinitely" (our security analysis will apply when the total running time is polynomial in  <span class="math">\\kappa</span> ). The input contribution function  <span class="math">I(\\cdot)</span>  and the chain reading function  <span class="math">R(\\cdot)</span>  are applied to the values stored in the chain. Parties check their communication tape RECEIVE() to see whether any necessary update of their local chain is due; then they attempt to extend it via the POW algorithm pow. The function  <span class="math">I(\\cdot)</span>  determines the input to be added in the chain given the party's state  <span class="math">st</span> , the current chain  <span class="math">\\mathcal{C}</span> , the contents of the party's input tape INPUT() and communication tape RECEIVE(). The input tape contains two types of symbols, READ and (INSERT, value); other inputs are ignored. In case the local chain  <span class="math">\\mathcal{C}</span>  is extended the new chain is broadcast to the other parties. Finally, in case a READ symbol is present in the communication tape, the protocol applies function  <span class="math">R(\\cdot)</span>  to its current chain and writes the result onto the output tape OUTPUT(). The pseudocode of the backbone protocol is presented in Algorithm 4.</p>

    <p class="text-gray-300">Algorithm 4 The Bitcoin backbone protocol in the dynamic setting at round “round” on local state <span class="math">(st,\\mathcal{C})</span> parameterized by the input contribution function <span class="math">I(\\cdot)</span> and the chain reading function <span class="math">R(\\cdot)</span>. The “ready” flag is False if and only if the party was inactive in the previous round.</p>

    <p class="text-gray-300">⬇ 1:if ready = True then 2: Diffuse(Ready) 3: <span class="math">\\tilde{\\mathcal{C}}\\leftarrow\\text{maxvalid}(\\mathcal{C},\\text{all chains }\\mathcal{C}^{\\prime}\\text{ found in Receive}())</span> 4: if Input() contains Read then 5: write <span class="math">R(\\mathbf{x}_{\\mathcal{C}})</span> to Output() 6: end if 7: <span class="math">\\langle st,x\\rangle\\leftarrow I(st,\\tilde{\\mathcal{C}},\\text{round},\\text{Input}(),\\text{Receive}())</span> 8: <span class="math">\\mathcal{C}_{\\text{new}}\\leftarrow\\text{pow}(\\text{round},x,\\tilde{\\mathcal{C}})</span> 9: if <span class="math">(\\mathcal{C}\\neq\\mathcal{C}_{\\text{new}})\\vee(\\text{Join}\\in\\text{Receive}())</span> then 10: <span class="math">\\mathcal{C}\\leftarrow\\mathcal{C}_{\\text{new}}</span> 11: Diffuse(<span class="math">\\mathcal{C}</span>) <span class="math">\\triangleright</span> chain is diffused when updated or when someone joins. 12: end if 13: Diffuse(RoundComplete) 14:else 15: ready <span class="math">\\leftarrow</span> True 16: Diffuse(Join, RoundComplete) 17:end if</p>

    <h2 id="sec-60" class="text-2xl font-bold">Appendix B Robust Public Transaction Ledgers</h2>

    <p class="text-gray-300">In this section we reproduce the presentation of public transaction ledgers given in <em>[10, 11]</em>. A public transaction ledger is defined with respect to a set of valid ledgers <span class="math">\\mathcal{L}</span> and a set of valid transactions <span class="math">\\mathcal{T}</span>, each one possessing an efficient membership test. A ledger <span class="math">\\mathbf{x}\\in\\mathcal{L}</span> is a vector of sequences of transactions <span class="math">\\text{tx}\\in\\mathcal{T}</span>. Each transaction tx may be associated with one or more accounts, denoted <span class="math">a_{1},a_{2},\\ldots</span> etc.</p>

    <p class="text-gray-300">The backbone protocol parties, called miners in the context of this section, process sequences of transactions of the form <span class="math">x=\\text{tx}_{1}\\ldots\\text{tx}_{e}</span> that are supposed to be incorporated into their local chain <span class="math">\\mathcal{C}</span>. The input inserted at each block of the chain <span class="math">\\mathcal{C}</span> is the sequence <span class="math">x</span> of transactions. Thus, a ledger is a vector of transaction sequences <span class="math">\\langle x_{1},\\ldots,x_{m}\\rangle</span>, and a chain <span class="math">\\mathcal{C}</span> of length <span class="math">m</span> contains the ledger <span class="math">\\mathbf{x}_{\\mathcal{C}}=\\langle x_{1},\\ldots,x_{m}\\rangle</span> if the input of the <span class="math">j</span>-th block in <span class="math">\\mathcal{C}</span> is <span class="math">x_{j}</span>.</p>

    <p class="text-gray-300">The description and properties of the ledger protocol will be expressed relative to an oracle Txgen which will control a set of accounts by creating them and issuing transactions on their behalf. In an execution of the backbone protocol, the environment <span class="math">\\mathcal{Z}</span> as well as the miners will have access to Txgen. Specifically, Txgen is a stateful oracle that responds to two types of queries (which we purposely only describe at a high level):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>GenAccount(<span class="math">1^{\\kappa}</span>): It generates an account <span class="math">a</span>.</li>

      <li>IssueTrans(<span class="math">1^{\\kappa},\\tilde{\\text{tx}}</span>): It returns a transaction tx provided that <span class="math">\\tilde{\\text{tx}}</span> is some suitably formed string, or <span class="math">\\bot</span>.</li>

    </ul>

    <p class="text-gray-300">We also consider a symmetric relation on <span class="math">\\mathcal{T}</span>, denoted by <span class="math">C(\\cdot,\\cdot)</span>, which indicates when two transactions <span class="math">\\text{tx}_{1},\\text{tx}_{2}</span> are conflicting. Valid ledgers <span class="math">\\mathbf{x}\\in\\mathcal{L}</span> can never contain two conflicting transactions. We call oracle Txgen unambiguous if it holds that for all PPT <span class="math">\\mathcal{A}</span>, the probability that <span class="math">\\mathcal{A}^{\\text{Txgen}}</span> produces a transaction <span class="math">\\text{tx}^{\\prime}</span> such that <span class="math">C(\\text{tx}^{\\prime},\\text{tx})=1</span>, for tx issued by Txgen, is negligible in <span class="math">\\kappa</span>.</p>

    <p class="text-gray-300">Finally, a transaction tx is called neutral if <span class="math">C(\\text{tx},\\text{tx}^{\\prime})=0</span> for any other transaction <span class="math">\\text{tx}^{\\prime}</span>. The presence of neutral transactions in the ledger can be helpful for a variety of purposes, as we will see next and in the BA protocol that we build on top of the ledger. For convenience we will assume that a single random nonce <span class="math">\\rho\\in\\{0,1\\}^{\\kappa}</span> is also a valid transaction. Nonces will be neutral transactions and may be included in the ledger for the sole purpose of ensuring independence between the POW instances solved by the honest parties.</p>

    <p class="text-gray-300">Next, we determine the three functions  <span class="math">V(\\cdot), I(\\cdot), R(\\cdot)</span>  that will turn the backbone protocol into  <span class="math">\\Pi_{\\mathsf{PL}}</span> , a protocol realizing a public transaction ledger. See Figure 1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Content validation predicate V(·)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(⟨x1, ..., xm⟩) is true if and only if the vector ⟨x1, ..., xm⟩ is a valid ledger, i.e., ⟨x1, ..., xm⟩ ∈ L.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Chain reading function R(·)</td>

            <td class="px-3 py-2 border-b border-gray-700">If V(⟨x1, ..., xm⟩) = True, the value R(C) is equal to ⟨x1, ..., xm⟩; unde-fined otherwise.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Input contribution func-tion I(·)</td>

            <td class="px-3 py-2 border-b border-gray-700">I(st, C, round, INPUT()) operates as follows: if the input tape contains (INSERT, v), it parses v as a sequence of transactions and retains the largest subsequence x' ≤ v that is valid with respect to xC (and whose transactions are not already included in xC). Finally, x = tx0x' where tx0 is a neutral random nonce transaction.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 1: The public transaction ledger protocol  <span class="math">\\Pi_{\\mathsf{PL}}</span> , built on the Bitcoin backbone.</p>

    <p class="text-gray-300">In Section 4.3 we introduced two essential properties for a protocol maintaining a public transaction ledger: (i) Persistence and (ii) Liveness. In a nutshell, Persistence states that once an honest player reports a transaction "deep enough" in the ledger, then all other honest players will report it indefinitely whenever they are asked, and at exactly the same position in the ledger (essentially, this means that all honest players agree on all the transactions that took place and in what order). In a more concrete Bitcoin-like setting, Persistence is essential to ensure that credits are final and that they happened at a certain "time" in the system's timeline (which is implicitly defined by the ledger itself).</p>

    <p class="text-gray-300">Persistence is useful but not enough to ensure that the ledger makes progress, i.e., that transactions are eventually inserted in a chain. This is captured by the Liveness property, which states that as long as a transaction comes from an honest account holder and is provided by the environment to all honest players, then it will be inserted into the honest players' ledgers, assuming the environment keeps providing it as an input for a sufficient number of rounds.</p>

    <p class="text-gray-300">For more details about the specification of a robust transaction ledger, in particular Bitcoin-like transactions and ledger, refer to [10, 11].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 9. [18, Chapter 12] A sequence of random variables  <span class="math">X_0, X_1, \\ldots</span>  is a martingale with respect to the sequence  <span class="math">Y_0, Y_1, \\ldots</span> , if, for all  <span class="math">n \\geq 0</span> , (1)  <span class="math">X_n</span>  is a function of  <span class="math">Y_0, \\ldots, Y_n</span> , (2)  $\\mathbf{E}[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">] &lt; \\infty<span class="math"> , and (3)  </span>\\mathbf{E}[X_{n+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_0, \\ldots, Y_n] = X_n$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 6. [17, Theorem 3.15] Let  <span class="math">X_0, X_1, \\ldots</span>  be a martingale with respect to the sequence  <span class="math">Y_0, Y_1, \\ldots</span> . For  <span class="math">n \\geq 0</span> , let</p>

    <div class="my-4 text-center"><span class="math-block">V = \\sum_ {i = 1} ^ {n} \\operatorname {v a r} \\left(X _ {i} - X _ {i - 1} \\mid Y _ {0}, \\dots , Y _ {i - 1}\\right) \\text {a n d} b = \\max  _ {1 \\leq i \\leq n} \\sup  \\left(X _ {i} - X _ {i - 1} \\mid Y _ {0}, \\dots , Y _ {i - 1}\\right),</span></div>

    <p class="text-gray-300">where  <span class="math">\\sup</span>  is taken over all possible assignments to  <span class="math">Y_0, \\ldots, Y_{i-1}</span> . Then, for any  <span class="math">t, v \\geq 0</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {P r} \\big [ (X _ {n} \\geq X _ {0} + t) \\wedge (V \\leq v) \\big ] \\leq \\exp \\biggl \\{- \\frac {t ^ {2}}{2 v + 2 b t / 3} \\biggr \\}.</span></div>

    <p class="text-gray-300">Fact 2. Suppose  <span class="math">f: \\mathbb{R}_{\\geq 0} \\to \\mathbb{R}_{\\geq 0}</span>  is concave and  <span class="math">f(0) \\geq 0</span> . Then, for any  <span class="math">x, y \\in [0, \\infty)</span>  and  <span class="math">\\lambda \\in [1, \\infty)</span> ,  <span class="math">f(x / \\lambda) \\geq f(x) / \\lambda</span> ,  <span class="math">f(\\lambda x) \\leq \\lambda f(x)</span> ,  <span class="math">f(x + y) \\leq f(x) + f(y)</span> .</p>

    <p class="text-gray-300">The following well-known inequalities may be used without reference.</p>

    <p class="text-gray-300">Fact 3. (1)  <span class="math">1 + x &amp;lt; e^{x}</span> , for all  <span class="math">x</span> . (2)  <span class="math">-\\frac{x}{1 - x} &amp;lt; \\ln(1 - x)</span> , for  <span class="math">x \\in (0,1)</span> . (3)  <span class="math">\\frac{x}{1 + x/2} &amp;lt; \\ln(1 + x) &amp;lt; x</span> , for  <span class="math">x &amp;gt; 0</span> .</p>`;
---

<BaseLayout title="The Bitcoin Backbone Protocol with Chains of Variable Diffic... (2016/1048)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/1048
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
