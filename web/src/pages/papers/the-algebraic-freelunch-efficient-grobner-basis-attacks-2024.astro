---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/347';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'The Algebraic Freelunch: Efficient Gröbner Basis Attacks Against Arithmetization-Oriented Primitives';
const AUTHORS_HTML = 'Augustin Bariant, Aurélien Boeuf, Axel Lemoine, Irati Manterola Ayala, Morten Øygarden, Léo Perrin, Håvard Raddum';

const CONTENT = `    <p class="text-gray-300">Augustin Bariant1,<sup>2</sup> , Aurélien Boeuf<sup>2</sup> , Axel Lemoine2,<sup>4</sup> , Irati Manterola Ayala<sup>3</sup> Morten Øygarden<sup>3</sup> , Léo Perrin<sup>2</sup> , and Håvard Raddum<sup>3</sup></p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p><sup>1</sup> ANSSI, Paris, France 2 Inria, Paris, France 3 Simula UiB, Bergen, Norway <sup>4</sup> DGA, France</p>
    </blockquote>

    <p class="text-gray-300">{irati,morten.oygarden,haavardr}@simula.no {augustin.bariant,aurelien.boeuf,axel.lemoine,leo.perrin}@inria.fr</p>

    <p class="text-gray-300">Abstract. In this paper, we present a new type of algebraic attack that applies to many recent arithmetization-oriented families of permutations, such as those used in Griffin, Anemoi, ArionHash, and XHash8, whose security relies on the hardness of the constrained-input constrained-output (CICO) problem. We refer to the attack as the FreeLunch approach: the monomial ordering is chosen so that the natural polynomial system encoding the CICO problem already is a Gröbner basis. In addition, we present a new dedicated resolution algorithm for FreeLunch systems of complexity lower than current state-of-the-art resolution algorithms. We show that the FreeLunch approach challenges the security of fullround instances of Anemoi, Arion and Griffin, and we experimentally confirm these theoretical results. In particular, combining the FreeLunch attack with a new technique to bypass 3 rounds of Griffin, we recover a CICO solution for 7 out of 10 rounds of Griffin in less than four hours on one core of AMD EPYC 7352 (2.3GHz).</p>

    <p class="text-gray-300">Keywords: Algebraic attacks · Gröbner basis · FreeLunch · Symmetric cryptanalysis · Griffin · Arion · Anemoi</p>

    <p class="text-gray-300">Recent decades have seen the emergence of new directions in symmetric cryptography. The aim of symmetric primitives has always been to provide strong security guarantees along with stringent performance requirements. For instance, modern AES [\\[1\\]](#page-31-0) implementations are able to process gigabytes of data in seconds. This has not changed, but the nature of the performance constraints considered is evolving. While the focus has traditionally been on software and hardware footprints, new use cases bring an entirely different set of relevant metrics.</p>

    <p class="text-gray-300">Numerous such new settings exist, such as Homomorphic Encryption-friendly ciphers <a href="#page-33-0">\\[17,</a><a href="#page-33-1">18</a><a href="#page-35-0">,41,</a><a href="#page-33-2">20,</a><a href="#page-32-0">8</a>[,36\\]](#page-34-0), ciphers designed to run efficiently in Multi Party Computation protocols <a href="#page-32-1">\\[4,</a><a href="#page-32-2">3,</a>[23\\]](#page-33-3), block ciphers defined over modular rings enabling more efficient masking [\\[40\\]](#page-34-1), and Arithmetization-Oriented [\\[5\\]](#page-32-3) Permutations (AOP) operating on vectors over large field elements to better integrate with modern Zero-Knowledge proof systems. Despite their differences, there are general trends in the design of these primitives, which we group under a broad umbrella: Symmetric Techniques for Advanced Protocols (STAP).</p>

    <p class="text-gray-300">One noticeable change the STAPs have brought is the underlying alphabet on which these primitives operate. Until recently, the overwhelming majority of symmetric primitives were designed based on operations either on the vector space (F2) n , or using arithmetic over small binary fields of size 2 <sup>m</sup>, for 3 ≤ m ≤ 9. For STAP, the used mathematical structures can be fields of characteristic 2, but with a much larger size (typically m ≥ 128), large fields of prime characteristic (say, p > 2 <sup>128</sup>), or possibly not even a field (like Elisabeth [\\[20\\]](#page-33-2) or Rubato [\\[36\\]](#page-34-0)).</p>

    <p class="text-gray-300">Moreover, the performance metrics now primarily involve the number of multiplications in the underlying structure. Some schemes are designed to have a low multiplicative depth, that is, few multiplications in sequence on any data path from input to output, while others are designed to merely have a low number of multiplications in total. These performance metrics have led designers to propose schemes that are light on multiplications but compensate by defining the multiplication operations over large fields. The hope is that schemes constructed this way may still be secure.</p>

    <p class="text-gray-300">Resurgence of Algebraic Attacks. Despite its functionality, the constraints on multiplications significantly impact the security analysis of STAP primitives. Key-recovery attacks can often be simplified to the resolution of a (system of) non-linear equation(s). While this general approach has been applied successfully to F2-based stream ciphers, traditional block ciphers and hash functions have mostly been resistant to algebraic attacks.</p>

    <p class="text-gray-300">However, since the constraints that STAP primitives must meet often affect their algebraic structure, algebraic attacks are one of the main threats to them. After an initial security analysis, most designers end up setting the number of rounds specifically so as to prevent algebraic attacks. Unfortunately, this is not always sufficient: to attack Jarvis [\\[5\\]](#page-32-3), Albrecht et al. managed to re-write the equations considered by the designers in a simpler way, which made the resolution step much more efficient than initially thought [\\[2\\]](#page-31-1). When considering FHE- or MPC-oriented stream ciphers, FLIP [\\[41\\]](#page-35-0) and its descendant Elisabeth [\\[20\\]](#page-33-2) both fell <a href="#page-33-4">\\[24</a>[,31\\]](#page-34-2) to linearization-based attacks: the system of equations to be solved ended up being simple enough that linear algebra-based approaches could be used.</p>

    <p class="text-gray-300">Despite their crucial impact (particularly on setting the number of rounds), algebraic attacks against symmetric primitives are not nearly as well understood as classical attacks. In particular, there is no consensus among designers on how to provide solid and convincing arguments for the security of primitives against algebraic attacks.</p>

    <p class="text-gray-300">Principles of an Algebraic Attack. Let us describe the main phases involved in the setup of an algebraic attack against a symmetric cipher. We provide a more thorough presentation in Section <a href="#page-3-0">2.</a></p>

    <p class="text-gray-300">First, the problem of interest to the cryptanalyst is modelled as a system of polynomial equations: state variables are chosen, and equations linking them in a way that captures the round function constraints are defined.</p>

    <p class="text-gray-300">Second, this system of equations is solved, using one of a few existing strategies. If the system can be represented as a unique univariate equation, an efficient FFT-based algorithm can be used to retrieve its roots, as performed in <a href="#page-32-4">\\[10,</a>[9\\]](#page-32-5). If, on the other hand, the system consists of several non-linear equations, one may need to convert the system into a form that can be solved efficiently.</p>

    <p class="text-gray-300">A common strategy, adopted in this paper, consists in deriving a univariate polynomial equation that shares its solution with the original system, and in efficiently solving it afterwards. This is typically done via the computation of a Gröbner basis [\\[21\\]](#page-33-5) for the system, using an algorithm such as F<sup>4</sup> [\\[29\\]](#page-34-3), or its follow-up F<sup>5</sup> [\\[30\\]](#page-34-4). The Gröbner basis is then modified using a change of order algorithm, such as FGLM [\\[28\\]](#page-34-5) or its variants <a href="#page-33-6">\\[26,</a><a href="#page-33-7">27,</a>[11\\]](#page-32-6), yielding a univariate polynomial equation sharing its solutions with the original system.</p>

    <p class="text-gray-300">In the past, cipher designers have adopted different approaches to prevent such an attack: the authors of Griffin bounded the complexity of an algebraic attack with an estimate of the theoretical cost of F5, but the authors of Arion [\\[44\\]](#page-35-1) chose instead to bound the complexity of the change of order step<a href="#page-2-0">5</a> .</p>

    <p class="text-gray-300">Our Contributions. In this paper, we present a new type of algebraic attack that significantly outperforms all known methods. It requires revisiting all steps of the general approach outlined above: the encoding, the Gröbner basis computation and the change of order steps are different. First, using a custom monomial ordering and a specific equation generation procedure, we get the Gröbner basis for free. Combining this with known techniques is already sufficient to attack a few full-round instances of Arion and Griffin with a complexity lower than the security claim. We then further decrease the complexity of our attacks by improving the "reordering" step: we provide a novel and more efficient algorithm of our own design<a href="#page-2-1">6</a> that, in practice, significantly outperforms FGLM for our systems of equations. Unfortunately, the precise complexity analysis of one of the steps of this algorithm has remained beyond our reach. Nevertheless, we performed thorough experiments, implementing the full attack against several round-reduced primitives—we published the code used to verify these results on GitHub.<a href="#page-2-2">7</a> From these experimental results we can extrapolate the complexity of the dominating step, and get attack complexities as low as 2 64 , 2 <sup>98</sup>, and 2 118 for the weakest variants of Griffin, Arion, and Anemoi, respectively, where all</p>

    <p class="text-gray-300"><span id="page-2-0"></span><sup>5</sup> This seems to be a choice of pragmatism, as it seems easier to get tight bounds; nothing in their experiments suggests that F<sup>5</sup> is faster.</p>

    <p class="text-gray-300"><span id="page-2-1"></span><sup>6</sup> If the solving steps were meals of the day, the lunch would be free, hence FreeLunch.</p>

    <p class="text-gray-300"><span id="page-2-2"></span><sup>7</sup> <https://github.com/aurelbof/algebraic-freelunch></p>

    <p class="text-gray-300">claim 128 bits of security. We can therefore confidently claim to shave off tens of bits of security from some full-round Griffin instances.</p>

    <p class="text-gray-300">Outline of this Paper. We recall the necessary background on algebraic attacks based on Gröbner bases in Section 2. Our main contribution, the FreeLunch method, is introduced in a generic fashion in Section 3, and we show how it can be successfully applied to various primitives in Section 4. While it is a priori not possible to obtain a Gröbner basis for free in some cases, we show in Section 5 that it may still be possible to derive one at a negligible cost and apply this finding to the AOP Anemoi. We conclude in Section 6 with a discussion on the impact of the FreeLunch approach in terms e.g. of design.</p>

    <p class="text-gray-300">We consider the case of an algebraic attack against a permutation intended for sponge [12] use. In this section, we will walk through the detailed inner workings of such an attack: it will allow us to introduce all the necessary mathematical background and state-of-the-art methods and to set the stage for our attacks by both providing all the theoretical tools we need and allowing to highlight the advantages of our method. Throughout the paper, we denote the base field by  <span class="math">\\mathbb{F}</span> . Depending on context, this notion includes both  <span class="math">\\mathbb{F}_p</span>  for a prime p and/or  <span class="math">\\mathbb{F}_{2^n}</span> . We will also use the notions of polynomials and polynomial mappings interchangeably.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">2.1 From an Attack to a System of Equations</h4>

    <p class="text-gray-300">We first present the constrained-input constrained-output (CICO) problem, that we will focus on solving. It was initially proposed by the designers of Keccak [35] as a crucial problem for estimating the security of permutations used in sponge constructions. It can also be seen as a variant of the limited birthday problem [32]. A natural instance in the context of algebraic cryptanalysis may be stated in the following form.</p>

    <p class="text-gray-300">Problem 1 (CICO problem). Let  <span class="math">F : \\mathbb{F}^t \\longrightarrow \\mathbb{F}^t</span>  be a permutation and  <span class="math">1 \\le \\ell &lt; t</span>  an integer. The goal is to find  <span class="math">x \\in \\{0\\}^\\ell \\times \\mathbb{F}^{t-\\ell}</span>  such that  <span class="math">F(x) \\in \\{0\\}^\\ell \\times \\mathbb{F}^{t-\\ell}</span> .</p>

    <p class="text-gray-300">In this paper we will focus on the case  <span class="math">\\ell=1</span> . An attacker able to solve the CICO problem has control over both the input and output of the permutation, which is precisely what a good permutation is supposed to prevent. Furthermore, in our case, the value 0 in the output could be replaced e.g., by a digest d to immediately obtain a preimage attack.</p>

    <p class="text-gray-300"><em>Encoding.</em> To solve a CICO instance, we need to <em>model</em> or <em>encode</em> the problem into a system of polynomial equations. In symmetric cryptography, this is usually done iteratively by modelling one round after another, possibly adding new variables to keep the degree of the initial system low. The main challenge is</p>

    <p class="text-gray-300">encoding the cipher's non-linear operations in a form that may be amenable for cryptanalysis. For STAP ciphers, the existence of low-degree models is usually possible by design: while such systems can be leveraged for cryptanalysis, they are also required for a fast verification in many ZK protocols.</p>

    <p class="text-gray-300">Consider a non-linear function  <span class="math">S: \\mathbb{F}^t \\to \\mathbb{F}^t</span> , and let  <span class="math">S_0, ..., S_{t-1}</span>  be its coordinate functions. A trivial model of such a function would consist of t equations of the form  <span class="math">y_i = S_i(x_0, ..., x_{t-1})</span> . In this case, a tuple  <span class="math">(x_0, ..., x_{t-1}, y_0, ..., y_{t-1})</span>  is a solution of the system if and only if we indeed have y = S(x).</p>

    <p class="text-gray-300">This situation corresponds to the simplest case, where the model is simply the evaluation of the function. However, more sophisticated models can exist, as first pointed out by the authors of Rescue [5,45]. Indeed, the non-linear layer of this permutation involves both  <span class="math">x \\mapsto x^{\\alpha}</span>  and  <span class="math">x \\mapsto x^{1/\\alpha}</span> , where  <span class="math">\\alpha</span>  is a small integer. In this case, even though a non-linear function has a very high degree  <span class="math">(1/\\alpha</span>  being a dense integer of  <span class="math">\\mathbb{Z}/(p-1)\\mathbb{Z})</span> , it is possible to design a low-degree model by using the equation  <span class="math">x = y^{\\alpha}</span>  rather than  <span class="math">y = x^{1/\\alpha}</span> .</p>

    <p class="text-gray-300">More generally, all that is needed from a model is that it describes the graph of S, i.e., the set  <span class="math">\\Gamma_S = \\{(x,y) \\mid (x,y) \\in (\\mathbb{F}^t)^2, y = S(x)\\}</span> . In what follows, we focus on models corresponding to a system of multivariate polynomials  <span class="math">P = \\{p_0, \\ldots, p_{n-1}\\} \\subset \\mathbb{F}[x_0, \\ldots, x_{n-1}]</span> , which is associated with the following system of polynomial equations:</p>

    <p class="text-gray-300"><span class="math-block">p_i(x_0, \\dots, x_{n-1}) = 0</span>   <span class="math">1 \\le i \\le n-1</span> . (1)</p>

    <p class="text-gray-300">The polynomial systems we consider have a finite number of solutions in the algebraic closure of  <span class="math">\\mathbb{F}</span> , and are such that there exists a solution of P which directly leads to a solution of an associated CICO problem (or to a preimage of a given hash). In the remainder of this paper, we call <strong>sysGen</strong> the procedure used to generate a system of equation.</p>

    <p class="text-gray-300">If n=1, then P contains a unique equation of degree D in one variable, and we can use univariate techniques to solve the problem. In practice, such an attack needs a number of operations given by  <span class="math">\\mathcal{O}\\left((D(\\log(D) + \\log(p))\\log(\\log(D)))\\right)</span>  (see [10] for more details). We call the function returning the root(s) of a univariate polynomial uniSol.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">2.2 Finding Structures in a System of Equations</h4>

    <p class="text-gray-300">Once our attack is represented by a system of equations, we need to solve it. To this end, we need to better understand the structures implied by a system of polynomial equations. Indeed, in order to solve the system, we need to somehow derive equations sharing the solutions of the original system, and whose solutions can be computed in practice. We thus need to formally describe the set of multivariate polynomials that have the roots we are interested in.</p>

    <p class="text-gray-300">This set of polynomials is in fact an ideal  <span class="math">I = \\langle P \\rangle</span> , contained in the ring  <span class="math">R = \\mathbb{F}[x_0, \\dots, x_{n-1}]</span> . We denote  <span class="math">d_i</span>  the degree of equation  <span class="math">p_i</span> , and  <span class="math">D_I</span>  the ideal degree of I, <em>i.e.</em> the number of solutions of P in the algebraic closure of  <span class="math">\\mathbb{F}^n</span> , counted with multiplicity. In order to study this ideal, we need the notion of monomial order.</p>

    <p class="text-gray-300">Definition 1. A monomial order ≺ is a total order on the set of monomials of R such that i) for any monomial m ∈ R we have 1 ≺ m; and ii) for any three monomials m1, m2, t ∈ R we have</p>

    <p class="text-gray-300"><span id="page-5-2"></span> <span class="math-block">m_1 \\prec m_2 \\implies t \\cdot m_1 \\prec t \\cdot m_2</span> .</p>

    <p class="text-gray-300">The typical monomial orders used in computations are the lexicographical (lex) order and the graded reverse lexicographical (grevlex) order. We now define a particular weighted order which we will use throughout the paper.</p>

    <p class="text-gray-300">Definition 2. Consider a weight vector w = (w0, . . . , wn−1) ∈ R n , where w<sup>0</sup> ̸= 0. We say that w is associated with the monomial order ≺, defined by:</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_{i=0}^{n-1} x_i^{\\alpha_i} \\prec \\prod_{i=0}^{n-1} x_i^{\\beta_i} \\iff \\begin{cases} \\sum_{i=0}^{n-1} w_i \\alpha_i &lt; \\sum_{i=0}^{n-1} w_i \\beta_i \\\\ \\text{or} \\\\ \\exists k, \\quad \\sum_{i=0}^{n-1} w_i \\alpha_i = \\sum_{i=0}^{n-1} w_i \\beta_i, \\ \\forall j &gt; k, \\alpha_j = \\beta_j \\text{ and } \\alpha_k &lt; \\beta_k. \\end{cases}</span></div>

    <p class="text-gray-300">Technically speaking, this defines a weighted graded lexicographical (deglex) order with x<sup>0</sup> ≺ x<sup>1</sup> ≺ . . . ≺ xn−1. The particularities of this choice will be needed in Section <a href="#page-24-0">5.</a></p>

    <p class="text-gray-300">Definition 3. The leading monomial of a nonzero polynomial f ∈ R, relative to a monomial order ≺, is the largest monomial contained in f according to ≺. It is denoted LM(f). The leading coefficient of f, LC(f), is the coefficient associated with LM(f). Finally, the leading term of f, LT(f), is the product of its leading monomial and coefficient.</p>

    <p class="text-gray-300">If S = {f1, f2, . . .} ⊆ R, then we can extend the above definitions to the set S, e.g., LT(S) = {LT(f1), LT(f2), . . .}. We may now define the notion of a Gröbner basis of an ideal of R.</p>

    <p class="text-gray-300">Definition 4 (Gröbner basis [\\[15\\]](#page-32-8)). Let I be an ideal of R. A finite set of polynomials G ⊂ I is a Gröbner basis with respect to ≺ if the leading monomial of every polynomial in I is a multiple of the leading monomial of some polynomial in G. A Gröbner basis G is said to be reduced if for all g ∈ G, no monomial in g is divisible by an element of LT(G) \\ {LT(g)} and LC(G) = {1}.</p>

    <p class="text-gray-300"><span id="page-5-1"></span>An ideal I always contains a Gröbner basis. For a fixed ≺ there are usually many Gröbner bases, but only one reduced Gröbner bases. We will crucially rely on the following results throughout this paper.</p>

    <p class="text-gray-300"><span id="page-5-0"></span>Proposition 1 (<a href="#page-33-5">\\[21,</a> Chapter 2,§9, Prop 4 and Thm 3]). Let G be a set of polynomials of R, G = {g1, ..., gm}. If the leading monomials of g<sup>i</sup> and g<sup>j</sup> are relatively prime for all 1 ≤ i ̸= j ≤ m, then G is a Gröbner basis for ⟨G⟩.</p>

    <p class="text-gray-300">Proposition 2 (<a href="#page-33-5">\\[21,</a> Chapter 2 §6 Prop 1]). Let I be an ideal, ≺ a monomial order, G a Gröbner basis of I w.r.t. ≺, and f ∈ R. There exists a unique r ∈ R such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>LT(r) is not divisible by any element of LT(G).</li>

      <li>∃ g ∈ I, such that f = g + r.</li>

    </ul>

    <p class="text-gray-300">The polynomial r is called the remainder or normal form of f w.r.t. I and ≺.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2.3 Exploiting a Gröbner Basis</h2>

    <p class="text-gray-300">The characteristics of a Gröbner basis can vary greatly depending on the underlying monomial order. For our goal, that is finding solutions of P, one typically wants to compute a Gröbner basis of ⟨P⟩ in the lex order. However, computing a Gröbner basis directly in this order tends to be computationally expensive. Instead, it is common to first compute a Gröbner basis in the grevlex order – which tends to be significantly faster – and then apply a dedicated order-changing algorithm, such as FGLM or its variants <a href="#page-34-5">\\[28</a><a href="#page-33-6">,26,</a><a href="#page-33-7">27,</a>[43\\]](#page-35-3), to finally recover a basis in lex order. While we do not give a complete description of these algorithms, we nevertheless highlight some of the principles underpinning them, as they will be needed later for our own resolution algorithm.</p>

    <p class="text-gray-300">The Quotient Ring. Thanks to Proposition <a href="#page-5-0">2,</a> we can define the quotient ring R/I, where each class has a unique representative r such that LT(r) is not divisible by any element of a LT(I). The monomial order ≺ does not affect the quotient ring R/I, but determines the representative of each class. Macaulay's theorem <a href="#page-33-8">\\[25,</a> Theorem 15.3] states that the set of monomials in R \\ LT(I) form a basis for R/I.</p>

    <p class="text-gray-300">Definition 5. Let I be an ideal of R. We say that I is zero-dimensional if dimF(R/I) is finite. In this case, its ideal degree D<sup>I</sup> is dimF(R/I).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The quotient ring R/I has a canonical basis with respect to ≺ denoted B≺(R/I), where the basis elements are given by all the monomials in R that are not in the ideal ⟨LM(G)⟩, for G a Gröbner basis for I. If I is zero-dimensional, we have</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B≺(R/I)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= D<sup>I</sup> . Each element r of R/I can then be written as a vector in the basis B≺(R/I), which we will call NormalForm(r). This allows us to define the linear matrix T<sup>j</sup> : R/I → R/I corresponding to the multiplication by x<sup>j</sup> .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 6 (Multiplication matrix of x<sup>j</sup> ). The multiplication matrix T<sup>j</sup> of x<sup>j</sup> relative to a zero-dimensional ideal I, a monomial order ≺, and the basis B≺(R/I) = (ϵ1, . . . , ϵ<sup>D</sup><sup>I</sup> ) is defined as the square matrix which has each column defined as C<sup>i</sup> = ϵ<sup>i</sup> × x<sup>j</sup> represented in the basis B≺(R/I).</p>

    <p class="text-gray-300"><span id="page-6-0"></span>Said differently, T<sup>0</sup> is the D<sup>I</sup> × D<sup>I</sup> matrix mapping the basis elements ϵ<sup>i</sup> 7→ NormalForm(x0ϵi). The following result is well-known in the literature, but we have not been able to find a reference that holds for finite fields (e.g., it is derived as Corollary 4.6 in [\\[22\\]](#page-33-9) over C). For completeness, we provide a short proof that works over any field.</p>

    <p class="text-gray-300"><strong>Proposition 3.</strong> Let I be a zero-dimensional ideal of R,  <span class="math">\\prec</span>  a monomial order, and  <span class="math">T_0</span>  the multiplication matrix of the variable  <span class="math">x_0</span>  with respect to  <span class="math">\\prec</span> . We have  <span class="math">\\det(x_0I - T_0) \\in I</span> , where I is the identity matrix.</p>

    <p class="text-gray-300">Proof. Let  <span class="math">C(x) = \\det(x\\mathbf{I} - T_0) = \\sum_{i=0}^{D_I} c_i x^i</span>  be the characteristic polynomial of  <span class="math">T_0</span> . By the Cayley-Hamilton theorem we have  <span class="math">C(T_0) = \\sum_{i=0}^{D_I} c_i T_0^i = \\mathbf{0}</span> , where  <span class="math">\\mathbf{0}</span>  is the  <span class="math">D_I \\times D_I</span>  zero-matrix. Letting  <span class="math">\\epsilon</span>  denote the column vector representing the constant polynomial 1 in R/I, we then have  <span class="math">C(T_0)\\epsilon = 0</span> . As  <span class="math">T_0^i\\epsilon</span>  is the representation of NormalForm <span class="math">(x_0^i)</span> , this implies that NormalForm <span class="math">(C(x_0)) = 0</span> , hence  <span class="math">C(x_0) \\in I</span> .</p>

    <p class="text-gray-300">The next definition is a very standard and common hypothesis for an ideal when implementing Gröbner basis polynomial solving algorithms.</p>

    <p class="text-gray-300"><strong>Definition 7 ([26], Definition 3.1).</strong> An ideal I of R is in <strong>shape position</strong> if its reduced Gröbner basis in the lexicographical order has the following form</p>

    <div class="my-4 text-center"><span class="math-block">G = \\{ f_0(x_0), x_1 - f_1(x_0), \\dots, x_{n-1} - f_{n-1}(x_0) \\}.</span></div>

    <p class="text-gray-300">In this case, it follows straightforwardly that  <span class="math">D_I = \\deg(f_0)</span> , and the cost of finding solutions for I, given its lexicographic Gröbner basis, reduces to the problem of finding the roots of  <span class="math">f_0</span> .</p>

    <p class="text-gray-300">In this section, we present our own custom approach to algebraic attacks, which is applicable to solve CICO instances for some arithmetization-oriented permutations (see Section 4). As with the algebraic attacks we presented in the previous section, we first need to describe our problem using a system of polynomial equations. We start with a description of the general form of systems for which a Gröbner basis can be obtained for free (see Section 3.1). Then, we show how to deduce a univariate polynomial from this system in Section 3.2. Means to create these polynomial systems for various primitives are discussed in Sections 3.3 and 3.4, where we reuse and generalize an encoding technique introduced by the authors of Griffin in a way that can be applied to iterated functions. The entire solving strategy is summarized in Section 3.5.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">3.1 FreeLunch Systems</h4>

    <p class="text-gray-300">We saw in Proposition 1 that there is a class of polynomial systems that admits a simple Gröbner basis. This is the motivation for the following definition.</p>

    <p class="text-gray-300"><strong>Definition 8 (FreeLunch System).</strong> Let R be the ring  <span class="math">\\mathbb{F}[x_0,\\ldots,x_{n-1}]</span>  and  <span class="math">P=\\{p_0,\\ldots,p_{n-1}\\}</span>  be a sequence of polynomials of R. We say that P is a <strong>FreeLunch system</strong> if there exists a monomial order  <span class="math">\\prec</span>  and integers  <span class="math">(\\alpha_0,\\ldots,\\alpha_{n-1})</span>  such that for all  <span class="math">i\\in\\{0,\\ldots,n-1\\}</span> ,  <span class="math">\\mathrm{LM}_{\\prec}(p_i)=x_i^{\\alpha_i}</span> . Any monomial order  <span class="math">\\prec</span>  that verifies this property is said to be a FreeLunch order.</p>

    <p class="text-gray-300">Note that this is not the first time Proposition <a href="#page-5-1">1</a> has been used in cryptography. In [\\[16\\]](#page-33-10), the authors describe a polynomial modeling for AES that can be said to be a FreeLunch system in a graded lex order. However, the ensuing change of order computation to a lex order is too costly to threaten the security of AES. The following properties are now easy to verify, and were also used in [\\[16\\]](#page-33-10).</p>

    <p class="text-gray-300">Proposition 4. A FreeLunch system P is a Gröbner basis for the ideal I = ⟨P⟩ with respect to any of its FreeLunch orders. Moreover, I is zero-dimensional and n</p>

    <p class="text-gray-300">of ideal degree <span class="math-block">D_I = \\prod_{i=0}^{n-1} \\alpha_i</span> .</p>

    <p class="text-gray-300">Proof. The first statement follows directly from Proposition <a href="#page-5-1">1.</a> For the latter statement, note that the canonical basis of R/I (w.r.t. a FreeLunch order ≺) is</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{B}_{\\prec}(R/I) = \\{x_0^{i_0} \\cdots x_{n-1}^{i_{n-1}} \\mid 0 \\le i_j &lt; \\alpha_j, \\text{ for } 0 \\le j \\le n-1\\}.</span></div>

    <p class="text-gray-300">Counting all these basis elements yields D<sup>I</sup> . ⊓⊔</p>

    <p class="text-gray-300">We conceived a dedicated algorithm for the resolution of FreeLunch systems, which has a competitive time complexity. The following result will be proven in Section <a href="#page-8-0">3.2,</a> where 2 ≤ ω ≤ 3 denotes the linear algebra exponent.</p>

    <p class="text-gray-300">Theorem 1. Given a FreeLunch system P, a FreeLunch order ≺, and the associated multiplication matrix T<sup>0</sup> of the variable x0, there exists an algorithm to compute a solution for x<sup>0</sup> with time complexity</p>

    <p class="text-gray-300"><span id="page-8-1"></span> <span class="math-block">\\tilde{\\mathcal{O}}\\left(\\alpha_0 \\left(\\prod_{i=1}^{n-1} \\alpha_i\\right)^{\\omega}\\right) .</span></p>

    <h2 id="sec-9" class="text-2xl font-bold">3.2 Extracting a Univariate Equation from a FreeLunch System</h2>

    <p class="text-gray-300">We now turn to the problem of solving a FreeLunch system, with the aim of showing Theorem <a href="#page-8-1">1.</a> As we will see in later sections, a FreeLunch system is typically only already a Gröbner basis under specially crafted monomial orders. To easily retrieve the solutions of a FreeLunch system, we look for a univariate polynomial belonging to the ideal spawned by the system. To do so, a common approach is to compute a Gröbner basis in the lex order. Given an initial Gröbner basis, computing a lex Gröbner basis can be performed using a change of order algorithm.</p>

    <p class="text-gray-300">Existing change of order algorithms. The FGLM algorithm [\\[28\\]](#page-34-5) provides an efficient method for changing the monomial orders of Gröbner bases of zerodimensional ideals, with a running time of O(nD<sup>3</sup> I ) operations and no conditions on the Gröbner bases, on the monomial order or on the ideal. Note that this cost includes computing the multiplication matrix T0.</p>

    <p class="text-gray-300">Later algorithms <a href="#page-33-6">\\[26,</a><a href="#page-33-7">27</a><a href="#page-35-3">,43,</a>[11\\]](#page-32-6) significantly improve upon this running time, but require various assumptions on the input basis and underlying ideal. For instance, [26,27,11] assume that the multiplication matrix  <span class="math">T_0</span>  is either given, or can be efficiently computed. Note that the latter is a consequence of the stability property (see [11, Definition 2.1]), which is assumed in some of these works. Unfortunately, FreeLunch systems do not generally satisfy this property. In fact, the authors of [11] state that when the base field is large enough and the ideal under consideration is radical, the stability property can be ensured through a generic linear change of coordinates. The issue is that doing so might transform the FreeLunch system into a different type of system that is not a Gröbner basis.</p>

    <p class="text-gray-300">We briefly recall the effectiveness of the change of order algorithms assuming that  <span class="math">T_0</span>  is given and that the ideal is in shape position. In this case, the algorithm of [27] runs in  <span class="math">\\mathcal{O}(D_I^\\omega \\log(D_I))</span>  and supposes that the input order is grevlex and the output order is lex. [43] runs in  <span class="math">\\mathcal{O}(nD_I^\\omega \\log(D_I))</span>  with no additional hypothesis, and achieve  <span class="math">\\mathcal{O}(D_I^\\omega \\log(D_I))</span>  when the ideal is in shape position. In our case, we are particularly interested in some algorithms that benefit from the sparsity of  <span class="math">T_0</span> , represented by its sparsity indicator t. The algorithm of [26, Theorem 3.2] for example runs in  <span class="math">\\mathcal{O}(tD_I^2)</span> . The algorithm of [11] achieves an even better time complexity, of  <span class="math">\\tilde{\\mathcal{O}}(t^{\\omega-1}D_I)</span> , if the input order is grevlex and the output order is lex. However, it is not clear to us if the ideas as presented in [11] can be directly generalized to our setting, i.e. with a weighted input monomial order, even if  <span class="math">T_0</span>  is given. Instead, we will develop a dedicated resolution algorithm from a basis in a FreeLunch order when  <span class="math">T_0</span>  is given, whose running time happens to coincide with that of [11]  <span class="math">(\\tilde{\\mathcal{O}}(t^{\\omega-1}D_I))</span> .</p>

    <p class="text-gray-300">A new approach. From the above discussion we see that while the original FGLM algorithm is applicable to the FreeLunch systems we are interested in, the improved variants are generally not. This motivated the design of a new dedicated algorithm for finding a univariate polynomial  <span class="math">f_0(x_0)</span>  belonging to the ideal, exploiting the sparsity of the multiplication matrix  <span class="math">T_0</span> .</p>

    <p class="text-gray-300">Let I be a zero-dimensional ideal of  <span class="math">R = \\mathbb{F}[x_0, \\dots, x_{n-1}]</span> ,  <span class="math">\\prec</span>  a monomial order giving a FreeLunch system,  <span class="math">\\mathcal{B}_{\\prec} = (\\epsilon_1, \\dots, \\epsilon_{D_I})</span>  the canonical basis of R/I, and  <span class="math">T_0</span>  the multiplication matrix corresponding to the variable  <span class="math">x_0</span> . Let H be the subspace of R/I containing the classes h of R/I where the unique representative of h with respect to  <span class="math">\\prec</span>  does not contain the variable  <span class="math">x_0</span> . Let  <span class="math">D_H</span>  be the dimension of H and  <span class="math">\\mathcal{B}_{\\prec}^H = [\\phi_1, \\dots, \\phi_{D_H}]</span>  be a canonical basis for the subspace H. It is clear that  <span class="math">\\mathcal{B}_{\\prec}^H</span>  exactly consists of the monomials m of  <span class="math">\\mathcal{B}_{\\prec}</span>  such that  <span class="math">x_0 \\nmid m</span> . Thus, it</p>

    <p class="text-gray-300">holds that <span class="math-block">D_H = \\prod_{i=1}^{n-1} \\alpha_i = D_I/\\alpha_0</span> . We order the basis  <span class="math">\\mathcal{B}_{\\prec}</span>  specifically as</p>

    <div class="my-4 text-center"><span class="math-block">[\\phi_1,\\ldots,\\phi_{D_H}, x_0\\phi_1,\\ldots,x_0\\phi_{D_H}, x_0^2\\phi_1,\\ldots,x_0^2\\phi_{D_H},\\ldots,x_0^{\\alpha_0-1}\\phi_1,\\ldots,x_0^{\\alpha_0-1}\\phi_{D_H}],</span></div>

    <p class="text-gray-300"><span id="page-9-0"></span>and identify any polynomial  <span class="math">f \\in R/I</span>  with its coefficient vector  <span class="math">v_f</span>  of length  <span class="math">D_I</span> . The coefficient vector for the polynomial  <span class="math">x_0 f \\in R/I</span>  can then be computed as a matrix/vector multiplication  <span class="math">T_0 v_f^{\\top}</span>  for a fixed matrix  <span class="math">T_0</span> . The following lemma gives the structure of  <span class="math">T_0</span> .</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Under the basis  <span class="math">\\mathcal{B}_{\\prec}</span> , the matrix  <span class="math">T_0</span>  is of the following form, represented as a block matrix with block sizes  <span class="math">D_H \\times D_H</span> :</p>

    <div class="my-4 text-center"><span class="math-block">T_0 = \\begin{pmatrix} 0 &amp; 0 &amp; \\dots &amp; 0 &amp; -M_0 \\\\ \\mathbf{I} &amp; 0 &amp; \\dots &amp; 0 &amp; -M_1 \\\\ \\vdots &amp; \\ddots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\ 0 &amp; \\dots &amp; 0 &amp; \\mathbf{I} &amp; -M_{\\alpha_0 - 1} \\end{pmatrix}.</span></div>

    <p class="text-gray-300">The block matrices  <span class="math">M_0, \\ldots, M_{\\alpha_0-1}</span>  are a representation of the reduction of  <span class="math">x_0^{\\alpha_0} \\mathcal{B}_{\\prec}^H</span>  modulo I. The exact entries in the  <span class="math">M_i</span>  matrices depend on the particular polynomials making up the Gröbner basis for the FreeLunch system. We call matGen the procedure which, given a basis  <span class="math">\\mathcal{B}_{\\prec}</span> , returns  <span class="math">T_0</span> .</p>

    <p class="text-gray-300">From Proposition 3 it follows that  <span class="math">\\det(x_0 \\mathbf{I}_{D_I} - T_0)</span>  is a univariate polynomial belonging to the ideal I. Computing this determinant and using a root-finding algorithm to solve  <span class="math">\\det(x_0 \\mathbf{I}_{D_I} - T_0) = 0</span>  will finally give us a value for  <span class="math">x_0</span>  that solves the CICO problem. The following lemma shows that computing this determinant of this particularly structured matrix  <span class="math">T_0</span>  can be done with much lower complexity than for a generic matrix of dimension  <span class="math">D_I</span> .</p>

    <p class="text-gray-300"><span id="page-10-0"></span><strong>Lemma 2.</strong> Let  <span class="math">M_0, \\ldots, M_{\\alpha_0-1}</span>  be the matrices defined in Lemma 1. We have</p>

    <div class="my-4 text-center"><span class="math-block">\\det(x_0 \\mathbf{I}_{D_I} - T_0) = \\pm \\det \\left( x_0^{\\alpha_0} \\mathbf{I}_{D_H} + \\sum_{i=0}^{\\alpha_0 - 1} x_0^i M_i \\right) .</span></div>

    <p class="text-gray-300">Proof.</p>

    <div class="my-4 text-center"><span class="math-block">\\det(x_0 \\mathbf{I}_{D_I} - T_0) = \\det \\begin{pmatrix} x_0 \\mathbf{I} &amp; 0 &amp; \\dots &amp; 0 &amp; M_0 \\\\ -\\mathbf{I} &amp; x_0 \\mathbf{I} &amp; \\dots &amp; 0 &amp; M_1 \\\\ \\vdots &amp; \\ddots &amp; \\ddots &amp; 0 &amp; \\vdots \\\\ 0 &amp; 0 &amp; -\\mathbf{I} &amp; x_0 \\mathbf{I} &amp; M_{\\alpha_0 - 2} \\\\ 0 &amp; 0 &amp; 0 &amp; -\\mathbf{I} &amp; x_0 \\mathbf{I} + M_{\\alpha_0 - 1} \\end{pmatrix}.</span></div>

    <p class="text-gray-300">The rows of this matrix can be split into a set of  <span class="math">\\alpha_0</span>  blocks of  <span class="math">D_H</span>  rows each. Denote these blocks as  <span class="math">L_0, \\ldots, L_{\\alpha_0-1}</span>  from top to bottom. We now do elementary row operations block-wise, from bottom to the top, with  <span class="math">L_i = L_i + x_0 L_{i+1}</span> , for  <span class="math">i = \\alpha_0 - 2, \\ldots, 0</span> . This does not change the value of the determinant, and after these row operations, the resulting determinant to compute is:</p>

    <div class="my-4 text-center"><span class="math-block">\\det \\begin{pmatrix} 0 &amp; 0 &amp; \\dots &amp; 0 &amp; x_0^{\\alpha_0} \\mathbf{I} + \\sum_{i=0}^{\\alpha_0 - 1} x_0^i M_i \\\\ -\\mathbf{I} &amp; 0 &amp; \\dots &amp; 0 &amp; x_0^{\\alpha_0 - 1} \\mathbf{I} + \\sum_{i=0}^{\\alpha_0 - 2} x_0^i M_{i+1} \\\\ \\vdots &amp; \\ddots &amp; \\ddots &amp; \\vdots &amp; &amp; \\vdots \\\\ 0 &amp; \\dots &amp; -\\mathbf{I} &amp; 0 &amp; x_0^2 \\mathbf{I} + \\sum_{i=0}^1 x_0^i M_{i+\\alpha_0 - 2} \\\\ 0 &amp; \\dots &amp; 0 &amp; -\\mathbf{I} &amp; x_0 \\mathbf{I} + M_{\\alpha_0 - 1} \\end{pmatrix}.</span></div>

    <p class="text-gray-300">In this block matrix representation, the determinant of the full matrix is the determinant of the top right matrix, up to the sign  <span class="math">(-1)^{\\alpha_0+1}</span> .</p>

    <p class="text-gray-300">Complexity Analysis. We call polyDet the procedure returning the polynomial  <span class="math">\\det(x_0 \\mathbf{I}_{D_I} - T_0)</span>  using Lemma 2. This step has a complexity  <span class="math">\\tilde{\\mathcal{O}}(D_I D_H^{\\omega-1}) = \\tilde{\\mathcal{O}}(\\alpha_0 D_H^{\\omega})</span>  with the algorithm of [39]. Note that this is precisely the complexity that was obtained with the algorithm of [11] for systems satisfying the stability and shape position properties. In order to estimate the logarithmic factors in the complexity formula, we bound the complexity with [33, Theorem 4.4], using a polynomial matrix multiplication algorithm of complexity  <span class="math">\\mathcal{O}(D_H^{\\omega}\\log(\\alpha_0) + D_H^2\\log(\\alpha_0)\\log(\\log(\\alpha_0)))</span>  [19]. This way, we bound the number of operations of polyDet with (when  <span class="math">D_H</span>  is large):</p>

    <p class="text-gray-300"><span id="page-11-3"></span> <span class="math-block">\\mathcal{O}\\left(\\alpha_0 \\log(\\alpha_0)^2 D_H^{\\omega} + \\alpha_0 \\log(\\alpha_0)^2 \\log(\\log(\\alpha_0)) D_H^2\\right) \\approx \\mathcal{O}(\\alpha_0 \\log(\\alpha_0)^2 D_H^{\\omega}) . \\tag{2}</span></p>

    <p class="text-gray-300">The remaining task to show Theorem 1 is to recover the roots of a univariate polynomial of degree  <span class="math">D_I</span> , a step we refer to as uniSol. This costs  <span class="math">\\tilde{\\mathcal{O}}(D_I)</span>  operations and is thus negligible in comparison with the polyDet step.</p>

    <p class="text-gray-300">We want to highlight that the complexity of the matGen step is hard to estimate precisely (recall that  <span class="math">T_0</span>  is assumed known in Theorem 1). This step can be upper bounded by  <span class="math">\\mathcal{O}\\left(nD_I^3\\right)</span>  operations [28, Proposition 3.1] using the FGLM algorithm. However, this is likely to be a loose upper bound, as it does not take into account any of the underlying structure. Indeed, we have observed this in our experiments by naively taking some of this structure into account (see Appendix G). Still, as we will see later, the matGen step can sometimes be costlier than polyDet.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">3.3 Ordering a FreeLunch</h4>

    <p class="text-gray-300">Having seen how to efficiently find solutions for FreeLunch systems, we will focus in the next two subsections on the problem of actually finding them. Recall that FreeLunch systems rely on the existence of specific monomial orders. How can we figure out if such an order exists (and thus, if a system is a FreeLunch)? In general, answering this question is not trivial. However, the systems we will be concerned with in Sections 4 and 5 naturally have a deeper structural property that allows for a procedural approach to this problem.</p>

    <p class="text-gray-300"><strong>Definition 9 (Triangular System).</strong> Let  <span class="math">P = (p_1, \\ldots, p_{n-1}, g)</span>  be a polynomial system in  <span class="math">\\mathbb{F}[x_0, x_1, \\ldots, x_{n-1}]</span> . We say that P is a <strong>triangular system</strong> if there exists polynomials  <span class="math">q_0, q_1, \\ldots, q_{n-1}</span> , integers  <span class="math">\\alpha_0, \\alpha_1, \\ldots, \\alpha_{n-1}</span> , and  <span class="math">c_0, \\ldots, c_{n-1} \\in \\mathbb{F} \\setminus \\{0\\}</span>  such that</p>

    <p class="text-gray-300"><span id="page-11-2"></span><span id="page-11-1"></span> <span class="math-block">\\begin{cases} p_i = c_i x_i^{\\alpha_i} + q_i(x_0, \\dots, x_{i-1}) &amp; \\text{for } 1 \\le i \\le n-1, \\\\ g = c_0 x_0^{\\alpha_0} + q_0(x_0, \\dots, x_{n-1}). \\end{cases}</span></p>

    <p class="text-gray-300">A triangular system P can be assigned the following monomial order that is naturally motivated by the FreeLunch definition.</p>

    <p class="text-gray-300"><strong>Construction 1</strong> For a triangular system P, we define its triangular order,  <span class="math">\\prec_T</span> , as the monomial order from Def. 2 associated with the weight vector defined recursively by:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{cases} \\operatorname{wt}(x_0) &amp;= 1, \\\\ \\operatorname{wt}(x_i) &amp;= \\operatorname{wt} \\left( \\operatorname{LM}_{\\prec_T} \\left( q_i(x_0, x_1, \\dots, x_{i-1}) \\right) \\right) / \\alpha_i &amp; \\text{for } 1 \\leq i \\leq n-1. \\end{cases}</span></div>

    <p class="text-gray-300">The recursion is well-defined since the leading monomial of  <span class="math">q_i</span>  and its associated weight are only dependent on the weights of  <span class="math">x_j</span>  for j < i. The definition ensures that  <span class="math">LM_{\\prec T}(p_i) = x_i^{\\alpha_i}</span>  for  <span class="math">1 \\le i \\le n-1</span> . Hence, a triangular system P is a FreeLunch system with respect to  <span class="math">\\prec_T</span>  if the leading monomial of g is univariate in  <span class="math">x_0</span> , which gives the following Proposition:</p>

    <p class="text-gray-300"><span id="page-12-3"></span><strong>Proposition 5 (Ordering a FreeLunch).</strong> Let P be a triangular system, and  <span class="math">\\prec_T</span>  be its triangular order. If  <span class="math">\\alpha_0 &gt; \\text{wt}(\\text{LM}_{\\prec_T}(q_0(x_0, \\ldots, x_{n-1})))</span>  then P is a FreeLunch system and  <span class="math">\\prec_T</span>  is one of its FreeLunch orders.</p>

    <p class="text-gray-300">As we will see below, such systems naturally occur when investigating some cryptographic permutations.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">3.4 FreeLunch Systems From Iterated Functions</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The permutations we target share the same structure: a composition of a number of round functions. The input and output of every round is a state of t elements from  <span class="math">\\mathbb F</span>  and the round functions typically consist of a limited number of multiplications and  <span class="math">\\alpha</span> -th roots in  <span class="math">\\mathbb F</span> . Writing them out directly as polynomial functions yields polynomials of high degree, owing to the  <span class="math">\\alpha</span> -th root operations. A natural modeling strategy introduces a new variable for each of them to keep the degree growth manageable, as  <span class="math">x=y^{\\alpha}</span>  is of much lower degree than  <span class="math">y=x^{1/\\alpha}</span>  when  <span class="math">\\alpha \\in \\{3,5,...,257\\}</span>  and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  is large. In this section, we take inspiration from an encoding suggested by the authors of Griffin [34] and show how to model this class of primitives as polynomials that form a low degree FreeLunch system.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-12-2"></span><img src="_page_12_Figure_7.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 1: Triangular system for a simple SPN with two branches and two rounds.</p>

    <p class="text-gray-300"><span id="page-12-1"></span> <span class="math">&lt;sup&gt;^{8}&lt;/sup&gt;</span>  We say that the permutation has t branches, or as we like to think of them, brunches.</p>

    <p class="text-gray-300"><strong>Toy Example.</strong> Let us start with a toy SPN of two rounds, where the round function F is given by  <span class="math">F = S \\circ A : \\mathbb{F}^2 \\to \\mathbb{F}^2</span> , for an invertible affine layer A and a non-linear layer S. Moreover, we write  <span class="math">S = (S_1, S_2)</span>  where  <span class="math">S_1(y) = y^d</span> , for a small integer d, and  <span class="math">S_2(y) = y^{1/\\alpha}</span> . This simple construction is shown in Figure 1, where we also label the branches with variables and polynomials at different points. We consider a CICO problem with input  <span class="math">(0, x_0)</span> .</p>

    <p class="text-gray-300">As we assume  <span class="math">d \\ll p</span> , we note that the round function F can only achieve a high degree as a polynomial function  <span class="math">\\mathbb{F}^2 \\to \\mathbb{F}^2</span>  due to the map  <span class="math">S_2</span> . Thus, we introduce new variables  <span class="math">x_1</span>  and  <span class="math">x_2</span>  for the output of  <span class="math">S_2</span>  in the first and second rounds, respectively. The polynomials  <span class="math">p_1, p_2</span>  relate the symbolic input and output of the two  <span class="math">S_2</span> -functions, where  <span class="math">q_1</span>  is an affine polynomial in  <span class="math">x_0</span>  that is input to  <span class="math">S_2</span>  in the first round, and  <span class="math">q_2(x_0, x_1)</span>  is the input to  <span class="math">S_2</span>  in the second round and has degree d in the  <span class="math">x_0</span> -variable and degree 1 in the  <span class="math">x_1</span> -variable. Finally, we let  <span class="math">g(x_0, x_1, x_2)</span>  represent the first output of the construction that is required to be 0 by the CICO-problem. We can now write q as</p>

    <div class="my-4 text-center"><span class="math-block">g(x_0, x_1, x_2) = c_0 x_0^{d^2} + q_0(x_0, x_1, x_2),</span></div>

    <p class="text-gray-300">for a suitable constant  <span class="math">c_0 \\in \\mathbb{F}</span> , and where  <span class="math">q_0(x_0, x_1, x_2)</span>  has degree d in  <span class="math">x_0</span> , degree d in  <span class="math">x_1</span>  and degree 1 in  <span class="math">x_2</span> . If  <span class="math">c_0 \\neq 0</span>  we observe that  <span class="math">P = \\{p_1, p_2, g\\}</span>  forms a triangular system (Definition 9), whose solutions yield a solution to the specified CICO-problem. The weight vector of  <span class="math">\\prec_T</span>  from Construction 1 is  <span class="math">(1, 1/\\alpha, d/\\alpha)</span> , and it is straightforward to verify that P satisfies the condition of Proposition 5. Hence, P is a FreeLunch system.</p>

    <p class="text-gray-300"><strong>General Case.</strong> The above example shows the core idea for how a FreeLunch system can be made from a round function that relies on the functional inverse of low degree function to achieve a high degree. Let us generalize this insight. Let  <span class="math">F_i: \\mathbb{F}^t \\to \\mathbb{F}^t</span> ,  <span class="math">\\mathbf{z}_{i-1} \\mapsto \\mathbf{z}_i</span> , denote the <em>i</em>-th round of a primitive, where  <span class="math">\\mathbf{z}_{i-1} = (z_{i-1,0}, \\ldots, z_{i-1,t-1})</span>  is the state after i-1 rounds. Recall that  <span class="math">F_i</span>  may itself have a high degree (in  <span class="math">\\mathbf{z}_{i-1}</span> ), but suppose there exists a set of variables  <span class="math">\\mathbf{x}_i = \\{x_{i,0}, \\ldots, x_{i,\\ell_i-1}\\}</span>  satisfying</p>

    <p class="text-gray-300"><span id="page-13-1"></span><span id="page-13-0"></span> <span class="math-block">x_{i,j}^{\\alpha_{i,j}} = \\mathcal{L}_{i,j}(\\boldsymbol{z}_{i-1}), \\text{ for } 0 \\le j &lt; \\ell_i,</span> (3)</p>

    <p class="text-gray-300">where  <span class="math">\\alpha_{i,j}</span>  is an integer and  <span class="math">\\mathcal{L}_{i,j}</span>  an affine function. Moreover, suppose that there exists a polynomial function  <span class="math">G_i : \\mathbb{F}^{t+\\ell_i} \\to \\mathbb{F}^t</span>  of low degree  <span class="math">d_i</span> , satisfying</p>

    <p class="text-gray-300"><span class="math-block">F_i(\\boldsymbol{z}_{i-1}) = \\{ G_i(\\boldsymbol{z}_{i-1}, \\boldsymbol{x}_i) \\mid \\boldsymbol{x}_i \\text{ satisfies } (3) \\}.</span>  (4)</p>

    <p class="text-gray-300">In other words, while  <span class="math">F_i</span>  and  <span class="math">G_i</span>  are different as polynomial functions, they yield the same output when  <span class="math">x_i</span>  is restricted by (3). For instance, in the toy example above, we used</p>

    <div class="my-4 text-center"><span class="math-block">G_1(z_0, x_1) = ((A_1(z_0))^d, x_1), \\qquad G_2(z_1, x_2) = ((A_1(z_1))^d, x_2),</span></div>

    <p class="text-gray-300">where  <span class="math">A_1</span>  denotes the first output of A.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Polynomial Modeling. We now have an iterated function of t branches where each round can be described using the functions G = {G1, . . . , Gr} satisfying <a href="#page-13-0">\\(3\\)</a> and <a href="#page-13-1">\\(4\\)</a>, and where G<sup>i</sup> is of degree d<sup>i</sup> . We introduce the shorthand d≤<sup>i</sup> = d1d<sup>2</sup> · · · d<sup>i</sup> , and we require that the exponents d<sup>i</sup> are small enough to ensure that their composition will not exceed the maximal degree determined by the finite field, i.e. d≤<sup>r</sup> <</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">− 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">With this in place, we give the following blueprint for constructing a polynomial system. Recall that we focus on the variant of the CICO-problem where a single input in F is unknown, which we will symbolically denote by x0, and the output of the first branch should be 0. The initial state is written as z0(x0), which consists of t affine polynomials in x0. The proceeding state is defined as z1(x0, x1) = G1(z0, x1), where we note that z<sup>1</sup> is now t polynomials of at most degree d<sup>1</sup> in the variables x0, x1. Furthermore, we create functions p<sup>1</sup> = {p1,0, . . . , p1,ℓ1−1} to encode the relations <a href="#page-13-0">\\(3\\)</a> that we encounter in this step. That is, for x<sup>1</sup> = {x1,0, . . . , x1,ℓ1−1}, we construct the polynomials</p>

    <div class="my-4 text-center"><span class="math-block">p_{1,j} = x_{1,j}^{\\alpha_{1,j}} - \\mathcal{L}_{1,j}(\\boldsymbol{z}_0), \\text{ for } 0 \\leq j &lt; \\ell_1 \\ .</span></div>

    <p class="text-gray-300">This process of updating the state z<sup>i</sup> and constructing polynomials<a href="#page-14-0">9</a> p<sup>i</sup> is repeated for all rounds up to r − 1. In the last round, we generate polynomials p<sup>r</sup> as before, but instead of updating the state, we compute the final polynomial</p>

    <p class="text-gray-300"><span id="page-14-1"></span> <span class="math-block">g(x_0, x_1, \\dots, x_r) = [G_r(z_{r-1}, x_r)]_1,</span></p>

    <p class="text-gray-300">where [·]<sup>1</sup> means the first polynomial of Gr(zr−1, xr). This construction yields the polynomial system P<sup>G</sup> = {p<sup>1</sup> , . . . , p<sup>r</sup> , g} over the ring F[x0, x1, . . . , xr].</p>

    <p class="text-gray-300">P<sup>G</sup> as a FreeLunch system. It is easy to verify that P<sup>G</sup> is a triangular system if g contains a univariate monomial in x0. In fact, this is a stronger case than the generic triangular systems considered in Section <a href="#page-11-0">3.3,</a> since we are also able to bound the degrees of the polynomials in P<sup>G</sup> by round degrees d1, . . . , dr. This allows us to give an analogous variant of Proposition <a href="#page-12-3">5</a> for PG. Instead of a condition on the entire system that could be computationally expensive to verify, we reduce the assumption to the condition of a single monomial in g.</p>

    <p class="text-gray-300">Proposition 6. Let P<sup>G</sup> be a polynomial system as constructed above, where all αi,j from <a href="#page-13-0">\\(3\\)</a> are at least 2, and the functions G = {G1, . . . , Gr} are of degrees d1, . . . , d<sup>r</sup> ≥ 2. Then P<sup>G</sup> is a FreeLunch system if g contains the monomial x d≤<sup>r</sup> 0 .</p>

    <p class="text-gray-300">Before proving the proposition, we start by defining ≺G, which is the monomial order from Definition <a href="#page-5-2">2</a> whose weight vector is given by</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{cases} \\operatorname{wt}(x_0) &amp;= 1 ,\\\\ \\operatorname{wt}(x_{i,j}) &amp;= d_{\\leq i-1}/\\alpha_{i,j} &amp; \\text{for } 1 \\leq i \\leq r \\text{ and } 1 \\leq j \\leq \\ell_i , \\end{cases}</span></div>

    <p class="text-gray-300"><span id="page-14-0"></span><sup>9</sup> If a single variable is introduced in a round, we will ease notation by writing x<sup>i</sup> = xi, p<sup>i</sup> = p<sup>i</sup> and αi.</p>

    <p class="text-gray-300">where we define  <span class="math">d_{\\leq 0} = 1</span> . Recall that  <span class="math">z_i</span>  denotes the <em>i</em>-th state represented by t polynomials in  <span class="math">x_0, x_1, \\ldots, x_i</span> . We will write wt(LM( <span class="math">z_i</span> )) for the maximal weight among the monomials of these t polynomials.</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> Let  <span class="math">z_i</span>  be the <em>i</em>-th state associated with a system  <span class="math">\\mathcal{G}</span>  that satisfies the conditions of Proposition 6. Then the following inequality holds for  <span class="math">\\prec_{\\mathcal{G}}</span> :</p>

    <p class="text-gray-300"><span id="page-15-0"></span> <span class="math-block">\\operatorname{wt}\\left(\\operatorname{LM}(\\boldsymbol{z}_i)\\right) \\leq d_{\\leq i}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We proceed by induction. The base case of i=0 is immediate since  <span class="math">z_0</span>  is affine in  <span class="math">x_0</span> , and  <span class="math">d_{\\leq 0}=1</span>  by definition. For the induction step, we recall that  <span class="math">z_i=G_i(z_{i-1},x_i)</span> , where  <span class="math">G_i</span>  has degree  <span class="math">d_i</span> . Thus we have</p>

    <p class="text-gray-300"><span class="math-block">\\operatorname{wt}(\\operatorname{LM}(\\boldsymbol{z}_i)) \\leq d_i \\cdot \\max\\{\\operatorname{wt}(\\operatorname{LM}(\\boldsymbol{z}_{i-1})), \\operatorname{wt}(x_{i,1}), \\dots, \\operatorname{wt}(x_{i,\\ell_i})\\}</span> .</p>

    <p class="text-gray-300">Now we have  <span class="math">\\operatorname{wt}(x_{i,j}) &lt; d_{\\leq i-1}</span> , and  <span class="math">\\operatorname{wt}(\\operatorname{LM}(\\boldsymbol{z}_{i-1})) \\leq d_{\\leq i-1}</span>  by the induction hypothesis. Hence</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{wt}(\\operatorname{LM}(\\boldsymbol{z}_i)) \\le d_i d_{\\le i-1} = d_{\\le i} . \\qquad \\Box</span></div>

    <p class="text-gray-300">The proof of this lemma also implies that  <span class="math">\\prec_{\\mathcal{G}}</span>  coincides with  <span class="math">\\prec_{T}</span>  from Construction 1 if all functions  <span class="math">\\mathcal{L}_{i,j}(\\boldsymbol{z}_{i-1})</span>  achieve their maximal weight  <span class="math">d_{\\leq i-1}</span> . We now have all we need to show Proposition 6.</p>

    <p class="text-gray-300"><em>Proof.</em> (Proposition 6). From Lemma 3 we observe</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{wt}\\left(x_{i,j}^{\\alpha_{i,j}}\\right) = \\alpha_{i,j}\\operatorname{wt}\\left(x_{i,j}\\right) = d_{\\leq i-1}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\geq \\operatorname{wt}(\\operatorname{LM}(\\boldsymbol{z}_{i-1})) \\geq \\operatorname{wt}(\\operatorname{LM}(\\mathcal{L}_{i,j}(\\boldsymbol{z}_{i-1}))).</span></div>

    <p class="text-gray-300">Hence LM  <span class="math">(f_{i,j}) = x_{i,j}^{\\alpha_{i,j}}</span> . Moreover, Lemma 3 also guarantees that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{wt}(\\operatorname{LM}(g)) \\leq \\operatorname{wt}(\\operatorname{LM}(\\boldsymbol{z}_r)) \\leq d_{\\leq r}.</span></div>

    <p class="text-gray-300">Due to the fact that  <span class="math">\\alpha_{i,j} \\geq 2</span> , the factor  <span class="math">1/\\alpha_{i,j}</span>  that appears in the weight of all variables  <span class="math">\\boldsymbol{x}_i, \\ i \\geq 1</span> , the above equality can only be achieved by the monomial  <span class="math">x_0^{d \\leq r}</span> . It then follows from the assumption that  <span class="math">\\mathrm{LM}(g) = x_0^{d \\leq r}</span> , which makes  <span class="math">P_{\\mathcal{G}}</span>  a FreeLunch system.</p>

    <p class="text-gray-300">Computing a reduced Gröbner Basis for  <span class="math">\\langle P_{\\mathcal{G}} \\rangle</span>  (sysGen). We have just seen that computing a Gröbner basis for a given FreeLunch system  <span class="math">P_{\\mathcal{G}}</span>  is – as the name suggests – free. There are, however, two practical concerns worth addressing. Firstly, while  <span class="math">P_{\\mathcal{G}}</span>  is itself a Gröbner basis, it is generally not the unique reduced Gröbner basis w.r.t. any of its FreeLunch orders. Secondly, generating the polynomials in  <span class="math">P_{\\mathcal{G}}</span>  may itself be hard.</p>

    <p class="text-gray-300">In practice we do not generate the polynomials in  <span class="math">P_{\\mathcal{G}}</span>  in the direct manner outlined earlier. Rather, we will use the fact that  <span class="math">\\boldsymbol{p}_i</span>  and g are constructed by composing certain round functions. This allows us to reduce by the polynomials  <span class="math">\\boldsymbol{p}_1, \\ldots, \\boldsymbol{p}_{i-1}</span>  introduced earlier in the process in order to suppress the growth</p>

    <p class="text-gray-300">of the number of monomials. This is detailed in Appendix A, where we show that when  <span class="math">P_{\\mathcal{G}}</span>  satisfies the conditions of Proposition 6, the polynomial system generated in this manner is also a FreeLunch system that is the unique reduced Gröbner basis for  <span class="math">\\langle P_{\\mathcal{G}} \\rangle</span>  w.r.t.  <span class="math">\\prec_{\\mathcal{G}}</span> . In Appendix A a complexity estimate for generating this latter polynomial system is also provided, under the assumption that reductions following every multiplication of multivariate polynomials can be done efficiently.</p>

    <h2 id="sec-12" class="text-2xl font-bold">3.5 Summary of the FreeLunch Attack</h2>

    <p class="text-gray-300">The strategy of the attack presented in this section is summarized in Algorithm 1. The initial condition is that there exists a FreeLunch system associated</p>

    <pre><code class="language-text">1. sysGen: Generate a FreeLunch system (Section 3.4).</code></pre>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>matGen: Compute the multiplication matrix  <span class="math">T_0</span>  (Section 3.2).</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>polyDet: Compute</li>

    </ol>

    <p class="text-gray-300"><span class="math-block">f(x_0) = \\det \\left( x_0^{\\alpha_0} \\mathbf{I}_{D_H} + \\sum_{i=0}^{\\alpha_0-1} x_0^i M_i \\right)</span>  (Section 3.2).</p>

    <p class="text-gray-300"><span id="page-16-1"></span>4. uniSol: Solve  <span class="math">f(x_0) = 0</span></p>

    <p class="text-gray-300">Algorithm 1: Overview of the FreeLunch Attack.</p>

    <p class="text-gray-300">with the target primitives. Methods for constructing this FreeLunch system were presented in Section 3.3 and 3.4, and the complexities for sysGen using these methods are discussed in Appendix A. A different way of generating a FreeLunch system will also be shown in Section 5. We will estimate the complexity of polyDet by (2), but we do not have a clear estimate for matGen. The final step uniSol recovers the roots of a univariate polynomial of degree  <span class="math">D_I</span> . This costs  <span class="math">\\tilde{\\mathcal{O}}(D_I)</span>  operations and is thus negligible in comparison with the earlier steps. We expect the complexity of the attack as a whole to be dominated by either matGen or polyDet for the primitives we have investigated. This is in line with our experiments (see Section 6.1), where matGen seems to be the dominating step for larger instances.</p>

    <p class="text-gray-300">The numbers for the complexity of the polyDet step in our attacks against several AOPs are shown in  <span class="math">^{10}</span>  Table 1. Details of how we obtained the complexities for the specific ciphers will be provided further in the paper. While we do not have a rigorous complexity estimate for the matGen step, recall that the complexity  <span class="math">\\mathcal{O}(nD_I^3)</span>  of the FGLM algorithm serves as a loose upper bound. This upper bound is already sufficient to break a few instances of Griffin and  <span class="math">\\alpha</span> -Arion. For Griffin we have FGLM complexities of  <span class="math">2^{108}</span>  and  <span class="math">2^{122}</span>  for  <span class="math">t \\geq 12</span>  and  <span class="math">\\alpha = 3, 5</span> ,</p>

    <p class="text-gray-300"><span id="page-16-2"></span><sup>&</sup>lt;sup>10</sup> The complexities correspond to the number of basic  <span class="math">\\mathbb{F}_p</span>  operations; writing them as number of calls to the primitive would yield lower but hard to compute numbers.</p>

    <p class="text-gray-300">respectively, and  <span class="math">2^{127}</span>  for t=8 and  <span class="math">\\alpha=3</span> . For  <span class="math">\\alpha</span> -Arion with  <span class="math">\\alpha=121</span>  and e=3 we get  <span class="math">2^{117}</span>  and  <span class="math">2^{127}</span>  for t=4,5 and for e=5 we get complexities of  <span class="math">2^{114}</span>  and  <span class="math">2^{124}</span>  for t=3,4.</p>

    <p class="text-gray-300"><span id="page-17-1"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Name</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\alpha/e</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Number of branches</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Name</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\geq 12</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Griffin</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

            <td class="px-3 py-2 border-b border-gray-700">120 (16)</td>

            <td class="px-3 py-2 border-b border-gray-700">112 (15)</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

            <td class="px-3 py-2 border-b border-gray-700">76 (11)</td>

            <td class="px-3 py-2 border-b border-gray-700">64 (10)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GIIIIII</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

            <td class="px-3 py-2 border-b border-gray-700">141 (14)</td>

            <td class="px-3 py-2 border-b border-gray-700">110 (11)</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

            <td class="px-3 py-2 border-b border-gray-700">81 (9)</td>

            <td class="px-3 py-2 border-b border-gray-700">74(9)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Arion</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

            <td class="px-3 py-2 border-b border-gray-700">128 (6)</td>

            <td class="px-3 py-2 border-b border-gray-700">134 (6)</td>

            <td class="px-3 py-2 border-b border-gray-700">114 (5)</td>

            <td class="px-3 py-2 border-b border-gray-700">119 (5)</td>

            <td class="px-3 py-2 border-b border-gray-700">98 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AI IOII</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

            <td class="px-3 py-2 border-b border-gray-700">132 (6)</td>

            <td class="px-3 py-2 border-b border-gray-700">113(5)</td>

            <td class="px-3 py-2 border-b border-gray-700">118(5)</td>

            <td class="px-3 py-2 border-b border-gray-700">122(5)</td>

            <td class="px-3 py-2 border-b border-gray-700">101(4)</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\alpha</span> -Arion</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

            <td class="px-3 py-2 border-b border-gray-700">104(5)</td>

            <td class="px-3 py-2 border-b border-gray-700">84 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700">88 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700">92 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700">98 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">α-AI IOII</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

            <td class="px-3 py-2 border-b border-gray-700">83 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700">87 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700">91 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700">94 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700">101 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">118 (21)</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Anemoi</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">156 (21)</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Anemoi</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">174 (20)</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">198 (19)</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Ø</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Time complexity ( <span class="math">\\log_2</span> ) of polyDet in FreeLunch-based attacks against some full-round algorithms (aiming at 128-bit security). Number of rounds in parentheses,  <span class="math">\\emptyset</span>  corresponds to undefined algorithms. The  <span class="math">\\alpha/e</span>  column reports  <span class="math">\\alpha</span>  for Griffin and Anemoi; and e for the Arion variants.</p>

    <p class="text-gray-300">Experimental Verification In this section and in Section 5, we support theoretical attacks with practical experiments on reduced-round versions. All experiments are performed on 1 core of AMD EPYC 7352 (2.3GHz) with 250 GB of memory, and on  <span class="math">\\mathbb{F}_p</span>  with p=0x64ec6dd0392073. The sysGen step is performed with SageMath [47], MAGMA [13] or the NTL [48] and Flint [37] libraries, the matGen step is performed with Flint, and the polyDet step is performed with the Polynomial Matrix Library [46,38].</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">4.1 A Detailed Example: Griffin</h4>

    <p class="text-gray-300"><strong>Specification of Griffin.</strong> Griffin [34] is a family of sponge hash and compression functions proposed by Grassi <em>et al.</em> at Crypto 2023 designed to be used in Zero-Knowledge applications. As such, it makes use of the internal permutation Griffin- <span class="math">\\pi</span> , which is defined over the finite field  <span class="math">\\mathbb{F}</span> .</p>

    <p class="text-gray-300">Each round function of  <span class="math">\\operatorname{Griffin}</span> - <span class="math">\\pi</span>  is composed of a non-linear layer, the addition of a round constant, and a linear layer defined by multiplication by an MDS matrix. The specific features of  <span class="math">\\operatorname{Griffin}</span>  impose that the primitive is only suitable for  <span class="math">\\mathbb{F}^t</span>  where t=3 or t is a multiple of four.</p>

    <p class="text-gray-300"><span id="page-17-2"></span><strong>Definition 10 (Non-linear layer of Griffin-</strong> <span class="math">\\pi</span> <strong>).</strong> Let  <span class="math">\\alpha \\in \\{3,5,7,11\\}</span>  be the smallest integer such that  <span class="math">\\gcd(\\alpha,p-1)=1,\\ p&gt;2^{63}</span>  and let t be the number of</p>

    <p class="text-gray-300">branches. For  <span class="math">0 \\le i \\le t-1</span> , let  <span class="math">(\\delta_i, \\mu_i) \\in \\mathbb{F}^2 \\setminus \\{(0,0)\\}</span>  be pairwise distinct such that  <span class="math">\\delta_i^2 - 4\\mu_i</span>  is a quadratic nonresidue modulo p. Then, the non-linear layer of Griffin- <span class="math">\\pi</span>  is  <span class="math">S(x_0, \\ldots, x_{t-1}) = (y_0, \\ldots, y_{t-1})</span> , where each  <span class="math">y_i</span>  is defined by the equations:</p>

    <div class="my-4 text-center"><span class="math-block">y_i := \\begin{cases} x_0^{1/\\alpha} &amp; \\text{if } i = 0 \\\\ x_1^{\\alpha} &amp; \\text{if } i = 1 \\\\ x_2 \\cdot (L_2(y_0, y_1, 0)^2 + \\delta_2 \\cdot L_2(y_0, y_1, 0) + \\mu_2) &amp; \\text{if } i = 2 \\\\ x_i \\cdot (L_i(y_0, y_1, x_{i-1})^2 + \\delta_i \\cdot L_i(y_0, y_1, x_{i-1}) + \\mu_i) &amp; \\text{otherwise,} \\end{cases}</span></div>

    <p class="text-gray-300">for  <span class="math">L_i(z_0, z_1, z_2) = (i - 1) \\cdot z_0 + z_1 + z_2</span></p>

    <p class="text-gray-300"><strong>Definition 11</strong> (Griffin- <span class="math">\\pi</span> ). Let r be the number of rounds, and for  <span class="math">1 \\leq i \\leq r-1</span>  let  <span class="math">\\mathbf{c}^{(i)} \\in \\mathbb{F}^t</span>  be a constant vector (we assume  <span class="math">\\mathbf{c}^{(r)} = 0</span> ). Then Griffin- <span class="math">\\pi</span>   <span class="math">\\mathcal{G}^{\\pi} : \\mathbb{F}^t \\to \\mathbb{F}^t</span>  is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{G}^{\\pi}(\\cdot) := \\mathcal{F}_r \\circ \\cdots \\circ \\mathcal{F}_2 \\circ \\mathcal{F}_1(M \\times \\cdot),</span></div>

    <p class="text-gray-300">where for  <span class="math">1 \\leq i \\leq r</span> , the i-th round function  <span class="math">\\mathcal{F}_i</span>  is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{F}_i(\\cdot) = \\boldsymbol{c}^{(i)} + M \\times S(\\cdot),</span></div>

    <p class="text-gray-300">for  <span class="math">M \\in \\mathbb{F}^{t \\times t}</span>  a matrix, and S the non-linear layer of Griffin- <span class="math">\\pi</span> .</p>

    <p class="text-gray-300">The first round function of Griffin- <span class="math">\\pi</span>  for t=4 is depicted in Fig. 2 where, to simplify the construction, we denote by  <span class="math">F_i</span>  the last two equations of Definition 10. The authors proposed various instances with a 128-bit security claim. The number of branches varies from 3 to 24 (though not all values are possible), and the number of rounds is computed for different degrees  <span class="math">\\alpha</span>  based on the complexity of finding a Gröbner basis using the basic encoding as it was the most efficient attack they could find.</p>

    <p class="text-gray-300">FreeLunch system for Griffin. We observe that the round function of Griffin readily lends itself to a naive construction of the system  <span class="math">P_{\\mathcal{G}}</span> , as described in Section 3.4. Indeed, for each round i we can simply define  <span class="math">\\mathbf{z}_i = G_i(\\mathbf{z}_{i-1}, x_i)</span>  by  <span class="math">\\mathbf{z}_i = \\mathbf{c}^{(i)} + M \\times \\mathbf{z}&#x27;_i</span> , where  <span class="math">\\mathbf{z}&#x27;_{i,0} = x_i</span>  and  <span class="math">\\mathbf{z}&#x27;_{i,j}</span>  given as  <span class="math">y_j</span> , for  <span class="math">1 \\leq j &lt; t</span> , in Definition 10 of the i-th round. Note that  <span class="math">G_i</span>  will be of degree at most  <span class="math">d_i = 2\\alpha + 1</span> . Under the assumption that the polynomial g in  <span class="math">P_{\\mathcal{G}}</span>  satisfies the monomial property of Proposition 6, we get an associated ideal degree of  <span class="math">(\\alpha(2\\alpha + 1))^r</span> .</p>

    <p class="text-gray-300">Remark 1. Note that the naive modeling  <span class="math">P_{\\mathcal{G}}</span>  given above for Griffin is not new; in fact, it was proposed by the authors of this algorithm for their initial security analysis [34, Section 6.2]. However, the authors did not attempt to compute a Gröbner basis for  <span class="math">\\langle P_{\\mathcal{G}} \\rangle</span>  in a FreeLunch order, but rather in the usual grevlex order. They estimate that computing a Gröbner basis in this latter monomial order well exceeds the security level for the suggested number of rounds.</p>

    <p class="text-gray-300"><span id="page-19-0"></span><img src="_page_19_Picture_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 2: First round function of Griffin-π with t = 4.</p>

    <p class="text-gray-300">Bypassing Several Rounds. A further improvement is constructing an affine input in x<sup>0</sup> for the CICO problem that is tailored to bypass the inversion operation for a few initial rounds. This effectively means that fewer variables x<sup>i</sup> are necessary, which in turn has a significant impact on the resulting ideal degree. Observe that bypassing inversions fits seamlessly with the machinery introduced in Section <a href="#page-12-0">3.4.</a> The only difference is that we choose a different sequence of polynomial functions G ∗ , where G ∗ 1 effectively spans several rounds but only depends on z0. The ensuing functions G ∗ i , i ≥ 2, can still be constructed as described for the naive method above (though there will now be fewer of them). The exact number of initial rounds we can bypass will depend on t, where a larger t generally allows us to bypass more rounds<a href="#page-19-1">11</a>. All underlying details are given in Appendix <a href="#page-38-0">B.</a></p>

    <p class="text-gray-300">For t = 3, 4, we can bypass one round with linear functions in z0. For t = 8, we are able to bypass two rounds with cubic functions in z0, and three rounds can be bypassed with deg(z0) = 6α + 3 for t ≥ 12. Assuming all systems satisfy Proposition <a href="#page-14-1">6,</a> we get the following parameters:</p>

    <p class="text-gray-300"><span class="math-block">D_{I,t} = \\begin{cases} (\\alpha (2\\alpha + 1))^{r-1}, &amp; \\text{for } t = 3, 4, \\\\ 3 (\\alpha (2\\alpha + 1))^{r-2}, &amp; \\text{for } t = 8, \\\\ (6\\alpha + 3) (\\alpha (2\\alpha + 1))^{r-3}, &amp; \\text{for } t \\ge 12. \\end{cases}</span>  (5)</p>

    <p class="text-gray-300"><span class="math-block">D_{H,t} = \\begin{cases} \\alpha^{r-1}, &amp; \\text{for } t = 3, 4, \\\\ \\alpha^{r-2}, &amp; \\text{for } t = 8, \\\\ \\alpha^{r-3}, &amp; \\text{for } t \\ge 12. \\end{cases}</span>  (6)</p>

    <p class="text-gray-300"><span id="page-19-1"></span><sup>11</sup> A similar observation of bypassing rounds was already considered in <a href="#page-34-10">\\[34,</a> Section 6.2]. However, the authors only describe a method for bypassing a single round for t = 3 and do not consider the effect of having a larger t.</p>

    <p class="text-gray-300"><span id="page-20-0"></span>Table 2: Expected time complexity ( <span class="math">\\log_2</span> ) of polyDet for the different full-round instances of Griffin, where  <span class="math">\\omega=2.81</span> . Number of rounds in parentheses.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Branches</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity <span class="math">(\\log_2)</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Dianches</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\alpha = 3</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\alpha = 5</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">120 (16)</td>

            <td class="px-3 py-2 border-b border-gray-700">141 (14)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">112 (15)</td>

            <td class="px-3 py-2 border-b border-gray-700">110 (11)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">76 (11)</td>

            <td class="px-3 py-2 border-b border-gray-700">81 (9)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">12,\\!16,\\!20,\\!24</span></td>

            <td class="px-3 py-2 border-b border-gray-700">64 (10)</td>

            <td class="px-3 py-2 border-b border-gray-700">74(9)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-20-1"></span>Table 3: Experimental results on Griffin with  <span class="math">(t, \\alpha) = (12, 3)</span> . sysGen uses Flint and NTL with the fast multivariate multiplication algorithm of Appendix A.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Number of</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Memory</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">rounds</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">{\\rm of}</span> polyDet</td>

            <td class="px-3 py-2 border-b border-gray-700">sysGen</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">{\\tt matGen}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">polyDet</td>

            <td class="px-3 py-2 border-b border-gray-700">(MB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">0.17</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02</td>

            <td class="px-3 py-2 border-b border-gray-700">0.53</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">4.0</td>

            <td class="px-3 py-2 border-b border-gray-700">6.67</td>

            <td class="px-3 py-2 border-b border-gray-700">50.78</td>

            <td class="px-3 py-2 border-b border-gray-700">471</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

            <td class="px-3 py-2 border-b border-gray-700">2,558</td>

            <td class="px-3 py-2 border-b border-gray-700">3,361</td>

            <td class="px-3 py-2 border-b border-gray-700">5,727</td>

            <td class="px-3 py-2 border-b border-gray-700">27,600</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Complexity Analysis and Experimental Results. We can now use the machinery described in Section 3.2 to solve the FreeLunch system for Griffin. As noted in Section 3.2, it is hard to theoretically estimate the complexity of matGen where one computes the multiplication matrix  <span class="math">T_0</span> . On the other hand, based on previous analysis, we estimate the complexity of polyDet by computing  <span class="math">D_{I,t}D_{H,t}^{\\omega-1} = D_{I,t}(D_{I,t}/\\alpha_0)^{\\omega-1}</span>  for the different values of  <span class="math">D_{I,t}</span> . As a consequence, the running time for polyDet becomes</p>

    <p class="text-gray-300"><span id="page-20-2"></span> <span class="math-block">\\tilde{\\mathcal{O}}(D_{I,t}D_{H,t}^{\\omega-1}) = \\begin{cases} \\tilde{\\mathcal{O}}((\\alpha^{\\omega} (2\\alpha+1))^{r-1}), &amp; \\text{for } t = 3, 4, \\\\ \\tilde{\\mathcal{O}}(3 (\\alpha^{\\omega} (2\\alpha+1))^{r-2}), &amp; \\text{for } t = 8, \\\\ \\tilde{\\mathcal{O}}((6\\alpha+3) (\\alpha^{\\omega} (2\\alpha+1))^{r-3}), &amp; \\text{for } t \\ge 12. \\end{cases}</span> (7)</p>

    <p class="text-gray-300">The resulting estimated time complexities of running polyDet for the proposed instances of Griffin are listed in Table 2. Experimental results are presented in Table 3 and discussed in Section 6.1. One example of concrete input and output values solving the CICO problem for 7 rounds of Griffin can be found in Appendix C.</p>

    <h2 id="sec-15" class="text-2xl font-bold">4.2 Applicability Beyond Griffin: the Example of ArionHash</h2>

    <p class="text-gray-300">Specification of ArionHash. ArionHash [44] is an arithmetization-oriented hash function proposed by Roy et~al. that, much like Griffin, uses a permutation as its core primitive. Called Arion- <span class="math">\\pi</span> , this permutation utilizes in each round a polynomial of very high degree in one branch and low degree polynomials in the remaining branches to significantly decrease the number of necessary rounds to achieve the desired security.</p>

    <p class="text-gray-300"><strong>Definition 12 (Non-linear layer of Arion-</strong> <span class="math">\\pi</span> <strong>).</strong> Let  <span class="math">p \\geq 5</span>  be a prime, t the number of branches, e the smallest positive integer be such that  <span class="math">\\gcd(e,p-1)=1</span> , and  <span class="math">121 \\leq \\alpha \\leq 257</span>  an integer such that  <span class="math">\\gcd(\\alpha,p-1)=1</span> .</p>

    <p class="text-gray-300">For  <span class="math">0 \\le i \\le t-2</span> , let  <span class="math">\\delta_{i,1}, \\delta_{i,2}, \\mu_i \\in \\mathbb{F}_q</span>  be such that  <span class="math">g_i(x) = x^2 + \\delta_{i,1} \\cdot x + \\delta_{i,2}</span>  is a quadratic function without zeroes in  <span class="math">\\mathbb{F}_q</span>  and define  <span class="math">h_i(x) = x^2 + \\mu_i \\cdot x</span> . Then the non-linear layer of Arion- <span class="math">\\pi</span>  is  <span class="math">\\mathcal{S} = \\{f_0, \\ldots, f_{t-1}\\}</span> , where each  <span class="math">f_i</span>  is defined "from-right-to-left" by the equations:</p>

    <div class="my-4 text-center"><span class="math-block">f_{t-1}(y_0, \\dots, y_{t-1}) = y_{t-1}^{1/\\alpha},</span></div>

    <div class="my-4 text-center"><span class="math-block">f_i(y_0, \\dots, y_{t-1}) = y_i^e \\cdot g_i(\\sigma_{i,t}) + h_i(\\sigma_{i,t}), \\qquad t - 2 \\ge i \\ge 0,</span></div>

    <p class="text-gray-300">where  <span class="math">\\sigma_{i,t}</span>  represents the sum of all previously computed inputs and outputs</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma_{i,t} = \\sum_{j=i+1}^{t-1} y_j + f_j(y_0, \\dots, y_{t-1}) .</span></div>

    <p class="text-gray-300"><strong>Definition 13</strong> (Arion- <span class="math">\\pi</span> ). Let r be the number of rounds, and for  <span class="math">1 \\leq i \\leq r</span>  let  <span class="math">c_i \\in \\mathbb{F}^t</span>  be a constant vector. Then Arion- <span class="math">\\pi</span>  is defined as the following composition over  <span class="math">\\mathbb{F}^t</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Arion-}\\pi: (y_0, \\dots, y_{t-1}) \\mapsto (L_{c_r} \\circ \\mathcal{S}_r) \\circ \\dots \\circ (L_{c_1} \\circ \\mathcal{S}_1) \\circ L_0(y_0, \\dots, y_{t-1}),</span></div>

    <p class="text-gray-300">where  <span class="math">L_{c_i}</span>  is the affine map of [44, Definition 3] and  <span class="math">S_i</span>  is the non-linear layer of Arion- <span class="math">\\pi</span> , for  <span class="math">1 \\leq i \\leq r</span> .</p>

    <p class="text-gray-300">We illustrate the construction of the first round of Arion- <span class="math">\\pi</span>  in Fig. 3 for t=4 where, for the sake of clarity, we only represent the function  <span class="math">f_i</span>  of the non-linear layer of Arionwithout the details of  <span class="math">g_i</span>  and  <span class="math">h_i</span> .</p>

    <p class="text-gray-300"><span id="page-21-0"></span><img src="_page_21_Picture_9.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 3: First round function of Arion- <span class="math">\\pi</span>  with t=4.</p>

    <p class="text-gray-300">We provide the parameters for Arion- <span class="math">\\pi</span>  and ArionHash as well as for their additionally proposed aggressive versions  <span class="math">\\alpha</span> -Arion and  <span class="math">\\alpha</span> -ArionHash with e=3,5 and  <span class="math">\\alpha=121</span>  in Table 4 (number of rounds are in parenthesis). The authors claim 128-bit security for each parameter set.</p>

    <p class="text-gray-300"><span id="page-22-0"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Arion- <span class="math">\\pi</span> &</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ArionHash</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\alpha</span> -Arion <span class="math">\\&amp;~\\alpha</span> -ArionHash</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Branches</td>

            <td class="px-3 py-2 border-b border-gray-700">Complexity <span class="math">(\\log_2)</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Complexity <span class="math">(\\log_2)</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">e = 3</td>

            <td class="px-3 py-2 border-b border-gray-700">e = 5</td>

            <td class="px-3 py-2 border-b border-gray-700">e = 3</td>

            <td class="px-3 py-2 border-b border-gray-700">e = 5</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">128 (6)</td>

            <td class="px-3 py-2 border-b border-gray-700">132 (6)</td>

            <td class="px-3 py-2 border-b border-gray-700">104 (5)</td>

            <td class="px-3 py-2 border-b border-gray-700">83 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">134(6)</td>

            <td class="px-3 py-2 border-b border-gray-700">113 (5)</td>

            <td class="px-3 py-2 border-b border-gray-700">84 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700">87 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">114 (5)</td>

            <td class="px-3 py-2 border-b border-gray-700">118 (5)</td>

            <td class="px-3 py-2 border-b border-gray-700">88 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700">91 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">119(5)</td>

            <td class="px-3 py-2 border-b border-gray-700">122(5)</td>

            <td class="px-3 py-2 border-b border-gray-700">92(4)</td>

            <td class="px-3 py-2 border-b border-gray-700">94 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">98 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700">101 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700">98 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700">101 (4)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Expected time complexity ( <span class="math">\\log_2</span> ) of polyDet for the different full-round instances of ArionHash, where  <span class="math">\\alpha=121</span>  and  <span class="math">\\omega=2.81</span> . Number of rounds in parentheses.</p>

    <p class="text-gray-300">FreeLunch system for ArionHash. Due to the similarities in construction between Arion- <span class="math">\\pi</span>  and Griffin- <span class="math">\\pi</span> , it comes as no surprise that the round function of Arion- <span class="math">\\pi</span>  also fits the naive construction of the system  <span class="math">P_{\\mathcal{G}}</span>  described in Section 3.4. In this case, we start with a constrained input  <span class="math">\\mathbf{z}_0</span>  depending linearly on a variable  <span class="math">x_0</span> , and for each round i we define  <span class="math">\\mathbf{z}_i = G_i(\\mathbf{z}_{i-1}, x_i)</span>  by  <span class="math">\\mathbf{z}_i = L_{c_i}(\\mathbf{z}_i&#x27;)</span> , where  <span class="math">\\mathbf{z}_{i,t-1}&#x27; = x_i</span>  and  <span class="math">\\mathbf{z}_{i,j}&#x27; = f_j(z_{i-1,0}, \\ldots, z_{i-1,t-2}, x_i^{\\alpha})</span>  for  <span class="math">t-2 \\geq j \\geq 0</span> . Note that each component of  <span class="math">\\mathbf{z}_i&#x27;</span>  (and thus of  <span class="math">\\mathbf{z}_i</span> ) will have degree at most  <span class="math">d_i = (2^{t-1}(e+1) - e)^i</span>  in  <span class="math">x_0</span> . Assuming that the polynomial g in  <span class="math">P_{\\mathcal{G}}</span>  satisfies the monomial property of Proposition 6, we get an associated ideal degree of  <span class="math">(\\alpha(2^{t-1}(e+1) - e))^r</span> .</p>

    <p class="text-gray-300">In addition, one can further improve this technique by generating a set of input states constructed so that the inversion operation for the first round is bypassed, reducing the number of necessary variables and, consequently, the associated ideal degree. This is done analogously to Griffin, and all underlying details can be found in Appendix D. For Arion we are only able to bypass a single round with  <span class="math">\\deg(z_0) = 3e</span> , independent of t. Assuming all systems satisfy Proposition 6, we get the following parameters:</p>

    <div class="my-4 text-center"><span class="math-block">D_I = 3e \\left(\\alpha \\left(2^{t-1}(e+1) - e\\right)\\right)^{r-1},</span></div>

    <div class="my-4 text-center"><span class="math-block">D_H = \\alpha^{r-1}.</span></div>

    <p class="text-gray-300">Complexity Analysis and Experimental Results. We can now apply the new methods introduced in Section 3.2 to solve the FreeLunch system for ArionHash. Based on the general complexity analysis of the attack, we list the estimated time complexities of polyDet for the different proposed ArionHash parameters in Table 4. Note that here  <span class="math">D_H = D_I/\\alpha_0 = \\alpha^{r-1}</span> , so that the running time for polyDet becomes</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde{\\mathcal{O}}(D_I D_H^{\\omega - 1}) = \\tilde{\\mathcal{O}}\\left(3e\\left(\\alpha^{\\omega}\\left(2^{t-1}(e+1) - e\\right)\\right)^{r-1}\\right) \\ .</span></div>

    <p class="text-gray-300">Experimental results are presented in Table 5 and discussed in Section 6.1.</p>

    <p class="text-gray-300"><span id="page-23-0"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Number of</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Memory</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">branches</td>

            <td class="px-3 py-2 border-b border-gray-700">of polyDet</td>

            <td class="px-3 py-2 border-b border-gray-700">sysGen</td>

            <td class="px-3 py-2 border-b border-gray-700">matGen</td>

            <td class="px-3 py-2 border-b border-gray-700">polyDet</td>

            <td class="px-3 py-2 border-b border-gray-700">(MB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">1.31</td>

            <td class="px-3 py-2 border-b border-gray-700">< 0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">6.8</td>

            <td class="px-3 py-2 border-b border-gray-700">3, 387</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

            <td class="px-3 py-2 border-b border-gray-700">1.46</td>

            <td class="px-3 py-2 border-b border-gray-700">0.07</td>

            <td class="px-3 py-2 border-b border-gray-700">18.7</td>

            <td class="px-3 py-2 border-b border-gray-700">7, 551</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">35</td>

            <td class="px-3 py-2 border-b border-gray-700">9.54</td>

            <td class="px-3 py-2 border-b border-gray-700">0.08</td>

            <td class="px-3 py-2 border-b border-gray-700">64.5</td>

            <td class="px-3 py-2 border-b border-gray-700">15, 903</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">247</td>

            <td class="px-3 py-2 border-b border-gray-700">0.31</td>

            <td class="px-3 py-2 border-b border-gray-700">215</td>

            <td class="px-3 py-2 border-b border-gray-700">32, 626</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

            <td class="px-3 py-2 border-b border-gray-700">24, 872</td>

            <td class="px-3 py-2 border-b border-gray-700">4.86</td>

            <td class="px-3 py-2 border-b border-gray-700">2, 545</td>

            <td class="px-3 py-2 border-b border-gray-700">134, 165</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5: Experimental results on 2-round Arion, with (e, α) = (3, 121). sysGen is performed using SageMath. polyDet uses an evaluation/interpolation algorithm of pml [\\[46\\]](#page-35-7) since the algorithm of [\\[39\\]](#page-34-8) implemented in pml does not work for the non-generic polynomial matrix in input of polyDet.</p>

    <h2 id="sec-16" class="text-2xl font-bold">4.3 Last Example: XHash8</h2>

    <p class="text-gray-300">XHash8 is a permutation proposed by Ashur, Kindi and Mahzoun in [\\[6\\]](#page-32-10). Along with XHash12, it is a follow-up of RPO [\\[7\\]](#page-32-11), itself a follow-up of Rescue-Prime [\\[45\\]](#page-35-2). XHash8 features a layer with inversion operations in eight out of twelve branches. Thus we need to introduce polynomials p<sup>i</sup> = (pi,0, . . . , pi,7) and variables x<sup>i</sup> = (xi,0, . . . , xi,7) in these layers. We can, by adjusting for this minor difference, directly define a FreeLunch system as we have seen in the previous two subsections. Since this is very similar to what we saw for Griffin and Arion, we will give the details for this analysis in Appendix <a href="#page-45-0">F,</a> and only limit ourselves to a short discussion of the highlights in the immediate following. We note that the related constructions XHash12, RPO and Rescue-Prime all contain a layer of inversion operations in all branches, and hence we cannot directly obtain a FreeLunch from them.</p>

    <p class="text-gray-300">Complexity and Impact on Security Analysis. In contrast to the flexible constructions of Griffin-π and Arion-π, XHash8 is only defined for a fixed prime p ≈ 2 <sup>64</sup> and a fixed sponge setting with state size t = 12, where the rate is 8 and capacity 4. Although this does not directly lend itself to a CICO problem with a single zero in input and output, we applied the FreeLunch approach to this setting. We generate a FreeLunch system with α<sup>0</sup> = 7<sup>6</sup> , D<sup>H</sup> = 7<sup>24</sup>, and D<sup>I</sup> = 7<sup>30</sup> , whose time complexity of polyDet is approximately 2 <sup>214</sup> for ω = 2.81. As this is significantly higher than brute force for the chosen p, we conclude that XHash8 seems very secure against the techniques presented in this paper.</p>

    <p class="text-gray-300">That said, we note that the current security estimates for XHash8 are (conservatively) extrapolated from scaled-down experiments with t = 3 using a single unknown input <a href="#page-32-10">\\[6,</a> App. B]. While the FreeLunch framework cannot currently be extrapolated in a similar manner for the full construction, we still hope it could provide a basis for future insights into the security of XHash8.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">5 Forcing the Presence of a FreeLunch for Anemoi</h4>

    <p class="text-gray-300">We have just seen three examples where the FreeLunch machinery of Section 3.4 could be readily applied. Anemoi is another class of permutations that rely on the inverse of low degree monomials in a finite field to achieve a high degree and so it would, a-priori, seem like another candidate where we can apply the FreeLunch techniques. However, we will see that this is not as straightforward as it may appear because a direct application of the technique creates a polynomial system  <span class="math">P_{\\mathcal{G}}</span>  where g does not satisfy the assumption of Proposition 6. Instead, we will show how to compute a modified polynomial system  <span class="math">P_{\\mathcal{G}^*}</span>  that retains the valid solution to the CICO problem, which will turn out to be a FreeLunch system. This comes at the cost of a somewhat larger, yet still comparable, ideal degree than what was given in Conjecture 2 of [14]. We start by describing Anemoi.</p>

    <p class="text-gray-300"><strong>Description of Anemoi.</strong> The Anemoi permutations [14] operate on  <span class="math">\\mathbb{F}_q^{2\\ell}</span>  for  <span class="math">\\ell \\geq 1</span> , and either  <span class="math">q=2^n</span>  with n odd, or q=p for any prime  <span class="math">p\\geq 3</span> . There are differences between the operations for the odd and even characteristic cases that will impact our later modeling. Thus, we focus on the setting of  <span class="math">\\ell=1</span>  and p prime, leaving the even case as future work. In odd characteristic, Anemoi takes a parameter  <span class="math">\\alpha</span>  such that  <span class="math">x\\mapsto x^\\alpha</span>  is a permutation of  <span class="math">\\mathbb{F}_p</span> , usually  <span class="math">\\alpha=3,\\,5,\\,7</span>  or 11. The original paper gives two specific hash function instances based on Anemoi with  <span class="math">\\ell=1</span> : AnemoiSponge-BN-254, with a 254-bit prime p, AnemoiSponge-BLS12-381, with a 381-bit prime p. 127 bits of security are claimed for both of these.</p>

    <p class="text-gray-300"><strong>Definition 14 (Odd</strong> Anemoi with  <span class="math">\\ell=1</span> ). For a given p,  <span class="math">\\alpha</span>  and number of rounds r, Anemoi is a permutation of  <span class="math">\\mathbb{F}_p^2</span>  defined as</p>

    <p class="text-gray-300"><span id="page-24-2"></span> <span class="math-block">Anemoi_{p,\\alpha,r}(x,y) = \\mathcal{M} \\circ \\mathsf{R}_r \\circ \\cdots \\circ \\mathsf{R}_1(x,y).</span></p>

    <p class="text-gray-300">For  <span class="math">1 \\le i \\le r</span> , the <em>i</em>-th round function  <span class="math">R_i</span>  is defined as</p>

    <p class="text-gray-300"><span class="math-block">\\mathsf{R}_i(x,y) = \\mathcal{H} \\circ \\mathcal{M}(x+c_i,y+d_i)</span>  and  <span class="math">\\mathcal{M}(x,y) = (2x+y,x+y),</span></p>

    <p class="text-gray-300">for constants  <span class="math">c_i, d_i \\in \\mathbb{F}_p</span> .  <span class="math">\\mathcal{H}</span>  is the nonlinear operation over  <span class="math">\\mathbb{F}_p^2</span>  that is described in Figure 4b for a non-zero constant  <span class="math">a \\in \\mathbb{F}</span> .</p>

    <p class="text-gray-300">Failure of the Direct FreeLunch Approach. As a starting point, we consider the following slight modification  <span class="math">^{12}</span>  of the polynomial system  <span class="math">P_{\\mathcal{G}}</span>  for Anemoi, for  <span class="math">1 \\leq i \\leq r</span> .</p>

    <div class="my-4 text-center"><span class="math-block">p_i(x_0, \\dots, x_i) = x_i^{\\alpha} + aQ_{i-1}(x_0, \\dots, x_{i-1})^2 - P_{i-1}(x_0, \\dots, x_{i-1}) + a^{-1}, \\quad (8)</span></div>

    <div class="my-4 text-center"><span class="math-block">g(x_0, \\dots, x_r) = P_r(x_0, \\dots, x_r) . \\tag{9}</span></div>

    <p class="text-gray-300"><span id="page-24-1"></span><sup>&</sup>lt;sup>12</sup> The only difference from the description in Section 3.4 is that we allow  <span class="math">\\mathcal{L}_{i,j}</span>  from (3) to be quadratic, due to the term  <span class="math">Q_{i-1}^2</span> .</p>

    <p class="text-gray-300"><span id="page-25-0"></span><img src="_page_25_Picture_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(a) Anemoi round function.</li>

      <li>(b)  <span class="math">\\mathcal{H}</span>  in odd characteristic.</li>

    </ul>

    <p class="text-gray-300">Fig. 4: Description of Anemoi over prime fields with  <span class="math">\\ell = 1</span> .</p>

    <p class="text-gray-300">A first observation is that  <span class="math">z_{i,0}</span>  must have a larger leading term than  <span class="math">z_{i,1}</span>  under any monomial order. Since this leading term gets distributed to both branches under  <span class="math">\\mathcal{M}</span>  (without the possibility of cancelling the leading term), we have  <span class="math">\\mathrm{LM}(Q_i) = \\mathrm{LM}(P_i)</span> . Now note from the output shown in Figure 4b that in the computation of  <span class="math">z_{i,0}</span> , the terms  <span class="math">aQ_{i-1}^2</span>  and  <span class="math">-aQ_{i-1}^2</span>  will both occur and cancel each other. Hence, the leading monomial of g must be either  <span class="math">x_r\\mathrm{LM}(Q_{r-1})</span>  or  <span class="math">x_r^2</span> , so there is no possible choice of monomial order where g will have a leading monomial in only  <span class="math">x_0</span> .</p>

    <p class="text-gray-300">In order to circumvent this issue, we will multiply g by suitable monomials in  <span class="math">x_1, \\ldots, x_r</span>  that leads to a reduction by the polynomials  <span class="math">p_1, \\ldots, p_r</span> . This process will ultimately lead to a new polynomial  <span class="math">g^*</span> , whose leading monomial will be univariate in  <span class="math">x_0</span> . To briefly illustrate the idea, we consider the first step of this procedure. Writing out g in terms of  <span class="math">P_{r-1}, Q_{r-1}</span>  and  <span class="math">x_r</span> , we have</p>

    <div class="my-4 text-center"><span class="math-block">g(P_{r-1}, Q_{r-1}, x_r) = (1 - 4ax_r)Q_{r-1} + (2ax_r - 1)x_r + 2(P_{r-1} - a^{-1})</span></div>

    <p class="text-gray-300">=  <span class="math">(-4aQ_{r-1} + 2ax_r - 1)x_r + Q_{r-1} + 2P_{r-1} - 2a^{-1}</span> ,</p>

    <p class="text-gray-300">taking into account the final  <span class="math">\\mathcal{M}</span> -transformation. In order to cancel out the product  <span class="math">x_rQ_{r-1}</span>  using  <span class="math">p_r</span> , we construct the following polynomial:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} g&#x27; &amp;= x_r^{\\alpha - 1}g + (4aQ_{r - 1} - 2ax_r + 1)p_r \\\\ &amp;= x_r^{\\alpha}(-4aQ_{r - 1} + 2ax_r - 1) + x_r^{\\alpha - 1}(Q_{r - 1} + 2P_{r - 1} - 2a^{-1}) \\\\ &amp;+ (4aQ_{r - 1} - 2ax_r + 1)(x_r^{\\alpha} + aQ_{r - 1}^2 - P_{r - 1} + a^{-1}) \\\\ &amp;= x_r^{\\alpha - 1}(Q_{r - 1} + 2P_{r - 1} - 2a^{-1}) + 4a^2Q_{r - 1}^3 + aQ_{r - 1}^2 \\\\ &amp;+ 4Q_{r - 1}(1 - aP_{r - 1}) - P_{r - 1} + a^{-1} - 2x_r(a^2Q_{r - 1}^2 - aP_{r - 1} + 1) \\ . \\end{split}</span></div>

    <p class="text-gray-300">Hence, we have successfully eliminated  <span class="math">x_r</span>  from the leading monomial of g' under any monomial order that satisfies</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} &amp; \\text{wt}\\left(\\text{LM}\\left(Q_{r-1}^{3}\\right)\\right) &gt; &amp; \\text{wt}\\left(\\text{LM}\\left(x_{r}^{\\alpha-1}Q_{r-1}\\right)\\right) \\ , \\\\ &amp; \\text{wt}\\left(\\text{LM}\\left(Q_{r-1}^{3}\\right)\\right) &gt; &amp; \\text{wt}\\left(\\text{LM}\\left(x_{r}^{\\alpha-1}P_{r-1}\\right)\\right) \\ , \\\\ &amp; \\text{wt}\\left(\\text{LM}\\left(Q_{r-1}^{3}\\right)\\right) &gt; &amp; \\text{wt}\\left(\\text{LM}\\left(x_{r}Q_{r-1}^{2}\\right)\\right) \\ , \\\\ &amp; \\text{wt}\\left(\\text{LM}\\left(Q_{r-1}^{3}\\right)\\right) &gt; &amp; \\text{wt}\\left(\\text{LM}\\left(x_{r}P_{r-1}\\right)\\right) \\ , \\end{aligned}</span></div>

    <p class="text-gray-300">which, since  <span class="math">\\alpha \\geq 3</span>  and  <span class="math">LM(P_{r-1}) = LM(Q_{r-1})</span> , can be simplified further to:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{wt}\\left(\\operatorname{LM}\\left(Q_{r-1}^{2}\\right)\\right) &gt; \\operatorname{wt}\\left(x_{r}^{\\alpha-1}\\right) = (\\alpha - 1)\\operatorname{wt}(x_{r}) \\ .</span></div>

    <p class="text-gray-300">Constructing FreeLunch Systems From Anemoi. We now turn our attention to the general construction of  <span class="math">g^*</span>  that will allow us to apply the FreeLunch machinery for solving the CICO problem for Anemoi. Here, we will not only be interested in the leading monomials of the intermediate states and  <span class="math">p_i</span> , but also in the second and third monomials. To this end, we define  <span class="math">\\prec_A</span>  to be the monomial order associated with the weight vector defined recursively by</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{cases} \\operatorname{wt}(x_0) = 1, \\\\ \\operatorname{wt}(x_i) = \\frac{2}{\\alpha} \\operatorname{wt}(x_0 \\cdots x_{i-1}), \\text{ for } 1 \\le i \\le r. \\end{cases}</span></div>

    <p class="text-gray-300">Indeed, this choice of monomial order allows us to prove the following two lemmas. For a polynomial h, we let  <span class="math">\\mathrm{Mon}_j(h)</span>  denote the j-th monomial of h according to  <span class="math">\\prec_A</span> . As usual, we write  <span class="math">\\mathrm{LM}(h) = \\mathrm{Mon}_1(h)</span> . To avoid pathological cases, we always consider an affine input in  <span class="math">x_0</span>  for the CICO-problem such that  <span class="math">x_0</span>  is not eliminated after the initial linear operation  <span class="math">\\mathcal{M}</span> . Finally, remember that two monomials may have equal weight, and only get sorted by their lexicographic order.</p>

    <p class="text-gray-300"><span id="page-26-0"></span><strong>Lemma 4.</strong> Let  <span class="math">Q_i(x_0, ..., x_i)</span>  be as defined in Figure 4a and ordered according to  <span class="math">\\prec_A</span> . Then the following holds for  <span class="math">\\alpha \\geq 3</span> .</p>

    <p class="text-gray-300"><span class="math-block">LM(Q_i) = x_0 \\cdots x_i,</span>  and  <span class="math">wt(LM(Q_i)) &gt; wt(Mon(Q_i))</span> .</p>

    <p class="text-gray-300"><span id="page-26-1"></span>Proof. We proceed by induction. The statements are clearly true for i=0, as  <span class="math">Q_0</span>  is an affine polynomial in  <span class="math">x_0</span>  by our CICO setting. Now assume it holds for i-1. As mentioned above, leading terms cannot be canceled under  <span class="math">\\mathcal{M}</span> , and the leading terms come from the first output of  <span class="math">\\mathcal{M}</span> . Thus, we can restrict ourselves to the two largest monomials in the first output from  <span class="math">\\mathcal{M}</span> , that is  <span class="math">2ax_iQ_{i-1}+ax_i^2+P_{i-1}-a^{-1}</span> . From the induction hypothesis we have  <span class="math">\\mathrm{LM}(x_iQ_{i-1})=x_0\\cdots x_i</span> , and it follows from the definition of  <span class="math">\\prec_A</span>  that this has a strictly higher weight than  <span class="math">x_i^2</span>  when  <span class="math">\\alpha\\geq 3</span> .</p>

    <p class="text-gray-300"><strong>Lemma 5.</strong> Let  <span class="math">p_i(x_0,...,x_i)</span>  be as defined in (8) and ordered according to  <span class="math">\\prec_A</span> , and let  <span class="math">\\alpha \\geq 3</span> . Then for all  <span class="math">1 \\leq i \\leq r</span>  the following holds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1.  <span class="math">LM(p_i) = x_i^{\\alpha}</span> .</li>

      <li>2.  <span class="math">Mon_2(p_i) = (x_0 \\cdots x_{i-1})^2</span> .</li>

      <li>3.  <span class="math">\\operatorname{wt}(\\operatorname{LM}(p_i)) = \\operatorname{wt}(\\operatorname{Mon}_2(p_i)) &gt; \\operatorname{wt}(\\operatorname{Mon}_3(p_i))</span> .</li>

    </ul>

    <p class="text-gray-300"><em>Proof.</em> We see from the definition of  <span class="math">p_i</span>  that  <span class="math">\\mathrm{LM}(p_i)</span>  must be either  <span class="math">x_i^{\\alpha}</span>  or  <span class="math">\\mathrm{LM}(Q_i^2)</span> . From Lemma 4, we have  <span class="math">\\mathrm{wt}(\\mathrm{LM}(Q_i^2)) = 2\\mathrm{wt}(x_0 \\cdots x_{i-1})</span> , so these two monomials have the same weight by definition of  <span class="math">\\prec_A</span> .  <span class="math">\\mathrm{LM}(p_i) = x_i^{\\alpha}</span>  then follows from Definition 2. Finally,  <span class="math">\\mathrm{Mon}_3(p_i) = \\mathrm{Mon}_2(Q_i^2)</span>  and thus has a strictly smaller weight than the initial two monomials (Lemma 4).</p>

    <p class="text-gray-300">Before we can define  <span class="math">g^*</span> , we also need a way to predict the powers of  <span class="math">x_i</span>  we will use in the multiplication of g prior to the reductions by  <span class="math">p_1, \\ldots, p_r</span> . This is handled by the following integer sequences.</p>

    <p class="text-gray-300"><span id="page-27-0"></span><strong>Definition 15.</strong> We define two integer sequences  <span class="math">\\{u_i\\}_{0 \\le i \\le r}</span>  and  <span class="math">\\{k_j\\}_{1 \\le j \\le r}</span> , where  <span class="math">u_r = 1</span> , and the remaining sequences are recursively defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">k_i</span>  is the unique integer  <span class="math">0 \\le k_i &lt; \\alpha</span>  such that  <span class="math">k_i \\equiv -u_i \\mod \\alpha</span> ;</li>

      <li><span class="math">-u_{i-1} = u_i + 2(u_i + k_i)/\\alpha.</span></li>

    </ul>

    <p class="text-gray-300">In the following, we will denote  <span class="math">u = u_0</span> .</p>

    <p class="text-gray-300">Note that in the above definition,  <span class="math">u_i + k_i</span>  is always a multiple of  <span class="math">\\alpha</span> ; hence  <span class="math">u_{i-1}</span>  is indeed an integer.</p>

    <p class="text-gray-300">For a polynomial h and sequence of polynomials H, we write Red(h, H) to denote the reduction of h by H w.r.t.  <span class="math">\\prec_A</span> . More specifically, Red(h, H) is the remainder after performing multivariate division of h by H (see [21, Ch. 2, §3]). We are now in a position to define  <span class="math">g^*</span> . Let  <span class="math">g&#x27;_r = g</span> , and recursively define</p>

    <p class="text-gray-300"><span class="math-block">g&#x27;_{i-1} = \\text{Red}(x_i^{k_i} g&#x27;_i, \\{p_i, p_{i+1}, \\dots, p_r\\}), \\text{ for } i = r, r - 1, \\dots, 1</span> .</p>

    <p class="text-gray-300">We set  <span class="math">g^<em> = g&#x27;_0</span> , and  <span class="math">I_A = \\langle P_{\\mathcal{G}^</em>} \\rangle</span> , where  <span class="math">P_{\\mathcal{G}^<em>} = \\{p_1, \\dots, p_r, g^</em>\\}</span> . It is clear from the construction that  <span class="math">I_A</span>  is a subideal of  <span class="math">\\langle P_{\\mathcal{G}} \\rangle</span> . The following result guarantees that  <span class="math">P_{\\mathcal{G}^*}</span>  is a FreeLunch system generating this subideal.</p>

    <p class="text-gray-300"><strong>Proposition 7.</strong> The polynomial system  <span class="math">P_{\\mathcal{G}^<em>}</span>  is a FreeLunch system, where  <span class="math">LM_{\\prec_A}(g^</em>) = x_0^u</span> . Moreover, the variety of the associated ideal  <span class="math">I_A</span>  contains all valid solutions of the underlying instance of Anemoi.</p>

    <p class="text-gray-300"><em>Proof.</em> By Lemma 5 we have  <span class="math">LM(p_i) = x_i^{\\alpha}</span> , so we need only show that  <span class="math">LM(g^<em>)</span>  is a univariate monomial in  <span class="math">x_0</span>  to guarantee that  <span class="math">P_{\\mathcal{G}^</em>}</span>  is a FreeLunch system. To this end, we will show by induction on descending i that  <span class="math">LM(g&#x27;_i) = (x_0 \\cdots x_i)^{u_i}</span> , and  <span class="math">wt(LM(g&#x27;_i)) &gt; LM(Mon_2(g&#x27;_i))</span> .</p>

    <p class="text-gray-300">For i=r, we have  <span class="math">g&#x27;_r=g=Q_r</span> , and the statement holds by Lemma 4. Suppose the hypothesis holds for a given i and consider i-1. If we denote  <span class="math">s_i=(u_i+k_i)/\\alpha</span> , we have  <span class="math">\\mathrm{LM}(x_i^{k_i}g&#x27;_i)=(x_0\\cdots x_{i-1})^{u_i}x_i^{\\alpha s_i}</span> . We now reduce this</p>

    <p class="text-gray-300">monomial by  <span class="math">p_i</span> . Write c for the leading coefficient of  <span class="math">x_i^{k_i}g_i&#x27;</span> . From Lemma 5, we have that the first two monomials in  <span class="math">p_i</span>  have the same weight, while all other monomials have smaller weights. Moreover, the induction hypothesis ensures that  <span class="math">\\operatorname{Mon}_j(x_i^{k_i}g_i&#x27;)</span>  will a have smaller weight than  <span class="math">\\operatorname{LM}(x_i^{k_i}g_i&#x27;)</span>  for  <span class="math">j \\geq 2</span> . Hence,</p>

    <div class="my-4 text-center"><span class="math-block">LM\\left(x_i^{k_i}g_i&#x27; - c(x_0 \\cdots x_{i-1})^{u_i}x_i^{\\alpha(s_i-1)}p_i\\right) = (x_0 \\cdots x_{i-1})^{u_i+2}x_i^{\\alpha(s_i-1)},</span></div>

    <p class="text-gray-300">following from the fact that  <span class="math">\\operatorname{wt}((x_0 \\cdots x_{i-1})^{u_i+2} x_i^{\\alpha(s_i-1)}) = \\operatorname{wt}(\\operatorname{LM}(x_i^{k_i} g_i&#x27;)) = \\operatorname{wt}(\\operatorname{LM}((x_0 \\cdots x_{i-1})^{u_i} p_i))</span> , and the weight of all other monomials are guaranteed to be strictly smaller. Repeating this process  <span class="math">s_i - 1</span>  times, we get  <span class="math">\\operatorname{LM}(g_{i-1}&#x27;) = (x_0 \\cdots x_{i-1})^{u_i+2s_i}</span> , which proves the induction statement. Since this implies that  <span class="math">\\operatorname{LM}(g^*) = \\operatorname{LM}(g_0&#x27;) = x_0^u</span> , it also concludes the proof of the first part of the proposition. The second part holds since  <span class="math">I_A</span>  is a subideal of  <span class="math">\\langle P_{\\mathcal{G}} \\rangle</span> , where the variety of the latter ideal will contain all solutions of Anemoi.</p>

    <p class="text-gray-300"><strong>Ideal Degree.</strong> Based on experiments, the authors of Anemoi conjectured a tight upper bound on the ideal degree of one modeling of the CICO-problem to be  <span class="math">(\\alpha + 2)^r</span>  [14, Conjecture 2]. As  <span class="math">I_A</span>  is a FreeLunch system, we have  <span class="math">D_{I_A} = \\alpha^r u</span> , where we recall that u is an integer depending on r and  <span class="math">\\alpha</span> . As  <span class="math">I_A</span>  is a subideal of  <span class="math">\\langle P_{\\mathcal{G}} \\rangle</span> , we generally expect  <span class="math">D_{I_A}</span>  to be strictly larger than  <span class="math">(\\alpha + 2)^r</span> . The following result proved in Appendix E guarantees that  <span class="math">D_I</span>  can at most differ by a factor close to  <span class="math">\\alpha</span> , which in practical instances will be a small constant.</p>

    <p class="text-gray-300"><span id="page-28-0"></span><strong>Proposition 8.</strong> Let u be as defined in Definition 15 for integers  <span class="math">r, \\alpha \\geq 1</span> . Then</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac{\\alpha+2}{\\alpha}\\right)^r \\leq u \\leq (\\alpha+1)\\left(\\frac{\\alpha+2}{\\alpha}\\right)^r - \\alpha .</span></div>

    <p class="text-gray-300">From experiments for  <span class="math">\\alpha = 3</span>  and large r, we find  <span class="math">u \\approx 2.1 (5/3)^r</span> .</p>

    <p class="text-gray-300"><strong>Summary.</strong> For Anemoi, we get a polynomial system with r equations of respective leading terms  <span class="math">x_1^{\\alpha}, \\dots x_r^{\\alpha}</span>  and one equation of leading term  <span class="math">x_0^u</span> . This gives the following parameters:</p>

    <div class="my-4 text-center"><span class="math-block">D_I = \\alpha^r u,$$ $$D_H = \\alpha^r.</span></div>

    <p class="text-gray-300">Complexity Analysis and Experimental Results. The FreeLunch system  <span class="math">P_{\\mathcal{G}^*}</span>  consists of r polynomials of degree  <span class="math">\\alpha</span>  and one polynomial of degree u. The algorithm of Section 3.2 has a complexity of  <span class="math">\\tilde{\\mathcal{O}}(\\alpha^{r\\omega}u)</span> . We plugged in the numbers for odd Anemoi  <span class="math">(\\ell=1)</span> , see Table 6. We also ran experiments for Anemoi with  <span class="math">(\\ell,\\alpha)=(1,3)</span>  and different number of rounds to verify the theory presented above. The results are presented in Table 7.</p>

    <p class="text-gray-300"><span id="page-29-2"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Security claim</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\alpha = 3</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\alpha = 5</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\alpha = 7</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\alpha = 11</span></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">118 (21)</td>

            <td class="px-3 py-2 border-b border-gray-700">156 (21)</td>

            <td class="px-3 py-2 border-b border-gray-700">174 (20)</td>

            <td class="px-3 py-2 border-b border-gray-700">198 (19)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">203 (37)</td>

            <td class="px-3 py-2 border-b border-gray-700">270(37)</td>

            <td class="px-3 py-2 border-b border-gray-700">307(36)</td>

            <td class="px-3 py-2 border-b border-gray-700">358(35)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6: Expected time complexity ( <span class="math">\\log_2</span> ) of polyDet against different full-round instances of Anemoi over  <span class="math">\\mathbb{F}_p</span> , where  <span class="math">\\ell=1</span>  and  <span class="math">\\omega=2.81</span> . Number of rounds in parentheses.</p>

    <p class="text-gray-300"><span id="page-29-3"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Number of</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Memory</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">rounds</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">{\\rm of}</span> polyDet</td>

            <td class="px-3 py-2 border-b border-gray-700">sysGen</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">{\\tt matGen}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">polyDet</td>

            <td class="px-3 py-2 border-b border-gray-700">(MB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">< 0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">< 0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02</td>

            <td class="px-3 py-2 border-b border-gray-700">< 400</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">< 0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.34</td>

            <td class="px-3 py-2 border-b border-gray-700">0.24</td>

            <td class="px-3 py-2 border-b border-gray-700">< 400</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">0.07</td>

            <td class="px-3 py-2 border-b border-gray-700">23.3</td>

            <td class="px-3 py-2 border-b border-gray-700">7.6</td>

            <td class="px-3 py-2 border-b border-gray-700">< 400</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">2.52</td>

            <td class="px-3 py-2 border-b border-gray-700">2,127</td>

            <td class="px-3 py-2 border-b border-gray-700">292</td>

            <td class="px-3 py-2 border-b border-gray-700">2,863</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">43</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">156,348</td>

            <td class="px-3 py-2 border-b border-gray-700">10,725</td>

            <td class="px-3 py-2 border-b border-gray-700">42,337</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 7: Experimental results on Anemoi with  <span class="math">(\\ell, \\alpha) = (1, 3)</span> . sysGen is performed with MAGMA and refers to the generation of the polynomial system  <span class="math">P_{\\mathcal{G}^*}</span>  from scratch, including the computation of  <span class="math">P_{\\mathcal{G}}</span> .</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">6 Conclusions</h4>

    <p class="text-gray-300">We have presented the FreeLunch approach, an algebraic attack particularly efficient against arithmetization-oriented permutations. We conclude this paper with some comments regarding our experiments as well the consequences of our results, in particular regarding the areas we believe are worth investigating further.</p>

    <h2 id="sec-19" class="text-2xl font-bold">6.1 Discussion on Experimental Results</h2>

    <p class="text-gray-300">Figure 5 depicts the runtimes of each step of our attack that we obtained experimentally when targeting Griffin and Anemoi. A first observation is that the running time of a full FreeLunch-based attack is hard to predict: there are three steps (sysGen, matGen, and polyDet), and we experimentally found situations where each of them was the slowest. The case of sysGen is a bit peculiar: using SageMath, MAGMA or Flint/NTL yields very different results and a deeper understanding seems out of our grasp. We nevertheless would argue (see Appendix A) that, should their implementations use similar tools, sysGen will always be of lower complexity than that of the rest of the attack.</p>

    <p class="text-gray-300">Assuming that the dominating step is either matGen or polyDet, it then seems easy to extrapolate: as we can see in Figure 5, their logarithm increases linearly with the number of rounds. Even better: for Griffin, Equation (7) predicts that adding a round multiplies the complexity of polyDet by  <span class="math">\\alpha^{\\omega}(2\\alpha+1)\\approx 109.5</span> , which closely matches our observations as  <span class="math">5727/50.79\\approx 112.7</span> . For matGen, we see that adding a round multiplies the time complexity by about 500. Extrapolating from this, an attack against full-round Griffin should take</p>

    <p class="text-gray-300">about  <span class="math">4.2 \\cdot 10^{11} \\mathrm{s}</span>  on a single CPU (around 13,000 years), or around  <span class="math">2^{70}</span>  clock cycles at 2.3 GHz. Similarly, for Anemoi with  <span class="math">\\mathbb{F}_p</span>  and  <span class="math">(l,\\alpha)=(1,3)</span> , adding a round multiplies the time complexity of matGen by about 75. Extrapolating gives respectively  <span class="math">2^{104}</span>  seconds (or  <span class="math">2^{135}</span>  clock cycles) and  <span class="math">2^{204}</span>  seconds ( <span class="math">2^{235}</span>  clock cycles) for full-round Anemoi with 128 and 256 bits of security.</p>

    <p class="text-gray-300"><span id="page-30-0"></span><img src="_page_30_Figure_1.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><img src="_page_30_Figure_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(a) Griffin complexity (from table 3).</li>

      <li>(b) Anemoi complexity (from table 7).</li>

    </ul>

    <p class="text-gray-300">Fig. 5: Experimental time complexity of our attacks on Griffin and Anemoi.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">6.2 Preventing the FreeLunch Attack</h4>

    <p class="text-gray-300">Our attack breaks full-round instances of symmetric primitives built using state-of-the-art security arguments, which consequently must be revisited: one must learn how to prevent the relevant applicability of the FreeLunch approach.</p>

    <p class="text-gray-300">At the Primitive Level. An obvious but perhaps costly countermeasure consists of simply adding more rounds. This is particularly tempting as we are able to tightly estimate the complexity of polyDet, a step which we have found to often be the most expensive in practice. Choosing a number of rounds high enough to prevent it would be a simple yet convincing argument. Primitive designers must also be mindful of "classical" tricks, i.e., symmetric cryptanalysis techniques (a priori) unrelated to root finding that can be used to enhance its efficiency. In the case of 12-branch Griffin, the fact that we can bypass 3 out of 10 rounds using some kind of subspace trail is a problem we deem worth studying.</p>

    <p class="text-gray-300">At the Mode of Operation Level. The FreeLunch systems are multivariate, but a single variable  <span class="math">(x_0)</span>  plays an inherently different role. This makes them particularly well suited to CICO instances whereby a single output word has to be set to 0, but they will not work if more 0's are needed in the output. Thus, a simple countermeasure against the FreeLunch approach (and univariate ones) consists of forcing the capacity of the sponge to have at least two words set to 0, even if one word would a priori be enough. Still, while easy to implement, the efficiency of this countermeasure in the long term is uncertain. Indeed, as argued below, inventing a variant of the FreeLunch that can handle multiple words is an interesting open problem.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">6.3 Open Problems for Future Work</h4>

    <p class="text-gray-300">Time Taken by Polynomial Reductions. A roadblock in our complexity estimates is the number of operations needed to perform certain reductions of a polynomial modulo an ideal. This is crucial for understanding the complexity of the matGen step and, to a lesser degree, sysGen (see Appendix <a href="#page-35-4">A\\)</a>. A tighter estimate for these computations would greatly benefit our analysis: we would be able to figure out which step of our attack is the actual bottleneck without the need for experiments or assumptions, and designers could then be able to use fewer rounds to achieve a given security level against FreeLunch-based attacks. For instance, estimating the complexity of a reduction by a FreeLunch triangular system (Definition <a href="#page-11-1">9\\)</a> would be a big step forward.</p>

    <p class="text-gray-300">Other Custom Approaches. The FreeLunch approach is, to the best of our knowledge, the first "custom" root finding method designed specifically for use in symmetric cryptanalysis. There is, of course, no reason to believe that it is the only one possible, and we consider it a direction worth pursuing. As a first step, a multivariate variant of FreeLunch where several variables play the role of x0, and where several words need to be set to 0, would be an interesting target.</p>

    <h2 id="sec-22" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">This work has been facilitated through the COSINUS associate team between Inria and Simula. The authors would like to thank Gaëtan Leurent for the helpful insights on the new dedicated Gröbner basis solving algorithm, and Pierre Briaud and Carlos Cid for the good discussions in the early stages of this work. The authors would also like to thank Vincent Neiger for the proof-reading and the discussions on the algorithmic aspects of the Gröbner basis theory. The research in this paper was supported in part by the French DGA, and by the French grant 22-PECY-0010 (project CRYPTANALYSE). The work of Aurélien Bœuf, Axel Lemoine, and Léo Perrin was supported by the European Research Council (ERC, grant agreement no. 101041545 "ReSCALE"). Morten Øygarden has been supported by the Norwegian Research Council through the project qsIo2.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-31-0"></span>1. Advanced Encryption Standard (AES). National Institute of Standards and Technology, NIST FIPS PUB 197, U.S. Department of Commerce (Nov 2001)</li>

      <li><span id="page-31-1"></span>2. Albrecht, M.R., Cid, C., Grassi, L., Khovratovich, D., Lüftenegger, R., Rechberger, C., Schofnegger, M.: Algebraic Cryptanalysis of STARK-Friendly Designs: Application to MARVELlous and MiMC. In: Galbraith, S.D., Moriai, S. (eds.) Advances in Cryptology - ASIACRYPT 2019 - 25th International Conference on the Theory and Application of Cryptology and Information Security, Kobe, Japan, December 8-12, 2019, Proceedings, Part III. Lecture Notes in Computer Science, vol. 11923, pp. 371–397. Springer (2019). <https://doi.org/10.1007/978-3-030-34618-8\\_13></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-32-2"></span>3. Albrecht, M.R., Grassi, L., Rechberger, C., Roy, A., Tiessen, T.: MiMC: Efficient Encryption and Cryptographic Hashing with Minimal Multiplicative Complexity. In: Cheon, J.H., Takagi, T. (eds.) Advances in Cryptology - ASIACRYPT 2016 - 22nd International Conference on the Theory and Application of Cryptology and Information Security, Hanoi, Vietnam, December 4-8, 2016, Proceedings, Part I. Lecture Notes in Computer Science, vol. 10031, pp. 191–219 (2016). <a href="https://doi.org/10.1007/978-3-662-53887-6\\_7">https://doi.</a> <a href="https://doi.org/10.1007/978-3-662-53887-6\\_7">org/10.1007/978-3-662-53887-6\\\\_7</a></li>

      <li><span id="page-32-1"></span>4. Albrecht, M.R., Rechberger, C., Schneider, T., Tiessen, T., Zohner, M.: Ciphers for MPC and FHE. In: Oswald, E., Fischlin, M. (eds.) Advances in Cryptology - EU-ROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part I. Lecture Notes in Computer Science, vol. 9056, pp. 430–454. Springer (2015). <https://doi.org/10.1007/978-3-662-46800-5\\_17></li>

      <li><span id="page-32-3"></span>5. Aly, A., Ashur, T., Ben-Sasson, E., Dhooghe, S., Szepieniec, A.: Design of Symmetric-Key Primitives for Advanced Cryptographic Protocols. IACR Transactions on Symmetric Cryptology 2020(3), 1–45 (Sep 2020), <a href="https://tosc.iacr.org/index.php/ToSC/article/view/8695">https://tosc.iacr.org/</a> <a href="https://tosc.iacr.org/index.php/ToSC/article/view/8695">index.php/ToSC/article/view/8695</a></li>

      <li><span id="page-32-10"></span>6. Ashur, T., Kindi, A., Mahzoun, M.: XHash8 and XHash12: Efficient STARKfriendly Hash Functions. Cryptology ePrint Archive, Paper 2023/1045 (2023), <https://eprint.iacr.org/2023/1045></li>

      <li><span id="page-32-11"></span>7. Ashur, T., Kindi, A., Meier, W., Szepieniec, A., Threadbare, B.: Rescue-Prime Optimized. Cryptology ePrint Archive, Paper 2022/1577 (2022), <a href="https://eprint.iacr.org/2022/1577">https://eprint.</a> <a href="https://eprint.iacr.org/2022/1577">iacr.org/2022/1577</a></li>

      <li><span id="page-32-0"></span>8. Ashur, T., Mahzoun, M., Toprakhisar, D.: Chaghri - An FHE-friendly Block Cipher. In: Yin, H., Stavrou, A., Cremers, C., Shi, E. (eds.) Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security, CCS 2022, Los Angeles, CA, USA, November 7-11, 2022. pp. 139–150. ACM (2022). <https://doi.org/10.1145/3548606.3559364></li>

      <li><span id="page-32-5"></span>9. Bariant, A.: Algebraic Cryptanalysis of Full Ciminion. Cryptology ePrint Archive, Paper 2023/1283 (2023), <https://eprint.iacr.org/2023/1283></li>

      <li><span id="page-32-4"></span>10. Bariant, A., Bouvier, C., Leurent, G., Perrin, L.: Algebraic Attacks against Some Arithmetization-Oriented Primitives. IACR Transactions on Symmetric Cryptology 2022(3), 73–101 (Sep 2022), <a href="https://tosc.iacr.org/index.php/ToSC/article/view/9850">https://tosc.iacr.org/index.php/ToSC/article/</a> <a href="https://tosc.iacr.org/index.php/ToSC/article/view/9850">view/9850</a></li>

      <li><span id="page-32-6"></span>11. Berthomieu, J., Neiger, V., Safey El Din, M.: Faster change of order algorithm for Gröbner bases under shape and stability assumptions. In: Proceedings of the 2022 International Symposium on Symbolic and Algebraic Computation. pp. 409–418 (2022)</li>

      <li><span id="page-32-7"></span>12. Bertoni, G., Daemen, J., Peters, M., Assche, G.V.: Cryptographic Sponge Functions (2011), <https://keccak.team/files/CSF-0.1.pdf> (accessed 23.05.2024)</li>

      <li><span id="page-32-9"></span>13. Bosma, W., Cannon, J., Playoust, C.: The Magma algebra system, I. The User Language. J. Symbolic Comput. 24(3-4), 235–265 (1997), <a href="http://dx.doi.org/10.1006/jsco.1996.0125">http://dx.doi.org/10.</a> <a href="http://dx.doi.org/10.1006/jsco.1996.0125">1006/jsco.1996.0125,</a> computational algebra and number theory (London, 1993)</li>

      <li><span id="page-32-12"></span>14. Bouvier, C., Briaud, P., Chaidos, P., Perrin, L., Salen, R., Velichkov, V., Willems, D.: New Design Techniques for Efficient Arithmetization-Oriented Hash Functions: Anemoi Permutations and Jive Compression Mode. In: Handschuh, H., Lysyanskaya, A. (eds.) Advances in Cryptology – CRYPTO 2023. Lecture Notes in Computer Science, vol. 14083, pp. 507–539. Springer Nature Switzerland, Cham (2023)</li>

      <li><span id="page-32-8"></span>15. Buchberger, B.: A theoretical basis for the reduction of polynomials to canonical forms. ACM SIGSAM Bulletin 10(3), 19–29 (1976)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-33-10"></span>16. Buchmann, J., Pyshkin, A., Weinmann, R.P.: A Zero-Dimensional Gröbner Basis for AES-128. In: Robshaw, M. (ed.) Fast Software Encryption. Lecture Notes in Computer Science, vol. 4047, pp. 78–88. Springer Berlin Heidelberg, Berlin, Heidelberg (2006)</li>

      <li><span id="page-33-0"></span>17. Canteaut, A., Carpov, S., Fontaine, C., Lepoint, T., Naya-Plasencia, M., Paillier, P., Sirdey, R.: Stream Ciphers: A Practical Solution for Efficient Homomorphic-Ciphertext Compression. In: Peyrin, T. (ed.) Fast Software Encryption - 23rd International Conference, FSE 2016, Bochum, Germany, March 20-23, 2016, Revised Selected Papers. Lecture Notes in Computer Science, vol. 9783, pp. 313–333. Springer (2016). <https://doi.org/10.1007/978-3-662-52993-5\\_16></li>

      <li><span id="page-33-1"></span>18. Canteaut, A., Carpov, S., Fontaine, C., Lepoint, T., Naya-Plasencia, M., Paillier, P., Sirdey, R.: Stream Ciphers: A Practical Solution for Efficient Homomorphic-Ciphertext Compression. J. Cryptol. 31(3), 885–916 (2018). <a href="https://doi.org/10.1007/S00145-017-9273-9">https://doi.org/10.</a> <a href="https://doi.org/10.1007/S00145-017-9273-9">1007/S00145-017-9273-9</a></li>

      <li><span id="page-33-11"></span>19. Cantor, D.G., Kaltofen, E.: On Fast Multiplication of Polynomials over Arbitrary Algebras. Acta Informatica 28(7), 693–701 (1991)</li>

      <li><span id="page-33-2"></span>20. Cosseron, O., Hoffmann, C., Méaux, P., Standaert, F.: Towards Case-Optimized Hybrid Homomorphic Encryption - Featuring the Elisabeth Stream Cipher. In: Agrawal, S., Lin, D. (eds.) Advances in Cryptology - ASIACRYPT 2022 - 28th International Conference on the Theory and Application of Cryptology and Information Security, Taipei, Taiwan, December 5-9, 2022, Proceedings, Part III. Lecture Notes in Computer Science, vol. 13793, pp. 32–67. Springer (2022). <https://doi.org/10.1007/978-3-031-22969-5\\_2></li>

      <li><span id="page-33-5"></span>21. Cox, D., Little, J., OShea, D.: Ideals, Varieties, and Algorithms: An Introduction to Computational Algebraic Geometry and Commutative Algebra. Springer Science & Business Media (2013)</li>

      <li><span id="page-33-9"></span>22. Cox, D.A., Little, J.B., O'Shea, D.: Using Algebraic Geometry, Graduate Texts in Mathematics, vol. 185. Springer (1998). <a href="https://doi.org/10.1007/978-1-4757-6911-1">https://doi.org/10.1007/</a> <a href="https://doi.org/10.1007/978-1-4757-6911-1">978-1-4757-6911-1</a></li>

      <li><span id="page-33-3"></span>23. Dobraunig, C., Eichlseder, M., Grassi, L., Lallemand, V., Leander, G., List, E., Mendel, F., Rechberger, C.: Rasta: A Cipher with Low ANDdepth and Few ANDs per Bit. In: Shacham, H., Boldyreva, A. (eds.) Advances in Cryptology - CRYPTO 2018 - 38th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 19-23, 2018, Proceedings, Part I. Lecture Notes in Computer Science, vol. 10991, pp. 662–692. Springer (2018). <a href="https://doi.org/10.1007/978-3-319-96884-1\\_22">https://doi.org/10.1007/978-3-319-96884-1\\\\_</a> <a href="https://doi.org/10.1007/978-3-319-96884-1\\_22">22</a></li>

      <li><span id="page-33-4"></span>24. Duval, S., Lallemand, V., Rotella, Y.: Cryptanalysis of the FLIP Family of Stream Ciphers. In: Robshaw, M., Katz, J. (eds.) Advances in Cryptology - CRYPTO 2016 - 36th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 14-18, 2016, Proceedings, Part I. Lecture Notes in Computer Science, vol. 9814, pp. 457–475. Springer (2016). <a href="https://doi.org/10.1007/978-3-662-53018-4\\_17">https://doi.org/10.1007/</a> <a href="https://doi.org/10.1007/978-3-662-53018-4\\_17">978-3-662-53018-4\\\\_17</a></li>

      <li><span id="page-33-8"></span>25. Eisenbud, D.: Commutative Algebra: With a View Toward Algebraic Geometry, vol. 150. Springer Science & Business Media (2013)</li>

      <li><span id="page-33-6"></span>26. Faugère, J.C., Mou, C.: Sparse FGLM algorithms. Journal of Symbolic Computation 80, 538–569 (2017)</li>

      <li><span id="page-33-7"></span>27. Faugère, Jean-Charles and Gaudry, Pierrick and Huot, Louise and Renault, Guénaël: Sub-cubic change of ordering for Gröbner basis: a probabilistic approach. In: Proceedings of the 39th International Symposium on Symbolic and Algebraic Computation. pp. 170–177 (2014)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-34-5"></span>28. Faugère, Jean-Charles and Gianni, Patrizia and Lazard, Daniel and Mora, Teo: Efficient computation of zero-dimensional Gröbner bases by change of ordering. Journal of Symbolic Computation 16(4), 329–344 (1993)</li>

      <li><span id="page-34-3"></span>29. Faugère, J.C.: A new efficient algorithm for computing Gröbner bases (F4). Journal of pure and applied algebra 139(1-3), 61–88 (1999)</li>

      <li><span id="page-34-4"></span>30. Faugère, J.C.: A new efficient algorithm for computing Gröbner bases without reduction to zero (F5). In: Proceedings of the 2002 international symposium on Symbolic and algebraic computation. pp. 75–83 (2002)</li>

      <li><span id="page-34-2"></span>31. Gilbert, H., Boissier, R.H., Jean, J., Reinhard, J.: Cryptanalysis of Elisabeth-4. In: Guo, J., Steinfeld, R. (eds.) Advances in Cryptology - ASIACRYPT 2023 - 29th International Conference on the Theory and Application of Cryptology and Information Security, Guangzhou, China, December 4-8, 2023, Proceedings, Part III. Lecture Notes in Computer Science, vol. 14440, pp. 256–284. Springer (2023). <https://doi.org/10.1007/978-981-99-8727-6\\_9></li>

      <li><span id="page-34-7"></span>32. Gilbert, H., Peyrin, T.: Super-Sbox Cryptanalysis: Improved Attacks for AES-Like Permutations. In: Hong, S., Iwata, T. (eds.) Fast Software Encryption, 17th International Workshop, FSE 2010, Seoul, Korea, February 7-10, 2010, Revised Selected Papers. Lecture Notes in Computer Science, vol. 6147, pp. 365–383. Springer (2010). <https://doi.org/10.1007/978-3-642-13858-4\\_21></li>

      <li><span id="page-34-9"></span>33. Giorgi, P., Jeannerod, C.P., Villard, G.: On the Complexity of Polynomial Matrix Computations. In: Proceedings of the 2003 international symposium on Symbolic and algebraic computation. pp. 135–142 (2003)</li>

      <li><span id="page-34-10"></span>34. Grassi, L., Hao, Y., Rechberger, C., Schofnegger, M., Walch, R., Wang, Q.: Horst Meets Fluid-SPN: Griffin for Zero-Knowledge Applications. In: Handschuh, H., Lysyanskaya, A. (eds.) Advances in Cryptology - CRYPTO 2023 - 43rd Annual International Cryptology Conference, CRYPTO 2023, Santa Barbara, CA, USA, August 20-24, 2023, Proceedings, Part III. Lecture Notes in Computer Science, vol. 14083, pp. 573–606. Springer (2023). <a href="https://doi.org/10.1007/978-3-031-38548-3\\_19">https://doi.org/10.1007/978-3-031-38548-3\\\\_</a> <a href="https://doi.org/10.1007/978-3-031-38548-3\\_19">19</a></li>

      <li><span id="page-34-6"></span>35. Guido, B., Joan, D., Michaël, P., Gilles, V.: Cryptographic sponge functions (2011), <https://keccak.team/files/CSF-0.1.pdf></li>

      <li><span id="page-34-0"></span>36. Ha, J., Kim, S., Lee, B., Lee, J., Son, M.: Rubato: Noisy Ciphers for Approximate Homomorphic Encryption. In: Dunkelman, O., Dziembowski, S. (eds.) Advances in Cryptology - EUROCRYPT 2022 - 41st Annual International Conference on the Theory and Applications of Cryptographic Techniques, Trondheim, Norway, May 30 - June 3, 2022, Proceedings, Part I. Lecture Notes in Computer Science, vol. 13275, pp. 581–610. Springer (2022). <a href="https://doi.org/10.1007/978-3-031-06944-4\\_20">https://doi.org/10.1007/978-3-031-06944-4\\\\_</a> <a href="https://doi.org/10.1007/978-3-031-06944-4\\_20">20</a></li>

      <li><span id="page-34-11"></span>37. Hart, W.B.: Flint: Fast Library for Number Theory. Computeralgebra-Rundbrief: Vol. 49 (2011)</li>

      <li><span id="page-34-12"></span>38. Hyun, S.G., Neiger, V., Schost, É.: Implementations of Efficient Univariate Polynomial Matrix Algorithms and Application to Bivariate Resultants. In: Proceedings ISSAC 2019. pp. 235–242. ACM (2019). <a href="https://doi.org/10.1145/3326229.3326272">https://doi.org/10.1145/3326229.3326272,</a> <https://github.com/vneiger/pml></li>

      <li><span id="page-34-8"></span>39. Labahn, G., Neiger, V., Zhou, W.: Fast, deterministic computation of the Hermite normal form and determinant of a polynomial matrix. Journal of Complexity 42, 44–71 (2017)</li>

      <li><span id="page-34-1"></span>40. Masure, L., Méaux, P., Moos, T., Standaert, F.: Effective and Efficient Masking with Low Noise Using Small-Mersenne-Prime Ciphers. In: Hazay, C., Stam, M. (eds.) Advances in Cryptology - EUROCRYPT 2023 - 42nd Annual International Conference on the Theory and Applications of Cryptographic Techniques,</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Lyon, France, April 23-27, 2023, Proceedings, Part IV. Lecture Notes in Computer Science, vol. 14007, pp. 596–627. Springer (2023). https://doi.org/10.1007/978-3-031-30634-1 20</li>

      <li><span id="page-35-0"></span>41. Méaux, P., Journault, A., Standaert, F., Carlet, C.: Towards Stream Ciphers for Efficient FHE with Low-Noise Ciphertexts. In: Fischlin, M., Coron, J. (eds.) Advances in Cryptology - EUROCRYPT 2016 - 35th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Vienna, Austria, May 8-12, 2016, Proceedings, Part I. Lecture Notes in Computer Science, vol. 9665, pp. 311–343. Springer (2016). https://doi.org/10.1007/978-3-662-49890-3\\_13</li>

      <li><span id="page-35-8"></span>42. Moenck, R.T.: Practical fast polynomial multiplication. In: Proceedings of the third ACM symposium on Symbolic and algebraic computation. pp. 136–148 (1976)</li>

      <li><span id="page-35-3"></span>43. Neiger, V., Schost, É.: Computing syzygies in finite dimension using fast linear algebra. J. Complex. <strong>60</strong>, 101502 (2020). https://doi.org/10.1016/J.JCO.2020.101502, https://doi.org/10.1016/j.jco.2020.101502</li>

      <li><span id="page-35-1"></span>44. Roy, A., Steiner, M.J., Trevisani, S.: Arion: Arithmetization-Oriented Permutation and Hashing from Generalized Triangular Dynamical Systems (2023), https://arxiv.org/abs/2303.04639</li>

      <li><span id="page-35-2"></span>45. Szepieniec, A., Ashur, T., Dhooghe, S.: Rescue-Prime: a Standard Specification (SoK). Cryptology ePrint Archive, Paper 2020/1143 (2020), https://eprint.iacr.org/2020/1143</li>

      <li><span id="page-35-7"></span>46. The PML team: PML: Polynomial Matrix Library (2023), version 0.3, https://github.com/vneiger/pml</li>

      <li><span id="page-35-5"></span>47. The Sage Developers: SageMath, the Sage Mathematics Software System (2022), https://www.sagemath.org</li>

      <li><span id="page-35-6"></span>48. V. Shoup, et al.: NTL: A Library for Doing Number Theory. https://libntl.org/</li>

      <li><span id="page-35-9"></span>49. Von Zur Gathen, J., Gerhard, J.: Modern Computer Algebra. Cambridge university press (2013)</li>

    </ul>

    <p class="text-gray-300">As noted at the end of Section 3.4, we do not generate the polynomial system  <span class="math">P_{\\mathcal{G}}</span>  directly in practice. Rather, we construct a related polynomial system iteratively while reducing as many monomials as possible along the way. More formally, for a polynomial h and an ordered sequence of polynomials H, we let  <span class="math">\\operatorname{Red}(h,H)</span>  denote the operation of reducing h by H (according to a specified monomial order). That is,  <span class="math">\\operatorname{Red}(h,H)</span>  is the remainder after performing multivariate division of h by H (see [21, Ch. 2, §3]). For a tuple of polynomials  <span class="math">\\mathbf{h} = (h_1, \\ldots, h_t)</span> , we write  <span class="math">\\operatorname{Red}(\\mathbf{h},H) = (\\operatorname{Red}(h_1,H),\\ldots,\\operatorname{Red}(h_t,H))</span> . Now fix a monomial order, and define  <span class="math">\\mathbf{z}&#x27;_0 = \\mathbf{z}_0</span> . We generate  <span class="math">\\mathbf{p}&#x27;_i = (p&#x27;_{i,1},\\ldots,p&#x27;_{i,l_i})</span>  and the reduced states  <span class="math">\\mathbf{z}&#x27;_i</span>  recursively as follows for  <span class="math">1 \\leq i \\leq r</span>  and  <span class="math">1 \\leq j \\leq l_i</span> .</p>

    <div class="my-4 text-center"><span class="math-block">p&#x27;_{i,j} = \\operatorname{Red} \\left( x_{i,j}^{\\alpha_{i,j}} - \\mathcal{L}_{i,j}(\\boldsymbol{z}&#x27;_{i-1}), \\{ \\boldsymbol{p}&#x27;_1 \\dots, \\boldsymbol{p}&#x27;_{i-1} \\} \\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{z}&#x27;_i = \\operatorname{Red} \\left( G_i(\\boldsymbol{z}&#x27;_{i-1}, \\boldsymbol{x}_i), \\{ \\boldsymbol{p}&#x27;_1, \\dots, \\boldsymbol{p}&#x27;_i \\} \\right),</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathcal{L}_{i,j}</span>  is the polynomial from (3). Finally, we define</p>

    <div class="my-4 text-center"><span class="math-block">g&#x27; = \\operatorname{Red}\\left([G_r(\\boldsymbol{z}_{r-1}&#x27;, \\boldsymbol{x}_r)]_1, \\{\\boldsymbol{p}_1, \\dots, \\boldsymbol{p}_r\\}\\right),</span></div>

    <p class="text-gray-300">and write  <span class="math">P&#x27;_{\\mathcal{G}} = \\{p&#x27;_1, \\dots, p&#x27;_r, g&#x27;\\}</span> . Since the construction of  <span class="math">P&#x27;_{\\mathcal{G}}</span>  only differs from that of  <span class="math">P_{\\mathcal{G}}</span>  by reductions with generators in the ideal  <span class="math">I_{\\mathcal{G}} = \\langle P_{\\mathcal{G}} \\rangle</span>  their ideals should, intuitively speaking, be identical. This intuition is confirmed by the following lemma.</p>

    <p class="text-gray-300">Lemma 6. For any fixed monomial order we have</p>

    <p class="text-gray-300"><span id="page-36-0"></span> <span class="math-block">I_{\\mathcal{G}} = \\langle P_{\\mathcal{G}} \\rangle = \\langle P&#x27;_{\\mathcal{G}} \\rangle</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> For any polynomial h and polynomial sequence H, we can write the reduction operation as  <span class="math">\\operatorname{Red}(h,H)=h+W</span> , for some polynomial  <span class="math">W\\in \\langle H\\rangle</span> . Since the  <span class="math">G_i</span> 's used in the construction of  <span class="math">\\boldsymbol{p}_i&#x27;</span>  and  <span class="math">\\boldsymbol{z}_i&#x27;</span>  are polynomial functions, one can show by induction that</p>

    <p class="text-gray-300"><span id="page-36-1"></span> <span class="math-block">p&#x27;_{i,j} \\in p_{i,j} + \\langle \\{\\boldsymbol{p}_1, \\dots, \\boldsymbol{p}_{i-1}\\} \\rangle, \\qquad z&#x27;_{i,j} \\in z_{i,j} + \\langle \\{\\boldsymbol{p}_1, \\dots, \\boldsymbol{p}_i\\} \\rangle</span>  (10)</p>

    <p class="text-gray-300">holds for all  <span class="math">1 \\leq i \\leq r</span>  and  <span class="math">1 \\leq j \\leq l_i</span> . In particular, we have  <span class="math">g&#x27; \\in g + \\langle \\{\\boldsymbol{p}_1,\\ldots,\\boldsymbol{p}_r\\} \\rangle</span> . Thus it is clear that  <span class="math">P_{\\mathcal{G}}</span>  and  <span class="math">P&#x27;_{\\mathcal{G}}</span>  generate the same polynomial ideal.</p>

    <p class="text-gray-300">The following result relates  <span class="math">P&#x27;_{\\mathcal{G}}</span>  and  <span class="math">P_{\\mathcal{G}}</span>  when Proposition 6 holds. Recall that we write  <span class="math">d_{\\leq i} = d_1 \\cdots d_i</span> , where  <span class="math">d_i = \\deg(G_i)</span> .</p>

    <p class="text-gray-300"><strong>Proposition 9.</strong> Let  <span class="math">P_{\\mathcal{G}}</span>  satisfy the condition of Proposition 6. Then constructing  <span class="math">P&#x27;_{\\mathcal{G}}</span>  w.r.t.  <span class="math">\\prec_{\\mathcal{G}}</span>  is also a FreeLunch system. Moreover, replacing g' in  <span class="math">P&#x27;_{\\mathcal{G}}</span>  with g'/LC(g') yields the unique reduced Gröbner basis for  <span class="math">I_{\\mathcal{G}}</span>  w.r.t.  <span class="math">\\prec_{\\mathcal{G}}</span> .</p>

    <p class="text-gray-300">Proof. By definition of polynomial division, we have  <span class="math">\\operatorname{wt}(\\operatorname{LM}(\\operatorname{Red}(h,H))) \\leq \\operatorname{wt}(\\operatorname{LM}(h))</span> . Since  <span class="math">\\operatorname{LM}(p_{i,j})&#x27;</span>  cannot be reduced by  <span class="math">\\{p_1&#x27;,\\ldots,p_{i-1}&#x27;\\}</span>  under  <span class="math">\\prec_{\\mathcal{G}}</span> , it follows from (10) and the prior discussion that  <span class="math">\\operatorname{LM}(p_{i,j}&#x27;) = \\operatorname{LM}(p_{i,j})</span> . For the similar statement on  <span class="math">\\operatorname{LM}(g&#x27;)</span> , we note that the condition  <span class="math">\\operatorname{LM}(g) = x_0^{d \\leq r}</span>  can only hold if for every i there exist a  <span class="math">j_i</span>  such that  <span class="math">\\operatorname{LM}(z_{i,j_i}) = x_0^{d \\leq i}</span> . By construction of  <span class="math">\\prec_{\\mathcal{G}}</span> , this monomial will not be reduced by  <span class="math">\\{p_1&#x27;,\\ldots,p_{i-1}&#x27;\\}</span> . Again, it follows from (10) that  <span class="math">\\operatorname{LM}(z_{i,j_i}&#x27;) = x_0^{d \\leq i}</span> . In particular,  <span class="math">\\operatorname{LM}(g&#x27;) = \\operatorname{LM}(g)</span> , hence  <span class="math">P_{\\mathcal{G}}&#x27;</span>  is also a FreeLunch system.</p>

    <p class="text-gray-300">For the last assertion, one observes from the way  <span class="math">p_{i,j}</span>  only depends on the variables  <span class="math">x_0, x_1, \\ldots, x_{i-1}, x_{i,j}</span>  that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Red}(p&#x27;_{i,j},P&#x27;_{\\mathcal{G}}\\setminus\\{p&#x27;_{i,j}\\})=\\operatorname{Red}(p&#x27;_{i,j},\\{\\boldsymbol{p}_1\\ldots,\\boldsymbol{p}_{i-1}\\})\\ ,</span></div>

    <p class="text-gray-300">holds for  <span class="math">\\prec_{\\mathcal{G}}</span> . Hence  <span class="math">P&#x27;_{\\mathcal{G}}</span>  is already fully reduced, and replacing g' with  <span class="math">g&#x27;/\\mathrm{LC}(g&#x27;)</span>  makes all polynomials monic.</p>

    <p class="text-gray-300">Remark 2. Recall from Proposition 2 that if H is a Gröbner basis for  <span class="math">\\langle H \\rangle</span> , then  <span class="math">\\operatorname{Red}(h,H)</span>  does not depend on the order of the sequence H. It follows from Proposition 9 that if  <span class="math">P_{\\mathcal{G}}</span>  satisfies the condition of Proposition 6, then the reductions in the construction of  <span class="math">p&#x27;_{i,j}</span> ,  <span class="math">\\mathbf{z}&#x27;_i</span>  and g' are independent of the order of the sequence  <span class="math">\\{\\mathbf{p}_1,\\ldots\\mathbf{p}_i\\}</span> , w.r.t.  <span class="math">\\prec_{\\mathcal{G}}</span> .</p>

    <p class="text-gray-300">Complexity of computing  <span class="math">P&#x27;_{\\mathcal{G}}</span> . We are left with bounding the complexity of computing  <span class="math">P&#x27;_{\\mathcal{G}}</span> , which will yield our estimate for the sysGen step. In the setting we will be interested in, this is expected to be dominated by the cost of applying the last round function  <span class="math">G_r</span>  to compute g', and its reduction by  <span class="math">\\{p&#x27;_1, \\ldots, p&#x27;_r\\}</span> . Our insight is that the reductions involved in the sysGen process are cheaper than the reductions required in matGen, since the reductions are performed on a smaller Gröbner basis; but we do not have a proof for such a statement. However, it is possible to bound the cost of the multiplications performed on the state  <span class="math">z&#x27;_{r-1}</span> when applying  <span class="math">G_r</span> . Let m denote the number of these multiplication, where we recall that m is typically small by design. We reduce by  <span class="math">\\{p&#x27;_1, \\dots, p&#x27;_r\\}</span>  after each multiplication, and will assume that this reduction is negligible compared to the cost of the multiplications themselves. Thus we have m multiplications of multivariate polynomials of maximal degree  <span class="math">d_{\\leq r}</span>  in  <span class="math">x_0</span>  and  <span class="math">\\alpha_{i,j}-1</span>  in  <span class="math">x_{i,j}</span> , for  <span class="math">1 \\leq i \\leq r</span> ,  <span class="math">1 \\leq j \\leq l_i</span> . We can then use the Kronecker trick presented by Moenck [42, Section 3.4] to perform these multiplications in an efficient manner. In short, the Kronecker trick starts by transforming the multivariate polynomials to univariate polynomials. This allows us to perform the multiplication using an efficient univariate multiplication algorithm, before converting the result back to a multivariate polynomial. Moenck describes the algorithm and proves its correctness for any bound on the degree of each variable in both polynomials in the input of multiplication, but only gives a complexity estimate when all bounds are equal. It is, however, easy to verify that the complexity formula for the multivariate multiplication algorithm in our setting will be:</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde{\\mathcal{O}}(d_{\\leq r} \\prod_{\\substack{1 \\leq i \\leq r \\\\ 1 \\leq j \\leq l_i}} 2\\alpha_{i,j}) ,</span></div>

    <p class="text-gray-300">when applying either the Fast Fourier Transform, or Schönhage & Strassen's algorithm to perform the univariate multiplication [49, Chapter 8]. Repeating this m times yields our estimate for cost of multiplications in the  <span class="math">{\\tt sysGen}</span>  step:</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde{\\mathcal{O}}(md \\leq r \\prod_{\\substack{1 \\leq i \\leq r \\\\ 1 \\leq j \\leq l_i}} 2\\alpha_{i,j}) .</span></div>

    <p class="text-gray-300">In comparison, recall that the polyDet step of our analysis is expected by Theorem 1 to require</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde{O}(d_{\\leq r}(\\prod_{\\substack{1 \\leq i \\leq r\\\\1 \\leq j \\leq l_i}} \\alpha_{i,j})^{\\omega})</span></div>

    <p class="text-gray-300">operations in  <span class="math">\\mathbb{F}</span> . Thus, when m remains small, we do not expect the multiplications in sysGen to be the bottleneck of the overall attack.</p>

    <p class="text-gray-300">Use in Experiments. We implemented the Kronecker trick for the experiments we ran with the Flint library [37], using the NTL library [48] for the univariate multiplication; the mapping between flint and NTL polynomial representations was performed by hand. The multivariate multiplications performed for experiments with MAGMA and SageMath used their own built-in functionalities.</p>

    <p class="text-gray-300">The number of rounds that can be bypassed before we need to introduce x<sup>1</sup> depends on the number of branches. For t ≥ 12 branches we can find an easily computable set of input states that allows to bypass the first three rounds of Griffin, so x<sup>1</sup> only appears in the fourth round. We explain in detail how this can be done for t = 12. After that it will become clear that three rounds can also be bypassed for t ∈ {16, 20, 24}, and how to determine how many rounds can be bypassed for t < 12.</p>

    <p class="text-gray-300">Denote the input state to Griffin as</p>

    <div class="my-4 text-center"><span class="math-block">(a_0x_0 + b_0, a_1x_0 + b_1, a_2x_0 + b_2, \\dots, a_{10}x_0 + b_{10}, 0).</span></div>

    <p class="text-gray-300">The a<sup>i</sup> and b<sup>j</sup> are constants in F that we now proceed to determine. Once the a<sup>i</sup> and b<sup>j</sup> are fixed the variable x<sup>0</sup> can be varied freely over F, generating a set of input states for the CICO problem that all have constant input to the x 1/α function in the three first rounds. Figure <a href="#page-38-1">6</a> illustrates the evolution of one of the chosen input states up to the start of round 3.</p>

    <p class="text-gray-300"><span id="page-38-1"></span><img src="_page_38_Figure_5.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 6: Evolution of chosen set of input states to Griffin with 12 branches. Red values give conditions on the a<sup>i</sup> and b<sup>j</sup> such that the input of x <sup>1</sup>/α in the third round becomes a known constant independent of x0.</p>

    <p class="text-gray-300">The values of a<sup>i</sup> and b<sup>j</sup> in Figure <a href="#page-38-1">6</a> can be determined as follows. After the initial linear transformation before the first round, all branches can be expressed as li(a)x<sup>0</sup> + li(b) for 0 ≤ i ≤ 11, where li(·) is a known linear combination. To get 0 on the branches indicated in Figure <a href="#page-38-1">6,</a> the a<sup>i</sup> 's and b<sup>j</sup> 's need to satisfy the following linear equations</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{lll}  l_0(\\mathbf{a}) = 0 &amp; l_0(\\mathbf{b}) = 0 \\\\  l_1(\\mathbf{a}) = 0 &amp; l_1(\\mathbf{b}) = 0 \\\\  l_3(\\mathbf{a}) = 0 &amp; l_3(\\mathbf{b}) = 0 \\\\  l_5(\\mathbf{a}) = 0 &amp; l_5(\\mathbf{b}) = 0 \\\\  l_7(\\mathbf{a}) = 0 &amp; l_7(\\mathbf{b}) = 0 \\\\  l_9(\\mathbf{a}) = 0 &amp; l_1(\\mathbf{b}) = 0 \\\\  l_{10}(\\mathbf{a}) = 0 &amp; l_{10}(\\mathbf{b}) = 0.  \\end{array}</span></div>

    <p class="text-gray-300">With 0 on any two adjacent branches, the input to F will either be all 0, with F(0, 0, 0) being equal to a constant, or the output of F will be multiplied with 0, making sure the value on the branch remains 0. This ensures that the algebraic expressions on the branches stay linear in x0, a and b after the affine transformation at the start of the second round. The need to have input 0 to x <sup>1</sup>/α and x α in the second round gives four more linear constraints</p>

    <p class="text-gray-300"><span class="math-block">l_{17}(\\mathbf{a}) = 0</span>   <span class="math">l_{17}(\\mathbf{b}) = 0</span>   <span class="math">l_{18}(\\mathbf{a}) = 0</span>   <span class="math">l_{18}(\\mathbf{b}) = 0</span> ,</p>

    <p class="text-gray-300">where the γ<sup>i</sup> are known constants.</p>

    <p class="text-gray-300">Before the affine transformation in the second round, most branches will have cubic polynomials in x<sup>0</sup> as their values (the hi(x0) in Figure <a href="#page-38-1">6\\)</a>. These are again linearly mixed in the affine transformation at the end of round two, producing the cubic polynomial</p>

    <div class="my-4 text-center"><span class="math-block">h_9(x_0) = c_3(\\boldsymbol{a}, \\boldsymbol{b})x_0^3 + c_2(\\boldsymbol{a}, \\boldsymbol{b})x_0^2 + c_1(\\boldsymbol{a}, \\boldsymbol{b})x_0 + c_0(\\boldsymbol{a}, \\boldsymbol{b})</span></div>

    <p class="text-gray-300">on the first branch. We want to enforce that c3(a, b) = c2(a, b) = c1(a, b) = 0 such that the input to the x <sup>1</sup>/α function in round three becomes a known constant independent from x0. The expressions for the coefficients are cubic in the a<sup>i</sup> and b<sup>j</sup> , but note that all the polynomials hi(x0) for 0 ≤ i ≤ 8 are made as products of linear factors as</p>

    <div class="my-4 text-center"><span class="math-block">(l_i(\\boldsymbol{a})x_0 + l_i(\\boldsymbol{b}))(l_j(\\boldsymbol{a})x_0 + l_j(\\boldsymbol{b}))(l_k(\\boldsymbol{a})x_0 + l_k(\\boldsymbol{b})),</span></div>

    <p class="text-gray-300">and that h9(x0) is a sum of these. By calculating the coefficients for the x 3 0 , x<sup>2</sup> 0 , and x<sup>0</sup> terms, we see that c3(a, b) is cubic in a, but does not contain b at all. Similarly, c2(a, b) is quadratic in a and linear in b and c1(a, b) is linear in a and quadratic in b.</p>

    <p class="text-gray-300">We can now use the 9 linear equations in a introduced above to eliminate a2, . . . , a<sup>10</sup> from c3(a). This leaves c<sup>3</sup> as c3(a0, a1), a cubic expression in a<sup>0</sup> and a1. Next we fix a<sup>1</sup> to an arbitrary non-zero value (to avoid the trivial solution a<sup>0</sup> = . . . = a<sup>10</sup> = 0) and solve for c3(a0) = 0 using a root-finding algorithm for univariate polynomials. With a<sup>0</sup> and a<sup>1</sup> fixed, all the other a<sup>i</sup> gets fixed as well from the linear constraints from rounds 1 and 2.</p>

    <p class="text-gray-300">Once all a<sup>i</sup> have been found, c2(a, b) = 0 just becomes a linear equation in b. Using this linear equation together with the 9 from above, we can eliminate b1, . . . , b<sup>10</sup> from the last coefficient c1(a, b). With all the a<sup>i</sup> fixed, c<sup>1</sup> then just becomes c1(b0), a quadratic expression in b<sup>0</sup> and we easily solve c1(b0) = 0. This determines all the values for the b<sup>i</sup> .</p>

    <p class="text-gray-300">With the a<sup>i</sup> and b<sup>j</sup> now fixed, we know that the input state from our chosen set will generate polynomials in x<sup>0</sup> of degree 6α + 3 on the branches at the start of round 4. We can then start the basic attack from there, adapting the weighted order of the variables accordingly. When the number of xi-variables is reduced by 3 and with the degree of x<sup>0</sup> bounded to 6α + 3 until the fourth round, the dimension of the Gröbner basis ideal becomes much smaller, which again reduces the overall attack complexity significantly.</p>

    <p class="text-gray-300">When there are more than 12 branches we can do the exact same trick as explained above. The only difference is that there will be more values of a<sup>i</sup> and b<sup>j</sup> that can be chosen arbitrarily when solving for c3(a, b) = c2(a, b) = c1(a, b) = 0. When there are less than 12 branches, there is not enough degrees of freedom to make it through the third round. For t = 8 we can bypass the two first rounds, so x<sup>1</sup> only needs to be introduced in round 3, and for t = 3, 4 it is possible to bypass the first round and introduce x<sup>1</sup> in round 2.</p>

    <p class="text-gray-300">In this section we give explicit solutions to the CICO problem related to a Griffin permutation whose characteristics are specified below. Everything discussed here can be checked by the reviewers using the supplementary material provided in verify.zip.</p>

    <h2 id="sec-27" class="text-2xl font-bold">Parameters of Griffin instances</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prime number: p = 28407454060060787 (55 bits);</li>

      <li>Exponent: α = 3;</li>

      <li>Number of rounds: r ∈ {5, 6, 7};</li>

      <li>Number of branches: t = 12 (corresponds to 10 rounds in the real version);</li>

      <li>Parameters of the quadratic functions: δ<sup>i</sup> = 4(i + 1), µ<sup>i</sup> = 7(i + 1)<sup>2</sup> , i = 0, . . . , r − 1;</li>

      <li>Round constants<a href="#page-40-1">13</a> (up to 7 rounds):</li>

    </ul>

    <p class="text-gray-300"><span id="page-40-1"></span><sup>13</sup> Our Griffin with r ≤ 7 rounds will use constants (c0, . . . , cr−2, c6).</p>

    <pre><code class="language-text">c0 = (24948861045225956, 21203603017242449, 5137804740880040,
     17203989140901077, 15884693750499599, 202426034695061,
     21925627314327927, 14915791625715646, 2270637844838412,
     19287066862534400, 23053628619630528, 20205234482325465)
c1 = (1953994697959081, 13694436956212586, 2244645965787647,
     20803493439220167, 13296675195272853, 18296898451764242,
     20376008308269607, 10239947264048958, 1116873941458788,
     19425600591729552, 20854422412323996, 10085561279368253)
c2 = (16905640598099854, 25230133406843513, 8957962046730991,
     14294289436907403, 10949906559535418, 28179662462119909,
     20848690834284278, 5962920227944130, 15129107418293752,
     6002695762195648, 6114627516150292, 22521669951514122)
c3 = (13008050022403386, 28091350245684079, 23189230572909585,
     8101795236077784, 3593606052472638, 11330866710107896,
     9840541134611106, 13915746912957553, 19822110644988410,
     24750875289653592, 25496607366081073, 2269647499797729)
c4 = (15770582149454036, 4472996328290429, 8197094411507273,
     14151116175893923, 19977244056516294, 22071066831282832,
     10912395968228633, 28293903648852908, 15600461636809584,
     16248565278833955, 23850742575902912, 12384888390231181)
c5 = (24731271392756981, 4234794164011219, 5709721189329773,
     23115678305163655, 11185048660199721, 21406367947811616,
     14929808901464726, 14209993563715217, 19373914823111461,
     12307896526346864, 16319890415782340, 19440350754040851)
c6 = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)</code></pre>

    <p class="text-gray-300">The round constants listed above were generated randomly using the following code in SageMath:</p>

    <pre><code class="language-text">p = 28407454060060787
Fp = F i n i t e F i e l d ( p )
R = 6
b = 12
set_random_seed ( i n t . from_bytes ( b&quot; G r i f f i n &quot; , &quot; l i t t l e &quot; ) )
RC = [ random_vector (Fp , b ) f o r _ i n r an ge (R) ]</code></pre>

    <h2 id="sec-28" class="text-2xl font-bold">Solutions to the CICO problem</h2>

    <p class="text-gray-300">Solutions of the CICO problem for r ∈ {5, 6, 7} are presented here. Griffin<sup>r</sup> denotes r-round Griffin.</p>

    <p class="text-gray-300">Griffin5(0, 3490692521816093, 23601145558450866, , 9967688977125539, 6082447726448232, , 3202643372242143, 14009612926527540, , 3219981769736554, 1403954519004962)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>= (0, 5621630451433068, 19970363721022544, , 19340983417234439, 703450676999922, , 25436703150515389, 27364572020087999, , 12423823785589327, 9583319713824981)</li>

      <li>Griffin5(0, 20508905520120247, 23936168820965785, , 17553236564762600, 3639182016432478, , 3713757452078792, 5123533774106823, , 18526890154199809, 7146019784219766)</li>

      <li>= (0, 398957666284762, 14158444455164092, , 21234778660794826, 254005063154066, , 20943402370356289, 5582293336098692, , 18302255515509522, 26476200309584297)</li>

      <li>Griffin6(0, 15940424764849354, 15734551202904841, , 24464738475171520, 22965208929786740, , 10856186368261439, 8227155735266026, , 2695459349798501, 26535488466949249)</li>

      <li>= (0, 28084819548111304, 27440009447766981, , 15867588640423583, 21846560125606713, , 3230042720230543, 8933226700213982, , 4787108825372316, 24658818061833687)</li>

      <li>Griffin6(0, 13453267118668680, 16821847582014700, , 5399506335051336, 27388226484505332, , 17984517745797377, 8860239602618916, , 2200106791585633, 4277034158946419)</li>

      <li>= (0, 15056970863769267, 16790578228924700, , 19887571512638539, 26391726423500753, , 20813391870109600, 20843251064205404, , 7490737291933204, 20355381094708976)</li>

    </ul>

    <p class="text-gray-300"> <span class="math">\\begin{aligned} &amp; \\text{Griffin}_7(0,471901030567494,19368389705049758,\\\\ &amp; &amp; 6207658171606065,13611402711597287,12429039749894833,\\\\ &amp; &amp; 22884233714242756,18540641300363820,25230426657954964,\\\\ &amp; &amp; 17547513396056919,15871260254068404,5181585218256522) \\end{aligned}</span></p>

    <p class="text-gray-300"> <span class="math">= (0, 24311659110177349, 24245222836079936, \\\\ 1360999973748497, 25535756342488541, 10834064085568113, \\\\ 2487598456547217, 22567275155120838, 2042666706826108, \\\\ 694695024982032, 10782435475712749, 20264250160050251)</span></p>

    <p class="text-gray-300">We can use a trick similar to that used for Griffin to bypass the first round of Arion- <span class="math">\\pi</span>  such that the variable  <span class="math">x_1</span>  is only first introduced in the second round. Unlike Griffin, this method can be applied to any number of branches in Arion- <span class="math">\\pi</span> . However, we can only bypass a single round.</p>

    <p class="text-gray-300">Denote the input state to Arion as</p>

    <div class="my-4 text-center"><span class="math-block">(a_0x_0 + b_0, a_1x_0 + b_1, a_2x_0 + b_2, \\dots, a_{t-2}x_0 + b_{t-2}, 0).</span></div>

    <p class="text-gray-300">The  <span class="math">a_i</span>  and  <span class="math">b_j</span>  are constants in  <span class="math">\\mathbb{F}</span>  that will be determined. Once the  <span class="math">a_i</span>  and  <span class="math">b_j</span>  are fixed, the variable  <span class="math">x_0</span>  can be varied freely over  <span class="math">\\mathbb{F}</span> , generating a set of input states for the CICO problem that all have input 0 to the  <span class="math">x^{1/\\alpha}</span>  function in the first round. Figure 7 illustrates the evolution of one of the chosen input states up to the start of round 2.</p>

    <p class="text-gray-300">The values of  <span class="math">a_i</span>  and  <span class="math">b_j</span>  can, in general, be determined as follows. After the initial matrix multiplication, all branches can be expressed as  <span class="math">l_i(\\boldsymbol{a})x_0 + l_i(\\boldsymbol{b})</span>  for  <span class="math">0 \\le i \\le t-1</span> , where  <span class="math">l_i(\\boldsymbol{a})</span>  and  <span class="math">l_i(\\boldsymbol{b})</span>  are known linear combinations. To get 0 on the last t-2 branches, the  <span class="math">a_i</span> 's and  <span class="math">b_j</span> 's need to satisfy the following linear equations</p>

    <p class="text-gray-300"><span class="math-block">l_2(\\boldsymbol{a}) = 0</span>   <span class="math">l_2(\\boldsymbol{b}) = 0</span>   <span class="math">\\vdots</span>   <span class="math">\\vdots</span>   <span class="math">l_{t-1}(\\boldsymbol{a}) = 0</span>   <span class="math">l_{t-1}(\\boldsymbol{b}) = 0.</span></p>

    <p class="text-gray-300">With 2t-4 equations on 2t-2 variables, these constraints leave two degrees of freedom for the variables in  <span class="math">\\boldsymbol{a}</span>  and  <span class="math">\\boldsymbol{b}</span> . Naively, one could think of additionally imposing the constraints  <span class="math">l_1(\\boldsymbol{a})=0</span>  and  <span class="math">l_1(\\boldsymbol{b})=0</span>  such that only the first branch is nonzero and the degree on  <span class="math">x_0</span>  is further reduced. However, the unique solution to this system is the trivial solution  <span class="math">(\\boldsymbol{a},\\boldsymbol{b})=(0,0)</span> , which is not of interest. Thus, we avoid this by instead imposing arbitrary conditions for two variables  <span class="math">a_k</span>  and  <span class="math">b_l</span>  (as long as  <span class="math">a_k</span>  is set to be a non-zero value to avoid the trivial solution). With  <span class="math">a_k</span>  and  <span class="math">b_l</span>  fixed, all the other variables get fixed, too, from the previous linear constraints. For simplicity, one could fix the values  <span class="math">a_0=1</span>  and  <span class="math">b_0=0</span> , leading to an input state of the form  <span class="math">(x_0,a_1x_0,a_2x_0,\\ldots,a_{t-2}x_0,0)</span> , where all  <span class="math">a_i</span> 's are fixed.</p>

    <p class="text-gray-300"><span id="page-44-1"></span><img src="_page_44_Picture_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 7: Evolution of chosen set of input states to Arion-π with 4 branches. Red values give conditions on the a<sup>i</sup> and b<sup>j</sup> .</p>

    <p class="text-gray-300">With 0 on the last t − 2 input branches, the output of the non-linear layer of Arion-π will be of the form (A(x0), B(x0), 0, . . . , 0), where A and B are polynomials in x<sup>0</sup> of degree 3e and e, respectively. Thus, the input state from our chosen set will generate polynomials in x<sup>0</sup> of degree 3e on the branches after the affine transformation in round 1. We can then start the basic attack from there, adapting the weighted order of the variables accordingly. When the number of xi-variables is reduced by 1 and with the degree of x<sup>0</sup> bounded to 3e until the second round, the dimension of the Gröbner basis ideal becomes smaller, which again reduces the overall attack complexity.</p>

    <p class="text-gray-300">Proof. Recall from Definition <a href="#page-27-0">15</a> that u is defined as u = u<sup>0</sup> through the sequence {ui}0≤i≤r. To simplify the exposition, we will work with the sequence {vi}0≤i≤<sup>r</sup> defined by v<sup>0</sup> = 1, and</p>

    <p class="text-gray-300"><span class="math-block">v_{i+1} = v_i + 2 \\left\\lceil \\frac{v_i}{\\alpha} \\right\\rceil</span> , for  <span class="math">0 \\le i &lt; r</span> .</p>

    <p class="text-gray-300">Note that v<sup>i</sup> = ur−<sup>i</sup> and, in particular, v<sup>r</sup> = u. Define two more integer sequences {ai}0≤i≤<sup>r</sup> and {bi}0≤i≤<sup>r</sup> defined by a<sup>0</sup> = b<sup>0</sup> = 1 and for 0 ≤ i < r</p>

    <div class="my-4 text-center"><span class="math-block">a_{i+1} = \\frac{\\alpha + 2}{\\alpha} a_i, \\qquad b_{i+1} = \\frac{\\alpha + 2}{\\alpha} b_i + 2.</span></div>

    <p class="text-gray-300">As a first step, we will prove a<sup>i</sup> ≤ v<sup>i</sup> ≤ b<sup>i</sup> . This is clearly true for i = 0. Supposing it holds up to some i, then using the identity x ≤ ⌈x⌉ < x + 1, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{\\alpha+2}{\\alpha}v_i \\le v_i + 2\\left\\lceil \\frac{v_i}{\\alpha} \\right\\rceil &lt; \\frac{\\alpha+2}{\\alpha}v_i + 2,</span></div>

    <p class="text-gray-300">Thus, using the induction hypothesis and the definitions of  <span class="math">\\{a_i\\}</span>  and  <span class="math">\\{b_i\\}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">a_{i+1} \\le v_{i+1} \\le b_{i+1}</span></div>

    <p class="text-gray-300">Observe that  <span class="math">a_i = \\left(\\frac{\\alpha+2}{\\alpha}\\right)^i</span> , which proves the left-hand side of the inequality in the proposition. For the right-hand side we note that  <span class="math">\\{b_i\\}</span>  can be written as  <span class="math">b_i = (\\alpha+1)\\left(\\frac{\\alpha+2}{\\alpha}\\right)^i - \\alpha</span> , when  <span class="math">i \\geq 1</span> . Indeed, this can be verified for i=1. Supposing it holds up to some i, then</p>

    <div class="my-4 text-center"><span class="math-block">b_{i+1} = \\frac{\\alpha + 2}{\\alpha}b_i + 2</span></div>

    <div class="my-4 text-center"><span class="math-block">= (\\alpha + 1)\\left(\\frac{\\alpha + 2}{\\alpha}\\right)^{i+1} - \\frac{\\alpha(\\alpha + 2)}{\\alpha} + 2</span></div>

    <div class="my-4 text-center"><span class="math-block">= (\\alpha + 1)\\left(\\frac{\\alpha + 2}{\\alpha}\\right)^{i+1} - \\alpha,</span></div>

    <p class="text-gray-300">and the bounds on u stated in Proposition 8 follows.</p>

    <h2 id="sec-31" class="text-2xl font-bold">F FreeLunch Systems for XHash8</h2>

    <p class="text-gray-300"><strong>Description of XHash8. XHash8</strong> is an SPN with nonlinear S-boxes, multiplication by a fixed MDS matrix M, and addition by round constants  <span class="math">C_i</span> . Its state contains t=12 elements in  <span class="math">\\mathbb{F}_p</span>  where  <span class="math">p=2^{64}-2^{32}+1</span> . The rate is fixed to 8 and capacity 4. There are 3 rounds in total, and each round consists of 3 steps, for a total of 9 steps (plus the initial affine layer (I)). With the cipher state denoted as  <span class="math">\\mathbf{z}=(z_0,\\ldots,z_{11})</span> , one round of XHash8 is constructed from the following functions (excluding  <span class="math">(P3)^{(k)}</span>  which is specified below):</p>

    <div class="my-4 text-center"><span class="math-block">(I): \\mathbf{z} \\mapsto M \\times (C_0 + \\mathbf{z}),</span></div>

    <div class="my-4 text-center"><span class="math-block">(F)^{(k)}: \\mathbf{z} \\mapsto C_{3k} + M \\times (z_0^7, \\dots, z_{11}^7),</span></div>

    <div class="my-4 text-center"><span class="math-block">(B&#x27;)^{(k)}: \\mathbf{z} \\mapsto C_{3k+1} + (z_0^{\\frac{1}{7}}, z_1, z_2^{\\frac{1}{7}}, z_3^{\\frac{1}{7}}, z_4, z_5^{\\frac{1}{7}}, z_6^{\\frac{1}{7}}, z_7, z_8^{\\frac{1}{7}}, z_{10}^{\\frac{1}{7}}, z_{11}^{\\frac{1}{7}}).</span></div>

    <p class="text-gray-300">The last step of a round,  <span class="math">(P3)^{(k)}</span> , consists of naturally mapping z to a state of four elements in a cubic expansion  <span class="math">\\mathbb{F}_{p^3}</span> , denoted  <span class="math">(S_{0,1,2}, S_{3,4,5}, S_{6,7,8}, S_{9,10,11})</span> , and then computing  <span class="math">S_{i,i+1,i+2}^7</span>  and mapping the result back to  <span class="math">\\mathbb{F}_p</span> . After that, like with  <span class="math">(F)^{(k)}</span> , an MDS layer is applied, and the round constant  <span class="math">C_{3k+2}</span>  is added. Effectively,  <span class="math">(P3)^{(k)}</span>  is equivalent to mapping each  <span class="math">z_{3q+r}</span>  to a multivariate polynomial of degree 7 in  <span class="math">z_{3q}, z_{3q+1}, z_{3q+2}</span>  (see also the detailed description in [6, Appendix A]), which is the way we modelize it.</p>

    <p class="text-gray-300">The steps are applied in the following order, from left to right:</p>

    <div class="my-4 text-center"><span class="math-block">(I) \\ (F)^{(1)} (B&#x27;)^{(1)} (P3)^{(1)} (F)^{(2)} (B&#x27;)^{(2)} (P3)^{(2)} (F)^{(3)} (B&#x27;)^{(3)} (P3)^{(3)}.</span></div>

    <p class="text-gray-300">One round preceded by (I) is shown in figure 8, taken from [6].</p>

    <p class="text-gray-300"><span id="page-46-0"></span><img src="_page_46_Figure_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 8: Round i of XHash8 preceded by an (I) step:  <span class="math">(I)(F)^{(i)}(B&#x27;)^{(i)}(P3)^{(i)}</span> .</p>

    <p class="text-gray-300">FreeLunch System for XHash8 Our resolution allows us to solve the CICO problem on one branch. However, since the size of one branch is roughly 64 bits, this CICO problem could simply be solved by making  <span class="math">2^{64}</span>  queries to the permutation, for which our solving algorithm does not give us an advantage. On top of that, the real capacity of XHash8 is c=4 for a security claim of 128 bits. Rather than claiming a full attack on XHash8, we show a special case where a FreeLunch system can be easily extracted. However, the later solving steps, in particular the polyDet step, will still have a very high complexity.</p>

    <p class="text-gray-300">Following the construction of FreeLunch systems from Section 3 we define the initial state as  <span class="math">\\mathbf{z}_0 = (x_0, 0, \\dots, 0)</span>  and add a new variable  <span class="math">x_{i,j}</span>  for  <span class="math">0 \\le i \\le 2</span>  and  <span class="math">j \\in \\{0, 2, 3, 5, 6, 8, 9, 11\\}</span>  after every  <span class="math">(\\cdot)^{1/7}</span> . All other nonlinear operations can be represented as polynomials of degree 7, fixing the weights of the introduced variables to</p>

    <div class="my-4 text-center"><span class="math-block">wt(x_0) = 1, wt(x_{i,j}) = 7^{2i} + 1.</span></div>

    <p class="text-gray-300">We end up with 25 polynomials in 25 variables; 24 of these polynomials have  <span class="math">x_{i,j}^7</span>  as leading monomials and the last polynomial has  <span class="math">x_0^{7^6}</span>  as a leading monomial. The coefficient of the  <span class="math">x_0^{7^6}</span> -term in the last polynomial will be non-zero with a very high probability, ensuring we get a FreeLunch system, with  <span class="math">D_H = 7^{24}</span>  and  <span class="math">\\alpha_0 = 7^6</span> .</p>

    <p class="text-gray-300">Complexity of solving the system. We can solve the system using the algorithm described in Section 3. The complexity of matGen is hard to estimate precisely. The complexity of the polyDet step is:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{O}(D_1^{\\omega}\\alpha_0\\log(\\alpha_0)^2)\\approx 2^{240}</span></div>

    <p class="text-gray-300">when  <span class="math">\\omega = 2.81</span> . Note that this is significantly higher than  <span class="math">2^{64}</span> , the brute force complexity for solving this CICO problem.</p>

    <h2 id="sec-32" class="text-2xl font-bold">G Implementation of the matGen Step</h2>

    <p class="text-gray-300">To the best of our knowledge, the matGen step has not been studied in the literature beyond [28]. Let  <span class="math">\\phi_i</span> ,  <span class="math">i \\in \\{1, \\dots D_1\\}</span> , denote the elements in the standard basis of R/I that is not divisible by  <span class="math">x_0</span> . Then, naively, matGen requires the reductions of  <span class="math">x_0^{\\alpha_0}\\phi_i</span>  by the FreeLunch system (which is a Gröbner basis). The bound on the number of steps in a reduction by a Gröbner basis in a weighted monomial order is not clear, but experiments suggest that the complexity grows with the degree of the polynomial to reduce. In order to give an estimation of the complexity of this step, we implemented matGen along with the FreeLunch attack in section 4 and section 5, and benchmarked it. We implemented a variant of the naive approach: we observed that the computation of NormalForm <span class="math">(x_0^{\\alpha_0}\\phi_i)</span>  can be sped up if  <span class="math">\\phi_i</span>  is not a single variable  <span class="math">x_i</span> . If  <span class="math">\\phi_i = a \\times b</span>  (a and b being non-trivial monomials), compute NormalForm <span class="math">(x_0^{\\alpha_0}a)</span> , and then NormalForm(NormalForm <span class="math">(x_0^{\\alpha_0}a)b</span> ). The intermediary normal form corresponds to another columns of  <span class="math">T_0</span>  and can be considered free if the columns of  <span class="math">T_0</span>  are computed in the right order. In our implementations, we chose  <span class="math">b = x_i</span>  with  <span class="math">\\alpha_i</span>  as low as possible; this seemed to be the fastest approach.</p>`;
---

<BaseLayout title="The Algebraic Freelunch: Efficient Gröbner Basis Attacks Aga... (2024/347)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/347
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="the-algebraic-freelunch-efficient-grobner-basis-attacks-2024" />
  </article>
</BaseLayout>
