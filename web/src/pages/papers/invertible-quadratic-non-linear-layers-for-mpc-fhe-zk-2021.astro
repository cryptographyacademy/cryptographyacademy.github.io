---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/1695';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Invertible Quadratic Non-Linear Layers for MPC-/FHE-/ZK-Friendly Schemes over $\\mathbb F_p^n$';
const AUTHORS_HTML = 'Lorenzo Grassi, Silvia Onofri, Marco Pedicini, Luca Sozzi';

const CONTENT = `    <h3 id="sec-2" class="text-xl font-semibold mt-8"><strong>Application to Poseidon</strong></h3>

    <p class="text-gray-300">Lorenzo Grassi<sup>1</sup>, Silvia Onofri<sup>2</sup>, Marco Pedicini<sup>3</sup> and Luca Sozzi<sup>4</sup></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><sup>1</sup> Radboud University, Nijmegen, the Netherlands, lgrassi@science.ru.nl</li>

      <li><sup>2</sup> Scuola Normale Superiore di Pisa, Pisa, Italy silvia.onofri@sns.it</li>

    </ul>

    <p class="text-gray-300">    <sup>3</sup> Università Roma Tre, Roma, Italy, marco.pedicini@uniroma3.it</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Abstract.</strong> Motivated by new applications such as secure Multi-Party Computation (MPC), Fully Homomorphic Encryption (FHE), and Zero-Knowledge proofs (ZK), many MPC-, FHE- and ZK-friendly symmetric-key primitives that minimize the number of multiplications over  <span class="math">\\mathbb{F}_p</span>  for a large prime p have been recently proposed in the literature. This goal is often achieved by instantiating the non-linear layer via power maps  <span class="math">x\\mapsto x^d</span> . In this paper, we start an analysis of new non-linear permutation functions over  <span class="math">\\mathbb{F}_p^n</span>  that can be used as building blocks in such symmetric-key primitives. Given a local map  <span class="math">F:\\mathbb{F}_p^m\\to\\mathbb{F}_p</span> , we limit ourselves to focus on S-Boxes over  <span class="math">\\mathbb{F}_p^n</span>  for  <span class="math">n\\geq m</span>  defined as  $\\mathcal{S}_F(x_0,x_1,\\ldots,x_{n-1})=y_0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{n-1}<span class="math">  where  </span>y_i:=F(x_i,x_{i+1},\\ldots,x_{i+m-1})$ . As main results, we prove that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>given any quadratic function  <span class="math">F: \\mathbb{F}_p^2 \\to \\mathbb{F}_p</span> , the corresponding S-Box  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  for  <span class="math">n \\geq 3</span>  is never invertible;</li>

      <li>similarly, given any quadratic function  <span class="math">F: \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span> , the corresponding S-Box  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  for  <span class="math">n \\geq 5</span>  is never invertible.</li>

    </ul>

    <p class="text-gray-300">Moreover, for each  <span class="math">p \\geq 3</span> , we present (1st) generalizations of the Lai-Massey construction over  <span class="math">\\mathbb{F}_p^n</span>  defined as before via functions  <span class="math">F:\\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  for each  <span class="math">n=m\\geq 2</span>  and (2nd) (non-trivial) quadratic functions  <span class="math">F:\\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  such that  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  for each  <span class="math">n \\in \\{3,4\\}</span>  is invertible. As an open problem for future work, we conjecture that for each  <span class="math">m\\geq 1</span>  there exists a finite integer  <span class="math">n_{\\max}(m)</span>  such that  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  defined as before via a quadratic function  <span class="math">F:\\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  is not invertible for each  <span class="math">n\\geq n_{\\max}(m)</span> . Finally, as a concrete application, we propose Neptune, a variant of the sponge hash function Poseidon, whose non-linear layer is designed by taking into account the results presented in this paper. We show that this variant leads to a concrete multiplication reduction with respect to Poseidon.</p>

    <p class="text-gray-300"><strong>Keywords:</strong> Multiplicative Complexity · Non-Linear Layer · MPC/FHE/ZK-Friendly Schemes · Poseidon</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6"><strong>Contents</strong></h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Introduction</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.1 The Round Function and the Non-Linear Layer</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.2 Our Contributions</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">Preliminary 2.1 Equivalence Class</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><sup>&</sup>lt;sup>4</sup> Università degli Studi di Milano, Milano, Italy, sozzi.luca97@gmail.com</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Generalized) Lai-Massey Functions over <span class="math">\\mathbb{F}_p^n</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">SI-Lifting <span class="math">S_F</span> over <span class="math">\\mathbb{F}_p^n</span> induced by Quadratic <span class="math">F: \\mathbb{F}_p^2 \\to \\mathbb{F}_p</span><br>4.1 Analysis of the Case <span class="math">n=2</span></td>

            <td class="px-3 py-2 border-b border-gray-700">10<br>10<br>11</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">SI-Lifting <span class="math">S_F</span> over <span class="math">\\mathbb{F}_p^n</span> induced by Quadratic <span class="math">F: \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span><br>5.1 Some Examples for the Case <span class="math">n=3</span></td>

            <td class="px-3 py-2 border-b border-gray-700">13<br>13<br>15<br>17</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof of Theorem 3  6.1 Case: <span class="math">\\alpha_{1,1,0} = \\alpha_{1,0,1} = \\alpha_{0,1,1} = 0</span></td>

            <td class="px-3 py-2 border-b border-gray-700">18<br>18<br>21<br>25<br>28</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">Neptune: a Concrete Application 7.1 POSEIDON and the Hades Design Strategy 7.2 NEPTUNE 7.3 Design Rationale 7.4 Security Analysis 7.4.1 (Invariant) Subspace Trails for the Internal Rounds 7.4.2 Statistical Attacks 7.4.3 Algebraic Attacks 7.5 Multiplicative Complexity: POSEIDON versus NEPTUNE</td>

            <td class="px-3 py-2 border-b border-gray-700">32<br>33<br>35<br>36<br>36<br>37<br>38<br>39</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">Open Problems for Future Research</td>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof of Proposition 3</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">В</td>

            <td class="px-3 py-2 border-b border-gray-700">Practical Verification for Quadratic Functions  B.1 Brute Force Research</td>

            <td class="px-3 py-2 border-b border-gray-700">47<br>48</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\mathbf{C}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">Details about the Security Analysis of Neptune  C.1 Maximum Differential Probability of S'  C.2 Gröbner Basis Attacks on Neptune  C.2.1 Working on the Input and the Output  C.2.2 Working at Round Level.</td>

            <td class="px-3 py-2 border-b border-gray-700">50<br>50<br>51<br>52<br>52</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1 Introduction</h3>

    <p class="text-gray-300">Due to the development of new applications such as Secure Multi-Party Computation (MPC), Fully Homomorphic Encryption (FHE), and Zero-Knowledge proofs (ZK), several symmetric cryptographic schemes have been recently proposed in the literature to minimize the number of non-linear operations (namely, field multiplications) in their natural algorithmic description, often referred to as the <em>multiplicative complexity</em>. (From now on, we also use the term  <span class="math">\\mathbb{F}_p</span> -multiplication – or simply, multiplication – to refer to a non-linear operation over  <span class="math">\\mathbb{F}_p</span> .<sup>1</sup>) Today, many of the mentioned applications operate on  <span class="math">\\mathbb{F}_p \\equiv \\mathrm{GF}(p)</span>  for a large prime  <span class="math">p \\geq 3</span>  (usually, p is of order  <span class="math">2^{64}</span> ,  <span class="math">2^{128}</span>  or even bigger), hence having cryptographic</p>

    <p class="text-gray-300"><span id="page-1-1"></span><sup>&</sup>lt;sup>1</sup>We do not make any distinction between a  <span class="math">\\mathbb{F}_p</span> -multiplication and a square operation, since – to the best of our knowledge – they have similar costs in the mentioned applications.</p>

    <p class="text-gray-300">schemes that have a natural description over  <span class="math">\\mathbb{F}_p</span>  is desirable. MPC-, FHE- and ZK-friendly symmetric-key primitives defined over  <span class="math">\\mathbb{F}_p</span>  include MiMC [AGR+16], GMiMC [AGP+19], HadesMiMC [GLR+20], Rescue [AAB+20], Poseidon [GKR+21], Masta [HKC+20], Ciminion [DGGK21], Pasta [DGH+21], Grendel [Sze21], Reinforced Concrete [GKL+22], HYDRA [GØSW22], and GRIFFIN [GHR+22]. As designing symmetric-key primitives in this domain is relatively new and not well-understood, many of these schemes share some common features. In particular, the non-linear function used in almost all of them is a simple power map  <span class="math">x \\mapsto x^d</span> . One of the few exceptions is Masta, whose non-linear layer resembles the chi-function introduced in [Wol85], which constitutes a prototype for the construction of the new non-linear functions we study in this paper. We start a research of new non-linear permutation functions over  <span class="math">\\mathbb{F}_p^n</span>  that can be used as building blocks in MPC-, FHE- and ZK-friendly symmetric-key primitives.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.1 The Round Function and the Non-Linear Layer</h3>

    <p class="text-gray-300">Symmetric cryptographic schemes including ciphers, permutations and hash functions are typically designed by iterating an efficiently implementable round function a sufficient number of times in order to guarantee the desired security level. Such round function is usually composed of two layers, a non-linear one and a linear/affine one. In more details, the round function of a scheme over  <span class="math">\\mathbb{F}_p^t</span>  for a prime  <span class="math">p \\geq 2</span>  and  <span class="math">t \\geq 1</span>  is usually defined as</p>

    <p class="text-gray-300"><span class="math-block">x \\mapsto c + \\mathcal{M} \\times S\\text{-Box}(x)</span>  (1)</p>

    <p class="text-gray-300">for each  <span class="math">x \\in \\mathbb{F}_p^t</span> , where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>S-Box :  <span class="math">\\mathbb{F}_p^t \\to \\mathbb{F}_p^t</span>  is the non-linear layer (or substitution layer);</li>

      <li><span class="math">\\mathcal{M} \\in \\mathbb{F}_p^{t \\times t}</span>  is an invertible matrix, and  <span class="math">c \\in \\mathbb{F}_p^t</span>  is a round constant or a secret key.</li>

    </ul>

    <p class="text-gray-300">Focusing on Substitution-Permutation Network (SPN) schemes, the non-linear layer is composed of parallel independent non-linear functions. Let  <span class="math">1 \\le n &lt; t</span>  be a divisor of t, that is,  <span class="math">t = n \\cdot t&#x27;</span>  for a certain integer t', and let  <span class="math">\\mathcal{S} : \\mathbb{F}_p^n \\to \\mathbb{F}_p^n</span>  be an invertible non-linear function. Given  <span class="math">x = (x_0, x_1, \\dots, x_{t-1}) \\in \\mathbb{F}_p^t</span> , the substitution layer is usually defined as</p>

    <p class="text-gray-300">S-Box</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$(x) := S(x_0, \\dots, x_{n-1}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S(x_n, \\dots, x_{2n-1}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S(x_{t-n}, \\dots, x_{t-1}),$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> (2)</p>

    <p class="text-gray-300">where  <span class="math">\\cdot \\parallel \\cdot</span>  denotes concatenation. In such a case, the scheme admits an equivalent representation over  <span class="math">\\mathbb{F}_q^{t&#x27;}</span> , where  <span class="math">q:=p^n</span> , and it can be classified as a strong-arranged SPN or as a weak-arranged one depending on the details of the linear layer  <span class="math">\\mathcal{M}</span>  (see [CGG<sup>+</sup>22] for more details).</p>

    <p class="text-gray-300">Invertible Functions over  <span class="math">\\mathbb{F}_p^n \\equiv \\mathbb{F}_{p^n}</span> . Given a non-linear function  <span class="math">\\mathcal{S}</span>  over  <span class="math">\\mathbb{F}_p^n \\equiv \\mathbb{F}_{p^n}</span> , Hermite's criterion gives a characterization of which  <span class="math">\\mathcal{S}</span>  is a permutation and which is not.</p>

    <p class="text-gray-300"><strong>Theorem 1</strong> (Hermite's Criterion [MP13]). Let  <span class="math">q = p^n</span> , where  <span class="math">p \\geq 2</span>  is a prime and n is a positive integer. A polynomial  <span class="math">\\mathcal{F} \\in \\mathbb{F}_q[x]</span>  is a Permutation Polynomial (PP) of  <span class="math">\\mathbb{F}_q</span>  if and only if the following two conditions hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. the reduction of  <span class="math">(\\mathcal{F}(x))^{q-1} \\mod (x^q x)</span>  is a monic polynomial of degree q 1;</li>

      <li>2. for each integer t with  <span class="math">1 \\le t \\le q-2</span>  and  <span class="math">t \\ne 0 \\mod p</span> , the reduction of  <span class="math">(\\mathcal{F}(x))^t \\mod (x^q-x)</span>  has degree  <span class="math">\\le q-2</span> .</li>

    </ul>

    <p class="text-gray-300">However, applying the previous criteria on a generic function over  <span class="math">\\mathbb{F}_{p^n}</span>  in order to establish if it is a permutation or not is in general computational demanding. This is not the case for certain special classes of polynomials, including the power maps and the</p>

    <p class="text-gray-300">Dickson polynomials, for which this question is easy to answer. E.g., a power map  <span class="math">x \\mapsto x^d</span>  over  <span class="math">\\mathbb{F}_{p^n}</span>  for  <span class="math">p \\geq 2</span>  and  <span class="math">n \\geq 1</span>  is invertible if and only if  <span class="math">\\gcd(p^n - 1, d) = 1</span> . As a direct consequence, no quadratic function over  <span class="math">\\mathbb{F}_p</span>  for  <span class="math">p \\geq 3</span>  is invertible.<sup>2</sup></p>

    <p class="text-gray-300">Other examples of invertible functions over  <span class="math">\\mathbb{F}_p</span>  for  <span class="math">p \\geq 3</span>  have been recently proposed in the literature via the Legendre symbol  <span class="math">L_p: \\mathbb{F}_p \\to \\{-1,0,1\\}</span>  defined as  <span class="math">L_p(x) := x^{(p-1)/2}</span>  (recalled in Definition 3), and they include  <span class="math">x \\mapsto x \\cdot (\\alpha + L_p(x))</span>  where  <span class="math">L_p(\\alpha^2 - 1) = 1</span>  introduced by Shallue [Sha12],  <span class="math">x \\mapsto x^d \\cdot L_p(x)</span>  where  <span class="math">\\gcd(d + (p-1)/2, p-1) = 1</span>  introduced by Szepieniec [Sze21], and their generalization proposed in [GKRS22].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Local Maps.</strong> For each  <span class="math">z \\in \\mathbb{F}_p^n</span> , the generic S-Box  $S(z) = y_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{n-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{ over } \\mathbb{F}_p^n$  is defined as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$S(z) := F_0(z)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_1(z)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_{n-1}(z)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where  <span class="math">F_0, F_1, \\ldots, F_{n-1} : \\mathbb{F}_p^n \\to \\mathbb{F}_p</span>  are potentially distinct functions. Instead of working with a generic function  <span class="math">\\mathcal{S}</span> , in this paper we limit ourselves to consider the case in which each value  <span class="math">y_i</span>  is specified according to a single fixed local map  <span class="math">F : \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  for  <span class="math">m \\leq n</span> .</p>

    <p class="text-gray-300"><span id="page-3-1"></span><strong>Definition 1.</strong> Let  <span class="math">p \\geq 3</span>  be a prime integer. Let  <span class="math">1 \\leq m \\leq n</span> , and let  <span class="math">F : \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  be a non-linear function. The function  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  is defined as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$S_F(x_0, x_1, \\dots, x_{n-1}) := y_0 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{n-1}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(3)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math-block">y_i = F(x_i, x_{i+1}, \\dots, x_{i+m-1})</span>  (4)</p>

    <p class="text-gray-300">for each  <span class="math">i \\in \\{0, 1, \\dots, n-1\\}</span> , where the sub-indexes are taken modulo n.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It is easy to check that the function  <span class="math">S_F</span>  is shift-invariant in the sense that  <span class="math">S_F \\circ \\Pi = \\Pi \\circ S_F</span>  for each translation permutation  <span class="math">\\Pi</span>  over  <span class="math">\\mathbb{F}_p^n</span> , that is, a map  $\\Pi(x_0, x_1, \\dots, x_{n-1}) = x_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{1+i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{n-1+i}<span class="math">  for a certain  </span>i \\in \\{0, 1, \\dots, n-1\\}<span class="math"> , where the sub-indexes are taken modulo n. We refer to the shift-invariant function  </span>S_F<span class="math">  over  </span>\\mathbb{F}_p^n<span class="math">  defined via the local map  </span>F : \\mathbb{F}_p^n \\to \\mathbb{F}_p<span class="math">  as the &quot;shift-invariant (m, n)-lifting  </span>S_F<span class="math">  induced by F&quot; (for simplicity, we usually make use of the abbreviation &quot;SI-lifting/SIL function  </span>S_F$ ").</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">One of the most well known examples of this kind of non-linear layer is the shift-invariant lifting  <span class="math">\\mathcal{S}_{\\chi}</span>  over  <span class="math">\\mathbb{F}_2^n</span>  defined via the local map  <span class="math">\\chi: \\mathbb{F}_2^3 \\to \\mathbb{F}_2</span></p>

    <p class="text-gray-300"><span id="page-3-2"></span> <span class="math-block">\\chi(x_0, x_1, x_2) := x_0 + (x_1 + 1) \\cdot x_2 \\mod 2, \\tag{5}</span></p>

    <p class="text-gray-300">first introduced by Wolfram [Wol85] and then re-considered and analyzed by Daemen [Dae95]. The function  <span class="math">\\mathcal{S}_{\\chi}</span>  defined over  <span class="math">\\mathbb{F}_2^n</span>  as in Definition 1 is invertible for each odd  <span class="math">n \\geq 3</span>  (we refer to e.g. [Dae95,MDGM22] for the proof), and it is used as a building component in many designs, including Keccak [BPVA+11,BDPA13], Rasta [DEG+18], Subterranean [DMMR20], among many others. Any shift-invariant lifting  <span class="math">\\mathcal{S}_{\\chi}</span>  over  <span class="math">\\mathbb{F}_2^n</span>  induced by the  <span class="math">\\chi</span>  function as local map, which therefore is a (2,n)-lifting, has several properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>while the degree of  <span class="math">S_{\\chi}</span>  is 2, the degree of  <span class="math">S_{\\chi}^{-1}</span>  (namely, its inverse) is (n+1)/2, that is, it is proportional to the field size (see e.g. [Dae95, Section 6.6.2] for details): hence, the greater is the size of the field n, the greater is the degree of  <span class="math">S_{\\chi}^{-1}</span> . This fact has a crucial impact in order to prevent backward or/and Meet-in-the-Middle (MitM) algebraic attacks, as in the case of Rasta [LSMI21,LSMI22];</li>

      <li>in terms of computational cost (multiplications/ANDs and additions/XORs), the cost of computing  <span class="math">\\mathcal{S}_{\\chi}</span>  over  <span class="math">\\mathbb{F}_2^n</span>  is equal to the cost of computing a non-linear layer defined as the concatenation of n' independent functions  <span class="math">\\mathcal{S}&#x27;_{\\chi}</span>  defined over  <span class="math">\\mathbb{F}_2^{n&#x27;&#x27;}</span>  for  <span class="math">n = n&#x27; \\cdot n&#x27;&#x27;</span> ;</li>

    </ul>

    <p class="text-gray-300"><span id="page-3-0"></span>Let  <span class="math">F(x) = \\alpha \\cdot x^2 + \\beta \\cdot x + \\gamma</span>  with  <span class="math">\\alpha \\neq 0</span>  be a generic quadratic function. Via the change of variable  <span class="math">y = x - \\beta/(2\\alpha)</span> , we obtain  <span class="math">F(y) = \\alpha \\cdot y^2 + \\gamma</span> , which is not invertible since F(y) = F(-y) for each  <span class="math">y \\in \\mathbb{F}_p</span> .</p>

    <p class="text-gray-300">• according to the analysis made in [DMMR20, MDGM22], a scheme instantiated with  <span class="math">S_{\\chi}</span>  over  <span class="math">\\mathbb{F}_2^n</span>  can achieve the same (if not better) security against statistical attacks of a scheme instantiated via a non-linear layer defined as the concatenation of n' independent functions  <span class="math">S&#x27;_{\\chi}</span>  over  <span class="math">\\mathbb{F}_2^{n&#x27;&#x27;}</span>  for  <span class="math">n = n&#x27; \\cdot n&#x27;&#x27;</span>  as before.</p>

    <p class="text-gray-300">Other examples of local maps  <span class="math">F: \\mathbb{F}_2^m \\to \\mathbb{F}_2</span>  which induce an invertible SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_2^n</span>  are listed in [Dae95, App. A.3], including  <span class="math">F: \\mathbb{F}_2^5 \\to \\mathbb{F}_2</span>  defined as</p>

    <div class="my-4 text-center"><span class="math-block">F(x_0, x_1, x_2, x_3, x_4) = x_1 + (x_0 + 1) \\cdot (x_2 + 1) \\cdot x_3 \\cdot x_4 \\quad \\text{or} \\quad F(x_0, x_1, x_2, x_3, x_4) = x_2 + (x_0 + 1) \\cdot (x_1 + 1) \\cdot x_3 \\cdot (x_4 + 1)</span></div>

    <p class="text-gray-300">for which the SI-lifting  <span class="math">S_F</span>  over  <span class="math">\\mathbb{F}_2^n</span>  is always invertible for each  <span class="math">n \\geq 5</span> .</p>

    <p class="text-gray-300">While some results are proposed in the literature for the binary case, to the best of our knowledge, no analogous result is known for the prime field case. In this paper, we pick up this problem, and we study the properties and the multiplicative cost of the SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  induced by a quadratic function  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  for a prime  <span class="math">p \\geq 3</span> . Our goal would be to find a local quadratic map  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  for a prime  <span class="math">p \\geq 3</span>  and for small  <span class="math">m \\in \\{2,3\\}</span>  such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1.  <span class="math">S_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  is invertible for a large class of values of  <span class="math">n \\geq m</span> ;</li>

      <li>2. the cost of computing  <span class="math">S_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  in terms of non-linear operations is bounded by n;</li>

      <li>3.  <span class="math">S_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  has several good/convenient algebraic and statistical properties similar to the ones listed for  <span class="math">S_{\\chi}</span> .</li>

    </ul>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.2 Our Contributions</h3>

    <p class="text-gray-300">Generalized Lai-Massey Construction for n=m. Probably, the easiest example of an invertible function  <span class="math">S_F</span>  over  <span class="math">\\mathbb{F}_p^2</span>  defined via a local map  <span class="math">F: \\mathbb{F}_p^2 \\to \\mathbb{F}_p</span>  is the Lai-Massey construction [LM90], for which  <span class="math">F(x_0, x_1) = x_0 + (x_0 - x_1)^2</span>  and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$S_F(x_0, x_1) = x_0 + (x_0 - x_1)^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_1 + (x_0 - x_1)^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Section 3, we start by presenting generalizations of such construction over  <span class="math">\\mathbb{F}_p^n</span>  for m=n, including (i)  <span class="math">F(x_0,x_1,\\ldots,x_{n-1})=x_0+(\\sum_{i=0}^{n-1}(-1)^i\\cdot x_i)^2</span>  for n=m even and (ii)  <span class="math">F(x_0,x_1,\\ldots,x_{n-1})=x_0+\\sum_{i=0}^{n-1}(x_i-x_{i+1})^2</span>  among others.</p>

    <p class="text-gray-300"><strong>Invertible Quadratic Functions.</strong> Even if the Lai-Massey constructions just presented can be efficiently computed (from the point of view of the multiplicative complexity), a cryptographic scheme based only on such non-linear functions can be potentially broken using e.g. an invariant subspace attack [Vau99] if the linear layer is not chosen appropriately. For this reason, we look for other quadratic functions as possible building blocks of a MPC-/ FHE-/ZK-friendly symmetric-key primitive, and we find the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">F(x_0, x_1, x_2) = \\psi_0 \\cdot x_0 + \\psi_1 \\cdot x_1 + \\psi_2 \\cdot x_2 + (x_0 + x_1 + x_2) \\cdot (\\alpha \\cdot x_0 + \\beta \\cdot x_1 + \\gamma \\cdot x_2)</span>  for which the SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^3</span>  is invertible if  <span class="math">p = 2 \\mod 3</span>  by carefully choosing  <span class="math">\\psi_i, \\alpha, \\beta, \\gamma</span>  as given in Proposition 9;</li>

      <li><span class="math">F(x_0, x_1, x_2) = \\alpha \\cdot (x_0 x_1)^2 + \\beta \\cdot (x_1 x_2)^2 + \\gamma \\cdot (x_2 x_0)^2 + \\varepsilon \\cdot x_0 + \\varepsilon&#x27; \\cdot (x_0 + x_1 + x_2)</span>  for which the SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^3</span>  is invertible if  <span class="math">p = 1 \\mod 3</span>  by carefully choosing  <span class="math">\\alpha, \\beta, \\gamma, \\varepsilon, \\varepsilon&#x27;</span>  as given in Proposition 10;</li>

      <li><span class="math">F(x_0, x_1, x_2) = (x_0 x_1)^2 + (x_1 x_2)^2 + \\alpha \\cdot x_0 + \\beta \\cdot (x_0 + x_1 + x_2)</span>  for which the SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^4</span>  is invertible by carefully choosing  <span class="math">\\alpha, \\beta</span>  as given in Proposition 12.</li>

    </ul>

    <p class="text-gray-300">These functions cover all possible values of  <span class="math">p \\geq 3</span> , and they can be computed via only  <span class="math">n \\in \\{3,4\\}</span>  non-linear operations, that is, t non-linear operations per round (details are given in the following). For comparison, a non-linear layer instantiated via the power map  <span class="math">x \\mapsto x^d</span>  (for  <span class="math">d \\geq 3</span>  so that  <span class="math">\\gcd(d, p-1) = 1</span> ) requires  <span class="math">t \\cdot (\\lfloor \\log_2(d) \\rfloor + \\operatorname{hw}(d) - 1) \\geq 2 \\cdot t</span>  non-linear operations,<sup>3</sup> which is at least double than the cost required for functions in the families just proposed.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">Non-Existence Results. As main results of this paper:</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>in Theorem 2, we prove that there is <strong>no</strong> quadratic function  <span class="math">F: \\mathbb{F}_p^2 \\to \\mathbb{F}_p</span>  such that the induced SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  for  <span class="math">n \\geq 3</span>  is a permutation;</li>

      <li>in Theorem 3, we prove that there is <strong>no</strong> quadratic function  <span class="math">F: \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  such that the induced SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  for  <span class="math">n \\geq 5</span>  is a permutation.</li>

    </ul>

    <p class="text-gray-300">Both results are also supported by our practical experiments, as given in App. B. Regarding the case m=n=2, in Proposition 8 we <em>prove</em> that the only quadratic function  <span class="math">F:\\mathbb{F}_p^2\\to\\mathbb{F}_p</span>  for which the SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^2</span>  is invertible is a Lai-Massey function of the form  <span class="math">F(x_0,x_1)=\\alpha\\cdot x_0+\\beta\\cdot x_1+\\gamma\\cdot (x_0-x_1)^2</span>  for  <span class="math">\\alpha\\neq\\pm\\beta</span> .</p>

    <p class="text-gray-300">Focusing on the case m=3, it is someway surprising when comparing the binary case and the prime case. Indeed, while e.g. the SI-lifting  <span class="math">\\mathcal{S}_{\\chi}</span>  over  <span class="math">\\mathbb{F}_2^n</span>  induced by the local map  <span class="math">\\chi</span>  defined as in (5) is known to be a permutation for each odd  <span class="math">n \\geq 3</span> , here we prove that there is no equivalent of the chi-function when working with a quadratic function  <span class="math">F: \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  for a prime integer  <span class="math">p \\geq 3</span> .</p>

    <p class="text-gray-300">As an open problem for future work, we conjecture that for each  <span class="math">m \\geq 1</span>  there exists a finite integer  <span class="math">n_{\\max}(m)</span>  such that the SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  induced by a quadratic function  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  is not invertible for each  <span class="math">n \\geq n_{\\max}(m)</span>  (see Conjecture 1 for details). Our results and observations suggest that if such conjecture is true, then  <span class="math">n_{\\max}(m)</span>  grows linearly with m (more specifically,  <span class="math">n_{\\max}(m) = 2 \\cdot m - 1</span> ).</p>

    <p class="text-gray-300">Neptune as a Concrete Application. Estimating the impact of quadratic non-linear layers in the design of a generic MPC-/FHE-/ZK-friendly iterative symmetric scheme is in general very hard, since many factors play a crucial role in determining the performance of the scheme in target applications (e.g., the number of rounds required for its security – and so the overall multiplicative complexity – does not depend only on the details of the non-linear layer, but also on the details of the linear layer, on the possible attack scenarios, on the security level, and so on). For this reason, we focus on Poseidon – a sponge hash function [BDPV07, BDPA08] recently proposed for ZK applications – and we show a possible way to modify it based on non-linear layers presented in this paper in order to reduce its multiplicative complexity.</p>

    <p class="text-gray-300">The internal permutation of the sponge hash function Poseidon is based on the Hades design strategy [GLR<sup>+</sup>20] proposed at Eurocrypt 2020. Its main feature and novelty regards the use of both rounds with full S-Box layer and rounds with partial S-Box layer in order to achieve both security and good performance. Here, we take this concept to its extremes. Instead of limiting ourselves to consider an uneven distribution of the S-Boxes, we propose to use two different round functions, one for the internal part and one for the external one. In Section 7, we propose a new sponge hash function called Neptune over  <span class="math">\\mathbb{F}_{p_2}^t</span> , a variant of the hash function Poseidon in which</p>

    <p class="text-gray-300">• the power maps  <span class="math">x \\mapsto x^d</span>  in the external full rounds are replaced by a concatenation of independent S-Boxes defined over  <span class="math">\\mathbb{F}_p^2</span>  via the Lai-Massey construction;</p>

    <p class="text-gray-300"><span id="page-5-0"></span>Given  <span class="math">d = \\sum_{i=0}^{\\lfloor \\log_2(d) \\rfloor} d_i \\cdot 2^i</span>  for  <span class="math">d_i \\in \\{0,1\\}</span> , evaluating  <span class="math">x \\mapsto x^d</span>  can require computing  <span class="math">x^{2^j}</span>  for each  <span class="math">j \\in \\{0,1,\\ldots,\\lfloor \\log_2(d) \\rfloor \\}</span>  for a cost of  <span class="math">\\lfloor \\log_2(d) \\rfloor</span>  non-linear operations, plus other  <span class="math">\\mathrm{hw}(d) - 1</span>  non-linear operations to get  <span class="math">x \\mapsto x^d</span>  (where  <span class="math">\\mathrm{hw}(\\cdot)</span>  is the Hamming weight).</p>

    <p class="text-gray-300">• the power map  <span class="math">x \\mapsto x^d</span>  in the internal partial rounds remains unchanged, but the matrix that instantiates the linear layer of the internal partial rounds is different from the one proposed for the external full rounds.</p>

    <p class="text-gray-300">As we show in there, these changes have the effect of (largely) reducing the multiplicative complexity of Poseidon in the case of large  <span class="math">t \\gg 1</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Notation.</strong> Let p be a prime number (unless specified otherwise, we always assume  <span class="math">p \\geq 3</span> ). Let  <span class="math">\\mathbb{F}_p</span>  denote the field of integer numbers modulo p, and let  <span class="math">\\mathbb{F}_p^n</span>  be the corresponding vector space for  <span class="math">n \\geq 1</span> . (We use the symbol "·" to denote the product between (i) elements of  <span class="math">\\mathbb{F}_p</span>  and (ii) one element of  <span class="math">\\mathbb{F}_p</span>  with one element of  <span class="math">\\mathbb{F}_p^n</span> , while we use the symbol "×" to denote the product between elements of  <span class="math">\\mathbb{F}_p^n</span>  or/and  <span class="math">\\mathbb{F}_p^{n \\times m}</span> .) We use small letters to denote either parameters/indexes or variables and greek letters to denote fixed elements in  <span class="math">\\mathbb{F}_p</span> . Given  <span class="math">x \\in \\mathbb{F}_p^n</span> , we denote by  <span class="math">x_i</span>  its i-th component for each  <span class="math">i \\in \\{0,1,\\ldots,n-1\\}</span> , that is,  <span class="math">x = (x_0, x_1, \\ldots, x_{n-1})</span>  or  $x = x_0 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{n-1}<span class="math"> , where · </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  denotes concatenation. We use capital letters to denote functions from  </span>\\mathbb{F}_p^m<span class="math">  to  </span>\\mathbb{F}_p<span class="math">  for  </span>m \\geq 1<span class="math"> , e.g.,  </span>F : \\mathbb{F}_p^m \\to \\mathbb{F}_p<span class="math">  and the calligraphic font to denote functions over  </span>\\mathbb{F}_p^n<span class="math">  for n &gt; 1, e.g.,  </span>S : \\mathbb{F}_p^n \\to \\mathbb{F}_p^n<span class="math"> . We use the fraktur font (e.g.,  </span>\\mathfrak{X}<span class="math"> ) to denote sets of elements, where  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  denotes the cardinality of the set  </span>\\mathfrak{X}<span class="math"> . We denote by  </span>\\mathrm{circ}(\\mu_0, \\mu_1, \\ldots, \\mu_{n-1}) \\in \\mathbb{F}_p^{n \\times n}$  the circulant matrix</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{circ}(\\mu_0, \\mu_1, \\dots, \\mu_{n-1}) := \\begin{bmatrix} \\mu_0 &amp; \\mu_1 &amp; \\dots &amp; \\mu_{n-2} &amp; \\mu_{n-1} \\\\ \\mu_{n-1} &amp; \\mu_0 &amp; \\dots &amp; \\mu_{n-3} &amp; \\mu_{n-2} \\\\ \\vdots &amp; &amp; &amp; \\vdots \\\\ \\mu_1 &amp; \\mu_2 &amp; \\dots &amp; \\mu_{n-1} &amp; \\mu_0 \\end{bmatrix}.</span></div>

    <p class="text-gray-300">Given a matrix  <span class="math">M \\in \\mathbb{F}_p^{n \\times m}</span> , we denote its transpose by  <span class="math">M^T \\in \\mathbb{F}_p^{m \\times n}</span> .</p>

    <p class="text-gray-300"><strong>Legendre Symbol.</strong> We recall some properties of the Legendre symbol used in the following.</p>

    <p class="text-gray-300"><strong>Definition 2.</strong> Let  <span class="math">p \\geq 3</span>  be a prime number. An integer  <span class="math">\\alpha</span>  is a quadratic residue modulo p if it is congruent to a perfect square modulo p, and it is a quadratic non-residue modulo p otherwise.</p>

    <p class="text-gray-300"><span id="page-6-1"></span><strong>Definition 3.</strong> The Legendre symbol  <span class="math">L_p(\\cdot)</span>  is a function  <span class="math">L_p: \\mathbb{F}_p \\to \\{-1, 0, 1\\}</span>  defined as  <span class="math">L_p(x) := x^{\\frac{p-1}{2}} \\mod p \\in \\{-1, 0, 1\\}</span> , or equivalently  <span class="math">L_p(0) = 0</span>  and</p>

    <div class="my-4 text-center"><span class="math-block">L_p(x) := \\begin{cases} 1 &amp; \\text{if } x \\text{ is a non-zero quadratic residue modulo } p, \\\\ -1 &amp; \\text{if } x \\text{ is a quadratic non-residue modulo } p \\end{cases}.</span></div>

    <p class="text-gray-300"><span id="page-6-2"></span><strong>Proposition 1</strong> ([Nag51]). The Legendre symbol has the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. if  <span class="math">x = y \\mod p</span> , then  <span class="math">L_n(x) = L_n(y)</span> :</li>

      <li>2.  <span class="math">L_p(x \\cdot y) = L_p(x) \\cdot L_p(y)</span> .</li>

    </ul>

    <p class="text-gray-300">Moreover, particular identities include:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">L_p(-1) = 1</span>  if  <span class="math">p = 1 \\mod 4</span> , while  <span class="math">L_p(-1) = -1</span>  if  <span class="math">p = 3 \\mod 4</span> ;</li>

      <li><span class="math">L_p(-3) = 1</span>  if  <span class="math">p = 1 \\mod 3</span> , while  <span class="math">L_p(-3) = -1</span>  if  <span class="math">p = 2 \\mod 3</span> ;</li>

      <li><span class="math">L_p(2) = 1</span>  if  <span class="math">p = 1, 7 \\mod 8</span> , while  <span class="math">L_p(2) = -1</span>  if  <span class="math">p = 3, 5 \\mod 8</span> .</li>

    </ul>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.1 Equivalence Class</h3>

    <p class="text-gray-300">First, we introduce a relation for classifying functions with similar properties.<sup>4</sup></p>

    <p class="text-gray-300"><span id="page-7-4"></span><strong>Definition 4</strong> (Similar Functions). Let  <span class="math">p \\geq 2</span>  be a prime integer. Let  <span class="math">F, F&#x27; : \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  be two functions. F and F' are similar – denoted as  <span class="math">F \\sim F&#x27;</span>  – if and only if</p>

    <p class="text-gray-300"><span id="page-7-5"></span> <span class="math-block">\\forall x \\in \\mathbb{F}_p^m: \\qquad F&#x27;(x) = \\omega \\cdot F(\\mu \\cdot x + \\bar{\\nu}) + \\psi \\tag{6}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where (1st)  <span class="math">\\mu, \\omega \\in \\mathbb{F}_p \\setminus \\{0\\}</span> , (2nd)  <span class="math">\\psi \\in \\mathbb{F}_p</span>  and (3rd)  $\\bar{\\nu} = \\nu \\cdot (1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1) \\in \\mathbb{F}_p^m<span class="math">  for  </span>\\nu \\in \\mathbb{F}_p$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Lemma 1.</strong> The binary relation  <span class="math">\\sim</span>  in Definition 4 is an equivalence relation.</p>

    <p class="text-gray-300"><em>Proof.</em> The relation satisfies Equation (6) therefore the following properties hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>reflexivity  <span class="math">(F \\sim F)</span> : obvious, by choosing  <span class="math">\\mu = \\omega = 1</span> , and  <span class="math">\\psi = \\nu = 0</span> ;</li>

      <li>symmetry  <span class="math">(F \\sim F&#x27; \\text{ implies } F&#x27; \\sim F)</span> : by definition,  <span class="math">F&#x27;(x) = \\omega \\cdot F(\\mu \\cdot x + \\bar{\\nu}) + \\psi</span> . Given  <span class="math">x&#x27; = \\mu \\cdot x + \\bar{\\nu}</span> , then:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\forall x&#x27; \\in \\mathbb{F}_p^m : \\qquad F(x&#x27;) = \\omega^{-1} \\cdot F&#x27;(\\mu^{-1} \\cdot x&#x27; - \\mu^{-1} \\cdot \\bar{\\nu}) - \\psi \\cdot \\omega^{-1};</span></div>

    <p class="text-gray-300">• transitivity  <span class="math">(F \\sim F&#x27; \\text{ and } F&#x27; \\sim F&#x27;&#x27; \\text{ implies } F \\sim F&#x27;&#x27;)</span> : by definition,  <span class="math">F&#x27;(x) = \\omega \\cdot F(\\mu \\cdot x + \\bar{\\nu}) + \\psi</span>  and  <span class="math">F&#x27;&#x27;(x) = \\omega&#x27; \\cdot F&#x27;(\\mu&#x27; \\cdot x + \\bar{\\nu}&#x27;) + \\psi&#x27;</span> . Then</p>

    <div class="my-4 text-center"><span class="math-block">\\forall x \\in \\mathbb{F}_p^m: \\qquad F^{&#x27;&#x27;}(x) = (\\omega \\cdot \\omega&#x27;) \\cdot F\\left((\\mu \\cdot \\mu&#x27;) \\cdot x + (\\bar{\\nu} + \\mu \\cdot \\bar{\\nu}&#x27;)\\right) + (\\psi&#x27; + \\omega&#x27; \\cdot \\psi) \\,. \\quad \\Box</span></div>

    <p class="text-gray-300"><span id="page-7-6"></span><strong>Proposition 2.</strong> Let  <span class="math">p \\geq 2</span>  be a prime integer, and let  <span class="math">F, F&#x27; : \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  be two similar functions. Let  <span class="math">\\mathcal{S}_F, \\mathcal{S}_{F&#x27;} : \\mathbb{F}_p^n \\to \\mathbb{F}_p^n</span>  be the two SI-liftings induced respectively by F and F'. Then,  <span class="math">\\mathcal{S}_F</span>  is invertible if and only if  <span class="math">\\mathcal{S}_{F&#x27;}</span>  is invertible.</p>

    <p class="text-gray-300"><em>Proof.</em> By definition of F' and  <span class="math">S_{F&#x27;}</span> , the <em>i</em>-th output of  <span class="math">S_{F&#x27;}(x_0, x_1, \\ldots, x_{n-1})</span>  is  <span class="math">F&#x27;(x_i, x_{i+1}, \\ldots, x_{i+m-1})</span> , where the sub-indexes are taken modulo n. Since  <span class="math">F&#x27;(x) = \\omega \\cdot F(\\mu \\cdot x + \\bar{\\nu}) + \\psi</span>  for each  <span class="math">x \\in \\mathbb{F}_p^m</span> , it follows that</p>

    <div class="my-4 text-center"><span class="math-block">S_{F&#x27;}(x) = \\omega \\cdot S_F(\\mu \\cdot x + \\bar{\\nu}) + \\bar{\\psi}</span></div>

    <p class="text-gray-300">where  <span class="math">\\omega \\neq 0</span>  and where  <span class="math">\\bar{\\psi} = (\\psi, \\psi, \\dots, \\psi) \\in \\mathbb{F}_p^n</span> . That is,  <span class="math">\\mathcal{S}_{F&#x27;}</span>  is equal to  <span class="math">\\mathcal{S}_F</span>  pre-composed and post-composed with two invertible affine functions. This implies that  <span class="math">\\mathcal{S}_{F&#x27;}</span>  is invertible if and only if  <span class="math">\\mathcal{S}_F</span>  is invertible.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.2 Necessary Conditions for Invertibility</h3>

    <p class="text-gray-300"><strong>Balanced Functions.</strong> As first thing, F has to be balanced for  <span class="math">S_F</span>  to be invertible.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 5</strong> (Balanced Function). Let  <span class="math">p \\geq 2</span>  be a prime integer. Let  <span class="math">F : \\mathbb{F}_p^m \\to \\mathbb{F}_p</span> . We say that F is <strong>balanced</strong> if and only if the pre-image of every element in  <span class="math">\\mathbb{F}_p</span>  has the same cardinality, i.e.  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x \\in \\mathbb{F}_p^m \\mid F(x) = y\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= p^{m-1}<span class="math">  for each  </span>y \\in \\mathbb{F}_p$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-7-2"></span><strong>Proposition 3.</strong> Let  <span class="math">p \\geq 2</span>  be a prime integer. Let be  <span class="math">S_F</span>  a SI-lifting over  <span class="math">\\mathbb{F}_p^n</span>  induced by  <span class="math">F : \\mathbb{F}_p^m \\to \\mathbb{F}_p</span> . If F is not balanced, then  <span class="math">S_F</span>  is not invertible.</p>

    <p class="text-gray-300">The proof of this well known result is given in App. A. A concrete application of it is given in the following proposition:</p>

    <p class="text-gray-300"><span id="page-7-3"></span><sup>&</sup>lt;sup>4</sup>In order to simplify the notation, we denote the product (i) between two elements in  <span class="math">\\mathbb{F}_p</span>  and (ii) between an element of  <span class="math">\\mathbb{F}_p</span>  and one of  <span class="math">\\mathbb{F}_p^m</span>  by using the same symbol "·". Given  <span class="math">x = (x_0, x_1, \\dots, x_{m-1}) \\in \\mathbb{F}_p^m</span>  and  <span class="math">\\mu \\in \\mathbb{F}_p</span> , then  <span class="math">\\mu \\cdot x := (\\mu \\cdot x_0, \\mu \\cdot x_1, \\dots, \\mu \\cdot x_{m-1}) \\in \\mathbb{F}_p^m</span> .</p>

    <p class="text-gray-300"><strong>Proposition 4.</strong> Let  <span class="math">p \\geq 2</span>  be a prime integer. Let  <span class="math">F : \\mathbb{F}_p^2 \\to \\mathbb{F}_p</span>  be</p>

    <div class="my-4 text-center"><span class="math-block">F(x_0, x_1) = \\alpha_{2,0} \\cdot x_0^2 + \\alpha_{1,1} \\cdot x_0 \\cdot x_1 + \\alpha_{0,2} \\cdot x_1^2 + \\alpha_{1,0} \\cdot x_0 + \\alpha_{0,1} \\cdot x_1 + \\alpha_{0,0}.</span></div>

    <p class="text-gray-300">If  <span class="math">\\alpha_{2,0} = \\alpha_{0,2} = 0</span> , then F is <strong>not</strong> a balanced function.</p>

    <p class="text-gray-300"><em>Proof.</em> Note that  <span class="math">\\alpha_{1,1} = \\alpha_{2,0} = \\alpha_{0,2} = 0</span>  would imply that F is a linear function. Hence, we assume  <span class="math">\\alpha_{1,1} \\neq 0</span> . Without loss of generality (W.l.o.g.), we can work with  <span class="math">\\alpha_{0,0} = 0</span> , due to Proposition 2 based on the equivalence class defined in Definition 4. In order to prove the result, we analyse separately two cases: (1st)  <span class="math">\\alpha_{1,0} = \\alpha_{0,1} = 0</span>  and (2nd)  <span class="math">\\alpha_{0,1} \\neq 0</span>  (the proof is analogous for  <span class="math">\\alpha_{1,0} \\neq 0</span> ):</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If  <span class="math">\\alpha_{0,1} = \\alpha_{1,0} = 0</span> , then  <span class="math">F(x_0, x_1) = 0</span>  if  <span class="math">x_0 = 0</span>  or  <span class="math">x_1 = 0</span> . It follows that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F^{-1}(0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ge 2p 1 \\ge p$ , hence F is not balanced;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Working over  <span class="math">\\mathbb{F}_2</span> , we have that  <span class="math">\\alpha_{2,0} = \\alpha_{0,2} = 0</span> , since  <span class="math">x^2 = x</span>  for each  <span class="math">x \\in \\mathbb{F}_2</span> . This implies that there is no quadratic function  <span class="math">F : \\mathbb{F}_2^2 \\to \\mathbb{F}_2</span>  which induces an invertible SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_2^n</span>  for  <span class="math">n \\geq 2</span> , in accordance with the results given in [Dae95].</p>

    <p class="text-gray-300"><strong>Corollary 1.</strong> Let  <span class="math">F: \\mathbb{F}_2^2 \\to \\mathbb{F}_2</span>  be a quadratic function. Then, the SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_2^n</span>  induced by F for  <span class="math">n \\geq 2</span>  is <strong>not</strong> invertible.</p>

    <p class="text-gray-300">Quadratic Functions F. Next, we show a necessary condition that a <em>quadratic</em> function  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  defined as</p>

    <p class="text-gray-300"><span id="page-8-0"></span> <span class="math-block">F(x_0, x_1, \\dots, x_{m-1}) := \\sum_{\\substack{i_0, \\dots, i_{m-1} \\in \\{0, 1, 2\\} \\text{ s.t.} \\\\ i_0 + \\dots + i_{m-1} \\le 2}} \\alpha_{i_0, \\dots, i_{m-1}} \\cdot x_0^{i_0} \\cdot \\dots \\cdot x_{m-1}^{i_{m-1}}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\equiv \\begin{bmatrix} x_0 &amp; x_1 &amp; \\dots &amp; x_{m-1} &amp; 1 \\end{bmatrix} \\times \\begin{bmatrix} \\alpha_{2, 0, \\dots, 0} &amp; \\frac{\\alpha_{1, 1, \\dots, 0}}{2} &amp; \\dots &amp; \\frac{\\alpha_{1, 0, \\dots, 1}}{2} &amp; \\frac{\\alpha_{1, 0, \\dots, 0}}{2} \\\\ \\vdots &amp; &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\ \\frac{\\alpha_{1, 0, \\dots, 1}}{2} &amp; \\alpha_{0, 2, \\dots, 0} &amp; \\dots &amp; \\frac{\\alpha_{0, 0, \\dots, 1}}{2} &amp; \\frac{\\alpha_{0, 0, \\dots, 1}}{2} \\end{bmatrix} \\times \\begin{bmatrix} x_0 \\\\ x_1 \\\\ \\vdots \\\\ x_{m-1} \\\\ 1 \\end{bmatrix}</span></div>

    <div class="my-4 text-center"><span class="math-block">(7)</span></div>

    <p class="text-gray-300">must satisfy in order to guarantee that  <span class="math">\\mathcal{S}_F</span>  can be a permutation.</p>

    <p class="text-gray-300"><span id="page-8-1"></span><strong>Proposition 5.</strong> Let  <span class="math">p \\geq 3</span>  be a prime integer. Let  <span class="math">F : \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  be defined as in (7). Let  <span class="math">\\alpha^{(2)}, \\alpha^{(1)} \\in \\mathbb{F}_p</span>  be the sum of the coefficients of the monomials of degree 2 and 1 respectively, that is,</p>

    <div class="my-4 text-center"><span class="math-block">\\forall l \\in \\{1, 2\\}: \\qquad \\alpha^{(l)} := \\sum_{\\substack{i_0, \\dots, i_{m-1} \\in \\{0, 1, 2\\} \\ s.t. \\\\ i_0 + \\dots + i_{m-1} = l}} \\alpha_{i_0, \\dots, i_{m-1}}.</span></div>

    <div class="my-4 text-center"><span class="math-block">(8)</span></div>

    <p class="text-gray-300">If  <span class="math">\\alpha^{(2)} = \\alpha^{(1)} = 0</span>  or if  <span class="math">\\alpha^{(2)} \\neq 0</span> , then the SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  induced by F is <strong>not</strong> a permutation for each  <span class="math">n \\geq m</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We prove that  <span class="math">S_F</span>  is not a permutation by constructing collisions, that is, by presenting two different elements  <span class="math">z, z&#x27; \\in \\mathbb{F}_p^n</span>  such that  <span class="math">S_F(z) = S_F(z&#x27;)</span>  and  <span class="math">z \\neq z&#x27;</span> . In order to do this, we work with elements of the form  <span class="math">w = (\\hat{w}, \\hat{w}, \\dots, \\hat{w}) \\in \\mathbb{F}_p^n</span> , that is,  <span class="math">w_i = w_j</span>  for each  <span class="math">i, j \\in \\{0, 1, \\dots, n\\}</span> . Over such inputs, the function F reduces to  <span class="math">F(x, x, \\dots, x) = \\alpha^{(2)} \\cdot x^2 + \\alpha^{(1)} \\cdot x + \\alpha_{0,0,\\dots,0}</span> . It follows that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">\\alpha^{(2)} = \\alpha^{(1)} = 0</span> , then  <span class="math">F(x, x, \\dots, x) = \\alpha_{0,0,\\dots,0}</span>  for each  <span class="math">x \\in \\mathbb{F}_p</span> . Hence  <span class="math">\\forall x. \\, u \\in \\mathbb{F}_n: \\qquad \\mathcal{S}_F(x, x, \\dots, x) = \\mathcal{S}_F(y, y, \\dots, y) = (\\alpha_{0.0, \\dots, 0}, \\dots, \\alpha_{0.0, \\dots, 0});</span></li>

      <li>if  <span class="math">\\alpha^{(2)} \\neq 0</span>  and  <span class="math">\\alpha^{(1)} \\neq 0</span> , then  <span class="math">F(x, x, ..., x) = x \\cdot (\\alpha^{(2)} \\cdot x + \\alpha^{(1)}) + \\alpha_{0,0,...,0}</span> . Since  <span class="math">x \\cdot (\\alpha^{(2)} \\cdot x + \\alpha^{(1)}) = 0</span>  if x = 0 or  <span class="math">x = -\\alpha^{(1)}/\\alpha^{(2)}</span> , then</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{S}_F(0,0,\\ldots,0) = \\mathcal{S}_F\\left(-\\frac{\\alpha^{(1)}}{\\alpha^{(2)}}, -\\frac{\\alpha^{(1)}}{\\alpha^{(2)}}, \\ldots, -\\frac{\\alpha^{(1)}}{\\alpha^{(2)}}\\right) = (\\alpha_{0,0,\\ldots,0},\\ldots,\\alpha_{0,0,\\ldots,0});</span></div>

    <p class="text-gray-300">• if  <span class="math">\\alpha^{(2)} \\neq 0</span>  and  <span class="math">\\alpha^{(1)} = 0</span> , then  <span class="math">F(x, x, ..., x) = \\alpha^{(2)} \\cdot x^2 + \\alpha_{0,0,...,0}</span> . It follows that  <span class="math">S_F(x, x, \\dots, x) = S_F(-x, -x, \\dots, -x) = (\\alpha^{(2)} \\cdot x^2 + \\alpha_{0,0,\\dots,0}, \\dots, \\alpha^{(2)} \\cdot x^2 + \\alpha_{0,0,\\dots,0})</span> for each  <span class="math">x \\in \\mathbb{F}_p</span> .</p>

    <p class="text-gray-300">Equivalently,  <span class="math">S_F</span>  can be a permutation only in the case in which  <span class="math">\\alpha^{(2)} = 0</span>  and  <span class="math">\\alpha^{(1)} \\neq 0</span> .</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">(Generalized) Lai-Massey Functions over <span class="math">\\mathbb{F}_n^n</span> 3</h4>

    <p class="text-gray-300">In this section, we propose some generalizations over  <span class="math">\\mathbb{F}_p^n</span>  of the Lai-Massey construction proposed in [LM90] by working with a local map  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  and m = n.</p>

    <p class="text-gray-300"><span id="page-9-1"></span><strong>Proposition 6.</strong> Let  <span class="math">p \\geq 2</span>  be a prime integer. Let  <span class="math">n = m \\geq 2</span>  such that either n is a multiple of p (i.e.,  <span class="math">n = 0 \\mod p</span> ) or n is even (i.e., n = 2n'). Let</p>

    <div class="my-4 text-center"><span class="math-block">F(x_0, x_1, \\dots, x_{n-1}) = \\sum_{i=0}^{n-1} \\mu_i \\cdot x_i + H(\\omega_0 \\cdot x_0 + \\omega_1 \\cdot x_1 + \\dots + \\omega_{n-1} \\cdot x_{n-1}), \\quad (9)</span></div>

    <p class="text-gray-300">where  <span class="math">(\\mu_0, \\ldots, \\mu_{n-1}) \\in \\mathbb{F}_p^n</span>  is such that the circulant matrix  <span class="math">circ(\\mu_0, \\ldots, \\mu_{n-1}) \\in \\mathbb{F}_p^{n \\times n}</span>  is</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">n = 0 \\mod p</span> :  <span class="math">\\omega_i = 1</span>  for each  <span class="math">i \\in \\{0, 1, ..., n-1\\}</span> :</li>

      <li>if  <span class="math">n = 0 \\mod 2</span> :  <span class="math">\\omega_i = (-1)^i</span>  for each  <span class="math">i \\in \\{0, 1, \\dots, n-1\\}</span> , and  <span class="math">H : \\mathbb{F}_p \\to \\mathbb{F}_p</span>  is an even function (that is, H(x) = H(-x)).</li>

    </ul>

    <p class="text-gray-300">Then, the SI-lifting  <span class="math">S_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  induced by F is invertible.</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">y = \\mathcal{S}_F(x)</span>  and let  <span class="math">\\mathcal{C} := \\operatorname{circ}(\\mu_0, \\dots, \\mu_{n-1})</span> . By definition of  <span class="math">\\mathcal{S}_F</span>  and since H is an even function for  <span class="math">n = 0 \\mod 2</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} y_0 \\\\ y_1 \\\\ \\vdots \\\\ y_{n-1} \\end{bmatrix} = \\mathcal{C} \\times \\begin{bmatrix} x_0 \\\\ x_1 \\\\ \\vdots \\\\ x_{n-1} \\end{bmatrix} + \\begin{bmatrix} H\\left(\\sum_{i=0}^{n-1} \\omega_i \\cdot x_i\\right) \\\\ H\\left(\\sum_{i=0}^{n-1} \\omega_i \\cdot x_i\\right) \\\\ \\vdots \\\\ H\\left(\\sum_{i=0}^{n-1} \\omega_i \\cdot x_i\\right) \\end{bmatrix} = \\mathcal{C} \\times \\begin{bmatrix} x_0 + \\frac{1}{\\mu&#x27;} \\cdot H\\left(\\sum_{i=0}^{n-1} \\omega_i \\cdot x_i\\right) \\\\ x_1 + \\frac{1}{\\mu&#x27;} \\cdot H\\left(\\sum_{i=0}^{n-1} \\omega_i \\cdot x_i\\right) \\\\ \\vdots \\\\ x_{n-1} + \\frac{1}{\\mu&#x27;} \\cdot H\\left(\\sum_{i=0}^{n-1} \\omega_i \\cdot x_i\\right) \\end{bmatrix},</span></div>

    <p class="text-gray-300">where  <span class="math">\\mu&#x27; := \\sum_i \\mu_i \\neq 0</span>  since  <span class="math">\\mathcal{C}</span>  is invertible by assumption. Let  <span class="math">z := \\mathcal{C}^{-1} \\times y \\in \\mathbb{F}_p^n</span> . The overall costruction is invertible since</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=0}^{n-1} \\omega_i \\cdot z_i = \\sum_{i=0}^{n-1} \\omega_i \\cdot x_i + \\frac{1}{\\mu&#x27;} \\cdot H\\left(\\sum_{i=0}^{n-1} \\omega_i \\cdot x_i\\right) \\cdot \\sum_{i=0}^{n-1} \\omega_i = \\sum_{i=0}^{n-1} \\omega_i \\cdot x_i.</span></div>

    <p class="text-gray-300">It follows that  <span class="math">x_i = z_i - \\frac{1}{\\mu&#x27;} \\cdot H\\left(\\sum_{j=0}^{n-1} \\omega_j \\cdot z_j\\right)</span>  for each  <span class="math">i \\in \\{0, 1, \\dots, n-1\\}</span> .  By choosing  <span class="math">H(x) = \\beta \\cdot x^2 + \\gamma</span>  for  <span class="math">\\beta, \\gamma \\in \\mathbb{F}_p</span>  and  <span class="math">\\mathcal{C} = \\operatorname{circ}(1, 0, \\dots, 0) \\in \\mathbb{F}_p^n</span> , computing  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  requires just one  <span class="math">\\mathbb{F}_p</span> -multiplication.</p>

    <p class="text-gray-300"><span id="page-10-3"></span><strong>Proposition 7.</strong> Let  <span class="math">p \\geq 2</span>  be a prime integer. Let</p>

    <div class="my-4 text-center"><span class="math-block">F(x_0, x_1, \\dots, x_{n-1}) = \\sum_{i=0}^{n-1} \\mu_i \\cdot x_i + \\gamma \\cdot \\sum_{i=0}^{n-1} H(x_i - x_{i+1}),</span></div>

    <p class="text-gray-300">where  <span class="math">(\\mu_0, \\ldots, \\mu_{n-1}) \\in \\mathbb{F}_p^n</span>  is such that the circulant matrix  <span class="math">\\operatorname{circ}(\\mu_0, \\ldots, \\mu_{n-1}) \\in \\mathbb{F}_p^{n \\times n}</span>  is an invertible matrix and where  <span class="math">\\gamma \\in \\mathbb{F}_p \\setminus \\{0\\}</span> . Then, the SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  induced by F is invertible.</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">y = S_F(x)</span> ,  <span class="math">C := \\operatorname{circ}(\\mu_0, \\dots, \\mu_{n-1})</span>  and let  <span class="math">\\mu&#x27; := \\sum_{i=0}^{n-1} \\mu_i</span> . First of all,  <span class="math">\\mu&#x27; \\neq 0</span>  since C is invertible (indeed, if  <span class="math">\\mu&#x27; = 0</span> , then the sum of all columns of C would be equal to zero, and the matrix would be non-invertible due to the existence of a linear relation among its columns). Based on this consideration, the following equality holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} y_0 \\\\ y_1 \\\\ \\vdots \\\\ y_{n-1} \\end{bmatrix} = \\mathcal{C} \\times \\begin{bmatrix} x_0 + \\frac{\\gamma}{\\mu&#x27;} \\cdot \\sum_{i=0}^{n-1} H(x_i - x_{i+1}) \\\\ x_1 + \\frac{\\gamma}{\\mu&#x27;} \\cdot \\sum_{i=0}^{n-1} H(x_i - x_{i+1}) \\\\ \\vdots \\\\ x_{n-1} + \\frac{\\gamma}{\\mu&#x27;} \\cdot \\sum_{i=0}^{n-1} H(x_i - x_{i+1}) \\end{bmatrix},</span></div>

    <p class="text-gray-300">Let  <span class="math">z := \\mathcal{C}^{-1} \\times y</span> . Working as before, the overall construction is invertible since  <span class="math">z_i - z_{i+1} = x_i - x_{i+1}</span> , which implies  <span class="math">x_i = z_i - \\frac{\\gamma}{\\mu&#x27;} \\cdot \\sum_{j=0}^{n-1} H(z_j - z_{j+1})</span>  for each  <span class="math">i \\in \\{0, 1, \\dots, n-1\\}</span> .  <span class="math">\\square</span></p>

    <p class="text-gray-300">By choosing  <span class="math">H(x) = \\beta \\cdot x^2 + \\gamma</span>  for  <span class="math">\\beta, \\gamma \\in \\mathbb{F}_p</span>  and  <span class="math">C = \\operatorname{circ}(1, 0, \\dots, 0) \\in \\mathbb{F}_p^n</span> , then evaluating the function  <span class="math">S_F</span>  costs n multiplications in  <span class="math">\\mathbb{F}_p</span>  (and just one multiplication for the case n = 3).</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">4.1 Analysis of the Case n=2</h3>

    <p class="text-gray-300">Here we prove that the only quadratic function  <span class="math">F: \\mathbb{F}_p^2 \\to \\mathbb{F}_p</span>  for which  <span class="math">\\mathcal{S}_F</span>  is invertible over  <span class="math">\\mathbb{F}_p^2</span>  is  <span class="math">F(x_0, x_1) = \\gamma_0 \\cdot x_0 + \\gamma_1 \\cdot x_1 + \\gamma_2 \\cdot (x_0 - x_1)^2</span>  where  <span class="math">\\gamma_0 \\neq \\pm \\gamma_1</span> .</p>

    <p class="text-gray-300"><span id="page-10-2"></span><strong>Proposition 8.</strong> Let  <span class="math">p \\geq 3</span>  be a prime integer, and let  <span class="math">F : \\mathbb{F}_p^2 \\to \\mathbb{F}_p</span>  be a quadratic function. The SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^2</span>  induced by F is invertible if and only if</p>

    <div class="my-4 text-center"><span class="math-block">F(x_0, x_1) = \\gamma_0 \\cdot x_0 + \\gamma_1 \\cdot x_1 + \\gamma_2 \\cdot (x_0 - x_1)^2</span></div>

    <p class="text-gray-300">where  <span class="math">\\gamma_0 \\neq \\pm \\gamma_1</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Consider a generic function  <span class="math">G(x_0, x_1) = \\alpha_{1,0} \\cdot x_0 + \\alpha_{0,1} \\cdot x_1 + \\alpha_{2,0} \\cdot x_0^2 + \\alpha_{0,2} \\cdot x_1^2 + \\alpha_{1,1} \\cdot x_0 \\cdot x_1</span> . First of all, if  <span class="math">\\alpha_{2,0} + \\alpha_{0,2} + \\alpha_{1,1} \\neq 0</span> , then the function is not invertible (see Proposition 5). Hence, we assume  <span class="math">\\alpha_{1,1} = -\\alpha_{2,0} - \\alpha_{0,2}</span> , which means</p>

    <div class="my-4 text-center"><span class="math-block">G(x_0, x_1) = \\alpha_{1,0} \\cdot x_0 + \\alpha_{0,1} \\cdot x_1 + (\\alpha_{2,0} \\cdot x_0 - \\alpha_{0,2} \\cdot x_1) \\cdot (x_0 - x_1).</span></div>

    <p class="text-gray-300">If  <span class="math">\\alpha_{2,0} = \\alpha_{0,2}</span>  and  <span class="math">\\alpha_{1,0} \\neq \\alpha_{0,1}</span> , then  <span class="math">G(x_0, x_1) = \\alpha_{1,0} \\cdot x_0 + \\alpha_{0,1} \\cdot x_1 + \\alpha_{2,0} \\cdot (x_0 - x_1)^2</span>  is a generalization of the Lai-Massey construction. Based on the results proposed in the previous section, it is invertible if and only if the circulant matrix  <span class="math">\\operatorname{circ}(\\alpha_{1,0}, \\alpha_{0,1})</span>  is invertible, that is, if  <span class="math">\\alpha_{1,0} \\neq \\pm \\alpha_{0,1}</span> .</p>

    <p class="text-gray-300">Let us now consider the case  <span class="math">\\alpha_{2,0} \\neq \\alpha_{0,2}</span> . We show that the lifting  <span class="math">\\mathcal{S}_G</span>  is never invertible by looking for a collision  <span class="math">\\mathcal{S}_G(x_0, x_1) = \\mathcal{S}_G(y_0, y_1)</span>  with  <span class="math">(x_0, x_1) \\neq (y_0, y_1)</span> . Via</p>

    <p class="text-gray-300">the change of variables  <span class="math">d_i = x_i - y_i</span>  and  <span class="math">s_i = x_i + y_i</span>  for  <span class="math">i \\in \\{0, 1\\}</span> , the system of equations  <span class="math">G(x_0, x_1) = G(y_0, y_1)</span>  and  <span class="math">G(x_1, x_0) = G(y_1, y_0)</span>  to solve corresponds to</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} \\alpha_{2,0} \\cdot d_0 - \\frac{\\alpha_{2,0} + \\alpha_{0,2}}{2} \\cdot d_1 &amp; \\alpha_{0,2} \\cdot d_1 - \\frac{\\alpha_{2,0} + \\alpha_{0,2}}{2} \\cdot d_0 \\\\ \\alpha_{0,2} \\cdot d_0 - \\frac{\\alpha_{2,0} + \\alpha_{0,2}}{2} \\cdot d_1 &amp; \\alpha_{2,0} \\cdot d_1 - \\frac{\\alpha_{2,0} + \\alpha_{0,2}}{2} \\cdot d_0 \\end{bmatrix} \\times \\begin{bmatrix} s_0 \\\\ s_1 \\end{bmatrix} = - \\begin{bmatrix} \\alpha_{1,0} \\cdot d_0 + \\alpha_{0,1} \\cdot d_1 \\\\ \\alpha_{1,0} \\cdot d_1 + \\alpha_{0,1} \\cdot d_0 \\end{bmatrix} \\,.</span></div>

    <p class="text-gray-300">The determinant of the matrix is equal to</p>

    <p class="text-gray-300"><span class="math-block">(\\alpha_{2,0} - \\alpha_{0,2}) \\cdot (\\alpha_{2,0} + \\alpha_{0,2}) \\cdot (d_0 - d_1)^2</span> .</p>

    <p class="text-gray-300">If  <span class="math">\\alpha_{2,0} \\neq \\pm \\alpha_{0,2}</span> , it is sufficient to choose  <span class="math">d_0 \\neq d_1</span>  in order to find a collision (since  <span class="math">d_0 \\neq d_1</span> , at least one among  <span class="math">d_0</span>  and  <span class="math">d_1</span>  are not null). The only remaining case to analyze is  <span class="math">\\alpha_{0,2} = -\\alpha_{2,0}</span> , for which the system of equation reduces to</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha_{2,0} \\cdot (d_0 \\cdot s_0 - d_1 \\cdot s_1) = \\alpha_{1,0} \\cdot d_0 + \\alpha_{0,1} \\cdot d_1,</span></div>

    <div class="my-4 text-center"><span class="math-block">d_0 \\cdot (\\alpha_{1,0} - \\alpha_{0,1}) = d_1 \\cdot (\\alpha_{1,0} - \\alpha_{0,1}).</span></div>

    <p class="text-gray-300">A collision can be easily set up by choosing  <span class="math">d_0 = d_1 \\neq 0</span>  and  <span class="math">s_0, s_1</span>  such that  <span class="math">\\alpha_{2,0} \\cdot (s_0 - s_1) = \\alpha_{1,0} + \\alpha_{0,1}</span>  (note that  <span class="math">\\alpha_{2,0} \\neq 0</span> , otherwise G is linear).</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">4.2 Analysis of the Case <span class="math">n \\geq 3</span></h3>

    <p class="text-gray-300">As one of the main results of this paper, we prove that given any quadratic function  <span class="math">F: \\mathbb{F}_p^2 \\to \\mathbb{F}_p</span> , then the SI-lifting  <span class="math">\\mathcal{S}_F</span>  induced by the local map F over  <span class="math">\\mathbb{F}_p^n</span>  is <strong>never</strong> invertible for each  <span class="math">n \\geq 3</span> .</p>

    <p class="text-gray-300"><span id="page-11-1"></span><strong>Theorem 2.</strong> Let  <span class="math">p \\geq 3</span>  be a prime integer. Let  <span class="math">F : \\mathbb{F}_p^2 \\to \\mathbb{F}_p</span>  be a function of degree 2. The lifting  <span class="math">\\mathcal{S}_F</span>  induced by F over  <span class="math">\\mathbb{F}_p^n</span>  is <strong>never</strong> a permutation for each  <span class="math">n \\geq 3</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Due to the results given in Proposition 5, here we limit ourselves to consider the case</p>

    <p class="text-gray-300"><span id="page-11-2"></span> <span class="math-block">\\alpha^{(2)} = \\alpha_{2,0} + \\alpha_{1,1} + \\alpha_{0,2} = 0 \\tag{10}</span></p>

    <p class="text-gray-300">and  <span class="math">\\alpha^{(1)} = \\alpha_{0,1} + \\alpha_{1,0} \\neq 0</span> .</p>

    <p class="text-gray-300">We prove the result for the case n=3. Our goal is to prove that for each function  <span class="math">F: \\mathbb{F}_p^2 \\to \\mathbb{F}_p</span>  of degree 2 defined as in (7), it is possible to find a collision, that is, two different inputs  <span class="math">x,y \\in \\mathbb{F}_p^3</span>  such that  <span class="math">F(x_0,x_1)=F(y_0,y_1), \\ F(x_1,x_2)=F(y_1,y_2)</span>  and  <span class="math">F(x_2,x_0)=F(y_2,y_0)</span> . By assuming  <span class="math">x_0=y_0=0</span> , any collision for n=3 can be easily generalized for each  <span class="math">n\\geq 4</span> . In fact, given a collision for n=3, a collision for  <span class="math">n\\geq 4</span>  can be easily set up by working with  <span class="math">x,y\\in\\mathbb{F}_p^n</span>  where  <span class="math">x_i=y_i=0</span>  for each  <span class="math">i\\geq 3</span> , that is,</p>

    <div class="my-4 text-center"><span class="math-block">S_F(0, x_1, x_2) = S_F(0, y_1, y_2) \\longrightarrow S_F(0, x_1, x_2, 0, 0, \\dots, 0) = S_F(0, y_1, y_2, 0, 0, \\dots, 0),</span></div>

    <p class="text-gray-300">since</p>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in \\{3, \\dots, n-1\\}: F(x_i, x_{i+1}) = F(0, 0) = F(y_i, y_{i+1}).</span></div>

    <p class="text-gray-300">Let  <span class="math">x_0 = y_0 = 0</span>  and let n = 3. The condition  <span class="math">S_F(0, x_1, x_2) = S_F(0, y_1, y_2)</span>  implies</p>

    <p class="text-gray-300">i.  <span class="math">F(0,x_1) = F(0,y_1)</span> , which is satisfied if and only if</p>

    <div class="my-4 text-center"><span class="math-block">(x_1 - y_1) \\cdot (\\alpha_{0,2} \\cdot (x_1 + y_1) + \\alpha_{0,1}) = 0 \\longrightarrow x_1 = y_1 \\text{ or } y_1 = -x_1 - \\frac{\\alpha_{0,1}}{\\alpha_{0,2}},</span></div>

    <p class="text-gray-300">assuming  <span class="math">\\alpha_{0,2} \\neq 0</span>  in this second case;</p>

    <p class="text-gray-300">ii.  <span class="math">F(x_2,0) = F(y_2,0)</span> , which is satisfied if and only if</p>

    <p class="text-gray-300"><span class="math-block">x_2 = y_2</span>  or  <span class="math">y_2 = -x_2 - \\frac{\\alpha_{1,0}}{\\alpha_{2,0}}</span> ,</p>

    <p class="text-gray-300">assuming  <span class="math">\\alpha_{2,0} \\neq 0</span>  in this second case.</p>

    <p class="text-gray-300">Based on these considerations, we propose separate collisions for the cases (1st)  <span class="math">\\alpha_{2,0}</span> ,  <span class="math">\\alpha_{1,1} \\neq 0</span> , (2nd)  <span class="math">\\alpha_{2,0} = 0</span>  and (3rd)  <span class="math">\\alpha_{1,1} = 0</span> . Since no condition is imposed on  <span class="math">\\alpha_{0,2}</span> , these three cases cover all possible quadratic functions F that have not been already excluded by Proposition 5. Indeed, if two coefficients among  <span class="math">\\alpha_{0,2}, \\alpha_{2,0}, \\alpha_{1,1}</span>  are equal to zero, then all three coefficients are null due to (10), and the function becomes linear.</p>

    <p class="text-gray-300">Case:  <span class="math">\\alpha_{2,0}, \\alpha_{1,1} \\neq 0</span> . We propose a collision by working with two inputs of the form  <span class="math">(0, x_1, x_2)</span>  and  <span class="math">(0, x_1, -x_2 - \\frac{\\alpha_{1,0}}{\\alpha_{2,0}})</span> . Due to the given considerations (i) and (ii), the conditions  <span class="math">F(0, x_1) = F(0, x_1)</span>  and  <span class="math">F(x_2, 0) = F(-x_2 - \\frac{\\alpha_{1,0}}{\\alpha_{2,0}}, 0)</span>  are always satisfied for each  <span class="math">x_1, x_2 \\in \\mathbb{F}_p</span> . Hence, it is sufficient to find  <span class="math">x_1, x_2</span>  such that the condition  <span class="math">F(x_1, x_2) = F(x_1, -x_2 - \\frac{\\alpha_{1,0}}{\\alpha_{2,0}})</span>  is verified.</p>

    <p class="text-gray-300">By choosing  <span class="math">x_1 = \\frac{\\alpha_{0,2} \\cdot \\alpha_{1,0}}{\\alpha_{1,1} \\cdot \\alpha_{2,0}} - \\frac{\\alpha_{0,1}}{\\alpha_{1,1}}</span> , we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\forall x \\in \\mathbb{F}_p: \\qquad \\mathcal{S}_F\\left(0, \\frac{\\alpha_{0,2} \\cdot \\alpha_{1,0}}{\\alpha_{1,1} \\cdot \\alpha_{2,0}} - \\frac{\\alpha_{0,1}}{\\alpha_{1,1}}, x\\right) = \\mathcal{S}_F\\left(0, \\frac{\\alpha_{0,2} \\cdot \\alpha_{1,0}}{\\alpha_{1,1} \\cdot \\alpha_{2,0}} - \\frac{\\alpha_{0,1}}{\\alpha_{1,1}}, -x - \\frac{\\alpha_{1,0}}{\\alpha_{2,0}}\\right),</span></div>

    <p class="text-gray-300">since</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} F\\left(\\frac{\\alpha_{0,2}\\cdot\\alpha_{1,0}-\\alpha_{0,1}\\cdot\\alpha_{2,0}}{\\alpha_{1,1}\\cdot\\alpha_{2,0}},x\\right) &amp;= F\\left(\\frac{\\alpha_{0,2}\\cdot\\alpha_{1,0}-\\alpha_{0,1}\\cdot\\alpha_{2,0}}{\\alpha_{1,1}\\cdot\\alpha_{2,0}},-x-\\frac{\\alpha_{1,0}}{\\alpha_{2,0}}\\right) \\\\ &amp;= &amp;\\alpha_{0,2}\\cdot x^2 + \\frac{\\alpha_{0,2}\\cdot\\alpha_{1,0}}{\\alpha_{2,0}}\\cdot x + \\frac{\\left(\\alpha_{0,2}\\cdot\\alpha_{1,0}-\\alpha_{2,0}\\cdot\\alpha_{0,1}\\right)^2}{\\alpha_{1,1}^2\\cdot\\alpha_{2,0}} + \\frac{\\alpha_{1,0}\\cdot\\left(\\alpha_{0,2}\\cdot\\alpha_{1,0}-\\alpha_{0,1}\\cdot\\alpha_{2,0}\\right)}{\\alpha_{1,1}\\cdot\\alpha_{2,0}} \\,. \\end{split}</span></div>

    <p class="text-gray-300">Note that no condition on  <span class="math">\\alpha_{0,2} \\in \\mathbb{F}_p</span>  is imposed.</p>

    <p class="text-gray-300">Case:  <span class="math">\\alpha_{2,0} = 0</span> . We propose a collision by working with two inputs of the form  <span class="math">(0, x_1, x_2)</span>  and  <span class="math">(0, -x_1 - \\frac{\\alpha_{0,1}}{\\alpha_{0,2}}, x_2)</span> . Due to the given consideration (i) and (ii), the conditions  <span class="math">F(0, x_1) = F(0, -x_1 - \\frac{\\alpha_{0,1}}{\\alpha_{0,2}})</span>  and  <span class="math">F(x_2, 0) = F(x_2, 0)</span>  are always satisfied for each  <span class="math">x_1, x_2 \\in \\mathbb{F}_p</span> . Hence, it is sufficient to find  <span class="math">x_1, x_2</span>  such that the condition  <span class="math">F(x_1, x_2) = F(-x_1 - \\frac{\\alpha_{0,1}}{\\alpha_{0,2}}, x_2)</span>  is verified.</p>

    <p class="text-gray-300">By choosing  <span class="math">x_2 = -\\frac{\\alpha_{1,0}}{\\alpha_{1,1}}</span> , we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\forall x \\in \\mathbb{F}_p: \\qquad \\mathcal{S}_F\\left(0, x, -\\frac{\\alpha_{1,0}}{\\alpha_{1,1}}\\right) = \\mathcal{S}_F\\left(0, -x - \\frac{\\alpha_{0,1}}{\\alpha_{0,2}}, -\\frac{\\alpha_{1,0}}{\\alpha_{1,1}}\\right),</span></div>

    <p class="text-gray-300">since</p>

    <div class="my-4 text-center"><span class="math-block">F\\left(x, -\\frac{\\alpha_{1,0}}{\\alpha_{1,1}}\\right) = F\\left(-x - \\frac{\\alpha_{0,1}}{\\alpha_{0,2}}, -\\frac{\\alpha_{1,0}}{\\alpha_{1,1}}\\right) = -\\frac{\\alpha_{1,0}\\cdot(\\alpha_{0,1}+\\alpha_{1,0})}{\\alpha_{1,1}}\\,,</span></div>

    <p class="text-gray-300">where  <span class="math">\\alpha_{1,1} = -\\alpha_{0,2} \\neq 0</span>  due to Equation (10) and since  <span class="math">\\alpha_{2,0} = 0</span> .</p>

    <p class="text-gray-300">Case:  <span class="math">\\alpha_{1,1} = 0</span> . We propose a collision by working with two inputs of the form  <span class="math">(0, x_1, x_2)</span>  and  <span class="math">(0, -x_1 - \\frac{\\alpha_{0,1}}{\\alpha_{0,2}}, -x_2 - \\frac{\\alpha_{1,0}}{\\alpha_{2,0}})</span> . Due to the given consideration (i) and (ii), the conditions  <span class="math">F(0, x_1) = F(0, -x_1 - \\frac{\\alpha_{0,1}}{\\alpha_{0,2}})</span>  and  <span class="math">F(x_2, 0) = F(-x_2 - \\frac{\\alpha_{1,0}}{\\alpha_{2,0}}, 0)</span>  are always satisfied for each  <span class="math">x_1, x_2 \\in \\mathbb{F}_p</span> . Hence, it is sufficient to find  <span class="math">x_1, x_2</span>  such that the condition  <span class="math">F(x_1, x_2) = F(-x_1 - \\frac{\\alpha_{0,1}}{\\alpha_{0,2}}, -x_2 - \\frac{\\alpha_{1,0}}{\\alpha_{2,0}})</span>  is verified.</p>

    <p class="text-gray-300">By choosing  <span class="math">x_2 = x</span>  and  <span class="math">x_1 = -x + \\frac{\\alpha_{1,0} - \\alpha_{0,1}}{2 \\cdot \\alpha_{0,2}}</span> , we have that</p>

    <div class="my-4 text-center"><span class="math-block">S_F\\left(0, -x + \\frac{\\alpha_{1,0} - \\alpha_{0,1}}{2 \\cdot \\alpha_{0,2}}, x\\right) = S_F\\left(0, x - \\frac{\\alpha_{1,0} + \\alpha_{0,1}}{2 \\cdot \\alpha_{0,2}}, -x - \\frac{\\alpha_{1,0}}{\\alpha_{2,0}}\\right),</span></div>

    <p class="text-gray-300">since</p>

    <div class="my-4 text-center"><span class="math-block">F\\left(-x + \\frac{\\alpha_{1,0} - \\alpha_{0,1}}{2 \\cdot \\alpha_{0,2}}, x\\right) = F\\left(x - \\frac{\\alpha_{1,0} + \\alpha_{0,1}}{2 \\cdot \\alpha_{0,2}}, -x - \\frac{\\alpha_{1,0}}{\\alpha_{2,0}}\\right) = \\frac{\\alpha_{1,0}^2 - \\alpha_{0,1}^2}{4 \\cdot \\alpha_{0,2}}</span></div>

    <p class="text-gray-300">where  <span class="math">\\alpha_{2,0} = -\\alpha_{0,2} \\neq 0</span>  due to Equation (10) and since  <span class="math">\\alpha_{1,1} = 0</span> .</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">SI-Lifting <span class="math">\\mathcal{S}_F</span> over <span class="math">\\mathbb{F}_n^n</span> induced by Quadratic <span class="math">F:\\mathbb{F}_n^3 \\to \\mathbb{F}_p</span> 5</h4>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">5.1 Some Examples for the Case n=3</h4>

    <p class="text-gray-300">Example of quadratic functions  <span class="math">F: \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  for which the SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^3</span>  is invertible are given in Proposition 6-7. Other examples are proposed in the following.</p>

    <p class="text-gray-300"><strong>Case:</strong>  <span class="math">p=2 \\mod 3</span> . First, we present a family of functions  <span class="math">F: \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  for which the induced SI-lifting  <span class="math">S_F</span>  over  <span class="math">\\mathbb{F}_p^3</span>  is a permutation if  <span class="math">p=2 \\mod 3</span> .</p>

    <p class="text-gray-300"><span id="page-13-2"></span><strong>Proposition 9.</strong> Let  <span class="math">p \\geq 5</span>  be a prime integer such that  <span class="math">p = 2 \\mod 3</span> . Let  <span class="math">\\alpha, \\beta \\in \\mathbb{F}_p</span>  and  <span class="math">\\psi_0, \\psi_1, \\psi_2 \\in \\mathbb{F}_p</span>  such that (1st)  <span class="math">\\sum_{i=0}^2 \\psi_i \\neq 0</span>  and (2nd) one of three following conditions is satisfied: (i)  <span class="math">\\psi_1 = \\psi_2</span>  and  <span class="math">\\psi_0 \\neq \\psi_1</span>  and  <span class="math">2 \\cdot \\alpha + \\beta \\neq 0</span> ; (ii)  <span class="math">\\psi_0 = \\psi_2</span>  and  <span class="math">\\psi_0 \\neq \\psi_1</span>  and  <span class="math">2 \\cdot \\beta + \\alpha \\neq 0</span> ; (iii)  <span class="math">\\psi_0 = \\psi_1</span>  and  <span class="math">\\psi_0 \\neq \\psi_2</span>  and  <span class="math">\\alpha - \\beta \\neq 0</span> . Given  <span class="math">F : \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  defined as</p>

    <p class="text-gray-300">Given <span class="math-block">F: \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  defined as</p>

    <div class="my-4 text-center"><span class="math-block">F(x_0, x_1, x_2) = \\psi_0 \\cdot x_0 + \\psi_1 \\cdot x_1 + \\psi_2 \\cdot x_2 + (x_0 + x_1 + x_2) \\cdot (\\alpha \\cdot x_0 + \\beta \\cdot x_1 - (\\alpha + \\beta) \\cdot x_2),</span></div>

    <p class="text-gray-300">the SI-lifting  <span class="math">S_F</span>  over  <span class="math">\\mathbb{F}_p^3</span>  induced by F is invertible.</p>

    <p class="text-gray-300"><em>Proof.</em> Note that  <span class="math">\\alpha = \\beta = 0</span>  is never possible. Given  <span class="math">y_i = F(x_i, x_{i+1}, x_{i+2})</span>  for each  <span class="math">i \\in \\{0, 1, 2\\}</span>  (where the sub-indexes are taken modulo 3), then</p>

    <div class="my-4 text-center"><span class="math-block">y_0 + y_1 + y_2 = (\\psi_0 + \\psi_1 + \\psi_2) \\cdot (x_0 + x_1 + x_2)</span></div>

    <p class="text-gray-300">where  <span class="math">\\psi_0 + \\psi_1 + \\psi_2 \\neq 0</span>  by assumption. Let  <span class="math">\\hat{y} := (y_0 + y_1 + y_2)/(\\psi_0 + \\psi_1 + \\psi_2)</span> , where  <span class="math">\\hat{y} = 0</span>  if and only if  <span class="math">x_0 + x_1 + x_2 = y_0 + y_1 + y_2 = 0</span> . The system of equations for  <span class="math">\\mathcal{S}(x) = y</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} \\alpha \\cdot \\hat{y} + \\psi_0 &amp; \\beta \\cdot \\hat{y} + \\psi_1 &amp; -(\\alpha + \\beta) \\cdot \\hat{y} + \\psi_2 \\\\ -(\\alpha + \\beta) \\cdot \\hat{y} + \\psi_2 &amp; \\alpha \\cdot \\hat{y} + \\psi_0 &amp; \\beta \\cdot \\hat{y} + \\psi_1 \\\\ \\beta \\cdot \\hat{y} + \\psi_1 &amp; -(\\alpha + \\beta) \\cdot \\hat{y} + \\psi_2 &amp; \\alpha \\cdot \\hat{y} + \\psi_0 \\end{bmatrix} \\times \\begin{bmatrix} x_0 \\\\ x_1 \\\\ x_2 \\end{bmatrix} = \\begin{bmatrix} y_0 \\\\ y_1 \\\\ y_2 \\end{bmatrix}.</span></div>

    <p class="text-gray-300">By simple computation, the matrix is invertible if</p>

    <div class="my-4 text-center"><span class="math-block">(\\psi_0 + \\psi_1 + \\psi_2) \\cdot \\left( 3 \\cdot (\\alpha^2 + \\alpha \\cdot \\beta + \\beta^2) \\cdot \\hat{y}^2 + 3 \\cdot (\\alpha \\cdot (\\psi_0 - \\psi_2) + \\beta \\cdot (\\psi_1 - \\psi_2)) \\cdot \\hat{y} + (\\psi_0^2 + \\psi_1^2 + \\psi_2^2 - \\psi_0 \\cdot \\psi_1 - \\psi_1 \\cdot \\psi_2 - \\psi_0 \\cdot \\psi_2) \\right) \\neq 0.</span></div>

    <p class="text-gray-300">If  <span class="math">\\hat{y} = 0</span> , then the matrix is invertible, since  <span class="math">\\psi_0^2 + \\psi_1^2 + \\psi_2^2 - \\psi_0 \\cdot \\psi_1 - \\psi_1 \\cdot \\psi_2 - \\psi_0 \\cdot \\psi_2</span>  is different from zero by assumption on  <span class="math">\\psi_0, \\psi_1, \\psi_2</span> .</p>

    <p class="text-gray-300">If  <span class="math">\\hat{y} \\neq 0</span> , first note that the coefficient  <span class="math">\\alpha^2 + \\alpha \\cdot \\beta + \\beta^2</span>  of  <span class="math">\\hat{y}^2</span>  is always different from zero for each  <span class="math">\\alpha, \\beta</span>  since -3 is not a square modulo p due to the assumption  <span class="math">p = 2 \\mod 3</span>  (see Proposition 1). Indeed,  <span class="math">\\alpha^2 + \\alpha \\cdot \\beta + \\beta^2 = 0</span>  for  <span class="math">\\beta \\neq 0</span>  is equivalent to  <span class="math">z^2 + z + 1 = 0</span>  for  <span class="math">z = \\alpha/\\beta</span> , which admits as solutions  <span class="math">(-2 \\pm \\sqrt{-3})/2</span> . Since -3 is a quadratic non-residue</p>

    <p class="text-gray-300">modulo p, then no solution exists. Hence, assuming  <span class="math">\\psi_1 = \\psi_2</span>  (analogous for the others), the determinant is equal to zero if and only if</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{y} = \\frac{-3 \\cdot \\alpha \\cdot (\\psi_0 - \\psi_2) \\pm \\sqrt{-3 \\cdot (\\psi_0 - \\psi_2)^2 \\cdot (\\alpha + 2 \\cdot \\beta)^2}}{6 \\cdot (\\alpha^2 + \\alpha \\cdot \\beta + \\beta^2)},</span></div>

    <p class="text-gray-300">which does not admit any solution since -3 is a quadratic non-residue modulo p (note that  <span class="math">\\psi_0 \\neq \\psi_2</span>  and  <span class="math">\\alpha \\neq -2\\beta</span> ). It follows that  <span class="math">\\mathcal{S}_F(x) = y</span>  is invertible.</p>

    <p class="text-gray-300">Regarding the cost, three  <span class="math">\\mathbb{F}_p</span> -multiplications are sufficient for computing  <span class="math">\\mathcal{S}_F</span> . Indeed, each function  <span class="math">F(x_i, x_{i+1}, x_{i+2})</span>  can be computed via one multiplication only, that is,  <span class="math">(x_i + x_{i+1} + x_{i+2}) \\times (\\alpha \\cdot x_i + \\beta \\cdot x_{i+1} - (\\alpha + \\beta) \\cdot x_{i+2})</span>  after pre-computing  <span class="math">(x_i + x_{i+1} + x_{i+2})</span>  and  <span class="math">(\\alpha \\cdot x_i + \\beta \\cdot x_{i+1} - (\\alpha + \\beta) \\cdot x_{i+2})</span> , where the multiplications with constants  <span class="math">\\alpha, \\beta, \\alpha + \\beta</span>  do not count since they are affine operations.</p>

    <p class="text-gray-300"><strong>Case:</strong>  <span class="math">p = 1 \\mod 3</span> . Next, we present a family of functions  <span class="math">F : \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  for which the induced SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^3</span>  is a permutation if  <span class="math">p = 1 \\mod 3</span> .</p>

    <p class="text-gray-300"><span id="page-14-0"></span><strong>Proposition 10.</strong> Let  <span class="math">p \\geq 7</span>  be a prime integer such that  <span class="math">p = 1 \\mod 3</span> . Let  <span class="math">\\alpha, \\beta, \\gamma, \\varepsilon, \\varepsilon&#x27; \\in \\mathbb{F}_p</span>  such that  <span class="math">\\varepsilon \\neq 0</span> ,  <span class="math">\\varepsilon + 3 \\cdot \\varepsilon&#x27; \\neq 0</span> ,  <span class="math">\\alpha \\neq \\gamma</span> ,  <span class="math">\\alpha \\cdot \\beta \\neq \\gamma^2</span> , and  <span class="math">\\beta \\in \\{\\beta_+, \\beta_-\\}</span>  where</p>

    <p class="text-gray-300"><span id="page-14-1"></span> <span class="math-block">\\beta_{\\pm} = \\frac{\\alpha \\cdot (1 \\pm \\sqrt{-3}) - \\gamma \\cdot (-1 \\pm \\sqrt{-3})}{2} \\,. \\tag{11}</span></p>

    <p class="text-gray-300">(Note that -3 is a quadratic residue modulo p for  <span class="math">p=1 \\mod 3</span>  – see Proposition 1.) Given  <span class="math">F: \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  defined as</p>

    <div class="my-4 text-center"><span class="math-block">F(x_0, x_1, x_2) = \\alpha \\cdot (x_0 - x_1)^2 + \\beta \\cdot (x_1 - x_2)^2 + \\gamma \\cdot (x_2 - x_0)^2 + \\varepsilon \\cdot x_0 + \\varepsilon&#x27; \\cdot (x_0 + x_1 + x_2),</span></div>

    <p class="text-gray-300">the SI-lifting  <span class="math">S_F</span>  over  <span class="math">\\mathbb{F}^3_p</span>  induced by F is invertible.</p>

    <p class="text-gray-300"><em>Proof.</em> Let us introduce the auxiliary variables  <span class="math">\\omega := \\alpha \\cdot \\beta - \\gamma^2</span> ,  <span class="math">\\psi := \\beta \\cdot \\gamma - \\alpha^2</span> ,  <span class="math">\\tau := \\alpha \\cdot \\gamma - \\beta^2</span> . First of all, note that  <span class="math">\\omega, \\tau, \\psi \\neq 0</span>  and that the following equalities</p>

    <p class="text-gray-300"><span class="math-block">\\omega \\cdot \\alpha + \\psi \\cdot \\beta + \\tau \\cdot \\gamma = 0</span> ,  <span class="math">\\omega \\cdot \\beta + \\psi \\cdot \\gamma + \\tau \\cdot \\alpha = 0</span> ,  <span class="math">\\omega \\cdot \\gamma + \\psi \\cdot \\alpha + \\tau \\cdot \\beta = 0</span></p>

    <p class="text-gray-300">are always satisfied. In particular, the first two equalities can be easily verified by replacing the values of  <span class="math">\\omega</span> ,  <span class="math">\\psi</span> ,  <span class="math">\\tau</span> . Regarding the last one, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\omega \\cdot \\gamma + \\psi \\cdot \\alpha + \\tau \\cdot \\beta = -(\\alpha + \\beta + \\gamma) \\cdot \\underbrace{(\\beta^2 - \\beta \\cdot (\\alpha + \\gamma) + \\alpha^2 + \\gamma^2 - \\alpha \\cdot \\gamma)}_{=0 \\text{ for } \\beta \\in \\{\\beta_+, \\beta_-\\} \\text{ as in (11)}} = 0,</span></div>

    <p class="text-gray-300">where the solutions of  <span class="math">\\beta^2 - \\beta \\cdot (\\alpha + \\gamma) + \\alpha^2 + \\gamma^2 - \\alpha \\cdot \\gamma = 0</span>  are</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\beta &amp;= \\frac{\\alpha + \\gamma \\pm \\sqrt{(\\alpha + \\gamma)^2 - 4 \\cdot (\\alpha^2 + \\gamma^2 - \\alpha \\cdot \\gamma)}}{2} = \\frac{\\alpha + \\gamma \\pm \\sqrt{-3\\alpha^2 - 3\\gamma^2 + 6\\alpha \\cdot \\gamma}}{2} \\\\ &amp;= \\frac{\\alpha + \\gamma \\pm \\sqrt{-3 \\cdot (\\alpha - \\gamma)^2}}{2} = \\frac{\\alpha + \\gamma \\pm (\\alpha - \\gamma)\\sqrt{-3}}{2} = \\frac{\\alpha \\cdot (1 \\pm \\sqrt{-3}) - \\gamma \\cdot (-1 \\pm \\sqrt{-3})}{2} = \\beta_{\\pm} \\,. \\end{split}</span></div>

    <p class="text-gray-300">Based on these initial observations, we show how to invert  <span class="math">S_F(x) = y</span> . Given  <span class="math">y_i = F(x_i, x_{i+1}, x_{i+2})</span>  for each  <span class="math">i \\in \\{0, 1, 2\\}</span>  (where the sub-indexes are taken modulo 3), it is not hard to check that the following linear equation is always satisfied</p>

    <div class="my-4 text-center"><span class="math-block">\\omega \\cdot y_0 + \\tau \\cdot y_1 + \\psi \\cdot y_2 = \\varepsilon \\cdot (\\omega \\cdot x_0 + \\tau \\cdot x_1 + \\psi \\cdot x_2),</span></div>

    <p class="text-gray-300">which implies that</p>

    <div class="my-4 text-center"><span class="math-block">x_0 = \\frac{\\omega \\cdot y_0 + \\tau \\cdot y_1 + \\psi \\cdot y_2}{\\omega \\cdot \\varepsilon} - \\frac{\\tau \\cdot x_1 + \\psi \\cdot x_2}{\\omega} \\equiv \\frac{\\hat{y} - \\tau \\cdot x_1 - \\psi \\cdot x_2}{\\omega},</span></div>

    <p class="text-gray-300">where  <span class="math">\\hat{y} := (\\omega \\cdot y_0 + \\tau \\cdot y_1 + \\psi \\cdot y_2)/\\varepsilon</span>  and where  <span class="math">\\omega, \\varepsilon \\neq 0</span>  by assumption.</p>

    <p class="text-gray-300">By taking the difference between  <span class="math">y_1</span>  and  <span class="math">y_2</span>  and by substituting  <span class="math">x_0</span> , we obtain:</p>

    <div class="my-4 text-center"><span class="math-block">\\underbrace{\\left(\\omega^2 \\cdot (\\alpha - \\gamma) + \\tau^2 \\cdot (\\beta - \\alpha) + \\psi^2 \\cdot (\\gamma - \\beta)\\right)}_{=0} \\cdot (x_1 - x_2)^2 + \\omega^2 \\cdot \\varepsilon \\cdot (x_1 - x_2) + (\\gamma - \\alpha) \\cdot \\hat{y}^2 - \\omega^2 \\cdot (y_1 - y_2) = 0</span></div>

    <p class="text-gray-300">where the coefficient of  <span class="math">(x_1 - x_2)^2</span>  is equal to zero due to the linear relations among  <span class="math">\\omega, \\tau, \\psi</span>  previously given:</p>

    <div class="my-4 text-center"><span class="math-block">0 = \\omega \\cdot \\underbrace{(\\omega \\cdot \\alpha + \\psi \\cdot \\beta + \\tau \\cdot \\gamma)}_{=0} - \\omega \\cdot \\underbrace{(\\omega \\cdot \\gamma + \\psi \\cdot \\alpha + \\tau \\cdot \\beta)}_{=0} + \\tau \\cdot \\underbrace{(\\omega \\cdot \\gamma + \\psi \\cdot \\alpha + \\tau \\cdot \\beta)}_{=0}</span></div>

    <div class="my-4 text-center"><span class="math-block">- \\tau \\cdot \\underbrace{(\\omega \\cdot \\beta + \\psi \\cdot \\gamma + \\tau \\cdot \\alpha)}_{=0} + \\psi \\cdot \\underbrace{(\\omega \\cdot \\beta + \\psi \\cdot \\gamma + \\tau \\cdot \\alpha)}_{=0} - \\psi \\cdot \\underbrace{(\\omega \\cdot \\alpha + \\psi \\cdot \\beta + \\tau \\cdot \\gamma)}_{=0}</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\omega^{2} \\cdot (\\alpha - \\gamma) + \\tau^{2} \\cdot (\\beta - \\alpha) + \\psi^{2} \\cdot (\\gamma - \\beta) + 2\\gamma \\cdot (\\alpha - \\gamma) \\cdot \\underbrace{(\\alpha \\cdot \\psi + \\beta \\cdot \\tau + \\gamma \\cdot \\omega)}_{=0}</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\omega^{2} \\cdot (\\alpha - \\gamma) + \\tau^{2} \\cdot (\\beta - \\alpha) + \\psi^{2} \\cdot (\\gamma - \\beta).</span></div>

    <p class="text-gray-300">It follows that</p>

    <div class="my-4 text-center"><span class="math-block">x_1 = x_2 + \\frac{(\\gamma - \\alpha) \\cdot \\hat{y}^2 - \\omega^2 \\cdot (y_1 - y_2)}{\\omega^2 \\cdot \\varepsilon}</span></div>

    <p class="text-gray-300">where  <span class="math">\\omega^2 \\cdot \\varepsilon \\neq 0</span> . By substituting  <span class="math">x_0, x_1</span>  in the equation  <span class="math">y_2 = F(x_2, x_0, x_1) = \\varepsilon \\cdot x_2 + \\varepsilon&#x27; \\cdot (x_0 + x_1 + x_2) + \\alpha \\cdot (x_2 - x_0)^2 + \\beta \\cdot (x_0 - x_1)^2 + \\gamma \\cdot (x_1 - x_2)^2</span>  – we omit the details since the computation is analogous to the one just given, we get a linear equation in  <span class="math">x_2</span>  of the form:</p>

    <div class="my-4 text-center"><span class="math-block">(\\varepsilon + 3\\varepsilon&#x27;) \\cdot x_2 + G(y_0, y_1, y_2) = 0</span></div>

    <p class="text-gray-300">for a certain function  <span class="math">G: \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span> . Since the coefficient  <span class="math">\\varepsilon + 3 \\cdot \\varepsilon&#x27;</span>  of  <span class="math">x_2</span>  is different from zero by assumption, the system of equations has a unique solution for any given  <span class="math">y_1, y_2, y_3</span>  and  <span class="math">\\mathcal{S}_F</span>  is invertible.</p>

    <p class="text-gray-300">As before, three  <span class="math">\\mathbb{F}_p</span> -multiplications are sufficient for computing  <span class="math">\\mathcal{S}_F</span> . Indeed, by precomputing  <span class="math">z_i = (x_i - x_{i+2})^2</span>  for each  <span class="math">i \\in \\{0, 1, 2\\}</span>  for a total cost of three multiplications, it follows that  <span class="math">F(x_i, x_{i+1}, x_{i+2})</span>  is linear in  <span class="math">x_0, x_1, x_2</span>  and in  <span class="math">z_0, z_1, z_2</span> .</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">5.2 Some Examples for the Case n=4</h3>

    <p class="text-gray-300"><strong>A Generic Result.</strong> Given an invertible function  <span class="math">\\mathcal{S}_G</span>  over  <span class="math">\\mathbb{F}_p^h</span> , we first show how to construct an invertible function over a bigger domain  <span class="math">\\mathbb{F}_p^n</span>  for n being multiple of h.</p>

    <p class="text-gray-300"><strong>Proposition 11.</strong> Let  <span class="math">p \\geq 2</span>  be a prime integer. Given  <span class="math">2 \\leq g \\leq h</span> , let  <span class="math">G : \\mathbb{F}_p^g \\to \\mathbb{F}_p</span>  such that the SI-lifting  <span class="math">\\mathcal{S}_G</span>  over  <span class="math">\\mathbb{F}_p^h</span>  induced by G is invertible.</p>

    <p class="text-gray-300">Let  <span class="math">m := (g-1) \\cdot (z+1) + 1</span>  and  <span class="math">n := h \\cdot (z+1)</span>  for an arbitrary integer  <span class="math">z \\ge 0</span> . Let  <span class="math">F : \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  be defined as</p>

    <div class="my-4 text-center"><span class="math-block">F(x_0,\\ldots,x_{m-1}):=G(x_0,x_{z+1},x_{2\\cdot(z+1)},\\ldots,x_{(g-1)\\cdot(z+1)}).</span></div>

    <p class="text-gray-300">(Note that F depends only on the variables  <span class="math">x_i</span>  for which the sub-index i is a multiple of z+1.) The SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  induced by F is invertible.</p>

    <p class="text-gray-300"><em>Proof.</em> The result is obviously true for z=0 (for which m=g and n=h). So, let's assume  <span class="math">z \\geq 1</span> . Let  <span class="math">y = \\mathcal{S}_F(x)</span> . The system of n equations  <span class="math">y_i = F(x_i, x_{i+1}, \\dots, x_{i+m-1})</span>  for each  <span class="math">i \\in \\{0, 1, \\dots, n-1\\}</span>  can be split into z+1 independent systems, each one consisting of h equations of the form</p>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in \\{0, 1, \\dots, z\\}: \\quad (y_i, y_{i+(z+1)}, \\dots, y_{i+(h-1)\\cdot(z+1)}) = \\mathcal{S}_G(x_i, x_{i+(z+1)}, \\dots, x_{i+(h-1)\\cdot(z+1)}).</span></div>

    <p class="text-gray-300">The invertibility of each one of these sub-systems follows from the fact that  <span class="math">S_G</span>  is invertible by assumption.</p>

    <p class="text-gray-300">The following corollary follows immediately.</p>

    <p class="text-gray-300"><span id="page-16-1"></span><strong>Corollary 2.</strong> Let  <span class="math">p \\geq 2</span>  be a prime integer, and let  <span class="math">m \\geq 2</span> . Let  <span class="math">G : \\mathbb{F}_p^2 \\to \\mathbb{F}_p</span>  such that the SI-lifting  <span class="math">S_G</span>  over  <span class="math">\\mathbb{F}_p^2</span>  induced by G is invertible. Let  <span class="math">F : \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  be defined as  <span class="math">F(x_0, \\ldots, x_{m-1}) := G(x_0, x_{m-1})</span> . Then, the SI-lifting  <span class="math">S_F</span>  over  <span class="math">\\mathbb{F}_p^{2\\cdot (m-1)}</span>  induced by F is invertible.</p>

    <p class="text-gray-300">Based on these results, given  <span class="math">F(x_0, x_1, x_2) = \\alpha \\cdot x_0 + \\beta \\cdot x_2 + (x_0 - x_2)^2</span>  such that  <span class="math">\\alpha \\neq \\pm \\beta</span> , then the SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^4</span>  induced by F is invertible.</p>

    <p class="text-gray-300"><strong>Concrete Examples.</strong> Examples of functions  <span class="math">F: \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  that depend on all three input variables and for which  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^4</span>  is invertible are given in the following.</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong> Let  <span class="math">p \\geq 3</span>  is a prime, and let  <span class="math">F: \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  be defined as</p>

    <div class="my-4 text-center"><span class="math-block">F(x_0, x_1, x_2) := \\alpha \\cdot (x_0 + x_2) + \\beta \\cdot x_1 + \\gamma \\cdot H(x_0 - x_2),</span></div>

    <p class="text-gray-300">where  <span class="math">\\beta, \\gamma \\in \\mathbb{F}_p \\setminus \\{0\\}</span> ,  <span class="math">\\alpha \\in \\mathbb{F}_p \\setminus \\{\\pm \\beta/2\\}</span> , and where  <span class="math">H : \\mathbb{F}_p \\to \\mathbb{F}_p</span>  is an even function. Then, the SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^4</span>  induced by F is invertible.</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">S_F(x) = y</span> . First of all, the equality  <span class="math">y_i - y_{i+2} = \\beta \\cdot (x_{i+1} - x_{i+3})</span>  holds for each  <span class="math">i \\in \\{0, 1, 2, 3\\}</span>  since H is an even function. Hence, the system  <span class="math">S_F(x) = y</span>  is equivalent to</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} \\alpha &amp; \\beta &amp; \\alpha &amp; 0 \\\\ 0 &amp; \\alpha &amp; \\beta &amp; \\alpha \\\\ \\alpha &amp; 0 &amp; \\alpha &amp; \\beta \\\\ \\beta &amp; \\alpha &amp; 0 &amp; \\alpha \\end{bmatrix} \\times \\begin{bmatrix} x_0 \\\\ x_1 \\\\ x_2 \\\\ x_3 \\end{bmatrix} = \\begin{bmatrix} y_0 - \\gamma \\cdot H((y_1 - y_3)/\\beta) \\\\ y_1 - \\gamma \\cdot H((y_0 - y_2)/\\beta) \\\\ y_2 - \\gamma \\cdot H((y_1 - y_3)/\\beta) \\\\ y_3 - \\gamma \\cdot H((y_0 - y_2)/\\beta) \\end{bmatrix}.</span></div>

    <p class="text-gray-300">The determinant of the l.h.s. matrix is  <span class="math">\\beta^2 \\cdot (4 \\cdot \\alpha^2 - \\beta^2)</span> , which is always non-null due to the condition  <span class="math">\\beta \\neq \\pm 2\\alpha</span>  and  <span class="math">\\beta \\neq 0</span> . Hence, it is possible to find an inverse matrix and to solve the system.</p>

    <p class="text-gray-300"><span id="page-16-0"></span><strong>Proposition 12.</strong> Let  <span class="math">p \\geq 5</span>  be a prime integer. Let  <span class="math">\\alpha \\in \\mathbb{F}_p</span> , and let  <span class="math">\\gamma \\in \\mathbb{F}_p \\setminus \\{0, -1, -1/3\\}</span>  be such that  <span class="math">L_p(\\gamma^2 + 1) = -1</span> . Given  <span class="math">F : \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  defined as</p>

    <div class="my-4 text-center"><span class="math-block">F(x_0, x_1, x_2) = (x_0 - x_1)^2 + (x_1 - x_2)^2 + \\alpha \\cdot (x_0 + \\gamma \\cdot (x_0 + x_1 + x_2)),</span></div>

    <p class="text-gray-300">the SI-lifting  <span class="math">S_F</span>  over  <span class="math">\\mathbb{F}_n^4</span>  induced by F is invertible.</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">S_F(x) = y</span> , and let  <span class="math">\\beta := \\alpha \\cdot \\gamma</span> . By simple computation:</p>

    <div class="my-4 text-center"><span class="math-block">y_0 - y_1 + y_2 - y_3 = (\\alpha + \\beta) \\cdot (x_0 - x_1 + x_2 - x_3)</span></div>

    <p class="text-gray-300">where  <span class="math">\\alpha + \\beta = \\alpha \\cdot (1 + \\gamma) \\neq 0</span>  by assumption. Let  <span class="math">\\hat{y} = (y_0 - y_1 + y_2 - y_3)/(\\alpha + \\beta)</span> , and  <span class="math">x_0 = \\hat{y} + x_1 + x_3 - x_2</span> . By substituting  <span class="math">x_0</span>  in  <span class="math">y_1, y_2, y_3</span> , we get:</p>

    <div class="my-4 text-center"><span class="math-block">y_{1} = (x_{1} - x_{2})^{2} + (x_{2} - x_{3})^{2} + \\alpha \\cdot x_{1} + \\beta \\cdot (x_{1} + x_{2} + x_{3}),</span></div>

    <div class="my-4 text-center"><span class="math-block">y_{2} = (x_{2} - x_{3})^{2} + (x_{3} - x_{0})^{2} + \\alpha \\cdot x_{2} + \\beta \\cdot (x_{2} + x_{3} + x_{0})</span></div>

    <div class="my-4 text-center"><span class="math-block">= (x_{2} - x_{3})^{2} + (x_{2} - x_{1})^{2} + \\hat{y}^{2} - 2 \\cdot (x_{2} - x_{1}) \\cdot \\hat{y} + \\alpha \\cdot x_{2} + \\beta \\cdot (2 \\cdot x_{3} + \\hat{y} + x_{1}),</span></div>

    <div class="my-4 text-center"><span class="math-block">y_{3} = (x_{3} - x_{0})^{2} + (x_{0} - x_{1})^{2} + \\alpha \\cdot x_{3} + \\beta \\cdot (x_{1} + x_{3} + x_{0})</span></div>

    <div class="my-4 text-center"><span class="math-block">= (x_{2} - x_{1})^{2} + 2\\hat{y}^{2} + (x_{3} - x_{2})^{2} + 2 \\cdot (x_{3} - 2x_{2} + x_{1}) \\cdot \\hat{y} + \\alpha \\cdot x_{3} + \\beta \\cdot (2x_{3} + \\hat{y} + 2x_{1} - x_{2}).</span></div>

    <p class="text-gray-300">Thus:</p>

    <div class="my-4 text-center"><span class="math-block">y_2 - y_1 = \\hat{y}^2 + \\beta \\hat{y} + (\\alpha - 2\\hat{y}) \\cdot (x_2 - x_1) + \\beta \\cdot (x_3 - x_2) \\rightarrow x_3 = x_2 + \\tilde{y} + \\frac{(2\\hat{y} - \\alpha) \\cdot (x_2 - x_1)}{\\beta}</span></div>

    <p class="text-gray-300">where  <span class="math">\\tilde{y} := (y_2 - y_1 - \\hat{y}^2 - \\beta \\hat{y})/\\beta</span> . By replacing it in  <span class="math">y_3 - y_2</span> , we get:</p>

    <div class="my-4 text-center"><span class="math-block">y_3 - y_2 = \\hat{y}^2 + (\\alpha + 2\\hat{y}) \\cdot \\tilde{y} + \\frac{(x_2 - x_1) \\cdot (4\\hat{y}^2 - \\alpha^2 - \\beta^2)}{\\beta} \\quad \\to \\quad x_2 = x_1 + \\frac{\\bar{y} \\cdot \\beta}{4\\hat{y}^2 - \\alpha^2 - \\beta^2},</span></div>

    <p class="text-gray-300">where  <span class="math">\\bar{y} := y_3 - y_2 - \\hat{y}^2 - (\\alpha + 2\\hat{y}) \\cdot \\tilde{y}</span> , and where  <span class="math">4\\hat{y}^2 - \\alpha^2 - \\beta^2</span>  is always non-zero due to the assumption on  <span class="math">\\gamma</span> . Indeed:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\hat{y} \\in \\mathbb{F}_p: \\quad 4 \\cdot \\hat{y}^2 \\neq \\alpha^2 + \\beta^2 \\equiv \\alpha^2 \\cdot (1 + \\gamma^2)</span></div>

    <p class="text-gray-300">since  <span class="math">L_p(4 \\cdot \\hat{y}^2) \\in \\{0, 1\\}</span>  while  <span class="math">L_p(\\alpha^2 \\cdot (1 + \\gamma^2)) = L_p(\\alpha^2) \\cdot L_p(1 + \\gamma^2) = -1</span>  by definition of  <span class="math">\\gamma</span> , and since a quadratic residue can never be equal to a quadratic non-residue. It follows that</p>

    <div class="my-4 text-center"><span class="math-block">x_0 = x_1 + \\hat{y} + \\tilde{y} + \\frac{\\bar{y} \\cdot (2\\hat{y} - \\alpha)}{4\\hat{y}^2 - \\alpha^2 - \\beta^2}, \\quad x_2 = x_1 + \\frac{\\bar{y} \\cdot \\beta}{4\\hat{y}^2 - \\alpha^2 - \\beta^2}, \\quad x_3 = x_1 + \\frac{\\bar{y} \\cdot (2\\hat{y} - \\alpha + \\beta)}{4\\hat{y}^2 - \\alpha^2 - \\beta^2} + \\tilde{y}.</span></div>

    <p class="text-gray-300">By replacing these values in  <span class="math">y_1</span> , we get a linear equation in  <span class="math">x_1</span>  of the form</p>

    <div class="my-4 text-center"><span class="math-block">(\\alpha + 3\\beta) \\cdot x_1 + G(y_0, y_1, y_2, y_3) = 0</span></div>

    <p class="text-gray-300">for a certain  <span class="math">G: \\mathbb{F}_p^4 \\to \\mathbb{F}_p</span> . Since  <span class="math">\\alpha + 3\\beta = \\alpha \\cdot (1 + 3 \\cdot \\gamma) \\neq 0</span>  by assumption, the system  <span class="math">S_F(x) = y</span>  is invertible.</p>

    <p class="text-gray-300">Regarding the cost, four  <span class="math">\\mathbb{F}_p</span> -multiplications are sufficient for computing the SI-lifting  <span class="math">\\mathcal{S}_F</span>  just defined. As before, it is sufficient to pre-compute and store  <span class="math">z_0 = (x_0 - x_1)^2</span> ,  <span class="math">z_1 = (x_1 - x_2)^2</span> ,  <span class="math">z_2 = (x_2 - x_3)^2</span> ,  <span class="math">z_3 = (x_3 - x_0)^2</span> . It follows that the SI-lifting  <span class="math">\\mathcal{S}_F</span>  is linear in  <span class="math">x_0, x_1, x_2, x_3</span>  and in  <span class="math">z_0, z_1, z_2, z_3</span> .</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">5.3 Analysis of the Case n > 5</h3>

    <p class="text-gray-300">As a main result of this work, we prove that given any quadratic function  <span class="math">F: \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span> , then the lifting  <span class="math">\\mathcal{S}_F</span>  induced by F over  <span class="math">\\mathbb{F}_p^n</span>  is never invertible for  <span class="math">n \\geq 5</span> .</p>

    <p class="text-gray-300"><span id="page-17-1"></span><strong>Theorem 3.</strong> Let  <span class="math">p \\geq 3</span>  be a prime integer. Let  <span class="math">F : \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  be a function of degree 2. The SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  induced by F is <strong>never</strong> a permutation for each  <span class="math">n \\geq 5</span> .</p>

    <p class="text-gray-300">As highlighted in the introduction, this result is quite surprising if compared to the  <span class="math">\\mathbb{F}_2</span>  case, for which it is well known that the SI–lifting  <span class="math">\\mathcal{S}_{\\chi}</span>  over  <span class="math">\\mathbb{F}_2^n</span>  induced via the local map  <span class="math">\\chi</span>  defined as in (5) is a permutation for each odd  <span class="math">n \\geq 3</span> .</p>

    <p class="text-gray-300">In order to prove Theorem 3, we consider separately the following cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. the function  <span class="math">F: \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  depends on at most two input variables (equivalently, it is independent of at least one variable). If  <span class="math">F(x_0, x_1, x_2) = G(x_0, x_1)</span>  or  <span class="math">F(x_0, x_1, x_2) = G(x_1, x_2)</span> , then due to the result given in Theorem 2, the SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  induced by F is never invertible. Also the case  <span class="math">F(x_0, x_1, x_2) = G(x_0, x_2)</span>  reduces to the one studied in Theorem 2, since</li>

      <li>if  <span class="math">n = 2n&#x27; \\ge 6</span>  is even, then the system of equations  <span class="math">S_F(x) = y</span>  can be split into two independent systems of equations, namely,</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$S_G(x_0, x_2, \\dots, x_{n-2}) = y_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{n-2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$S'_G(x_1, x_3, \\dots, x_{n-1}) = y_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{n-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">both defined over  <span class="math">\\mathbb{F}_p^{n&#x27;}</span> . Due to Theorem 2, both  <span class="math">\\mathcal{S}_G</span>  and  <span class="math">\\mathcal{S}_G&#x27;</span>  are not invertible;</p>

    <p class="text-gray-300">• if  <span class="math">n = 2n&#x27; + 1 \\ge 5</span>  is odd, then the system of equations  <span class="math">\\mathcal{S}_F(x) = y</span>  can be re-written as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$S_G(x_0, x_2, x_4, \\dots, x_{n-1}, x_1, x_3, \\dots, x_{n-2}) = y_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{n-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{n-2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> over  <span class="math">\\mathbb{F}_p^n</span> . Due to Theorem 2,  <span class="math">S_G</span>  is not invertible;</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>2. the function  <span class="math">F: \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  only contains monomials that depend on a single variable, that is,  <span class="math">\\alpha_{1,1,0} = \\alpha_{1,0,1} = \\alpha_{0,1,1} = 0</span> ;</li>

      <li>3. the function  <span class="math">F: \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  is linear in one variable, e.g.,  <span class="math">F(x_0, x_1, x_2) = x_0 + G(x_1, x_2)</span>  where  <span class="math">G: \\mathbb{F}_p^2 \\to \\mathbb{F}_p</span>  is a function of degree 2. Note that if F is linear in two variables (e.g.,  <span class="math">F(x_0, x_1, x_2) = x_0 + \\alpha \\cdot x_1 + G(x_2)</span>  for a quadratic  <span class="math">G: \\mathbb{F}_p \\to \\mathbb{F}_p</span> ), then  <span class="math">\\mathcal{S}_F</span>  is never a permutation due to Proposition 5 since  <span class="math">\\alpha^{(2)} \\neq 0</span> ;</li>

      <li>4. for the remaining cases, we analyze separately the functions with  <span class="math">\\alpha_{1,0,1} \\neq 0</span>  from the ones with  <span class="math">\\alpha_{1,0,1} = 0</span> .</li>

    </ul>

    <p class="text-gray-300">The second case is studied in Lemma 3, the third case is studied in Lemma 4, while the last cases are studied in Lemma 5 and in Lemma 6 respectively. Details are given in the next Section 6.</p>

    <p class="text-gray-300"><strong>Practical Verification.</strong> The theoretical results just given are supported by our practical verification, for which <strong>no</strong> quadratic function F that induces an invertible  <span class="math">\\mathcal{S}_F</span>  is found. For our practical tests, we limit ourselves to consider balanced functions  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  under the equivalence class defined in Definition 4. The practical results are reported in App. B – Table 3 for the case of quadratic functions  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  for m=2,3. Those include the number and the percentage of balanced functions, the maximum value of  <span class="math">n \\geq 3</span>  tested and the total runtime.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">6 Proof of Theorem 3</h3>

    <p class="text-gray-300">We prove that the SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  is not a permutation for any quadratic function  <span class="math">F: \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  and  <span class="math">n \\geq 5</span>  by constructing collisions, i.e., we find two distinct <em>n</em>-tuples  <span class="math">x, y \\in \\mathbb{F}_p^n</span>  such that  <span class="math">\\mathcal{S}_F(x) = \\mathcal{S}_F(y)</span>  and  <span class="math">x \\neq y</span> , or equivalently:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in \\{0, 1, 2, \\dots, n-1\\}: F(x_i, x_{i+1}, x_{i+2}) = F(y_i, y_{i+1}, y_{i+2}),</span></div>

    <p class="text-gray-300">where the sub-indexes are taken modulo n. Due to the results given in Proposition 5, here we limit ourselves to consider the case</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha^{(2)} \\equiv \\alpha_{2,0,0} + \\alpha_{0,2,0} + \\alpha_{0,0,2} + \\alpha_{1,1,0} + \\alpha_{1,0,1} + \\alpha_{0,1,1} = 0,</span></div>

    <p class="text-gray-300"><span class="math-block">\\alpha^{(1)} \\equiv \\alpha_{1,0,0} + \\alpha_{0,1,0} + \\alpha_{0,0,1} \\neq 0.</span> (12)</p>

    <p class="text-gray-300"><span id="page-18-3"></span>For reaching this goal, we introduce new variables  <span class="math">s,d\\in\\mathbb{F}_p^n,</span>  respectively for the sum and for the difference:</p>

    <p class="text-gray-300"><span id="page-18-4"></span> <span class="math-block">s := x + y \\qquad \\text{and} \\qquad d := x - y. \\tag{13}</span></p>

    <p class="text-gray-300">Clearly, a pair (s,d) is equivalent to a pair x,y, since x=(s+d)/2 and y=(s-d)/2.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8"><strong>6.1</strong> Case: <span class="math">\\alpha_{1,1,0} = \\alpha_{1,0,1} = \\alpha_{0,1,1} = 0</span></h3>

    <p class="text-gray-300"><span id="page-18-2"></span><strong>Lemma 3.</strong> Let  <span class="math">p \\geq 3</span>  be a prime integer. Let  <span class="math">F : \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  be a function of degree 2 defined as</p>

    <div class="my-4 text-center"><span class="math-block">F(x_0, x_1, x_2) = \\alpha_{2,0,0} \\cdot x_0^2 + \\alpha_{0,2,0} \\cdot x_1^2 + \\alpha_{0,0,2} \\cdot x_2^2 + \\alpha_{1,0,0} \\cdot x_0 + \\alpha_{0,1,0} \\cdot x_1 + \\alpha_{0,0,1} \\cdot x_2,</span></div>

    <p class="text-gray-300">that is,  <span class="math">\\alpha_{1,1,0} = \\alpha_{1,0,1} = \\alpha_{0,1,1} = 0</span> . The SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  induced by F is <strong>never</strong> a permutation for each  <span class="math">n \\geq 5</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We prove this result by finding a collision for  <span class="math">S_F</span> . Due to the condition  <span class="math">\\alpha^{(2)} = \\alpha_{0,0,2} + \\alpha_{0,2,0} + \\alpha_{2,0,0} = 0</span>  – see (12), at least two terms among  <span class="math">\\alpha_{0,0,2}, \\alpha_{0,2,0}, \\alpha_{2,0,0}</span>  are different from zero (otherwise F would be linear). For this reason, in order to prove the result, we study separately the cases (1st)  <span class="math">\\alpha_{0,0,2}, \\alpha_{0,2,0}, \\alpha_{2,0,0} \\neq 0</span>  and (2nd)  <span class="math">\\alpha_{0,0,2} = 0</span>  or  <span class="math">\\alpha_{0,2,0} = 0</span>  or  <span class="math">\\alpha_{2,0,0} = 0</span> :</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">case  <span class="math">\\alpha_{0,0,2}, \\alpha_{0,2,0}, \\alpha_{2,0,0} \\neq 0</span> : we show that the result is true for n=5 by finding two different inputs  <span class="math">x, y \\in \\mathbb{F}_p^5</span>  such that  <span class="math">x_0 = y_0 = x_1 = y_1 = \\hat{z} \\in \\mathbb{F}_p</span>  and  <span class="math">\\mathcal{S}_F(x) = \\mathcal{S}_F(y) \\in \\mathbb{F}_p^5</span>  and  <span class="math">x \\neq y</span> . This is done by solving a system of (linear) equations. The collision over  <span class="math">\\mathbb{F}_p^n</span>  for  <span class="math">n \\geq 6</span>  is obtained by working with  $x' = x \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{z}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{z}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{z}<span class="math">  and  </span>y' = y \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{z}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{z}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{z} \\in \\mathbb{F}_p^n$ ;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">case  <span class="math">\\alpha_{0,0,2} = 0</span>  or  <span class="math">\\alpha_{0,2,0} = 0</span>  or  <span class="math">\\alpha_{2,0,0} = 0</span> : we construct a collision directly over  <span class="math">\\mathbb{F}_p^n</span> , by choosing the differences  <span class="math">(x_i - y_i)</span>  in an appropriate way.</p>

    <p class="text-gray-300">Case:  <span class="math">\\alpha_{0,0,2}, \\alpha_{0,2,0}, \\alpha_{2,0,0} \\neq 0</span> . First of all, we construct a collision for n=5 by finding two different inputs  <span class="math">x,y \\in \\mathbb{F}_p^5</span>  with  <span class="math">x_0=y_0=x_1=y_1=0 \\in \\mathbb{F}_p</span>  such that  <span class="math">\\mathcal{S}_F(x)=\\mathcal{S}_F(y)\\in \\mathbb{F}_p^5</span>  and  <span class="math">x\\neq y</span> . This allows us to generalize such collision over  <span class="math">\\mathbb{F}_p^n</span>  for each  <span class="math">n\\geq 6</span>  by working as in Theorem 2, since</p>

    <p class="text-gray-300"><span id="page-19-0"></span> <span class="math-block">S_F(0,0,x_2,x_3,x_4) = S_F(0,0,y_2,y_3,y_4) \\rightarrow S_F(0,0,x_2,x_3,x_4,0,\\dots,0) = S_F(0,0,y_2,y_3,y_4,0,\\dots,0),</span></p>

    <p class="text-gray-300">where  <span class="math">F(x_i, x_{i+1}, x_{i+2}) = F(0, 0, 0) = F(y_i, y_{i+1}, y_{i+2})</span>  for each  <span class="math">i \\in \\{5, 6, ..., n-1\\}</span> . Hence, we look for  <span class="math">x = (0, 0, x_2, x_3, x_4), y = (0, 0, y_2, y_3, y_4) \\in \\mathbb{F}_p^5</span>  such that  <span class="math">\\mathcal{S}_F(x) = \\mathcal{S}_F(y)</span> . By making use of the variables  <span class="math">d, s \\in \\mathbb{F}_p^5</span>  introduced in (13):</p>

    <div class="my-4 text-center"><span class="math-block">F(0,0,x_2) = F(0,0,y_2) \\qquad \\rightarrow \\qquad d_2 \\cdot (\\alpha_{0,0,2} \\cdot s_2 + \\alpha_{0,0,1}) = 0 \\qquad \\rightarrow \\qquad s_2 = -\\frac{\\alpha_{0,0,1}}{\\alpha_{0,0,2}},</span></div>

    <div class="my-4 text-center"><span class="math-block">F(x_4,0,0) = F(y_4,0,0) \\qquad \\rightarrow \\qquad d_4 \\cdot (\\alpha_{2,0,0} \\cdot s_4 + \\alpha_{1,0,0}) = 0 \\qquad \\rightarrow \\qquad s_4 = -\\frac{\\alpha_{1,0,0}}{\\alpha_{2,0,0}},</span></div>

    <p class="text-gray-300">where  <span class="math">\\alpha_{0,0,2}, \\alpha_{2,0,0} \\neq 0</span>  by assumption, and where no condition on  <span class="math">d_2, d_4</span>  is imposed.</p>

    <p class="text-gray-300">The other three conditions  <span class="math">F(0, x_2, x_3) = F(0, y_2, y_3)</span> ,  <span class="math">F(x_2, x_3, x_4) = F(y_2, y_3, y_4)</span>  and  <span class="math">F(x_3, x_4, 0) = F(y_3, y_4, 0)</span>  correspond respectively to</p>

    <div class="my-4 text-center"><span class="math-block">d_2 \\cdot (\\alpha_{0,2,0} \\cdot s_2 + \\alpha_{0,1,0}) + d_3 \\cdot (\\alpha_{0,0,2} \\cdot s_3 + \\alpha_{0,0,1}) = 0, \\tag{14}</span></div>

    <div class="my-4 text-center"><span class="math-block">d_2 \\cdot (\\alpha_{2.0.0} \\cdot s_2 + \\alpha_{1.0.0}) + d_3 \\cdot (\\alpha_{0.2.0} \\cdot s_3 + \\alpha_{0.1.0}) + d_4 \\cdot (\\alpha_{0.0.2} \\cdot s_4 + \\alpha_{0.0.1}) = 0, \\quad (15)</span></div>

    <div class="my-4 text-center"><span class="math-block">d_3 \\cdot (\\alpha_{2,0,0} \\cdot s_3 + \\alpha_{1,0,0}) + d_4 \\cdot (\\alpha_{0,2,0} \\cdot s_4 + \\alpha_{0,1,0}) = 0, \\tag{16}</span></div>

    <p class="text-gray-300">where  <span class="math">s_2 = -\\frac{\\alpha_{0,0,1}}{\\alpha_{0,0,2}}</span>  and  <span class="math">s_4 = -\\frac{\\alpha_{1,0,0}}{\\alpha_{2,0,0}}</span>  due to  <span class="math">F(0,0,x_2) = F(0,0,y_2)</span>  and  <span class="math">F(x_4,0,0) = F(y_4,0,0)</span>  respectively. By summing these three equations, we get  <span class="math">d_2 + d_3 + d_4 = 0</span> :</p>

    <p class="text-gray-300"><span id="page-19-2"></span><span id="page-19-1"></span> <span class="math-block">0 = d_{2} \\cdot \\left( \\underbrace{-\\frac{\\alpha_{0,0,1}}{\\alpha_{0,0,2}}}_{=s_{2}} \\cdot \\underbrace{(\\alpha_{0,2,0} + \\alpha_{2,0,0})}_{=-\\alpha_{0,0,2}} + \\alpha_{1,0,0} + \\alpha_{0,1,0} \\right) + d_{3} \\cdot \\underbrace{(\\alpha^{(2)})}_{=0} \\cdot s_{3} + \\alpha^{(1)}</span></p>

    <div class="my-4 text-center"><span class="math-block">+ d_{4} \\cdot \\left( \\underbrace{-\\frac{s_{4}}{\\alpha_{1,0,0}}}_{\\alpha_{2,0,0}} \\cdot \\underbrace{(\\alpha_{0,2,0} + \\alpha_{0,0,2})}_{=\\alpha_{0,0,1}} + \\alpha_{0,1,0} \\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\underbrace{\\alpha^{(1)}}_{\\neq 0} \\cdot (d_{2} + d_{3} + d_{4}) \\qquad \\longrightarrow \\qquad d_{2} + d_{3} + d_{4} = 0,</span></div>

    <p class="text-gray-300">where  <span class="math">\\alpha^{(2)} = \\alpha_{0,2,0} + \\alpha_{2,0,0} + \\alpha_{0,0,2} = 0</span>  and  <span class="math">\\alpha^{(1)} \\neq 0</span>  due to (12). Hence, the system of equations (14) – (15) – (16) can be re-written as</p>

    <div class="my-4 text-center"><span class="math-block">d_{2} \\cdot \\left(-\\alpha_{0,2,0} \\cdot \\alpha_{0,0,1} + \\alpha_{0,1,0} \\cdot \\alpha_{0,0,2}\\right) + d_{3} \\cdot \\left(\\alpha_{0,0,2}^{2} \\cdot s_{3} + \\alpha_{0,0,1} \\cdot \\alpha_{0,0,2}\\right) = 0,</span></div>

    <div class="my-4 text-center"><span class="math-block">d_{2} \\cdot \\left(\\alpha_{0,2,0} \\cdot \\alpha_{1,0,0} - \\alpha_{0,1,0} \\cdot \\alpha_{2,0,0}\\right) + d_{3} \\cdot \\left(\\alpha_{2,0,0}^{2} \\cdot s_{3} + \\alpha_{0,2,0} \\cdot \\alpha_{1,0,0} + \\alpha_{2,0,0} \\cdot (\\alpha_{1,0,0} - \\alpha_{0,1,0})\\right) = 0,</span></div>

    <div class="my-4 text-center"><span class="math-block">d_{2} + d_{3} + d_{4} = 0,</span></div>

    <p class="text-gray-300">where the first equation corresponds to (14) multiplied by  <span class="math">\\alpha_{0,0,2}</span> , and where the second one corresponds to (16) multiplied by  <span class="math">\\alpha_{2,0,0}</span>  (after the substitution of  <span class="math">d_4</span>  with  <span class="math">-d_2-d_3</span> ). By re-writing the first two equations in a matrix form, we get</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} -\\alpha_{0,2,0} \\cdot \\alpha_{0,0,1} + \\alpha_{0,1,0} \\cdot \\alpha_{0,0,2} &amp; \\alpha_{0,0,2}^2 \\cdot s_3 + \\alpha_{0,0,1} \\cdot \\alpha_{0,0,2} \\\\ \\alpha_{0,2,0} \\cdot \\alpha_{1,0,0} - \\alpha_{0,1,0} \\cdot \\alpha_{2,0,0} &amp; \\alpha_{2,0,0}^2 \\cdot s_3 + \\alpha_{0,2,0} \\cdot \\alpha_{1,0,0} + \\alpha_{2,0,0} \\cdot (\\alpha_{1,0,0} - \\alpha_{0,1,0}) \\end{bmatrix} \\times \\begin{bmatrix} d_2 \\\\ d_3 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}.</span></div>

    <div class="my-4 text-center"><span class="math-block">(17)</span></div>

    <p class="text-gray-300">If the left-hand side (l.h.s.) matrix is invertible, then the only solution to the system of equations would be  <span class="math">d_2 = d_3 = 0</span> , which implies  <span class="math">d_4 = 0</span> . Hence, we choose  <span class="math">s_3</span>  such that the determinant of the l.h.s. matrix is equal to zero:</p>

    <div class="my-4 text-center"><span class="math-block">s_3 = -\\frac{\\alpha_{0,1,0}}{\\alpha_{0,2,0}} \\,.</span></div>

    <p class="text-gray-300">In such a way, the first two equations are linearly dependent, and the solution of the system of equations is given by</p>

    <div class="my-4 text-center"><span class="math-block">d_3 = d_2 \\cdot \\frac{\\alpha_{0,2,0}}{\\alpha_{0,0,2}}, \\qquad d_4 = d_2 \\cdot \\frac{\\alpha_{2,0,0}}{\\alpha_{0,0,2}},</span></div>

    <div class="my-4 text-center"><span class="math-block">s_2 = -\\frac{\\alpha_{0,0,1}}{\\alpha_{0,0,2}}, \\qquad s_3 = -\\frac{\\alpha_{0,1,0}}{\\alpha_{0,2,0}}, \\qquad s_4 = -\\frac{\\alpha_{1,0,0}}{\\alpha_{2,0,0}},</span></div>

    <p class="text-gray-300">where no condition on  <span class="math">d_2 \\neq 0</span>  is imposed. Based on this computation, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} &amp; \\mathcal{S}_{F}\\left(0,0,x-\\frac{\\alpha_{0,0,1}}{2\\alpha_{0,0,2}},-x\\cdot\\left(1+\\frac{\\alpha_{2,0,0}}{\\alpha_{0,0,2}}\\right)+\\frac{\\alpha_{0,0,1}}{2\\alpha_{0,0,2}}-\\frac{\\alpha_{0,0,2}\\cdot\\alpha_{0,0,1}+\\alpha_{0,1,0}}{2\\alpha_{0,2,0}},x\\cdot\\frac{\\alpha_{2,0,0}}{\\alpha_{0,0,2}}-\\frac{\\alpha_{1,0,0}}{2\\alpha_{2,0,0}}\\right)\\\\ =&amp; \\mathcal{S}_{F}\\left(0,0,-x-\\frac{\\alpha_{0,0,1}}{2\\alpha_{0,0,2}},x\\cdot\\left(1+\\frac{\\alpha_{2,0,0}}{\\alpha_{0,0,2}}\\right)+\\frac{\\alpha_{0,0,1}}{2\\alpha_{0,0,2}}-\\frac{\\alpha_{0,0,2}\\cdot\\alpha_{0,0,1}+\\alpha_{0,1,0}}{2\\alpha_{0,2,0}},-x\\cdot\\frac{\\alpha_{2,0,0}}{\\alpha_{0,0,2}}-\\frac{\\alpha_{1,0,0}}{2\\alpha_{2,0,0}}\\right)\\,, \\end{split}</span></div>

    <p class="text-gray-300">is a collision for  <span class="math">S_F</span> , where x is an arbitrary value in  <span class="math">\\mathbb{F}_p</span> . We verified the above collision using the computer algebra system Wolfram Mathematica by running the file Lemma3.ma we provide in https://gitlab.com/pis147879/supplemental-material/-/tree/main/proofs.</p>

    <p class="text-gray-300">Case:  <span class="math">\\alpha_{0,0,2} = 0</span>  (analogous for  <span class="math">\\alpha_{0,2,0} = 0</span>  and for  <span class="math">\\alpha_{2,0,0} = 0</span> ). If  <span class="math">\\alpha_{0,0,1} = 0</span> , then F depends only on  <span class="math">x_0</span>  and  <span class="math">x_1</span> , and the result follows from Theorem 2. For this reason, we limit ourselves to construct a collision for the case  <span class="math">\\alpha_{0,0,1} \\neq 0</span>  directly over  <span class="math">\\mathbb{F}_p^n</span> .</p>

    <p class="text-gray-300">First of all, since  <span class="math">\\alpha^{(2)} = 0</span>  due to (12) and since  <span class="math">\\alpha_{0,0,2} = 0</span> , it follows that  <span class="math">\\alpha_{0,2,0} = -\\alpha_{2,0,0}</span> . Working under the equivalence class defined in Definition 4, we can assume  <span class="math">\\alpha_{2,0,0} = -\\alpha_{0,2,0} = 1</span> . Hence, we limit ourselves to prove the result for</p>

    <div class="my-4 text-center"><span class="math-block">F(x_0, x_1, x_2) = x_0^2 - x_1^2 + A(x_0, x_1, x_2),</span></div>

    <p class="text-gray-300">where  <span class="math">A(x_0, x_1, x_2) := \\alpha_{1,0,0} \\cdot x_0 + \\alpha_{0,1,0} \\cdot x_1 + \\alpha_{0,0,1} \\cdot x_2</span> .</p>

    <p class="text-gray-300">By making use of the variables  <span class="math">d, s \\in \\mathbb{F}_p^n</span>  introduced in (13), a collision  <span class="math">\\mathcal{S}_F(x) = \\mathcal{S}_F(y)</span>  occurs if</p>

    <div class="my-4 text-center"><span class="math-block">F(x_i, x_{i+1}, x_{i+2}) - F(y_i, y_{i+1}, y_{i+2}) = s_i \\cdot d_i - s_{i+1} \\cdot d_{i+1} + A(d_i, d_{i+1}, d_{i+2}) = 0</span></div>

    <p class="text-gray-300">for each  <span class="math">i \\in \\{0, 1, \\dots, n-1\\}</span>  (where the sub-indices are taken modulo n), that is, if</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} d_0 &amp; -d_1 &amp; 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 \\\\ 0 &amp; d_1 &amp; -d_2 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 \\\\ 0 &amp; 0 &amp; d_2 &amp; -d_3 &amp; 0 &amp; \\dots &amp; 0 \\\\ \\vdots &amp; &amp; &amp; \\ddots &amp; \\ddots &amp; &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\dots &amp; 0 &amp; d_{n-3} &amp; -d_{n-2} &amp; 0 \\\\ 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; d_{n-2} &amp; -d_{n-1} \\\\ -d_0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; d_{n-1} \\end{bmatrix} \\times \\begin{bmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{n-3} \\\\ s_{n-2} \\\\ s_{n-1} \\end{bmatrix} = \\begin{bmatrix} A(d_0, d_1, d_2) \\\\ A(d_1, d_2, d_3) \\\\ A(d_2, d_3, d_4) \\\\ \\vdots \\\\ A(d_{n-3}, d_{n-2}, d_{n-1}) \\\\ A(d_{n-2}, d_{n-1}, d_0) \\\\ A(d_{n-1}, d_0, d_1) \\end{bmatrix}.</span></div>

    <p class="text-gray-300">The determinant of the l.h.s. matrix is zero, since the sum of all the rows is equal to zero. Hence, a solution of such system exists if the right-hand side (r.h.s.) vector satisfies the same linear condition, that is, if  <span class="math">\\sum_{i=0}^{n-1} A(d_i, d_{i+1}, d_{i+2}) = 0</span> . Since</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=0}^{n-1} A(d_i, d_{i+1}, d_{i+2}) = \\sum_{i=0}^{n-1} (\\alpha_{1,0,0} \\cdot d_i + \\alpha_{0,1,0} \\cdot d_{i+1} + \\alpha_{0,0,1} \\cdot d_{i+2}) = \\alpha^{(1)} \\cdot \\sum_{i=0}^{n-1} d_i,</span></div>

    <p class="text-gray-300">where  <span class="math">\\alpha^{(1)} \\neq 0</span>  due to (12), it follows that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=0}^{n-1} A(d_i, d_{i+1}, d_{i+2}) = 0 \\qquad \\longleftrightarrow \\qquad \\sum_{i=0}^{n-1} d_i = 0.</span></div>

    <p class="text-gray-300">By choosing  <span class="math">d_0, d_1, \\ldots, d_{n-1} \\in \\mathbb{F}_p</span>  such that  <span class="math">\\sum_{i=0}^{n-1} d_i = 0</span>  (i.e.,  <span class="math">d_{n-1} = -\\sum_{i=0}^{n-2} d_i</span> ), equations that compose the system we aim to solve are linearly dependent. In such a case, the collision  <span class="math">\\mathcal{S}_F(x) = \\mathcal{S}_F(y)</span>  occurs if the following system of n-1 equations is satisfied:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} d_0 &amp; -d_1 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 \\\\ 0 &amp; d_1 &amp; -d_2 &amp; 0 &amp; \\dots &amp; 0 \\\\ 0 &amp; 0 &amp; d_2 &amp; -d_3 &amp; \\dots &amp; 0 \\\\ \\vdots &amp; &amp; &amp; \\ddots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\dots &amp; 0 &amp; d_{n-3} &amp; -d_{n-2} \\\\ 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; d_{n-2} \\end{bmatrix} \\times \\begin{bmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{n-3} \\\\ s_{n-2} \\end{bmatrix} = \\begin{bmatrix} A(d_0, d_1, d_2) \\\\ A(d_1, d_2, d_3) \\\\ A(d_2, d_3, d_4) \\\\ \\vdots \\\\ A(d_{n-3}, d_{n-2}, d_{n-1}) \\\\ A(d_{n-3}, d_{n-2}, d_{n-1}) \\\\ A(d_{n-2}, d_{n-1}, d_0) + s_{n-1} \\cdot d_{n-1} \\end{bmatrix},</span></div>

    <p class="text-gray-300">where no condition is imposed on  <span class="math">s_{n-1} \\in \\mathbb{F}_p</span> . The determinant of such  <span class="math">(n-1) \\times (n-1)</span>  matrix is  <span class="math">\\prod_{i=0}^{n-2} d_i</span> , which is different from zero by choosing  <span class="math">d_i \\neq 0</span>  for each  <span class="math">i \\in \\{0, 1, \\dots, n-2\\}</span> . In such a case, it is possible to find  <span class="math">s_0, s_1, \\dots, s_{n-2}</span>  that solve the system of equations for the given  <span class="math">d_i \\neq 0</span>  and  <span class="math">s_{n-1}</span> , where  <span class="math">d_{n-1} = -\\sum_{i=0}^{n-2} d_i</span> . The found  <span class="math">d_i</span>  and  <span class="math">s_i</span>  correspond to a collision for  <span class="math">\\mathcal{S}_F</span> .</p>

    <p class="text-gray-300"><span id="page-21-1"></span><strong>Lemma 4.</strong> Let  <span class="math">p \\geq 3</span>  be a prime integer. Let  <span class="math">G : \\mathbb{F}_p^2 \\to \\mathbb{F}_p</span>  be a function of degree 2, and let  <span class="math">F : \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  be a function of degree 2 defined as</p>

    <p class="text-gray-300">1. <span class="math-block">F(x_0, x_1, x_2) := \\alpha_{1,0,0} \\cdot x_0 + G(x_1, x_2)</span> , or</p>

    <p class="text-gray-300">2. <span class="math-block">F(x_0, x_1, x_2) := \\alpha_{0,0,1} \\cdot x_2 + G(x_0, x_1)</span> .</p>

    <p class="text-gray-300">The SI-lifting  <span class="math">S_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  induced by F is <strong>never</strong> a permutation for each  <span class="math">n \\geq 5</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> W.l.o.g., we limit ourselves to prove the lemma for the function  <span class="math">F(x_0, x_1, x_2) = \\alpha_{1,0,0} \\cdot x_0 + G(x_1, x_2)</span> , since the proof for the second case  <span class="math">F(x_0, x_1, x_2) = \\alpha_{0,0,1} \\cdot x_2 + G(x_0, x_1)</span>  is analogous. Indeed, assume that  <span class="math">x = (x_0, x_1, \\dots, x_{n-1})</span>  and  <span class="math">y = (y_0, y_1, \\dots, y_{n-1})</span>  generate a collision for the SI-lifting  <span class="math">\\mathcal{S}_F</span>  induced by  <span class="math">F(x_0, x_1, x_2) = x_0 + G(x_1, x_2)</span> . Then,</p>

    <p class="text-gray-300"> <span class="math">x&#x27; = (x_{n-1}, x_{n-2}, \\dots, x_1, x_0)</span>  and  <span class="math">y&#x27; = (y_{n-1}, y_{n-2}, \\dots, y_1, y_0)</span>  generate a collision for the SI-lifting  <span class="math">S_{F&#x27;}</span>  induced by  <span class="math">F&#x27;(x_0, x_1, x_2) = x_2 + G(x_0, x_1)</span> .</p>

    <p class="text-gray-300">Due to the equivalence class defined in Definition 4, we can assume that  <span class="math">\\alpha_{1,0,0}=1</span>  in the case  <span class="math">F(x_0,x_1,x_2)=\\alpha_{1,0,0}\\cdot x_0+G(x_1,x_2)</span> , that is, from now on we work with  <span class="math">F(x_0,x_1,x_2)=x_0+G(x_1,x_2)</span> .</p>

    <p class="text-gray-300">We prove this result by finding a collision for  <span class="math">S_F</span> . First of all, if  <span class="math">\\alpha_{0,1,1} = 0</span> , then F satisfies Lemma 3, and a collision is already known. By assuming  <span class="math">\\alpha_{0,1,1} \\neq 0</span> , we achieve this goal by studying separately the following cases:</p>

    <p class="text-gray-300">case  <span class="math">\\alpha_{0,0,2} = \\alpha_{0,2,0} \\neq 0</span> : we construct a collision by working with two inputs  <span class="math">x, y \\in \\mathbb{F}_p^n</span>  such that  <span class="math">x_i \\neq y_i</span>  for each  <span class="math">i \\in \\{0, 1, 2, \\dots, n-1\\}</span> ;</p>

    <p class="text-gray-300">case n odd and  <span class="math">\\alpha_{0,0,2} \\neq \\alpha_{0,2,0}</span> : we construct a collision by working with two inputs  <span class="math">x, y \\in \\mathbb{F}_p^n</span>  such that  <span class="math">x_i = y_i</span>  for each i odd and  <span class="math">x_j \\neq y_j</span>  for each j even;</p>

    <p class="text-gray-300">case n even and  <span class="math">\\alpha_{0,0,2} \\neq \\alpha_{0,2,0}</span> : we construct a collision by working with two inputs  <span class="math">x,y \\in \\mathbb{F}_p^n</span>  such that  <span class="math">x_i = y_i</span>  for each  <span class="math">i \\neq n-1</span>  odd and  <span class="math">x_j \\neq y_j</span>  for each j even and j = n-1.</p>

    <p class="text-gray-300">We recall that  <span class="math">\\alpha^{(2)} = 0</span>  and  <span class="math">\\alpha^{(1)} \\neq 0</span>  due to (12).</p>

    <p class="text-gray-300">Case:  <span class="math">\\alpha_{0,0,2} = \\alpha_{0,2,0} \\neq 0</span>  and  <span class="math">\\alpha_{0,1,1} \\neq 0</span> . First of all,  <span class="math">\\alpha^{(2)} = 0</span>  implies  <span class="math">\\alpha_{0,1,1} = -2\\alpha_{0,2,0}</span> . Working under the equivalence class defined in Definition 4, we also assume  <span class="math">\\alpha_{0,2,0} = 1</span>  (besides  <span class="math">\\alpha_{1,0,0} = 1</span> ).</p>

    <p class="text-gray-300">Let  <span class="math">A(z_0, z_1, z_2) : \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  be the linear function  <span class="math">A(z_0, z_1, z_2) := z_0 + \\alpha_{0,1,0} \\cdot z_1 + \\alpha_{0,0,1} \\cdot z_2</span> . By making used of the variables  <span class="math">d, s \\in \\mathbb{F}_p^n</span>  introduced in (13), the collision  <span class="math">\\mathcal{S}_F(x) = \\mathcal{S}_F(y)</span>  occurs if:</p>

    <div class="my-4 text-center"><span class="math-block">0 = F(x_i, x_{i+1}, x_{i+2}) - F(y_i, y_{i+1}, y_{i+2})</span></div>

    <p class="text-gray-300">=  <span class="math">(d_{i+1} - d_{i+2}) \\cdot s_{i+1} + (d_{i+2} - d_{i+1}) \\cdot s_{i+2} + A(d_i, d_{i+1}, d_{i+2})</span></p>

    <p class="text-gray-300">for each  <span class="math">i \\in \\{0, 1, 2, ..., n-1\\}</span> , that is, if</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} 0 &amp; d_1 - d_2 &amp; d_2 - d_1 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 \\\\ 0 &amp; 0 &amp; d_2 - d_3 &amp; d_3 - d_2 &amp; 0 &amp; \\dots &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; d_3 - d_4 &amp; d_4 - d_3 &amp; \\dots &amp; 0 \\\\ \\vdots &amp; &amp; &amp; \\ddots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; d_{n-2} - d_{n-1} &amp; d_{n-1} - d_{n-2} \\\\ d_0 - d_{n-1} &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; d_{n-1} - d_0 \\\\ d_0 - d_1 &amp; d_1 - d_0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 \\end{bmatrix} \\times \\begin{bmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{n-3} \\\\ s_{n-2} \\\\ s_{n-1} \\end{bmatrix}</span></div>

    <div class="my-4 text-center"><span class="math-block">= - \\left[ A(d_0, d_1, d_2), A(d_1, d_2, d_3), A(d_2, d_3, d_4), \\dots, A(d_{n-2}, d_{n-1}, d_0), A(d_{n-1}, d_0, d_1) \\right]^T.</span></div>

    <p class="text-gray-300">The determinant of the l.h.s. matrix is equal to zero, since the sum (with alternating sign) of the columns is equal to zero.</p>

    <p class="text-gray-300">In order to set up a system of linear independent equations, note that the first condition  <span class="math">F(x_0,x_1,x_2)=F(y_0,y_1,y_2)</span>  (that is,  <span class="math">0=(d_1-d_2)\\cdot s_1+(d_2-d_1)\\cdot s_2+d_0+\\alpha_{0,1,0}\\cdot d_1+\\alpha_{0,0,1}\\cdot d_2</span> ) is always satisfied if</p>

    <p class="text-gray-300"><span id="page-22-0"></span> <span class="math-block">d_1 = d_2</span>  and  <span class="math">d_0 = -(\\alpha_{0,1,0} + \\alpha_{0,0,1}) \\cdot d_1</span> , (18)</p>

    <p class="text-gray-300">where no condition on  <span class="math">s_0, s_1, s_2</span>  is imposed. Since  <span class="math">\\alpha^{(1)} = 1 + \\alpha_{0,1,0} + \\alpha_{0,0,1} \\neq 0</span>  due to (12), then  <span class="math">\\alpha_{0,1,0} + \\alpha_{0,0,1} \\neq -1</span>  and so  <span class="math">d_0 \\neq d_2, d_1</span> . In particular:</p>

    <div class="my-4 text-center"><span class="math-block">d_0 - d_1 = -(\\alpha_{0,1,0} + \\alpha_{0,0,1}) \\cdot d_1 - d_1 = -d_1 \\cdot \\alpha^{(1)}</span></div>

    <p class="text-gray-300">by definition of  <span class="math">\\alpha^{(1)} = 1 + \\alpha_{0,1,0} + \\alpha_{0,0,1} \\neq 0</span>  (remember that we fixed  <span class="math">\\alpha_{1,0,0} = 1</span> ).</p>

    <p class="text-gray-300">For simplicity, we fix  <span class="math">s_0 = 0</span> . In the case  <span class="math">d_1 = d_2</span>  and  <span class="math">d_0 = -(\\alpha_{0,1,0} + \\alpha_{0,0,1}) \\cdot d_2</span> , the first equation  <span class="math">F(x_0, x_1, x_2) = F(y_0, y_1, y_2)</span>  is satisfied for each  <span class="math">s_0</span> , and the collision  <span class="math">S_F(x) = S_F(y)</span>  occurs if</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} 0 &amp; d_2 - d_3 &amp; d_3 - d_2 &amp; 0 &amp; \\dots &amp; 0 \\\\ 0 &amp; 0 &amp; d_3 - d_4 &amp; d_4 - d_3 &amp; \\dots &amp; 0 \\\\ \\vdots &amp; &amp; \\ddots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\dots &amp; 0 &amp; d_{n-2} - d_{n-1} &amp; d_{n-1} - d_{n-2} \\\\ 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; d_{n-1} - d_0 \\end{bmatrix} \\times \\begin{bmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{n-3} \\\\ s_{n-2} \\\\ s_{n-1} \\end{bmatrix} = \\begin{bmatrix} A(d_1, d_2, d_3), \\dots, A(d_{n-3}, d_{n-2}, d_{n-1}), A(d_{n-2}, d_{n-1}, d_0), A(d_{n-1}, d_0, d_1) \\end{bmatrix}^T.</span></div>

    <p class="text-gray-300">The determinant of the l.h.s. matrix is equal to</p>

    <div class="my-4 text-center"><span class="math-block">(-1)^n \\cdot \\underbrace{(d_0 - d_1)}_{= -d_1 \\cdot \\alpha^{(1)}} \\cdot \\prod_{i=2}^{n-1} (d_i - d_{i+1}) \\equiv -(-1)^n \\cdot \\alpha^{(1)} \\cdot d_1 \\cdot \\prod_{i=2}^{n-1} (d_i - d_{i+1}).</span></div>

    <p class="text-gray-300">due to (18). Hence, the determinant is always different from zero by choosing  <span class="math">d_1 \\neq 0</span>  and  <span class="math">d_i \\neq d_{i+1}</span>  for each  <span class="math">i \\in \\{3, \\ldots, n-2\\}</span> . In such a case, there exist  <span class="math">s_1, \\ldots, s_{n-2} \\in \\mathbb{F}_p</span>  that solve the system of equations for the given  <span class="math">d_i</span> , where  <span class="math">s_0 = 0</span> ,  <span class="math">d_1 = d_2</span>  and  <span class="math">d_0 = -(\\alpha_{0,1,0} + \\alpha_{0,0,1}) \\cdot d_2</span> . The found  <span class="math">d_i</span>  and  <span class="math">s_i</span>  correspond to a collision for  <span class="math">S_F</span> .</p>

    <p class="text-gray-300">Case: n odd,  <span class="math">\\alpha_{0,1,1} \\neq 0</span>  and  <span class="math">\\alpha_{0,0,2} \\neq \\alpha_{0,2,0}</span> . Let n = 2n' + 1. By making used of the variables  <span class="math">d, s \\in \\mathbb{F}_p^n</span>  introduced in (13), the collision  <span class="math">\\mathcal{S}_F(x) = \\mathcal{S}_F(y)</span>  occurs if</p>

    <div class="my-4 text-center"><span class="math-block">0 = F(x_i, x_{i+1}, x_{i+2}) - F(y_i, y_{i+1}, y_{i+2})</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\alpha_{0,2,0} \\cdot d_{i+1} \\cdot s_{i+1} + \\alpha&#x27;_{0,1,1} \\cdot (d_{i+1} \\cdot s_{i+2} + s_{i+1} \\cdot d_{i+2}) + \\alpha_{0,0,2} \\cdot d_{i+2} \\cdot s_{i+2} + A(d_i, d_{i+1}, d_{i+2})</span></div>

    <div class="my-4 text-center"><span class="math-block">= s_{i+1} \\cdot (\\alpha_{0,2,0} \\cdot d_{i+1} + \\alpha&#x27;_{0,1,1} \\cdot d_{i+2}) + s_{i+2} \\cdot (\\alpha_{0,0,2} \\cdot d_{i+2} + \\alpha&#x27;_{0,1,1} \\cdot d_{i+1}) + A(d_i, d_{i+1}, d_{i+2})</span></div>

    <p class="text-gray-300">for each  <span class="math">i \\in \\{0, 1, 2, ..., n-1\\}</span> , where  <span class="math">\\alpha_{0,1,1} := 2 \\cdot \\alpha&#x27;_{0,1,1}</span> , and  <span class="math">A(z_0, z_1, z_2) : \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  is the linear function  <span class="math">A(z_0, z_1, z_2) := z_0 + \\alpha_{0,1,0} \\cdot z_1 + \\alpha_{0,0,1} \\cdot z_2</span>  as before.</p>

    <p class="text-gray-300">We propose a collision by working with two inputs  <span class="math">x, y \\in \\mathbb{F}_p^n</span>  defined as</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">x_i = y_i</span>  for each  <span class="math">i \\in \\{1, 3, ..., 2j + 1, ..., n 2\\}</span>  odd (i.e.,  <span class="math">d_i = 0</span>  for each i odd);</li>

      <li><span class="math">x_i \\neq y_i</span>  for each  <span class="math">i \\in \\{0, 2, ..., 2j, ..., n-1\\}</span>  even.</li>

    </ul>

    <p class="text-gray-300">In such a case, the collision  <span class="math">S_F(x) = S_F(y)</span>  occurs if</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} 0 &amp; \\alpha&#x27;_{0,1,1} \\cdot d_2 &amp; \\alpha_{0,0,2} \\cdot d_2 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\alpha_{0,2,0} \\cdot d_2 &amp; \\alpha&#x27;_{0,1,1} \\cdot d_2 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; \\alpha&#x27;_{0,1,1} \\cdot d_4 &amp; \\alpha_{0,0,2} \\cdot d_4 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 \\\\ \\vdots &amp; &amp; &amp; &amp; \\ddots &amp; \\ddots &amp; &amp; &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; \\alpha&#x27;_{0,1,1} \\cdot d_{n-1} &amp; \\alpha_{0,0,2} \\cdot d_{n-1} \\\\ \\alpha_{0,0,2} \\cdot d_0 + &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; \\alpha&#x27;_{0,1,1} \\cdot d_{n-1} + \\alpha&#x27;_{0,0,2} \\cdot d_{n-1} + \\alpha&#x27;_{0,1,1} \\cdot d_{n-1} &amp; \\alpha&#x27;_{0,0,2} \\cdot d_{n-1} + \\alpha&#x27;_{0,0,2} \\cdot d_{n-1} + \\alpha&#x27;_{0,2,0} \\cdot d_0 &amp; \\alpha&#x27;_{0,1,1} \\cdot d_0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 \\\\ \\end{bmatrix}</span></div>

    <p class="text-gray-300"> <span class="math">\\times \\left[s_0, s_1, s_2, s_3, s_4, \\dots, s_{n-3}, s_{n-2}, s_{n-1}\\right]^T</span></p>

    <div class="my-4 text-center"><span class="math-block">= -\\left[A(d_0,0,d_2),A(0,d_2,0),A(d_2,0,d_4),\\ldots,A(d_{n-3},0,d_{n-1}),A(0,d_{n-1},d_0),A(d_{n-1},d_0,0)\\right]^T.</span></div>

    <p class="text-gray-300">The determinant of the l.h.s. matrix is equal to:</p>

    <p class="text-gray-300"><span class="math-block">\\alpha&#x27;_{0,1,1}^{\\frac{n-1}{2}} \\cdot d_0 \\cdot d_{n-1} \\cdot \\prod_{i=1}^{n&#x27;-1} d_{2i}^2 \\cdot (d_0 \\cdot \\beta + d_{n-1} \\cdot \\gamma)</span> ,</p>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">\\beta := \\alpha_{0,2,0}^{\\frac{n-1}{2}} \\cdot \\alpha_{0,1,1} + \\alpha_{0,0,2}^{\\frac{n+1}{2}} \\quad \\text{and} \\quad \\gamma := \\alpha_{0,2,0}^{\\frac{n+1}{2}} + \\alpha_{0,0,2}^{\\frac{n-1}{2}} \\cdot \\alpha&#x27;_{0,1,1}.</span></div>

    <p class="text-gray-300">Hence</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">\\alpha_{0,0,2} = 0</span> , then  <span class="math">\\alpha_{0,2,0} = -\\alpha_{0,1,1} \\neq 0</span>  due to the fact that  <span class="math">\\alpha^{(2)} = 0</span>  see (12). In such a case,  <span class="math">\\beta \\neq 0</span> , and the matrix is invertible (i.e., the determinant is different from zero) for  <span class="math">d_0, d_2, d_4, \\ldots, d_{n-1} \\neq 0</span>  and  <span class="math">\\beta \\cdot d_0 \\neq -d_{n-1} \\cdot \\gamma</span> . By solving the linear system of equations, the found  <span class="math">d_i</span>  and  <span class="math">s_i</span>  correspond to a collision for  <span class="math">\\mathcal{S}_F</span> . Analogous for  <span class="math">\\alpha_{0,2,0} = 0</span> ;</li>

      <li>if  <span class="math">\\alpha_{0,0,2}, \\alpha_{0,2,0} \\neq 0</span> , then at least one among  <span class="math">\\beta</span>  and  <span class="math">\\gamma</span>  is different from zero. Indeed, if  <span class="math">\\alpha_{0,0,2}, \\alpha_{0,2,0} \\neq 0</span>  and if  <span class="math">\\beta = \\gamma = 0</span> , then</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">0 = \\frac{\\beta}{\\alpha_{0,2,0}^{\\frac{n-1}{2}}} = \\left(\\frac{\\alpha_{0,0,2}}{\\alpha_{0,2,0}}\\right)^{\\frac{n-1}{2}} \\cdot (\\alpha_{0,1,1} + \\alpha_{0,2,0}) \\qquad \\rightarrow \\qquad \\alpha_{0,2,0} = -\\alpha_{0,1,1} \\,,</span></div>

    <div class="my-4 text-center"><span class="math-block">0 = \\frac{\\gamma}{\\alpha_{0,0,2}^{\\frac{n-1}{2}}} = \\left(\\frac{\\alpha_{0,2,0}}{\\alpha_{0,0,2}}\\right)^{\\frac{n-1}{2}} \\cdot (\\alpha_{0,1,1} + \\alpha_{0,0,2}) \\qquad \\rightarrow \\qquad \\alpha_{0,0,2} = -\\alpha_{0,1,1} \\,.</span></div>

    <p class="text-gray-300">This implies that  <span class="math">\\alpha_{0,0,2} = \\alpha_{0,2,0}</span> , which is not possible by assumption. Hence, w.l.o.g., let's assume that  <span class="math">\\beta \\neq 0</span>  (analogous if  <span class="math">\\gamma \\neq 0</span> ). Working as before, the matrix is invertible (i.e., the determinant is different from zero) for  <span class="math">d_0, d_2, d_4, \\ldots, d_{n-1} \\neq 0</span>  and  <span class="math">\\beta \\cdot d_0 \\neq -d_{n-1} \\cdot \\gamma</span> . By solving the linear system of equations, the found  <span class="math">d_i</span>  and  <span class="math">s_i</span>  correspond to a collision for  <span class="math">\\mathcal{S}_F</span> .</p>

    <p class="text-gray-300">Case: n even,  <span class="math">\\alpha_{0,1,1} \\neq 0</span>  and  <span class="math">\\alpha_{0,0,2} \\neq \\alpha_{0,2,0}</span> . Let n = 2n'' + 2. The proof is similar to the one proposed for n odd, but in this case we propose a collision by working with two inputs  <span class="math">x, y \\in \\mathbb{F}_n^n</span>  defined as</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">x_i = y_i</span>  for each  <span class="math">i \\in \\{1, 3, \\dots, 2i&#x27; + 1, \\dots, n 3\\}</span>  odd, but not for i = n 1 (equivalently,  <span class="math">d_i = 0</span>  for each i odd  <span class="math">\\neq n 1</span> );</li>

      <li><span class="math">x_i \\neq y_i</span>  for each  <span class="math">i \\in \\{0, 2, \\dots, 2i&#x27;, \\dots, n-2\\}</span>  even, and for i = n-1.</li>

    </ul>

    <p class="text-gray-300">In such a case, the collision  <span class="math">S_F(x) = S_F(y)</span>  occurs if</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} 0 &amp; \\alpha&#x27;_{0,1,1} \\cdot d_2 &amp; \\alpha_{0,0,2} \\cdot d_2 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\alpha_{0,2,0} \\cdot d_2 &amp; \\alpha&#x27;_{0,1,1} \\cdot d_2 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; \\alpha&#x27;_{0,1,1} \\cdot d_4 &amp; \\alpha_{0,0,2} \\cdot d_4 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 \\\\ \\vdots &amp; &amp; &amp; \\ddots &amp; \\ddots &amp; &amp; &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; \\alpha&#x27;_{0,1,1} \\cdot d_{n-1} &amp; \\alpha_{0,1,1} \\cdot d_{n-1} \\\\ \\alpha_{0,0,2} \\cdot d_0 + &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\\\ \\alpha_{0,0,1} \\cdot d_{n-1} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; &amp; &amp; &amp; &amp; &amp;</span></div>

    <p class="text-gray-300">where  <span class="math">\\alpha&#x27;_{0,1,1} := \\alpha_{0,1,1}/2</span>  as before. The determinant of the l.h.s. matrix is equal to:</p>

    <div class="my-4 text-center"><span class="math-block">(\\alpha&#x27;_{0,1,1})^{n&#x27;&#x27;} \\cdot \\left( (\\alpha_{0,0,2})^{n&#x27;&#x27;} \\cdot (\\alpha_{0,0,2} \\cdot d_{n-1} + \\alpha&#x27;_{0,1,1} \\cdot d_{n-2}) \\cdot (\\alpha_{0,0,2} \\cdot d_0 + \\alpha&#x27;_{0,1,1} \\cdot d_{n-1}) \\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">- (\\alpha_{0,2,0})^{n&#x27;&#x27;} \\cdot \\left( \\alpha&#x27;_{0,1,1} \\cdot d_0 + \\alpha_{0,2,0} \\cdot d_{n-1} \\right) \\cdot \\left( \\alpha&#x27;_{0,1,1} \\cdot d_{n-1} + \\alpha_{0,2,0} \\cdot d_{n-2} \\right) \\right) \\cdot \\prod_{i=0}^{n&#x27;&#x27;} d_{2i}^{2}.</span></div>

    <p class="text-gray-300">Working as in the case n odd:</p>

    <p class="text-gray-300">• if  <span class="math">\\alpha_{0,2,0}=0</span>  (hence,  <span class="math">\\alpha_{0,0,2}=-\\alpha_{0,1,1}\\neq 0</span> ): the determinant of the matrix becomes</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\alpha&#x27;_{0,1,1} \\cdot \\alpha_{0,0,2}\\right)^{n&#x27;&#x27;} \\cdot \\left(\\alpha_{0,0,2} \\cdot d_0 + \\alpha&#x27;_{0,1,1} \\cdot d_{n-1}\\right) \\cdot \\left(\\alpha_{0,0,2} \\cdot d_{n-1} + \\alpha&#x27;_{0,1,1} \\cdot d_{n-2}\\right) \\cdot \\prod_{i=0}^{n&#x27;&#x27;} d_{2i}^2,</span></div>

    <p class="text-gray-300">which is different from zero by choosing  <span class="math">d_0, d_2, d_4, \\ldots, d_{n-2}, d_{n-1} \\neq 0, d_0 \\neq -\\frac{\\alpha&#x27;_{0,1,1} \\cdot d_{n-1}}{\\alpha_{0,0,2}}</span>  and  <span class="math">d_{n-1} \\neq -\\frac{\\alpha&#x27;_{0,1,1} \\cdot d_{n-2}}{\\alpha_{0,0,2}}</span> . By solving the linear system of equations, the found  <span class="math">d_i</span>  and  <span class="math">s_i</span>  correspond to a collision for  <span class="math">\\mathcal{S}_F</span> . Analogous if  <span class="math">\\alpha_{0,0,2} = 0</span> ;</p>

    <p class="text-gray-300">• if  <span class="math">\\alpha_{0,2,0}, \\alpha_{0,0,2} \\neq 0</span> : let  <span class="math">d_0, d_{n-1} \\in \\mathbb{F}_p \\setminus \\{0\\}</span>  be such that  <span class="math">\\alpha&#x27;_{0,1,1} \\cdot d_0 + \\alpha_{0,2,0} \\cdot d_{n-1} = 0</span> . In such a case, the determinant becomes</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{\\left(\\alpha_{0,1,1}&#x27;\\cdot\\alpha_{0,0,2}\\right)^{n&#x27;&#x27;}}{\\alpha_{0,1,1}&#x27;}\\cdot\\left(\\left(\\alpha_{0,1,1}&#x27;\\right)^2-\\alpha_{0,0,2}\\cdot\\alpha_{0,2,0}\\right)\\cdot\\left(\\alpha_{0,0,2}\\cdot d_{n-1}+\\alpha_{0,1,1}&#x27;\\cdot d_{n-2}\\right)\\cdot d_{n-1}\\cdot\\prod_{i=0}^{n&#x27;&#x27;}d_{2i}^2\\,,</span></div>

    <p class="text-gray-300">which is different from zero by choosing  <span class="math">d_0, d_2, d_4, \\ldots, d_{n-2}, d_{n-1} \\neq 0</span>  and  <span class="math">d_{n-1} = -\\frac{\\alpha&#x27;_{0,1,1} \\cdot d_{n-2}}{\\alpha_{0,0,2}}</span> , if  <span class="math">(\\alpha&#x27;_{0,1,1})^2 \\neq \\alpha_{0,0,2} \\cdot \\alpha_{0,2,0}</span> . By solving the linear system of equations, the found  <span class="math">d_i</span>  and  <span class="math">s_i</span>  correspond to a collision for  <span class="math">\\mathcal{S}_F</span> .</p>

    <p class="text-gray-300">In order to finish the proof, we have to prove that  <span class="math">(\\alpha&#x27;_{0,1,1})^2 \\neq \\alpha_{0,0,2} \\cdot \\alpha_{0,2,0}</span> . Since  <span class="math">\\alpha^{(2)} = \\alpha_{0,0,2} + \\alpha_{0,2,0} + \\alpha_{0,1,1} = 0</span>  due to (12), then</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\alpha_{0,1,1}&#x27;\\right)^2 - \\alpha_{0,0,2} \\cdot \\alpha_{0,2,0} = \\left(-\\frac{\\alpha_{0,0,2} + \\alpha_{0,2,0}}{2}\\right)^2 - \\alpha_{0,0,2} \\cdot \\alpha_{0,2,0} = \\frac{(\\alpha_{0,0,2} - \\alpha_{0,2,0})^2}{4}</span></div>

    <p class="text-gray-300">is equal to zero if and only if  <span class="math">\\alpha_{0,0,2} = \\alpha_{0,2,0}</span> , which is not possible by assumption. This concludes the proof.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8"><strong>6.3</strong> Case: <span class="math">\\alpha_{1,0,1} \\neq 0</span></h3>

    <p class="text-gray-300"><span id="page-25-1"></span><strong>Lemma 5.</strong> Let  <span class="math">p \\geq 3</span>  be a prime integer. Let  <span class="math">F : \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  be a function of degree 2 defined as in (7) where  <span class="math">\\alpha_{1,0,1} \\neq 0</span> . The SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  induced by F is <strong>never</strong> a permutation for each  <span class="math">n \\geq 5</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We prove this result by finding a collision for  <span class="math">\\mathcal{S}_F</span> . The strategy of the proof is similar to the one proposed for Lemma 3. We first prove the result for the case n=5. Our goal is to prove that for each function  <span class="math">F: \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  of degree 2 defined as in (7), it is possible to find two different inputs  <span class="math">x, y \\in \\mathbb{F}_p^5</span>  such that  <span class="math">\\mathcal{S}_F(x) = \\mathcal{S}_F(y)</span> , or equivalently:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in \\{0, 1, 2, 3, 4\\}: F(x_i, x_{i+1}, x_{i+2}) = F(y_i, y_{i+1}, y_{i+2}),</span></div>

    <p class="text-gray-300">where the sub-indexes are taken modulo n = 5. By assuming  <span class="math">x_0 = y_0 = x_1 = y_1 = \\hat{z} \\in \\mathbb{F}_p</span> , we can easily generalize such collision for each  <span class="math">n \\geq 6</span> , that is,</p>

    <div class="my-4 text-center"><span class="math-block">S_F(\\hat{z}, \\hat{z}, x_2, x_3, x_4) = S_F(\\hat{z}, \\hat{z}, y_2, y_3, y_4) \\to S_F(\\hat{z}, \\hat{z}, x_2, x_3, x_4, \\hat{z}, \\dots, \\hat{z}) = S_F(\\hat{z}, \\hat{z}, y_2, y_3, y_4, \\hat{z}, \\dots, \\hat{z}),</span></div>

    <p class="text-gray-300">since  <span class="math">F(x_i, x_{i+1}, x_{i+2}) = F(\\hat{z}, \\hat{z}, \\hat{z}) = F(y_i, y_{i+1}, y_{i+2})</span>  for each  <span class="math">i \\in \\{5, \\dots, n-1\\}</span> .</p>

    <p class="text-gray-300"><strong>Case: Only a Single Non-Null Difference</strong> <em>d<sup>i</sup></em> <strong>6= 0.</strong> We first construct collisions in which the inputs <em>x</em> and <em>y</em> differ in one word/variable only, that is, there exists <em>l</em> ∈ {2<em>,</em> 3<em>,</em> 4} such that <em>x<sup>l</sup></em> 6= <em>y<sup>l</sup></em> (equivalently, <em>d<sup>l</sup></em> 6= 0 where <em>d<sup>l</sup></em> = <em>x<sup>l</sup></em> − <em>y<sup>l</sup></em> is defined as in <a href="#page-18-4">\\(13\\)</a>), and <em>x<sup>j</sup></em> = <em>y<sup>j</sup></em> for each <em>j</em> ∈ {2<em>,</em> 3<em>,</em> 4}.</p>

    <p class="text-gray-300"><em>SubCase: x</em><sup>4</sup> 6= <em>y</em>4<em>.</em> In the case <em>x</em><sup>2</sup> = <em>y</em>2, <em>x</em><sup>3</sup> = <em>y</em>3, and <em>x</em><sup>4</sup> 6= <em>y</em>4, the collision S<em><sup>F</sup></em> (ˆ<em>z, z, x</em> ˆ <sup>2</sup><em>, x</em>3<em>, x</em>4) = S<em><sup>F</sup></em> (ˆ<em>z, z, x</em> ˆ <sup>2</sup><em>, x</em>3<em>, y</em>4) occurs if</p>

    <div class="my-4 text-center"><span class="math-block">F(x_2, x_3, x_4) = F(y_2, y_3, x_4) \\rightarrow 0 = \\alpha_{0,0,2} \\cdot (x_4 + y_4) + \\alpha_{0,1,1} \\cdot x_3 + \\alpha_{1,1,0} \\cdot x_2 + \\alpha_{0,0,1},</span></div>

    <div class="my-4 text-center"><span class="math-block">F(x_3, x_4, \\hat{z}) = F(x_3, y_4, \\hat{z}) \\rightarrow 0 = \\alpha_{0,2,0} \\cdot (x_4 + y_4) + \\alpha_{0,1,1} \\cdot \\hat{z} + \\alpha_{1,1,0} \\cdot x_3 + \\alpha_{0,1,0},</span></div>

    <div class="my-4 text-center"><span class="math-block">F(x_4, \\hat{z}, \\hat{z}) = F(y_4, \\hat{z}, \\hat{z}) \\rightarrow 0 = \\alpha_{2,0,0} \\cdot (x_4 + y_4) + (\\alpha_{1,1,0} + \\alpha_{1,0,1}) \\cdot \\hat{z} + \\alpha_{1,0,0},</span></div>

    <p class="text-gray-300">that is,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} \\alpha_{1,1,0} + \\alpha_{1,0,1} &amp; 0 &amp; 0 \\\\ \\alpha_{0,1,1} &amp; 0 &amp; \\alpha_{1,1,0} \\\\ 0 &amp; \\alpha_{1,0,1} &amp; \\alpha_{0,1,1} \\end{bmatrix} \\times \\begin{bmatrix} \\hat{z} \\\\ x_2 \\\\ x_3 \\end{bmatrix} = - \\begin{bmatrix} \\alpha_{2,0,0} \\cdot (x_4 + y_4) + \\alpha_{1,0,0} \\\\ \\alpha_{0,2,0} \\cdot (x_4 + y_4) + \\alpha_{0,1,0} \\\\ \\alpha_{0,0,2} \\cdot (x_4 + y_4) + \\alpha_{0,0,1} \\end{bmatrix}.</span></div>

    <p class="text-gray-300">A non-trivial solution (hence, a collision) exists if <em>α</em>1<em>,</em>1<em>,</em><sup>0</sup> 6= −<em>α</em>1<em>,</em>0<em>,</em><sup>1</sup> and <em>α</em>1<em>,</em>1<em>,</em><sup>0</sup> = 0 6 (remember that <em>α</em>1<em>,</em>0<em>,</em><sup>1</sup> 6= 0 by assumption).</p>

    <p class="text-gray-300"><em>SubCase: x</em><sup>3</sup> 6= <em>y</em>3<em>.</em> Working in a similar way, in the case <em>x</em><sup>2</sup> = <em>y</em>2, <em>x</em><sup>3</sup> 6= <em>y</em>3, and <em>x</em><sup>4</sup> = <em>y</em>4, the collision S<em><sup>F</sup></em> (ˆ<em>z, z, x</em> ˆ <sup>2</sup><em>, x</em>3<em>, x</em>4) = S<em><sup>F</sup></em> (ˆ<em>z, z, x</em> ˆ <sup>2</sup><em>, y</em>3<em>, x</em>4) occurs if</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} \\alpha_{1,0,1} &amp; \\alpha_{0,1,1} &amp; 0 \\\\ 0 &amp; \\alpha_{1,1,0} &amp; \\alpha_{0,1,1} \\\\ \\alpha_{1,0,1} &amp; 0 &amp; \\alpha_{1,1,0} \\end{bmatrix} \\times \\begin{bmatrix} \\hat{z} \\\\ x_2 \\\\ x_4 \\end{bmatrix} = - \\begin{bmatrix} \\alpha_{0,0,2} \\cdot (x_3 + y_3) + \\alpha_{0,0,1} \\\\ \\alpha_{0,2,0} \\cdot (x_3 + y_3) + \\alpha_{0,1,0} \\\\ \\alpha_{2,0,0} \\cdot (x_3 + y_3) + \\alpha_{1,0,0} \\end{bmatrix}.</span></div>

    <p class="text-gray-300">A non-trivial solution (hence, a collision) exists if <em>α</em> 2 <sup>1</sup><em>,</em>1<em>,</em><sup>0</sup> + <em>α</em> 2 <sup>0</sup><em>,</em>1<em>,</em><sup>1</sup> 6= 0 (remember that <em>α</em>1<em>,</em>0<em>,</em><sup>1</sup> 6= 0 by assumption).</p>

    <p class="text-gray-300"><em>SubCase: x</em><sup>2</sup> =6 <em>y</em>2<em>.</em> Finally, in the case <em>x</em><sup>2</sup> 6= <em>y</em>2, <em>x</em><sup>3</sup> = <em>y</em>3, and <em>x</em><sup>4</sup> = <em>y</em>4, the collision S<em><sup>F</sup></em> (ˆ<em>z, z, x</em> ˆ <sup>2</sup><em>, x</em>3<em>, x</em>4) = S<em><sup>F</sup></em> (ˆ<em>z, z, y</em> ˆ <sup>2</sup><em>, x</em>3<em>, x</em>4) occurs if</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} \\alpha_{1,0,1} + \\alpha_{0,1,1} &amp; 0 &amp; 0 \\\\ \\alpha_{1,1,0} &amp; \\alpha_{0,1,1} &amp; 0 \\\\ 0 &amp; \\alpha_{1,1,0} &amp; \\alpha_{1,0,1} \\end{bmatrix} \\times \\begin{bmatrix} \\hat{z} \\\\ x_3 \\\\ x_4 \\end{bmatrix} = - \\begin{bmatrix} \\alpha_{0,0,2} \\cdot (x_2 + y_2) + \\alpha_{0,0,1} \\\\ \\alpha_{0,2,0} \\cdot (x_2 + y_2) + \\alpha_{0,1,0} \\\\ \\alpha_{2,0,0} \\cdot (x_2 + y_2) + \\alpha_{1,0,0} \\end{bmatrix}.</span></div>

    <p class="text-gray-300">A non-trivial solution (hence, a collision) exists if <em>α</em>0<em>,</em>1<em>,</em><sup>1</sup> 6= −<em>α</em>1<em>,</em>0<em>,</em><sup>1</sup> and <em>α</em>0<em>,</em>1<em>,</em><sup>1</sup> = 0 6 (remember that <em>α</em>1<em>,</em>0<em>,</em><sup>1</sup> 6= 0 by assumption).</p>

    <p class="text-gray-300"><em>Summary.</em> In summary, assuming <em>α</em>1<em>,</em>0<em>,</em><sup>1</sup> 6= 0, the case in which it is <em>not</em> possible to find a collision by using the strategy just proposed (i.e., only a single non-zero difference <em>di</em>) is</p>

    <p class="text-gray-300"><span id="page-26-0"></span> <span class="math-block">\\begin{cases} \\alpha_{1,1,0}^2 + \\alpha_{0,1,1}^2 = 0; \\\\ \\alpha_{1,0,1} = -\\alpha_{1,1,0} &amp; or &amp; \\alpha_{1,1,0} = 0; \\\\ \\alpha_{1,0,1} = -\\alpha_{0,1,1} &amp; or &amp; \\alpha_{0,1,1} = 0. \\end{cases}</span> (19)</p>

    <p class="text-gray-300">Indeed, if <em>α</em>1<em>,</em>0<em>,</em><sup>1</sup> 6= 0, it is sufficient that one of three conditions given in the system is not fulfilled in order to find a collision using the previous strategy.</p>

    <p class="text-gray-300">In the following, we set up collisions for this remaining case. Before going on, we note that if <em>α</em>1<em>,</em>1<em>,</em><sup>0</sup> = 0, then the condition <em>α</em>1<em>,</em>0<em>,</em><sup>1</sup> = −<em>α</em>1<em>,</em>1<em>,</em><sup>0</sup> cannot occur since <em>α</em>1<em>,</em>0<em>,</em><sup>1</sup> 6= 0. Analogous for <em>α</em>0<em>,</em>1<em>,</em><sup>1</sup> = 0 and <em>α</em>1<em>,</em>0<em>,</em><sup>1</sup> = −<em>α</em>0<em>,</em>1<em>,</em>1.</p>

    <p class="text-gray-300">Case:  <span class="math">\\alpha_{0,1,1} \\neq 0</span>  and  <span class="math">\\alpha_{1,1,0} \\neq 0</span> . Let's first consider the case  <span class="math">\\alpha_{1,0,1} \\neq 0</span>  and  <span class="math">\\alpha_{1,1,0} \\neq 0</span> . Here, we prove that this case can never occur. Indeed, the second condition in (19) is satisfied if and only if  <span class="math">\\alpha_{1,0,1} = -\\alpha_{1,1,0}</span> , while the third condition in (19) is satisfied if and only if  <span class="math">\\alpha_{1,0,1} = -\\alpha_{0,1,1}</span> . It follows that  <span class="math">-\\alpha_{1,0,1} = \\alpha_{1,1,0} = \\alpha_{0,1,1}</span> . By replacing it in the first condition in (19), we get</p>

    <div class="my-4 text-center"><span class="math-block">0 = \\alpha_{1,1,0}^2 + \\alpha_{0,1,1}^2 = 2 \\cdot \\alpha_{1,1,0}^2 \\qquad \\to \\qquad \\alpha_{1,1,0} = 0 \\,,</span></div>

    <p class="text-gray-300">which contradicts the assumption of the analyzed case  <span class="math">\\alpha_{1,1,0} \\neq 0</span> .</p>

    <p class="text-gray-300">Case:  <span class="math">\\alpha_{1,1,0} = 0</span>  and/or  <span class="math">\\alpha_{0,1,1} = 0</span> . If  <span class="math">\\alpha_{1,1,0} = 0</span> , then due to the first condition  <span class="math">\\alpha_{1,1,0}^2 + \\alpha_{0,1,1}^2 = 0</span> , it follows that  <span class="math">\\alpha_{0,1,1} = 0</span> . Hence,  <span class="math">\\alpha_{1,1,0} = 0</span>  if and only if  <span class="math">\\alpha_{0,1,1} = 0</span> . Let's consider separately the cases  <span class="math">\\alpha_{0,2,0} \\neq 0</span>  and  <span class="math">\\alpha_{0,2,0} = 0</span> .</p>

    <p class="text-gray-300">SubCase:  <span class="math">\\alpha_{0,2,0} \\neq 0</span> . If  <span class="math">\\alpha_{0,2,0} \\neq 0</span> , we can still set up a collision by working with  <span class="math">x_2 = y_2</span> ,  <span class="math">x_3 = y_3</span> , and  <span class="math">x_4 \\neq y_4</span> . Let  <span class="math">s_4 := x_4 + y_4</span> . In such a case, the collision  <span class="math">\\mathcal{S}_F(\\hat{z},\\hat{z},x_2,x_3,x_4) = \\mathcal{S}_F(\\hat{z},\\hat{z},x_2,x_3,y_4)</span>  occurs if</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} \\alpha_{1,0,1} &amp; 0 &amp; \\alpha_{2,0,0} \\\\ 0 &amp; 0 &amp; \\alpha_{0,2,0} \\\\ 0 &amp; \\alpha_{1,0,1} &amp; \\alpha_{0,0,2} \\end{bmatrix} \\times \\begin{bmatrix} \\hat{z} \\\\ x_2 \\\\ s_4 \\end{bmatrix} = - \\begin{bmatrix} \\alpha_{1,0,0} \\\\ \\alpha_{0,1,0} \\\\ \\alpha_{0,0,1} \\end{bmatrix}.</span></div>

    <p class="text-gray-300">Since the determinant of the l.h.s. matrix is always non-zero (it corresponds to  <span class="math">\\alpha_{1,0,1}^2 \\cdot \\alpha_{0,2,0}</span> , which is non-zero due to the assumption on  <span class="math">\\alpha_{1,0,1} \\neq 0</span>  and  <span class="math">\\alpha_{0,2,0} \\neq 0</span> ), this linear system of equations admits a solution, which corresponds to a collision.</p>

    <p class="text-gray-300">SubCase:  <span class="math">\\alpha_{0,2,0} = 0</span> . If  <span class="math">\\alpha_{0,2,0} = 0</span>  and if  <span class="math">\\alpha_{0,1,0} = 0</span> , the result follows immediately from Theorem 2. Hence, we limit ourselves to consider the case  <span class="math">\\alpha_{0,2,0} = 0</span>  and  <span class="math">\\alpha_{0,1,0} \\neq 0</span> .</p>

    <p class="text-gray-300">W.l.o.g., since  <span class="math">\\alpha_{0,1,0} \\neq 0</span> , we can assume  <span class="math">\\alpha_{0,1,0} = 1</span>  due to the equivalence class proposed in Definition 4. Since  <span class="math">\\alpha_{0,2,0} = \\alpha_{1,1,0} = \\alpha_{0,1,1} = 0</span>  and since  <span class="math">\\alpha_{1,0,1} \\neq 0</span> , the condition  <span class="math">0 = \\alpha^{(2)} = \\alpha_{2,0,0} + \\alpha_{0,0,2} + \\alpha_{1,0,1}</span>  as given in (12) implies that at least one among  <span class="math">\\alpha_{2,0,0}</span>  and  <span class="math">\\alpha_{0,0,2}</span>  is different from zero. W.l.o.g., we assume  <span class="math">\\alpha_{2,0,0} \\neq 0</span> , and we propose a collision by working with  <span class="math">x_2 = y_2</span>  (analogous for  <span class="math">\\alpha_{2,0,0} = 0</span>  and  <span class="math">\\alpha_{0,0,2} \\neq 0</span>  by working with  <span class="math">x_4 = y_4</span> ).</p>

    <p class="text-gray-300">In such a case, the collision  <span class="math">S_F(\\hat{z}, \\hat{z}, x_2, x_3, x_4) = S_F(\\hat{z}, \\hat{z}, x_2, y_3, y_4)</span>  occurs if</p>

    <p class="text-gray-300"><span id="page-27-0"></span> <span class="math-block">\\begin{bmatrix} \\alpha_{1,0,1} &amp; 0 &amp; \\alpha_{0,0,2} &amp; 0\\\\ \\alpha_{1,0,1} &amp; 0 &amp; 0 &amp; \\alpha_{2,0,0}\\\\ 0 &amp; \\alpha_{1,0,1} \\cdot d_4 &amp; 0 &amp; \\alpha_{0,0,2} \\cdot d_4\\\\ \\alpha_{1,0,1} \\cdot d_3 &amp; 0 &amp; \\alpha_{2,0,0} \\cdot d_3 &amp; 0 \\end{bmatrix} \\times \\begin{bmatrix} \\hat{z}\\\\ x_2\\\\ s_3\\\\ s_4 \\end{bmatrix} = -\\begin{bmatrix} \\alpha_{0,0,1}\\\\ \\alpha_{1,0,0}\\\\ d_3 + \\alpha_{0,0,1} \\cdot d_4\\\\ \\alpha_{1,0,0} \\cdot d_3 + d_4 \\end{bmatrix}, \\quad (20)</span></p>

    <p class="text-gray-300">where  <span class="math">d_3 = x_3 - y_3 \\neq 0</span>  and  <span class="math">d_4 = x_4 - y_4 \\neq 0</span> . The determinant of the l.h.s. matrix is equal to</p>

    <p class="text-gray-300"><span class="math-block">2 \\cdot \\alpha_{1,0,1}^2 \\cdot \\alpha_{2,0,0} \\cdot (\\alpha_{0,0,2} - \\alpha_{2,0,0}) \\cdot d_3 \\cdot d_4</span> .</p>

    <p class="text-gray-300">If  <span class="math">\\alpha_{0,0,2} \\neq \\alpha_{2,0,0}</span> , the determinant is different from zero by choosing  <span class="math">d_3, d_4 \\neq 0</span> , and the solution of the system of equations corresponds to a non-trivial collision. Instead, if  <span class="math">\\alpha_{0,0,2} = \\alpha_{2,0,0}</span> , the rows of the l.h.s. matrix satisfy a linear relation with linear coefficients  <span class="math">-d_3, 0, 0, 1</span> , that is,</p>

    <div class="my-4 text-center"><span class="math-block">-d_3 \\cdot \\begin{bmatrix} \\alpha_{1,0,1} \\\\ 0 \\\\ \\alpha_{0,0,2} \\\\ 0 \\end{bmatrix}^T + 0 \\cdot \\begin{bmatrix} \\alpha_{1,0,1} \\\\ 0 \\\\ 0 \\\\ \\alpha_{2,0,0} \\end{bmatrix}^T + 0 \\cdot \\begin{bmatrix} 0 \\\\ \\alpha_{1,0,1} \\cdot d_4 \\\\ 0 \\\\ \\alpha_{0,0,2} \\cdot d_4 \\end{bmatrix}^T + \\begin{bmatrix} \\alpha_{1,0,1} \\cdot d_3 \\\\ 0 \\\\ \\alpha_{2,0,0} \\cdot d_3 \\end{bmatrix}^T = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix}^T.</span></div>

    <p class="text-gray-300">A solution can exist if the r.h.s. vector satisfies the same linear relation, that is, if</p>

    <div class="my-4 text-center"><span class="math-block">0 = -d_3 \\cdot \\alpha_{0,0,1} + \\alpha_{1,0,0} \\cdot d_3 + d_4 \\qquad \\to \\qquad d_4 = d_3 \\cdot (\\alpha_{0,0,1} - \\alpha_{1,0,0}).</span></div>

    <p class="text-gray-300">Given  <span class="math">d_3 \\neq 0</span> ,  <span class="math">d_4</span>  is equal to zero if and only if  <span class="math">\\alpha_{0,0,1} = \\alpha_{1,0,0}</span> . Hence, if  <span class="math">\\alpha_{0,0,2} = \\alpha_{2,0,0}</span>  and  <span class="math">\\alpha_{0,0,1} \\neq \\alpha_{1,0,0}</span>  (and so  <span class="math">d_4 \\neq 0</span> ), the equations are linearly dependent, and the system of equations (20) reduces to</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} 0 &amp; \\alpha_{0,0,2} &amp; 0 \\\\ 0 &amp; 0 &amp; \\alpha_{2,0,0} \\\\ \\alpha_{1,0,1} \\cdot d_4 &amp; 0 &amp; \\alpha_{0,0,2} \\cdot d_4 \\end{bmatrix} \\times \\begin{bmatrix} x_2 \\\\ s_3 \\\\ s_4 \\end{bmatrix} = - \\begin{bmatrix} \\alpha_{0,0,1} - \\alpha_{1,0,1} \\cdot \\hat{z} \\\\ \\alpha_{1,0,0} - \\alpha_{1,0,1} \\cdot \\hat{z} \\\\ d_3 + \\alpha_{0,0,1} \\cdot d_4 \\end{bmatrix}.</span></div>

    <p class="text-gray-300">Since the l.h.s. matrix is invertible (the determinant is equal to  <span class="math">\\alpha_{0,0,2}^2 \\cdot \\alpha_{1,0,1} \\cdot d_4 \\neq 0</span> ), then the system of equations admits a non-trivial solution, which corresponds to a collision.</p>

    <p class="text-gray-300">SubSubCase:  <span class="math">\\alpha_{0,2,0}=0</span> ,  <span class="math">\\alpha_{0,0,2}=\\alpha_{2,0,0}</span> , and  <span class="math">\\alpha_{0,0,1}=\\alpha_{1,0,0}</span> . The only remaining case to analyze is  <span class="math">\\alpha_{0,2,0}=0</span> ,  <span class="math">\\alpha_{0,0,2}=\\alpha_{2,0,0}</span> , and  <span class="math">\\alpha_{0,0,1}=\\alpha_{1,0,0}</span> , for which we propose a collision by working with  <span class="math">\\hat{z}=0</span> ,  <span class="math">x_2\\neq y_2</span> ,  <span class="math">x_3\\neq y_3</span> , and  <span class="math">x_4\\neq y_4</span>  (i.e.,  <span class="math">d_2,d_3,d_4\\neq 0</span> ). By making used of the variables  <span class="math">d_i</span>  and  <span class="math">s_i</span>  as defined in (13), the collision  <span class="math">\\mathcal{S}_F(0,0,x_2,x_3,x_4)=\\mathcal{S}_F(0,0,y_2,y_3,y_4)</span>  occurs if</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{cases} \\alpha_{2,0,0} \\cdot s_2 + \\alpha_{1,0,0} = 0 \\\\ \\alpha_{2,0,0} \\cdot s_3 \\cdot d_3 + d_2 + \\alpha_{1,0,0} \\cdot d_3 = 0 \\\\ \\alpha_{2,0,0}(s_2 \\cdot d_2 + s_4 \\cdot d_4) + \\frac{\\alpha_{1,0,1}}{2}(s_2 \\cdot d_4 + s_4 \\cdot d_2) + \\alpha_{1,0,0} \\cdot (d_2 + d_4) + d_3 = 0 \\\\ \\alpha_{2,0,0} \\cdot s_3 \\cdot d_3 + \\alpha_{1,0,0} \\cdot d_3 + d_4 = 0 \\\\ \\alpha_{2,0,0} \\cdot s_4 + \\alpha_{1,0,0} = 0 \\end{cases}</span></div>

    <p class="text-gray-300">The first and the last equations imply  <span class="math">s_2 = s_4 = -\\frac{\\alpha_{1,0,0}}{\\alpha_{2,0,0}}</span> . The difference between the second and the fourth equation implies  <span class="math">d_2 = d_4</span> . By choosing  <span class="math">s_3 = -\\frac{d_2 + \\alpha_{1,0,0} \\cdot d_3}{\\alpha_{2,0,0} \\cdot d_3}</span> , both the second and the fourth equations are satisfied. The last equation to solve is the third one, which can be re-written as</p>

    <div class="my-4 text-center"><span class="math-block">0 = \\underbrace{(2\\alpha_{2,0,0} + \\alpha_{1,0,1})}_{-\\alpha^{(2)} = 0} \\cdot s_2 \\cdot d_2 + 2\\alpha_{1,0,0} \\cdot d_2 + d_3 = 2\\alpha_{1,0,0} \\cdot d_2 + d_3</span></div>

    <p class="text-gray-300">since  <span class="math">\\alpha^{(2)}=0</span>  – see (12). By choosing  <span class="math">d_3=-2\\alpha_{1,0,0}\\cdot d_2</span>  where  <span class="math">d_2\\neq 0</span> , we finally get a collision for the case  <span class="math">\\alpha_{0,0,2}=\\alpha_{2,0,0}</span>  and  <span class="math">\\alpha_{0,0,1}=\\alpha_{1,0,0}</span>  of the form</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{S}_{F}\\left(0,0,\\frac{x}{2} - \\frac{\\alpha_{1,0,0}}{2\\alpha_{2,0,0}}, -\\alpha_{1,0,0} \\cdot x + \\frac{1 - 2\\alpha_{1,0,0}^{2}}{4\\alpha_{2,0,0} \\cdot \\alpha_{1,0,0}}, \\frac{x}{2} - \\frac{\\alpha_{1,0,0}}{2\\alpha_{2,0,0}}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\mathcal{S}_{F}\\left(0,0,-\\frac{x}{2} - \\frac{\\alpha_{1,0,0}}{2\\alpha_{2,0,0}}, \\alpha_{1,0,0} \\cdot x + \\frac{1 - 2\\alpha_{1,0,0}^{2}}{4\\alpha_{2,0,0} \\cdot \\alpha_{1,0,0}}, -\\frac{x}{2} - \\frac{\\alpha_{1,0,0}}{2\\alpha_{2,0,0}}\\right),</span></div>

    <p class="text-gray-300">where x is an arbitrary value in  <span class="math">\\mathbb{F}_p</span> . We verified the above collision using the computer algebra system Wolfram Mathematica by running the file Lemma5.ma we provide in https://gitlab.com/pis147879/supplemental-material/-/tree/main/proofs.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8"><strong>6.4</strong> Case: <span class="math">\\alpha_{1,0,1} = 0</span></h3>

    <p class="text-gray-300"><span id="page-28-1"></span><strong>Lemma 6.</strong> Let  <span class="math">p \\geq 3</span>  be a prime integer. Let  <span class="math">F : \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  be a function of degree 2 defined as in (7) where  <span class="math">\\alpha_{1,0,1} = 0</span> . The SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  induced by F is <strong>never</strong> a permutation for each  <span class="math">n \\geq 5</span> .</p>

    <p class="text-gray-300">Proof. We prove this result by finding a collision for  <span class="math">S_F</span> . We study separately the case (1st)  <span class="math">\\alpha_{0,1,1}=0</span>  or/and  <span class="math">\\alpha_{1,1,0}=0</span>  from the case (2nd)  <span class="math">\\alpha_{0,1,1},\\alpha_{1,1,0}\\neq 0</span> . The strategy of the proof is analogous to the one proposed for Lemma 5, that is, we look for a collision of the form  <span class="math">S_F(\\hat{z},\\hat{z},x_2,x_3,x_4,\\hat{z},\\ldots,\\hat{z})=S_F(\\hat{z},\\hat{z},y_2,y_3,y_4,\\hat{z},\\ldots,\\hat{z})</span>  for a generic  <span class="math">\\hat{z}\\in\\mathbb{F}_p</span> . As before, we limit ourselves to focus on the case n=5, that is, we present collisions of the form  <span class="math">S_F(\\hat{z},\\hat{z},x_2,x_3,x_4)=S_F(\\hat{z},\\hat{z},y_2,y_3,y_4)</span> .</p>

    <p class="text-gray-300">Case:  <span class="math">\\alpha_{0,1,1} = 0</span>  or/and  <span class="math">\\alpha_{1,1,0} = 0</span> . First of all, if  <span class="math">\\alpha_{1,1,0} = \\alpha_{0,1,1} = 0</span> , then the result follows immediately from Lemma 3. Let's assume that exactly one term among  <span class="math">\\alpha_{1,1,0}</span>  and  <span class="math">\\alpha_{0,1,1}</span>  is different from zero. In this case, we can set up a collision by working with  <span class="math">x_2 = y_2</span> ,  <span class="math">x_4 = y_4</span> , and  <span class="math">x_3 \\neq y_3</span>  (equivalently,  <span class="math">d_2 = d_4 = 0</span>  and  <span class="math">d_3 \\neq 0</span> ), for which the collision  <span class="math">\\mathcal{S}_F(\\hat{z}, \\hat{z}, x_2, x_3, x_4) = \\mathcal{S}_F(\\hat{z}, \\hat{z}, x_2, y_3, x_4)</span>  occurs if</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} \\alpha_{0,0,2} &amp; \\alpha_{0,1,1} &amp; 0 \\\\ \\alpha_{0,2,0} &amp; \\alpha_{1,1,0} &amp; \\alpha_{0,1,1} \\\\ \\alpha_{2,0,0} &amp; 0 &amp; \\alpha_{1,1,0} \\end{bmatrix} \\times \\begin{bmatrix} s_3 \\\\ x_2 \\\\ x_4 \\end{bmatrix} = - \\begin{bmatrix} \\alpha_{0,0,1} \\\\ \\alpha_{0,1,0} \\\\ \\alpha_{1,0,0} \\end{bmatrix} \\,,</span></div>

    <p class="text-gray-300">where  <span class="math">s_3 = x_3 + y_3</span>  as in (13). The determinant of the l.h.s. matrix is</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha_{0,0,2} \\cdot \\alpha_{1,1,0}^2 - \\alpha_{0,1,1} \\cdot \\alpha_{0,2,0} \\cdot \\alpha_{1,1,0} + \\alpha_{2,0,0} \\cdot \\alpha_{0,1,1}^2 = \\begin{cases} \\alpha_{0,0,2} \\cdot \\alpha_{1,1,0}^2 &amp; \\text{if } \\alpha_{1,1,0} \\neq 0 \\text{ and } \\alpha_{0,1,1} = 0 \\\\ \\alpha_{2,0,0} \\cdot \\alpha_{0,1,1}^2 &amp; \\text{if } \\alpha_{1,1,0} = 0 \\text{ and } \\alpha_{0,1,1} \\neq 0 \\end{cases}</span></div>

    <p class="text-gray-300">In the case  <span class="math">\\alpha_{1,1,0} \\neq 0</span>  and  <span class="math">\\alpha_{0,1,1} = 0</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">\\alpha_{0,0,2} \\neq 0</span> , then the matrix is invertible, and the solution corresponds to a collision;</li>

      <li>if  <span class="math">\\alpha_{0,0,2} = 0</span> , then the matrix is not invertible. However, the function F reduces to</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">F(x_0, x_1, x_2) = \\alpha_{2,0,0} \\cdot x_0^2 + \\alpha_{0,2,0} \\cdot x_1^2 + \\alpha_{1,1,0} \\cdot x_0 \\cdot x_1 + \\alpha_{1,0,0} \\cdot x_0 + \\alpha_{0,1,0} \\cdot x_1 + \\alpha_{0,0,1} \\cdot x_2</span></div>

    <div class="my-4 text-center"><span class="math-block">\\equiv \\alpha_{0,0,1} \\cdot x_2 + G(x_0, x_1)</span></div>

    <p class="text-gray-300">for a certain quadratic function  <span class="math">G: \\mathbb{F}_p^2 \\to \\mathbb{F}_p</span> . In such a case, the function  <span class="math">\\mathcal{S}_F</span>  is not invertible, respectively due to the results proposed in Lemma 4 if  <span class="math">\\alpha_{0,0,1} \\neq 0</span> , and in Theorem 2 otherwise (i.e., if  <span class="math">\\alpha_{0,0,1} = 0</span> ).</p>

    <p class="text-gray-300">Analogous for the case  <span class="math">\\alpha_{1,1,0} = 0</span>  and  <span class="math">\\alpha_{0,1,1} \\neq 0</span> .</p>

    <p class="text-gray-300"><strong>Case:</strong>  <span class="math">\\alpha_{0,1,1}, \\alpha_{1,1,0} \\neq \\mathbf{0}</span> . Let  <span class="math">\\alpha&#x27;_{0,1,1} := \\alpha_{0,1,1}/2</span>  and  <span class="math">\\alpha&#x27;_{1,1,0} := \\alpha_{1,1,0}/2</span> . In this case, we set up a collision by working with  <span class="math">x_2 = y_2, x_3 \\neq y_3</span> , and  <span class="math">x_4 \\neq y_4</span>  (equivalently,  <span class="math">d_2 = 0</span>  and  <span class="math">d_3, d_4 \\neq 0</span> ). By making used of the variables  <span class="math">d_i</span>  and  <span class="math">s_i</span>  defined as in (13) for  <span class="math">i \\in \\{3, 4\\}</span> , the collision  <span class="math">\\mathcal{S}_F(\\hat{z}, \\hat{z}, x_2, x_3, x_4) = \\mathcal{S}_F(\\hat{z}, \\hat{z}, x_2, y_3, y_4)</span>  occurs if</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} \\alpha_{0,0,2} &amp; 0 &amp; \\alpha_{0,1,1} &amp; 0 \\\\ 0 &amp; \\alpha_{2,0,0} &amp; 0 &amp; \\alpha_{1,1,0} \\\\ \\alpha_{0,2,0} \\cdot d_3 + \\alpha&#x27;_{0,1,1} \\cdot d_4 &amp; \\alpha_{0,0,2} \\cdot d_4 + \\alpha&#x27;_{0,1,1} \\cdot d_3 &amp; \\alpha_{1,1,0} \\cdot d_3 &amp; 0 \\\\ \\alpha_{2,0,0} \\cdot d_3 + \\alpha&#x27;_{1,1,0} \\cdot d_4 &amp; \\alpha_{0,2,0} \\cdot d_4 + \\alpha&#x27;_{1,1,0} \\cdot d_3 &amp; 0 &amp; \\alpha_{0,1,1} \\cdot d_4 \\end{bmatrix} \\times \\begin{bmatrix} s_3 \\\\ s_4 \\\\ x_2 \\\\ \\hat{z} \\end{bmatrix} = - \\begin{bmatrix} A(0,0,d_3) \\\\ A(d_4,0,0) \\\\ A(0,d_3,d_4) \\\\ A(d_3,d_4,0) \\end{bmatrix},</span></div>

    <p class="text-gray-300">where  <span class="math">A: \\mathbb{F}_p^3 \\to \\mathbb{F}_p</span>  is the linear function defined as  <span class="math">A(z_0, z_1, z_2) = \\alpha_{1,0,0} \\cdot z_0 + \\alpha_{0,1,0} \\cdot z_1 + \\alpha_{0,0,1} \\cdot z_2</span> . The determinant of the l.h.s. matrix is equal to</p>

    <div class="my-4 text-center"><span class="math-block">\\beta \\cdot (\\alpha&#x27;_{1,1,0} \\cdot d_3^2 + \\alpha&#x27;_{0,1,1} \\cdot d_4^2) + \\gamma \\cdot d_3 \\cdot d_4</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\beta &amp;:= \\alpha_{1,1,0} \\cdot \\alpha_{0,1,1} \\cdot \\alpha_{0,2,0} - \\alpha_{1,1,0}^2 \\cdot \\alpha_{0,0,2} - \\alpha_{0,1,1}^2 \\cdot \\alpha_{2,0,0} \\,, \\\\ \\gamma &amp;:= \\alpha_{1,1,0} \\cdot \\alpha_{0,1,1} \\cdot \\alpha_{2,0,0} \\cdot \\alpha_{0,0,2} - \\alpha_{0,1,1}^2 \\cdot \\alpha_{2,0,0} \\cdot \\alpha_{0,2,0} - \\alpha_{1,1,0}^2 \\cdot \\alpha_{0,0,2} \\cdot \\alpha_{0,2,0} \\,. \\end{split}</span></div>

    <p class="text-gray-300">Thus:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">\\beta \\neq 0</span> , then the determinant of the matrix is different from zero by choosing  <span class="math">d_3 \\neq 0</span>  and  <span class="math">d_4 = 0</span>  (or vice-versa);</li>

      <li>if  <span class="math">\\beta = 0</span>  and  <span class="math">\\gamma \\neq 0</span> , then the determinant of the matrix is different from zero by choosing  <span class="math">d_3 \\neq 0</span>  and  <span class="math">d_4 \\neq 0</span> .</li>

    </ul>

    <p class="text-gray-300">In such cases, the solution of the system of equations corresponds to a collision.</p>

    <p class="text-gray-300">By re-using the same approach in the case  <span class="math">x_3 = y_3</span> ,  <span class="math">x_2 \\neq y_2</span> , and  <span class="math">x_4 \\neq y_4</span>  (equivalently,  <span class="math">d_3 = 0</span>  and  <span class="math">d_2, d_4 \\neq 0</span> ), it is possible to set up a collision for the case</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha_{0,0,2} \\cdot \\alpha_{2,0,0} \\cdot (\\alpha_{1,1,0}^2 - \\alpha_{0,1,1}^2) + \\alpha_{1,1,0} \\cdot \\alpha_{0,1,1} \\cdot \\alpha_{0,2,0} \\cdot (\\alpha_{0,0,2} - \\alpha_{2,0,0}) \\neq 0</span></div>

    <p class="text-gray-300">as well (we omit the details, since the computation is analogous to the one just given for the case  <span class="math">x_2 = y_2</span> ,  <span class="math">x_3 \\neq y_3</span> , and  <span class="math">x_4 \\neq y_4</span> ).</p>

    <p class="text-gray-300">In order to finish the proof, the only remaining case in which we have to set up a collision is</p>

    <p class="text-gray-300"><span id="page-30-0"></span> <span class="math-block">\\begin{cases} \\alpha_{1,1,0} \\cdot \\alpha_{0,1,1} \\cdot \\alpha_{0,2,0} - \\alpha_{1,1,0}^2 \\cdot \\alpha_{0,0,2} - \\alpha_{0,1,1}^2 \\cdot \\alpha_{2,0,0} = 0 \\\\ \\alpha_{1,1,0} \\cdot \\alpha_{0,1,1} \\cdot \\alpha_{2,0,0} \\cdot \\alpha_{0,0,2} - \\alpha_{0,1,1}^2 \\cdot \\alpha_{2,0,0} \\cdot \\alpha_{0,2,0} - \\alpha_{1,1,0}^2 \\cdot \\alpha_{0,0,2} \\cdot \\alpha_{0,2,0} = 0 \\\\ \\alpha_{0,0,2} \\cdot \\alpha_{2,0,0} \\cdot (\\alpha_{1,1,0}^2 - \\alpha_{0,1,1}^2) + \\alpha_{1,1,0} \\cdot \\alpha_{0,1,1} \\cdot \\alpha_{0,2,0} \\cdot (\\alpha_{0,0,2} - \\alpha_{2,0,0}) = 0 \\end{cases}</span>  (21)</p>

    <p class="text-gray-300">The sum between the first equation and the second one multiplied by  <span class="math">\\alpha_{0,2,0}</span>  is equal to  <span class="math">\\alpha_{0,2,0}^2 = \\alpha_{0,0,2} \\cdot \\alpha_{2,0,0}</span> . By replacing  <span class="math">\\alpha_{1,1,0} \\cdot \\alpha_{0,1,1} \\cdot \\alpha_{0,2,0}</span>  in the last equation via the first one, we get  <span class="math">(\\alpha_{0,0,2} \\cdot \\alpha_{1,1,0})^2 = (\\alpha_{2,0,0} \\cdot \\alpha_{0,1,1})^2</span> . Due to these considerations, it follows that Equation (21) reduces to</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{cases} \\alpha_{0,0,2} \\cdot \\alpha_{1,1,0} = \\pm \\alpha_{2,0,0} \\cdot \\alpha_{0,1,1} \\\\ \\alpha_{0,2,0}^2 = \\alpha_{0,0,2} \\cdot \\alpha_{2,0,0} \\end{cases}</span></div>

    <p class="text-gray-300">It is not hard to check that this system is satisfied if and only if one of the two following events happens:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1.  <span class="math">\\alpha_{2,0,0} = \\alpha_{0,2,0} = \\alpha_{0,0,2} = 0</span> ; or</li>

      <li>2.  <span class="math">\\varphi^2 = \\pm \\frac{\\alpha_{0,1,1}}{\\alpha_{1,1,0}}</span>  is a quadratic residue, and  <span class="math">\\alpha_{0,0,2} = \\alpha_{2,0,0} \\cdot \\varphi^2</span> ,  <span class="math">\\alpha_{0,2,0} = \\pm \\alpha_{2,0,0} \\cdot \\varphi</span> , where  <span class="math">\\alpha_{2,0,0}, \\alpha_{0,2,0}, \\alpha_{0,0,2} \\neq 0</span> .</li>

    </ul>

    <p class="text-gray-300">SubCase:  <span class="math">\\alpha_{2,0,0} = \\alpha_{0,2,0} = \\alpha_{0,0,2} = 0</span> . Due to  <span class="math">\\alpha^{(2)} = 0</span>  – see (12), we have that  <span class="math">\\alpha_{0,1,1} = -\\alpha_{1,1,0}</span> . We construct a collision by working with  <span class="math">x_2 \\neq y_2</span> ,  <span class="math">x_3 \\neq y_3</span>  and  <span class="math">x_4 = y_4</span>  (equivalently,  <span class="math">d_4 = 0</span>  and  <span class="math">d_2, d_3 \\neq 0</span> ). In such a case, the collision  <span class="math">\\mathcal{S}_F(\\hat{z}, \\hat{z}, x_2, x_3, x_4) = \\mathcal{S}_F(\\hat{z}, \\hat{z}, y_2, y_3, x_4)</span>  occurs if</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} \\alpha_{0,1,1} \\cdot d_2 &amp; 0 &amp; 0 &amp; 0 \\\\ -\\alpha_{0,1,1} \\cdot d_2 &amp; \\frac{\\alpha_{0,1,1}}{2} \\cdot d_3 &amp; \\frac{\\alpha_{0,1,1}}{2} \\cdot d_2 &amp; 0 \\\\ 0 &amp; -\\frac{\\alpha_{0,1,1}}{2} \\cdot d_3 &amp; -\\frac{\\alpha_{0,1,1}}{2} \\cdot d_2 &amp; \\alpha_{0,1,1} \\cdot d_3 \\\\ 0 &amp; 0 &amp; 0 &amp; -\\alpha_{0,1,1} \\cdot d_3 \\end{bmatrix} \\times \\begin{bmatrix} \\hat{z} \\\\ s_2 \\\\ s_3 \\\\ x_4 \\end{bmatrix} = - \\begin{bmatrix} \\alpha_{0,0,1} \\cdot d_2 \\\\ \\alpha_{0,1,0} \\cdot d_2 + \\alpha_{0,0,1} \\cdot d_3 \\\\ \\alpha_{1,0,0} \\cdot d_2 + \\alpha_{0,1,0} \\cdot d_3 \\\\ \\alpha_{1,0,0} \\cdot d_3 \\end{bmatrix}.</span></div>

    <p class="text-gray-300">The determinant of the l.h.s. matrix is equal to zero (since the sum of its rows is equal to zero). Hence, a solution can exist only in the case in which the r.h.s. vector satisfies the same linear condition, that is,</p>

    <div class="my-4 text-center"><span class="math-block">\\underbrace{(\\alpha_{0,0,1} + \\alpha_{0,1,0} + \\alpha_{1,0,0})}_{\\equiv \\alpha^{(1)} \\neq 0} \\cdot (d_2 + d_3) = 0 \\qquad \\to \\qquad d_2 = -d_3,</span></div>

    <p class="text-gray-300">where  <span class="math">\\alpha^{(1)} \\neq 0</span>  due to (12). In the case  <span class="math">d_2 = -d_3 \\neq 0</span> , a solution for the system of equations (hence, a collision) is given by</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{z} = -\\frac{\\alpha_{0,0,1}}{\\alpha_{0,1,1}}, \\qquad x_4 = \\frac{\\alpha_{1,0,0}}{\\alpha_{0,1,1}}, \\qquad s_3 = s_2 - 2 \\cdot \\frac{\\alpha_{0,1,0}}{\\alpha_{0,1,1}},</span></div>

    <p class="text-gray-300">where no condition is imposed on  <span class="math">s_2</span> . It follows that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{S}_F\\left(-\\frac{\\alpha_{0,0,1}}{\\alpha_{0,1,1}}, -\\frac{\\alpha_{0,0,1}}{\\alpha_{0,1,1}}, x, y - \\frac{\\alpha_{0,1,0}}{\\alpha_{0,1,1}}, \\frac{\\alpha_{1,0,0}}{\\alpha_{0,1,1}}\\right) = \\mathcal{S}_F\\left(-\\frac{\\alpha_{0,0,1}}{\\alpha_{0,1,1}}, -\\frac{\\alpha_{0,0,1}}{\\alpha_{0,1,1}}, y, x - \\frac{\\alpha_{0,1,0}}{\\alpha_{0,1,1}}, \\frac{\\alpha_{1,0,0}}{\\alpha_{0,1,1}}\\right),</span></div>

    <p class="text-gray-300">where  <span class="math">x \\in \\mathbb{F}_p \\setminus \\{0\\}</span>  and  <span class="math">y \\in \\mathbb{F}_p</span>  are arbitrary values. We verified the above collision using the computer algebra system Wolfram Mathematica by running the file Lemma6.ma we provide in https://gitlab.com/pis147879/supplemental-material/-/tree/main/proofs.</p>

    <p class="text-gray-300">SubCase:  <span class="math">\\varphi^2 = \\pm \\frac{\\alpha_{0,1,1}}{\\alpha_{1,1,0}}</span>  is a quadratic residue,  <span class="math">\\alpha_{0,0,2} = \\alpha_{2,0,0} \\cdot \\varphi^2 \\neq 0</span> , and  <span class="math">\\alpha_{0,2,0} = \\pm \\alpha_{2,0,0} \\cdot \\varphi \\neq 0</span> . Here we present a collision by working with  <span class="math">\\hat{z} = 0</span> ,  <span class="math">x_2 = y_2</span> ,  <span class="math">x_3 \\neq y_3</span>  and  <span class="math">x_4 = y_4</span>  (equivalently,  <span class="math">d_2 = d_4 = 0</span>  and  <span class="math">d_3 \\neq 0</span> ). In such a case, the collision  <span class="math">\\mathcal{S}_F(0,0,x_2,x_3,x_4) = \\mathcal{S}_F(0,0,x_2,y_3,x_4)</span>  occurs if</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} \\pm \\varphi^2 \\cdot \\alpha_{1,1,0} &amp; \\varphi^2 \\cdot \\alpha_{2,0,0} &amp; 0 \\\\ \\alpha_{1,1,0} &amp; \\pm \\varphi^2 \\cdot \\alpha_{2,0,0} &amp; \\pm \\varphi^2 \\cdot \\alpha_{1,1,0} \\\\ 0 &amp; \\alpha_{2,0,0} &amp; \\alpha_{1,1,0} \\end{bmatrix} \\times \\begin{bmatrix} x_2 \\\\ s_3 \\\\ x_4 \\end{bmatrix} = - \\begin{bmatrix} \\alpha_{0,0,1} \\\\ \\alpha_{0,1,0} \\\\ \\alpha_{1,0,0} \\end{bmatrix},</span></div>

    <p class="text-gray-300">where  <span class="math">s_3 = x_3 + y_3</span> . The determinant of the l.h.s. matrix is</p>

    <div class="my-4 text-center"><span class="math-block">-\\alpha_{1,1,0}^2 \\cdot \\alpha_{2,0,0} \\cdot (1 \\pm \\varphi + \\varphi^2).</span></div>

    <p class="text-gray-300">Since  <span class="math">\\alpha_{1,1,0}</span> ,  <span class="math">\\alpha_{2,0,0} \\neq 0</span> , if  <span class="math">1 \\pm \\varphi + \\varphi^2 \\neq 0</span> , then the determinant is different from zero, and the system admits a solution which corresponds to a collision.</p>

    <p class="text-gray-300">For finishing the proof, we construct a collision for the remaining case  <span class="math">1 \\pm \\varphi + \\varphi^2 = 0</span> . In order to do this, we first prove that  <span class="math">\\varphi^2 = \\pm 1</span> . Indeed, due to the condition  <span class="math">\\alpha^{(2)} = 0</span>  – see (12), we have that</p>

    <div class="my-4 text-center"><span class="math-block">0 = \\alpha^{(2)} = \\alpha_{2,0,0} + \\alpha_{0,2,0} + \\alpha_{0,2,0} + \\alpha_{0,1,1} + \\alpha_{1,1,0}</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\alpha_{2,0,0} \\cdot \\underbrace{(1 \\pm \\varphi + \\varphi^2)}_{=0} + \\alpha_{1,1,0} + \\alpha_{0,1,1} \\longrightarrow \\alpha_{1,1,0} = -\\alpha_{0,1,1},</span></div>

    <p class="text-gray-300">where  <span class="math">\\alpha_{0,0,2}=\\alpha_{2,0,0}\\cdot\\varphi^2</span>  and  <span class="math">\\alpha_{0,2,0}=\\pm\\alpha_{2,0,0}\\cdot\\varphi</span> . Since  <span class="math">\\varphi^2=\\pm\\frac{\\alpha_{0,1,1}}{\\alpha_{1,1,0}}</span> , it follows that</p>

    <div class="my-4 text-center"><span class="math-block">\\varphi^2 = \\pm \\frac{\\alpha_{0,1,1}}{\\alpha_{1,1,0}} = \\pm \\frac{-\\alpha_{1,1,0}}{\\alpha_{1,1,0}} = \\pm 1.</span></div>

    <p class="text-gray-300">By combining  <span class="math">\\varphi^2 = \\pm 1</span>  and  <span class="math">1 \\pm \\varphi + \\varphi^2 = 0</span> , we get the following:</p>

    <p class="text-gray-300">• if  <span class="math">\\varphi^2 = -1</span> :</p>

    <div class="my-4 text-center"><span class="math-block">0 = 1 \\pm \\varphi + \\varphi^2 = 1 \\pm \\varphi - 1 = \\pm \\varphi,</span></div>

    <p class="text-gray-300">that is,  <span class="math">\\varphi^2 = 0</span> , which contradicts  <span class="math">\\varphi^2 = -1</span> ;</p>

    <p class="text-gray-300">• if  <span class="math">\\varphi^2 = 1</span> :</p>

    <div class="my-4 text-center"><span class="math-block">0 = 1 \\pm \\varphi + \\varphi^2 = \\pm \\varphi + 2 \\qquad \\to \\qquad \\varphi = \\pm 2.</span></div>

    <p class="text-gray-300">The condition  <span class="math">\\varphi = \\pm 2</span>  does not contradict  <span class="math">\\varphi^2 = 1</span>  only in the case in which 4 = 1 mod p, that is, p = 3.</p>

    <p class="text-gray-300"><span id="page-32-2"></span><img src="_page_32_Figure_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Figure 1: A sponge hash function instantiated with a permutation  <span class="math">\\mathcal{P}</span> .</p>

    <p class="text-gray-300">Hence, the only remaining case to analyze for concluding the proof is p=3 and  <span class="math">\\varphi=\\pm 1</span> , that is</p>

    <div class="my-4 text-center"><span class="math-block">F(x_0, x_1, x_2) = x_0^2 + x_1^2 + x_2^2 \\pm x_0 \\cdot x_1 \\mp x_1 \\cdot x_2 + \\alpha_{1,0,0} \\cdot x_0 + \\alpha_{0,1,0} \\cdot x_1 + \\alpha_{0,0,1} \\cdot x_2,</span></div>

    <p class="text-gray-300">where the condition  <span class="math">\\alpha_{1,1,0} = -\\alpha_{0,1,1} \\neq 0</span>  implies  <span class="math">\\alpha_{1,1,0} = \\pm 1</span>  and  <span class="math">\\alpha_{0,1,1} = \\mp 1</span>  when working over  <span class="math">\\mathbb{F}_3</span> . Let's focus on the case  <span class="math">\\alpha_{1,1,0} = 1</span>  and  <span class="math">\\alpha_{0,1,1} = -1</span>  (the other case is analogous). In such a case, we construct a collision by working with  <span class="math">x_2 \\neq y_2</span> ,  <span class="math">x_3 \\neq y_3</span>  and  <span class="math">x_4 = y_4</span>  (equivalently,  <span class="math">d_4 = 0</span>  and  <span class="math">d_2, d_3 \\neq 0</span> ). The collision  <span class="math">\\mathcal{S}_F(\\hat{z}, \\hat{z}, x_2, x_3, x_4) = \\mathcal{S}_F(\\hat{z}, \\hat{z}, y_2, y_3, x_4)</span>  occurs if</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} -d_2 &amp; d_2 &amp; 0 &amp; 0 \\\\ d_2 &amp; d_2 + d_3 &amp; d_3 + d_2 &amp; 0 \\\\ 0 &amp; d_2 - d_3 &amp; d_3 - d_2 &amp; -d_3 \\\\ 0 &amp; 0 &amp; d_3 &amp; d_3 \\end{bmatrix} \\times \\begin{bmatrix} \\hat{z} \\\\ s_2 \\\\ s_3 \\\\ x_4 \\end{bmatrix} = - \\begin{bmatrix} \\alpha_{0,0,1} \\cdot d_2 \\\\ \\alpha_{0,1,0} \\cdot d_2 + \\alpha_{0,0,1} \\cdot d_3 \\\\ \\alpha_{1,0,0} \\cdot d_2 + \\alpha_{0,1,0} \\cdot d_3 \\\\ \\alpha_{1,0,0} \\cdot d_3 \\end{bmatrix},</span></div>

    <p class="text-gray-300">where  <span class="math">s_i = x_i + y_i</span>  and  <span class="math">d_i = x_i - y_i</span>  for  <span class="math">i \\in \\{2, 3\\}</span>  as in (13). Similar to before, the determinant of the l.h.s. matrix is zero (since the sum of its rows is equal to zero – remember that we are working over  <span class="math">\\mathbb{F}_3</span> ). Hence, a solution can exist if the r.h.s. vector satisfies the same linear relation, which as before implies  <span class="math">d_3 = -d_2</span> . In the case  <span class="math">d_2 = -d_3 \\neq 0</span> , a solution for the system of equations (hence, a collision) is given by</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{z} = -\\alpha_{0,1,0} + \\alpha_{0,0,1}, \\qquad s_2 = -\\alpha_{0,1,0}, \\qquad s_3 = -x_4 - \\alpha_{1,0,0},</span></div>

    <p class="text-gray-300">where no condition is imposed on  <span class="math">x_4</span> . This concludes the proof.</p>

    <p class="text-gray-300">As a final step, we present Neptune, a sponge hash function [BDPV07,BDPA08] instantiated with the Neptune<sup> <span class="math">\\pi</span> </sup> permutation. (A sponge hash function instantiated by a generic permutation  <span class="math">\\mathcal{P}</span>  is shown in Figure 1.) Neptune<sup> <span class="math">\\pi</span> </sup> resembles the permutation Poseidon<sup> <span class="math">\\pi</span> </sup> proposed in [GKR<sup>+</sup>21]. In the following, after recalling Poseidon and presenting Neptune as its variant, we discuss its design rationale and its security. Next, we compare the multiplicative complexity of Neptune with the one of Poseidon.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">7.1 Poseidon and the Hades Design Strategy</h3>

    <p class="text-gray-300">Poseidon is a sponge hash function over  <span class="math">\\mathbb{F}_p^t</span> . Its internal permutation is based on the Hades design strategy [GLR<sup>+</sup>20], proposed at Eurocrypt 2020. The main feature of Hades schemes is the use of two different non-linear layers, namely, a <em>full</em> one (composed of t</p>

    <p class="text-gray-300"><span id="page-32-3"></span> <span class="math">&lt;sup&gt;^5&lt;/sup&gt;</span> Due to this fact, we decided to call our hash function as Neptune, which is the Roman name of the Greek god Poseidon.</p>

    <p class="text-gray-300">power maps  <span class="math">x \\mapsto x^d</span>  for odd  <span class="math">d \\ge 3</span> ) in the external rounds, and a partial one (composed of a single power map  <span class="math">x \\mapsto x^d</span>  and t-1 identity functions) in the internal rounds. This particular structure allows to provide security against both statistical and algebraic attacks, and at the same time to achieve a low multiplicative complexity. Roughly speaking, the external rounds aim to prevent statistical attacks, while the main goal of the internal partial rounds is to increase the overall degree of the permutation, which is crucial for providing security against algebraic attacks.</p>

    <p class="text-gray-300">Let  <span class="math">p &gt; 2^{63}</span>  be a prime number and let  <span class="math">\\kappa \\in [80, 256]</span>  be the security level. Let  <span class="math">t \\geq 2</span> be such that  <span class="math">p^t \\geq 2^{3 \\cdot \\kappa}</span>  (given t = c + r, the capacity c and the rate r satisfy respectively  <span class="math">p^c \\geq 2^{2 \\cdot \\kappa}</span>  and  <span class="math">p^r \\geq 2^{\\kappa}</span> ). Let  <span class="math">d \\geq 3</span>  be the smallest integer such that  <span class="math">\\gcd(d, p - 1) = 1</span> . The Poseidon permutation  <span class="math">\\mathcal{P}^{\\pi}: \\mathbb{F}_p^t \\to \\mathbb{F}_p^t</span>  is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{P}^{\\pi}(\\cdot) = \\underbrace{\\mathcal{F}^{(7)} \\circ \\cdots \\circ \\mathcal{F}^{(4)}}_{=4 \\text{ rounds}} \\circ \\underbrace{\\mathcal{P}^{(R_P - 1)} \\circ \\cdots \\circ \\mathcal{P}^{(0)}}_{=R_P \\text{ rounds}} \\circ \\underbrace{\\mathcal{F}^{(3)} \\circ \\cdots \\circ \\mathcal{F}^{(0)}}_{=4 \\text{ rounds}}(\\cdot),</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathcal{F}^{(j)} = c^{(F,j)} + M \\times \\mathcal{S}^{(F)}(\\cdot)</span>  and  <span class="math">\\mathcal{P}^{(j)} = c^{(P,j)} + M \\times \\mathcal{S}^{(P)}(\\cdot)</span>  are the round functions, so that  <span class="math">c^{(F,j)}, c^{(P,j)}</span>  are (random) round constants,  <span class="math">M \\in \\mathbb{F}_p^{t \\times t}</span>  is a MDS matrix and  <span class="math">\\mathcal{S}^{(F)}, \\mathcal{S}^{(P)}: \\mathbb{F}_p^t \\to \\mathbb{F}_p^t</span>  are defined as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathcal{S}^{(F)}(x_0,\\ldots,x_{t-1}) = x_0^d \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_1^d\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{t-1}^d, \\quad \\mathcal{S}^{(P)}(x_0,\\ldots,x_{t-1}) = x_0^d \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{t-1}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The number of full rounds is  <span class="math">R_F = 8</span>  and the number of partial rounds is  <span class="math">R_P =</span>  <span class="math">\\lceil 1.125 \\cdot \\lceil \\log_d(2) \\cdot (\\min\\{\\kappa, \\log_2(p)\\} - 8) + \\log_d(t) \\rceil \\rceil.</span></p>

    <p class="text-gray-300">In [BCD<sup>+</sup>20], distinguishers for this reduced-round permutation were presented, which lead to collision attacks on the sponge hash function instantiated with the reduced-round permutation  <span class="math">\\mathcal{P}^{\\pi}</span> . In the same paper, authors also set up preimage attacks on the sponge hash function instantiated with the full-round permutation  <span class="math">\\mathcal{P}^{\\pi}</span>  in the case of a weak MDS matrix M such that  <span class="math">M^2</span>  is a multiple of the identity, and so, for which an invariant subspace trail that covers all the internal rounds with probability 1 exists (see also [KR21]). In [GRS21], Grassi et al. showed how to properly choose the MDS matrix M in order to prevent this (and similar) attack(s).</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">7.2 Neptune</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">\\kappa \\in [80, 256]</span>  be the security level, and let  <span class="math">p &gt; 2^{63}</span>  be a prime number. Let  <span class="math">t = 2t&#x27; \\in</span>  <span class="math">\\{2,4,\\ldots,24\\}</span>  be an even integer. Since Neptune is intended to be used as the internal permutation of a sponge hash function, the parameters  <span class="math">p, \\kappa</span>  and t have to satisfy (1st)  <span class="math">p^c \\geq 2^{2 \\cdot \\kappa}</span>  and (2nd)  <span class="math">p^r \\geq 2^{\\kappa}</span> , where r and c are respectively the rate and the capacity such that t = c + r. About the padding, we suggest to use the same one proposed e.g. in Poseidon: (1st) the message m is padded with 0\\* until the size of  $m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is a multiple of r; (2nd) the inner part is initially instantiated as  </span>IV =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">IV' \\in \\mathbb{F}_p^c$ , where</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is the size of the input message m as an element of  <span class="math">\\mathbb{F}_p^{\\star}</span> , and where  <span class="math">IV&#x27; \\in \\mathbb{F}_p^{c-1}</span>  is a fixed initial value. The Neptune permutation  <span class="math">\\mathcal{N}^{\\pi}: \\mathbb{F}_p^t \\to \\mathbb{F}_p^t</span>  is defined as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{N}^{\\pi}(\\cdot) = \\underbrace{\\mathcal{E}^{(5)} \\circ \\mathcal{E}^{(4)}}_{=2 \\text{ rounds}} \\circ \\underbrace{\\mathcal{I}^{(R_I - 1)} \\circ \\cdots \\circ \\mathcal{I}^{(0)}}_{=R_I \\text{ rounds}} \\circ \\underbrace{\\mathcal{E}^{(3)} \\circ \\cdots \\circ \\mathcal{E}^{(0)}}_{=4 \\text{ rounds}} (M^{(E)} \\times \\cdot),</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{E}^{(j)} = c^{(E,j)} + M^{(E)} \\times \\mathcal{S}^{(E)}(\\cdot) \\,, \\qquad \\text{and} \\qquad \\mathcal{I}^{(j)} = c^{(I,j)} + M^{(I)} \\times \\mathcal{S}^{(I)}(\\cdot) \\,,</span></div>

    <p class="text-gray-300">and where  <span class="math">c^{(E,j)},c^{(I,i)}\\in\\mathbb{F}_{p}^{t}</span>  are (random) round constants.</p>

    <p class="text-gray-300"><span id="page-33-1"></span><sup>&</sup>lt;sup>6</sup>In [GLR<sup>+</sup>20, GKR<sup>+</sup>21], authors use the nomenclature "Full" and "Partial" rounds for referring respectively to the "External" and the "Internal" rounds.</p>

    <p class="text-gray-300"><strong>About the External Rounds</strong>  <span class="math">\\mathcal{E}</span> . Let  <span class="math">\\alpha, \\gamma \\in \\mathbb{F}_p \\setminus \\{0\\}</span>  be arbitrary and fixed (e.g.,  <span class="math">\\alpha = 1</span>  and  <span class="math">\\gamma \\neq 0</span> ). The non-linear  <span class="math">\\mathcal{S}^{(E)} : \\mathbb{F}_p^t \\to \\mathbb{F}_p^t</span>  is defined as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathcal{S}^{(E)}(x_0, x_1, \\dots, x_{t-2}, x_{t-1}) = \\mathcal{S}'(x_0, x_1) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}'(x_2, x_3) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}'(x_{t-2}, x_{t-1}),$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where S' over  <span class="math">\\mathbb{F}_p^2</span>  is defined as  $S'(x_{2i}, x_{2i+1}) = y_{2i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{2i+1}<span class="math">  for each  </span>i \\in \\{0, 1, \\dots, t'-1\\}$  where</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">y_{2i} = \\alpha^2 \\cdot (2x_{2i} + x_{2i+1}) + 3\\alpha \\cdot (x_{2i} - x_{2i+1})^2 + (\\gamma + \\alpha \\cdot (x_{2i} - 2x_{2i+1}) - (x_{2i} - x_{2i+1})^2)^2,</span></div>

    <div class="my-4 text-center"><span class="math-block">y_{2i+1} = \\alpha^2 \\cdot (x_{2i} + 3x_{2i+1}) + 4\\alpha \\cdot (x_{2i} - x_{2i+1})^2 + (\\gamma + \\alpha \\cdot (x_{2i} - 2x_{2i+1}) - (x_{2i} - x_{2i+1})^2)^2.</span></div>

    <p class="text-gray-300">Let  <span class="math">M&#x27;, M&#x27;&#x27; \\in \\mathbb{F}_p^{t&#x27; \\times t&#x27;}</span>  be two MDS matrices such that (1st)  <span class="math">M&#x27; \\neq \\mu \\cdot M&#x27;&#x27;</span>  for each  <span class="math">\\mu \\in \\mathbb{F}_p</span>  and (2nd)  <span class="math">M&#x27;_{i,j} \\neq M&#x27;&#x27;_{i,j}</span>  for each  <span class="math">i, j \\in \\{0, 1, \\dots, t&#x27;-1\\}</span> . The matrix  <span class="math">M^{(E)} \\in \\mathbb{F}_p^{t \\times t}</span>  is defined as</p>

    <div class="my-4 text-center"><span class="math-block">M^{(E)} = \\begin{bmatrix} M_{0,0}&#x27; &amp; 0 &amp; M_{0,1}&#x27; &amp; 0 &amp; \\dots &amp; M_{0,t&#x27;-1}&#x27; &amp; 0 \\\\ 0 &amp; M_{0,0}&#x27;&#x27; &amp; 0 &amp; M_{0,1}&#x27;&#x27; &amp; \\dots &amp; 0 &amp; M_{0,t&#x27;-1}&#x27;&#x27; \\\\ M_{1,0}&#x27; &amp; 0 &amp; M_{1,1}&#x27; &amp; 0 &amp; \\dots &amp; M_{1,t&#x27;-1}&#x27; &amp; 0 \\\\ 0 &amp; M_{1,0}&#x27;&#x27; &amp; 0 &amp; M_{1,1}&#x27;&#x27; &amp; \\dots &amp; 0 &amp; M_{1,t&#x27;-1}&#x27;&#x27; \\\\ \\vdots &amp; &amp; &amp; \\ddots &amp; &amp; \\vdots \\\\ M_{t&#x27;-1,0}&#x27; &amp; 0 &amp; M_{t&#x27;-1,1}&#x27; &amp; 0 &amp; \\dots &amp; M_{t&#x27;-1,t&#x27;-1}&#x27; &amp; 0 \\\\ 0 &amp; M_{t&#x27;-1,0}&#x27;&#x27; &amp; 0 &amp; M_{t&#x27;-1,1}&#x27;&#x27; &amp; \\dots &amp; 0 &amp; M_{t&#x27;-1,t&#x27;-1}&#x27;&#x27; \\end{bmatrix},</span></div>

    <p class="text-gray-300">that is.</p>

    <div class="my-4 text-center"><span class="math-block">M_{i,j}^{(E)} = \\begin{cases} M_{i&#x27;,j&#x27;}&#x27; &amp; \\text{if } (i,j) = (2i&#x27;,2j&#x27;) \\\\ M_{i&#x27;&#x27;,j&#x27;&#x27;}^{&#x27;&#x27;} &amp; \\text{if } (i,j) = (2i^{&#x27;&#x27;}+1,2j^{&#x27;&#x27;}+1) \\;, \\\\ 0 &amp; \\text{otherwise} \\end{cases}</span></div>

    <p class="text-gray-300"><strong>About the Internal Round</strong>  <span class="math">\\mathcal{I}</span> . The internal round  <span class="math">\\mathcal{I}</span>  is defined via a Partial-SPN scheme as in Poseidon. The non-linear layer  <span class="math">\\mathcal{S}^{(I)}: \\mathbb{F}_p^t \\to \\mathbb{F}_p^t</span>  is defined as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$S^{(I)}(x_0, x_1, \\dots, x_{t-2}, x_{t-1}) = x_0^d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{t-2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{t-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where  <span class="math">d \\geq 3</span>  is the <em>smallest</em> integer such that  <span class="math">\\gcd(d, p-1) = 1</span> . The linear layer is defined via an invertible matrix  <span class="math">M^{(I)} \\in \\mathbb{F}_p^{t \\times t}</span>  that must prevent arbitrary-long subspace trails for the Partial-SPN scheme  <span class="math">\\mathcal{I}^{(R_I-1)} \\circ \\cdots \\circ \\mathcal{I}^{(0)}</span> , as explained in [GRS21].</p>

    <p class="text-gray-300">We suggest to make use of a matrix that can be computed via  <span class="math">\\mathcal{O}(t)</span>  affine operations, as</p>

    <div class="my-4 text-center"><span class="math-block">M_{i,j}^{(I)} = \\begin{cases} \\mu_i^{(I)} &amp; \\text{if } i = j \\\\ 1 &amp; \\text{otherwise} \\end{cases},</span></div>

    <p class="text-gray-300">where  <span class="math">\\mu_{i,i}^{(I)} \\in \\mathbb{F}_p \\setminus \\{0\\}</span>  are chosen in order to guarantee the previous requirements.</p>

    <p class="text-gray-300"><strong>Number of Rounds.</strong> The number of rounds are:  <span class="math">R_F = 6</span>  for the external ones (that is, 4 at the beginning and 2 at the end), and</p>

    <div class="my-4 text-center"><span class="math-block">R_I = \\left\\lceil 1.125 \\cdot \\max\\left\\{ \\left\\lceil \\frac{\\min\\{\\kappa, \\log_2(p)\\} - 6}{\\log_2(d)} + 3 + t + \\log_d(t) \\right\\rceil; \\left\\lceil \\frac{\\kappa}{2} - 4 \\cdot t - 2 \\right\\rceil \\right\\} \\right\\rceil</span></div>

    <p class="text-gray-300">for the internal ones (where we add 12.5% of security margin, as in Poseidon).</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">7.3 Design Rationale</h3>

    <p class="text-gray-300">By simple calculation, the number of  <span class="math">\\mathbb{F}_p</span> -multiplications required to evaluate Poseidon is</p>

    <div class="my-4 text-center"><span class="math-block">(\\lfloor \\log_2(d) \\rfloor + \\operatorname{hw}(d) - 1) \\cdot (8 \\cdot t + R_P),</span></div>

    <p class="text-gray-300">that is,  <span class="math">\\mathcal{O}(16 \\cdot t)</span>  for d=3 and  <span class="math">\\mathcal{O}(24 \\cdot t)</span>  for d=5 (where d=3,5 are the two most common values used in ZK protocols). In order to design Neptune, we decided to focus only on the external full rounds, since we noticed that the number of internal partial rounds is almost constant with respect to t. For this reason, we decided not to modify them. Regarding the external rounds and in order to make use of the results proposed in this paper, the goals we tried to achieve were:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. cost of  <span class="math">t \\mathbb{F}_p</span> -multiplications;</li>

      <li>2. be able to guarantee security against statistical attacks via a small number of full external rounds.</li>

    </ul>

    <p class="text-gray-300">As a result, instead of limiting ourselves to consider an uneven distribution of the S-Boxes, we propose two different round functions, one for the internal part and one for the external one. Moreover, we consider an uneven distribution of the external rounds (four at the beginning versus two at the end).</p>

    <p class="text-gray-300"><strong>Concatenation of Independent S-Boxes.</strong> At the current state, we do not know any (non-trivial) quadratic function  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  for which it is possible to set up an invertible function  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  as in Definition 1 for  <span class="math">n \\gg m</span> . For this reason, we were "forced" to set up the non-linear layer of the external rounds as a concatenation of independent quadratic S-Boxes defined over  <span class="math">\\mathbb{F}_p^n</span>  for  <span class="math">n \\in \\{2,3,4\\}</span> .</p>

    <p class="text-gray-300">Based on our results, possible options for  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  based on  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  include:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Lai-Massey constructions, as  <span class="math">F(x_0, x_1) = x_0 + (x_0 x_1)^2</span>  or  <span class="math">F(x_0, x_1, x_2) = x_0 + \\sum_{j=0}^{2} (x_j x_{j+1})^2</span> ;</li>

      <li>if  <span class="math">p = 1 \\mod 3</span> :  <span class="math">F(x_0, x_1, x_2) = x_0 + \\alpha \\cdot (x_0 x_1)^2 + \\beta \\cdot (x_1 x_2)^2 + \\gamma \\cdot (x_2 x_0)^2</span>  as in Proposition 10; otherwise, if  <span class="math">p = 2 \\mod 3</span> :  <span class="math">F(x_0, x_1, x_2) = x_0 + (x_0 + x_1 + x_2) \\cdot (\\alpha \\cdot x_0 + \\beta \\cdot x_1 (\\alpha + \\beta) \\cdot x_2)</span>  as in Proposition 9;</li>

      <li><span class="math">F(x_0, x_1, x_2) = (x_0 x_1)^2 + (x_1 x_2)^2 + \\alpha \\cdot x_0 + \\beta \\cdot (x_0 + x_1 + x_2)</span>  as in Proposition 12.</li>

    </ul>

    <p class="text-gray-300">We decided to discard the second option, since it would force us to consider separately the case  <span class="math">p=1 \\mod 3</span>  from the case  <span class="math">p=2 \\mod 3</span> . Regarding the first and the third option, they all admit invariant subspaces, that is, there exists a subspace  <span class="math">\\mathfrak{X}\\subset\\mathbb{F}_p^m</span>  which is invariant through the non-linear function. E.g.,  <span class="math">\\langle [1,1]^T\\rangle</span>  is invariant for the Lai-Massey one with m=n=2,  <span class="math">\\langle [1,1,0]^T\\rangle, \\langle [1,0,1]^T\\rangle, \\langle [0,1,1]^T\\rangle</span>  (and their linear combinations) are invariant for the Lai-Massey one with m=n=3, while  <span class="math">\\langle [1,1,1,1]^T\\rangle</span>  is invariant for the last function with m=3 and m=4. We opted for the Lai-Massey construction with m=n=2, since it allows to cover a larger range of values of t.</p>

    <p class="text-gray-300">Let  <span class="math">F(x_0, x_1) = \\alpha \\cdot x_0 + (x_0 - x_1)^2</span>  for  <span class="math">\\alpha \\in \\mathbb{F}_p \\setminus \\{0\\}</span> , and let  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^2</span>  be defined as in Definition 1. Due to the presence of the invariant subspace  <span class="math">\\langle [1, 1]^T \\rangle</span> , we do not use  <span class="math">\\mathcal{S}_F</span>  directly, but we consider  <span class="math">\\mathcal{S}&#x27;(x_i, x_{i+1})</span>  defined as</p>

    <p class="text-gray-300"><span id="page-35-1"></span> <span class="math-block">\\mathcal{S}&#x27;(x_i, x_{i+1}) = \\begin{bmatrix} -\\alpha \\cdot \\gamma \\\\ 0 \\end{bmatrix} + \\mathcal{S}_F \\circ \\left( \\begin{bmatrix} \\gamma \\\\ 0 \\end{bmatrix} + \\begin{bmatrix} 2 &amp; 1 \\\\ 1 &amp; 3 \\end{bmatrix} \\times \\mathcal{S}_F(x_i, x_{i+1}) \\right). \\tag{22}</span></p>

    <p class="text-gray-300">The invertible matrix [2,1;1,3] and the vector  <span class="math">[\\gamma;0]</span>  (for  <span class="math">\\gamma \\neq 0</span> ) have been chosen in order to destroy the invariant subspace  <span class="math">\\langle [1,1]^T \\rangle</span> . Note that  <span class="math">\\mathcal{S}&#x27;</span>  over  <span class="math">\\mathbb{F}_p^2</span>  costs  <span class="math">2 \\mathbb{F}_p</span> -multiplications, which implies that  <span class="math">\\mathcal{S}^{(E)}</span>  over  <span class="math">\\mathbb{F}_p^t</span>  costs t  <span class="math">\\mathbb{F}_p</span> -multiplications.</p>

    <p class="text-gray-300"><strong>Low-Degree Inverse.</strong> By considering only the external rounds, a concrete drawback of the quadratic Lai-Massey function regards the fact that its degree is low both in the forward and in the backward direction. For this reason, the partial rounds instantiated with an invertible power map – which has low degree in e.g. the forward direction and high degree in the backward one – play a crucial role in order to stop Meet-in-the-Middle (MitM) attacks. Indeed, we recall that the inverse  <span class="math">x \\mapsto x^{d&#x27;}</span>  of  <span class="math">x \\mapsto x^d</span>  satisfies  <span class="math">(d \\cdot d&#x27; - 1) \\mod (p-1) = 0</span>  (due to Fermat's little theorem  <span class="math">x^p = x \\mod p</span>  for each  <span class="math">x \\in \\mathbb{F}_p \\setminus \\{0\\}</span> ), which implies that d' is of approximately the same order of p (for small values of d).</p>

    <p class="text-gray-300">The Linear Layer  <span class="math">M^{(E)}</span> . The S-Box  <span class="math">\\mathcal{S}&#x27;</span>  over  <span class="math">\\mathbb{F}_p^2</span>  mixes two  <span class="math">\\mathbb{F}_p</span> -words in a non-linear way. Hence, it is not necessary to instantiate the linear layer with a  <span class="math">t \\times t</span>  MDS matrix in order to achieve both full diffusion and a high number of active S-Boxes over two consecutive rounds. Instead, such goal can be achieved by mixing only the first output components of the S-Boxes among them via a MDS matrix M', and independently only the second output components of the S-Boxes among them via a different MDS matrix M''. This is exactly the definition of  <span class="math">M^{(E)}</span> , for which half of the components are equal to zero.</p>

    <p class="text-gray-300">Besides that, in the following we show that  <span class="math">M^{(E)} \\in \\mathbb{F}_p^{t \\times t}</span>  cannot be re-written as a matrix in  <span class="math">\\mathbb{F}_{p^2}^{t&#x27; \\times t&#x27;}</span> . Equivalently, it has degree strictly bigger than one when written as a linear function over  <span class="math">\\mathbb{F}_{p^2}^{t&#x27;}</span> . Based on the classification given in [CGG<sup>+</sup>22, Section 2], the Neptune<sup> <span class="math">\\pi</span> </sup> permutation is a weak-arranged SPN scheme, while the Poseidon<sup> <span class="math">\\pi</span> </sup> permutation is a strong-arranged SPN scheme. This has an impact on the security argument against some structural statistical attacks, as discussed later on.</p>

    <p class="text-gray-300">Initial Matrix Multiplication. With respect to Poseidon, we emphasize that the input of  <span class="math">Neptune^{\\pi}</span>  is multiplied by  <span class="math">M^{(E)}</span>  before the first S-Box layer is applied. This could make a difference in the case of algebraic attacks, since the <em>invertible</em> S-Box layer is defined via the concatenation of independent non-linear functions, as concretely shown in [BBLP22]. Indeed, if no initial diffusion/matrix multiplication takes place, one can potentially ignore the first S-Box layer (by replacing the initial value IV with the corresponding output via the S-Box layer). Once a solution is found at the output of the first S-Box layer, it is sufficient to invert it in order to find the corresponding solution at the input of the permutation and so of the hash function. A similar scenario could occur at the end of the permutation if no full diffusion takes place.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">7.4 Security Analysis</h3>

    <p class="text-gray-300">Due to the similarities between Poseidon and Neptune, we emphasize that (almost) all the attacks work in the same way for the two schemes. This means that we are going to adapt the security analysis of Poseidon to Neptune.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">7.4.1 (Invariant) Subspace Trails for the Internal Rounds</h3>

    <p class="text-gray-300">As already pointed out in [BCD<sup>+</sup>20,KR21], there exist several subspaces of  <span class="math">\\mathbb{F}_p^t</span>  that are invariant through the internal rounds of Poseidon and so of Neptune. The matrix  <span class="math">M^{(I)}</span>  plays a crucial role in order to destroy them.</p>

    <p class="text-gray-300"><strong>Definition 6</strong> ((Invariant) Subspace Trail [LAAZ11,LMR15,GRR16]). Let  <span class="math">(\\mathfrak{U}_0,\\ldots,\\mathfrak{U}_l)</span>  denote a set of l+1 subspaces of  <span class="math">\\mathbb{F}_p^t</span>  with  <span class="math">\\dim(\\mathfrak{U}_i) \\leq \\dim(\\mathfrak{U}_{i+1})</span> .  <span class="math">(\\mathfrak{U}_0,\\ldots,\\mathfrak{U}_l)</span>  is a subspace trail of length l with respect to the function  <span class="math">\\mathcal{R}</span>  defined over  <span class="math">\\mathbb{F}_p^t</span>  if for each  <span class="math">i \\in \\{0,\\ldots,l\\}</span>  and for each  <span class="math">\\alpha_i \\in \\mathbb{F}_p^t</span> , there exists  <span class="math">\\alpha_{i+1} \\in \\mathbb{F}_p^t</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}(\\mathfrak{U}_i + \\alpha_i) := \\{ \\mathcal{R}(x) \\mid x \\in \\mathfrak{U}_i + \\alpha_i \\} \\subseteq \\mathfrak{U}_{i+1} + \\alpha_{i+1} .</span></div>

    <p class="text-gray-300">If  <span class="math">\\mathfrak{U}_i = \\mathfrak{U}_j</span>  for each  <span class="math">i, j = 0, \\ldots, l</span> , the trail is called an <em>invariant subspace trail</em>.</p>

    <p class="text-gray-300">Following Poseidon, for each  <span class="math">i \\geq 0</span> , let's define the subspace  <span class="math">\\mathfrak{X}_i \\subseteq \\mathbb{F}_p^t</span>  as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathfrak{X}_i := \\left\\{ x \\in \\mathbb{F}_p^t \\mid \\forall j \\leq i : \\quad \\left( (M^{(I)})^j \\times x \\right)_0 \\in \\mathbb{F}_p \\right\\} \\,.</span></div>

    <p class="text-gray-300">As shown in [GRS21, GSW<sup>+</sup>21], the matrix  <span class="math">M^{(I)}</span>  must be chosen in order to guarantee that no subspace  <span class="math">\\mathfrak{X}_i</span>  is invariant for an arbitrary number of internal rounds, and more generally, that no subspace trail can cover any arbitrary number of internal rounds. We suggest to make used the tool presented in [GRS21] in order to properly choose the matrix  <span class="math">M^{(I)}</span>  for this goal. This implies that no more than t-1 internal rounds can be covered without activating any S-Box  <span class="math">x\\mapsto x^d</span> .</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">7.4.2 Statistical Attacks</h4>

    <p class="text-gray-300">The external rounds aim to provide security against statistical attacks. Working as in HadesMiMC or as in Poseidon (see [GLR<sup>+</sup>20, Section 4.2] for details), the idea is that the permutation composed of the external rounds only (that is, with the internal rounds replaced by an invertible linear layer) resists statistical attacks. Here we focus on (truncated) differential and rebound attacks. As in Poseidon, the security against these attacks implies the security against other statistical attacks, including the linear one [Mat93], impossible differential [Knu98, BBS99], integral one [DKR97], zero-correlation linear one [BR11, BR14], and so on.</p>

    <p class="text-gray-300"><strong>Differential Attacks.</strong> Given pairs of inputs with some fixed input differences, differential cryptanalysis [BS93] considers the probability distribution of the corresponding output differences produced by the cryptographic primitive. Let  <span class="math">\\delta, \\Delta \\in \\mathbb{F}_p^n</span>  be respectively the input and the output differences through a permutation  <span class="math">\\mathcal{P}</span>  over  <span class="math">\\mathbb{F}_p^n</span> . The differential probability (DP) of having a certain output difference  <span class="math">\\Delta</span>  given a particular input difference  <span class="math">\\delta</span>  is equal to</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\operatorname{Prob}_{\\mathcal{P}}(\\delta \\to \\Delta) = \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x \\in \\mathbb{F}_p^n \\mid \\mathcal{P}(x+\\delta) - \\mathcal{P}(x) = \\Delta\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{p^n}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the case of iterated schemes, a cryptanalyst searches for ordered sequences of differences over any number of rounds that are called differential characteristics/trails. Assuming the independence of the rounds, the DP of a differential trail is the product of the DPs of its one-round differences.</p>

    <p class="text-gray-300"><strong>Definition 7.</strong> Let  <span class="math">\\mathcal{P}</span>  be a permutation over  <span class="math">\\mathbb{F}_{p^n} \\equiv \\mathbb{F}_p^n</span> . Its maximum differential probability is defined as  <span class="math">\\mathrm{DP}_{\\mathrm{max}} = \\max_{\\delta, \\Delta \\in \\mathbb{F}_p^n \\setminus \\{0\\}} \\mathrm{Prob}_{\\mathcal{P}}(\\delta \\to \\Delta)</span> .</p>

    <p class="text-gray-300">As it is well known, the maximum differential probability of the function  <span class="math">x \\mapsto x^d</span>  is (d-1)/p. Regarding the function  <span class="math">\\mathcal{S}&#x27;</span> , we prove in App. C.1 the following result:</p>

    <p class="text-gray-300"><strong>Lemma 7.</strong> Let  <span class="math">p \\geq 3</span> , and let  <span class="math">S&#x27; : \\mathbb{F}_p^2 \\to \\mathbb{F}_p^2</span>  be defined as in Definition 22. Let  <span class="math">\\delta \\equiv (\\delta_0, \\delta_1) \\in \\mathbb{F}_p^2 \\setminus \\{(0,0)\\}</span>  and  <span class="math">\\Delta \\equiv (\\Delta_0, \\Delta_1) \\in \\mathbb{F}_p^2 \\setminus \\{(0,0)\\}</span>  be respectively the input and the output differences. Then:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x \\in \\mathbb{F}_p^2 \\mid \\mathcal{S}'(x+\\delta) - \\mathcal{S}'(x) = \\Delta\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{p^2} = \\begin{cases} p^{-2} & \\textit{if } \\delta_0 \\neq \\delta_1 \\textit{ and } \\Delta_0 \\neq \\Delta_1 \\\\ p^{-1} & \\textit{if } \\delta_0 = \\delta_1 \\textit{ or } \\Delta_0 = \\Delta_1 \\\\ 0 & \\textit{if } \\delta_0 = \\delta_1 \\textit{ and } \\Delta_0 = \\Delta_1 \\end{cases}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In other words, its maximum differential probability is  <span class="math">p^{-1}</span> .</p>

    <p class="text-gray-300">Working over two consecutive rounds, the minimum number of active S-Boxes is t'+1, due to the fact that (1st) both M' and M'' are MDS matrices (with branch number equal to t'+1=t/2+1) and (2nd) they are "independent", in the sense that they work over</p>

    <p class="text-gray-300">independent t'  <span class="math">\\mathbb{F}_p</span> -words. This means that the overall probability of each differential trail over two consecutive rounds per three times is at most</p>

    <div class="my-4 text-center"><span class="math-block">p^{-3(t&#x27;+1)} = p^{-3t/2-3} \\le p^{-3} \\cdot 2^{-9\\kappa/2} \\ll 2^{-4\\kappa}</span></div>

    <p class="text-gray-300">since t=2t' and  <span class="math">p^t=p^c\\cdot p^r\\geq 2^{3\\kappa}</span> . As a result, when targeting a security level of  <span class="math">\\kappa</span>  bits, two consecutive rounds per three times are sufficient for preventing classical differential attacks. We point out that by considering the internal rounds as well (as suggested in e.g. [KR21]), the probability of each differential trail is even smaller, more precisely, it is at most  <span class="math">p^{-3(t&#x27;+1)}\\cdot \\left(\\frac{d-1}{p}\\right)^{\\lfloor R_I/t\\rfloor}</span> , where  <span class="math">\\lfloor \\frac{R_I}{t}\\rfloor\\geq 1</span>  since at least one S-Box  <span class="math">x\\mapsto x^d</span>  is active every t internal rounds.</p>

    <p class="text-gray-300">Truncated Differential and Rebound Attacks. Truncated differential attacks [Knu94] are a variant of the classical differential one in which the attacker specifies only part of the difference between pairs of texts. In the particular case of an hash function, truncated differentials can be exploited in order to set up rebound attacks [MRST09]. The goal of this attack is to find two (input, output) pairs such that the two inputs satisfy a certain (truncated) input difference, and the corresponding outputs satisfy a certain (truncated) output difference.</p>

    <p class="text-gray-300">Due to the choice of the matrix  <span class="math">M^{(E)}</span>  and working as in Poseidon (see [GKR<sup>+</sup>21, Section 5.5.1] for details), no truncated differential (equivalently, subspace trail) with probability 1 can cover more than a single round. In particular, while the S-Box  <span class="math">\\mathcal{S}&#x27;</span>  is defined over  <span class="math">\\mathbb{F}_{p^2} \\equiv \\mathbb{F}_p^2</span> , we point out that the matrix  <span class="math">M^{(E)}</span>  does not admit an equivalent representation over  <span class="math">\\mathbb{F}_{p^2}^{t&#x27;\\times t&#x27;}</span> . Indeed, consider the field  <span class="math">\\mathbb{F}_{p^2} = \\mathrm{GF}(p)[x]/P(x)</span> , where P is an irreducible polynomial of the form  <span class="math">P(x) = x^2 - \\eta</span>  where  <span class="math">L_p(\\eta) = -1</span> . The product of two elements  <span class="math">a \\cdot x + b</span>  and  <span class="math">c \\cdot x + d</span>  is given by</p>

    <div class="my-4 text-center"><span class="math-block">(a \\cdot x + b) \\cdot (c \\cdot x + d) = ac \\cdot x^2 + (ad + bc) \\cdot x + bd \\equiv (ad + bc) \\cdot x + (bd + \\eta \\cdot ac),</span></div>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span id="page-38-1"></span> <span class="math-block">\\begin{bmatrix} ad + bc \\\\ bd + \\eta \\cdot ac \\end{bmatrix} = \\begin{bmatrix} b &amp; a \\\\ \\eta \\cdot a &amp; b \\end{bmatrix} \\times \\begin{bmatrix} c \\\\ d \\end{bmatrix}. \\tag{23}</span></p>

    <p class="text-gray-300">Hence, each  <span class="math">2 \\times 2</span>  sub-matrix  <span class="math">[M&#x27;_{i,j}, 0; 0, M&#x27;&#x27;_{i,j}]</span>  of  <span class="math">M^{(E)}</span>  is of the form (23) if and only if  <span class="math">M&#x27;_{i,j} = M&#x27;&#x27;_{i,j}</span> , which never holds due to the definition of M', M''.</p>

    <p class="text-gray-300">Due to these facts and working as in Poseidon (for which both the S-Boxes and the matrix multiplications are defined over the same field  <span class="math">\\mathbb{F}_p</span> ), we conjecture that six external rounds are sufficient for preventing rebound attacks.</p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">7.4.3 Algebraic Attacks</h3>

    <p class="text-gray-300">Interpolation Attacks. The interpolation attack [JK97] aims to construct an interpolation polynomial that describes the function. Such polynomial can be used in order to set up a distinguisher and/or an attack on the symmetric scheme. The attack does not work if the number of unknown monomials is sufficiently large (e.g., larger than the data available for the attack). In the MitM scenario, the attacker constructs two polynomials, one that involves the input(s) and one that involve the output(s), that must match in the middle.</p>

    <p class="text-gray-300">Due to the presence of the map  <span class="math">x \\mapsto x^d</span>  in the internal rounds, the final two full rounds combined with three internal rounds ensure maximum degree in the backward direction (remember that  <span class="math">1/d \\equiv d&#x27;</span>  such that  <span class="math">(d&#x27; \\cdot d - 1) \\mod (p - 1) = 0</span> , so d' is of the same order of p). Working as in Poseidon (see [GKR<sup>+</sup>21, Section 5.5.2] for details) and in order to guarantee security against the interpolation attack, the number of internal rounds  <span class="math">R_I</span></p>

    <p class="text-gray-300">must satisfy</p>

    <div class="my-4 text-center"><span class="math-block">4^3 \\cdot d^{R_I - 3} \\ge \\min\\{p, 2^{\\kappa}\\} \\longrightarrow R_I \\ge 3 + \\log_d(2) \\cdot \\left(\\min\\{\\kappa, \\log_2(p)\\} - 6\\right),</span></div>

    <p class="text-gray-300">where (1st) the two final rounds and 3 internal rounds are necessary for reaching maximum degree in the backward direction and (2nd) the first round is not taken into account, since no full diffusion is achieved. Finally, we add t internal rounds due to the possibility to cover them with an invariant subspace trails (which would imply no degree growth), and  <span class="math">\\log_d(t)</span>  additional internal rounds in order to ensure that the polynomial is dense.</p>

    <p class="text-gray-300">Security against interpolation attack also implies security against (i) higher-order differential attack [Lai94, Knu94], due to the results presented in [BCD <span class="math">^+</span> 20, Proposition 1], and (ii) cube attacks [DS09, AP11].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Factorization and Gröbner Basis Attacks. Polynomial factorization can be used to solve a single univariate equation F(x)=0 for a polynomial F over  <span class="math">\\mathbb{F}_p</span> . E.g., in the case  <span class="math">r\\geq 1</span> , factorization can be used to find a pre-image of  <span class="math">h\\in \\mathbb{F}_p</span> , by solving  $F(x)=\\left[\\widehat{\\mathcal{N}}(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{v}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{IV})\\right]_0-h=0<span class="math">  for a fixed  </span>\\hat{v}\\in \\mathbb{F}_p^{r-1}<span class="math"> , where  </span>\\mathrm{IV}\\in \\mathbb{F}_p^c<span class="math">  is the initial value that instantiates the inner part. In such a case, it is actually not necessary to find the full factorization of the polynomial, since one root is sufficient for setting up the attack. The cost of finding a root is proportional to the degree  </span>\\Delta$  of the polynomial F, more precisely</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Delta \\cdot (\\log_2(\\Delta))^2 \\cdot (\\log_2(\\Delta) + \\log_2(p)) \\cdot (1 + 64 \\cdot \\log_2(\\log_2(\\Delta)))</span></div>

    <p class="text-gray-300">as shown in [vzGG13]. It is easy to check that security against interpolation attack implies security against this attack as well.</p>

    <p class="text-gray-300">Gröbner basis reduction [Buc76] generalizes factorization, and it allows to solve a system of non-linear equations that describe the function. As we explain in App. C.2, the cost of such an attack depends both on the number and on the degree of the equations, on the number of variables, but also on the fact that the equations to solve are dense or not. In there, we consider two possible approaches for setting up the system of equations that describes Neptune, that is,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. working on the relation between the input and the output of the entire permutation;</li>

      <li>2. working at round level.</li>

    </ul>

    <p class="text-gray-300">In the first case, we show that the number of rounds for preventing the interpolation attack is sufficient to prevent this attack as well. In the second case, assuming  <span class="math">R_F = 6</span> , we show that the attack is prevented if</p>

    <p class="text-gray-300"><span class="math-block">R_I \\ge \\left\\lceil \\frac{\\kappa}{2} - 4 \\cdot t - 2 \\right\\rceil</span> .</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">7.5 Multiplicative Complexity: Poseidon versus Neptune</h3>

    <p class="text-gray-300">With these results in mind, we finally compare the multiplicative complexity between Poseidon and Neptune. By simple calculation, the number of  <span class="math">\\mathbb{F}_p</span> -multiplications required to evaluate them are:</p>

    <p class="text-gray-300">NEPTUNE: <span class="math-block">(5 + \\lfloor \\log_2(d) \\rfloor + \\operatorname{hw}(d)) \\cdot t + (\\lfloor \\log_2(d) \\rfloor + \\operatorname{hw}(d) - 1) \\cdot (R_I - t),</span></p>

    <p class="text-gray-300">POSEIDON:  <span class="math">8 \\cdot (\\lfloor \\log_2(d) \\rfloor + \\operatorname{hw}(d) - 1) \\cdot t + (\\lfloor \\log_2(d) \\rfloor + \\operatorname{hw}(d) - 1) \\cdot R_P,</span></p>

    <p class="text-gray-300">where  <span class="math">(R_I - t) \\approx R_P</span>  is almost constant with respect to t. In the case of large  <span class="math">t \\gg 1</span>  and for d = 3, Neptune requires  <span class="math">\\mathcal{O}(8 \\cdot t)</span>   <span class="math">\\mathbb{F}_p</span> -multiplications versus  <span class="math">\\mathcal{O}(16 \\cdot t)</span>   <span class="math">\\mathbb{F}_p</span> -multiplications required by Poseidon. Similarly, in the case of large  <span class="math">t \\gg 1</span>  and for d = 5, Neptune requires  <span class="math">\\mathcal{O}(9 \\cdot t)</span>   <span class="math">\\mathbb{F}_p</span> -multiplications versus  <span class="math">\\mathcal{O}(24 \\cdot t)</span>   <span class="math">\\mathbb{F}_p</span> -multiplications required by Poseidon.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">R_F</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">R_P \\&amp; R_I</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Multiplicative Complexity</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Poseidon <span class="math">(d=3)</span></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">87</td>

            <td class="px-3 py-2 border-b border-gray-700">238 (+ 10.2 %)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Neptune <span class="math">(d=3)</span></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Poseidon <span class="math">(d=3)</span></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">88</td>

            <td class="px-3 py-2 border-b border-gray-700">304 (+ 21.6 %)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Neptune <span class="math">(d=3)</span></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">101</td>

            <td class="px-3 py-2 border-b border-gray-700">250</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Poseidon <span class="math">(d=3)</span></td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">88</td>

            <td class="px-3 py-2 border-b border-gray-700">368 (+ 29.6 %)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Neptune <span class="math">(d=3)</span></td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">106</td>

            <td class="px-3 py-2 border-b border-gray-700">284</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Poseidon <span class="math">(d=3)</span></td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">89</td>

            <td class="px-3 py-2 border-b border-gray-700">434 (+ 36.5 %)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Neptune <span class="math">(d=3)</span></td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">111</td>

            <td class="px-3 py-2 border-b border-gray-700">318</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Comparison between Poseidon and Neptune – both instantiated with d=3 – for the case  <span class="math">p\\approx 2^{256},\\ \\kappa=128,</span>  and several values of  <span class="math">t\\in\\{4,8,12,16\\}.</span></p>

    <p class="text-gray-300"><span id="page-40-0"></span>Table 2: Comparison between Poseidon and Neptune – both instantiated with d=5 – for the case  <span class="math">p\\approx 2^{256}</span> ,  <span class="math">\\kappa=128</span> , and several values of  <span class="math">t\\in\\{4,8,12,16\\}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">R_F</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">R_P \\&amp; R_I</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Multiplicative Complexity</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Poseidon <span class="math">(d=5)</span></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">276 (+ 21.0 %)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Neptune <span class="math">(d=5)</span></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">68</td>

            <td class="px-3 py-2 border-b border-gray-700">228</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Poseidon <span class="math">(d=5)</span></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">372 (+ 40.1 %)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Neptune <span class="math">(d=5)</span></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">72</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Poseidon <span class="math">(d=5)</span></td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">61</td>

            <td class="px-3 py-2 border-b border-gray-700">471 (+ 53.9 %)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Neptune <span class="math">(d=5)</span></td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">78</td>

            <td class="px-3 py-2 border-b border-gray-700">306</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Poseidon <span class="math">(d=5)</span></td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">61</td>

            <td class="px-3 py-2 border-b border-gray-700">567 (+ 64.3 %)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Neptune <span class="math">(d=5)</span></td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">83</td>

            <td class="px-3 py-2 border-b border-gray-700">345</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">More concretely, a comparison between the two schemes for small values of t is proposed in Table 2 for the case  <span class="math">p \\approx 2^{256}</span> . As it is possible to observe, Neptune has always a smaller multiplicative complexity with respect to Poseidon.</p>

    <p class="text-gray-300">Besides that, NEPTUNE has several advantages with respect to Poseidon from the plain performance point of view:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the matrix multiplication of each external round of Neptune costs  <span class="math">t^2/2</span>  multiplications with constants  <span class="math">versus\\ t^2</span>  multiplications with constants in the case of Poseidon (besides the fact that Neptune has two external/full rounds less than Poseidon);</li>

      <li>in Poseidon, the same matrix M is used for the full/external rounds and for the partial/internal ones. Since such matrix must prevent arbitrary-long subspace trails with probability 1 for the partial/internal rounds, it cannot be instantiated with, e.g., a circulant matrix. Vice-versa, the MDS matrices M', M'' in the external rounds of Neptune do not have to satisfy such requirement. Hence, they can be instantiated with e.g.  <span class="math">\\operatorname{circ}(2,1,1)</span>  or  <span class="math">\\operatorname{circ}(3,2,1,1)</span>  for  <span class="math">t&#x27; \\in \\{3,4\\}</span>  respectively;</li>

      <li>both Neptune and Poseidon admit an equivalent representation in which the matrix multiplication of each internal/partial round costs  <span class="math">2 \\cdot t</span>  multiplications with constants (for more details, we refer to [GLR<sup>+</sup>19, GLR<sup>+</sup>20, App. C]). However, in such representation, the matrix of the internal/partial round is not fixed, that is, changes at every round. Without using such equivalent representation, the matrix multiplication of each internal round of Neptune can cost only t multiplications with constants, besides being fixed.</li>

    </ul>

    <p class="text-gray-300">A concrete implementation of Neptune and Poseidon for zk-SNARK has been recently proposed in  <span class="math">[GHR^+22]</span> . In there, authors showed that Neptune outperforms Poseidon both from the point of view of the number of R1CS constraints, and from the</p>

    <p class="text-gray-300">point of view of the plain performance, as expected. We refer to  <span class="math">[GHR^+22, Table\\ 1-2\\ in\\ Section\\ 7.5]</span>  for more details.</p>

    <p class="text-gray-300">In this paper, we started an analysis regarding the possibility to construct invertible SI-lifting  <span class="math">S_F</span>  via a local map F. We proved that, given any quadratic function  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  for  <span class="math">m \\in \\{2,3\\}</span> , the corresponding function  <span class="math">S_F</span>  defined over  <span class="math">\\mathbb{F}_p^n</span>  as in Definition 1 is not invertible for  <span class="math">n \\geq 3</span>  and  <span class="math">n \\geq 5</span>  respectively. Based on this, in the following we formulate and propose several interesting open problems for future research.</p>

    <p class="text-gray-300"><strong>Open Conjectures.</strong> First of all, we expect that a similar scenario occurs for bigger values of m. More formally:</p>

    <p class="text-gray-300"><span id="page-41-1"></span><strong>Conjecture 1.</strong> Let  <span class="math">p \\geq 3</span>  be a prime integer, and let  <span class="math">1 \\leq m \\leq n</span> . For each m, there exists a <strong>finite</strong> integer  <span class="math">n_{max}(m) \\geq m+1</span>  such that given any quadratic function  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span> , the SI-lifting  <span class="math">S_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  induced by F is <strong>not</strong> invertible for any  <span class="math">n \\geq n_{max}(m)</span> .</p>

    <p class="text-gray-300">E.g., if m=1, then  <span class="math">n_{\\max}=1</span> ; if m=2, then  <span class="math">n_{\\max}=3</span> ; if m=3, then  <span class="math">n_{\\max}=5</span> . The lower bound  <span class="math">n_{\\max}(m)\\geq m+1</span>  for each  <span class="math">m\\geq 2</span>  is based on the result proposed in Section 3, where the Lai-Massey functions defined over  <span class="math">\\mathbb{F}_p^m</span>  via a quadratic function  <span class="math">F:\\mathbb{F}_p^m\\to\\mathbb{F}_p</span>  are invertible.</p>

    <p class="text-gray-300">If this first conjecture is true, it would be interesting to analyze how fast  <span class="math">n_{\\text{max}}(m)</span>  grows. The current results for  <span class="math">m \\in \\{1, 2, 3\\}</span>  suggest that</p>

    <div class="my-4 text-center"><span class="math-block">n_{\\max}(m) = 2 \\cdot m - 1.</span></div>

    <p class="text-gray-300">Such a result is not in contrast with Corollary 2, or with other results proposed in the paper. Indeed, by applying Corollary 2 on a generic m, we can construct an invertible function  <span class="math">S_F</span>  over  <span class="math">\\mathbb{F}_p^{2\\cdot (m-1)}</span>  via a quadratic function  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  (e.g.,  <span class="math">F(x_0, x_1, \\dots, x_{m-1}) = x_0 + (x_0 - x_{m-1})^2</span> ). Such a result is not in conflict with  <span class="math">n_{\\max}(m) = 2 \\cdot m - 1</span>  just given.</p>

    <p class="text-gray-300">Conjecture 2. Let  <span class="math">n_{max}(m)</span>  be defined as in Conjecture 1. Then,  <span class="math">n_{max}(m) = 2 \\cdot m - 1</span> .</p>

    <p class="text-gray-300">If this second conjecture " <span class="math">n_{max}(m) = 2 \\cdot m - 1</span> " is true, this implies that given a local quadratic function  <span class="math">F : \\mathbb{F}_p^m \\to \\mathbb{F}_p</span> , it is not possible to set up an invertible function  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  defined as in Definition 1 for  <span class="math">n \\gg m</span> .</p>

    <p class="text-gray-300">In order to prove the conjectures, it could be useful to exploit the following matrix representation of the problem. As we have already seen in (7), any function  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  can be re-written in a matrix form as  <span class="math">F(x_0, x_1, \\ldots, x_{m-1}) = \\bar{x}^T \\times A \\times \\bar{x}</span> , where  <span class="math">\\bar{x} = (x_0, x_1, \\ldots, x_{m-1}, 1) \\in \\mathbb{F}_p^{m+1}</span> , and where  <span class="math">A \\in \\mathbb{F}_p^{(m+1)\\times(m+1)}</span>  is the symmetric matrix given in there. A possible way of proving the previous conjectures would be to find collisions  <span class="math">\\mathcal{S}_F(x_0, x_1, \\ldots, x_{n-1}) = \\mathcal{S}_F(x_0&#x27;, x_1&#x27;, \\ldots, x_{n-1}&#x27;)</span> . In such a case, for each  <span class="math">i \\in \\{0, 1, \\ldots, n-1\\}</span> , the condition  <span class="math">F(x_i, x_{i+1}, \\ldots, x_{i+m-1}) = F(x_i&#x27;, x_{i+1}&#x27;, \\ldots, x_{i+m-1}&#x27;)</span>  corresponds to</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} x_i &amp; \\dots &amp; x_{i+m-1} &amp; 1 &amp; x_i&#x27; &amp; \\dots &amp; x_{i+m-1}&#x27; &amp; 1 \\end{bmatrix} \\times \\underbrace{ \\begin{bmatrix} A &amp; 0^{(m+1)\\times(m+1)} \\\\ 0^{(m+1)\\times(m+1)} &amp; -A \\end{bmatrix}}_{\\equiv B \\in \\mathbb{F}_p^{(2m+2)\\times(2m+2)}} \\times \\begin{bmatrix} x_i \\\\ \\vdots \\\\ x_{i+m-1} \\\\ 1 \\\\ \\vdots \\\\ x_{i+m-1}&#x27; \\\\ 1 \\end{bmatrix} = 0 \\,,</span></div>

    <p class="text-gray-300">where  <span class="math">0^{(m+1)\\times(m+1)} \\in \\mathbb{F}_p^{(m+1)\\times(m+1)}</span>  is the null matrix. Hence, it could be potentially possible to find collisions by exploiting the details of the symmetric matrix B, which is independent of the index i.</p>

    <p class="text-gray-300">Constructing Invertible Non-Linear Functions. If the previous conjectures turn out to be true, the problem to construct invertible non-linear functions over  <span class="math">\\mathbb{F}_p^n</span>  with low degree/multiplicative complexity would remain open.</p>

    <p class="text-gray-300">A possible way for solving it would be to consider higher-degree local functions  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span> , e.g., cubic local functions. In such a case, it is possible that  <span class="math">\\mathcal{S}_F</span>  would be invertible for each  <span class="math">n \\geq m</span> . Just as a concrete example, consider  <span class="math">F(x_0, x_1, \\ldots, x_{m-1}) = \\left(\\sum_{i=0}^{m-1} \\mu_i \\cdot x_i\\right)^3</span>  for  <span class="math">\\mu_0, \\mu_1, \\ldots, \\mu_{m-1} \\in \\mathbb{F}_p</span> . Given  <span class="math">m \\leq n</span> , it is not hard to check that the SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  induced by F is invertible if (i)  <span class="math">\\gcd(p-1,3) = 1</span>  (which implies that  <span class="math">x \\mapsto x^3</span>  is invertible) and (ii) the circulant matrix  <span class="math">\\operatorname{circ}(\\mu_0, \\mu_1, \\ldots, \\mu_{m-1}, 0, 0, \\ldots, 0) \\in \\mathbb{F}_p^{n \\times n}</span>  is invertible.</p>

    <p class="text-gray-300">As another possible approach, one could consider modified versions of Definition 1 in which several local maps are involved. More formally:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 8.</strong> Let  <span class="math">p \\geq 3</span>  be a prime integer. Let  <span class="math">1 \\leq m, h \\leq n</span> , and let  <span class="math">F_0, F_1, \\ldots, F_{h-1}</span> :  <span class="math">\\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  be h non-linear function(s). The function  <span class="math">\\mathcal{S}_{F_0, F_1, \\ldots, F_{h-1}}</span>  over  <span class="math">\\mathbb{F}_p^n</span>  is defined as  $\\mathcal{S}_{F_0, F_1, \\ldots, F_{h-1}}(x_0, x_1, \\ldots, x_{n-1}) := y_0 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{n-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  where</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">y_i = F_i \\mod_h(x_i, x_{i+1}, \\dots, x_{i+m-1})</span></div>

    <p class="text-gray-300">for each  <span class="math">i \\in \\{0, 1, \\dots, n-1\\}</span> , where the sub-indexes are taken modulo n.</p>

    <p class="text-gray-300">A concrete example of invertible functions of this form is the Type–II Feistel construction [ZMI90, Nyb96], for which  <span class="math">\\mathcal{S}_{F_0,F_1}</span>  over  <span class="math">\\mathbb{F}_p^n</span>  for  <span class="math">n \\geq 2</span>  is defined via  <span class="math">F_0(x_0,x_1) = x_1</span>  and  <span class="math">F_1(x_0,x_1) = x_1 + G(x_0)</span> , where G is any function over  <span class="math">\\mathbb{F}_p</span> . The research of other invertible non-linear functions  <span class="math">\\mathcal{S}_{F_0,F_1,\\ldots,F_{h-1}}</span>  is left for future research.</p>

    <p class="text-gray-300"><strong>Acknowledgments.</strong> Authors thank Reviewers for their valuable comments and suggestions. In particular, we thank them for suggesting the re-formulation of the conjectures via the matrix representation proposed in Section 8. We also thank Yann Rotella for shepherding this final version of our manuscript. Lorenzo Grassi is supported by the European Research Council under the ERC advanced grant agreement under grant ERC-2017-ADG Nr. 788980 ESCADA.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">References</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-42-2"></span>[AAB<sup>+</sup>20] Abdelrahaman Aly, Tomer Ashur, Eli Ben-Sasson, Siemen Dhooghe, and Alan Szepieniec. Design of Symmetric-Key Primitives for Advanced Cryptographic Protocols. <em>IACR Transactions on Symmetric Cryptology</em>, 2020(3):1–45, 2020.</li>

      <li><span id="page-42-1"></span>[AGP+19] Martin R. Albrecht, Lorenzo Grassi, Léo Perrin, Sebastian Ramacher, Christian Rechberger, Dragos Rotaru, Arnab Roy, and Markus Schofnegger. Feistel Structures for MPC, and More. In ESORICS 2019, volume 11736 of LNCS, pages 151–171, 2019.</li>

      <li><span id="page-42-0"></span>[AGR <span class="math">^+</span> 16] Martin R. Albrecht, Lorenzo Grassi, Christian Rechberger, Arnab Roy, and Tyge Tiessen. MiMC: Efficient Encryption and Cryptographic Hashing with Minimal Multiplicative Complexity. In  <span class="math">ASIACRYPT\\ 2016</span> , volume 10031 of LNCS, pages 191–219, 2016.</li>

      <li><span id="page-42-3"></span>[AP11] Andrea Agnesse and Marco Pedicini. Cube Attack in Finite Fields of Higher Order. In AISC 2011, volume 116 of CRPIT, pages 9–14, 2011.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-43-8"></span>[BBLP22] Augustin Bariant, Clémence Bouvier, Gaëtan Leurent, and Léo Perrin. Practical Algebraic Attacks against some Arithmetization-oriented Hash Functions. Research report, Inria, 2022.</li>

      <li><span id="page-43-9"></span>[BBS99] Eli Biham, Alex Biryukov, and Adi Shamir. Cryptanalysis of Skipjack Reduced to 31 Rounds Using Impossible Differentials. In <em>EUROCRYPT 1999</em>, volume 1592 of <em>LNCS</em>, pages 12–23, 1999.</li>

      <li><span id="page-43-7"></span>[BCD<sup>+</sup>20] Tim Beyne, Anne Canteaut, Itai Dinur, Maria Eichlseder, Gregor Leander, Gaëtan Leurent, María Naya-Plasencia, Léo Perrin, Yu Sasaki, Yosuke Todo, and Friedrich Wiemer. Out of Oddity - New Cryptanalytic Techniques Against Symmetric Primitives Optimized for Integrity Proof Systems. In <em>CRYPTO 2020</em>, volume 12172 of <em>LNCS</em>, pages 299–328, 2020.</li>

      <li><span id="page-43-6"></span>[BDPA08] Guido Bertoni, Joan Daemen, Michaël Peeters, and Gilles Van Assche. On the Indifferentiability of the Sponge Construction. In <em>EUROCRYPT 2008</em>, volume 4965 of <em>LNCS</em>, pages 181–197, 2008.</li>

      <li><span id="page-43-3"></span>[BDPA13] Guido Bertoni, Joan Daemen, Michaël Peeters, and Gilles Van Assche. Keccak. In <em>EUROCRYPT 2013</em>, volume 7881 of <em>LNCS</em>, pages 313–314, 2013.</li>

      <li><span id="page-43-5"></span>[BDPV07] G. Bertoni, J. Daemen, M. Peeters, and G. Van Assche. Sponge functions, 2007. In: Ecrypt Hash Workshop 2007, <a href="http://www.csrc.nist.gov/pki/HashWorkshop/Public Comments/2007_May.html">http://www.csrc.nist.gov/pki/</a> <a href="http://www.csrc.nist.gov/pki/HashWorkshop/Public Comments/2007_May.html">HashWorkshop/PublicComments/2007\\\\_May.html</a>.</li>

      <li><span id="page-43-2"></span>[BPVA<sup>+</sup>11] Guido Bertoni, Michaël Peeters, Gilles Van Assche, et al. The Keccak reference, 2011. <https://keccak.team/files/Keccak-reference-3.0.pdf>.</li>

      <li><span id="page-43-10"></span>[BR11] Andrey Bogdanov and Vincent Rijmen. Linear Hulls with Correlation Zero and Linear Cryptanalysis of Block Ciphers. Cryptology ePrint Archive, Report 2011/123, 2011. <https://ia.cr/2011/123>.</li>

      <li><span id="page-43-11"></span>[BR14] Andrey Bogdanov and Vincent Rijmen. Linear hulls with correlation zero and linear cryptanalysis of block ciphers. <em>Des. Codes Cryptogr.</em>, 70(3):369–383, 2014.</li>

      <li><span id="page-43-12"></span>[BS93] Eli Biham and Adi Shamir. <em>Differential Cryptanalysis of the Data Encryption Standard</em>. Springer, 1993.</li>

      <li><span id="page-43-13"></span>[Buc76] Bruno Buchberger. A theoretical basis for the reduction of polynomials to canonical forms. <em>SIGSAM Bull.</em>, 10(3):19–29, 1976.</li>

      <li><span id="page-43-0"></span>[CGG<sup>+</sup>22] Carlos Cid, Lorenzo Grassi, Aldo Gunsing, Reinhard Lüftenegger, Christian Rechberger, and Markus Schofnegger. Influence of the Linear Layer on the Algebraic Degree in SP-Networks. <em>IACR Trans. Symmetric Cryptol.</em>, 2022(1):110–137, 2022.</li>

      <li><span id="page-43-14"></span>[CLO13] David Cox, John Little, and Donal O'Shea. <em>Ideals, varieties, and algorithms: an introduction to computational algebraic geometry and commutative algebra</em>. Springer Science & Business Media, 2013.</li>

      <li><span id="page-43-1"></span>[Dae95] Joan Daemen. <em>Cipher and hash function design, strategies based on linear and differential cryptanalysis, PhD Thesis</em>. K.U.Leuven, 1995. <a href="https://cs.ru.nl/~joan/">https://cs.</a> <a href="https://cs.ru.nl/~joan/">ru.nl/~joan/</a>.</li>

      <li><span id="page-43-4"></span>[DEG<sup>+</sup>18] Christoph Dobraunig, Maria Eichlseder, Lorenzo Grassi, Virginie Lallemand, Gregor Leander, Eik List, Florian Mendel, and Christian Rechberger. Rasta: A Cipher with Low ANDdepth and Few ANDs per Bit. In <em>CRYPTO 2018</em>, volume 10991 of <em>LNCS</em>, pages 662–692, 2018.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-44-2"></span>[DGGK21] Christoph Dobraunig, Lorenzo Grassi, Anna Guinet, and Daniël Kuijsters. Ciminion: Symmetric Encryption Based on Toffoli-Gates over Large Finite Fields. In <em>EUROCRYPT 2021</em>, volume 12697 of <em>LNCS</em>, pages 3–34, 2021.</li>

      <li><span id="page-44-3"></span>[DGH<sup>+</sup>21] Christoph Dobraunig, Lorenzo Grassi, Lukas Helminger, Christian Rechberger, Markus Schofnegger, and Roman Walch. Pasta: A Case for Hybrid Homomorphic Encryption. Cryptology ePrint Archive, Report 2021/731, 2021. <https://ia.cr/2021/731>.</li>

      <li><span id="page-44-10"></span>[DKR97] Joan Daemen, Lars R. Knudsen, and Vincent Rijmen. The block cipher Square. In <em>FSE 1997</em>, volume 1267 of <em>LNCS</em>, pages 149–165, 1997.</li>

      <li><span id="page-44-8"></span>[DMMR20] Joan Daemen, Pedro Maat Costa Massolino, Alireza Mehrdad, and Yann Rotella. The Subterranean 2.0 Cipher Suite. <em>IACR Trans. Symmetric Cryptol.</em>, 2020(S1):262–294, 2020.</li>

      <li><span id="page-44-11"></span>[DS09] Itai Dinur and Adi Shamir. Cube Attacks on Tweakable Black Box Polynomials. In <em>EUROCRYPT 2009</em>, volume 5479 of <em>LNCS</em>, pages 278–299, 2009.</li>

      <li><span id="page-44-6"></span>[GHR<sup>+</sup>22] Lorenzo Grassi, Yonglin Hao, Christian Rechberger, Markus Schofnegger, Roman Walch, and Qingju Wang. Horst Meets Fluid-SPN: Griffin for Zero-Knowledge Applications. Cryptology ePrint Archive, Report 2022/403, 2022. <https://ia.cr/2022/403>.</li>

      <li><span id="page-44-4"></span>[GKL<sup>+</sup>22] Lorenzo Grassi, Dmitry Khovratovich, Reinhard Lüftenegger, Christian Rechberger, Markus Schofnegger, and Roman Walch. Reinforced Concrete: A Fast Hash Function for Verifiable Computation. In <em>Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security, CCS 2022</em>, pages 1323–1335. ACM, 2022.</li>

      <li><span id="page-44-1"></span>[GKR<sup>+</sup>21] Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roy, and Markus Schofnegger. Poseidon: A New Hash Function for Zero-Knowledge Proof Systems. In <em>USENIX Security 2021</em>. USENIX Association, 2021.</li>

      <li><span id="page-44-7"></span>[GKRS22] Lorenzo Grassi, Dmitry Khovratovich, Sondre Rønjom, and Markus Schofnegger. The Legendre Symbol and the Modulo-2 Operator in Symmetric Schemes over (F<em>p</em>) <em><sup>n</sup></em>. <em>IACR Trans. Symmetric Cryptol.</em>, 2022(1):5–37, 2022.</li>

      <li><span id="page-44-12"></span>[GLR<sup>+</sup>19] Lorenzo Grassi, Reinhard Lüftenegger, Christian Rechberger, Dragos Rotaru, and Markus Schofnegger. On a Generalization of Substitution-Permutation Networks: The HADES Design Strategy. Cryptology ePrint Archive, Report 2019/1107, 2019. <https://ia.cr/2019/1107>.</li>

      <li><span id="page-44-0"></span>[GLR<sup>+</sup>20] Lorenzo Grassi, Reinhard Lüftenegger, Christian Rechberger, Dragos Rotaru, and Markus Schofnegger. On a Generalization of Substitution-Permutation Networks: The HADES Design Strategy. In <em>EUROCRYPT 2020</em>, volume 12106 of <em>LNCS</em>, pages 674–704, 2020.</li>

      <li><span id="page-44-5"></span>[GØSW22] Lorenzo Grassi, Morten Øygarden, Markus Schofnegger, and Roman Walch. From Farfalle to Megafono via Ciminion: The PRF Hydra for MPC Applications. Cryptology ePrint Archive, Report 2022/342, 2022. <a href="https://ia.cr/2022/342">https:</a> <a href="https://ia.cr/2022/342">//ia.cr/2022/342</a> – accepted at EUROCRYPT 2023.</li>

      <li><span id="page-44-9"></span>[GRR16] Lorenzo Grassi, Christian Rechberger, and Sondre Rønjom. Subspace Trail Cryptanalysis and its Applications to AES. <em>IACR Trans. Symmetric Cryptol.</em>, 2016(2):192–225, 2016.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-45-7"></span>[GRS21] Lorenzo Grassi, Christian Rechberger, and Markus Schofnegger. Proving Resistance Against Infinitely Long Subspace Trails: How to Choose the Linear Layer. <em>IACR Trans. Symmetric Cryptol.</em>, 2021(2):314–352, 2021.</li>

      <li><span id="page-45-10"></span>[GSW<sup>+</sup>21] Chun Guo, François-Xavier Standaert, Weijia Wang, Xiao Wang, and Yu Yu. Provable Security of SP Networks with Partial Non-Linear Layers. <em>IACR Transactions on Symmetric Cryptology</em>, 2021(2):353–388, 2021.</li>

      <li><span id="page-45-0"></span>[HKC<sup>+</sup>20] Jincheol Ha, Seongkwang Kim, Wonseok Choi, Jooyoung Lee, Dukjae Moon, Hyojin Yoon, and Jihoon Cho. Masta: An HE-Friendly Cipher Using Modular Arithmetic. <em>IEEE Access</em>, 8:194741–194751, 2020.</li>

      <li><span id="page-45-15"></span>[JK97] Thomas Jakobsen and Lars R. Knudsen. The Interpolation Attack on Block Ciphers. In <em>FSE 1997</em>, volume 1267 of <em>LNCS</em>, pages 28–40, 1997.</li>

      <li><span id="page-45-13"></span>[Knu94] Lars R. Knudsen. Truncated and Higher Order Differentials. In <em>FSE 1994</em>, volume 1008 of <em>LNCS</em>, pages 196–211, 1994.</li>

      <li><span id="page-45-12"></span>[Knu98] Lars R. Knudsen. DEAL - A 128-bit Block Cipher. <em>Technical Report, Department of Informatics, Bergen, Norway</em>, 1998.</li>

      <li><span id="page-45-6"></span>[KR21] Nathan Keller and Asaf Rosemarin. Mind the Middle Layer: The HADES Design Strategy Revisited. In <em>EUROCRYPT 2021</em>, volume 12697 of <em>LNCS</em>, pages 35–63, 2021.</li>

      <li><span id="page-45-8"></span>[LAAZ11] Gregor Leander, Mohamed Ahmed Abdelraheem, Hoda AlKhzaimi, and Erik Zenner. A Cryptanalysis of PRINTcipher: The Invariant Subspace Attack. In <em>CRYPTO 2011</em>, volume 6841 of <em>LNCS</em>, pages 206–221, 2011.</li>

      <li><span id="page-45-16"></span>[Lai94] Xuejia Lai. Higher order derivatives and differential cryptanalysis. Communications and Cryptography: Two Sides of One Tapestry, 1994.</li>

      <li><span id="page-45-5"></span>[LM90] Xuejia Lai and James L. Massey. A Proposal for a New Block Encryption Standard. In <em>EUROCRYPT 1990,</em>, volume 473 of <em>LNCS</em>, pages 389–404, 1990.</li>

      <li><span id="page-45-9"></span>[LMR15] Gregor Leander, Brice Minaud, and Sondre Rønjom. A Generic Approach to Invariant Subspace Attacks: Cryptanalysis of Robin, iSCREAM and Zorro. In <em>EUROCRYPT 2015</em>, volume 9056 of <em>LNCS</em>, pages 254–283, 2015.</li>

      <li><span id="page-45-3"></span>[LSMI21] Fukang Liu, Santanu Sarkar, Willi Meier, and Takanori Isobe. Algebraic Attacks on Rasta and Dasta Using Low-Degree Equations. In <em>Advances in Cryptology - ASIACRYPT 2021</em>, volume 13090 of <em>LNCS</em>, pages 214–240, 2021.</li>

      <li><span id="page-45-4"></span>[LSMI22] Fukang Liu, Santanu Sarkar, Willi Meier, and Takanori Isobe. The Inverse of <em>χ</em> and Its Applications to Rasta-Like Ciphers. <em>J. Cryptol.</em>, 35(4):28, 2022.</li>

      <li><span id="page-45-11"></span>[Mat93] Mitsuru Matsui. Linear Cryptanalysis Method for DES Cipher. In <em>EURO-CRYPT 1993</em>, volume 765 of <em>LNCS</em>, pages 386–397, 1993.</li>

      <li><span id="page-45-2"></span>[MDGM22] Alireza Mehrdad, Joan Daemen, Lorenzo Grassi, and Silvia Mella. Differential Trail Search in Cryptographic Primitives with Big-Circle Chi. <em>IACR Trans. Symmetric Cryptol.</em>, 2022(2):253–288, 2022.</li>

      <li><span id="page-45-1"></span>[MP13] Gary L. Mullen and Daniel Panario. <em>Handbook of Finite Fields</em>. Chapman & Hall/CRC, 1st edition, 2013.</li>

      <li><span id="page-45-14"></span>[MRST09] Florian Mendel, Christian Rechberger, Martin Schläffer, and Søren S. Thomsen. The Rebound Attack: Cryptanalysis of Reduced Whirlpool and Grøstl. In <em>FSE 2009</em>, volume 5665 of <em>LNCS</em>, pages 260–276, 2009.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-46-5"></span>[Nag51] Trygve Nagell. Euler's Criterion and Legendre's Symbol. Introduction to Number Theory, 1951.</li>

      <li><span id="page-46-8"></span>[Nyb96] Kaisa Nyberg. Generalized Feistel Networks. In <em>Advances in Cryptology - ASIACRYPT 1996</em>, volume 1163 of <em>LNCS</em>, pages 91–104. Springer, 1996.</li>

      <li><span id="page-46-3"></span>[Sha12] Christopher J. Shallue. Permutation Polynomials of Finite Fields. arXiv, ePrint: 1211.6044, 2012.</li>

      <li><span id="page-46-9"></span>[SS21] Jan Ferdinand Sauer and Alan Szepieniec. SoK: Gröbner Basis Algorithms for Arithmetization Oriented Ciphers. Cryptology ePrint Archive, Report 2021/870, 2021. https://ia.cr/2021/870.</li>

      <li><span id="page-46-1"></span>[Sze21] Alan Szepieniec. On the Use of the Legendre Symbol in Symmetric Cipher Design. Cryptology ePrint Archive, Report 2021/984, 2021. https://ia.cr/2021/984.</li>

      <li><span id="page-46-4"></span>[Vau99] Serge Vaudenay. On the Lai-Massey Scheme. In ASIACRYPT 1999, volume 1716 of LNCS, pages 8–19, 1999.</li>

      <li><span id="page-46-6"></span>[vzGG13] Joachim von zur Gathen and Jürgen Gerhard. Modern Computer Algebra (3. ed.). Cambridge University Press, 2013.</li>

      <li><span id="page-46-2"></span>[Wol85] Stephen Wolfram. Cryptography with Cellular Automata. In <em>CRYPTO 1985</em>, volume 218 of <em>LNCS</em>, pages 429–432, 1985.</li>

      <li><span id="page-46-7"></span>[ZMI90] Yuliang Zheng, Tsutomu Matsumoto, and Hideki Imai. On the Construction of Block Ciphers Provably Secure and Not Relying on Any Unproved Hypotheses. In Advances in Cryptology – CRYPTO 1989, volume 435 of LNCS, pages 461–480, 1990.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  and  <span class="math">y \\in \\mathbb{F}_p</span> , here we use the notation  <span class="math">F^{-1}(y)</span>  to denote  <span class="math">F^{-1}(y) := \\{x \\in \\mathbb{F}_p^m \\mid F(x) = y\\}</span> . Without loss of generality, let's assume that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F^{-1}(0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq p^{m-1}<span class="math">  (analogous for the other cases). Let&#x27;s define the sets  </span>\\mathfrak{A}, \\mathfrak{B} \\subseteq \\mathbb{F}_p^n$  as:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathfrak{A} := \\{ (x_0, x_1, \\dots, x_{n-1}) \\in \\mathbb{F}_p^n \\mid x_0 = 0 \\}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathfrak{B} := \\{ (x_0, x_1, \\dots, x_{n-1}) \\in \\mathbb{F}_p^n \\mid (x_0, x_1, \\dots, x_{m-1}) \\in F^{-1}(0) \\}.</span></div>

    <p class="text-gray-300">In particular:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathfrak{B} = \\bigcup_{(x_m, \\dots, x_{n-1}) \\in \\mathbb{F}_p^{n-m}} \\mathfrak{B}_{(x_m, \\dots, x_{n-1})}, \\quad \\text{where}</span></div>

    <p class="text-gray-300"> <span class="math">\\mathfrak{B}_{(x_m,\\ldots,x_{n-1})} := \\{(x_0,\\ldots,x_{m-1},x_m,\\ldots,x_{n-1}) \\in \\mathbb{F}_p^n \\mid (x_0,\\ldots,x_{m-1}) \\in F^{-1}(0)\\}.</span></p>

    <p class="text-gray-300">Note that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= q^{n-1}$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- $</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathfrak{B}_{(x_m,...,x_{n-1})}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\geq p^{m-1}<span class="math">  for each  </span>(x_m,...,x_{n-1}) \\in \\mathbb{F}_p^{n-m}<span class="math">  (by the hypothesis of F being not balanced and  </span></td>

            <td class="px-3 py-2 border-b border-gray-700">F^{-1}(0)</td>

            <td class="px-3 py-2 border-b border-gray-700">\\geq p^{m-1}$ ), which implies that</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\sum_{(x_m, \\dots, x_{n-1}) \\in \\mathbb{F}_p^{n-m}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{B}_{(x_m, \\dots, x_{n-1})}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq p^{m-1} \\cdot p^{n-m} = p^{n-1} =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By meanings of cardinality of  <span class="math">S_F</span>  restricted on  <span class="math">\\mathfrak{B}</span>  cannot be injective, hence  <span class="math">S_F</span>  is not injective, which implies that  <span class="math">S_F</span>  is not invertible.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">В <strong>Practical Verification for Quadratic Functions</strong></h4>

    <p class="text-gray-300">In this section, we describe the practical experiments we performed in order to support our theoretical results. Supplemental material including the source code in C++ can be found in the public git repository:</p>

    <p class="text-gray-300">https://gitlab.com/pis147879/supplemental-material/-/tree/main/experiments</p>

    <p class="text-gray-300">containing the following files:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>source code main.cpp.</li>

      <li>Makefile to compile and run the code,</li>

      <li>a readme.md file containing instructions,</li>

      <li>a description of practical experiments (experiments.pdf),</li>

      <li>directories with log files of our practical tests.</li>

    </ul>

    <p class="text-gray-300">Compiling with make and running by setting in the Makefile variables in accord to the case to run. A standard C++ compiler should work (we have used g++ with gcc version 7.5.0 and the GNU multi-precision library libgmp version 6.2.0). The code is not optimised although offers a rudimentary form of parallelization, which becomes necessary to run some cases we report on.</p>

    <p class="text-gray-300">In the same repository, directory:</p>

    <p class="text-gray-300">https://gitlab.com/pis147879/supplemental-material/-/tree/main/proofs</p>

    <p class="text-gray-300">we include symbolic computations to verify collisions in Lemmas 3-5-6 (Lemma3.ma, Lemma5.ma, Lemma6.ma) and a summary of their execution results, same directory in the file CollisionVerification-Lemma3-5-6.pdf.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Brute Force Research <strong>B.1</strong></h4>

    <p class="text-gray-300">Here we propose a pseudo-code of the algorithm that we used for our tests for the case of polynomial functions  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  of degree  <span class="math">d \\geq 2</span> , defined as (7). Given  <span class="math">p \\geq 3</span>  and  <span class="math">n \\geq m \\geq 2</span> , Algorithm 1 consists of two steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. checking if a function  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  is balanced or not;</li>

      <li>2. if a function is balanced, checking if the corresponding SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  is invertible or not.</li>

    </ul>

    <p class="text-gray-300">The check is done by making use of hash tables.</p>

    <p class="text-gray-300"><strong>Reducing the Search Space.</strong> As first step, we show how to use the necessary conditions given in Section 2 in order to reduce the cost:</p>

    <p class="text-gray-300">• first of all, the coefficient of the monomial of degree zero can be fixed equal to zero (that is,  <span class="math">\\alpha_{0,\\dots,0}=0</span> ); indeed, just choose  <span class="math">\\psi=-\\alpha_{0,\\dots,0}\\cdot\\omega</span> ;</p>

    <p class="text-gray-300"><strong>Algorithm 1:</strong> Pseudo-code for finding functions  <span class="math">F : \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  for which the corresponding SI-lifting  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  is invertible.</p>

    <pre><code class="language-text">Data: Input: p \\geq 3, m \\geq 2, n \\geq m
    Result: Output: F: \\mathbb{F}_p^m \\to \\mathbb{F}_p such that \\mathcal{S}_F over \\mathbb{F}_p^n is invertible
 1 let \\mathfrak{X} = \\emptyset be the set of functions \\mathbb{F}_p^m \\to \\mathbb{F}_p;
 2 for each function F defined as in (7) do
         // 1st Step: check if F is balanced
         let a = 0 \\in \\mathbb{N}^p and b = 0 \\in \\{0, 1\\}^{p^n};
 3
         for all x \\in \\mathbb{F}_p^m do
 4
              a_{F(x)} \\leftarrow a_{F(x)} + 1;

if a_{F(x)} &gt; p^{m-1} then
 5
 6
                   Break: F is not balanced, hence discard it;
 7
         // 2nd Step: given F balanced, check if \\mathcal{S}_F is invertible
         for all x \\in \\mathbb{F}_p^n do
 8
 9
              if b_{\\mathcal{S}_F(x)} = 0 then
                  b_{\\mathcal{S}_F(x)} \\leftarrow 1;
10
11
                   Break: S_F is not a permutation, hence discard F;
         \\mathfrak{X} \\leftarrow \\mathfrak{X} \\cup \\{F\\};
14 return X</code></pre>

    <p class="text-gray-300"><span id="page-48-1"></span>• the coefficient of one monomial of degree one and one of degree two can be chosen in  <span class="math">\\{0,1\\}</span>  (e.g.,  <span class="math">\\alpha_{1,0,\\dots,0},\\alpha_{2,0,\\dots,0}\\in\\{0,1\\}</span> ); indeed, if they are both equal to zero the result is obvious, if only one of them is different from zero just choose  <span class="math">\\omega</span>  as the inverse of the non-zero one. If both  <span class="math">\\alpha_{1,0,\\dots,0}\\neq 0</span>  and  <span class="math">\\alpha_{2,0,\\dots,0}\\neq 0</span> , take  <span class="math">\\mu=\\frac{\\alpha_{1,0,\\dots,0}}{\\alpha_{2,0,\\dots,0}}</span> ,  <span class="math">\\omega=\\frac{\\alpha_{2,0,\\dots,0}}{(\\alpha_{1,0,\\dots,0})^2}</span>  and  <span class="math">\\nu=0</span> .</p>

    <p class="text-gray-300">In this way, the number of quadratic functions  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  reduces as following</p>

    <div class="my-4 text-center"><span class="math-block">p^{1+2m+\\binom{m}{2}} = p^{\\frac{m^2+3m+2}{2}} \\quad \\to \\quad 2^2 \\cdot p^{\\frac{m^2+3m-4}{2}}.</span></div>

    <p class="text-gray-300"><strong>Memory and Computational Costs.</strong> Let's analyze the cost of the algorithm. First of all, the memory cost is given by  <span class="math">\\mathcal{O}(\\max\\{p \\cdot \\lceil \\log_2(p^{m-1}) \\rceil, p^n\\}) = \\mathcal{O}(p^n)</span>  bits. Indeed, since the first step stops when one entry of  <span class="math">a \\in \\mathbb{N}^p</span>  is bigger than  <span class="math">p^{m-1}</span> , we need  <span class="math">\\lceil \\log_2(p^{m-1}) \\rceil</span>  bits for each entry of such array.</p>

    <p class="text-gray-300">Regarding the computational cost, for each function  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>we have to test  <span class="math">p^m</span>  different inputs in order to check if F is balanced:</li>

      <li>if the function F is balanced, we have to test  <span class="math">p^n</span>  different inputs in order to check if  <span class="math">S_F</span>  is invertible.</li>

    </ul>

    <p class="text-gray-300">This requires  <span class="math">\\mathcal{O}(p^m \\cdot 2^2 \\cdot p^{(m^2+3m-4)/2} \\cdot p^n)</span>  steps (namely, memory access, evaluation of the function F, etc.). Note that these are just rough estimations, since several functions F are e.g. discarded in the first step if they are not balanced.</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6"><strong>B.2</strong> Practical Results</h4>

    <p class="text-gray-300">In order to carry out the practical experiments, we implemented the brute-force collisionsearch algorithm described in Algorithm 1: for each quadratic function  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  we look for a collision in the domain of the corresponding SI-lifting function  <span class="math">\\mathcal{S}_F</span>  (as defined in</p>

    <p class="text-gray-300"><span id="page-49-0"></span>Table 3: Summary of our practical results for <em>d</em> = 2 and <em>m</em> ∈ {2<em>,</em> 3}. For each <em>p</em> ≥ 3, we report the maximum value of <em>n</em> tested, the number of balanced <em>quadratic</em> functions with respect to the total number of functions <em>F</em> (with <em>α</em>0<em>,</em>0<em>,</em><sup>0</sup> = 0, <em>α</em>2<em>,</em>0<em>,</em>0<em>, α</em>0<em>,</em>0<em>,</em><sup>1</sup> ∈ {0<em>,</em> 1}) and the total runtime in hours/days.</p>

    <p class="text-gray-300">|    | Case: m = 2 and n ≥ 3 |                       |       |            |  |  |  |  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">----</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-----------------------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-----------------------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">------------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">--</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">--</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">--</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">--</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">17.5%</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5 hours</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">69</td>

            <td class="px-3 py-2 border-b border-gray-700">13.8%</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">3.6 hours</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">151</td>

            <td class="px-3 py-2 border-b border-gray-700">11.0%</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">0.9 hours</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">411</td>

            <td class="px-3 py-2 border-b border-gray-700">7.7%</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">9.6 hours</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">589</td>

            <td class="px-3 py-2 border-b border-gray-700">6.7%</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0 hours</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">1 041</td>

            <td class="px-3 py-2 border-b border-gray-700">5.2%</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">3.7 hours</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">1 315</td>

            <td class="px-3 py-2 border-b border-gray-700">4.8%</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">6.3 hours</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">1 959</td>

            <td class="px-3 py-2 border-b border-gray-700">4.0%</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">16.0 hours</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|    |                       | Case: m = 3 and n ≥ 5 |       |            |  |  |  |  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># balanced F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">percentage</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">max n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">runtime</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">53 725</td>

            <td class="px-3 py-2 border-b border-gray-700">17.2%</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">5.3 hours</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">426 139</td>

            <td class="px-3 py-2 border-b border-gray-700">12.9%</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">6.0 days</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">2 464 657</td>

            <td class="px-3 py-2 border-b border-gray-700">3.2%</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">46.8 days</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition <a href="#page-3-1">1\\)</a> over F <em>n p</em> for <em>n</em> ≥ <em>m</em>. We aim to practically verify that no invertible function S<em><sup>F</sup></em> exists for the cases (1st) <em>m</em> = 2 and <em>n</em> ≥ 3 (as proved in Theorem <a href="#page-11-1">2\\)</a> and (2nd) <em>m</em> = 3 and <em>n</em> ≥ 5 (as proved in Theorem <a href="#page-17-1">3\\)</a>. We verify it practically just for small values of <em>p</em> and <em>n</em>, while the theoretical proofs confirm that the behavior that occurs for small values is also valid for all <em>p</em> ≥ 3.</p>

    <p class="text-gray-300">The tests have been done on a Intel 40-core Xeon E5-2698 v4 @ 2.20GHz. The results of the practical experiments are given in Table <a href="#page-49-0">3,</a> describing for each <em>p</em> ≥ 3:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the number of balanced <em>quadratic</em> functions with respect to the total number of functions <em>F</em>;</li>

      <li>the maximum value of <em>n</em> tested (denoted as "max <em>n</em>");</li>

      <li>the total runtime in hours/days.</li>

    </ul>

    <p class="text-gray-300">We restrict the domain of functions <em>F</em> by using the equivalence classes introduced in Section <a href="#page-7-0">2.1</a> (that is, <em>α</em>0<em>,</em>0<em>,</em><sup>0</sup> = 0, <em>α</em>2<em>,</em>0<em>,</em>0<em>, α</em>0<em>,</em>0<em>,</em><sup>1</sup> ∈ {0<em>,</em> 1}).</p>

    <p class="text-gray-300">As described in Algorithm <a href="#page-48-1">1,</a> tests are divided into two main phases: (1st) the balanced testing and (2nd) the collision search. The time each step requires depends on the case considered:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>d</em> = 2 and <em>m</em> = 2: the balanced testing takes just the 0.1% of the total runtime, while the collision search takes most of the time spent on the tests;</li>

      <li><em>d</em> = 2 and <em>m</em> = 3: runtimes for balanced testing and collision search depend on <em>p</em>, e.g. for <em>p</em> = 3 the balanced testing takes the 0.1% of the total runtime, while for <em>p</em> = 11 it takes the 88%.</li>

    </ul>

    <p class="text-gray-300">Anyway, the balanced testing and collisions search runtimes depend strongly on the number of iterations that the program requires in order to establish if a function is balanced or, respectively, invertible (i.e., to find the first collision), since the program works iteratively, testing for each value whether its image has already been evaluated as the image of another value.</p>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">C.1 Maximum Differential Probability of <span class="math">\\mathcal{S}&#x27;</span></h3>

    <p class="text-gray-300">Let  <span class="math">p \\geq 3</span>  be a prime integer, and let  <span class="math">\\mathcal{S}&#x27; : \\mathbb{F}_p^2 \\to \\mathbb{F}_p^2</span>  be defined as in (22). Here we prove that its maximum differential probability is  <span class="math">p^{-1}</span> .</p>

    <p class="text-gray-300">In order to do this, we proceed in two steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>first, we compute the maximum differential probability of  <span class="math">S_{F&#x27;}</span>  over  <span class="math">\\mathbb{F}_p^2</span>  defined as in Definition 1 via  <span class="math">F&#x27;(x_0, x_1) = \\alpha \\cdot x_0 + \\beta \\cdot (x_0 x_1)^2</span> ;</li>

      <li>based on this result, we compute the maximum differential probability of  <span class="math">\\mathcal{S}&#x27;</span> .</li>

    </ul>

    <p class="text-gray-300"><strong>Maximum Differential Probability of</strong>  <span class="math">S_{F&#x27;}</span> . Given input/output differences  <span class="math">(\\delta_0, \\delta_1), (\\Delta_0, \\Delta_1) \\in \\mathbb{F}_p^2 \\setminus \\{(0,0)\\}</span> , we first analyze the number of solutions  <span class="math">(x_0, x_1)</span>  of the following system</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha \\cdot \\delta_0 + \\beta \\cdot (\\delta_0 - \\delta_1)^2 + 2\\beta \\cdot (\\delta_0 - \\delta_1) \\cdot (x_0 - x_1) = \\Delta_0</span></div>

    <div class="my-4 text-center"><span class="math-block">\\alpha \\cdot \\delta_1 + \\beta \\cdot (\\delta_0 - \\delta_1)^2 + 2\\beta \\cdot (\\delta_0 - \\delta_1) \\cdot (x_0 - x_1) = \\Delta_1,</span></div>

    <p class="text-gray-300">which corresponds to</p>

    <p class="text-gray-300"><span id="page-50-2"></span> <span class="math-block">\\alpha \\cdot (\\delta_0 - \\delta_1) = \\Delta_0 - \\Delta_1 \\tag{24}</span></p>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">(\\delta_0 - \\delta_1) \\cdot (x_0 - x_1) = \\frac{\\Delta_0 - \\alpha \\cdot \\delta_0 - \\beta \\cdot (\\delta_0 - \\delta_1)^2}{2\\beta}.</span></div>

    <p class="text-gray-300">It follows that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">\\delta_0 \\neq \\delta_1</span> , such system of equations admits exactly p solutions;</li>

      <li>if  <span class="math">\\delta_0 = \\delta_1</span>  (hence,  <span class="math">\\Delta_0 = \\Delta_1</span> ), then the equations are always satisfied if  <span class="math">\\Delta_0 = \\alpha \\cdot \\delta_0</span> .</li>

    </ul>

    <p class="text-gray-300"><strong>Maximum Differential Probability of</strong>  <span class="math">\\mathcal{S}&#x27;</span> <strong>.</strong> Given  <span class="math">(\\delta_0, \\delta_1), (\\Delta_0, \\Delta_1) \\in \\mathbb{F}_p^2 \\setminus \\{(0, 0)\\}</span> , the maximum differential probability of  <span class="math">\\mathcal{S}&#x27;</span>  is given by</p>

    <p class="text-gray-300"><span id="page-50-3"></span> <span class="math-block">\\sum_{(\\varepsilon_0,\\varepsilon_1)\\in\\mathbb{F}_p^2} \\operatorname{Prob}\\left(\\begin{bmatrix} \\delta_0\\\\ \\delta_1 \\end{bmatrix} \\to \\begin{bmatrix} \\varepsilon_0\\\\ \\varepsilon_1 \\end{bmatrix}\\right) \\times \\operatorname{Prob}\\left(\\left(\\begin{bmatrix} 2 &amp; 1\\\\ 1 &amp; 3 \\end{bmatrix} \\times \\begin{bmatrix} \\varepsilon_0\\\\ \\varepsilon_1 \\end{bmatrix}\\right) \\to \\begin{bmatrix} \\Delta_0\\\\ \\Delta_1 \\end{bmatrix}\\right). \\tag{25}</span></p>

    <p class="text-gray-300">In our case, condition (24) becomes:</p>

    <p class="text-gray-300"><span class="math-block">\\alpha \\cdot (\\delta_0 - \\delta_1) = \\varepsilon_0 - \\varepsilon_1</span>  and  <span class="math">\\alpha \\cdot (\\varepsilon_0 - 2 \\cdot \\varepsilon_1) = \\Delta_0 - \\Delta_1</span> ,</p>

    <p class="text-gray-300">that is</p>

    <p class="text-gray-300"><span class="math-block">\\varepsilon_0 = 2 \\cdot \\alpha \\cdot (\\delta_0 - \\delta_1) - \\frac{\\Delta_0 - \\Delta_1}{\\alpha}</span>  and  <span class="math">\\varepsilon_1 = \\alpha \\cdot (\\delta_0 - \\delta_1) - \\frac{\\Delta_0 - \\Delta_1}{\\alpha}</span></p>

    <p class="text-gray-300">Hence, the probability given in (25) reduces to</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Prob}\\left(\\begin{bmatrix} \\delta_0 \\\\ \\delta_1 \\end{bmatrix} \\to \\begin{bmatrix} 2 \\cdot \\alpha \\cdot (\\delta_0 - \\delta_1) - \\frac{\\Delta_0 - \\Delta_1}{\\alpha} \\\\ \\alpha \\cdot (\\delta_0 - \\delta_1) - \\frac{\\Delta_0 - \\Delta_1}{\\alpha} \\end{bmatrix}\\right) \\times \\operatorname{Prob}\\left(\\begin{bmatrix} 5 \\cdot \\alpha \\cdot (\\delta_0 - \\delta_1) - 3 \\cdot \\frac{\\Delta_0 - \\Delta_1}{\\alpha} \\\\ 5 \\cdot \\alpha \\cdot (\\delta_0 - \\delta_1) - 4 \\cdot \\frac{\\Delta_0 - \\Delta_1}{\\alpha} \\end{bmatrix} \\to \\begin{bmatrix} \\Delta_0 \\\\ \\Delta_1 \\end{bmatrix}\\right).</span></div>

    <p class="text-gray-300">Such probability is never bigger than  <span class="math">p^{-1}</span> , since:</p>

    <p class="text-gray-300">• if  <span class="math">\\delta_0 = \\delta_1</span> , then</p>

    <div class="my-4 text-center"><span class="math-block">2 \\cdot \\alpha \\cdot (\\delta_0 - \\delta_1) - \\frac{\\Delta_0 - \\Delta_1}{\\alpha} = \\alpha \\cdot (\\delta_0 - \\delta_1) - \\frac{\\Delta_0 - \\Delta_1}{\\alpha}.</span></div>

    <p class="text-gray-300">This implies that the first probability is equal to 1. If  <span class="math">\\delta_0 \\neq \\delta_1</span> , then the first probability is 1/p;</p>

    <p class="text-gray-300">• if  <span class="math">\\Delta_0 = \\Delta_1</span> , then</p>

    <div class="my-4 text-center"><span class="math-block">5 \\cdot \\alpha \\cdot (\\delta_0 - \\delta_1) - 3 \\cdot \\frac{\\Delta_0 - \\Delta_1}{\\alpha} = 5 \\cdot \\alpha \\cdot (\\delta_0 - \\delta_1) - 4 \\cdot \\frac{\\Delta_0 - \\Delta_1}{\\alpha}.</span></div>

    <p class="text-gray-300">This implies that the second probability is equal to 1. If  <span class="math">\\Delta_0 \\neq \\Delta_1</span> , then the first probability is 1/p;</p>

    <p class="text-gray-300">• if  <span class="math">\\delta_0 = \\delta_1</span>  and  <span class="math">\\Delta_0 = \\Delta_1</span> , then</p>

    <div class="my-4 text-center"><span class="math-block">2 \\cdot \\alpha \\cdot (\\delta_0 - \\delta_1) - \\frac{\\Delta_0 - \\Delta_1}{\\alpha} = \\alpha \\cdot (\\delta_0 - \\delta_1) - \\frac{\\Delta_0 - \\Delta_1}{\\alpha}$$ $$= 5 \\cdot \\alpha \\cdot (\\delta_0 - \\delta_1) - 3 \\cdot \\frac{\\Delta_0 - \\Delta_1}{\\alpha} = 5 \\cdot \\alpha \\cdot (\\delta_0 - \\delta_1) - 4 \\cdot \\frac{\\Delta_0 - \\Delta_1}{\\alpha} = 0.</span></div>

    <p class="text-gray-300">In such a case, the overall probability is equal to zero, since we cannot have a zero difference in the middle when the input/output differences are non-zero (remember that the construction is invertible).</p>

    <p class="text-gray-300">It follows that the probability is maximum when either  <span class="math">\\delta_0 = \\delta_1</span>  or  <span class="math">\\Delta_0 = \\Delta_1</span> , and in such a case it is equal to 1/p.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">C.2 Gröbner Basis Attacks on Neptune</h3>

    <p class="text-gray-300">The cost of the Gröbner basis attack depends on the system of equations that describes Neptune. As usually done in the literature, instead of considering (collision or/and preimage) attacks on the sponge hash function, we focus on the CICO problem on the permutation that instantiates Neptune.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 9.</strong> The invertible function  <span class="math">\\mathcal{G}: \\mathbb{F}_p^t \\to \\mathbb{F}_p^t</span>  is  <span class="math">\\kappa</span> -secure against the CICO  <span class="math">(t_1, t_2)</span> -problem (where  <span class="math">t_1, t_2 &lt; t</span> ) if there is no algorithm with expected complexity smaller than  <span class="math">2^{\\kappa}</span>  that for given  <span class="math">i_1 \\in \\mathbb{F}_p^{t_1}</span>  and  <span class="math">o_1 \\in \\mathbb{F}_p^{t_2}</span>  finds  <span class="math">i_2, o_2</span>  such that  $\\mathcal{G}(i_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i_2) = o_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">o_2$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We consider two approaches:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>working on the relation between the input and the output of the entire permutation;</li>

      <li>working at round level.</li>

    </ul>

    <p class="text-gray-300"><strong>Preliminary.</strong> A Gröbner basis attack consists of three steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. first, the attacker needs to set up the equation system and compute a Gröbner basis for it;</li>

      <li>2. secondly, they perform a change of term ordering for the basis, usually going to a term order which makes it easier to eliminate variables and find the solutions;</li>

      <li>3. finally, the attacker uses the system obtained in the second step in order to start solving for the variables.</li>

    </ul>

    <p class="text-gray-300">We refer to [CLO13,SS21] for a detailed description about such an attack. Here we focus on the complexity of the first step (i.e., computing a Gröbner basis), which can be estimated by</p>

    <div class="my-4 text-center"><span class="math-block">C_{\\rm GB} = \\mathcal{O}\\left( \\binom{D_{\\rm reg} + n_v}{n_v}^{\\omega} \\right)</span></div>

    <p class="text-gray-300">operations, where  <span class="math">D_{\\text{reg}}</span>  is the degree of regularity,  <span class="math">n_v</span>  is the number of variables, and  <span class="math">2 \\le \\omega &lt; 3</span>  is a constant representing the complexity of a matrix multiplication. Let  <span class="math">n_e</span>  be</p>

    <p class="text-gray-300">the number of equations in the polynomial system, <em>n<sup>v</sup></em> be the number of equations to solve, and <em>d<sup>i</sup></em> is the degree of the <em>i</em>-th equation. Directly computing <em>D</em>reg is hard in general, but an estimate for semi–regular sequences, for which the degree of regularity is defined as the index of the first non-positive coefficient in the series of</p>

    <div class="my-4 text-center"><span class="math-block">H(z) = \\frac{\\prod_{i=1}^{n_e} (1 - z^{d_i})}{(1 - z)^{n_v}}.</span></div>

    <p class="text-gray-300">In the particular case of regular sequences (namely, in the case <em>n<sup>e</sup></em> = <em>nv</em>), the degree of regularity is simply equal to</p>

    <div class="my-4 text-center"><span class="math-block">D_{\\text{reg}} = 1 + \\sum_{i=1}^{n_e} (d_i - 1).</span></div>

    <h3 id="sec-42" class="text-xl font-semibold mt-8"><strong>C.2.1 Working on the Input and the Output</strong></h3>

    <p class="text-gray-300">Let's first consider the input and the output of the permutation, focusing on the case in which the number of unknown input variables <em>x</em> is equal to the number of known output variables. In such a case, we get <em>x</em> equations of degree 4 6 · <em>d <sup>R</sup><sup>I</sup></em> = 212+<em>R<sup>I</sup></em> ·log<sup>2</sup> (<em>d</em>) (we assume that <em>R<sup>F</sup></em> = 6 is fixed) in <em>x</em> variables. Hence, we have that</p>

    <div class="my-4 text-center"><span class="math-block">D_{\\text{reg}} = 1 + x \\cdot (2^{12 + R_I \\cdot \\log_2(d)} - 1),</span></div>

    <p class="text-gray-300">which implies a cost of approximately</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{O}\\left(\\binom{x \\cdot 2^{12 + R_I \\cdot \\log_2(d)}}{x}\\right)^{\\omega}\\right)</span></div>

    <p class="text-gray-300">assuming a semi-regular system (as done for Poseidon). Since <em>ω</em> ≥ 2 (the best scenario for the attacker), then</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{pmatrix} x \\cdot 2^{12 + R_I \\cdot \\log_2(d)} \\\\ x \\end{pmatrix}^{\\omega} \\ge \\left( \\frac{\\left(1 + x \\cdot \\left(2^{12 + R_I \\cdot \\log_2(d)} - 1\\right)\\right)^x}{x!} \\right)^2</span></div>

    <div class="my-4 text-center"><span class="math-block">\\ge \\left( \\frac{1 + x \\cdot \\left(2^{12 + R_I \\cdot \\log_2(d)} - 1\\right)}{x} \\right)^{2x} \\approx \\left(2^{12 + R_I \\cdot \\log_2(d)}\\right)^{2x},</span></div>

    <p class="text-gray-300">where <em>x</em>! ≤ <em>x x</em> for each <em>x</em> ≥ 1. In order to guarantee <em>κ</em> bits of security:</p>

    <div class="my-4 text-center"><span class="math-block">(2^{12+R_I \\cdot \\log_2(d)})^{2x} \\ge \\min\\{2^{\\kappa}, p^x\\}.</span></div>

    <p class="text-gray-300">The maximum is obtained for <em>x</em> = 1, which implies</p>

    <p class="text-gray-300"><span class="math-block">R_I \\ge \\log_d(2) \\cdot \\left(\\frac{\\min\\{\\kappa, \\log_2(p)\\}}{2} - 12\\right)</span> .</p>

    <p class="text-gray-300">Such inequality is always satisfied by the number of rounds required to prevent the interpolation attack, for which <em>R<sup>I</sup></em> is proportional to <em>R<sup>I</sup></em> ≥ log<em><sup>d</sup></em> (2) · min{<em>κ,</em> log<sup>2</sup> (<em>p</em>)}. Due to the large gap between these two number of rounds, we expect that the Gröbner basis attack does not outperfom the interpolation attack even in the case in which the degree of regularity used here is over-estimated (equivalently, the system is not semi-regular).</p>

    <h3 id="sec-43" class="text-xl font-semibold mt-8"><strong>C.2.2 Working at Round Level</strong></h3>

    <p class="text-gray-300">Another possibility for setting up the Gröbner basis attack consists of working at round level. In such a case:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>every internal round can be described as a single equation of degree <em>d</em>;</li>

      <li>every external round can be described via <em>t</em> equations of degree 2. Indeed, assuming for simplicity <em>α</em> = <em>β</em> = 1, note that given (<em>y</em>0<em>, y</em>1) = S 0 (<em>x</em>0<em>, x</em>1), we have</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} y_0 + (y_0 - y_1)^2 \\\\ y_1 + (y_0 - y_1)^2 \\end{bmatrix} = \\begin{bmatrix} \\gamma \\\\ 0 \\end{bmatrix} + \\begin{bmatrix} 2 &amp; 1 \\\\ 1 &amp; 3 \\end{bmatrix} \\times \\begin{bmatrix} x_0 + (x_0 - x_1)^2 \\\\ x_1 + (x_0 - x_1)^2 \\end{bmatrix}.</span></div>

    <p class="text-gray-300">Let <em>x</em> ∈ {1<em>, . . . , t</em>} be the number of variables. It follows that we have</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>R<sup>I</sup></em> equations of degree <em>d</em>;</li>

      <li>(<em>R<sup>F</sup></em> − 1) · <em>t</em> + <em>x</em> equations of degree 2</li>

    </ul>

    <p class="text-gray-300">in (<em>R<sup>F</sup></em> − 1) · <em>t</em> + <em>R<sup>I</sup></em> + <em>x</em> variables. Assuming a semi-regular system and <em>R<sup>F</sup></em> = 6, we have that</p>

    <p class="text-gray-300"><span class="math-block">D_{\\text{reg}} = 1 + 5 \\cdot t + x + R_I \\cdot (d-1)</span> .</p>

    <p class="text-gray-300">As in the case of Poseidon, the cost of the Gröbner basis attack is well approximated by</p>

    <div class="my-4 text-center"><span class="math-block">\\binom{10 \\cdot t + R_I \\cdot d + 2 \\cdot x}{5 \\cdot t + R_I + x}^2 \\ge \\binom{2 \\cdot (5 \\cdot t + R_I + x)}{5 \\cdot t + R_I + x}^2</span></div>

    <p class="text-gray-300">where the last inequality follows from the fact that <em>d</em> ≥ 3. We recall that for each <em>a, b</em> ≥ 1:</p>

    <div class="my-4 text-center"><span class="math-block">\\binom{a \\cdot b}{b} \\ge \\left(\\frac{a \\cdot b}{b}\\right)^b</span></div>

    <p class="text-gray-300">since</p>

    <div class="my-4 text-center"><span class="math-block">\\binom{a\\cdot b}{b} = \\frac{((a-1)\\cdot b+1)!}{b!} = \\prod_{i=1}^b \\frac{(a-1)\\cdot b+i}{i} \\geq \\prod_{i=1}^b \\frac{a}{b} = \\left(\\frac{a\\cdot b}{b}\\right)^b.</span></div>

    <p class="text-gray-300">Hence:</p>

    <div class="my-4 text-center"><span class="math-block">{2 \\cdot (5 \\cdot t + R_I + x) \\choose 5 \\cdot t + R_I + x}^2 \\ge 2^{2 \\cdot (5 \\cdot t + R_I + x)}.</span></div>

    <p class="text-gray-300">In order to achieve security, we require that this cost is higher than min{2 <em>κ , px</em>} ≤ 2 <em>κ</em> for each <em>x</em> ∈ {1<em>, . . . , t</em>}, which occurs if</p>

    <div class="my-4 text-center"><span class="math-block">R_I \\ge \\frac{\\kappa}{2} - 4 \\cdot t - 2 \\,,</span></div>

    <p class="text-gray-300">where we added <em>t</em> − 1 rounds in order to take into account the fact that (up to) <em>t</em> internal rounds can be skipped via an invariant subspace.</p>`;
---

<BaseLayout title="Invertible Quadratic Non-Linear Layers for MPC-/FHE-/ZK-Frie... (2021/1695)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/1695
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="invertible-quadratic-non-linear-layers-for-mpc-fhe-zk-2021" />
  </article>
</BaseLayout>
