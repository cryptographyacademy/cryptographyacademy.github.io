---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/1579';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'KiloNova: Non-Uniform PCD with Zero-Knowledge Property from Generic Folding Schemes';
const AUTHORS_HTML = 'Tianyu Zheng, Shang Gao, Yu Guo, Bin Xiao';

const CONTENT = `    <p class="text-gray-300">Tianyu Zheng [11] Shang Gao [11] Yu Guo [22] Bin Xiao [11]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Proof-Carrying Data (PCD) is a powerful cryptographic primitive generalizing Incrementally Verifiable Computation (IVC) to enable sequential computation by multiple distrusting parties. However, the more complex construction of PCD incurs efficiency problems. For instance, naively adopting existing folding schemes for IVC to PCD results in an “explosive cross terms” problem. Additionally, the development of virtual machines like EVM proposes new requirements of handling non-uniform circuits and providing zero knowledge. To address these challenges, we introduce KiloNova, a new construction of zero-knowledge PCD from non-uniform multi-folding schemes.</p>

    <p class="text-gray-300">We first propose a generic folding scheme for multiple instances with non-uniform circuits. Inspired by HyperNova <em>(Kothapalli et al. 23)</em>, we employ sum-check protocols to linearize the CCS relation. This process yields a relaxed relation with linear claims on structures and instance-witness pairs, thereby avoiding cross terms in the folding operations. Based on the relaxed relation, we build a generic folding scheme with comparable performance to other advanced work. We also introduce an efficient approach to achieving zero knowledge for this folding scheme.</p>

    <p class="text-gray-300">Next, we propose a novel construction for zero-knowledge PCD. Unlike previous works, our construction eliminates the need for a separate design of a zero-knowledge Non-Interactive Argument of Knowledge (NARK), allowing a zero-knowledge PCD to be constructed with only a zero-knowledge folding scheme. This theoretical improvement significantly reduces the work of building zero-knowledge PCD. Based on this, we construct KiloNova, the first zero-knowledge, non-uniform PCD based on folding schemes. Our PCD outperforms others according to the evaluation, with only a single multi-scalar multiplication dominating the prover cost at each step. Its recursive circuit is dominated by <span class="math">O(\\log(n))</span> random-oracle-like hashes and <span class="math">O(k)</span> scalar multiplications, where <span class="math">n</span> is the circuit input length and <span class="math">k</span> is the instance number at each step. To address potential efficiency challenges in the real-world implementation of non-uniform PCD, we introduce a new technique for delegating the costly structure folds.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Recently, there has been a surge of interest in the realization of <em>Incrementally Verifiable Computation</em> (IVC), a cryptographic primitive that runs sequential</p>

    <p class="text-gray-300">computations <em>[34]</em> while allowing efficient verification of the execution at any point. As a generalization of IVC to directed acyclic graphs, Proof-Carrying Data (PCD) allows multiple distrusting parties to perform computations sequentially. This property enables PCD in a wider range of applications such as distributed computation <em>[3, 18]</em> and blockchain technology <em>[1, 6, 7]</em>. Meanwhile, the ability to handle multiple instances in each round provides a broader spectrum of trade-offs for system performance, as mentioned in <em>[20]</em>.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Folding/Accumulation Schemes.</h4>

    <p class="text-gray-300">The traditional approach to constructing IVC/PCD employs a general-purpose SNARK at each step <span class="math">i</span> to attest the correctness of the proof output by step <span class="math">i-1</span> recursively. This construction requires implementing the whole verification logic in the SNARK proving circuit (specifically, the recursive circuit), which incurs a significant overhead as the verification may include costly non-native operations such as elliptic curve pairings <em>[10]</em>. A recent line of work proposes a more practical idea to “defer” the expensive operations in the proof verification and run them together at the end of IVC/PCD, including Halo <em>[10]</em>, Halo infinite <em>[5]</em>, BCMS20 <em>[15]</em>, BCLMS21 <em>[14]</em>, Nova <em>[26]</em>, HyperNova <em>[25]</em>, Protostar <em>[13]</em>, etc. The fundamental concept behind these schemes is inspired by batch verification <em>[2]</em>, which allows checking multiple proofs in a batch with almost the same cost as checking merely one proof. Concretely, instead of checking the SNARK/NARK proof from the prior step in the recursive circuit, the prover defers it by applying a so-called folding/accumulation scheme (we use them interchangeably in the following) and continues the incremental computations. As a result, the expensive SNARK/NARK verification in the recursive circuit is replaced with a cheaper verification of the folding scheme. Finally, the IVC verifier (or the decider), conducts a batch verification for all SNARK/NARK proofs deferred at each step.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Proof-Carrying Data.</h4>

    <p class="text-gray-300">BCMS20 <em>[15]</em> introduces the first PCD construction based on accumulation schemes for SNARKs, such as Sonic <em>[28]</em> and Plonk <em>[22]</em>. This scheme utilizes the “additive” property of polynomial commitments as defined in <em>[5]</em>, which allows accumulations on the evaluation proofs of existing polynomial IOPs. To further reduce the recursion overhead, BCLMS21 <em>[14]</em> introduces split accumulation schemes to accumulate only the statement part of evaluation proofs. However, they can only construct PCD for R1CS relations that can not express high-degree constraints. Although several folding/accumulation schemes <em>[13, 25, 26]</em> have been demonstrated as effective primitives for building IVC systems in recent years, directly applying them to PCD may cause severe efficiency problems. This is due to the different structures between IVC and PCD. Compared to IVC, which only folds two instances at each sequential step, PCD requires folding multiple instances. This main difference raises a problem of an exploding number of “cross terms” (also known as error terms in <em>[13]</em>).</p>

    <p class="text-gray-300">Concretely, the cross terms are redundant elements generated when folding non-linear relations. For example, when folding two quadratic instances <span class="math">(w_{i},t_{i})</span> such that <span class="math">w_{i}^{2}=t_{i}</span> for <span class="math">i=1,2</span>, the folded instance <span class="math">(w,t)=(w_{1}+rw_{2},t_{1}+rt_{2})</span> with a random challenge <span class="math">r</span> does not satisfy <span class="math">w^{2}=t</span>. The prover has to compute and</p>

    <p class="text-gray-300">send an extra cross term as <span class="math">2w_{1}w_{2}</span> for verification. As stated in <em>[20]</em>, the number of cross terms grows in <span class="math">O(d^{s})</span> when folding <span class="math">s</span> instances in <span class="math">d</span>-degree relations with the techniques given by Protostar <em>[13]</em>. Most of other schemes improved on Nova <em>[26]</em> also encounter this problem more or less. Even worse, the “cross terms” problem also hinders us from proposing PCD constructions to satisfy the implementation of virtual machines with rich instruction sets (e.g., EVM, RISC-V, Wasm). This application requires the ability to handle non-uniform circuits. Providing zero knowledge may be required as well in privacy-preserving scenarios. Unfortunately, achieving both these properties may exacerbate the efficiency problem. We highlight their technical difficulties in detail as follows.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Challenge 1: Non-Uniform Circuits.</h4>

    <p class="text-gray-300">To attest universal machine executions, SuperNova <em>[24]</em> realizes a non-uniform IVC by enhancing Nova <em>[26]</em> with a selector for the list of predefined functions (i.e., instructions). The downside is that the IVC proof at each step increases with the size of the instruction set. Protostar <em>[13]</em> introduces a more expressive folding/accumulation scheme for special sound protocols supporting Plonkish relations, which yields a non-uniform IVC. Its major drawback lies in the exponential growth of the number of cross terms when folding multiple high-degree instances, which hinders the construction of PCD. Protogalaxy <em>[20]</em> aims to reduce the number of cross terms in Protostar by leveraging the property of the Lagrange base, thus making the recursion overhead tolerable for multi-instance situations. Though Protogalaxy successfully reduced the exponential growth to linear in asymptotic, it causes a quasi-linear prover complexity due to the computation of Lagrange bases.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Challenge 2: Zero Knowledge PCD.</h4>

    <p class="text-gray-300">In addition to the difficulties in supporting non-uniform circuits, adding zero knowledge to folding-based IVC/PCD is also challenging. Since most existing schemes focus on scenarios involving one prover, they only need to provide zero knowledge for the final verifier by applying a general-purpose zkSNARK at the end of IVC. While for IVC/PCD run by multiple distrusting parties, zero knowledge between each two parties is not guaranteed. Such defect prevents a wider range of applications in privacy-preserving scenarios, such as anonymous De-Fi, confidential transactions, and trustless cross-chain bridges <em>[38, 12, 36]</em>. Based on the theorems given by Bünz et al. <em>[14]</em>, it is efficient to compile any Non-Interactive Argument of Knowledge (NARK) with a folding/accumulation scheme into PCD. Two more conditions are required for further constructing zero-knowledge PCD: (1) the folding/accumulation scheme is zero-knowledge, and (2) the NARK itself is zero-knowledge. The predicament here is that transforming NARK instances into zero-knowledge forms with masking values requires an extra inefficient process with expensive prover cost and cross terms. Section 4.3 elaborates on this predicament with concrete examples.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Our Motivation.</h4>

    <p class="text-gray-300">Upon the research status described above, we develop our motivation in two steps. First, can we build a non-uniform multi-folding scheme without cross terms? If so, can we efficiently construct zero-knowledge PCD from the folding scheme?</p>

    <p class="text-gray-300">We answer all questions above positively and present KiloNova, a non-uniform zero-knowledge PCD from generic folding schemes. To achieve this, we make theory and systems contributions as follows. (1) We introduce a relaxed CCS relation with only linear claims on instance-witness pairs and structures. (2) We build a non-uniform multi-folding scheme without cross terms from the relaxed CCS relation. (3) We propose a new construction for zero-knowledge PCD and construct KiloNova based on the non-interactive folding scheme. We also mention some optimization techniques for enhancing the performance of the folding scheme and PCD. Each of these contributions is elaborated below.</p>

    <p class="text-gray-300">(1) Relaxed CCS Relations. Motivated by Nova [26], and HyperNova [25], we introduce a new relaxed CCS relation called Atomic CCS (ACCS) to enable our folding scheme to efficiently deal with non-uniform circuits. Similar to the linearized committed CCS relation in HyperNova, this new ACCS relation is also reduced from the original CCS relation [31] by partially running an "early stopping" version of SuperSpartan [25]. The difference is that our protocol runs an extra round of sum-check protocol than HyperNova, which stops right before compiling the polynomial Oracle queries for the second sum-check protocol, as illustrated in Figure 1. Thus, the obtained ACCS instances as input of the folding schemes contain independent linear claims on instance-witness pairs and structures, enabling an efficient protocol of folding multiple non-uniform instances without cross terms.</p>

    <p class="text-gray-300">(2) Generic Folding Schemes. Based on the atomic CCS relations, we design a multi-folding scheme for multiple non-uniform CCS instances, which is denoted as the generic folding scheme. Generally speaking, the generic folding scheme runs the SuperSpartan protocol for each CCS instance in parallel and aggregates their sum-check protocols into one, except for the final Oracle queries. The remaining expensive query operations are folded and formalized as one atomic CCS instance, and its verification is "deferred" to the final verifier. Therefore, the recursive circuit at each step only contains the cheap verification of folding, while does not include the expensive verification of the final atomic CCS instance. The following theorem captures its cryptographic and efficiency characteristics. Since the folding scheme is public coin, it can be transformed</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1: Illustrations for Atomic CCS relations. Assume the input CCS relation is encoded as a multi-variate polynomial on variables of vectors  <span class="math">\\pmb{x}, \\pmb{y}</span> . The ACCS relation is derived from the claims output by the second sum-check protocol on  <span class="math">\\pmb{y}</span> .</p>

    <p class="text-gray-300">into a non-interactive version in the random oracle model according to the Fiat-Shamir heuristic <em>[21]</em>.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">There exists a constant-round, public-coin folding scheme for multiple <span class="math">N</span>-sized CCS instances with non-uniform circuit “structures” (i.e., CCS coefficient matrices), the prover’s work is <span class="math">O_{\\lambda}(s\\cdot N)</span>, and the verifier’s work and the communication are both <span class="math">O_{\\lambda}(\\log N)</span>, assuming the existence of any additively-homomorphic commitment scheme that provides <span class="math">O_{\\lambda}(1)</span>-sized commitments to <span class="math">N</span>-sized vectors over <span class="math">\\mathbb{F}</span> (e.g., Pedersen’s commitments), where <span class="math">\\lambda</span> is the security parameter and <span class="math">s</span> is the number of instances.</p>

    <p class="text-gray-300">For the purpose of building zero-knowledge PCD, we further derive a zero-knowledge version of the generic folding scheme with several existing techniques. First, we adopt an existing approach to ensure zero knowledge for sum-check protocols <em>[17]</em>. Second, for the intermediate non-linear claims in the folding schemes, we utilize the random padding technique in <em>[9]</em> to avoid extra computation and cross terms. Finally, we need an extra random instance for masking the output atomic CCS instance.</p>

    <p class="text-gray-300">(3) New Constructions of Zero-Knowledge PCD. Based on the generic folding schemes, it is feasible to obtain a non-uniform PCD according to the previous constructions <em>[15, 26]</em>, which enables runtime circuit selection with the proving cost and recursive overhead independent of the sizes of “uninvoked” circuits. However, the previous theorem in <em>[15]</em> additionally requires a zero-knowledge NARK for the construction of zero-knowledge PCD. As discussed above, it is inefficient to transform the CCS relation into zero-knowledge versions. To solve this problem, we modify the construction of PCD by splitting the task for each recursive step into two independent circuits as shown in Figure 2. This modification allows the prover to first transform the CCS instances into zero-knowledge atomic CCS instances by reusing our generic folding scheme rather than introducing an extra costly protocol. This new approach removes the requirement of a zero-knowledge NARK in the construction of zero-knowledge PCD. It can also be applied to existing IVC systems to achieve zero-knowledge. We summarize the new construction model as a theorem below.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">(informal). There is an efficient construction that compiles any NARK with a zero-knowledge folding/accumulation scheme into zero-knowledge PCD. Additionally, if the folding/accumulation scheme is post-quantum secure, then PCD is also post-quantum secure.</p>

    <p class="text-gray-300">This new construction yields a zero-knowledge and non-uniform PCD as Kilo-Nova. Furthermore, we propose an optimization technique to solve a potential efficiency problem existing in the non-uniform PCD: the increasing cost of dealing with the non-uniform structures. Our technique delegates the computation</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Nova's construction for IVC</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Our new construction for ZK IVC/PCD Fig. 2: Comparison between previous construction (left) and our construction (right). The recursive circuit is split into two parts for incremental computation  <span class="math">F</span>  and folding scheme verification Multi-Fold.  <span class="math">\\mathcal{V}</span>  in the right-side construction. The first part of  <span class="math">F</span>  is written into a new instance-witness pair as  <span class="math">(\\mathsf{u}&#x27;,\\mathsf{w}&#x27;)</span> , which is folded into zero-knowledge pair  <span class="math">(U_{i + 1},W_{i + 1})</span>  by the Multi-Fold.  <span class="math">\\mathcal{P}</span> . Plus, the zero-knowledge folding scheme also ensures the pair  <span class="math">(u_{i + 1},w_{i + 1})</span>  is zero-knowledge.</p>

    <p class="text-gray-300">of structure folds (folding atomic CCS matrices) to a more powerful third party that runs an extra IVC in parallel, thereby reducing the proving and communication costs for nodes in the PCD.</p>

    <p class="text-gray-300">In this part, we present a comprehensive evaluation of our generic folding scheme and zero-knowledge PCD and compare them to related work.</p>

    <p class="text-gray-300">Comparison with Existing Folding Schemes. We first compare features of our proposed generic folding scheme with other existing schemes in Table 1. Our scheme proves in the same CCS language as HyperNova [25], which is expressive to generalize Plonkish, R1CS, and AIR with high-degree constraints. Other expressive schemes, such as Protostar [13] and Protogalaxy [20], apply special sound protocols (SPS) to support high-degree constraints. In addition, our scheme efficiently supports both non-uniform circuits and multi-folding, which is only provided by Protogalaxy [20] currently. Although a recent work called UniPlonk [19] uniformizes the verifier's work in Plonk to allow Halo2 [11] and Nova [26] supporting non-uniform circuits, it is unknown whether it can be applied to systems based on multi-folding schemes. The last column indicates whether zero knowledge for IVC/PCD is achieved. Schemes that consider only one prover and apply zkSNARKs for proving the final IVC/PCD proofs, e.g., Nova [26], are not counted as zero-knowledge IVC/PCD. Therefore, BCLMS21 is the only scheme that provides zero knowledge among the schemes we compared. However, it does not support high-degree constraints and multi-folding.</p>

    <p class="text-gray-300">Table 1: Features comparison between existing folding/accumulation schemes</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Schemes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Language</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Non-uniform</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Multi-Folding</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ZK</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nova [26]</td>

            <td class="px-3 py-2 border-b border-gray-700">R1CS</td>

            <td class="px-3 py-2 border-b border-gray-700">No/Yes in [19]</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SuperNova [24]</td>

            <td class="px-3 py-2 border-b border-gray-700">R1CS</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HyperNova [25]</td>

            <td class="px-3 py-2 border-b border-gray-700">CCS</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

            <td class="px-3 py-2 border-b border-gray-700">No/Yes in [39]</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BCLMS21 [14]</td>

            <td class="px-3 py-2 border-b border-gray-700">R1CS</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Protostar [13]</td>

            <td class="px-3 py-2 border-b border-gray-700">Degree-d Plonk/CCS</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">No/Expensive</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Protogalaxy [20]</td>

            <td class="px-3 py-2 border-b border-gray-700">Degree-d Plonk/CCS</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KiloNova</td>

            <td class="px-3 py-2 border-b border-gray-700">CCS</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the theoretical performance of our generic folding scheme, we only compare it with state-of-the-art schemes, including HyperNova [25] and Protostar [13] as shown in Table 2. Note that the performance of our solution is close to HyperNova. For degree  <span class="math">d</span>  CCS instances with  <span class="math">m \\times n</span>  circuit matrices, the prover needs to compute a multi-scalar multiplication with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}<span class="math">  operations, where  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  denotes the number of non-zero elements in the witness. For the verifier cost, our scheme performs  </span>\\log m + \\log n<span class="math">  times more random-oracle-like hashes than HyperNova due to the additional  </span>\\log n<span class="math">  rounds in the second sum-check protocol. The performance of ProtoStar equals our computation, while its recursive overhead is minimal with only  </span>O(1)$  hashes. Moreover, KiloNova has more appealing features than the other two schemes, as we mentioned in Table 1. If we consider constructing non-uniform PCD that folds multiple instances with non-uniform structures, it is impractical to apply HyperNova and Protostar because their performance downgrades significantly.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Comparison with Existing PCDs. The above analysis demonstrates that our generic folding schemes outperform other schemes with more appealing features while retaining comparable complexity. Next, we compare the performance of the KiloNova built from this folding scheme with other PCDs.</p>

    <p class="text-gray-300">Comparison with BCLMS21. Bunz et al. introduce PCD in BCLMS21 [14] from the split accumulation scheme that accumulates the proof of a NARK for uniform R1CS relations. The verification cost of the obtained PCD is relatively high, requiring 10 multi-scalar multiplication (MSM) of size  <span class="math">m</span> , while KiloNova only requires 1 MSM. In terms of prover cost and recursive overhead, BCLM21 needs to handle  <span class="math">O(r)</span>  group operations with a larger coefficient than our scheme. However, it avoids logarithmic random oracle queries. Notably, BCLM21 does not support  <span class="math">d</span> -degree circuits and lookup operations.</p>

    <p class="text-gray-300">Comparison with Protogalaxy. Recently, another effective accumulation scheme named Protogalaxy [20] has been proposed. As the following-up work of Protostar [13], Protogalaxy reduces the cross terms from  <span class="math">O(d^{s})</span>  to  <span class="math">O(ds)</span>  when folding  <span class="math">s</span>  non-uniform instances and requires only  <span class="math">O(1)</span>  random oracle queries. While Protogalaxy appears being a promising primitive for constructing non-uniform PCD, it faces challenges in explicit constructions. First, it needs to handle cross</p>

    <p class="text-gray-300">Table 2: Performance comparison between different folding/accumulation schemes</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Criteria</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">KiloNova</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">HyperNova [25]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Protostar [13]</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prover</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">d log2 d) F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">d log2 d) F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">d log2 d) F</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verifier</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G</td>

            <td class="px-3 py-2 border-b border-gray-700">3 G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">log m + log n RO</td>

            <td class="px-3 py-2 border-b border-gray-700">log m RO</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1) RO</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(d log m) F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(d log m) F</td>

            <td class="px-3 py-2 border-b border-gray-700">(d + O(1)) F</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">items with Lagrange bases, yielding a quasi-linear prover cost with instance number  <span class="math">s</span>  and degree  <span class="math">d</span>  while ours is linear. Besides, the prover cost is still constantly higher than our work because of computing extra  <span class="math">s</span>  evaluations on  <span class="math">\\widetilde{eq}(\\cdot)</span> . Second, Protogalaxy does not support circuit aggregation as we proposed in Section 5.2 since the instances being folded are still non-linear. Lastly, the authors of Protogalaxy neither provide constructions for non-uniform PCD nor add zero knowledge, whereas KiloNova presents explicit descriptions and solves the potential technical problems.</p>

    <p class="text-gray-300">Concurrent work. In a paper concurrent with this work, Zhou et al. also construct a PCD with a multi-folding scheme extended on HyperNova. However, their work seems to be a complementary work for HyperNova and thus lack theoretical contributions. Compared to KiloNova, their PCD supports neither non-uniform circuits nor zero knowledge.</p>

    <p class="text-gray-300">In this paper, we use  <span class="math">\\lambda</span>  to denote the security parameter. Accordingly,  <span class="math">\\mathrm{negl}(\\lambda)</span>  denotes an unspecified function that is negligible in  <span class="math">\\lambda</span> . We denote by  <span class="math">[n]</span>  the set  <span class="math">\\{1,\\dots,n\\} \\subseteq \\mathbb{N}</span> . Let  <span class="math">\\mathbb{F}</span>  denote a finite field, e.g.,  <span class="math">\\mathbb{F}_p</span>  is a prime field for a large prime  <span class="math">p</span> . The bold-type lower-case letters denote vectors, e.g.,  <span class="math">\\boldsymbol{a} \\in \\mathbb{F}^n</span>  is a vector of elements  <span class="math">a_1,\\ldots,a_n \\in \\mathbb{F}</span> .  <span class="math">\\boldsymbol{a}[i]</span>  is also used to denote the  <span class="math">i</span> -th element of  <span class="math">\\boldsymbol{a}</span>  when the element is not specified with a concrete value. To represent a set, we use  <span class="math">\\{a_i\\}_{i=1}^n</span>  as a short-hand for  <span class="math">\\{a_1,\\dots,a_n\\}</span> . For a finite set  <span class="math">S</span> , let  <span class="math">x \\gets \\# S</span>  denote sampling  <span class="math">x</span>  from  <span class="math">S</span>  uniformly at random. We use "PPT algorithms" to refer to "Probabilistic Polynomial Time Algorithms".</p>

    <p class="text-gray-300">We recall some basic definitions for polynomials from [30] as follows. Let  <span class="math">f(\\cdot): \\mathbb{F}^n \\to \\mathbb{F}</span>  be a multivariate polynomial with  <span class="math">n</span>  input elements over  <span class="math">\\mathbb{F}</span> , its total de</p>

    <p class="text-gray-300">ree <span class="math">d</span> is defined as the maximum degree over all monomials in <span class="math">f(\\cdot)</span>. Moreover, the degree of a polynomial in a specified variable <span class="math">x_{i}</span> is the maximum exponent that <span class="math">x_{i}</span> takes in any of the monomials in <span class="math">f(\\cdot)</span>. Particularly, a multivariate polynomial is a <em>multilinear</em> polynomial if the degree of the polynomial in each variable is at most one. To keep consistent with our notation of vectors, we use <span class="math">f(\\bm{x})</span> to denote the polynomial <span class="math">f(\\cdot)</span> with the specified input variable as vector <span class="math">\\bm{x}</span>. Next, we state the lemmas used in our paper.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Lemma 1 (Multilinear extensions <em>[33]</em>)</h6>

    <p class="text-gray-300">Let <span class="math">f(\\cdot):\\{0,1\\}^{n}\\to\\mathbb{F}</span> be a function that maps <span class="math">n</span>-bit elements into an element of <span class="math">\\mathbb{F}</span>. The multilinear extension of <span class="math">f(\\cdot)</span> is a unique multilinear <span class="math">n</span>-variate polynomial <span class="math">\\tilde{f}(\\cdot):\\mathbb{F}^{n}\\to\\mathbb{F}</span> such that <span class="math">\\tilde{f}(\\bm{x})=f(\\bm{x})</span> for all <span class="math">\\bm{x}\\in\\{0,1\\}^{n}</span>, which can be computed as follows.</p>

    <p class="text-gray-300"><span class="math">\\tilde{f}(\\bm{x})=\\sum_{\\bm{e}\\in\\{0,1\\}^{n}}f(\\bm{e})\\cdot\\widetilde{eq}(\\bm{x},\\bm{e}),</span></p>

    <p class="text-gray-300">where <span class="math">\\widetilde{eq}(\\bm{x},\\bm{e})=\\prod_{i=1}^{n}(x_{i}\\cdot e_{i}+(1-x_{i})\\cdot(1-e_{i}))</span>.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Lemma 2 (Schwartz-Zippel lemma <em>[29]</em>)</h6>

    <p class="text-gray-300">Assume <span class="math">f(\\cdot):\\mathbb{F}^{n}\\to\\mathbb{F}</span> is a non-zero <span class="math">n</span>-variate polynomial of degree at most <span class="math">d</span>. Then on any finite set <span class="math">S\\subseteq\\mathbb{F}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\bm{x}\\leftarrow\\boxplus S^{n}}[f(\\bm{x}=0)\\leq d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">],$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\bm{x}</span> is a randomly sampled vector from <span class="math">S^{n}</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the size of </span>S$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">2.3 Sum-check Protocol</h3>

    <p class="text-gray-300">The sum-check protocol is an interactive proof proposed by Lund et al. <em>[27]</em>. It has long attracted the attention of practitioners for its desirable performance, especially in a recent study on proof systems with linear proving time <em>[30, 37]</em>. Here, we only briefly review it. More technical details can be referred to <em>[30]</em>.</p>

    <p class="text-gray-300">Assume <span class="math">f(\\cdot):\\mathbb{F}^{n}\\to\\mathbb{F}</span> as an <span class="math">n</span>-variate low-degree polynomial with the maximum degree of <span class="math">d</span> for each variable. The prover wants to convince the verifier of the following claim:</p>

    <p class="text-gray-300"><span class="math">\\text{sum}=\\sum_{x_{1}\\in\\{0,1\\}}\\sum_{x_{2}\\in\\{0,1\\}}\\cdots\\sum_{x_{n}\\in\\{0,1\\}}f(x_{1},...,x_{n}).</span> (1)</p>

    <p class="text-gray-300">To conduct this protocol with logarithmic verifier cost, the verifier chooses a random vector <span class="math">\\bm{r}\\in\\mathbb{F}^{n}</span> as the challenges for the <span class="math">n</span>-round interactions with the prover. At the final step, the verifier outputs a claim about the evaluation <span class="math">f(\\bm{r})</span>, i.e., <span class="math">c\\leftarrow\\Pi_{\\text{sc}}(f,n,d,\\text{sum},\\bm{r})</span>. If <span class="math">c=f(\\bm{r})</span> holds, then the verifier is convinced of the claim about the sum of <span class="math">f(\\cdot)</span> in Equation (1). According to previous work <em>[27, 30]</em>, the sum-check protocol satisfies both completeness and soundness properties, and its communication cost takes <span class="math">O(n\\cdot d)</span> element of <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2.4 Polynomial Commitment Scheme</p>

    <p class="text-gray-300">We adapt the definition of the polynomial commitment scheme from <em>[x1]</em>.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 1 (Polynomial commitment (PC)).</h6>

    <p class="text-gray-300">A polynomial commitment (PC) scheme for multilinear polynomials is defined as a tuple of four protocols <span class="math">\\mathsf{PC}=(\\mathsf{Gen},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Eval})</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Gen}(1^{\\lambda},\\ell)\\to\\mathsf{pp}</span>: takes as input <span class="math">\\ell</span> (the number of variables in a multilinear polynomial); produces public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">\\mathsf{Commit}(\\mathsf{pp},f)\\to C</span>: takes as input an <span class="math">\\ell</span>-variate multilinear polynomial <span class="math">f:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span>; produces a commitment <span class="math">C</span>.</li>

      <li><span class="math">\\mathsf{Open}(\\mathsf{pp},C,f)\\to b</span>: verifies the opening of commitment <span class="math">C</span> to the <span class="math">\\ell</span>-variate multilinear polynomial <span class="math">f</span>; outputs <span class="math">b\\in\\{0,1\\}</span>.</li>

      <li><span class="math">\\mathsf{Eval}(\\mathsf{pp},C,\\bm{x},y,\\ell,f)\\to b</span> is a protocol between a PPT prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span>. Both <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> hold a commitment <span class="math">C</span>, the number of variables <span class="math">\\ell</span>, a scalar <span class="math">y\\in\\mathbb{F}</span>, and <span class="math">\\bm{x}\\in\\mathbb{F}^{\\ell}</span>. <span class="math">\\mathcal{P}</span> additionally knows an <span class="math">\\ell</span>-variate multilinear polynomial <span class="math">f</span>. <span class="math">\\mathcal{P}</span> attempts to convince <span class="math">\\mathcal{V}</span> that <span class="math">f(\\bm{x})=y</span>. At the end of the protocol, <span class="math">\\mathcal{V}</span> outputs <span class="math">b\\in\\{0,1\\}</span>.</li>

    </ul>

    <p class="text-gray-300">A PC is an extractable polynomial commitment scheme for multilinear polynomials over a finite field <span class="math">\\mathbb{F}</span> if it satisfies completeness, binding, and knowledge soundness properties as defined in Appendix A.1.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">A polynomial commitment scheme for multilinear polynomials <span class="math">\\mathsf{PC}=(\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Eval})</span> is additively homomorphic if for all <span class="math">\\ell</span> and public parameters <span class="math">\\mathsf{pp}</span> produced from <span class="math">\\mathsf{Setup}(1^{\\lambda},\\ell)</span>, and for any <span class="math">f_{1},f_{2}:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span>, <span class="math">\\mathsf{Commit}(\\mathsf{pp},f_{1})+\\mathsf{Commit}(\\mathsf{pp},f_{2})=\\mathsf{Commit}(\\mathsf{pp},f_{1}+f_{2})</span>.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">2.5 Proof-Carrying Data</h3>

    <p class="text-gray-300">In this paper, we adopt the definition of PCD from <em>[14, 39]</em>. We start with defining some necessary terminologies before presenting the definition.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Definition 3.</h6>

    <p class="text-gray-300">A <em>transcript</em> <span class="math">\\mathsf{T}</span> is a directed acyclic graph with each vertex <span class="math">u\\in V(\\mathsf{T})</span> labeled by local data <span class="math">z^{(u)}_{\\mathsf{loc}}</span> and each edge <span class="math">e\\in E(\\mathsf{T})</span> labeled by a message <span class="math">z^{(e)}\\neq\\bot</span>. The output <span class="math">o(\\mathsf{T})</span> of a transcript <span class="math">\\mathsf{T}</span> is a message <span class="math">z^{(e)}</span> where <span class="math">e=(u,v)</span> is the lexicographically-first edge such that <span class="math">v</span> is a sink.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Definition 4.</h6>

    <p class="text-gray-300">A vertex <span class="math">u\\in V(\\mathsf{T})</span> is <span class="math">\\varphi</span>-compliant for <span class="math">\\varphi\\in\\mathsf{F}</span> if for all outgoing edges <span class="math">e=(u,v)\\in E(\\mathsf{T})</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(base case) if <span class="math">u</span> has no incoming edges, <span class="math">\\varphi(z^{(e)},z^{(u)}_{\\mathsf{loc}},\\bot,...,\\bot)</span> accepts,</li>

      <li>(recursive case) if <span class="math">u</span> has incoming edges <span class="math">e_{1},...,e_{m}</span>, <span class="math">\\varphi(z^{(e)},z_{\\mathsf{loc}^{(u)}},z^{(e_{1})},...,z^{(e_{m})})</span> accepts.</li>

    </ul>

    <p class="text-gray-300">We say that <span class="math">\\mathsf{T}</span> is <span class="math">\\varphi</span>-compliant if all of its vertices are <span class="math">\\varphi</span>-compliant.</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Definition 5 (Proof-Carrying Data <em>[39]</em>).</h6>

    <p class="text-gray-300">A proof-carrying data scheme for a class of compliance predicates <span class="math">\\mathsf{F}</span> is a tuple of algorithms <span class="math">\\mathsf{PCD}=(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(1^{\\lambda})\\to\\mathsf{pp}</span> on input security parameter <span class="math">\\lambda</span>, samples and outputs public parameter <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">\\mathcal{K}(\\mathsf{pp},\\varphi)\\to(\\mathsf{pk},\\mathsf{vk})</span> on input public parameter <span class="math">\\mathsf{pp}</span> and a compliance predicate <span class="math">\\varphi\\in\\mathsf{F}</span>, outputs a prover key <span class="math">\\mathsf{pk}</span> and a verifier key <span class="math">\\mathsf{vk}</span>.</li>

      <li><span class="math">\\mathcal{P}(\\mathsf{pk},z,z_{\\mathsf{loc}},\\{z_{i},\\Pi_{i}\\}_{i=1}^{r})\\to\\Pi</span> on input public key <span class="math">\\mathsf{pk}</span>, message <span class="math">z</span> of an outgoing edge, local data <span class="math">z_{\\mathsf{loc}}</span>, messages <span class="math">\\{z_{i}\\}_{i\\in[r]}</span> of incoming edges and their corresponding proofs <span class="math">\\{\\Pi_{i}\\}_{i\\in[r]}</span>, outputs a new proof <span class="math">\\Pi</span> to attest the correctness of <span class="math">z</span>.</li>

      <li><span class="math">\\mathcal{V}(\\mathsf{vk},z,\\Pi)\\to 0/1</span> on input verifier key <span class="math">\\mathsf{vk}</span>, message <span class="math">z</span> and proof <span class="math">\\Pi</span>, outputs <span class="math">0/1</span> to reject or accept.</li>

    </ul>

    <p class="text-gray-300">A proof-carrying data scheme PCD should satisfy the perfect completeness, knowledge soundness, and zero-knowledge properties described in Appendix A.2.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">2.6 Customizable Constraint Systems</h3>

    <p class="text-gray-300">The customizable constraint system (CCS) is an intermediate representation of arithmetic circuits introduced by Setty et al. <em>[31]</em>, which can simultaneously generalize R1CS, Plonkish, and AIR without overheads. However, directly implementing the CCS relation into a zero-knowledge proof is neither straightforward nor efficient. For modern SNARKs, practitioners usually combine a polynomial IOP <em>[16]</em> with a polynomial commitment scheme <em>[23]</em>. Therefore, encoding the CCS relation into low-degree polynomials and committing them correspondingly will accommodate it to a more friendly form for building zero-knowledge proofs. To fulfill these requirements, we present the definitions of the CCS relation and committed CCS relation following HyperNova <em>[25]</em> in this part.</p>

    <p class="text-gray-300">Consider a CCS structure <span class="math">\\mathcal{S}=(m,n,N,l,t,q,d,\\{M_{j}\\}_{j\\in[t]},\\{S_{i}\\}_{i\\in[q]},\\{c_{i}\\}_{i\\in[q]})</span>. Let <span class="math">s_{x}=\\log m</span> and <span class="math">s_{y}=\\log n</span>. We interpret each <span class="math">M_{j}</span> (for <span class="math">j\\in[t]</span>) as functions with the following mapping: <span class="math">\\{0,1\\}^{s_{y}}\\times\\{0,1\\}^{s_{y}}\\to\\mathbb{F}</span>. For <span class="math">j\\in[t]</span>, let <span class="math">\\widetilde{M}_{j}</span> denote the multilinear extension (MLE) of <span class="math">M_{j}</span> i.e., <span class="math">\\widetilde{M}_{j}</span> is the unique multilinear polynomial in <span class="math">s_{x}+s_{y}</span> variables such that</p>

    <p class="text-gray-300"><span class="math">\\widetilde{M}_{j}(\\bm{x},\\bm{y})=M_{j}(\\bm{x},\\bm{y}),\\forall\\bm{x}\\in\\{0,1\\}^{s_{x}},\\bm{y}\\in\\{0,1\\}^{s_{y}}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similarly, for a purported witness <span class="math">\\bm{\\mathsf{w}}\\in\\mathbb{F}^{n-l-1}</span>, let <span class="math">\\widetilde{w}</span> denote the unique MLE of <span class="math">\\bm{\\mathsf{w}}</span> viewed as a function. WLOG, let $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{\\mathsf{w}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=l+1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For ease of exposition, a CCS relation <span class="math">\\mathcal{R}</span> should be defined over public parameters, structure, instance, and witness tuples. Specifically, a structure <span class="math">\\mathcal{S}</span> describes constraints and an “instance” consisting of the public input and output where a “witness” should satisfy. We only define the committed CCS (CCCS) relation as below. The definition of the CCS relation is given in Appendix A.3.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Definition 6 (Committed CCS)</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{PC}=(\\mathsf{Gen},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Eval})</span> denote an additively-homomorphic polynomial commitment scheme for multilinear polynomials over a finite field <span class="math">\\mathbb{F}</span>. Denote the public parameters of size bounds as <span class="math">m,n,N,l,t,q,d\\in\\mathbb{N}</span> where <span class="math">n=2\\cdot(l+1)</span> and <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Gen}(1^{\\lambda},s_{y})</span>. The committed customizable constraint system (CCCS) relation <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span> is defined as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span> structure <span class="math">\\mathcal{S}</span> consists of:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a sequence of sparse multilinear polynomials in <span class="math">s_{x}+s_{y}</span> variables <span class="math">\\{\\widetilde{M}_{j}\\}_{j\\in[t]}</span> such that they evaluate to a non-zero value in at most <span class="math">N=\\Omega(m)</span> locations over the Boolean hypercube <span class="math">\\{0,1\\}^{s_{x}}\\times\\{0,1\\}^{s_{y}}</span>.</li>

      <li>a sequence of <span class="math">q</span> multisets <span class="math">\\{S_{i}\\}_{i\\in[q]}</span>, where an element in each multiset is from the domain <span class="math">\\{1,...,t\\}</span> and the cardinality of each multiset is at most <span class="math">d</span>.</li>

      <li>a sequence of <span class="math">q</span> constants <span class="math">\\{c_{i}\\}_{i\\in[q]}</span>, where each constant is from <span class="math">\\mathbb{F}</span>.</li>

      <li>A <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span> instance is <span class="math">(C,\\mathbf{i}\\mathbf{o})</span> where <span class="math">C</span> is a commitment to a multilinear polynomial in <span class="math">s_{y}-1</span> variables and <span class="math">\\mathbf{i}\\mathbf{o}\\in\\mathbb{F}^{l}</span>.</li>

      <li>A <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span> witness consists of a multilinear polynomial <span class="math">\\widetilde{\\mathbf{w}}</span> in <span class="math">s_{y}-1</span> variables.</li>

    </ul>

    <p class="text-gray-300">A <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span> instance with structure <span class="math">\\mathcal{S}</span> is satisfied by a <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span> witness if <span class="math">\\mathsf{Commit}(\\mathsf{pp},\\widetilde{\\mathbf{w}})=C</span> and if for all <span class="math">\\mathbf{x}\\in\\{0,1\\}^{s_{x}}</span>,</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in[q]}c_{i}\\left(\\prod_{j\\in S_{i}}\\left(\\sum_{\\mathbf{y}\\in\\{0,1\\}^{s_{y}}}\\widetilde{M}_{j}(\\mathbf{x},\\mathbf{y})\\cdot\\tilde{z}(\\mathbf{y})\\right)\\right)=0,</span> (2)</p>

    <p class="text-gray-300">where <span class="math">\\tilde{z}(\\mathbf{y})</span> is an <span class="math">s_{y}</span>-variate multilinear polynomial such that <span class="math">\\tilde{z}(\\mathbf{y})=\\widetilde{(\\mathbf{w},1,\\mathbf{i}\\mathbf{o})}</span> for all <span class="math">\\mathbf{y}\\in\\{0,1\\}^{s_{y}}</span>.</p>

    <h2 id="sec-27" class="text-2xl font-bold">3 Building Blocks</h2>

    <p class="text-gray-300">In this section, we describe several essential building blocks for the design of KiloNova. First, we extend the multi-folding scheme introduced in HyperNova <em>[25]</em> to support non-uniform circuit scenarios. The new model is called a <em>generic folding scheme</em>. Next, we derive a new “relaxed” relation called <em>atomic CCS relation</em> from the SuperSpartan protocol to remove the cross terms generated in the generic folding schemes.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">3.1 Generic Folding Schemes</h3>

    <p class="text-gray-300">Recall that a folding scheme <em>[x13]</em> for a relation <span class="math">\\mathcal{R}</span> is a protocol between a prover and a verifier that reduces the task of checking two instances in <span class="math">\\mathcal{R}</span> with the <em>same</em> structure <span class="math">\\mathcal{S}</span> into the task of checking a single folded instance in <span class="math">\\mathcal{R}</span> also with structure <span class="math">\\mathcal{S}</span>. Then in HyperNova, the authors introduce a generalization of folding schemes as multi-folding schemes, which can fold two collections of instances in relations <span class="math">\\mathcal{R}^{(1)}</span> and <span class="math">\\mathcal{R}^{(2)}</span> with the <em>same</em> structure <span class="math">\\mathcal{S}</span> respectively.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">This paper extends the multi-folding scheme to allow it to fold relations with different structures. Concretely, a generic folding scheme is defined with respect to a set of relations  <span class="math">\\{\\mathcal{R}^{(i)}\\}_{i = 1}^{\\ell}</span>  with different structures  <span class="math">\\{S^{(i)}\\}_{i = 1}^{\\ell}</span>  and size parameters  <span class="math">\\{s^{(i)}\\}_{i = 1}^{\\ell}</span>  (the number of repetition for each  <span class="math">S^{(i)}</span> ). It is an interactive protocol between a prover and a verifier that reduces the task of checking a collection of  <span class="math">s^{(i)}</span>  instances in  <span class="math">\\mathcal{R}^{(i)}</span>  for all  <span class="math">i\\in [\\ell ]</span>  ( <span class="math">\\sum_{i\\in [\\ell ]}s^{(i)}</span>  instances in total) into checking a single folded instance in  <span class="math">\\mathcal{R}^<em></span>  with structure  <span class="math">S^{</em>}</span> . We formally define it below.</p>

    <p class="text-gray-300">Definition 7 (Generic folding schemes). Consider relations  <span class="math">\\{\\mathcal{R}^{(i)}\\}_{i = 1}^{\\ell}</span>  over public parameters, structures, instance, and witness tuples such that each  <span class="math">\\mathcal{R}^{(i)}</span>  has distinct structure  <span class="math">S^{(i)}</span> . A generic folding scheme for  <span class="math">\\{(\\mathcal{R}^{(i)},s^{(i)})\\}_{i = 1}^{\\ell}</span>  consists of a PPT generator algorithm  <span class="math">\\mathcal{G}</span> , a deterministic encoder algorithm  <span class="math">\\mathcal{K}</span> , and a pair of PPT algorithms  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  denoting the prover and the verifier respectively, with the following interface:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(1^{\\lambda})\\to \\mathsf{pp}</span> : on input security parameter  <span class="math">\\lambda</span> , samples public parameters  <span class="math">\\mathsf{pp}</span> .</li>

      <li><span class="math">\\mathcal{K}(\\mathsf{pp},\\{\\mathcal{S}^{(i)}\\}_{i = 1}^{\\ell})\\to (\\mathsf{pk},\\mathsf{vk})</span>  : on input pp, and common structures  <span class="math">\\{\\mathcal{S}^{(i)}\\}_{i = 1}^{\\ell}</span>  among the instances to be folded, outputs a prover key pk and a verifier key vk.</li>

      <li><span class="math">\\mathcal{P}(\\mathsf{pk},\\{\\mathcal{S}^{(i)},\\mathbf{u}^{(i)},\\mathbf{w}^{(i)}\\}_{i = 1}^{\\ell})\\to (\\mathcal{S}^{<em>},\\mathbf{u}^{</em>},\\mathbf{w}^{<em>})</span>  : on input  <span class="math">\\ell</span>  vectors of instances  <span class="math">\\{\\mathbf{u}^{(i)}\\}_{i = 1}^{\\ell}</span> , where each vector  <span class="math">\\mathbf{u}^{(i)}</span>  is in  <span class="math">\\mathcal{R}^{(i)}</span>  with a distinct structure  <span class="math">\\mathcal{S}^{(i)}</span> , and corresponding vector of witnesses  <span class="math">\\mathbf{w}^{(i)}</span>  for  <span class="math">i\\in [\\ell]</span> , outputs a folded instance-witness pair  <span class="math">(\\mathbf{u}^{</em>},\\mathbf{w}^{<em>})</span>  in a new relations  <span class="math">\\mathcal{R}^</em></span>  with structure  <span class="math">\\mathcal{S}^*</span> .</li>

      <li><span class="math">\\mathcal{V}(\\mathsf{vk},\\{\\mathcal{S}^{(i)},\\mathbf{u}^{(i)}\\}_{i = 1}^{\\ell})\\to (\\mathcal{S}^{<em>},\\mathbf{u}^{</em>})</span>  : on input  <span class="math">\\ell</span>  vectors of instances  <span class="math">\\{\\mathbf{u}^{(i)}\\}_{i = 1}^{\\ell}</span>  outputs a folded instance  <span class="math">\\mathbf{u}^<em></span>  in a new relations  <span class="math">\\mathcal{R}^</em></span>  with structure  <span class="math">\\mathcal{S}^*</span> .</li>

    </ul>

    <p class="text-gray-300">Let  <span class="math">\\Pi_{\\mathrm{fold}}</span>  denote the interaction between  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span> . Then  <span class="math">\\Pi_{\\mathrm{fold}}</span>  is a function that takes as input  <span class="math">((\\mathsf{pk},\\mathsf{vk}),\\{(\\mathcal{S}^{(i)},\\mathbf{u}^{(i)},\\mathbf{w}^{(i)})\\}_{i = 1}^{\\ell})</span>  and runs the interaction on prover input  <span class="math">(\\mathsf{pk},\\{(\\mathcal{S}^{(i)},\\mathbf{u}^{(i)},\\mathbf{w}^{(i)})\\}_{i = 1}^{\\ell})</span>  and verifier input  <span class="math">(\\mathsf{vk},\\{\\mathcal{S}^{(i)},\\mathbf{u}^{(i)}\\}_{i = 1}^{\\ell})</span> . At the end of interaction  <span class="math">\\Pi_{\\mathrm{fold}}</span>  outputs  <span class="math">(\\mathbf{u}^{<em>},\\mathbf{w}^{</em>})</span>  where  <span class="math">\\mathbf{u}^{<em>}</span>  is the verifier's output folded instance, and  <span class="math">\\mathbf{w}^{</em>}</span>  is the prover's output folded witness.</p>

    <p class="text-gray-300">We slightly abuse the vector-from denotation  <span class="math">(\\mathsf{pp},\\mathcal{S}^{(i)},\\mathbf{u}^{(i)},\\mathbf{w}^{(i)})\\in \\mathcal{R}^{(i)}</span>  to represent that  <span class="math">(\\mathsf{pp},\\mathcal{S}^{(i)},\\mathbf{u}_j^{(i)},\\mathbf{w}_j^{(i)})\\in \\mathcal{R}^{(i)}</span>  for all  <span class="math">j\\in [s^{(i)}]</span> . A generic folding scheme for  <span class="math">\\{\\mathcal{R}^{(i)}\\}_{i = 1}^{\\ell}</span>  satisfies the following requirements.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Perfect Completeness: For all PPT adversaries  <span class="math">\\mathcal{A}</span> , we have that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\{(p p, \\mathcal {S} ^ {(i)}, \\mathbf {u} ^ {(i)}, \\mathbf {w} ^ {(i)}) \\in \\mathcal {R} ^ {(i)} \\} _ {i = 1} ^ {\\ell} &amp;amp; \\begin{array}{c} p p \\leftarrow \\mathcal {G} (1 ^ {\\lambda}), \\\\ \\{\\mathcal {S} ^ {(i)}, \\mathbf {u} ^ {(i)}, \\mathbf {w} ^ {(i)} \\} _ {i = 1} ^ {\\ell} \\leftarrow \\mathcal {A} (p p), \\\\ \\Downarrow &amp;amp; \\begin{array}{c} (p k, v k) \\leftarrow \\mathcal {K} (p p, \\{\\mathcal {S} ^ {(i)} \\} _ {i = 1} ^ {\\ell}), \\\\ (\\mathcal {S} ^ {*}, \\mathbf {u} ^ {*}, \\mathbf {w} ^ {*}) \\\\ \\leftarrow \\Pi_ {\\text {f o l d}} ((p k, v k), \\{\\mathcal {S} ^ {(i)}, \\mathbf {u} ^ {(i)}, \\mathbf {w} ^ {(i)} \\} _ {i = 1} ^ {\\ell}) \\end{array} \\end{array} \\right] = 1.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge Soundness: For any expected polynomial-time adversaries  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{P}^<em></span> ,  <span class="math">\\Pi_{\\mathrm{fold}}^</em></span>  is run by  <span class="math">\\mathcal{P}^*, \\mathcal{V}</span> , there is an expected polynomial-time extractor</li>

    </ol>

    <p class="text-gray-300">Ext such that for all randomness  <span class="math">\\rho</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\Pr \\left[ \\{(p p, \\mathcal {S} ^ {(i)}, \\mathbf {u} ^ {(i)}, \\mathbf {w} ^ {(i)}) \\in \\mathcal {R} ^ {(i)} \\} _ {i = 1} ^ {\\ell} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} p p \\leftarrow \\mathcal {G} (1 ^ {\\lambda}), \\\\ (\\{\\mathcal {S} ^ {(i)}, \\mathbf {u} ^ {(i)} \\} _ {i = 1} ^ {\\ell}, \\mathrm {s t}) \\leftarrow \\mathcal {A} (p p, \\rho), \\\\ \\{\\mathbf {w} ^ {(i)} \\} _ {i \\in [ \\ell ]} \\leftarrow \\operatorname {E x t} (p p, \\rho) \\end{array} \\right. \\right] \\approx \\\\ \\Pr \\left[ \\begin{array}{l} (p p, \\mathcal {S} ^ {<em>}, \\mathbf {u} ^ {</em>}, \\mathbf {w} ^ {<em>}) \\in \\mathcal {R} ^ {</em>} \\end{array} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} p p \\leftarrow \\mathcal {G} (1 ^ {\\lambda}), \\\\ (\\{\\mathcal {S} ^ {(i)}, \\mathbf {u} ^ {(i)} \\} _ {i = 1} ^ {\\ell}, \\mathrm {s t}) \\leftarrow \\mathcal {A} (p p, \\rho), \\\\ (p k, \\mathrm {v k}) \\leftarrow \\mathcal {K} (p p, \\{\\mathcal {S} ^ {(i)} \\} _ {i = 1} ^ {\\ell}), \\\\ (\\mathcal {S} ^ {<em>}, \\mathbf {u} ^ {</em>}, \\mathbf {w} ^ {<em>}) \\leftarrow \\Pi_ {\\text {f o l d}} ^ {</em>} ((p k, \\mathrm {v k}), \\{\\mathcal {S} ^ {(i)}, \\mathbf {u} ^ {(i)} \\} _ {i = 1} ^ {\\ell}, \\mathrm {s t}) \\end{array} \\right. \\right]. \\right. \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Efficiency: The communication costs and  <span class="math">\\mathcal{V}</span> 's computation are lower in the case where  <span class="math">\\mathcal{V}</span>  participates in the generic folding scheme and then checks a witness sent by  <span class="math">\\mathcal{P}</span>  for the folded instance than in the case where  <span class="math">\\mathcal{V}</span>  checks witnesses sent by  <span class="math">\\mathcal{P}</span>  for each of the original instances.</li>

    </ol>

    <p class="text-gray-300">A generic folding scheme is secure in the random oracle model if the above requirements hold when all parties are provided access to a random oracle.</p>

    <p class="text-gray-300">Definition 8 (Honest Verifier Zero-knowledge). Let  <span class="math">\\mathrm{trace}(\\Pi_{\\mathrm{fold}},\\mathrm{input})</span>  denote the non-deterministic function which takes as input an interaction function  <span class="math">\\Pi_{\\mathrm{fold}}</span>  and a prescribed input input, and produces an interaction transcript between  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  on input. A generic folding scheme  <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>  for  <span class="math">\\{R^{(i)},s^{(i)}\\}_{i = 1}^{\\ell}</span>  satisfies honest verifier zero-knowledge if there exists a PPT simulator Sim such that for all PPT adversaries  <span class="math">\\mathcal{A}</span> , the following distributions are (statistically/computationally) indistinguishable</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} \\left. \\begin{array}{l} \\text {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}), \\\\ (\\{\\mathcal {S} ^ {(i)}, \\mathbf {u} ^ {(i)}, \\mathbf {w} ^ {(i)} \\} _ {i = 1} ^ {\\ell}) \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ \\{\\left(\\mathsf {p p}, \\mathcal {S} ^ {(i)}, \\mathbf {u} ^ {(i)}, \\mathbf {w} ^ {(i)}\\right) \\in \\mathcal {R} ^ {(i)} \\} _ {i = 1} ^ {\\ell}, \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, \\{\\mathcal {S} ^ {(i)} \\} _ {i = 1} ^ {\\ell}), \\\\ \\mathsf {t r} \\leftarrow \\mathsf {t r a c e} (\\Pi_ {\\mathsf {f o l d}}, ((\\mathsf {p k}, \\mathsf {v k}), \\{\\mathcal {S} ^ {(i)}, \\mathbf {u} ^ {(i)}, \\mathbf {w} ^ {(i)} \\} _ {i = 1} ^ {\\ell}) \\end{array} \\right\\} \\end{array} \\right.</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{ \\begin{array}{l} (\\mathsf {p p}, \\{\\mathcal {S} ^ {(i)}, \\mathbf {u} ^ {(i)} \\} _ {i = 1} ^ {\\ell}, \\mathsf {t r}) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (\\mathsf {p p}, \\tau) \\leftarrow \\mathsf {S i m} (1 ^ {\\lambda}), \\\\ (\\{\\mathcal {S} ^ {(i)}, \\mathbf {u} ^ {(i)} \\} _ {i = 1} ^ {\\ell}, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ \\{(\\mathsf {p p}, \\mathcal {S} ^ {(i)}, \\mathbf {u} ^ {(i)}, \\mathbf {w} ^ {(i)}) \\in \\mathcal {R} ^ {(i)} \\} _ {i = 1} ^ {\\ell}, \\\\ \\mathsf {t r} \\leftarrow \\mathsf {S i m} (\\mathsf {p p}, \\{\\mathcal {S} ^ {(i)}, \\mathbf {u} ^ {(i)} \\} _ {i = 1} ^ {\\ell}, \\tau) \\end{array} \\right. \\end{array} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Definition 9 (Non-interactive). A generic folding scheme  <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>  is noninteractive if the interaction between  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  consists of a single message from  <span class="math">\\mathcal{P}</span>  to  <span class="math">\\mathcal{V}</span> . This single message is denoted as  <span class="math">\\mathcal{P}</span> 's output and as  <span class="math">\\mathcal{V}</span> 's input.</p>

    <p class="text-gray-300">Definition 10 (Public coin). A generic folding scheme  <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>  is called public coin if all the messages sent from  <span class="math">\\mathcal{V}</span>  to  <span class="math">\\mathcal{P}</span>  are sampled from a uniform distribution.</p>

    <h2 id="sec-29" class="text-2xl font-bold">3.2 Atomic CCS Relations</h2>

    <p class="text-gray-300">In this part, we first introduce a relaxed CCS relation called atomic CCS that is amenable to constructing generic folding schemes. Different from the committed</p>

    <p class="text-gray-300">CCS relations or linearized committed CCS in <em>[25]</em>, this new variant is satisfied with linear constraints on structures (matrices) and instance-witness pairs, respectively. Therefore, folding multiple atomic CCS instances under different matrices does not produce any cross terms.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">Motivations.</h4>

    <p class="text-gray-300">Generally speaking, most of the current solutions reduce the cross terms with some “makeup” measures after the folding schemes, which adds extra cost for the prover and verifier sides. While we believe a more practical way is to take measures before the folding schemes to avoid the generation of cross terms. Inspired by this idea, we extend the approach in HyberNova <em>[25]</em>, which linearizes the high-degree CCS relation by running an “early stopping” version of SuperSpartan. To state it clearly, we need to first give a review of SuperSpartan. On input as a committed CCS instance, the prover and verifier in SuperSpartan rewrite it into a sum-check statement:</p>

    <p class="text-gray-300"><span class="math">\\sum_{\\bm{x}\\in\\{0,1\\}^{s_{x}}}\\widetilde{eq}(\\bm{\\alpha},\\bm{x})\\cdot\\sum_{i\\in[q]}c_{i}\\left(\\prod_{j\\in S_{i}}\\left(\\sum_{\\bm{y}\\in\\{0,1\\}^{s_{y}}}\\widetilde{M}_{j}(\\bm{x},\\bm{y})\\cdot\\tilde{z}(\\bm{y})\\right)\\right)=0</span> (3)</p>

    <p class="text-gray-300">where <span class="math">\\bm{\\alpha}</span> is a randomly sampled vector from <span class="math">\\mathbb{F}^{s_{x}}</span> and <span class="math">\\widetilde{eq}(\\bm{\\alpha},\\bm{x})</span> is added to reduce the <span class="math">s_{x}</span> constraints in <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span> to one sum constraint above. To check Equation (3), the prover and verifier run two rounds of sum-check protocols recursively on <span class="math">\\bm{x}</span> and <span class="math">\\bm{y}</span>. After the first round of the sum-check protocol, the verifier can check the final evaluation on <span class="math">\\bm{r}_{x}</span> with the following claims given by the prover:</p>

    <p class="text-gray-300"><span class="math">\\sum_{\\bm{y}\\in\\{0,1\\}^{s_{y}}}\\widetilde{M}_{j}(\\bm{r}_{x},\\bm{y})\\cdot\\tilde{z}(\\bm{y})=\\sigma_{j},\\ \\forall j\\in[t].</span> (4)</p>

    <p class="text-gray-300">where <span class="math">\\bm{r}_{x}</span> is the challenge vector generated among the protocol. These claims can be further checked by running <span class="math">t</span> sum-check protocols in parallel, and prover sends <span class="math">t+1</span> claims for the verifier to check the final evaluation:</p>

    <p class="text-gray-300">\\[ \\begin{cases}\\widetilde{M}_{j}(\\bm{r}_{x},\\bm{r}_{y})=\\theta_{j},\\ \\forall j\\in[t]\\\\ \\tilde{z}(\\bm{r}_{y})=\\epsilon\\end{cases}. \\] (5)</p>

    <p class="text-gray-300">Note that Equation (4) only contains polynomial <span class="math">\\tilde{z}(\\bm{y})</span> with degree of 1. For two instances with same structures <span class="math">\\{\\widetilde{M}_{j}\\}_{j=1}^{t}</span>, folding their claims in Equation (4) produces no cross terms. Therefore, HyperNova formalizes these claims as a restricted form of CCS, i.e., linearized committed CCS. To prevent cross terms in generic folding schemes, folding with the above linearized committed CCS instances is not sufficient. We further run the second round of sum-check protocol and obtain Equation (5). Note that Equation (5) contains claims on <span class="math">\\widetilde{M}_{j}(\\bm{r}_{x},\\bm{r}_{y}),j\\in[t]</span> and <span class="math">\\tilde{z}(\\bm{r}_{y})</span> separately with degree at most 1. As a result, folding these claims produces no cross terms, even for instances with different structures. We denote this new variant of CCS as Atomic CCS and formalize it in the following definition.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Definition 11 (Atomic CCS).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{PC}=(\\mathsf{Gen},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Eval})</span> denote an additively-homomorphic polynomial commitment scheme for multilinear polynomials over a finite field <span class="math">\\mathbb{F}</span>. Denote the public parameters of size bounds as <span class="math">m,n,N,l,t\\in\\mathbb{N}</span> where <span class="math">n=2\\cdot(l+1)</span> and <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Gen}(1^{\\lambda},s_{y}-1)</span>. The atomic customizable constraint system (ACCS) relation <span class="math">\\mathcal{R}_{\\mathsf{ACCS}}</span> is defined as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An <span class="math">\\mathcal{R}_{\\mathsf{ACCS}}</span> structure <span class="math">\\mathcal{S}</span> consists of a sequence of sparse multilinear polynomials in <span class="math">s_{x}+s_{y}</span> variables <span class="math">\\{\\widetilde{M}_{j}\\}_{j\\in[t]}</span> such that they evaluate to a non-zero value in at most <span class="math">N=\\Omega(m)</span> locations over the boolean hypercube <span class="math">\\{0,1\\}^{s_{x}}\\times\\{0,1\\}^{s_{y}}</span>.</li>

      <li>An <span class="math">\\mathcal{R}_{\\mathsf{ACCS}}</span> instance is <span class="math">(C,v_{0},\\mathbf{i}\\mathbf{o},\\bm{r}_{x},\\bm{r}_{y},v_{1},...,v_{t},v_{z})</span> where <span class="math">v_{0}\\in\\mathbb{F},\\mathbf{i}\\mathbf{o}\\in\\mathbb{F}^{l},\\bm{r}_{x}\\in\\mathbb{F}^{s_{x}},\\bm{r}_{y}\\in\\mathbb{F}^{s_{y}},v_{z}\\in\\mathbb{F},v_{j}\\in\\mathbb{F}</span> for all <span class="math">j\\in[t]</span>, and <span class="math">C</span> is a commitment to a multilinear polynomial in <span class="math">s_{y}-1</span> variables.</li>

      <li>An <span class="math">\\mathcal{R}_{\\mathsf{ACCS}}</span> witness consists of a multilinear polynomial <span class="math">\\widetilde{\\mathbf{w}}</span> in <span class="math">s_{y}-1</span> variables.</li>

    </ul>

    <p class="text-gray-300">An <span class="math">\\mathcal{R}_{\\mathsf{ACCS}}</span> instance (structure-instance tuple) is satisfied by an <span class="math">\\mathcal{R}_{\\mathsf{ACCS}}</span> witness if <span class="math">\\mathsf{Commit}(\\mathsf{pp},\\widetilde{\\mathbf{w}})=C</span>, <span class="math">v_{z}=\\tilde{z}(\\bm{r}_{y})</span> and if for all <span class="math">j\\in[t]</span>, the equation <span class="math">v_{j}=\\widetilde{M}_{j}(\\bm{r}_{x},\\bm{r}_{y})</span> holds, where <span class="math">\\widetilde{M}_{j}(\\bm{x},\\bm{y})</span> is an <span class="math">(s_{x}+s_{y})</span>-variate multilinear polynomial, <span class="math">\\tilde{z}(\\bm{y})</span> is an <span class="math">s_{y}</span>-variate multilinear polynomial such that <span class="math">\\tilde{z}(\\bm{y})=(\\widetilde{\\mathbf{w}},v_{0},\\mathbf{i}\\mathbf{o})</span> for all <span class="math">\\bm{y}\\in\\{0,1\\}^{s_{y}}</span>.</p>

    <h2 id="sec-32" class="text-2xl font-bold">4 Generic Folding Scheme for CCS</h2>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">4.1 High-level Ideas</h3>

    <p class="text-gray-300">This section describes a generic folding scheme for CCS. Its aim is folding the input instances into one atomic CCS instance. For better understanding, one can first imagine running the “early stopping” SuperSpartan for each instance independently and then applying aggregation techniques for their intermediate steps, e.g., sum-check protocols and claims. We use Figure 3 to further illustrate our idea. Given polynomials <span class="math">\\{f^{(i)}(\\bm{x})\\}_{i=1}^{n}</span> derived from the input committed CCS or atomic CCS instances, the prover can aggregate them into one polynomial <span class="math">f(\\bm{x})</span> by a challenge value <span class="math">\\gamma</span> given by the verifier. Then they can run the first sum-check protocol for <span class="math">f(\\bm{x})</span> on the random vector <span class="math">\\bm{r}_{x}</span>. By fixing the input <span class="math">\\bm{x}</span> as value <span class="math">\\bm{r}_{x}</span>, we further derive polynomials <span class="math">\\{g^{(i)}(\\bm{y})\\}_{i=1}^{n}</span>. Then, the prover and verifier run the same aggregation with challenge <span class="math">\\delta</span> and the sum-check protocol on <span class="math">\\bm{r}_{y}</span>. Finally, the prover sends the claim to the evaluations of polynomials <span class="math">\\{\\widetilde{M}_{j}^{(i)}\\}_{j\\in[t]}</span> and <span class="math">\\tilde{z}^{(i)}</span> for each <span class="math">i</span>-th instance. A folding operation is executed on all claims above to obtain a folded atomic CCS instance. To build such a folding scheme, our starting point is to consider the simplest case of folding two instances. Practically, there are three combinations of input instances to be folded:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>two committed CCS instances;</li>

      <li>one committed CCS instance and one atomic CCS instance;</li>

      <li>two atomic CCS instances.</li>

    </ul>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 3: Workflow of Generic Folding Scheme. Take totally  <span class="math">n</span>  committed CCS or atomic CCS instances as inputs, the prover and verifier encode them into one aggregated polynomial  <span class="math">f(\\pmb{x})</span>  and run the "early stopping" SuperSpartan to obtain the  <span class="math">n</span>  atomic CCS instances, which can be folded into one without cross terms.</p>

    <p class="text-gray-300">Note that if two committed CCS instances share the same structure, it is trivial to run the "early stopping" SuperSpartan and fold their final atomic CCS instances. For cases including ACCS (case 2 or 3), we are not ready to build a folding scheme because they may not have the same random vectors  <span class="math">\\boldsymbol{r}_x, \\boldsymbol{r}_y</span> , and it is infeasible to directly fold them. To amend this, we further run "early stopping" SuperSpartan to "update" the random vectors of atomic CCS instances for new ones. We illustrate this with a simple example: assuming a claim (constraint)  <span class="math">f(\\boldsymbol{r}_x) = v</span> , the prover writes a new polynomial as  <span class="math">g(\\boldsymbol{x}) = \\widetilde{eq}(\\boldsymbol{r}_x, \\boldsymbol{x}) \\cdot f(\\boldsymbol{x})</span> , and engages in a sum-check protocol with the verifier to show  <span class="math">\\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{x_e}} g(\\boldsymbol{x}) = v</span>  with randomness  <span class="math">\\boldsymbol{r}_x&#x27;</span> . This equation holds because the sum of  <span class="math">g(\\boldsymbol{x})</span>  can be regarded as an MLE of  <span class="math">f(\\cdot)</span>  as  <span class="math">\\tilde{f}(\\boldsymbol{e}) = \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{x_e}} \\widetilde{eq}(\\boldsymbol{e}, \\boldsymbol{x}) \\cdot f(\\boldsymbol{x})</span>  according to Lemma 1. By evaluating  <span class="math">\\tilde{f}(\\boldsymbol{e})</span>  on  <span class="math">\\boldsymbol{e} = \\boldsymbol{r}_x</span> , we obtain</p>

    <div class="my-4 text-center"><span class="math-block">v = \\tilde {f} (\\boldsymbol {r} _ {x}) = \\sum_ {\\boldsymbol {x} \\in \\{0, 1 \\} ^ {x _ {e}}} \\widetilde {e q} (\\boldsymbol {r} _ {x}, \\boldsymbol {x}) \\cdot f (\\boldsymbol {x}) = \\sum_ {\\boldsymbol {x} \\in \\{0, 1 \\} ^ {x _ {e}}} g (\\boldsymbol {x}).</span></div>

    <p class="text-gray-300">As a result, the prover produces a new claim as  <span class="math">g(\\boldsymbol{r}_x&#x27;) = v&#x27;</span>  with updated  <span class="math">\\boldsymbol{r}_x&#x27;</span> . And the evaluation of  <span class="math">f(\\boldsymbol{r}_x&#x27;)</span>  can be computed as  <span class="math">v&#x27;/e</span> , where  <span class="math">e = \\widetilde{eq}(\\boldsymbol{r}_y, \\boldsymbol{r}_y&#x27;)</span> .</p>

    <p class="text-gray-300">The validity of the original claim can be guaranteed by the soundness of the sum-check protocol.</p>

    <p class="text-gray-300">For simplicity, we only present the folding scheme for case 2 in Section 4.2, details for other cases are left to Appendix B. Concretely, we provide a folding scheme for two instances in specific relations <span class="math">\\mathcal{R}</span> and <span class="math">\\mathcal{R}&#x27;</span>, where <span class="math">\\mathcal{R}</span> and <span class="math">\\mathcal{R}&#x27;</span> are ACCS and CCCS relations with different structures <span class="math">\\mathcal{S}</span> and <span class="math">\\mathcal{S}&#x27;</span> respectively. We assume <span class="math">\\mathcal{S}</span> and <span class="math">\\mathcal{S}&#x27;</span> share the same size bounds <span class="math">m,n,N,l,t</span>, but contain different multilinear polynomials, <span class="math">\\{\\widetilde{M}_j\\}_{j\\in [t]}</span> and <span class="math">\\{\\widetilde{M}_j&#x27;\\}_{j\\in [t]}</span>. For structures with different size bounds, we can use a simple padding scheme to ensure they are the same size. According to protocols given in Appendix B, it is also efficient to build a folding scheme for multiple instances. We present the general process of the non-interactive generic folding scheme in Section 4.4.</p>

    <h2 id="sec-34" class="text-2xl font-bold">4.2 Main Protocol</h2>

    <p class="text-gray-300"><strong>Construction 1 (Folding scheme for two instances).</strong> Let <span class="math">\\mathsf{PC} = (\\mathsf{Gen},\\mathsf{Commit},</span> Open,Eval) denote an additively homomorphic polynomial commitment scheme for multilinear polynomials. The generator and the encoder are defined as follows.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {G} (1 ^ {\\lambda} \\to \\mathsf {p p}):</span></div>

    <p class="text-gray-300">1: Sample size bounds <span class="math">m, n, N, l, t, q, d \\in \\mathbb{N}</span> with <span class="math">n = 2 \\cdot (l + 1)</span>. 2: <span class="math">\\mathsf{pp}_{\\mathsf{PC}}\\gets \\mathsf{Gen}(1^{\\lambda},\\log n - 1)</span> 3: Output <span class="math">(m,n,N,l,t,q,d,\\mathsf{pp}_{\\mathsf{PC}})</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {K} (\\mathsf {p p}, \\mathcal {S}, \\mathcal {S} ^ {\\prime}) \\rightarrow (\\mathsf {p k}, \\mathsf {v k}) :</span></div>

    <p class="text-gray-300">1: Parse <span class="math">\\mathcal{S}</span> to obtain <span class="math">\\{\\widetilde{M}_j\\}_{j\\in [t]}</span>. 2: Parse <span class="math">\\mathcal{S}&#x27;</span> to obtain <span class="math">\\{\\widetilde{M}_j&#x27;\\}_{j\\in [t]},\\{S_i&#x27;\\}_{i\\in [q]},\\{c_i&#x27;\\}_{i\\in [q]}</span>. 3: <span class="math">\\mathsf{pk}\\gets (\\mathsf{pp},(\\{\\widetilde{M}_j\\}_{j\\in [t]},\\{\\widetilde{M}_j&#x27;\\}_{j\\in [t]},\\{S_i&#x27;\\}_{i\\in [q]},\\{c_i&#x27;\\}_{i\\in [q]}))</span> 4: <span class="math">\\mathsf{vk}\\gets \\bot</span> 5: Output <span class="math">(\\mathsf{pk},\\mathsf{vk})</span></p>

    <p class="text-gray-300">To distinguish, we mark the parts corresponding to the committed CCS instance in blue text. The verifier <span class="math">\\mathcal{V}</span> takes as inputs an atomic CCS instance <span class="math">(C,v_0,\\mathbf{i}\\mathbf{o},\\boldsymbol {r}_x,\\boldsymbol {r}_y,\\{v_j\\}_{j\\in [t]},v_z)</span> and a committed CCS instance <span class="math">(C^{\\prime},\\mathbf{i}\\mathbf{o}^{\\prime})</span>. The prover <span class="math">\\mathcal{P}</span>, in addition to the two instances, takes witnesses <span class="math">\\widetilde{\\mathbf{w}}</span> and <span class="math">\\widetilde{\\mathbf{w}}^{\\prime}</span>. Let <span class="math">s_x = \\log m</span>, <span class="math">s_y = \\log n</span>, <span class="math">\\tilde{z} = (\\widetilde{\\mathbf{w},v_0,\\mathbf{i}\\mathbf{o}})</span>, and <span class="math">\\tilde{z}^{\\prime} = (\\widetilde{\\mathbf{w}^{\\prime},1,\\mathbf{i}\\mathbf{o}^{\\prime}})</span>. The prover and the verifier proceed as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}\\to \\mathcal{P}</span>: <span class="math">\\mathcal{V}</span> samples <span class="math">\\gamma \\leftarrow \\S \\mathbb{F}</span>, <span class="math">\\alpha \\leftarrow \\S \\mathbb{F}^{s_x}</span>, and sends them to <span class="math">\\mathcal{P}</span>.</li>

      <li><span class="math">\\mathcal{V}</span>: Sample <span class="math">\\boldsymbol{r}_x^{\\prime} \\gets \\S \\mathbb{F}^{s_x}</span>.</li>

      <li><span class="math">\\mathcal{P}</span>: Compute <span class="math">\\tilde{z} (\\boldsymbol {y}) = (\\widetilde{\\boldsymbol{w}},v_0,\\mathbf{i}\\boldsymbol {o})</span>, <span class="math">\\tilde{z}^{\\prime}(\\boldsymbol {y}) = (\\widetilde{\\boldsymbol{w}}^{\\prime},1,\\mathbf{i}\\boldsymbol{o}^{\\prime})</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V} \\leftrightarrow \\mathcal{P}</span>: Run the sum-check protocol#1 <span class="math">c_x \\leftarrow \\Pi_{\\mathrm{sc}}(f, s_x, d + 1, \\mathsf{sum}_x, \\boldsymbol{r}_x&#x27;)</span>, where <span class="math">\\tilde{e} q(\\boldsymbol{r}_x, \\boldsymbol{x}), \\tilde{e} q(\\boldsymbol{r}_y, \\boldsymbol{y})</span> in <span class="math">L_j(\\boldsymbol{x})</span> are used for updating challenge vectors:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{sum}_x := \\sum_{j \\in [t]} \\gamma^j \\cdot v_j,</span></div>

    <div class="my-4 text-center"><span class="math-block">f(\\boldsymbol{x}) := \\left(\\sum_{j \\in [t]} \\gamma^j \\cdot L_j(\\boldsymbol{x})\\right) + \\gamma^t \\cdot Q(\\boldsymbol{x}),</span></div>

    <div class="my-4 text-center"><span class="math-block">L_j(\\boldsymbol{x}) := \\widetilde{e} q(\\boldsymbol{r}_x, \\boldsymbol{x}) \\cdot \\left(\\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s_y}} \\widetilde{e} q(\\boldsymbol{r}_y, \\boldsymbol{y}) \\cdot \\widetilde{M}_j(\\boldsymbol{x}, \\boldsymbol{y})\\right), \\; j \\in [t],</span></div>

    <div class="my-4 text-center"><span class="math-block">Q(\\boldsymbol{x}) := \\widetilde{e} q(\\boldsymbol{\\alpha}, \\boldsymbol{x}) \\cdot \\left(\\sum_{i \\in [q]} c_i&#x27; \\cdot \\prod_{j \\in S_i} \\left(\\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s_y}} \\widetilde{M}_j&#x27;(\\boldsymbol{x}, \\boldsymbol{y}) \\cdot \\tilde{z}&#x27;(\\boldsymbol{y})\\right)\\right),</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span>: <span class="math">(\\{\\sigma_j\\}_{j \\in [t]}, \\{\\sigma_j&#x27;\\}_{j \\in [t]})</span>, where:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\sigma_j = \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s_y}} \\widetilde{e} q(\\boldsymbol{r}_y, \\boldsymbol{y}) \\cdot \\widetilde{M}_j(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}), \\; \\forall j \\in [t],</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sigma_j&#x27; = \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s_y}} \\widetilde{M}_j&#x27;(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}) \\cdot \\tilde{z}&#x27;(\\boldsymbol{y}), \\; \\forall j \\in [t].</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>: Compute <span class="math">e_1 \\leftarrow \\widetilde{e} q(\\boldsymbol{r}_x, \\boldsymbol{r}_x&#x27;)</span> and <span class="math">e_2 \\leftarrow \\widetilde{e} q(\\boldsymbol{\\alpha}, \\boldsymbol{r}_x&#x27;)</span>, and abort if:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">c_x \\neq \\left(\\sum_{j \\in [t]} \\gamma^j \\cdot e_1 \\cdot \\sigma_j\\right) + \\left(\\gamma^t \\cdot e_2 \\cdot \\sum_{i \\in [q]} c_i&#x27; \\cdot \\prod_{j \\in S_i} \\sigma_j&#x27;\\right).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span>: <span class="math">\\mathcal{V}</span> samples <span class="math">\\delta \\leftarrow \\S \\mathbb{F}</span>, and sends it to <span class="math">\\mathcal{P}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>: Sample <span class="math">\\boldsymbol{r}_y&#x27; \\leftarrow \\S \\mathbb{F}^{s_y}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V} \\leftrightarrow \\mathcal{P}</span>: Run the sum-check protocol#2 <span class="math">c_y \\leftarrow \\Pi_{\\mathrm{sc}}(g, s_y, 2, \\mathsf{sum}_y, \\boldsymbol{r}_y&#x27;)</span>, where:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{sum}_y := \\sum_{j \\in [t]} \\delta^j \\cdot \\sigma_j + \\delta^{t+1} \\cdot v_z + \\delta^{t+1} \\cdot \\sum_{j \\in [t]} \\delta^j \\cdot \\sigma_j&#x27;,</span></div>

    <div class="my-4 text-center"><span class="math-block">g(\\boldsymbol{y}) := \\sum_{j \\in [t]} \\delta^j \\cdot R_j(\\boldsymbol{y}) + \\delta^{t+1} \\cdot S(\\boldsymbol{y}) + \\delta^{t+1} \\cdot \\sum_{j \\in [t]} \\delta^j \\cdot T_j(\\boldsymbol{y}),</span></div>

    <div class="my-4 text-center"><span class="math-block">R_j(\\boldsymbol{y}) = \\widetilde{e} q(\\boldsymbol{r}_y, \\boldsymbol{y}) \\cdot \\widetilde{M}_j(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}), \\; \\forall j \\in [t],</span></div>

    <div class="my-4 text-center"><span class="math-block">T_j(\\boldsymbol{y}) = \\widetilde{M}_j&#x27;(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}) \\cdot \\tilde{z}&#x27;(\\boldsymbol{y}), \\; \\forall j \\in [t],</span></div>

    <div class="my-4 text-center"><span class="math-block">S(\\boldsymbol{y}) = \\widetilde{e} q(\\boldsymbol{r}_y, \\boldsymbol{y}) \\cdot \\tilde{z}(\\boldsymbol{y}).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span>: <span class="math">(\\epsilon, \\epsilon&#x27;, \\{\\theta_j\\}_{j \\in [t]}, \\{\\theta_j&#x27;\\}_{j \\in [t]})</span>, where:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\epsilon = \\tilde{z}(\\boldsymbol{r}_y&#x27;),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\epsilon&#x27; = \\tilde{z}&#x27;(\\boldsymbol{r}_y&#x27;),</span></div>

    <p class="text-gray-300"><span class="math">\\theta_{j}</span> <span class="math">=\\widetilde{M}_{j}(\\bm{r}_{x}^{\\prime},\\bm{r}_{y}^{\\prime}),\\ \\forall j\\in[t],</span> <span class="math">\\theta_{j}^{\\prime}</span> <span class="math">=\\widetilde{M}_{j}^{\\prime}(\\bm{r}_{x}^{\\prime},\\bm{r}_{y}^{\\prime}),\\ \\forall j\\in[t].</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: <span class="math">\\mathcal{V}</span> samples <span class="math">\\eta\\leftrightarrows\\mathbb{F}</span> and sends it to <span class="math">\\mathcal{P}</span>.</li>

      <li><span class="math">\\mathcal{V}</span>: Compute <span class="math">e_{3}\\leftarrow\\widetilde{e_{q}}(\\bm{r}_{y},\\bm{r}_{y}^{\\prime})</span>, and abort if:</li>

    </ol>

    <p class="text-gray-300"><span class="math">c_{y}\\neq\\sum_{j\\in[t]}\\delta^{j}\\cdot e_{3}\\cdot\\theta_{j}+\\delta^{t+1}\\cdot e_{3}\\cdot\\epsilon+\\delta^{t+1}\\cdot\\sum_{j\\in[t]}\\delta^{j}\\cdot\\theta_{j}^{\\prime}\\cdot\\epsilon^{\\prime}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V},\\mathcal{P}</span>: Output the folded atomic CCS structure <span class="math">\\mathcal{S}^{*}</span> containing</li>

    </ol>

    <p class="text-gray-300"><span class="math">M_{j}^{*}=M_{j}+\\eta\\cdot M_{j}^{\\prime}</span></p>

    <p class="text-gray-300">for all <span class="math">j\\in[t]</span> and its instance <span class="math">(C^{<em>},v_{0}^{</em>},\\bm{\\mathsf{i o}}^{<em>},\\bm{r}_{x}^{</em>},\\bm{r}_{y}^{<em>},\\ \\{v_{j}^{</em>}\\}_{j\\in[t]},v_{z}^{<em>})</span>, where <span class="math">\\bm{r}_{x}^{</em>}=\\bm{r}_{x}^{\\prime},\\bm{r}_{y}^{*}=\\bm{r}_{y}^{\\prime}</span>, and for all <span class="math">j\\in[t]</span>:</p>

    <p class="text-gray-300"><span class="math">C^{<em>}</span> <span class="math">\\leftarrow C+\\eta\\cdot C^{\\prime},</span> <span class="math">\\mathsf{i o}^{</em>}</span> <span class="math">\\leftarrow\\mathsf{i o}+\\eta\\cdot\\mathsf{i o}^{\\prime},</span> <span class="math">v_{0}^{<em>}</span> <span class="math">\\leftarrow v_{0}+\\eta\\cdot 1,</span> <span class="math">v_{j}^{</em>}</span> <span class="math">\\leftarrow\\theta_{j}+\\eta\\cdot\\theta_{j}^{\\prime},</span> <span class="math">v_{z}^{*}</span> <span class="math">\\leftarrow\\epsilon+\\eta\\cdot\\epsilon^{\\prime}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> : Output the folded witness <span class="math">\\bm{\\mathsf{w}}+\\eta\\cdot\\bm{\\mathsf{w}}^{\\prime}</span>.</li>

    </ol>

    <h6 id="sec-35" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">(Folding scheme for committed CCS). Construction 1 is a public coin folding scheme for <span class="math">(\\mathcal{R},\\mathcal{R}^{\\prime})</span> with perfect completeness and knowledge soundness.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Proof sketch.</h6>

    <p class="text-gray-300">It is trivial to prove that Construction 1 satisfies completeness. For the knowledge soundness, we prove that Construction 1 is knowledge sound if the commitment scheme <span class="math">\\mathsf{Commit}()</span> satisfies the binding property. Concretely, if there exists an adversary <span class="math">\\mathcal{A}</span> that succeeds in producing valid proof with non-negligible probability, we show that a polynomial time extractor <span class="math">\\mathsf{Ext}</span> that outputs the witness with non-negligible probability can be constructed. According to the conclusion in <em>[8]</em>, given a <span class="math">2^{s_{x}+s_{y}}</span>-tree of transcripts, we can either find a pair of commitments breaking the binding property or construct an expected extractor outputting the witness.</p>

    <p class="text-gray-300">The detailed proof of Theorem 1 is given in Appendix B.3.</p>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">4.3 Adding Zero-knowledge</h3>

    <p class="text-gray-300">The above construction is proven to satisfy completeness and knowledge soundness properties. In this part, we further discuss adding zero knowledge to it. A straightforward idea is directly adding a masking value for the witness <span class="math">\\bm{\\mathsf{w}}</span>. That is, the prover runs the protocol with <span class="math">\\rho\\cdot\\bm{\\mathsf{w}}+\\bm{\\mathsf{w}}</span> instead of <span class="math">\\bm{\\mathsf{w}}</span>, where <span class="math">\\bm{\\mathsf{w}}\\in\\mathbb{F}^{n-l-1}</span>. Although this technique can prove the validity of folding without leaking any</p>

    <p class="text-gray-300">information about the witness, the prover needs to do the extra computation, especially when folding committed CCS instances. We illustrate this point with the following example. Assume the prover wants to run the sum-check#1 on a committed CCS instance with a masking vector <span class="math">\\bm{w}</span>. The target polynomial is written as:</p>

    <p class="text-gray-300"><span class="math">f(\\bm{x})=\\widetilde{eq}(\\bm{\\alpha},\\bm{x})\\cdot\\left(\\sum_{i\\in[q]}c_{i}\\cdot\\prod_{j\\in S_{i}}\\left(\\sum_{\\bm{y}\\in\\{0,1\\}^{s_{y}}}\\widetilde{M}_{j}(\\bm{x},\\bm{y})\\cdot\\widetilde{Z}(\\bm{y})\\right)\\right),</span></p>

    <p class="text-gray-300">where <span class="math">\\widetilde{Z}(\\bm{y})=(\\rho\\cdot\\widetilde{\\bm{w}+\\bm{w}},1,\\mathbf{i}\\mathbf{o})</span>. Since the masking vector <span class="math">\\bm{w}</span> is sampled randomly, the above target polynomial no longer equals zero. To ensure the equation holds, the prover has to compute the sum of the new polynomial <span class="math">f(\\bm{x})</span>, which takes <span class="math">O(N+tm+qmd\\log^{2}d)</span> <span class="math">\\mathbb{F}</span>-ops dominated by the computation of non-linear part with degree <span class="math">d</span>. When dealing with multiple committed CCS instances, the prover must execute the above computation for each independently. Moreover, the prover has to send <span class="math">O(2^{d})</span> cross terms for each instance to convince the verifier of the original relation on <span class="math">\\mathbf{w}</span>. To alleviate these problems, we propose a more efficient approach for our scheme by separating the zero-knowledge problem into three parts and solving them independently.</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">1.1.1 Zero-knowledge for prover claims.</h4>

    <p class="text-gray-300">We first consider shielding the witness <span class="math">\\mathbf{w}</span> among the verification of the claims. The verifier is expected to learn no information about <span class="math">\\mathbf{w}</span> except its validity to the CCS instance from steps 5, 6, and 10-12. As mentioned above, the non-linearity part of the CCS relation prevents us from directly masking the witness as <span class="math">\\rho\\cdot\\mathbf{w}+\\bm{w}</span>. Here, we utilize an approach in <em>[9]</em> by Bootle et al. to randomize the claims, which will not introduce extra costs for non-linear parts. Generally speaking, the claims at steps 5 and 10 can be regarded as linear combinations of the values in <span class="math">\\mathbf{w}</span>. According to the result given by Bootle et al., if we pad the witness with as many non-zero random values as the number of combinations it receives, then all the responses will be uniformly random and leak no information.</p>

    <p class="text-gray-300">Again, we take the committed CCS relation in Equation (6) as an example. With a randomly sampled vector <span class="math">\\bm{r}=[\\bm{r}_{j}]_{j=1}^{t},\\bm{r}_{j}\\in\\mathbb{F}^{2}</span> added to the vector <span class="math">\\bm{r}</span>, the equation can be rewritten as</p>

    <p class="text-gray-300">\\[ \\sum_{i\\in[q]}c_{i}\\cdot\\bigcirc_{j\\in S_{i}}\\begin{bmatrix}M_{j}&O\\\\ O&I_{j}\\end{bmatrix}\\cdot(\\bm{z},\\bm{r})=(\\bm{0},\\sum_{i\\in[q]}c_{i}\\cdot\\bigcirc_{j\\in S_{i}}\\bm{r}_{j}), \\]</p>

    <p class="text-gray-300">where <span class="math">O</span> denotes zero matrix, <span class="math">I_{j}</span> is a <span class="math">2\\times 2t</span> matrix with an <span class="math">2\\times 2</span> identity matrix <span class="math">I</span> in the <span class="math">j</span>-th position, i.e.,</p>

    <p class="text-gray-300"><span class="math">I_{j}=[\\underbrace{O,...,O}_{j-1},I,O,...,O].</span></p>

    <p class="text-gray-300">So far, the zero knowledge of the committed CCS instance is retained against <span class="math">2t</span> queries of the linear combination of <span class="math">\\mathbf{w}</span>. To accommodate it to our folding scheme,</p>

    <p class="text-gray-300">we denote extra two sets of variables as <span class="math">\\pmb{a} \\in \\{0,1\\}, \\pmb{b} \\in \\{0,1\\}^{\\log(2t)}</span> for representing <span class="math">I_j, \\pmb{r}_j</span>. The above equation can be further written into the multilinear polynomial form as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_{i \\in [q]} c_i \\prod_{j \\in S_i} \\left(\\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s_y}, \\boldsymbol{b} \\in \\{0,1\\}^{\\log(2t)}} (\\widetilde{M}_j(\\boldsymbol{x}, \\boldsymbol{y}) + \\widetilde{I}_j(\\boldsymbol{a}, \\boldsymbol{b})) \\cdot (\\widetilde{z}(\\boldsymbol{y}) + \\widetilde{r}(\\boldsymbol{b}))\\right) \\\\ = \\sum_{\\boldsymbol{b} \\in \\{0,1\\}^{\\log(2t)}} \\left(\\sum_{i \\in [q]} c_i \\cdot \\bigcirc_{j \\in S_i} \\widetilde{r}_j(\\boldsymbol{b})\\right), \\end{array}</span></div>

    <p class="text-gray-300">for all <span class="math">\\pmb{x} \\in \\{0,1\\}^{s_x}, \\pmb{a} \\in \\{0,1\\}</span>, where <span class="math">\\widetilde{I}_j(\\pmb{a},\\pmb{b})), \\widetilde{r}_j(\\pmb{b})</span> are the MLE's for <span class="math">I_j, r_j</span> on <span class="math">\\pmb{a}, \\pmb{b}</span> and <span class="math">\\widetilde{r}(\\pmb{b}) = \\sum_{j=1}^{t} \\widetilde{r}_j(\\pmb{b})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(2) Zero-knowledge for sum-check protocols. Preserving the privacy of <span class="math">\\mathbf{w}</span> among the claims sent by the prover is insufficient to ensure zero knowledge of the whole folding scheme. Note that the sum-check protocols #1 and #2 at steps 4 and 9 are not shielded. Thus, the transcripts in the protocol also leak the information of <span class="math">\\mathbf{w}</span>. To amend this problem, we refer to a previous work as Libra [35], which presents a zero-knowledge sum-check protocol by masking the coefficients of the target polynomial <span class="math">f(\\pmb{x})</span> with a random polynomial <span class="math">f_r(\\pmb{x})</span> of size <span class="math">O(d)</span>, where $s_x =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is logarithmic of the size of target polynomial </span>f(\\pmb{x})<span class="math">. Briefly, the random polynomial can be constructed as </span>f_r(\\pmb{x}) = r_0 + r_1(x_1) + r_2(x_2) + \\dots + r_{s_x}(x_{s_x})<span class="math">, where </span>r_i(x_i) = r_{i,1}x_i + r_{i,2}x_i^2 + \\dots + r_{i,d}x_i^d<span class="math"> is a random univariate polynomial of degree </span>d<span class="math">. For simplicity, we denote the zero-knowledge sum-check protocol as </span>c \\gets \\Pi_{\\mathrm{zksc}}(f, n, d, \\mathsf{sum}, \\boldsymbol{r})$. The security is guaranteed accordingly by the results in [17].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(3) Zero-knowledge for folded instances. The previous two techniques can guarantee zero knowledge of most processes in Construction 1 except the final folding operation at step 14. The prover outputs the folded witness <span class="math">\\mathbf{w} + \\eta \\cdot \\mathbf{w}&#x27;</span> without randomization. To amend this, the masking value <span class="math">\\mathbf{w} \\in \\mathbb{F}^{n - l - 1}</span> mentioned at the beginning has to be introduced. Differently, only one <span class="math">\\mathbf{w}</span> is needed this time because the privacy in the previous steps is already preserved. Therefore, the prover takes the masking value as another committed CCS instance, i.e., masking instance, with empty structure <span class="math">S</span>, empty io and commitment <span class="math">C = \\text{Commit}(\\mathsf{pp}, \\widetilde{\\mathbf{w}})</span>, and runs the folding scheme accordingly, where <span class="math">O</span> denote <span class="math">m \\times n</span> zero matrix.</p>

    <p class="text-gray-300">Besides, we also want to mention a trick for saving the computation of the sum of <span class="math">\\widetilde{\\boldsymbol{w}}</span>. The polynomial <span class="math">f(\\boldsymbol{x})</span> aggregates the masking value with all other instances. According to the proving algorithm for the sum-check protocol proposed in [32], it is handy to acquire the sum of <span class="math">f(\\boldsymbol{x})</span> from the bookkeeping table. Thus, we can obtain the sum of <span class="math">\\widetilde{\\boldsymbol{w}}</span> by subtracting sums of other instances, i.e.,</p>

    <p class="text-gray-300">7 It is more efficient to write polynomials on <span class="math">\\pmb{x} \\in \\{0,1\\}^{\\log(m+2)}, \\pmb{y} \\in \\{0,1\\}^{\\log(n+2t)}</span>, we omit this expression for simplicity. In fact, the extra variables may even be unnecessary in real-world implementation since most vector <span class="math">\\pmb{z}</span> ends with a number of zeros, which can be replaced with randomness.</p>

    <p class="text-gray-300">22</p>

    <p class="text-gray-300"><span class="math">\\sum_{j\\in[t]}\\gamma^{j}\\cdot v_{j}\\cdot v_{z}</span> for atomic CCS instance and <span class="math">0</span> for committed CCS instance, from <span class="math">\\sum_{\\mathbf{x}\\in\\{0,1\\}^{s_{x}}}</span> without actually computing the concrete evaluations.</p>

    <p class="text-gray-300">The final zero-knowledge generic folding schemes based on the above three techniques only require the prover to compute <em>one</em> additional polynomial sum for masking the folding instances in (3). Besides, there is no extra cross terms introduced in the scheme. Due to page limitations, we only integrate these techniques into the non-interactive folding scheme in the following subsection, rather than independently presenting a zero-knowledge version of construction 1.</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">4.4 Putting Everything Together</h3>

    <p class="text-gray-300">We present a non-interactive generic folding scheme with input as multiple committed CCS or atomic CCS instances in Construction 2. Zero knowledge is achieved as well by applying the techniques mentioned above. Guaranteed by the security of construction 1, it is not difficult to argue that construction 2 also satisfies completeness, knowledge soundness, and zero-knowledge. At the end of this part, we give a comprehensive evaluation of the performance, including the prover cost, verifier cost, and communication complexity. (While we do present the corresponding security proof of zero knowledge in Appendix B.3)</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Construction 2 (Zero-knowledge non-interactive generic folding scheme).</h6>

    <p class="text-gray-300">We construct a zero-knowledge non-interactive generic folding scheme as zk-NIFS, which consists of 4 PPT algorithms <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>. Let <span class="math">\\mathbb{H}</span> be the random oracle, <span class="math">\\mathsf{PC}=(\\mathsf{Gen},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Eval})</span> denote an additively-homomorphic polynomial commitment scheme for multilinear polynomials. For generality, we assume the scheme takes input as multiple CCS instances, including</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\sum_{i\\in[\\ell_{1}]}s^{(i)}</span> atomic CCS instances in a set of relations <span class="math">\\{\\mathcal{R}^{(i)}\\}_{i\\in[\\ell_{1}]}</span> with different structures <span class="math">\\{\\mathcal{S}^{(i)}\\}_{i\\in[\\ell_{1}]}</span>, where each relation <span class="math">\\mathcal{R}^{(i)}</span> corresponds to <span class="math">s^{(i)}</span> instances. Let <span class="math">s_{1}=\\sum_{i\\in[\\ell_{1}]}s^{(i)}</span>, each atomic CCS instance consists of <span class="math">(S^{(k)},\\mathbf{u}^{(k)},\\mathbf{w}^{(k)})</span>, where <span class="math">\\mathbf{u}^{(k)}=(C^{(k)},v_{0}^{(k)},\\mathsf{io}^{(k)},\\bm{r}_{x}^{(k)},\\bm{r}_{y}^{(k)},\\{v_{j}^{(k)}\\}_{j\\in[t]},v_{z}^{(k)})</span> for all <span class="math">k=1,...,s_{1}</span>.</li>

      <li><span class="math">\\sum_{i=\\ell_{1}+1}^{\\ell_{1}+\\ell_{2}}s^{(i)}</span> committed CCS instances in a set of relations <span class="math">\\{\\mathcal{R}^{(i)}\\}_{i=\\ell_{1}+1}^{\\ell_{1}+\\ell_{2}}</span> with different structures <span class="math">\\{\\mathcal{S}^{(i)}\\}_{i=\\ell_{1}+1}^{\\ell_{1}+\\ell_{2}}</span>, where each relation <span class="math">\\mathcal{R}^{(i)}</span> corresponds to <span class="math">s^{(i)}</span> instances. Let <span class="math">s_{2}=\\sum_{i=\\ell_{1}+1}^{\\ell_{1}+\\ell_{2}}s^{(i)}</span>, each committed CCS instance is consists of <span class="math">(S^{(k)},\\mathbf{u}^{(k)},\\mathbf{w}^{(k)})</span>, where <span class="math">\\mathbf{u}^{(k)}=(C^{(k)},\\mathsf{io}^{(k)})</span> for all <span class="math">k=s_{1}+1,...,s_{1}+s_{2}</span></li>

    </ul>

    <p class="text-gray-300">Denote <span class="math">s=s_{1}+s_{2}</span>, we use <span class="math">i,k</span> to index the relations (structures) <span class="math">\\{\\mathcal{R}^{(i)}\\}_{i\\in[\\ell]}</span> and instances <span class="math">\\{\\mathbf{u}^{(k)}\\}_{k\\in[s]}</span> respectively. By applying Fiat-Shamir transformation to the zero-knowledge sum-check protocol mentioned in Section 4.3, we obtain the proving algorithm <span class="math">\\mathrm{FS}[\\varPi_{\\mathsf{zksc}}]</span>. <span class="math">\\mathcal{P}</span> with output transcript as <span class="math">\\mathsf{ts}=(c,\\Delta\\mathsf{sum},\\{m_{j}\\}_{j\\in[s]},\\bm{r})</span> and the verifying algorithm <span class="math">\\mathrm{FS}[\\varPi_{\\mathsf{zksc}}]</span>. <span class="math">\\mathcal{V}</span> with output <span class="math">1</span> for validity. We only present the concrete algorithms for zk-NIFS. <span class="math">\\mathcal{P},\\mathsf{zk-NIFS}</span>. <span class="math">\\mathcal{V}</span> below to highlight the differences compared to Section 4.2.</p>

    <p class="text-gray-300">zk-NIFS.  <span class="math">\\mathcal{P}((\\mathsf{pk},\\mathsf{vk}),\\{S^{(i)}\\}_{i\\in [\\ell ]},\\{\\mathbf{u}^{(k)}\\}_{k\\in [s]},\\{\\mathbf{w}^{(k)}\\}_{k\\in [s]})</span>  :</p>

    <p class="text-gray-300">1: Randomly sample  <span class="math">\\{\\pmb{r}^{(k)}\\in \\mathbb{F}^{2t}\\}_{k\\in [s]},\\pmb {w}\\in \\mathbb{F}^{n - l - 1}</span> 2: Generate instance  <span class="math">\\mathbf{u}^{(0)}</span>  with  <span class="math">\\pmb{w}</span> . 3: Pad each  <span class="math">\\mathbf{z}^{(k)}</span>  with  <span class="math">\\mathbf{r}^{(k)}</span> , update  <span class="math">\\mathbf{sum}_x</span> . 4: Generate claims on sums of  <span class="math">\\widetilde{\\pmb{w}} (\\pmb {y}),\\{\\widetilde{\\pmb{r}}^{(k)}(\\pmb {y})\\}_{k = 0}^{s}</span> 5: Pad each  <span class="math">M_j^{(i)}</span>  with  <span class="math">I_j</span> . 6:  <span class="math">\\gamma, \\alpha \\gets \\mathbb{H}(\\{\\mathbf{u}^{(k)}\\}_{k=0}^s)</span> , construct polynomial  <span class="math">f</span> . 7: Run sum-check#1 as  <span class="math">\\mathbf{ts}_x\\gets \\mathrm{FS}[\\varPi_{\\mathrm{zksc}}]</span> .  <span class="math">\\mathcal{P}(f,s_x,d + 1,\\mathbf{sum}_x)</span> . 8: Generate claims on  <span class="math">\\{\\sigma_j^{(k)}\\}_{k = 0,j = 1}^{s,t}</span> . 9:  <span class="math">\\delta \\gets \\mathbb{H}(\\mathbf{ts}_x, \\{\\sigma_j^{(k)}\\}_{k=0,j=1}^{s,t})</span> , construct polynomial  <span class="math">g</span> . 10: Run sum-check#2 as  <span class="math">\\mathbf{ts}_y\\gets \\mathrm{FS}[\\varPi_{\\mathrm{zksc}}]</span> .  <span class="math">\\mathcal{P}(g,s_y,d + 1,\\mathbf{sum}_y)</span> . 11: Generate claims on  <span class="math">\\{\\epsilon^{(k)}\\}_{k = 0}^s,\\{\\theta_j^{(k)}\\}_{k = 0,j = 1}^{s,t}</span> 12:  <span class="math">\\eta \\gets \\mathbb{H}(\\mathbf{ts}_y, \\{\\epsilon^{(k)}\\}_{k=0}^s, \\{\\theta_j^{(k)}\\}_{k=0,j=1}^{s,t})</span> . 13: Set vectors for each instance  <span class="math">\\mathbf{u}^{(k)}, k = 0, \\dots, s</span>  as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {v} ^ {(k)} := \\left(\\left\\{M _ {j} ^ {(k)} \\right\\} _ {j \\in [ t ]}, C ^ {(k)}, v _ {0} ^ {(k)}, \\mathbf {i o} ^ {(k)}, \\left\\{\\theta_ {j} ^ {(k)} \\right\\} _ {j \\in [ t ]}, \\epsilon^ {(k)}, \\mathbf {w} ^ {(k)}\\right).</span></div>

    <p class="text-gray-300">14:  <span class="math">\\mathbf{v}^{<em>} := \\sum_{k=0}^{s} \\eta^{k} \\cdot \\mathbf{v}^{(k)}, M_{j}^{</em>} := \\sum_{i \\in [\\ell]} \\eta^{i} \\cdot M_{j}^{(i)}, \\forall j \\in [t]</span> . 15: Set folding proof as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {p f} := (\\mathbf {u} ^ {(0)}, \\gamma , \\boldsymbol {\\alpha}, \\boldsymbol {r} _ {x} ^ {\\prime}, \\mathbf {t s} _ {x}, \\{\\sigma_ {j} ^ {(k)} \\} _ {k = 0, j = 1} ^ {s, t}, \\delta , \\boldsymbol {r} _ {y} ^ {\\prime}, \\mathbf {t s} _ {y}, \\{\\epsilon^ {(k)} \\} _ {k = 0} ^ {s}, \\{\\theta_ {j} ^ {(k)} \\} _ {k = 0, j = 1} ^ {s, t}).</span></div>

    <p class="text-gray-300">16: Output  <span class="math">(\\{M_j^<em>\\}_{j\\in [t]},\\mathbf{v}^</em>,\\mathsf{pf})</span></p>

    <p class="text-gray-300">zk-NIFS.  <span class="math">\\mathcal{V}((\\mathsf{pk},\\mathsf{vk}),\\{S^{(i)}\\}_{i\\in [\\ell ]},\\{\\mathbf{u}^{(k)}\\}_{k\\in [s]},\\mathsf{pf})</span></p>

    <p class="text-gray-300">1: Check the validity of  <span class="math">\\mathbf{sum}_x</span>  with claims on  <span class="math">\\widetilde{\\boldsymbol{w}} (\\boldsymbol {y}),\\{\\widetilde{\\boldsymbol{r}}^{(k)}(\\boldsymbol {y})\\}_{k = 0}^s</span> 2: Pad each  <span class="math">M_j^{(i)}</span>  with  <span class="math">I_j</span> . 3:  <span class="math">\\gamma, \\alpha \\gets \\mathbb{H}(\\{\\mathbf{u}^{(k)}\\}_{k=0}^s)</span> . 4: Check sum-check#1 as  <span class="math">1 \\stackrel{?}{=} \\mathrm{FS}[\\varPi_{\\mathrm{zksc}}]</span> .  <span class="math">\\mathcal{V}(\\mathsf{ts}_x, s_x, d + 1, \\mathsf{sum}_x)</span> . 5: Check claims on  <span class="math">\\{\\sigma_j^{(k)}\\}_{k = 0,j = 1}^{s,t}</span>  with  <span class="math">c_{x},\\gamma ,\\alpha</span> 6:  <span class="math">\\delta \\gets \\mathbb{H}(\\mathbf{ts}_x, \\{\\sigma_j^{(k)}\\}_{k=0,j=1}^{s,t})</span> . 7: Check sum-check#2 as  <span class="math">1 \\stackrel{?}{=} \\mathrm{FS}[\\varPi_{\\mathrm{zksc}}]</span> .  <span class="math">\\mathcal{V}(\\mathbf{ts}_y, s_y, d + 1, \\mathbf{sum}_y)</span> . 8: Check claims of  <span class="math">\\{\\epsilon^{(k)}\\}_{k = 0}^s,\\{\\theta_j^{(k)}\\}_{k = 0,j = 1}^{s,t}</span>  with  <span class="math">c_{y},\\delta</span> 9:  <span class="math">\\eta \\gets \\mathbb{H}(\\mathbf{ts}_y, \\{\\epsilon^{(k)}\\}_{k=0}^s, \\{\\theta_j^{(k)}\\}_{k=0,j=1}^{s,t})</span></p>

    <p class="text-gray-300">10: Set vectors for each instance <span class="math">\\mathbf{u}^{(k)}, k = 0, \\dots, s</span> as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{v}^{(k)} := (\\{M_j^{(k)}\\}_{j \\in [t]}, C^{(k)}, v_0^{(k)}, \\mathbf{i o}^{(k)}, \\{\\theta_j^{(k)}\\}_{j \\in [t]}, \\epsilon^{(k)}, \\mathbf{w}^{(k)}).</span></div>

    <p class="text-gray-300">11: Check <span class="math">\\mathbf{v}^<em> := \\sum_{k=0}^s \\eta^k \\cdot \\mathbf{v}^{(k)}</span>, <span class="math">M_j^</em> := \\sum_{i \\in [\\ell]} \\eta^i \\cdot M_j^{(i)}, \\forall j \\in [t]</span>.</p>

    <p class="text-gray-300"><strong>Complexity.</strong> Denote the random oracle for sum-check protocol as <span class="math">\\mathbb{H}_{\\mathrm{sc}}</span>.</p>

    <p class="text-gray-300">The folding scheme prover</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>asks <span class="math">\\log m + \\log n</span> queries to <span class="math">\\mathbb{H}_{\\mathrm{sc}}</span> and <span class="math">\\log m + 2</span> queries to <span class="math">\\mathbb{H}</span>;</li>

      <li>computes sum-check protocols (steps 7,8,10,11 in zk-NIFS.P) with <span class="math">O(s_{1}(N + tm) + s_{2}(N + tm + qmd\\log^{2}d))</span> <span class="math">\\mathbb{F}</span>-ops for all <span class="math">s_1</span> atomic CCS instances and <span class="math">s_2</span> committed CCS instances where</li>

      <li>for each atomic CCS instance, runs <span class="math">O(N + tm)</span> <span class="math">\\mathbb{F}</span>-ops according to the standard linear-time-sum-check techniques [32],</li>

      <li>for each committed CCS instance, runs <span class="math">O(N + tm + qmd\\log^2 d)</span> <span class="math">\\mathbb{F}</span>-ops according to the technique in SuperSpartan [31];</li>

      <li>performs <span class="math">O(s)</span> <span class="math">\\mathbb{G}</span>-ops to combine <span class="math">\\{C^{(k)}\\}_{k=0}^s</span>;</li>

      <li>performs <span class="math">O(\\ell N + s(n + t))</span> <span class="math">\\mathbb{F}</span>-ops to combine <span class="math">\\{M_j^{(i)}\\}_{i,j=1}^{\\ell,t}</span> and <span class="math">\\{\\mathbf{v}^{(k)}\\}_{k=0}^s</span>.</li>

    </ul>

    <p class="text-gray-300">The folding scheme verifier</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>asks <span class="math">\\log m + \\log n</span> queries to <span class="math">\\mathbb{H}_{\\mathrm{sc}}</span> and <span class="math">\\log m + 2</span> queries to <span class="math">\\mathbb{H}</span>;</li>

      <li>checks sum-check protocols (steps 4,5,7,8 in zk-NIFS.V) with <span class="math">O(s_{1}(d\\log m + \\log n) + s_{2}(dq + d\\log m + \\log n))</span> <span class="math">\\mathbb{F}</span>-ops for all <span class="math">s_1</span> atomic CCS instances and <span class="math">s_2</span> committed CCS instances;</li>

      <li>performs <span class="math">O(s)</span> <span class="math">\\mathbb{G}</span>-ops to combine <span class="math">\\{C^{(k)}\\}_{k=0}^s</span>;</li>

      <li>performs <span class="math">O(\\ell N + s(n + t))</span> <span class="math">\\mathbb{F}</span>-ops to combine <span class="math">\\{M_j^{(i)}\\}_{i,j=1}^{\\ell,t}</span> and <span class="math">\\{\\mathbf{v}^{(k)}\\}_{k=0}^s</span>.</li>

    </ul>

    <p class="text-gray-300">We further mention a bonus feature of the ACCS relation for optimizing the performance above. In real-world implementations, instead of directly operating on the raw data of a matrix <span class="math">M</span>, we prefer to first squeeze the <span class="math">m \\cdot n</span> field elements into a group element as <span class="math">\\mathsf{Commit}(M)</span> with commitment schemes. Assume an output atomic CCS instance contains matrices <span class="math">\\{M_j\\}_{j \\in [t]}</span> and corresponding claim values <span class="math">\\{v_j\\}_{j=1}^t</span> in the generic folding scheme, we observe that it is feasible to apply a batch verification of all claims: instead of checking each claim independently, we can check only one claim on the aggregated matrices and values. To achieve this, the prover needs to compute <span class="math">\\sum_{j=1}^t \\mathsf{Commit}(M_j)</span> and <span class="math">\\sum_{j=1}^t v_j</span> if the discrete logarithm independence is satisfied among these commitments (If not, the prover needs to compute linear combinations). As a result, the <span class="math">t</span> matrix commitments and values of an atomic CCS instance can be aggregated into one matrix and one value, respectively. The number of matrix commitments in the folded instance sent to the next node is reduced from <span class="math">t</span> to 1. For input two instances, the communication complexity can be reduced from <span class="math">O(d \\log m + \\log n + tN)</span> to <span class="math">O(d \\log m + \\log n + N)</span>, while the prover and verifier need to perform extra <span class="math">st</span> group additions to aggregate matrix commitments.</p>

    <p class="text-gray-300">25</p>

    <p class="text-gray-300">5 KiloNova: Non-uniform Zero-knowledge PCD</p>

    <p class="text-gray-300">This section explains how to build non-uniform zero-knowledge PCD from the above-mentioned generic folding scheme. To begin with, we discuss the optimization technique used to reduce the overhead for handling structure folds in non-uniform PCD in Section 5.2. Based on this technique, we further construct zero-knowledge PCD from the zero-knowledge non-interactive generic folding scheme in Section 5.1.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">5.1 New Constructions for Zero-knowledge PCD</h3>

    <p class="text-gray-300">This part constructs zero-knowledge PCD from our zero-knowledge non-interactive generic folding scheme. If zero knowledge is not considered, one can directly adapt the scheme in <em>[39]</em> to build a PCD from the folding scheme. However, a technical gap exists when we try to achieve zero knowledge of PCD. According to the conclusion in <em>[15]</em>, a zero-knowledge PCD is built from an accumulation scheme (folding schemes in our paper) and an argument system (SNARK in <em>[14]</em> or NARK in <em>[14]</em>) for proving the recursive circuit, both of which are required to satisfy zero-knowledge. Unfortunately, in the construction of <em>[39]</em>, PCD prover only computes and outputs a committed CCS instance for the recursive circuit without providing zero knowledge. Adding zero-knowledge to the committed CCS instance will introduce extra prover cost, as discussed in Section 4.3.</p>

    <p class="text-gray-300">Therefore, we must find another efficient approach to realize the zero-knowledge PCD. The general idea is to reuse the zero-knowledge folding scheme to transform the committed CCS instance into a zero-knowledge atomic CCS instance. To achieve this, we need to redesign the original construction for PCD in <em>[39]</em>. To state the problem clearly, we describe the predicates represented by the recursive circuit as follows</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that the compliance predicate <span class="math">\\varphi(z,z_{\\mathsf{loc}},z_{1},...,z_{s})</span> satisfies.</li>

      <li>Check that the hash values for all input instances with non-empty <span class="math">z_{k},k\\in[s]</span> are valid.</li>

      <li>Run the zk-NIFS. <span class="math">\\mathcal{V}</span> algorithm to check the validity of the folded instance.</li>

      <li>Compute the hash value for the folded instance.</li>

    </ol>

    <p class="text-gray-300">Note that predicates 3 and 4 will not leak information about <span class="math">z_{\\mathsf{loc}},z_{1},...,z_{s}</span> since the generic folding scheme already achieves zero knowledge. Thus, we only need to preserve the privacy of the witness <span class="math">z_{\\mathsf{loc}},z_{1},...,z_{s}</span> for predicates 1 and 2 (<span class="math">z</span> is public). Thankfully, predicates 1 and 2 do not require the output of folding scheme zk-NIFS. <span class="math">\\mathcal{P}</span>, which means that they can be checked before the prover runs zk-NIFS. <span class="math">\\mathcal{P}</span>. We can split the circuit for the predicate into two parts as <span class="math">\\mathcal{R}_{0},\\mathcal{R}_{1}</span> and handle them respectively in different steps. As a result, the prover first computes the instance <span class="math">(\\mathbf{u}_{0},\\mathbf{w}_{0})</span> for <span class="math">\\mathcal{R}_{0}</span>, then folds it with other input instances. In the circuit <span class="math">\\mathcal{R}_{1}</span>, the validity of the folded instances <span class="math">\\mathbf{U}</span> is checked. And the prover computes another instance for <span class="math">\\mathcal{R}_{1}</span>.</p>

    <p class="text-gray-300">Compared to the original construction, PCD prover only needs to run the folding scheme with one more instance for <span class="math">\\mathcal{R}_{0}</span>, which adds negligible cost to its</p>

    <p class="text-gray-300">asymptotic complexity. We also show that this modification does not contradict the securities of PCD in Appendix C. Moreover, the same modification can be applied to the construction of zero-knowledge IVC as long as they are built from a multi-folding scheme.</p>

    <p class="text-gray-300"><strong>Construction 3 (A PCD from Generic Folding Schemes).</strong> Let zk-NIFS be the zero-knowledge non-interactive generic folding scheme for committed CCS and atomic CCS relations <span class="math">\\{\\mathcal{R}^{(i)}\\}_{i\\in [\\ell]}</span>. Let <span class="math">(\\mathbf{u}_{\\perp},\\mathbf{w}_{\\perp})</span> be a default trivially satisfying atomic CCS instance-witness pair for any structure and public parameters. According to the definition of PCD, we can construct a scheme consisting of polynomial-time algorithms <span class="math">\\mathsf{PCD} = (\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> for a class of compliance predicates <span class="math">\\mathsf{F}</span>. Besides, we assume all the structures used below are valid, which is guaranteed by the extra IVC for proving the structure folds.</p>

    <p class="text-gray-300">Denote a compliance predicate <span class="math">\\varphi</span> selected from <span class="math">\\mathsf{F}</span> with a cryptographic hash function <span class="math">\\mathsf{Hash}</span>, we first define the circuits <span class="math">R_0</span> and <span class="math">R_1</span> realizing the recursion on <span class="math">s</span> inputs of <span class="math">\\{z_k, \\mathbf{U}_k, \\mathbf{u}_k\\}_{k=1}^s</span>.</p>

    <div class="my-4 text-center"><span class="math-block">0/1 \\leftarrow R_0(h; (z, z_{\\text{loc}}, \\{z_k, \\mathbf{U}_k, \\mathbf{u}_k\\}_{k \\in [s]}, \\vee \\mathbf{k}&#x27;)):</span></div>

    <p class="text-gray-300">1: Check that the compliance predicate <span class="math">\\varphi (z,z_{\\mathrm{loc}},z_1,\\dots,z_s)</span> accepts. 2: For all <span class="math">k \\in [s]</span> such that <span class="math">z_k \\neq \\bot</span>, check that <span class="math">\\mathbf{u}_k.\\mathbf{i}\\mathbf{o} = \\mathsf{Hash}(\\mathsf{v}\\mathsf{k}&#x27;, z_k, \\mathbf{U}_k)</span>,</p>

    <p class="text-gray-300">where <span class="math">\\mathbf{u}_k.\\mathbf{i}\\mathbf{o}</span> is the public IO of <span class="math">\\mathbf{u}_k</span>.</p>

    <p class="text-gray-300">3: If the above checks hold, output 1; otherwise, output 0.</p>

    <p class="text-gray-300">Since <span class="math">R_0</span> can be computed in polynomial time, it can be represented as a <span class="math">\\mathcal{R}_{\\mathrm{CCCS}}</span> structure <span class="math">\\mathbf{s}_0</span>. Let</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbf{s}_0, \\mathbf{u}_0, \\mathbf{w}_0) \\leftarrow \\operatorname{trace}(R_0, (h, (z, z_{\\text{loc}}, \\{z_k, \\mathbf{U}_k, \\mathbf{u}_k\\}_{k \\in [s]}, \\vee \\mathbf{k}&#x27;)))</span></div>

    <p class="text-gray-300">denote the satisfied <span class="math">\\mathcal{R}_{\\mathrm{CCCS}}</span> instance for the execution of the circuit <span class="math">R_0</span> on input <span class="math">(h, (z, z_{\\mathrm{loc}}, \\{z_k, \\mathbf{U}_k, \\mathbf{u}_k\\}_{k \\in [s]}, \\vee \\mathbf{k}&#x27;)</span>.</p>

    <div class="my-4 text-center"><span class="math-block">0/1 \\leftarrow R_1(h; (\\{\\mathbf{U}_k, \\mathbf{u}_k\\}_{k \\in [s]}, \\mathbf{u}_0, \\vee \\mathbf{k}&#x27;, \\mathbf{U}, \\Pi)):</span></div>

    <p class="text-gray-300">1: If <span class="math">z_k = \\bot</span> for all <span class="math">k \\in [s]</span>, check that <span class="math">h = \\mathsf{Hash}(\\mathsf{v}\\mathsf{k}&#x27;, z, \\mathbf{U})</span> and <span class="math">\\mathbf{u}_0 = \\mathbf{U}</span>, else check that</p>

    <p class="text-gray-300">(a) <span class="math">\\mathbf{U} = \\mathsf{zk}\\text{-NIFS}.\\mathcal{V}&#x27;(\\mathsf{v}\\mathsf{k}&#x27;, \\{\\mathbf{U}_k, \\mathbf{u}_k\\}_{k \\in [s]}, \\mathbf{u}_0, \\Pi)</span>.</p>

    <p class="text-gray-300">(b) <span class="math">h = \\mathsf{Hash}(\\mathsf{v}\\mathsf{k}&#x27;, z, \\mathbf{U})</span>.</p>

    <p class="text-gray-300">2: If the above checks hold, output 1; otherwise, output 0.</p>

    <p class="text-gray-300">Since <span class="math">R_1</span> can be computed in polynomial time, it can be represented as a <span class="math">\\mathcal{R}_{\\mathrm{CCCS}}</span> structure <span class="math">\\mathbf{s}</span>. Let</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbf{s}, \\mathbf{u}, \\mathbf{w}) \\leftarrow \\operatorname{trace}(R_0, (h, (\\{\\mathbf{U}_k, \\mathbf{u}_k\\}_{k \\in [s]}, \\mathbf{u}_0, \\vee \\mathbf{k}&#x27;, \\mathbf{U}, \\Pi))</span></div>

    <p class="text-gray-300">denote the satisfied <span class="math">\\mathcal{R}_{\\mathrm{CCCS}}</span> instance for the execution of the circuit <span class="math">R_1</span> on input <span class="math">(h, (\\{\\mathbf{U}_k, \\mathbf{u}_k\\}_{k \\in [s]}, \\mathbf{u}_0, \\vee \\mathbf{k}&#x27;, \\mathbf{U}, \\Pi))</span>.</p>

    <p class="text-gray-300">Now, we can define the algorithms <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> for PCD.</p>

    <p class="text-gray-300">27</p>

    <p class="text-gray-300"><span class="math">\\mathsf{pp}\\gets \\mathcal{G}(1^{\\lambda})</span>  ..</p>

    <p class="text-gray-300">1: Compute and output  <span class="math">\\mathsf{pp}^{\\prime}\\gets \\mathsf{zk - NIFS}.\\mathcal{G}(1^{\\lambda})</span></p>

    <p class="text-gray-300"><span class="math">(\\mathsf{pk},\\mathsf{vk})\\gets \\mathcal{K}(\\mathsf{pp},\\varphi)</span></p>

    <p class="text-gray-300">1: Compute  <span class="math">(\\mathsf{pk}_{\\mathsf{fs}}^{\\prime},\\mathsf{vk}_{\\mathsf{fs}}^{\\prime})\\gets \\mathsf{zk - NIFS}.\\mathcal{K}^{\\prime}(\\mathsf{pp}^{\\prime},R_{\\varphi}).</span> 2: Output  <span class="math">(\\mathsf{pk},\\mathsf{vk})\\gets ((\\varphi ,\\mathsf{pk}_{\\mathsf{fs}}^{\\prime}),(\\varphi ,\\mathsf{vk}_{\\mathsf{fs}}^{\\prime}))</span></p>

    <p class="text-gray-300"><span class="math">\\varPi \\leftarrow \\mathcal{P}(\\mathsf{pk},z,z_{\\mathrm{loc}},\\{z_k,\\varPi_k\\}_{k = 1}^s)</span></p>

    <p class="text-gray-300">1: For  <span class="math">k \\in [s]</span> , parse  <span class="math">\\Pi_k</span>  as satisfied atomic CCS instance  <span class="math">(\\mathsf{S}_k, \\mathbf{U}_k, \\mathbf{W}_k)</span>  and satisfied committed CCS instance  <span class="math">(\\mathsf{s}_k, \\mathbf{u}_k, \\mathbf{w}_k)</span> . 2:  <span class="math">(\\mathsf{s}_0,\\mathbf{u}_0,\\mathbf{w}_0)\\gets \\mathsf{trace}(R_0,(h,(z,z_{\\mathrm{loc}},\\{z_k,\\mathbf{U}_k,\\mathbf{u}_k\\}_{k\\in [s]},\\mathsf{vk}^{\\prime}))</span> 3: If  <span class="math">z_{k} = \\bot</span>  for all  <span class="math">k \\in [s]</span> , then set  <span class="math">(\\mathbf{U}, \\mathbf{W}, \\mathsf{pf}) \\coloneqq (\\mathbf{u}_{0}, \\mathbf{w}_{0}, \\bot)</span> , else compute  <span class="math">(\\mathsf{S}, \\mathbf{U}, \\mathbf{W}, \\mathsf{pf}) \\gets \\mathsf{zk-NIFS}.\\mathcal{P}&#x27;(\\mathsf{pk}_{\\mathsf{fs}}, \\{\\mathsf{S}_{k}, \\mathbf{U}_{k}, \\mathbf{W}_{k}\\}_{k \\in [s]}, \\{\\mathsf{s}_{k}, \\mathbf{u}_{k}, \\mathbf{w}_{k}\\}_{k=0}^{s})</span> . 4: Compute  <span class="math">h \\gets \\mathsf{Hash}(\\mathsf{vk}_{\\mathsf{fs}}&#x27;, z, \\mathbf{U})</span> . 5:  <span class="math">(\\mathsf{s},\\mathbf{u},\\mathbf{w})\\gets \\mathsf{trace}(R_1,(h,(\\{\\mathbf{U}_k,\\mathbf{u}_k\\}_{k\\in [s]},\\mathbf{u}_0,\\mathsf{vk}_{\\mathsf{fs}}&#x27;,\\mathbf{U},\\mathsf{pf}))).</span> 6: Output  <span class="math">\\varPi:=((S,U,W),(s,u,w))</span></p>

    <p class="text-gray-300"><span class="math">0 / 1\\gets \\mathcal{V}(\\mathsf{vk},z,\\varPi)</span></p>

    <p class="text-gray-300">1: Parse  <span class="math">\\varPi</span>  as  <span class="math">((\\mathsf{S},\\mathbf{U},\\mathbf{W}),(\\mathsf{s},\\mathbf{u},\\mathbf{w}))</span> 2: Check that  <span class="math">\\mathbf{u}.\\mathbf{i}\\mathbf{o} = \\mathsf{Hash}(\\mathsf{vk}_{\\mathsf{fs}}^{\\prime},z,\\mathbf{U})</span> 3: Check that  <span class="math">\\mathbf{W}</span>  is a satisfied  <span class="math">\\mathcal{R}_{\\mathrm{ACCS}}</span>  witness to  <span class="math">\\mathbf{U}</span>  and  <span class="math">\\mathbf{w}</span>  is a satisfied  <span class="math">\\mathcal{R}_{\\mathrm{CCCS}}</span>  witness to  <span class="math">\\mathbf{u}</span> . 4: If the above checks hold, output 1; otherwise, output 0.</p>

    <p class="text-gray-300">Theorem 4.  <span class="math">\\mathsf{PCD} = (\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>  in Construction 3 for a class of compliance predicates  <span class="math">\\mathsf{F}</span>  with constant depth in definition XX satisfies the perfect completeness, knowledge soundness, and zero knowledge in the random oracle.</p>

    <p class="text-gray-300">The proof of Theorem 4 is presented in Appendix C. We present the evaluation of complexity below.</p>

    <p class="text-gray-300">Complexity. Denote the random oracle for sum-check protocol as  <span class="math">\\mathbb{H}_{\\mathrm{sc}}</span></p>

    <p class="text-gray-300">The recursive cost at each step contains</p>

    <p class="text-gray-300">computing the compliance predicate  <span class="math">\\varphi</span> computing  <span class="math">r</span>  times pf hash function Hash;</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>invoking  <span class="math">\\mathsf{zk}</span> -NIFS.  <span class="math">\\mathcal{V}&#x27;</span>  with  <span class="math">2\\log m + \\log n</span>  random oracle queries,  <span class="math">O(s(dq + d\\log m + \\log n))</span> <span class="math">\\mathbb{F}</span> -ops and  <span class="math">s</span> <span class="math">\\mathbb{G}</span> -ops.</li>

    </ul>

    <p class="text-gray-300">The native prover at each step cost contains</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>invoking  <span class="math">\\mathsf{zk}</span> -NIFS.  <span class="math">\\mathcal{P}&#x27;</span>  with  <span class="math">2\\log m + \\log n</span>  random oracle queries,  <span class="math">O(s(N + tm + qmd\\log^2 d))</span> <span class="math">\\mathbb{F}</span> -ops and  <span class="math">s</span> <span class="math">\\mathbb{G}</span> -ops;</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>computing 1 time of hash function Hash;</li>

      <li>computing two satisfying committed CCS instances for the execution of <span class="math">\\mathcal{R}_{0},\\mathcal{R}_{1}</span>, which is dominated by computing the commitment of witness <span class="math">\\mathbf{w}_{0},\\mathbf{w}</span> with <span class="math">O(n)</span> <span class="math">\\mathbb{G}</span>-ops.</li>

    </ul>

    <p class="text-gray-300">The proof <span class="math">\\Pi</span> consists of an atomic CCS instance <span class="math">(\\mathsf{S},\\mathbf{U},\\mathbf{W})</span> and a committed CCS instance <span class="math">(\\mathsf{s},\\mathbf{u},\\mathbf{w})</span>, which are linear in the size of <span class="math">\\mathcal{R}_{\\varphi}</span>. While according to previous work in Nova <em>[26]</em> and HyperNova <em>[25]</em>, we can fold these two instances with zk-NIFS. <span class="math">\\mathcal{P}</span> and apply a general SNARK (the folded instance is already zero-knowledge) to prove their validity. For example, instantiating a polynomial IOP based on Bulletproofs polynomial commitment schemes <em>[12]</em> for <span class="math">(\\mathsf{S},\\mathbf{U},\\mathbf{W})</span> and <span class="math">(\\mathsf{s},\\mathbf{u},\\mathbf{w})</span> can reduce the proof size to <span class="math">O(\\log m)</span>.</p>

    <p class="text-gray-300">The PCD verifier cost contains</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>invoking zk-NIFS. <span class="math">\\mathcal{V}</span> for two instances with <span class="math">2\\log m+\\log n</span> random oracle queries, <span class="math">O((dq+d\\log m+\\log n))</span> <span class="math">\\mathbb{F}</span>-ops and 2 <span class="math">\\mathbb{G}</span>-ops;</li>

      <li>verification of polynomial commitments with <span class="math">O(\\log n)</span> random oracle queries and <span class="math">O(n)</span> <span class="math">\\mathbb{G}</span>-ops;</li>

      <li>verification of the IVC system for structure folds with <span class="math">O(mn)</span> <span class="math">\\mathbb{F}</span>-ops.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The security of the folding scheme still holds. Here, we only give sketch proof of the knowledge soundness. Assume the original folding scheme zk-NIFS satisfies knowledge soundness. Thus, there exists an extractor <span class="math">\\mathsf{Ext}</span> runs in polynomial time for zk-NIFS, which succeeds in extracting witness with non-negligible probability <span class="math">\\epsilon</span>. For the new aggregated folding scheme, an extractor <span class="math">\\mathsf{Ext}^{\\prime}</span> can also be constructed by calling <span class="math">\\mathsf{Ext}</span>. The extractor <span class="math">\\mathsf{Ext}^{\\prime}</span> invokes <span class="math">\\mathsf{Ext}</span> to obtain <span class="math">t</span> transcripts, each with different challenge <span class="math">\\zeta^{(i)},i=1,..,t</span>. By interpolating, the extractor can compute the matrices <span class="math">\\{M_{j}^{<em>}\\}_{j\\in[t]}</span> and values <span class="math">\\{v_{j}^{</em>}\\}_{j=1}^{t}</span> from the linear combined <span class="math">M^{<em>}</span> and <span class="math">v^{</em>}</span>. It is naive to argue that <span class="math">\\mathsf{Ext}^{\\prime}</span> runs in polynomial time. For the advantage <span class="math">\\mathsf{Ext}^{\\prime}</span> succeeds with probability <span class="math">(\\epsilon-\\mathrm{negl}(\\lambda))\\cdot(1-\\mathrm{negl}(\\lambda))</span>. This is because given that <span class="math">\\mathsf{Ext}</span> does not abort, the probability that different challenges are sampled with less than <span class="math">\\sqrt[4\\times 1]{\\lvert\\overline{\\mathbb{F}}\\rvert}</span> rewinds, i.e., <span class="math">\\zeta^{(1)}\\neq\\cdots\\neq\\zeta^{(t)}</span>, is $(1-O(1)/\\sqrt[4\\times 1]{\\lvert\\overline{\\mathbb{F}}\\rvert})\\cdot\\epsilon\\cdot(1-\\sqrt[4\\times 1]{\\lvert\\overline{\\mathbb{F}}\\rvert}^{d}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">5.2 Delegation Schemes.</h3>

    <p class="text-gray-300">First, we explain the complexity problem caused by structure folds and highlight the necessity of applying our optimization techniques. In real-world implementations, the folding scheme verifier does not directly compute the linear combination of matrices as described in step 11 of zk-NIFS. <span class="math">\\mathcal{V}</span>. Instead, commitments on each matrix are used according to Protostar and Protogalaxy <em>[13, 20]</em>, which incurs a large number of group scalar multiplications in the recursive circuits when handling multiple non-uniform instances. Take our generic foldings scheme as an example, the verifier zk-NIFS. <span class="math">\\mathcal{V}</span> needs to compute the linear combination of matrix commitments <span class="math">\\{\\mathsf{Commit}(M_{j}^{(i)})\\}_{i\\in[\\ell]}</span> for all <span class="math">j=[t]</span>, leading to <span class="math">O(\\ell\\cdot t)</span> <span class="math">\\mathbb{G}</span> operations in total. This raises complexity concerns for PCD, especially when the</p>

    <p class="text-gray-300">prover needs to fold multiple instances with different structures among mutually distrustful nodes. On the one hand, the verification logic should be written into the recursive circuit, increasing the prover cost. On the other hand, the folded matrix commitments should be sent to the next node in PCD, incurring a high communication cost.</p>

    <p class="text-gray-300">To alleviate this problem, we introduce an optimization technique for delegating the costly structure folds. In our folding scheme, the prover folds the structures by computing the linear combinations of public matrices, and the verifier repeats the same process. We observe that this subprotocol is independent of other steps in the folding scheme. Thus, the original prover can prove the structure folds by delegating to a third party <span class="math">^{8}</span> . This is because the matrices are selected from a public list, e.g., an instruction set. Such delegation is extremely useful for optimizing the performance of PCD because the delegated computation is an IVC executed by only one prover, which avoids communication between different nodes. As a result, we can safely remove the verification of structure folds from the original prover as long as ensuring the consistency of the challenge for folding. This observation also applies to other non-uniform folding schemes such as Protostar and Protogalaxy [13,20]. Concretely, the prover runs another IVC system for iteratively computing the linear combination of matrix commitments for folding the structure. We believe an IVC system instantiated from Nova [26] is sufficient for this task. One thing left is to ensure the delegated prover uses the same challenge  <span class="math">\\eta</span>  as the original prover. To achieve this, we can instantiate an accumulator with the binding property in both parties. A naive approach is computing an extra function as  <span class="math">r_i = \\mathsf{Hash}(r_{i-1}, \\eta_i)</span>  at each step. Other existing accumulators, such as [4], can also be utilized. Since these accumulators are also incremental computations, it is natural to add this computation in the original function  <span class="math">F</span>  in the IVC system. Figure 4 illustrate this construction in details.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 4: Delegation schemes for PCD. The structure folds are delegated to a third party running the IVC. To ensure the soundness property, an extra accumulation for the challenge  <span class="math">\\eta</span>  should be instantiated in the recursive circuits marked in the red box. The binding property guarantees that PCD and IVC always use the same  <span class="math">\\eta</span>  for folding.</p>

    <p class="text-gray-300">Acknowledgement</p>

    <p class="text-gray-300">We would like to thank Binyi Chen and Benedikt Bünz from Espresso Systems for the inspiring discussions about the technical details of ProtoStar. We would also like to thank Yingfei from the Secbit zero-knowledge discussion group, Josh Beal from Yale University and Yanpei Guo from Beihang University for helping proof-read our paper. This research has received partial support from HK RGC GRF under Grants PolyU 15216721, 15207522, 15202123, and NSFC Youth 62302418.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Beal, J., Fisch, B.: Derecho: Privacy pools with proof-carrying disclosures. Cryptology ePrint Archive (2023)</li>

      <li>[2] Bellare, M., Garay, J.A., Rabin, T.: Fast batch verification for modular exponentiation and digital signatures. In: Advances in Cryptology—EUROCRYPT’98: International Conference on the Theory and Application of Cryptographic Techniques Espoo, Finland, May 31–June 4, 1998 Proceedings 17. pp. 236–250. Springer (1998)</li>

      <li>[3] Bitansky, N., Canetti, R., Chiesa, A., Tromer, E.: Recursive composition and bootstrapping for snarks and proof-carrying data. In: Proceedings of the forty-fifth annual ACM symposium on Theory of computing. pp. 111–120 (2013)</li>

      <li>[4] Boneh, D., Bünz, B., Fisch, B.: Batching techniques for accumulators with applications to iops and stateless blockchains. In: Advances in Cryptology–CRYPTO 2019: 39th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 18–22, 2019, Proceedings, Part I 39. pp. 561–586. Springer (2019)</li>

      <li>[5] Boneh, D., Drake, J., Fisch, B., Gabizon, A.: Halo infinite: Proof-carrying data from additive polynomial commitments. In: Advances in Cryptology–CRYPTO 2021: 41st Annual International Cryptology Conference, CRYPTO 2021, Virtual Event, August 16–20, 2021, Proceedings, Part I 41. pp. 649–680. Springer (2021)</li>

      <li>[6] Bonneau, J., Meckler, I., Rao, V.: Coda: Decentralized cryptocurrency at scale. Cryptology ePrint Archive (2020)</li>

      <li>[7] Bonneau, J., Meckler, I., Rao, V., Shapiro, E.: Mina: Decentralized cryptocurrency at scale. New York Univ. O (1) Labs, New York, NY, USA, Whitepaper pp. 1–47 (2020)</li>

      <li>[8] Bootle, J., Cerulli, A., Chaidos, P., Groth, J., Petit, C.: Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In: Advances in Cryptology–EUROCRYPT 2016: 35th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Vienna, Austria, May 8-12, 2016, Proceedings, Part II 35. pp. 327–357. Springer (2016)</li>

      <li>[9] Bootle, J., Chiesa, A., Liu, S.: Zero-knowledge iops with linear-time prover and polylogarithmic-time verifier. In: Annual International Conference on the Theory and Applications of Cryptographic Techniques. pp. 275–304. Springer (2022)</li>

      <li>[10] Bowe, S., Grigg, J., Hopwood, D.: Recursive proof composition without a trusted setup. Cryptology ePrint Archive (2019)</li>

      <li>[11] Bowe, S., Grigg, J., Hopwood, D.: Halo2. https://github. com/zcash/halo2 (2020)</li>

      <li>[12] Bünz, B., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., Maxwell, G.: Bulletproofs: Short proofs for confidential transactions and more. In: 2018 IEEE symposium on security and privacy (SP). pp. 315–334. IEEE (2018)</li>

      <li>[13] Bünz, B., Chen, B.: Protostar: Generic efficient accumulation/folding for special sound protocols. Cryptology ePrint Archive (2023)</li>

      <li>[14] Bünz, B., Chiesa, A., Lin, W., Mishra, P., Spooner, N.: Proof-carrying data without succinct arguments. In: Advances in Cryptology–CRYPTO 2021: 41st Annual International Cryptology Conference, CRYPTO 2021, Virtual Event, August 16–20, 2021, Proceedings, Part I 41. pp. 681–710. Springer (2021)</li>

      <li>[15] Bünz, B., Chiesa, A., Mishra, P., Spooner, N.: Proof-carrying data from accumulation schemes. Cryptology ePrint Archive (2020)</li>

      <li>[16] Bünz, B., Fisch, B., Szepieniec, A.: Transparent snarks from dark compilers. In: Advances in Cryptology–EUROCRYPT 2020: 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zagreb, Croatia, May 10–14, 2020, Proceedings, Part I 39. pp. 677–706. Springer (2020)</li>

      <li>[</li>

    </ul>

    <p class="text-gray-300">17] Chiesa, A., Forbes, M.A., Spooner, N.: A zero knowledge sumcheck and its applications. arXiv preprint arXiv:1704.02086 (2017)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[18] Chiesa, A., Tromer, E., Virza, M.: Cluster computing in zero knowledge. In: Advances in Cryptology-EUROCRYPT 2015: 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part II 34. pp. 371–403. Springer (2015)</li>

      <li>[19] Chu, S., Gomes, B.H., Iglesias, F.H., Norton, T., Tebbs, D.: Uniplonk: Plonk with universal verifier. Cryptology ePrint Archive (2023)</li>

      <li>[20] Eagen, L., Gabizon, A.: Protogalaxy: Efficient protostar-style folding of multiple instances. Cryptology ePrint Archive (2023)</li>

      <li>[21] Fiat, A., Shamir, A.: How to prove yourself: Practical solutions to identification and signature problems. In: Conference on the theory and application of cryptographic techniques. pp. 186–194. Springer (1986)</li>

      <li>[22] Gabizon, A., Williamson, Z.J., Ciobotaru, O.: Plonk: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive (2019)</li>

      <li>[23] Kate, A., Zaverucha, G.M., Goldberg, I.: Constant-size commitments to polynomials and their applications. In: Advances in Cryptology-ASIACRYPT 2010: 16th International Conference on the Theory and Application of Cryptology and Information Security, Singapore, December 5-9, 2010. Proceedings 16. pp. 177–194. Springer (2010)</li>

      <li>[24] Kothapalli, A., Setty, S.: Supernova: Proving universal machine executions without universal circuits. Cryptology ePrint Archive (2022)</li>

      <li>[25] Kothapalli, A., Setty, S.: Hypernova: Recursive arguments for customizable constraint systems. Cryptology ePrint Archive (2023)</li>

      <li>[26] Kothapalli, A., Setty, S., Tzialla, I.: Nova: Recursive zero-knowledge arguments from folding schemes. In: Annual International Cryptology Conference. pp. 359–388. Springer (2022)</li>

      <li>[27] Lund, C., Fortnow, L., Karloff, H., Nisan, N.: Algebraic methods for interactive proof systems. Journal of the ACM (JACM) 39(4), 859–868 (1992)</li>

      <li>[28] Maller, M., Bowe, S., Kohlweiss, M., Meiklejohn, S.: Sonic: Zero-knowledge snarks from linear-size universal and updatable structured reference strings. In: Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security. pp. 2111–2128 (2019)</li>

      <li>[29] Schwartz, J.T.: Fast probabilistic algorithms for verification of polynomial identities. Journal of the ACM (JACM) 27(4), 701–717 (1980)</li>

      <li>[30] Setty, S.: Spartan: Efficient and general-purpose zksnarks without trusted setup. In: Annual International Cryptology Conference. pp. 704–737. Springer (2020)</li>

      <li>[31] Setty, S., Thaler, J., Wahby, R.: Customizable constraint systems for succinct arguments. Cryptology ePrint Archive (2023)</li>

      <li>[32] Thaler, J.: Time-optimal interactive proofs for circuit evaluation. In: Annual Cryptology Conference. pp. 71–89. Springer (2013)</li>

      <li>[33] Thaler, J., et al.: Proofs, arguments, and zero-knowledge. Foundations and Trends® in Privacy and Security 4(2–4), 117–660 (2022)</li>

      <li>[34] Valiant, P.: Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In: Theory of Cryptography: Fifth Theory of Cryptography Conference, TCC 2008, New York, USA, March 19-21, 2008. Proceedings 5. pp. 1–18. Springer (2008)</li>

      <li>[35] Xie, T., Zhang, J., Zhang, Y., Papamanthou, C., Song, D.: Libra: Succinct zero-knowledge proofs with optimal prover computation. In: Advances in Cryptology–CRYPTO 2019: 39th Annual International Cryptology Conference, Santa Barbara,</li>

    </ul>

    <p class="text-gray-300">CA, USA, August 18–22, 2019, Proceedings, Part III 39. pp. 733–764. Springer (2019)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Xie, T., Zhang, J., Cheng, Z., Zhang, F., Zhang, Y., Jia, Y., Boneh, D., Song, D.: zkbridge: Trustless cross-chain bridges made practical. In: Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security. pp. 3003–3017 (2022)</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Xie, T., Zhang, Y., Song, D.: Orion: Zero knowledge proof with linear prover time. In: Annual International Cryptology Conference. pp. 299–328. Springer (2022)</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Zheng, T., Gao, S., Song, Y., Xiao, B.: Leaking arbitrarily many secrets: Any-out-of-many proofs and applications to ringct protocols. In: 2023 IEEE Symposium on Security and Privacy (SP). pp. 2533–2550. IEEE (2023)</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Zhou, Z., Zhang, Z., Dong, J.: Proof-carrying data from multi-folding schemes. Cryptology ePrint Archive (2023)</li>

    </ol>

    <h2 id="sec-43" class="text-2xl font-bold">A Formal Definitions</h2>

    <h3 id="sec-44" class="text-xl font-semibold mt-8">A.1 Security Definitions for Polynomial Commitment</h3>

    <p class="text-gray-300">A PC is an extractable polynomial commitment scheme for multilinear polynomials over a finite field <span class="math">\\mathbb{F}</span> if it satisfies completeness, binding, and knowledge soundness properties as defined below.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. PC has completeness if for all <span class="math">\\ell</span>-variate multilinear polynomial <span class="math">g \\in \\mathbb{F}[\\ell]</span>,</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{l} \\operatorname{Eval}(\\mathfrak{pp}_{\\mathfrak{pc}}, C, \\ell, r, v; f) = 1 \\\\ \\wedge f(r) = v \\end{array} \\right] \\begin{array}{l} \\mathfrak{pp}_{\\mathfrak{pc}} \\leftarrow \\operatorname{Setup}(1^{\\lambda}, \\ell); \\\\ C \\leftarrow \\operatorname{Commit}(\\mathfrak{pp}_{\\mathfrak{pc}}, f) \\end{array} = 1.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Binding. PC has binding if for any PPT adversary <span class="math">\\mathcal{A}</span>, size parameter <span class="math">\\ell &amp;gt; 1</span>,</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{l} b_0 = b_1 \\neq 0 \\\\ \\wedge f_0 \\neq f_1 \\end{array} \\right] \\begin{array}{l} \\mathfrak{pp}_{\\mathfrak{pc}} \\leftarrow \\operatorname{Setup}(1^{\\lambda}, \\ell); (C, f_0, f_1) \\leftarrow \\mathcal{A}(\\mathfrak{pp}_{\\mathfrak{pc}}); \\\\ b_0 \\leftarrow \\operatorname{Open}(\\mathfrak{pp}_{\\mathfrak{pc}}, C, f_0); b_1 \\leftarrow \\operatorname{Open}(\\mathfrak{pp}_{\\mathfrak{pc}}, C, f_1) \\end{array} \\leq \\operatorname{negl}(\\lambda).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge soundness. PC has knowledge soundness if given <span class="math">\\mathfrak{pp}_{\\mathfrak{pc}} \\gets \\operatorname{Setup}(1^{\\lambda}, \\ell)</span>, Eval is a succinct argument of knowledge for NP relation</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\operatorname{Eval}}(\\mathfrak{pp}_{\\mathfrak{pc}}) = \\{(C, r, v; f): f \\in \\mathbb{F}[\\ell] \\wedge f(r) = v \\wedge \\operatorname{Open}(\\mathfrak{pp}_{\\mathfrak{pc}}, C, f) = 1\\}.</span></div>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">A.2 Security Definitions for PCD</h3>

    <p class="text-gray-300">A proof-carrying data scheme PCD should satisfy the perfect completeness, knowledge soundness, and zero-knowledge properties.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Perfect Completeness. PCD has perfect completeness if for every adversary <span class="math">\\mathcal{A}</span>,</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{c} \\mathcal{V}(\\mathsf{vk}, z, \\Pi) = 1 \\\\ \\mathcal{V}(\\mathsf{vk}, z, \\Pi) = 1 \\end{array} \\begin{array}{c} \\mathfrak{pp} \\leftarrow \\mathcal{G}(1^{\\lambda}); \\\\ (\\varphi, z, z_{\\mathrm{loc}}, \\{z_i, \\Pi_i\\}_{i=1}^r) \\leftarrow \\mathcal{A}(\\mathfrak{pp}); \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathcal{K}(\\mathfrak{pp}, \\varphi); \\\\ \\varphi \\in \\mathsf{F}; \\varphi(z, z_{\\mathrm{loc}}, \\{z_i\\}_{i=1}^r) = 1; \\\\ \\forall i \\in [r], z_i = \\bot \\text{ or } \\mathcal{V}(\\mathsf{vk}, z_i, \\Pi_i) = 1; \\\\ \\Pi \\leftarrow \\mathcal{P}(\\mathsf{pk}, z, z_{\\mathrm{loc}}, \\{z_i, \\Pi_i\\}_{i=1}^r) \\end{array} \\right] = 1.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge soundness. PCD has knowledge soundness (w.r.t. an auxiliary input distribution <span class="math">\\mathcal{D}</span>) if for every expected polynomial time adversary <span class="math">\\mathcal{P}^<em></span>, there exists an expected polynomial time extractor <span class="math">\\operatorname{Ext}_{\\mathcal{P}^</em>}</span> such that for every set <span class="math">Z</span>,</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{l} \\varphi \\in \\mathsf{F} \\\\ \\wedge (\\mathsf{pp}, \\mathsf{ai}, \\varphi, \\circ (\\mathsf{T}), \\mathsf{ao}) \\in Z \\\\ \\wedge \\mathsf{T} \\text{ is } \\varphi\\text{-compliant} \\end{array} \\right] \\begin{array}{l} \\mathsf{pp} \\leftarrow \\mathcal{G}(1^{\\lambda}); \\\\ \\mathsf{ai} \\leftarrow \\mathcal{D}(\\mathsf{pp}); \\\\ (\\varphi, \\mathsf{T}, \\mathsf{ao}) \\leftarrow \\operatorname{Ext}_{\\mathcal{P}^*}(\\mathsf{pp}, \\mathsf{ao}) \\end{array} \\geq</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{l} \\varphi \\in \\mathsf{F} \\\\ \\wedge (\\mathsf{pp}, \\mathsf{ai}, \\varphi, \\circ, \\mathsf{ao}) \\in Z \\\\ \\wedge \\mathcal{V}(\\mathsf{vk}, \\circ, \\varPi) = 1 \\end{array} \\right] \\begin{array}{l} \\mathsf{pp} \\leftarrow \\mathcal{G}(1^{\\lambda}); \\\\ \\mathsf{ai} \\leftarrow \\mathcal{D}(\\mathsf{pp}); \\\\ (\\varphi, \\circ, \\varPi, \\mathsf{ao}) \\leftarrow \\mathcal{P}^*(\\mathsf{pp}, \\mathsf{ai}); \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathcal{K}(\\mathsf{pp}, \\varphi) \\end{array} \\quad -\\operatorname{negl}(\\lambda).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Zero Knowledge. PCD has (statistical) zero knowledge if there exists a probabilistic polynomial-time simulator <span class="math">\\mathsf{Sim}</span> such that for every polynomial-size honest adversary <span class="math">\\mathcal{A}</span> the distributions below are computationally indistinguishable:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} (\\mathsf{pp}, \\varPi) \\end{array} \\right. \\begin{array}{l} \\mathsf{pp} \\leftarrow \\mathcal{G}(1^{\\lambda}); \\\\ (\\varphi, z, z_{\\mathrm{loc}}, [z_i, \\varPi_i]_{i=1}^r) \\leftarrow \\mathcal{A}(\\mathsf{pp}); \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathcal{K}(\\mathsf{pp}, \\varphi); \\\\ \\varPi \\leftarrow \\mathcal{P}(\\mathsf{pk}, \\varphi, z, z_{\\mathrm{loc}}, [z_i, \\varPi_i]_{i=1}^r) \\end{array}</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} (\\mathsf{pp}, \\varPi) \\end{array} \\right. \\begin{array}{l} (\\mathsf{pp}, \\tau) \\leftarrow \\operatorname{Sim}(1^{\\lambda}); \\\\ (\\varphi, z, z_{\\mathrm{loc}}, [z_i, \\varPi_i]_{i=1}^r) \\leftarrow \\mathcal{A}(\\mathsf{pp}); \\\\ \\varPi \\leftarrow \\operatorname{Sim}(\\mathsf{pp}, \\varphi, z, \\tau) \\end{array}.</span></div>

    <h2 id="sec-46" class="text-2xl font-bold">A.3 Definitions for CCS</h2>

    <p class="text-gray-300"><strong>Definition 12 (CCS [31]).</strong> We define the customizable constraint system (CCS) relation <span class="math">\\mathcal{R}_{\\mathrm{CCS}}</span> as follows. Let the public parameter consist of size bounds <span class="math">m, n, N</span>, <span class="math">l, t, q, d \\in \\mathbb{N}</span> where <span class="math">n &amp;gt; l</span>.</p>

    <p class="text-gray-300">An <span class="math">\\mathcal{R}_{\\mathrm{CCS}}</span> structure <span class="math">\\mathcal{S}</span> consists of:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a sequence of matrices <span class="math">\\{M_j \\in \\mathbb{F}^{m \\times n}\\}_{j \\in [t]}</span> with at most <span class="math">N = \\Omega(\\max(m, n))</span> non-zero entries in total;</li>

      <li>a sequence of <span class="math">q</span> multisets <span class="math">\\{S_i\\}_{i \\in [q]}</span>, where an element in each multiset is from the domain <span class="math">\\{1, \\dots, t\\}</span> and the cardinality of each multiset is at most <span class="math">d</span>.</li>

      <li>a sequence of <span class="math">q</span> constants <span class="math">\\{c_i\\}_{i \\in [q]}</span>, where each constant is from <span class="math">\\mathbb{F}</span>.</li>

    </ul>

    <p class="text-gray-300">A <span class="math">\\mathcal{R}_{\\mathrm{CCS}}</span> instance consists of public input and output <span class="math">\\mathbf{i}\\mathbf{o} \\in \\mathbb{F}^l</span>.</p>

    <p class="text-gray-300">A <span class="math">\\mathcal{R}_{\\mathrm{CCS}}</span> witness consists of a vector <span class="math">\\mathbf{w} \\in \\mathbb{F}^{n - l - 1}</span>.</p>

    <p class="text-gray-300">A <span class="math">\\mathcal{R}_{\\mathrm{CCS}}</span> instance <span class="math">\\mathbf{i}\\mathbf{o}</span> with structure <span class="math">\\mathcal{S}</span> is satisfied by a <span class="math">\\mathcal{R}_{\\mathrm{CCS}}</span> witness <span class="math">\\mathbf{w}</span> if</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i \\in [q]} c_i \\cdot \\bigcirc_{j \\in S_i} M_j \\cdot \\boldsymbol{z} = \\mathbf{0}, \\tag{6}</span></div>

    <p class="text-gray-300">where <span class="math">\\boldsymbol{z} = (\\mathbf{w}, 1, \\mathbf{i}\\mathbf{o}) \\in \\mathbb{F}^n</span>, <span class="math">M_j \\cdot \\boldsymbol{z}</span> denotes matrix-vector multiplication, <span class="math">\\bigcirc</span> denotes the Hadamard product between vectors, and <span class="math">\\mathbf{0}</span> is an <span class="math">m</span>-sized vector with entries equal to the additive identity in <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">35</p>

    <p class="text-gray-300">B Details for Generic Folding Schemes</p>

    <p class="text-gray-300">We first present two special sound protocols for committed CCS and atomic CCS relations separately to illustrate how to run “early stopping” SuperSpartan for them. According to the workflow in Figure 3, one can first assume running the special sound protocol for each instance independently and then applying aggregation techniques for their intermediate steps, e.g., sum-check protocols and polynomial evaluations.</p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">B.1 Special Sound Protocol for Committed CCS</h3>

    <p class="text-gray-300">This part describes special sound protocols for the committed CCS relation <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span>. The basic idea is to commit the special sound protocol in SuperSpartan <em>[31]</em>. Unlike the general-purpose protocol described in Protostar <em>[13]</em>, the special sound protocol we used is specified for concrete CCS relations because the relation itself is already expressive enough. Note that Protostar also covers CCS relations with their special sound protocol to manifest expressiveness. While their protocols are not based on sum-check protocols. The performance of the final scheme is still restricted by the accumulation scheme they proposed.</p>

    <p class="text-gray-300">We instantiate a protocol with a series of interactions between two parties <span class="math">(\\mathcal{P},\\mathcal{V})</span>, checking the validity of relation <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span> by running sum-check protocols on the target multi-variate polynomials. The running steps of the protocol are given in <span class="math">\\Pi_{\\mathsf{CCCS}}</span> below. Specifically, the prover wants to convince that Equation (2) holds for all <span class="math">\\bm{x}\\in\\{0,1\\}^{s_{x}}</span>. To check this equation with sum-check protocol, a trick is introduced in Spartan <em>[30]</em>: if multiply each value with a corresponding term <span class="math">\\widetilde{eq}(\\bm{\\alpha},\\bm{x})</span> with random chosen <span class="math">\\bm{\\alpha}</span>, then their sum equals to zero only when all values equal to zero with high probability. Formally, denote <span class="math">\\widetilde{F}(\\bm{x})</span> as</p>

    <p class="text-gray-300"><span class="math">\\widetilde{F}(\\bm{x})=\\sum_{i\\in[q]}c_{i}\\left(\\prod_{j\\in S_{i}}\\left(\\sum_{\\bm{y}\\in\\{0,1\\}^{s_{y}}}\\widetilde{M}_{j}(\\bm{x},\\bm{y})\\cdot\\tilde{z}(\\bm{y})\\right)\\right),</span></p>

    <p class="text-gray-300">denote <span class="math">\\widetilde{Q}(\\bm{t})</span> as</p>

    <p class="text-gray-300"><span class="math">\\widetilde{Q}(\\bm{t})=\\sum_{\\bm{x}\\in\\{0,1\\}^{s_{x}}}\\widetilde{F}(\\bm{x})\\cdot\\widetilde{eq}(\\bm{t},\\bm{x}),</span></p>

    <p class="text-gray-300">where <span class="math">\\widetilde{eq}(\\bm{t},\\bm{x})=\\prod_{i=1}^{s_{x}}(t_{i}\\cdot x_{i}+(1-t_{i})\\cdot(1-x_{i}))</span>. Note that <span class="math">Q(\\bm{t})</span> is a multivariate polynomial evaluates to <span class="math">\\widetilde{F}(\\bm{t})</span> for all <span class="math">\\bm{t}\\in\\{0,1\\}^{s_{x}}</span>. Therefore, <span class="math">Q(\\bm{t})</span> is a zero-polynomial if and only if <span class="math">\\widetilde{F}(\\bm{x})</span> evaluates to zero everywhere on <span class="math">\\bm{x}\\in\\{0,1\\}^{s_{x}}</span> (that is, the CCS relation is satisfied). To check whether <span class="math">Q(\\bm{t})</span> is a zero-polynomial, it is sufficient to query its value on a random input <span class="math">\\bm{t}=\\bm{\\alpha}</span> with an acceptable soundness error.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Lemma 3.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\bm{\\alpha}}\\{Q(\\alpha)=0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\exists\\bm{x}\\in\\{0,1\\}^{s_{x}}\\ s.t.\\ \\widetilde{F}(\\bm{x})\\neq 0\\}\\leq\\log m/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-49" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Refers to the proof of Lemma 4.3 in Spartan <em>[30]</em>. ∎</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">As a result, the prover runs the first sum-check protocol at step 4 on the polynomial  <span class="math">f(\\pmb{x})</span>  with the randomness  <span class="math">\\alpha, r_x</span>  given by the verifier at step 1 and 2, where  <span class="math">\\mathrm{sum}_x = 0</span> .</p>

    <p class="text-gray-300">Special Sound Protocol  <span class="math">\\Pi_{\\mathrm{CCCS}} = (\\mathcal{P},\\mathcal{V})</span>  for relation  <span class="math">\\mathcal{R}_{\\mathrm{CCCS}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  : Sample  <span class="math">\\pmb{\\alpha} \\gets \\mathbb{F}^{s_x}</span>  and send to  <span class="math">\\mathcal{P}</span> .</li>

      <li><span class="math">\\mathcal{V}</span>  : Sample  <span class="math">\\pmb{r}_x\\gets \\mathbb{F}^{s_x}</span></li>

      <li><span class="math">\\mathcal{P}</span>  : Compute  <span class="math">\\tilde{z} (\\pmb {y}) = (\\widetilde{\\pmb{w},1,\\pmb{io}})</span></li>

      <li>Sum-check#1. Run  <span class="math">c_x \\gets \\Pi_{\\mathrm{sc}}(f, s_x, d + 1, \\mathrm{sum}_x, \\boldsymbol{r}_x)</span>  where:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">f (\\boldsymbol {x}) = \\widetilde {e q} (\\boldsymbol {\\alpha}, \\boldsymbol {x}) \\cdot \\left(\\sum_ {i \\in [ q ]} c _ {i} \\cdot \\prod_ {j \\in S _ {i}} \\left(\\sum_ {\\boldsymbol {y} \\in \\{0, 1 \\} ^ {s _ {y}}} \\widetilde {M} _ {j} (\\boldsymbol {x}, \\boldsymbol {y}) \\cdot \\tilde {z} (\\boldsymbol {y})\\right)\\right).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  : Compute  <span class="math">\\{\\sigma_j\\}_{j\\in [t]}</span>  and send to  <span class="math">\\nu</span>  , where for all  <span class="math">j\\in [t]</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\sigma_ {j} = \\sum_ {\\boldsymbol {y} \\in \\{0, 1 \\} ^ {s _ {y}}} \\widetilde {M} _ {j} (\\boldsymbol {r} _ {x}, \\boldsymbol {y}) \\cdot \\tilde {z} (\\boldsymbol {y}).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  : Compute  <span class="math">e\\gets \\widetilde{eq} (\\pmb {\\alpha},\\pmb {r}_x)</span>  , and abort if:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">c _ {x} \\neq e \\cdot \\sum_ {i \\in [ q ]} c _ {i} \\cdot \\prod_ {j \\in S _ {i}} \\sigma_ {j}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  : Sample  <span class="math">\\delta \\gets \\mathbb{F}</span> , and send to  <span class="math">\\mathcal{P}</span> .</li>

      <li><span class="math">\\mathcal{V}</span>  : Sample  <span class="math">\\pmb{r}_y\\gets \\mathbb{F}^{s_y}</span></li>

      <li>Sum-check#2. Run  <span class="math">c_{y} \\gets \\Pi_{\\mathrm{sc}}(g, s_{y}, 2, \\mathrm{sum}_{y}, \\boldsymbol{r}_{y})</span>  where:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">g (\\boldsymbol {y}) = \\sum_ {j \\in [ t ]} \\delta^ {j} \\cdot \\widetilde {M} _ {j} (\\boldsymbol {r} _ {x}, \\boldsymbol {y}) \\cdot \\tilde {z} (\\boldsymbol {y}).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  : Compute  <span class="math">\\epsilon, \\{\\theta_j\\}_{j \\in [t]}</span>  and send to  <span class="math">\\mathcal{V}</span> , where for all  <span class="math">j \\in [t]</span> :</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\epsilon = \\tilde {z} (\\boldsymbol {r} _ {y}), \\theta_ {j} = \\widetilde {M} _ {j} (\\boldsymbol {r} _ {x}, \\boldsymbol {r} _ {y}).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  : Abort if:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">c _ {y} \\neq \\sum_ {j \\in [ t ]} \\delta^ {j} \\cdot \\theta_ {j} \\cdot \\epsilon .</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  : Open the witness  <span class="math">\\widetilde{\\mathbf{w}}</span></li>

      <li><span class="math">\\mathcal{V}</span>  : Check that</li>

    </ol>

    <p class="text-gray-300">(1) Commit  <span class="math">(\\mathsf{pp},\\widetilde{\\mathbf{w}}) = C</span> (2)  <span class="math">\\epsilon = \\tilde{z} (\\pmb {r}_y),\\theta_j = \\widetilde{M}_j(\\pmb {r}_x,\\pmb {r}_y).</span></p>

    <p class="text-gray-300">To evaluate  <span class="math">f(\\boldsymbol{r}_x)</span> , the verifier needs to know the value of  <span class="math">\\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s_y}} \\widetilde{M}_j(\\boldsymbol{x}, \\boldsymbol{y}) \\cdot \\tilde{z}(\\boldsymbol{y})</span>  for all  <span class="math">j \\in [t]</span> , which can be reduced to another sum-check problem. Thus, the prover makes  <span class="math">t</span>  separate claims to the sums on  <span class="math">\\boldsymbol{y} \\in \\{0,1\\}^{s_y}</span>  to the verifier at step 5. The verifier checks two facts accordingly: (1)  <span class="math">c_x</span>  in sum-check#1 is consistent with the above claims (step 6), and (2) the  <span class="math">t</span>  claims are valid.</p>

    <p class="text-gray-300">The first fact is verified directly at step 6. For the second fact, a naive approach is to run <span class="math">t</span> more times the sum-check protocol in parallel for <span class="math">t</span> claims. A more elegant solution aggregates these claims by linear combination with weights <span class="math">[\\delta^{1},...,\\delta^{t}]</span> generated from a random <span class="math">\\delta</span>. Consequently, the prover and verifier can run the sum-check protocol only once on the aggregated multi-variate polynomial <span class="math">g(\\bm{y})</span> at step 9 with the randomness <span class="math">\\bm{r}_{y}</span> and <span class="math">\\text{sum}_{y}=\\sum_{j\\in[t]}\\delta^{j}\\cdot\\sigma_{j}</span>. Likewisey, the prover makes claims to <span class="math">t</span> evaluations <span class="math">\\{M_{j}(\\bm{r}_{x},\\bm{r}_{y})\\}_{j=1}^{t}</span> and one evaluation <span class="math">\\tilde{z}(\\bm{r}_{y})</span> at steps 10. The verifier checks accordingly by running step 11 and computing the evaluations at step 13.</p>

    <p class="text-gray-300">The security properties of the protocol <span class="math">\\Pi_{\\mathsf{CCCS}}</span> are guaranteed as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. <span class="math">\\Pi_{\\mathsf{CCCS}}</span> satisfies perfect completeness.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Knowledge Soundness. <span class="math">\\Pi_{\\mathsf{CCCS}}</span> is a knowledge sound protocol for <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span> if the commitment scheme <span class="math">\\mathsf{Commit}()</span> satisfies the binding property. To prove it, let <span class="math">\\mathsf{Ext}_{\\mathsf{CCCS}}</span> be the PPT extractor for the protocol <span class="math">\\Pi_{\\mathsf{CCCS}}</span>. By rewinding the malicious prover <span class="math">\\mathcal{P}^{<em>}</span> twice with different challenges <span class="math">\\rho,\\rho^{\\prime}</span>, <span class="math">\\mathsf{Ext}_{\\mathsf{CCCS}}</span> can compute a witness <span class="math">\\bm{\\mathsf{w}}^{\\prime}</span> satisfying: (1) <span class="math">\\mathsf{Commit}(\\mathsf{pp},\\widetilde{\\bm{\\mathsf{w}}}^{\\prime})=C</span> guaranteed by the binding property of commitment scheme and (2) the CCS relation guaranteed by the soundness of sum-check protocol </em>[27]* and Schwartz-Zippel lemma. By applying the union bound, we claim that the soundness error of <span class="math">\\Pi_{\\mathsf{CCCS}}</span> is at most $O(d\\cdot\\log m+t+\\log n)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">B.2 Special Sound Protocols for Atomic CCS</h3>

    <p class="text-gray-300">Based on the observations above, we build a special sound protocol <span class="math">\\Pi_{\\mathsf{ACCS}}</span> friendly for the folding schemes. The prover and verifier run a series of interactions in the protocol to substitute the random vectors <span class="math">\\bm{r}_{x},\\bm{r}_{y}</span> in the atomic CCS instance. First, the prover rewrites each <span class="math">\\widetilde{M}_{j}(\\bm{r}_{x},\\bm{r}_{y}),j\\in[t]</span> as</p>

    <p class="text-gray-300"><span class="math">M_{j}(\\bm{x})=\\widetilde{eq}(\\bm{r}_{x},\\bm{x})\\cdot\\left(\\sum_{\\bm{y}\\in\\{0,1\\}^{s_{y}}}\\widetilde{eq}(\\bm{r}_{y},\\bm{y})\\cdot\\widetilde{M}_{j}(\\bm{x},\\bm{y})\\right)</span></p>

    <p class="text-gray-300">Then the prover and verifier run the first sum-check protocol on <span class="math">\\bm{x}</span> for each <span class="math">M_{j}(\\bm{x})</span>. With the random challenge <span class="math">\\gamma</span> sampled by the verifier at step 1, the prover constructs an aggregated polynomial <span class="math">f(\\bm{x})</span> as the linear combinations of each <span class="math">M_{j}(\\bm{x})</span>. Then the prover and verifier run the sum-check#1 on <span class="math">f(\\bm{x})</span> at step 4 with the random vector <span class="math">\\bm{r}_{x}^{\\prime}</span>, where the <span class="math">\\text{sum}_{x}</span> equals to <span class="math">\\sum_{j\\in[t]}\\gamma^{j}\\cdot v_{j}</span>. If the sum-check#1 is correctly executed, the claims on matrices are updated to</p>

    <p class="text-gray-300"><span class="math">\\sigma_{j}=\\sum_{\\bm{y}\\in\\{0,1\\}^{s_{y}}}\\widetilde{eq}(\\bm{r}_{y},\\bm{y})\\cdot\\widetilde{M}_{j}(\\bm{r}_{x}^{\\prime},\\bm{y})</span></p>

    <p class="text-gray-300">for <span class="math">j\\in[t]</span> with the new random vector <span class="math">\\bm{r}_{x}^{\\prime}</span> at step 5. Next, the prover rewrites for <span class="math">\\widetilde{z}(\\bm{r}_{y})</span> and each <span class="math">\\widetilde{M}_{j}(\\bm{r}_{x},\\bm{r}_{y})</span> as</p>

    <p class="text-gray-300"><span class="math">M_{j}(\\bm{y})=\\widetilde{eq}(\\bm{r}_{y},\\bm{y})\\cdot\\widetilde{M}_{j}(\\bm{r}_{x}^{\\prime},\\bm{y}),\\quad z(\\bm{y})=\\widetilde{eq}(\\bm{r}_{y},\\bm{y})\\cdot\\widetilde{z}(\\bm{y})</span></p>

    <p class="text-gray-300">the prover and verifier run the sum-check#2 on the aggregated  <span class="math">g(\\pmb{y})</span>  at step 9 with the random vector  <span class="math">\\pmb{r}_y&#x27;</span> , where  <span class="math">\\mathrm{sum_y} = \\sum_{j\\in [t]}\\delta^j\\cdot \\sigma_j + \\delta^{t + 1}\\cdot v_z</span> . The remaining process runs similarly. Finally, the protocol transforms the original atomic CCS into a new one on  <span class="math">\\pmb{r}_x&#x27;,\\pmb{r}_y&#x27;</span> .</p>

    <p class="text-gray-300">For the security of the proposed  <span class="math">\\Pi_{\\mathrm{ACCS}}</span> , it retains completeness and soundness as the  <span class="math">\\Pi_{\\mathrm{CCS}}</span>  does. We omit the security proof since it can be covered by the proofs for our generic folding scheme in Appendix B.3.</p>

    <p class="text-gray-300">Special Sound Protocol  <span class="math">\\Pi_{\\mathrm{ACCS}} = (\\mathcal{P},\\mathcal{V})</span>  for relation  <span class="math">\\mathcal{R}_{\\mathrm{ACCS}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  : Sample  <span class="math">\\gamma \\leftarrow \\S \\mathbb{F}</span> , and send to  <span class="math">\\mathcal{P}</span> .</li>

      <li><span class="math">\\mathcal{V}</span>  : Sample  <span class="math">\\pmb{r}_x^{\\prime}\\gets \\S \\mathbb{F}^{s_x}</span></li>

      <li><span class="math">\\mathcal{P}</span>  : Compute  <span class="math">\\tilde{z} (\\pmb {y}) = (\\widetilde{\\pmb{w}},1,\\mathbf{i}\\pmb {o})</span></li>

      <li>Sum-check#1.  <span class="math">c_{x}\\gets \\Pi_{\\mathfrak{w}}(f,s_{x},2,\\mathrm{sum}_{x})</span>  with random  <span class="math">\\pmb{r}_x^{\\prime}</span>  where:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">f (\\boldsymbol {x}) = \\sum_ {j \\in [ t ]} \\gamma^ {j} \\cdot \\widetilde {e q} (\\boldsymbol {r} _ {x}, \\boldsymbol {x}) \\cdot \\left(\\sum_ {\\boldsymbol {y} \\in \\{0, 1 \\} ^ {s _ {y}}} \\widetilde {e q} (\\boldsymbol {r} _ {y}, \\boldsymbol {y}) \\cdot \\widetilde {M} _ {j} (\\boldsymbol {x}, \\boldsymbol {y})\\right).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  : Compute  <span class="math">\\{\\sigma_j\\}_{j\\in [t]}</span>  and send to  <span class="math">\\nu</span>  , where:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\sigma_{j} = \\sum_{\\pmb {y}\\in \\{0,1\\}^{sy}}\\widetilde{eq} (\\pmb{r}_{y},\\pmb {y})\\cdot \\widetilde{M}_{j}(\\pmb{r}_{x}^{\\prime},\\pmb {y}),</span>  for all  <span class="math">j\\in [t]</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  : Compute  <span class="math">e_1\\gets \\widetilde{eq} (\\pmb {r}_x,\\pmb {r}_x^{\\prime})</span>  , and abort if:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">c _ {x} \\neq e _ {1} \\cdot \\sum_ {j \\in [ t ]} \\gamma^ {j} \\cdot \\sigma_ {j}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  : Sample  <span class="math">\\delta \\gets \\S \\mathbb{F}</span> , and send to  <span class="math">\\mathcal{P}</span> .</li>

      <li><span class="math">\\mathcal{V}</span>  : Sample  <span class="math">\\pmb{r}_y^{\\prime}\\gets \\S \\mathbb{F}^{s_y}</span></li>

      <li>Sum-check#2.  <span class="math">c_{y}\\gets \\Pi_{\\mathfrak{w}}(g,s_{y},2,\\mathrm{sum}_{y})</span>  with random  <span class="math">\\pmb{r}_y^\\prime</span>  where:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">g (\\boldsymbol {y}) = \\sum_ {j \\in [ t ]} \\delta^ {j} \\cdot \\widetilde {e q} (\\boldsymbol {r} _ {y}, \\boldsymbol {y}) \\cdot \\widetilde {M} _ {j} (\\boldsymbol {r} _ {x} ^ {\\prime}, \\boldsymbol {y}) + \\delta^ {t + 1} \\cdot \\widetilde {e q} (\\boldsymbol {r} _ {y}, \\boldsymbol {y}) \\cdot \\tilde {z} (\\boldsymbol {y}).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  : Compute  <span class="math">\\epsilon, \\{\\theta_j\\}_{j \\in [t]}</span>  and send to  <span class="math">\\mathcal{V}</span> , where for all  <span class="math">j \\in [t]</span> :</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\epsilon = \\tilde {z} (\\boldsymbol {r} _ {y} ^ {\\prime}), \\theta_ {j} = \\widetilde {M} _ {j} (\\boldsymbol {r} _ {x} ^ {\\prime}, \\boldsymbol {r} _ {y} ^ {\\prime}).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  : Compute  <span class="math">e_2\\gets \\widetilde{eq} (\\pmb {r}_y,\\pmb {r}_y^{\\prime})</span>  , and abort if:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">c _ {y} \\neq e _ {2} \\cdot \\left(\\sum_ {j \\in [ t ]} \\delta^ {j} \\cdot \\theta_ {j} + \\delta^ {t + 1} \\cdot \\epsilon\\right).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  : Open the witness  <span class="math">\\widetilde{\\mathbf{w}}</span></li>

      <li><span class="math">\\mathcal{V}</span>  : Check that</li>

    </ol>

    <p class="text-gray-300">(1) Commit(pp,  <span class="math">\\widetilde{\\mathbf{w}}) = C</span> (2)  <span class="math">\\epsilon = \\tilde{z} (\\pmb{r}_y^{\\prime})</span> <span class="math">\\theta_{j} = \\widetilde{M}_{j}(\\pmb{r}_{x}^{\\prime},\\pmb{r}_{y}^{\\prime})</span></p>

    <p class="text-gray-300">In this section, we present the formal security proofs of our generic foldings scheme, including perfect completeness, knowledge soundness, and honest verifier</p>

    <p class="text-gray-300">zero-knowledge. For the former two properties, we mainly refer to the proof of the HyperNova <em>[25]</em>.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">(Perfect Completeness). Construction 1 satisfies perfect completeness.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider public parameters <span class="math">\\mathsf{pp}=(m,n,N,l,t,q,d,\\mathsf{pp}_{\\mathsf{PC}})\\leftarrow\\mathcal{G}(1^{\\lambda})</span> and let <span class="math">s_{x}=\\log m</span> and <span class="math">s_{y}=\\log n</span>. Consider arbitrary structures</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}</span> <span class="math">=\\{\\widetilde{M}_{j}\\}_{j\\in[t]}\\leftarrow\\mathcal{A}(\\mathsf{pp}),</span> <span class="math">\\mathcal{S}^{\\prime}</span> <span class="math">=\\{\\widetilde{M}_{j}^{\\prime}\\}_{j\\in[t]},\\{S_{i}^{\\prime}\\}_{i\\in[q]},\\{c_{i}^{\\prime}\\}_{i\\in[q]}\\leftarrow\\mathcal{A}(\\mathsf{pp}).</span></p>

    <p class="text-gray-300">Consider prover and verifier key <span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow\\mathcal{K}(\\mathsf{pp},\\mathcal{S},\\mathcal{S}^{\\prime})</span>. Suppose the prover and verifier are provided an atomic CCS instance</p>

    <p class="text-gray-300"><span class="math">(C,v_{0},\\mathsf{io},\\bm{r}_{x},\\bm{r}_{y},\\{v_{j}\\}_{j\\in[t]},v_{z}),</span></p>

    <p class="text-gray-300">and a committed CCS instance</p>

    <p class="text-gray-300"><span class="math">(C^{\\prime},\\mathsf{io}^{\\prime}).</span></p>

    <p class="text-gray-300"><em>1. Sum-check protocol#1</em>: suppose the prover is additionally provided the corresponding satisfying witnesses <span class="math">\\widetilde{\\bm{\\mathsf{w}}}</span> and <span class="math">\\widetilde{\\bm{\\mathsf{w}}}^{\\prime}</span>. Since the input atomic CCS instance-witness pair is satisfying, we have, for <span class="math">\\tilde{z}=(\\widetilde{\\bm{w},v_{0},\\mathsf{io}})</span>, that</p>

    <p class="text-gray-300"><span class="math">v_{j}</span> <span class="math">=\\sum_{\\bm{y}\\in\\{0,1\\}^{sy}}\\widetilde{eq}(\\bm{r}_{y},\\bm{y})\\cdot\\widetilde{M}_{j}(\\bm{r}_{x},\\bm{y})</span> <span class="math">=\\sum_{\\bm{x}\\in\\{0,1\\}^{s_{x}}}\\widetilde{eq}(\\bm{r}_{x},\\bm{x})\\cdot\\left(\\sum_{\\bm{y}\\in\\{0,1\\}^{sy}}\\widetilde{eq}(\\bm{r}_{y},\\bm{y})\\cdot\\widetilde{M}_{j}(\\bm{x},\\bm{y})\\right)</span> <span class="math">=\\sum_{\\bm{x}\\in\\{0,1\\}^{s_{x}}}L_{j}(\\bm{x}),\\forall j\\in[t].</span></p>

    <p class="text-gray-300">Moreover, since the input committed CCS instance-witness pair is satisfying, we have, for <span class="math">\\tilde{z}^{\\prime}(\\bm{y})=(\\widetilde{\\bm{w}^{\\prime},1,\\mathsf{io}^{\\prime}})(\\bm{y})</span>, that</p>

    <p class="text-gray-300"><span class="math">0=\\sum_{i\\in[q]}c_{i}^{\\prime}\\cdot\\prod_{j\\in S_{i}^{\\prime}}\\left(\\sum_{y\\in\\{0,1\\}^{sy}}\\widetilde{M}_{j}^{\\prime}(\\bm{x},\\bm{y})\\cdot\\tilde{z}^{\\prime}(\\bm{y})\\right),\\forall\\bm{x}\\in\\{0,1\\}^{s_{x}}.</span></p>

    <p class="text-gray-300">Treating the right-hand side of the above equation as a polynomial in <span class="math">\\bm{x}</span>, because it is multilinear and vanishes on all <span class="math">\\bm{x}\\in\\{0,1\\}^{s_{x}}</span>, we have that it must be the</p>

    <p class="text-gray-300">zero polynomial. Therefore, we have, for <span class="math">\\alpha</span> sampled by the verifier, that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} 0 &amp;amp;= \\sum_{i \\in [q]} c_i&#x27; \\cdot \\prod_{j \\in S_i&#x27;} \\left( \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s_y}} \\widetilde{M}_j&#x27;(\\boldsymbol{\\alpha}, \\boldsymbol{y}) \\cdot \\tilde{z}&#x27;(\\boldsymbol{y}) \\right) \\\\ &amp;amp;= \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s_x}} \\widetilde{e q}(\\boldsymbol{\\alpha}, \\boldsymbol{x}) \\cdot \\left( \\sum_{i \\in [q]} c_i&#x27; \\prod_{j \\in S_i&#x27;} \\left( \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s_y}} \\widetilde{M}_j&#x27;(\\boldsymbol{x}, \\boldsymbol{y}) \\cdot \\tilde{z}&#x27;(\\boldsymbol{y}) \\right) \\right) \\\\ &amp;amp;= \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s_x}} Q(\\boldsymbol{x}). \\end{aligned}</span></div>

    <p class="text-gray-300">For <span class="math">\\gamma</span> sampled by the verifier, by linearity, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\sum_{j \\in [t]} \\gamma^j \\cdot v_j &amp;amp;= \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s_x}} \\left( \\left( \\sum_{j \\in [t]} \\gamma^j \\cdot L_j(\\boldsymbol{x}) \\right) + \\gamma^{t+1} \\cdot Q(\\boldsymbol{x}) \\right) \\\\ &amp;amp;= \\sum_{\\boldsymbol{x} \\in \\{0,1\\}^{s_x}} f(\\boldsymbol{x}). \\end{aligned}</span></div>

    <p class="text-gray-300">Therefore, by the perfect completeness of the sum-check protocol, we have for <span class="math">e_1 = \\widetilde{e q}(\\boldsymbol{r}_x, \\boldsymbol{r}_x&#x27;), e_2 = \\widetilde{e q}(\\boldsymbol{\\alpha}, \\boldsymbol{r}_x&#x27;)</span> and</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma_j = \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s_y}} \\widetilde{e q}(\\boldsymbol{r}_y, \\boldsymbol{y}) \\cdot \\widetilde{M}_j(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}), \\forall j \\in [t],</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sigma_j&#x27; = \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s_y}} \\widetilde{M}_j&#x27;(\\boldsymbol{r}_x&#x27;, \\boldsymbol{y}) \\cdot \\tilde{z}&#x27;(\\boldsymbol{y}), \\forall j \\in [t],</span></div>

    <p class="text-gray-300">that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} c_x &amp;amp;= f(\\boldsymbol{r}_x&#x27;) \\\\ &amp;amp;= \\left( \\sum_{j \\in [t]} \\gamma^j \\cdot L_j(\\boldsymbol{r}_x&#x27;) \\right) + \\gamma^{t+1} \\cdot Q(\\boldsymbol{r}_x&#x27;) \\\\ &amp;amp;= \\left( \\sum_{j \\in [t]} \\gamma^j \\cdot e_1 \\cdot \\sigma_j \\right) + \\gamma^{t+1} \\cdot e_2 \\cdot \\sum_{i \\in [q]} c_i&#x27; \\cdot \\prod_{j \\in S_i&#x27;} \\sigma_j&#x27;. \\end{aligned}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sum-check protocol#2: According to the results of sum-check protocol#1, for  <span class="math">\\tilde{z}(\\pmb{x}), \\tilde{z}&#x27;(\\pmb{x})</span>  and sampled  <span class="math">\\pmb{r}_x&#x27;</span> , we have</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sigma_ {j} = \\sum_ {\\boldsymbol {y} \\in \\{0, 1 \\} ^ {s _ {y}}} \\widetilde {e q} (\\boldsymbol {r} _ {y}, \\boldsymbol {y}) \\cdot \\widetilde {M} _ {j} (\\boldsymbol {r} _ {x} ^ {\\prime}, \\boldsymbol {y}) \\\\ = \\sum_ {\\boldsymbol {y} \\in \\{0, 1 \\} ^ {s _ {y}}} R _ {j} (\\boldsymbol {y}), \\forall j \\in [ t ], \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} v _ {z} = \\sum_ {\\boldsymbol {y} \\in \\{0, 1 \\} ^ {s _ {y}}} \\widetilde {e q} (\\boldsymbol {r} _ {y}, \\boldsymbol {y}) \\cdot \\widetilde {z} (\\boldsymbol {y}) \\\\ \\sigma_ {j} ^ {\\prime} = \\sum_ {\\boldsymbol {y} \\in \\{0, 1 \\} ^ {s _ {y}}} \\widetilde {M} _ {j} ^ {\\prime} (\\boldsymbol {r} _ {x} ^ {\\prime}, \\boldsymbol {y}) \\cdot \\tilde {z} ^ {\\prime} (\\boldsymbol {y}), \\\\ = \\sum_ {\\boldsymbol {y} \\in \\{0, 1 \\} ^ {s _ {y}}} T _ {j} (\\boldsymbol {y}), \\forall j \\in [ t ]. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">For  <span class="math">\\delta</span>  sampled by the verifier, by linearity, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {j \\in [ t ]} \\delta^ {j} \\cdot \\sigma_ {j} + \\delta^ {t + 1} \\cdot v _ {z} + \\delta^ {t + 1} \\cdot \\sum_ {j \\in [ t ]} \\delta^ {j} \\cdot \\sigma_ {j} ^ {\\prime} \\\\ = \\sum_ {j \\in [ t ]} \\delta^ {j} \\cdot R _ {j} (\\boldsymbol {y}) + \\delta^ {t + 1} \\cdot S (\\boldsymbol {y}) + \\delta^ {t + 1} \\cdot \\sum_ {j \\in [ t ]} \\delta^ {j} \\cdot T _ {j} (\\boldsymbol {y}) \\\\ = \\sum_ {j \\in [ t ]} g (\\boldsymbol {y}). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Therefore, by the perfect completeness of the sum-check protocol, we have for</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\epsilon = \\tilde {z} (\\boldsymbol {r} _ {y} ^ {\\prime}), \\\\ \\epsilon^ {\\prime} = \\tilde {z} ^ {\\prime} (\\boldsymbol {r} _ {y} ^ {\\prime}), \\\\ \\theta_ {j} = \\widetilde {M} _ {j} (\\boldsymbol {r} _ {x} ^ {\\prime}, \\boldsymbol {r} _ {y} ^ {\\prime}), \\forall j \\in [ t ], \\\\ \\theta_ {j} ^ {\\prime} = \\widetilde {M} _ {j} ^ {\\prime} (\\boldsymbol {r} _ {x} ^ {\\prime}, \\boldsymbol {r} _ {y} ^ {\\prime}), \\forall j \\in [ t ], \\\\ \\end{array}</span></div>

    <p class="text-gray-300">that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} c _ {y} = g \\left(\\boldsymbol {r} _ {y} ^ {\\prime}\\right) \\\\ = \\sum_ {j \\in [ t ]} \\delta^ {j} \\cdot R _ {j} \\left(\\boldsymbol {r} _ {y} ^ {\\prime}\\right) + \\delta^ {t + 1} \\cdot S (\\boldsymbol {y}) + \\delta^ {t + 1} \\cdot \\sum_ {j \\in [ t ]} \\delta^ {j} \\cdot T _ {j} \\left(\\boldsymbol {r} _ {y} ^ {\\prime}\\right) \\\\ = \\sum_ {j \\in [ t ]} \\delta^ {j} \\cdot e _ {3} \\cdot \\theta_ {j} + \\delta^ {t + 1} \\cdot \\epsilon + \\delta^ {t + 1} \\cdot \\sum_ {j \\in [ t ]} \\delta^ {j} \\cdot \\theta_ {j} \\cdot \\epsilon^ {\\prime}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The above two steps imply that the verifier will not abort. Now, consider the atomic CCS instance obtained from  <span class="math">\\mathcal{R}&#x27;</span>  as</p>

    <div class="my-4 text-center"><span class="math-block">\\left(C ^ {\\prime}, 1, \\mathrm {i o} ^ {\\prime}, \\boldsymbol {r} _ {x} ^ {\\prime}, \\boldsymbol {r} _ {y} ^ {\\prime}, \\left\\{\\theta_ {j} ^ {\\prime} \\right\\} _ {j \\in [ t ]}, \\epsilon^ {\\prime}\\right).</span></div>

    <p class="text-gray-300">By the precondition that the committed CCS instance <span class="math">(C&#x27;, \\mathbf{i}\\mathbf{o}&#x27;)</span> is satisfied by <span class="math">\\widetilde{\\boldsymbol{\\boldsymbol{w}}}^{\\prime}</span> and by the definition of <span class="math">\\{\\theta_j^{\\prime}\\}_{j\\in[t]},\\epsilon^{\\prime}</span> we have that this new atomic CCS instance is satisfied by the witness <span class="math">\\widetilde{\\boldsymbol{\\boldsymbol{w}}}^{\\prime}</span>.</p>

    <p class="text-gray-300">Therefore, for random <span class="math">\\eta</span> sampled by the verifier, and folded structure <span class="math">\\mathcal{S}^<em></span> with <span class="math">\\{M_j^</em> = M_j + \\eta \\cdot M_j&#x27;\\}_{j=1}^t</span>, folded instance <span class="math">C^<em> = C + \\eta \\cdot C&#x27;</span>, <span class="math">v_0^</em> = v_0 + \\eta \\cdot 1</span>, <span class="math">\\mathbf{i}\\mathbf{o}^<em> = \\mathbf{i}\\mathbf{o} + \\eta \\cdot \\mathbf{i}\\mathbf{o}&#x27;</span>, <span class="math">v_j^</em> = \\theta_j + \\eta \\cdot \\theta_j&#x27;</span>, <span class="math">v_z^* = \\epsilon_j + \\eta \\cdot \\epsilon_j&#x27;</span>, we have that the output folded atomic CCS instance</p>

    <div class="my-4 text-center"><span class="math-block">(C ^ {*}, v _ {0} ^ {*}, \\mathbf {i o} ^ {*}, \\boldsymbol {r} _ {x} ^ {\\prime}, \\boldsymbol {r} _ {y} ^ {\\prime}, \\{v _ {j} ^ {*} \\} _ {j \\in [ t ]}, v _ {z} ^ {*}).</span></div>

    <p class="text-gray-300">is satisfied by the witness <span class="math">\\widetilde{\\boldsymbol{w}}^{<em>} \\gets \\widetilde{\\boldsymbol{w}} + \\eta \\cdot \\widetilde{\\boldsymbol{w}}^{\\prime}</span> under the structure <span class="math">\\mathcal{S}^{</em>}</span> by the linearity and the additive homomorphism property of the commitment scheme.</p>

    <p class="text-gray-300"><strong>Lemma 5.</strong> (Knowledge Soundness). Construction 1 satisfies knowledge soundness.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Consider an adversary <span class="math">\\mathcal{A}</span> that adaptively picks the structures and instances, and a malicious prover <span class="math">\\mathcal{P}^*</span> that succeeds with probability <span class="math">\\epsilon</span>. Let <span class="math">\\mathsf{pp} \\gets \\mathcal{G}(1^{\\lambda})</span>. Suppose on input <span class="math">\\mathsf{pp}</span> and random tape <span class="math">\\eta</span>, the adversary <span class="math">\\mathcal{A}</span> picks two structures</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {S} = \\{\\widetilde {M} _ {j} \\} _ {j \\in [ t ]},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {S} ^ {\\prime} = \\{\\widetilde {M _ {j} ^ {\\prime}} \\} _ {j \\in [ t ]}, \\{S _ {i} ^ {\\prime} \\} _ {i \\in [ q ]}, \\{c _ {i} ^ {\\prime} \\} _ {i \\in [ q ]}.</span></div>

    <p class="text-gray-300">a new committed CCS instance</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {u} = (C, v _ {0}, \\mathrm {i o}, \\boldsymbol {r} _ {x}, \\boldsymbol {r} _ {y}, \\{v _ {j} \\} _ {j \\in [ t ]}, v _ {z}),</span></div>

    <p class="text-gray-300">and committed CCS instance</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {u} ^ {\\prime} = (C ^ {\\prime}, \\mathrm {i o} ^ {\\prime}),</span></div>

    <p class="text-gray-300">and some auxiliary state <span class="math">\\mathsf{st}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Extraction Algorithm</strong>: we construct an expected-polynomial time extractor <span class="math">\\mathsf{Ext}</span> that succeeds with probability <span class="math">\\epsilon - \\mathrm{negl}(\\lambda)</span> in obtaining satisfying witnesses for the original instances as follows.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{Ext}(\\mathsf{pp},\\rho)</span>:</p>

    <p class="text-gray-300">1 : Obtain the output tuple from <span class="math">\\mathcal{A}</span>:</p>

    <p class="text-gray-300"><span class="math">(\\mathcal{S},\\mathcal{S}^{\\prime},\\mathbf{u},\\mathbf{u}^{\\prime},\\mathsf{st})\\leftarrow\\mathcal{A}(\\mathsf{pp},\\rho).</span> 2 : Compute <span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow\\mathcal{K}(\\mathsf{pp},\\mathcal{S},\\mathcal{S}^{\\prime}).</span> 3 : Run the folding interaction#1</p>

    <p class="text-gray-300"><span class="math">(\\mathcal{S}_{1}^{<em>},\\mathbf{u}_{1}^{</em>},\\widetilde{\\mathbf{w}}_{1}^{<em>})\\leftarrow\\langle\\mathcal{P}^{</em>},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),\\mathcal{S},\\mathcal{S}^{\\prime},\\mathbf{u},\\mathbf{u}^{\\prime},\\mathsf{st})</span></p>

    <p class="text-gray-300">once with the final verifier challenge <span class="math">\\eta_{1}\\leftarrow\\sharp\\ \\mathbb{F}.</span> 4 : Abort if <span class="math">(\\mathsf{pp},\\mathcal{S}_{1}^{<em>},\\mathbf{u}_{1}^{</em>},\\widetilde{\\mathbf{w}}_{1}^{*})\\notin\\mathcal{R}_{\\mathsf{ACCS}}.</span> 5 : Run the folding interaction#2</p>

    <p class="text-gray-300"><span class="math">(\\mathcal{S}_{2}^{<em>},\\mathbf{u}_{2}^{</em>},\\widetilde{\\mathbf{w}}_{2}^{<em>})\\leftarrow\\langle\\mathcal{P}^{</em>},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),\\mathcal{S},\\mathcal{S}^{\\prime},\\mathbf{u},\\mathbf{u}^{\\prime},\\mathsf{st}))</span></p>

    <p class="text-gray-300">with a different verifier’s final challenge <span class="math">\\eta_{2}\\leftarrow\\sharp\\ \\mathbb{F}</span> while maintaining the same prior randomness. Keep doing so until <span class="math">(\\mathsf{pp},\\mathcal{S}_{2}^{<em>},\\mathbf{u}_{2}^{</em>},\\widetilde{\\mathbf{w}}_{2}^{<em>})\\in\\mathcal{R}_{\\mathsf{ACCS}}.</span> 6 : Abort if <span class="math">\\eta_{1}=\\eta_{2}</span> or <span class="math">\\mathcal{S}_{1}^{</em>}\\neq\\mathcal{S}_{2}^{<em>}.</span> 7 : Interpolating points <span class="math">(\\eta_{1},\\widetilde{\\mathbf{w}}_{1}^{</em>})</span> and <span class="math">(\\eta_{2},\\widetilde{\\mathbf{w}}_{2}^{*})</span>, retrieve the witness polynomials <span class="math">\\widetilde{\\mathbf{w}}</span> and <span class="math">\\widetilde{\\mathbf{w}}^{\\prime}</span> such that for <span class="math">i\\in\\{1,2\\}</span></p>

    <p class="text-gray-300"><span class="math">\\widetilde{\\mathbf{w}}+\\eta_{i}\\cdot\\widetilde{\\mathbf{w}}^{\\prime}=\\widetilde{\\mathbf{w}}_{i}^{*}.</span> 8 : Output <span class="math">(\\widetilde{\\mathbf{w}},\\widetilde{\\mathbf{w}}^{\\prime}).</span></p>

    <p class="text-gray-300">We first demonstrate that the extractor <span class="math">\\mathsf{Ext}</span> runs in expected polynomial time. Observe that <span class="math">\\mathsf{Ext}</span> runs the folding interaction#1 once, and if it does not abort, keeps rerunning the folding interaction#2 until <span class="math">\\mathcal{P}^{*}</span> succeeds. Let <span class="math">W</span> denote the event that the extractor does not abort at step 4, and <span class="math">\\bar{W}</span> denotes that the event <span class="math">W</span> does not happen. Define the number of folding interactions <span class="math">\\mathsf{Ext}</span> runs in total as a variable <span class="math">X</span> (i.e., number of rewinds). We can calculate its expectation as</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[X]=\\Pr[W]\\cdot(1+\\frac{1}{\\Pr[\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle\\ \\text{succeeds}]})+\\Pr[\\bar{W}]\\cdot 1=\\epsilon\\cdot(1+\\frac{1}{\\epsilon})+(1-\\epsilon)\\cdot 1=2.</span></p>

    <p class="text-gray-300">Therefore, we have that the extractor runs in the expected polynomial time.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Advantage Analysis: We now analyze <span class="math">\\mathsf{Ext}</span>’s success probability. We must demonstrate that <span class="math">\\mathsf{Ext}</span> succeeds in producing <span class="math">\\widetilde{\\mathbf{w}}</span> and <span class="math">\\widetilde{\\mathbf{w}}^{\\prime}</span> such that</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{pp},\\mathcal{S},\\mathbf{u},\\widetilde{\\mathbf{w}})\\in\\mathcal{R}_{\\mathsf{ACCS}}\\ \\text{and}\\ (\\mathsf{pp},\\mathcal{S}^{\\prime},\\mathbf{u}^{\\prime},\\widetilde{\\mathbf{w}}^{\\prime})\\in\\mathcal{R}_{\\mathsf{CCCS}}</span></p>

    <p class="text-gray-300">, with probability <span class="math">\\epsilon-\\mathrm{negl}(\\lambda)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To do so, we first show that the extractor successfully produces <em>some</em> output (i.e., does not abort) in less than $\\sqrt[3]{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> rewinding steps with probability </span>\\epsilon-\\mathrm{negl}(\\lambda)<span class="math">. Indeed, by the malicious prover’s success probability, we have that the extractor does not abort at step (4) with probability </span>\\epsilon$. Given that the extractor does not abort at step (4), by Markov’s inequality, we have that the extractor</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\frac{\\partial}{\\partial t}\\left[\\frac{\\partial}{\\partial x}\\left(\\frac{\\partial}{\\partial y}\\right)\\right]=\\frac{\\partial}{\\partial x}\\left[\\frac{\\partial}{\\partial y}\\left(\\frac{\\partial}{\\partial z}\\right)\\right]=\\frac{\\partial}{\\partial y}\\left[\\frac{\\partial}{\\partial z}\\left(\\frac{\\partial}{\\partial y}\\right)\\right].</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rewinds more than $\\sqrt[3]{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{\\mathbb{F}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ times with probability</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[X\\geq\\sqrt[3]{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{\\mathbb{F}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]\\leq\\frac{\\mathbb{E}[X]}{\\sqrt[3]{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{\\mathbb{F}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}=\\frac{2}{\\sqrt[3]{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{\\mathbb{F}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">X</span> is the random variable of the number of running folding interactions. Thus, the probability that the extractor does not abort at step (4) and requires less than $\\sqrt[3]{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{\\mathbb{F}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> rewinds is </span>(1-2/\\sqrt[3]{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{\\mathbb{F}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})\\cdot\\epsilon$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now, suppose that the extractor does not abort at step (4) and requires less than $\\sqrt[3]{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{\\mathbb{F}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> rewinds. This ensures that the extractor tests at most </span>\\sqrt[3]{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{\\mathbb{F}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> values for </span>\\eta<span class="math">. Since the challenges are sampled uniformly in random form </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, the probability that </span>\\rho^{(1)}\\neq\\rho^{(2)}<span class="math"> is </span>1-\\sqrt[3]{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{\\mathbb{F}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{2}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Therefore, assuming </span>\\sqrt[3]{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{\\mathbb{F}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{2}\\geq 2<span class="math">, we have that the probability the extractor successfully produces some output under </span>\\sqrt[3]{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{\\mathbb{F}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ rewinding steps is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[X<\\sqrt[3]{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]\\cdot\\Pr[\\rho^{(1)}\\neq\\rho^{(2)}]<span class="math"> </span>=(1-\\frac{2}{\\sqrt[3]{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}})\\cdot\\epsilon\\cdot(1-\\frac{\\sqrt[3]{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">=\\epsilon-\\text{negl}(\\lambda).</span></p>

    <p class="text-gray-300">Next, if the extractor does not abort, we show that the extractor succeeds in producing satisfying witnesses with probability <span class="math">1-\\text{negl}(\\lambda)</span>. This brings the overall extractor success probability to <span class="math">(\\epsilon-\\text{negl}(\\lambda))\\cdot(1-\\text{negl}(\\lambda))</span>.</p>

    <p class="text-gray-300">For <span class="math">i\\in\\{1,2\\}</span>, let <span class="math">\\mathbf{u}_{i}^{<em>}=(C_{i}^{</em>},v_{0,i}^{<em>},\\mathbf{i}\\mathbf{o}_{i}^{</em>},r_{x,i}^{<em>},v_{1,i}^{</em>},...,v_{t,i}^{<em>},v_{z,i}^{</em>})</span>. We first show that the retrieved polynomials are valid openings to the corresponding commitments in the instance. For <span class="math">i\\in\\{1,2\\}</span>, since <span class="math">\\widetilde{\\mathbf{w}}_{i}^{*}</span> is a satisfying witness, by construction,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Commit}(\\mathsf{pp},\\widetilde{\\mathbf{w}})+\\eta_{i}\\cdot\\mathsf{Commit}(\\mathsf{pp},\\widetilde{\\mathbf{w}}^{\\prime})</span> <span class="math">=\\mathsf{Commit}(\\mathsf{pp},\\widetilde{\\mathbf{w}}+\\eta_{i}\\cdot\\widetilde{\\mathbf{w}}^{\\prime})</span> <span class="math">=\\mathsf{Commit}(\\mathsf{pp},\\widetilde{\\mathbf{w}}_{i}^{<em>})</span> <span class="math">=C_{i}^{</em>}</span> <span class="math">=C+\\eta_{i}\\cdot C^{\\prime}.</span></p>

    <p class="text-gray-300">Interpolating, we have that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Commit}(\\mathsf{pp},\\widetilde{\\mathbf{w}})</span> <span class="math">=C,</span> (7) <span class="math">\\mathsf{Commit}(\\mathsf{pp},\\widetilde{\\mathbf{w}}^{\\prime})</span> <span class="math">=C^{\\prime}.</span> (8)</p>

    <p class="text-gray-300">Next, we must argue that <span class="math">\\widetilde{\\mathbf{w}}</span> and <span class="math">\\widetilde{\\mathbf{w}}^{\\prime}</span> satisfy the remainder of the instances <span class="math">(\\mathcal{S},\\mathbf{u})</span> and <span class="math">(\\mathcal{S}^{\\prime},\\varphi^{\\prime})</span> respectively.</p>

    <p class="text-gray-300">Consider <span class="math">\\{\\theta_{j}\\}_{j\\in[t]},\\{\\theta_{j}^{\\prime}\\}_{j\\in[t]}</span> and <span class="math">\\epsilon,\\epsilon^{\\prime}</span> sent by the prover which by the extractor’s construction are identical across all executions of the interaction. By the verifier’s computation we have that for <span class="math">i\\in\\{1,2\\}</span> and all <span class="math">j\\in[t]</span></p>

    <p class="text-gray-300"><span class="math">v_{j,i}</span> <span class="math">=\\theta_{j}+\\eta_{i}\\cdot\\theta_{j}^{\\prime},</span> (9) <span class="math">v_{z,i}</span> <span class="math">=\\epsilon+\\eta_{i}\\cdot\\epsilon^{\\prime}.</span> (10)</p>

    <p class="text-gray-300">Now, because <span class="math">\\widetilde{\\mathbf{w}}_i^*</span> is a satisfying witness, for <span class="math">i \\in \\{1,2\\}</span> we have for all <span class="math">j \\in [t]</span> that</p>

    <div class="my-4 text-center"><span class="math-block">v_{j,i} = \\widetilde{M}_{j,i}^*(\\boldsymbol{r}_x&#x27;, \\boldsymbol{r}_y&#x27;),</span></div>

    <div class="my-4 text-center"><span class="math-block">v_{z,i} = \\tilde{z}_i^*(\\boldsymbol{r}_y&#x27;),</span></div>

    <p class="text-gray-300">where <span class="math">\\widetilde{M}_{j,i}^<em> = \\widetilde{M}_j + \\eta_i \\cdot \\widetilde{M}_j</span>, <span class="math">\\tilde{z}_i^</em> = (\\widetilde{\\mathbf{w}_i^<em>, v_{0,i}^</em>}, \\mathbf{i}\\mathbf{o}_i^*) = \\tilde{z} + \\eta \\cdot \\tilde{z}&#x27;</span>.</p>

    <p class="text-gray-300">Meanwhile, according to equations (9) and (10), for <span class="math">i \\in \\{1,2\\}</span> and <span class="math">j \\in [t]</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\theta_j + \\eta_i \\cdot \\theta_j&#x27; = v_{j,i} = \\widetilde{M}_j(\\boldsymbol{r}_x&#x27;, \\boldsymbol{r}_y&#x27;) + \\eta_i \\cdot \\widetilde{M}_j&#x27;(\\boldsymbol{r}_x&#x27;, \\boldsymbol{r}_y&#x27;),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\epsilon + \\eta_i \\cdot \\epsilon&#x27; = v_{z,i} = \\tilde{z}(\\boldsymbol{r}_y&#x27;) + \\eta_i \\cdot \\tilde{z}&#x27;(\\boldsymbol{r}_y&#x27;),</span></div>

    <p class="text-gray-300">where <span class="math">\\tilde{z} = (\\widetilde{\\mathbf{w}_i, v_{0,i}}, \\mathbf{i}\\mathbf{o}_i)</span> and <span class="math">\\tilde{z}&#x27; = (\\widetilde{\\mathbf{w}&#x27;, 1, \\mathbf{i}\\mathbf{o}&#x27;})</span>. Interpolating, we have that, for all <span class="math">j \\in [t]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\theta_j = \\widetilde{M}_j(\\boldsymbol{r}_x&#x27;, \\boldsymbol{r}_y&#x27;),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\theta_j&#x27; = \\widetilde{M}_j&#x27;(\\boldsymbol{r}_x&#x27;, \\boldsymbol{r}_y&#x27;),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\epsilon = \\tilde{z}(\\boldsymbol{r}_y&#x27;),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\epsilon&#x27; = \\tilde{z}&#x27;(\\boldsymbol{r}_y&#x27;).</span></div>

    <p class="text-gray-300">Thus, because the verifier does not abort at step 11, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} c_y &amp;amp;= \\sum_{j \\in [t]} \\delta^j \\cdot e_3 \\cdot \\theta_j + \\delta^{t+1} \\cdot e_3 \\cdot \\epsilon + \\delta^{t+1} \\cdot \\sum_{j \\in [t]} \\delta^j \\cdot \\theta_j&#x27; \\cdot \\epsilon&#x27; \\\\ &amp;amp;= \\sum_{j \\in [t]} \\delta^j \\cdot \\widetilde{eq}(\\boldsymbol{r}_y, \\boldsymbol{r}_y&#x27;) \\cdot \\theta_j + \\delta^{t+1} \\cdot \\widetilde{eq}(\\boldsymbol{r}_y, \\boldsymbol{r}_y&#x27;) \\cdot \\epsilon + \\delta^{t+1} \\cdot \\sum_{j \\in [t]} \\delta^j \\cdot \\theta_j&#x27; \\cdot \\epsilon&#x27; \\\\ &amp;amp;= \\sum_{j \\in [t]} \\delta^j \\cdot \\widetilde{eq}(\\boldsymbol{r}_y, \\boldsymbol{r}_y&#x27;) \\cdot \\widetilde{M}_j(\\boldsymbol{r}_x&#x27;, \\boldsymbol{r}_y&#x27;) + \\delta^{t+1} \\cdot \\widetilde{eq}(\\boldsymbol{r}_y, \\boldsymbol{r}_y&#x27;) \\cdot \\tilde{z}(\\boldsymbol{r}_y&#x27;) + \\delta^{t+1} \\cdot \\sum_{j \\in [t]} \\delta^j \\cdot \\widetilde{M}_j&#x27;(\\boldsymbol{r}_x&#x27;, \\boldsymbol{r}_y&#x27;) \\cdot \\tilde{z}&#x27;(\\boldsymbol{r}_y&#x27;) \\\\ &amp;amp;= \\sum_{j \\in [t]} \\delta^j \\cdot R_j(\\boldsymbol{r}_y&#x27;) + \\delta^{t+1} \\cdot S(\\boldsymbol{r}_y&#x27;) + \\delta^{t+1} \\cdot \\sum_{j \\in [t]} \\delta^j \\cdot T_j(\\boldsymbol{r}_y&#x27;) \\\\ &amp;amp;= g(\\boldsymbol{r}_y&#x27;), \\end{aligned}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">by the soundness of the sum-check protocol#2, this implies that with probability $1 - O(d \\cdot s_y) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1 - \\mathrm{negl}(\\lambda)<span class="math"> over the choice of </span>\\boldsymbol{r}_y'$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} &amp;amp;\\sum_{j \\in [t]} \\delta^j \\cdot \\sigma_j + \\delta^{t+1} \\cdot v_z + \\delta^{t+1} \\cdot \\sum_{j \\in [t]} \\delta^j \\cdot \\sigma_j&#x27; \\\\ &amp;amp;= \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s_y}} g(\\boldsymbol{y}) \\\\ &amp;amp;= \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s_y}} \\left( \\sum_{j \\in [t]} \\delta^j \\cdot R_j(\\boldsymbol{y}) + \\delta^{t+1} \\cdot S(\\boldsymbol{y}) + \\delta^{t+1} \\cdot \\sum_{j \\in [t]} \\delta^j \\cdot T_j(\\boldsymbol{y}) \\right) \\\\ &amp;amp;= \\sum_{j \\in [t]} \\delta^j \\cdot \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s_y}} R_j(\\boldsymbol{y}) + \\delta^{t+1} \\cdot \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s_y}} S(\\boldsymbol{y}) + \\delta^{t+1} \\cdot \\sum_{j \\in [t]} \\delta^j \\cdot \\sum_{\\boldsymbol{y} \\in \\{0,1\\}^{s_y}} T_j(\\boldsymbol{y}). \\end{aligned}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the Schwartz-Zippel lemma [Sch80], this implies that with probability $1 - O(t) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1 - \\mathrm{negl}(\\lambda)<span class="math"> over the choice of </span>\\delta<span class="math">, for all </span>j \\in [t]$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\sigma_{j} = \\sum_{\\boldsymbol{y} \\in \\{0, 1\\}^{s y}} R_{j}(\\boldsymbol{y}) = \\sum_{\\boldsymbol{y} \\in \\{0, 1\\}^{s y}} \\widetilde{e q}(\\boldsymbol{r}_{y}, \\boldsymbol{y}) \\cdot \\widetilde{M}_{j}(\\boldsymbol{r}_{x}^{\\prime}, \\boldsymbol{y}),</span></div>

    <div class="my-4 text-center"><span class="math-block">v_{z} = \\sum_{\\boldsymbol{y} \\in \\{0, 1\\}^{s y}} S(\\boldsymbol{y}) = \\sum_{\\boldsymbol{y} \\in \\{0, 1\\}^{s y}} \\widetilde{e q}(\\boldsymbol{r}_{y}, \\boldsymbol{y}) \\cdot \\tilde{z}(\\boldsymbol{y}),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sigma_{j}^{\\prime} = \\sum_{\\boldsymbol{y} \\in \\{0, 1\\}^{s y}} T_{j}(\\boldsymbol{y}) = \\sum_{\\boldsymbol{y} \\in \\{0, 1\\}^{s y}} \\widetilde{M}_{j}^{\\prime}(\\boldsymbol{r}_{x}^{\\prime}, \\boldsymbol{y}) \\cdot \\tilde{z}^{\\prime}(\\boldsymbol{y}).</span></div>

    <p class="text-gray-300">Thus, because the verifier does not abort at step 5, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} c_{x} &amp;amp;= \\left(\\sum_{j \\in [t]} \\gamma^{j} \\cdot e_{1} \\cdot \\sigma_{j}\\right) + \\left(\\gamma^{t+1} \\cdot e_{2} \\cdot \\sum_{i \\in [q]} c_{i}^{\\prime} \\cdot \\prod_{j \\in S_{i}} \\sigma_{j}\\right) \\\\ &amp;amp;= \\left(\\sum_{j \\in [t]} \\gamma^{j} \\cdot \\widetilde{e q}(\\boldsymbol{r}_{x}, \\boldsymbol{r}_{x}^{\\prime}) \\cdot \\sigma_{j}\\right) + \\left(\\gamma^{t+1} \\cdot \\widetilde{e q}(\\boldsymbol{\\alpha}, \\boldsymbol{r}_{x}^{\\prime}) \\cdot \\sum_{i \\in [q]} c_{i}^{\\prime} \\cdot \\prod_{j \\in S_{i}} \\theta_{j}\\right) \\\\ &amp;amp;= \\left(\\sum_{j \\in [t]} \\gamma^{j} \\cdot \\widetilde{e q}(\\boldsymbol{r}_{x}, \\boldsymbol{r}_{x}^{\\prime}) \\cdot \\sum_{\\boldsymbol{y} \\in \\{0, 1\\}^{s y}} \\widetilde{e q}(\\boldsymbol{r}_{y}, \\boldsymbol{y}) \\cdot \\widetilde{M}_{j}(\\boldsymbol{r}_{x}^{\\prime}, \\boldsymbol{y})\\right) \\\\ &amp;amp;\\quad + \\left(\\gamma^{t+1} \\cdot \\widetilde{e q}(\\boldsymbol{\\alpha}, \\boldsymbol{r}_{x}^{\\prime}) \\cdot \\sum_{i \\in [q]} c_{i} \\cdot \\prod_{j \\in S_{i}} \\sum_{\\boldsymbol{y} \\in \\{0, 1\\}^{s y}} \\widetilde{M}_{j}^{\\prime}(\\boldsymbol{r}_{x}^{\\prime}, \\boldsymbol{y}) \\cdot \\tilde{z}^{\\prime}(\\boldsymbol{y})\\right) \\\\ &amp;amp;= \\sum_{j \\in [t]} \\gamma^{j} \\cdot L_{j}(\\boldsymbol{r}_{x}^{\\prime}) + \\gamma^{t+1} \\cdot Q(\\boldsymbol{r}_{x}^{\\prime}) \\\\ &amp;amp;= f(\\boldsymbol{r}_{x}^{\\prime}), \\end{aligned}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">by the soundness of the sum-check protocol#1, this implies that with probability $1 - O(d \\cdot s_x) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1 - \\mathrm{negl}(\\lambda)<span class="math"> over the choice of </span>\\boldsymbol{r}_x'$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\sum_{j \\in [t]} \\gamma^{j} \\cdot v_{j} + \\gamma^{t+1} \\cdot 0 &amp;amp;= \\sum_{\\boldsymbol{x} \\in \\{0, 1\\}^{s x}} f(x) \\\\ &amp;amp;= \\sum_{\\boldsymbol{x} \\in \\{0, 1\\}^{s x}} \\left(\\left(\\sum_{j \\in [t]} \\gamma^{j} \\cdot L_{j}(\\boldsymbol{x})\\right) + \\gamma^{t+1} \\cdot Q(\\boldsymbol{x})\\right) \\\\ &amp;amp;= \\sum_{\\boldsymbol{x} \\in \\{0, 1\\}^{s x}} \\gamma^{j} \\cdot \\left(\\sum_{j \\in [t]} L_{j}(\\boldsymbol{x})\\right) + \\gamma^{t+1} \\cdot \\sum_{\\boldsymbol{x} \\in \\{0, 1\\}^{s x}} Q(x). \\end{aligned}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the Schwartz-Zippel lemma [Sch80], this implies that with probability $1 - O(t) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1 - \\mathrm{negl}(\\lambda)<span class="math"> over the choice of </span>\\gamma<span class="math">, for all </span>j \\in [t]$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">v_j = \\sum_{\\boldsymbol{x} \\in \\{0, 1\\}^{s_x}} L_j(\\boldsymbol{x}),</span></div>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_{\\boldsymbol{x} \\in \\{0, 1\\}^{s_x}} Q(x).</span></div>

    <p class="text-gray-300">Therefore,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} v_j &amp;amp;= \\sum_{\\boldsymbol{x} \\in \\{0, 1\\}^{s_x}} L_j(\\boldsymbol{x}) \\\\ &amp;amp;= \\sum_{\\boldsymbol{x} \\in \\{0, 1\\}^{s_x}} \\widetilde{eq}(\\boldsymbol{r}_x, \\boldsymbol{x}) \\cdot \\left( \\sum_{\\boldsymbol{y} \\in \\{0, 1\\}^s} \\widetilde{eq}(\\boldsymbol{r}_y, \\boldsymbol{y}) \\cdot \\widetilde{M}_j(\\boldsymbol{x}, \\boldsymbol{y}) \\right) \\\\ &amp;amp;= \\widetilde{M}_j(\\boldsymbol{r}_x, \\boldsymbol{r}_y). \\end{aligned}</span></div>

    <p class="text-gray-300">This implies that <span class="math">\\widetilde{\\boldsymbol{w}}</span> is a satisfying witness to <span class="math">(\\mathcal{S}, \\mathbf{u})</span>. Finally, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} 0 &amp;amp;= \\sum_{\\boldsymbol{x} \\in \\{0, 1\\}^{s_x}} Q(x) \\\\ &amp;amp;= \\sum_{\\boldsymbol{x} \\in \\{0, 1\\}^{s_x}} \\widetilde{eq}(\\boldsymbol{\\alpha}, \\boldsymbol{x}) \\cdot \\left( \\sum_{i \\in [q]} c_i&#x27; \\cdot \\prod_{j \\in S_i} \\left( \\sum_{\\boldsymbol{y} \\in \\{0, 1\\}^{s_y}} \\widetilde{M}_j&#x27;(\\boldsymbol{x}, \\boldsymbol{y}) \\cdot \\tilde{z}&#x27;(\\boldsymbol{y}) \\right) \\right) \\\\ &amp;amp;= \\sum_{i \\in [q]} c_i&#x27; \\cdot \\prod_{j \\in S_i} \\left( \\sum_{\\boldsymbol{y} \\in \\{0, 1\\}^{s_y}} \\widetilde{M}_j&#x27;(\\boldsymbol{\\alpha}, \\boldsymbol{y}) \\cdot \\tilde{z}&#x27;(\\boldsymbol{y}) \\right). \\end{aligned}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the Schwartz-Zippel lemma, this implies that with probability $1 - s_x /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1 - \\mathrm{negl}(\\lambda)<span class="math"> over the choice of </span>\\boldsymbol{\\alpha}<span class="math">, we have that for all </span>\\boldsymbol{x} \\in \\{0,1\\}^{s_x}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_{i \\in [q]} c_i&#x27; \\cdot \\prod_{j \\in S_i} \\left( \\sum_{\\boldsymbol{y} \\in \\{0, 1\\}^{s_y}} \\widetilde{M}_j&#x27;(\\boldsymbol{x}, \\boldsymbol{y}) \\cdot \\tilde{z}&#x27;(\\boldsymbol{y}) \\right).</span></div>

    <p class="text-gray-300">This implies that <span class="math">\\widetilde{\\boldsymbol{w}}&#x27;</span> is a satisfying witness to <span class="math">(\\mathcal{S}&#x27;, \\mathbf{u}&#x27;)</span>. Thus, if the extractor does not abort, it succeeds in producing satisfying witness <span class="math">\\widetilde{\\boldsymbol{w}}, \\widetilde{\\boldsymbol{w}}&#x27;</span> with probability <span class="math">1 - \\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300"><strong>Lemma 6.</strong> (Honest Verifier Zero Knowledge). Construction 1 satisfies honest verifier zero knowledge.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Consider an adversary <span class="math">\\mathcal{A}</span> that adaptively picks the structures and instances. Let <span class="math">\\mathsf{pp} \\gets \\mathcal{G}(1^{\\lambda})</span>. Suppose on input <span class="math">\\mathsf{pp}</span>, the adversary <span class="math">\\mathcal{A}</span> picks two structures</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\mathcal{S} &amp;amp;= \\{\\widetilde{M}_j\\}_{j \\in [t]}, \\\\ \\mathcal{S}&#x27; &amp;amp;= \\{\\widetilde{M}_j&#x27;\\}_{j \\in [t]}, \\{S_i&#x27;\\}_{i \\in [q]}, \\{c_i&#x27;\\}_{i \\in [q]}, \\end{aligned}</span></div>

    <p class="text-gray-300">a new committed CCS instance-witness pair</p>

    <p class="text-gray-300"><span class="math">(\\mathbf{u},\\mathbf{w})=(C,v_{0},\\mathsf{io},\\bm{r}_{x},\\bm{r}_{y},\\{v_{j}\\}_{j\\in[t]},v_{z},\\mathbf{w}),</span></p>

    <p class="text-gray-300">and committed CCS instance-witness pair</p>

    <p class="text-gray-300"><span class="math">(\\mathbf{u}^{\\prime},\\mathbf{w}^{\\prime})=(C^{\\prime},\\mathsf{io}^{\\prime}.\\mathbf{w}).</span></p>

    <p class="text-gray-300">With the keys generated by <span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow\\mathcal{K}(\\mathsf{pp},\\mathcal{S},\\mathcal{S}^{\\prime})</span>, the non-deterministic function <span class="math">\\mathsf{trace}</span> produces an interaction transcript <span class="math">\\mathsf{tr}</span> between honest <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> of <span class="math">\\Pi_{\\mathsf{fold}}</span> on input <span class="math">((\\mathsf{pk},\\mathsf{vk}),(\\mathbf{u},\\mathbf{u}^{\\prime}),(\\mathbf{w},\\mathbf{w}^{\\prime}))</span>.</p>

    <p class="text-gray-300">Next, we construct a PPT simulator <span class="math">\\mathsf{Sim}</span> producing the trace <span class="math">\\mathbf{\\hat{t}r}</span> with indistinguishable distribution from <span class="math">\\mathsf{tr}</span> with the input of <span class="math">(\\mathsf{pp},\\{(\\mathcal{S},\\mathcal{S}^{\\prime}),(\\mathbf{u},\\mathbf{u}^{\\prime}),\\rho)</span>.</p>

    <p class="text-gray-300">To begin with, the simulator inputs a random challenge <span class="math">\\hat{\\eta}</span> to aggregate the structures and instances accordingly to obtain the folded structure <span class="math">\\hat{S}^{*}</span> containing</p>

    <p class="text-gray-300"><span class="math">\\hat{M_{j}}^{*}=\\hat{\\eta}\\cdot M_{j}+\\hat{\\eta}^{2}\\cdot M_{j}^{\\prime}</span></p>

    <p class="text-gray-300">for all <span class="math">j\\in[t]</span>, and part of the folded instance <span class="math">\\hat{\\mathbf{u}}^{*}</span> containing</p>

    <p class="text-gray-300"><span class="math">\\hat{v_{0}}^{<em>}\\leftarrow\\hat{\\eta}\\cdot v_{0}+\\hat{\\eta}^{2}\\cdot 1,</span> <span class="math">\\hat{\\mathsf{io}}^{</em>}\\leftarrow\\hat{\\eta}\\cdot\\mathsf{io}+\\hat{\\eta}^{2}\\cdot\\mathsf{io}^{\\prime}.</span> <span class="math">\\hat{v_{j}}^{*}\\leftarrow\\hat{\\eta}\\cdot v_{j}+\\hat{\\eta}^{2}\\cdot v_{j}^{\\prime}\\ \\forall j\\in[t],</span></p>

    <p class="text-gray-300">To simulate the trace <span class="math">\\mathbf{\\hat{t}r}</span>, the simulator samples a random vector in <span class="math">\\mathbb{F}n-l-1</span> as <span class="math">\\hat{\\mathbf{w}}^{*}</span>, and compute the commitment on the random witness <span class="math">\\bm{w}</span> in the masking instance as</p>

    <p class="text-gray-300"><span class="math">\\hat{C}^{\\prime\\prime}=\\mathsf{Commit}(\\mathsf{pp},\\hat{\\mathbf{w}}^{*})-\\hat{\\eta}\\cdot C-\\hat{\\eta}^{2}\\cdot C^{\\prime}.</span></p>

    <p class="text-gray-300">The commitment <span class="math">\\hat{C}^{<em>}=\\mathsf{Commit}(\\mathsf{pp},\\hat{\\mathbf{w}}^{</em>})</span> is added to the instance <span class="math">\\hat{\\mathbf{u}}^{*}</span>.</p>

    <p class="text-gray-300">By sampling another random value as <span class="math">\\hat{v_{z}}^{*}</span>, the simulator computes the value <span class="math">\\hat{\\epsilon}^{\\prime\\prime}</span> for the claim on <span class="math">\\hat{v_{z}}^{\\prime\\prime}</span> of the masking instance as</p>

    <p class="text-gray-300"><span class="math">\\hat{\\epsilon}^{\\prime\\prime}=\\hat{v_{z}}^{*}-\\hat{\\eta}\\cdot\\hat{\\epsilon}-\\hat{\\eta}^{2}\\cdot\\hat{\\epsilon}^{\\prime},</span></p>

    <p class="text-gray-300">where <span class="math">\\hat{\\epsilon}=v_{z},\\hat{\\epsilon}^{\\prime}=v_{z}^{\\prime}</span>. The <span class="math">\\hat{v_{z}}^{<em>}</span> is then added to the instance <span class="math">\\hat{\\mathbf{u}}^{</em>}</span>.</p>

    <p class="text-gray-300">Denote <span class="math">\\hat{\\theta_{j}}=v_{j},\\hat{\\theta_{j}}^{{}^{\\prime}}=v_{j}^{\\prime},\\hat{\\theta_{j}}^{{}^{\\prime\\prime}}=\\bot</span> Now, we have obtained the claims on matrices and instance-witness pairs for three instances as follows</p>

    <p class="text-gray-300"><span class="math">\\hat{\\epsilon}=\\tilde{z}(\\bm{r}_{y}^{\\prime}),</span> <span class="math">\\hat{\\epsilon}^{\\prime}=\\tilde{z}^{\\prime}(\\bm{r}_{y}^{\\prime}),</span> <span class="math">\\hat{\\epsilon}^{\\prime\\prime}=\\tilde{z}^{\\prime}(\\bm{r}_{y}^{\\prime}),</span> <span class="math">\\hat{\\theta_{j}}=\\widetilde{M}_{j}(\\bm{r}_{x}^{\\prime},\\bm{r}_{y}^{\\prime}),\\forall j\\in[t],</span> <span class="math">\\hat{\\theta_{j}}^{{}^{\\prime}}=\\widetilde{M}_{j}^{\\prime}(\\bm{r}_{x}^{\\prime},\\bm{r}_{y}^{\\prime}),\\forall j\\in[t].</span></p>

    <p class="text-gray-300">Note that the matrices for making instance can be set equal to either <span class="math">\\{M_j\\}_{j \\in [t]}</span> or <span class="math">\\{M_j&#x27;\\}_{j \\in [t]}</span>. The above values are indistinguishable from those in <span class="math">\\mathbf{tr}</span>.</p>

    <p class="text-gray-300">According to the conclusion given by Chiesa et al. in [17], the <span class="math">\\mathsf{Sim}</span> can invoke another efficient simulator <span class="math">\\mathsf{Sim}_{\\mathsf{sc}}</span> to simulate an indistinguishable trace <span class="math">\\mathbf{tr}_2</span> for sum-check#2 based on the claims above.</p>

    <p class="text-gray-300">By running the similar process as above, the <span class="math">\\mathsf{Sim}</span> can simulate another indistinguishable trace <span class="math">\\mathbf{tr}_1</span> for sum-check#1 based on the claims given in <span class="math">\\mathbf{tr}_2</span>.</p>

    <p class="text-gray-300">Finally, the <span class="math">\\mathsf{Sim}</span> outputs a valid trace <span class="math">\\hat{\\mathbf{tr}}</span> constructed from <span class="math">\\hat{\\epsilon}, \\hat{\\epsilon}&#x27;, \\hat{\\epsilon}&#x27;&#x27;&#x27;, \\hat{\\theta}_j, \\hat{\\theta}_j&#x27;, \\hat{\\theta}_j&#x27;&#x27;</span> and <span class="math">\\mathbf{tr}_1, \\mathbf{tr}_2</span>. Obviously, the <span class="math">\\mathsf{Sim}</span> can be executed in polynomial time.</p>

    <h2 id="sec-54" class="text-2xl font-bold">C Security proofs for PCD</h2>

    <p class="text-gray-300">We refer to the security proofs of completeness and knowledge soundness to [39].</p>

    <p class="text-gray-300"><strong>Lemma 7 (Perfect Completeness).</strong> Construction 3 satisfies perfect completeness.</p>

    <p class="text-gray-300"><strong>Proof.</strong> For public parameter <span class="math">\\mathsf{pp}</span>, consider arbitrary adversarially chosen messages <span class="math">(\\varphi, z, z_{\\mathrm{loc}}, \\{z_i, \\Pi_i\\}_{k \\in [s]})</span> satisfying</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\varphi \\in \\mathsf{F}; \\varphi (z, z_{\\mathrm{loc}}, \\{z_k\\}_{k \\in [s]}) = 1; \\\\ \\forall k \\in [s], z_k = \\bot \\text{ or } \\mathcal{V}(\\mathsf{vk}, z_k, \\Pi_k) = 1, \\end{array}</span></div>

    <p class="text-gray-300">such that the perfect completeness precondition is satisfied. We show that given <span class="math">\\Pi \\gets \\mathcal{P}(\\mathsf{pk}, z, z_{\\mathrm{loc}}, \\{z_k, \\Pi_k\\}_{k \\in [s]})</span>, the verifier algorithm passes, i.e., <span class="math">\\mathcal{V}(\\mathsf{vk}, z, \\Pi) = 1</span> with probability 1.</p>

    <p class="text-gray-300">Specifically, there are two cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">z_k = \\bot</span> for all <span class="math">k \\in [s]</span>, the prover runs the algorithm honestly, and the compliance <span class="math">\\varphi(z, z_{\\mathrm{loc}}, z_1, \\dots, z_s)</span> holds by the preconditions. The circuit <span class="math">\\mathcal{R}_0</span> can be constructed accordingly and a satisfied <span class="math">\\mathcal{R}_{\\mathrm{CCCS}}</span> instance is as</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf{s}_0, \\mathbf{u}_0, \\mathbf{w}_0) \\leftarrow \\operatorname{trace}(R_0, (h, (z, z_{\\mathrm{loc}}, \\{z_k, \\mathbf{U}_k, \\mathbf{u}_k\\}_{k \\in [s]}, \\mathsf{vk}&#x27;))</span></div>

    <p class="text-gray-300">Then the prover sets <span class="math">(\\mathbf{U}, \\mathbf{W}, \\mathsf{pf})</span> accordingly to <span class="math">(\\mathbf{u}_0, \\mathbf{w}_0, \\bot)</span> and computes <span class="math">h = \\mathsf{Hash}(\\mathsf{vk}_{\\text{mathoffs}}&#x27;, z, \\mathbf{U})</span>. And the circuit <span class="math">\\mathcal{R}_1</span> can be constructed accordingly and a satisfied <span class="math">\\mathcal{R}_{\\mathrm{CCCS}}</span> instance is as</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf{s}, \\mathbf{u}, \\mathbf{w}) \\leftarrow \\operatorname{trace}(R_1, (h, (\\{\\mathbf{U}_k, \\mathbf{u}_k\\}_{k \\in [s]}, \\mathbf{u}_0, \\mathsf{vk}&#x27;, \\mathbf{U}, \\Pi)).</span></div>

    <p class="text-gray-300">Besides, <span class="math">\\mathbf{u}.\\mathbf{io} = \\mathsf{H}(\\mathsf{vk}&#x27;, z, \\mathbf{U})</span>. As a result, <span class="math">\\mathcal{V}(\\mathsf{vk}, z, \\Pi) = 1</span> with probability 1.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\exists k \\in [s]</span> such that <span class="math">z_k \\neq \\bot</span>, by the perfect completeness precondition, <span class="math">\\{\\mathbf{U}_k, \\mathbf{W}_k\\}_{k \\in [s]}</span> are satisfied <span class="math">\\mathcal{R}_{\\mathrm{ACCS}}</span> instance-witness pairs, <span class="math">\\{\\mathbf{u}_k, \\mathbf{w}_k\\}_{k \\in [s]}</span> are satisfied <span class="math">\\mathcal{R}_{\\mathrm{CCCS}}</span> instance-witness pairs, and <span class="math">\\mathbf{u}_k.\\mathbf{io} = \\mathsf{H}(\\mathsf{vk}&#x27;, z_k, \\mathbf{U}_k)</span>. The prover runs the algorithm honestly, and the compliance <span class="math">\\varphi(z, z_{\\mathrm{loc}}, z_1, \\dots, z_s)</span> holds by the preconditions. The circuit <span class="math">\\mathcal{R}_0</span> can be constructed accordingly and a satisfied <span class="math">\\mathcal{R}_{\\mathrm{CCCS}}</span> instance is as</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf{s}_0, \\mathbf{u}_0, \\mathbf{w}_0) \\leftarrow \\operatorname{trace}(R_0, (h, (z, z_{\\mathrm{loc}}, \\{z_k, \\mathbf{U}_k, \\mathbf{u}_k\\}_{k \\in [s]}, \\mathsf{vk}&#x27;))</span></div>

    <p class="text-gray-300">Then, the prover runs the generic foldings scheme for <span class="math">\\{\\mathsf{S}_k,\\mathbf{U}_k,\\mathbf{W}_k\\}_{k\\in [s]}</span>, <span class="math">\\{\\mathsf{s}_k,\\mathbf{u}_k,\\mathbf{w}_k\\}_{k = 0}^s</span>. By the perfect completeness of the generic folding scheme, we have that <span class="math">(\\mathbf{U},\\mathbf{W})</span> is a satisfied <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span> instance-witness pair. The circuit <span class="math">\\mathcal{R}_1</span> can be constructed accordingly and a satisfied <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span> instance is as</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf {s}, \\mathbf {u}, \\mathbf {w}) \\leftarrow \\operatorname {t r a c e} \\left(R _ {1}, \\left(h, \\left(\\left\\{z _ {k}, \\mathbf {U} _ {k}, \\mathbf {u} _ {k} \\right\\} _ {k \\in [ s ]}, \\mathbf {u} _ {0}, \\mathrm {v k} ^ {\\prime}, \\mathbf {U}, \\Pi\\right)\\right).</span></div>

    <p class="text-gray-300">Besides, <span class="math">\\mathbf{u}.\\mathbf{i}\\mathbf{o} = \\mathsf{H}(\\mathsf{v}\\mathsf{k}&#x27;,z,\\mathbf{U})</span>. As a result, <span class="math">\\mathcal{V}(\\mathsf{v}\\mathsf{k},z,\\varPi)=1</span> with probability 1.</p>

    <p class="text-gray-300">In conclusion, we show that Construction 3 has perfect completeness.</p>

    <p class="text-gray-300">Lemma 8 (Knowledge Soundness). Construction 3 satisfies knowledge soundness.</p>

    <p class="text-gray-300">Proof. Given a fixed set <span class="math">Z</span>, <span class="math">\\mathsf{pp} \\gets \\mathcal{G}(1^{\\lambda})</span> and auxiliary input <span class="math">\\mathsf{ai} \\gets \\mathcal{D}(\\mathsf{pp})</span>, the polynomial time adversary <span class="math">\\mathcal{P}^<em></span> succeeds in producing valid transcript <span class="math">(\\varphi, \\circ, \\Pi, \\mathsf{ao})</span> with non-negligible probability <span class="math">\\epsilon</span>. We aim to show that it is feasible to construct an extractor <span class="math">\\mathsf{Ext}_{\\mathcal{P}^</em>}</span> on input <span class="math">(\\mathsf{pp}, \\mathsf{ai})</span>, succeeds in outputting <span class="math">(\\varphi, \\mathsf{T}, \\mathsf{ao})</span> with probability <span class="math">\\epsilon - \\mathrm{negl}(\\lambda)</span>, where <span class="math">\\varphi \\in \\mathsf{F}</span>, <span class="math">(\\mathsf{pp}, \\mathsf{ai}, \\varphi, \\mathsf{ao}) \\in Z</span> and <span class="math">\\mathsf{T}</span> is <span class="math">\\varphi</span>-compliant.</p>

    <p class="text-gray-300">According to [14], it is convenient to assume the transcript <span class="math">\\mathsf{T}</span> as a <span class="math">d</span>-depth tree, where <span class="math">d</span> is the depth of <span class="math">\\varphi</span>. Among the tree <span class="math">\\mathsf{T}</span>, each node <span class="math">u</span> with local data <span class="math">z(u)_{\\mathrm{loc}}</span> has a unique outgoing edge labelled with <span class="math">z^{(u)}</span> and a proof <span class="math">\\varPi^{(u)}</span> for the correctness of <span class="math">z^{(u)}</span>. The extractor <span class="math">\\mathsf{Ext}_{\\mathcal{P}^<em>}</span> is constructed inductively by constructing a sequence of extractors <span class="math">\\mathsf{Ext}_0, \\ldots, \\mathsf{Ext}_d</span>. For <span class="math">i \\in 0, \\ldots, d</span>, <span class="math">\\mathsf{Ext}_i</span> outputs a <span class="math">(i + 1)</span>-depth tree <span class="math">\\mathsf{T}_i</span>. Basically, we define <span class="math">\\mathsf{Ext}_0(\\mathsf{pp}, \\mathsf{ai})</span> runs <span class="math">(\\varphi, \\circ, \\varPi, \\mathsf{ao}) \\gets \\mathcal{P}^</em>(\\mathsf{pp}, \\mathsf{ai})</span> and outputs <span class="math">(\\varphi, \\mathsf{T}_0, \\mathsf{ao})</span>, where <span class="math">\\mathsf{T}_0</span> contains only one node labeled with <span class="math">(\\circ, \\varPi)</span>.</p>

    <p class="text-gray-300">Then assume we already have extractor <span class="math">\\mathsf{Ext}_{i-1}</span>. To construct <span class="math">\\mathsf{Ext}_i</span>, an adversary <span class="math">\\mathcal{P}_{i-1}^*</span> for the zero-knowledge non-interactive generic folding scheme needs to be constructed first.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{i - 1}^{*}(\\mathsf{pp},\\mathsf{ai},\\rho)</span>:</p>

    <p class="text-gray-300">1: Compute <span class="math">(\\varphi, \\mathsf{T}_{i-1}, \\mathsf{ao}) \\gets \\mathsf{Ext}_{i-1}(\\mathsf{pp}, \\mathsf{ai})</span>. If <span class="math">\\mathsf{T}_{i-1}</span> is not a tree of depth <span class="math">i</span>, abort. 2: For each node <span class="math">u \\in L_{\\mathsf{T}_{i-1}}(i)</span>, denote its label as <span class="math">(z^{(u)}, \\Pi_{(u)})</span>. 3: Parse <span class="math">\\Pi^{(u)}</span> as <span class="math">((\\mathbf{U}^{(u)},\\mathbf{W}^{(u)}),(\\mathbf{u}^{(u)},\\mathbf{w}^{(u)}))</span>. 4: Obtain <span class="math">(\\{\\mathbf{U}_k^{(u)},\\mathbf{u}_k^{(u)},z_j^{(u)}\\}_{k\\in [s]},\\mathbf{u}_0,\\mathsf{pf}^{(u)})</span> from <span class="math">\\mathbf{w}^{(u)}</span>. 5: Let <span class="math">L_{i-1} \\coloneqq \\{u \\in L_{\\mathsf{T}_{i-1}}(i) \\mid \\exists k \\in [s], z_k^{(u)} \\neq \\bot\\}</span>. 6: Output <span class="math">\\left(\\left\\{\\{\\mathbf{U}_k^{(u)},\\mathbf{u}_k^{(u)}\\}_{k\\in [s]},\\mathbf{u}_0^{(u)},\\mathbf{U}^{(u)},\\mathbf{W}^{(u)},\\mathsf{pf}^{(u)}\\right\\}_{u\\in L_{i - 1}},(\\varphi ,\\mathsf{T}_{i - 1},\\mathsf{ao})\\right)</span>.</p>

    <p class="text-gray-300">where <span class="math">L_{\\mathsf{T}_{i-1}}(i)</span> denotes the set of nodes of <span class="math">\\mathsf{T}</span> at depth <span class="math">i</span>. According to the knowledge soundness of the generic folding scheme, we can construct another extractor <span class="math">\\mathsf{Ext}_{\\mathcal{P}_{i-1}^<em>}</span>. On input <span class="math">v \\in L_{i-1}</span>, <span class="math">\\mathsf{Ext}_{\\mathcal{P}_{i-1}^</em>}</span> outputs <span class="math">\\{\\mathbf{W}_k^{(u)}, \\mathbf{w}_k^{(u)}\\}_{k \\in [s]}</span> and <span class="math">\\mathbf{w}_0^{(u)}</span> with non-negligible probability, where <span class="math">\\{\\mathbf{U}_k^{(u)}, \\mathbf{W}_k^{(u)}\\}_{k \\in [s]}</span> are satisfied atomic CCS instance-witness pairs and <span class="math">\\{\\mathbf{u}_k^{(u)}, \\mathbf{w}_k^{(u)}\\}_{k=0}^s</span> are satisfied committed CCS instance-witness pairs.</p>

    <p class="text-gray-300">Based on <span class="math">\\mathcal{P}_{i-1}^<em>, \\mathsf{Ext}_{\\mathcal{P}_{i-1}^</em>}</span>, we can further construct <span class="math">\\mathsf{Ext}_i</span> as follows.</p>

    <p class="text-gray-300"><span class="math">(\\varphi, \\mathsf{T}_i, \\mathsf{ao}) \\gets \\mathsf{Ext}_i(\\mathsf{pp}, \\mathsf{ai})</span> :</p>

    <p class="text-gray-300">1: Compute  <span class="math">\\left(\\left\\{\\{\\mathbf{U}_k^{(u)},\\mathbf{W}_k^{(u)}\\}_{k\\in [s]},\\{\\mathbf{u}_k^{(u)},\\mathbf{w}_k^{(u)}\\}_{k = 0}^<em>\\right\\}_{u\\in L_{i - 1}},(\\varphi ,\\mathsf{T}_{i - 1},\\mathsf{ao})\\right)</span> <span class="math">\\leftarrow \\mathsf{Ext}_{\\mathcal{P}_{i - 1}^</em>}(\\mathsf{pp},\\mathsf{ai},\\rho).</span>  If  <span class="math">\\mathsf{T}_{i - 1}</span>  is not a tree of depth  <span class="math">i</span>  , abort. 2: Retrieve  <span class="math">\\{\\mathbf{w}^{(u)}\\}_{u\\in L_{\\mathsf{T}_{i - 1}}(i)}</span>  from the internal state of  <span class="math">\\mathcal{P}_{i - 1}^*</span>  and obtain  <span class="math">z_{\\mathrm{loc}}^{(u)},\\{z_k^{(u)}\\}_{k\\in [s]}</span>  from  <span class="math">\\mathbf{w}^{(u)}</span> 3: Append  <span class="math">z_{\\mathrm{loc}}^{(u)}</span>  to the label of  <span class="math">u \\in L_{\\mathsf{T}_{i-1}(i)}</span> . 4: For each node  <span class="math">u \\in L_{i-1}</span> , let  <span class="math">L_u := \\{k \\in [s] \\mid z_k^{(u)} \\neq \\bot\\}</span> . Construct  <span class="math">\\mathsf{T}_i</span>  of depth  <span class="math">i+1</span>  from  <span class="math">\\mathsf{T}_{i-1}</span>  by adding, for each node  <span class="math">u \\in L_{i-1}</span> ,  <span class="math">(z_k^{(u)}, \\Pi_k^{(u)})</span>  to the label of its child  <span class="math">k \\in L_u</span> , where  <span class="math">\\Pi_k^{(u)} = \\left((\\mathbf{U}_k^{(u)}, \\mathbf{W}_k^{(u)}), (\\mathbf{u}_k^{(u)}, \\mathbf{w}_k^{(u)})\\right)</span> . 5: Output  <span class="math">(\\varphi, \\mathsf{T}_i, \\mathsf{ao})</span></p>

    <p class="text-gray-300">We claim that for  <span class="math">i \\in \\{0, 1, \\dots, d\\}</span> , the extractor  <span class="math">\\mathsf{Ext}_i(\\mathsf{pp}, \\mathsf{ai})</span>  outputs  <span class="math">(\\varphi, \\mathsf{T}_i, \\mathsf{ao})</span>  in expected polynomial time such that with probability  <span class="math">\\epsilon - \\mathrm{negl}(\\lambda)</span> , the following conditions hold</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\varphi \\in \\mathsf{F}</span> ,  <span class="math">(\\mathsf{pp}, \\mathsf{ai}, \\varphi, \\circ (\\mathsf{T}_i), \\mathsf{ao}) \\in Z</span> ;</li>

      <li><span class="math">\\mathsf{T}_i</span>  is  <span class="math">\\varphi</span> -compliant up to depth  <span class="math">i</span> ;</li>

      <li>for all  <span class="math">u \\in L_{\\mathsf{T}_i}(i + 1)</span> ,  <span class="math">\\mathcal{V}(\\mathsf{vk}, z^{(u)}, \\Pi^{(u)}) = 1</span> .</li>

    </ul>

    <p class="text-gray-300">The correctness of the above claim can be proved by induction.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(Base case.) Since  <span class="math">\\mathsf{Ext}_0(\\mathsf{pp},\\mathsf{ai})</span>  runs  <span class="math">(\\varphi, \\circ, \\Pi, \\mathsf{ao}) \\gets \\mathcal{P}^*(\\mathsf{pp},\\mathsf{ai})</span> , it satisfies the conditions above.</li>

      <li>(Inductive hypothesis.) Assume that the extractor  <span class="math">\\mathsf{Ext}_{i - 1}</span>  satisfies the above-mentioned conditions.</li>

      <li>(Inductive step.) Based on the hypothesis, we show that  <span class="math">\\mathsf{Ext}_i</span>  also satisfies the conditions by the following discussion.</li>

    </ul>

    <p class="text-gray-300">The inductive hypothesis ensures that  <span class="math">\\mathsf{Ext}_{i-1}</span>  satisfies with probability  <span class="math">\\epsilon</span> -negl( <span class="math">\\lambda</span> ), that  <span class="math">\\varphi \\in \\mathsf{F}</span> ,  <span class="math">(\\mathsf{pp}, \\mathsf{ai}, \\varphi, \\circ (\\mathsf{T}_{i-1}), \\mathsf{ao}) \\in Z</span> ,  <span class="math">\\mathsf{T}_{i-1}</span>  is  <span class="math">\\varphi</span> -compliant up to the depth  <span class="math">i-1</span> , and for all  <span class="math">u \\in L_{\\mathsf{T}_{i-1}}(i)</span> ,  <span class="math">\\mathcal{V}(\\mathsf{vk}, z^{(u)}, \\Pi^{(u)}) = 1</span> . By the correctness of algorithm  <span class="math">\\mathcal{V}</span> , we have</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(1)  <span class="math">\\{(\\mathbf{U}^{(u)},\\mathbf{W}^{(u)}),(\\mathbf{u}^{(u)},\\mathbf{w}^{(u)})\\}_{u\\in L_{\\mathsf{T}_{i - 1}(i)}}</span>  are satisfied instance-witness pairs.</li>

    </ul>

    <p class="text-gray-300">Since  <span class="math">\\mathsf{T}_{i - 1}</span>  is  <span class="math">\\varphi</span> -compliant, by the construction of  <span class="math">\\mathcal{R}_0, \\mathcal{R}_1</span>  and hash function Hash, we have</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(2) for  <span class="math">u \\in L_{\\mathsf{T}_{i - 1}}(i), \\varphi(z^{(u)}, z_{\\mathrm{loc}}^{(u)}, z_1^{(u)}, \\ldots, z_s^{(u)})</span>  accepts;</li>

    </ul>

    <p class="text-gray-300">(3) for  <span class="math">u \\in L_{i-1}</span> ,  <span class="math">\\mathbf{U}^{(u)} = \\mathsf{zk}</span> -NIFS.  <span class="math">\\mathcal{V}&#x27;(\\mathsf{vk}&#x27;, \\{\\mathbf{U}_k^{(u)}\\}_{k \\in [s]}, \\{\\mathbf{u}_k^{(u)}\\}_{k=0}^s, \\mathsf{pf}^{(u)})</span> ; (4) for  <span class="math">u \\in L_{i-1}</span> ,  <span class="math">\\mathbf{u}_k^{(u)}.\\mathbf{io} = \\mathsf{Hash}(\\mathsf{vk}&#x27;, z_k^{(u)}, \\mathbf{U}_k^{(u)}) \\forall k \\in [s]</span> .</p>

    <p class="text-gray-300">(2) implies that  <span class="math">\\mathsf{T}_i</span>  is  <span class="math">\\varphi</span> -compliant up to depth  <span class="math">i</span>  and  <span class="math">\\varphi \\in \\mathsf{F}</span> ,  <span class="math">(\\mathsf{pp}, \\mathsf{ai}, \\varphi, \\circ(\\mathsf{T}_i), \\mathsf{ao}) \\in Z</span> . (1) and (3) imply that there exists efficient construction of  <span class="math">\\mathcal{P}_{i-1}^<em></span>  that succeeds in producing folded pairs  <span class="math">\\{\\mathbf{U}^{(u)}, \\mathbf{W}^{(u)}\\}_{u \\in L_{i-1}}</span>  with probability  <span class="math">\\epsilon - \\mathrm{negl}(\\lambda)</span> . Then there exists an efficient extractor  <span class="math">\\mathsf{Ext}_{\\mathcal{P}_{i-1}^</em>}</span>  outputting  <span class="math">\\{\\{\\mathbf{W}_k^{(u)}\\}_{k \\in [s]}, \\{\\mathbf{w}_k^{(u)}\\}_{k=0}^s\\}_{u \\in L_{i-1}}</span>  guaranteed by the knowledge soundness of generic foldings scheme. (1)-(4) imply that  <span class="math">\\mathcal{V}(\\mathsf{vk}, z^{(u)}, \\Pi^{(u)}) = 1</span>  holds for all  <span class="math">u \\in L_{(T)_i}(i+1)</span> . Therefore, the hypothesis for  <span class="math">\\mathsf{Ext}_i</span>  also holds.</p>

    <p class="text-gray-300">In conclusion, we prove that Construction 3 is knowledge-sound.</p>

    <p class="text-gray-300">Lemma 9 (Zero Knowledge). Construction 3 satisfies zero knowledge.</p>

    <p class="text-gray-300">Proof. We prove that PCD is zero-knowledge by constructing a probabilistic polynomial-time simulator Sim as</p>

    <p class="text-gray-300">Sim(1):</p>

    <p class="text-gray-300">1: Compute  <span class="math">(\\mathsf{pp}_{\\mathrm{fs}},\\tau_{\\mathrm{fs}})\\gets \\mathsf{Sim}_{\\mathrm{fs}}(1^{\\lambda})</span> 2: Output  <span class="math">(\\mathsf{pp} = \\mathsf{pp}_{\\mathsf{fs}},\\tau = \\tau_{\\mathsf{fs}})</span></p>

    <p class="text-gray-300">Sim(pp,  <span class="math">\\varphi ,z,\\tau</span></p>

    <p class="text-gray-300">1: Obtain  <span class="math">\\{\\mathsf{S}_k,\\mathbf{U}_k\\}_{k\\in [s]}</span> <span class="math">\\{\\mathsf{s}_k,\\mathbf{u}_k\\}_{k = 0}^s</span>  from public  <span class="math">\\mathcal{R}_1</span> 2: Compute  <span class="math">(\\mathsf{S},\\mathbf{U},\\mathbf{W},\\mathsf{pf})\\gets \\mathsf{Sim}_{\\mathsf{fs}}(\\mathsf{pp}_{\\mathsf{fs}},\\{\\mathsf{S}^{(k)},\\mathbf{U}^{(k)}\\}_{k\\in [s]},\\{\\mathsf{s}^{(k)},\\mathbf{u}^{(k)}\\}_{k = 0}^{s},\\tau)</span> 3: Compute  <span class="math">h \\gets \\operatorname{Hash}(\\mathsf{vk}_{\\mathsf{fs}}^i, z, \\mathbf{U})</span> . 4: Output  <span class="math">(\\mathsf{s},\\mathbf{u},\\mathbf{w})\\gets \\mathsf{trace}(\\mathcal{R}_1,(h,(\\{\\mathbf{U}_k,\\mathbf{u}_k\\}_{k\\in [s]},\\mathbf{u}_0,\\mathsf{vk}_{\\mathsf{fs}}^i,\\mathbf{U},\\mathsf{pf}))).</span></p>

    <p class="text-gray-300">□</p>`;
---

<BaseLayout title="KiloNova: Non-Uniform PCD with Zero-Knowledge Property from ... (2023/1579)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/1579
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
