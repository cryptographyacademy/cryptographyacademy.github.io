---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/812';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Improved Interpolation Attacks on Cryptographic Primitives of Low Algebraic Degree';
const AUTHORS_HTML = 'Chaoyun Li, Bart Preneel';

const CONTENT = `    <p class="text-gray-300">Chaoyun Li Bart Preneel</p>

    <p class="text-gray-300">imec-COSIC, Dept. Electrical Engineering (ESAT), KU Leuven, Leuven, Belgium chaoyun.li@esat.kuleuven.be, bart.preneel@esat.kuleuven.be</p>

    <p class="text-gray-300">Abstract. Symmetric cryptographic primitives with low multiplicative complexity have been proposed to improve the performance of emerging applications such as secure Multi-Party Computation. However, primitives composed of round functions with low algebraic degree require a careful evaluation to assess their security against algebraic cryptanalysis, and in particular interpolation attacks. This paper proposes new low-memory interpolation attacks on symmetric key primitives of low degree. Moreover, we present generic attacks on block ciphers with a simple key schedule; our attacks require either constant memory or constant data complexity. The improved attack is applied to the block cipher MiMC which aims to minimize the number of multiplications in large finite fields. As a result, we can break MiMC-129/129 with 38 rounds with time and data complexity <span class="math">2^{65.5}</span> and <span class="math">2^{60.2}</span> respectively and with negligible memory; this attack invalidates one of the security claims of the designers. Our attack indicates that for MiMC-129/129 the full 82 rounds are necessary even with restrictions on the memory available to the attacker. For variants of MiMC with larger keys, we present new attacks with reduced complexity. Our results do not affect the security claims of the full round MiMC.</p>

    <p class="text-gray-300">Keywords: Block cipher, Cryptanalysis, Interpolation attack, MiMC</p>

    <p class="text-gray-300">Symmetric cryptographic primitives have been widely employed to provide confidentiality and authenticity for communicated and stored data [24]. Recently, they find new applications in advanced cryptographic protocols for computing on encrypted data, such as secure Multi-Party Computation (MPC), Zero-Knowledge proofs (ZK) and Fully Homomorphic Encryption (FHE). The adoption of dedicated symmetric key primitives turns out to be vital to improve the efficiency of these protocols. The main design goal is to minimize the multiplicative complexity (MC), i.e., minimize the number of multiplications in a circuit and/or to minimize the multiplicative depth of the circuit. However, traditional block ciphers, stream ciphers and hash functions are typically not designed to minimize these parameters; to the contrary, having high multiplicative depth is seen as an important requirement to achieve strong security.</p>

    <p class="text-gray-300">Many new symmetric primitives have been proposed in the context of MPC, ZK, or FHE schemes <em>[5, 15, 8, 3]</em>. The block cipher LowMC <em>[5]</em> is one of the earliest designs dedicated to FHE and MPC applications. With very small multiplicative size and depth, it outperforms AES-128 in computation and communication complexity for these applications. The stream ciphers Kreyvium <em>[8]</em> and FLIP <em>[20]</em> have been designed to minimize the AND-depth of the circuit. Indeed, they aim to provide practical solutions for efficient homomorphic-ciphertext compression <em>[8, 20]</em>. A new family of stream ciphers Rasta <em>[12]</em> intends to achieve both minimum AND-depth and minimum number of AND gates per encrypted bit.</p>

    <p class="text-gray-300">MiMC, proposed by Albrecht et al. in 2016 <em>[3, 4]</em>, is dedicated to applications for which the total number of field multiplications in the underlying cryptographic primitive poses the largest performance bottleneck. More specifically, MiMC aims to minimize multiplications in the larger fields <span class="math">\\mathbb{F}_{2^{n}}</span> and <span class="math">\\mathbb{F}_{p}</span>. Indeed, MiMC outperforms both AES and LowMC in applications such as MPC <em>[15]</em>, Succinct Non-interactive Arguments of Knowledge (SNARKs) <em>[7]</em>, and Scalable Transparent ARguments of Knowledge (STARKs) <em>[6]</em>. New variants of MiMC, such as GMiMC <em>[2]</em>, have been constructed by inserting the original design into generalized Feistel structures.</p>

    <p class="text-gray-300">However, the security of MiMC is not well understood. Due to the simple algebraic structure and the large number of rounds, the security evaluation of MiMC has been focusing on algebraic attacks such as interpolation attacks and Gröbner basis attacks <em>[3, 1]</em>. In the design paper, the authors first consider the classical interpolation attack. Moreover, the so-called GCD attack has been introduced. With this new technique, new lower bounds on the number of rounds have been derived. However, there is a need for further work to assess the security of round-reduced MiMC and to find tighter lower bounds on the number of rounds.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Our Contributions.</h4>

    <p class="text-gray-300">This paper presents novel attacks against primitives with low algebraic degree. The first new attack is based on an observation from Sun et al. <em>[27]</em>. It introduces novel interpolation attacks with constant memory complexity: some key-dependent terms of the interpolated polynomial are determined directly, without constructing the complete polynomial. Then we propose an algorithm with constant memory for recovering the second highest order coefficient resulting in an efficient key recovery attack.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The second new attack exploits a simple cyclic key schedule. The master key is $k_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{\\ell-1}<span class="math"> and the round keys are given by </span>k_{i}=k_{i\\bmod\\ell}+c_{i}\\,,<span class="math"> where the </span>c_{i}<span class="math">’s are constants that are chosen independently. For this specific key schedule, we present generic attacks with either constant memory or constant data complexity. Our attacks follow a guess-and-determine strategy. After guessing </span>(\\ell-1)$ subkeys, we apply state-of-the-art key recovery attacks to the reduced cipher. The advantage of our strategy is that we can keep the data and memory complexity of the whole attack as low as those of the attack on the reduced cipher. The results of our attacks are summarized in Table 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As an illustration, we apply the new attacks to the block cipher MiMC. Specifically, we can break 38-round MiMC-129/129 with time complexity <span class="math">2^{65.5}</span></p>

    <p class="text-gray-300">data complexity <span class="math">2^{60.2}</span> and negligible memory. Our results refute the claim of the MiMC designers who consider attacks with less than <span class="math">2^{64}</span> bytes memory and conclude <em>[4, p. 17]</em>: “38 rounds are sufficient to protect MiMC-129/129 against the interpolation, the GCD and the other attacks. Time-memory trade-offs might well be possible, and we leave this as a topic for future research.” Our attack simply reduces memory while keeping the time complexity at the same value, hence we show that there is no trade-off. Further, our attack indicates that for MiMC-<span class="math">n/n</span> over <span class="math">\\mathbb{F}_{q}</span> the number of rounds cannot be smaller than <span class="math">\\lceil\\frac{\\log_{2}(q)}{\\log_{2}(3)}\\rceil</span> even if there is a restriction on the memory available to the attacker.</p>

    <p class="text-gray-300">For a two-key version of MiMC-<span class="math">n/n</span>, the best attack described by the designers has complexity <span class="math">O(3^{3r})</span>. The designers further claimed that the bound can be improved by a Meet-In-The-Middle (MITM) attack <em>[4, p. 18]</em>, but they offer no details. By employing our generic attack to the concrete design, the complexity can be reduced to <span class="math">O(r3^{r})</span> if <span class="math">r\\leq\\lceil\\frac{n}{\\log_{2}(3)}\\rceil-1</span> and <span class="math">O(r3^{2r-1})</span> if <span class="math">r\\geq\\lceil\\frac{n}{\\log_{2}(3)}\\rceil</span>. Our reduced bound is the first tighter bound based on specific attacks.</p>

    <p class="text-gray-300">To the best of our knowledge, our analysis of MiMC is the first third party cryptanalysis of MiMC.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Related Work.</h4>

    <p class="text-gray-300">MiMC has a very a simple round function <span class="math">F_{i}(x):=(x+k+c_{i})^{3}</span>. This design is inspired by the KN cipher of Nyberg and Knudsen <em>[22]</em> and the <span class="math">\\mathcal{PURE}</span> cipher of Jakobsen and Knudsen, which is a simplified variant of the KN cipher <em>[16]</em>. The KN cipher is a prototype cipher which is provably secure against linear and differential attacks. However, Jakobsen and Knudsen showed that the KN cipher is vulnerable to the higher-order differential attacks <em>[16]</em>. The same authors introduced interpolation attacks and applied the new method to assess the security of <span class="math">\\mathcal{PURE}</span> <em>[16, 17]</em>.</p>

    <p class="text-gray-300">However, neither the higher-order differential attack <em>[19, 18]</em> nor the classical interpolation attack is applicable to MiMC. In both attacks, one needs to guess the last round key which is exactly the master key of MiMC. Thus, one already reaches the complexity of exhaustive key search. By contrast, our low-memory interpolation attack does not need to guess any round key; it is the first low-memory attack applicable to round-reduced MiMC.</p>

    <p class="text-gray-300">Interpolation attacks are known to be efficient against primitives with operations over a large finite field. To improve the attack on bit-oriented primitives, Dinur et al. <em>[10]</em> proposed the optimized interpolation attack, which breaks the first version of LowMC. The optimized interpolation attacks exploit higher-order differential properties, building on Shimoyama et al. <em>[25]</em>. As pointed out by the designers of MiMC, the degree of any state bits rises quickly when the round function is viewed as a vectorial Boolean function. This makes it impossible to obtain higher-order differentials of MiMC after a few rounds. Hence, the optimized interpolation attacks on MiMC would be infeasible.</p>

    <p class="text-gray-300">Recently, Rechberger et al. have introduced difference enumeration techniques to analyze the full LowMC v2 <em>[23]</em>. In order to counter this atack, a new version was proposed called LowMC v3 <em>[5]</em>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Table 1. Attacks on  <span class="math">r</span> -round key-alternating and Feistel network ciphers with round function of degree  <span class="math">d</span>  over  <span class="math">\\mathbb{F}_q</span> . For  <span class="math">\\ell &amp;gt; 1</span> , we cyclically add  <span class="math">\\ell</span>  independent subkeys in each round.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Key size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Memory</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Data</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ref.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Key-alternating</td>

            <td class="px-3 py-2 border-b border-gray-700">q</td>

            <td class="px-3 py-2 border-b border-gray-700">O(rdr)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(rdr)</td>

            <td class="px-3 py-2 border-b border-gray-700">dr+1</td>

            <td class="px-3 py-2 border-b border-gray-700">[4]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">q</td>

            <td class="px-3 py-2 border-b border-gray-700">O(r2dr)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(rdr)</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">[4]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">q</td>

            <td class="px-3 py-2 border-b border-gray-700">O(rdr)‡</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">dr+1</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect. 3.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">qℓ</td>

            <td class="px-3 py-2 border-b border-gray-700">O(rdr)‡</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">dr+1</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect. 4.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">qℓ</td>

            <td class="px-3 py-2 border-b border-gray-700">O(RER(r,ℓ)dRER(r,ℓ)qℓ-1} †‡</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">dRER(r,ℓ)+1</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect. 4.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">qℓ</td>

            <td class="px-3 py-2 border-b border-gray-700">O(RER(r,ℓ)2dRER(r,ℓ)qℓ-1}</td>

            <td class="px-3 py-2 border-b border-gray-700">O(RER(r,ℓ)dRER(r,ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect. 4.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Feistel network</td>

            <td class="px-3 py-2 border-b border-gray-700">q</td>

            <td class="px-3 py-2 border-b border-gray-700">O([r/2]2d(r/2)]</td>

            <td class="px-3 py-2 border-b border-gray-700">O([r/2]d(r/2)]</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">[4]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">q</td>

            <td class="px-3 py-2 border-b border-gray-700">O(rdr-2)¶</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">dr-2+1</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect. 3.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">qℓ</td>

            <td class="px-3 py-2 border-b border-gray-700">O(rdr-2)¶</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">dr-2+1</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect. 4.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">qℓ</td>

            <td class="px-3 py-2 border-b border-gray-700">O(RER(r,ℓ)dRER(r,ℓ)-2qℓ-1}¶‡</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">dRER(r,ℓ)-2+1</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect. 4.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">qℓ</td>

            <td class="px-3 py-2 border-b border-gray-700">O([RER(r,ℓ)/2]2d[RER(r,ℓ)/2]qℓ-1}</td>

            <td class="px-3 py-2 border-b border-gray-700">O([RER(r,ℓ)/2]d[RER(r,ℓ)/2])</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect. 4.2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\sharp r \\leq \\lceil \\log_d(q - 1) \\rceil + \\ell - 2</span> <span class="math">\\mathbb{P}r\\leq \\lceil \\log_d(q - 1)\\rceil +\\ell</span> <span class="math">\\dagger R_{\\mathrm{ER}}(r,\\ell) = \\left(\\lfloor \\frac{r + 1}{2}\\rfloor -1\\right)\\ell</span> <span class="math">\\ddagger R_{\\mathrm{PR}}(r,\\ell) = 1 + \\left(\\lfloor \\frac{r}{2}\\rfloor -1\\right)\\ell</span></p>

    <p class="text-gray-300">We conclude the related work by briefly recalling some recent work on the dedicated low MC stream ciphers Kreyvium and FLIP. Cube attacks <em>[11]</em> and guess-and-determine attacks are common techniques for the cryptanalysis of stream ciphers. Cube attacks based on the division property have been introduced by Todo <em>et al.</em> <em>[28]</em> and further improved by Wang <em>et al.</em> <em>[29]</em>. They yield the current best key recovery attack on round-reduced Kreyvium. A preliminary version of the stream cipher FLIP <em>[20]</em> has been broken by guess-and-determine attacks <em>[13]</em>. This has resulted in more conservative parameters of the design.</p>

    <p class="text-gray-300">The remainder of this paper is organized as follows. In Sect. 2, we introduce iterated ciphers and recall some classical polynomial algorithms. In Sect. 3, new low-memory interpolation attacks are presented. Section 4 proposes attacks on ciphers with simple key schedules. Applications of our attacks to MiMC are provided in Sect. 5. The final section concludes the paper.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">In this section, alternating ciphers and Feistel ciphers are presented. We also recall some polynomial algorithms, which will be used in the sequel.</p>

    <h5 id="sec-6" class="text-base font-semibold mt-4">Notation.</h5>

    <p class="text-gray-300">We will use the following notation in the sequel.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathbb{F}_{q}\\,</span>be the finite field with <span class="math">q</span> elements, where <span class="math">q</span> is a prime power.</li>

      <li>The symbol “<span class="math">+</span>” stands for addition in the finite field <span class="math">\\mathbb{F}_{q}\\,</span>. It can also denote integer addition; we trust that the meaning will be clear from the context.</li>

      <li><span class="math">d</span> is the degree of the round function <span class="math">F(x)</span>, where <span class="math">d&gt;1</span></li>

      <li><span class="math">r</span> represents the number of rounds of a block cipher</li>

      <li><span class="math">\\kappa</span> is the size of key space in bits</li>

      <li><span class="math">R(d,q)=\\lceil\\log_{d}(q-1)\\rceil</span></li>

      <li>T/M/D represent time, memory and data complexities of an attack respectively</li>

    </ul>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.1 Basic Constructions for Block Ciphers</h3>

    <p class="text-gray-300">An <span class="math">r</span>-round <em>key-alternating (KA) cipher</em> is constructed by iterating a round function <span class="math">r</span> times where each round consists of a key addition and the application of a nonlinear function <span class="math">F</span>. The ciphertext is obtained by adding a final key <span class="math">k_{r}</span> to the output of the last round. Let the round function be <span class="math">F_{i}(x)=F(x+k_{i})</span>. Then the encryption process is given by</p>

    <p class="text-gray-300"><span class="math">E_{k}(x)=(F_{r-1}\\circ F_{r-2}\\circ\\cdots\\circ F_{0})(x)+k_{r}\\,,</span> (1)</p>

    <p class="text-gray-300">where <span class="math">k</span> is the master key, <span class="math">k_{i}</span> is the <span class="math">i</span>-th round key derived from <span class="math">k</span> by a key schedule algorithm, and <span class="math">x</span> and <span class="math">E_{k}(x)</span> are plaintext and ciphertext, respectively. An <span class="math">r</span>-round KA cipher is depicted in Fig. 1.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. A key-alternating cipher</p>

    <p class="text-gray-300">An <span class="math">r</span>-round Feistel Network (FN) cipher consists of the <span class="math">r</span>-round repetition of a round function <span class="math">F</span> and swap:</p>

    <div class="my-4 text-center"><span class="math-block">x _ {i} ^ {L} = x _ {i - 1} ^ {R}, \\tag {2}</span></div>

    <div class="my-4 text-center"><span class="math-block">x _ {i} ^ {R} = F \\left(k _ {i} + x _ {i - 1} ^ {R}\\right) + x _ {i - 1} ^ {L}, \\tag {3}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $x = x_0^L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_0^R<span class="math"> is the plaintext, and the ciphertext is </span>x_r^R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_r^L$ since the swap operation is not applied in the last round. One round of an FN cipher is depicted in Fig. 2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2. One round of a Feistel network</p>

    <p class="text-gray-300">In this paper, we always assume that the round function <span class="math">F</span> is a monic polynomial of degree <span class="math">d</span> over <span class="math">\\mathbb{F}_q</span>, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">F (x) = x ^ {d} + \\sum_ {i = 0} ^ {d - 1} a _ {i} x ^ {i}, \\tag {4}</span></div>

    <p class="text-gray-300">where <span class="math">d</span> is a positive integer and <span class="math">a_{i}\\in \\mathbb{F}_{q}</span></p>

    <p class="text-gray-300">We associate to the parameters <span class="math">q, \\kappa, d, r</span> (cf. supra) a KA cipher <span class="math">\\mathrm{KA}[q, \\kappa, d, r]</span>. Similarly, we define the FN cipher <span class="math">\\mathrm{FN}[q, \\kappa, d, r]</span>. Here <span class="math">q</span> is the size of only half of the state, i.e., the whole state has size <span class="math">q^2</span>. It should be pointed that we ignore the details of the polynomials since our attacks work on the generic constructions regardless of the concrete choice of the components.</p>

    <p class="text-gray-300">How to Choose the Polynomial <span class="math">F(x)</span>. Since a block cipher must have invertible round functions, <span class="math">F(x)</span> needs to be a permutation polynomial for KA ciphers. While for FN ciphers, there is no such restriction. It is readily seen that <span class="math">F(x)</span> is the only nonlinear component. For instance, <span class="math">F(x)</span> must have high nonlinearity and low differential uniformity to provide resistance against differential and linear attacks <em>[21, 9]</em>. For FHE- and MPC-friendly ciphers, an additional requirement is to minimize the number of multiplications in the implementation of <span class="math">F(x)</span>. This motivates the choice of <span class="math">F(x)</span> with very low algebraic degree, such as <span class="math">x^{3}</span> in MiMC.</p>

    <p class="text-gray-300">The Number of Rounds. Since we focus on ciphers with low degree components, a large number of rounds is needed to protect against algebraic cryptanalysis. The design goal is to achieve the balance between security and performance. Thus we aim to deduce some lower bounds to preclude algebraic attacks.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.2 Polynomial Algorithms</h3>

    <p class="text-gray-300">This paper measures the time complexity of polynomial algorithms in terms of field operations. Without loss of generality, we also assume that the underlying finite fields support Fast Fourier Transforms (FFTs). Similarly, the memory complexity is estimated with regard to field elements.</p>

    <p class="text-gray-300">Polynomial Interpolation. Assume that <span class="math">f(x)\\in\\mathbb{F}_{q}[x]</span> has degree at most <span class="math">n</span>, where <span class="math">n</span> is a positive integer. Consider <span class="math">(n+1)</span> distinct points <span class="math">\\{(x_{0},y_{0}),(x_{1},y_{1}),</span> <span class="math">\\cdots,(x_{n},y_{n})\\}</span> where <span class="math">y_{i}=f(x_{i})</span> and <span class="math">x_{i}\\in\\mathbb{F}_{q}</span>. Then <span class="math">f(x)</span> is uniquely determined by the following Lagrange interpolation formula</p>

    <p class="text-gray-300"><span class="math">f(x)\\;=\\;\\sum_{i=0}^{n}\\;y_{i}\\cdot\\prod_{0\\leq j\\leq n,j\\neq i}\\frac{x-x_{j}}{x_{i}-x_{j}}\\,.</span> (5)</p>

    <p class="text-gray-300">It has been shown in <em>[26, 14]</em> that the Lagrange interpolation polynomial can be constructed with time and memory complexity <span class="math">O(n\\log(n))</span>.</p>

    <p class="text-gray-300">GCD Algorithms. Given two polynomials of degree <span class="math">n</span> with coefficients from <span class="math">\\mathbb{F}_{q}</span>, the straightforward Euclidean Algorithm computes the Greatest Common Divisor (GCD) with <span class="math">O(n^{2})</span> field operations. The Fast Euclidean Algorithm computes the same GCD in <span class="math">O(M(n)\\log(n))</span> field operations, where <span class="math">M(n)</span> is the time to multiply two <span class="math">n</span>-degree polynomials <em>[14]</em>. In this paper, we take <span class="math">M(n)=O(n\\log(n))</span>. Hence, the time complexity of the GCD algorithm is <span class="math">O(n\\log^{2}(n))</span>, which is exactly the estimate used by the MiMC designers <em>[3]</em>.</p>

    <h2 id="sec-9" class="text-2xl font-bold">3 Low-Memory Interpolation Attacks</h2>

    <p class="text-gray-300">This section presents novel interpolation attacks on primitives with low algebraic degree. Compared with classical interpolation attacks, our new attacks have very low memory complexities. Before giving our attacks, we first recall the classical interpolation attacks.</p>

    <p class="text-gray-300">3.1 Interpolation Attacks</p>

    <p class="text-gray-300">Interpolation attacks were introduced by Jakobsen and Knudsen <em>[16, 17]</em>: one considers the (intermediate) ciphertext as a polynomial of plaintext. With sufficiently many plaintext/ciphertext pairs, one can reconstruct this polynomial. Since the polynomial is key-dependent, it is possible to recover some round keys by employing a guess-and-determine strategy.</p>

    <p class="text-gray-300">Assume that a block cipher <span class="math">E</span> has <span class="math">r</span> rounds. First, one finds an upper bound <span class="math">N</span> on the degree of the intermediate ciphertext after <span class="math">(r-1)</span> rounds, denoted with <span class="math">y^{r-1}</span>. Next one guesses the last round key and obtains the corresponding value of <span class="math">y^{r-1}</span>. With <span class="math">(N+1)</span> distinct plaintext/ciphertext pairs, one can construct the polynomial representation of <span class="math">y^{r-1}</span> by Lagrange interpolation. Afterwards, the key guess can be confirmed with an additional plaintext/ciphertext pair. Specifically, one decrypts the last round and evaluates the polynomial in the corresponding plaintext. Then the key guess is considered as a valid key candidate if the decrypted and evaluated values match. Otherwise, the key guess is eliminated and we repeat the process until the correct key is found.</p>

    <p class="text-gray-300">Let <span class="math">L</span> denote the number of all possible last round keys of the cipher <span class="math">E</span>. Then the above attack has time complexity <span class="math">O(N\\log(N)\\cdot L)</span>, memory complexity <span class="math">O(N)</span> and data complexity <span class="math">N+2</span>.</p>

    <p class="text-gray-300">The meet-in-the-middle (MITM) approach has also been introduced in <em>[16]</em>. One considers <span class="math">h(x)</span> and <span class="math">g(y)</span> as two polynomials describing the same intermediate state, where <span class="math">x</span> and <span class="math">y</span> denote the plaintext and ciphertext respectively, hence <span class="math">h(x)=g(y)</span>. If one substitutes the values of <span class="math">x</span> and <span class="math">y</span>, this yields a linear equation in the unknown coefficients of <span class="math">h</span> and <span class="math">g</span>. By collecting a sufficient number of plaintext/ciphertext pairs, one can solve the linear system to recover these coefficients. Then one can mount a key recovery attack with a similar guess-and-determine strategy as in the original interpolation attack. The only difference is that here we test the key guess by checking if the plaintext/ciphertext pair satisfies the equation <span class="math">h(x)=g(y)</span>.</p>

    <p class="text-gray-300">If both the encryption and decryption round functions have low degree, the MITM attack can cryptanalyze more rounds than the original interpolation attack. Let <span class="math">\\deg(h)=N_{1}</span> and <span class="math">\\deg(g)=N_{2}</span>. Then one needs to establish <span class="math">O(N_{1}+N_{2}+2)</span> linear equations with <span class="math">O(N_{1}+N_{2}+2)</span> data and solve these for each key guess. The time and memory complexities are <span class="math">O((N_{1}+N_{2}+2)^{2}\\cdot L)</span> and <span class="math">O((N_{1}+N_{2}+2)^{3})</span> respectively, where <span class="math">L</span> is the number of last round keys.</p>

    <p class="text-gray-300">We briefly discuss the impact of the MITM attack on different constructions. For any permutation polynomial <span class="math">g(x)\\in\\mathbb{F}_{q}[x]</span> with <span class="math">\\deg(g)&gt;1</span>, let <span class="math">g^{-1}(x)</span> be the (compositional) inverse of <span class="math">g(x)</span>, then</p>

    <p class="text-gray-300"><span class="math">g^{-1}(g(x))\\equiv x\\pmod{x^{q}-x}\\,.</span></p>

    <p class="text-gray-300">Hence we have <span class="math">\\deg(g)\\cdot\\deg(g^{-1})\\geq q</span>. Note that we always assume that <span class="math">\\deg(g)</span> is small, so <span class="math">\\deg(g^{-1})</span> can be quite large, i.e., close to <span class="math">q</span>. Thus, for <span class="math">\\mathrm{KA}[q,\\kappa,d,r]</span>, there is no benefit to consider the MITM attacks. However, for Feistel networks, we need to take the MITM attack into account since the inverse of the round function has the same degree as the original one.</p>

    <p class="text-gray-300">3.2 Leading Terms of the Output</p>

    <p class="text-gray-300">We present some results on the leading terms, i.e. , terms with the highest and the second highest degrees, of the output of KA and FN ciphers. These results will be used in the sequel.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Proposition 1.</h6>

    <p class="text-gray-300">Let <span class="math">f(x)=x^{d}+\\sum_{i=0}^{d-1}a_{i}x^{i}</span> be the round function of KA<span class="math">[q,\\kappa,d,r]</span>, where <span class="math">d</span> is a positive integer with <span class="math">d&gt;1</span> and <span class="math">a_{i}\\in\\mathbb{F}_{q}</span> . If <span class="math">r\\leq R(d,q)-1</span>, then for KA<span class="math">[q,\\kappa,d,r]</span>, we have that (i) the algebraic degree of the output is <span class="math">d^{r}</span>, and (ii) the leading terms of the output are <span class="math">x^{d^{r}}+(d_{p}^{r}\\cdot k_{0}+d_{p}^{r-1}\\cdot a_{d-1})x^{d^{r}-1}</span>, where <span class="math">d\\equiv d_{p}\\bmod p</span>, <span class="math">0\\leq d_{p}\\leq p-1</span> and <span class="math">p</span> is the characteristic of <span class="math">\\mathbb{F}_{q}</span> .</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The claim (i) is a direct corollary of (ii), so it suffices to prove (ii). We will show the result by induction on <span class="math">r</span>. If <span class="math">r=1</span>, then the output is <span class="math">f(x+k_{0})+k_{1}</span>. By the binomial theorem, the output can be written as</p>

    <p class="text-gray-300"><span class="math">x^{d}+d\\cdot k_{0}x^{d-1}+g_{1}(x)+a_{d-1}x^{d-1}+g_{2}(x)\\,,</span></p>

    <p class="text-gray-300">where <span class="math">\\deg(g_{1}+g_{2})\\leq d-2</span>. Hence the leading terms are</p>

    <p class="text-gray-300"><span class="math">x^{d}+(d_{p}\\cdot k_{0}+a_{d-1})x^{d-1}\\,.</span></p>

    <p class="text-gray-300">Assume that the claim holds for <span class="math">t-1</span>, where <span class="math">1\\leq t-1\\leq R(d,q)-2</span>. Then the leading terms of the output of round <span class="math">t-1</span> are</p>

    <p class="text-gray-300"><span class="math">x^{d^{t-1}}+(d_{p}^{t-1}\\cdot k_{0}+d_{p}^{t-2}\\cdot a_{d-1})x^{d^{t-1}-1}\\,.</span></p>

    <p class="text-gray-300">Again, by the binomial theorem, the leading terms of the round <span class="math">t</span> output is</p>

    <p class="text-gray-300">\\[ \\begin{array}[]{l}\\left(x^{d^{t-1}}\\right)^{d}+d\\cdot\\left(x^{d^{t-1}}\\right)^{d-1}(d_{p}^{t-1}\\cdot k_{0}+d_{p}^{t-2}\\cdot a_{d-1})x^{d^{t-1}-1}\\\\ =x^{d^{t}}+\\left(d_{p}^{t}\\cdot k_{0}+d_{p}^{t-1}\\cdot a_{d-1}\\right)x^{d^{t}-1}\\,,\\end{array} \\]</p>

    <p class="text-gray-300">which implies that the claim is true for <span class="math">t</span>. Therefore, the claim holds for any <span class="math">r\\leq R(d,q)-1</span>. ∎</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For FN<span class="math">[q,\\kappa,d,r]</span>, we consider plaintexts of the form $x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C<span class="math">, where </span>C<span class="math"> is a constant in </span>\\mathbb{F}_{q}$ . As shown in the following proposition, we can achieve two more rounds compared with KA ciphers.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-12" class="text-base font-medium mt-4">Proposition 2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">f(x)=x^{d}+\\sum_{i=0}^{d-1}a_{i}x^{i}</span> be the round function of FN<span class="math">[q,\\kappa,d,r]</span>, where <span class="math">d</span> is a positive integer with <span class="math">d&gt;1</span> and <span class="math">a_{i}\\in\\mathbb{F}_{q}</span> . Consider plaintexts of the form $x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C<span class="math">, where </span>C<span class="math"> is a constant in </span>\\mathbb{F}_{q}<span class="math"> . If </span>3\\leq r\\leq R(d,q)+1<span class="math">, then the leading terms of the <em>right</em> part of the output are </span>x^{d^{r-2}}+(d_{p}^{r-2}\\cdot(k_{1}+f(C+k_{0}))+d_{p}^{r-3}\\cdot a_{d-1})x^{d^{r-2}-1}<span class="math">, where </span>d\\equiv d_{p}\\bmod p<span class="math">, </span>0\\leq d_{p}\\leq p-1<span class="math"> and </span>p<span class="math"> is the characteristic of </span>\\mathbb{F}_{q}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Proof.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The output of the first round is $C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(x+f(C+k_{0}))<span class="math">. This leads to the output </span>(x+f(C+k_{0}))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(f(x+k_{1}+f(C+k_{0}))+C)<span class="math"> after the second round and output </span>(f(x+k_{1}+f(C+k_{0}))+C)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(x+f(C+k_{0})+f(f(x+k_{1}+f(C+k_{0}))+C+k_{2}))$ after the third round. Then similarly to Proposition 1, one can prove that the leading terms of the right part of the output are</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">x^{d^{r-2}}+(d^{r-2}_{p}\\cdot(k_{1}+f(C+k_{0}))+d^{r-3}_{p}\\cdot a_{d-1})x^{d^{r-2}-1}</span></p>

    <p class="text-gray-300">when <span class="math">3\\leq r\\leq R(d,q)+1</span>. ∎</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Remark 1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that the special case <span class="math">p=2</span>, <span class="math">d</span> odd and $P=x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C<span class="math"> or </span>C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x$ has been described by Sun <em>et al.</em> <em>[27]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.3 New Attacks</h3>

    <p class="text-gray-300">One of the bottlenecks of classical interpolation attacks is that the attacker always needs to store the whole interpolated polynomial. Thus, the memory complexity can be very high if the degree of the polynomial is high. Based on the result in Sect. 3.2, for certain KA and FN ciphers, the key can be deduced from the second highest term of the interpolated polynomial. Hence, to recover the key, we only need to store the coefficient of the specific term rather than the whole polynomial. In this way, we can present our new interpolation attack with constant memory complexity.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Interpolating One Coefficient.</h4>

    <p class="text-gray-300">Now we present the algorithm for recovering the coefficient of the second highest term of the interpolated polynomial.</p>

    <p class="text-gray-300">Assume that <span class="math">g(x)\\in\\mathbb{F}_{q}[x]</span> has degree at most <span class="math">\\Delta</span>. Also assume that we know <span class="math">(\\Delta+1)</span> points <span class="math">\\{(x_{0},y_{0}),(x_{1},y_{1}),\\cdots,(x_{\\Delta},y_{\\Delta})\\}</span>, where <span class="math">x_{i}=\\alpha^{i}</span> for some primitive element <span class="math">\\alpha\\in\\mathbb{F}_{q}</span> and <span class="math">y_{i}=g(x_{i})</span>. Then by the Lagrange interpolation formula, <span class="math">g(x)</span> is uniquely determined by the formula</p>

    <p class="text-gray-300"><span class="math">g(x)\\;=\\;\\sum_{i=0}^{\\Delta}\\;g(\\alpha^{i})\\cdot\\prod_{0\\leq j\\leq\\Delta,j\\neq i}\\frac{x-\\alpha^{j}}{\\alpha^{i}-\\alpha^{j}}\\,.</span></p>

    <p class="text-gray-300">Let <span class="math">g(x)=\\sum_{i=0}^{\\Delta}a_{i}x^{i}</span>, then the coefficient of the second highest term is equal to</p>

    <p class="text-gray-300"><span class="math">a_{\\Delta-1}\\;=\\;\\sum_{i=0}^{\\Delta}\\;\\frac{-g(\\alpha^{i})\\cdot\\sum\\limits_{0\\leq j\\leq\\Delta,j\\neq i}\\alpha^{j}}{\\prod\\limits_{0\\leq j\\leq\\Delta,j\\neq i}(\\alpha^{i}-\\alpha^{j})}\\;=\\;\\sum_{i=0}^{\\Delta}\\;g(\\alpha^{i})\\frac{\\beta_{i}}{\\gamma_{i}}\\,,</span> (6)</p>

    <p class="text-gray-300">where <span class="math">\\gamma_{i}=\\prod_{0\\leq j\\leq\\Delta,j\\neq i}(\\alpha^{i}-\\alpha^{j})</span> and <span class="math">\\beta_{i}=-\\sum_{0\\leq j\\leq\\Delta,j\\neq i}\\alpha^{j}</span>. Note that</p>

    <p class="text-gray-300"><span class="math">\\gamma_{i+1}=\\gamma_{i}\\cdot\\alpha^{\\Delta}\\cdot\\frac{\\alpha^{i}-\\alpha^{-1}}{\\alpha^{i}-\\alpha^{\\Delta}}\\;\\text{ and }\\;\\beta_{i}=\\alpha^{i}-\\sum_{0\\leq j\\leq\\Delta}\\alpha^{j}\\,.</span></p>

    <p class="text-gray-300">By combining these observations, we present the procedure for recovering only the coefficient of the second highest term in Algorithm 1.</p>

    <p class="text-gray-300">Proposition 3 describes the complexity of Algorithm 1.</p>

    <p class="text-gray-300">Algorithm 1 Recover the coefficient of the second highest term 0: The algebraic degree <span class="math">\\Delta</span> of the polynomial, a primitive element <span class="math">\\alpha\\in\\mathbb{F}_{q}</span> , and the polynomial evaluation oracle <span class="math">\\mathcal{O}</span> 0: The coefficient <span class="math">t</span> of the second highest term 1: <span class="math">t\\leftarrow 0</span> 2: <span class="math">s\\leftarrow-\\sum_{j=0}^{\\Delta}\\alpha^{j}</span> 3: <span class="math">a\\leftarrow\\prod_{j=1}^{\\Delta}(1-\\alpha^{j})</span> 4: <span class="math">b\\leftarrow 1</span> 5: for <span class="math">i</span> from <span class="math">0</span> to <span class="math">\\Delta</span> do 6: <span class="math">t\\leftarrow t+\\mathcal{O}(b)\\cdot\\frac{s+b}{a}</span> 7: if <span class="math">i&lt;\\Delta</span> then 8: <span class="math">a\\leftarrow a\\cdot\\alpha^{\\Delta}\\cdot\\frac{b-\\alpha^{-1}}{b-\\alpha^{\\Delta}}</span> 9: <span class="math">b\\leftarrow b\\cdot\\alpha</span> 10: end if 11: end for 12: return <span class="math">t</span></p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Proposition 3.</h6>

    <p class="text-gray-300">Algorithm 1 has time complexity <span class="math">O(\\Delta\\log(\\Delta))</span> and memory complexity <span class="math">O(1)</span>.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The time complexity of Algorithm 1 is exactly the time complexity of interpolating one coefficient in Lagrange interpolation, which is shown to be <span class="math">O(\\Delta\\log(\\Delta))</span> in <em>[26]</em>. Due to the simplicity of the algorithm, one can immediately obtain that the memory complexity is <span class="math">O(1)</span>. ∎</p>

    <p class="text-gray-300">New Attacks on KA. Assume that <span class="math">d_{p}\\neq 0</span> and <span class="math">r\\leq R(d,q)-1</span>. Then the attack on <span class="math">\\mathrm{KA}[q,\\kappa,d,r]</span> is described below.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\Delta=d^{r}</span>. Choose a primitive element <span class="math">\\alpha\\in\\mathbb{F}_{q}</span> , and the encryption oracle <span class="math">\\mathcal{E}</span> as input to Algorithm 1.</li>

      <li>Run Algorithm 1. Let <span class="math">t</span> be the output.</li>

      <li>By Proposition 1, we have <span class="math">t=d^{r}_{p}\\cdot k_{0}+d^{r-1}_{p}\\cdot a_{d-1}</span>. Therefore, <span class="math">k_{0}</span> can be determined from</li>

    </ol>

    <p class="text-gray-300"><span class="math">k_{0}=\\frac{t-d^{r-1}_{p}\\cdot a_{d-1}}{d^{r}_{p}}\\,.</span></p>

    <p class="text-gray-300">In the above attack, we need to query the encryption oracle <span class="math">d^{r}+1</span> times. The time and memory complexity are dominated by Algorithm 1, which is <span class="math">O(rd^{r})</span> and <span class="math">O(1)</span> respectively according to Proposition 3. In summary, the time/memory/data complexities of the attack on <span class="math">\\mathrm{KA}[q,\\kappa,d,r]</span> are as follows:</p>

    <p class="text-gray-300"><span class="math">T=O(rd^{r}),M=O(1),D=d^{r}+1\\,.</span> (7)</p>

    <p class="text-gray-300">New Attacks on FN. Assume that <span class="math">d_{p}\\neq 0</span> and <span class="math">3\\leq r\\leq R(d,q)+1</span>. For <span class="math">r\\leq R(d,q)+1</span>, the attack on <span class="math">\\mathrm{FN}[q,\\kappa,d,r]</span> is shown below:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Let <span class="math">\\Delta=d^{r-2}</span> and <span class="math">C_{0}</span> be a constant in <span class="math">\\mathbb{F}_{q}\\,</span>. Take a primitive element <span class="math">\\alpha\\in\\mathbb{F}_{q}\\,</span>, and the FN encryption oracle <span class="math">\\mathcal{E}</span> as input to Algorithm 1. Note that the input of <span class="math">\\mathcal{E}</span> is of the form $\\alpha^{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{0}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run Algorithm 1. Let <span class="math">t</span> be the output.</li>

      <li>By Proposition 1, we have <span class="math">t=d^{r-2}_{p}\\cdot(k_{1}+f(C+k_{0}))+d^{r-3}_{p}\\cdot a_{d-1}</span>.</li>

      <li>Pick two other distinct constants <span class="math">C_{1}</span> and <span class="math">C_{2}</span>. Repeat Steps 1-3, assume that the results are <span class="math">t_{1}</span> and <span class="math">t_{2}</span> respectively. Now we have the system of equations with unknowns <span class="math">k_{0}</span> and <span class="math">k_{1}</span>:</li>

    </ol>

    <p class="text-gray-300">\\[ \\left\\{&t_{0}=d^{r-2}_{p}\\cdot(k_{1}+f(C_{0}+k_{0}))+d^{r-3}_{p}\\cdot a_{d-1}\\,,\\\\ &t_{1}=d^{r-2}_{p}\\cdot(k_{1}+f(C_{1}+k_{0}))+d^{r-3}_{p}\\cdot a_{d-1}\\,,\\\\ &t_{2}=d^{r-2}_{p}\\cdot(k_{1}+f(C_{2}+k_{0}))+d^{r-3}_{p}\\cdot a_{d-1}\\,.\\right. \\] (8)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>From Eqn. (8), we obtain</li>

    </ol>

    <p class="text-gray-300"><span class="math">f(C_{i}+k_{0})-f(C_{j}+k_{0})-\\frac{t_{i}-t_{j}}{d^{r-2}_{p}}=0\\,,</span></p>

    <p class="text-gray-300">where <span class="math">0\\leq i&lt;j\\leq 2</span>. Then <span class="math">k_{0}</span> can be determined by computing the GCD of the three polynomials of <span class="math">k_{0}</span>. Finally, one can obtain</p>

    <p class="text-gray-300"><span class="math">k_{1}=\\frac{t_{0}-d^{r-3}_{p}\\cdot a_{d-1}}{d^{r-2}_{p}}-f(C_{0}+k_{0})\\,.</span></p>

    <p class="text-gray-300">Note that <span class="math">f(x)</span> is assumed to have low degree in this paper. Thus, the complexity of Step 5 is negligible. Then similarly to the analysis of attacks on KA ciphers, the complexity of the above attack on FN<span class="math">[q,\\kappa,d,r]</span> is:</p>

    <p class="text-gray-300"><span class="math">T=O(rd^{r-2}),M=O(1),D=d^{r-2}+1\\,.</span></p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Discussion.</h4>

    <p class="text-gray-300">It is worth pointing out that our new attacks are chosen-plaintext attacks since we need to choose plaintexts of a specific form in Algorithm 1. As classical interpolation attacks are known-plaintext attacks, the low-memory interpolation attacks requires a stronger attack model.</p>

    <p class="text-gray-300">Note that Sun et al. in <em>[27]</em> also present a low-memory higher-order integral attack which applies to both KA and FN ciphers. However, their attack needs to know the values of the interpolated polynomials over all elements in <span class="math">\\mathbb{F}_{q}\\,</span>. That is, their attack has data complexity <span class="math">q</span>. Under our assumption, we always have <span class="math">d^{r}+1\\leq q</span>. Hence, our attack has smaller data complexity than the higher-order integral attack in <em>[27]</em>.</p>

    <p class="text-gray-300">An interesting research direction is to break the barrier of the assumption, i.e., determine some key-dependent terms even with <span class="math">r&gt;R(d,q)+1</span>.</p>

    <h2 id="sec-19" class="text-2xl font-bold">4 Attacks on Block Ciphers with Simple Key Schedules</h2>

    <p class="text-gray-300">This section proposes attacks on block ciphers with simple key schedules. The first type of attacks are direction applications of the low-memory attack proposed</p>

    <p class="text-gray-300">in Sect. 3. The second class of attacks are based on the same strategy and are divided into two groups in terms of memory and data complexities.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We consider ciphers with key space size <span class="math">\\kappa=q^{\\ell}</span>, i.e., <span class="math">\\mathrm{KA}[q,q^{\\ell},d,r]</span> and <span class="math">\\mathrm{FN}[q,q^{\\ell},d,r]</span>, where <span class="math">2\\leq\\ell\\leq r+1</span>. In this section, we assume a simple key schedule. The master key is $k_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{\\ell-1}<span class="math"> and the </span>i<span class="math">-th round key is </span>k_{i\\bmod\\ell}+c_{i}<span class="math">, i.e., the </span>i$-th round function is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">F_{i}(x):=F(x+k_{i\\bmod\\ell}+c_{i}),\\ 0\\leq i\\leq r\\,,</span></p>

    <p class="text-gray-300">where <span class="math">F</span> has the form as in (4) and the <span class="math">c_{i}</span>’s are independently chosen constants.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">4.1 Iterative Low-Memory Interpolation Attacks</h3>

    <p class="text-gray-300">This section presents attacks on block ciphers with simple key schedules by iteratively applying the low-memory attack proposed in Sect. 3.</p>

    <p class="text-gray-300">Our attack is based on the observation that the low-memory interpolation attack is independent of the key schedule. Hence, one can recover the first subkey <span class="math">k_{0}</span> by the low-memory interpolation attack and then substitute the obtained subkey to peel off the first round. By repeating the process, the remaining subkeys can be determined, as illustrated in Algorithm 2. An interesting property of the attack is that the complexity of the whole attack is dominated by that of recovering the first subkey. Actually, the complexities of recovering the <span class="math">i</span>-th subkey <span class="math">k_{i}</span> are given by those of the low-memory interpolation attack on the <span class="math">(r-i)</span>-round reduced cipher. Thus, by the analysis in Sect. 3.3, the <span class="math">i</span>-th subkey <span class="math">k_{i}</span> can be determined with complexities:</p>

    <p class="text-gray-300"><span class="math">T_{i}=O(rd^{r-i}),M_{i}=O(1),D_{i}=d^{r-i}+1,\\ i=0,1,\\cdots,\\ell-1.</span></p>

    <p class="text-gray-300">Therefore, the total complexities of the full attack is dominated by those of recovering the subkey <span class="math">k_{0}</span>, i.e. ,</p>

    <p class="text-gray-300"><span class="math">T=O(rd^{r}),M=O(1),D=d^{r}+1\\,.</span></p>

    <p class="text-gray-300">Algorithm 2 Attacks on <span class="math">\\mathrm{KA}[q,q^{\\ell},d,r]</span> with <span class="math">r\\leq R(d,q)-1</span> and <span class="math">\\mathrm{FN}[q,q^{\\ell},d,r]</span> with <span class="math">r\\leq R(d,q)+1</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Recover <span class="math">k_{0}</span> by the low-memory interpolation attack in Sect. 3.3.</li>

      <li>Substitute <span class="math">k_{0}</span> in the cipher. Then repeat Step 1 to recover <span class="math">k_{1}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Repeat Step 2 until the master key $k_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{\\ell-1}$ is obtained.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now we elaborate the above attack for the cipher <span class="math">\\mathrm{KA}[q,q^{2},d,r]</span> with a simple key schedule. Assume that <span class="math">d_{p}\\neq 0</span> and <span class="math">r\\leq R(d,q)-1</span>. Then the attack is described below.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\Delta=d^{r}</span>. Choose a primitive element <span class="math">\\alpha\\in\\mathbb{F}_{q}\\,</span>, and the encryption oracle <span class="math">\\mathcal{E}</span> as input to Algorithm 1.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run Algorithm 1. Let <span class="math">t</span> be the output.</li>

      <li>By Proposition 1, we have <span class="math">t=d_{p}^{r}\\cdot k_{0}+d_{p}^{r-1}\\cdot a_{d-1}</span>. Therefore, <span class="math">k_{0}</span> can be determined from</li>

    </ol>

    <p class="text-gray-300"><span class="math">k_{0}=\\frac{t-d_{p}^{r-1}\\cdot a_{d-1}}{d_{p}^{r}}\\,.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Substitute <span class="math">k_{0}</span> in the cipher. Then repeat Steps 1-3 with the minor change that <span class="math">\\Delta=d^{r-1}</span>. Finally, <span class="math">k_{1}</span> can be recovered.</li>

    </ol>

    <p class="text-gray-300">Similar to the discussion in Sect. 3.3, it is readily seen that the time/memory/data complexities of the attack on <span class="math">\\mathrm{KA}[q,q^{2},d,r]</span> are as follows:</p>

    <p class="text-gray-300"><span class="math">T=O(rd^{r}),M=O(1),D=d^{r}+1\\,.</span></p>

    <p class="text-gray-300">The following proposition summarize the results in this section.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Proposition 4.</h6>

    <p class="text-gray-300">Assume that <span class="math">r\\leq R(d,q)-1</span> for <span class="math">\\text{KA}[q,q^{\\ell},d,r]</span> and <span class="math">r\\leq R(d,q)+1</span> for <span class="math">\\text{FN}[q,q^{\\ell},d,r]</span>. Then there exists an attack on <span class="math">\\text{KA}[q,q^{\\ell},d,r]</span> with time complexity <span class="math">O(rd^{r})</span>, memory complexity <span class="math">O(1)</span>, and data complexity <span class="math">d^{r}+1</span> while there exists an attack on <span class="math">\\text{FN}[q,q^{\\ell},d,r]</span>, with time complexity <span class="math">O(rd^{r-2})</span>, memory complexity <span class="math">O(1)</span>, and data complexity <span class="math">d^{r-2}+1</span>.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">4.2 Attacks based on Guess-and-Determine Strategies</h3>

    <p class="text-gray-300">This section explores the guess-and-determine strategies in the analysis of block ciphers with simple key schedules. We propose a generic attack and then implement the attack with existing techniques.</p>

    <p class="text-gray-300">Based on a guess-and-determine strategy, a generic attack on <span class="math">\\text{KA}[q,q^{\\ell},d,r]</span> and <span class="math">\\text{FN}[q,q^{\\ell},d,r]</span> is presented in Algorithm 3. The main idea is that after guessing <span class="math">(\\ell-1)</span> subkeys <span class="math">k_{0},k_{1},\\cdots,k_{\\ell-2}</span>, we can skip the first <span class="math">(\\ell-1)</span> rounds. If the last round key is not <span class="math">k_{\\ell-1}</span>, by decrypting with the guessed subkeys we can also skip several final rounds until we hit <span class="math">k_{\\ell-1}</span>. As a result, we only need to consider <span class="math">R_{\\texttt{KA}}(r,\\ell)</span> and <span class="math">R_{\\texttt{FN}}(r,\\ell)</span> rounds for <span class="math">\\text{KA}[q,q^{\\ell},d,r]</span> and <span class="math">\\text{FN}[q,q^{\\ell},d,r]</span> respectively, where</p>

    <p class="text-gray-300"><span class="math">R_{\\texttt{KA}}(r,\\ell)=\\left(\\left\\lfloor\\frac{r+1}{\\ell}\\right\\rfloor-1\\right)\\ell\\ \\ \\text{and}\\ \\ R_{\\texttt{FN}}(r,\\ell)=1+\\left(\\left\\lfloor\\frac{r}{\\ell}\\right\\rfloor-1\\right)\\ell\\,.</span> (9)</p>

    <p class="text-gray-300">Moreover, the reduced cipher can be regarded as a reduced-round cipher by replacing some key additions with constant additions. This fact allows us to extend the attack on the single key version to large key versions. The above observation has been summarized in the following.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proposition 5.</h6>

    <p class="text-gray-300">Assume that there is an attack on <span class="math">\\text{KA}[q,q,d,r]</span> or <span class="math">\\text{FN}[q,q,d,r]</span> with time complexity <span class="math">T(r)</span>, memory complexity <span class="math">M(r)</span>, and data complexity <span class="math">D(r)</span>. Then there exists an attack on <span class="math">\\text{KA}[q,q^{\\ell},d,r]</span> or <span class="math">\\text{FN}[q,q^{\\ell},d,r]</span> with time complexity <span class="math">T(R_{\\lambda}(r,\\ell))q^{\\ell-1}</span>, memory complexity <span class="math">M(R_{\\lambda}(r,\\ell))</span>, and data complexity <span class="math">D(R_{\\lambda}(r,\\ell))</span>, where <span class="math">\\lambda\\in\\{\\texttt{KA},\\texttt{FN}\\}</span>.</p>

    <p class="text-gray-300">We will implement Algorithm 3 with low-memory interpolation and GCD attacks.</p>

    <p class="text-gray-300">Algorithm 3 Generic attacks on <span class="math">\\mathrm{KA}[q,q^{\\ell},d,r]</span> and <span class="math">\\mathrm{FN}[q,q^{\\ell},d,r]</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Guess subkeys <span class="math">k_{0},k_{1},\\cdots,k_{\\ell-2}</span>.</li>

      <li>Mount a key recovery attack on the reduced cipher with <span class="math">k_{\\ell-1}</span> the only unknown key. If it fails to recover the remaining <span class="math">k_{\\ell-1}</span>, then go back to Step 1. Otherwise, one obtains a candidate <span class="math">k^{*}_{\\ell-1}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Test the candidate master key $k_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k^{*}_{\\ell-1}<span class="math"> with an additional random plaintext/ciphertext pair. If the test is passed, then </span>k_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k^{*}_{\\ell-1}$ is the right key. Otherwise, repeat Steps 1-3 until right keys are found.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Low-Memory Interpolation Attacks Note that the attack in Sect. 3.3 can be directly applied to the reduced ciphers of <span class="math">\\mathrm{KA}[q,q^{\\ell},d,r]</span> and <span class="math">\\mathrm{FN}[q,q^{\\ell},d,r]</span>. Then by Proposition 5, we have the following result.</p>

    <p class="text-gray-300">Proposition 6. Assume that <span class="math">r \\leq R(d, q) + \\ell - 2</span> for <span class="math">\\mathrm{KA}[q, q^{\\ell}, d, r]</span> and <span class="math">r \\leq R(d, q) + \\ell</span> for <span class="math">\\mathrm{FN}[q, q^{\\ell}, d, r]</span>. There exists an attack on <span class="math">\\mathrm{KA}[q, q^{\\ell}, d, r]</span> with time complexity <span class="math">O(R_{\\mathcal{E}\\ell}(r, \\ell)d^{R_{\\mathcal{E}\\ell}(r, \\ell)}q^{\\ell - 1})</span>, memory complexity <span class="math">O(1)</span>, and data complexity <span class="math">d^{R_{\\mathcal{E}\\ell}(r, \\ell)} + 1</span> and there exists an attack on <span class="math">\\mathrm{FN}[q, q^{\\ell}, d, r]</span>, with time complexity <span class="math">O(R_{\\mathcal{F}\\mathbb{F}}(r, \\ell)d^{R_{\\mathcal{F}\\mathbb{F}}(r, \\ell) - 2}q^{\\ell - 1})</span>, memory complexity <span class="math">O(1)</span>, and data complexity <span class="math">d^{R_{\\mathcal{F}\\mathbb{F}}(r, \\ell) - 2} + 1</span>.</p>

    <p class="text-gray-300">To illustrate the main procedure, we present an attack on <span class="math">\\mathrm{KA}[q,q^2,d,r]</span>. Assume that <span class="math">d_p\\neq 0,r\\leq R(d,q)</span> and <span class="math">r\\equiv 0</span> (mod 2). Then the attack is given below.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Guess subkey <span class="math">k_{0}</span>.</li>

      <li>Let <span class="math">\\Delta = d^{r - 2}</span>. Choose a primitive element <span class="math">\\alpha \\in \\mathbb{F}_q</span>, and the encryption oracle <span class="math">\\mathcal{E}</span> as input to Algorithm 1.</li>

      <li>In Line 6 of Algorithm 1, the oracle returns <span class="math">F^{-1}\\big(\\mathcal{E}(F^{-1}(b) + k_0 + c_0) + k_0 + c_r\\big)</span>, where <span class="math">F^{-1}</span> is the compositional inverse of <span class="math">F</span>. Thus, Algorithm 1 returns the coefficient of the second highest term of the polynomial representing the last <span class="math">(r - 2)</span> rounds of the cipher. Run Algorithm 1.</li>

      <li>Let <span class="math">t</span> be the output of Algorithm 1. By Proposition 1, we have <span class="math">t = d_p^{r-2} \\cdot k_1 + d_p^{r-3} \\cdot a_{d-1}</span>, where the notation is from Proposition 1. Therefore, <span class="math">k_1^s</span> can be determined from <span class="math">k_1^s = (t - d_p^{r-3} \\cdot a_{d-1}) / d_p^{r-2}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5. Test the candidate master key $k_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_1^*<span class="math">. If the test is passed, then </span>k_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_1^*$ is the right key. Otherwise, repeat Steps 1-5 until the right keys are found.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Step 1 needs <span class="math">q</span> guesses in the worst case; for each guess we execute Steps 2-4, that correspond to a low-memory interpolation attack on an <span class="math">(r - 2)</span>-round reduced cipher. From Eqn. (7) the complexity of the above attack is given by</p>

    <div class="my-4 text-center"><span class="math-block">T = O (r d ^ {r - 2} q), M = O (1), D = d ^ {r - 2} + 1.</span></div>

    <p class="text-gray-300">GCD Attacks The GCD attack on MiMC was introduced by Albrecht et al. [3]: it deduces the key by computing the greatest common divisor of polynomials from known plaintext/ciphertext pairs. The GCD attack enjoys very low data</p>

    <p class="text-gray-300">15</p>

    <p class="text-gray-300">complexity, which makes it appropriate in a low-data scenario. It is straightforward to plug the attack into the framework of Algorithm 3. We will present GCD attacks on <span class="math">\\mathrm{KA}[q,q^{\\ell},d,r]</span> and <span class="math">\\mathrm{FN}[q,q^{\\ell},d,r]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Denote by <span class="math">E(x)</span> the encryption of plaintext <span class="math">x</span> under the key $k_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{\\ell-1}<span class="math">. The GCD attack on </span>\\mathrm{KA}[q,q^{\\ell},d,r]$ proceeds as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Guess subkey <span class="math">k_{0},k_{1},\\cdots,k_{\\ell-2}</span>.</li>

      <li>Denote by <span class="math">E(k_{\\ell-1},x)</span> the output of the <span class="math">R_{\\mathtt{KA}}(r,\\ell)</span>-round reduced cipher with input <span class="math">x</span>. For any two different plaintext/ciphertext pairs, one can obtain the corresponding input/output pairs <span class="math">(x_{i},y_{i})</span> for <span class="math">i=0,1</span>.</li>

      <li>Compute the univariate polynomial <span class="math">E(K,x_{i})-y_{i}</span> explicitly for <span class="math">i=0,1</span>. It is clear that these polynomials share <span class="math">K-k_{\\ell-1}</span> as a factor if the key guess is correct. Indeed, in this case with high probability <span class="math">\\gcd(E(K,x_{0})-y_{0},E(K,x_{1})-y_{1})=K-k_{\\ell-1}</span>.</li>

      <li>Compute <span class="math">\\gcd(E(K,x_{0})-y_{0},E(K,x_{1})-y_{1})</span>. If the result is 1 or has only irreducible factors with degree larger than two, then the key guess is wrong and we go back to Step 1. Otherwise, the constant part of the linear factors of the result are candidates for <span class="math">k_{\\ell-1}</span>, denoted by <span class="math">k^{*}_{\\ell-1}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5. Test the candidate master key $k_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k^{*}_{\\ell-1}<span class="math">. If the test is passed, then </span>k_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k^{*}_{\\ell-1}$ is the right key. Otherwise, repeat Steps 1-6 until the right keys are found.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As we show in Appendix A, Step 3 can be implemented with both time and memory complexities <span class="math">O(R_{\\mathtt{KA}}(r,\\ell)d^{R_{\\mathtt{KA}}(r,\\ell)})</span>. Note that both of the polynomials <span class="math">E(K,x_{0})-y_{0}</span> and <span class="math">E(K,x_{1})-y_{1}</span> have degree <span class="math">d^{R_{\\mathtt{KA}}(r,\\ell)}</span>. Then, by the estimation in Sect. 2.2, the complexity of computing greatest common divisors in Step 4 is <span class="math">O(R_{\\mathtt{KA}}(r,\\ell)^{2}d^{R_{\\mathtt{KA}}(r,\\ell)})</span>. Thus, the time complexity for each subkey guess is dominated by the computation of the greatest common divisor, i.e. , <span class="math">O(R_{\\mathtt{KA}}(r,\\ell)^{2}d^{R_{\\mathtt{KA}}(r,\\ell)})</span>. Therefore, the total time complexity of the above attack is <span class="math">O(R_{\\mathtt{KA}}(r,\\ell)^{2}d^{R_{\\mathtt{KA}}(r,\\ell)}q^{\\ell-1})</span>. Moreover, the memory consumption is around <span class="math">O(R_{\\mathtt{KA}}(r,\\ell)d^{R_{\\mathtt{KA}}(r,\\ell)})</span> since Step 3 dominates the memory complexity. Notably, we only need three plaintext/ciphertext pairs. To sum up, the time/memory/data complexities of the above attack are given by</p>

    <p class="text-gray-300"><span class="math">T=O(R_{\\mathtt{KA}}(r,\\ell)^{2}d^{R_{\\mathtt{KA}}(r,\\ell)}q^{\\ell-1}),M=O(R_{\\mathtt{KA}}(r,\\ell)d^{R_{\\mathtt{KA}}(r,\\ell)}),D=3\\,.</span></p>

    <p class="text-gray-300">With the MITM approach, one can mount an attack on <span class="math">\\mathrm{FN}[q,q^{\\ell},d,r]</span> with similar complexity but double the number of rounds attainable. Now we sketch the main idea by the attack on <span class="math">\\mathrm{FN}[q,q,d,r]</span>. First, we construct two polynomials <span class="math">G(K,x)</span> and <span class="math">H(K,y)</span> representing the state after round <span class="math">\\lceil r/2\\rceil</span> as a polynomial in the unknown key and the plaintext or ciphertext respectively. Then the key can be deduced by computing the greatest common divisor of two polynomials <span class="math">G(K,x_{0})-H(K,y_{0})</span> and <span class="math">G(K,x_{1})-H(K,y_{1})</span> whose degrees are upper bounded by <span class="math">d^{\\lfloor r/2\\rfloor}</span>. Hence, the time/memory/data complexities of the above attack are given by</p>

    <p class="text-gray-300"><span class="math">T=O(\\lfloor r/2\\rfloor^{2}d^{\\lfloor r/2\\rfloor}),M=O(\\lfloor r/2\\rfloor d^{\\lfloor r/2\\rfloor}),D=3\\,.</span></p>

    <p class="text-gray-300">We can generalize the above attack to FN<span class="math">[q,q^{\\ell},d,r]</span> with slight modifications. Note that we only need to consider the <span class="math">R_{\\textsf{FN}}(r,\\ell)</span>-round cipher after the subkey guessing. Next, we compute two polynomials <span class="math">G(K,x)</span> and <span class="math">H(K,y)</span> representing the state after round <span class="math">\\lceil R_{\\textsf{FN}}(r,\\ell)/2\\rceil</span> of the reduced cipher as a polynomial in the unknown <span class="math">k_{\\ell-1}</span> and the input or output of the reduced cipher respectively. Then consider the two polynomials <span class="math">G(K,x_{0})-H(K,y_{0})</span> and <span class="math">G(K,x_{1})-H(K,y_{1})</span>. The remaining steps of the GCD computation and key filtering are the same as in the case KA<span class="math">[q,q^{\\ell},d,r]</span>. Hence, we omit the details. Similar to the attack on FN<span class="math">[q,q,d,r]</span>, we have that the complexity of the attack on FN<span class="math">[q,q^{\\ell},d,r]</span> equals</p>

    <p class="text-gray-300"><span class="math">T=O(\\lfloor R_{\\textsf{FN}}(r,\\ell)/2\\rfloor^{2}d^{\\lfloor R_{\\textsf{FN}}(r,\\ell)/2\\rfloor}q^{\\ell-1}),M=O(\\lfloor R_{\\textsf{FN}}(r,\\ell)/2\\rfloor d^{\\lfloor R_{\\textsf{FN}}(r,\\ell)/2\\rfloor}),D=3\\,.</span></p>

    <p class="text-gray-300">In this way, with similar complexities one can double the number of rounds attainable compared with the GCD attack on KA<span class="math">[q,q^{\\ell},d,r]</span>.</p>

    <p class="text-gray-300">We summarize the discussion in the following result.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proposition 7.</h6>

    <p class="text-gray-300">There exists an attack on KA<span class="math">[q,q^{\\ell},d,r]</span> with time complexity <span class="math">O(R_{\\textsf{KA}}(r,\\ell)^{2}d^{R_{\\textsf{KA}}(r,\\ell)}q^{\\ell-1})</span>, memory complexity <span class="math">O(R_{\\textsf{KA}}(r,\\ell)d^{R_{\\textsf{KA}}(r,\\ell)})</span>, and data complexity <span class="math">3</span>, and there exists an attack on for FN<span class="math">[q,q^{\\ell},d,r]</span> with time complexity <span class="math">O(\\lfloor R_{\\textsf{FN}}(r,\\ell)/2\\rfloor^{2}d^{\\lfloor R_{\\textsf{FN}}(r,\\ell)/2\\rfloor}q^{\\ell-1})</span>, memory complexity <span class="math">O(\\lfloor R_{\\textsf{FN}}(r,\\ell)/2\\rfloor d^{\\lfloor R_{\\textsf{FN}}(r,\\ell)/2\\rfloor})</span>, and data complexity <span class="math">3</span>.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">GCD attacks enjoy very low data complexity while they suffer large memory complexity since one needs to compute and store the two polynomials. Thus, the low-memory interpolation attack and low data GCD attacks are not superior to each other.</p>

    <h2 id="sec-26" class="text-2xl font-bold">5 Applications to MiMC</h2>

    <p class="text-gray-300">In this section, we apply our new techniques to the block cipher MiMC. Using our new techniques, we can break a variant of MiMC with memory restriction on attacks and lower the attack complexity of the larger key versions.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">5.1 Description of MiMC</h3>

    <p class="text-gray-300">MiMC is a family of block cipher designs operating entirely over the finite field <span class="math">\\mathbb{F}_{q}</span> ; they can be seen as generalizations of the KN-cipher <em>[22]</em> and <span class="math">\\mathcal{PURE}</span> <em>[16]</em>. The design aims to achieve an efficient implementation over a field <span class="math">\\mathbb{F}_{q}</span> — especially the large prime field <span class="math">\\mathbb{F}_{p}</span> — by minimizing computationally expensive field operations, e.g. multiplications or exponentiations.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">MiMC-<span class="math">n/n</span>.</h4>

    <p class="text-gray-300">Let <span class="math">q</span> be a prime or power of <span class="math">2</span> such that <span class="math">\\gcd(3,q-1)=1</span>. For a message <span class="math">x\\in\\mathbb{F}_{q}</span> and a secret key <span class="math">k\\in\\mathbb{F}_{q}</span> , the encryption process of MiMC-<span class="math">n/n</span> is constructed by iterating a round function <span class="math">r</span> times. At round <span class="math">i</span>, the round function is defined as</p>

    <p class="text-gray-300"><span class="math">F_{i}(x):=(x+k+c_{i})^{3},</span></p>

    <p class="text-gray-300">where the <span class="math">c_{i}</span>’s are random constants in <span class="math">\\mathbb{F}_{q}</span> and <span class="math">c_{0}=c_{r}=0</span>. Then the encryption process is given by</p>

    <p class="text-gray-300"><span class="math">E_{k}(x)=(F_{r-1}\\circ F_{r-2}\\circ\\cdots\\circ F_{0})(x)+k\\,.</span></p>

    <p class="text-gray-300">The number of rounds is given by <span class="math">r=\\lceil\\frac{\\log_{2}(q)}{\\log_{2}(3)}\\rceil</span>.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">MiMC-<span class="math">2n/n</span>(<span class="math">Feistel</span>)</h4>

    <p class="text-gray-300">By employing the same permutation polynomial in FN, one can process larger blocks and have the same circuit for encryption and decryption. The round function of MiMC-<span class="math">2n/n</span> is defined by</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$x_{i}^{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{i}^{R}\\leftarrow x_{i-1}^{R}+(x_{i-1}^{L}+k+c_{i})^{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{i-1}^{L}\\,,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where the <span class="math">c_{i}</span>’s are random constants in <span class="math">\\mathbb{F}_{q}</span> and <span class="math">c_{0}=c_{r}=0</span>. The swap operation is not applied in the last round. The number of rounds is given by <span class="math">r^{\\prime}=2\\cdot\\lceil\\frac{\\log_{2}(q)}{\\log_{2}(3)}\\rceil</span>.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">5.2 Attacks on a Variant with Low Memory Complexity</h3>

    <p class="text-gray-300">This section presents an attack on an instantiation of MiMC where the memory available to the attacker is limited. Our results indicate that the number of rounds proposed by the designers is too optimistic.</p>

    <p class="text-gray-300">In <em>[3]</em>, the designers consider the case in which there is a restriction on the memory available to the attacker. In this setting, many memory-consuming attacks will be infeasible. According to the designers, this enables the reduction of the number of rounds to gain better performance. To be specific, the authors claim that this restriction has a great impact on interpolation attacks and GCD attacks. Indeed, the problem arises if the attacker is not able to store all the coefficients of the interpolation polynomial and similar for the GCD attack.</p>

    <p class="text-gray-300">For MiMC-129/129, the number of rounds is <span class="math">82=\\left\\lceil\\frac{129}{\\log_{2}(3)}\\right\\rceil</span> in the original design. A much more aggressive version with only 38 rounds is proposed under the assumption that the attacker is restricted to a memory of <span class="math">2^{64}</span> bytes.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">The Attack</h4>

    <p class="text-gray-300">We note that the 38-round MiMC-129/129 fits into the model of KA<span class="math">[2^{129},2^{129},3,38]</span>. Additionally, we have <span class="math">d_{p}=1</span> in this case. Then we can adapt the attack on KA<span class="math">[q,\\kappa,d,r]</span> to this concrete cipher. The attack is given below.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\Delta=3^{38}</span>. Choose a primitive element <span class="math">\\alpha\\in\\mathbb{F}_{2^{129}}</span>, and the encryption oracle 38-round MiMC-129/129 as input to Algorithm 1.</li>

      <li>Run Algorithm 1. Let <span class="math">t</span> be the output.</li>

      <li>By Proposition 1, we have <span class="math">k=t</span> since <span class="math">c_{0}=0,d_{p}=1</span> and <span class="math">a_{d-1}=0</span>.</li>

    </ol>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">Complexity Analysis</h4>

    <p class="text-gray-300">In this attack, we need to query the encryption oracle <span class="math">3^{38}+1</span> times, i.e, around <span class="math">2^{60.23}</span>. Actually, the time complexity is dominated by the running time of Algorithm 1, which is around <span class="math">38\\cdot(3^{38}+1)</span>, i.e., <span class="math">2^{65.48}</span>. The</p>

    <p class="text-gray-300">data complexity is also <span class="math">3^{38}+1</span>, i.e, around <span class="math">2^{60.23}</span>. Finally, as we can see, the memory complexity is negligible.</p>

    <p class="text-gray-300">Our low-memory interpolation attacks have the same time complexity as classical interpolation attack with negligible memory complexity. This implies that the number of round cannot be smaller than <span class="math">\\left\\lceil\\frac{\\log_{q}(q)}{\\log_{2}(3)}\\right\\rceil</span> even if there is a restriction on the memory available to the attacker.</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">Discussion</h4>

    <p class="text-gray-300">It is worth pointing out that neither of the classical interpolation attacks nor higher-order differential attacks work on MiMC-<span class="math">n/n</span>. In both attacks, one needs to guess the last round key which is exactly the master key of MiMC. This leads to an attack with complexity worse than exhaustive key search. By contrast, our low-memory interpolation attack does not need to guess any round key. Therefore, our attack is the first low-memory attack against MiMC.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">5.3 Attacks on Larger Key Versions</h3>

    <p class="text-gray-300">This section shows attacks on variants of MiMC with a larger key size. Our results indicate that the security margin is less than claimed by the designers.</p>

    <p class="text-gray-300">Instead of adding the same key in each round, a variant of MiMC is proposed with a key length that is equal to <span class="math">\\ell</span> times the block length. In this case, we cyclically add <span class="math">\\ell</span> independent keys. That is, at round <span class="math">i</span>, the round function is defined as</p>

    <p class="text-gray-300"><span class="math">F_{i}(x):=(x+k_{i\\bmod\\ell}+c_{i})^{3}\\,,</span></p>

    <p class="text-gray-300">where the <span class="math">c_{i}</span>’s are random constants in <span class="math">\\mathbb{F}_{q}</span> and <span class="math">c_{0}=c_{r}=0</span>.</p>

    <p class="text-gray-300">We note that the MiMC-<span class="math">n/n</span> and MiMC-<span class="math">2n/n</span> with larger key size fit into the model of KA<span class="math">[q,q^{\\ell},3,r]</span> and FN<span class="math">[q,q^{\\ell},3,r]</span> respectively. Then by Propositions 4, 6 and 7, we have the following results.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Proposition 8.</h6>

    <p class="text-gray-300">Let <span class="math">R_{\\textsf{KA}}(r,\\ell)</span> and <span class="math">R_{\\textsf{FN}}(r,\\ell)</span> be given as in Eqn. (9). (i) Assume that <span class="math">r\\leq\\lceil\\log_{3}(q-1)\\rceil-1</span> for KA<span class="math">[q,q^{\\ell},3,r]</span> and <span class="math">r\\leq\\lceil\\log_{3}(q-1)\\rceil+1</span> for FN<span class="math">[q,q^{\\ell},3,r]</span>. There exists an attack on <span class="math">r</span>-round MiMC-<span class="math">n/n</span> with key size <span class="math">\\ell n</span> having complexity <span class="math">T=O(r3^{r}),M=O(1),D=3^{r}+1</span>. While for MiMC-<span class="math">2n/n</span> with key size <span class="math">\\ell n</span>, there exists an attack with complexity <span class="math">T=O(r3^{r-2}),M=O(1),D=3^{r-2}+1</span>.</p>

    <p class="text-gray-300">(ii) Assume that <span class="math">r\\leq\\lceil\\log_{3}(q-1)\\rceil+\\ell-2</span> for KA<span class="math">[q,q^{\\ell},3,r]</span> and <span class="math">r\\leq\\lceil\\log_{3}(q-1)\\rceil+\\ell</span> for FN<span class="math">[q,q^{\\ell},3,r]</span>. There exists an attack on <span class="math">r</span>-round MiMC-<span class="math">n/n</span> with key size <span class="math">\\ell n</span> having complexity <span class="math">T=O(R_{\\textsf{KA}}(r,\\ell)3^{R_{\\textsf{KA}}(r,\\ell)}q^{\\ell-1}),M=O(1),D=3^{R_{\\textsf{KA}}(r,\\ell)}+1</span>. While for MiMC-<span class="math">2n/n</span> with key size <span class="math">\\ell n</span>, there exists an attack with complexity <span class="math">T=O(R_{\\textsf{FN}}(r,\\ell)3^{R_{\\textsf{FN}}(r,\\ell)-2}q^{\\ell-1}),\\,M=O(1),D=3^{R_{\\textsf{FN}}(r,\\ell)-2}+1</span>.</p>

    <p class="text-gray-300">(iii) There exists an attack on <span class="math">r</span>-round MiMC-<span class="math">n/n</span> having key size <span class="math">\\ell n</span> with complexity <span class="math">T=O(R_{\\textsf{KA}}(r,\\ell)^{2}3^{R_{\\textsf{KA}}(r,\\ell)}q^{\\ell-1}),M=O(R_{\\textsf{KA}}(r,\\ell)3^{R_{\\textsf{KA}}(r,\\ell)}),D=3</span>. While for <span class="math">r</span>-round MiMC-<span class="math">2n/n</span> having key size <span class="math">\\ell n</span>, there exists attacks with complexity <span class="math">T=O(\\lfloor R_{\\textsf{FN}}(r,\\ell)/2\\rfloor^{2}3^{\\lfloor R_{\\textsf{FN}}(r,\\ell)/2\\rfloor}q^{\\ell-1}),M=O(\\lfloor R_{\\textsf{FN}}(r,\\ell)/2\\rfloor 3^{\\lfloor R_{\\textsf{FN}}(r,\\ell)/2\\rfloor}),</span></p>

    <p class="text-gray-300">The designers of MiMC-<span class="math">n/n</span> analyze the case <span class="math">\\ell=2</span> <em>[3]</em>. By computing the Gröbner basis the time complexity equals <span class="math">O(4\\cdot 3^{3r})</span> while the resultant algorithms lead to a complexity of <span class="math">O(3^{4.69r})</span>. By Proposition 8 (i), our attacks have time complexity <span class="math">O(r3^{r})</span> if <span class="math">r\\leq\\lceil\\log_{3}(q-1)\\rceil-1</span>. While for <span class="math">r\\geq\\lceil\\log_{3}(q-1)\\rceil</span>, by Proposition 8 (ii), our attacks have asymptotic time complexity <span class="math">O(r3^{2r-1})</span>. Therefore, our analysis shows a smaller security margin of the MiMC-<span class="math">n/n</span> instance with larger key size.</p>

    <p class="text-gray-300">For MiMC-<span class="math">2n/n</span>, by Proposition 8 (i) and (iii), our attacks have time complexity <span class="math">O(r3^{r-2})</span> if <span class="math">r\\leq\\lceil\\log_{3}(q-1)\\rceil-1</span> and <span class="math">O(r^{2}3^{\\lfloor\\frac{3r-2}{r}\\rfloor-1})</span> if <span class="math">r\\geq\\lceil\\log_{3}(q-1)\\rceil</span>.</p>

    <p class="text-gray-300">The MiMC designers claimed that their security bounds <span class="math">O(4\\cdot 3^{3r})</span> and <span class="math">O(3^{4.69r})</span> can be improved by an MITM approach <em>[4, p. 18]</em>. However, there were no details on the claim. Our reduced bound is the first tighter bound which is derived from a specific attack.</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">5.4 Verification on MiMC over Small Fields</h3>

    <p class="text-gray-300">We have verified our attack experimentally. For instance, we have implemented the low-memory interpolation attack on 10-round MiMC-17/17. As a result, we can recover the key in 1.3 seconds with Sage.</p>

    <p class="text-gray-300">We have also implemented the GCD attacks on larger key versions. Take <span class="math">\\ell=2</span>, for finite fields with small size, one can recover the master key in practical time with Sage. For example, one can recover the key in less than one hour for 7-round MiMC-11/11.</p>

    <p class="text-gray-300">We have also carried out experiments to evaluate the behavior of the GCD value obtained after guessing certain round keys when the GCD attack is applied to the larger key version. Again we take <span class="math">\\ell=2</span>. The experiments are performed in fields <span class="math">\\mathbb{F}_{q}</span> with <span class="math">q\\leq 2^{17}</span>. We take random plaintext/ciphertext pairs to obtain the distribution of GCD values. Our experiments show the following results:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When the key guess <span class="math">k_{0}</span> is correct, we can always obtain the GCD value <span class="math">K-k_{1}</span>.</li>

      <li>When the key guess <span class="math">k_{0}</span> is wrong, mostly we get GCD value 1 hence we can eliminate the wrong key guess immediately. With small probability, say less than 1%, we can get nontrivial GCD values and even a linear factor <span class="math">K-a</span>. In this case, <span class="math">a</span> is considered as a valid candidate that can be filtered out with an additional test.</li>

    </ul>

    <p class="text-gray-300">The above observations support the settings of the attack described in Sect. 4.2.</p>

    <h2 id="sec-37" class="text-2xl font-bold">6 Concluding Remarks</h2>

    <p class="text-gray-300">This paper has shown that the memory requirements for classical interpolation attacks can be reduced substantially, resulting in practical attacks on primitives with low algebraic degrees. For a simple key schedule, we present generic attacks that have either constant memory or constant data complexity. To illustrate our techniques, we have applied the new attacks to the block cipher MiMC.</p>

    <p class="text-gray-300">As a result, we can break a round-reduced version of MiMC with low memory complexity and we can reduce the attack complexity of the larger key versions. However, our results do not affect the security claims of the full round MiMC. To the best of our knowledge, our analysis of MiMC is the first third-party cryptanalysis of MiMC.</p>

    <p class="text-gray-300">For future research, it is of interest to assess the security of MiMC with original key size, i.e., a single key addition in all rounds. It remains unclear if the approaches in this paper can be applied to the new proposal GMiMC. Moreover, it is an open problem to analyze the security of the MiMC-based hash function MiMCHash.</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">Acknowledgement.</h4>

    <p class="text-gray-300">The authors thank the anonymous reviewers for many helpful comments. The work is supported by the Research Council KU Leuven under the grant C16/15/058 and by the European Union’s Horizon 2020 research and innovation programme under grant agreement No. H2020-MSCA-ITN-2014-643161 ECRYPT-NET.</p>

    <h2 id="sec-39" class="text-2xl font-bold">Appendix A Algorithm for Computing <span class="math">\\bm{E(K,x_{i})}-y_{i}</span></h2>

    <p class="text-gray-300">This section describes the algorithm to obtain the explicit expression of <span class="math">E(K,x_{i})-y_{i}</span> which is used in Step 3 of the GCD attacks in Sect. 4.2. Recall that here <span class="math">K</span> is the variable and <span class="math">(x_{i},y_{i})</span> is an input/output pair corresponding to some plaintext/ciphertext pair.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Select <span class="math">d^{R_{\\mathsf{EA}}(r,\\ell)}+1</span> different values <span class="math">\\alpha_{0},\\cdots,\\alpha_{d^{R_{\\mathsf{EA}}(r,\\ell)}}\\in\\mathbb{F}_{q}</span> .</li>

      <li>Compute <span class="math">\\beta_{j}=E(\\alpha_{j},x_{i})-y_{i}</span> for <span class="math">i=0,1</span> and <span class="math">0\\leq j\\leq d^{R_{\\mathsf{EA}}(r,\\ell)}</span>.</li>

      <li>Interpolate the polynomial <span class="math">g_{i}(x)</span> such that <span class="math">g_{i}(\\alpha_{j})=\\beta_{j}</span> for <span class="math">i=0,1</span> and <span class="math">0\\leq j\\leq d^{R_{\\mathsf{EA}}(r,\\ell)}</span>.</li>

    </ol>

    <p class="text-gray-300">First observe that the iterative structure of <span class="math">E(K,x_{i})-y_{i}</span> enables us to evaluate <span class="math">E(\\alpha_{j},x_{i})-y_{i}</span> round by round. In each round one needs to evaluate a polynomial with constant degree, which can be done in constant time. Hence, each <span class="math">\\beta_{j}</span> is obtained with complexity only <span class="math">O(R_{\\mathsf{EA}}(r,\\ell))</span> though the degree is <span class="math">d^{R_{\\mathsf{EA}}(r,\\ell)}</span>. It follows that the second step has time complexity <span class="math">O(R_{\\mathsf{EA}}(r,\\ell)d^{R_{\\mathsf{EA}}(r,\\ell)})</span>. The third step is a standard polynomial interpolation with complexity <span class="math">O(R_{\\mathsf{EA}}(r,\\ell)d^{R_{\\mathsf{EA}}(r,\\ell)})</span>. Hence, the total time complexity is <span class="math">O(R_{\\mathsf{EA}}(r,\\ell)d^{R_{\\mathsf{EA}}(r,\\ell)})</span>. The memory complexities of the algorithm is <span class="math">O(R_{\\mathsf{EA}}(r,\\ell)d^{R_{\\mathsf{EA}}(r,\\ell)})</span> due to the polynomial interpolation in the third step <em>[14]</em>.</p>

    <h2 id="sec-40" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Albrecht, M.R., Cid, C., Grassi, L., Khovratovich, D., Lüftenegger, R., Rechberger, C., Schofnegger, M.: Algebraic cryptanalysis of STARK-friendly designs: Application to MARVELlous and MiMC. Cryptology ePrint Archive, Report 2019/419 (2019), https://eprint.iacr.org/2019/419</li>

    </ul>

    <p class="text-gray-300">2] Albrecht, M.R., Grassi, L., Perrin, L., Ramacher, S., Rechberger, C., Rotaru, D., Roy, A., Schofnegger, M.: Feistel structures for MPC, and more. Cryptology ePrint Archive, Report 2019/397 (2019), https://eprint.iacr.org/2019/397</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[3] Albrecht, M.R., Grassi, L., Rechberger, C., Roy, A., Tiessen, T.: MiMC: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. In: Advances in Cryptology - ASIACRYPT 2016 - 22nd International Conference on the Theory and Application of Cryptology and Information Security, Hanoi, Vietnam, December 4-8, 2016, Proceedings, Part I. pp. 191–219 (2016)</li>

      <li>[4] Albrecht, M.R., Grassi, L., Rechberger, C., Roy, A., Tiessen, T.: MiMC: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. Cryptology ePrint Archive, Report 2016/492 (2016), https://eprint.iacr.org/2016/492</li>

      <li>[5] Albrecht, M.R., Rechberger, C., Schneider, T., Tiessen, T., Zohner, M.: Ciphers for MPC and FHE. In: Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part I. pp. 430–454 (2015)</li>

      <li>[6] Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046 (2018), https://eprint.iacr.org/2018/046</li>

      <li>[7] Ben-Sasson, E., Chiesa, A., Genkin, D., Tromer, E., Virza, M.: SNARKs for C: verifying program executions succinctly and in zero knowledge. In: Advances in Cryptology - CRYPTO 2013 - 33rd Annual Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2013. Proceedings, Part II. pp. 90–108 (2013)</li>

      <li>[8] Canteaut, A., Carpov, S., Fontaine, C., Lepoint, T., Naya-Plasencia, M., Paillier, P., Sirdey, R.: Stream ciphers: A practical solution for efficient homomorphic-ciphertext compression. In: Fast Software Encryption - 23rd International Conference, FSE 2016, Bochum, Germany, March 20-23, 2016, Revised Selected Papers. pp. 313–333 (2016)</li>

      <li>[9] Daemen, J., Rijmen, V.: The Design of Rijndael: AES - The Advanced Encryption Standard. Information Security and Cryptography, Springer (2002)</li>

      <li>[10] Dinur, I., Liu, Y., Meier, W., Wang, Q.: Optimized interpolation attacks on LowMC. In: Advances in Cryptology - ASIACRYPT 2015 - 21st International Conference on the Theory and Application of Cryptology and Information Security, Auckland, New Zealand, November 29 - December 3, 2015, Proceedings, Part II. pp. 535–560 (2015)</li>

      <li>[11] Dinur, I., Shamir, A.: Cube attacks on tweakable black box polynomials. In: Advances in Cryptology - EUROCRYPT 2009, 28th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Cologne, Germany, April 26-30, 2009. Proceedings. pp. 278–299 (2009)</li>

      <li>[12] Dobraunig, C., Eichlseder, M., Grassi, L., Lallemand, V., Leander, G., List, E., Mendel, F., Rechberger, C.: Rasta: A cipher with low ANDdepth and few ANDs per bit. In: Advances in Cryptology - CRYPTO 2018 - 38th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 19-23, 2018, Proceedings, Part I. pp. 662–692 (2018)</li>

      <li>[13] Duval, S., Lallemand, V., Rotella, Y.: Cryptanalysis of the FLIP family of stream ciphers. In: Advances in Cryptology - CRYPTO 2016 - 36th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 14-18, 2016, Proceedings, Part I. pp. 457–475 (2016)</li>

      <li>[14] von zur Gathen, J., Gerhard, J.: Modern Computer Algebra (3. ed.). Cambridge University Press (2013)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[15] Grassi, L., Rechberger, C., Rotaru, D., Scholl, P., Smart, N.P.: MPC-friendly symmetric key primitives. In: Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, Vienna, Austria, October 24-28, 2016. pp. 430–443 (2016)</li>

      <li>[16] Jakobsen, T., Knudsen, L.R.: The interpolation attack on block ciphers. In: Fast Software Encryption, 4th International Workshop, FSE ’97, Haifa, Israel, January 20-22, 1997, Proceedings. pp. 28–40 (1997)</li>

      <li>[17] Jakobsen, T., Knudsen, L.R.: Attacks on block ciphers of low algebraic degree. J. Cryptology 14(3), 197–210 (2001)</li>

      <li>[18] Knudsen, L.R.: Truncated and higher order differentials. In: Preneel, B. (ed.) FSE 1994. LNCS, vol. 1008, pp. 196–211. Springer (1994)</li>

      <li>[19] Lai, X.: Higher order derivatives and differential cryptanalysis. In: Communications and Cryptography. The Springer International Series in Engineering and Computer Science, vol. 276, pp. 227–233 (1994)</li>

      <li>[20] Méaux, P., Journault, A., Standaert, F., Carlet, C.: Towards stream ciphers for efficient FHE with low-noise ciphertexts. In: Advances in Cryptology - EUROCRYPT 2016 - 35th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Vienna, Austria, May 8-12, 2016, Proceedings, Part I. pp. 311–343 (2016)</li>

      <li>[21] Nyberg, K.: Differentially uniform mappings for cryptography. In: Advances in Cryptology - EUROCRYPT ’93, Workshop on the Theory and Application of of Cryptographic Techniques, Lofthus, Norway, May 23-27, 1993, Proceedings. pp. 55–64 (1993)</li>

      <li>[22] Nyberg, K., Knudsen, L.R.: Provable security against a differential attack. J. Cryptology 8(1), 27–37 (1995)</li>

      <li>[23] Rechberger, C., Soleimany, H., Tiessen, T.: Cryptanalysis of low-data instances of full LowMCv2. IACR Transactions on Symmetric Cryptology 2018(3), 163–181 (Sep 2018). https://doi.org/10.13154/tosc.v2018.i3.163-181, https://tosc.iacr.org/index.php/ToSC/article/view/7300</li>

      <li>[24] Shannon, C.E.: Communication theory of secrecy systems. Bell Systems Technical Journal 28(4), 656–715 (1949)</li>

      <li>[25] Shimoyama, T., Moriai, S., Kaneko, T.: Improving the higher order differential attack and cryptanalysis of the <em>KN</em> cipher. In: Information Security, First International Workshop, ISW ’97, Tatsunokuchi, Japan, September 17-19, 1997, Proceedings. pp. 32–42 (1997)</li>

      <li>[26] Stoß, H.: The complexity of evaluating interpolation polynomials. Theor. Comput. Sci. 41, 319–323 (1985)</li>

      <li>[27] Sun, B., Qu, L., Li, C.: New cryptanalysis of block ciphers with low algebraic degree. In: Fast Software Encryption, 16th International Workshop, FSE 2009, Leuven, Belgium, February 22-25, 2009, Revised Selected Papers. pp. 180–192 (2009)</li>

      <li>[28] Todo, Y., Isobe, T., Hao, Y., Meier, W.: Cube attacks on non-blackbox polynomials based on division property. In: Advances in Cryptology - CRYPTO 2017 - 37th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 20-24, 2017, Proceedings, Part III. pp. 250–279 (2017)</li>

      <li>[29] Wang, Q., Hao, Y., Todo, Y., Li, C., Isobe, T., Meier, W.: Improved division property based cube attacks exploiting algebraic properties of superpoly. In: Advances in Cryptology - CRYPTO 2018 - 38th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 19-23, 2018, Proceedings, Part I. pp. 275–305 (2018)</li>

    </ul>`;
---

<BaseLayout title="Improved Interpolation Attacks on Cryptographic Primitives o... (2019/812)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/812
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
