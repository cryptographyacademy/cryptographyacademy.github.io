---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/255';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'New and Old Limits for AES Known-Key Distinguishers';
const AUTHORS_HTML = 'Lorenzo Grassi, Christian Rechberger';

const CONTENT = `    <p class="text-gray-300">Lorenzo Grassi [ IAIK, Graz University of Technology, Austria ] Christian Rechberger [ IAIK, Graz University of Technology, Austria DTU Compute, DTU, Denmark firstname.lastname@iaik.tugraz.at ]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Known-key distinguishers have been introduced by Knudsen and Rijmen in 2007 to better understand the security of block ciphers in situations where the key can not be considered to be secret, i.e. the “thing between secret-key model and hash function use-cases”.</p>

    <p class="text-gray-300">AES is often considered as a target of such analyses, simply because AES or its building blocks are used in many settings that go beyond classical encryption. The most recent approach of Gilbert (proposed at Asiacrypt 2014) considers 8 core rounds, and extends it by one round in each direction. The resulting approach on 10-round has a time complexity of <span class="math">2^{64}</span>, and the best generic approach was shown to beat the proposed method with probably <span class="math">&amp;lt;2^{-16.5}</span> and is hence referred to as a “distinguisher”. Interestingly, Gilbert’s work also for the first time showed that the known-key model may not be weaker than the chosen-key model, as the best chosen-key attacks on AES only cover 9 rounds so far. This current state of affairs is unsatisfying as it contradicts the original intent of the known-key model.</p>

    <p class="text-gray-300">In this paper we pick up the work of Gilbert, further exploring the limits of the known-key model with a focus on the AES, and eventually propose a way to remedy the situation. In that work, arguments are put forward suggesting that a total of two extension rounds seem to be the limit in the known-key model, and that likely only a distinguisher that exploits the uniform distribution property can be extended in such way. We disprove both conjectures and arrive at the following results: We firstly show that the technique proposed by Gilbert can also be used to extend a known-key distinguisher based on truncated differential trails. This allows us to present improved known-key distinguishers for AES from 7 to 10 rounds of AES. In particular, we are able to set up a 9-round known-key distinguisher for AES with a time complexity of <span class="math">2^{23}</span> and a 10-round known-key distinguisher with a time complexity of <span class="math">2^{50}</span>. Secondly we are also able to show that more than two extension rounds are possible. As a result of this, we describe the first known-key distinguishers on 12 rounds of AES, by extending Gilbert’s 8-round known-key distinguisher by two rounds in each direction. The time complexity is <span class="math">2^{66}</span>, and for this result we do have supporting formal arguments, similar to Gilbert, that the best generic approach to beat the proposed method has probably <span class="math">&amp;lt;2^{-25}</span>.</p>

    <p class="text-gray-300">This also shows that the counter-intuitive gap between the known-key and the chosen-key model may be wider than initially thought. To remedy the situation, we propose a refinement of the known-key model which restores its original intent.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">keywords:</h6>

    <p class="text-gray-300">Block cipher Permutation AES Known-Key Distinguisher</p>

    <p class="text-gray-300">New and Old Limits for AES Known-Key Distinguishers</p>

    <p class="text-gray-300">1 Introduction 3 1.1 Known-Key Distinguishers for AES: the State of the Art 3 1.2 Our contributions 5</p>

    <p class="text-gray-300">2 Preliminary - Description of AES 6</p>

    <p class="text-gray-300">3 Subspace trails 7 3.1 Subspace trails of AES 7</p>

    <p class="text-gray-300">4 Known-Key Distinguishers for AES 8 4.1 Definition of Known-Key Distinguisher 8 4.2 7- and 8-Round Known-Key Distinguisher 11 4.3 Multiple Limited-Birthday 8-Round Known-Key Distinguisher 12</p>

    <p class="text-gray-300">5 Gilbert's Known-Key Distinguisher for 10-round AES 12 5.1 Uniform Distribution 8-round Known-Key Distinguisher 12 5.2 Extension to 10 Rounds of AES 15 5.2.1 Generic Considerations 17 5.3 Another Strategy for the Verifier 17</p>

    <p class="text-gray-300">6 Key-Recovery Extensions using Truncated Differentials 20 6.1 Attack for the Case of 1-Round Extension 20 6.2 Attack for the Case of 2-Round Extension 21</p>

    <p class="text-gray-300">7 9-Round Known-Key Distinguisher for AES 22</p>

    <p class="text-gray-300">8 10-Round Distinguisher of AES - Full AES-128 25 8.1 Independent Subkeys: No Key Schedule 26 8.2 The Key Schedule Case 27 8.2.1 Number <span class="math">n</span> of Tuples: Oracle-Queries. 28 8.2.2 Number <span class="math">n</span> of Tuples: Oracle-Queries and Cost of Generic Player. 29</p>

    <p class="text-gray-300">9 12-Round Distinguisher of AES 29</p>

    <p class="text-gray-300">10 Gilbert's Distinguisher for 12-round AES 31 10.0.1 The Verification Process 32 10.0.2 On the Meaningfulness of this Distinguisher 34</p>

    <p class="text-gray-300">11 Infeasibility of a 14-round Known-Key Distinguisher 35</p>

    <p class="text-gray-300">12 Discussion of Results and Proposal for a New Model 36</p>

    <p class="text-gray-300">A A possible Variant of Gilbert's Distinguisher - Details 39 B The Rebound Attack - Details 40 C Known-Key Distinguishers for 7- and 8-round AES based on Uniform Distribution and Balance Property 41 C.1 Known-Key Distinguisher based on Balance Property 41 C.2 Known-Key Distinguisher based on Uniform Distribution 42 C.3 Zero-Sum Distinguisher - Scenario of Sect. 4 44</p>

    <p class="text-gray-300">New and Old Limits for AES Known-Key Distinguishers</p>

    <p class="text-gray-300">D.1 Known-Key Distinguisher on 9-Round AES 47 D.2 Known-Key Distinguisher on 10-Round AES with Key Schedule. 48</p>

    <p class="text-gray-300">E.1 7-Round Known-Key Distinguisher 49 E.2 8-Round Known-Key Distinguisher 49 E.3 9-Round Known-Key Distinguisher 50</p>

    <p class="text-gray-300">E.3.1 Independent Subkeys: No Key Schedule. 51 E.3.2 The Key Schedule Case. 51</p>

    <p class="text-gray-300">E.4 Considerations and Comparison with Gilbert's Distinguisher 51</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Block ciphers play an important role in symmetric cryptography providing the basic tool for encryption. They are the oldest and most scrutinized cryptographic tools. Consequently, they are the most trusted cryptographic algorithms that are often used as the underlying tool to construct other cryptographic algorithms, whose proofs of security are performed under the assumption that the underlying block cipher is ideal.</p>

    <p class="text-gray-300">The concept of known-key distinguishers was introduced by Knudsen and Rijmen in <em>[x10]</em>. In the classical single secret-key setting, the attacker does not know the randomly generated key and aims to recover it or builds a (secret-key) distinguisher that allows to distinguish the cipher from a random permutation. The security model in known-key attacks is quite different though: the attacker knows the randomly drawn key the block cipher operates with and aims to find a structural property for the cipher under the known key - a property which an ideal cipher (a permutation drawn at random) would not have. Only for completeness, a more relaxed version - called chosen-key distinguisher - can be considered, where the adversary is assumed to have a full control over the key. This model was introduced in <em>[x2]</em>, and has been extended to a related-key attack on the full-round AES-256, while the best chosen-key distinguisher for AES-128 <em>[x7]</em> currently present in literature covers 9-round out of 10. In this paper however we focus on the known-key model and do not allow or assume related keys.</p>

    <p class="text-gray-300">Since their introductions, known-key attacks have been a major research topic in the symmetric-key community. Indeed, if known-key distinguishers could be considered less relevant than secret-key ones, they anyway allow to learn something about the security margin of a cipher. For example, if it is not possible to find distinguishers for a block cipher when the key is given, then one cannot find a distinguisher when the key is secret. Secondly and more important, block ciphers and hash functions are very close cryptographic primitives, as the latter can be built from the former and vice versa. For example, the Davies-Meyer construction or the Miyaguchi-Preneel construction can transform a secure block cipher into a secure compression function. In a hash setting, block cipher security models such as the known-key model (or the chosen-key model) make sense since in practice the attacker has full access and control over the internal computations. Moreover, an attack in these models depicts a structural flaw of the cipher, while it should be desired to work with a primitive that doesn’t have any flaw, even in the most generous security model for the attacker. A classical example is the devastating effect on the compression function security of weak keys for a block cipher <em>[WPS^{+}12]</em>, which are usually considered as a minor flaw for a block cipher if the set of these weak-keys is small. Therefore, the security notions to consider for a block cipher will vary depending if this block cipher will be used in a hash function setting or not.</p>

    <p class="text-gray-300">The known-key model received scrutiny from a more theoretical side too. In <em>[x1]</em> a model derived form the indifferentiability framework is used to formalize the known-key security of block ciphers based on the underlying building blocks, while in <em>[x16]</em> the impact of attacks in the known-key model on hash functions is studied.</p>

    <p class="text-gray-300">Citing Knudsen and Rijmen <em>[x10]</em>, “imagine a block cipher” for which a known-key distinguisher exists, “but where no efficient attacks are known in the traditional black-box model. Should we recommend the use of such a cipher? We don’t think so!”</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">1.1 Known-Key Distinguishers for AES: the State of the Art</h3>

    <p class="text-gray-300">In the known-key model, a full access to an instance of the encryption function associated with a known random key and its inverse is given. The purpose is to simultaneously control the inputs and the outputs of the primitive, i.e. to achieve input-output correlations that one could not efficiently achieve with inputs and outputs of a perfect random permutation to which would have an oracle access. A formal definition of a known-key distinguisher</p>

    <p class="text-gray-300">New and Old Limits for AES Known-Key Distinguishers</p>

    <p class="text-gray-300">Table 1: AES known-key distinguishers. The computation cost is the sum of the computational cost to generate  <span class="math">N</span> -tuples of plaintexts/ciphertexts and of the verification cost. The word "Extended" refers to a distinguisher which exploits the technique introduced by Gilbert [Gil14] (in this case we also highlight which distinguisher is extended), while "MultDT" refers to Multiple Differential Trail. A detailed table with all the distinguishers presented in this paper is given in Sect. 4.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Computations</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Memory</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Property</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Reference</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">Zero-Sum</td>

            <td class="px-3 py-2 border-b border-gray-700">[KR07]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">224</td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">Differential Trail</td>

            <td class="px-3 py-2 border-b border-gray-700">[MPRS09]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">Multiple Diff. Trail</td>

            <td class="px-3 py-2 border-b border-gray-700">App. E.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">Uniform Distribution</td>

            <td class="px-3 py-2 border-b border-gray-700">[Gil14] - App. C</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">248</td>

            <td class="px-3 py-2 border-b border-gray-700">232</td>

            <td class="px-3 py-2 border-b border-gray-700">Differential Trail</td>

            <td class="px-3 py-2 border-b border-gray-700">[GP10]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">244</td>

            <td class="px-3 py-2 border-b border-gray-700">232</td>

            <td class="px-3 py-2 border-b border-gray-700">Multiple Diff. Trail</td>

            <td class="px-3 py-2 border-b border-gray-700">[JNPP14]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">223</td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">Extended 7-Round MultDT</td>

            <td class="px-3 py-2 border-b border-gray-700">App. E.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">250</td>

            <td class="px-3 py-2 border-b border-gray-700">232</td>

            <td class="px-3 py-2 border-b border-gray-700">Extended 8-Round MultDT</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect. 7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">223</td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">Extended 7-Round MultDT</td>

            <td class="px-3 py-2 border-b border-gray-700">App. E.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">Extended 8-Round Unif. Dist.</td>

            <td class="px-3 py-2 border-b border-gray-700">[Gil14]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">250</td>

            <td class="px-3 py-2 border-b border-gray-700">232</td>

            <td class="px-3 py-2 border-b border-gray-700">Extended 8-Round MultDT</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect. 8.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">282</td>

            <td class="px-3 py-2 border-b border-gray-700">232</td>

            <td class="px-3 py-2 border-b border-gray-700">Extended 8-Round MultDT</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect. 9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">266</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">Extended 8-Round Unif. Dist.</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect. 10</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">is provided in Sect. 4, where we propose and describe in details a generic scenario for known-key distinguisher. We emphasize that all the known-key distinguishers currently present in the literature - including the one presented in this paper - implicitly exploit (and can be described in) the scenario proposed in Sect. 4.</p>

    <p class="text-gray-300">AES and related constructions served as a benchmark for cryptanalytic techniques since the very introduction of this model by Knudsen and Rijmen [KR07] with a 7-round result. Subsequently, 8-round results were obtained using truncated differentials [GP10], which were later on improved in [JNPP14]. Currently, this last one - which exploits the rebound technique  <span class="math">\\mathrm{[LMS^{+}15]}</span>  and the so called "multiple limited-birthday problem" - is the best 8-round known-key distinguisher in literature. Recently, Gilbert [Gil14] found a way to extend an 8-round known-key distinguisher (using a novel representation of AES) into a more intricate 10-round distinguisher and hence presented for the first time a known-key distinguisher for full AES-128.</p>

    <p class="text-gray-300">All the known-key distinguishers on AES currently present in the literature are briefly recalled in Sect. 4 using the "subspace trail notation", recently introduced at FSE 2017. In Table 1 we list the known-key distinguishers for AES, including our main results (we refer to Table 2 in Sect. 4 for more details about the AES known-key distinguishers obtained by extending distinguishers based on Multiple Differential Trails).</p>

    <p class="text-gray-300">As we will describe in more detail in Sect. 4.1, the approach of [Gil14] makes use of a freedom in the know-key model that was actually always there but never spelled out explicitly. In more detail, there is always the role of a "verifier", in addition to a "shortcut-player" and a "generic player". In [Gil14] the verifier has perhaps for the first time some</p>

    <p class="text-gray-300">non-negligible computations to do. The details of the definitions are such that it is still not possible to simply “peel-off” an arbitrary number of rounds, on the contrary it seemed that only the detection of a very specific property (the “uniform distribution property”) could take advantage of computations of the verifier.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">1.2 Our contributions</h3>

    <p class="text-gray-300">We have two types of contributions in this paper. The first type is a progress in cryptanalysis, improving in various ways distinguishers (or conjectures thereof in case we can not prove that no generic attack is better) on AES in the model of <em>[x10]</em>. Even though this leads to statements on more rounds of AES than ever before (without related keys) that seem meaningful, it is not clear if such statements can become useful in the sense to e.g. have an impact of hash function use-cases of block ciphers. For the sake of completeness, it should be indeed mentioned that even if the strategy proposed by Gilbert allows to set up efficient known-key distinguishers, its “<em>impact on the security of […] AES when used as a known key primitive, e.g. in a hash function construction, is questionable</em>” (see abstract of <em>[x10]</em>).</p>

    <p class="text-gray-300">The second type of contribution is the high level insight that the details of the known-key model need to be changed if we want to restore the original intent of the known-key model. The reason is that with our new result the difference between the chosen-key model and what is currently thought of as the known-key model is counter-intuitive: As we show it is now possible to have cryptanalytic results on many more rounds of AES in the known-key model than in the chosen-key model and this is true for more than a single property. Hence we propose a simple restriction of the verifier in the known-key model to remedy the situation.</p>

    <p class="text-gray-300">In the following we summarize two aspects of our cryptanalytic results first. In the conclusion of his paper, Gilbert claims that it seems technically difficult to use a stronger property than the uniform distribution one to extend an 8-round known-key distinguisher to a 10-round one. In particular, he left “<em>the investigation of improved 10-round known-key distinguishers and associated proofs - or even plausible heuristic arguments if rigorous proofs turn out to be too difficult to obtain - as an open issue.</em>”</p>

    <p class="text-gray-300">In this paper, we pick up this challenge, and using a strategy similar to the one proposed by Gilbert in <em>[x10]</em>, we show how to construct more efficient 8-, 9- and 10-round distinguishers. To achieve this result, we exploit known-key distinguishers based on truncated differential trails. In particular, we use as starting point the 8-round known-key distinguisher presented in <em>[x16]</em>, and we extend it at the end or/and at the beginning using the same strategy proposed by Gilbert. This allows to set up a 9-round known-key distinguisher (see Sect. 7) and a 10-round known-key distinguisher for AES (see Sect. 8.1) with time complexity approximately of <span class="math">2^{50}</span>. Moreover, starting from the 7-round known-key distinguisher presented in <em>[x22]</em> - improved in App. E.1 using the “multiple limited-birthday problem” proposed in <em>[x16]</em> - and using exactly the same technique presented for the previous cited distinguishers, we are able to set up 8- and 9-round known-key distinguisher for AES (see App. E.2 and E.3), both with complexity approximately of <span class="math">2^{23}</span>.</p>

    <p class="text-gray-300">As a main cryptanalytic result, in Sect. 9 we show that it is possible to extend our 10-round distinguisher up to 12 rounds Moreover, in Sect. 10 we show that the same strategy can be used to extend Gilbert’s 10-round distinguisher based on the uniform distribution property up to 12 rounds. These are the <em>first known-key distinguisher for full AES-192</em>, and they also provide counter-examples of the claim made in <em>[x10]</em> about the (im)possibility to use Gilbert’s technique to extend a 8-round distinguisher more than 2 rounds: “*The reader might wonder whether the technique we used to derive a known-key distinguisher for the 10-round AES from a known-key distinguisher for the 8-round AES does not allow to extend this 8-round known distinguisher by an arbitrary number of rounds. It is easy however to see that the argument showing that 10-round relation <span class="math">\\mathcal{R}</span> is efficiently</p>

    <p class="text-gray-300">checkable does not transpose for showing that the relations over <span class="math">r&gt;10</span> rounds one could derive from the 8-round relation by expressing that the r-round inputs and outputs are related by <span class="math">r-8&gt;2</span> outer rounds to intermediate blocks that satisfy the 8-round relation are efficiently checkable.”</p>

    <p class="text-gray-300">Finally, we discuss why our results no longer exclude known-key distinguishers up to 14 rounds, but at the same time why this seems currently not feasible. Using our results presented in the paper as starting point, we show that one of the main problem (but not the only one) about the possibility to extend a known-key distinguisher exploiting the strategy initially proposed by Gilbert is related to the existence of key-recovery attack on AES with more than a single extension at the end and a computational complexity lower than <span class="math">2^{128}</span> computations. We refer to Sect. 11 for a complete discussion. We conclude in Sect. 12, with a discussion of the results and a proposal of a refinement of the known-key model which restores its original intent (in which the role of the verifier gets back to being marginal).</p>

    <h2 id="sec-12" class="text-2xl font-bold">2 Preliminary - Description of AES</h2>

    <p class="text-gray-300">The Advanced Encryption Standard <em>[x10]</em> is a Substitution-Permutation network that supports key sizes of 128, 192 and 256 bits. The 128-bit plaintext initializes the internal state as a <span class="math">4\\times 4</span> matrix of bytes as values in the finite fields <span class="math">\\mathbb{F}_{256}</span>, defined using the irreducible polynomial <span class="math">x^{8}+x^{4}+x^{3}+x+1</span>. Depending on the version of AES, <span class="math">N_{r}</span> round are applied to the state: <span class="math">N_{r}=10</span> for AES-128, <span class="math">N_{r}=12</span> for AES-192 and <span class="math">N_{r}=14</span> for AES-256. An AES round applies four operations to the state matrix:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>SubBytes (S-Box) - applying the same 8-bit to 8-bit invertible S-Box 16 times in parallel on each byte of the state (it provides non-linearity in the cipher);</li>

      <li>ShiftRows (<span class="math">SR</span>) - cyclic shift of each row to the left;</li>

      <li>MixColumns (<span class="math">MC</span>) - multiplication of each column by a constant <span class="math">4\\times 4</span> invertible matrix <span class="math">M_{MC}</span> (<span class="math">MC</span> and <span class="math">SR</span> provide diffusion in the cipher);</li>

      <li>AddRoundKey (<span class="math">ARK</span>) - XORing the state with a 128-bit subkey.</li>

    </ul>

    <p class="text-gray-300">One round of AES can be described as <span class="math">R(x)=K\\oplus MC\\circ SR\\circ\\textrm{ S-Box}(x).</span> In the first round an additional AddRoundKey operation (using a whitening key) is applied, and in the last round the MixColumns operation is omitted.</p>

    <p class="text-gray-300">Finally, as we don’t use the details of the AES key schedule in this paper, we refer to <em>[x10]</em> for a complete description.</p>

    <p class="text-gray-300">The Notation Used in the Paper. Let <span class="math">x</span> denote a plaintext, a ciphertext, an intermediate state or a key. Then <span class="math">x_{i,j}</span> with <span class="math">i,j\\in\\{0,...,3\\}</span> denotes the byte in the row <span class="math">i</span> and in the column <span class="math">j</span>. We denote by <span class="math">k^{r}</span> the key of the <span class="math">r</span>-th round, where <span class="math">k^{0}</span> is the secret key. If only the key of the final round is used, then we denote it by <span class="math">k</span> to simplify the notation. Finally, we denote by <span class="math">R</span> one round of AES, while we denote <span class="math">r</span> rounds of AES by <span class="math">R^{r}</span>. We sometimes use the notation <span class="math">R_{K}</span> instead of <span class="math">R</span> to highlight the round key <span class="math">K</span>. As last thing, in the paper we often use the term “partial collision” (or “collision”) when two texts belong to the same coset of a given subspace <span class="math">X</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Lorenzo Grassi and Christian Rechberger</p>

    <p class="text-gray-300">Invariant subspace cryptanalysis can be a powerful cryptanalytic tool, and subspace trails [GRR17] - introduced at FSE 2017 - are a recent generalization of it.</p>

    <p class="text-gray-300">Let  <span class="math">F</span>  denote a round function in a iterative block cipher and let  <span class="math">V \\oplus a</span>  denote a coset of a vector space  <span class="math">V</span> . Then if  <span class="math">F(V \\oplus a) = V \\oplus a</span>  we say that  <span class="math">V \\oplus a</span>  is an invariant coset of the subspace  <span class="math">V</span>  for the function  <span class="math">F</span> . This concept can be generalized to trails of subspaces.</p>

    <p class="text-gray-300">Definition 1. Let  <span class="math">(V_{1}, V_{2}, \\dots, V_{r+1})</span>  denote a set of  <span class="math">r+1</span>  subspaces with  <span class="math">\\dim(V_{i}) \\leq \\dim(V_{i+1})</span> . If for each  <span class="math">i = 1, \\dots, r</span>  and for each  <span class="math">a_{i} \\in V_{i}^{\\perp}</span> , there exist (unique)  <span class="math">a_{i+1} \\in V_{i+1}^{\\perp}</span>  such that  <span class="math">F(V_{i} \\oplus a_{i}) \\subseteq V_{i+1} \\oplus a_{i+1}</span> , then  <span class="math">(V_{1}, V_{2}, \\dots, V_{r+1})</span>  is subspace trail of length  <span class="math">r</span>  for the function  <span class="math">F</span> . If all the previous relations hold with equality, the trail is called a constant-dimensional subspace trail.</p>

    <p class="text-gray-300">This means that if  <span class="math">F^t</span>  denotes the application of  <span class="math">t</span>  rounds with fixed keys, then  <span class="math">F^t(V_1 \\oplus a_1) = V_{t+1} \\oplus a_{t+1}</span> . We refer to [GRR17] for more details about the concept of subspace trails. Our treatment here is however meant to be self-contained.</p>

    <p class="text-gray-300">In this section, we recall the subspace trails of AES presented in [GRR17]. For the following, we only work with vectors and vector spaces over  <span class="math">\\mathbb{F}_{2^8}^{4\\times 4}</span> , and we denote by  <span class="math">\\{e_{0,0},\\dots,e_{3,3}\\}</span>  the unit vectors of  <span class="math">\\mathbb{F}_{2^8}^{4\\times 4}</span>  (e.g.  <span class="math">e_{i,j}</span>  has a single 1 in row  <span class="math">i</span>  and column  <span class="math">j</span> ). We also recall that given a subspace  <span class="math">X</span> , the cosets  <span class="math">X\\oplus a</span>  and  <span class="math">X\\oplus b</span>  (where  <span class="math">a\\neq b</span> ) are equivalent (that is  <span class="math">X\\oplus a\\sim X\\oplus b</span> ) if and only if  <span class="math">a\\oplus b\\in X</span> .</p>

    <p class="text-gray-300">Definition 2. The column spaces  <span class="math">\\mathcal{C}_i</span>  are defined as  <span class="math">\\mathcal{C}_i = \\langle e_{0,i},e_{1,i},e_{2,i},e_{3,i}\\rangle</span> .</p>

    <p class="text-gray-300">For instance,  <span class="math">\\mathcal{C}_0</span>  corresponds to the symbolic matrix</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {C} _ {0} = \\left\\{\\left[ \\begin{array}{c c c c} x _ {1} &amp; 0 &amp; 0 &amp; 0 \\\\ x _ {2} &amp; 0 &amp; 0 &amp; 0 \\\\ x _ {3} &amp; 0 &amp; 0 &amp; 0 \\\\ x _ {4} &amp; 0 &amp; 0 &amp; 0 \\end{array} \\right] \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\forall x _ {1}, x _ {2}, x _ {3}, x _ {4} \\in \\mathbb {F} _ {2 ^ {8}} \\right\\} \\equiv \\left[ \\begin{array}{c c c c} x _ {1} &amp; 0 &amp; 0 &amp; 0 \\\\ x _ {2} &amp; 0 &amp; 0 &amp; 0 \\\\ x _ {3} &amp; 0 &amp; 0 &amp; 0 \\\\ x _ {4} &amp; 0 &amp; 0 &amp; 0 \\end{array} \\right].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Definition 3. The diagonal spaces  <span class="math">\\mathcal{D}_i</span>  and the inverse-diagonal spaces  <span class="math">\\mathcal{ID}_i</span>  are respectively defined as  <span class="math">\\mathcal{D}_i = SR^{-1}(\\mathcal{C}_i) \\equiv \\langle e_{0,i}, e_{1,i+1}, e_{2,i+2}, e_{3,i+3} \\rangle</span>  and  <span class="math">\\mathcal{ID}_i = SR(\\mathcal{C}_i) \\equiv \\langle e_{0,i}, e_{1,i-1}, e_{2,i-2}, e_{3,i-3} \\rangle</span> , where the indexes are taken modulo 4.</p>

    <p class="text-gray-300">For instance,  <span class="math">\\mathcal{D}_0</span>  and  <span class="math">\\mathcal{ID}_0</span>  correspond to symbolic matrix</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {D} _ {0} \\equiv \\left[ \\begin{array}{c c c c} x _ {1} &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; x _ {2} &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; x _ {3} &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; x _ {4} \\end{array} \\right], \\qquad \\mathcal {I D} _ {0} \\equiv \\left[ \\begin{array}{c c c c} x _ {1} &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; x _ {2} \\\\ 0 &amp;amp; 0 &amp;amp; x _ {3} &amp;amp; 0 \\\\ 0 &amp;amp; x _ {4} &amp;amp; 0 &amp;amp; 0 \\end{array} \\right].</span></div>

    <p class="text-gray-300">Definition 4. The  <span class="math">i</span> -th mixed spaces  <span class="math">\\mathcal{M}_i</span>  are defined as  <span class="math">\\mathcal{M}_i = MC(\\mathcal{ID}_i)</span> .</p>

    <p class="text-gray-300">For instance,  <span class="math">\\mathcal{M}_0</span>  corresponds to symbolic matrix</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {M} _ {0} \\equiv \\left[ \\begin{array}{c c c c} 0 \\mathrm {x} 0 2 \\cdot x _ {1} &amp;amp; x _ {4} &amp;amp; x _ {3} &amp;amp; 0 \\mathrm {x} 0 3 \\cdot x _ {2} \\\\ x _ {1} &amp;amp; x _ {4} &amp;amp; 0 \\mathrm {x} 0 3 \\cdot x _ {3} &amp;amp; 0 \\mathrm {x} 0 2 \\cdot x _ {2} \\\\ x _ {1} &amp;amp; 0 \\mathrm {x} 0 3 \\cdot x _ {4} &amp;amp; 0 \\mathrm {x} 0 2 \\cdot x _ {3} &amp;amp; x _ {2} \\\\ 0 \\mathrm {x} 0 3 \\cdot x _ {1} &amp;amp; 0 \\mathrm {x} 0 2 \\cdot x _ {4} &amp;amp; x _ {3} &amp;amp; x _ {2} \\end{array} \\right].</span></div>

    <p class="text-gray-300">Definition 5. For  <span class="math">I \\subseteq \\{0,1,2,3\\}</span> , let  <span class="math">\\mathcal{C}_I, \\mathcal{D}_I, \\mathcal{ID}_I</span>  and  <span class="math">\\mathcal{M}_I</span>  defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {C} _ {I} = \\bigoplus_ {i \\in I} \\mathcal {C} _ {i}, \\qquad \\mathcal {D} _ {I} = \\bigoplus_ {i \\in I} \\mathcal {D} _ {i}, \\qquad \\mathcal {I D} _ {I} = \\bigoplus_ {i \\in I} \\mathcal {I D} _ {i}, \\qquad \\mathcal {M} _ {I} = \\bigoplus_ {i \\in I} \\mathcal {M} _ {i}.</span></div>

    <p class="text-gray-300">New and Old Limits for AES Known-Key Distinguishers</p>

    <p class="text-gray-300">As shown in detail in [GRR17]:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for any coset <span class="math">\\mathcal{D}_I \\oplus a</span> there exists a unique <span class="math">b \\in \\mathcal{C}_I^\\perp</span> such that <span class="math">R(\\mathcal{D}_I \\oplus a) = \\mathcal{C}_I \\oplus b</span>;</li>

      <li>for any coset <span class="math">\\mathcal{C}_I \\oplus a</span> there exists a unique <span class="math">b \\in \\mathcal{M}_I^\\perp</span> such that <span class="math">R(\\mathcal{C}_I \\oplus a) = \\mathcal{M}_I \\oplus b</span>.</li>

    </ul>

    <p class="text-gray-300">This simply states that a coset of a sum of diagonal spaces <span class="math">\\mathcal{D}_I</span> encrypts to a coset of a corresponding sum of column spaces. Similarly, a coset of a sum of column spaces <span class="math">\\mathcal{C}_I</span> encrypts to a coset of the corresponding sum of mixed spaces.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> For each <span class="math">I</span> and for each <span class="math">a \\in \\mathcal{D}_I^\\perp</span>, there exists one and only one <span class="math">b \\in \\mathcal{M}_I^\\perp</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">R^2(\\mathcal{D}_I \\oplus a) = \\mathcal{M}_I \\oplus b. \\tag{1}</span></div>

    <p class="text-gray-300">We refer to [GRR17] for a complete proof of this theorem. Observe that <span class="math">b</span> depends on <span class="math">a</span> and on the secret key <span class="math">k</span>, and that this theorem doesn't depend on the particular choice of the S-Box (i.e. it is independent of the details of the S-Box).</p>

    <p class="text-gray-300">Observe that if <span class="math">X</span> is a generic subspace, <span class="math">X \\oplus a</span> is a coset of <span class="math">X</span> and <span class="math">x</span> and <span class="math">y</span> are two elements of the (same) coset <span class="math">X \\oplus a</span>, then <span class="math">x \\oplus y \\in X</span>. It follows that:</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> For all <span class="math">x, y</span> and for all <span class="math">I \\subseteq \\{0,1,2,3\\}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Prob}(R^2(x) \\oplus R^2(y) \\in \\mathcal{M}_I \\mid x \\oplus y \\in \\mathcal{D}_I) = 1. \\tag{2}</span></div>

    <p class="text-gray-300">As demonstrated in [GRR17], we finally recall that for each <span class="math">I, J \\subseteq \\{0,1,2,3\\}</span>:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}_I \\cap \\mathcal{D}_J = \\{0\\} \\quad \\text{if and only if} \\quad</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 4, \\tag{3}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Theorem 2.</strong> Let <span class="math">I, J \\subseteq \\{0,1,2,3\\}</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 4<span class="math">. For all </span>x \\neq y$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Prob}(R^4(x) \\oplus R^4(y) \\in \\mathcal{M}_I \\mid x \\oplus y \\in \\mathcal{D}_J) = 0. \\tag{4}</span></div>

    <p class="text-gray-300">For completeness, we briefly describe the subspace trail notation using a more "classical" one. If two texts <span class="math">t^1</span> and <span class="math">t^2</span> are equal, expect for the bytes in the <span class="math">i</span>-th diagonal<span class="math">^4</span> for each <span class="math">i \\in I</span>, then they belong in the same coset of <span class="math">\\mathcal{D}_I</span>. Two texts <span class="math">t^1</span> and <span class="math">t^2</span> belong in the same coset of <span class="math">\\mathcal{M}_I</span> if the bytes of their difference <span class="math">MC^{-1}(t^1 \\oplus t^2)</span> in the <span class="math">i</span>-th anti-diagonal for each <span class="math">i \\notin I</span> are equal to zero. Similar considerations hold for the column space <span class="math">\\mathcal{C}_I</span> and the inverse-diagonal space <span class="math">\\mathcal{ID}_I</span>.</p>

    <p class="text-gray-300">Before we present our new known-key distinguishers for AES, we review the most relevant ones to our work. First, we give a formal definition of the known-key distinguisher scenario, using the one proposed in [Gil14] by Gilbert as starting point.</p>

    <p class="text-gray-300">Informally, a known-key distinguisher exploits the fact that it is in general harder for an adversary who doesn't know the key to derive an <span class="math">N</span>-tuple of input blocks of the considered block cipher <span class="math">E</span> that is "abnormally correlated" with the corresponding <span class="math">N</span>-tuple of output blocks than for one who knows the secret key. This difficulty is well expressed by the <span class="math">T</span>-intractable definition, first proposed in [CGH04] and [ABM14], and then re-expressed by Gilbert as follows:</p>

    <p class="text-gray-300"><span class="math">^4</span>The <span class="math">i</span>-th diagonal of a <span class="math">4 \\times 4</span> matrix <span class="math">A</span> is defined as the elements that lie on row <span class="math">r</span> and column <span class="math">c</span> such that <span class="math">r - c = i \\mod 4</span>. The <span class="math">i</span>-th anti-diagonal of a <span class="math">4 \\times 4</span> matrix <span class="math">A</span> is defined as the elements that lie on row <span class="math">r</span> and column <span class="math">c</span> such that <span class="math">r + c = i \\mod 4</span>.</p>

    <p class="text-gray-300">Lorenzo Grassi ^{1} and Christian Rechberger ^{1,2}</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: A Known-Key Distinguisher Scenario. Step (0): a relationship  <span class="math">\\mathcal{R}</span>  is chosen. Step (1): the secret key is given to the Oracle  <span class="math">\\Pi / \\Pi^{-1}</span>  and to the Shortcut Player  <span class="math">\\mathcal{A}</span> . Step (2): the Shortcut Player  <span class="math">\\mathcal{A}</span>  and the Generic Player  <span class="math">\\mathcal{A}&#x27;</span>  generate the  <span class="math">N</span> -tuples that satisfy the required relationship  <span class="math">\\mathcal{R}</span> . Step (3): the Verifier receives the  <span class="math">N</span> -tuple and checks if  <span class="math">\\mathcal{R}</span>  is satisfied or not. The faster player to generate the  <span class="math">N</span> -tuple wins the "game".</p>

    <p class="text-gray-300">Definition 6. Let  <span class="math">E: (K, X) \\in \\{0,1\\}^k \\times \\{0,1\\}^n \\to E_K(X) \\in \\{0,1\\}^n</span>  denote a block cipher of block size  <span class="math">n</span>  bits. Let  <span class="math">N \\geq 1</span>  and  <span class="math">\\mathcal{R}</span>  denote an integer and any relation over the set  <span class="math">S</span>  of  <span class="math">N</span> -tuples of  <span class="math">n</span> -bit blocks.  <span class="math">\\mathcal{R}</span>  is said to be  <span class="math">T</span> -intractable relatively to  <span class="math">E</span>  if, given any algorithm  <span class="math">\\mathcal{A}&#x27;</span>  that is given an oracle access to a perfect random permutation  <span class="math">\\Pi</span>  of  <span class="math">\\{0,1\\}^n</span>  and its inverse, it is impossible for  <span class="math">\\mathcal{A}&#x27;</span>  to construct in time  <span class="math">T&#x27; \\leq T</span>  two  <span class="math">N</span> -tuples  <span class="math">\\mathcal{X}&#x27; = (X_i&#x27;)</span>  and  <span class="math">\\mathcal{Y}&#x27; = (Y_i&#x27;)</span>  such that  <span class="math">Y_i&#x27; = \\Pi(X_i&#x27;)</span> ,  <span class="math">i = 1, \\dots, N</span>  and  <span class="math">\\mathcal{X}&#x27;\\mathcal{R}\\mathcal{Y}&#x27;</span>  with a success probability  <span class="math">p&#x27; \\geq 1/2</span>  over  <span class="math">\\Pi</span>  and the random choices of  <span class="math">\\mathcal{A}&#x27;</span> . The computing time  <span class="math">T&#x27;</span>  of  <span class="math">\\mathcal{A}&#x27;</span>  is measured as an equivalent number of computations of  <span class="math">E</span> , with the convention that the time needed for one oracle query to  <span class="math">\\Pi</span>  or  <span class="math">\\Pi^{-1}</span>  is equal to 1. Thus if  <span class="math">q&#x27;</span>  denotes the number of queries of  <span class="math">\\mathcal{A}&#x27;</span>  to  <span class="math">\\Pi</span>  or  <span class="math">\\Pi^{-1}</span> , then  <span class="math">q&#x27; \\leq T&#x27;</span> .</p>

    <p class="text-gray-300">Definition 7. Let  <span class="math">E: (K, X) \\in \\{0,1\\}^k \\times \\{0,1\\}^n \\to E_K(X) \\in \\{0,1\\}^n</span>  denote a block cipher of block size  <span class="math">n</span>  bits. A known-key distinguisher  <span class="math">(\\mathcal{R}, \\mathcal{A})</span>  of order  <span class="math">N \\geq 1</span>  consists of (1) a relation  <span class="math">\\mathcal{R}</span>  over the  <span class="math">N</span> -tuples of  <span class="math">n</span> -bit blocks (2) an algorithm  <span class="math">\\mathcal{A}</span>  that on input a  <span class="math">k</span> -bit key  <span class="math">K</span>  produces in time  <span class="math">T_{\\mathcal{A}}</span> , i.e. in time equivalent with  <span class="math">T_{\\mathcal{A}}</span>  computations of  <span class="math">E</span> , an  <span class="math">N</span> -tuple  <span class="math">\\mathcal{X} = (X_i)</span> <span class="math">i = 1, \\dots, N</span>  of plaintext blocks and an  <span class="math">N</span> -tuple  <span class="math">\\mathcal{Y} = (Y_i)</span> <span class="math">i = 1, \\dots, N</span>  of ciphertext blocks related by  <span class="math">Y_i = E_K(X_i)</span>  and by  <span class="math">\\mathcal{X}\\mathcal{R}\\mathcal{Y}</span> . The two following conditions must be met:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The relation  <span class="math">\\mathcal{R}</span>  must be  <span class="math">T_{\\mathcal{A}}</span> -intractable relatively to  <span class="math">E</span> ;</li>

      <li>The validity of  <span class="math">\\mathcal{R}</span>  must be efficiently checkable: we formalize this requirement by incorporating the time for checking whether two  <span class="math">N</span> -tuples are related by  <span class="math">\\mathcal{R}</span>  in the computing time  <span class="math">T_{\\mathcal{A}}</span>  of algorithm  <span class="math">\\mathcal{A}</span> .</li>

    </ul>

    <p class="text-gray-300">We emphasize that while the algorithm  <span class="math">\\mathcal{A}</span>  takes a random key  <span class="math">K</span>  as input, the relation  <span class="math">\\mathcal{R}</span>  satisfies by the  <span class="math">N</span> -tuples of input and output blocks constructed by  <span class="math">\\mathcal{A}</span>  or  <span class="math">\\mathcal{A}&#x27;</span>  is the same for all values of  <span class="math">K</span>  (in other words, it is independent of  <span class="math">K</span> ) and must be efficiently checkable without knowing  <span class="math">K</span> .</p>

    <p class="text-gray-300">To better understand these definitions, we propose and describe in more details a generic scenario for a known-key distinguisher, which is depicted in Fig. 1. This scenario is composed of five characters, which are a key generator, an oracle, two players and a verifier. First of all - step (0), we assume that a relation  <span class="math">\\mathcal{R}</span>  defined as in Def. 6 is chosen. At step (1), the key generator generates a key, which is given to the oracle and to one of the two</p>

    <p class="text-gray-300">New and Old Limits for AES Known-Key Distinguishers</p>

    <p class="text-gray-300">Table 2: Details of AES known-key distinguishers presented in this paper, obtained by extending distinguishers based on Multiple Differential Trails. "Rounds" denotes the number of rounds of the basic distinguisher + the number of rounds of the extensions (if even, the number of extension rounds is equal at the end and at the beginning). "Cost Case 1" denotes the cost of the shortcut player when the total cost of the generic player is approximated by the number of oracle-queries, while "Cost Case 2" refers to the case in which the total cost of the generic player is the sum of number of queries and of its computational cost. "Cost Verifier" denotes the cost of the verifier. A check-mark  <span class="math">\\checkmark</span>  in the "KS" column denotes the case in which the key schedule holds,  <span class="math">\\times</span>  denotes the case in which the sub-keys are independent, while white-space/no-mark denotes the case in which the two previous cases are equivalent (for the distinguisher purposes).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">KS</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cost Case 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cost Case 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cost Verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Memory</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Reference</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7 + 1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">223</td>

            <td class="px-3 py-2 border-b border-gray-700">221</td>

            <td class="px-3 py-2 border-b border-gray-700">211.8</td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">App. E.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8 + 1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">250</td>

            <td class="px-3 py-2 border-b border-gray-700">245.6</td>

            <td class="px-3 py-2 border-b border-gray-700">211.6</td>

            <td class="px-3 py-2 border-b border-gray-700">232</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect. 7 - App. D.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7 + 2</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">223</td>

            <td class="px-3 py-2 border-b border-gray-700">221</td>

            <td class="px-3 py-2 border-b border-gray-700">212.6</td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">App. E.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7 + 2</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">221</td>

            <td class="px-3 py-2 border-b border-gray-700">221</td>

            <td class="px-3 py-2 border-b border-gray-700">212.6</td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">App. E.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8 + 2</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">250</td>

            <td class="px-3 py-2 border-b border-gray-700">245.6</td>

            <td class="px-3 py-2 border-b border-gray-700">212.5</td>

            <td class="px-3 py-2 border-b border-gray-700">232</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect. 8.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8 + 2</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">246</td>

            <td class="px-3 py-2 border-b border-gray-700">245</td>

            <td class="px-3 py-2 border-b border-gray-700">212.5</td>

            <td class="px-3 py-2 border-b border-gray-700">232</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect. 8.2 - App. D.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8 + 4</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">282</td>

            <td class="px-3 py-2 border-b border-gray-700">282</td>

            <td class="px-3 py-2 border-b border-gray-700">271.1</td>

            <td class="px-3 py-2 border-b border-gray-700">232</td>

            <td class="px-3 py-2 border-b border-gray-700">Sect. 9</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">player. For the following, we call "shortcut player" the player that knows the key and "generic player" the player that doesn't know it. Referring to the previous definitions by Gilbert, the generic player can be identified with the algorithm  <span class="math">\\mathcal{A}&#x27;</span> , while the shortcut player can be identified with the algorithm  <span class="math">\\mathcal{A}</span> . At step (2), the two players generate the  <span class="math">N</span> -tuple of (plaintexts, ciphertexts) which satisfy the required relation  <span class="math">\\mathcal{R}</span> . Since the generic player doesn't know the key, he must ask the oracle (identified with  <span class="math">\\Pi</span>  and/or  <span class="math">\\Pi^{-1}</span>  in the previous definitions) for the encryption (resp. decryption) of random plaintexts (resp. ciphertexts). In the more general case, the oracle can generate the ciphertexts (resp. the plaintexts) using a random permutation instead of the encryption (resp. decryption) process. We stress that this step doesn't consist only on the generation of (plaintext, ciphertext) pairs, but also includes any computational cost that the player must do in order to find the  <span class="math">N</span> -tuple with the required property. When a player finds the  <span class="math">N</span> -tuple which satisfies the required relation  <span class="math">\\mathcal{R}</span> , he sends it to the verifier - step (3). The verifier finally checks if the  <span class="math">N</span> -tuple satisfied the relation  <span class="math">\\mathcal{R}</span>  (remember that the verifier doesn't know the key). The first/fastest player who sends the  <span class="math">N</span> -tuple with the required property wins the "game".</p>

    <p class="text-gray-300">Before going on, we emphasize that the role of the verifier is only to prevent one or both of the two players from cheating. In other words, in the case of honest players, the verifier can be omitted, and the winner of the game is simply the first/fastest player that claims to have found the  <span class="math">N</span> -tuple of (plaintexts, ciphertexts) which satisfy the required relation  <span class="math">\\mathcal{R}</span> . We highlight that such a verifier is implicitly present in all the distinguishers currently present in literature.</p>

    <p class="text-gray-300">A distinguisher is meaningful if the cost of the generic player - we assume that the cost of one oracle-query is equal to the cost of one encryption - to generate the  <span class="math">N</span> -tuple is higher than the cost of the shortcut player, when the probability of success is equal for the two players. Equivalently, a distinguisher is meaningful if the probability of the generic player to win the game is higher than the probability of the shortcut player, when the number of tuples of (plaintexts, ciphertexts) that the two players can generate is fixed and equal for both players. In other words, in the first case one considers the computational costs of the</p>

    <p class="text-gray-300">Lorenzo Grassi ^{1} and Christian Rechberger ^{1,2}</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: 7- and 8-round differential paths for AES-128.</p>

    <p class="text-gray-300">two players to generate the  <span class="math">N</span> -tuples with a fixed probability of success (equal for both the players). In the second case, the computational cost (equivalent to the number of oracle queries for the generic player and the number of  <span class="math">N</span> -tuple generated by the shortcut one) is fixed and one considers the probabilities of success of the two players to win the game.</p>

    <p class="text-gray-300">Both for the distinguisher that we are going to present and for the Gilbert's one, the computational cost of the verification step is not negligible. Thus, in order to compare our distinguishers to the others present in literature, we define the cost of the distinguisher as the sum of the cost of the verification step (i.e. the cost of the verifier) and of the cost to construct the set of plaintexts/ciphertexts with the required property (that is, the cost of the shortcut player - the cost of the other player is higher). For this reason, we assume for the following that a relationship  <span class="math">\\mathcal{R}</span>  is efficiently checkable if and only if the computational cost of the verifier is negligible with respect to the player ones. This implies that the cost of the distinguisher can be approximated with the computational cost of the shortcut player (the cost of the other player is always higher). Moreover, this assumption prevents the construction of meaningless known-key distinguishers, as discussed in Sect. 11.</p>

    <p class="text-gray-300">Table 2 summarizes the main details of all the known-key distinguishers based on Multiple Differential Trails presented in this paper with respect to the above scenario. To better understand this table, some considerations must be done. Since the generic player depends by the oracle to generate the  <span class="math">N</span> -tuple (i.e. he cannot work alone to generate it), two possible settings can be analyzed. In the first one, only the number of oracle queries is considered to determine the computational cost of this player, that is the number of encryptions/decryptions required by the generic player to the oracle - this case is denoted by "Case 1" in Table 2. In the second one, both the number of oracle queries and any other computational cost of the generic player (which is in general not negligible) are considered - this case is denoted by "Case 2" in Table 2. Intuitively this second setting is weaker than the first one, in the sense that a known-key distinguisher in the first setting works also in the second one but not viceversa. In other words, one can expect that the required number  <span class="math">N</span>  of tuples is higher in the first setting than in the second one (or equal in the best case). If the total cost of the generic player is well approximated by the number of queries, these two settings are completely equivalent. In the following, we recall the known-key distinguishers present in literature in the above scenario.</p>

    <p class="text-gray-300">In the 7- and 8-round known-key distinguishers proposed in [MPRS09] and [GP10], the goal of the two players is to find two pairs of (plaintexts, ciphertexts) - i.e.  <span class="math">(p^1, c^1)</span>  and  <span class="math">(p^2, c^2)</span>  - with the following properties: the two plaintexts belong to the same coset of  <span class="math">\\mathcal{D}_i</span>  - i.e.  <span class="math">p^1 \\oplus p^2 \\in \\mathcal{D}_i</span>  - and the two ciphertexts belong to the same coset of  <span class="math">\\mathcal{M}_i</span>  - i.e.  <span class="math">c^1 \\oplus c^2 \\in \\mathcal{M}_i</span>  - for a fixed  <span class="math">i \\in \\{0, 1, 2, 3\\}</span> .</p>

    <p class="text-gray-300">In the above known-key distinguisher setting, the best technique that the shortcut player (i.e. the player who knows the key) can use to win the game is the Rebound Attack. The rebound attack is a differential attack and it was proposed in [MRST09] for the cryptanalysis of AES-based hash functions. Since it is a differential attack, one needs a "good" (truncated) differential trail in order to exploit it. Examples of truncated differential</p>

    <p class="text-gray-300">New and Old Limits for AES Known-Key Distinguishers</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: 8-round differential characteristic for known-key distinguisher of AES-128.</p>

    <p class="text-gray-300">trails used for 7- and 8-round AES are depicted in Fig. 2. The rebound attack consists of two phases, called inbound and outbound phase. In the first one, the attacker uses the knowledge of the key to find pairs of texts that satisfy the middle rounds of the truncated differential trail. In the second one, he propagates the solutions found in the first phase in the forward and in the backward directions, and checks if at least one of them satisfies the entire differential trail. A complete description of the rebound attack is given in App. B, with particular attention to the AES case.</p>

    <p class="text-gray-300">As proved in [GP10], in the case of a perfect random permutation  <span class="math">2^{64}</span>  operations are required to find (plaintexts, ciphertexts) pairs  <span class="math">(p_1, c_1)</span>  and  <span class="math">(p_2, c_2)</span>  that have the required properties with good probability. Instead, for the AES case and using the rebound attack,  <span class="math">2^{48}</span>  computations are sufficient to find them with the same probability (besides a memory cost of  <span class="math">16 \\times 2^{32} = 2^{36}</span>  bytes).</p>

    <p class="text-gray-300">An improvement of the previous known-key distinguisher on 8-round of AES was proposed in [JNPP14]. Using the subspace trail notation, in this modified version of the 8-round known-key distinguisher, the goal of the two players is to find two pairs of (plaintexts, ciphertexts) such that the two plaintexts belong to the same coset of  <span class="math">\\mathcal{D}_i</span>  for an arbitrary  <span class="math">i</span>  and the two ciphertexts belong to the same coset of  <span class="math">\\mathcal{M}_j</span>  for an arbitrary  <span class="math">j</span> , where  <span class="math">i</span>  and  <span class="math">j</span>  are not fixed in advance and it is not required that they are equal (i.e. no condition is imposed on  <span class="math">i</span>  and  <span class="math">j</span> ) - an example is given in Fig. 3. For arbitrary initial and final subspaces, the computational cost is reduced from  <span class="math">2^{48}</span>  to  <span class="math">2^{44}</span>  (note that there are 4 initial and final different subspaces  <span class="math">\\mathcal{D}_i</span>  and  <span class="math">\\mathcal{M}_j</span> , for a total of  <span class="math">4^2 = 2^4</span>  possibilities) while the required memory is still  <span class="math">2^{32}</span> , as shown in detail in [JNPP14]. In App. E.1 we show that the same technique can be used to improve the 7-round known-key distinguisher of AES presented in [MPRS09].</p>

    <p class="text-gray-300">Another 8-round known-key distinguisher for AES is based on the uniform distribution property and it was proposed by Gilbert in [Gil14]. In this case, the goal of the two players is to find a set of  <span class="math">2^{64}</span>  (plaintext, ciphertext) pairs - that is  <span class="math">(p^i, c^i)</span>  for  <span class="math">i = 0, \\dots, 2^{64} - 1</span>  with the following properties:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- for each  <span class="math">K \\subseteq \\{0,1,2,3\\}</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 3<span class="math">  the plaintexts are uniform distributed in cosets of the diagonal space  </span>\\mathcal{D}_K<span class="math">  - equivalently, for each  </span>K<span class="math">  with  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 3<span class="math">  and for each  </span>a \\in \\mathcal{D}_K^\\perp<span class="math">  there are  </span>2^{32}<span class="math">  plaintexts  </span>p^j<span class="math">  for  </span>j \\in J \\subseteq \\{0,\\dots,2^{64} - 1\\}<span class="math">  with  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{32}<span class="math">  such that  </span>p^j \\in \\mathcal{D}_K \\oplus a<span class="math">  for all  </span>j \\in J$ ;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lorenzo Grassi¹ and Christian Rechberger¹,²</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- for each <span class="math">K \\subseteq \\{0,1,2,3\\}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 3<span class="math"> the ciphertexts are uniform distributed in cosets of the mixed space </span>\\mathcal{M}_K<span class="math"> - equivalently, for each </span>K<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 3<span class="math"> and for each </span>a \\in \\mathcal{M}_K^+<span class="math"> there are </span>2^{32}<span class="math"> ciphertexts </span>c^j<span class="math"> for </span>j \\in J \\subseteq \\{0,\\dots,2^{64} - 1\\}<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{32}<span class="math"> such that </span>c^j \\in \\mathcal{M}_K \\oplus a<span class="math"> for all </span>j \\in J$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If the final MixColumns is omitted, an equivalent condition holds on the ciphertexts by replaying the mixed space <span class="math">\\mathcal{M}_K</span> with the inverse-diagonal one <span class="math">\\mathcal{ID}_K</span>.</p>

    <p class="text-gray-300">In the case in which the final MixColumns operation is omitted, it is possible to reformulate the goal of the two players as following: find a set of <span class="math">2^{64}</span> (plaintext, ciphertext) pairs - that is <span class="math">(p^i, c^i)</span> for <span class="math">i = 0, \\dots, 2^{64} - 1</span> - such that the bytes of the plaintexts and the ciphertexts are uniform distributed, that is:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- for each <span class="math">j, k = 0, 1, 2, 3</span> and for each <span class="math">x \\in \\mathbb{F}_{2^k}</span>, there are <span class="math">2^{56}</span> plaintexts <span class="math">p^i</span> for <span class="math">i \\in I \\subseteq \\{0, \\dots, 2^{64} - 1\\}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{56}<span class="math"> that satisfy </span>p_{j,k}^i = x<span class="math"> for all </span>i \\in I$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We prove that these two properties are equivalent for the ciphertexts (the same argumentation applies on the plaintexts as well). First of all, if the bytes of the ciphertexts are uniform distributed, then the ciphertexts are uniform distributed in cosets of the inverse-diagonal space <span class="math">\\mathcal{ID}_K</span> for each <span class="math">K</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 3<span class="math"> by definition of </span>\\mathcal{ID}_K<span class="math">. Viceversa, consider the case in which the ciphertexts are uniform distributed in cosets of </span>\\mathcal{ID}_K<span class="math"> for each </span>K<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 3<span class="math">. By definition, there are </span>2^{32}<span class="math"> ciphertexts </span>\\tilde{c}^i<span class="math"> with </span>i \\in I \\subseteq \\{0, \\dots, 2^{64} - 1\\}<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{32}<span class="math"> that belong to the same coset of </span>\\mathcal{ID}_{0,1,2} \\oplus a<span class="math"> for a certain </span>a \\in \\mathcal{ID}_{0,1,2}^+<span class="math"> (equivalent for the other spaces </span>\\mathcal{ID}_K<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 3<span class="math">). By definition, </span>a \\in \\mathcal{ID}_{0,1,2}^+<span class="math"> if and only if </span>a_{k,j} = 0<span class="math"> for </span>(k,j) \\neq (0,3), (1,2), (2,1), (3,0)<span class="math">, i.e. for each </span>k + j \\neq 3<span class="math">. In other words, </span>\\tilde{c}^i \\in \\mathcal{ID}_{0,1,2} \\oplus a<span class="math"> for each </span>i \\in I<span class="math"> if and only if </span>\\tilde{c}_{k,j}^i = a_{k,j}<span class="math"> for each </span>i \\in I<span class="math"> and for each </span>k + j = 3<span class="math">. Working independently on each byte, it follows that the bytes of </span>c^i<span class="math"> are uniform distributed (for example, working on the first byte and considering all </span>a \\in \\mathcal{ID}_{0,1,2}^+<span class="math"> with </span>a_{0,3}<span class="math"> fixed, it follows that there are </span>2^{24} \\cdot 2^{32} = 2^{56}<span class="math"> ciphertexts </span>c^i<span class="math"> s.t. </span>c_{0,3}^i = a_{0,3}$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For completeness, note that the property of uniform distribution doesn't survive the final MixColumns matrix<span class="math">^5</span>. If the final MixColumns is not omitted, the goal of the two players becomes to find a set of <span class="math">2^{64}</span> (plaintext, ciphertext) pairs - that is <span class="math">(p^i, c^i)</span> for <span class="math">i = 0, \\dots, 2^{64} - 1</span> - such that the bytes of the <span class="math">p^i</span> and of <span class="math">MC^{-1}(c^i)</span> are uniform distributed. On the other hand, we highlight that the uniform distribution implies the balance/zero-sum property both on the plaintexts and on the ciphertexts, and that the balance property is not destroyed by the (final) MixColumns operation (since this operation is linear). For completeness, we remember that texts <span class="math">\\{t^i\\}_{i \\in I}</span> have the balance property if <span class="math">\\bigoplus_{i \\in I} t^i = 0</span>.</p>

    <p class="text-gray-300">The Strategy of the Shortcut Player. Here, we briefly recall the best strategy that the shortcut player can use to win the game using the subspace trails notation instead of the Super-SB notation (Super-SB(·) ≡ S-Box ∘ ARK ∘ MC ∘ S-Box(·)) - we refer to App. C for all the details. The idea is to start in the middle with a set <span class="math">S</span> of texts defined</p>

    <p class="text-gray-300"><span class="math">^5</span>We highlight that distinguisher proposed by Gilbert is in the case in which the final MixColumns is omitted. Indeed, in [Gil14] - Sect. 2: [...] to refer to the variant of AES<span class="math">_r</span> where the MixColumns transformation is kept in the last round: we will denote this variant by AES<span class="math">_{r+}</span>. The distinguishjer proposed in [Gil14] are for AES<span class="math">_8</span> and AES<span class="math">_{10}</span> and not AES<span class="math">_{8+}</span> and AES<span class="math">_{10+}</span>. Moreover, consider the following fact. In the untwisted representation proposed by Gilbert, AES<span class="math">_{2r+}</span> is equivalent to AES<span class="math">_{2r+} \\equiv FP \\circ (R \\circ S)^r \\circ IP \\circ AK</span> while AES<span class="math">_{2r} \\equiv AK \\circ SR \\circ P \\circ S \\circ (R \\circ S)^{r-1} \\circ IP \\circ AK</span>, where <span class="math">S, R, \\ldots</span> are defined in [Gil14]. In Property 1 of Sect. 4 of [Gil14], it is proved that the bytes of the encryption of each coset of <span class="math">\\mathcal{C}_i</span> under <span class="math">S \\circ R \\circ S</span> are uniform distributed. Due to the previous representation, this is equivalent to consider 4 rounds of AES without the final MixColumns.</p>

    <p class="text-gray-300">New and Old Limits for AES Known-Key Distinguishers</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">as <span class="math">S := \\mathcal{D}_i \\oplus \\mathcal{M}_j \\oplus c</span> for a constant <span class="math">c</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{64}$. Observe that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{D}_i \\oplus \\mathcal{M}_j \\oplus c \\equiv \\bigcup_{b \\in \\mathcal{D}_i \\oplus c} \\mathcal{M}_j \\oplus b = \\bigcup_{a \\in \\mathcal{M}_j \\oplus c} \\mathcal{D}_i \\oplus a,</span></div>

    <p class="text-gray-300">i.e. the set <span class="math">S</span> can be re-written as union of cosets of the space <span class="math">\\mathcal{D}_i</span> or as union of cosets of the space <span class="math">\\mathcal{M}_j</span>. The ciphertexts are given by the 4-round encryption of <span class="math">S</span>, while the plaintexts by the 4-round decryption of <span class="math">S</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">After encrypting <span class="math">S</span> for 4 rounds, the texts are uniform distributed in each coset of <span class="math">\\mathcal{M}_I</span> of dimension 12 (i.e. $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 3<span class="math">). That is, after 4 rounds, each coset of </span>\\mathcal{M}_I<span class="math"> for </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 3<span class="math"> contains exactly </span>2^{32}<span class="math"> elements. Indeed, by Theorem 2 note that given two elements in the same coset of </span>\\mathcal{D}_I<span class="math">, they can not belong to the same coset of </span>\\mathcal{M}_J<span class="math"> for </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 4<span class="math"> after 4-round. Thus, given a coset of </span>\\mathcal{D}_i<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math">, after 4 rounds each element is distributed in a different cosets of </span>\\mathcal{M}_J<span class="math"> for </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 3<span class="math">. Since a coset of </span>\\mathcal{D}_i<span class="math"> contains </span>2^{32}<span class="math"> elements and since there are exactly </span>2^{32}<span class="math"> cosets of </span>\\mathcal{M}_J<span class="math">, the elements of </span>\\mathcal{D}_i \\oplus \\mathcal{M}_j<span class="math"> are uniformly distributed in each coset of </span>\\mathcal{M}_I<span class="math">. The same happens if one decrypts </span>S<span class="math"> for 4 rounds. In this case, after decrypting </span>S<span class="math"> for 4 rounds, the texts are uniform distributed in each coset of </span>\\mathcal{D}_I<span class="math"> of dimension 12 (i.e. </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 3<span class="math">), that is each coset of </span>\\mathcal{D}_I<span class="math"> for </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 3<span class="math"> contains exactly </span>2^{32}$ elements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">On the Meaningfulness of this Distinguisher. For the following, we briefly recall the argumentation given by Gilbert about the meaningfulness of such distinguisher.</p>

    <p class="text-gray-300">First of all, <span class="math">2^{64}</span> texts satisfy the uniform distribution on each byte with probability</p>

    <div class="my-4 text-center"><span class="math-block">p = \\left(\\prod_{i=0}^{255} \\binom{2^{64} - i \\cdot 2^{56}}{2^{56}} \\cdot \\left(2^{-8}\\right)^{2^{64}}\\right)^{16}.</span></div>

    <p class="text-gray-300">Indeed, consider the following problem. Given <span class="math">N</span> texts and 2 sets, assume that each text belongs to one of the two sets with probability <span class="math">2^{-1}</span>. It follows that the <span class="math">N</span> texts are uniform distributed among the two sets with prob. <span class="math">\\binom{N}{N/2} \\cdot 2^{-N}</span>. In a similar way, given <span class="math">d \\geq 2</span> sets, they are uniform distributed with probability <span class="math">\\left(\\prod_{i=0}^{d-1} \\binom{N-i \\cdot N/d}{N/d} \\cdot d^{-N}\\right)</span>.</p>

    <p class="text-gray-300">Using Stirling's formula <span class="math">n! \\simeq n^n \\cdot e^{-n} \\cdot \\sqrt{2\\pi \\cdot n}</span>, the previous probability is well approximated by</p>

    <div class="my-4 text-center"><span class="math-block">p = \\left(\\frac{2^{64}!}{\\left(2^{56!}\\right)^{256}} \\cdot \\left(2^{-8}\\right)^{2^{64}}\\right)^{16} \\simeq \\left(\\frac{1}{2^{49} \\cdot \\pi}\\right)^{128} \\cdot \\left(256!\\right)^{-1/2} \\simeq 2^{-7328.1} \\equiv 2^{-2^{12.84}}. \\tag{5}</span></div>

    <p class="text-gray-300">In other words, given <span class="math">2^{64}</span> plaintexts whose bytes are uniform distributed, this represents the probability that the bytes of the corresponding ciphertexts are uniform distributed. For comparison, given <span class="math">2^{64}</span> plaintexts whose sum is zero, then the sum of the corresponding ciphertexts is equal to zero with probability <span class="math">2^{-128}</span>.</p>

    <p class="text-gray-300">What is the minimum number <span class="math">N \\equiv 2^{64} + M &amp;gt; 2^{64}</span> of - random - (plaintext, ciphertext) pairs such that there is a subset of <span class="math">2^{64}</span> pairs whose bytes are uniform distributed both on the plaintexts and on the ciphertexts with non-negligible property? Given <span class="math">2^{64} + M</span> texts, it is possible to construct</p>

    <div class="my-4 text-center"><span class="math-block">\\binom{2^{64} + M}{2^{64}} \\simeq \\frac{1}{\\sqrt{2\\pi \\cdot M}} \\cdot \\left(\\frac{2^{64} + M}{M}\\right)^M</span></div>

    <p class="text-gray-300">6Consider the case <span class="math">N = 2^{64}</span> and <span class="math">d = 256</span>. The product of the binomial coefficients is explained as follows. For each one of the 16 bytes, there must exist <span class="math">2^{64}/256 = 2^{56}</span> texts for each one of the 256 possible values. Thus, there are <span class="math">\\binom{2^{64}}{2^{56}}</span> possible sets of <span class="math">2^{56}</span> texts for each the byte as value 0, <span class="math">\\binom{2^{64}-2^{56}}{2^{56}}</span> possible sets of <span class="math">2^{56}</span> texts for each the byte as value 1 and so on.</p>

    <p class="text-gray-300">Lorenzo Grassi and Christian Rechberger</p>

    <p class="text-gray-300">different sets of  <span class="math">2^{64}</span>  texts (where the approximation is given using the Stirling's formula and by the assumption  <span class="math">M \\ll 2^{64}</span> ). This number is always higher than  <span class="math">p^{-2} \\equiv 2^{2^{13.84}}</span>  for each  <span class="math">M \\geq 2^{12}</span> . In other words, given  <span class="math">2^{64} + 2^{12}</span>  random pairs, there is a good probability to find  <span class="math">2^{64}</span>  (plaintext, ciphertext) pairs such that the bytes of the plaintexts and of the ciphertexts are uniform distributed. It follows that if the cost of the generic player is approximated by the number of oracle queries, then his cost is approximately of  <span class="math">2^{64} + 2^{12} \\simeq 2^{64}</span>  encryptions vs  <span class="math">2^{64}</span>  encryption of the shortcut player.</p>

    <p class="text-gray-300">So, why is this distinguisher meaningful? Instead to focus on the cost of the players, Gilbert shows that the probability of the generic player to win the game given  <span class="math">2^{64}</span>  texts is negligible. To do this, Gilbert claims that this probability is upper bounded by the probability of the following game: given  <span class="math">2^{64} - 1</span>  (plaintext, ciphertext) pairs whose bytes are "almost uniform" - see the definition in the following, find a text for which the bytes of the corresponding  <span class="math">2^{64}</span>  texts are uniform distributed. Since this probability is upper bounded by  <span class="math">2^{-127}</span>  - see proof of Prop. 4 of [Gil14] - and since this second game is (strong) "related" to the original one <span class="math">^7</span> , the conclusion follows immediately.</p>

    <p class="text-gray-300">For completeness, we formal define what "almost uniform" means. Consider  <span class="math">2^{64} - 1</span>  texts  <span class="math">t^i \\in \\mathbb{F}_{2^8}^{4 \\times 4}</span>  for  <span class="math">i = 0, \\dots, N - 2</span> . We say that the bytes of  <span class="math">2^{64} - 1</span>  texts  <span class="math">t^i</span>  are "almost uniform" if for each row and column  <span class="math">j, k = 0, 1, 2, 3</span>  (1) there exists  <span class="math">x \\in \\mathbb{F}_{2^8}</span>  s.t. there are  <span class="math">2^{56} - 1</span>  texts that satisfy  <span class="math">t_{j,k}^i = x</span>  and (2) for each  <span class="math">y \\in \\mathbb{F}_{2^8} \\setminus x</span> , there are  <span class="math">2^{56}</span>  texts that satisfy  <span class="math">t_{j,k}^i = y</span> . More generally:</p>

    <p class="text-gray-300">Definition 8. Consider  <span class="math">2^{N} - d</span>  texts  <span class="math">t^i \\in \\mathbb{F}_{2^8}^{4 \\times 4}</span>  for  <span class="math">i = 0, \\dots, N - d - 1</span>  for  <span class="math">d \\geq 1</span> . We say that the bytes of  <span class="math">2^{N} - 1</span>  texts  <span class="math">t^d</span>  are "almost uniform" if for each row and column  <span class="math">j, k = 0, 1, 2, 3</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there exists a set  <span class="math">X \\equiv \\{x_1, \\dots, x_s \\in \\mathbb{F}_{2^8}\\}</span>  with cardinality  <span class="math">s \\leq d</span>  such that for each  <span class="math">x_l \\in X</span>  with  <span class="math">1 \\leq l \\leq s</span>  there are  <span class="math">2^{N - 8} - d \\leq \\hat{s}_l \\leq 2^{N - 8} - s</span>  texts that satisfy  <span class="math">t_{j,k}^i = x_l</span>  where  <span class="math">\\sum_{l=1}^{s} \\hat{s}_l = d</span> ;</li>

      <li>for each  <span class="math">y \\in \\mathbb{F}_{2^8} \\setminus X</span> , there are  <span class="math">2^{N - 8}</span>  texts that satisfy  <span class="math">t_{j,k}^i = y</span> .</li>

    </ul>

    <p class="text-gray-300">Proposition 1. Consider a set of  <span class="math">2^{N}</span>  texts whose bytes are uniform distributed. The bytes of each subset of  <span class="math">2^{N} - d</span>  texts are "almost uniform" distributed w.r.t. the previous definition.</p>

    <p class="text-gray-300">This distinguisher is the starting point used by Gilbert in order to set up the first 10-round known-key distinguisher for AES. The basic idea is to extend this 8-round distinguisher based on the uniform distribution property adding one round at the end and one at the beginning. Assume for simplicity that the final MixColumns is omitted. In the known-key distinguisher scenario presented above, the players have to send to the verifier  <span class="math">2^{64}</span>  (plaintext, ciphertext) pairs, that is  <span class="math">(p^i, c^i)</span>  for  <span class="math">i = 0, \\dots, 2^{64} - 1</span> , with the following properties:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. there exists a key  <span class="math">k^0</span>  s.t. the bytes of  <span class="math">\\{R_{k^0}(p^i)\\}_i</span>  are uniform distributed, or equivalently that the texts  <span class="math">\\{R_{k^0}(p^i)\\}_i</span>  are uniform distributed among the cosets of  <span class="math">\\mathcal{D}_I</span>  for each  <span class="math">I</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 3$ ;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">New and Old Limits for AES Known-Key Distinguishers</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. there exists a key <span class="math">k^{10}</span> s.t. the bytes of <span class="math">\\{MC^{-1} \\circ R_{k^{10}}^{-1}(c^i)\\}_i</span> are uniform distributed, or equivalently that the texts <span class="math">\\{R_{k^{10}}^{-1}(c^i)\\}_i</span> are uniform distributed among the cosets of <span class="math">\\mathcal{M}_J</span> for each <span class="math">J</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 3$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">MC^{-1}</span> denotes the inverse MixColumns operation. In this game, the subkeys <span class="math">k^0</span> and <span class="math">k^{10}</span> are assumed to be independent (argumentations are given by Gilbert to show that the same distinguisher is applicable also to the case in which the key-schedule holds - we discuss this topic in details in the following).</p>

    <p class="text-gray-300">Since uniform distribution implies balance property - viceversa is not true in general, if the previous properties are satisfied then for the key <span class="math">k^0</span> the sum of the plaintexts after one round is equal to zero, i.e. <span class="math">\\bigoplus_{i=0}^{2^{64}-1} R_{k^0}(p^i) = 0</span>, and for the key <span class="math">k^{10}</span> the sum of the ciphertexts one round before is equal to zero, i.e. <span class="math">\\bigoplus_{i=0}^{2^{64}-1} R_{k^{10}}^{-1}(c^i) = 0</span>.</p>

    <p class="text-gray-300">We emphasize that even if this is a known-key distinguisher, the verifier must be able to check the previous properties without the knowledge of the key or the subkeys. Since the verifier has no information of the key, one must show that the above conditions are efficiently checkable. The only way to verify these requirements is to find these two subkeys in an efficient way, which is not possible using a brute force attack (<span class="math">k^0</span> and <span class="math">k^{10}</span> have 128 bits). Instead to check all the <span class="math">2 \\cdot 2^{128} = 2^{129}</span> possible values of <span class="math">k^0</span> and <span class="math">k^{10}</span>, the idea proposed by Gilbert is to check uniform distribution working on single columns of <span class="math">SR(c^i)</span> and of <span class="math">SR^{-1}(p^i)</span> (the strategy proposed by Gilbert<span class="math">^9</span> is similar to the one proposed in Algorithm 1). In this way, the verifier must guess only 32 bits instead of 128, and she has to repeat this operation 4 times (one for each anti-diagonal/diagonal) for each key. In the following, we discuss a way to improve this procedure working independently on each byte of <span class="math">k^0</span> and <span class="math">k^{10}</span> instead of entire anti-diagonal/diagonal. The idea is simply to use integral attack [DKR97]-[KW02] to filter wrong keys.</p>

    <p class="text-gray-300">In conclusion, the shortcut player (i.e. the one who knows the key) can construct these <span class="math">2^{64}</span> (plaintext, ciphertext) pairs using the same strategy proposed for the 8 rounds distinguisher (note that in this case the keys <span class="math">k^0</span> and <span class="math">k^{10}</span> correspond to the secret sub-keys). Instead, as proved by Gilbert in Prop. 6 of [Gil14], the probability that the generic player (i.e. the one who doesn't know the secret key) successfully outputs (input, output) pairs that satisfy the previous properties (both in the input and in the output) is upper bounded by <span class="math">2^{-16.5}</span>. Finally, the verifier can find the keys <span class="math">k^0</span> and <span class="math">k^{10}</span> that satisfy the required property (if exist) with a computational cost which is smaller than the cost of the two players.</p>

    <p class="text-gray-300">On the Meaningfulness of this Distinguisher. For the following, we briefly recall the argumentation given by Gilbert about the meaningfulness of this distinguisher.</p>

    <p class="text-gray-300">First of all, what is the probability that given a set of <span class="math">2^{64}</span> texts there exists a key <span class="math">\\hat{k}</span> such that the bytes of 1-round encryption (resp. decryption) of such texts are uniform distributed? Using the previous calculation and since there are <span class="math">2^{128}</span> different keys, this probability is equal to <span class="math">2^{128} \\cdot p \\simeq 2^{128} \\cdot 2^{-7328.1} = 2^{-7200.1} \\equiv 2^{-2^{12.81}}</span> where <span class="math">p</span> is defined in (5). Similar to the 8-round case, it follows that <span class="math">2^{64} + 2^{12} \\simeq 2^{64}</span> (plaintext, ciphertext) pairs are sufficient to have good probability to win the game.</p>

    <p class="text-gray-300">So, as before, why is this distinguisher meaningful? As for the 8-round case, instead to focus on the cost of the players, Gilbert shows that the probability of the generic player to win the game given <span class="math">2^{64}</span> texts is negligible. To do this, Gilbert claims that this probability is upper bounded by the probability of the following game. Consider <span class="math">2^{64} - d</span> (plaintext,</p>

    <p class="text-gray-300"><span class="math">^9</span>Algorithm 1 is presented in order to propose a 12-round distinguisher based on the uniform distribution property as extension of 10-round Gilbert's distinguisher. The difference between this algorithm and the one proposed by Gilbert is the fact that in our case some wrong-key candidates can be eliminated using the zero-sum property. In other words, in order to turn our algorithm in the one proposed by Gilbert, it is sufficient to check all the keys <span class="math">k \\equiv (k_{0,0}, k_{1,3}, k_{2,2}, k_{3,1})</span> from <span class="math">(0 \\times 00, 0 \\times 00, 0 \\times 00, 0 \\times 00)</span> to <span class="math">(0 \\times f f, 0 \\times f f, 0 \\times f f, 0 \\times f f)</span>, and not only the ones found by Algorithm 2.</p>

    <p class="text-gray-300">ciphertext) pairs for <span class="math">d\\geq 5</span>, that is <span class="math">(p^{i},c^{i})</span> for each <span class="math">i=0,...,2^{64}-d-1</span>, with the property that there exist a set of keys <span class="math">k^{0}</span> and <span class="math">k^{10}</span> - this set can correspond to the entire set of keys - for which the bytes of <span class="math">R_{k^{0}}(p^{i})</span> and of <span class="math">MC^{-1}\\circ R_{k^{10}}^{-1}(c^{i})</span> (that is 1-round encryption of <span class="math">p^{i}</span> and the 1-round decryption of the ciphertexts) are “almost uniform” distributed. The goal of the player is to find the remaining <span class="math">d</span> texts for which the bytes of the corresponding <span class="math">2^{64}</span> texts after 1-round encryption/decryption are uniform distributed. Since this probability is upper bounded by <span class="math">(2^{128})^{2}\\cdot\\left(\\frac{5^{10}}{2^{128}-2^{64}+1}\\right)^{3}\\simeq 2^{-16.5}</span> - see proof of Prop. 6 of <em>[x10]</em> - and since this second game is “related” to the original one, the conclusion follows immediately.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">5.2.1 Generic Considerations</h4>

    <p class="text-gray-300">The previous 10-round distinguisher proposed by Gilbert is different from all the previous distinguishers up to 8 rounds present in literature. For all distinguishers up to 8-round, the relation <span class="math">\\mathcal{R}</span> that the <span class="math">N</span>-tuple of (plaintexts, ciphertexts) must satisfy doesn’t involve any operation of the block cipher <span class="math">E</span>. As a consequence, it allows the verifier to check whether the <span class="math">N</span>-tuple of (plaintexts, ciphertexts) satisfy the required relation <span class="math">\\mathcal{R}</span> without knowing anything of the key. When <span class="math">\\mathcal{R}</span> doesn’t re-use operations of <span class="math">E</span>, this provides some heuristic evidence that this distinguisher can be considered meaningful.</p>

    <p class="text-gray-300">On the other hand, the previous 10-round distinguisher and the ones that we are going to propose don’t satisfy this requirement, i.e. in these cases the relation <span class="math">\\mathcal{R}</span> involves and re-uses some operations of <span class="math">E</span>. The novelty of Gilbert’s work is not just the possibility to extend the distinguisher up to 10-round AES, but rather the introduction of a new distinguisher model. Requiring the existence of round keys for which the 1-round encryption of the plaintexts (respectively, 1-round decryption of the ciphertexts) satisfy the relation <span class="math">\\mathcal{R}</span>, or in other words considering relations <span class="math">\\mathcal{R}</span> that depend on some operations of <span class="math">E</span>, allows to set up new distinguishers that penetrate more round of the block cipher. For a detailed discussion on the reasons why such known-key distinguishers should not be systematically ruled out as if they were artificial we refer to Sect. 3 of <em>[x10]</em>. We emphasize that the goal of this paper is not to disprove or to give more argumentations about the validity of such model. Rather, under the assumption of validity of such model, the contributions of our paper are to show the possibility to set up distinguishers based on the truncated differential property instead of the uniform distribution one in the Gilbert’s framework, and the possibility to extend such distinguishers for up to 12-round AES, that is two more beyond the claimed given by Gilbert in <em>[x10]</em>.</p>

    <p class="text-gray-300">A Variant of Gilbert’s Distinguisher. Before we go on, we highlight a variant of the Gilbert’s distinguisher - that also applies to all our proposed distinguishers present in the paper - which allows to better understand it. Consider the case in which the two players have to send to the verifier the <span class="math">N</span>-tuple that verify the required relation <span class="math">\\mathcal{R}</span> together with the subkeys for which such relation is satisfied. As an example, in the 10-round distinguisher just presented, the players have to send <span class="math">2^{64}</span> (plaintexts, ciphertexts) pairs <span class="math">(p^{i},c^{i})</span> and the two subkeys <span class="math">k^{0}</span> and <span class="math">k^{10}</span> such that the bytes of <span class="math">R_{k^{0}}(p^{i})</span> and <span class="math">MC^{-1}\\circ R_{k^{10}}^{-1}(c^{i})</span> are uniform distributed. Thus, since the task of the verifier is to check that the relation <span class="math">\\mathcal{R}</span> is satisfied only for the keys she received, it follows that her computational cost is negligible. On the other hand, we show in details in App. A that such variant of the distinguisher is meaningless, since it can be set up for any number of rounds of AES.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">5.3 Another Strategy for the Verifier</h3>

    <p class="text-gray-300">In order to extend the Gilbert’s distinguisher on 12-round AES by exploiting the uniform distribution property, we present another strategy that the verifier can use in order to check the existence of keys <span class="math">k^{0}</span> and <span class="math">k^{10}</span> for which the required property <span class="math">\\mathcal{R}</span> is verified. The</p>

    <p class="text-gray-300">New and Old Limits for AES Known-Key Distinguishers</p>

    <p class="text-gray-300">Data:  <span class="math">2^{64}</span>  texts  <span class="math">t^i</span>  for  <span class="math">i = 0, \\dots, 2^{64} - 1</span></p>

    <p class="text-gray-300">Result: One anti-diagonal of  <span class="math">k</span>  - e.g.  <span class="math">(k_{0,0}, k_{1,3}, k_{2,2}, k_{3,1})</span>  - s.t. each byte of  <span class="math">MC^{-1} \\circ R_k(t^i)</span>  is uniform distributed</p>

    <p class="text-gray-300">Let  <span class="math">A[0, \\dots, 2^{32} - 1]</span>  and  <span class="math">B^1[0, \\dots, 255], B^2[0, \\dots, 255], B^3[0, \\dots, 255], B^4[0, \\dots, 255]</span>  five arrays initialized to zero;</p>

    <p class="text-gray-300">for  <span class="math">i</span>  from  <span class="math">\\theta</span>  to  <span class="math">2^{64} - 1</span>  do</p>

    <p class="text-gray-300"><span class="math">x\\gets t_{0,0}^{i} + 2^{8}\\cdot t_{3,1}^{i} + 2^{16}\\cdot t_{2,2}^{i} + 2^{24}\\cdot t_{3,1}^{i};</span></p>

    <p class="text-gray-300"><span class="math">A[x]\\gets A[x] + 1;</span></p>

    <p class="text-gray-300">end</p>

    <p class="text-gray-300">Use Algorithm 2 to find  <span class="math">k_{0,0}, k_{1,3}, k_{2,2}, k_{3,1}</span>  - i.e. to filter wrong candidates;</p>

    <p class="text-gray-300">for each  <span class="math">k \\equiv (k_{0,0}, k_{1,3}, k_{2,2}, k_{3,1})</span>  found using Algorithm 2 do</p>

    <p class="text-gray-300">for  <span class="math">s</span>  from  <span class="math">(0x00, 0x00, 0x00, 0x00)</span>  to  <span class="math">(0xff, 0xff, 0xff, 0xff)</span>  do</p>

    <p class="text-gray-300">Let  <span class="math">s \\equiv (s^0, s^1, s^2, s^3) \\in \\mathbb{F}_{2^8}^4</span>  be a column of 4 bytes;</p>

    <p class="text-gray-300">Compute  <span class="math">x \\equiv MC^{-1} \\circ R_k(s)</span> ; // partial decryption of  <span class="math">s</span>  w.r.t. to  <span class="math">k</span>  - note:  <span class="math">x \\equiv (x^1, x^2, x^3, x^4) \\in \\mathbb{F}_{2^8}^4</span>  is a column of 4 bytes</p>

    <p class="text-gray-300">Increment  <span class="math">B^1, B^2, B^3, B^4[x]</span> :  <span class="math">B^j[x^j] \\gets B^j[x^j] + A[x]</span>  for each  <span class="math">j = 1, 2, 3, 4</span> ;</p>

    <p class="text-gray-300">end</p>

    <p class="text-gray-300">if uniform distribution - i.e.  <span class="math">B^{j}[x] = 2^{56}</span>  for each  <span class="math">x = 0, \\dots, 255</span>  and for each  <span class="math">j = 1, 2, 3, 4</span>  then</p>

    <p class="text-gray-300">identify  <span class="math">k</span>  as possible candidate;</p>

    <p class="text-gray-300">end</p>

    <p class="text-gray-300">end</p>

    <p class="text-gray-300">return candidates for  <span class="math">(k_{0,0}, k_{1,3}, k_{2,2}, k_{3,1})</span> .</p>

    <p class="text-gray-300">Algorithm 1: Verifier Strategy: find one anti-diagonal (e.g. the first one) of the last round-key  <span class="math">k</span>  - equivalent for the other anti-diagonals and for the first round key - s.t. the bytes of  <span class="math">MC^{-1} \\circ R_k^{-1}(t^i)</span>  are uniform distributed. For simplicity, we omit the final MixColumns - if it is not omitted, it is sufficient to swap it with the final AddRoundKey operation.</p>

    <p class="text-gray-300">goal of the following strategy is not to improve the computational cost of the verifier, but to show the possibility to check the existence of such keys working independently on each byte of the key instead of combinations of 4 bytes. The idea is simply to filter wrong key candidates using the integral attack [DKR97]-[KW02].</p>

    <p class="text-gray-300">As we have just seen, the two players have to find  <span class="math">2^{64}</span>  (plaintext, ciphertext) pairs, i.e.  <span class="math">(p^i, c^i)</span>  for  <span class="math">i = 0, \\dots, 2^{64} - 1</span> , s.t. there exist keys  <span class="math">k^0</span>  and  <span class="math">k^{10}</span>  for which bytes of  <span class="math">R_{k^0}(p^i)</span>  and  <span class="math">MC^{-1} \\circ R_{k^{10}}^{-1}(c^i)</span>  are uniform distributed. When the verifier receives the set of  <span class="math">2^{64}</span>  (plaintext, ciphertext) pairs from the players, she checks if the required properties are satisfied or not by finding the two keys. Under Gilbert's assumption - no key-schedule holds, the verifier can work independently on  <span class="math">k^0</span>  and  <span class="math">k^{10}</span> . Both for  <span class="math">k^0</span>  and  <span class="math">k^{10}</span> , Gilbert proposes to work on 4 bytes of the key at the same time, that is to work on entire antidiagonal in the case of  <span class="math">k^{10}</span>  (for simplicity the last MixColumns operation is omitted) and to work on entire diagonal in the case of  <span class="math">k^0</span> . Here we show that a different strategy can be used to verify the existence of these two keys.</p>

    <p class="text-gray-300">As we are going to show, it is not necessary to work on 4 bytes of the subkeys  <span class="math">k^0</span>  and  <span class="math">k^{10}</span>  simultaneously, but it is possible to find  <span class="math">k^0</span>  and  <span class="math">k^{10}</span>  working on single bytes (independently of the others). The idea is to exploit the fact that uniform distribution implies zero-sum property. Thus, the verifier first looks for subkeys  <span class="math">k^0</span>  and  <span class="math">k^{10}</span>  that satisfy  <span class="math">\\bigoplus_{i=0}^{2^{64}-1} R_{k^0}(p^i) = 0</span>  and  <span class="math">\\bigoplus_{i=0}^{2^{64}-1} R_{k^{10}}^{-1}(c^i) = 0</span>  working independently on each byte. Only for keys that satisfy zero-sum, she then checks if the uniform property is verified, working simultaneously on 4 bytes of the subkeys. We emphasize that if zero-sum is not satisfied, then also uniform distribution is not satisfied. Moreover, we highlight that the number of</p>

    <p class="text-gray-300">Lorenzo Grassi and Christian Rechberger</p>

    <p class="text-gray-300">Data:  <span class="math">2^{64}</span>  texts  <span class="math">t^i</span>  for  <span class="math">i = 0, \\dots, 2^{64} - 1</span></p>

    <p class="text-gray-300">Result: One byte of  <span class="math">k</span>  - e.g.  <span class="math">k_{0,0}</span>  - s.t.  <span class="math">\\bigoplus_{i} \\mathrm{S-Box}^{-1}(p_{0,0}^{i} \\oplus k_{0,0}) = 0</span></p>

    <p class="text-gray-300">Let  <span class="math">A[0, \\dots, 2^8 - 1]</span>  an array initialized to zero;</p>

    <p class="text-gray-300">for  <span class="math">i</span>  from  <span class="math">\\theta</span>  to  <span class="math">2^{64} - 1</span>  do</p>

    <p class="text-gray-300"><span class="math">A[t_{0,0}^i ]\\gets (A[t_{0,0}^i ] + 1)\\mathrm{mod}2;\\qquad / / A[x]</span>  denotes the value stored in the</p>

    <p class="text-gray-300"><span class="math">x</span> -th address of the array  <span class="math">A</span></p>

    <p class="text-gray-300">end</p>

    <p class="text-gray-300">for  <span class="math">k</span>  from 0x00 to 0xff do</p>

    <p class="text-gray-300"><span class="math">x\\gets 0</span></p>

    <p class="text-gray-300">for  <span class="math">i</span>  from 0 to 255 do</p>

    <p class="text-gray-300"><span class="math">x\\gets x\\oplus A[i]\\cdot \\mathrm{S - Box}^{-1}(i\\oplus k);</span></p>

    <p class="text-gray-300">//  <span class="math">A[i]</span>  can only be 0 or 1</p>

    <p class="text-gray-300">end</p>

    <p class="text-gray-300">if  <span class="math">x = \\theta</span>  then</p>

    <p class="text-gray-300">identify  <span class="math">k</span>  as candidate for  <span class="math">k_{0,0}</span></p>

    <p class="text-gray-300">end</p>

    <p class="text-gray-300">end</p>

    <p class="text-gray-300">return candidates for  <span class="math">k_{0,0}</span></p>

    <p class="text-gray-300">Algorithm 2: First Part of Verifier Strategy: working on each byte of the key independently of the others, filter wrong key candidates using zero-sum property.</p>

    <p class="text-gray-300">subkeys that satisfy zero-sum is very small compared to the number of all possible keys. Indeed, note that since zero-sum is satisfied with prob.  <span class="math">2^{-128}</span>  and since there are only  <span class="math">2^{128}</span>  keys, on average only one key passes the first step. It follows that the second step of this strategy - i.e. checking uniform distribution when zero-sum is satisfied - has negligible cost compared to the total cost. For completeness, note that the only case in which no key is filtered occurs when all the values of the vector  <span class="math">A</span>  defined in Algorithm 2 are even. Since the probability that at least one value of vector  <span class="math">A</span>  defined in Algorithm 2 is odd is given by  <span class="math">1 - (2^{-1})^{256} = 1 - 2^{-256} \\simeq 1</span> , this implies that only few candidates survive Algorithm 2 - i.e. only few candidates are tested in Algorithm 1 - with very high probability.</p>

    <p class="text-gray-300">In more details, if the bytes of  <span class="math">MC^{-1} \\circ R_{k^{10}}^{-1}(c^i)</span>  are uniform distributed then  <span class="math">\\bigoplus_{i} MC^{-1} \\circ R_{k^{10}}^{-1}(c^i) = \\bigoplus_{i} R_{k^{10}}^{-1}(c^i) = 0</span> . The subkeys  <span class="math">k^{10}</span>  that satisfy this requirement can be found using a classical square attack - see Algorithm 2. For completeness, if the final MixColumns operation is not omitted, then one simply changes the positions of the final MixColumns operation and of the final AddRoundKey operation, using the fact that the MixColumns is linear. Exactly in the same way, if the bytes of  <span class="math">R_{k^0}(p^i)</span>  are uniform distributed then  <span class="math">\\bigoplus_{i} R_{k^0}(p^i) = 0</span> . Since a set of balanced texts  <span class="math">\\{t^i\\}_{i \\in I}</span>  is mapped into a set of balanced texts by the MixColumns operation (indeed, since  <span class="math">MC</span>  is linear, it follows that  <span class="math">\\bigoplus_{i \\in I} MC(t^i) = MC(\\bigoplus_{i \\in I}(t^i)) = 0</span> ), the verifier can simply check if the condition  <span class="math">\\bigoplus_{i=0}^{2^{64}-1} \\mathrm{S-Box}(p_{j,l}^i \\oplus k_{j,l}^0) = 0</span>  holds for each byte (i.e.  <span class="math">\\forall j, l = 0, \\dots, 3</span> ) in order to verify that  <span class="math">\\bigoplus_{i=0}^{2^{64}-1} R_{k^0}(p^i) = 0</span> . It follows that the verifier can work on single bytes of  <span class="math">k^0</span>  and  <span class="math">k^{10}</span>  to filter wrong key candidates.</p>

    <p class="text-gray-300">Using this proposed strategy, the verification cost is a little lower than the one given in the original strategy of Gilbert (approximately  <span class="math">10 \\times 2^{64}</span>  vs  <span class="math">10 \\times 2^{64}</span>  look-ups table, that  <span class="math">2^{57.36}</span>  vs  <span class="math">2^{59.7}</span>  ten-round encryptions assuming 1 S-Box look-up  <span class="math">\\approx 1</span>  table look-up). In particular, observe that all the arrays  <span class="math">A</span>  defined in Algorithms 1 and 2 can be computed simultaneously and stored, and that we expect that only few (on average only one) keys pass Algorithms 2 - that is, the cost of the verification step is well approximated by the</p>

    <p class="text-gray-300">New and Old Limits for AES Known-Key Distinguishers</p>

    <p class="text-gray-300">cost to compute the array <span class="math">A</span>. On the other hand, we emphasize that the goal of this strategy is to show the possibility to work on single byte of the key independently of the others, and not to improve the verification cost in a significant way.</p>

    <h2 id="sec-25" class="text-2xl font-bold">6 Key-Recovery Extensions using Truncated Differentials</h2>

    <p class="text-gray-300">Our known-key distinguishers exploit the same idea proposed for the first time by Gilbert. In particular, our idea is to extend the 8-round distinguishers recalled in Sect. 4.3 at the end or/and at the beginning, in the same way used by Gilbert to extend the 8-round distinguisher based on the uniform distribution property.</p>

    <p class="text-gray-300">Since we are going to extend known-key distinguishers based on truncated differential properties, we need an efficient key-recovery attack that allows the verifier to check the required property on the <span class="math">N</span>-tuple of (plaintexts, ciphertexts) that she receives by the players. For this reason, we re-propose the low-data complexity truncated differential attacks on 3- and 4-round AES-128 presented in [GRR17]. The attacks that we present here are a little modified with respect to those presented in [GRR17] due to different scope of this work. In particular, the attack on 3 rounds of [GRR17] is described here as an attack on a single round, while the attack on 4 rounds is described here as an attack on 2 rounds (besides other changes for this second case, which are described in the following).</p>

    <h2 id="sec-26" class="text-2xl font-bold">6.1 Attack for the Case of 1-Round Extension</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider three plaintexts in the same coset of <span class="math">\\mathcal{M}_i</span> for $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math"> and the corresponding ciphertexts after one round</span>^{12}<span class="math">, that is </span>(p^j, c^j)<span class="math"> for </span>j = 1, 2, 3<span class="math">. The goal of the attack is to find the key </span>k<span class="math"> such that the ciphertexts belong to the same coset of </span>\\mathcal{M}_i<span class="math"> one round before, that is </span>k<span class="math"> has to satisfy the following condition</span>^{13}$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">R _ {k} ^ {- 1} (c ^ {1}) \\oplus R _ {k} ^ {- 1} (c ^ {2}) \\in \\mathcal {M} _ {i} \\qquad \\text{and} \\qquad R _ {k} ^ {- 1} (c ^ {1}) \\oplus R _ {k} ^ {- 1} (c ^ {3}) \\in \\mathcal {M} _ {i}.</span></div>

    <p class="text-gray-300">For simplicity, we assume that the final MixColumns operation is omitted (otherwise one simply switches the final MixColumns and the final AddRoundKey operation, as usual in literature). Since each column of <span class="math">\\mathcal{M}_i</span> depends on different and independent variables, the idea of the attack is to work independently on each column of <span class="math">\\mathcal{M}_i</span> or equivalently of <span class="math">SR^{-1}(k)</span>, and to exploit the relationships that hold among the bytes that lie in the same column of <span class="math">\\mathcal{M}_i</span>.</p>

    <p class="text-gray-300">Without loss of generality, we assume <span class="math">I = \\{0\\}</span> and we present the attack only for the first column of <span class="math">SR^{-1}(k)</span> (analogous for the others). The conditions that the bytes of the first column of <span class="math">SR^{-1}(k)</span> must satisfy are:</p>

    <div class="my-4 text-center"><span class="math-block">s _ {0, 0} ^ {h} = 0 \\mathrm {x} 0 2 \\cdot s _ {1, 3} ^ {h}, \\quad s _ {2, 2} ^ {h} = s _ {1, 3} ^ {h}, \\quad s _ {3, 1} ^ {h} = 0 \\mathrm {x} 0 3 \\cdot s _ {1, 3} ^ {h}, \\tag {6}</span></div>

    <p class="text-gray-300">where <span class="math">s_{i,j}^{h} = \\mathrm{S - Box}^{-1}(c_{i,j}^{1}\\oplus k_{i,j})\\oplus \\mathrm{S - Box}^{-1}(c_{i,j}^{h}\\oplus k_{i,j})</span> for <span class="math">h = 2,3</span>. For each value of <span class="math">k_{1,3}</span> (2<span class="math">^{8}</span> possible values in total), the idea is to find the values of <span class="math">k_{0,0}</span>, <span class="math">k_{2,2}</span> and <span class="math">k_{3,1}</span> that satisfy the previous relationships. On average, using a single pair of ciphertexts and working in this way, it is possible to find 2<span class="math">^{8}</span> combinations of these four bytes (i.e. one for each possible value of <span class="math">k_{1,3}</span>). The idea is to test them using the second pair of ciphertexts: on average, only the right combination passes the test. The same procedure is used for the others columns.</p>

    <p class="text-gray-300"><span class="math">^{11}</span>We emphasize that both these attacks have been practical verified (see [GRR17] for details).</p>

    <p class="text-gray-300"><span class="math">^{12}</span>More generally, consider two couples of (plaintexts, ciphertexts) pairs, that is <span class="math">\\{(p_0^j, c_0^j), (p_1^j, c_1^j)\\}</span> for <span class="math">j = 1, 2</span> such that <span class="math">p_0^j \\oplus p_1^j \\in \\mathcal{M}_i</span>.</p>

    <p class="text-gray-300"><span class="math">^{13}</span>Note that if <span class="math">R_{k}^{-1}(c^{1}) \\oplus R_{k}^{-1}(c^{2}) \\in \\mathcal{M}_{i}</span> and <span class="math">R_{k}^{-1}(c^{1}) \\oplus R_{k}^{-1}(c^{3}) \\in \\mathcal{M}_{i}</span>, it follows that also <span class="math">R_{k}^{-1}(c^{2}) \\oplus R_{k}^{-1}(c^{3}) \\in \\mathcal{M}_{i}</span> since <span class="math">\\mathcal{M}_{i}</span> is a subspace.</p>

    <p class="text-gray-300">2 ciphertexts pairs <span class="math">(c^{1},c^{2})</span> and <span class="math">(c^{1},c^{3})</span>, whose corresponding plaintexts belong in the same coset of <span class="math">\\mathcal{D}_{0}</span>. Result: First diagonal of the secret key <span class="math">k</span> (i.e. <span class="math">k_{i,i}</span> for each <span class="math">i=0,...,3</span>). (Note: the same procedure with the <em>same</em> ciphertexts can be used to recover the other diagonals of the key.) for all values <em>of <span class="math">k_{1,3}</span></em> do for all values <em>of <span class="math">k_{0,0}</span></em> do check if <span class="math">s^{h}_{0,0}=0\\text{x}02\\cdot s^{h}_{1,3}</span> is satisfied for both pairs of ciphertexts, where <span class="math">s^{h}_{i,j}=\\text{S-Box}^{-1}(c^{1}_{i,j}\\oplus k_{i,j})\\oplus\\text{S-Box}^{-1}(c^{h}_{i,j}\\oplus k_{i,j})</span> for <span class="math">h=2,3</span> if <em>satisfied</em> then identify candidates for <span class="math">k_{1,3}</span> and <span class="math">k_{0,0}</span>; repeat the same procedure for <span class="math">k_{2,2}</span> and <span class="math">k_{3,1}</span>, that is check if the equivalence <span class="math">s^{h}_{2,2}=s^{h}_{1,3}</span> and <span class="math">s^{h}_{3,1}=0\\text{x}03\\cdot s^{h}_{1,3}</span> are satisfied; end if end for end for end for return candidate of the first diagonal of <span class="math">k</span> Algorithm 3: <em>Key-recovery Attack - Pseudo Code</em>. For simplicity, in this pseudo-code, we show how to find only the first diagonal of the secret key that verify relationship <span class="math">\\mathcal{R}</span>. To recover the entire key, it is sufficient to repeat the same attack for the other diagonals using the same pairs of ciphertexts. For more details, see Algorithm 5 of <em>[x10]</em>.</p>

    <p class="text-gray-300">The total computational cost of the attack is well approximated by the cost of the first phase, that is by the cost to find (on average) the <span class="math">2^{8}</span> combinations of <span class="math">k_{0,0},...,k_{3,1}</span> that satisfy (6) for the first column and similar for the others (the cost to check them with the second pair of texts is negligible). In particular, the computational cost of this attack using 3 chosen plaintexts can be approximated by <span class="math">2^{17.1}</span> S-Box look-ups (and negligible memory cost), or approximately <span class="math">2^{11.6}</span> table look-ups and a memory cost of <span class="math">16\\times 2^{12}=2^{16}</span> using a precomputation phase. We refer to <em>[x10]</em> for all the details.</p>

    <p class="text-gray-300">For the following, we emphasize that the same attack works exactly in the same way also in the decryption direction (chosen ciphertexts attack) with the same complexity. In this case the idea is to consider three ciphertexts in the same coset of <span class="math">\\mathcal{D}_{i}</span>, and to look for a key such that the corresponding plaintexts belong to the same coset of <span class="math">\\mathcal{D}_{i}</span> after one round (see <em>[x10]</em> for details).</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">6.2 Attack for the Case of 2-Round Extension</h3>

    <p class="text-gray-300">To set up the first 12-round known-key distinguisher of AES-128, we also need to recall (a modified version of) the low-data complexity truncated differential attack on 4-round of AES-128, which is obtained by extending the previous attack on 3 rounds at the end. We refer to <em>[x10]</em> for a complete description of the attack - see Algorithm 6 for a complete pseudo-code, and for simplicity we assume that the final MixColumns is omitted.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider plaintexts in the same coset of <span class="math">\\mathcal{M}_{i}</span> for $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math"> and the corresponding ciphertexts after two rounds. The goal of the attack is to find the key such that the ciphertexts belong to the same coset of </span>\\mathcal{M}_{i}<span class="math"> two rounds before. The idea of the attack is to guess two columns of </span>SR^{-1}(k^{2})<span class="math">, where </span>k^{2}<span class="math"> is the final key. Given 5 plaintexts and the corresponding ciphertexts </span>(p^{j},c^{j})<span class="math"> for </span>j=1,...,5<span class="math">, for each one of the </span>2^{64}<span class="math"> possible values of these two columns of </span>SR^{-1}(k^{2})<span class="math">, the idea is to partially decrypt these 5 ciphertexts one round, that is to compute the eight bytes </span>s^{j}:=R_{k^{2}}^{-1}(c^{j})<span class="math"> for each </span>i=1,...,5$. Due to the ShiftRows operation, these 8 bytes are distributed in two columns. Thus, the idea is to simply to repeat the previous attack on 3 rounds. However, due to the ShiftRows operation, the</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">New and Old Limits for AES Known-Key Distinguishers</p>

    <p class="text-gray-300">eight bytes of <span class="math">s^i</span> are uniform distributed in the four columns, i.e. two byte for each column, that is for each column one can only exploit the relationship that holds among these two bytes (see [GRR17] for details).</p>

    <p class="text-gray-300">Using two pairs of ciphertexts (e.g. <span class="math">(c^1, c^2)</span> and <span class="math">(c^1, c^3)</span>), it is possible to find (on average) at most one combination of eight bytes of <span class="math">k^2</span> for each possible guess of the eight bytes of <span class="math">k^2</span>, for a total of <span class="math">2^{64}</span> possibilities. The idea is to test these found values against other pairs of ciphertexts, that is to check if the relationships among the bytes of the keys hold also for these other pairs of ciphertexts<span class="math">^{14}</span>. Since each relationship is satisfied with probability <span class="math">2^{-32}</span> (there are four relationships, each one satisfied with probability <span class="math">2^{-8}</span>), it is sufficient to test the found values of <span class="math">k^1</span> and <span class="math">k^2</span> against only other two pairs of ciphertexts, in order to eliminate all the wrong candidates with high probability. Thus, using 5 chosen plaintexts (i.e. 4 pairs with a common plaintext<span class="math">^{15}</span>), it is possible to recover 8 bytes of <span class="math">k^1</span> and of <span class="math">k^2</span>. To discover the complete key, the idea is essentially to repeat the same procedure on the last two columns of <span class="math">k^2</span> (we refer to [GRR17] for details).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As shown in [GRR17], the computational cost of this attack is well approximated by <span class="math">2^{81}</span> S-Box look-ups (with negligible cost of memory) or <span class="math">2^{76}</span> table look-ups and a memory cost of <span class="math">16 \\cdot 2^{12} = 2^{16}</span> bytes. Moreover, the same attack works also in the decryption direction, with the same complexity. In particular, given ciphertexts in the same coset of <span class="math">\\mathcal{D}_i</span> for $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math"> and the corresponding plaintexts two rounds before, the idea is to look for the keys such that the plaintexts belong to the same coset of </span>\\mathcal{D}_i$ after two rounds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Exploiting the same idea proposed by Gilbert, we set up our known-key distinguisher for 9 rounds of AES by extending the 8-round distinguisher presented in [JNPP14] (and recalled in Sect. 4.3) at the end (or at the beginning).</p>

    <p class="text-gray-300">In the above defined known-key scenario, the players have to send to the verifier <span class="math">n</span> different tuples of (plaintext, ciphertext) pairs, that is <span class="math">\\{(p_i^1, c_i^1), (p_i^2, c_i^2)\\}</span> for <span class="math">i = 0, \\dots, n-1</span>, with the following properties<span class="math">^{16}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for each tuple, there exists <span class="math">j</span> s.t. the two plaintexts belong to the same coset of <span class="math">\\mathcal{D}_j</span>, that is</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\forall i = 0, \\dots , n - 1, \\quad \\exists j \\in \\{0, \\dots , 3 \\} \\quad \\text{s.t.} \\quad p _ {i} ^ {1} \\oplus p _ {i} ^ {2} \\in \\mathcal {D} _ {j};</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there exists a key <span class="math">k</span> s.t. for each tuple there exists <span class="math">l</span> for which the two ciphertexts belong to the same coset of <span class="math">\\mathcal{M}_l</span> one round before, that is</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\exists k \\quad \\text{s.t.} \\quad \\forall i = 0, \\dots , n - 1, \\quad \\exists l \\in \\{0, \\dots , 3 \\} \\quad \\text{s.t.} \\quad R _ {k} ^ {- 1} (c _ {i} ^ {1}) \\oplus R _ {k} ^ {- 1} (c _ {i} ^ {2}) \\in \\mathcal {M} _ {l}.</span></div>

    <p class="text-gray-300">The fastest player to construct these <span class="math">n</span>-tuples wins the game.</p>

    <p class="text-gray-300">We stress that the key <span class="math">k</span> must be equal for all the tuples. In other words, if there exist two different tuples <span class="math">(c_0, c_1)</span> and <span class="math">(c_2, c_3)</span> such that <span class="math">R_k^{-1}(c_0) \\oplus R_k^{-1}(c_1) \\in \\mathcal{M}_l</span> and <span class="math">R_k^{-1}(c_2) \\oplus R_k^{-1}(c_3) \\in \\mathcal{M}_l</span> for two different keys <span class="math">k \\neq \\tilde{k}</span>, then the above defined relationship <span class="math">\\mathcal{R}</span> is not satisfied. Note that without this request on the secret key <span class="math">k</span>, it is extremely easy to construct tuples such that the two ciphertexts belong to the same coset of <span class="math">\\mathcal{M}_l</span> one round</p>

    <p class="text-gray-300"><span class="math">^{14}</span>This step is different from the one proposed in [GRR17]. In that case, the idea is to find the right key by a brute force attack in order to keep the data complexity as low as possible. For our distinguisher, we propose to test the found key against other pairs of plaintexts and ciphertexts, since it is not possible to use a brute force attack.</p>

    <p class="text-gray-300"><span class="math">^{15}</span>Note that 4 different pairs can be obtained by 3 chosen plaintexts. However, such pairs are not useful for the attack, essentially for the same reason given in footnote 13. We refer to [GRR17] for a complete and detailed explanation.</p>

    <p class="text-gray-300"><span class="math">^{16}</span>We say that the tuples are different if <span class="math">p_i^1 \\neq p_i^2</span> for each <span class="math">i</span> and if <span class="math">(p_i^1, p_i^2) \\neq (p_j^1, p_j^2)</span> and <span class="math">(p_i^1, p_i^2) \\neq (p_j^2, p_j^1)</span> for each <span class="math">i \\neq j</span>.</p>

    <p class="text-gray-300">Lorenzo Grassi and Christian Rechberger</p>

    <p class="text-gray-300">before. Indeed, as we have seen for the attack of Sect. 6, given two ciphertexts <span class="math">c^{1}</span> and <span class="math">c^{2}</span>, on average there exist <span class="math">4\\cdot (2^{8})^{4}=2^{34}</span> different keys such that <span class="math">R^{-1}(c^{1})\\oplus R^{-1}(c^{2})\\in\\mathcal{M}_{l}</span> for a certain <span class="math">l</span>. Thus, it is straightforward to construct <span class="math">n</span> different tuples with the above defined relationship <span class="math">\\mathcal{R}</span> but without any condition on the key <span class="math">k</span>.</p>

    <p class="text-gray-300">Before we go on, it is also important to emphasize that no condition on the key <span class="math">k</span> is imposed, except that it exists and it is equal for all the tuples. That is, it is not required that this key is equal to the real secret subkey. The same consideration holds also for the next distinguishers presented in this paper, and for the 10-round distinguisher presented by Gilbert in <em>[x11]</em>.</p>

    <p class="text-gray-300">In the following, we present the distinguisher in details. To obtain a suitable value for <span class="math">n</span>, we consider the best strategy that the generic player can adopt to win the game. A value of <span class="math">n</span> is suitable when the computational cost of the generic player using this best strategy is worse than the one of the other player.</p>

    <p class="text-gray-300">As we show in details in the following, to do this one has to consider the numbers of oracle-queries done by the two player and any further cost of the generic player. In particular, if only the number of oracle-queries is taken in account, then <span class="math">n</span> must be equal or greater than 8, which implies that the computational cost for the shortcut player is of <span class="math">2^{47}</span> and for the generic player is of <span class="math">2^{48.9}</span>. In order to make the advantage of the shortcut player more significant, we have chosen an (arbitrary) value of <span class="math">n=64</span>, which implies a cost for the shortcut player of <span class="math">2^{50}</span> computations and of <span class="math">2^{65.6}</span> computations for the generic player. Instead, if all the costs are considered (number of oracle-queries + cost of the generic player), then a suitable value of <span class="math">n</span> is 3, the computational cost for the shortcut player is <span class="math">2^{45.6}</span> and for the generic player is approximately <span class="math">2^{109.5}</span>. In both cases, the computational cost of the verifier is well approximated by <span class="math">2^{11.6}</span>.</p>

    <p class="text-gray-300">The Verifier. Given <span class="math">n</span> tuples, for each one of them the verifier can easily check if the two plaintexts belong (or not) to the same cosets of <span class="math">\\mathcal{D}_{j}</span> for a certain <span class="math">j</span>, by computing their XOR sum and checking that three diagonals are equal to zero.</p>

    <p class="text-gray-300">More complicated is to check if there exists a (unique) key <span class="math">k</span> for which the requirement on the ciphertexts is fulfilled. The idea is to find such key (if exists), using the attack described in Sect. 6.1. First of all, given a single tuple, there exist on average <span class="math">4\\cdot(2^{8})^{4}=2^{34}</span> keys of the final round such that the two ciphertexts belong to the same coset of <span class="math">\\mathcal{M}_{l}</span> one round before for a certain <span class="math">l</span>. Given two tuples, the probability that such key exists is only <span class="math">(2^{34})^{2}\\cdot 2^{-128}=2^{-60}</span>, while more generally, given <span class="math">n</span> tuples, the probability that at least one key exists (for which the previous requirements are satisfied) is given by:</p>

    <p class="text-gray-300"><span class="math">2^{34n}\\cdot 2^{-128(n-1)}=2^{-94\\cdot n+128}.</span></p>

    <p class="text-gray-300">This is due to the fact that for each tuple there are one average <span class="math">2^{34}</span> different keys and that the probability that two keys are equal is <span class="math">2^{-128}</span>. By this preliminary analysis, it is already possible to deduce that the number of tuples should be at least 2 (i.e. <span class="math">n\\geq 2</span>). Indeed, for <span class="math">n=1</span> such a key always exists (which implies that using a random tuple it is possible to win the game), while for <span class="math">n=2</span> the probability that such key exists for two random tuples is only <span class="math">2^{-60}</span>.</p>

    <p class="text-gray-300">Thus, assume that the verifier receives <span class="math">n\\geq 2</span> tuples. The idea is to use two tuples and the attack described in Sect. 4.3 to recover (if exists) the key that satisfies the required property. If <span class="math">n&amp;gt;2</span>, the verifier simply checks if the relation <span class="math">\\mathcal{R}</span> is satisfied by the found key for the other <span class="math">n-2</span> tuples. In more details, working independently on each column, the attacker uses the first tuple to</p>

    <p class="text-gray-300">17We observe that the claim "the transposition of our technique to the 8-round distinguisher of [GP10] does not allow to derive a valid 10-round distinguisher" made in [Gil14] is justified only when no assumption on the key k is done. In other words, the above defined relationship \\mathcal{R} together with the requirement of uniqueness of the key k allows to extend the 8-round distinguisher of [GP10] as in [Gil14].</p>

    <p class="text-gray-300">find <span class="math">2^{8}</span> combinations for each column of <span class="math">SR^{-1}(k)</span> and checks immediately them with the second tuple. Since she repeats this attack for each possible <span class="math">\\mathcal{M}_{i}</span> (i.e. 4 times), the cost of this step is of <span class="math">4\\cdot 2^{17.1}=2^{19.1}</span> S-Box look-ups. In this way, the verifier finds on average only one key (if exists). If at least one possible key is found using two tuples, she simply checks if the other <span class="math">n-2</span> tuples satisfy the relation <span class="math">\\mathcal{R}</span> for this found key (more generally, she repeats this step for all the keys found using the first two tuples). The cost of this operation is well approximated by <span class="math">2\\cdot 16=2^{5}</span> S-Box look-ups for each tuple (note that she must decrypt one round two ciphertexts).</p>

    <p class="text-gray-300">In conclusion, given <span class="math">n\\geq 2</span> tuples, the cost of the verifier is well approximated by <span class="math">2^{19.1}+(n-2)\\cdot 2^{5}</span> S-Box look-ups, that is approximately <span class="math">2^{11.6}</span> 9-round encryptions if <span class="math">n\\ll 2^{14}</span>.</p>

    <p class="text-gray-300">The Shortcut Player. The shortcut player can simply use the same strategy described in <em>[x10]</em> and in Sect. 4.3 for the known-key distinguisher on 8 rounds to find the <span class="math">n</span> tuples that satisfy the above defined relation <span class="math">\\mathcal{R}</span>. Indeed, it is straightforward to prove that all the properties are satisfied, since for each tuple the two plaintexts belong to the same coset of <span class="math">\\mathcal{D}_{i}</span> (for a certain <span class="math">i</span>) and the two ciphertexts belong to the same coset of <span class="math">\\mathcal{M}_{j}</span> (for a certain <span class="math">j</span>) one round before with respect to the known key - by construction. Since the computational cost to build one tuple is of <span class="math">2^{44}</span> encryptions, the cost to construct <span class="math">n</span> tuples is well approximated by <span class="math">n\\cdot 2^{44}</span>.</p>

    <p class="text-gray-300">The Generic Player. Here we analyze and present the (intuitively) best strategy that the generic player can use to find <span class="math">n</span> tuples with the required properties, and the corresponding computational cost. Intuitively, the best strategy for this player is to choose tuples such that for each one of them the two plaintexts belong to the same coset of <span class="math">\\mathcal{D}_{j}</span> for a certain <span class="math">j</span>. In this way, the required condition on the plaintexts is (obviously) satisfied. Then, the player asks the oracle for the corresponding ciphertexts. The idea is to check if there exists a key <span class="math">k</span> and <span class="math">n</span> tuples such that the two ciphertexts of each of these <span class="math">n</span> tuples belong to the same coset of <span class="math">\\mathcal{M}_{l}</span> one round before. We remember that it is not necessary that the key for which this condition is satisfied is the real one.</p>

    <p class="text-gray-300">As we have already seen, given a single tuple there exist on average <span class="math">2^{34}</span> keys such that the two ciphertexts belong to the same coset of <span class="math">\\mathcal{M}_{j}</span> one round before. To set up a meaningful distinguisher, a value of <span class="math">n</span> is suitable if the number of oracle-queries of the generic player is higher than the cost of the shortcut player. By previous observations, given a set of <span class="math">n</span> tuples, the probability that at least one common key exists for which the property on the ciphertexts is satisfied is <span class="math">2^{-94n+128}</span>. Thus, the idea is to estimate the number of (plaintext, ciphertext) pairs that this player has to generate in order to win the game (that is, in order to find with high probability <span class="math">n</span> tuples with the required property). If this number is higher than <span class="math">2^{44}\\cdot n</span> for a fixed <span class="math">n</span>, then the other player wins the game.</p>

    <p class="text-gray-300">Since each coset of <span class="math">\\mathcal{D}_{j}</span> contains <span class="math">2^{32}</span> different plaintexts, it is possible to construct approximately <span class="math">2^{63}</span> different couples <span class="math">\\{(p^{1},c^{1}),(p^{2},c^{2})\\}</span>. Given <span class="math">t</span> different cosets of <span class="math">\\mathcal{D}_{j}</span>, it is possible to construct <span class="math">s=2^{63}\\cdot t</span> different couples. It follows that one can construct approximately</p>

    <p class="text-gray-300"><span class="math">\\binom{s}{n}\\approx\\frac{s^{n}}{n!}</span></p>

    <p class="text-gray-300">different sets of <span class="math">n</span> different tuples (i.e. <span class="math">n</span> different couples <span class="math">\\{(p^{1},c^{1}),(p^{2},c^{2})\\}</span>), where the approximation holds for <span class="math">n\\ll s</span>. Since the probability that a set of <span class="math">n</span> tuples satisfy the above defined relation <span class="math">\\mathcal{R}</span> is <span class="math">2^{-94n+128}</span>, the generic player must consider at least <span class="math">s</span> different</p>

    <p class="text-gray-300">couples such that <span class="math">s^{n}/n!\\simeq 2^{94n-128}</span> or equivalently</p>

    <p class="text-gray-300"><span class="math">s\\simeq 2^{94-\\frac{128}{n}}\\cdot(n!)^{\\frac{1}{n}}.</span> (7)</p>

    <p class="text-gray-300">By this formula, for <span class="math">n=8</span> this player has to consider approximately <span class="math">2^{79.9}</span> different tuples, or equivalently <span class="math">2^{48.9}</span> (plaintext, ciphertext) pairs (that is, <span class="math">2^{16.9}</span> initial different cosets of <span class="math">\\mathcal{D}_{j}</span>). Indeed, given <span class="math">2^{16.9}</span> initial different cosets of <span class="math">\\mathcal{D}_{j}</span>, it is possible to construct approximately <span class="math">2^{16.9}\\cdot 2^{63}=2^{79.9}</span> different couples, that is approximately <span class="math">2^{624}</span> different sets of 8 tuples. Since each of these sets satisfies the required properties with probability <span class="math">2^{-94\\cdot 8+128}=2^{-624}</span>, he has a good probability to find 8 different tuples with the required property. The cost to generate these <span class="math">2^{48.9}</span> (plaintexts, ciphertexts) pairs is of <span class="math">2^{48.9}</span> oracle-queries (with the assumption 1 oracle-query <span class="math">\\simeq 1</span> encryption). On the other hand, the cost to generate these 8 tuples for the shortcut player is of <span class="math">8\\cdot 2^{44}=2^{47}</span> (which is smaller). We emphasize that the cost of the generic player is higher than the cost of the shortcut player is satisfied for any value <span class="math">n</span> with <span class="math">n\\geq 8</span>.</p>

    <p class="text-gray-300">Finally, the same strategy can be used to extend the 7-round known-key distinguisher of App. E.1 in order to set up a 8-round known-key distinguisher with a time complexity of <span class="math">2^{21.6}</span>. All the details are given in App. E.2.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">The Computational Cost of Generic Player is Not Negligible!</h4>

    <p class="text-gray-300">Until now, we haven’t considered the (further) cost of the generic player to identify the <span class="math">n</span> tuples with the required relationship <span class="math">\\mathcal{R}</span> that he must send to the verifier. That is, we have only considered the cost (as number of oracle-queries) to generate a sufficient number of (plaintexts, ciphertexts) pairs to guarantee that <span class="math">n</span> tuples with the required properties exist with a good probability. However, note that the player has to identify the <span class="math">n</span> tuples with the required properties before to send them to the verifier. As we show in App. D.1, the computational cost of this step is not negligible. In particular, we propose a modified version of the attack presented in Sect. 6.1 that allows to find the required <span class="math">n</span>-tuples and to minimize the total computational cost. As a final result, it follows that if the cost of this step is taken into account, then <span class="math">n=3</span> tuples are sufficient to set up our distinguisher on 9 rounds of AES. We refer to App. D.1 for all the details.</p>

    <h2 id="sec-30" class="text-2xl font-bold">8 10-Round Distinguisher of AES - Full AES-128</h2>

    <p class="text-gray-300">Using the same strategy proposed by Gilbert in <em>[x11]</em>, we set up our 10-round distinguisher by extending the 8-round one presented in <em>[x13]</em> and in Sect. 4.3 both at the beginning and at the end, or equivalently by extending our 9-round distinguisher presented in the previous section at the beginning.</p>

    <p class="text-gray-300">In the above defined known-key distinguisher scenario, the players have to send to the verifier <span class="math">n</span> different tuples of (plaintext, ciphertext) pairs, that is <span class="math">\\{(p_{i}^{1},c_{i}^{1}),(p_{i}^{2},c_{i}^{2})\\}</span> for <span class="math">i=0,...,n-1</span>, with the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there exists a key <span class="math">k^{0}</span> s.t. for each tuple there exists <span class="math">j</span> for which the two plaintexts belong to the same coset of <span class="math">\\mathcal{D}_{j}</span> after one round, that is</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\exists\\,k^{0}\\quad\\text{s.t.}\\quad\\forall i=0,...,n-1,\\quad\\exists j\\in\\{0,...,3\\}\\quad\\text{s.t.}\\quad R_{k^{0}}(p_{i}^{1})\\oplus R_{k^{0}}(p_{i}^{2})\\in\\mathcal{D}_{j};</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there exists a key <span class="math">k^{10}</span> s.t. for each tuple there exists <span class="math">l</span> for which the two ciphertexts belong to the same coset of <span class="math">\\mathcal{M}_{l}</span> one round before, that is</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\exists\\,k^{10}\\quad\\text{s.t.}\\quad\\forall i=0,...,n-1,\\quad\\exists l\\in\\{0,...,3\\}\\quad\\text{s.t.}\\quad R_{k^{10}}^{-1}(c_{i}^{1})\\oplus R_{k^{10}}^{-1}(c_{i}^{2})\\in\\mathcal{M}_{l}.</span></p>

    <p class="text-gray-300">We stress that the keys <span class="math">k^{0}</span> and <span class="math">k^{10}</span> must be equal for all the tuples, otherwise it is straightforwards to generate tuples with the required properties (same argumentation of the 9-round case). However, a difference with the previous 9-round distinguisher arises. In the previous case, the verifier must verify the existence of a single key (by finding it, if exists), since the property on the plaintexts can be verified directly on them without guessing any secret-key material. For the 10-round case instead, the verifier has to check the existence of both <span class="math">k^{0}</span> and <span class="math">k^{10}</span>. Thus, two possible scenarios can be considered and studied:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>no key-schedule holds - <span class="math">k^{0}</span> and <span class="math">k^{10}</span> are independent;</li>

      <li>AES key-schedule among <span class="math">k^{0}</span> and <span class="math">k^{10}</span>.</li>

    </ol>

    <p class="text-gray-300">Intuitively, the second case (i.e. with key schedule) is harder than the first one (i.e. without key schedule) for the generic player, since a further property must be verified. In other words, the time required by this player to generate the tuples for the second scenario is not lower than for the first one, or in other words the probability of success in the second scenario is not higher than in the first one.</p>

    <p class="text-gray-300">Before we present this distinguisher in detail, we highlight that the same strategy can be used to extend the 7-round known-key distinguisher of App. E.1 both at the beginning and at the end in order to set up the best 9-round known-key distinguisher from the computational point of view - its time complexity is approximately of <span class="math">2^{23}</span> computations. All the details are given in App. E.3.</p>

    <p class="text-gray-300">The Shortcut Player. First of all, we study the computational cost of the player who knows the key. For this player, the two scenarios (with/without key schedule) are completely identical. Indeed, using the 8-round distinguisher described in <em>[x10]</em> and in Sect. 4.3, he is able to generate <span class="math">n</span> tuples that satisfy all the conditions (included the key schedule without any additional cost). The computational cost of this player is well approximated by <span class="math">n\\cdot 2^{44}</span> computations.</p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">8.1 Independent Subkeys: No Key Schedule</h3>

    <p class="text-gray-300">The strategies used by the verifier and by the generic player depend on which scenario one considers, that is depend on the fact that the two keys <span class="math">k^{0}</span> and <span class="math">k^{10}</span> are independent or that a key schedule holds. Following the same strategy adopted by Gilbert in <em>[x13]</em>, as first case we assume that these two keys are independent.</p>

    <p class="text-gray-300">The Generic Player. For the 9-round distinguisher, the best strategy that the generic player could adopt was to choose plaintexts in the same coset of <span class="math">\\mathcal{D}_{j}</span>, in order to fulfill the requested property on the plaintexts. The idea is simply to adapt this strategy for this case, that is the idea is to choose plaintexts such that the condition on the plaintexts is fulfilled with probability 1.</p>

    <p class="text-gray-300">To do this, the generic player must fix a random key <span class="math">\\hat{k}</span>, and computes for a certain <span class="math">j\\in\\{0,...,3\\}</span> and for a random <span class="math">a\\in\\mathcal{D}_{j}^{\\perp}</span> the following set:</p>

    <p class="text-gray-300"><span class="math">D_{a}:=R_{\\hat{k}}^{-1}(\\mathcal{D}_{j}\\oplus a).</span> (8)</p>

    <p class="text-gray-300">The idea is choose/use plaintexts in this set <span class="math">D_{a}</span> just defined. In other words, the player works in the same way described for the 9-round distinguisher but using <span class="math">D_{a}</span> defined above instead of a coset of <span class="math">\\mathcal{D}_{j}</span>. The corresponding ciphertexts are simply got by oracle-queries. Since the cardinality of a coset of <span class="math">\\mathcal{D}_{j}</span> is <span class="math">2^{32}</span>, the computation of a set <span class="math">D_{a}</span> requires <span class="math">2^{32+4}=2^{36}</span> S-Box look-ups for each coset <span class="math">\\mathcal{D}_{j}\\oplus a</span>. Note that if the player needs more than <span class="math">2^{32}</span> (plaintext, ciphertext) pairs, he simply chooses another <span class="math">a^{\\prime}\\in\\mathcal{D}_{j}^{\\perp}</span> (or/and another <span class="math">j</span>)</p>

    <p class="text-gray-300">and, using the <em>same</em> key <span class="math">\\hat{k}</span>, he computes the corresponding set <span class="math">D_{a^{\\prime}}</span> defined as before. We emphasize that the player must use always the same key <span class="math">\\hat{k}</span> to compute these sets, in order to fulfill the property on the plaintexts.</p>

    <p class="text-gray-300">Given the set <span class="math">D_{a}</span>, the idea is to use the same strategy presented for the 9-round distinguisher in the previous section in order to find the <span class="math">n</span> tuples with the required properties. Since the procedure to choose tuples such that the requirement on the ciphertexts is fulfilled is identical to the one presented for the 9-round distinguisher, we refer to that section for more details. We stress that given plaintexts in the same set <span class="math">D_{a}</span>, the requirement on the plaintexts is always fulfilled since by construction there exists a key (which is <span class="math">\\hat{k}</span>) such that the plaintexts of each tuple belong to the same coset of <span class="math">\\mathcal{D}_{j}</span> after one round.</p>

    <p class="text-gray-300">As a result, the strategy and the computational cost used to find these <span class="math">n</span> tuples are (approximately) identical to the one presented in the previous section - note that the cost to compute the set <span class="math">D_{a}</span> is negligible compared to the total cost. It follows that <span class="math">n\\geq 8</span> tuples are sufficient for the case in which the cost of the generic player is approximated by the number of oracle-queries, while <span class="math">n\\geq 3</span> tuples are sufficient for the case in which all the costs (oracle-queries + cost of the player) are considered. As before, we choose an (arbitrary) value of <span class="math">n=64</span> in order to make the advantage of the shortcut player more significant.</p>

    <p class="text-gray-300">The Verifier. Given <span class="math">n</span> tuples, the verifier has to check the existence of keys <span class="math">k^{0}</span> and <span class="math">k^{10}</span> as defined previously. Since no key schedule is considered, the idea is simply to work independently on the plaintexts (in order to find <span class="math">k^{0}</span>) and on the ciphertexts (in order to find <span class="math">k^{10}</span>). Since the verifier performs two independent attacks (as described in Sect. 6.1) on the plaintexts and on the ciphertexts, the cost doubles with respect to the 9-round case. As for the previous case, note that the verification cost is much lower than the players costs.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">8.2 The Key Schedule Case</h3>

    <p class="text-gray-300">The scenario in which a key schedule holds is more complicated to analyze. Before we present our strategy, we recall the one adopted by Gilbert to set up his 10-round distinguisher. First he considers the case of AES with independent subkeys - denoted by <span class="math">\\text{AES}^{<em>}_{10}</span>, and he presents a 10-round known-key distinguisher for <span class="math">\\text{AES}^{</em>}</span>. Then, he simply observes that this known-key distinguisher on <span class="math">\\text{AES}^{<em>}_{10}</span> “</em>is obviously applicable without any modification to AES<span class="math">{}_{10}</span>, i.e. the full AES-128<em>” (see Sect. 4.2 - page 221 of </em>[x10]*). Using the same argumentation, we can easily conclude that also our distinguisher can be applied to real AES, i.e. to the case in which the key schedule holds. Indeed, as we have already pointed out, note that nothing changes for the shortcut player, while this scenario is more complicated for the generic player who doesn’t know the key, since a further condition on <span class="math">k^{0}</span> and <span class="math">k^{10}</span> (the key schedule) is imposed. Even if it is possible to refer to previous results, here we show that a less number of tuples can be sufficient to set up this distinguisher in the case in which the key schedule holds.</p>

    <p class="text-gray-300">The Verifier. Given <span class="math">n</span> tuples, the verifier has to check the existence of <span class="math">k^{0}</span> and <span class="math">k^{10}</span> that satisfy the AES key schedule and for which the properties on the plaintexts and on the ciphertexts are fulfilled. Working as before, the verifier can use several (equivalent) strategies, and here we focus on two of them.</p>

    <p class="text-gray-300">In the first case, the idea is to work again independently on the plaintexts and on the ciphertexts, and find independently the two keys. Only as final step, she checks if there exist keys <span class="math">k^{0}</span> and <span class="math">k^{10}</span> (among the ones found previously) that satisfy the key schedule. In the second case, the idea is to work only on the plaintexts and to find <span class="math">k^{0}</span> such that the property on the plaintexts is satisfied. When a candidate for <span class="math">k^{0}</span> is found using the <span class="math">n</span></p>

    <p class="text-gray-300">New and Old Limits for AES Known-Key Distinguishers</p>

    <p class="text-gray-300">tuples, the verifier finds <span class="math">k^{10}</span> using the key schedule and checks if the requirement on the ciphertexts is satisfied.</p>

    <p class="text-gray-300">For both these two cases, since on average only one key <span class="math">k^0</span> and one key <span class="math">k^{10}</span> is found if the number of tuples <span class="math">n</span> is greater or equal than 2, the computational cost for the verifier is comparable and well approximated by the cost of the (previous) case in which the subkeys are independent.</p>

    <p class="text-gray-300">The Generic Player. When the key schedule holds, the strategy presented before for the generic player must be modified since it is no more the best one. Indeed, suppose this player fixes a key <span class="math">k^0 = \\hat{k}</span> as before. It follows that the probability that <span class="math">\\hat{k}</span> (fixed) and a suitable <span class="math">k^{10}</span> satisfy the key schedule is only <span class="math">2^{-128}</span>, which implies that the probability of success is very low.</p>

    <p class="text-gray-300">For this reason, we present a modified strategy that he can use in this scenario. The idea is to look for plaintexts that maximize the number of keys <span class="math">k^0</span> and <span class="math">k^{10}</span> for which the requirements are satisfied (included the key-schedule). If we consider two random pairs of texts <span class="math">(p^1, c^1)</span> and <span class="math">(p^2, c^2)</span>, there are on average <span class="math">2^{34}</span> keys <span class="math">k^0</span> such that <span class="math">R_{k^0}(p^1) \\oplus R_{k^0}(p^2) \\in \\mathcal{D}_j</span> and <span class="math">2^{34}</span> keys <span class="math">k^{10}</span> such that <span class="math">R_{k^{10}}^{-1}(c^1) \\oplus R_{k^{10}}^{-1}(c^2) \\in \\mathcal{M}_l</span> for certain <span class="math">j</span> and <span class="math">l</span>. Thus, an initial key and a final one that satisfy the key schedule exist only with probability <span class="math">(2^{34})^2 \\cdot 2^{-128} = 2^{-60}</span>. Consider instead two plaintexts that belong to the same coset of <span class="math">\\mathcal{D}_j</span>. Since a coset of <span class="math">\\mathcal{D}_j</span> is mapped into a coset of <span class="math">\\mathcal{C}_j</span> (see Sect. 3.1), after one round the two texts belong to the same coset of <span class="math">\\mathcal{C}_j</span> for all the possible keys with probability 1. At the same time, it is possible to prove that there exist <span class="math">2^{106}</span> keys for which the two plaintexts belong to the same coset of <span class="math">\\mathcal{C}_j \\cap \\mathcal{D}_l \\subseteq \\mathcal{D}_l</span> after one round.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proposition 2. Let <span class="math">p^1</span> and <span class="math">p^2</span> two plaintexts that belong to the same coset of <span class="math">\\mathcal{D}_j</span> for a certain <span class="math">j</span>, that is <span class="math">p^1 \\oplus p^2 \\in \\mathcal{D}_j</span>. Moreover, assume that <span class="math">p^1 \\oplus p^2 \\notin \\mathcal{D}_j \\cap \\mathcal{C}_L</span> for each <span class="math">L \\subseteq \\{0,1,2,3\\}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 3<span class="math">. Then there exist on average </span>2^{106}<span class="math"> different keys </span>k<span class="math"> such that </span>R_k(p^1) \\oplus R_k(p^2) \\in \\mathcal{D}_l<span class="math"> for a certain </span>l \\in \\{0,1,2,3\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The proof is given in App. F. Thus, if one considers two couples <span class="math">(p^1, c^1)</span> and <span class="math">(p^2, c^2)</span> that satisfy the hypothesis of the previous proposition (in particular, <span class="math">p^1 \\oplus p^2 \\in \\mathcal{D}_l</span> for a certain <span class="math">l</span>), then there are on average <span class="math">2^{106}</span> keys <span class="math">k^0</span> such that <span class="math">R_{k^0}(p^1) \\oplus R_{k^0}(p^2) \\in \\mathcal{D}_i</span> and <span class="math">2^{34}</span> keys <span class="math">k^{10}</span> such that <span class="math">R_{k^{10}}^{-1}(c^1) \\oplus R_{k^{10}}^{-1}(c^2) \\in \\mathcal{M}_j</span>. It follows that there exist on average <span class="math">2^{106} \\cdot 2^{34} \\cdot 2^{-128} = 2^{12}</span> combinations of initial and final subkeys <span class="math">k^0</span> and <span class="math">k^{10}</span> that satisfy the key schedule. Even if we don't exclude better strategies, we conjecture that this is one of the best strategy that this player can use in order to maximize the number of keys <span class="math">(k^0, k^{10})</span> that satisfy the key schedule and the other required properties.</p>

    <h2 id="sec-33" class="text-2xl font-bold">8.2.1 Number <span class="math">n</span> of Tuples: Oracle-Queries.</h2>

    <p class="text-gray-300">Starting by these considerations, we show that <span class="math">n = 4</span> tuples are sufficient to set up the distinguisher when a key-schedule holds and when only the number of oracle-queries is considered (remember that for independent subkeys <span class="math">n</span> must be equal or greater than 8). First of all, working as in Sect. 7, note that given <span class="math">n</span> tuples (where the plaintexts are chosen as described previously), the probability that there exist keys <span class="math">(k^0, k^{10})</span> that satisfy the key schedule and for which the properties on the plaintexts/ciphertexts are satisfied is <span class="math">2^{12 \\cdot n} \\cdot 2^{-128 \\cdot (n - 1)} = 2^{-116 \\cdot n + 128}</span> instead of <span class="math">2^{-94 \\cdot n + 128}</span> (see Eq. (7)), since for each couple there are only <span class="math">2^{12}</span> possible combinations<span class="math">^{19}</span> of keys <span class="math">(k^0, k^{10})</span> instead of <span class="math">2^{34}</span>. Thus, using similar argumentation as before, in order to win the game the generic player must consider <span class="math">s</span> different couples, where <span class="math">s</span> is given by</p>

    <div class="my-4 text-center"><span class="math-block">s \\simeq 2^{116 - \\frac{128}{n}} \\cdot (n!)^{\\frac{1}{n}}. \\tag{9}</span></div>

    <p class="text-gray-300"><span class="math">^{19}</span> If two combinations <span class="math">(\\hat{k}^0, \\hat{k}^{10})</span> and <span class="math">(\\hat{k}^0, \\hat{k}^{10})</span> satisfy the key schedule, then they are equal with prob. <span class="math">2^{-128}</span> (e.g. if <span class="math">\\hat{k}^0 = \\hat{k}^0</span> then <span class="math">\\hat{k}^{10} = \\hat{k}^{10}</span> due to the key schedule).</p>

    <p class="text-gray-300">In particular, he has to consider at least <span class="math">2^{85.14}</span> different couples in order to find <span class="math">n=4</span> tuples that satisfy the requirements. Since each coset of <span class="math">\\mathcal{D}_{j}</span> contains <span class="math">2^{32}</span> different plaintexts (or approximately <span class="math">2^{63}</span> different couples), in order to generate <span class="math">n</span> couples that satisfy <span class="math">\\mathcal{R}</span> the generic player must do approximately</p>

    <p class="text-gray-300"><span class="math">2^{116-\\frac{128}{n}}\\cdot(n!)^{\\frac{1}{n}}\\cdot 2^{32-63}\\approx 2^{84-\\frac{128}{n}}\\cdot n\\cdot\\frac{(2\\pi\\cdot n)^{\\frac{1}{2n}}}{e}</span></p>

    <p class="text-gray-300">oracle-queries, where the last approximation is given by Stirling formula <span class="math">n!\\approx n^{n}\\cdot e^{-n}\\cdot\\sqrt{2\\pi\\cdot n}</span>. Thus, for <span class="math">n=4</span> he must consider approximately <span class="math">2^{22.14}</span> different cosets of <span class="math">\\mathcal{D}_{j}</span> defined as in (8), for a total of <span class="math">2^{54.14}</span> (plaintexts, ciphertexts) pairs. Thus, in the case in which the cost of the generic player is approximated by the number of oracle-queries, his cost is of approximately <span class="math">2^{54.2}</span> oracle-queries. On the other hand, the cost for the shortcut player to generate the same number of different tuples with the required properties is approximately of <span class="math">4\\cdot 2^{44}=2^{46}</span> computations, which is lower.</p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">8.2.2 Number <span class="math">n</span> of Tuples: Oracle-Queries and Cost of Generic Player.</h4>

    <p class="text-gray-300">As for the 9-round case, if one considers all the costs (that is the number of oracle-queries and the computational cost of the generic player) and if the key-schedule holds, it turns that a lower number of tuples (precisely <span class="math">n=2</span>) is sufficient. We refer to App. D.2 for details.</p>

    <h2 id="sec-35" class="text-2xl font-bold">9 12-Round Distinguisher of AES</h2>

    <p class="text-gray-300">As one of the major contributions of this paper, in this section we present the first known-key distinguisher for 12 rounds of AES. This distinguisher is obtained by extending the previous 10-round distinguisher both at the end and at the beginning, or equivalently by extending two times at the end and at the beginning the 8-round known-key distinguisher presented in <em>[x10]</em> and in Sect. 4.3. We highlight that this is the first known-key distinguisher for full AES-192 (and on 12 rounds of AES-128, i.e. full AES-128 with two more rounds) and it also provides a counterexample to the claims made in <em>[x13]</em>.</p>

    <p class="text-gray-300">In the know-key distinguisher scenario, the players have to send to the verifier <span class="math">n</span> different tuples of (plaintext, ciphertext) pairs, that is <span class="math">\\{(p_{i}^{1},c_{i}^{1}),(p_{i}^{2},c_{i}^{2})\\}</span> for <span class="math">i=0,...,n-1</span>, with the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there exist keys <span class="math">k^{0},k^{1}</span> s.t. for each tuple there exists <span class="math">j</span> for which the two plaintexts belong to the same coset of <span class="math">\\mathcal{D}_{j}</span> after two rounds, that is</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\exists\\,k^{0},k^{1}\\;\\;\\text{s.t.}\\;\\;\\forall i=0,...,n-1\\quad\\exists j\\in\\{0,...,3\\}\\;\\;\\text{s.t.}\\;\\;R_{k^{0},k^{1}}^{2}(p_{i}^{1})\\oplus R_{k^{0},k^{1}}^{2}(p_{i}^{2})\\in\\mathcal{D}_{j};</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there exist keys <span class="math">k^{11},k^{12}</span> s.t. for each tuple there exists <span class="math">l</span> for which the two ciphertexts belong to the same coset of <span class="math">\\mathcal{M}_{l}</span> two rounds before, that is</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\exists k^{11},k^{12}\\;\\text{s.t.}\\;\\;\\forall i=0,...,n-1\\;\\;\\exists l\\in\\{0,...,3\\}\\;\\text{s.t.}\\;\\;R_{k^{11},k^{12}}^{-2}(c_{i}^{1})\\oplus R_{k^{11},k^{12}}^{-2}(c_{i}^{2})\\in\\mathcal{M}_{l};</span></p>

    <p class="text-gray-300">where <span class="math">R_{k^{0},k^{1}}^{2}(\\cdot)\\equiv R_{k^{1}}(R_{k^{0}}(\\cdot))</span> and <span class="math">R_{k^{11},k^{12}}^{-2}(\\cdot)\\equiv R_{k^{11}}^{-1}(R_{k^{12}}^{-1}(\\cdot))</span>.</p>

    <p class="text-gray-300">As for the known-key distinguisher for 10-round AES, two scenarios can be considered, that is the case of independent subkeys and the case in which the key schedule holds. For the following, we consider only the first scenario, that is we limit ourselves to present a known-key distinguisher for 12-round of AES with independent subkeys. However, using similar argumentation as before, we claim that the same distinguisher can be applied to the case in which the key schedule holds. In particular, we remember that nothing change for</p>

    <p class="text-gray-300">the shortcut player (who knows the key) in this second case, while the challenge becomes much harder for the other player.</p>

    <p class="text-gray-300">The strategy used by the players and by the verifier is very similar to the one presented for the 10-round distinguisher in the case of no key-schedule. Thus, we refer to the previous section for all the details, and we limit here to highlight the idea and the major differences.</p>

    <p class="text-gray-300">The Two Players. Exactly as before, the shortcut player can generate <span class="math">n</span> tuples with the required properties for a cost of <span class="math">n\\cdot 2^{44}</span> computations.</p>

    <p class="text-gray-300">The generic player exploits the same strategy proposed for the 10-round distinguisher with no key-schedule. First he fixes random keys <span class="math">\\hat{k}^{0},\\hat{k}^{1}</span> and <span class="math">\\hat{k}^{12}</span>, and using the keys <span class="math">\\hat{k}^{0}</span> and <span class="math">\\hat{k}^{1}</span>, he computes the set <span class="math">D_{a}=R_{\\hat{k}^{0}}^{-1}(R_{\\hat{k}^{1}}^{-1}(\\mathcal{D}_{j}\\oplus a))</span>. Similar to the previous case, the idea is to work with plaintexts in the same set <span class="math">D_{a}</span>. He then gets the corresponding ciphertexts by oracle-queries, and the idea is simply to decrypt them using the key <span class="math">\\hat{k}^{12}</span>. As a result, using the same strategy proposed for the 9- and 10-round distinguisher, he can construct <span class="math">n</span> tuples that satisfy the relation <span class="math">\\mathcal{R}</span>, that is he is able to find <span class="math">n</span> tuples for which a common key <span class="math">k^{11}</span> exists such that the requirement on the ciphertexts is satisfied.</p>

    <p class="text-gray-300">By analogous calculation as before, at least <span class="math">n\\geq 8</span> tuples are sufficient to set up the distinguisher when only the number of the oracle-queries is considered.</p>

    <p class="text-gray-300">The Verifier. When the verifier receives the <span class="math">n</span> tuples, she can use the following strategy to check if the required properties are satisfied or not. First of all, since there is no key schedule, the verifier can work independently on <span class="math">k^{0},k^{1}</span> (that is on the plaintexts) and on <span class="math">k^{11},k^{12}</span> (that is on the ciphertexts). Similarly to the previous cases where the verifier uses the key-recovery attack of Sect. 6.1 to find the keys, for this 12-round distinguisher the idea is to exploit the key-recovery attack presented in Sect. 6.2 to find (if exist) the four keys <span class="math">k^{0},k^{1}</span> and <span class="math">k^{11},k^{12}</span>.</p>

    <p class="text-gray-300">We present in details the verification procedure for the ciphertexts case (analogous for the plaintexts). Given the first tuple and using the strategy described in Sect. 6.2, the verifier guesses eight bytes of the final subkey <span class="math">k^{12}</span> (two diagonals), decrypts partially, and finds <span class="math">2^{34}</span> values for eight bytes of <span class="math">k^{11}</span> working as in Sect. 6.1, for a total of <span class="math">2^{34}\\cdot 2^{64}=2^{98}</span> candidates. Then, she eliminates wrong candidates by testing them using the other tuples - to reduce the computational cost, she can work independently on each column of <span class="math">k^{11}</span>. Note that the probability that found subkeys <span class="math">k^{11}</span> and <span class="math">k^{12}</span> satisfy the required property for another tuple is <span class="math">4\\cdot 2^{-32}=2^{-30}</span>. Thus, using other four tuples, with high probability the verifier finds approximately only on pair of subkeys <span class="math">k^{11}</span> and <span class="math">k^{12}</span> for which the property on the ciphertexts is satisfied (note <span class="math">2^{98}\\cdot(2^{-30})^{4}=2^{-22}</span>). The cost of this step is of <span class="math">2^{76}</span> table look-ups (using the pre-computation phase), as shown in Sect. 6.2 or in <em>[x13]</em> in more details. The remaining eight bytes of <span class="math">k^{11}</span> and of <span class="math">k^{12}</span> and the subkeys <span class="math">k^{0}</span> and <span class="math">k^{1}</span> can be found in a similar way.</p>

    <p class="text-gray-300">As a result, given 5 different tuples, the total cost for this attack is approximately of <span class="math">4\\cdot 2^{76}=2^{78}</span> table look-ups (using the pre-computation phase). When the verifier has found possible candidates for the four keys, she checks that also the other <span class="math">n-5</span> tuples satisfy the relation <span class="math">\\mathcal{R}</span> for the found keys. In conclusion, given <span class="math">n\\geq 5</span> tuples, the total cost for the verifier can be approximated at <span class="math">2\\cdot(2^{78}+2^{6}\\cdot(n-5))</span> table look-ups. If <span class="math">n\\ll 2^{72}</span>, then the computational cost of the verifier is approximately <span class="math">2^{71.1}</span> twelve-round encryptions.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">Number <span class="math">n</span> of Tuples.</h4>

    <p class="text-gray-300">As we have just seen, it is possible to set up the distinguisher for <span class="math">n</span> equal or greater than 8. However, if <span class="math">n=8</span> then the cost of the shortcut player (<span class="math">2^{47}</span> computations) is much lower than the cost of the verifier (<span class="math">2^{71.1}</span> computations), which is not consistent with the given definition of known-key distinguisher (see Sect. 4.1). Indeed, by definition the verification cost must be less than the cost of the shortcut players (and so the cost of the generic</p>

    <p class="text-gray-300">Lorenzo Grassi and Christian Rechberger</p>

    <p class="text-gray-300">player), that is the entire cost of the distinguisher (computational cost of the shortcut player + verification cost) must be well approximated by the cost of the shortcut player. In order to fulfill this condition, it is sufficient to choose a number of tuple <span class="math">n</span> that satisfy the condition <span class="math">n \\cdot 2^{44} \\gg 2^{71.1}</span> (and <span class="math">n \\ll 2^{72}</span>). It follows that a good (arbitrary) choice for this distinguisher could be <span class="math">n \\geq 2^{38}</span>.</p>

    <p class="text-gray-300">In conclusion, to win the game, the two players have to send <span class="math">2^{38}</span> tuples of (plaintext, ciphertext) pairs with the required properties. The cost for the shortcut player is of <span class="math">2^{82}</span> computations, while the verification cost is of <span class="math">2^{71.1}</span> computations. Note that even if this result is obtained considering only the number of the oracle-queries and the case of independent subkeys, it holds also for the cases in which all the costs are considered and/or the key schedule holds. Indeed, it is simple to observe that also in these cases (1) the choice of a suitable number <span class="math">n</span> is more influenced by the request that the verification cost is lower than the cost to generate the <span class="math">n</span> tuples and (2) the game becomes harder for the generic player, while nothing changes for the shortcut one.</p>

    <p class="text-gray-300">In this section, we show that the Gilbert's 10-round distinguisher can be extended to 12-round still exploiting the uniform distribution property. In [Gil14], the main argumentation about the impossibility of such extension regards the impossibility to efficiently check the relationship <span class="math">\\mathcal{R}</span> when more than a single round is add a beginning (resp. at the end) of the 8-round distinguisher<span class="math">^{21}</span>. In Sect. 5.3 we have proposed another strategy that the verifier can used in order to check the property on 10-round of the Gilbert's 10-round distinguisher. In particular, we have showed that the verifier can filter (almost all) wrong key candidates working independently on each byte of the key. This is the starting point in order to extend the distinguisher based on the uniform distribution property on 12 rounds. In the following, we first formal define the 12-round distinguisher based on the uniform distribution property, and - after showing that <span class="math">\\mathcal{R}</span> is efficiently checkable - we prove that this new 12-round distinguisher is meaningful using the same argumentations given by Gilbert in [Gil14] for the 10-round case.</p>

    <p class="text-gray-300">Using the Gilbert's 10-round distinguisher as starting point, a formal definition of the 12-round known-key distinguisher based on the uniform distribution property is given in the following. In the known-key distinguisher scenario, the players have to send to the verifier <span class="math">n \\geq 1</span> different sets of <span class="math">2^{64}</span> (plaintext, ciphertext) pairs, that is <span class="math">(p_i^j, c_i^j)</span> for <span class="math">i = 0, \\dots, 2^{64} - 1</span> and <span class="math">j = 0, \\dots, n - 1</span>, with the following properties:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. there exist keys <span class="math">k^0, k^1</span> such that for all <span class="math">j = 0, \\dots, n - 1</span> the texts <span class="math">\\{R_{k^1}(R_{k^0}(p_i^j))\\}_i</span> are uniform distributed among the cosets of <span class="math">\\mathcal{D}_I</span> for each <span class="math">I \\subseteq \\{0, 1, 2, 3\\}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 3<span class="math">, or equivalently such that for all </span>j = 0, \\dots, n - 1<span class="math"> the bytes of the texts </span>\\{R_{k^1}(R_{k^0}(p_i^j))\\}_i$ are uniform distributed;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. there exist keys <span class="math">k^{11}, k^{12}</span> such that for all <span class="math">j = 0, \\dots, n - 1</span> the texts <span class="math">\\{R_{k^{11}}^{-1}(R_{k^{12}}^{-1}(c_i^j))\\}_i</span> are uniform distributed among the cosets of <span class="math">\\mathcal{M}_J</span> for each <span class="math">J \\subseteq \\{0, 1, 2, 3\\}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 3<span class="math">, or equivalently such that for all </span>j = 0, \\dots, n - 1<span class="math"> the bytes of the texts </span>\\{MC^{-1} \\circ R_{k^{11}}^{-1}(R_{k^{12}}^{-1}(c_i^j))\\}_i$ are uniform distributed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">^{20}</span>By previous analysis, we remember that the cost of the shortcut player is always lower than the cost of the generic player for each value of <span class="math">n</span> that satisfies <span class="math">n \\geq 8</span>.</p>

    <p class="text-gray-300"><span class="math">^{21}</span>Observe that in [Gil14] the verifier works simultaneously on 4 bytes of the key. If one adds another round, it follows that the only way to decrypt two rounds to check a particular property is to guess one full subkey. This implies that the cost of the verifier is higher than <span class="math">2^{128}</span>, that is higher than the costs of the two players.</p>

    <p class="text-gray-300">As for Gilbert’s distinguisher, we assume that all the subkeys are independent, that is no key-schedule holds. However, the same distinguisher distinguisher works exactly in the same way also in the case in which a key-schedule holds. Indeed, as we have just seen, in the case in which the key-schedule holds the game becomes harder for the generic player (since more conditions on the keys are imposed), while there is no difference for the shortcut player. We emphasize that the keys <span class="math">k^{0},k^{1},k^{11}</span> and <span class="math">k^{12}</span> for which the previous properties are satisfied must be the same for all the sets of <span class="math">2^{64}</span> texts. In other words, given <span class="math">n</span> sets such that the first set satisfies the property of uniform distribution for keys <span class="math">k^{0},k^{1}</span>, the second for keys <span class="math">\\hat{k}^{0},\\hat{k}^{1}</span> and so on, then the required properties can not be considered fulfilled.</p>

    <p class="text-gray-300">In the following, we show that such distinguisher is meaningful if <span class="math">n\\geq 2</span>. In particular, using the same argumentation proposed by Gilbert for the 8- and 10-round cases, we have chosen to set up a distinguisher on 12 rounds for <span class="math">n\\geq 4</span> - even if the distinguisher can be set up also for <span class="math">n=2</span>, our choice of <span class="math">n=4</span> is due in order to make the advantage of the shortcut player more significant. Using the same strategy proposed for the 8-round distinguisher and for the 10-round one (note that the keys <span class="math">k^{0},k^{1}</span> and <span class="math">k^{11},k^{12}</span> correspond to the secret sub-keys), the cost of the shortcut player to construct the <span class="math">n=4</span> sets of <span class="math">2^{64}</span> (plaintext, ciphertext) pairs with the required properties is of <span class="math">2^{66}</span> encryptions. In the following, we show that (1) the verification cost is lower than <span class="math">2^{66}</span> encryptions and that (2) the probability of victory of the shortcut player using <span class="math">2^{66}</span> oracle queries is negligible.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">10.0.1 The Verification Process</h4>

    <p class="text-gray-300">In order to prove that such distinguisher is meaningful if <span class="math">n\\geq 2</span>, we study the verifier role. As before, the idea is to set up the verification process by filtering wrong keys by checking zero-sum property, and then to check if the uniform distribution property is satisfied only for those keys for which the balance property holds.</p>

    <p class="text-gray-300">Consider the case in which the final MixColumns operation is omitted - if it is not omitted, it is sufficient to swap the final MixColumns and the final AddRoundKey - and the case in which the attacker looks for keys <span class="math">k^{11},k^{12}</span> (analogous for <span class="math">k^{0},k^{1}</span>). Using a classical square attack with the extension at the end - see <em>[x12]</em> for all the details - the verifier guesses 5 bytes of the keys, that is 4 bytes (i.e. one anti-diagonal) of the last subkey <span class="math">k^{12}</span> and 1 byte of the subkey <span class="math">k^{11}</span>. She first uses the 4 bytes of the last key to partially decrypt one round, and then working on each byte independently of the others she simply checks that the zero-sum property holds 2-round before. The complete pseudo-code is given in Algorithm 4, where the verifier looks for 4 bytes of the last subkey <span class="math">k^{12}</span> and (simultaneously) for 4 of the subkey <span class="math">k^{11}</span>.</p>

    <p class="text-gray-300">Working on 4 bytes, the zero-sum property is satisfied with prob. <span class="math">2^{-32}</span>. Since the verifier tests <span class="math">2^{32}</span> values of 4 bytes of <span class="math">k^{12}</span> and <span class="math">2^{32}</span> of 4 bytes of <span class="math">k^{11}</span>, we expect that using a single set (i.e. <span class="math">n=1</span>) of <span class="math">2^{64}</span> texts, then <span class="math">2^{64}\\cdot 2^{-32}=2^{32}</span> combinations of these 8 bytes pass this first test (analogous for the other 4 combinations of 8 bytes). The idea is to test these <span class="math">2^{32}</span> combinations using the second set of texts (thus, <span class="math">n\\geq</span>). It follows that on average only 1 combination of these 8 bytes of the keys passes the test. Using the same procedure, the verifier is able to find keys <span class="math">k^{12}</span> and <span class="math">k^{11}</span> for which the zero-sum property is satisfied. The idea is finally to use Algorithm 1 to check if also the uniform distribution property is satisfied, as for the 10-round case. Observe that choosing <span class="math">n&gt;2</span>, the probability that wrong-guessed keys pass the zero-sum property becomes lower.</p>

    <p class="text-gray-300">What is the computational cost of the verifier? First of all, given 2 sets of <span class="math">2^{64}</span> texts the verifier must compute the array <span class="math">A</span> as defined in Algorithm 4 and Algorithm 1. The cost of this step is given by <span class="math">2\\cdot 2^{64}</span> look-ups table (note that all these arrays can be computed and stored at the same time).</p>

    <p class="text-gray-300">Focusing on Algorithm 4, in order to compute the arrays <span class="math">B</span>, the verifier must compute <span class="math">2^{32}\\cdot 2^{32}\\cdot 4=2^{66}</span> S-Box and <span class="math">2^{32}\\cdot 2^{32}\\cdot 2=2^{65}</span> look-ups table. Given the arrays <span class="math">B</span>, the</p>

    <p class="text-gray-300">Lorenzo Grassi ^{1} and Christian Rechberger ^{1,2}</p>

    <p class="text-gray-300">Data: 2 sets of  <span class="math">2^{64}</span>  texts  <span class="math">t^i</span>  and  <span class="math">\\hat{t}^i</span>  for  <span class="math">i = 0, \\dots, 2^{64} - 1</span></p>

    <p class="text-gray-300">Result: One anti-diagonal of  <span class="math">k^{12}</span>  - e.g.  <span class="math">(k_{0,0}^{12}, k_{1,3}^{12}, k_{2,2}^{12}, k_{3,1}^{12})</span>  - and one column of  <span class="math">k^{11}</span>  -  <span class="math">(k_{0,0}^{11}, k_{1,0}^{11}, k_{2,0}^{11}, k_{3,0}^{11})</span>  - s.t.  <span class="math">\\bigoplus_{i} R_{k^{11}}^{-1} \\circ R_{k^{12}}^{-1}(p^i)_{j,k} = 0</span>  for each  <span class="math">j = k</span></p>

    <p class="text-gray-300">Let  <span class="math">A_{j}[0,\\dots,2^{32} - 1]</span>  and  <span class="math">B_{j}^{0}[0,\\dots,255], B_{j}^{1}[0,\\dots,255], B_{j}^{2}[0,\\dots,255], B_{j}^{3}[0,\\dots,255]</span>  ten arrays initialized to zero for  <span class="math">j = 0,1</span> ;</p>

    <p class="text-gray-300">for  <span class="math">i</span>  from  <span class="math">\\theta</span>  to  <span class="math">2^{64} - 1</span>  do</p>

    <pre><code class="language-latex">$x\\gets t_{0,0}^{i} + 2^{8}\\cdot t_{1,3}^{i} + 2^{16}\\cdot t_{2,2}^{i} + 2^{24}\\cdot t_{3,1}^{i};$ $A_0[x]\\gets (A_0[x] + 1)\\bmod 2;\\qquad / / A[x]$  denotes the value stored in the  $x$  -th address of the array  $A\\hat{x}\\leftarrow \\hat{t}_{0,0}^{i} + 2^{8}\\cdot \\hat{t}_{1,3}^{i} + 2^{16}\\cdot \\hat{t}_{2,2}^{i} + 2^{24}\\cdot \\hat{t}_{3,1}^{i};$ $A_{1}[\\hat{x} ]\\gets (A_{1}[x] + 1)\\bmod 2;$</code></pre>

    <p class="text-gray-300">end</p>

    <p class="text-gray-300">for  <span class="math">k^{12}</span>  from  <span class="math">(0z00,0z00,0z00,0z00)</span>  to  <span class="math">(0xff,0xff,0xff,0xff)</span>  do</p>

    <pre><code class="language-txt">for  $s$  from  $(0z00,0z00,0z00,0z00)$  to  $(0xff,0xff,0xff,0xff)$  do
Let  $s\\equiv (s^0,s^1,s^2,s^3)\\in \\mathbb{F}_{2^8}^4$  is a column of 4 bytes;
Compute  $x\\equiv MC^{-1}\\circ R_{k^{12}}(s)$  // partial decryption of  $s$  w.r.t. to  $k$  - note:  $x\\equiv (x^{1},x^{2},x^{3},x^{4})\\in \\mathbb{F}_{2^{8}}^{4}$  is a column of 4 bytes
$B_j^k [x^k ]\\gets (B_j^k [x^k ] + A_j[i])$  mod 2 for each  $j = 0,1$  and  $k = 0,1,2,3$
end
for  $k_{0,0}^{11}$  from 0z00 to 0xff do
$x\\gets \\bigoplus_{i = 0}^{256}B_0^0 [i]\\cdot \\mathrm{S - Box^{-1}}(i\\oplus k_{0,0}^{11});$  //  $B[i]$  can only be 0 or 1
$\\hat{x}\\gets \\bigoplus_{i = 0}^{256}B_1^0 [i]\\cdot \\mathrm{S - Box^{-1}}(i\\oplus k_{0,0}^{11});$
if  $x = \\hat{x} = 0$  then
Find  $k_{1,0}^{11},k_{2,0}^{11}$  and  $k_{3,0}^{11}$  by repeating the last step;
if zero-sum satisfied then
Identify one anti-diagonal of  $k^{12}$  and one column of  $k^{11}$  as possible
key;
end
end</code></pre>

    <p class="text-gray-300">end</p>

    <p class="text-gray-300">return candidates for  <span class="math">k^{12}</span>  and  <span class="math">k^{11}</span> .</p>

    <p class="text-gray-300">Algorithm 4: First Part of Verifier Strategy: filter wrong key candidates using zero-sum property.</p>

    <p class="text-gray-300">cost to find the candidates for 4 bytes of the key  <span class="math">k^{12}</span>  and 4 bytes of key  <span class="math">k^{11}</span>  is given by  <span class="math">2^{32} (\\equiv k^{12}) \\cdot (4 \\cdot 2^8) (\\equiv k^{11}) \\cdot 2^8 \\cdot 2 = 2^{51}</span>  S-Box and  <span class="math">2^{51}</span>  table look-ups. Assuming that the cost of 1 S-Box look-up is equivalent to the cost of 1 table look-up <span class="math">^{22}</span> , the total cost of the verifier to compute Algorithm 4 and to find the entire keys (i.e.  <span class="math">k^0, k^1</span>  and  <span class="math">k^{11}, k^{12}</span> ) is given by  <span class="math">2 \\cdot 4 \\cdot (2^{66} + 2^{65} + 2 \\cdot 2^{51}) \\simeq 2^{69.6}</span>  table look-ups, or equivalently  <span class="math">2^{61.8}</span>  12-round encryptions.</p>

    <p class="text-gray-300">For the (few) candidates of the key that satisfy zero-sum, the verifier tests the uniform distribution property. Given  <span class="math">n</span>  sets of texts and using Algorithm 1 only for the keys found by Algorithm 4, the total cost is well approximated by  <span class="math">2^{69.6} + n \\cdot 2^{64}</span>  table look-ups (note that the cost of the 2-round decryption/encryption is approximately  <span class="math">n \\cdot 16 \\cdot 4 \\cdot 2^{32} \\simeq n \\cdot 2^{38}</span>  S-Box look-ups, so it is negligible), that is  <span class="math">2^{61.8} + n \\cdot 2^{56.1}</span>  12-round encryptions. It follows that the cost of the verifier is lower than the costs of the two players (which is higher than  <span class="math">n \\cdot 2^{64}</span>  encryptions).</p>

    <p class="text-gray-300">Only for completeness, we highlight that the verifier can use the “Partial-Sum” key-recovery attack <em>[FKL^{+}01]</em> - <em>[x20]</em> in order to find the required keys faster.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">10.0.2 On the Meaningfulness of this Distinguisher</h4>

    <p class="text-gray-300">First of all, what is the probability that given a set of <span class="math">2^{64}</span> texts there exist keys <span class="math">\\hat{k}^{1}</span> and <span class="math">\\hat{k}^{2}</span> such that the bytes of 2-round encryptions (resp. decryptions) of such texts are uniform distributed? Using the previous calculation and since there are <span class="math">(2^{128})^{2}=2^{256}</span> different keys, this probability is equal to <span class="math">2^{256}\\cdot p\\simeq 2^{256}\\cdot 2^{-7328.1}=2^{-7072.1}\\equiv 2^{-2^{12.78}}</span> where <span class="math">p</span> is defined in (5). In other words, this is the probability that, given <span class="math">2^{64}</span> (plaintext, ciphertext) pairs such that the bytes of the plaintexts are uniform distributed after 2-round, there exist keys <span class="math">k^{11},k^{12}</span> for which the bytes of the ciphertexts are uniform distributed 2-round before.</p>

    <p class="text-gray-300">More generally, given <span class="math">2^{64}</span> random pairs of texts, the probability that exist keys <span class="math">k^{0},k^{1}</span> and <span class="math">k^{11},k^{12}</span> for which the bytes of the plaintexts/ciphertexts are uniform distributed after 2-round encryption/decryption is <span class="math">2^{512}\\cdot 2^{-7328.1}=2^{-6816.1}\\equiv 2^{-2^{12.73}}</span>. Thus, similar to the 8-round case, it follows that <span class="math">2^{64}+2^{12}\\simeq 2^{64}</span> - random - (plaintext, ciphertext) pairs are sufficient to have good probability to win the game. In other words, the generic player can find <span class="math">n</span> sets of <span class="math">2^{64}</span> texts with the required property by doing approximately <span class="math">n\\cdot(2^{64}+2^{12})\\simeq n\\cdot 2^{64}</span> oracle queries - with random plaintexts/ciphertets (as before this number doesn’t take into account the cost to find the required pairs of texts). Before we go on, we emphasize that if the keys schedule holds (i.e. the subkeys are not independent), then the number of different subkeys is <span class="math">2^{128}</span> and not <span class="math">2^{512}</span>.</p>

    <p class="text-gray-300">As before, a natural question arises: why is this distinguisher meaningful? As for the 8- and the 10-round cases, instead to focus on the cost of the players and using similar argumentation to the ones proposed by Gilbert, we show that the probability of the generic player to win the game given <span class="math">n\\geq 2</span> sets of <span class="math">2^{64}</span> texts is negligible. To do this, we claim that this probability is upper bounded by the probability of the following “related” game. Assume <span class="math">n=2</span> and consider 2 sets of <span class="math">2^{64}-d</span> (plaintext, ciphertext) pairs for <span class="math">d\\geq 5</span>, that is <span class="math">(p^{i},c^{i})</span> for each <span class="math">i=0,...,2^{64}-d-1</span>, with the following property: there is a set of keys <span class="math">k^{0},k^{1}</span> and <span class="math">k^{11},k^{12}</span> - which can correspond to the set of the entire keys - such that for each one of the two sets, the bytes of <span class="math">R_{k^{1}}\\circ R_{k^{0}}(p^{i})</span> and of <span class="math">MC^{-1}\\circ R_{k^{11}}^{-1}\\circ R_{k^{12}}^{-1}(c^{i})</span> (that is 2-round encryption of <span class="math">p^{i}</span> and the 2-round decryption of the ciphertexts) are “almost uniform” w.r.t. the definition given before. The goal of the player is to find <span class="math">2\\cdot d</span> texts such that - for each one of the two sets - the bytes of the <span class="math">2^{64}</span> texts of each set after 2-round encryption/decryption are uniform distributed. Since this probability is upper bounded by <span class="math">2^{-25}</span> - as we are going to show - and since this second game is “related” to the original one, the conclusion follows immediately.</p>

    <p class="text-gray-300">More formally, using the same argumentation proposed by Gilbert, we prove the following statement.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Proposition 3.</h6>

    <p class="text-gray-300">For any oracle algorithm <span class="math">\\mathcal{A}</span> that makes <span class="math">\\leq N=2\\cdot 2^{64}=2^{65}</span> oracle queries to a perfect random permutation <span class="math">\\Pi</span> or <span class="math">\\Pi^{-1}</span> of <span class="math">\\{0,1\\}^{128}</span>, the probability that <span class="math">\\mathcal{A}</span> outputs <span class="math">n\\geq 2</span> sets of <span class="math">2^{64}</span>-tuple <span class="math">(X_{i},Y_{i})</span> for <span class="math">i=0,...,2^{64}-1</span> of <span class="math">\\Pi</span> that satisfies <span class="math">Y_{i}=\\Pi(X_{i})</span> and also satisfies <span class="math">\\mathcal{R}</span> defined previously is upper bounded by <span class="math">\\binom{10}{5}\\times 2^{512}\\times\\left(\\frac{5^{16}}{2^{128}-(2^{64}-5)}\\right)^{6}\\approx 2^{-25}</span>.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">If at least one of the <span class="math">N</span> pairs <span class="math">(X_{i},Y_{i})</span> output by <span class="math">\\mathcal{A}</span> does not result from a query <span class="math">X_{i}</span> to <span class="math">\\Pi</span> or a query <span class="math">Y_{i}</span> to <span class="math">\\Pi^{-1}</span>, then the probability that for this pair <span class="math">Y_{i}=\\Pi(X_{i})</span> and consequently the success probability of <span class="math">\\mathcal{A}</span> is upper bounded by <span class="math">\\frac{1}{2^{n}-(N-1)}</span>. So from now on we only consider the opposite case, i.e. all the <span class="math">(X_{i},Y_{i})</span> result from queries to <span class="math">\\Pi</span> or <span class="math">\\Pi^{-1}</span>.</p>

    <p class="text-gray-300">As we have already said, a set of <span class="math">N</span> texts is uniform distributed if any subset is “almost” uniform distributed w.r.t. the definition given before. Following the same argumentation provided by Gilbert for the 10-round case, we consider 2 sets of <span class="math">2^{64}-5</span> (plaintext, ciphertext)</p>

    <p class="text-gray-300">Lorenzo Grassi and Christian Rechberger</p>

    <p class="text-gray-300">pairs which are “almost” uniform distributed for a set of keys <span class="math">k^0, k^1</span> and <span class="math">k^{11}, k^{12}</span> after 2-rounds decryption/encryption, and we study the probability of the generic player to find the remaining <span class="math">2 \\cdot 5 = 10</span> pairs such that there exist keys <span class="math">k^0, k^1</span> and <span class="math">k^{11}, k^{12}</span> for which the bytes of the 2 corresponding sets of <span class="math">2^{64}</span> are uniform distributed after 2-round encryption/decryption. As shown by Gilbert - see proof of Prop. 6 in [Gil14], for each one of the two sets the probability that 5 pairs satisfy this condition is upper bounded by <span class="math">\\left(\\frac{5^{16}}{2^{128} - (2^{64} - 5)}\\right)^3</span>. Moreover, observe that the player does 10 oracle queries, which can be divided in <span class="math">\\binom{10}{5} = 252</span> different sets of 5 elements. Since the <span class="math">2^{512}</span> four subkeys are considered to be independent and must be equal for the two sets, one gets the claimed upper bound about the total probability of <span class="math">\\binom{10}{5} \\times 2^{512} \\times \\left(\\frac{5^{16}}{2^{128} - (2^{64} - 5)}\\right)^6 \\approx 2^{-25}</span>. □ □</p>

    <p class="text-gray-300">The same strategy applies for any <span class="math">n \\geq 2</span>. In particular, if <span class="math">n = 4</span> the probability becomes <span class="math">\\binom{20}{5} \\times \\binom{15}{5} \\times \\binom{10}{5} \\times 2^{512} \\times \\left(\\frac{5^{16}}{2^{128} - (2^{64} - 5)}\\right)^{12} \\approx 2^{-544.7}</span>.</p>

    <p class="text-gray-300">In this paper, we have shown that Gilbert's known-key distinguisher model can lead to results on more rounds than previous expected. Even though the core distinguisher remains at 8 rounds, 12 instead of 10 rounds are achieved. This may raise the question: How meaningful is this distinguisher model? We claim that it appears meaningful in the sense that it does not seem to allow results on an arbitrary number of rounds.</p>

    <p class="text-gray-300">We analyze this claim in more details, assuming by contradiction the existence of a meaningful known-key distinguisher on 14 rounds of AES (to be meaningful, we assume that the probability of the shortcut player to win the game is higher than the one of the generic player). The main criticism in order to extend a known-key distinguisher both at the end and at the beginning as in the Gilbert model regards the computational cost to verify the existence of keys such that the <span class="math">n</span> tuples of (plaintexts, ciphertexts) pairs satisfy the relation <span class="math">\\mathcal{R}</span>. We stress that the verification cost must be lower than the players costs. Thus, consider the known-key distinguishers that exploit the uniform distribution property - where zero-sum property is used to filter wrong keys - or a truncated differential trail. In order to extend 1 round at the beginning and at the end, a classical key recovery attack - as the integral attack [DKR97] and the truncated differential attack [GRR17] - is sufficient for this task. In order to extend 2 rounds as for the distinguishers presented in this paper, the idea is to use a key recovery attack with an extension at the end, e.g. the integral attack with an extension at the end [DKR97] and the truncated differential attack of Sect. 6.2. In a similar way, in order to extend for <span class="math">r \\geq 3</span> rounds, one needs a key-recovery attack with two extensions at the end, that is more than a single one<span class="math">^{23}</span>. Since balance and/or truncated differential attacks with this property don't exist in literature for AES-128<span class="math">^{24}</span> and since it seems very unlikely to set up them without guessing an entire subkey (which leads to a brute force attack), we claim that it is not possible to extend the 8-round distinguishers currently present in the literature for more than 4 rounds, that is 2 rounds at the end and 2 at the beginning. We leave the open problem to confute our claims for future investigations.</p>

    <p class="text-gray-300"><span class="math">^{23}</span>In App. G we show why attacks with both an extension at the end and at the beginning are completely useless for this scope, taking as example the partial-sum attack on 7 rounds of AES-128 presented in [FKL+01] - also known as herds attack.</p>

    <p class="text-gray-300"><span class="math">^{24}</span>Note that for AES-256 it is possible to set up such attacks by simply guessing an entire subkey. However, since the complexity of such attacks is higher than <span class="math">2^{128}</span> (an entire subkey is guessed), the verification cost is higher than the costs of the players.</p>

    <p class="text-gray-300">New and Old Limits for AES Known-Key Distinguishers</p>

    <p class="text-gray-300">In this paper, we improve all the known-key distinguishers (or present conjectures for such known-key distinguishers) currently present in the literature for AES from 7 up to 10 rounds of AES and we set up the first known-key distinguishers on 12 rounds of AES, by extending distinguishers based on truncated differential trails and uniform distribution property using the technique proposed by Gilbert in <em>[Gilbert]</em>.</p>

    <p class="text-gray-300">In order to extend Gilbert’s distinguisher up to 12-round AES based on the uniform distribution property, we propose a different strategy that can be used by the verifier and we present a formal proof which is based on the same argumentation proposed by Gilbert in order to justify the 8- and the 10-round distinguisher presented in <em>[Gilbert]</em>. For our new distinguishers using truncated-differential properties the situation is different: The problem to formally prove that no generic attack is better than those conjectured distinguishers remains open.</p>

    <p class="text-gray-300">Taking a step back from the concrete results, what we also showed is that the gap between the known-key model and the chosen-key model may be even larger. Among the possibilities to remedy this counter-intuitive situation, we propose to define a new model that better capture the desire to have something “in-between” the chosen-key and the known-key model. Our proposal is to distinguish “classical” Known-Key distinguisher - where the verifier can directly verify the relation <span class="math">\\mathcal{R}</span> on the plaintexts and ciphertexts without guessing any key material - and the “Gilbert” Known-Key distinguisher. To achieve this result, we simply have to adapt Def. 7 for the first case</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Definition 9.</h6>

    <p class="text-gray-300">Let <span class="math">E:(K,X)\\in\\{0,1\\}^{k}\\times\\{0,1\\}^{n}\\to E_{K}(X)\\in\\{0,1\\}^{n}</span> denote a block cipher of block size <span class="math">n</span> bits. A “classical” known-key distinguisher <span class="math">(\\mathcal{R},\\mathcal{A})</span> of order <span class="math">N\\geq 1</span> consists of (1) a relation <span class="math">\\mathcal{R}</span> over the <span class="math">N</span>-tuples of <span class="math">n</span>-bit blocks (2) an algorithm <span class="math">\\mathcal{A}</span> that on input a <span class="math">k</span>-bit key <span class="math">K</span> produces in time <span class="math">T_{\\mathcal{A}}</span>, i.e. in time equivalent with <span class="math">T_{\\mathcal{A}}</span> computations of <span class="math">E</span>, an <span class="math">N</span>-tuple <span class="math">\\mathcal{X}=(X_{i})~{}i=1,...,N</span> of plaintext blocks and an <span class="math">N</span>-tuple <span class="math">\\mathcal{Y}=(Y_{i})~{}i=1,...,N</span> of ciphertext blocks related by <span class="math">Y_{i}=E_{K}(X_{i})</span> and by</p>

    <p class="text-gray-300"><span class="math">L_{\\mathcal{X}}(\\mathcal{X})\\quad\\mathcal{R}\\quad L_{\\mathcal{Y}}(\\mathcal{Y})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">L_{\\mathcal{X}}(\\cdot)</span> and <span class="math">L_{\\mathcal{Y}}(\\cdot)</span> are linear operations that operates respectively on <span class="math">\\mathcal{X}</span> and on <span class="math">\\mathcal{Y}</span>, that is $L_{\\mathcal{X}}(\\mathcal{X})=\\{L_{\\mathcal{X}}(x)\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\forall x\\in\\mathcal{X}\\}<span class="math"> and </span>L_{\\mathcal{X}}(\\cdot)<span class="math"> is linear (analogous for </span>L_{\\mathcal{Y}}(\\cdot)$). The following conditions must be met:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The relation <span class="math">\\mathcal{R}</span> doesn’t have to involve any operation that defined <span class="math">E</span> (with the only exception of a group addition, usually XOR);</li>

      <li>The relation <span class="math">\\mathcal{R}</span> must be <span class="math">T_{\\mathcal{A}}</span>-intractable relatively to <span class="math">E</span>;</li>

      <li>The validity of <span class="math">\\mathcal{R}</span> must be efficiently checkable: we formalize this requirement by incorporating the time for checking whether two <span class="math">N</span>-tuples are related by <span class="math">\\mathcal{R}</span> in the computing time <span class="math">T_{\\mathcal{A}}</span> of algorithm <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <p class="text-gray-300">We emphasize that all the “classical” known-key distinguishers present in literature satisfy this definition, but not the “extended Gilbert distinguishers”. In particular, while this is simple to verify for zero-sum distinguishers and the ones based on the truncated differential trails where <span class="math">L_{\\mathcal{X}}(\\cdot)</span> and <span class="math">L_{\\mathcal{Y}}(\\cdot)</span> are the identity function, we focus on the 8-round Gilbert’s distinguisher based on the uniform distribution property in order to clarify the relation <span class="math">L_{\\mathcal{X}}(\\mathcal{X})\\,\\mathcal{R}\\,L_{\\mathcal{Y}}(\\mathcal{Y})</span> instead of <span class="math">\\mathcal{X}\\,\\mathcal{R}\\,\\mathcal{Y}</span>. The distribution property holds on the ciphertexts if and only if the final MixColumns operation is omitted (see Sect. 5 for more details). However, since <span class="math">\\mathcal{R}</span> must hold between <span class="math">L_{\\mathcal{X}}(\\mathcal{X})</span> and <span class="math">L_{\\mathcal{Y}}(\\mathcal{Y})</span> - by definition, if the</p>

    <p class="text-gray-300">25Observe that the AddRoundKey operation is an affine operation, but not a linear one. Indeed, ARK(x\\oplus y) = x\\oplus y\\oplus k\\neq x\\oplus y = x\\oplus k\\oplus y\\oplus k = ARK(x)\\oplus ARK(y).</p>

    <p class="text-gray-300">Lorenzo Grassi ^{1} and Christian Rechberger ^{1,2}</p>

    <p class="text-gray-300">final MixColumns operation is not omitted, the distinguisher still holds since one can still compute the inverse MixColumns operation on the ciphertexts.</p>

    <p class="text-gray-300">The work in this paper has been partially supported by the Austrian Science Fund (project P26494-N15).</p>

    <h2 id="sec-46" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ABM13] Elena Andreeva, Andrey Bogdanov, and Bart Mennink. Towards understanding the known-key security of block ciphers. In Shiho Moriai, editor, Fast Software Encryption - 20th International Workshop, FSE 2013, Singapore, March 11-13, 2013. Revised Selected Papers, volume 8424 of Lecture Notes in Computer Science, pages 348–366. Springer, 2013.</li>

      <li>[ABM14] Elena Andreeva, Andrey Bogdanov, and Bart Mennink. Towards Understanding the Known-Key Security of Block Ciphers. In FSE 2013, volume 8424 of LNCS, pages 348–366, 2014.</li>

      <li>[AM] Jean-Philippe Aumasson and Willi Meier. Zero-sum distinguishers for reduced Keccak-f and for the core functions of Luffa and Hamsi. Presented at the Rump Session of Cryptographic Hardware and Embedded Systems - CHES 2009, https://131002.net/data/papers/AM09.pdf.</li>

      <li>[BC10] Christina Boura and Anne Canteaut. A zero-sum property for the KECCAK-<span class="math">f</span> permutation with 18 rounds. In IEEE International Symposium on Information Theory 2010, pages 2488–2492, 2010.</li>

      <li>[BCD11] Christina Boura, Anne Canteaut, and Christophe De Cannière. Higher-Order Differential Properties of Keccak and Luffa. In FSE 2011, volume 6733 of LNCS, pages 252–269, 2011.</li>

      <li>[BDPV] Guido Bertoni, Joan Daemen, Michaël Peeters, and Gilles Van Assche. Note on zero-sum distinguishers of Keccak-f. http://keccak.noekeon.org/NoteZeroSum.pdf.</li>

      <li>[Bel97] Bellare, Mihir and Micciancio, Daniele. A New Paradigm for Collision-Free Hashing: Incrementality at Reduced Cost. In EUROCRYPT 1997, volume 1233 of LNCS, pages 163–192, 1997.</li>

      <li>[BKN09] Alex Biryukov, Dmitry Khovratovich, and Ivica Nikolić. Distinguisher and Related-Key Attack on the Full AES-256. In CRYPTO 2009, volume 5677 of LNCS, pages 231–249, 2009.</li>

      <li>[CGH04] Ran Canetti, Oded Goldreich, and Shai Halevi. The Random Oracle Methodology, Revisited. Journal ACM, 51(4):557–594, 2004.</li>

      <li>[DKR97] Joan Daemen, Lars R. Knudsen, and Vincent Rijmen. The Block Cipher Square. In FSE 1997, volume 1267 of LNCS, pages 149–165, 1997.</li>

      <li>[DL12] Ming Duan and XueJia Lai. Improved zero-sum distinguisher for full round Keccak-<span class="math">f</span> permutation. Chinese Science Bulletin, 57(6):694–697, 2012.</li>

      <li>[DR02] Joan Daemen and Vincent Rijmen. The Design of Rijndael: AES - The Advanced Encryption Standard. Information Security and Cryptography. Springer, 2002.</li>

    </ul>

    <p class="text-gray-300">New and Old Limits for AES Known-Key Distinguishers</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[FJP13] Pierre-Alain Fouque, Jérémy Jean, and Thomas Peyrin. Structural Evaluation of AES and Chosen-Key Distinguisher of 9-Round AES-128. In CRYPTO 2013, volume 8042 of LNCS, pages 183–203, 2013.</li>

      <li>[FKL^{+}01] Niels Ferguson, John Kelsey, Stefan Lucks, Bruce Schneier, Mike Stay, David Wagner, and Doug Whiting. Improved Cryptanalysis of Rijndael. In FSE 2000, volume 1978 of LNCS, pages 213–230, 2001.</li>

      <li>[Gil14] Henri Gilbert. A Simplified Representation of AES. In ASIACRYPT 2014, volume 8873 of LNCS, pages 200–222, 2014.</li>

      <li>[GP10] Henri Gilbert and Thomas Peyrin. Super-Sbox Cryptanalysis: Improved Attacks for AES-Like Permutations. In FSE 2010, volume 6147 of LNCS, pages 365–383, 2010.</li>

      <li>[GRR17] Lorenzo Grassi, Christian Rechberger, and Sondre Rønjom. Subspace Trail Cryptanalysis and its Applications to AES. IACR Transactions on Symmetric Cryptology, 2016(2):192–225, 2017.</li>

      <li>[JNPP14] Jérémy Jean, María Naya-Plasencia, and Thomas Peyrin. Multiple limited-birthday distinguishers and applications. In SAC 2013, volume 8282 of LNCS, pages 533–550, 2014.</li>

      <li>[KR07] Lars R. Knudsen and Vincent Rijmen. Known-Key Distinguishers for Some Block Ciphers. In ASIACRYPT 2007, volume 4833 of LNCS, pages 315–324, 2007.</li>

      <li>[KW02] Lars Knudsen and David Wagner. Integral Cryptanalysis. In FSE 2002, volume 2365 of LNCS, pages 112–127, 2002.</li>

      <li>[LMS^{+}15] Mario Lamberger, Florian Mendel, Martin Schläffer, Christian Rechberger, and Vincent Rijmen. The Rebound Attack and Subspace Distinguishers: Application to Whirlpool. J. Cryptology, 28(2):257–296, 2015.</li>

      <li>[MP15] Bart Mennink and Bart Preneel. On the impact of known-key attacks on hash functions. In Tetsu Iwata and Jung Hee Cheon, editors, Advances in Cryptology - ASIACRYPT 2015 - 21st International Conference on the Theory and Application of Cryptology and Information Security, Auckland, New Zealand, November 29 - December 3, 2015, Proceedings, Part II, volume 9453 of Lecture Notes in Computer Science, pages 59–84. Springer, 2015.</li>

      <li>[MPRS09] Florian Mendel, Thomas Peyrin, Christian Rechberger, and Martin Schläffer. Improved Cryptanalysis of the Reduced Grøstl Compression Function, ECHO Permutation and AES Block Cipher. In SAC 2009, volume 5867 of LNCS, pages 16–35, 2009.</li>

      <li>[MRST09] Florian Mendel, Christian Rechberger, Martin Schläffer, and Søren S. Thomsen. The Rebound Attack: Cryptanalysis of Reduced Whirlpool and Grøstl. In FSE 2009, volume 5665 of LNCS, pages 260–276, 2009.</li>

      <li>[MS12] Lorenz Minder and Alistair Sinclair. The extended k-tree algorithm. Journal of Cryptology, 25(2):349–382, 2012.</li>

      <li>[Tun12] Michael Tunstall. Improved "Partial Sums"-based Square Attack on AES. In SECRYPT 2012, pages 25–34, 2012.</li>

      <li>[Wag02] David Wagner. A Generalized Birthday Problem. In CRYPTO 2002, volume 2442 of LNCS, pages 288–303, 2002.</li>

    </ul>

    <p class="text-gray-300">Lorenzo Grassi and Christian Rechberger</p>

    <p class="text-gray-300">[WPS^{+}12] Lei Wei, Thomas Peyrin, Przemysław Sokolowski, San Ling, Josef Pieprzyk, and Huaxiong Wang. On the (In)Security of IDEA in Various Hashing Modes. In FSE 2012, volume 7549 of LNCS, pages 163–179, 2012.</p>

    <h2 id="sec-47" class="text-2xl font-bold">Appendix A A possible Variant of Gilbert’s Distinguisher - Details</h2>

    <p class="text-gray-300">In Sect. 5, we proposed a possible variant of the Gilbert’s distinguisher - that also applies to all our proposed distinguishers present in the paper - which allows to better understand it. Consider the case in which the two players have to send to the verifier the <span class="math">N</span>-tuple that verify the required relation <span class="math">\\mathcal{R}</span> together with the subkeys for which such relation is satisfied.</p>

    <p class="text-gray-300">In more details, assume that the relationship <span class="math">\\mathcal{R}</span> depends on the existence of subkey(s) such that the required property is not directly verified on the plaintexts or/and on the ciphertexts but one (or more) round(s) before/after. As an example, consider the 10-round known-key distinguisher proposed by Gilbert and based on the balance propoerty. In this case, the two players have to send <span class="math">2^{64}</span> (plaintexts, ciphertexts) pairs, i.e. <span class="math">(p^{i},c^{i})</span> for <span class="math">i=0,...,2^{64}-1</span> and the two subkeys <span class="math">k^{0}</span> and <span class="math">k^{10}</span> such that the plaintexts are uniformly distributed after one round in the cosets of <span class="math">\\mathcal{D}_{I}</span> and the ciphertexts are uniformly distributed one round before in the cosets of <span class="math">\\mathcal{M}_{J}</span>.</p>

    <p class="text-gray-300">In this case, the task of the verifier is to check if the relation <span class="math">\\mathcal{R}</span> is satisfied (or not) only for the subkeys she received by the players. It follows that her computational cost is negligible, in the sense that it is comparable to the computational cost of the 8-round integral distinguisher presented in <em>[x12]</em> where the required property <span class="math">\\mathcal{R}</span> can be directly verified on the plaintexts/ciphertexts (or equivalently comparable to the computational costs of the other known-key distinguishers present in literature up to 8 rounds). Here we show in details why such distinguisher is meaningless.</p>

    <p class="text-gray-300">The main problem of such a distinguisher regards the fact that it can be set up for any number of rounds. To explain this problem, consider our known-key distinguisher on <span class="math">r=8+2\\cdot r^{\\prime}</span> rounds of AES, for <span class="math">r^{\\prime}\\geq 1</span> (the same considerations apply e.g. to the Gilbert integral distinguisher). The players have to send to the verifier <span class="math">n</span> different tuples of (plaintext, ciphertext) pairs, that is <span class="math">\\{(p_{i}^{1},c_{i}^{1}),(p_{i}^{2},c_{i}^{2})\\}</span> for <span class="math">i=0,...,n-1</span>, and <span class="math">2\\cdot r^{\\prime}</span> subkeys <span class="math">k^{0},...,k^{r^{\\prime}-1}</span> and <span class="math">k^{r},...,k^{r-r^{\\prime}+1}</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for each tuple there exists <span class="math">\\in\\{0,...,3\\}j</span> for which the two plaintexts belong to the same coset of <span class="math">\\mathcal{D}_{j}</span> after <span class="math">r^{\\prime}</span> rounds, that is</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\forall i=0,...,n-1\\,\\exists j\\in\\{0,...,3\\}\\quad\\text{s.t.}\\quad R_{k^{0},...,k^{r^{\\prime}-1}}(p_{i}^{1})\\oplus R_{k^{0},...,k^{r^{\\prime}-1}}(p_{i}^{2})\\in\\mathcal{D}_{j};</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for each tuple there exists <span class="math">l\\in\\{0,...,3\\}</span> for which the two ciphertexts belong to the same coset of <span class="math">\\mathcal{M}_{l}</span> <span class="math">r^{\\prime}</span> rounds before, that is</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\forall i=0,...,n-1\\,\\exists l\\in\\{0,...,3\\}\\quad\\text{s.t.}\\quad R_{k^{r},...,k^{r-r^{\\prime}+1}}^{-1}(c_{i}^{1})\\oplus R_{k^{r},...,k^{r-r^{\\prime}+1}}^{-1}(c_{i}^{2})\\in\\mathcal{M}_{l},</span></p>

    <p class="text-gray-300">where <span class="math">R_{k^{0},...,k^{r^{\\prime}-1}}(\\cdot)\\equiv R_{k^{r^{\\prime}-1}}\\circ...\\circ R_{k^{0}}(\\cdot)</span> and <span class="math">R_{k^{r},...,k^{r-r^{\\prime}+1}}^{-1}(\\cdot)\\equiv R_{k^{r-r^{\\prime}+1}}^{-1}\\circ...\\circ R_{k^{r}}^{-1}(\\cdot)</span>.</p>

    <p class="text-gray-300">Consider now the costs of the verifier and of the two players. As we have already said, the cost of the verifier is negligible, since she has to check if the relation <span class="math">\\mathcal{R}</span> is satisfied only for the received subkeys. The cost of the shortcut player is approximately of <span class="math">n\\cdot 2^{44}</span> computations for <span class="math">n</span> tuples, since he can use the rebound attack - as showed in Sect. 4.2 - to find them. The generic player instead can use the strategy proposed in details Sect. 8 for the 10 rounds case and in Sect. 9 for the 12 rounds one in order to win the game. Such strategy allows the player to find plaintexts (or ciphertexts) that satisfy the required condition with negligible computational cost. However, the only way to satisfy both the conditions (i.e. the relation <span class="math">\\mathcal{R}</span>) is to test the texts found in the first step by brute force. It</p>

    <p class="text-gray-300">follows that when the number <span class="math">n</span> of required tuples increases (and the number of rounds <span class="math">r^{\\prime}</span>), the computational cost of the generic player grows faster than the cost of the shortcut player. In other words, even if we don’t exclude that a better strategy exists, it seems hard that the cost of the generic player can be lower than the cost of the shortcut one. By definition of known-key distinguisher given in Sect. 4.1, it follows that such a distinguisher can be set up for any number of rounds (of AES), which is meaningless according to our argumentations/discussions given in Sect. 11.</p>

    <h2 id="sec-48" class="text-2xl font-bold">Appendix B The Rebound Attack - Details</h2>

    <p class="text-gray-300">In the 7- and 8-round known-key distinguishers proposed in <em>[x10]</em> and <em>[x9]</em>, the goal of the two players is to find two pairs of (plaintexts, ciphertexts) - i.e. <span class="math">(p^{1},c^{1})</span> and <span class="math">(p^{2},c^{2})</span> - with the following property: the two plaintexts belong to the same coset of <span class="math">\\mathcal{D}_{i}</span> - i.e. <span class="math">p^{1}\\oplus p^{2}\\in\\mathcal{D}_{i}</span> - and the two ciphertexts belong to the same coset of <span class="math">\\mathcal{M}_{i}</span> - i.e. <span class="math">c^{1}\\oplus c^{2}\\in\\mathcal{M}_{i}</span> - for a fixed index <span class="math">i</span>.</p>

    <p class="text-gray-300">Consider the known-key distinguisher setting of the two players proposed in Sect. 4.1. In order to win the proposed game, the technique that the shortcut player (i.e. the player that knows the key) should use is the <em>Rebound Attack</em>.</p>

    <p class="text-gray-300">The rebound attack was proposed in <em>[x11]</em> for the cryptanalysis of AES-based hash functions. The rebound attack consists of two phases, called inbound and outbound phase. According to these phases, the internal permutation of the hash function is split into three sub-parts. Let <span class="math">f</span> be the permutation, then we get <span class="math">f=f_{fw}\\circ f_{in}\\circ f_{bw}</span>. The part of the inbound phase is placed in the middle of the permutation and the two parts of the outbound phase are placed next to the inbound part. In the outbound phase, two high-probability (truncated) differential trails are constructed, which are then connected in the inbound phase.</p>

    <p class="text-gray-300">Since the rebound attack is a differential attack, as first thing an attacker needs to construct a <em>“good” (truncated) differential trail</em>. A good trail used for a rebound attack should have a high probability in the outbound phases and can have a rather low probability in the inbound phase. In particular, two properties are important: first, the system of equations that determine whether a pair follows the differential trail in the inbound phase should be under-determined. This contributes to the fact that many solutions (starting points for the outbound phase) can be found efficiently by using guess-and-determine strategies. Second, the outbound phases need to have high probability in the outward direction.</p>

    <p class="text-gray-300">When searching for solutions of the <em>inbound part</em>, the attacker first guesses some variables such that the remaining system is easier to solve. Hence, the inbound phase of the attack is similar to message modification in an attack on hash functions. The available freedom in terms of the actual values of the internal variables is used to find a solution deterministically or with a very high probability.</p>

    <p class="text-gray-300">In the <em>outbound phase</em>, the attacker verifies whether the solutions of the inbound phase also follow the differential trail in the outbound parts. Note that in the outbound phase, there are usually only a few or no free variables left. Hence, a solution of the inbound phase will lead to a solution of the outbound phase with a low probability. Therefore, the attacker aims for narrow (truncated) differential trails in the outbound parts, which can be fulfilled with a probability as high as possible (in the outward directions). The advantage of using an inbound phase in the middle and two outbound phases at the beginning and end is that one can construct differential trails with a higher probability in the outbound phase and at the same time cover a relatively high number of rounds.</p>

    <p class="text-gray-300">The AES Case. Here we consider in details the strategy of the shortcut player for 7- and 8-round of AES. The truncated differential trails used for 7- and 8-round AES are</p>

    <p class="text-gray-300">Lorenzo Grassi ^{1} and Christian Rechberger ^{1,2}</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 4: 7- and 8-round differential paths for AES-128.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 5: A detail of the inbound phase (rounds 2 - 4) of the 8-round differential.</p>

    <p class="text-gray-300">depicted in Fig. 4. Referring to the 8-round trail (the 7-round case is analogous), the inbound phase is composed of the states from  <span class="math">S_{2}</span>  to  <span class="math">S_{5}</span> , which are highlight in Fig. 5. The player chooses differences in 8 bytes, that is 4 bytes in  <span class="math">S_{start}^{\\prime}</span>  (i.e.  <span class="math">S_{2}</span>  after the S-Box) and the 4 output bytes in  <span class="math">S_{end}</span>  (i.e.  <span class="math">S_{5}</span>  before the S-Box). Since ShiftRows and MixColumns are linear operations, the player can propagate these difference through these operations in order to compute  <span class="math">S_{in}</span>  and  <span class="math">S_{out}</span> . We define the operations between these two states as Super-SB:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {S u p e r} - S B (\\cdot) := \\mathrm {S} - \\operatorname {B o x} \\circ A R K \\circ M C \\circ \\mathrm {S} - \\operatorname {B o x} (\\cdot), \\tag {10}</span></div>

    <p class="text-gray-300">where note that the key is known. The player has to look for two states  <span class="math">S_{in}</span>  and  <span class="math">S_{out}</span>  such that the differential trail is satisfied though this Super-SB operation. When the player finds these two states, he can easily compute the corresponding states  <span class="math">S_{2}</span>  and  <span class="math">S_{5}</span> .</p>

    <p class="text-gray-300">In the outbound phase, the player simply propagates the results found in the previous step in the backward and in the forward directions, and checks if they satisfy the entire differential trail.</p>

    <p class="text-gray-300">As proved in [GP10], in the case of a perfect random permutation on average  <span class="math">2^{64}</span>  operations are required to find two (plaintexts, ciphertexts) pairs that satisfy the 8-round differential trail. Instead, in the AES case and when the initial and the final subspaces are fixed, it requires  <span class="math">2^{48}</span>  computations and  <span class="math">2^{32}</span>  memory.</p>

    <h2 id="sec-50" class="text-2xl font-bold">C.1 Known-Key Distinguisher based on Balance Property</h2>

    <p class="text-gray-300">The 7- and the 8-round known-key distinguisher based on the balance property are a direct application of the 3- and 4-round secret-key distinguishers based on the square property and used in an inside-out fashion.</p>

    <p class="text-gray-300">First of all, we re-call some definitions. Given a set of texts, we say that a byte  <span class="math">X</span>  could be:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Active  <span class="math">(A)</span> : Every value in  <span class="math">\\mathbb{F}_{2^8}</span>  appears the same number of times in  <span class="math">X</span> ;</li>

      <li>Balance  <span class="math">(B)</span> : The XOR of all values in  <span class="math">X</span>  is 0;</li>

      <li>Constant  <span class="math">(C)</span> : The value is fixed to a constant for all texts in  <span class="math">X</span> .</li>

    </ul>

    <p class="text-gray-300">First, we formally define the 7- and the 8-round known-key distinguisher based on the balance property. Assume there are two players - one knows the key and the other not,</p>

    <p class="text-gray-300">New and Old Limits for AES Known-Key Distinguishers</p>

    <p class="text-gray-300">and the verifier. To win the game, the players have to send to the verifier  <span class="math">2^{n}</span>  (plaintext, ciphertext) pairs, that is  <span class="math">(p^i, c^i)</span>  for  <span class="math">i = 0, \\dots, 2^n - 1</span> , such that the balance property holds both on the plaintexts and on the ciphertexts:</p>

    <div class="my-4 text-center"><span class="math-block">\\bigoplus_ {i = 0} ^ {2 ^ {n} - 1} p ^ {i} = \\bigoplus_ {i = 0} ^ {2 ^ {n} - 1} c ^ {i} = 0.</span></div>

    <p class="text-gray-300">A suitable value of  <span class="math">n</span>  is 56 for 7 rounds of AES and 64 for 8 rounds case.</p>

    <p class="text-gray-300">What is the best strategy that the shortcut player can use to win the game? Consider  <span class="math">2^{32}</span>  plaintexts with one active diagonal (i.e. 4 bytes), and all the others 12 bytes constants. It is a well-known fact that the sum of  <span class="math">2^{32}</span>  corresponding ciphertexts after four rounds is equal to zero. A similar property holds in the decryption direction, that is the following integral properties hold:</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c c c c} B &amp;amp; B &amp;amp; B &amp;amp; B \\\\ B &amp;amp; B &amp;amp; B &amp;amp; B \\\\ B &amp;amp; B &amp;amp; B &amp;amp; B \\\\ B &amp;amp; B &amp;amp; B &amp;amp; B \\end{array} \\right] \\xleftarrow {R ^ {(- 3)}} \\left[ \\begin{array}{c c c c} A &amp;amp; C &amp;amp; C &amp;amp; C \\\\ A &amp;amp; C &amp;amp; C &amp;amp; C \\\\ A &amp;amp; C &amp;amp; C &amp;amp; C \\\\ A &amp;amp; C &amp;amp; C &amp;amp; C \\end{array} \\right] \\quad \\text {a n d} \\quad \\left[ \\begin{array}{c c c c} A &amp;amp; C &amp;amp; C &amp;amp; C \\\\ C &amp;amp; A &amp;amp; C &amp;amp; C \\\\ C &amp;amp; C &amp;amp; A &amp;amp; C \\\\ C &amp;amp; C &amp;amp; C &amp;amp; A \\end{array} \\right] \\xrightarrow {R ^ {(4)}} \\left[ \\begin{array}{c c c c} B &amp;amp; B &amp;amp; B &amp;amp; B \\\\ B &amp;amp; B &amp;amp; B &amp;amp; B \\\\ B &amp;amp; B &amp;amp; B &amp;amp; B \\\\ B &amp;amp; B &amp;amp; B &amp;amp; B \\end{array} \\right]</span></div>

    <p class="text-gray-300">where  <span class="math">R^{(4)}</span>  denotes 4 consecutive AES encryption rounds and  <span class="math">R^{(-3)}</span>  denotes 3 full AES decryption rounds.</p>

    <p class="text-gray-300">Equivalent, this means that if one takes a coset of  <span class="math">\\mathcal{D}_i</span>  for a certain  <span class="math">i</span> , then the sum of the corresponding ciphertexts after 4 rounds is equal to zero. Again, if one takes a coset of  <span class="math">\\mathcal{C}_j</span>  for a certain  <span class="math">j</span>  as the set of ciphertexts, the sum of the corresponding plaintexts 3 rounds before is equal to 0. Thus, starting in the middle with a coset of  <span class="math">\\mathcal{D}_i \\oplus \\mathcal{C}_j</span>  for a certain  <span class="math">i</span>  and  <span class="math">j</span> , then the sum of the corresponding plaintexts 3 rounds before and the ciphertexts after 4 rounds is equal to 0:</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c c c c} B &amp;amp; B &amp;amp; B &amp;amp; B \\\\ B &amp;amp; B &amp;amp; B &amp;amp; B \\\\ B &amp;amp; B &amp;amp; B &amp;amp; B \\\\ B &amp;amp; B &amp;amp; B &amp;amp; B \\end{array} \\right] \\xleftarrow {R ^ {- 3}} \\left[ \\begin{array}{c c c c} A &amp;amp; C &amp;amp; C &amp;amp; C \\\\ A &amp;amp; A &amp;amp; C &amp;amp; C \\\\ A &amp;amp; C &amp;amp; A &amp;amp; C \\\\ A &amp;amp; C &amp;amp; C &amp;amp; A \\end{array} \\right] \\xrightarrow {R ^ {4}} \\left[ \\begin{array}{c c c c} B &amp;amp; B &amp;amp; B &amp;amp; B \\\\ B &amp;amp; B &amp;amp; B &amp;amp; B \\\\ B &amp;amp; B &amp;amp; B &amp;amp; B \\\\ B &amp;amp; B &amp;amp; B &amp;amp; B \\end{array} \\right].</span></div>

    <p class="text-gray-300">This distinguisher on 7 rounds AES was proposed for the first time by Knudsen and Rijmen in [KR07], and it has a complexity of  <span class="math">2^{56}</span> . In particular, in this case it is possible to prove that the probability of success of the player who doesn't know the key is strictly less than 1. In other words, the other player needs more computations to generate a set of (plaintexts, ciphertexts) pairs with the required properties.</p>

    <p class="text-gray-300">Since a coset of  <span class="math">\\mathcal{C}_j</span>  is mapped into a coset of  <span class="math">\\mathcal{M}_j</span>  after one round with prob. 1, then given a coset of  <span class="math">\\mathcal{M}_j</span>  for a certain  <span class="math">j</span>  as the set of ciphertexts, the sum of the corresponding plaintexts 4 rounds before is equal to 0. Equivalently, starting in the middle with a coset of  <span class="math">\\mathcal{D}_i \\oplus \\mathcal{M}_j</span>  for a certain  <span class="math">i</span>  and  <span class="math">j</span> , then the sum of the corresponding plaintexts 4 rounds before and of the ciphertexts after 4 rounds is equal to 0:</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c c c c} B &amp;amp; B &amp;amp; B &amp;amp; B \\\\ B &amp;amp; B &amp;amp; B &amp;amp; B \\\\ B &amp;amp; B &amp;amp; B &amp;amp; B \\\\ B &amp;amp; B &amp;amp; B &amp;amp; B \\end{array} \\right] \\xleftarrow {R ^ {- 4}} \\mathcal {D} _ {i} \\oplus \\mathcal {M} _ {j} \\oplus a \\xrightarrow {R ^ {4}} \\left[ \\begin{array}{c c c c} B &amp;amp; B &amp;amp; B &amp;amp; B \\\\ B &amp;amp; B &amp;amp; B &amp;amp; B \\\\ B &amp;amp; B &amp;amp; B &amp;amp; B \\\\ B &amp;amp; B &amp;amp; B &amp;amp; B \\end{array} \\right]</span></div>

    <p class="text-gray-300">for a constant  <span class="math">a</span> . A similar distinguisher was proposed for the first time by Gilbert in [Gil14], and it has a complexity of  <span class="math">2^{64}</span> .</p>

    <p class="text-gray-300">To set up a known-key distinguisher on 8 rounds, the idea is simply to connect two 4-round trails in the middle and to choose a middle space  <span class="math">\\mathcal{D}_i\\oplus \\mathcal{M}_j</span>  for  <span class="math">i</span>  and  <span class="math">j</span>  fixed (with</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math">). In the middle, the set </span>\\mathcal{D}_{i}\\oplus\\mathcal{M}_{j}$ can be re-written as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\bigcup_{b\\in\\mathcal{D}_{i}}\\mathcal{M}_{j}\\oplus b=\\bigcup_{a\\in\\mathcal{M}_{j}}\\mathcal{D}_{i}\\oplus a,</span></p>

    <p class="text-gray-300">that is as union of cosets of the space <span class="math">\\mathcal{D}_{i}</span> or as union of cosets of the space <span class="math">\\mathcal{M}_{j}</span>.</p>

    <p class="text-gray-300">Forward Direction. If one encrypts <span class="math">\\mathcal{D}_{i}\\oplus a</span> for four rounds (<span class="math">a\\in\\mathcal{M}_{j}</span>), then the set <span class="math">R^{(4)}(\\mathcal{D}_{i}\\oplus a)</span> is a set of <span class="math">(2^{8})^{4}=2^{32}</span> ciphertexts where each ciphertext belongs to a different coset of a mixed space <span class="math">\\mathcal{M}_{I}</span> of dimension 12. Thus if one encrypts all <span class="math">2^{32}</span> cosets of <span class="math">\\mathcal{D}_{i}</span>, we get all the <span class="math">2^{32}</span> cosets of <span class="math">\\mathcal{M}_{I}</span>, where each coset contains exactly <span class="math">2^{32}</span> ciphertexts. Only for completeness, if the final MixColumns operation is omitted, then the encryption of all <span class="math">2^{32}</span> cosets of <span class="math">\\mathcal{D}_{i}</span> results in all the <span class="math">2^{32}</span> cosets of <span class="math">\\mathcal{ID}_{I}</span>, where each coset contains exactly <span class="math">2^{32}</span> ciphertexts.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Indeed, note that by Theorem 2 two elements that belong to the same coset of <span class="math">\\mathcal{D}_{I}</span> can not belong to the same coset of <span class="math">\\mathcal{M}_{J}</span> for $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 4<span class="math">. Thus, given a coset of </span>\\mathcal{D}_{i}<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math">, after 4 rounds each element is distributed in a different coset of </span>\\mathcal{M}_{J}<span class="math"> for </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=3<span class="math">. Note that </span>\\mathcal{D}_{i}\\oplus\\mathcal{M}_{j}=\\bigcup_{a\\in\\mathcal{M}_{j}}\\mathcal{D}_{i}\\oplus a<span class="math">. Thus, since the coset of </span>\\mathcal{D}_{i}<span class="math"> contains </span>2^{32}<span class="math"> elements and since there are exactly </span>2^{32}<span class="math"> cosets of </span>\\mathcal{M}_{J}<span class="math">, the elements of </span>\\mathcal{D}_{i}\\oplus\\mathcal{M}_{j}<span class="math"> are uniformly distributed in each coset of </span>\\mathcal{M}_{I}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Backward Direction. If one decrypts <span class="math">\\mathcal{M}_{j}\\oplus b</span> for four rounds (<span class="math">b\\in\\mathcal{D}_{i}</span>), then - due to Theorem 2 - the set <span class="math">R^{(-4)}(\\mathcal{M}_{j}\\oplus b)</span> is a set of <span class="math">2^{32}</span> plaintexts where each plaintext belongs to a different coset of a diagonal space <span class="math">\\mathcal{D}_{J}</span> of dimension 12. If one decrypts all <span class="math">2^{32}</span> cosets of <span class="math">\\mathcal{M}_{j}</span>, one gets all the <span class="math">2^{32}</span> cosets of <span class="math">\\mathcal{D}_{J}</span>, where each coset contains exactly <span class="math">2^{32}</span> plaintexts.</p>

    <h4 id="sec-52" class="text-lg font-semibold mt-6">A Distinguisher with complexity <span class="math">2^{64}</span>: Uniform Distribution</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose to start in the middle with <span class="math">2^{64}</span> texts in the same coset of <span class="math">\\mathcal{D}_{i}\\oplus\\mathcal{M}_{j}</span>, and let <span class="math">J</span> and <span class="math">I</span> fixed such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=3<span class="math">. As we have seen, the ciphertexts are uniform distributed in all the cosets of </span>\\mathcal{M}_{I}<span class="math">, that is each coset contains exactly </span>2^{32}<span class="math"> ciphertexts. In the same way, the plaintexts are uniform distributed in all the cosets of </span>\\mathcal{D}_{J}<span class="math">, that is each coset contains exactly </span>2^{32}$ plaintexts. Thus, one needs only to count the number of elements in the ciphertexts and plaintexts that belongs to each coset to distinguish an 8-round AES permutation from a random one.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Description as Zero-Sum Distinguisher. An even simpler approach is possible: the simplest method is to XOR the <span class="math">2^{64}</span> plaintexts <em>and</em> ciphertexts and verify that the result is zero. The complexity is <span class="math">2^{64}</span>. This is the distinguisher which exploits the integral property proposed by Gilbert in <em>[x10]</em>.</p>

    <p class="text-gray-300">Even if we’ve already presented it, we recall it using the subspace trail notation, which allows an easier explanation than using the <span class="math">Super</span>-<span class="math">SB</span> operation</p>

    <p class="text-gray-300"><span class="math">Super</span>-<span class="math">SB(\\cdot):=\\mathrm{S\\mbox{-}Box}\\circ ARK\\circ MC\\circ\\mathrm{S\\mbox{-}Box}(\\cdot)</span> (11)</p>

    <p class="text-gray-300">introduced by Gilbert. To do this, we recall the 7-round AES distinguisher proposed by Knudsen and Rijmen in <em>[x16]</em>, which has a complexity of <span class="math">2^{56}</span> and which exploits the following integral property:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Zero\\mbox{-}Sum}\\quad\\stackrel{{\\scriptstyle R^{-3}}}{{\\longleftarrow}}\\quad\\mathcal{D}_{0}\\oplus\\mathcal{C}_{0}\\oplus a\\quad\\stackrel{{\\scriptstyle R^{4}}}{{\\longrightarrow}}\\quad\\mathrm{Zero\\mbox{-}Sum},</span></p>

    <p class="text-gray-300">where <span class="math">a\\in(\\mathcal{D}_{0}\\oplus\\mathcal{C}_{0})^{\\perp}</span>. Equivalently, this means that if one starts from a (collection of) coset(s) of <span class="math">\\mathcal{D}_{0}</span> then after four rounds (without the final MixColumns operation) the integral</p>

    <p class="text-gray-300">property holds. In a similar way, if one starts from a (collection of) coset(s) of <span class="math">\\mathcal{C}_{0}</span>, then the integral property holds three rounds before.</p>

    <p class="text-gray-300">As shown in detail in <em>[x10]</em> and in Sect. 3, for each <span class="math">a\\in\\mathcal{C}_{0}^{\\perp}</span> there exists unique <span class="math">b\\in\\mathcal{M}_{0}^{\\perp}</span> such that <span class="math">R^{-1}(\\mathcal{M}_{0}\\oplus b)=\\mathcal{C}_{0}\\oplus a</span>. This means that if one starts from a coset of <span class="math">\\mathcal{M}_{0}</span>, then the integral property holds four rounds before. Indeed, this coset of <span class="math">\\mathcal{M}_{0}</span> is mapped into a coset of <span class="math">\\mathcal{C}_{0}</span>, and then the integral property holds. Thus if one takes a collection of cosets of <span class="math">\\mathcal{M}_{0}</span>, then the integral property holds four rounds before. In conclusion, if one starts in the middle with a coset of <span class="math">\\mathcal{D}_{0}\\oplus\\mathcal{M}_{0}</span> instead of a coset of <span class="math">\\mathcal{D}_{0}\\oplus\\mathcal{C}_{0}</span>, then the integral property holds both after four rounds and four rounds before:</p>

    <p class="text-gray-300"><span class="math">\\text{Zero-Sum}\\quad\\xleftarrow{R^{-4}}\\quad\\mathcal{D}_{0}\\oplus\\mathcal{M}_{0}\\oplus a^{\\prime}\\quad\\xrightarrow{R^{4}}\\quad\\text{Zero-Sum}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">a^{\\prime}\\in(\\mathcal{D}_{0}\\oplus\\mathcal{M}_{0})^{\\perp}</span>. The complexity is <span class="math">2^{64}</span> since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}_{0}\\oplus\\mathcal{M}_{0}\\oplus a^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{64}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-53" class="text-xl font-semibold mt-8">C.3 Zero-Sum Distinguisher - Scenario of Sect. 4</h3>

    <p class="text-gray-300">To better formalize this scenario, we describe the zero-sum distinguisher in the scenario of the two players and of the verifierier described in Sect. 4. As we have already said, the goal of the two players is to find an <span class="math">N</span>-tuple of (plaintexts, ciphertexts) <span class="math">(p^{i},c^{i})</span> for <span class="math">i=0,...,N-1=2^{n}-1</span> such that the sums of the plaintexts and of the ciphertexts are equal to zero, i.e.</p>

    <p class="text-gray-300"><span class="math">\\bigoplus_{i=0}^{N-1}p^{i}=\\bigoplus_{i=0}^{N-1}c^{i}=0.</span></p>

    <p class="text-gray-300">We analyze the scenario for the two players and of the verifier. We remember that a distinguisher is meaningful if (1) the cost of the generic player - we assume that the cost of 1 oracle-query is equal to the cost of 1 encryption - to generate the <span class="math">N</span> -tuple is higher than the cost of the shortcut player when both the players have the same probability of success, and if (2) the cost to verify <span class="math">\\mathcal{R}</span> - given plaintexts and the corresponding ciphertexts - is (much) lower than the costs of the two players to generate the required <span class="math">N</span>-tuple.</p>

    <p class="text-gray-300">Shortcut Player. Assume that the shortcut player knows a set of texts <span class="math">X=\\{x^{i}\\}_{i}</span> and a set of texts <span class="math">Y=\\{y^{i}\\}_{i}</span> with the following properties: <span class="math">\\bigoplus_{i}R^{s}(x^{i})=0</span> and <span class="math">\\bigoplus_{i}R^{s-r}(y^{i})=0</span>. for <span class="math">0&lt;s&lt;r</span> and such that <span class="math">dim(X\\oplus Y)=n</span>. <span class="math">R^{s}</span> means <span class="math">s</span>-round encryptions and <span class="math">R^{s-r}</span> means <span class="math">(r-s)</span>-round deccryptions in this paper. For the following, note that <span class="math">X\\oplus Y=\\bigcup_{y\\in Y}X\\oplus y=\\bigcup_{x\\in X}Y\\oplus x.</span> Since he can work with the intermediate states, he simply chooses texts in <span class="math">X\\oplus Y</span> and simply defines the plaintexts as the <span class="math">r-s</span> rounds decryption of <span class="math">X\\oplus Y</span> and the corresponding ciphertexts as the <span class="math">s</span> rounds encryptions of <span class="math">X\\oplus Y</span>.</p>

    <p class="text-gray-300">We emphasize that the players must send only a set of <span class="math">N</span> plaintexts s.t. the sum of the plaintexts and the sum of the ciphertexts is equal to zero. It follows that starting in the middle, the shortcut player has to compute only <span class="math">s/r\\cdot N</span> computations/encryptions. Thus, the cost for such a player is of <span class="math">s/r\\cdot N</span> computations/encryptions - we assume 1 round encryption has the same cost of 1 round decryption. Consider for example the case <span class="math">r=2\\cdot s</span>. It follows that to generate such set <span class="math">N/2</span> encryptions are sufficient.</p>

    <p class="text-gray-300">Such a strategy is well accepted in literature. To provide examples to this claim, consider the zero-sum distinguishers of Keccak-<span class="math">f</span> <em>[x1]</em> - <em>[x4]</em> - <em>[x11]</em> recently published in literature. In all these works, the computational complexity difference between the inside-out approach and the generic method is usually very small (a factor 2). Even if a distinguisher can be considered meaningful only if this difference is significant, the Keccak Team published a note “Note on zero-sum distinguishers of Keccak-<span class="math">f</span>” <em>[x5]</em> where they confirmed the validity of such distinguishers: “[…] the zero-sum distinguishers of</p>

    <p class="text-gray-300">Lorenzo Grassi¹ and Christian Rechberger¹,²</p>

    <p class="text-gray-300">[AM, BC10]are valid, albeit with a very small advantage".</p>

    <p class="text-gray-300">Generic Player. One possible strategy that the generic player can use is the one proposed by Wagner in [Wag02] in order to solve the <span class="math">k</span>-sum problem. Given a function <span class="math">f</span> on <span class="math">n</span> bits, the <span class="math">k</span>-sum problem is to find <span class="math">x_{1}, \\ldots, x_{k}</span> such that <span class="math">\\sum_{i=1}^{k} f(x_{i}) = 0</span>. A solution to this problem is given in [Wag02] with a running time of <span class="math">\\mathcal{O}(N \\cdot 2^{k/(1 + \\log_{2} N)})</span>. This strategy has used by Knudsen and Rijmen in [KR07] - the first authors that propose zero-sum distinguisher - in order to estimate the computational cost of the Generic Player. In particular, using the solution provided in [Wag02], they conjecture that the complexity of the Generic Player to find an <span class="math">N</span>-tuple for which the sum in <span class="math">k</span> bits is approximated by <span class="math">\\mathcal{O}(N \\cdot 2^{k/(1 + \\log_{2} N)})</span>. encryptions. The approach to estimate the complexity comes close to an answer to this is the one to solve the <span class="math">k</span>-sum problem [Wag02]. Given a function <span class="math">f</span> on <span class="math">n</span> bits, the <span class="math">k</span>-sum problem is to find <span class="math">x_{1}, \\ldots, x_{k}</span> such that <span class="math">\\sum_{i=1}^{k} f(x_{i}) = 0</span>. A solution to this problem is given in [Wag02] with a running time of <span class="math">(N \\cdot 2^{k/(1 + \\log_{2} N)})</span>. Before we go on, we remember that the same authors highlight that “[...] this is a very inaccurate estimation of the complexity we are looking for: the complexity estimate above is in the big <span class="math">\\mathcal{O}</span> notation, thus ignoring smaller constants²⁶, the approach requires memory (more than for the AES distinguisher), but much more important, the <span class="math">k</span>-sum problem does not give us the structure that we get for reduced AES, merely a collection of texts whose sum through the function <span class="math">f</span> is zero with no conditions of balance on the values of <span class="math">x_{i}</span>²⁷. [...]”.</p>

    <p class="text-gray-300">Another possible strategy that can be used is inspired by the attack against XHASH in [Bel97] (brought to attention of Keccak Team [BDPV] by Jean-Philippe Aumasson). The strategy is the following. Assume we are looking for a set <span class="math">\\mathcal{Z} = \\{z_i\\}</span> of <span class="math">N</span> elements in <span class="math">\\mathbb{F}_{2^n}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\bigoplus_{i} z_{i} = \\bigoplus_{i} f(z_{i}) = 0.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As first step, one considers <span class="math">N</span> random values <span class="math">x_{i} \\in \\mathbb{F}_{2^{n}}</span> and compute $\\mathcal{X} = \\{x_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(x_{i})\\}_{i}<span class="math"> where </span>x_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(x_{i}) \\in \\mathbb{F}_{2^{2n}}<span class="math">. Let </span>S_{0} = \\bigoplus_{\\mathcal{X}} x_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(x_{i}) \\equiv \\bigoplus_{\\mathcal{X}} x_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bigoplus_{\\mathcal{X}} f(x_{i})<span class="math">. If </span>S_{0}<span class="math"> is equal to zero (prob. </span>2^{-2n}<span class="math">), then the problem is solved. Assume </span>S_{0} \\neq 0<span class="math">. The idea is to consider other </span>M<span class="math"> random elements - for a certain </span>M - y_{i} \\in \\mathbb{F}_{2^{n}}<span class="math"> and compute </span>\\{y_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(y_{i})\\}_{i}<span class="math">. Then, one computes binary coefficients </span>\\{a_{i}\\}_{i=0,\\dots,M}$ that satisfy the following inequality:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bigoplus_{i=0}^{M} a_{i} \\cdot \\left(x_{i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(x_{i}) \\oplus y_{i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(y_{i})\\right) = A. \\tag{12}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Observe that such condition is satisfied with non-negligible property if <span class="math">M &amp;gt; 2n</span> - in particular, it is satisfied with probability higher than <span class="math">99.99\\%</span> if <span class="math">M = 2n + 10</span>. For the following, we assume <span class="math">M = 2n + \\varepsilon</span>, where <span class="math">\\varepsilon \\geq 0</span>. As we are going to show, the value of <span class="math">\\varepsilon</span> determines the priori probability that the system of equations (12) has a solution: by increasing <span class="math">\\varepsilon</span> the probability that it has no solution decreases exponentially. Assume that a solution of the previous equality is found. The set <span class="math">\\mathcal{Z} = \\{z_i\\}</span> is defined as</p>

    <div class="my-4 text-center"><span class="math-block">z_{i} \\equiv \\left\\{ \\begin{array}{c l} a_{i} \\cdot y_{i} \\oplus (1 \\oplus a_{i}) \\cdot x_{i} &amp;amp; \\text{if } i \\leq M \\\\ x_{i} &amp;amp; \\text{if } i &amp;gt; M \\end{array} \\right.</span></div>

    <p class="text-gray-300">²⁶A detailed study of this problem can be found in [MS12], where authors give an estimate of the probability of success/failure of Wagner Algorithm. It follows that the constant should be higher than 1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">²⁷For completeness, we show that this problem has a simple solution. Considering the AES-case, we can assume <span class="math">x_{i} \\in \\mathbb{F}_{2^{8}}^{4 \\times 4}</span> and that <span class="math">f</span> is the 7-round AES encryption function. Under this assumption, one obtains a set of plaintexts, which XOR-sum is equal to zero after 7 rounds. To fix the problem, one can consider elements <span class="math">x_{i}</span> as in <span class="math">\\mathbb{F}_{2^{8}}^{4 \\times 8}</span>, defined as $x_{i} \\equiv p_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Enc^{7}(p_{i})<span class="math"> where </span>Enc^{7}(p_{i})<span class="math"> denotes the corresponding ciphertext of </span>p_{i}<span class="math"> after 7 round. In this case, the function </span>f<span class="math"> is simply the identity function. It follows that </span>\\bigoplus x_{i} \\equiv \\bigoplus p_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Enc^{7}(p_{i}) = 0<span class="math"> implies </span>\\bigoplus p_{i} = 0<span class="math"> and </span>\\bigoplus Enc^{7}(p_{i}) = 0<span class="math">, i.e. zero-sum both on the plaintexts and on the ciphertexts. Moreover, it follows that the complexity of such a problem becomes of </span>\\mathcal{O}(N \\cdot 2^{2 \\cdot k / (1 + \\log_{2} N)})<span class="math">, since we are working on </span>\\mathbb{F}_{2^{8}}^{4 \\times 8}<span class="math"> instead of </span>\\mathbb{F}_{2^{8}}^{4 \\times 4}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">New and Old Limits for AES Known-Key Distinguishers</p>

    <p class="text-gray-300">Note that <span class="math">a_{i}\\cdot y_{i}\\oplus (1\\oplus a_{i})\\cdot x_{i}</span> is equal to <span class="math">y_{i}</span> for <span class="math">a_{i}=1</span> and equal to <span class="math">x_{i}</span> otherwise. It is simple to observe that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\bigoplus_{i}z_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(z_{i})<span class="math"> </span>=\\bigoplus_{i\\leq M}(a_{i}\\cdot y_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(y_{i})\\oplus(1\\oplus a_{i})\\cdot x_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(x_{i}))\\oplus\\bigoplus_{i&gt;M}x_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(x_{i})=$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It follows that the computational cost is well approximated by:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">N+2n+\\varepsilon</span> encryptions;</li>

      <li>solve a linear system of <span class="math">2n+\\varepsilon</span> equations.</li>

    </ul>

    <p class="text-gray-300">If <span class="math">N\\gg 2n+\\varepsilon</span>, such a cost is well approximated by <span class="math">N</span> computations/encryptions, that is it is “always” larger than the cost of the shortcut player of a factor 2. For completeness, such strategy can be used also in the case of Partial Balance.E.g. let <span class="math">\\phi:\\mathbb{F}_{2^{n}}\\to\\mathbb{F}_{2^{n}}</span> defined as <span class="math">\\phi(x)=x\\wedge\\Phi</span> where <span class="math">\\Phi\\in\\mathbb{F}_{2^{n}}</span> is fixed and <span class="math">\\wedge</span> is the AND logic. The algorithm works as well, where the set <span class="math">\\mathcal{Z}=\\{z_{i}\\}</span> must satisfy <span class="math">\\bigoplus_{i}\\phi(z_{i})=\\bigoplus_{i}f(z_{i})=0</span>.</p>

    <p class="text-gray-300">Come back to problem of <span class="math">\\varepsilon</span>. Given a fixed set <span class="math">\\{a_{i}\\}_{i}</span>, they satisfy (12) with probability <span class="math">2^{-2n}</span>. It follows that given <span class="math">2n+\\varepsilon</span> sets, at least one of them satisfy (12) with probability</p>

    <p class="text-gray-300"><span class="math">1-(1-2^{-2n})^{2n+\\varepsilon}\\approx 1-e^{\\varepsilon}.</span></p>

    <p class="text-gray-300">assuming <span class="math">2n\\gg 1</span>. For a probability of success higher than <span class="math">99.99\\%</span> (remember that the probability of success of shortcut player is 1), it follows <span class="math">\\varepsilon\\geq 10</span>.</p>

    <p class="text-gray-300">As last things, note that such an algorithm is faster than Wagner’s one if</p>

    <p class="text-gray-300"><span class="math">N+2n+10\\leq N\\cdot 2^{2n/(1+\\log N)},</span></p>

    <p class="text-gray-300">which is always satisfied e.g. if <span class="math">1+\\log N\\leq 2n\\ll N</span> (that is, <span class="math">N+2n+10\\approx N</span> and <span class="math">1&amp;lt;2^{2n/(1+\\log N)}</span>).</p>

    <p class="text-gray-300">Verifier. Given the (plaintext, ciphertext) pairs, it’s simple to note that the cost of the verifier is of <span class="math">2^{n}\\cdot 2=2\\cdot N</span> XOR-sum operations, which is much smaller than the costs of the two players. We emphasize that the cost of the verifier must be smaller than the cost of the players when the plaintexts and the corresponding ciphertexts are given. In other words, even if the verifier receives from the shortcut player only the plaintexts that satisfy <span class="math">\\mathcal{R}</span>, the verification cost doesn’t include the cost to compute the corresponding ciphertexts (remember that the advantage of the shortcut player w.r.t. the generic player is the fact that he doesn’t need to work both on the plaintexts and on the ciphertexts).</p>

    <h2 id="sec-54" class="text-2xl font-bold">Appendix D Details of Known-Key Distinguisher when the Computational Cost of the Generic Player is Considered</h2>

    <p class="text-gray-300">Referring to the known-key distinguisher scenario described in Sect. 4.1, the generic player depends by the oracle to generate the <span class="math">N</span>-tuple (i.e. he cannot work alone to generate it). As a consequence, note that two possible settings can be analyzed. In the first one, only the number of oracle queries is considered to determine the computational cost of this player, that is the number of encryptions/decryptions required by the generic player to the oracle. In the second one, both the number of oracle queries and any further computational</p>

    <p class="text-gray-300">28The computational cost for a m\\times m matrix is \\mathcal{O}(m^3) . Since 2n + \\varepsilon \\ll N , we emphasize that the cost of this step is negligible with the cost of the first step.</p>

    <p class="text-gray-300">cost of the generic player (which is in general not negligible) are considered. As we have already said, we expect that a known-key distinguisher in the first setting works also in the second one but not viceversa. If the total cost of the generic player is well approximated by the number of queries (assuming 1 oracle-query <span class="math">\\approx 1</span> computation/encryption), these two settings are completely equivalent.</p>

    <p class="text-gray-300">In the main text, we have focused only on the first case, that is we have approximated the cost of the generic player by the number of oracle-queries necessary to generate a sufficient number of (plaintexts, ciphertexts) pairs such that <span class="math">n</span> tuples with the required properties exist with a good probability. However, note that the player has also to identify the <span class="math">n</span> tuples with the required properties before sending them to the verifier. As we are going to show, this computational cost is not negligible. In this section, we present the details of this case both for the 9-round distinguisher presented in Sect. 7 and for the 10-round one with key schedule presented in Sect. 8.2.</p>

    <h3 id="sec-55" class="text-xl font-semibold mt-8">D.1 Known-Key Distinguisher on 9-Round AES</h3>

    <p class="text-gray-300">For a complete description of the 9-round known-key distinguisher for AES, we refer to Sect. 7. Here we limit to consider the cost of the generic player to find the <span class="math">n</span> tuples with the required properties. In particular, we are going to show that if this cost is taken into account, then <span class="math">n=3</span> tuples are sufficient for our distinguisher on 9 rounds of AES.</p>

    <p class="text-gray-300">By formula (7), if <span class="math">n=3</span> then <span class="math">2^{52.2}</span> different couples, or approximately <span class="math">2^{26.6}</span> plaintexts/ciphertexts pairs are sufficient to find the 3-tuples with the required properties (where the plaintexts belong to the same coset of <span class="math">\\mathcal{D}_{i}</span>). Indeed, note that with <span class="math">2^{52.2}</span> different couples it is possible to construct approximately <span class="math">2^{154}</span> different sets of 3 tuples. Since the probability that a set satisfies the required properties is <span class="math">2^{-154}</span>, there is at least one set that satisfies the property with non-negligible property. Thus, the cost to generate them is of <span class="math">2^{26.6}</span> oracle-queries.</p>

    <p class="text-gray-300">Given these <span class="math">2^{26.6}</span> (plaintexts, ciphertexts) pairs, the generic player must work on the ciphertexts (note that the property on the plaintexts is already satisfied) in order to find the 3-tuples with the required properties. For each couple <span class="math">\\{(p^{1},c^{1}),(p^{2},c^{2})\\}</span>, a possible strategy is to find the key <span class="math">k</span> such that <span class="math">R_{k}^{-1}(c^{1})\\oplus R_{k}^{-1}(c^{2})\\in\\mathcal{M}_{i}</span>, using the attack of Sect. 6.1, and then to find 3 couples with a common key <span class="math">k</span>. In the following, we present a modified strategy that allows to reduce the computational cost.</p>

    <p class="text-gray-300">A possible way to reduce the total computational cost is to work first on only two couples (instead of three), that is to find two couples with the same key for which the required property is satisfied. Since there are <span class="math">2^{52.2}</span> couples, the player can construct approximately <span class="math">2^{103.4}</span> 2-tuples (i.e. different sets of two different couples). Approximately, there are <span class="math">2^{103.4}\\cdot(4\\cdot 2^{32})^{2}\\cdot 2^{-128}=2^{43.4}</span> different sets with on average one key in common for the two couples. For this step and using the attack of Sect. 6.1, the cost can be approximated at <span class="math">2^{103.4}\\cdot 4\\cdot 2^{11.6}=2^{117}</span> table look-ups. Then, given two couples with a common key <span class="math">k</span>, the attacker looks for a third couple for which the required property is satisfied by the found key <span class="math">k</span>. Note that for a given key, the probability that a pair of ciphertexts belong to the same coset of <span class="math">\\mathcal{M}_{l}</span> one round before for that key is only <span class="math">2^{34-128}=2^{-94}</span>. It follows that the player has to consider all the <span class="math">2^{43.4}</span> possible sets of two couples just found and all the possible <span class="math">2^{52.4}</span> couples (for a total of approximately <span class="math">2^{43.4}\\cdot 2^{52.2}=2^{95.6}</span> possibilities) in order to find the three tuples. Thus, given two couples with a common key, the idea is simply to test this found key on all the other couples, until one couple that satisfies the required property is found. To do this, the player computes <span class="math">2^{43.4}\\cdot 2^{52.2}\\cdot 2\\cdot 2^{4}=2^{100.6}</span> S-Box look-ups tables. It follows that the attacker is able to find the three desired couples, with a cost of approximately <span class="math">2^{117}</span> table look-ups or <span class="math">2^{109.5}</span> nine-round encryptions, besides the (non-negligible) memory cost to store the couples found at the first step with the corresponding key.</p>

    <p class="text-gray-300">New and Old Limits for AES Known-Key Distinguishers</p>

    <p class="text-gray-300">The cost of the shortcut player can instead be approximated by <span class="math">3 \\cdot 2^{44} = 2^{45.6}</span> nine-round encryptions. Thus, <span class="math">n = 3</span> tuples are sufficient to set up the 9-round known-key distinguisher when all the costs (oracle queries + computational cost of generic player). Even if we don't exclude that the generic player can use better strategies to find these three couples, it seems improbable that the generic player is able to find the 3-tuples faster than the shortcut player when all the costs are considered. It follows that if the two players have to send 3 different tuples with the desired properties, then the game is win (with very high probability) by the player who knows the key. We leave as an open problem the research of a better strategy that the generic player can use to find these <span class="math">n</span> tuples. For completeness, using the above strategy it is possible to prove that <span class="math">n = 2</span> tuples are not sufficient to set up this distinguisher<span class="math">^{29}</span>.</p>

    <h2 id="sec-56" class="text-2xl font-bold">D.2 Known-Key Distinguisher on 10-Round AES with Key Schedule</h2>

    <p class="text-gray-300">For a complete description of the 10-round known-key distinguisher for AES with key schedule, we refer to Sect. 8.2. Here we limit to consider the cost of the generic player to find the <span class="math">n</span> tuples with the required properties. In this case, it turns that <span class="math">n = 2</span> tuples are sufficient.</p>

    <p class="text-gray-300">Indeed, in this case the cost for the shortcut player is of <span class="math">2^{45}</span> computations. Instead, if <span class="math">n = 2</span> and using formula (9), the other player must consider at least <span class="math">s = 2^{52.5}</span> different couples, that is approximately <span class="math">2^{26.75}</span> different (plaintext, ciphertext) pairs (with a cost of <span class="math">2^{26.75}</span> oracle-queries), where all the plaintexts belong to the same coset of <span class="math">\\mathcal{D}_j</span>. The player can construct approximately <span class="math">2^{104}</span> 2-tuples. First of all, for each one the player look for a final key <span class="math">k^{10}</span> (if exists). Since the probability that such key exists for a given 2-tuple is only <span class="math">2^{-60}</span>, only <span class="math">2^{44}</span> 2-tuples survive this step. The cost of this step is well approximated by <span class="math">2^{104} \\cdot 4 \\cdot 2^{11.6} = 2^{117.6}</span> table look-ups, using the attack described in Sect. 6.1.</p>

    <p class="text-gray-300">Given these <span class="math">2^{44}</span> 2-tuples just found with the corresponding key <span class="math">k^{10}</span>, for each key <span class="math">k^{10}</span> the player can simply find the <span class="math">j</span>-th column of the first key <span class="math">k^0</span> (note that three columns of <span class="math">k^0</span> can take any possible values), and checks if the property on the plaintexts is satisfied. Since this happens with probability <span class="math">30^{2-44}</span>, such key usually exists. The cost of this step is well approximated by <span class="math">2^{44} \\cdot 2^{34} \\cdot 40 = 2^{83.1}</span> S-Box look-ups to check the key schedule, that is approximately <span class="math">2^{75.5}</span> ten-round encryptions, besides the (not-negligible) memory cost. It follows that the computational cost for this player is much higher than the one of the shortcut player. However, since we don't exclude that the generic player can use a better strategy to win the game, we leave the open problem to improve the strategy that we have just presented here. On the other hand, even if a better strategy is found, it seems improbable that the generic player is able to find the 2-tuples faster than the shortcut player when all the costs are considered.</p>

    <h2 id="sec-57" class="text-2xl font-bold">E New 7-, 8- and 9-round AES Known-Key Distinguishers</h2>

    <p class="text-gray-300">In this section, we propose new 8- and 9-round known-key distinguisher for AES, which are obtained extending at the end or/and at the beginning a 7-round known-key distinguisher for AES. The strategy to set up them is the same used in Sect. 7 and 8. For this reason, we refer to those sections for all the details. We highlight that the 9-round known-key</p>

    <p class="text-gray-300"><span class="math">^{29}</span>In this case, <span class="math">2^{30.5}</span> different couples instead of <span class="math">2^{52.2}</span> are sufficient, that is <span class="math">2^{16.75}</span> different (plaintexts, ciphertexts) pairs, for a cost of <span class="math">2^{16.75}</span> oracle-queries. In order to find the key, the total cost can be approximated at <span class="math">2^{42.1}</span> table look-ups, or <span class="math">2^{34.6}</span> nine-round encryptions. The cost for the player who knows the key is of <span class="math">2^{45}</span> nine-round encryptions. It follows that <span class="math">n = 2</span> tuples are not sufficient.</p>

    <p class="text-gray-300"><span class="math">^{30}</span>Remember that we're working with plaintexts in the same coset of <span class="math">\\mathcal{D}_j</span>. After one round, they are mapped into the same coset of <span class="math">\\mathcal{C}_j</span>. Thus, two texts belong to the same coset of <span class="math">\\mathcal{C}_j \\cap \\mathcal{D}_j</span> for a certain <span class="math">i</span>, if three bytes of the <span class="math">j</span>-th column are equal to zero. This happens with probability <span class="math">4 \\cdot 2^{-24} = 2^{-22}</span>.</p>

    <p class="text-gray-300">Lorenzo Grassi ^{1} and Christian Rechberger ^{1,2}</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 6: 7-round differential characteristic for known-key distinguisher of AES-128.</p>

    <p class="text-gray-300">distinguisher proposed in this section is the best one both for the computational and data cost among those currently present in the literature.</p>

    <p class="text-gray-300">For the following, we briefly recall the currently best known distinguisher on 8 rounds of AES (proposed in [JNPP14] and already presented in Sect. 4.3). This distinguisher is obtained starting from the 8-round distinguisher presented in [GP10], and depicted in Fig. 4. Using the subspace trail notation and the known-key distinguisher scenario, the goal of the two players in this distinguisher is to find a pair of (plaintexts, ciphertexts) - i.e.  <span class="math">(p^1, c^1)</span>  and  <span class="math">(p^2, c^2)</span>  - with the following properties: the two plaintexts belong to the same coset of  <span class="math">\\mathcal{D}_i</span>  - i.e.  <span class="math">p^1 \\oplus p^2 \\in \\mathcal{D}_i</span>  - and the two ciphertexts belong to the same coset of  <span class="math">\\mathcal{M}_i</span>  - i.e.  <span class="math">c^1 \\oplus c^2 \\in \\mathcal{M}_i</span> , where the index  <span class="math">i</span>  is fixed. The idea proposed in [JNPP14] to improve this distinguisher is simply to not fix the initial subspace  <span class="math">\\mathcal{D}_i</span>  and the final one  <span class="math">\\mathcal{M}_j</span> , that is to leave  <span class="math">i</span>  and  <span class="math">j</span>  completely arbitrary (i.e. they can take any possible values). It follows that the probability that a solution of the inbound phase of the rebound attack satisfies the outbound phase is higher, which implies that a complexity of  <span class="math">2^{44}</span>  is sufficient (instead of  <span class="math">2^{48}</span> ) for the shortcut player.</p>

    <p class="text-gray-300">The same strategy can be applied to the 7 rounds distinguisher presented in [MPRS09] and recalled in Sect. 4.2. In particular, using the same argumentation of [JNPP14], the computational cost of the distinguisher illustrated in Fig. 6 is  <span class="math">2^{20}</span>  instead of  <span class="math">2^{24}</span> . Indeed, note that for free  <span class="math">\\mathcal{D}_i</span>  and  <span class="math">\\mathcal{M}_j</span> , the probability that a solution of the inbound phase satisfies the outbound phase increases of a factor  <span class="math">4^2 = 2^4</span> .</p>

    <p class="text-gray-300">A possible 8-round known-key distinguisher can be set up starting from the 7-round distinguisher just presented and extending it at the end (or at the beginning) using a similar technique presented in Sect. 7 for the 9-round distinguisher. We refer to Sect. 7 for a complete discussion of this technique and we limit here to give a formal definition of the distinguisher and to do some considerations about the data and the computational cost.</p>

    <p class="text-gray-300">In the known-key distinguisher scenario, the two players have to send to the verifier  <span class="math">n</span>  different tuples of (plaintext, ciphertext) pairs, that is  <span class="math">\\{(p_i^1, c_i^1), (p_i^2, c_i^2)\\}</span>  for  <span class="math">i = 0, \\dots, n - 1</span> , with the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for each tuple, there exists  <span class="math">j</span>  s.t. the two plaintexts belong to the same coset of  <span class="math">\\mathcal{D}_j</span> , that is</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\forall i = 0, \\dots , n - 1, \\quad \\exists j \\in \\{0, \\dots , 3 \\} \\quad \\text {s . t .} \\quad p _ {i} ^ {1} \\oplus p _ {i} ^ {2} \\in \\mathcal {D} _ {j};</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there exists a key  <span class="math">k</span>  s.t. for each tuple there exists  <span class="math">l</span>  for which the two ciphertexts</li>

    </ol>

    <p class="text-gray-300">New and Old Limits for AES Known-Key Distinguishers</p>

    <p class="text-gray-300">belong to the same coset of <span class="math">\\mathcal{M}_{l}</span> one round before, that is</p>

    <p class="text-gray-300"><span class="math">\\exists!\\,k\\quad\\text{s.t.}\\quad\\forall i=0,...,n-1,\\quad\\exists l\\in\\{0,...,3\\}\\quad\\text{s.t.}\\quad R_{k}^{-1}(c_{i}^{1})\\oplus R_{k}^{-1}(c_{i}^{2})\\in\\mathcal{M}_{l}.</span></p>

    <p class="text-gray-300">If only the number of oracle-queries is considered, it is possible to prove that <span class="math">n\\geq 3</span> tuples are sufficient to set up this distinguisher. Indeed, using the same argumentation of Sect. 7, the generic player has to consider approximately <span class="math">2^{52.18}</span> different couples (see (7)), that is approximately <span class="math">2^{26.59}</span> different (plaintexts, ciphertexts) pairs, for a cost of <span class="math">2^{26.6}</span> oracle-queries, in order to have good probability to construct 3 tuples with the required properties. On the other hand, the cost for the shortcut player is only of <span class="math">3\\cdot 2^{20}=2^{21.6}</span> computations. In order to make the advantage of the shortcut player more significant, we choose an (arbitrary) value of <span class="math">n=8</span>, which implies a cost for the shortcut player of <span class="math">2^{23}</span> computations and of <span class="math">2^{48.9}</span> computations for the generic player.</p>

    <p class="text-gray-300">In a similar way, it is possible to prove that <span class="math">n=2</span> tuples are sufficient to set up this 8-round distinguisher when all the costs (number of oracle-queries + cost of generic player) are taken into account. Indeed, in this case and in order to construct 2 tuples that satisfy the required property for the same key, the second player has to consider approximately <span class="math">2^{30.4}</span> different tuples, that is <span class="math">2^{15.74}</span> different (plaintexts, ciphertexts) pairs. Using the same analysis proposed in App. D.1, the cost to find the 2-tuples that satisfy the relation <span class="math">\\mathcal{R}</span> can be approximated at <span class="math">2^{30.4}\\cdot 2^{11.6}=2^{42}</span> table look-ups, that is <span class="math">2^{34.68}</span> eight-round AES encryptions. On the other hand, the cost of the player that knows the key is of <span class="math">2\\cdot 2^{20}=2^{21}</span> computations, which is (much) lower than <span class="math">2^{35.68}</span>.</p>

    <p class="text-gray-300">For both cases, the verifier uses the same strategy presented in Sect. 7, and her cost is well approximated by <span class="math">2^{11.6}</span> eight-round encryptions.</p>

    <h3 id="sec-60" class="text-xl font-semibold mt-8">E.3 9-Round Known-Key Distinguisher</h3>

    <p class="text-gray-300">An efficient 9-round known-key distinguisher can be set up by extending the previous 8-round distinguisher at the beginning, or equivalent by extending the 7-round known-key distinguisher both at the beginning and at the end. Such a distinguisher is the best one both for the computational and data cost among those presented in literature.</p>

    <p class="text-gray-300">In order to set up this distinguisher on 9 rounds, we exploit the same strategy proposed for 10-round one. For this reason, we refer to Sect. 8 for a complete discussion. In the known-key distinguisher scenario, the two players have to send to the verifier <span class="math">n</span> different tuples of (plaintext, ciphertext) pairs, that is <span class="math">\\{(p_{i}^{1},c_{i}^{1}),(p_{i}^{2},c_{i}^{2})\\}</span> for <span class="math">i=0,...,n-1</span>, with the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there exists a key <span class="math">k^{0}</span> s.t. for each tuple there exists <span class="math">j</span> for which the two plaintexts belong to the same coset of <span class="math">\\mathcal{D}_{j}</span> after one round, that is</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\exists!\\,k^{0}\\quad\\text{s.t.}\\quad\\forall i=0,...,n-1,\\quad\\exists j\\in\\{0,...,3\\}\\quad\\text{s.t.}\\quad R_{k^{0}}(p_{i}^{1})\\oplus R_{k^{0}}(p_{i}^{2})\\in\\mathcal{D}_{j};</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there exists a key <span class="math">k^{9}</span> s.t. for each tuple there exists <span class="math">l</span> for which the two ciphertexts belong to the same coset of <span class="math">\\mathcal{M}_{l}</span> one round before, that is</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\exists!\\,k^{9}\\quad\\text{s.t.}\\quad\\forall i=0,...,n-1,\\quad\\exists l\\in\\{0,...,3\\}\\quad\\text{s.t.}\\quad R_{k^{9}}^{-1}(c_{i}^{1})\\oplus R_{k^{9}}^{-1}(c_{i}^{2})\\in\\mathcal{M}_{l}.</span></p>

    <p class="text-gray-300">We discuss here the two scenarios in which (1) the subkeys are independent and in which (2) a key schedule holds. Since the strategies used by the players are equivalent of the ones proposed in Sect. 8, we refer to that section for all the details and we limit here to do some considerations about the computational and data cost.</p>

    <h4 id="sec-61" class="text-lg font-semibold mt-6">8.3.1 Independent Subkeys: No Key Schedule.</h4>

    <p class="text-gray-300">As for the 10-round known-key distinguisher, we first consider the case in which there is no key schedule. The idea for the generic player is to choose an initial key <span class="math">\\hat{k}</span> and to choose the plaintexts in the set <span class="math">D_{a}=R_{\\hat{k}}^{-1}(\\mathcal{D}_{i}\\oplus a)</span>. If this player needs more plaintexts, the idea is to compute other <span class="math">D_{a^{\\prime}}</span> sets for another <span class="math">a^{\\prime}\\in\\mathcal{D}_{i}^{\\perp}</span> using the same key <span class="math">\\hat{k}</span>, as for the 10-round distinguisher case.</p>

    <p class="text-gray-300">In a similar way as before, <span class="math">n\\geq 3</span> tuples are sufficient for the case in which only the number of oracle-queries is considered, while <span class="math">n\\geq 2</span> tuples are sufficient to set up the distinguisher for the case in which all the cost are considered. As before, we choose an (arbitrary) value of <span class="math">n=8</span> to make the advantage of the shortcut player more significant. The costs of the two players are well approximated by the costs given for the previous 8-round distinguisher (note that the cost to compute <span class="math">R_{\\hat{k}}^{-1}(\\mathcal{D}_{i}\\oplus a)</span> is negligible compared to the total cost). Finally, the cost of the verifier is double with respect the previous case (since she has to check the existence of two keys).</p>

    <h4 id="sec-62" class="text-lg font-semibold mt-6">8.3.2 The Key Schedule Case.</h4>

    <p class="text-gray-300">Similar to what done in Sect. 8, the idea for the generic player is to choose the plaintexts in the same coset of <span class="math">\\mathcal{D}_{i}</span> in order to maximize the possible number of key <span class="math">k^{0}</span> and <span class="math">k^{10}</span> for which the required properties are satisfied - we refer to Sect. 8 - Prop. 2 for all the details. By analogous calculation of Sect. 8, if <span class="math">n=2</span> then this player needs approximately <span class="math">2^{52.48}</span> different couples in order to have a good probability of success, that is he must do approximately <span class="math">2^{26.74}</span> oracle-queries. On the other hand, the computational cost for the shortcut player is of <span class="math">2^{21}</span>. Thus, <span class="math">n=2</span> tuple is sufficient for this setting. Since <span class="math">n</span> must be at least equal to 2, note that the same result holds also for the case in which we consider the total computational cost (oracle cost + player cost). The verification cost is (approximately) equivalent to the one given for the case of independent subkeys, due to the (same) argumentations given in Sect. 8.</p>

    <h3 id="sec-63" class="text-xl font-semibold mt-8">8.4 Considerations and Comparison with Gilbert’s Distinguisher</h3>

    <p class="text-gray-300">Using the technique described in Sect. 9, one can theoretically extend again the previous 9-round known-key distinguisher at the end or/and at the beginning, obtaining a 10-or/and 11-round known-key distinguisher. Even if this is possible, we show that this distinguisher is (much) less competitive than the one described in Sect. 8 - obtained by a single extension at the end and at the beginning of a 8-round distinguisher - and the one proposed by Gilbert in <em>[Gilbert]</em>. The main problem of a 10-round distinguisher obtained extending a 7-round distinguisher two times at the end and one at the beginning (or viceversa) regards the computational cost of the verifier. Indeed, it is possible to show that this cost is much higher than <span class="math">2^{64}</span>, using similar argumentations proposed in Sect. 9 and due to the complexity of the key-recovery attack described in Sect. 6.2. Thus, since by definition the computational cost of verifier must be smaller than the costs of the two players, it follows that the overall computational cost of such a distinguisher is much higher than <span class="math">2^{64}</span>, that is it is much higher than the computational cost of our 10-round known-key distinguisher proposed in Sect. 8 and the one proposed by Gilbert in <em>[Gilbert]</em>.</p>

    <p class="text-gray-300">A final observation regards the possibility to set up a 8- and 9-round known-key distinguisher by extending at the beginning or/and at the end the 7-round known-key distinguisher based on the uniform distribution property (in a similar way of what Gilbert did to set up his distinguisher on 10-round). Note that the 7-round distinguisher based on this property has a complexity of <span class="math">2^{56}</span>). Thus, the 8-round known-key distinguisher obtained by extending the 7-round distinguisher at the end (or at the beginning) has at least a complexity of <span class="math">2^{56}</span>, which is higher than the 8-round known-key distinguisher</p>

    <p class="text-gray-300">proposed in <em>[x10]</em> (complexity of <span class="math">2^{44}</span>) and our one proposed in App. E.2 (complexity of <span class="math">2^{23}</span>). Similar argumentation holds for the 9-round distinguisher (obtained by extending at the beginning and at the end the cited 7-round distinguisher). It follows that such distinguishers are not competitive with respect to the others currently present in literature.</p>

    <h2 id="sec-64" class="text-2xl font-bold">Appendix F Proof of Proposition 2 - Sect. 8.2</h2>

    <h6 id="sec-65" class="text-base font-medium mt-4">Proposition 4.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">p^{1}</span> and <span class="math">p^{2}</span> two plaintexts that belong to the same coset of <span class="math">\\mathcal{D}_{j}</span> for a certain <span class="math">j</span>, that is <span class="math">p^{1}\\oplus p^{2}\\in\\mathcal{D}_{j}</span>. Moreover, assume that <span class="math">p^{1}\\oplus p^{2}\\notin\\mathcal{D}_{j}\\cap\\mathcal{C}_{L}</span> for each <span class="math">L\\subseteq\\{0,1,2,3\\}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 3<span class="math">. Then there exist on average </span>2^{106}<span class="math"> different keys </span>k<span class="math"> such that </span>R_{k}(p^{1})\\oplus R_{k}(p^{2})\\in\\mathcal{D}_{l}<span class="math"> for a certain </span>l\\in\\{0,1,2,3\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-66" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First of all, suppose by contradiction that <span class="math">p^{1}\\oplus p^{2}\\in\\mathcal{D}_{j}\\cap\\mathcal{C}_{L}</span> for a certain <span class="math">L\\subseteq\\{0,1,2,3\\}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 3<span class="math">. Since </span>\\mathcal{D}_{j}\\cap\\mathcal{C}_{L}\\subseteq\\mathcal{C}_{L}<span class="math">, it follows that </span>R(p^{1})\\oplus R(p^{2})\\in\\mathcal{C}_{j}\\cap\\mathcal{M}_{L}\\subseteq\\mathcal{M}_{L}<span class="math"> for </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 3<span class="math">. By (3), it follows that if </span>R(p^{1})\\oplus R(p^{2})\\in\\mathcal{M}_{L}<span class="math"> for </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 3<span class="math">, then </span>R(p^{1})\\oplus R(p^{2})\\notin\\mathcal{D}_{j}<span class="math"> for </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now, without loss of generality assume <span class="math">j=0</span> (the proof can be easily generalized for each <span class="math">j</span>). The idea is to look for the number of keys such that <span class="math">R_{k}(p^{1})\\oplus R_{k}(p^{2})\\in\\mathcal{C}_{j}\\cap\\mathcal{D}_{l}\\subseteq\\mathcal{D}_{l}</span> for a certain <span class="math">l\\in\\{0,1,2,3\\}</span>.</p>

    <p class="text-gray-300">By definition, <span class="math">p^{1}_{i,l}=p^{2}_{i,l}</span> for each <span class="math">i\\neq l</span>. Thus, it is easy to note that for each value of <span class="math">k_{i,l}</span> for <span class="math">i\\neq l</span> (that is 12 bytes) then <span class="math">R(p^{1})_{i,l}=R(p^{2})_{i,l}</span> for each <span class="math">i</span> and for each <span class="math">l=1,2,3</span> (i.e. the second, the third and the fourth columns of <span class="math">R(p^{1})</span> and <span class="math">R(p^{1})</span> are equal), for a total of <span class="math">2^{96}</span> possibilities.</p>

    <p class="text-gray-300">Consider now the bytes on the first diagonal, that is in positions <span class="math">i=l</span>. In this case, one has to guarantee that after one round three bytes of the two texts are equal, in order to have <span class="math">R_{k}(p^{1})\\oplus R_{k}(p^{2})\\in\\mathcal{C}_{j}\\cap\\mathcal{D}_{l}</span>. As shown in the attack on 3 rounds of Sect. 6.1, for each <span class="math">l</span> on average there are <span class="math">2^{8}</span> possible combinations of these four bytes such that this condition is satisfied. Since there are four different possible values of <span class="math">l</span>, the number of possible keys for this second point are on average <span class="math">4\\cdot 2^{8}=2^{10}</span>.</p>

    <p class="text-gray-300">In conclusion, the number of keys such that <span class="math">R_{k}(p^{1})\\oplus R_{k}(p^{2})\\in\\mathcal{C}_{j}\\cap\\mathcal{D}_{l}</span> for a certain <span class="math">l</span> are <span class="math">(2^{8})^{12}\\cdot 2^{10}=2^{106}</span>.</p>

    <p class="text-gray-300">∎∎</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">p^{1}</span> and <span class="math">p^{2}</span> in the same coset of <span class="math">\\mathcal{D}_{j}</span> (that is <span class="math">p^{1}\\oplus p^{2}\\in\\mathcal{D}_{j}</span>), and without loss of generality assume <span class="math">j=\\{0\\}</span>. We do a consideration about the hypothesis that <span class="math">p^{1}\\oplus p^{2}\\notin\\mathcal{D}_{0}\\cap\\mathcal{C}_{L}</span> for each <span class="math">L\\subseteq\\{0,1,2,3\\}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 3<span class="math">. If </span>p^{1}\\oplus p^{2}\\in\\mathcal{D}_{0}<span class="math">, then </span>p^{1}\\oplus p^{2}\\notin\\mathcal{D}_{0}\\cap\\mathcal{C}_{L}<span class="math"> for each </span>L\\subseteq\\{0,1,2,3\\}<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 3<span class="math"> if and only if </span>p^{1}_{i,i}\\neq p^{2}_{i,i}<span class="math"> for each </span>i=0,...,3<span class="math">. By simple calculation, this happens with probability </span>(255/256)^{4}\\simeq 2^{-0.0225}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Thus, given a coset of <span class="math">\\mathcal{D}_{0}</span>, it is possible to construct approximately <span class="math">2^{31}\\cdot(2^{32}-1)=2^{62.9999\\ldots}\\simeq 2^{63}</span> different couples. If one eliminates all the pairs <span class="math">(p^{1},p^{2})</span> for which there exists at least one <span class="math">i</span> such that <span class="math">p^{1}_{i,i}=p^{2}_{i,i}</span>, then the number of survived pairs is <span class="math">2^{62.9999\\ldots}\\cdot(255/256)^{4}=2^{62.9775\\ldots}</span>, which is still well approximated by <span class="math">2^{63}</span> for our scope. The cases for the other subspaces <span class="math">\\mathcal{D}_{j}</span> are similar.</p>

    <h2 id="sec-67" class="text-2xl font-bold">Appendix G The Herds Attack</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N. Ferguson et al. <em>[FKL^{+}01]</em> presented the first (and unique) integral attack on 7 rounds of AES-128. The attack is obtained by extending at the beginning the integral attack on 6 rounds of AES-128 <em>[DKR97]</em>-<em>[x18]</em>. This attack requires <span class="math">2^{128}-2^{119}</span> chosen plaintexts, which are distributed in <span class="math">2^{96}-2^{87}</span> different cosets of <span class="math">\\mathcal{D}_{i}</span> for a certain <span class="math">i\\subseteq\\{0,1,2,3\\}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math">, it has a computational complexity of </span>2^{120}<span class="math"> seven-round AES-encryptions and a memory cost of </span>2^{64}$ bits of memory.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Here we show why this attack can not be used to set up a 14-round known-key distinguisher for AES, based on the balanced property. Moreover, the same argumentation can also be used to justify why key-recovery attacks with both an extension at the end and at the beginning can not be used to set up known-key distinguisher in the Gilbert model.</p>

    <p class="text-gray-300">We briefly recall the idea used in <em>[FKL^{+}01]</em> to set up the attack on 7 rounds of AES. As we have already seen, given <span class="math">2^{32}</span> plaintexts in the same coset of a diagonal space <span class="math">\\mathcal{D}_{i}</span>, their sum after 4 rounds is equal to zero for each key. Thus, it is possible to set up an integral attack on 5 rounds of AES (working independently on each byte of the final subkey), and on 6 rounds. In this second case, assuming that the final MixColumns is omitted (otherwise the idea is simply to exchange the final MixColumns operation and the final AddRoundKey operation - they are linear), the idea is to guess one column of <span class="math">SR(k)</span> - where <span class="math">k</span> is the final round, decrypt one round and repeat the attack on 5 rounds. We refer to <em>[x10]</em> for more details.</p>

    <p class="text-gray-300">In order to attack 7 rounds, a first possibility is to extend the previous attack at the end, by guessing the entire final subkey, decrypting one round and repeating the attack on 6 rounds. However, while for AES-192 and AES-256 this attack is better than a brute force one, this is not true for AES-128. The idea of Ferguson et al. is the following. Consider the entire codebook, that is <span class="math">2^{128}</span> plaintexts (which can be seen as the union of <span class="math">2^{96}</span> different cosets of a diagonal space <span class="math">\\mathcal{D}_{i}</span>). Their sum after 5 rounds is equal to zero for each key. Similar to the previous attack on 6 rounds, the idea is to guess 4 byte of the final key (i.e. one column of <span class="math">SR(k)</span>), decrypt one round and do a classical integral attack (as the one already described for 5-round). However, as the authors observe, the sum is zero also for wrong keys and not only for the right one, since the full codebook is used.</p>

    <p class="text-gray-300">To solve the problem, the idea is not to consider the sum of all the ciphertexts, but only of part of them. In particular, given a byte <span class="math">x\\in\\mathbb{F}_{2^{8}}</span> fixed, one guesses four byte of the initial key and computes one-round encryption of each plaintext. The idea is to select the plaintexts such that after one round the byte in the <span class="math">j</span>-th row and <span class="math">l</span>-th column of the corresponding text is equal to <span class="math">x</span>, for a total of <span class="math">2^{120}</span> plaintexts. Then, the idea is to consider only the sum of the ciphertexts of these <span class="math">2^{120}</span> plaintexts, which is equal to zero only for the right key. Thus, by guessing 4 bytes of the final key and working independently on each byte of the second to last key, one checks if the sum is equal to zero.</p>

    <p class="text-gray-300">Finally the authors show how to improve this technique in order to use only <span class="math">2^{128}-2^{119}</span> chosen plaintexts instead of the full codebook, besides other improvements on the computational cost. We refer to <em>[FKL^{+}01]</em> for a complete description of the attack, and we limit ourselves to explain why it can not be used for a known-key distinguisher.</p>

    <p class="text-gray-300">Given the details of the herds attack, we now focus on the 14-round known-key distinguisher. Suppose by contradiction that such distinguisher can be set up. Without being too formal, we first give a more precise idea of this distinguisher. In the known-key distinguisher scenario, the players have to send to the verifier <span class="math">2^{n}</span> (plaintext, ciphertext) pairs, that is <span class="math">(p^{i},c^{i})</span> for <span class="math">i=0,...,2^{n}-1</span> where <span class="math">n\\geq 64</span>, with the following properties:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. there exist keys <span class="math">k^{0},k^{1},k^{2}</span> such that the texts <span class="math">\\{R_{k^{2}}(R_{k^{1}}(R_{k^{0}}(p^{i})))\\}_{i}</span> are uniform distributed among the cosets of <span class="math">\\mathcal{D}_{I}</span> for each <span class="math">I\\subseteq\\{0,1,2,3\\}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=3$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">First of all, note <span class="math">2^{n}</span> must be greater or equal than <span class="math">2^{128}-2^{119}</span>, that is <span class="math">2^{n}\\geq 2^{128}-2^{119}</span>. Indeed, this is the minimum number of texts for which the attacker is able to use the herds attack (i.e. the computational cost is lower than a brute force one). Assuming that this distinguisher is meaningful, we analyze the strategies of the players and of the verifier.</p>

    <p class="text-gray-300">First consider the shortcut player, i.e. the player who knows the key. As for the 8-round known-key distinguisher based on the integral property (see App. C for details), in order to guarantee the balanced property holds both on the plaintexts and on the ciphertexts,</p>

    <p class="text-gray-300">New and Old Limits for AES Known-Key Distinguishers</p>

    <p class="text-gray-300">the best strategy for this player is to consider the union of at least <span class="math">2^{64}-2^{55}</span> different cosets of <span class="math">\\mathcal{D}_i \\cap \\mathcal{M}_j</span>, that is</p>

    <div class="my-4 text-center"><span class="math-block">\\bigcup_{k=0}^{2^{64}-2^{55}-1} \\left(\\mathcal{D}_i \\oplus \\mathcal{M}_j \\oplus a_k\\right)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for <span class="math">2^{64}-2^{55}</span> different <span class="math">a_k \\in (\\mathcal{D}_i \\oplus \\mathcal{M}_j)^\\perp</span> (where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\mathcal{D}_i \\oplus \\mathcal{M}_j)^\\perp</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{64}$). Note that the previous union of cosets can be rewritten in the following way:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\bigcup_{k=0}^{2^{64}-2^{55}-1} \\left(\\mathcal{D}_i \\oplus \\mathcal{M}_j \\oplus a_k\\right) = \\bigcup_{k=0}^{2^{64}-2^{55}-1} \\left(\\bigcup_{b \\in \\mathcal{M}_j} \\mathcal{D}_i \\oplus (b \\oplus a_k)\\right) = \\bigcup_{k=0}^{2^{96}-2^{87}-1} \\mathcal{D}_i \\oplus \\hat{a}_k,</span></div>

    <p class="text-gray-300">that is the player is considering in the middle a union of cosets of <span class="math">\\mathcal{D}_i</span> (analogous for <span class="math">\\mathcal{M}_j</span>). In particular, the computational cost of this player is at least <span class="math">2^{128} - 2^{119}</span>.</p>

    <p class="text-gray-300">Consider now the verification strategy. As before, the idea is to filter wrong keys by checking zero sum, that is to look for subkeys <span class="math">k^0, k^1, k^2</span> and <span class="math">k^{12}, k^{13}, k^{14}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\bigoplus_{i=0}^{2^n - 1} R_{k^2}(R_{k^1}(R_{k^0}(p^i))) = 0 \\quad \\text{and} \\quad \\bigoplus_{i=1}^{2^{64}} R_{k^{12}}^{-1}(R_{k^{13}}^{-1}(R_{k^{14}}^{-1}(c^i))) = 0.</span></div>

    <p class="text-gray-300">The idea is to use the herds attack to find the subkeys and so to prove their existences. However, as we are going to show, a problem arises for the verifier, since when she receives the plaintexts and the ciphertexts by the player, the only way in which she can check the existence of the six subkeys is using a brute force attack. In other words, the verifier can not use in any way the herds attack presented before. Indeed, to do this, she has to know the "intermediate" texts, which corresponds to the 7-round encryption of the plaintexts or to the 7-round decryption of the ciphertexts. Since she doesn't know them, she can not divide the texts in set of <span class="math">2^{120}</span> elements. In other words, the extension at the beginning of the herds attack creates a problem for the verifier, since she doesn't have any access to the intermediate values of the plaintexts/ciphertexts. This justifies why this attack can not be used in order to set up a 14-round known-key distinguisher, and more generally why an attack with both the extension at the end and the beginning can not be used to set up a known-key distinguisher in the Gilbert model.</p>`;
---

<BaseLayout title="New and Old Limits for AES Known-Key Distinguishers (2017/255)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/255
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
