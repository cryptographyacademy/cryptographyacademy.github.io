---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2008/471';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Automatic Generation of Sound Zero-Knowledge Protocols';
const AUTHORS_HTML = 'Endre Bangerter, Jan Camenisch, Stephan Krenn, Ahmad-Reza Sadeghi, Thomas Schneider';

const CONTENT = `    <p class="text-gray-300">Automatic Generation of Sound Zero-Knowledge Protocols</p>

    <p class="text-gray-300">Endre Bangerter^{1}, Jan Camenisch^{2}, Stephan Krenn^{3}, Ahmad-Reza Sadeghi^{4}, and Thomas Schneider^{4}</p>

    <p class="text-gray-300">^{1} Bern University of Applied Sciences, Biel-Bienne, Switzerland endre.bangerter@bfh.ch ^{2} Bern University of Applied Sciences, Biel-Bienne and University of Fribourg, Switzerland stephan.krenn@bfh.ch ^{3} IBM Research, Zurich Research Lab, Rüschlikon, Switzerland jca@zurich.ibm.com ^{4} Horst Görtz Institute for IT Security, Ruhr-University Bochum, Germany {ahmad.sadeghi,thomas.schneider}@trust.rub.de</p>

    <p class="text-gray-300">Abstract. Efficient zero-knowledge proofs of knowledge (ZK-PoK) are basic building blocks of many practical cryptographic applications such as identification schemes, group signatures, and secure multiparty computation. Currently, first applications that essentially rely on ZK-POKs are being deployed in the real world. The most prominent example is Direct Anonymous Attestation (DAA), which was adopted by the Trusted Computing Group (TCG) and implemented as one of the functionalities of the cryptographic chip Trusted Platform Module (TPM).</p>

    <p class="text-gray-300">Implementing systems using ZK-PoK turns out to be challenging, since ZK-PoK are, loosely speaking, significantly more complex than standard crypto primitives, such as encryption and signature schemes. As a result, implementation cycles of ZK-PoK are time-consuming and error-prone, in particular for developers with minor or no cryptographic skills.</p>

    <p class="text-gray-300">To overcome these challenges, we have designed and implemented a compiler with corresponding languages that given a high-level ZK-PoK protocol specification automatically generates a sound implementation of this. The output is given in form of <span class="math">\\Sigma</span>-protocols, which are the most efficient protocols for ZK-PoK currently known. Our compiler translates ZK-PoK protocol specifications, written in a high-level protocol description language, into Java code or LaTeX documentation of the protocol.</p>

    <p class="text-gray-300">The compiler is based on a unified theoretical framework that encompasses a large number of existing ZK-PoK techniques.Within this framework we present a new efficient ZK-PoK protocol for exponentiation homomorphisms in hidden order groups. Our protocol overcomes several limitations of the existing proof techniques.</p>

    <p class="text-gray-300">Key words: Zero-Knowledge, Protocol Compiler, Language Design</p>

    <h2 id="sec-1" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">A zero-knowledge proof of knowledge (ZK-PoK) is a two-party protocol between a prover and a verifier, which allows the prover to convince the verifier that he knows some secret values (proof of knowledge property), without that the verifier learns anything about them (zero-knowledge property). There are fundamental results showing that all relations in NP have ZK-PoK <em>[x10]</em>. The corresponding protocols are of theoretical relevance, but much too inefficient in practice.</p>

    <p class="text-gray-300">Essentially, all efficient ZK-PoK protocols used in practice today are based on so called <span class="math">\\Sigma</span>-protocols. These are three-move protocols consisting of the first message from the prover, a challenge uniformly chosen at random by the verifier and the corresponding response from the prover again. What is typically being proved using basic <span class="math">\\Sigma</span>-protocols is the knowledge of a preimage under a homomorphism. There are numerous variations of these preimage proofs. For instance, so called “AND-proofs” allow to prove simultaneous knowledge of multiple preimages under possibly different</p>

    <p class="text-gray-300">homomorphisms. Similarly there are “OR-proofs”, and one can also show that different preimages fulfill a set of linear relations.</p>

    <p class="text-gray-300">These <span class="math">\\Sigma</span>-protocol based ZK-PoK proof techniques play an important role in applied cryptography. In fact, many practically oriented applications use such proofs as basic building blocks. Examples of such applications include identification schemes <em>[x10]</em>, interactive verifiable computation <em>[x4]</em>, group signatures <em>[x5]</em>, secure watermark detection <em>[x1]</em>, and efficient secure multiparty computation <em>[x16]</em> - just to name a few.</p>

    <p class="text-gray-300">While many of these applications typically only exist on a specification level, a direction of applied research has produced first applications using ZK-PoKs being deployed in the real world. One prominent example is Direct Anonymous Attestation (DAA) <em>[x3]</em>, which was adopted by the Trusted Computing Group (TCG), an industry consortium of many IT enterprises, as a privacy enhancing mechanism for remote authentication of computing platforms. Another example is the idemix anonymous credential system <em>[x6]</em>, which was released by IBM into the Eclipse Higgins project, an open source effort dedicated to developing software for “user-centric” identity management.</p>

    <p class="text-gray-300">Up to now, the design and implementation of practical ZK-PoK protocols is done “by hand”. The security proofs of these protocols consist of, loosely speaking, a handful of standard arguments and tricks which are repeated in different constellations over and over again. In fact, past experiences, e.g., during the development of the idemix anonymous credential system <em>[x7]</em> or Direct Anonymous Attestation <em>[x2]</em> have shown that (i) implementation cycles of ZK-PoK are time-consuming and error-prone, and (ii) it is hard to achieve resilience against design modifications, i.e., minor changes in the protocol specification can result in substantial implementation work. Moreover, in practice, protocols are often designed by cryptographers and then implemented by software engineers. The former typically are not skilled in implementation matters and the latter have a hard time understanding details and subtleties of ZK-PoK protocols, which are sometimes indeed rather complex. This can lead to a rupture between design and implementation, which can eventually lead to implementation errors. In this paper we aim at tackling these challenges.</p>

    <p class="text-gray-300">Our contributions. To overcome theses challenges, we have designed and implemented a compiler and corresponding languages that given a high-level ZK-PoK protocol specification automatically generates the implementation of the corresponding <span class="math">\\Sigma</span>-protocol. More precisely, we have designed a language which is inspired by the widely used Camenisch-Stadler notation <em>[x8]</em>. ZK-PoK protocol specifications in this language are then translated by the compiler either into Java or LaTeX code. The Java code can be integrated into higher level systems that make use of the corresponding ZK-PoK. The group operations in the generated code are expressed in terms of abstract interfaces. This allows users of the code to plug their preferred libraries into the protocol code by implementing our abstract interfaces. By the same mechanism we assert the algebraic extensibility and flexibility of the code being generated, i.e., to use one’s favorite group one simply implements our abstract interfaces with that group. The LaTeX code can be used for documenting the protocols and also for verification purposes. To the best of our knowledge, this is the first compiler suite to support the automatic generation of sound ZK-PoK protocols.</p>

    <p class="text-gray-300">The existing theory and collection of ZK-PoK proof techniques and “tricks” using <span class="math">\\Sigma</span>-protocols is vast. The problem however is the lack of a unified theory underlying these techniques. To build our compiler on solid ground, we have developed a unified framework which encompasses a large number (but probably not all) of existing proof techniques. The basis of the framework are simple</p>

    <p class="text-gray-300">proofs of knowledge of preimages under homomorphisms. More precisely, we have incorporated the theory by Cramer <em>[x10]</em> on special homomorphisms. These are essentially homomorphisms with a known order co-domain and the homomorphisms of the form <span class="math">\\phi(w)=w^{e}</span> underlying, e.g., the RSA scheme.</p>

    <p class="text-gray-300">Exponentiation homomorphisms in hidden order groups (i.e., <span class="math">\\phi:\\mathbb{Z}^{l}\\rightarrow\\mathcal{H}:(w_{1},\\ldots,w_{l})\\mapsto h_{1}^{w_{1}}\\cdots h_{l}^{w_{l}}</span> with <span class="math">h_{1},\\ldots,h_{l}</span> being elements of an RSA group) are not special and thus not covered by Cramer’s theory. Essentially, all ZK-PoK for such homomorphisms are currently based on the Damgård-Fujisaki (DF) scheme <em>[x14]</em>. While the DF scheme allows to demonstrate knowledge of preimages of exponentiation homomorphisms in hidden order groups, it is not a proof of knowledge in the strict sense, but loosely speaking, something weaker. In fact, the DF scheme is often wrongly believed to be a proof of knowledge. This is surprising, since the authors of the paper don’t make this claim, and describe in detail their proper definition of demonstrating knowledge. In fact, the DF scheme only works for homomorphisms which are generated using an associated setup protocol.</p>

    <p class="text-gray-300">We propose the novel <span class="math">\\Sigma^{exp}</span>-protocol, which takes up and extends the ideas underlying the DF scheme. The <span class="math">\\Sigma^{exp}</span>-protocol relies on weaker and simpler setup assumptions than the DF scheme and works for arbitrary exponentiation homomorphisms. In particular, it does not require that homomorphisms are generated according to some specific setup protocol, but only an auxiliary input has to be given to the prover and the verifier. This auxiliary input has to be verified in a setup protocol once, and can then be used for arbitrary exponentiation homomorphisms with less than an arbitrary (but fixed) number of base elements. Also, the <span class="math">\\Sigma^{exp}</span>-protocol can always be used instead of the DF scheme. This makes the <span class="math">\\Sigma^{exp}</span>-protocol more appropriate for our unified framework. The <span class="math">\\Sigma^{exp}</span>-protocol yields computational proofs of knowledge in the auxiliary string model, i.e., under the assumption that the prover and verifier are given some appropriately chosen auxiliary information. This definitional setting is simpler than the rather contrived one, which underlies the DF scheme. This can potentially lead to a simpler and more modular security analysis of applications relying on the <span class="math">\\Sigma^{exp}</span>-protocol. We believe that the <span class="math">\\Sigma^{exp}</span>-protocol is a contribution of independent interest.</p>

    <p class="text-gray-300">Finally, our theoretical framework also describes how to compose the basic protocols for preimage proofs mentioned above to obtain “AND” and “AND-OR” proofs, and to prove linear relations among preimages. Therefore we rely on a selection of existing techniques. The unification of ZK-PoK for special homomorphisms and hidden order homomorphisms is novel.</p>

    <p class="text-gray-300">The current version of the compiler - as presented in this paper - implements most of the general framework (excluding the proposed <span class="math">\\Sigma^{exp}</span>-protocol) and can already be used to automatically generate sound ZK-PoKs for many practical applications in known-order groups including Pedersen Commitments/Verifiable Secret Sharing <em>[x26]</em>, Schnorr Authentication/Signatures <em>[x30]</em>, proving in ZK that a number is the product of two safe primes <em>[x11]</em>, Electronic Cash <em>[x1, x18, x12]</em>, Group Signatures <em>[x13]</em>, and Ring Signatures <em>[x10]</em>. Also supported are ZK-PoKs of a plaintext corresponding to a ciphertext or relations between plaintexts under various encryption schemes such as, RSA <em>[x29]</em>, Paillier <em>[x28]</em>, or Damgård-Jurik <em>[x15]</em>; these homomorphic encryption schemes are widely used in e-voting and secure multiparty computation.</p>

    <p class="text-gray-300">Currently, we are working on the extension of our compiler for protocols in hidden order groups.</p>

    <p class="text-gray-300">Related Work. The compiler presented in this paper was started in <em>[x3, x11]</em>. We have extended it substantially and present it together with the underlying theoretical framework here.</p>

    <p class="text-gray-300">A profound analysis of <span class="math">\\Sigma</span>-protocols for special homomorphisms, the so-called <span class="math">\\Sigma^{\\phi}</span>-protocol, can be found in <em>[x10]</em>, and the used composition rules can be found in <em>[x11]</em>. A first framework for</p>

    <p class="text-gray-300">boolean formulae containing linear relations was done by Brands <em>[x1]</em> and extended by Bresson and Stern in <em>[x2]</em> to a larger class of predicates. The idea underlying our proofs for relations is essentially the same as in <em>[x4]</em>, where the authors also explain how to obtain efficient proof systems for such formulae. However, all these frameworks are restricted to exponentiation-based homomorphisms in known-order groups only. We extend it to unknown order groups as well. The <span class="math">\\Sigma^{exp}</span>-protocol extends work of Damgård-Fujisaki <em>[x7]</em> and overcomes some of their restrictions; similar approaches also appear in <em>[x5, x4]</em>.</p>

    <p class="text-gray-300">Provably secure protocols for two-party secure function evaluation (SFE) can be compiled automatically <em>[x13, x15]</em>. Similar to what our compiler does in the context of zero-knowledge protocols, these compilers allow to specify the function to be evaluated in a high-level language and automatically compile this into an executable protocol. They use zero-knowledge protocols as building blocks to prove that players behave honestly. In principle, the verification of the relation to be proven in zero-knowledge can be expressed as a function to which the prover provides the secret witness and which is evaluated in a secure way. The protocols generated by our compiler are much more efficient than this generic approach.</p>

    <p class="text-gray-300">On a lower level, Cryptography Aware language and cOmpiler (CAO) <em>[x6]</em> provides compiler support for efficient and secure low-level implementation of cryptographic primitives resistant against software side-channels <em>[x3]</em> and applications to elliptic curve cryptography <em>[x4]</em>.</p>

    <h2 id="sec-2" class="text-2xl font-bold">2 General Framework Description</h2>

    <p class="text-gray-300">In this section we present the theoretical framework underlying our compiler. We briefly review the theory by Cramer <em>[x8]</em> on <span class="math">\\Sigma</span>-protocols and proofs of knowledge for special homomorphisms using the <span class="math">\\Sigma^{\\phi}</span>-protocol in §2.1. On a high level, the class of special homomorphisms consists of homomorphisms where the co-domain is a known order group and of the power homomorphisms <span class="math">\\phi(w)=w^{e}</span> in hidden order groups. In the following §2.2 we describe how to compose <span class="math">\\Sigma^{\\phi}</span>-protocols to obtain simultaneous proofs of knowledge for preimages under multiple homomorphisms (i.e., “AND composition”), and PoKs for subsets of preimages out of a given set (i.e., “AND - OR composition”). Finally, in §2.3 we present techniques to prove knowledge of linear relations among preimages of homomorphisms; these techniques can be combined in a modular way with the “AND” and “AND-OR” compositions. As a result we obtain a rich language of expressions that can be proved about preimages of homomorphisms, and a simple unified theory underlying these constructions.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">2.1 <span class="math">\\Sigma</span>-protocols and proofs of knowledge for special homomorphisms</h3>

    <p class="text-gray-300">By <span class="math">s\\in_{R}S</span> we denote uniform random choice of element <span class="math">s</span> from set <span class="math">S</span>. The cardinality of <span class="math">S</span> is denoted by <span class="math">\\#S</span>, and the power set of <span class="math">S</span> by <span class="math">2^{S}</span>. We write <span class="math">(w_{i})_{i=1}^{n}</span> for the vector <span class="math">(w_{1},\\ldots,w_{n})</span>. By <span class="math">(w_{1},\\ldots,w_{n})^{T}</span> we denote the transposed vector. A mapping <span class="math">\\phi:\\mathcal{G}\\to\\mathcal{H}</span> from an additive group <span class="math">(\\mathcal{G},+)</span> into a multiplicative group <span class="math">(\\mathcal{H},\\cdot)</span> is called <em>homomorphism</em>, iff <span class="math">\\forall a,b\\in\\mathcal{G}:\\phi(a+b)=\\phi(a)\\cdot\\phi(b)</span>. By <span class="math">\\operatorname{Im}\\phi</span> we denote the <em>image of <span class="math">\\phi</span></em>, i.e., <span class="math">\\operatorname{Im}\\phi=\\{z\\in\\mathcal{H}:\\exists w\\in\\mathcal{G}:z=\\phi(w)\\}</span>. Note that <span class="math">\\operatorname{Im}\\phi</span> is a subgroup of <span class="math">\\mathcal{H}</span>.</p>

    <p class="text-gray-300">Let <span class="math">R</span> be a binary relation and let <span class="math">(x,w)\\in R</span>, where <span class="math">w</span> is a witness and <span class="math">x</span> an element of the associated language <span class="math">L_{R}</span>. Informally, a <em>proof of knowledge</em> with <em>knowledge error <span class="math">\\kappa</span></em> for <span class="math">R</span> is a pair of interactive algorithms <span class="math">(\\mathsf{P},\\mathsf{V})</span>, such that every (potentially dishonest) prover <span class="math">\\mathsf{P}^{<em>}</span> who on input <span class="math">x</span> can make verifier <span class="math">\\mathsf{V}</span> accept with probability more than <span class="math">\\kappa(x)</span>, has to know a <span class="math">w^{\\prime}</span>, such that <span class="math">(x,w^{\\prime})\\in R</span>; further, <span class="math">\\mathsf{V}</span> always accepts for the honest prover <span class="math">\\mathsf{P}</span>. For a formal definition we refer to </em>[x2]*.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">A proof of knowledge in the auxiliary string model with knowledge error <span class="math">\\kappa</span> for relation <span class="math">R</span> is a proof of knowledge where <span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> additionally are given an auxiliary string <span class="math">\\alpha</span>, which is chosen according to some predefined probability distribution. For a formal definition we refer to <em>[x10]</em>. We note that auxiliary string proofs of knowledge subsume the plain ones. We call a proof of knowledge in the plain or the auxiliary string model computational, if we restrict provers to be probabilistic polynomial-time (PPT) algorithms.</p>

    <p class="text-gray-300">All protocols generated by our compiler fall into the abstract class of <span class="math">\\Sigma</span>-protocols defined next.</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Definition 1 (<span class="math">\\Sigma</span>-protocol)</h6>

    <p class="text-gray-300">Let <span class="math">R</span> denote a binary relation, and consider a <span class="math">(x,w)\\in R</span>. Let <span class="math">\\mathsf{P}_{1},\\mathsf{P}_{2}</span>, and <span class="math">\\mathsf{V}</span> denote arbitrary algorithms and <span class="math">\\alpha</span> a (potentially empty) auxiliary string. A protocol between a prover <span class="math">\\mathcal{P}:=\\mathcal{P}(x,w,\\alpha)</span> and a verifier <span class="math">\\mathcal{V}:=\\mathcal{V}(x,\\alpha)</span> is called a <span class="math">\\Sigma</span>-protocol with challenge set <span class="math">\\mathcal{C}=\\{0,\\ldots,c^{+}\\}</span> if it satisfies the following conditions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>3-move form: The protocol is of the following form:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> sets <span class="math">(r,state):=\\mathsf{P}_{1}(x,w,\\alpha)</span>, sends <span class="math">r</span> to <span class="math">\\mathcal{V}</span> and keeps <span class="math">state</span> secret.</li>

      <li><span class="math">\\mathcal{V}</span> sends a random challenge <span class="math">c\\in_{R}\\mathcal{C}</span> to <span class="math">\\mathcal{P}</span></li>

      <li><span class="math">\\mathcal{P}</span> computes <span class="math">s:=\\mathsf{P}_{2}(x,w,state,c,\\alpha)</span>, sends <span class="math">s</span> to <span class="math">\\mathcal{V}</span> who accepts if predicate <span class="math">\\mathsf{V}(x,r,c,s,\\alpha)=true</span>; otherwise he rejects.</li>

    </ul>

    <p class="text-gray-300">Often <span class="math">r,c,s</span> are referred to as <em>commitment, challenge</em> and <em>response</em>, respectively.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: For an honest prover, the verifier always accepts.</li>

      <li>Special honest-verifier zero-knowledge: There is a PPT algorithm <span class="math">\\mathsf{S}</span>, called the <em>simulator</em>, which takes <span class="math">(x,c)</span> as input and outputs a triple <span class="math">(r,c,s)</span> the distribution of which is indistinguishable from the distribution of real communications between prover and verifier.</li>

    </ul>

    <p class="text-gray-300">If <span class="math">\\alpha</span> is the empty string, we will omit it as a parameter.</p>

    <p class="text-gray-300">Concrete instances of a <span class="math">\\Sigma</span>-protocol are obtained by defining the algorithms <span class="math">\\mathsf{P}_{1}</span>, <span class="math">\\mathsf{P}_{2}</span>, <span class="math">\\mathsf{V}</span>, and proving the protocol properties required by Definition 1.</p>

    <p class="text-gray-300">The significance of this definition is that the 3-move form and the completeness property underly the proof of knowledge property of all <span class="math">\\Sigma</span>-protocols currently being known. The completeness property of a <span class="math">\\Sigma</span>-protocol trivially corresponds to the completeness property required for a proof of knowledge.</p>

    <p class="text-gray-300">The 3-move form property is more interesting. In fact, based on this property one can show that there is an algorithm that, when given rewinding access to an arbitrary convicing prover in a <span class="math">\\Sigma</span>-protocol, will output two <em>accepting communication triples</em> <span class="math">(r,c^{\\prime},s^{\\prime})</span> and <span class="math">(r,c^{\\prime\\prime},s^{\\prime\\prime})</span> (i.e., triples such that <span class="math">\\mathsf{V}(x,r,c^{\\prime},s^{\\prime})=\\mathsf{V}(x,r,c^{\\prime\\prime},s^{\\prime\\prime})=true</span>), satisfying <span class="math">c^{\\prime}\\neq c^{\\prime\\prime}</span>. This property is fundamental, since all currently existing knowledge extractors for <span class="math">\\Sigma</span>-protocols build upon this property. For a proof of this property see, e.g., Damgård <em>[x10]</em>.</p>

    <p class="text-gray-300">Also, from the special honest-verifier zero-knowledge (special HVZK) property the plain HVZK property of <span class="math">\\Sigma</span>-protocols easily follows. Moreover, there exist techniques that allow to turn a <span class="math">\\Sigma</span>-protocol into a zero-knowledge or concurrent zero-knowledge protocol, e.g. <em>[x10]</em>. The Fiat-Shamir heuristic allows to transform <span class="math">\\Sigma</span> protocols into non-interactive signatures of knowledge <em>[x16]</em>.</p>

    <p class="text-gray-300">Next we describe a concrete <span class="math">\\Sigma</span>-protocol for homomorphisms with a finite domain.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Definition 2 (<span class="math">\\Sigma^{\\phi}</span>-protocol)</h6>

    <p class="text-gray-300">Let be given a homomorphism <span class="math">\\phi:\\mathcal{G}\\rightarrow\\mathcal{H}</span> with a finite domain <span class="math">\\mathcal{G}</span> and <span class="math">x=\\phi(w)</span>. The <span class="math">\\Sigma^{\\phi}</span>-protocol with prover <span class="math">\\mathcal{P}(x,w)</span> and verifier <span class="math">\\mathcal{V}(x)</span> is defined by choosing the algorithms <span class="math">\\mathsf{P}_{1}</span>, <span class="math">\\mathsf{P}_{2}</span>, and <span class="math">\\mathsf{V}</span>, occurring in the definition of the <span class="math">\\Sigma</span>-protocol, as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}_{1}(x,w)</span> chooses <span class="math">k\\in_{R}\\mathcal{G}</span> and sets <span class="math">(r,state):=(\\phi(k),k)</span>.</li>

      <li><span class="math">\\mathsf{P}_{2}(x,w,state,c)</span> computes <span class="math">s:=k+cw</span>.</li>

      <li><span class="math">\\mathsf{V}(x,r,c,s)=true</span>, iff <span class="math">\\phi(s)=rx^{c}</span>.</li>

    </ul>

    <p class="text-gray-300">For any <span class="math">\\phi</span> with a finite domain the <span class="math">\\Sigma^{\\phi}</span>-protocol with binary challenge set <span class="math">\\mathcal{C}=\\{0,1\\}</span> is a <span class="math">\\Sigma</span>-protocol according to Definition 1 and it can be shown to be a proof of knowledge with knowledge error <span class="math">1/2</span>, e.g., <em>[x10]</em>. To obtain a sufficiently small knowledge error it needs to be repeated sequentially, e.g., <span class="math">80</span> repetitions are required to reduce the knowledge error to <span class="math">1/2^{80}</span>. The resulting proofs are not sufficiently efficient for many practical applications. For so called <em>special homomorphisms</em> we can obtain much more efficient proofs, since they allow to obtain a small knowledge error in a single execution of the <span class="math">\\Sigma^{\\phi}</span>-protocol.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Definition 3 (Special Homomorphism <em>[x10]</em>)</h6>

    <p class="text-gray-300">A homomorphism <span class="math">\\phi</span> is called <em>special</em>, if there is a PPT algorithm that on input <span class="math">\\phi:\\mathcal{G}\\to\\mathcal{H}</span> and <span class="math">x\\in\\operatorname{Im}\\phi</span> outputs <span class="math">(u,v)\\in\\mathcal{G}\\times\\mathbb{Z}\\setminus\\{0\\}</span>, such that <span class="math">x^{v}=\\phi(u)</span>. For a given <span class="math">\\phi</span>, the <em>special exponent <span class="math">v</span></em> being output has to be the same for all <span class="math">x</span>.</p>

    <p class="text-gray-300">Many homomorphisms used in cryptography are special. For example every homomorphism <span class="math">\\phi</span>, for which a non-zero multiple <span class="math">v</span> of the order of <span class="math">\\operatorname{Im}\\phi</span> is known, is special, since <span class="math">x^{v}=1=\\phi(0)</span> for all <span class="math">x\\in\\operatorname{Im}\\phi</span>. Especially, if the order of <span class="math">\\mathcal{H}</span> is known, one can set <span class="math">v:=\\operatorname{ord}(\\mathcal{H})</span>. There are also special homomorphisms for which the order of the image is unknown (and in fact hard to compute). For instance, consider a power homomorphism <span class="math">\\phi:\\mathbb{Z}_{n}^{<em>}\\to\\mathbb{Z}_{n}^{</em>},x\\mapsto x^{e}</span> where <span class="math">n</span> is an RSA modulus and <span class="math">e\\in\\mathbb{Z}</span>. Then for every <span class="math">x\\in\\operatorname{Im}\\phi</span> the pair <span class="math">(x,e)</span> satisfies <span class="math">x^{e}=\\phi(x)</span>, and thus <span class="math">\\phi</span> is special. Examples for efficient protocols relying on special homomorphisms are those given by Schnorr <em>[x22]</em> and by Guillou and Quisquater <em>[x14]</em>.</p>

    <p class="text-gray-300">For the proof of the following theorem on special homomorphisms we refer to §A.1:</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Theorem 1</h6>

    <p class="text-gray-300">Let <span class="math">\\phi</span> be a special homomorphism, and let <span class="math">c^{+}</span> be smaller than the smallest prime dividing its special exponent <span class="math">v</span>. Then the <span class="math">\\Sigma^{\\phi}</span>-protocol is a <span class="math">\\Sigma</span>-protocol with challenge set <span class="math">\\mathcal{C}=\\{0,\\ldots,c^{+}\\}</span> according to Definition 1, and a HVZK proof of knowledge with knowledge error <span class="math">1/\\#\\mathcal{C}</span> for <span class="math">\\phi</span>.</p>

    <p class="text-gray-300">Notation of ZK-PoKs. We will use the notation introduced in <em>[x11]</em> to denote ZK-PoKs. That is, a term like</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ZPK}\\bigg{[}(\\omega_{1},\\omega_{2}):x_{1}=\\phi_{1}(\\omega_{1})\\quad\\wedge\\quad x_{2}=\\phi_{2}(\\omega_{2})\\quad\\wedge\\quad\\omega_{1}=a\\omega_{2}\\bigg{]}</span></p>

    <p class="text-gray-300">means, that knowledge of <span class="math">w_{1},w_{2}</span> has to be proven such that <span class="math">x_{1}=\\phi_{1}(w_{1})</span>, <span class="math">x_{2}=\\phi_{2}(w_{2})</span> and <span class="math">w_{1}=aw_{2}</span>. We will stick to the convention that knowledge of variables denoted by Greek letters has to be proven, whereas all other quantities are assumes to be publicly known.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.2 Boolean composition of preimage proofs</h3>

    <p class="text-gray-300">In many cryptographic applications simple preimage proofs are not sufficient. Hence we will describe the techniques used in our compiler to prove knowledge of a subset of preimages. To this end, we will consider the case of pure AND-proofs, followed by proofs for arbitrary monotone boolean formulae.</p>

    <p class="text-gray-300">AND - proofs. First, we consider the pure AND-proof, i.e., proofs of knowledge of multiple preimages under possibly different homomorphisms. Using the notation of Camenisch and Stadler</p>

    <p class="text-gray-300">[CS97a] we want to perform the following ZK-PoK:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ZPK}\\bigg{[}(\\omega_{i})_{i=1}^{m}:\\bigwedge_{i=1}^{m}x_{i}=\\phi_{i}(\\omega_{i})\\bigg{]}.</span> (1)</p>

    <p class="text-gray-300">Here, the <span class="math">\\phi_{i}:\\mathcal{G}_{i}\\to\\mathcal{H}_{i}</span> are special homomorphisms. For notational convenience, we will describe the composition of two proofs only (i.e., <span class="math">m=2</span>); generalisation to an arbitrary <span class="math">m</span> is straightforward. This means, we show how to <span class="math">\\mathsf{ZPK}\\big{[}(\\omega_{1},\\omega_{2}):x_{1}=\\phi_{1}(\\omega_{1})\\wedge x_{2}=\\phi_{2}(\\omega_{2})\\big{]}</span>:</p>

    <p class="text-gray-300">To this end, define <span class="math">\\phi:\\mathcal{G}_{1}\\times\\mathcal{G}_{2}\\to\\mathcal{H}_{1}\\times\\mathcal{H}_{2}</span> by <span class="math">(w_{1},w_{2})\\mapsto(\\phi_{1}(w_{1}),\\phi_{2}(w_{2}))</span>. Set <span class="math">w:=(w_{1},w_{2})</span> and <span class="math">x:=(x_{1},x_{2})</span>. Then performing <span class="math">\\mathsf{ZPK}\\big{[}(\\omega):x=\\phi(\\omega)\\big{]}</span> proves knowledge of the required preimages, if one chooses <span class="math">c^{+}</span> smaller than the smallest prime dividing <span class="math">\\operatorname{lcm}(v_{1},v_{2})</span>, where <span class="math">v_{i}</span> is the special exponent of <span class="math">\\phi_{i}</span>.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Lemma 1</h6>

    <p class="text-gray-300">Using the AND-composition technique described above yields a special HVZK proof of knowledge (in the plain model) for the preimages <span class="math">w_{1},w_{2}</span> under special homomorphisms <span class="math">\\phi_{1},\\phi_{2}</span>.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Proof (Sketch)</h6>

    <p class="text-gray-300">Note that <span class="math">\\phi</span> is special with special exponent <span class="math">\\operatorname{lcm}(v_{1},v_{2})</span>. Hence, using Theorem 1 we have that the according <span class="math">\\Sigma^{\\phi}</span>-protocol is a <span class="math">\\Sigma</span>-protocol. ∎</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Proofs of expressions containing ORs</h4>

    <p class="text-gray-300">Let’s now consider AND-OR-proofs, i.e., proofs of arbitrary monotone boolean formulae. Let be given <span class="math">x_{i}=\\phi_{i}(w_{i})</span> for <span class="math">i=1,\\ldots,n</span>. Let each <span class="math">\\phi_{i}</span> be special. Further, let be given a <em>monotone access structure</em> <span class="math">\\Gamma</span> on <span class="math">\\{1,\\ldots,n\\}</span>. That is, <span class="math">\\Gamma\\subseteq 2^{\\{1,\\ldots,n\\}}</span> satisfying that, if <span class="math">A\\in\\Gamma</span> and <span class="math">A\\subseteq B</span>, then <span class="math">B\\in\\Gamma</span>. We explain how to construct a ZK-PoK for:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ZPK}\\bigg{[}(\\omega_{i})_{i=1}^{n}:\\bigvee_{A\\in\\Gamma}\\bigwedge_{j\\in A}x_{j}=\\phi_{j}(\\omega_{j})\\bigg{]}.</span> (2)</p>

    <p class="text-gray-300">To this end, we use the technique of Cramer, Damgård and Schoenmakers <em>[x1]</em>, which uses <em>secret sharing schemes</em> <em>[x12, x2]</em> to yield efficient HVZK proofs of knowledge for expressions like (2). These PoKs are perfect HVZK in the plain model. For details we refer to <em>[x1]</em>.</p>

    <p class="text-gray-300">Our compiler uses Shamir’s secret sharing scheme <em>[x12]</em>, which allows to realize any <em>threshold access structure</em>, i.e., there is a <span class="math">k\\leq n</span>, s.t. <span class="math">A\\in\\Gamma</span>, if and only if <span class="math">\\#A\\geq k</span>; we stress that this covers OR-proofs, as an OR can be seen as a threshold scheme with <span class="math">k=1</span>.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.3 Relations among preimages</h3>

    <p class="text-gray-300">Next we will describe how homogeneous linear relations among the preimages can be proven. For better understanding, we first consider a simple example, where only one equation has to be satisfied:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ZPK}\\bigg{[}(\\omega_{1},\\omega_{2}):x_{1}=\\phi_{1}(\\omega_{1})\\wedge x_{2}=\\phi_{2}(\\omega_{2})\\wedge\\omega_{2}=b\\omega_{1}\\bigg{]}</span> (3)</p>

    <p class="text-gray-300">The idea now is quite simple: first, note that the set <span class="math">\\hat{\\mathcal{G}}</span> of pairs satisfying the relation is a subgroup of <span class="math">\\mathcal{G}^{2}</span>; that is, <span class="math">\\hat{\\mathcal{G}}=\\{(z,bz):z\\in\\mathcal{G}\\}</span>. So, define <span class="math">\\phi:\\hat{\\mathcal{G}}\\to\\mathcal{H}_{1}\\times\\mathcal{H}_{2}</span> as the cartesian product of <span class="math">\\phi_{1}</span> and <span class="math">\\phi_{2}</span>, and let <span class="math">x:=(x_{1},x_{2})</span>. Then (3) can be proven by performing <span class="math">\\mathsf{ZPK}\\big{[}(\\omega):x=\\phi(\\omega)\\big{]}</span>. Note that <span class="math">r\\in_{R}\\hat{\\mathcal{G}}</span> can be drawn efficiently by choosing <span class="math">r_{1}\\in_{R}\\mathcal{G}</span> and setting <span class="math">r:=(r_{1},br_{1})</span>. This is essentially the same idea as in <em>[x1]</em>, where this technique is used to prove that two discrete logarithms are equal.</p>

    <p class="text-gray-300">Let us now generalize this to the general case, with an arbitrary number of homomorphisms and linear relations. Assume one has <span class="math">m</span> homomorphisms <span class="math">\\phi_j: \\mathcal{G}^{n_j} \\to \\mathcal{H}_j</span> and a family of sets <span class="math">\\Theta \\subseteq 2^{\\{1,\\dots,m\\}}</span>. For each <span class="math">j</span>, let <span class="math">x_j = \\phi_j(w_{j1},\\ldots ,w_{jn_j})</span>. We show how to prove the following statement:</p>

    <div class="my-4 text-center"><span class="math-block">Z P K \\left[ \\left(\\left(\\omega_{j1}, \\dots , \\omega_{jn_j}\\right)_{j=1}^{m}\\right): \\bigvee_{S \\in \\Theta} \\left(\\bigwedge_{j \\in S} x_j = \\phi_j \\left(\\omega_{j1}, \\dots , \\omega_{jn_j}\\right) \\wedge \\mathbf{0} = A_S \\cdot \\left(\\left(\\omega_{j1}, \\dots , \\omega_{jn_j}\\right)_{j \\in S}\\right)^T\\right) \\right]. \\tag{4}</span></div>

    <p class="text-gray-300">Here, for each <span class="math">S \\in \\Theta</span>, <span class="math">A_S</span> denotes an integer matrix with <span class="math">\\sum_{j \\in S} n_j</span> columns and as many rows as linear relation have to be satisfied, of the following form:</p>

    <div class="my-4 text-center"><span class="math-block">A_S = \\begin{pmatrix} 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; * \\dots &amp;amp; * \\\\ 0 &amp;amp; \\ddots &amp;amp; &amp;amp; \\vdots &amp;amp; \\vdots \\\\ 1 &amp;amp; * &amp;amp; \\dots &amp;amp; * \\dots &amp;amp; * \\end{pmatrix}.</span></div>

    <p class="text-gray-300">In the following we assume that all <span class="math">\\phi_j</span> in (4) are special homomorphisms, for which the special exponent is a nonzero multiple of <span class="math">\\operatorname{ord}(\\operatorname{Im} \\phi)</span>. Then the 4 can be handled using the composition techniques of §2.2 by additionally performing the following steps for each <span class="math">S \\in \\Theta</span> first:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">x_S := (x_j)_{j \\in S}</span> be the vector consisting of all images in <span class="math">S</span>.</li>

      <li>Define <span class="math">\\mathcal{G}_S</span> as the subgroup of <span class="math">\\prod_{j \\in S} \\mathcal{G}^{n_j}</span> consisting of all tuples satisfying the linear relations in (4) within the conjunctive clauses corresponding to <span class="math">S</span>. Because of the form of <span class="math">A_S</span>, random choices can be done efficiently in <span class="math">\\mathcal{G}_S</span> by forward substitution.</li>

      <li>The homomorphism <span class="math">\\phi_S: \\mathcal{G}_S \\to \\prod_{j \\in S} \\mathcal{H}_j</span> is set to the cartesian product of all <span class="math">\\phi_j</span> with <span class="math">j \\in S</span>.</li>

    </ul>

    <p class="text-gray-300">Using this approach, expression (4) reduces to an OR-proof among the preimages of the <span class="math">x_S</span>:</p>

    <div class="my-4 text-center"><span class="math-block">Z P K \\left[ \\left(\\left(\\omega_{j1}, \\dots , \\omega_{jn_j}\\right)_{j=1}^{m}\\right): \\bigvee_{S \\in \\Theta} x_S = \\phi_S \\left(\\left(\\omega_{j1}, \\dots , \\omega_{jn_j}\\right)_{j \\in S}\\right) \\right].</span></div>

    <p class="text-gray-300"><strong>Theorem 2.</strong> Let the special exponent <span class="math">v_j</span> of <span class="math">\\phi_j</span> be a nonzero multiple of the order of <span class="math">\\operatorname{Im} \\phi_j</span> for all <span class="math">j \\in \\{1, \\ldots, m\\}</span>. Then performing the steps described above yields a <span class="math">\\Sigma</span>-protocol to prove knowledge of preimages satisfying the conditions in (4).</p>

    <p class="text-gray-300"><strong>Proof.</strong> We show that all <span class="math">\\phi_S</span> are special: As <span class="math">v_j</span> is a (nonzero) multiple of the order of <span class="math">\\operatorname{Im} \\phi_j</span>, the same holds for <span class="math">v_S := \\prod_{j \\in S} v_j</span> and <span class="math">\\phi_S</span>. Set <span class="math">u = 0</span> for all <span class="math">x \\in \\operatorname{Im} \\phi_S</span>. Then <span class="math">x^{v_S} = 1 = \\phi_S(0)</span> and the zero-vector trivially satisfies all homogeneous linear equations. So the claim follows by Lemma 1 and the correctness of the OR-composition by [CDS94]. <span class="math">\\square</span></p>

    <p class="text-gray-300">So far we have restricted the domain of each homomorphism to be <span class="math">\\mathcal{G}^{n_j}</span>. Yet, the above result can easily be generalized to the case of arbitrary domains, as long as all preimage within one linear relation in (4) are elements of the same group. This is already implemented in our compiler.</p>

    <p class="text-gray-300"><strong>Further relations.</strong> Using the methods described so far, it is possible to prove all statements that can algebraically be derived from preimage proofs using boolean composition and linear relations. For instance multiplicative relations can be performed manually with our current compiler:</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Example 1 (Multiplicative Relations modulo <span class="math">ord(\\mathcal{G})</span>)</h6>

    <p class="text-gray-300">To prove knowledge of the discrete logarithms <span class="math">w_{1},w_{2},w_{3}</span> of <span class="math">x_{1},x_{2},x_{3}</span>, satisfying <span class="math">w_{1}w_{2}=w_{3}\\mod\\mathrm{ord}(\\mathcal{G})</span> one can perform the following proof:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ZPK}\\biggl{[}(\\omega_{1},\\omega_{2},\\omega_{3}):x_{1}=g^{\\omega_{1}}\\wedge x_{2}=g^{\\omega_{2}}\\wedge x_{3}=g^{\\omega_{3}}\\wedge x_{3}=x_{1}^{\\omega_{2}}\\biggr{]}.</span></p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Example 2 (Polynomial Relations modulo <span class="math">ord(\\mathcal{G})</span>)</h6>

    <p class="text-gray-300">As a special case of the previous example one can show that one preimage is a power of another one, which together with linear relations allows to prove polynomial relations without constant terms. If in the previous example the relation <span class="math">w_{3}=w_{1}^{2}+w_{2}\\mod\\mathrm{ord}(\\mathcal{G})</span> has to be satisfied, the problem can be reduced to one only containing linear constraints <em>[x10]</em>, which can be handled as explained before:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ZPK}\\biggl{[}(\\omega_{1},\\omega_{2},\\omega_{3},\\mu):x_{1}=g^{\\omega_{1}}\\wedge x_{2}=g^{\\omega_{2}}\\wedge x_{3}=g^{\\omega_{3}}\\wedge 1=g^{\\mu}x_{1}^{-\\omega_{1}}\\wedge\\omega_{3}=\\mu+\\omega_{2}\\biggr{]}.</span></p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Example 3 (Range Proof)</h6>

    <p class="text-gray-300">As suggested in <em>[x11]</em> one can proof knowledge of a preimage <span class="math">\\omega</span> of <span class="math">x=\\phi(\\omega)</span> that lies in a given range, i.e., <span class="math">2^{\\ell_{1}}-2^{\\ell_{2}}\\leq\\omega\\leq 2^{\\ell_{1}}+2^{\\ell_{2}}</span> for public constants <span class="math">\\ell_{1},\\ell_{2}</span>, by committing to the bits of <span class="math">\\omega</span> with Pederson’s homomorphic commitment scheme <em>[x24]</em> and then proving that the commitments hide either <span class="math">0</span> or <span class="math">1</span> and constitute the binary representation of <span class="math">\\omega</span>.</p>

    <p class="text-gray-300">In the following two sections we describe how our current compiler implements the described general framework in §3 and give practical examples in §4. Theoretically interested readers can safely skip these sections and continue reading in §5 how the general framework presented in this section can be extended to hidden order groups.</p>

    <h2 id="sec-16" class="text-2xl font-bold">3 Implementation of the Compiler</h2>

    <p class="text-gray-300">As a proof of concept, we have implemented a compiler that brings the theoretical framework of §2 into practice. That is, the current version of the compiler supports the <span class="math">\\Sigma^{\\phi}</span>-protocol (cf. Definition 2) for proofs of special homomorphisms, especially including all homomorphisms with known-order co-domain. Future versions will also be able to prove exponentiation homomorphisms in unknown-order groups using the techniques described in §5.</p>

    <p class="text-gray-300">The compiler is based on work in <em>[x5]</em> and IBM Research and we plan to publish it as an open source project soon. It translates a high-level protocol specification into a complete, sound and HVZK <span class="math">\\Sigma</span>-protocol for special homomorphisms using the techniques of §2.2 and §2.3.</p>

    <p class="text-gray-300">The input of the compiler is a protocol specification in a language which is very close to the intuitive and widely used notation of Camenisch-Stadler <em>[x10]</em> with extensions to specify the underlying algebraic structures precisely.</p>

    <p class="text-gray-300">The output of the compiler is either a human-readable specification of the protocol in LaTeX or JAVA source code for prover and verifier that can be compiled into runnable code. The JAVA code corresponds to the algorithms of the <span class="math">\\Sigma</span>-protocol for prover and verifier <span class="math">(\\mathsf{P}_{1},\\mathsf{P}_{2},\\mathsf{V})</span> that can easily be integrated into high-level user applications. Some parameters that can not be inferred by the compiler automatically (like the size of the challenge set) must be chosen by the user according to the theory and provided as constructor arguments. The compiler was designed modularly to be easily extendible with other backends, e.g., to produce C-code for specific embedded platforms.</p>

    <p class="text-gray-300">Next, we describe the semantics of the input language using a practical running example. We discuss two more practical examples to demonstrate the broad applicability of our compiler in §4. The complete EBNF specifying the syntax of the input language formally is given in Appendix B.</p>

    <p class="text-gray-300">3.1 Overview</p>

    <p class="text-gray-300">As running example we show how our compiler can be used to automatically generate protocols to prove relations between plaintexts encrypted with the Damgård-Jurik crypto system <em>[x10]</em>. The running example proves that ciphertext <span class="math">x_{a}</span> is either an encryption of <span class="math">0</span> or <span class="math">1</span> and that prover knows the plaintext of ciphertexts <span class="math">x_{b}</span> and <span class="math">x_{c}</span> being encryptions of the same message <span class="math">\\mu</span>, i.e.,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ZPK}\\bigg{[}(\\mu,(\\rho_{i})_{i=1}^{4}):(x_{a}=E(0,\\rho_{1})\\vee x_{a}=E(1,\\rho_{2}))\\wedge x_{b}=E(\\mu,\\rho_{3})\\wedge x_{c}=E(\\mu,\\rho_{4})\\bigg{]}.</span></p>

    <p class="text-gray-300">with <span class="math">E(.,.)</span> denoting the encryption function and <span class="math">\\rho_{i}</span> randomization parameters.</p>

    <p class="text-gray-300">⬇ // Declarations Group Zn, Zm<em>; GroupElement g,x_a,x_b,x_c,rho_[0..3],mu; Homomorphism phi_[0..3]; IntegerConstant n; // Assignments AssignGroupMember(Zn, mu); AssignGroupMember(Zm</em>,{g,x_a,x_b,x_c,rho_[0..3]}); // Definitions</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DefineHomomorphism(phi_0, (rho_0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-> (rho_0^n));</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DefineHomomorphism(phi_2, (mu,rho_2)</td>

            <td class="px-3 py-2 border-b border-gray-700">-> (g^mu * rho_2^n));</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DefineHomomorphism(phi_3, (mu,rho_3)</td>

            <td class="px-3 py-2 border-b border-gray-700">-> (g^mu * rho_3^n));</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">// Protocol Specification SpecifyProtocol [</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Relation = ([(x_a)=phi_0(rho_0)]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[(x_a*g^(-1))=phi_1(rho_1)])</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">&& ([(x_b)=phi_2(mu,rho_2)] && [(x_c)=phi_3(mu,rho_3)]); Target = LATEX; Layout = COMPACT; ]</p>

    <p class="text-gray-300">The LaTeX output generated by our compiler is given in Appendix C.</p>

    <p class="text-gray-300">As in the example, all input files are composed of four parts for <em>Declarations</em> (cf. § 3.2), <em>Assignments</em> (cf. §3.3), <em>Definitions</em> (cf. §3.4), and <em>Protocol Specification</em> (cf. §3.5) in the given order that are described in the following sections.</p>

    <p class="text-gray-300"><em>Line comments</em> starting with // can be inserted at any place, <em>statements</em> are terminated with ‘;’, and <em>arrays</em> are used as shortcut, e.g., rho_[0..3] is equivalent to rho_0,rho_1,rho_2,rho_3.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">3.2 Declarations</h3>

    <p class="text-gray-300">Each variable must be declared as Group, GroupElement, Homomorphism, or IntegerConstant before usage. The order of declarations is arbitrary. For convenience, multiple variables separated with ‘,’ can be declared in the same line.</p>

    <p class="text-gray-300">Most relevant groups are already pre-defined in the compiler while abstraction allows users to add arbitrary groups.</p>

    <p class="text-gray-300">Pre-defined finite additive (<span class="math">\\mathbb{Z}_{m}</span>) resp. multiplicative (<span class="math">\\mathbb{Z}_{m}^{<em>}</span>) groups modulo <span class="math">m</span> are defined as uppercase Z followed by a letter for the modulus and an optional </em> to indicate the multiplicative group, i.e., Group Zn; declares group (<span class="math">\\mathbb{Z}_{n},+</span>) resp. Group Zm<em>; declares group (<span class="math">\\mathbb{Z}_{m}^{</em>},*)</span>. In the implementation, the corresponding modulus is given as constructor parameter, e.g., <span class="math">m</span> would be set to <span class="math">n^{2}</span> in the running example when used for Paillier crypto system.</p>

    <p class="text-gray-300">Alternatively, abstract groups like Group (G,+) or Group(H,<em>) can be declared for which an abstract class is generated that allows easy integration of arbitrary groups like elliptic curve groups. The first parameter is the name of the group whereas second parameter denotes whether the group is written additively (+) or multiplicatively (</em>).</p>

    <p class="text-gray-300">Other declarations have the structure <type> <variablename>;, where <type> is either GroupElement, Homomorphism, or IntegerConstant and <variablename> has to start with a letter followed by letters, numbers or underscores (_).</p>

    <p class="text-gray-300">The pre-defined parameter names shown in Table 1 in the appendix are reserved for code generation and hence can not be used as variable names. Alternatively, pre-defined parameter names can be changed in the ParameterNames section described later.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">3.3 Assignments</h3>

    <p class="text-gray-300">In this section of the input file, each group element must be assigned to one group declared before. Single group elements can be assigned with AssignGroupMember(Zn,mu);. Multiple group elements are grouped in braces like AssignGroupMember(Zm*,{g,x_a,...}); in the running example.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">3.4 Definitions</h3>

    <p class="text-gray-300">Homomorphisms can be defined either concrete or abstract. They must already have been declared before.</p>

    <p class="text-gray-300">Concrete definition maps elements explicitly from domain to co-domain, e.g.,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DefineHomomorphism(phi_2, (mu,rho_2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-> (g^mu*rho_2^n));</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for homomorphism <span class="math">\\phi_{2}:(\\mu,\\rho_{2})\\mapsto g^{\\mu}\\cdot\\rho_{2}{}^{n}</span> in the running example.</p>

    <p class="text-gray-300">The mapping can consist of group elements (i.e., <span class="math">g</span>) and integer constants (i.e., <span class="math">n</span>) defined before as well as integer numbers (i.e., 1 in the definition of <span class="math">\\phi_{1}</span>). It must be semantically correct, e.g., only combines group elements of the same group with its group operation. For concrete homomorphisms a class is generated that implements the homomorphism using the corresponding group operations.</p>

    <p class="text-gray-300">Alternatively, abstract definition, e.g., DefineHomomorphism(phi, G_1 # G_2 -> H_1 # H_2);, specifies only the domain <span class="math">(G_{1}\\times G_{2})</span> and the co-domain <span class="math">(H_{1}\\times H_{2})</span> of the homomorphism <span class="math">\\phi:G_{1}\\times G_{2}\\rightarrow H_{1}\\times H_{2}</span>. An interface is generated that can be instantiated with a corresponding implementation of an arbitrary complex homomorphism.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">3.5 Protocol Specification</h3>

    <p class="text-gray-300">The protocol specification is encapsulated in a block SpecifyProtocol [ ...] and contains the specification of the protocol in the order given in this section. Relation and Target must be specified whereas Constraints, ParameterNames and Layout are optional.</p>

    <p class="text-gray-300">Relation (cf. §2.2). Group elements must be related to homomorphisms together with an optional access structure. The relation can be given either in boolean or enumerative description as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Boolean description is close to Camenisch-Stadler notation <em>[x10]</em>, e.g., the relation in the running example directly corresponds to <span class="math">(x_{a}=\\phi_{0}(\\rho_{0})\\vee x_{a}/g=\\phi_{1}(\\rho_{1}))\\wedge x_{b}=\\phi_{2}(\\mu,\\rho_{2})\\wedge x_{c}=\\phi_{3}(\\mu,\\rho_{3})</span>. It consists of literals encapsulated in [...] that relate preimages via homomorphisms to images. The access structure is specified as monotone boolean operators AND (&) resp. OR (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) between the literals and is compiled into AND- resp. OR-proofs. Additionally, arithmetic expressions, i.e., semantically correct expressions (cf. previous section) on publicly known values (images, integer constants and integers), can be defined on the left-hand side of the literals, e.g., [(x_a^(5*n))=phi_0(rho_3)].</variablename></type></type></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Alternatively, enumerative description allows more detailed specification of the access structure. The relation of the running example is equivalent to</p>

    <p class="text-gray-300">⬇ Relation [ CommonInput = {(phi_0,(x_a)),(phi_1,(x_a*g^(-1))),(phi_2,(x_b)),(phi_3,(x_c))}; PreimageInput = {(rho_0),(rho_1),(mu,rho_2),(mu,rho_3)}; AccessStructure = {{phi_0,phi_2,phi_3},{phi_1,phi_2,phi_3}}; ]</p>

    <p class="text-gray-300">in enumerative description. The common input and the preimage input are both ordered lists of tuples that correspond to each other in number and position. Each tuple of the common input consists of the name of the homomorphism (e.g., phi_i)) followed by the list of its publicly known images (e.g., (x_i)). Each tuple of the preimage input is the list of private preimages (e.g., (rho_0), (rho_1), (mu,rho_2), resp. (mu,rho_3)) of the homomorphism defined in the same position of the common input. Hence, the first position of the example above specifies that <span class="math">x_{a}=\\phi_{0}(\\rho_{0})</span>. The access structure is given as a set of qualified sets that describes its disjunctive normal form (DNF). If an honest prover knows all preimages of one qualified set, e.g., the preimages of <span class="math">\\phi_{0}</span>, <span class="math">\\phi_{2}</span> and <span class="math">\\phi_{3}</span> or those of <span class="math">\\phi_{1}</span>, <span class="math">\\phi_{2}</span> and <span class="math">\\phi_{3}</span> in the example, the honest verifier will accept the proof. The compiler automatically generates a combination of AND and OR-proofs corresponding to the DNF of the specified access structure.</p>

    <p class="text-gray-300">If the access structure is not specified, an abstract class is generated to allow arbitrary implementation of monotone access structures. We have implemented a threshold access structure based on Shamir’s Secret Sharing <em>[x24]</em> to efficiently prove knowledge of <span class="math">k</span> out-of <span class="math">n</span> preimages <em>[x1]</em>.</p>

    <p class="text-gray-300">Constraints (cf. §2.3). Homogenous linear relations between preimages can be expressed as constraints, e.g., Constraints = (w_1=3<em>w_2+w_3)&&(w_4=-w_1)&&(w_5=w_6);. For multiplicatively written groups with group operation </em> the first constraint would be written as (w_1=w_2^3*w_3), the second as w_4=w_1^(-1).</p>

    <p class="text-gray-300">All preimages in one constraint must belong to the same group and the left hand side must always be a single variable. Multiple constraints can be connected with && and are valid globally for all homomorphisms that depend on the corresponding preimages.</p>

    <p class="text-gray-300">If linear combinations of the same preimages are re-used in multiple homomorphisms, e.g., m in the running example, they are automatically converted into an explicit constraint, i.e., the input in the running example is internally changed to:</p>

    <p class="text-gray-300">⬇ Relation =...&&([(x_b)=phi_2(mu_phi_2,rho_2)]&&[(x_c)=phi_3(mu_phi_3,rho_3)]); Constraints = (mu_phi_2=mu_phi_3);.</p>

    <p class="text-gray-300">The order of constraints is important in order to avoid cyclic dependencies. If a preimage is assigned on the left hand side of a constraint it must only be used on the right hand side of later constraints only (in left-to-right order). E.g. the order in Constraints = (omega_1=omega_2) && (omega_3=omega_1); is correct while swapping the two constraints would be invalid. For simplicity, the compiler assigns the variables from left to right so each variable has to be assigned before its value is used in a later assignment. Naturally, cyclic assignments like (omega_1=omega_2) && (omega_2=omega_1) are impossible with this notation. Future versions of the compiler might find a correct ordering of assignments automatically but still detect cyclic assignments.</p>

    <p class="text-gray-300">ParameterNames. Pre-defined parameter names can be changed from their default name given in Table 1 in the appendix to avoid conflicts with user-defined variable names like</p>

    <p class="text-gray-300">ParameterNames{VarRandom=u; VarChallenge=z;}.</p>

    <p class="text-gray-300">Target. The back-end of the compiler used for output generation can be specified as target. Target = JAVA; generates JAVA source code for prover and verifier that can be compiled into runnable code, Target = LATEX; a human-readable summary of the protocol in LaTeX.</p>

    <p class="text-gray-300">Layout. The layout of the LaTeX output (Target = LATEX;) is set to compact mode by specifying Layout = COMPACT; or verbose mode if Layout is omitted. Compact mode puts together multiple homomorphisms to visualize the protocol specification in a more compact way.</p>

    <h2 id="sec-21" class="text-2xl font-bold">4 Examples</h2>

    <p class="text-gray-300">We describe two real-world applications demonstrating the broad applicability of our compiler in practice. For lack of space, only the input specifications are given here while the corresponding LaTeX outputs generated by the compiler can be found in the appendix.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">4.1 Group Signature Scheme</h3>

    <p class="text-gray-300">A group signature scheme allows members of a group to sign messages s.t. the signature does not reveal their identity. Only a designated group manager is able to identify the group member who issued a given signature. Camenisch and Lysyanskaya <em>[x1]</em> propose an efficient group signature scheme that extends the approach of <em>[x2]</em> to known order groups of prime order <span class="math">q</span> with bilinear maps. The example demonstrates how our compiler can be used to automatically generate the <span class="math">\\Sigma</span>-protocol underlying their signature proof of knowledge</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SPK}\\bigg{[}(\\mu,\\rho,\\nu):v_{s}^{\\rho}=v_{x}v_{xy}^{\\mu}\\wedge c_{1}=g^{\\nu}\\wedge c_{2}=h^{\\nu}\\wedge c_{3}=y_{1}^{\\nu}g^{\\mu}\\wedge c_{4}=(y_{2}y_{3}^{H})^{\\nu}\\bigg{]}(m)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $H:=\\mathcal{H}(c_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{3})<span class="math">. The first clause proving knowledge of a CL signature <em>[x2]</em> is rewritten as </span>v_{x}=v_{s}^{\\rho}v_{xy}^{-\\mu}$ in the protocol specification. The generated LaTeX output is given in Appendix D.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">⬇ // Declarations Group Zq, (G,*); GroupElement g,h,mu,rho,nu,v_x,v_s,v_xy,H,y_[1..3],c_[1..4]; Homomorphism phi_[0..4];</p>

    <p class="text-gray-300">// Assignments AssignGroupMember(Zq, {mu,rho,nu,H}); AssignGroupMember(G, {g,h,v_x,v_s,v_xy,y_[1..3],c_[1..4]});</p>

    <p class="text-gray-300">// Definitions</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DefineHomomorphism(phi_0, (rho,mu)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-> (v_s^rho <em> v_xy^(-1</em>mu)));</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DefineHomomorphism(phi_2, (nu)</td>

            <td class="px-3 py-2 border-b border-gray-700">-> (h^nu));</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DefineHomomorphism(phi_3, (nu,mu)</td>

            <td class="px-3 py-2 border-b border-gray-700">-> (y_1^nu * g^mu));</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DefineHomomorphism(phi_4, (nu)</td>

            <td class="px-3 py-2 border-b border-gray-700">-> ((y_2*y_3^H)^nu));</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">// Protocol Specification SpecifyProtocol [ Relation = [(v_x) = phi_0(rho,mu)] && [(c_1) = phi_1(nu)] && [(c_2) = phi_2(nu)] && [(c_3) = phi_3(nu,mu)] && [(c_4) = phi_4(nu)]; Target = LATEX; ]</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">4.2 Ring Signature Scheme</h3>

    <p class="text-gray-300">The second example demonstrates automatic generation of the proofs from a basic ring signature scheme <em>[x3]</em> based on a Schnorr signature <em>[x10]</em>. Ring signatures are group signatures without a group manager who can unveil the identity of the issuer of a ring signature. A ring signature can</p>

    <p class="text-gray-300">be issued by proving knowledge of one secret key <span class="math">w_{j}</span> of the <span class="math">n</span> public keys <span class="math">x_{1},\\ldots,x_{n}</span> associated to the members of the group with the following signature proof of knowledge</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SPK}\\bigg{[}(w_{1},\\ldots,w_{n}):x_{1}=g^{w_{1}}\\vee\\cdots\\vee x_{n}=g^{w_{n}}\\bigg{]}(m).</span></p>

    <p class="text-gray-300">The example generates the underlying <span class="math">\\Sigma</span>-protocol for <span class="math">n=3</span> members.</p>

    <p class="text-gray-300">⬇ // Declarations Group Zq, Zp<em>; GroupElement g,x_[1..3],w_[1..3]; Homomorphism phi_[1..3]; // Assignments AssignGroupMember(Zq, {w_[1..3]}); AssignGroupMember(Zp</em>, {g,x_[1..3]}); // Definitions</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DefineHomomorphism(phi_1, (w_1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-> (g^w_1));</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DefineHomomorphism(phi_3, (w_3)</td>

            <td class="px-3 py-2 border-b border-gray-700">-> (g^w_3));</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">// Protocol Specification SpecifyProtocol [ Relation [ CommonInput = {(phi_1,(x_1)), (phi_2,(x_2)), (phi_3,(x_3))}; PreimageInput = {(w_1),(w_2),(w_3)}; AccessStructure = {{phi_1},{phi_2},{phi_3}}; ] Target = LATEX; Layout = COMPACT; ]</p>

    <p class="text-gray-300">AccessStructure allows specification of an arbitrary access structure of signers who are qualified to sign on the group’s behalf. If AccessStructure is omitted it is generated as abstract class. Instantiation with the implemented threshold access structure yields a ring signature scheme where valid signatures can be issued by cooperation of at least <span class="math">k</span> of the <span class="math">n</span> members of the group <em>[x1]</em>.</p>

    <p class="text-gray-300">The generated LaTeX output is given in Appendix E.</p>

    <h2 id="sec-24" class="text-2xl font-bold">5 Extension to Hidden Order Groups</h2>

    <p class="text-gray-300">The <span class="math">\\Sigma^{\\phi}</span>-protocol as defined in §2 can only be used efficiently if the underlying homomorphism is special. To overcome this limitation, we introduce a novel protocol (the <span class="math">\\Sigma^{exp}</span>-protocol) in §5.1, which yields efficient proofs of knowledge for exponentiation homomorphisms in hidden order groups. The <span class="math">\\Sigma^{exp}</span>-protocol extends ideas of the Damgård-Fujisaki proof scheme <em>[x10]</em> and overcomes several limitations of it. In §5.2 and §5.3 we show how the framework given in §2 can be extended to cover the <span class="math">\\Sigma^{exp}</span>-protocol as well, and we show how to combine the techniques for <span class="math">\\Sigma^{\\phi}</span>- and <span class="math">\\Sigma^{exp}</span>-protocols.</p>

    <p class="text-gray-300">The <span class="math">\\Sigma^{exp}</span>-protocol is not yet implemented in the compiler described in §3 and §4, but the implementation will take place in near future. We present the <span class="math">\\Sigma^{exp}</span>-protocol here and extend the general framework of §2 to hidden order groups, which we think is of independent interest.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">5.1 An efficient protocol for exponentiation homomorphisms in hidden order groups</h3>

    <p class="text-gray-300">We first note that the <span class="math">\\Sigma^{\\phi}</span>-protocol is only defined for homomorphisms with a finite domain. It is thus not applicable for exponentiation homomorphisms <span class="math">\\phi_{E}=g_{1}^{w_{1}}\\ldots g_{l}^{w_{l}}</span> in hidden order groups (e.g.,</p>

    <p class="text-gray-300">when <span class="math">g_{1},\\ldots,g_{l}</span> are elements of an RSA group); these are mappings of the form <span class="math">\\phi_{E}:\\mathbb{Z}^{l}\\to\\mathcal{H}</span>, having an infinite domain. In this case, the soundness property is not satisfied any more. Yet this is only a technical issue, since the <span class="math">\\Sigma^{\\phi}</span>-protocol can be easily modified to also work for exponentiations in hidden order groups, e.g. <em>[x1]</em>. The more fundamental problem is that the resulting <span class="math">\\Sigma</span>-protocol is only known to be a proof of knowledge when the challenge set is chosen to be <span class="math">\\mathcal{C}=\\{0,1\\}</span>. The resulting proofs are thus not sufficiently efficient for most practical applications.</p>

    <p class="text-gray-300">There are ways around this problem. Bangerter et al <em>[x2]</em> discuss protocols and techniques which allow to obtain efficient proofs for homomorphisms in hidden order groups. Yet, the soundness of these techniques relies on rather strong assumptions (i.e., the random oracle model) and most of all are not based on the <span class="math">\\Sigma</span>-protocol and thus do not fit into our framework. The most widely used technique is the Damgård-Fujisaki (DF) scheme <em>[x10]</em>. It allows to demonstrate knowledge of a commitment in RSA groups (and other hidden order groups) using a <span class="math">\\Sigma</span>-protocol. On a high level, the scheme consits of a setup protocol where prover and verifier jointly generate a commitment function. Then, once the prover has committed to some value, he uses a <span class="math">\\Sigma</span>-protocol to demonstrate knowledge of that value to the verifier. The commitment being used is the exponentiation homomorphism <span class="math">\\phi_{E}=g_{1}^{w_{1}}g_{2}^{w_{2}}</span>. However, the DF scheme can be extended to work for multi-exponentiation with more than two base elements.</p>

    <p class="text-gray-300">It is important to note that the DF scheme, as the authors state explicitly, is <em>not</em> a proof of knowledge, but loosely speaking something weaker. That is the <span class="math">\\Sigma</span>-protocol used in the DF scheme only demonstrates knowledge for homomorphisms which were priorly generated in the setup phase. Since the setup protocol is rather inefficient, using the DF scheme is only suitable when setup costs can be neglected. In practice, when the DF scheme is used as a sub-protocol of some higher-level application, this is typically the case when the setup protocol is run during system initialization, but not while the system is in interactive use. This in turn means that <em>all</em> homomorphisms for which the DF scheme is to be applied to, need to be known a priori at initialization time.</p>

    <p class="text-gray-300">To overcome these restrictions we present a novel protocol, called <span class="math">\\Sigma^{exp}</span> which allows to obtain efficient statistical HVZK proofs of knowledge in the auxiliary string model. It works for any exponentiation homomorphism <span class="math">\\phi_{E}=g_{1}^{w_{1}}\\ldots g_{l}^{w_{l}}</span>, in particular in hidden order groups, in the case that the order of <span class="math">\\operatorname{Im}\\phi_{E}</span> does not contain small prime factors. The protocol extends ideas found in the DF scheme. That is, the soundness of our protocol also relies on the strong RSA assumption and our protocol requires a setup phase similar to the DF scheme. Compared to the DF scheme it has two main advantages. First, the setup protocol only needs to be run once and for all and then our scheme can be used as an efficient proof of knowledge for <em>arbitrary</em> exponentiation homomorphisms (that do not contain more than an arbitrary but fixed number of base elements). Second, our protocol is a proof of knowledge in the auxiliary string model. Technically, this is a simpler and easier to grasp definitional setting than the rather contrived one underlying the DF scheme. This can potentially lead to a simpler and more modular security analysis of applications relying on our protocol. Loosely speaking, our scheme is more flexible than the DF scheme and works for a larger class of exponentiation homomorphisms, and thus it is more appropriate for the theoretical framework underlying our compiler, and probably also for other practical applications as well.</p>

    <p class="text-gray-300">The idea underlying the <span class="math">\\Sigma^{exp}</span>-protocol is as follows: in the setup phase, we generate a DF commitment function <span class="math">\\vartheta</span> and then pass it on as auxiliary input to the <span class="math">\\Sigma^{exp}</span>. In the protocol we let the prover commit to the preimage of the homomorphisms <span class="math">\\phi_{E}</span> whose knowledge he wants to prove. Then we run a variant of the <span class="math">\\Sigma</span>-protocol which proves that the committed values are equal to the</p>

    <p class="text-gray-300">preimage of <span class="math">\\phi_E</span>. The soundness of the scheme then essentially follows from the soundness of the DF scheme.</p>

    <p class="text-gray-300">Let us first describe how to generate the auxiliary <span class="math">\\vartheta</span>-function. By <span class="math">m</span> we denote an arbitrary but fixed positive integer. Now, one chooses a safe prime modulus <span class="math">n</span> (i.e., <span class="math">n = (2p + 1)(2q + 1)</span>, where <span class="math">p, q, (2p + 1)</span>, and <span class="math">(2q + 1)</span> are primes) and generator <span class="math">g</span> of the sub-group of quadratic residues of <span class="math">\\mathbb{Z}_n^*</span>. Finally, choose uniform random elements <span class="math">g_1, \\ldots, g_m</span> from <span class="math">\\langle g \\rangle</span>, and define <span class="math">\\vartheta(x_1, \\ldots, x_{m+1}) = g_1^{x_1} \\cdots g_m^{x_m} \\cdot g^{x_{m+1}}</span>.</p>

    <p class="text-gray-300">Given an exponentiation homomorphism <span class="math">\\phi_E: \\mathbb{Z}^l \\to H</span> let <span class="math">\\mathcal{G}</span> denote an arbitrary finite subset of <span class="math">\\mathbb{Z}^l</span>, which is defined by the integer parameters <span class="math">T_1, \\ldots, T_l</span> as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{G} := \\{-T_1, \\dots, T_1\\} \\times \\cdots \\times \\{-T_l, \\dots, T_l\\}. \\tag{5}</span></div>

    <p class="text-gray-300">The <span class="math">T_i</span> can be chosen arbitrarily large and are only needed to control the size of the prover's random choices to ensure that the protocol is statistically HVZK, if <span class="math">-T_i \\leq w_i \\leq T_i</span> holds for all <span class="math">i = 1, \\ldots, l</span>.</p>

    <p class="text-gray-300">Using an additional security parameter <span class="math">k_s &amp;gt; 0</span>, we associate the following set with <span class="math">\\mathcal{G}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{G}&#x27; := \\{-2^{k_s} c^+ T_1, \\dots, 2^{k_s} c^+ T_1\\} \\times \\cdots \\times \\{-2^{k_s} c^+ T_l, \\dots, 2^{k_s} c^+ T_l\\}. \\tag{6}</span></div>

    <p class="text-gray-300">We note that the security parameter <span class="math">k_s</span> controls the tightness of statistical HVZK property of the <span class="math">\\Sigma^{exp}</span>-protocol which we define next.</p>

    <p class="text-gray-300"><strong>Definition 4 (Σ^{exp}-protocol).</strong> Let be given an exponentiation homomorphism <span class="math">\\phi_E: \\mathbb{Z}^l \\to \\mathcal{H}</span>, <span class="math">x = \\phi_E(w)</span>, and <span class="math">\\vartheta(z_1, \\ldots, z_{m+1}) = g_1^{z_1} \\cdots g_l^{z_l} \\cdot g^{z_{l+1}}</span> which is generated as described above. A Σ^{exp}-protocol with challenge set <span class="math">\\mathcal{C} = \\{0, \\ldots, c^+\\}</span> consists of <span class="math">(\\mathsf{P}, \\mathsf{V})</span> performing the joint computation described in Figure 1.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. Description of the Σ^{exp}-protocol</p>

    <p class="text-gray-300">Now, the following holds:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Theorem 3.</strong> Under the strong RSA assumption, the Σ^{exp}-protocol with challenge set <span class="math">\\mathcal{C} = \\{0, \\ldots, c^+\\}</span> is a statistical special HVZK computational proof of knowledge in the auxiliary string model for any exponentiation homomorphism <span class="math">\\phi_E</span>, if <span class="math">c^+</span> is smaller than the smallest prime dividing the order of <span class="math">\\operatorname{Im} \\phi_E</span>. The knowledge error is $1 / \\# \\mathcal{C} + 1 / p(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, where </span>p()$ is an arbitrary but fixed polynomial. Especially, the Σ^{exp}-protocol is a Σ-protocol according to Definition 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For a proof of the theorem we refer to Appendix A.2. Finally, let us sketch how to choose the auxiliary <span class="math">\\vartheta</span>-function in practice. Most importantly, we observe that one can choose <span class="math">\\vartheta</span> once and then use the <span class="math">\\Sigma^{exp}</span>-protocol for any exponentiation homomorphism using the same <span class="math">\\vartheta</span>. There are essentially three possible ways to choose <span class="math">\\vartheta</span>. One is to use the setup protocol of the DF scheme. That is, the verifier chooses <span class="math">\\vartheta</span> as outlined above and sends it to the prover. Then it uses a rather inefficient variant of the <span class="math">\\Sigma</span> - protocol with binary challenges to prove that <span class="math">g_{1},\\ldots,g_{l}\\in\\langle g\\rangle</span>. This prove is necessary to assert that <span class="math">\\vartheta</span> is a hiding commitment function and thus essential for the zero-knowledge property of our protocol. In a real world implementation using the <span class="math">\\Sigma^{exp}</span>-protocol one would rather either hardcode <span class="math">\\vartheta</span> into the system (like other system parameters) or let a trusted third party publish <span class="math">\\vartheta</span> along with a certificate vouching that it was generated correctly.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">5.2 Boolean Composition of <span class="math">\\Sigma^{exp}</span>-protocols</h3>

    <p class="text-gray-300">Analogously to §2.2 we show how <span class="math">\\Sigma^{exp}</span>-protocols can be combined by boolean operators, cf. (1) and (2).</p>

    <p class="text-gray-300">AND-proofs. We want to briefly discuss the AND-composition of two <span class="math">\\Sigma^{exp}</span>-protocols. Let be given <span class="math">x_{1}=\\phi_{E_{1}}(w_{1})=h_{11}^{w_{11}}\\cdots h_{1l_{1}}^{w_{1l_{1}}}</span> and <span class="math">x_{2}=\\phi_{E_{2}}(w_{2})=h_{21}^{w_{21}}\\cdots h_{2l_{2}}^{w_{2l_{2}}}</span>. For a direct protocol composition, one would now run the setup phase twice to obtain <span class="math">\\vartheta_{l_{1}+1}</span> and <span class="math">\\vartheta_{l_{2}+1}</span>. In the following we show how this can be optimized to avoid unneeded overhead.</p>

    <p class="text-gray-300">By <span class="math">\\mathcal{G}_{i}</span> and <span class="math">\\mathcal{G}_{i}^{\\prime}</span> we denote the sets described in (5) resp. (6) for <span class="math">\\phi_{E_{1}}</span> and <span class="math">\\phi_{E_{2}}</span>. Note that elements in <span class="math">G_{1}</span> and <span class="math">G_{1}^{\\prime}</span> have <span class="math">l_{1}</span> components, whereas those in <span class="math">G_{2}</span> and <span class="math">G_{2}^{\\prime}</span> have <span class="math">l_{2}</span>. As auxiliary input let be given <span class="math">\\vartheta_{l+1}</span>, with <span class="math">l:=l_{1}+l_{2}</span>. In contrast to a parallel execution of the protocols, the prover commits to all his random choices (and preimages, resp.) at once, instead of computing a commitment for the random choices (resp., preimages) of each <span class="math">\\phi_{E_{i}}</span>. More precisely, the protocol looks like this:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In <span class="math">\\mathsf{P}_{1}</span>, the prover draws random choices <span class="math">\\mathsf{r}\\in_{R}\\{-2^{2k_{s}}c^{+}n,2^{2k_{s}}c^{+}n\\}</span> and <span class="math">\\mathsf{w}\\in_{R}\\{0,2^{k_{s}}n\\}</span>, as well as <span class="math">r_{i}\\in_{R}\\mathcal{G}_{i}^{\\prime}</span> for <span class="math">i=1,2</span>. Then he commits to <span class="math">r_{1},r_{2}</span> as usual by <span class="math">t_{i}:=\\phi_{E_{i}}(r_{i})</span>.</li>

    </ul>

    <p class="text-gray-300">Now, in contrast to a parallel execution, he commits to <span class="math">(w_{1},w_{2})</span> simultaneously, blinding it using <span class="math">\\mathsf{w}</span>, by <span class="math">\\mathsf{x}:=\\vartheta_{l+1}(w_{1},w_{2},\\mathsf{w})</span>. Analogously, he computes <span class="math">\\mathsf{t}:=\\vartheta_{l+1}(r_{1},r_{2},\\mathsf{r})</span>. The tuple <span class="math">(\\mathsf{x},(t_{1},t_{2}),\\mathsf{t})</span> is sent to the verifier.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The remaining steps now are a straightforward adaption of the protocol in Figure 1: having received the challenge <span class="math">c</span>, in <span class="math">\\mathsf{P}_{2}</span> the prover computes responses <span class="math">s_{1}:=r_{1}+cw_{1}</span> and <span class="math">s_{2}:=r_{2}+cw_{2}</span>. He sets <span class="math">\\mathsf{s}:=\\mathsf{r}+\\mathsf{cw}</span> and sends <span class="math">((s_{1},s_{2}),\\mathsf{s})</span> to the verifier, who checks that <span class="math">\\phi_{E_{i}}(s_{i})=t_{i}x_{i}^{c}</span> for <span class="math">i=1,2</span>, and that <span class="math">\\vartheta_{l+1}(s_{1},s_{2},\\mathsf{s})=\\mathsf{tx}^{c}</span>.</li>

    </ul>

    <h6 id="sec-27" class="text-base font-medium mt-4">Lemma 2</h6>

    <p class="text-gray-300">If <span class="math">c^{+}</span> is smaller than the smallest prime dividing <span class="math">\\mathrm{ord}(\\mathrm{Im}\\ \\phi_{E_{1}})</span> or <span class="math">\\mathrm{ord}(\\mathrm{Im}\\ \\phi_{E_{2}})</span>, the above composition yields a computational proof of knowledge (in the auxiliary string model) of the preimages of <span class="math">x_{1},x_{2}</span> under <span class="math">\\phi_{E_{1}}</span> resp. <span class="math">\\phi_{E_{2}}</span>, that satisfies statistical special HVZK property.</p>

    <p class="text-gray-300">The proof is a direct adaption of the proof of Theorem 3 and hence omitted.</p>

    <p class="text-gray-300">If an expression like (1) contains special homomorphisms as well as exponentiation homomorphisms in hidden order groups, the AND-composition is done for the occurring homomorphisms of each class separately, and then the resulting <span class="math">\\Sigma</span>-protocols are run in parallel using the same challenge <span class="math">c</span>. The following result then follows from Lemma 1 and Lemma 2:</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Theorem 4</h6>

    <p class="text-gray-300">Let <span class="math">c^{+}\\in\\mathbb{Z}</span> be smaller than the smallest prime dividing one special exponent of <span class="math">\\phi_{1},\\ldots,\\phi_{m_{1}}</span> or one of the orders of <span class="math">\\mathrm{Im}\\ \\phi_{m_{1}+1},\\ldots,\\mathrm{Im}\\ \\phi_{m}</span>. Then applying the described composition techniques and running the resulting protocols in parallel yields a statistical HVZK, computational</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">proof of knowledge (in the auxiliary string model) with challenge set <span class="math">\\mathcal{C}:=\\{0,\\ldots,c^{+}\\}</span> and knowledge-error $\\kappa=1/\\#\\mathcal{C}+1/p(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, where </span>p()$ is an arbitrary but fixed polynomial.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proofs of expressions containing ORs. For proofs of expressions containing ORs, the corresponding technique given in §2.2 can be applied without changes: for the results of <em>[x10]</em> there has to be a HVZK proof of knowledge in form of a <span class="math">\\Sigma</span>-protocol for each predicate in an expression like (2). This is the case here, if one chooses the <span class="math">\\Sigma^{\\phi}</span>-protocol for all special homomorphisms, and the <span class="math">\\Sigma^{exp}</span>-protocol for all exponentiation homomorphisms in hidden order groups. A computational, statistical HVZK, proof of knowledge in the auxiliary string model is obtained, if <span class="math">c^{+}</span> is chosen as, e.g., in Theorem 4.</p>

    <p class="text-gray-300">We are aware that the performance of the output of our compiler can be enhanced by skillfully applying AND-compositions before using this technique. We will consider this in future versions.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">5.3 Relations among preimages</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Essentially the same technique as described in detail in §2.3 also works for linear constraints among the preimages of exponentiation homomorphisms in the <span class="math">\\Sigma^{exp}</span>-protocol. Again the idea is to perform an AND-composition within each AND-term in an expression like (4), but to restrict the sets for the random choices. A small technical issue arises because the sets for random choices are no groups any more, see (6). Hence, in the example given at the beginning of this section, it could happen that <span class="math">br_{1}</span> is not in this set any more. Yet, this problem is easy to overcome: one only has to check that for each component <span class="math">w_{i}</span> the parameter <span class="math">T_{i}</span> is chosen large enough, what can be done very fast because of the form of <span class="math">A_{S}</span>. In the given example this means that $T_{2}\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{1}<span class="math">, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the absolute value of </span>b$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If in (4) special homomorphisms appear as well as exponentiation homomorphisms, the constructions are run separately for them.</p>

    <h2 id="sec-30" class="text-2xl font-bold">6 Conclusion and Future Work</h2>

    <p class="text-gray-300">We have presented a compiler that given a high-level ZK-PoK protocol specification automatically generates a sound implementation of the corresponding <span class="math">\\Sigma</span>-protocol. The initial version of the compiler can already be used for many practical applications as given in the introduction, but is currently restricted to automatic generation of proofs for special homomorphisms, i.e., the framework given in §2. Future work will contain the <span class="math">\\Sigma^{exp}</span>-protocol together with the theory explained in §5 and protocols as suggested in <em>[x13, x12]</em> to allow proofs in unknown order groups as well, which in turn will enable to generate more efficient proofs for complex statements like efficient interval proofs.</p>

    <p class="text-gray-300">In order to increase the flexibility of the existing tool, predefined and user-written macros will be supported, which are translated into the input language by a precompiler. Such macros could for example simplify the realization of complex algebraic relations among the preimages. Additionally to <span class="math">\\mathbb{Z}_{n}</span> and <span class="math">\\mathbb{Z}_{n}^{*}</span>, other commonly used groups such as groups over elliptic curves and homomorphisms like multiexponentiation homomorphisms could be predefined.</p>

    <p class="text-gray-300">In the theoretical framework in §2 we give conditions under which the output protocol is a HVZK proof of knowledge. Those can easily be checked manually for special homomorphisms, which are currently implemented in the compiler. Yet, this issue becomes more challenging when the input language of the compiler gets more comprehensive. Thus it is preferable that incorrect inputs (that would result in unsound protocols) are spotlighted automatically. For this reason, an automated formal verification of the output will be implemented.</p>

    <p class="text-gray-300">Last, transformations of the generated <span class="math">\\Sigma</span>-protocols to signature schemes <em>[x10]</em> or concurrent zero-knowledge <em>[x14]</em> that are also secure against malicious verifiers could be automated easily.</p>

    <p class="text-gray-300">Acknowledgements. The authors would like to thank Thomas Briner who wrote the initial version of the compiler as well as Wilko Henecka who extended the compiler substantially for their support.</p>

    <h2 id="sec-31" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ARS05] A. Adelsbach, M. Rohe, and A.-R. Sadeghi. Complementing zero-knowledge watermark detection: Proving properties of embedded information without revealing it. Multimedia Systems, 11(2):143–158, 2005.</li>

      <li>[Ban05] E. Bangerter. Efficient Zero-Knowledge Proofs of Knowledge for Homomorphisms. PhD thesis, Ruhr-University Bochum, 2005.</li>

      <li>[BCC04] E. Brickell, J. Camenisch, and L. Chen. Direct anonymous attestation. In Proc. ACM CCS 2004, pages 132–145. ACM, 2004.</li>

      <li>[BCM05] E. Bangerter, J. Camenisch, and U. Maurer. Efficient proofs of knowledge of discrete logarithms and representations in groups with hidden order. In International Workshop on Practice and Theory in Public-Key Cryptography – PKC 05, volume 3386 of LNCS, pages 154–171. Springer, 2005.</li>

      <li>[BG93] M. Bellare and O. Goldreich. On defining proofs of knowledge. In Advances in Cryptology – CRYPTO 92, volume 740 of LNCS, pages 390–420. Springer, 1993.</li>

      <li>[Bla79] G. Blakley. Safeguarding cryptographic keys. In National Computer Conference 97, pages 313–317, 1979.</li>

      <li>[BMP07] Manuel Barbosa, Andrew Moss, and Dan Page. Compiler assisted elliptic curve cryptography. In Information Security (IS), volume 4804 of LNCS, pages 1785–1802. Springer, 2007.</li>

      <li>[BNPS05] M. Barbosa, R. Noad, D. Page, and N.P. Smart. First steps toward a cryptography-aware language and compiler. Cryptology ePrint Archive, Report 2005/160, 2005. http://eprint.iacr.org/.</li>

      <li>[BP05] Manuel Barbosa and Dan Page. On the automatic construction of indistinguishable operations. Cryptology ePrint Archive, Report 2005/174, 2005. http://eprint.iacr.org/.</li>

      <li>[Bra94] S. Brands. Untraceable off-line cash in wallet with observers. In Advances in Cryptology – CRYPTO 93, volume 773 of LNCS, pages 302–318. Springer, 1994.</li>

      <li>[Bra97] S. Brands. Rapid demonstration of linear relations connected by boolean operators. In Advances in Cryptology – EUROCRYPT 97, volume 1233 of LNCS, pages 318–333. Springer, 1997.</li>

      <li>[Bri04] T. Briner. Compiler for zero-knowledge proof-of-knowledge protocols. Master’s thesis, ETH Zurich, 2004.</li>

      <li>[BS02] E. Bresson and J. Stern. Proofs of knowledge for non-monotone discrete-log formulae and applications. In ISC ’02: Proceedings of the 5th International Conference on Information Security, pages 272–288. Springer, 2002.</li>

      <li>[Cam98] J. Camenisch. Group Signature Schemes and Payment Systems Based on the Discrete Logarithm Problem. PhD thesis, ETH Zurich, Konstanz, 1998.</li>

      <li>[CDS94] R. Cramer, I. Damgård, and B. Schoenmakers. Proofs of partial knowledge and simplified design of witness hiding protocols. In Advances in Cryptology – CRYPTO 94, volume 839 of LNCS, pages 174–187. Springer, 1994.</li>

      <li>[CFT98] A. Chan, Y. Frankel, and Y. Tsiounis. Easy come - easy go divisible cash. Technical Report TR-0371-05-98-582, GTE, 1998. Updated version with corrections.</li>

      <li>[CH02] J. Camenisch and E. V. Herreweghen. Design and implementation of the idemix anonymous credential system. In Proc. ACM CCS 2002, pages 21–30. ACM, 2002. http://www.zurich.ibm.com/security/idemix/.</li>

      <li>[CL02] J. Camenisch and A. Lysyanskaya. A signature scheme with efficient protocols. In Security in Communication Networks – SCN 2002, volume 2576 of LNCS, pages 268–289, 2002.</li>

      <li>[CL04] J. Camenisch and A. Lysyanskaya. Signature schemes and anonymous credentials from bilinear maps. In Advances in Cryptology – CRYPTO 2004, volume 3152 of LNCS, pages 56–72. Springer, 2004.</li>

      <li>[CM99] J. Camenisch and M. Michels. Proving in zero-knowledge that a number is the product of two safe primes. In Advances in Cryptology – EUROCRYPT 99, volume 1592 of LNCS, pages 107–122. Springer, 1999.</li>

      <li>[Cra96] R. Cramer. Modular Design of Secure yet Practical Cryptographic Protocols. PhD thesis, CWI and University of Amsterdam, 1996.</li>

      <li>[CRS05] J. Camenisch, M. Rohe, and A.-R. Sadeghi. Sokrates - a compiler framework for zero-knowledge protocols. In Western European Workshop on Research in Cryptology – WEWoRC 05, 2005.</li>

      <li>[CS97a] J. Camenisch and M. Stadler. Efficient group signature schemes for large groups (extended abstract). In Advances in Cryptology – CRYPTO 97, volume 1294, pages 410–424. Springer, 1997.</li>

    </ul>

    <p class="text-gray-300">CS97b. J. Camenisch and M. Stadler. Proof systems for general statements about discrete logarithms. Technical Report 260, Institute for Theoretical Computer Science, ETH Zürich, 1997.</p>

    <p class="text-gray-300">CS03. J. Camenisch and V. Shoup. Practical verifiable encryption and decryption of discrete logarithms. In Advances in Cryptology – CRYPTO 2003, volume 2729 of LNCS, pages 126–144. Springer, 2003.</p>

    <p class="text-gray-300">Dam00. I. Damgård. Efficient concurrent zero-knowledge in the auxiliary string model. In Advances in Cryptology – EUROCRYPT 2000, volume 1807 of LNCS, pages 418–430. Springer, 2000.</p>

    <p class="text-gray-300">Dam04. I. Damgård. On sigma-protocols, 2004. Lecture on Cryptologic Protocol Theory; Faculty of Science, University of Aarhus.</p>

    <p class="text-gray-300">DF02. I. Damgård and E. Fujisaki. A statistically-hiding integer commitment scheme based on groups with hidden order. In Advances in Cryptology – ASIACRYPT 2000, volume 2501 of LNCS, pages 77–85. Springer, 2002.</p>

    <p class="text-gray-300">DJ01. I. Damgård and M. Jurik. A generalisation, a simplification and some applications of paillier’s probabilistic public-key system. In Proc. 4th International Workshop on Practice and Theory in Public-Key Cryptography (PKC 2001), LNCS, pages 119–136. Springer, 2001.</p>

    <p class="text-gray-300">FS87. A. Fiat and A. Shamir. How to prove yourself: practical solutions to identification and signature problems. In Advances in Cryptology – CRYPTO 86, volume 263 of LNCS, pages 186–194. Springer, 1987.</p>

    <p class="text-gray-300">GMW91. O. Goldreich, S. Micali, and A. Wigderson. Proofs that yield nothing but their validity or all languages in NP have zero-knowledge proof systems. Journal of the ACM, 38(1):691–729, 1991. Preliminary version in 27th FOCS, 1986.</p>

    <p class="text-gray-300">GQ88. L. Guillou and J. Quisquater. A practical zero-knowledge protocol fitted to security microprocessor minimizing both transmission and memory. In Advances in Cryptology – EUROCRYPT 88, volume 330 of LNCS, pages 123–128. Springer, 1988.</p>

    <p class="text-gray-300">LPS08. Y. Lindell, B. Pinkas, and N. Smart. Implementing two-party computation efficiently with security against malicious adversaries. In Security in Communication Networks – SCN 2008, volume 5229 of LNCS, pages 2–20. Springer, 2008.</p>

    <p class="text-gray-300">MNPS04. D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella. Fairplay — a secure two-party computation system. In USENIX Security ’04, 2004. http://www.cs.huji.ac.il/project/Fairplay/fairplay.html.</p>

    <p class="text-gray-300">MOR03. P. MacKenzie, A. Oprea, and M. K. Reiter. Automatic generation of two-party computations. In Proc. ACM CCS 2003, pages 210–219. ACM, 2003.</p>

    <p class="text-gray-300">Oka95. T. Okamoto. An efficient divisible electronic cash scheme. In Advances in Cryptology – CRYPTO 95, volume 963 of LNCS, pages 438–451. Springer, 1995.</p>

    <p class="text-gray-300">Pai99. P. Paillier. Public-key cryptosystems based on composite degree residuosity classes. In Advances in Cryptology – EUROCRYPT 99, volume 1592 of LNCS, pages 223–238. Springer, 1999.</p>

    <p class="text-gray-300">Ped92. T. P. Pedersen. Non-interactive and information-theoretic secure verifiable secret sharing. In Advances in Cryptology – CRYPTO 91, volume 576 of LNCS, pages 129–140. Springer, 1992.</p>

    <p class="text-gray-300">RSA78. R. L. Rivest, A. Shamir, and L. Adleman. A method for obtaining digital signatures and public-key cryptosystems. Communications of the ACM, 21(2):120–126, 1978.</p>

    <p class="text-gray-300">Sch91. C. Schnorr. Efficient signature generation by smart cards. Journal Of Cryptology, 4(3):161–174, 1991.</p>

    <p class="text-gray-300">Sha79. A. Shamir. How to share a secret. Communications of the ACM, 22(11):612–613, 1979.</p>

    <h2 id="sec-32" class="text-2xl font-bold">Appendix A Proofs</h2>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">A.1 Proof of Theorem 1</h3>

    <h6 id="sec-34" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">3-move form and completeness follow from the definition.</p>

    <p class="text-gray-300">For special HVZK consider the following simulator: on input <span class="math">c\\in\\mathcal{C}</span>, choose <span class="math">s\\in_{R}\\mathcal{G}</span> and set <span class="math">r:=\\phi(s)x^{-c}</span>. Hence, the <span class="math">\\Sigma^{\\phi}</span>-protocol is a <span class="math">\\Sigma</span>-protocol according to Definition 1.</p>

    <p class="text-gray-300">For proof of knowledge property consider the following: using standard rewinding arguments, e.g. <em>[x10]</em>, it is possible to obtain two accepting communication triples <span class="math">(r,c^{\\prime},s^{\\prime})</span> and <span class="math">(r,c^{\\prime\\prime},s^{\\prime\\prime})</span> with <span class="math">c^{\\prime}\\neq c^{\\prime\\prime}</span> within the allowed running time of the knowledge extractor as defined by <em>[x5]</em>. Dividing the corresponding verification equations yields <span class="math">x^{c^{\\prime}-c^{\\prime\\prime}}=\\phi(s^{\\prime}-s^{\\prime\\prime})</span>. Since <span class="math">\\phi</span> is special, <span class="math">x^{v}=\\phi(u)</span>. We have <span class="math">\\gcd(c^{\\prime}-c^{\\prime\\prime},v)=1</span>, as <span class="math">c^{+}</span> is smaller than the smallest prime dividing <span class="math">v</span>. So, <span class="math">a,b\\in\\mathbb{Z}</span>, s.t. <span class="math">a(c^{\\prime}-c^{\\prime\\prime})+bv=1</span> can be found efficiently with extended Euclidean algorithm and by using the homomorphic property of <span class="math">\\phi</span> we obtain <span class="math">w^{\\prime}:=a(s^{\\prime}-s^{\\prime\\prime})+bu</span> as a preimage. ∎</p>

    <p class="text-gray-300">A.2 Proof of Theorem 3</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The first two properties of a <span class="math">\\Sigma</span>-protocol, i.e., <em>3-move-form</em> and <em>completeness</em>, are clear. Only the special HVZK and the proof of knowledge properties remain to show.</p>

    <p class="text-gray-300">Let’s start with <em>special HVZK</em>: To this end we consider the following simulator S for the <span class="math">\\Sigma^{exp}</span>-protocol on input <span class="math">c\\in\\mathcal{C}</span>: Choose <span class="math">\\mathsf{w}^{\\prime}\\in_{R}\\{0,\\ldots,2^{k_{s}}n\\}</span> and set <span class="math">\\mathsf{x}^{\\prime}:=g^{\\mathsf{W}^{\\prime}}</span>. Choose <span class="math">s^{\\prime}\\in\\mathcal{G}^{\\prime}</span>, and <span class="math">\\mathsf{s}^{\\prime}\\in_{R}\\{-2^{2k_{s}}c^{+}n,2^{2k_{s}}c^{+}n\\}</span>. Set <span class="math">t^{\\prime}:=\\phi_{E}(s^{\\prime})x^{-c}</span> and <span class="math">\\mathsf{t}^{\\prime}:=\\vartheta_{l+1}(s^{\\prime},\\mathsf{s}^{\\prime})\\mathsf{x}^{\\prime-c}</span>. The output of S is then given by <span class="math">((\\mathsf{x}^{\\prime},\\mathsf{t}^{\\prime},t^{\\prime}),c,(s^{\\prime},\\mathsf{s}^{\\prime}))</span>.</p>

    <p class="text-gray-300">We now have to verify that the distribution of these tuples is statistically indistuingishable from the verifier’s real view <span class="math">((\\mathsf{x},\\mathsf{t},t),c,(s,\\mathsf{s}))</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Both <span class="math">(\\mathsf{t},t)</span> and <span class="math">(\\mathsf{t}^{\\prime},t^{\\prime})</span> are uniquely determined by the other values. So it is sufficient to show that the distributions of $Pr(\\mathsf{x}^{\\prime},s^{\\prime},\\mathsf{s}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c,w)<span class="math"> and </span>Pr(\\mathsf{x},s,\\mathsf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c,w)<span class="math"> are statistically indistinguishable. To do so, we write </span>Pr(\\mathsf{x}^{\\prime},s^{\\prime},\\mathsf{s}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c,w)=Pr(s^{\\prime},\\mathsf{s}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}^{\\prime},c,w)Pr(\\mathsf{x}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c,w)<span class="math"> and </span>Pr(\\mathsf{x},s,\\mathsf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c,w)=Pr(s,\\mathsf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x},c,w)Pr(\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c,w)$, resp..</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The distributions of <span class="math">\\mathsf{x}</span> and <span class="math">\\mathsf{x}^{\\prime}</span> do not depend on <span class="math">c</span> and <span class="math">w</span>, as their choices do not depend on the secret preimage or the challenge. So we have to show that <span class="math">Pr(\\mathsf{x})</span> and <span class="math">Pr(\\mathsf{x}^{\\prime})</span> are statistically close. Since <span class="math">\\mathsf{w}\\in_{R}\\{0,\\ldots,2^{k_{s}}n\\}</span>, which is an interval much larger than the order of <span class="math">g</span> (upper bounded by <span class="math">n</span>), we have that <span class="math">\\mathsf{x}=g_{1}^{w_{1}}\\cdots g_{l}^{w_{l}}\\cdot g^{\\mathsf{W}}</span> is statistically close to the uniform distribution on <span class="math">\\langle g\\rangle</span>. On the other hand, with the same argument, the same holds for <span class="math">\\mathsf{x}^{\\prime}=g^{\\mathsf{W}^{\\prime}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">So it remains to show that $Pr(s^{\\prime},\\mathsf{s}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}^{\\prime},c,w)<span class="math"> and </span>Pr(s,\\mathsf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x},c,w)<span class="math"> are statistically close. First, note that the components of </span>s<span class="math"> are distributed independently; so the following holds: </span>Pr(s,\\mathsf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x},c,w)=Pr(s_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c,w_{1})\\cdots Pr(s_{l}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c,w_{l})Pr(\\mathsf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x},c)<span class="math"> and analogously for </span>Pr(s^{\\prime},\\mathsf{s}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}^{\\prime},c,w)<span class="math">. Each </span>s_{i}$ is uniform and random on</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\{-2^{k_{s}}T_{i}+cw_{i},\\ldots,cw_{i}+2^{k_{s}}T_{i}\\}</span></p>

    <p class="text-gray-300">and each <span class="math">s_{i}^{\\prime}</span> is uniform and random on</p>

    <p class="text-gray-300"><span class="math">\\{-2^{k_{s}}T_{i},\\ldots,2^{k_{s}}T_{i}\\}.</span></p>

    <p class="text-gray-300">So the statistical difference of the distributions is <span class="math">2cw_{i}/(2^{k_{s}+1}T_{i})</span> for each <span class="math">i=1,\\ldots,l</span>, and therefore negligible in the security parameter <span class="math">k_{s}</span>. Similarly, the difference of <span class="math">\\mathsf{s}</span> and <span class="math">\\mathsf{s}^{\\prime}</span> is negligible in <span class="math">k_{s}</span>. As <span class="math">l</span> is polynomially bounded in <span class="math">k_{s}</span>, the sum of these differences is negligible.</p>

    <p class="text-gray-300">Let’s turn to the <em>proof of knowledge property</em> now: using standard rewinding arguments we obtain two accepting communication triples, say <span class="math">((\\mathsf{x},\\mathsf{t},t),c^{\\prime},(s^{\\prime},\\mathsf{s}^{\\prime}))</span> and <span class="math">((\\mathsf{x},\\mathsf{t},t),c^{\\prime\\prime},(s^{\\prime\\prime},\\mathsf{s}^{\\prime\\prime}))</span>, with <span class="math">c^{\\prime}\\neq c^{\\prime\\prime}</span>, within the allowed running time of a knowledge-extractor <em>[x1]</em>. By dividing the corresponding verification equations we obtain</p>

    <p class="text-gray-300"><span class="math">\\phi_{E}(\\Delta s)=x^{\\Delta c}\\qquad\\text{and}\\qquad\\vartheta_{l+1}(\\Delta s,\\Delta\\mathsf{s})=\\mathsf{x}^{\\Delta c}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\Delta c:=c^{\\prime\\prime}-c^{\\prime}</span>, and analogously for <span class="math">\\Delta s,\\Delta\\mathsf{s}</span>. According to <em>[x10]</em> $\\Delta c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta s_{i}<span class="math"> for all </span>i<span class="math">, and </span>\\Delta c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta\\mathsf{s}<span class="math">, as otherwise the prover could factor the RSA-modulus </span>n$ efficiently. So we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">w^{\\prime}=(\\Delta s_{1}/\\Delta c,\\ldots,\\Delta s_{l}/\\Delta c)</span></p>

    <p class="text-gray-300">as a preimage, where the division in the exponent holds over the integers. Particularly, the <span class="math">\\Sigma^{exp}</span>-protocol is a <span class="math">\\Sigma</span>-protocol according to Definition 1.</p>

    <p class="text-gray-300">B EBNF Syntax Definition of the Input Language</p>

    <p class="text-gray-300">The syntax of the compiler's input language is specified by the following EBNF:</p>

    <p class="text-gray-300">Input ::= Declaration { Declaration } Assignment { Assignment } Definition { Definition } Protocol.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Declaration ::= GroupDeclaration</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(('GroupElement'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'Homomorphism'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'IntegerConstant') IdentList )';.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">GroupDeclaration ::= 'Group' GroupList ';'.</p>

    <p class="text-gray-300">GroupList ::= Group { ',' Group }.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Group ::= ('(' Ident [ ArrayNotation ] ',' ('+'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'*) '))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">('Z' Letter { '*' }).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">IdentList ::= Ident [ ArrayNotation ] { ',' Ident [ ArrayNotation ] }.</p>

    <p class="text-gray-300">ArrayNotation ::= '[' Number '.' .' Number ']'.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ident ::= Letter { Letter</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Number</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'_' }.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Letter ::= 'A'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'B'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'Z'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'a'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'z'.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Number ::= '0'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'9' { '0'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'9' }.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition ::= HomomorphismDefinition';.</p>

    <p class="text-gray-300">HomomorphismDefinition ::= 'DefineHomomorphism' HomomorphismDefinitionList.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">HomomorphismDefinitionList ::= '(' Ident ',' (AbstractStructure</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ConcreteStructure ) ')' { ',' (' Ident ',' (AbstractStructure</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ConcreteStructure ) ')' }.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ConcreteStructure ::= ( Ident</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">('(' IdentList ')) ) '</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-&gt;' '(' Expression { ',' Expression } ').</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">IdentList ::= Ident [ ArrayNotation ] [ ',' IdentList ].</p>

    <p class="text-gray-300">Expression ::= TermList.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">TermList ::= Term [ ('+'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'-') TermList ].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Term ::= FactorList.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FactorList ::= Factor [ ('*'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'/') FactorList ].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Factor ::= ExponentList.</p>

    <p class="text-gray-300">ExponentList ::= Exponent [ '^' ExponentList ].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Exponent ::= Ident</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Number</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">('(' Expression '))').</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">AbstractStructure ::= GroupStructure '-&gt;' GroupStructure.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">GroupStructure ::= ( Ident</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">('Z' Letter)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">('Z' Letter '*) ) [ ' # ' ( Ident</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">('Z' Letter { '*'})) ].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Assignment ::= 'AssignGroupMember' GroupMemberAssignmentList ';'.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">GroupMemberAssignmentList ::= '(' Ident ',' (Ident</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">('{ 'Ident [ ArrayNotation ] [ ',' Ident [ ArrayNotation ] '}) ')' ',' [ GroupmemberAssignList ].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Protocol ::= 'SpecifyProtocol' [' Relation [ Constraints ] [ VariableNames ] Target [ Layout ] '].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Relation ::= 'Relation' EnumerativeDescription</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BooleanDescription.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">EnumerativeDescription ::= '[' CommonInput PreImageInput [ AccessStructure ].</p>

    <p class="text-gray-300">CommonInput ::= 'CommonInput' '=' '{' CommonInputTuple [ ',' CommonInputTuple ] '}' ';'.</p>

    <p class="text-gray-300">CommonInputTuple ::= '(' Ident ',' (' Expression { ',' Expression } ')' )'.</p>

    <p class="text-gray-300">PreImageInput ::= 'PreImageInput' '=' '{' PreImageInputTuple { ',' PreImageInputTuple } '}' ';'.</p>

    <p class="text-gray-300">PreImageInputTuple ::= '(' Ident { ',' Ident } ').</p>

    <p class="text-gray-300">AccessStructure ::= 'AccessStructure' '=' '{' QualifiedSet { ',' QualifiedSet } '}.</p>

    <p class="text-gray-300">QualifiedSet ::= '{' Ident { ',' Ident } '}.</p>

    <p class="text-gray-300">BooleanDescription ::= '=' BooleanTermList.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BooleanTermList ::= BooleanTerm [ '</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">' BooleanTermList ].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">BooleanTerm ::= BooleanFactorList.</p>

    <p class="text-gray-300">BooleanFactorList ::= BooleanFactor [ '&amp;&amp; BooleanFactorList ].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BooleanFactor ::= HomomorphismRelation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">('( ' BooleanTermList )').</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">HomomorphismRelation ::= [' ImageHomRelationTuple '=' Ident '(' PreImageHomRelation-Tuple )''].</p>

    <p class="text-gray-300">PreImageHomRelationTuple ::= Ident { ', Ident }</p>

    <p class="text-gray-300">ImageHomRelationTuple ::= '(' Expression ').</p>

    <p class="text-gray-300">Constraints ::= 'Constraints' '=' ConstraintEquation { '&amp;&amp; ConstraintEquation } ';'.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ConstraintEquation ::= '(' Ident '=' ConstraintTuple { ('+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'-'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'*'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'/') ConstraintTuple } ').</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ConstraintTuple ::= [ '-'] ( (Number '* ' Ident)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Ident '^' Number)).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">VariableNames ::= 'ParameterNames' '[' VariableNameDefinition { VariableNameDefinition } '].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VariableNameDefinition ::= ( 'VarRandom'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'VarCommit'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'VarChallenge'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'VarResponse'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'VarPreimage'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'VarImage'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'VarHomomorphism'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'SecretSharingScheme'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'AccessStructure'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'QualifiedSet'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'ChallengeMax' ) '=' Ident ';'.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Target ::= 'Target' '=' 'JAVA'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">'LATEX' ';'.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Layout ::= 'Layout' '=' 'COMPACT' ';'.</p>

    <p class="text-gray-300">Table 1. Pre-defined variable names</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Protocol Element</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Default Name</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Description</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VarRandom</td>

            <td class="px-3 py-2 border-b border-gray-700">r</td>

            <td class="px-3 py-2 border-b border-gray-700">Randomly chosen preimage of prover</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VarCommit</td>

            <td class="px-3 py-2 border-b border-gray-700">t</td>

            <td class="px-3 py-2 border-b border-gray-700">Commitment of prover</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VarChallenge</td>

            <td class="px-3 py-2 border-b border-gray-700">c</td>

            <td class="px-3 py-2 border-b border-gray-700">Challenge of verifier</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VarResponse</td>

            <td class="px-3 py-2 border-b border-gray-700">s</td>

            <td class="px-3 py-2 border-b border-gray-700">Response of prover</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VarPreimage</td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">Compact mode: preimage</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VarImage</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">Compact mode: image</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VarHomomorphism</td>

            <td class="px-3 py-2 border-b border-gray-700">zeta</td>

            <td class="px-3 py-2 border-b border-gray-700">Compact mode: homomorphism</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SecretSharingScheme</td>

            <td class="px-3 py-2 border-b border-gray-700">Theta</td>

            <td class="px-3 py-2 border-b border-gray-700">Secret sharing scheme</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AccessStructure</td>

            <td class="px-3 py-2 border-b border-gray-700">Gamma</td>

            <td class="px-3 py-2 border-b border-gray-700">Access structure</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">QualifiedSet</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">Qualified set</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ChallengeMax</td>

            <td class="px-3 py-2 border-b border-gray-700">c_plus</td>

            <td class="px-3 py-2 border-b border-gray-700">Challenge maximum c+ for c ∈R [0..c+]</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">C Generated output of running example in §3</p>

    <p class="text-gray-300">C.1 Protocol Inputs</p>

    <p class="text-gray-300">Homomorphisms as defined in Input File <span class="math">\\phi_0: \\mathbb{Z}_m^<em> \\to \\mathbb{Z}_m^</em>, \\rho_0 \\mapsto \\rho_0^n</span> <span class="math">\\phi_1: \\mathbb{Z}_m^<em> \\to \\mathbb{Z}_m^</em>, \\rho_1 \\mapsto \\rho_1^n</span> <span class="math">\\phi_2: \\mathbb{Z}_n \\times \\mathbb{Z}_m^<em> \\to \\mathbb{Z}_m^</em>, (\\mu, \\rho_2) \\mapsto g^\\mu \\cdot \\rho_2^n</span> <span class="math">\\phi_3: \\mathbb{Z}_n \\times \\mathbb{Z}_m^<em> \\to \\mathbb{Z}_m^</em>, (\\mu, \\rho_3) \\mapsto g^\\mu \\cdot \\rho_3^n</span></p>

    <p class="text-gray-300">Homomorphisms as used in Protocol <span class="math">\\psi_0 = \\phi_0 \\times \\phi_2 \\times \\phi_3</span> <span class="math">\\psi_1 = \\phi_1 \\times \\phi_2 \\times \\phi_3</span></p>

    <p class="text-gray-300">Common Input <span class="math">\\mathbb{Z}: c^+, n</span> <span class="math">\\mathbb{Z}_m^<em>: g, x_a, x_b, x_c</span> Secret Sharing Scheme <span class="math">\\Theta, \\mathbb{Z}_m^</em>, \\mathbb{Z}_n</span></p>

    <p class="text-gray-300">Preimage Input <span class="math">\\mathbb{Z}_n: \\mu</span> <span class="math">\\mathbb{Z}_m^*: \\rho_0, \\rho_1, \\rho_2, \\rho_3</span> Qualified Set <span class="math">A</span></p>

    <p class="text-gray-300">Access Structure <span class="math">\\left((\\rho_0) \\wedge (\\mu, \\rho_2) \\wedge (\\mu, \\rho_3)\\right) \\vee \\left((\\rho_1) \\wedge (\\mu, \\rho_2) \\wedge (\\mu, \\rho_3)\\right)</span></p>

    <p class="text-gray-300">Constraints on Preimages <span class="math">\\mu_{\\phi_3} = 1 \\cdot \\mu_{\\phi_2}</span></p>

    <p class="text-gray-300">Relation <span class="math">\\phi_0: x_a = \\rho_0^n</span> <span class="math">\\phi_1: x_a \\cdot g^{-1} = \\rho_1^n</span> <span class="math">\\phi_2: x_b = g^\\mu \\cdot \\rho_2^n</span> <span class="math">\\phi_3: x_c = g^\\mu \\cdot \\rho_3^n</span></p>

    <p class="text-gray-300">Round 1, Prover:</p>

    <p class="text-gray-300">For each  <span class="math">\\zeta_i \\in \\{\\psi_0, \\psi_1\\}</span>  with  <span class="math">y_{\\zeta_i} = \\zeta_i(x_{\\zeta_i})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if secret  <span class="math">x_{\\zeta_i}</span>  is known:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\rho_{\\zeta_i} \\in_R \\operatorname{dom}(\\zeta_i)</span></p>

    <p class="text-gray-300"><span class="math">t_{\\zeta_i}\\coloneqq \\zeta_i(\\rho_{\\zeta_i})</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if secret  <span class="math">x_{\\zeta_i}</span>  is unknown:</li>

    </ul>

    <p class="text-gray-300"><span class="math">s_{\\zeta_i} \\in_R \\operatorname{dom}(\\zeta_i)</span></p>

    <p class="text-gray-300"><span class="math">c_{i}\\in_{R}[0,c^{+}]</span></p>

    <p class="text-gray-300"><span class="math">t_{\\zeta_i}\\coloneqq \\zeta_i(s_{\\zeta_i})\\cdot y_{\\zeta_i}^{c_i}</span></p>

    <p class="text-gray-300"><span class="math">t_{\\zeta_i}</span></p>

    <p class="text-gray-300">Round 2, Verifier:</p>

    <p class="text-gray-300"><span class="math">c\\in_{R}[0,c^{+}]</span></p>

    <p class="text-gray-300">C</p>

    <p class="text-gray-300">Round 3, Prover:</p>

    <p class="text-gray-300"><span class="math">(c_{0},c_{1})\\coloneqq \\mathrm{complete}(c,\\{[c_{i}]_{\\hat{A}}\\} ,\\Gamma^{*}(n))</span></p>

    <p class="text-gray-300">For each  <span class="math">\\zeta_i \\in \\{\\psi_0, \\psi_1\\}</span>  with  <span class="math">y_{\\zeta_i} = \\zeta_i(x_{\\zeta_i})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if secret  <span class="math">x_{\\zeta_i}</span>  is known:</li>

    </ul>

    <p class="text-gray-300"><span class="math">s_{\\zeta_i} \\coloneqq \\rho_{\\zeta_i} + (-x_{\\zeta_i}) \\cdot c_i</span></p>

    <p class="text-gray-300"><span class="math">s_{\\zeta_i},c_i</span></p>

    <p class="text-gray-300">Round 4, Verifier:</p>

    <p class="text-gray-300">Check whether</p>

    <p class="text-gray-300"><span class="math">s_{1,3}\\stackrel {?}{=}1\\cdot s_{1,1}</span></p>

    <p class="text-gray-300">Check for each  <span class="math">\\zeta_i \\in \\{\\psi_0, \\psi_1\\}</span>  with  <span class="math">y_{\\zeta_i} = \\zeta_i(x_{\\zeta_i})</span>  whether</p>

    <p class="text-gray-300"><span class="math">t_{\\zeta_i}\\stackrel {?}{=}\\zeta_i(s_{\\zeta_i})\\cdot y_{\\zeta_i}^{c_i}</span></p>

    <p class="text-gray-300">Check whether isConsistent  <span class="math">(c, \\{[c_i]\\}, \\Gamma^*(n))</span>  returns true</p>

    <p class="text-gray-300">D Generated output of example in §4.1</p>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">D.1 Protocol Inputs</h3>

    <p class="text-gray-300">Homomorphisms as defined in Input File</p>

    <p class="text-gray-300"><span class="math">\\phi_{0}:\\mathbb{Z}_{q}^{2}\\to G</span>, <span class="math">(\\rho,\\mu)\\mapsto v_{s}{}^{\\rho}\\cdot v_{xy}^{(-1\\cdot\\mu)}</span></p>

    <p class="text-gray-300"><span class="math">\\phi_{1}:\\mathbb{Z}_{q}\\to G</span>, <span class="math">\\nu\\mapsto g^{\\nu}</span></p>

    <p class="text-gray-300"><span class="math">\\phi_{2}:\\mathbb{Z}_{q}\\to G</span>, <span class="math">\\nu\\mapsto h^{\\nu}</span></p>

    <p class="text-gray-300"><span class="math">\\phi_{3}:\\mathbb{Z}_{q}^{2}\\to G</span>, <span class="math">(\\nu,\\mu)\\mapsto y_{1}{}^{\\nu}\\cdot g^{\\mu}</span></p>

    <p class="text-gray-300"><span class="math">\\phi_{4}:\\mathbb{Z}_{q}\\to G</span>, <span class="math">\\nu\\mapsto\\left(y_{2}\\cdot y_{3}{}^{H}\\right)^{\\nu}</span></p>

    <p class="text-gray-300">Homomorphisms as used in Protocol</p>

    <p class="text-gray-300"><span class="math">\\psi_{0}=\\phi_{0}\\times\\phi_{1}\\times\\phi_{2}\\times\\phi_{3}\\times\\phi_{4}</span></p>

    <p class="text-gray-300">Common Input</p>

    <p class="text-gray-300"><span class="math">G:c_{1},c_{2},c_{3},c_{4},g,h,v_{s},v_{x},v_{xy},y_{1},y_{2},y_{3}</span></p>

    <p class="text-gray-300"><span class="math">\\mathbb{Z}_{q}:H</span></p>

    <p class="text-gray-300"><span class="math">\\mathbb{Z}:c^{+}</span></p>

    <p class="text-gray-300"><span class="math">G,\\text{Secret Sharing Scheme}\\;\\Theta,\\mathbb{Z}_{q}</span></p>

    <p class="text-gray-300">Preimage Input</p>

    <p class="text-gray-300"><span class="math">\\mathbb{Z}_{q}:\\mu,\\nu,\\rho</span></p>

    <p class="text-gray-300">Qualified Set <span class="math">A</span></p>

    <p class="text-gray-300">Access Structure</p>

    <p class="text-gray-300"><span class="math">\\left((\\rho,\\mu)\\wedge(\\nu)\\wedge(\\nu)\\wedge(\\nu,\\mu)\\wedge(\\nu)\\right)</span></p>

    <p class="text-gray-300">Constraints on Preimages</p>

    <p class="text-gray-300"><span class="math">\\mu_{\\phi_{3}}=1\\cdot\\mu_{\\phi_{0}}</span></p>

    <p class="text-gray-300"><span class="math">\\nu_{\\phi_{2}}=1\\cdot\\nu_{\\phi_{1}}</span></p>

    <p class="text-gray-300"><span class="math">\\nu_{\\phi_{3}}=1\\cdot\\nu_{\\phi_{1}}</span></p>

    <p class="text-gray-300"><span class="math">\\nu_{\\phi_{4}}=1\\cdot\\nu_{\\phi_{1}}</span></p>

    <p class="text-gray-300">Relation</p>

    <p class="text-gray-300"><span class="math">\\phi_{0}:v_{x}=v_{s}{}^{\\rho}\\cdot v_{xy}^{(-1\\cdot\\mu)}</span></p>

    <p class="text-gray-300"><span class="math">\\phi_{1}:c_{1}=g^{\\nu}</span></p>

    <p class="text-gray-300"><span class="math">\\phi_{2}:c_{2}=h^{\\nu}</span></p>

    <p class="text-gray-300"><span class="math">\\phi_{3}:c_{3}=y_{1}{}^{\\nu}\\cdot g^{\\mu}</span></p>

    <p class="text-gray-300"><span class="math">\\phi_{4}:c_{4}=\\left(y_{2}\\cdot y_{3}{}^{H}\\right)^{\\nu}</span></p>

    <p class="text-gray-300">Round 1, Prover:</p>

    <p class="text-gray-300"><span class="math">r_{0,0}\\in_{R}\\mathbb{Z}_{q}</span></p>

    <p class="text-gray-300"><span class="math">r_{0,1}\\in_{R}\\mathbb{Z}_{q}</span></p>

    <p class="text-gray-300"><span class="math">r_{0,2}\\in_{R}\\mathbb{Z}_{q}</span></p>

    <p class="text-gray-300"><span class="math">r_{0,5}:= r_{0,1}\\cdot 1</span></p>

    <p class="text-gray-300"><span class="math">r_{0,3}:= r_{0,2}\\cdot 1</span></p>

    <p class="text-gray-300"><span class="math">r_{0,4}:= r_{0,2}\\cdot 1</span></p>

    <p class="text-gray-300"><span class="math">r_{0,6}:= r_{0,2}\\cdot 1</span></p>

    <p class="text-gray-300"><span class="math">t_{0,0}:= \\left(v_{s}^{r_{0,0}}\\cdot v_{xy}^{(-1\\cdot r_{0,1})}\\right)</span></p>

    <p class="text-gray-300"><span class="math">t_{0,1}:= (g^{r_{0,2}})</span></p>

    <p class="text-gray-300"><span class="math">t_{0,2}:= (h^{r_{0,3}})</span></p>

    <p class="text-gray-300"><span class="math">t_{0,3}:= (y_{1}^{r_{0,4}}\\cdot g^{r_{0,5}})</span></p>

    <p class="text-gray-300"><span class="math">t_{0,4}:= \\left(\\left(y_{2}\\cdot y_{3}^{H}\\right)^{r_{0,6}}\\right)</span></p>

    <p class="text-gray-300"><span class="math">t_{0,0}, t_{0,1}, t_{0,2}, t_{0,3}, t_{0,4}</span></p>

    <p class="text-gray-300">Round 2, Verifier:</p>

    <p class="text-gray-300"><span class="math">c\\in_{R}[0,c^{+}]</span></p>

    <p class="text-gray-300">Round 3, Prover:</p>

    <p class="text-gray-300"><span class="math">(s_{0,0}, s_{0,1}) := (r_{0,0}, r_{0,1}) + ((-((\\rho, \\mu)))) \\cdot c</span></p>

    <p class="text-gray-300"><span class="math">s_{0,2} := r_{0,2} + ((-(\\nu))) \\cdot c</span></p>

    <p class="text-gray-300"><span class="math">s_{0,3} := r_{0,3} + ((-(\\nu))) \\cdot c</span></p>

    <p class="text-gray-300"><span class="math">(s_{0,4}, s_{0,5}) := (r_{0,4}, r_{0,5}) + ((-((\\nu, \\mu)))) \\cdot c</span></p>

    <p class="text-gray-300"><span class="math">s_{0,6} := r_{0,6} + ((-(\\nu))) \\cdot c</span></p>

    <p class="text-gray-300"><span class="math">s_{0,0}, s_{0,1}, s_{0,2}, s_{0,3}, s_{0,4}, s_{0,5}, s_{0,6}</span></p>

    <p class="text-gray-300">Round 4, Verifier:</p>

    <p class="text-gray-300">Check whether</p>

    <p class="text-gray-300"><span class="math">s_{0,5}\\stackrel{{\\scriptstyle?}}{{=}}1\\cdot s_{0,1}</span> <span class="math">s_{0,3}\\stackrel{{\\scriptstyle?}}{{=}}1\\cdot s_{0,2}</span> <span class="math">s_{0,4}\\stackrel{{\\scriptstyle?}}{{=}}1\\cdot s_{0,2}</span> <span class="math">s_{0,6}\\stackrel{{\\scriptstyle?}}{{=}}1\\cdot s_{0,2}</span></p>

    <p class="text-gray-300">Check whether</p>

    <p class="text-gray-300"><span class="math">t_{0,0}\\stackrel{{\\scriptstyle?}}{{=}}(v_s^{s_{0,0}}\\cdot v_{xy}^{(-1\\cdot s_{0,1})})\\cdot v_x^c</span> <span class="math">t_{0,1}\\stackrel{{\\scriptstyle?}}{{=}}(g^{s_{0,2}})\\cdot c_1^c</span> <span class="math">t_{0,2}\\stackrel{{\\scriptstyle?}}{{=}}(h^{s_{0,3}})\\cdot c_2^c</span> <span class="math">t_{0,3}\\stackrel{{\\scriptstyle?}}{{=}}(y_1^{s_{0,4}}\\cdot g^{s_{0,5}})\\cdot c_3^c</span> <span class="math">t_{0,4}\\stackrel{{\\scriptstyle?}}{{=}}((y_2\\cdot y_3^H)^{s_{0,6}})\\cdot c_4^c</span></p>

    <h2 id="sec-39" class="text-2xl font-bold">Appendix E Generated output of example in §4.2</h2>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">E.1 Protocol Inputs</h3>

    <p class="text-gray-300">Homomorphisms as defined in Input File</p>

    <p class="text-gray-300"><span class="math">\\phi_{1}:\\mathbb{Z}_{q}\\to\\mathbb{Z}_{p}^{<em>},\\,w_{1}\\mapsto g^{w_{1}}</span> <span class="math">\\phi_{2}:\\mathbb{Z}_{q}\\to\\mathbb{Z}_{p}^{</em>},\\,w_{2}\\mapsto g^{w_{2}}</span> <span class="math">\\phi_{3}:\\mathbb{Z}_{q}\\to\\mathbb{Z}_{p}^{*},\\,w_{3}\\mapsto g^{w_{3}}</span></p>

    <p class="text-gray-300">Homomorphisms as used in Protocol</p>

    <p class="text-gray-300"><span class="math">\\phi_{1}=\\phi_{1}</span> <span class="math">\\phi_{2}=\\phi_{2}</span> <span class="math">\\phi_{3}=\\phi_{3}</span></p>

    <p class="text-gray-300">Common Input</p>

    <p class="text-gray-300"><span class="math">\\mathbb{Z}:c^{+}</span> <span class="math">\\mathbb{Z}_{p}^{<em>}:g,x_{1},x_{2},x_{3}</span> Secret Sharing Scheme <span class="math">\\Theta,\\mathbb{Z}_{p}^{</em>},\\mathbb{Z}_{q}</span></p>

    <p class="text-gray-300">Preimage Input</p>

    <p class="text-gray-300"><span class="math">\\mathbb{Z}_{q}:w_{1},w_{2},w_{3}</span> Qualified Set <span class="math">A</span></p>

    <p class="text-gray-300">Access Structure</p>

    <p class="text-gray-300"><span class="math">\\left((w_{1})\\right)\\vee\\left((w_{2})\\right)\\vee\\left((w_{3})\\right)</span></p>

    <p class="text-gray-300">Relation</p>

    <p class="text-gray-300"><span class="math">\\phi_{1}:x_{1}=g^{w_{1}}</span> <span class="math">\\phi_{2}:x_{2}=g^{w_{2}}</span> <span class="math">\\phi_{3}:x_{3}=g^{w_{3}}</span></p>

    <p class="text-gray-300">Round 1, Prover:</p>

    <p class="text-gray-300">For each  <span class="math">\\zeta_i \\in \\{\\phi_1, \\phi_2, \\phi_3\\}</span>  with  <span class="math">y_{\\zeta_i} = \\zeta_i(x_{\\zeta_i})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if secret  <span class="math">x_{\\zeta_i}</span>  is known:</li>

    </ul>

    <p class="text-gray-300"><span class="math">r_{\\zeta_i}\\in_R\\mathrm{dom}(\\zeta_i)</span></p>

    <p class="text-gray-300"><span class="math">t_{\\zeta_i}\\coloneqq \\zeta_i(r_{\\zeta_i})</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if secret  <span class="math">x_{\\zeta_i}</span>  is unknown:</li>

    </ul>

    <p class="text-gray-300"><span class="math">s_{\\zeta_i}\\in_R\\mathrm{dom}(\\zeta_i)</span></p>

    <p class="text-gray-300"><span class="math">c_{i}\\in_{R}[0,c^{+}]</span></p>

    <p class="text-gray-300"><span class="math">t_{\\zeta_i}\\coloneqq \\zeta_i(s_{\\zeta_i})\\cdot y_{\\zeta_i}^{c_i}</span></p>

    <p class="text-gray-300"><span class="math">t_{\\zeta_i}</span></p>

    <p class="text-gray-300">Round 2, Verifier:</p>

    <p class="text-gray-300"><span class="math">c\\in_{R}[0,c^{+}]</span></p>

    <p class="text-gray-300">c</p>

    <p class="text-gray-300">Round 3, Prover:</p>

    <p class="text-gray-300"><span class="math">(c_{0},c_{1},c_{2})\\coloneqq \\mathrm{complete}(c,\\{[c_{i}]_{\\bar{A}}\\} ,\\Gamma^{*}(n))</span></p>

    <p class="text-gray-300">For each  <span class="math">\\zeta_i \\in \\{\\phi_1, \\phi_2, \\phi_3\\}</span>  with  <span class="math">y_{\\zeta_i} = \\zeta_i(x_{\\zeta_i})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if secret  <span class="math">x_{\\zeta_i}</span>  is known:</li>

    </ul>

    <p class="text-gray-300"><span class="math">s_{\\zeta_i} := r_{\\zeta_i} + (-x_{\\zeta_i}) \\cdot c_i</span></p>

    <p class="text-gray-300"><span class="math">s_{\\zeta_i},c_i</span></p>

    <p class="text-gray-300">Round 4, Verifier:</p>

    <p class="text-gray-300">Check for each  <span class="math">\\zeta_i \\in \\{\\phi_1, \\phi_2, \\phi_3\\}</span>  with  <span class="math">y_{\\zeta_i} = \\zeta_i(x_{\\zeta_i})</span>  whether</p>

    <p class="text-gray-300"><span class="math">t_{\\zeta_i}\\stackrel {?}{=}\\zeta_i(s_{\\zeta_i})\\cdot y_{\\zeta_i}^{c_i}</span></p>

    <p class="text-gray-300">Check whether isConsistent  <span class="math">(c, \\{[c_i]\\}, \\Gamma^*(n))</span>  returns true</p>`;
---

<BaseLayout title="Automatic Generation of Sound Zero-Knowledge Protocols (2008/471)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2008 &middot; eprint 2008/471
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
