---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/317';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Libra: Succinct Zero-Knowledge Proofs with Optimal Prover Computation';
const AUTHORS_HTML = 'Tiancheng Xie, Jiaheng Zhang, Yupeng Zhang, Charalampos Papamanthou, Dawn Song';

const CONTENT = `    <p class="text-gray-300">Libra: Succinct Zero-Knowledge Proofs with Optimal Prover Computation</p>

    <p class="text-gray-300">Tiancheng Xie<em> Jiaheng Zhang</em> Yupeng Zhang†</p>

    <p class="text-gray-300">Charalampos Papamanthou‡ Dawn Song*</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">We present Libra, the first zero-knowledge proof system that has both optimal prover time and succinct proof size/verification time. In particular, if <span class="math">C</span> is the size of the circuit being proved (i) the prover time is <span class="math">O(C)</span> irrespective of the circuit type; (ii) the proof size and verification time are both <span class="math">O(d\\log C)</span> for <span class="math">d</span>-depth log-space uniform circuits (such as RAM programs). In addition Libra features an one-time trusted setup that depends only on the size of the input to the circuit and not on the circuit logic. Underlying Libra is a new linear-time algorithm for the prover of the interactive proof protocol by Goldwasser, Kalai and Rothblum (also known as GKR protocol), as well as an efficient approach to turn the GKR protocol to zero-knowledge using small masking polynomials. Not only does Libra have excellent asymptotics, but it is also efficient in practice. For example, our implementation shows that it takes 200 seconds to generate a proof for constructing a SHA2-based Merkle tree root on 256 leaves, outperforming all existing zero-knowledge proof systems. Proof size and verification time of Libra are also competitive.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Zero-knowledge proofs (ZKP) are cryptographic protocols between two parties, a <em>prover</em> and a <em>verifier</em>, in which the prover can convince the verifier about the validity of a statement without leaking any extra information beyond the fact that the statement is true. Since they were first introduced by Goldwasser et al. <em>[33]</em>, ZKP protocols have evolved from pure theoretical constructs to practical implementations, achieving proof sizes of just hundreds of bytes and verification times of several milliseconds, regardless of the size of the statement being proved. Due to this successful transition to practice, ZKP protocols have found numerous applications not only in the traditional computation delegation setting but most importantly in providing privacy of transactions in deployed cryptocurrencies (e.g., Zcash <em>[11]</em>) as well as in other blockchain research projects (e.g., Hawk <em>[39]</em>).</p>

    <p class="text-gray-300">Despite such progress in practical implementations, ZKP protocols are still notoriously hard to scale for large statements, due to a particularly high overhead on generating the proof. For most systems, this is primarily because the prover has to perform a large number of cryptographic operations, such as exponentiation in an elliptic curve group. And to make things worse the</p>

    <p class="text-gray-300">asymptotic complexity of computing the proof is typically more than linear, e.g., <span class="math">O(C\\log C)</span> or even <span class="math">O(C\\log^{2}C)</span>, where <span class="math">C</span> is the size of the statement.</p>

    <p class="text-gray-300">Unfortunately, as of today we are yet to construct a ZKP system whose prover time is <em>optimal</em>, i.e., linear in the size of the statement <span class="math">C</span> (this is irrespective of whether the ZKP system has per-statement trusted setup, one-time trusted setup or no trusted setup at all). The only notable exception is the recent work by Bünz et al. <em>[18]</em> that however suffers from linear verification time—for a detailed comparison see Table 1. Therefore designing ZKP systems that enjoy linear prover time as well as succinct proof size and verification time is an open problem, whose resolution can have significant practical implications.</p>

    <p class="text-gray-300">Our contributions. In this paper we propose Libra, the first ZKP protocol with <em>linear prover time</em> and <em>succinct proof size and verification time</em> in the size of the arithmetic circuit representing the statement <span class="math">C</span>, when the circuit is <em>log-space uniform</em>. Libra is based on the doubly efficient interactive proof protocol proposed by Goldwasser et al. in <em>[32]</em> (referred as GKR protocol in this paper), and the verifiable polynomial delegation scheme proposed by Zhang et al. in <em>[53]</em>. As such it comes with <em>one-time trusted</em> setup (and not per-statement trusted setup) that depends only on the size of the input (witness) to the statement that is being proved. Not only does Libra have excellent asymptotic performance but also its prover outperforms in practice all other ZKP systems while verification time and proof size are also very competitive—see Table 1. Our concrete contributions are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>GKR with linear prover time. Libra features a new linear-time algorithm to generate a GKR proof. Our new algorithm does not require any pattern in the circuit and our result subsumes all existing improvements on the GKR prover assuming special circuit structures, such as regular circuits in <em>[45]</em>, data-parallel circuits in <em>[49, 45]</em>, circuits with different sub-copies in <em>[54]</em>. See related work for more details.</li>

      <li>Adding zero-knowledge. We propose an approach to turn Libra into zero-knowledge efficiently. In particular, we show a way to mask the responses of our linear-time prover with small random polynomials such that the zero-knowledge variant of the protocol introduces minimal overhead on the verification time compared to the original (unmasked) construction.</li>

      <li>Implementation and evaluation. We implement Libra. Our implementation takes an arithmetic circuit with various types of gates (fan-in <span class="math">2</span> and degree <span class="math">\\leq 2</span>, such as <span class="math">+,-,\\times</span>, AND, XOR, etc.) and compiles it into a ZKP protocol. We conduct thorough comparisons to all existing ZKP systems (see Section 1.1). The open-source implementation of our system is released at <em>[5]</em>.</li>

    </ul>

    <h3 id="sec-1" class="text-xl font-semibold mt-8">1.1 Comparing to other ZKP Systems</h3>

    <p class="text-gray-300">Table 1 shows a detailed comparison between Libra and existing ZKP systems. First of all, Libra is the best among all existing systems in terms of practical prover time. In terms of asymptotics, Libra is the only system with linear prover time and succinct verification and proof size for log-space uniform circuits. The only other system with linear prover time is Bulletproofs <em>[18]</em> whose verification time is linear, <em>even for log-space uniform circuits</em>. In the practical front, Bulletproofs prover time and verification time are high, due to the large number of cryptographic operations required for every gate of the circuit.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 1: Comparison of Libra to existing ZKP systems, where  $(\\mathcal{G},\\mathcal{P},\\mathcal{V},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  denote the trusted setup algorithm, the prover algorithm, the verification algorithm and the proof size respectively. Also,  </span>C<span class="math">  is the size of the log-space uniform circuit with depth  </span>d<span class="math"> , and  </span>n$  is the size of its input. The numbers are for a circuit computing the root of a Merkle tree with 256 leaves (511 instances of SHA256).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">libSNARK [15]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ligero [7]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bulletproofs [18]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyrax [51]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">libSTARK [10]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Aurora [13]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Libra</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C) per-statement trusted setup</td>

            <td class="px-3 py-2 border-b border-gray-700">no trusted setup</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) one-time trusted setup</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C log C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C log C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C log C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C log2C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C log C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">V</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√n + d log C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(d log C)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√n + d log C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(d log C)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">1027s</td>

            <td class="px-3 py-2 border-b border-gray-700">NA</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">210s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P</td>

            <td class="px-3 py-2 border-b border-gray-700">360s</td>

            <td class="px-3 py-2 border-b border-gray-700">400s</td>

            <td class="px-3 py-2 border-b border-gray-700">2,555s</td>

            <td class="px-3 py-2 border-b border-gray-700">1,041s</td>

            <td class="px-3 py-2 border-b border-gray-700">2,022s</td>

            <td class="px-3 py-2 border-b border-gray-700">3199s</td>

            <td class="px-3 py-2 border-b border-gray-700">201s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">V</td>

            <td class="px-3 py-2 border-b border-gray-700">0.002s</td>

            <td class="px-3 py-2 border-b border-gray-700">4s</td>

            <td class="px-3 py-2 border-b border-gray-700">98s</td>

            <td class="px-3 py-2 border-b border-gray-700">9.9s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.044s</td>

            <td class="px-3 py-2 border-b border-gray-700">15.2s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.71s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">0.13KB</td>

            <td class="px-3 py-2 border-b border-gray-700">1,500KB</td>

            <td class="px-3 py-2 border-b border-gray-700">2KB</td>

            <td class="px-3 py-2 border-b border-gray-700">185KB</td>

            <td class="px-3 py-2 border-b border-gray-700">395KB</td>

            <td class="px-3 py-2 border-b border-gray-700">174.3KB</td>

            <td class="px-3 py-2 border-b border-gray-700">51KB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The proof and verification of Libra are also competitive to other systems. In asymptotic terms, our proof size is only larger than libSNARK [15] and Bulletproofs [18], and our verification is slower than libSNARK [15] and libSTARK [10]. Compared to Hyrax [51], which is also based on similar techniques with our work, Libra improves the performance in all aspects (yet Hyrax does not have any trusted setup). One can refer to Section 5 for a detailed description of our experimental setting as well as a more detailed comparison.</p>

    <p class="text-gray-300">Finally, among all systems, libSNARK [15] requires a trusted setup for every statement, and Libra requires an one-time trusted setup that depends on the input size. See Section 5.3 for a discussion on removing trusted setup in Libra.</p>

    <p class="text-gray-300">Log-space uniform circuits. Though the prover time in Libra is optimal for all circuits, the verification time is succinct only when the circuit is structured (log-space uniform with logarithmic depth). This is the best that can be achieved for all ZKP protocols without per-circuit setup, as the verifier must read the entire circuit, which takes linear time in the worst case. We always refer to log-space uniform circuits when we say our scheme is succinct in this paper, to differentiate from schemes with linear verification time on all circuits (irrespective of whether the circuits are log-space uniform or not). Schemes such as libSTARK [10], zkVSQL [52] and Hyrax [51] also have such property.</p>

    <p class="text-gray-300">In practice, with the help of auxiliary input and circuit squashing, most computations can be expressed as log-space uniform circuits with low depth, such as matrix multiplication, image scaling and Merkle hash tree in Section 5. Asymptotically, as shown in [10, 15, 54], all random memory access (RAM) programs can be validated by circuits that are log-space uniform with log-depth in the running time of the programs (but linear in the size of the programs) by RAM-to-circuit reduction, which justifies the expressiveness of such circuits.</p>

    <p class="text-gray-300">1.2 Our Techniques</p>

    <p class="text-gray-300">Our main technical contributions are a GKR protocol with linear prover time and an efficient approach to turn the GKR protocol into zero-knowledge. We summarize the key ideas behind these two contributions. The detailed protocols are presented in Section 3 and 4 respectively.</p>

    <p class="text-gray-300">GKR with linear prover. Goldwasser et al. <em>[32]</em> showed an approach to model the evaluation of a layered circuit as a sequence of summations on polynomials defined by values in consecutive layers of the circuit. Using the famous sumcheck protocol (see Section 2.3.1), they developed a protocol (the GKR protocol) allowing the verifier to validate the circuit evaluation in logarithmic time with a logarithmic size proof. However, the polynomials in the protocol are multivariate with <span class="math">2s</span> variables, where <span class="math">S</span> is the number of gates in one layer of the circuit and <span class="math">s=\\log S</span>. Naively running the sumcheck protocol on these polynomials incurs <span class="math">S^{2}</span> prover time, as there are at least <span class="math">2^{2s}=S^{2}</span> monomials in a <span class="math">2s</span>-variate polynomial. Later, Cormode et al. <em>[25]</em> observed that these polynomials are sparse, containing only <span class="math">S</span> nonzero monomials and improved the prover time to <span class="math">S\\log S</span>.</p>

    <p class="text-gray-300">In our new approach, we divide the protocol into two separate sumchecks. In each sumcheck, the polynomial only contains <span class="math">s</span> variables, and can be expressed as the product of two multilinear polynomials. Utilizing the sparsity of the circuit, we develop new algorithms to scan through each gate of the circuit and compute the closed-form of all these multilinear polynomials explicitly, which takes <span class="math">O(S)</span> time. With this new way of representation, the prover can deploy a dynamic programming technique to generate the proofs in each sumcheck in <span class="math">O(S)</span> time, resulting in a total prover time of <span class="math">O(S)</span>.</p>

    <p class="text-gray-300">Efficient zero-knowledge GKR. The original GKR protocol is not zero-knowledge, since the messages in the proof can be viewed as weighed sums of the values in the circuit and leak information. In <em>[51, 52]</em>, the authors proposed to turn the GKR protocol into zero-knowledge by hiding the messages in homomorphic commitments, which incurs a big overhead in the verification time. In <em>[24]</em>, Chiesa et al. proposed an alternative approach by masking the protocol with random polynomials. However, the masking polynomials are as big as the original ones and the prover time becomes exponential, making the approach mainly of theoretical interest.</p>

    <p class="text-gray-300">In our scheme, we first show that in order to make the sumcheck protocol zero-knowledge, the prover can mask it with a “small” polynomial. In particular, the masking polynomial only contains logarithmically many random coefficients. The intuition is that though the original polynomial has <span class="math">O(2^{\\ell})</span> or more terms (<span class="math">\\ell</span> is the number of variables in the polynomial), the prover only sends <span class="math">O(\\ell)</span> messages in the sumcheck protocol. Therefore, it suffices to mask the original polynomial with a random one with <span class="math">O(\\ell)</span> coefficients to achieve zero-knowledge. In particular, we set the masking polynomial as the sum of <span class="math">\\ell</span> univariate random polynomials with the same variable-degree. In Section 4.1, we show that the entropy of this mask exactly counters the leakage of the sumcheck, proving that it is sufficient and optimal.</p>

    <p class="text-gray-300">Besides the sumcheck, the GKR protocol additionally leaks two evaluations of the polynomial defined by values in each layer of the circuit. To make these evaluations zero-knowledge, we mask the polynomial by a special low-degree random polynomial. In particular, we show that after the mask, the verifier in total learns 4 messages related to the evaluations of the masking polynomial and we can prove zero-knowledge by making these messages linearly independent. Therefore, the masking polynomial is of constant size: it consists of 2 variables with variable degree 2.</p>

    <p class="text-gray-300">In recent years there has been significant progress in efficient ZKP protocols and systems. In this section, we discuss related work in this area, with the focus on those with sublinear proofs.</p>

    <p class="text-gray-300">QAP-based. Following earlier work of Ishai <em>[36]</em>, Groth <em>[35]</em> and Lipmaa <em>[40]</em>, Gennaro et al. <em>[30]</em> introduced quadratic arithmetic programs (QAPs), which forms the basis of most recent implementations <em>[12, 16, 21, 26, 29, 44, 50]</em> including libSNARK <em>[15]</em>. The proof size in these systems is constant, and the verification time depends only on the input size. Both these properties are particularly appealing and have led to real-world deployments, e.g., ZCash <em>[11]</em>. One of the main bottlenecks, however, of QAP-based systems is the high overhead in the prover running time and memory consumption, making it hard to scale to large statements. In addition, a separate trusted setup for every different statement is required.</p>

    <p class="text-gray-300">IOPs. Based on “(MPC)-in-the-head” introduced in <em>[23, 31, 37]</em>, Ames et al. <em>[7]</em> proposed a ZKP scheme called Ligero. It only uses symmetric key operations and the prover time is fast in practice. However, it generates proofs of size <span class="math">O(\\sqrt{C})</span>, which is several megabytes in practice for moderate-size circuits. In addition, the verification time is quasi-linear to the size of the circuit. It is categorized as interactive PCP, which is a special case of interactive oracle proofs (IOPs). IOP generalizes the probabilistically checkable proofs (PCPs) where earlier works of Kilian <em>[38]</em> and Micali <em>[43]</em> are built on. In the IOP model, Ben-Sasson et al. built libstark <em>[10]</em>, a zero-knowledge transparent argument of knowledge (zkSTARK).libstark does not rely on trusted setup and executes in the RAM model of computation. Their verification time is only linear to the description of the RAM program, and succinct (logarithmic) in the time required for program execution. Recently, Ben-Sasson et al. <em>[13]</em> proposed Aurora, a new ZKP system in the IOP model with the proof size of <span class="math">O(\\log^{2}C)</span>.</p>

    <p class="text-gray-300">Discrete log. Before Bulletproof <em>[18]</em>, earlier discrete-log based ZKP schemes include the work of Groth <em>[34]</em>, Bayer and Groth <em>[9]</em> and Bootle et al. <em>[19]</em>. The proof size of these schemes are larger than Bulletproof either asymptotically or concretely.</p>

    <p class="text-gray-300">Hash-based. Bootle et al. <em>[20]</em> proposed a ZKP scheme with linear prover time and verification time. The verification only requires <span class="math">O(C)</span> field additions. However, the proof size is <span class="math">O(\\sqrt{C})</span> and the constants are large as mentioned in the paper <em>[20]</em>.</p>

    <p class="text-gray-300">Interactive proofs. The line of work that relates to our paper the most is based on interactive proofs <em>[33]</em>. In the seminal work of <em>[32]</em>, Goldwasser et al. proposed an efficient interactive proof for layered arithmetic circuits. Later, Cormode et al. <em>[25]</em> improved the prover complexity of the interactive proof in <em>[32]</em> to <span class="math">O(C\\log C)</span> using multilinear extensions instead of low degree extensions. Several follow-up works further reduce the prover time assuming special structures of the circuit. For regular circuits where the wiring pattern can be described in constant space and time, Thaler <em>[45]</em> introduced a protocol with <span class="math">O(C)</span> prover time; for data parallel circuits with many copies of small circuits with size <span class="math">C^{\\prime}</span>, a <span class="math">O(C\\log C^{\\prime})</span> protocol is presented in the same work, later improved to <span class="math">O(C+C^{\\prime}\\log C)</span> by Wahby et al. in <em>[49]</em>; for circuits with many non-connected but different copies, Zhang et al. showed a protocol with <span class="math">O(C\\log C^{\\prime})</span> prover time.</p>

    <p class="text-gray-300">In <em>[53]</em>, Zhang et al. extended the GKR protocol to an argument system using a protocol for verifiable polynomial delegation. Zhang et al. <em>[54]</em> and Wahby et al. <em>[51]</em> make the argument system zero-knowledge by putting all the messages in the proof into homomorphic commitments, as proposed by Cramer and Damgard in <em>[27]</em>. This approach introduces a high overhead on the verification time compared to the plain argument system without zero-knowledge, as each addition becomes a multiplication and each multiplication becomes an exponentiation in the homomorphic</p>

    <p class="text-gray-300">commitments. The multiplicative overhead is around two orders of magnitude in practice. Additionally, the scheme of [51], Hyrax, removes the trusted setup of the argument system by introducing a new polynomial delegation, increasing the proof size and verification time to  <span class="math">O(\\sqrt{n})</span>  where  <span class="math">n</span>  is the input size of the circuit.</p>

    <p class="text-gray-300">Lattice-based. Recently Baum et al. [8] proposed the first lattice-based ZKP system with sublinear proof size. The proof size is  <span class="math">O(\\sqrt{C \\log^3 C})</span> , and the practical performance is to be explored.</p>

    <p class="text-gray-300">In this paper, we use  <span class="math">\\lambda</span>  to denote the security parameter, and  <span class="math">\\mathsf{negl}(\\lambda)</span>  to denote the negligible function in  <span class="math">\\lambda</span> . "PPT" stands for probabilistic polynomial time. We use  <span class="math">f(), h()</span>  for polynomials,  <span class="math">x, y, z</span>  for vectors of variables and  <span class="math">g, u, v</span>  for vectors of values.  <span class="math">x_i</span>  denotes the  <span class="math">i</span> -th variable in  <span class="math">x</span> . We use bold letters such as  <span class="math">\\mathbf{A}</span>  to represent arrays. For a multivariate polynomial  <span class="math">f</span> , its "variable-degree" is the maximum degree of  <span class="math">f</span>  in any of its variables.</p>

    <p class="text-gray-300">Bilinear pairings. Let  <span class="math">\\mathbb{G},\\mathbb{G}_T</span>  be two groups of prime order  <span class="math">p</span>  and let  <span class="math">g\\in \\mathbb{G}</span>  be a generator.  <span class="math">e:\\mathbb{G}\\times \\mathbb{G}\\to \\mathbb{G}_T</span>  denotes a bilinear map and we use  <span class="math">\\mathsf{bp} = (p,\\mathbb{G},\\mathbb{G}_T,e,g)\\gets \\mathsf{BilGen}(1^\\lambda)</span>  for the generation of parameters for the bilinear map. Our scheme relies on the  <span class="math">q</span> -Strong Bilinear Diffie-Hellman ( <span class="math">q</span> -SBDH) assumption and an extended version of the Power Knowledge of Exponent (PKE) assumption.</p>

    <p class="text-gray-300">Assumption 1 (q-Strong Bilinear Diffie-Hellman). For any PPT adversary  <span class="math">\\mathcal{A}</span> , the following holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{l} \\mathsf {b p} \\leftarrow \\mathsf {B i l G e n} (1 ^ {\\lambda}) \\\\ s \\stackrel {{R}} {{\\leftarrow}} \\mathbb {Z} _ {p} ^ {*} \\qquad : (x, e (g, g) ^ {\\frac {1}{s + \\sigma}}) \\leftarrow \\mathcal {A} (1 ^ {\\lambda}, \\sigma) \\\\ \\sigma = (\\mathsf {b p}, g ^ {s},..., g ^ {s ^ {q}}) \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">The second assumption is a generalization of the  <span class="math">q</span> -PKE assumption [35] to multivariate polynomials, proposed in [52, 53]. Let  <span class="math">\\mathcal{W}_{\\ell,d}</span>  be the set of all multisets of  <span class="math">\\{1,\\dots,\\ell\\}</span>  with the cardinality of each element being at most  <span class="math">d</span> .</p>

    <p class="text-gray-300">Assumption 2  <span class="math">((d,\\ell)</span> -Extended Power Knowledge of Exponent). For any PPT adversary  <span class="math">\\mathcal{A}</span> , there is a polynomial time algorithm  <span class="math">\\mathcal{E}</span>  (takes the same randomness of  <span class="math">\\mathcal{A}</span>  as input) such that for all benign auxiliary inputs  <span class="math">z\\in \\{0,1\\}^{\\mathrm{poly}(\\lambda)}</span>  the following probability is negligible:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname <em> {P r} \\left[ \\begin{array}{c c} \\mathsf {b p} \\leftarrow \\mathsf {B i l G e n} (1 ^ {\\lambda}) &amp; \\\\ s _ {1}, \\ldots , s _ {\\ell}, s _ {\\ell + 1}, \\alpha \\stackrel {{R}} {{\\leftarrow}} Z _ {p} ^ {</em>}, s _ {0} = 1 &amp; \\\\ \\sigma_ {1} = (\\{g ^ {\\prod_ {i \\in W} s _ {i}} \\} _ {W \\in \\mathcal {W} _ {\\ell , d}, g ^ {s _ {\\ell + 1}}}) &amp; e (h, g ^ {\\alpha}) = e (\\tilde {h}, g) \\\\ \\sigma_ {2} = (\\{g ^ {\\alpha \\prod_ {i \\in W} s _ {i}} \\} _ {W \\in \\mathcal {W} _ {\\ell , d}}, g ^ {\\alpha s _ {\\ell + 1}}) &amp; : \\prod_ {W \\in \\mathcal {W} _ {\\ell , d}} g ^ {a _ {W} \\prod_ {i \\in W} s _ {i}} g ^ {b s _ {\\ell + 1}} \\neq h \\\\ \\sigma = (\\mathsf {b p}, \\sigma_ {1}, \\sigma_ {2}, g ^ {\\alpha}) &amp; \\\\ \\mathbb {G} \\times \\mathbb {G} \\ni (h, \\tilde {h}) \\leftarrow \\mathcal {A} \\left(1 ^ {\\lambda}, \\sigma , z\\right) &amp; \\\\ \\left(a _ {0}, \\ldots , a _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {W} _ {\\ell , d}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, b\\right) \\leftarrow \\mathcal {E} \\left(1 ^ {\\lambda}, \\sigma , z\\right) &amp; \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">2.2 Interactive Proofs and Zero-knowledge Arguments</p>

    <p class="text-gray-300">Interactive proofs. An interactive proof allows a prover <span class="math">\\mathcal{P}</span> to convince a verifier <span class="math">\\mathcal{V}</span> the validity of some statement. The interactive proof runs in several rounds, allowing <span class="math">\\mathcal{V}</span> to ask questions in each round based on <span class="math">\\mathcal{P}</span>’s answers of previous rounds. We phrase this in terms of <span class="math">\\mathcal{P}</span> trying to convince <span class="math">\\mathcal{V}</span> that <span class="math">f(x)=1</span>. The proof system is interesting only when the running time of <span class="math">\\mathcal{V}</span> is less than the time of directly computing the function <span class="math">f</span>. We formalize interactive proofs in the following:</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">Let <span class="math">f</span> be a Boolean function. A pair of interactive machines <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> is an interactive proof for <span class="math">f</span> with soundness <span class="math">\\epsilon</span> if the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For every <span class="math">x</span> such that <span class="math">f(x)=1</span> it holds that <span class="math">\\Pr[\\langle\\mathcal{P},\\mathcal{V}\\rangle(x)=accept]=1</span>.</li>

      <li><span class="math">\\epsilon</span>-Soundness. For any <span class="math">x</span> with <span class="math">f(x)\\neq 1</span> and any <span class="math">\\mathcal{P}^{<em>}</span> it holds that <span class="math">\\Pr[\\langle\\mathcal{P}^{</em>},\\mathcal{V}\\rangle=accept]\\leq\\epsilon</span></li>

    </ul>

    <p class="text-gray-300">Zero-knowledge arguments. An argument system for an NP relationship <span class="math">R</span> is a protocol between a computationally-bounded prover <span class="math">\\mathcal{P}</span> and a verifier <span class="math">\\mathcal{V}</span>. At the end of the protocol, <span class="math">\\mathcal{V}</span> is convinced by <span class="math">\\mathcal{P}</span> that there exists a witness <span class="math">w</span> such that <span class="math">(x;w)\\in R</span> for some input <span class="math">x</span>. We focus on arguments of knowledge which have the stronger property that if the prover convinces the verifier of the statement validity, then the prover must know <span class="math">w</span>. We use <span class="math">\\mathcal{G}</span> to represent the generation phase of the public key <span class="math">\\mathsf{pk}</span> and the verification key <span class="math">\\mathsf{vk}</span>. Formally, consider the definition below, where we assume <span class="math">R</span> is known to <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span>.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">Let <span class="math">R</span> be an NP relation. A tuple of algorithm <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> is a zero-knowledge argument of knowledge for <span class="math">R</span> if the following holds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness. For every <span class="math">(\\mathsf{pk},\\mathsf{vk})</span> output by <span class="math">\\mathcal{G}(1^{\\lambda})</span> and <span class="math">(x,w)\\in R</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\langle\\mathcal{P}(\\mathsf{pk},w),\\mathcal{V}(\\mathsf{vk})\\rangle(x)=\\mathsf{accept}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness. For any PPT prover <span class="math">\\mathcal{P}</span>, there exists a PPT extractor <span class="math">\\varepsilon</span> such that for every <span class="math">(\\mathsf{pk},\\mathsf{vk})</span> output by <span class="math">\\mathcal{G}(1^{\\lambda})</span> and any <span class="math">x</span>, it holds that</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[\\langle\\mathcal{P}(\\mathsf{pk}),\\mathcal{V}(\\mathsf{vk})\\rangle(x)=\\mathsf{accept}\\wedge(x,w)\\notin R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w\\leftarrow\\varepsilon(\\mathsf{pk},x)]\\leq\\mathsf{negl}(\\lambda)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Zero knowledge. There exists a PPT simulator <span class="math">\\mathcal{S}</span> such that for any PPT adversary <span class="math">\\mathcal{A}</span>, auxiliary input <span class="math">z\\in\\{0,1\\}^{\\mathsf{poly}(\\lambda)}</span>, <span class="math">(x;w)\\in R</span>, it holds that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\langle\\mathcal{P}(\\mathsf{pk},w),\\mathcal{A}\\rangle=\\mathsf{accept}:(\\mathsf{pk},\\mathsf{vk})\\leftarrow\\mathcal{G}(1^{\\lambda});(x,w)\\leftarrow\\mathcal{A}(z,\\mathsf{pk},\\mathsf{vk})\\right]=</span> <span class="math">\\Pr\\left[\\langle\\mathcal{S}(\\mathsf{trap},z,\\mathsf{pk}),\\mathcal{A}\\rangle=\\mathsf{accept}:(\\mathsf{pk},\\mathsf{vk},\\mathsf{trap})\\leftarrow\\mathcal{S}(1^{\\lambda});(x,w)\\leftarrow\\mathcal{A}(z,\\mathsf{pk},\\mathsf{vk})\\right]</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say that <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> is a succinct argument system if the running time of <span class="math">\\mathcal{V}</span> and the total communication between <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> (proof size) are $\\mathsf{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.3 GKR Protocol</h3>

    <p class="text-gray-300">In <em>[32]</em>, Goldwasser et al. proposed an efficient interactive proof protocol for layered arithmetic circuits, which we use as a building block for our new zero-knowledge argument and is referred as the GKR protocol. We present the detailed protocol here.</p>

    <p class="text-gray-300">Protocol 1 (Sumcheck). The protocol proceeds in <span class="math">\\ell</span> rounds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the first round, <span class="math">\\mathcal{P}</span> sends a univariate polynomial</li>

    </ul>

    <p class="text-gray-300"><span class="math">f_{1}(x_{1})\\stackrel{{\\scriptstyle def}}{{=}}\\sum_{b_{2},\\ldots,b_{\\ell}\\in\\{0,1\\}}f(x_{1},b_{2},\\ldots,b_{\\ell})\\,,</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> checks <span class="math">H=f_{1}(0)+f_{1}(1)</span>. Then <span class="math">\\mathcal{V}</span> sends a random challenge <span class="math">r_{1}\\in\\mathbb{F}</span> to <span class="math">\\mathcal{P}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the <span class="math">i</span>-th round, where <span class="math">2\\leq i\\leq l-1</span>, <span class="math">\\mathcal{P}</span> sends a univariate polynomial</li>

    </ul>

    <p class="text-gray-300"><span class="math">f_{i}(x_{i})\\stackrel{{\\scriptstyle def}}{{=}}\\sum_{b_{i+1},\\ldots,b_{\\ell}\\in\\{0,1\\}}f(r_{1},\\ldots,r_{i-1},x_{i},b_{i+1},\\ldots,b_{\\ell})\\,,</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> checks <span class="math">f_{i-1}(r_{i-1})=f_{i}(0)+f_{i}(1)</span>, and sends a random challenge <span class="math">r_{i}\\in\\mathbb{F}</span> to <span class="math">\\mathcal{P}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the <span class="math">\\ell</span>-th round, <span class="math">\\mathcal{P}</span> sends a univariate polynomial</li>

    </ul>

    <p class="text-gray-300"><span class="math">f_{\\ell}(x_{\\ell})\\stackrel{{\\scriptstyle def}}{{=}}f(r_{1},r_{2},\\ldots,r_{l-1},x_{\\ell})\\,,</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> checks <span class="math">f_{\\ell-1}(r_{\\ell-1})=f_{\\ell}(0)+f_{\\ell}(1)</span>. The verifier generates a random challenge <span class="math">r_{\\ell}\\in\\mathbb{F}</span>. Given oracle access to an evaluation <span class="math">f(r_{1},r_{2},\\ldots,r_{\\ell})</span> of <span class="math">f</span>, <span class="math">\\mathcal{V}</span> will accept if and only if <span class="math">f_{\\ell}(r_{\\ell})=f(r_{1},r_{2},\\ldots,r_{\\ell})</span>. The instantiation of the oracle access depends on the application of the sumcheck protocol.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">2.3.1 Sumcheck Protocol.</h4>

    <p class="text-gray-300">The sumcheck problem is a fundamental problem that has various applications. The problem is to sum a polynomial <span class="math">f:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span> on the binary hypercube</p>

    <p class="text-gray-300"><span class="math">\\sum\\nolimits_{b_{1},b_{2},\\ldots,b_{\\ell}\\in\\{0,1\\}}f(b_{1},b_{2},...,b_{\\ell}).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Directly computing the sum requires exponential time in <span class="math">\\ell</span>, as there are <span class="math">2^{\\ell}</span> combinations of <span class="math">b_{1},\\ldots,b_{\\ell}</span>. <em>Lund et al. [41]</em> proposed a <em>sumcheck</em> protocol that allows a verifier <span class="math">\\mathcal{V}</span> to delegate the computation to a computationally unbounded prover <span class="math">\\mathcal{P}</span>, who can convince <span class="math">\\mathcal{V}</span> that <span class="math">H</span> is the correct sum. We provide a description of the sumcheck protocol in Protocol 1. The proof size of the sumcheck protocol is <span class="math">O(d\\ell)</span>, where <span class="math">d</span> is the variable-degree of <span class="math">f</span>, as in each round, <span class="math">\\mathcal{P}</span> sends a univariate polynomial of one variable in <span class="math">f</span>, which can be uniquely defined by <span class="math">d+1</span> points. The verifier time of the protocol is <span class="math">O(d\\ell)</span>. The prover time depends on the degree and the sparsity of <span class="math">f</span>, and we will give the complexity later in our scheme. The sumcheck protocol is complete and sound with $\\epsilon=\\frac{d\\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">2.3.2 GKR protocol</h4>

    <p class="text-gray-300">Using the sumcheck protocol as a building block, <em>Goldwasser et al. [32]</em> showed an interactive proof protocol for layered arithmetic circuits.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 3 (Multi-linear Extension).</h6>

    <p class="text-gray-300">Let <span class="math">V:\\{0,1\\}^{\\ell}\\to\\mathbb{F}</span> be a function. The multilinear extension of <span class="math">V</span> is the unique polynomial <span class="math">\\hat{V}:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span> such that <span class="math">\\hat{V}(x_{1},x_{2},...,x_{l})=V(x_{1},x_{2},...,x_{l})</span> for all <span class="math">x_{1},x_{2},\\ldots,x_{l}\\in\\{0,1\\}^{l}</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}</span> can be expressed as:</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}(x_{1},x_{2},...,x_{l})=\\sum\\nolimits_{b\\in\\{0,1\\}^{l}}\\prod_{i=1}^{l}[((1-x_{i})(1-b_{i})+x_{i}b_{i})\\cdot V(b)]</span></p>

    <p class="text-gray-300">where <span class="math">b_{i}</span> is <span class="math">i</span>-th bit of <span class="math">b</span>.</p>

    <p class="text-gray-300">Multilinear extensions of arrays. Inspired by the close form equation of the multilinear extension given above, we can view an array <span class="math">\\mathbf{A}=(a_{0},a_{1},\\ldots,a_{n-1})</span> as a function <span class="math">A:\\{0,1\\}^{\\log n}\\to\\mathbb{F}</span> such that <span class="math">\\forall i\\in[0,n-1],A(i)=a_{i}</span>. Therefore, in this paper, we abuse the use of multilinear extension on an array as the multilinear extension <span class="math">\\tilde{A}</span> of <span class="math">A</span>.</p>

    <p class="text-gray-300">High Level Ideas. Let <span class="math">C</span> be a layered arithmetic circuit with depth <span class="math">d</span> over a finite field <span class="math">\\mathbb{F}</span>. Each gate in the <span class="math">i</span>-th layer takes inputs from two gates in the <span class="math">(i+1)</span>-th layer; layer <span class="math">0</span> is the output layer and layer <span class="math">d</span> is the input layer. The protocol proceeds layer by layer. Upon receiving the claimed output from <span class="math">\\mathcal{P}</span>, in the first round, <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> run the sumcheck protocol to reduce the claim about the output to a claim about the values in the layer above. In the <span class="math">i</span>-th round, both parties reduce a claim about layer <span class="math">i-1</span> to a claim about layer <span class="math">i</span> through the sumcheck protocol. Finally, the protocol terminates with a claim about the input layer <span class="math">d</span>, which can be checked directly by <span class="math">\\mathcal{V}</span>, or is given as an oracle access. If the check passes, <span class="math">\\mathcal{V}</span> accepts the claimed output.</p>

    <p class="text-gray-300">Notation. Before describing the GKR protocol, we introduce some additional notations. We denote the number of gates in the <span class="math">i</span>-th layer as <span class="math">S_{i}</span> and let <span class="math">s_{i}=\\lceil\\log S_{i}\\rceil</span>. (For simplicity, we assume <span class="math">S_{i}</span> is a power of <span class="math">2</span>, and we can pad the layer with dummy gates otherwise.) We then define a function <span class="math">V_{i}:\\{0,1\\}^{s_{i}}\\to\\mathbb{F}</span> that takes a binary string <span class="math">b\\in\\{0,1\\}^{s_{i}}</span> and returns the output of gate <span class="math">b</span> in layer <span class="math">i</span>, where <span class="math">b</span> is called the gate label. With this definition, <span class="math">V_{0}</span> corresponds to the output of the circuit, and <span class="math">V_{d}</span> corresponds to the input layer. Finally, we define two additional functions <span class="math">add_{i},mult_{i}:\\{0,1\\}^{s_{i-1}+2s_{i}}\\to\\{0,1\\}</span>, referred as <em>wiring predicates</em> in the literature. <span class="math">add_{i}</span> (<span class="math">mult_{i}</span>) takes one gate label <span class="math">z\\in\\{0,1\\}^{s_{i-1}}</span> in layer <span class="math">i-1</span> and two gate labels <span class="math">x,y\\in\\{0,1\\}^{s_{i}}</span> in layer <span class="math">i</span>, and outputs <span class="math">1</span> if and only if gate <span class="math">z</span> is an addition (multiplication) gate that takes the output of gate <span class="math">x,y</span> as input. With these definitions, <span class="math">V_{i}</span> can be written as follows:</p>

    <p class="text-gray-300"><span class="math">V_{i}(z)=</span> <span class="math">\\sum_{x,y\\in\\{0,1\\}^{s_{i+1}}}(add_{i+1}(z,x,y)(V_{i+1}(x)+V_{i+1}(y))</span> (1) <span class="math">+mult_{i+1}(z,x,y)(V_{i+1}(x)V_{i+1}(y)))</span></p>

    <p class="text-gray-300">for any <span class="math">z\\in\\{0,1\\}^{s_{i}}</span>.</p>

    <p class="text-gray-300">In the equation above, <span class="math">V_{i}</span> is expressed as a summation, so <span class="math">\\mathcal{V}</span> can use the sumcheck protocol to check that it is computed correctly. As the sumcheck protocol operates on polynomials defined on <span class="math">\\mathbb{F}</span>, we rewrite the equation with their multilinear extensions:</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(g)=</span> <span class="math">\\sum\\nolimits_{x,y\\in\\{0,1\\}^{s_{i+1}}}f_{i}(x,y)</span> <span class="math">=</span> <span class="math">\\sum\\nolimits_{x,y\\in\\{0,1\\}^{s_{i+1}}}(a\\tilde{d}d_{i+1}(g,x,y)(\\tilde{V}_{i+1}(x)+\\tilde{V}_{i+1}(y))</span> <span class="math">+m\\tilde{u}lt_{i+1}(g,x,y)(\\tilde{V}_{i+1}(x)\\tilde{V}_{i+1}(y)))\\,,</span> (2)</p>

    <p class="text-gray-300">where <span class="math">g\\in\\mathbb{F}^{s_{i}}</span> is a random vector.</p>

    <p class="text-gray-300">Protocol. With Equation 2, the GKR protocol proceeds as follows. The prover <span class="math">\\mathcal{P}</span> first sends the claimed output of the circuit to <span class="math">\\mathcal{V}</span>. From the claimed output, <span class="math">\\mathcal{V}</span> defines polynomial <span class="math">\\tilde{V}_{0}</span> and computes <span class="math">\\tilde{V}_{0}(g)</span> for a random <span class="math">g\\in\\mathbb{F}^{s_{0}}</span>. <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> then invoke a sumcheck protocol on Equation 2 with <span class="math">i=0</span>. As described in Section 2.3.1, at the end of the sumcheck, <span class="math">\\mathcal{V}</span> needs an oracle access to <span class="math">f_{i}(u,v)</span>, where <span class="math">u,v</span> are randomly selected in <span class="math">\\mathbb{F}^{s_{i+1}}</span>. To compute <span class="math">f_{i}(u,v)</span>, <span class="math">\\mathcal{V}</span> computes <span class="math">\\tilde{add}_{i+1}(u,v)</span> and <span class="math">\\tilde{mult}_{i+1}(u,v)</span> locally (they only depend on the wiring pattern of the circuit, but not on the values), asks <span class="math">\\mathcal{P}</span> to send <span class="math">\\tilde{V}_{1}(u)</span> and <span class="math">\\tilde{V}_{1}(v)</span> and computes <span class="math">f_{i}(u,v)</span> to complete the sumcheck protocol. In this way, <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> reduces a claim about the output to two claims about values in layer 1. <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> could invoke two sumcheck protocols on <span class="math">\\tilde{V}_{1}(u)</span> and <span class="math">\\tilde{V}_{1}(v)</span> recursively to layers above, but the number of claims and the sumcheck protocols would increase exponentially in <span class="math">d</span>.</p>

    <p class="text-gray-300">Combining two claims: condensing to one claim. In <em>[32]</em>, Goldwasser et al. presented a protocol to reduce two claims <span class="math">\\tilde{V}_{i}(u)</span> and <span class="math">\\tilde{V}_{i}(v)</span> to one as following. <span class="math">\\mathcal{V}</span> defines a line <span class="math">\\gamma:\\mathbb{F}\\to\\mathbb{F}^{s_{i}}</span> such that <span class="math">\\gamma(0)=u,\\gamma(1)=v</span>. <span class="math">\\mathcal{V}</span> sends <span class="math">\\gamma(x)</span> to <span class="math">\\mathcal{P}</span>. Then <span class="math">\\mathcal{P}</span> sends <span class="math">\\mathcal{V}</span> a degree <span class="math">s_{i}</span> univariate polynomial <span class="math">h(x)=\\tilde{V}_{i}(\\gamma(x))</span>. <span class="math">\\mathcal{V}</span> checks that <span class="math">h(0)=\\tilde{V}_{i}(u),h(1)=\\tilde{V}_{i}(v)</span>. Then <span class="math">\\mathcal{V}</span> randomly chooses <span class="math">r\\in\\mathbb{F}</span> and computes a new claim <span class="math">h(r)=\\tilde{V}_{i}(\\gamma(r))=\\tilde{V}_{i}(w)</span> on <span class="math">w=\\gamma(r)\\in\\mathbb{F}^{s_{i}}</span>. <span class="math">\\mathcal{V}</span> sends <span class="math">r,w</span> to <span class="math">\\mathcal{P}</span>. In this way, the two claims are reduced to one claim <span class="math">\\tilde{V}_{i}(w)</span>. Combining this protocol with the sumcheck protocol on Equation 2, <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> can reduce a claim on layer <span class="math">i</span> to one claim on layer <span class="math">i+1</span>, and eventually to a claim on the input, which completes the GKR protocol.</p>

    <p class="text-gray-300">Combining two claims: random linear combination. In <em>[24]</em>, Chiesa et al. proposed an alternative approach using random linear combinations. Upon receiving the two claims <span class="math">\\tilde{V}_{i}(u)</span> and <span class="math">\\tilde{V}_{i}(v)</span>, <span class="math">\\mathcal{V}</span> selects <span class="math">\\alpha_{i},\\beta_{i}\\in\\mathbb{F}</span> randomly and computes <span class="math">\\alpha_{i}\\tilde{V}_{i}(u)+\\beta_{i}\\tilde{V}_{i}(v)</span>. Based on Equation 2, this random linear combination can be written as</p>

    <p class="text-gray-300"><span class="math">\\alpha_{i}\\tilde{V}_{i}(u)+\\beta_{i}\\tilde{V}_{i}(v)</span> <span class="math">=</span> <span class="math">\\alpha_{i}\\sum_{x,y\\in\\{0,1\\}^{s_{i+1}}}(\\tilde{add}_{i+1}(u,x,y)(\\tilde{V}_{i+1}(x)+\\tilde{V}_{i+1}(y))+\\tilde{mult}_{i+1}(u,x,y)(\\tilde{V}_{i+1}(x)\\tilde{V}_{i+1}(y)))</span> <span class="math">+</span> <span class="math">\\beta_{i}\\sum_{x,y\\in\\{0,1\\}^{s_{i+1}}}(\\tilde{add}_{i+1}(v,x,y)(\\tilde{V}_{i+1}(x)+\\tilde{V}_{i+1}(y))+\\tilde{mult}_{i+1}(v,x,y)(\\tilde{V}_{i+1}(x)\\tilde{V}_{i+1}(y)))</span> <span class="math">=</span> <span class="math">\\sum_{x,y\\in\\{0,1\\}^{s_{i+1}}}((\\alpha_{i}\\tilde{add}_{i+1}(u,x,y)+\\beta_{i}\\tilde{add}_{i+1}(v,x,y))(\\tilde{V}_{i+1}(x)+\\tilde{V}_{i+1}(y))</span> <span class="math">+(\\alpha_{i}\\tilde{mult}_{i+1}(u,x,y)+\\beta_{i}\\tilde{mult}_{i+1}(v,x,y))(\\tilde{V}_{i+1}(x)\\tilde{V}_{i+1}(y)))</span> (3)</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> then execute the sumcheck protocol on Equation 3 instead of Equation 2. At the end of the sumcheck protocol, <span class="math">\\mathcal{V}</span> still receives two claims about <span class="math">\\tilde{V}_{i+1}</span>, computes their random linear combination and proceeds to an layer above recursively until the input layer.</p>

    <p class="text-gray-300">In our new ZKP scheme, we will mainly use the second approach. The full GKR protocol using random linear combinations is given in Protocol 2.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Theorem 1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>[47]</em> <em>[45]</em> <em>[25]</em> <em>[32]</em>. Let <span class="math">C:\\mathbb{F}^{n}\\to\\mathbb{F}^{k}</span> be a depth-<span class="math">d</span> layered arithmetic circuit. Protocol 2 is an interactive proof for the function computed by <span class="math">C</span> with soundness $O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. It uses </span>O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> rounds of interaction and running time of the prover </span>\\mathcal{P}<span class="math"> is </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Let the optimal computation time for all </span>\\tilde{add}_{i}<span class="math"> and </span>\\tilde{mult}_{i}<span class="math"> be </span>T<span class="math">, the running time of </span>\\mathcal{V}<span class="math"> is </span>O(n+k+d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+T)<span class="math">. For log-space uniform circuits it is </span>T=\\mathsf{poly}\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Protocol 2. Let  <span class="math">\\mathbb{F}</span>  be a prime field. Let  <span class="math">C\\colon \\mathbb{F}^n\\to \\mathbb{F}^k</span>  be a  <span class="math">d</span> -depth layered arithmetic circuit.  <span class="math">\\mathcal{P}</span>  wants to convince that  <span class="math">\\mathrm{out} = C(\\mathrm{in})</span>  where in is the input from  <span class="math">\\mathcal{V}</span> , and out is the output. Without loss of generality, assume  <span class="math">n</span>  and  <span class="math">k</span>  are both powers of 2 and we can pad them if not.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define the multilinear extension of array out as  <span class="math">\\tilde{V}_0</span> .  <span class="math">\\mathcal{V}</span>  chooses a random  <span class="math">g \\in \\mathbb{F}^{s_0}</span>  and sends it to  <span class="math">\\mathcal{P}</span> . Both parties compute  <span class="math">\\tilde{V}_0(g)</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run a sumcheck protocol on</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\tilde {V} _ {0} (g ^ {(0)}) = \\sum_ {x, y \\in \\{0, 1 \\} ^ {s _ {1}}} \\tilde {m u l t} _ {1} (g ^ {(0)}, x, y) (\\tilde {V} _ {1} (x) \\tilde {V} _ {1} (y)) + \\tilde {a d d} _ {1} (g ^ {(0)}, x, y) (\\tilde {V} _ {1} (x) + \\tilde {V} _ {1} (y))</span></div>

    <p class="text-gray-300">At the end of the protocol,  <span class="math">\\mathcal{V}</span>  receives  <span class="math">\\tilde{V}_1(u^{(1)})</span>  and  <span class="math">\\tilde{V}_1(v^{(1)})</span> ,  <span class="math">\\mathcal{V}</span>  computes  <span class="math">\\tilde{mult}_1(g^{(0)},u^{(1)},v^{(1)})</span> ,  <span class="math">\\tilde{add}_1(g^{(0)},u^{(1)},v^{(1)})</span>  and checks that  <span class="math">\\tilde{mult}_1(g^{(0)},u^{(1)},v^{(1)})\\tilde{V}_1(u^{(1)})\\tilde{V}_1(v^{(1)}) + \\tilde{add}_1(g^{(0)},u^{(1)},v^{(1)})(\\tilde{V}_1(u^{(1)}) + \\tilde{V}_1(v^{(1)}))</span>  equals to the last message of the sumcheck.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i = 1, \\dots, d - 1</span> :</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  randomly selects  <span class="math">\\alpha^{(i)},\\beta^{(i)}\\in \\mathbb{F}</span>  and sends them to  <span class="math">\\mathcal{P}</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run the sumcheck on the equation</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\alpha^ {(i)} \\dot {V} _ {i} (u ^ {(i)}) + \\beta^ {(i)} \\dot {V} _ {i} (v ^ {(i)}) = \\\\ \\sum_ {x, y \\in \\{0, 1 \\} ^ {s _ {i + 1}}} \\left(\\left(\\alpha^ {(i)} \\tilde {m u l t} _ {i + 1} \\left(u ^ {(i)}, x, y\\right) + \\beta^ {(i)} \\tilde {m u l t} _ {i + 1} \\left(v ^ {(i)}, x, y\\right)\\right) \\left(\\tilde {V} _ {i + 1} (x) \\tilde {V} _ {i + 1} (y)\\right) \\right. \\\\ + \\left(\\alpha^ {(i)} \\tilde {a d d} _ {i + 1} \\left(u ^ {(i)}, x, y\\right) + \\beta^ {(i)} \\tilde {a d d} _ {i + 1} \\left(v ^ {(i)}, x, y\\right)\\right) \\left(\\tilde {V} _ {i + 1} (x) + \\tilde {V} _ {i + 1} (y)\\right) \\\\ \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At the end of the sumcheck protocol,  <span class="math">\\mathcal{P}</span>  sends  <span class="math">\\mathcal{V} \\tilde{V}_{i+1}(u^{(i+1)})</span>  and  <span class="math">\\tilde{V}_{i+1}(v^{(i+1)})</span> .</li>

      <li><span class="math">\\mathcal{V}</span>  computes the following and checks if it equals to the last message of the sumcheck. For simplicity, let  <span class="math">Mult_{i+1}(x) = \\tilde{mult}_{i+1}(x, u^{(i+1)}, v^{(i+1)})</span>  and  <span class="math">Add_{i+1}(x) = \\tilde{add}_{i+1}(x, u^{(i+1)}, v^{(i+1)})</span> .</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\alpha^ {(i)} \\operatorname {M u l t} _ {i + 1} \\left(u ^ {(i)}\\right) + \\beta^ {(i)} \\operatorname {M u l t} _ {i + 1} \\left(v ^ {(i)}\\right) \\left(\\tilde {V} _ {i + 1} \\left(u ^ {(i + 1)}\\right) \\tilde {V} _ {i + 1} \\left(v ^ {(i + 1)}\\right)\\right) + \\right. \\\\ \\left(\\alpha^ {(i)} \\tilde {A d d} _ {i + 1} \\left(u ^ {(i)}\\right) + \\beta^ {(i)} \\tilde {A d d} _ {i + 1} \\left(v ^ {(i)}\\right) \\left(\\tilde {V} _ {i + 1} \\left(u ^ {(i + 1)}\\right) + \\tilde {V} _ {i + 1} \\left(v ^ {(i + 1)}\\right)\\right) \\right. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">If all checks in the sumcheck pass,  <span class="math">V</span>  uses  <span class="math">\\tilde{V}_{i+1}(u^{(i+1)})</span>  and  <span class="math">\\tilde{V}_{i+1}(v^{(i+1)})</span>  to proceed to the  <span class="math">(i+1)</span> -th layer. Otherwise,  <span class="math">\\mathcal{V}</span>  outputs reject and aborts.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At the input layer  <span class="math">d</span> ,  <span class="math">\\mathcal{V}</span>  has two claims  <span class="math">\\tilde{V}_d(u^{(d)})</span>  and  <span class="math">\\tilde{V}_d(v^{(d)})</span> .  <span class="math">\\mathcal{V}</span>  queries the oracle of evaluations of  <span class="math">\\tilde{V}_d</span>  at  <span class="math">u^{(d)}</span>  and  <span class="math">v^{(d)}</span>  and checks that they are the same as the two claims. If yes, output accept; otherwise, output reject.</li>

    </ul>

    <p class="text-gray-300">Let  <span class="math">\\mathbb{F}</span>  be a finite field,  <span class="math">\\mathcal{F}</span>  be a family of  <span class="math">\\ell</span> -variate polynomial over  <span class="math">\\mathbb{F}</span> , and  <span class="math">d</span>  be a variable-degree parameter. A zero-knowledge verifiable polynomial delegation scheme (zkVPD) for  <span class="math">f \\in \\mathcal{F}</span>  and  <span class="math">t \\in \\mathbb{F}^{\\ell}</span>  consists of the following algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{pp},\\mathsf{vp})\\gets \\mathsf{KeyGen}(1^{\\lambda},\\ell ,d),</span></li>

      <li>com  <span class="math">\\leftarrow</span>  Commit(f,  <span class="math">r_f</span> , pp),</li>

      <li>{accept, reject}  <span class="math">\\leftarrow</span>  CheckComm(com, vp),</li>

    </ul>

    <p class="text-gray-300"><span class="math">(y,\\pi)\\gets \\mathrm{Open}(f,t,r_f,\\mathsf{pp}),</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\{\\mathrm{accept},\\mathrm{reject}\\} \\gets \\mathrm{Verify}(\\mathrm{com},t,y,\\pi ,\\mathrm{vp})</span></li>

    </ul>

    <p class="text-gray-300">A zkVPD scheme satisfies correctness, soundness and zero knowledge, which we formally define below.</p>

    <p class="text-gray-300">Definition 4. Let  <span class="math">\\mathbb{F}</span>  be a finite field,  <span class="math">\\mathcal{F}</span>  be a family of  <span class="math">\\ell</span> -variate polynomial over  <span class="math">\\mathbb{F}</span> , and  <span class="math">d</span>  be a variable-degree parameter. A zero-knowledge verifiable polynomial delegation scheme (zkVPD) consists of the following algorithms:  <span class="math">(\\mathsf{pp},\\mathsf{vp})\\gets \\mathsf{KeyGen}(1^{\\lambda},\\ell ,d)</span> ,  <span class="math">\\mathsf{com}\\gets \\mathsf{Commit}(f,r_f,\\mathsf{pp})</span> ,  <span class="math">\\{\\mathsf{accept},\\mathsf{reject}\\} \\gets \\mathsf{CheckComm}(\\mathsf{com},\\mathsf{vp})</span> ,  <span class="math">(y,\\pi)\\gets \\mathsf{Open}(f,t,r_f,\\mathsf{pp})</span> ,  <span class="math">\\{\\mathsf{accept},\\mathsf{reject}\\} \\gets \\mathsf{Verify}(\\mathsf{com},t,y,\\pi ,\\mathsf{vp})</span> , such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Perfect Completeness For any polynomial  <span class="math">f \\in \\mathcal{F}</span>  and value  <span class="math">t</span> , the following probability is 1.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr_ {r _ {f}} \\left[ \\begin{array}{l l} (\\mathsf {p p}, \\mathsf {v p}) \\leftarrow \\mathsf {K e y G e n} (1 ^ {\\lambda}, \\ell , d) &amp;amp; \\\\ \\mathsf {c o m} \\leftarrow \\mathsf {C o m m i t} (f, r _ {f}, \\mathsf {p p}): &amp;amp; \\mathsf {C h e c k C o m m} (\\mathsf {c o m}, \\mathsf {v p}) = \\mathsf {a c c e p t} \\wedge \\\\ (y, \\pi) \\leftarrow \\mathsf {O p e n} (f, t, r _ {f}, \\mathsf {p p}) &amp;amp; \\mathsf {V e r i f y} (\\mathsf {c o m}, t, y, \\pi , \\mathsf {v p}) = \\mathsf {a c c e p t} \\end{array} \\right]</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Binding For any PPT adversary  <span class="math">\\mathcal{A}</span>  and benign auxiliary input  <span class="math">z_{1}, z_{2}</span>  the following probability is negligible of  <span class="math">\\lambda</span> :</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} (\\mathsf {p p}, \\mathsf {v p}) \\leftarrow \\mathsf {K e y G e n} (1 ^ {\\lambda}, \\ell , d) &amp;amp; \\mathsf {C h e c k C o m m} (\\mathsf {c o m} ^ {*}, \\mathsf {v p}) = \\mathsf {a c c e p t} \\wedge \\\\ (\\pi^ {*}, \\mathsf {c o m} ^ {*}, y ^ {*}, \\mathsf {s t a t e}) \\leftarrow \\mathcal {A} (1 ^ {\\lambda}, z _ {1}, \\mathsf {p p}): &amp;amp; \\mathsf {V e r i f y} (\\mathsf {c o m} ^ {*}, t ^ {*}, y ^ {*}, \\pi^ {*}, \\mathsf {v p}) = \\mathsf {a c c e p t} \\wedge \\\\ (f ^ {*}, t ^ {*}, r _ {f} ^ {*}) \\leftarrow \\mathcal {A} (1 ^ {\\lambda}, z _ {2}, \\mathsf {s t a t e}, \\mathsf {p p}) &amp;amp; \\mathsf {c o m} ^ {*} = \\mathsf {C o m m i t} (f ^ {*}, r _ {f} ^ {*}, \\mathsf {p p}) \\wedge \\\\ &amp;amp; (y ^ {*}, \\pi^ {*}) = \\mathsf {O p e n} (f ^ {*}, t ^ {*}, r _ {f} ^ {*}, \\mathsf {p p}) \\wedge \\\\ &amp;amp; f ^ {*} (t ^ {*}) \\neq y ^ {*} \\end{array} \\right]</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Zero Knowledge For security parameter  <span class="math">\\lambda</span> , polynomial  <span class="math">f</span> , adversary  <span class="math">\\mathcal{A}</span> , and simulator  <span class="math">\\mathcal{S}</span> , consider the following two experiments:</li>

    </ul>

    <p class="text-gray-300">Real  <span class="math">\\mathcal{A},f(1^{\\lambda})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{pp},\\mathsf{vp})\\gets \\mathsf{KeyGen}(1^{\\lambda},\\ell ,d)</span></li>

      <li><span class="math">\\mathsf{com}\\gets \\mathsf{Commit}(f,r_f,\\mathsf{pp})</span></li>

      <li><span class="math">k\\gets \\mathcal{A}(1^{\\lambda},\\mathrm{com},\\mathrm{vp})</span></li>

      <li>For  <span class="math">i = 1,\\dots,k</span>  repeat</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">t_i\\gets \\mathcal{A}(1^\\lambda ,\\mathrm{com},y_1,\\dots,y_{i - 1},\\pi_1,</span>  ...  <span class="math">\\pi_{i - 1},\\mathrm{vp})</span> (b)  <span class="math">(y_{i},\\pi_{i})\\gets \\mathsf{Open}(f,t_{i},r_{f},\\mathsf{pp})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b\\gets \\mathcal{A}(1^{\\lambda},\\mathrm{com},(y_1,\\dots,y_k,\\pi_1,\\dots,\\pi_k),\\mathsf{vp})</span></li>

      <li>Output  <span class="math">b</span></li>

    </ol>

    <p class="text-gray-300">Ideal  <span class="math">\\mathcal{A},\\mathcal{S}(1^{\\lambda})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{com},\\mathsf{pp},\\mathsf{vp},\\sigma)\\gets \\mathsf{Sim}(1^{\\lambda},\\ell ,d)</span></li>

      <li><span class="math">k\\gets \\mathcal{A}(1^{\\lambda},\\mathrm{com},\\mathrm{vp})</span></li>

      <li>For  <span class="math">i = 1,\\dots,k</span>  repeat:</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">t_i\\gets \\mathcal{A}(1^\\lambda ,\\mathrm{com},y_1,\\dots,y_{i - 1},\\pi_1,</span>  ...  <span class="math">\\pi_{i - 1},\\mathrm{vp})</span> (b)  <span class="math">(y_{i},\\pi_{i},\\sigma)\\gets \\mathsf{Sim}(t_{i},\\sigma ,\\mathsf{pp})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b\\gets \\mathcal{A}(1^{\\lambda},\\mathrm{com},(y_1,\\dots,y_k,\\pi_1,\\dots,\\pi_k),\\mathsf{vp})</span></li>

      <li>Output  <span class="math">b</span></li>

    </ol>

    <p class="text-gray-300">For any PPT adversary  <span class="math">\\mathcal{A}</span>  and all polynomial  <span class="math">f\\in \\mathbb{F}</span> , there exists simulator  <span class="math">\\mathcal{S}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr [ \\operatorname {R e a l} _ {\\mathcal {A}, f} (1 ^ {\\lambda}) = 1 ] - \\Pr [ \\operatorname {I d e a l} _ {\\mathcal {A}, \\mathcal {S}} (1 ^ {\\lambda}) = 1 ]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\operatorname {n e g l} (\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">In this section we present a new algorithm (see Algorithm 6) for the prover of the GKR protocol [32] that runs in linear time for arbitrary layered circuits. Before that, we present some necessary building blocks.</p>

    <p class="text-gray-300">Algorithm 1 <span class="math">\\mathcal{F}\\leftarrow</span> FunctionEvaluations(<span class="math">f,\\mathbf{A},r_{1},\\ldots,r_{\\ell}</span>) 0: Multilinear <span class="math">f</span> on <span class="math">\\ell</span> variables, initial bookkeeping table <span class="math">\\mathbf{A}</span>, random <span class="math">r_{1},\\ldots,r_{\\ell}</span>; 0: All function evaluations <span class="math">f(r_{1},\\ldots,r_{i-1},t,b_{i+1},\\ldots,b_{\\ell})</span>; 1: for <span class="math">i=1,\\ldots,\\ell</span> do 2: for <span class="math">b\\in\\{0,1\\}^{\\ell-i}</span> do // <span class="math">b</span> is both a number and its binary representation. 3: for <span class="math">t=0,1,2</span> do 4: Let <span class="math">f(r_{1},\\ldots,r_{i-1},t,b)=\\mathbf{A}[b]\\cdot(1-t)+\\mathbf{A}[b+2^{\\ell-i}]\\cdot t</span> 5: <span class="math">\\mathbf{A}[b]=\\mathbf{A}[b]\\cdot(1-r_{i})+\\mathbf{A}[b+2^{\\ell-i}]\\cdot r_{i}</span> 6: Let <span class="math">\\mathcal{F}</span> contain all function evaluations <span class="math">f(.)</span> computed at Step 4 7: return <span class="math">\\mathcal{F}</span></p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.1 Linear-time sumcheck for a multilinear function <em>[45]</em></h3>

    <p class="text-gray-300">In <em>[45]</em>, Thaler proposed a linear-time algorithm for the prover of the sumcheck protocol on a multilinear function <span class="math">f</span> on <span class="math">\\ell</span> variables (the algorithm runs in <span class="math">O(2^{\\ell})</span> time). We review this algorithm here. Recall that in the <span class="math">i</span>-th round of the sumcheck protocol the prover sends the verifier the univariate polynomial on <span class="math">x_{i}</span></p>

    <p class="text-gray-300"><span class="math">\\sum_{b_{i+1},\\ldots,b_{\\ell_{i}}\\in\\{0,1\\}}f(r_{1},\\ldots,r_{i-1},x_{i},b_{i+1},\\ldots,b_{\\ell})\\,,</span></p>

    <p class="text-gray-300">where <span class="math">r_{1},\\ldots,r_{i-1}</span> are random values chosen by the verifier in previous rounds. Since <span class="math">f</span> is multilinear, it suffices for the prover to send two evaluations of the polynomial at points <span class="math">t=0</span> and <span class="math">t=1</span>, namely the evaluations</p>

    <p class="text-gray-300"><span class="math">\\sum_{b_{i+1},\\ldots,b_{\\ell_{i}}\\in\\{0,1\\}}f(r_{1},\\ldots,r_{i-1},0,b_{i+1},\\ldots,b_{\\ell})</span> (4)</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\sum_{b_{i+1},\\ldots,b_{\\ell_{i}}\\in\\{0,1\\}}f(r_{1},\\ldots,r_{i-1},1,b_{i+1},\\ldots,b_{\\ell})\\,.</span> (5)</p>

    <p class="text-gray-300">To compute the above sums the prover maintains a <em>bookkeeping table</em> <span class="math">\\mathbf{A}</span> for <span class="math">f</span>. This table, at round <span class="math">i</span>, has <span class="math">2^{\\ell-i+1}</span> entries storing the values</p>

    <p class="text-gray-300"><span class="math">f(r_{1},\\ldots,r_{i-1},b_{i},b_{i+1},\\ldots,b_{\\ell})</span></p>

    <p class="text-gray-300">for all <span class="math">b_{i},\\ldots,b_{\\ell}\\in\\{0,1\\}</span> and is initialized with evaluations of <span class="math">f</span> on the hypercube. For every entry of <span class="math">\\mathbf{A}</span>, the prover subsequently computes, as in Step 4 of Algorithm 1 FunctionEvaluations two values</p>

    <p class="text-gray-300"><span class="math">f(r_{1},\\ldots,r_{i-1},0,b_{i+1},\\ldots,b_{\\ell})\\text{ and }f(r_{1},\\ldots,r_{i-1},1,b_{i+1},\\ldots,b_{\\ell})\\,.</span></p>

    <p class="text-gray-300">Once these function evaluations are in place, the prover can easily sum over them and compute the required sumcheck messages as required by Relations 4 and 5. This is done in Algorithm 2 SumCheck.</p>

    <p class="text-gray-300">Complexity analysis. Both Algorithms 1 and 2 run in <span class="math">O(2^{\\ell})</span> time: The first iteration takes <span class="math">O(2^{\\ell})</span>, the second <span class="math">O(2^{\\ell-1})</span> and so on, and therefore the bound holds.</p>

    <p class="text-gray-300">Algorithm 2 <span class="math">\\{a_{1},\\ldots,a_{\\ell}\\}\\leftarrow</span> SumCheck<span class="math">(f,\\mathbf{A},r_{1},\\ldots,r_{\\ell})</span> 0: Multilinear <span class="math">f</span> on <span class="math">\\ell</span> variables, initial bookkeeping table <span class="math">\\mathbf{A}</span>, random <span class="math">r_{1},\\ldots,r_{\\ell}</span>; 0: <span class="math">\\ell</span> sumcheck messages for <span class="math">\\sum_{x\\in\\{0,1\\}^{\\ell}}f(x)</span>. Each message <span class="math">a_{i}</span> consists of 3 elements <span class="math">(a_{i0},a_{i1},a_{i2})</span>; 1: <span class="math">\\mathcal{F}\\leftarrow</span> FunctionEvaluations<span class="math">(f,\\mathbf{A},r_{1},\\ldots,r_{\\ell})</span> 2: for <span class="math">i=1,\\ldots,\\ell</span> do 3: for <span class="math">t\\in\\{0,1,2\\}</span> do 4: <span class="math">a_{it}=\\sum_{b\\in\\{0,1\\}^{\\ell-i}}f(r_{1},\\ldots,r_{i-1},t,b)</span> // All evaluations needed are in <span class="math">\\mathcal{F}</span>. 5: return <span class="math">\\{a_{1},\\ldots,a_{\\ell}\\}</span>;</p>

    <p class="text-gray-300">Algorithm 3 <span class="math">\\{a_{1},\\ldots,a_{\\ell}\\}\\leftarrow</span> SumCheckProduct<span class="math">(f,\\mathbf{A}_{f},g,\\mathbf{A}_{g},r_{1},\\ldots,r_{\\ell})</span> 0: Multilinear <span class="math">f</span> and <span class="math">g</span>, initial bookkeeping tables <span class="math">\\mathbf{A}_{f}</span> and <span class="math">\\mathbf{A}_{g}</span>, random <span class="math">r_{1},\\ldots,r_{\\ell}</span>; 0: <span class="math">\\ell</span> sumcheck messages for <span class="math">\\sum_{x\\in\\{0,1\\}^{\\ell}}f(x)g(x)</span>. Each message <span class="math">a_{i}</span> consists of 3 elements <span class="math">(a_{i0},a_{i1},a_{i2})</span>; 1: <span class="math">\\mathcal{F}\\leftarrow</span> FunctionEvaluations<span class="math">(f,\\mathbf{A}_{f},r_{1},\\ldots,r_{\\ell})</span> 2: <span class="math">\\mathcal{G}\\leftarrow</span> FunctionEvaluations<span class="math">(g,\\mathbf{A}_{g},r_{1},\\ldots,r_{\\ell})</span> 3: for <span class="math">i=1,\\ldots,\\ell</span> do 4: for <span class="math">t\\in\\{0,1,2\\}</span> do 5: <span class="math">a_{it}=\\sum_{b\\in\\{0,1\\}^{\\ell-i}}f(r_{1},\\ldots,r_{i-1},t,b)\\cdot g(r_{1},\\ldots,r_{i-1},t,b)</span> // All evaluations needed are in <span class="math">\\mathcal{F}</span> and <span class="math">\\mathcal{G}</span>. 6: return <span class="math">\\{a_{1},\\ldots,a_{\\ell}\\}</span>;</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.2 Linear-time sumcheck for products of multilinear functions <em>[45]</em></h3>

    <p class="text-gray-300">The linear-time sumcheck in the previous section can be generalized to a product of two multilinear functions. Let now <span class="math">f</span> and <span class="math">g</span> be two multilinear functions on <span class="math">\\ell</span> variables each, we describe a linear-time algorithm to compute the messages of the prover for the sumcheck on the product <span class="math">f\\cdot g</span>, as proposed in <em>[45]</em>. Note that we cannot use Algorithm 2 here since <span class="math">f\\cdot g</span> is not multilinear. However, similarly with the single-function case, the prover must now send, at round <span class="math">i</span>, the following evaluations at points <span class="math">t=0</span>, <span class="math">t=1</span> and <span class="math">t=2</span></p>

    <p class="text-gray-300"><span class="math">\\sum_{b_{i+1},\\ldots,b_{\\ell_{i}}\\in\\{0,1\\}}f(r_{1},\\ldots,r_{i-1},t,b_{i+1},\\ldots,b_{\\ell})\\cdot g(r_{1},\\ldots,r_{i-1},t,b_{i+1},\\ldots,b_{\\ell})</span></p>

    <p class="text-gray-300">The above can be easily computed by computing evaluations for functions <span class="math">f</span> and <span class="math">g</span> separately using Algorithm 1 and the combining the results using our new Algorithm 3 SumCheckProduct. We now have the following lemma:</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Algorithm SumCheckProduct runs in time <span class="math">O(2^{\\ell})</span></p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">All loops in SumCheckProduct require time <span class="math">2^{\\ell}+2^{\\ell-1}+\\ldots=O(2^{\\ell})</span>. Also SumCheckProduct calls FunctionEvaluations twice (one for <span class="math">f</span> and one for <span class="math">g</span>) and each such call takes <span class="math">O(2^{\\ell})</span> time. ∎</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">3.3 Linear-time sumcheck for GKR functions</p>

    <p class="text-gray-300">Let us now consider the sumcheck problem on a particular class of functions that are relevant for the GKR protocol (that is why we call them GKR functions). In particular we want to compute the sumcheck</p>

    <p class="text-gray-300"><span class="math">\\sum\\nolimits_{x,y\\in\\{0,1\\}^{\\ell}}f_{1}(g,x,y)f_{2}(x)f_{3}(y)\\,,</span> (6)</p>

    <p class="text-gray-300">for a fixed point <span class="math">g\\in\\mathbb{F}^{\\ell}</span>, where <span class="math">f_{2}(x),f_{3}(x):\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span> are multilinear extensions of arrays <span class="math">\\mathbf{A}_{f_{2}},\\mathbf{A}_{f_{3}}</span> of size <span class="math">2^{\\ell}</span>, and function <span class="math">f_{1}:\\mathbb{F}^{3\\ell}\\to\\mathbb{F}</span> is the multilinear extension of a sparse array with <span class="math">O(2^{\\ell})</span> (out of <span class="math">2^{3\\ell}</span> possible) nonzero elements. It is not hard to see that the sumcheck polynomials in GKR given by Equations 2 and 3 satisfy these properties.</p>

    <p class="text-gray-300">We note here that applying Algorithm 1 FunctionEvaluations for this particular class of polynomials would lead to quadratic prover time. This is because <span class="math">f_{1}</span> has <span class="math">2^{2\\ell}</span> variables to sum on yielding <span class="math">O(2^{2\\ell})</span> complexity. However, one could take advantage of the sparsity of <span class="math">f_{1}</span>: the prover can store only the <span class="math">O(2^{\\ell})</span> non-zero values of the bookkeeping table A. This is exactly the approach used in many prior work <em>[49, 54, 25]</em>. However, with this approach, the number of nonzero values that must be considered in Step 2 is always at most <span class="math">2^{\\ell}</span>, since it is not guaranteed that this number will reduce to half (i.e., to <span class="math">2^{\\ell-i}</span>) after every update in Step 5 of Algorithm 1 because it is sparse. Therefore, the overall complexity becomes <span class="math">O(\\ell\\cdot 2^{\\ell})</span>.</p>

    <p class="text-gray-300">In this section we effectively reduce this bound to <span class="math">O(2^{\\ell})</span>. Our protocol divides the sumcheck into two phases: the first <span class="math">\\ell</span> rounds bounding the variables of <span class="math">x</span> to a random point <span class="math">u</span>, and the last <span class="math">\\ell</span> rounds bounding the variables of <span class="math">y</span> to a random point <span class="math">v</span>. The central idea lies in rewriting Equation 6 as follows</p>

    <p class="text-gray-300"><span class="math">\\sum\\nolimits_{x,y\\in\\{0,1\\}^{\\ell}}f_{1}(g,x,y)f_{2}(x)f_{3}(y)</span> <span class="math">=</span> <span class="math">\\sum\\nolimits_{x\\in\\{0,1\\}^{\\ell}}f_{2}(x)\\sum\\nolimits_{y\\in\\{0,1\\}^{\\ell}}f_{1}(g,x,y)f_{3}(y)</span> <span class="math">=</span> <span class="math">\\sum\\nolimits_{x\\in\\{0,1\\}^{\\ell}}f_{2}(x)h_{g}(x)\\,,</span></p>

    <p class="text-gray-300">where <span class="math">h_{g}(x)=\\sum_{y\\in\\{0,1\\}^{\\ell}}f_{1}(g,x,y)f_{3}(y)</span>.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">3.3.1 Phase one.</h4>

    <p class="text-gray-300">With the formula above, in the first <span class="math">\\ell</span> rounds, the prover and the verifier are running exactly a sumcheck on a product of two multilinear functions <span class="math">f_{2}\\cdot h_{g}</span>, since functions <span class="math">f_{2}</span> and <span class="math">h_{g}</span> can be viewed as functions only in <span class="math">x</span>—<span class="math">y</span> can be considered constant (it is always summed on the hypercube). To compute the sumcheck messages for the first <span class="math">\\ell</span> rounds, given their bookkeeping tables, we can call</p>

    <p class="text-gray-300"><span class="math">\\textsf{SumCheckProduct}(h_{g}(x),\\mathbf{A}_{h_{g}},f_{2}(x),\\mathbf{A}_{f_{2}},u_{1},\\ldots,u_{\\ell})</span></p>

    <p class="text-gray-300">in Algorithm 3. By Lemma 1 this will take <span class="math">O(2^{\\ell})</span> time. We now show how to initialize the bookkeeping tables in linear time.</p>

    <p class="text-gray-300">Initializing the bookkeeping tables: Initializing the bookkeeping table for <span class="math">f_{2}</span> in <span class="math">O(2^{\\ell})</span> time is trivial, since <span class="math">f_{2}</span> is a multilinear extension of an array and therefore the evaluations on the hypercube are known. Initializing the bookkeeping table for <span class="math">h_{g}</span> in <span class="math">O(2^{\\ell})</span> time is more challenging but we can leverage the sparsity of <span class="math">f_{1}</span>. Consider the following lemma.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{N}_{x}</span> be the set of <span class="math">(z,y)\\in\\{0,1\\}^{2\\ell}</span> such that <span class="math">f_{1}(z,x,y)</span> is non-zero. Then for all <span class="math">x\\in\\{0,1\\}^{\\ell}</span>, it is <span class="math">h_{g}(x)=\\sum_{(z,y)\\in\\mathcal{N}_{x}}I(g,z)\\cdot f_{1}(z,x,y)\\cdot f_{3}(y)</span>, where <span class="math">I(g,z)=\\prod_{i=1}^{\\ell}((1-g_{i})(1-z_{i})+g_{i}z_{i}))</span>.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">As <span class="math">f_{1}</span> is a multilinear extension, as shown in <em>[45]</em>, we have <span class="math">f_{1}(g,x,y)=\\sum_{z\\in\\{0,1\\}^{\\ell}}I(g,z)f_{1}(z,x,y)</span>, where <span class="math">I</span> is the multilinear extension of the identity polynomial, i.e., <span class="math">I(w,z)=1</span> iff <span class="math">w=z</span> for all <span class="math">w,z\\in\\{0,1\\}^{\\ell}</span>. Therefore, we have</p>

    <p class="text-gray-300"><span class="math">h_{g}(x)=\\sum_{y\\in\\{0,1\\}^{\\ell}}f_{1}(g,x,y)f_{3}(y)=\\sum_{z,y\\in\\{0,1\\}^{\\ell}}I(g,z)f_{1}(z,x,y)f_{3}(y)=\\sum_{(z,y)\\in\\mathcal{N}_{x}}I(g,z)\\cdot f_{1}(z,x,y)\\cdot f_{3}(y)</span></p>

    <p class="text-gray-300">Algorithm 4 <span class="math">\\mathbf{A}_{h_{g}}\\leftarrow\\text{Initialize\\_PhaseOne}(f_{1},f_{3},\\mathbf{A}_{f_{3}},g)</span> 0: Multilinear <span class="math">f_{1}</span> and <span class="math">f_{3}</span>, initial bookkeeping tables <span class="math">\\mathbf{A}_{f_{3}}</span>, random <span class="math">g=g_{1},\\ldots,g_{\\ell}</span>; 0: Bookkeeping table <span class="math">\\mathbf{A}_{h_{g}}</span>; 1: <span class="math">\\mathbf{p}\\mathbf{o}\\mathbf{c}\\mathbf{e}\\mathbf{d}\\mathbf{u}\\mathbf{r}\\mathbf{e}\\mathbf{G}\\leftarrow\\mathbf{P}\\mathbf{r}\\mathbf{e}\\mathbf{c}\\mathbf{o}\\mathbf{m}\\mathbf{p}\\mathbf{u}\\mathbf{t}\\mathbf{e}(g)</span> <span class="math">//\\ G</span> is an array of size <span class="math">2^{\\ell}</span>. 2: Set <span class="math">\\mathbf{G}[0]=1</span> 3: for <span class="math">i=0,\\ldots,\\ell-1</span> do 4: for <span class="math">b\\in\\{0,1\\}^{i}</span> do 5: <span class="math">\\mathbf{G}[b,0]=\\mathbf{G}[b]\\cdot(1-g_{i+1})</span> 6: <span class="math">\\mathbf{G}[b,1]=\\mathbf{G}[b]\\cdot g_{i+1}</span> 7: <span class="math">\\forall x\\in\\{0,1\\}^{\\ell}</span>, set <span class="math">\\mathbf{A}_{h_{g}}[x]=0</span> 8: for every <span class="math">(z,x,y)</span> such that <span class="math">f_{1}(z,x,y)</span> is non-zero do 9: <span class="math">\\mathbf{A}_{h_{g}}[x]=\\mathbf{A}_{h_{g}}[x]+\\mathbf{G}[z]\\cdot f_{1}(z,x,y)\\cdot\\mathbf{A}_{f_{3}}[y]</span> 10: return <span class="math">\\mathbf{A}_{h_{g}}</span>;</p>

    <p class="text-gray-300">Moreover, <span class="math">I(w,z)=\\prod_{i=1}^{\\ell}((1-w_{i})(1-z_{i})+w_{i}z_{i}))</span> is the unique polynomial that evaluates to <span class="math">1</span> iff <span class="math">w=z</span> for all <span class="math">w,z\\in\\{0,1\\}^{\\ell}</span>. As the multilinear extension is unique, we have <span class="math">I(g,z)=\\prod_{i=1}^{\\ell}((1-g_{i})(1-z_{i})+g_{i}z_{i}))</span>. ∎</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">The bookkeeping table <span class="math">\\mathbf{A}_{h_{g}}</span> can be initialized in time <span class="math">O(2^{\\ell})</span>.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As <span class="math">f_{1}</span> is sparse, $\\sum_{x\\in\\{0,1\\}^{\\ell}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{N}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(2^{\\ell})<span class="math">. From Lemma 2, given the evaluations of </span>I(g,z)<span class="math"> for all </span>z\\in\\{0,1\\}^{\\ell}<span class="math">, the prover can iterate all </span>(z,y)\\in\\mathcal{N}_{x}<span class="math"> for all </span>x<span class="math"> to compute </span>\\mathbf{A}_{h_{g}}$. The full algorithm is presented in Algorithm 4.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Procedure <span class="math">\\mathsf{P}\\mathsf{r}\\mathsf{e}\\mathsf{c}\\mathsf{o}\\mathsf{m}\\mathsf{p}\\mathsf{u}\\mathsf{t}\\mathsf{e}(g)</span> is to evaluate <span class="math">\\mathbf{G}[z]=I(g,z)=\\prod_{i=1}^{\\ell}((1-g_{i})(1-z_{i})+g_{i}z_{i}))</span> for <span class="math">z\\in\\{0,1\\}^{\\ell}</span>. By the closed-form of <span class="math">I(g,z)</span>, the procedure iterates each bit of <span class="math">z</span>, and multiples <span class="math">1-g_{i}</span> for <span class="math">z_{i}=0</span> and multiples <span class="math">g_{i}</span> for <span class="math">z_{i}=1</span>. In this way, the size of <span class="math">\\mathbf{G}</span> doubles in each iteration, and the total complexity is <span class="math">O(2^{\\ell})</span>.</p>

    <p class="text-gray-300">Step 8-9 computes <span class="math">h_{g}(x)</span> using Lemma 2. When <span class="math">f_{1}</span> is represented as a map of <span class="math">(z,x,y),f_{1}(z,x,y)</span> for non-zero values, the complexity of these steps is <span class="math">O(2^{\\ell})</span>. In the GKR protocol, this is exactly the representation of a gate in the circuit, where <span class="math">z,x,y</span> are labels of the gate, its left input and its right input, and <span class="math">f_{1}(z,x,y)=1</span>. ∎</p>

    <p class="text-gray-300">With the bookkeeping tables, the prover runs <span class="math">\\mathsf{S}\\mathsf{u}\\mathsf{m}\\mathsf{C}\\mathsf{h}\\mathsf{e}\\mathsf{c}\\mathsf{k}\\mathsf{P}\\mathsf{r}\\mathsf{o}\\mathsf{d}\\mathsf{u}\\mathsf{c}\\mathsf{t}(h_{g}(x),\\mathbf{A}_{h_{g}},f_{2}(x),\\mathbf{A}_{f_{2}},u_{1},\\ldots,u_{\\ell})</span> in Algorithm 3 and the total complexity for phase one is <span class="math">O(2^{\\ell})</span>.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">3.3.2 Phase two.</h4>

    <p class="text-gray-300">At this point, all variables in <span class="math">x</span> have been bounded to random numbers <span class="math">u</span>. In the second phase, the equation to sum on becomes</p>

    <p class="text-gray-300"><span class="math">\\sum\\nolimits_{y\\in\\{0,1\\}^{\\ell}}f_{1}(g,u,y)f_{2}(u)f_{3}(y)</span></p>

    <p class="text-gray-300">Note here that <span class="math">f_{2}(u)</span> is merely a single value which we already computed in phase one. Both <span class="math">f_{1}(g,u,y)</span> and <span class="math">f_{3}(y)</span> are polynomials on <span class="math">y</span> with <span class="math">\\ell</span> variables. Similar to phase one, to compute the messages for the last <span class="math">\\ell</span> rounds we can call</p>

    <p class="text-gray-300"><span class="math">\\mathsf{S}\\mathsf{u}\\mathsf{m}\\mathsf{C}\\mathsf{h}\\mathsf{e}\\mathsf{c}\\mathsf{k}\\mathsf{P}\\mathsf{r}\\mathsf{o}\\mathsf{d}\\mathsf{u}\\mathsf{c}\\mathsf{t}(f_{1}(g,u,y),\\mathbf{A}_{f_{1}},f_{3}(y)\\cdot f_{2}(u),\\mathbf{A}_{f_{3}}\\cdot f_{2}(u),,v_{1},\\ldots,v_{\\ell})\\,.</span></p>

    <p class="text-gray-300">Note here that <span class="math">\\mathbf{A}_{f_{1}}</span> is the bookkeeping table for <span class="math">f_{1}(g,u,y)</span>, not the original sparse function <span class="math">f_{1}(g,x,y)</span></p>

    <p class="text-gray-300">Algorithm 5  <span class="math">\\mathbf{A}_{f_1} \\gets</span>  Initialize_PhaseTwo  <span class="math">(f_1, g, u)</span> Input: Multilinear  <span class="math">f_{1}</span> , random  <span class="math">g = g_{1},\\ldots ,g_{\\ell}</span>  and  <span class="math">u = u_{1},\\ldots ,u_{\\ell}</span> ; Output: Bookkeeping table  <span class="math">\\mathbf{A}_{f_1}</span> ; 1:  <span class="math">\\mathbf{G}\\gets</span>  Precompute  <span class="math">(g)</span> 2:  <span class="math">\\mathbf{U}\\gets</span>  Precompute  <span class="math">(u)</span> 3:  <span class="math">\\forall y\\in \\{0,1\\}^{\\ell}</span> , set  <span class="math">\\mathbf{A}_{f_1}[y] = 0</span> 4: for every  <span class="math">(z,x,y)</span>  such that  <span class="math">f_{1}(z,x,y)</span>  is non-zero do 5:  <span class="math">\\mathbf{A}_{f_1}[y] = \\mathbf{A}_{f_1}[y] + \\mathbf{G}[z]\\cdot \\mathbf{U}[x]\\cdot f_1(z,x,y)</span> 6: return  <span class="math">\\mathbf{A}_{f_1}</span> ;</p>

    <p class="text-gray-300">Algorithm 6  <span class="math">\\{a_1,\\ldots ,a_{2\\ell}\\} \\gets</span>  SumCheckGKR  <span class="math">(f_{1},f_{2},f_{3},u_{1}\\dots ,u_{\\ell},v_{1},\\dots ,v_{\\ell},g)</span> Input: Multilinear extensions  <span class="math">f_{1}(z,x,y)</span>  (with  <span class="math">O(2^{\\ell})</span>  non-zero entries),  <span class="math">f_{2}(x),f_{3}(y)</span>  and their bookkeeping tables  <span class="math">\\mathbf{A}_{f_2},\\mathbf{A}_{f_3}</span>  , randomness  <span class="math">u = u_{1},\\ldots ,u_{\\ell}</span>  and  <span class="math">v = v_{1},\\ldots ,v_{\\ell}</span>  and point  <span class="math">g</span> Output:  <span class="math">2\\ell</span>  sumcheck messages for  <span class="math">\\sum_{x,y\\in \\{0,1\\}^{\\ell}}f_{1}(g,x,y)f_{2}(x)f_{3}(y)</span> 1:  <span class="math">\\mathbf{A}_{h_g}\\gets</span>  Initialize_PhaseOne  <span class="math">(f_1,f_3,\\mathbf{A}_{f_3},g)</span> 2:  <span class="math">\\{a_1,\\dots ,a_\\ell \\} \\gets</span>  SumCheckProduct  <span class="math">(\\sum_{y\\in \\{0,1\\}^\\ell}f_1(g,x,y)f_3(y),\\mathbf{A}_{h_g},f_2,\\mathbf{A}_{f_2},u_1,\\dots ,u_\\ell)</span> 3:  <span class="math">\\mathbf{A}_{f_1}\\gets</span>  Initialize_PhaseTwo  <span class="math">(f_1,g,u)</span> 4:  <span class="math">\\{a_{\\ell +1},\\ldots ,a_{2\\ell}\\} \\gets</span>  SumCheckProduct  <span class="math">(f_1(g,u,y),\\mathbf{A}_{f_1},f_3(y)\\cdot f_2(u),\\mathbf{A}_{f_3}\\cdot f_2(u),v_1,\\dots ,v_\\ell)</span> 5: return  <span class="math">\\{a_1,\\dots ,a_{2\\ell}\\}</span></p>

    <p class="text-gray-300">It now remains to initialize the bookkeeping table for  <span class="math">f_{1}(g,u,y)</span>  efficiently. Similar to phase one, we have the following lemma:</p>

    <p class="text-gray-300">Lemma 4. Let  <span class="math">\\mathcal{N}_g</span>  be the set of  <span class="math">(z,x)\\in \\{0,1\\}^{2\\ell}</span>  such that  <span class="math">f_{1}(z,x,y)</span>  is non-zero. Then for all  <span class="math">y\\in \\{0,1\\}^{\\ell}</span> , it is  <span class="math">f_{1}(g,u,y) = \\sum_{(z,x)\\in \\mathcal{N}_{g}}I(g,z)\\cdot I(u,x)\\cdot f_{1}(z,x,y)</span> .</p>

    <p class="text-gray-300">Proof. This immediately follows from the fact that  <span class="math">f_{1}</span>  is a multilinear extension. We have  <span class="math">f_{1}(g,u,y) = \\sum_{z,y\\in \\{0,1\\}^{\\ell}}I(g,z)\\cdot I(u,x)\\cdot f_{1}(z,x,y)</span> , where the closed from of  <span class="math">I</span>  is given in Lemma 2.</p>

    <p class="text-gray-300">Lemma 5. The bookkeeping table  <span class="math">A_{f_1}</span>  can be initialized in time  <span class="math">O(2^{\\ell})</span> .</p>

    <p class="text-gray-300">Proof. Similar to Algorithm 4, he prover again iterates all non-zero indices of  <span class="math">f_{1}</span>  to compute it using Lemma 4. The full algorithm is presented in Algorithm 5.</p>

    <p class="text-gray-300">We now summarize the final linear-time algorithm for computing the prover messages for the sumcheck protocol on GKR functions. See Algorithm 6 SumCheckGKR.</p>

    <p class="text-gray-300">Theorem 2. Algorithm SumCheckGKR runs in  <span class="math">O(2^{\\ell})</span>  time.</p>

    <p class="text-gray-300">Proof. Follows from Lemmata 1, 3 and 5.</p>

    <p class="text-gray-300">3.3.3 Generalizations of our technique.</p>

    <p class="text-gray-300">Our technique can be extended to sumchecks of the general type</p>

    <p class="text-gray-300"><span class="math">\\sum\\nolimits_{x_{1},x_{2},\\ldots,x_{c}\\in\\{0,1\\}^{c}}f_{0}(g,x_{1},x_{2},\\ldots,x_{c})f_{1}(x_{1})f_{2}(x_{2})...f_{c}(x_{c})\\,,</span></p>

    <p class="text-gray-300">where <span class="math">c</span> is a constant, functions <span class="math">f_{i}</span> are multilinear and <span class="math">f_{0}()</span> is sparse and consists of linearly-many nonzero monomials. We divide the protocol into <span class="math">c</span> phases similarly as above. This generalization captures the sumcheck in the original GKR paper with identity polynomials (see <em>[32]</em>), and our new algorithms also improve the prover time of this to linear.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">3.4 Putting everything together</h3>

    <p class="text-gray-300">The sumcheck protocol in GKR given by Equation 2 can be decomposed into several instances that have the form of Equation 6 presented in the previous section. The term</p>

    <p class="text-gray-300"><span class="math">\\sum_{x,y\\in\\{0,1\\}^{s_{i+1}}}\\tilde{mult}_{i+1}(g,x,y)(\\tilde{V}_{i+1}(x)\\tilde{V}_{i+1}(y))</span></p>

    <p class="text-gray-300">is exactly the same as Equation 6. The term <span class="math">\\sum_{x,y\\in\\{0,1\\}^{s_{i+1}}}\\tilde{add}_{i+1}(g,x,y)(\\tilde{V}_{i+1}(x)+\\tilde{V}_{i+1}(y))</span> can be viewed as:</p>

    <p class="text-gray-300"><span class="math">\\sum_{x,y\\in\\{0,1\\}^{s_{i+1}}}\\tilde{add}_{i+1}(g,x,y)\\tilde{V}_{i+1}(x)+\\sum_{x,y\\in\\{0,1\\}^{s_{i+1}}}\\tilde{add}_{i+1}(g,x,y)\\tilde{V}_{i+1}(y)</span></p>

    <p class="text-gray-300">The first sum can be computed using the same protocol in Algorithm 6 without <span class="math">f_{3}(y)</span>, and the second sum can be computed without <span class="math">f_{2}(x)</span>. The complexity for both cases remains linear. Due to linearity of the sumcheck protocol, the prover can execute these 3 instances simultaneously in every round, and sum up the individual messages and send them to the veriifer.</p>

    <p class="text-gray-300">Combining two claims. After the sumcheck in the GKR protocol is completed, as described in Section 2.3, the prover and the verifier need to combine the two claims about <span class="math">\\tilde{V}_{i+1}</span> received at the end of the sumcheck protocol to one to avoid the exponential blow-up. There are two ways to combine the two claims and we show how to do each of them in linear time.</p>

    <p class="text-gray-300">The second approach using random linear combinations is rather straight forward. After the output layers, <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> execute sumcheck protocol on Equation 3 instead of Equations 2, which still satisfies the properties of Equation 6. One could view it as 6 instances of Equation 6 and the prover time is still linear. Moreover, there is a better way to further improve the efficiency. Taking <span class="math">\\sum_{x,y\\in\\{0,1\\}^{s_{i+1}}}(\\alpha_{i}\\tilde{mult}_{i+1}(u,x,y)+\\beta_{i}\\tilde{mult}_{i+1}(v,x,y))\\tilde{V}_{i+1}(x)\\tilde{V}_{i+1}(y)</span> as an example, in Algorithm 4, the prover runs Precompute twice on <span class="math">u</span> and <span class="math">v</span> to generate two arrays (<span class="math">\\mathbf{G}_{1}</span> and <span class="math">\\mathbf{G}_{2}</span>), and sets <span class="math">\\mathbf{G}[b]=\\alpha_{i}\\mathbf{G}_{1}[b]+\\beta_{i}\\mathbf{G}_{2}[b]</span> for all <span class="math">b</span>. The rest of the algorithms remains the same. This only incurs a small overhead in practice in our implementation, compared to the original algorithm on Equation 6.</p>

    <p class="text-gray-300">Though with the approach above we already have a linear prover GKR protocol, the technique to condense two points to one proposed in the original GKR protocol <em>[32]</em> may still be interesting in some scenarios (e.g., in our implementation, we use this approach in the last layer and only make one query to the multi-linear extension of the input, which is more efficient practice). We present an algorithm to reduce the prover time of this approach to linear in Appendix A.</p>

    <h2 id="sec-26" class="text-2xl font-bold">4 Zero Knowledge Argument Protocols</h2>

    <p class="text-gray-300">In this section, we present the construction of our new zero-knowledge argument system. In <em>[53]</em>, Zhang et al. proposed to combine the GKR protocol with a verifiable polynomial delegation protocol, resulting in an argument system. Later, in <em>[51, 52]</em>, the construction was extended to zero-knowledge, by sending all</p>

    <p class="text-gray-300">the messages in the GKR protocol in homomorphic commitments and performing all the checks by zero-knowledge equality and product testing. This incurs a high overhead for the verifier compared to the plain version without zero-knowledge, as each multiplication becomes an exponentiation and each equality check becomes a <span class="math">\\Sigma</span>-protocol, which is around <span class="math">100\\times</span> slower in practice.</p>

    <p class="text-gray-300">In this paper, we follow the same blueprint of combining GKR and VPD to obtain an argument system, but instead show how to extend it to be zero-knowledge efficiently. In particular, the prover masks the GKR protocol with special random polynomials so that the verifier runs a “randomized” GKR that leaks no extra information and her overhead is small. A similar approach was used by Chiesa et al. in <em>[24]</em>. In the following, we present the zero-knowledge version of each building block, followed by the whole zero-knowledge argument.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">4.1 Zero Knowledge Sumcheck</h3>

    <p class="text-gray-300">As a core step of the GKR protocol, <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> execute a sumcheck protocol on Equation 2, during which <span class="math">\\mathcal{P}</span> sends <span class="math">\\mathcal{V}</span> evaluations of the polynomial at several random points chosen by <span class="math">\\mathcal{V}</span>. These evaluations leak information about the values in the circuit, as they can be viewed as weighted sums of these values.</p>

    <p class="text-gray-300">To make the sumcheck protocol zero-knowledge, we take the approach proposed by Chiesa et al. in <em>[24]</em>, which is masking the polynomial in the sumcheck protocol by a random polynomial. In this approach, to prove</p>

    <p class="text-gray-300"><span class="math">H=\\sum\\nolimits_{x_{1},x_{2},\\ldots,x_{\\ell}\\in\\{0,1\\}}f(x_{1},x_{2},\\ldots,x_{\\ell}),</span></p>

    <p class="text-gray-300">the prover generates a random polynomial <span class="math">g</span> with the same variables and individual degrees of <span class="math">f</span>. She commits to the polynomial <span class="math">g</span>, and sends the verifier a claim <span class="math">G=\\sum\\limits_{x_{1},x_{2},\\ldots,x_{\\ell}\\in\\{0,1\\}}g(x_{1},x_{2},\\ldots,x_{\\ell})</span>. The verifier picks a random number <span class="math">\\rho</span>, and execute a sumcheck protocol with the prover on</p>

    <p class="text-gray-300"><span class="math">H+\\rho G=\\sum\\nolimits_{x_{1},x_{2},\\ldots,x_{\\ell}\\in\\{0,1\\}}(f(x_{1},x_{2},\\ldots,x_{\\ell})+\\rho g(x_{1},x_{2},\\ldots,x_{\\ell})).</span></p>

    <p class="text-gray-300">Construction 1. We assume the existence of a zkVPD protocol defined in Section 2.4. For simplicity, we omit the randomness <span class="math">r_{f}</span> and public parameters <span class="math">\\mathsf{pp},\\mathsf{vp}</span> without any ambiguity. To prove the claim <span class="math">H=\\sum\\limits_{x_{1},x_{2},\\ldots,x_{\\ell}\\in\\{0,1\\}}f(x_{1},x_{2},\\ldots,x_{\\ell})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> selects a polynomial <span class="math">g(x_{1},\\ldots,x_{\\ell})=a_{0}+g_{1}(x_{1})+g_{2}(x_{2})+\\ldots+g_{l}(x_{\\ell})</span>, where <span class="math">g_{i}(x_{i})=a_{i,1}x_{i}+a_{i,2}x_{i}^{2}+\\ldots+a_{i,d}x_{i}^{d}</span> and all <span class="math">a_{i,j}</span>s are uniformly random. <span class="math">\\mathcal{P}</span> sends <span class="math">H=\\sum\\limits_{x_{1},x_{2},\\ldots,x_{\\ell}\\in\\{0,1\\}}f(x_{1},x_{2},\\ldots,x_{\\ell})</span>, <span class="math">G=\\sum\\limits_{x_{1},x_{2},\\ldots,x_{\\ell}\\in\\{0,1\\}}g(x_{1},x_{2},\\ldots,x_{\\ell})</span> and <span class="math">\\mathsf{com}_{g}=\\mathsf{Commit}(g)</span> to <span class="math">\\mathcal{V}</span>.</li>

      <li><span class="math">\\mathcal{V}</span> uniformly selects <span class="math">\\rho\\in\\mathbb{F}^{*}</span>, computes <span class="math">H+\\rho G</span> and sends <span class="math">\\rho</span> to <span class="math">\\mathcal{P}</span>.</li>

      <li><span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> run the sumcheck protocol on</li>

    </ol>

    <p class="text-gray-300"><span class="math">H+\\rho G=\\sum\\limits_{x_{1},x_{2},\\ldots,x_{\\ell}\\in\\{0,1\\}}(f(x_{1},x_{2},\\ldots,x_{\\ell})+\\rho g(x_{1},x_{2},\\ldots,x_{\\ell}))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At the last round of the sumcheck protocol, <span class="math">\\mathcal{V}</span> obtains a claim <span class="math">h_{\\ell}(r_{\\ell})=f(r_{1},r_{2},\\ldots,r_{\\ell})+\\rho g(r_{1},r_{2},\\ldots,r_{\\ell})</span>. <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> opens the commitment of <span class="math">g</span> at <span class="math">r=(r_{1},\\ldots,r_{\\ell})</span> by <span class="math">(g(r),\\pi)\\leftarrow\\mathsf{Open}(g,r),\\mathsf{Verify}(\\mathsf{com}_{g},g(r),r,\\pi)</span>. If <span class="math">\\mathsf{Verify}</span> outputs <span class="math">\\mathsf{reject}</span>, <span class="math">\\mathcal{V}</span> aborts.</li>

      <li><span class="math">\\mathcal{V}</span> computes <span class="math">h_{\\ell}(r_{\\ell})-\\rho g(r_{1},\\ldots,r_{\\ell})</span> and compares it with the oracle access of <span class="math">f(r_{1},\\ldots,r_{\\ell})</span>.</li>

    </ol>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">At the last round of this sumcheck, the prover opens the commitment of <span class="math">g</span> at <span class="math">g(r_{1},\\ldots,r_{\\ell})</span>, and the verifier computes <span class="math">f(r_{1},\\ldots,r_{l})</span> by subtracting <span class="math">\\rho g(r_{1},\\ldots,r_{\\ell})</span> from the last message, and compares it with the oracle access of <span class="math">f</span>. It is shown that as long as the commitment and opening of <span class="math">g</span> are zero-knowledge, the protocol is zero-knowledge. Intuitively, this is because all the coefficients of <span class="math">f</span> are masked by those of <span class="math">g</span>. The soundness still holds because of the random linear combination of <span class="math">f</span> and <span class="math">g</span>.</p>

    <p class="text-gray-300">Unfortunately, the masking polynomial <span class="math">g</span> is as big as <span class="math">f</span>, and opening it to a random point later is expensive. In <em>[24]</em>, the prover sends a PCP oracle of <span class="math">g</span>, and executes a zero-knowledge sumcheck to open it to a random point, which incurs an exponential complexity for the prover. Even replacing it with the zkVPD protocol in <em>[52]</em>, the prover time is slow in practice.</p>

    <p class="text-gray-300">In this paper, we show that it suffices to mask <span class="math">f</span> with a small polynomial to achieve zero-knowledge. In particular, we set <span class="math">g(x_{1},\\ldots,x_{\\ell})=a_{0}+g_{1}(x_{1})+g_{2}(x_{2})+\\ldots+g_{\\ell}(x_{\\ell})</span>, where <span class="math">g_{i}(x_{i})=a_{i,1}x_{i}+a_{i,2}x_{i}^{2}+\\ldots+a_{i,d}x_{i}^{d}</span> is a random univariate polynomial of degree <span class="math">d</span> (<span class="math">d</span> is the variable degree of <span class="math">f</span>). Note here that the size of <span class="math">g</span> is only <span class="math">O(d\\ell)</span>, while the size of <span class="math">f</span> is exponential in <span class="math">\\ell</span>.</p>

    <p class="text-gray-300">The intuition of our improvement is that the prover sends <span class="math">O(d\\ell)</span> messages in total to the verifier during the sumcheck protocol, thus a polynomial <span class="math">g</span> with <span class="math">O(d\\ell)</span> random coefficients is sufficient to mask all the messages and achieve zero-knowledge. We present the full protocol in Construction 1.</p>

    <p class="text-gray-300">The completeness of the protocol holds obviously. The soundness follows the soundness of the sumcheck protocol and the random linear combination in step 2 and 3, as proven in <em>[24]</em>. We give a proof of zero knowledge here.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Theorem 3 (Zero knowledge).</h6>

    <p class="text-gray-300">For every verifier <span class="math">\\mathcal{V}^{<em>}</span> and every <span class="math">\\ell</span>-variate polynomial <span class="math">f:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span> with variable degree <span class="math">d</span>, there exists a simulator <span class="math">\\mathcal{S}</span> such that given access to <span class="math">H=\\sum_{x_{1},x_{2},\\ldots,x_{\\ell}\\in\\{0,1\\}}f(x_{1},x_{2},\\ldots,x_{\\ell})</span>, <span class="math">\\mathcal{S}</span> is able to simulate the partial view of <span class="math">\\mathcal{V}^{</em>}</span> in step 1-4 of Construction 1.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We build the simulator <span class="math">\\mathcal{S}</span> as following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> selects a random polynomial <span class="math">g^{<em>}(x_{1},\\ldots,x_{\\ell})=a_{0}^{</em>}+g_{1}^{<em>}(x_{1})+g_{2}^{</em>}(x_{2})+\\cdots+g_{\\ell}^{<em>}(x_{\\ell})</span>, where <span class="math">g_{i}^{</em>}(x_{i})=a_{i,1}^{<em>}x_{i}+a_{i,2}^{</em>}x_{i}^{2}+\\cdots+a_{i,d}^{<em>}x_{i}^{d}</span>. <span class="math">\\mathcal{S}</span> sends <span class="math">H</span>, <span class="math">G^{</em>}=\\sum\\limits_{x_{1},x_{2},\\cdots,x_{\\ell}\\in\\{0,1\\}}g^{<em>}(x_{1},x_{2},\\cdots,x_{\\ell})</span> and <span class="math">\\mathsf{com}_{g^{</em>}}=\\mathsf{Commit}(g^{*})</span> to <span class="math">\\mathcal{V}</span>.</li>

      <li><span class="math">\\mathcal{S}</span> receives <span class="math">\\rho\\neq 0</span> from <span class="math">\\mathcal{V}^{*}</span>.</li>

      <li><span class="math">\\mathcal{S}</span> selects a polynomial <span class="math">f^{<em>}:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span> with variable degree <span class="math">d</span> uniformly at random conditioning on <span class="math">\\sum\\limits_{x_{1},x_{2},\\cdots,x_{\\ell}\\in\\{0,1\\}}f^{</em>}(x_{1},x_{2},\\cdots,x_{\\ell})=H</span>. <span class="math">\\mathcal{S}</span> then engages in a sumcheck protocol with <span class="math">\\mathcal{V}</span> on <span class="math">H+\\rho G^{<em>}=\\sum\\limits_{x_{1},x_{2},\\cdots,x_{\\ell}\\in\\{0,1\\}}(f^{</em>}(x_{1},x_{2},\\cdots,x_{\\ell})+\\rho g^{*}(x_{1},x_{2},\\cdots,x_{\\ell}))</span></li>

      <li>Let <span class="math">r\\in\\mathbb{F}^{\\ell}</span> be the point chosen by <span class="math">\\mathcal{V}^{<em>}</span> in the sumcheck protocol. <span class="math">\\mathcal{S}</span> runs <span class="math">(g^{</em>}(r),\\pi)\\leftarrow\\mathsf{Open}(g^{*},r)</span> and sends them to <span class="math">\\mathcal{V}</span>.</li>

    </ol>

    <p class="text-gray-300">As both <span class="math">g</span> and <span class="math">g^{*}</span> are randomly selected, and the zkVPD protocol is zero-knowledge, it is obvious that step 1 and 4 in <span class="math">\\mathcal{S}</span> are indistinguishable from those in the real world of Construction 1. It remains to show that the sumchecks in step 3 of both worlds are indistinguishable.</p>

    <p class="text-gray-300">To see that, recall that in round <span class="math">i</span> of the sumcheck protocol, <span class="math">\\mathcal{V}</span> receives a univariate polynomial <span class="math">h_{i}(x_{i})=\\sum\\limits_{b_{i+1},\\ldots,b_{\\ell}\\in\\{0,1\\}}h(r_{1},\\ldots,r_{i-1},x_{i},b_{i+1},\\ldots,b_{\\ell})</span> where <span class="math">h=f+\\rho g</span>. (The view of <span class="math">\\mathcal{V}^{<em>}</span> is defined in the same way with <span class="math">h^{</em>},f^{<em>},g^{</em>}</span> and we omit the repetition in the following.) As the variable degree of <span class="math">f</span> and <span class="math">g</span> is <span class="math">d</span>, <span class="math">\\mathcal{P}</span> sends <span class="math">\\mathcal{V}</span> <span class="math">h_{i}(0),h_{i}(1),\\ldots,h_{i}(d)</span> which uniquely defines <span class="math">h_{i}(x_{i})</span>. These evaluations reveal <span class="math">d+1</span> independent linear constraints on the coefficients of <span class="math">h</span>. In addition, note that when these evaluations are computed honestly by <span class="math">\\mathcal{P}</span>, <span class="math">h_{i}(0)+h_{i}(1)=h_{i-1}(r_{i-1})</span>, as required in the sumcheck protocol. Therefore, in all <span class="math">\\ell</span> rounds of the sumcheck, <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{V}^{<em>}</span> receives <span class="math">\\ell(d+1)-(\\ell-1)=\\ell d+1</span> independent linear constraints on the coefficients of <span class="math">h</span> and <span class="math">h^{</em>}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300"><span class="math">h</span> and <span class="math">h^{<em>}</span> are masked by <span class="math">g</span> and <span class="math">g^{</em>}</span>, each with exactly <span class="math">\\ell d+1</span> coefficients selected randomly, the two linear systems are identically distributed. Therefore, step 3 of the ideal world is indistinguishable from that of the real world.</p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">4.2 Zero knowledge GKR</h3>

    <p class="text-gray-300">To achieve zero-knowledge, we replace the sumcheck protocol in GKR with the zero-knowledge version described in the previous section. However, the protocol still leaks additional information. In particular, at the end of the zero-knowledge sumcheck, <span class="math">\\mathcal{V}</span> queries the oracle to evaluate the polynomial on a random point. When executed on Equation 2, this reveals two evaluations of the polynomial <span class="math">\\tilde{V}_{i}</span> defined by the values in the <span class="math">i</span>-th layer of the circuit: <span class="math">\\hat{V}_{i}(u)</span> and <span class="math">\\tilde{V}_{i}(v)</span>.</p>

    <p class="text-gray-300">To prevent this leakage, Chiesa et al. <em>[24]</em> proposed to replace the multi-linear extension <span class="math">\\tilde{V}_{i}</span> with a low degree extension, such that learning <span class="math">\\hat{V}_{i}(u)</span> and <span class="math">\\hat{V}_{i}(v)</span> does not leak any information about <span class="math">V_{i}</span>. Define a low degree extension of <span class="math">V_{i}</span> as</p>

    <p class="text-gray-300"><span class="math">\\dot{V}_{i}(z)\\stackrel{{\\scriptstyle def}}{{=}}\\tilde{V}_{i}(z)+Z_{i}(z)\\sum\\nolimits_{w\\in\\{0,1\\}^{\\lambda}}R_{i}(z,w),</span> (7)</p>

    <p class="text-gray-300">where <span class="math">Z(z)=\\prod_{i=1}^{s_{i}}z_{i}(1-z_{i})</span>, i.e., <span class="math">Z(z)=0</span> for all <span class="math">z\\in\\{0,1\\}^{s_{i}}</span>. <span class="math">R_{i}(z,w)</span> is a random low-degree polynomial and <span class="math">\\lambda</span> is the security parameter. With this low degree extension, Equation 2 becomes</p>

    <p class="text-gray-300"><span class="math">\\dot{V}_{i}(g)</span> <span class="math">=\\sum\\nolimits_{x,y\\in\\{0,1\\}^{s_{i+1}}}m\\tilde{u}lt_{i+1}(g,x,y)(\\dot{V}_{i+1}(x)\\dot{V}_{i+1}(y))</span> (8) <span class="math">+\\tilde{a}\\tilde{d}d_{i+1}(g,x,y)(\\dot{V}_{i+1}(x)+\\dot{V}_{i+1}(y))+Z_{i}(g)\\sum\\nolimits_{w\\in\\{0,1\\}^{\\lambda}}R_{i}(g,w)</span> <span class="math">=\\sum\\nolimits_{x,y\\in\\{0,1\\}^{s_{i+1}},w\\in\\{0,1\\}^{\\lambda}}(I(\\vec{0},w)\\cdot\\tilde{m}\\tilde{u}lt_{i+1}(g,x,y)(\\dot{V}_{i+1}(x)\\dot{V}_{i+1}(y))</span> (9) <span class="math">+\\tilde{a}\\tilde{d}d_{i+1}(g,x,y)(\\dot{V}_{i+1}(x)+\\dot{V}_{i+1}(y))+I((x,y),\\vec{0})Z_{i}(g)R_{i}(g,w))</span></p>

    <p class="text-gray-300">where <span class="math">I(\\vec{a},\\vec{b})</span> is an identity polynomial <span class="math">I(\\vec{a},\\vec{b})=0</span> iff <span class="math">\\vec{a}=\\vec{b}</span>. The first equation holds because <span class="math">\\dot{V}_{i}</span> agrees with <span class="math">\\tilde{V}_{i}</span> on the Boolean hyper-cube <span class="math">\\{0,1\\}^{s_{i}}</span>, as <span class="math">Z_{i}(z)=0</span> for binary inputs. The second equation holds because the mask in <span class="math">\\dot{V}_{i}</span> is in the form of a “sum” and can be moved into the sumcheck equation.</p>

    <p class="text-gray-300">When executing the zero-knowledge sumcheck protocol on Equation 8, at the end of the protocol, <span class="math">\\mathcal{V}</span> receives <span class="math">\\dot{V}_{i+1}(u)</span> and <span class="math">\\dot{V}_{i+1}(v)</span> for random points <span class="math">u,v\\in\\mathbb{F}^{s_{i+1}}</span> chosen by <span class="math">\\mathcal{V}</span>. They no longer leak information about <span class="math">V_{i+1}</span>, as they are masked by <span class="math">Z_{i+1}(z)\\sum\\nolimits_{w\\in\\{0,1\\}^{\\lambda}}R_{i+1}(z,w)</span> for <span class="math">z=u</span> and <span class="math">z=v</span>. <span class="math">\\mathcal{V}</span> computes <span class="math">\\tilde{m}\\tilde{u}lt_{i+1}(g,u,v)</span> and <span class="math">\\tilde{a}\\tilde{d}d_{i+1}(g,u,v)</span> as before, computes <span class="math">Z_{i}(g),I(\\vec{0},c),I((u,v),\\vec{0})</span> where <span class="math">c\\in\\mathbb{F}^{\\lambda}</span> is a random point chosen by <span class="math">\\mathcal{V}</span> for variable <span class="math">w</span>, opens <span class="math">R_{i}(g,w)</span> at <span class="math">c</span> with <span class="math">\\mathcal{P}</span> through a polynomial commitment, and checks that together with <span class="math">\\dot{V}_{i+1}(u),\\dot{V}_{i+1}(v)</span> received from <span class="math">\\mathcal{P}</span> they are consistent with the last message of the sumcheck.<span class="math">\\mathcal{V}</span> then uses <span class="math">\\dot{V}_{i+1}(u),\\dot{V}_{i+1}(v)</span> to proceed to the next round.</p>

    <p class="text-gray-300">Unfortunately, similar to the zero-knowledge sumcheck, the masking polynomial <span class="math">R_{i}</span> is very large in <em>[24]</em>. Opening <span class="math">R_{i}</span> at a random point takes exponential time for <span class="math">\\mathcal{P}</span> either using a PCP oracle as in <em>[24]</em> or potentially using a zkVPD, as <span class="math">R</span> has <span class="math">s_{i}+2s_{i+1}+\\lambda</span> variables.</p>

    <p class="text-gray-300">In this section, we show that we can set <span class="math">R_{i}</span> to be a small polynomial to achieve zero-knowledge. In particular, <span class="math">R_{i}</span> has only two variables with variable degree 2. This is because in the <span class="math">(i-1)</span>-th round, <span class="math">\\mathcal{V}</span> receives two evaluations of <span class="math">V_{i}</span>, <span class="math">\\dot{V}_{i}(u)</span> and <span class="math">\\dot{V}_{i}(v)</span>, which are masked by <span class="math">\\sum_{w}R_{i}(u,w)</span> and <span class="math">\\sum_{w}R_{i}(v,w)</span>; in the <span class="math">i</span>-th sumcheck, <span class="math">\\mathcal{V}</span> opens <span class="math">R_{i}</span> at <span class="math">R_{i}(u,c)</span> and <span class="math">R_{i}(v,c)</span>. It suffices to make these four evaluations linearly independent, assuming the commitment and opening of <span class="math">R_{i}</span> are using a zkVPD. Therefore, we set the low-degree term in Equation 7 as <span class="math">Z_{i}(z)\\sum\\nolimits_{w\\in\\{0,1\\}}R_{i}(z_{1},w)</span>, i.e. <span class="math">R_{i}</span> only takes two variables, the first variable <span class="math">z_{1}</span> of <span class="math">z</span> and an extra variable <span class="math">w\\in\\{0,1\\}</span> instead of <span class="math">\\{0,1\\}^{\\lambda}</span>, with variable degree 2.</p>

    <p class="text-gray-300">The full protocol is presented in Construction 2. Here we use superscriptions (e.g., <span class="math">u^{(i)}</span>) to denote random numbers or vectors for the <span class="math">i</span>-th layer of the circuit.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">22</p>

    <p class="text-gray-300"><strong>Construction 2.</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>On a layered arithmetic circuit <span class="math">C</span> with <span class="math">d</span> layers and input <span class="math">\\mathsf{in}</span>, the prover <span class="math">\\mathcal{P}</span> sends the output of the circuit <span class="math">\\mathsf{out}</span> to the verifier <span class="math">\\mathcal{V}</span>.</li>

      <li><span class="math">\\mathcal{P}</span> randomly selects polynomials <span class="math">R_{1}(z_{1},w),\\ldots ,R_{d}(z_{1},w):\\mathbb{F}^{2}\\to \\mathbb{F}</span> with variable degree 2. <span class="math">\\mathcal{P}</span> commits to these polynomials by sending <span class="math">\\mathsf{com}_i\\gets \\mathsf{Commit}(R_i)</span> to <span class="math">\\mathcal{V}</span> for <span class="math">i\\in [1,d]</span>.</li>

      <li><span class="math">\\mathcal{V}</span> defines <span class="math">\\dot{V}_0(z) = \\tilde{V}_0(z)</span>, where <span class="math">\\tilde{V}_0(z)</span> is the multilinear extension of out. <span class="math">\\dot{V}_0(z)</span> can be viewed as a special case with <span class="math">R_0(z_1, w)</span> being the 0 polynomial. <span class="math">\\mathcal{V}</span> evaluates it at a random point <span class="math">\\dot{V}_0(g^{(0)})</span> and sends <span class="math">g^{(0)}</span> to <span class="math">\\mathcal{P}</span>.</li>

      <li><span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> execute the zero knowledge sumcheck protocol presented in Construction 1 on</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\dot{V}_{0}(g^{(0)}) = \\sum_{x, y \\in \\{0, 1\\}^{s_{1}}} \\tilde{m u l t}_{1}(g^{(0)}, x, y) (\\dot{V}_{1}(x) \\dot{V}_{1}(y)) \\\\ \\quad + \\tilde{a d d}_{1}(g^{(0)}, x, y) (\\dot{V}_{1}(x) + \\dot{V}_{1}(y)) \\end{array}</span></div>

    <p class="text-gray-300">If <span class="math">\\dot{u}_1^{(1)} = v_1^{(1)}</span>, <span class="math">\\mathcal{P}</span> aborts. At the end of the protocol, <span class="math">\\mathcal{V}</span> receives <span class="math">\\dot{V}_1(u^{(1)})</span> and <span class="math">\\dot{V}_1(v^{(1)})</span>. <span class="math">\\mathcal{V}</span> computes <span class="math">\\tilde{m u l t}_{1}(g^{(0)}, u^{(1)}, v^{(1)})</span>, <span class="math">\\tilde{a d d}_{1}(g^{(0)}, u^{(1)}, v^{(1)})</span> and checks that</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde{m u l t}_{1}(g^{(0)}, u^{(1)}, v^{(1)}) \\dot{V}_{1}(u^{(1)}) \\dot{V}_{1}(v^{(1)}) + \\tilde{a d d}_{1}(g^{(0)}, u^{(1)}, v^{(1)}) (\\dot{V}_{1}(u^{(1)}) + \\dot{V}_{1}(v^{(1)}))</span></div>

    <p class="text-gray-300">equals to the last message of the sumcheck (evaluation oracle).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For layer <span class="math">i = 1, \\ldots, d - 1</span>:</li>

    </ol>

    <p class="text-gray-300">(a) <span class="math">\\mathcal{V}</span> randomly selects <span class="math">\\alpha^{(i)},\\beta^{(i)}\\in \\mathbb{F}</span> and sends them to <span class="math">\\mathcal{P}</span>.</p>

    <p class="text-gray-300">(b) Let <span class="math">Mult_{i+1}(x, y) = \\alpha^{(i)} \\tilde{mult}_{i+1}(u^{(i)}, x, y) + \\beta^{(i)} \\tilde{mult}_{i+1}(v^{(i)}, x, y)</span> and <span class="math">Add_{i+1}(x, y) = \\alpha^{(i)} \\tilde{add}_{i+1}(u^{(i)}, x, y) + \\beta^{(i)} \\tilde{add}_{i+1}(v^{(i)}, x, y)</span>. <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> run the zero knowledge sumcheck on the equation</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\alpha^{(i)} \\dot{V}_{i}(u^{(i)}) + \\beta^{(i)} \\dot{V}_{i}(v^{(i)}) = \\\\ \\sum_{\\substack{x,y\\in \\{0,1\\}^{s_{i + 1}}\\\\ w\\in \\{0,1\\}}}(I(\\vec{0},w)\\cdot Mult_{i + 1}(x,y)(\\dot{V}_{i + 1}(x)\\dot{V}_{i + 1}(y)) \\\\ \\quad + Add_{i + 1}(x, y)(\\dot{V}_{i + 1}(x) + \\dot{V}_{i + 1}(y)) \\\\ \\quad + I((x, y), \\vec{0})(\\alpha^{(i)} Z_{i}(u^{(i)}) R_{i}(u_{1}^{(i)}, w) + \\beta^{(i)} Z_{i}(v^{(i)}) R_{i}(v_{1}^{(i)}, w))) \\end{array}</span></div>

    <p class="text-gray-300">If <span class="math">u_1^{(i + 1)} = v_1^{(i + 1)}</span>, <span class="math">\\mathcal{P}</span> aborts.</p>

    <p class="text-gray-300">(c) At the end of the zero-knowledge sumcheck protocol, <span class="math">\\mathcal{P}</span> sends <span class="math">\\mathcal{V}</span> <span class="math">\\dot{V}_{i+1}(u^{(i+1)})</span> and <span class="math">\\dot{V}_{i+1}(v^{(i+1)})</span>.</p>

    <p class="text-gray-300">(d) <span class="math">\\mathcal{V}</span> computes</p>

    <div class="my-4 text-center"><span class="math-block">a_{i + 1} = \\alpha^{(i)} \\tilde{mult}_{i + 1}(u^{(i)}, u^{(i + 1)}, v^{(i + 1)}) + \\beta^{(i)} \\tilde{mult}_{i + 1}(v^{(i)}, u^{(i + 1)}, v^{(i + 1)})</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">b_{i + 1} = \\alpha^{(i)} \\tilde{add}_{i + 1}(u^{(i)}, u^{(i + 1)}, v^{(i + 1)}) + \\beta^{(i)} \\tilde{add}_{i + 1}(v^{(i)}, u^{(i + 1)}, v^{(i + 1)})</span></div>

    <p class="text-gray-300">locally. <span class="math">\\mathcal{V}</span> computes <span class="math">Z_{i}(u^{(i)}), Z_{i}(v^{(i)}), I(\\vec{0}, c^{(i)}), I((u^{(i + 1)}, v^{(i + 1)}), \\vec{0})</span> locally.</p>

    <p class="text-gray-300">(e) <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> open <span class="math">R_{i}</span> at two points <span class="math">R_{i}(u_{1}^{(i)},c^{(i)})</span> and <span class="math">R_{i}(v_{1}^{(i)},c^{(i)})</span> using Open and Verify.</p>

    <p class="text-gray-300"><span class="math">(\\mathcal{V})</span> <span class="math">= \\mathcal{V}</span>  computes the following as the evaluation oracle and uses it to complete the last step of the zero-knowledge sumcheck.</p>

    <p class="text-gray-300"><span class="math">I(\\vec{0},c^{(i)})(a_{i + 1}(\\dot{V}_{i + 1}(u^{(i + 1)})\\dot{V}_{i + 1}(v^{(i + 1)}))+</span> <span class="math">b_{i + 1}(\\dot{V}_{i + 1}(u^{(i + 1)})+\\dot{V}_{i + 1}(v^{(i + 1)})))+</span> <span class="math">I((u^{(i + 1)},v^{(i + 1)}),\\vec{0})(\\alpha^{(i)}Z_{i}(u^{(i)})R_{i}(u_{1}^{(i)},c^{(i)})+\\beta^{(i)}Z_{i}(v^{(i)})R_{i}(v_{1}^{(i)},c^{(i)}))</span></p>

    <p class="text-gray-300">If all checks in the zero knowledge sumcheck and Verify passes,  <span class="math">\\mathcal{V}</span>  uses  <span class="math">\\dot{V}_{i+1}(u^{(i+1)})</span>  and  <span class="math">\\dot{V}_{i+1}(v^{(i+1)})</span>  to proceed to the  <span class="math">(i+1)</span> -th layer. Otherwise,  <span class="math">\\mathcal{V}</span>  outputs reject and aborts.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At the input layer  <span class="math">d</span> ,  <span class="math">\\mathcal{V}</span>  has two claims  <span class="math">\\dot{V}_d(u^{(d)})</span>  and  <span class="math">\\dot{V}_d(v^{(d)})</span> .  <span class="math">\\mathcal{V}</span>  opens  <span class="math">R_d</span>  at 4 points  <span class="math">R_d(u_1^{(d)},0)</span> ,  <span class="math">R_d(u_1^{(d)},1)</span> ,  <span class="math">R_d(v_1^{(d)},0)</span> ,  <span class="math">R_d(v_1^{(d)},1)</span>  and checks that  <span class="math">\\dot{V}_d(u^{(d)}) = \\tilde{V}_d(u^{(d)}) + Z_d(u^{(d)}) \\sum_{w \\in \\{0,1\\}} R_d(u_1^{(d)},w)</span>  and  <span class="math">\\dot{V}_d(v^{(d)}) = \\tilde{V}_d(v^{(d)}) + Z_d(v^{(d)}) \\sum_{w \\in \\{0,1\\}} R_d(v_1^{(d)},w)</span> , given oracle access to two evaluates of  <span class="math">\\tilde{V}_d</span>  at  <span class="math">u^{(d)}</span>  and  <span class="math">v^{(d)}</span> . If the check passes, output accept; otherwise, output reject.</li>

    </ol>

    <p class="text-gray-300">Theorem 4. Construction 2 is an interactive proof protocol per Definition 1, for a function  <span class="math">f</span>  defined by a layered arithmetic circuit  <span class="math">C</span>  such that  <span class="math">f(\\mathsf{in},\\mathsf{out}) = 1</span>  iff  <span class="math">C(\\mathsf{in}) = \\mathsf{out}</span> . In addition, for every verifier  <span class="math">\\mathcal{V}^<em></span>  and every layered circuit  <span class="math">C</span> , there exists a simulator  <span class="math">S</span>  such that given oracle access to out,  <span class="math">S</span>  is able to simulate the partial view of  <span class="math">\\mathcal{V}^</em></span>  in step 1-5 of Construction 2.</p>

    <p class="text-gray-300">The completeness follows from the construction explained above and the completeness of the zero knowledge sumcheck. The soundness follows the soundness of the GKR protocol with low degree extensions, as proven in [32] and [24]. We give the proof of zero knowledge here.</p>

    <p class="text-gray-300">Proof. With oracle access to out, and the simulator  <span class="math">S_{sc}</span>  of the zero-knowledge sumcheck protocol in Section 4.1 as a subroutine, we construct the simulator  <span class="math">S</span>  as following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span>  sends the out to  <span class="math">\\nu^{*}</span> .</li>

      <li><span class="math">\\mathcal{S}</span>  randomly selects polynomials  <span class="math">R_1^<em>(z_1, w), \\ldots, R_d^</em>(z_1, w): \\mathbb{F}^2 \\to \\mathbb{F}</span>  with variable degree 2.  <span class="math">\\mathcal{S}</span>  commits to these polynomials by sending  <span class="math">\\operatorname{com}_i \\gets \\operatorname{Commit}(R_i^<em>)</span>  to  <span class="math">\\mathcal{V}^</em></span>  for  <span class="math">i \\in [1, d]</span> .</li>

      <li><span class="math">\\mathcal{S}</span>  receives  <span class="math">g^{(0)}</span>  from  <span class="math">\\nu^{*}</span> .</li>

      <li><span class="math">\\mathcal{S}</span>  calls  <span class="math">S_{sc}</span>  to simulate the partial view of the zero knowledge sumcheck protocol on</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\dot {V} _ {0} (g ^ {(0)}) = \\sum_ {x, y \\in \\{0, 1 \\} ^ {s _ {1}}} \\tilde {m u l t} _ {1} (g ^ {(0)}, x, y) (\\dot {V} _ {1} (x) \\dot {V} _ {1} (y)) + \\tilde {a d d} _ {1} (g ^ {(0)}, x, y) (\\dot {V} _ {1} (x) + \\dot {V} _ {1} (y))</span></div>

    <p class="text-gray-300">If  <span class="math">u_1^{(1)} = v_1^{(1)}</span> ,  <span class="math">S</span>  aborts. At the end of the sumcheck,  <span class="math">S</span>  samples  <span class="math">\\dot{V}_1^<em>(u^{(1)})</span>  and  <span class="math">\\dot{V}_1^</em>(v^{(1)})</span>  such that  <span class="math">\\tilde{mult}_1(g^{(0)}, u^{(1)}, v^{(1)})\\dot{V}_1^<em>(u^{(1)})\\dot{V}_1^</em>(v^{(1)}) + \\tilde{add}_1(g^{(0)}, u^{(1)}, v^{(1)})</span>  ( <span class="math">\\dot{V}_1^<em>(u^{(1)}) + \\dot{V}_1^</em>(v^{(1)})</span> ) equals to the last message of the sumcheck.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For layer  <span class="math">i = 1,\\ldots ,d - 1</span>  ..</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">\\mathcal{S}</span>  receives  <span class="math">\\alpha^{(i)},\\beta^{(i)}</span>  from  <span class="math">\\nu^{*}</span> (b) Let  <span class="math">Mult_{i+1}(x,y) = \\alpha^{(i)} \\tilde{mult}_{i+1}(u^{(i)}, x,y) + \\beta^{(i)} \\tilde{mult}_{i+1}(v^{(i)}, x,y)</span>  and  <span class="math">Add_{i+1}(x,y) = \\alpha^{(i)} \\tilde{add}_{i+1}(u^{(i)}, x,y) + \\beta^{(i)} \\tilde{add}_{i+1}(v^{(i)}, x,y)</span> .  <span class="math">S</span>  calls  <span class="math">S_{sc}</span>  to simulate the partial view of the zero knowledge sumcheck protocol on</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\alpha^{(i)} \\dot{V}_{i}(u^{(i)}) + \\beta^{(i)} \\dot{V}_{i}(v^{(i)}) = \\\\ \\sum_{\\substack{x,y\\in \\{0,1\\}^{s_{i + 1}}\\\\ w\\in \\{0,1\\}}}(I(\\vec{0},w)\\cdot Mult_{i + 1}(x,y)(\\dot{V}_{i + 1}(x)\\dot{V}_{i + 1}(y)) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Add_{i + 1}(x, y)(\\dot{V}_{i + 1}(x) + \\dot{V}_{i + 1}(y)) \\\\</li>

      <li>I((x, y), \\vec{0})(\\alpha^{(i)} Z_{i}(u^{(i)}) R_{i}(u_{1}^{(i)}, w) + \\beta^{(i)} Z_{i}(v^{(i)}) R_{i}(v_{1}^{(i)}, w)))</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">If <span class="math">u_{1}^{(i + 1)} = v_{1}^{(i + 1)}</span>, <span class="math">\\mathcal{S}</span> aborts.</p>

    <p class="text-gray-300">(c) At the end of the zero-knowledge sumcheck protocol, if <span class="math">u_{1}^{(i + 1)} = v_{1}^{(i + 1)}</span>, <span class="math">\\mathcal{S}</span> aborts. Otherwise, <span class="math">\\mathcal{S}</span> samples <span class="math">\\dot{V}_{i + 1}^{<em>}(u^{(i + 1)})</span> and <span class="math">\\dot{V}_{i + 1}^{</em>}(v^{(i + 1)})</span> randomly such that the following equals to the last message of the sumcheck protocol.</p>

    <p class="text-gray-300">$$ \\begin{array}{l} I (\\vec {0}, c ^ {(i)}) \\left(a _ {i + 1} \\left(\\dot {V} _ {i + 1} ^ {<em>} \\left(u ^ {(i + 1)}\\right) \\dot {V} _ {i + 1} ^ {</em>} \\left(v ^ {(i + 1)}\\right)\\right) + b _ {i + 1} \\left(\\dot {V} _ {i + 1} ^ {<em>} \\left(u ^ {(i + 1)}\\right) + \\dot {V} _ {i + 1} ^ {</em>} \\left(v ^ {(i + 1)}\\right)\\right)\\right) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>I \\left(\\left(u ^ {(i + 1)}, v ^ {(i + 1)}\\right), \\vec {0}\\right) \\left(\\alpha^ {(i)} Z _ {i} \\left(u ^ {(i)}\\right) R _ {i} ^ {<em>} \\left(u _ {1} ^ {(i)}, c ^ {(i)}\\right) + \\beta^ {(i)} Z _ {i} \\left(v ^ {(i)}\\right) R _ {i} ^ {</em>} \\left(v _ {1} ^ {(i)}, c ^ {(i)}\\right)\\right)</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300"><span class="math">a_{i + 1} = \\alpha^{(i)}\\widetilde{mult}_{i + 1}(u^{(i)},u^{(i + 1)},v^{(i + 1)}) + \\beta^{(i)}\\widetilde{mult}_{i + 1}(v^{(i)},u^{(i + 1)},v^{(i + 1)})</span> and <span class="math">b_{i + 1} = \\alpha^{(i)}\\widetilde{add}_{i + 1}(u^{(i)},u^{(i + 1)},v^{(i + 1)}) + \\beta^{(i)}\\widetilde{add}_{i + 1}(v^{(i)},u^{(i + 1)},v^{(i + 1)})</span>. <span class="math">\\mathcal{S}</span> sends <span class="math">\\dot{V}_{i + 1}(u^{(i + 1)})</span> and <span class="math">\\dot{V}_{i + 1}(v^{(i + 1)})</span> to <span class="math">\\nu^{*}</span>.</p>

    <p class="text-gray-300">(d) <span class="math">\\mathcal{V}^<em></span> computes the corresponding values locally as in step 5(d) of Construction 2. (e) <span class="math">\\mathcal{S}</span> opens <span class="math">R_{i}^{</em>}</span> at two points <span class="math">R_{i}^{<em>}(u_{1}^{(i)},c^{(i)})</span> and <span class="math">R_{i}^{</em>}(v_{1}^{(i)},c^{(i)})</span> using Open. (f) <span class="math">\\mathcal{V}^*</span> performs the checks as in step 5(f) of Construction 2.</p>

    <p class="text-gray-300">Note here that <span class="math">\\mathcal{V}^*</span> can actually behave arbitrarily in step 5(d) and 5(f) above. We include these steps to be consistent with the real world in Construction 2 for the ease of interpretation.</p>

    <p class="text-gray-300">To prove zero-knowledge, step 1,3, 5(a), 5(d) and 5(f) are obviously indistinguishable as <span class="math">\\mathcal{S}</span> only receives messages from <span class="math">\\nu^{<em>}</span>. Step 2 and 5(e) of both worlds are indistinguishable because of the zero knowledge property of the zkVPD, and the fact that <span class="math">R^{</em>}</span> and <span class="math">R</span> are sampled randomly in both worlds. Step 4 and 5(b) are indistinguishable as proven in Theorem 3 for <span class="math">\\mathcal{S}_{sc}</span>.</p>

    <p class="text-gray-300">It remains to consider the messages received at the end of step 4 and in step 5(c), namely <span class="math">\\dot{V}_i(u^{(i)})</span>, <span class="math">\\dot{V}_i(v^{(i)})</span> and <span class="math">\\dot{V}_i^<em>(u^{(i)})</span>, <span class="math">\\dot{V}_i^</em>(v^{(i)})</span> for <span class="math">i = 1, \\ldots, d</span>. In the real world, <span class="math">\\dot{V}_i(z)</span> is masked by <span class="math">\\sum_{w \\in \\{0,1\\}} R_i(z_1, w)</span> (<span class="math">Z(z)</span> is publicly known), thus <span class="math">\\dot{V}_i(u^{(i)})</span> and <span class="math">\\dot{V}_i(v^{(i)})</span> are masked by <span class="math">\\sum_{w \\in \\{0,1\\}} R_i(u_1^{(i)}, w)</span> and <span class="math">\\sum_{w \\in \\{0,1\\}} R_i(v_1^{(i)}, w)</span> correspondingly.</p>

    <p class="text-gray-300">In addition, in step 5(e), <span class="math">\\mathcal{V}^*</span> opens <span class="math">R_{i}</span> at <span class="math">R_{i}(u_{1}^{(i)},c^{(i)})</span> and <span class="math">R_{i}(v_{1}^{(i)},c^{(i)})</span>. To simplify the notation here, we consider only a particular layer and omit the subscription and superscription of <span class="math">i</span>. Let <span class="math">R(z_{1},w) = a_{0} + a_{1}z_{1} + a_{2}w + a_{3}z_{1}w + a_{4}z_{1}^{2} + a_{5}w^{2} + a_{6}z_{1}^{2}w^{2}</span>, where <span class="math">a_0,\\ldots ,a_6</span> are randomly chosen. We can write the four evaluations above as</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c c c c c c c c} 2 &amp;amp; 2 u _ {1} &amp;amp; 1 &amp;amp; u _ {1} &amp;amp; 2 u _ {1} ^ {2} &amp;amp; 1 &amp;amp; u _ {1} ^ {2} \\\\ 2 &amp;amp; 2 v _ {1} &amp;amp; 1 &amp;amp; v _ {1} &amp;amp; 2 v _ {1} ^ {2} &amp;amp; 1 &amp;amp; v _ {1} ^ {2} \\\\ 1 &amp;amp; u _ {1} &amp;amp; c &amp;amp; c u _ {1} &amp;amp; u _ {1} ^ {2} &amp;amp; c ^ {2} &amp;amp; c ^ {2} u _ {1} ^ {2} \\\\ 1 &amp;amp; v _ {1} &amp;amp; c &amp;amp; c v _ {1} &amp;amp; v _ {1} ^ {2} &amp;amp; c ^ {2} &amp;amp; c ^ {2} v _ {1} ^ {2} \\end{array} \\right] \\times \\left[ \\begin{array}{c c c c c c c c} a _ {0} &amp;amp; a _ {1} &amp;amp; a _ {2} &amp;amp; a _ {3} &amp;amp; a _ {4} &amp;amp; a _ {5} &amp;amp; a _ {6} \\end{array} \\right] ^ {T}</span></div>

    <p class="text-gray-300">After row reduction, the left matrix is</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c c c c c c c c} 2 &amp;amp; 2 u _ {1} &amp;amp; 1 &amp;amp; u _ {1} &amp;amp; 2 u _ {1} ^ {2} &amp;amp; 1 &amp;amp; u _ {1} ^ {2} \\\\ 0 &amp;amp; 2 (v _ {1} - u _ {1}) &amp;amp; 0 &amp;amp; v _ {1} - u _ {1} &amp;amp; 2 (u _ {1} ^ {2} - v _ {1} ^ {2}) &amp;amp; 0 &amp;amp; u _ {1} ^ {2} - v _ {1} ^ {2} \\\\ 0 &amp;amp; 0 &amp;amp; 2 c - 1 &amp;amp; (2 c - 1) u _ {1} &amp;amp; 0 &amp;amp; 2 c ^ {2} - 1 &amp;amp; (2 c ^ {2} - 1) u _ {1} ^ {2} \\\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; (2 c - 1) (v _ {1} - u _ {1}) &amp;amp; 0 &amp;amp; 0 &amp;amp; (2 c ^ {2} - 1) (v _ {1} ^ {2} - u _ {1} ^ {2}) \\end{array} \\right]</span></div>

    <p class="text-gray-300">As <span class="math">u_{1} \\neq v_{1}</span>, the matrix has full rank if <span class="math">2c^{2} - 1 \\neq 0 \\mod p</span>, where <span class="math">p</span> is the prime that defines <span class="math">\\mathbb{F}</span>. This holds if <span class="math">2^{-1}</span> is not in the quadratic residue of <span class="math">p</span>, or equivalently <span class="math">p \\not\\equiv 1,7 \\mod 8</span>. In case <span class="math">p \\equiv 1,7 \\mod 8</span>, we can add a check to both the protocol and the simulator to abort if <span class="math">2c^{2} - 1 = 0</span>. This does not affect the proof of zero knowledge, and only reduces the soundness error by a small amount.</p>

    <p class="text-gray-300">Because of the full rank of the matrix, the four evaluations are linearly independent and uniformly distributed, as <span class="math">a_0, \\ldots, a_6</span> are chosen randomly. In the ideal world, <span class="math">R^{<em>}(u_{1}, c)</span> and <span class="math">R^{</em>}(v_{1}, c)</span> are independent and uniformly distributed, and <span class="math">\\hat{V}^{<em>}(u), \\hat{V}^{</em>}(v)</span> are randomly selected subject to a linear constraint (step 5(c)), which is the same as the real world. Therefore, they are indistinguishable in the two worlds, which completes the proof.</p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <h2 id="sec-31" class="text-2xl font-bold">4.3 Zero knowledge VPD</h2>

    <p class="text-gray-300">In this section, we present the instantiations of the zkVPD protocol, as defined in Definition 4. For every intermediate layer <span class="math">i</span>, we use the same zkVPD protocol as proposed by Zhang et al. in [52] to commit and open the masking polynomials <span class="math">g_{i}(x), R_{i}(z_{1}, w)</span>. In fact, as we show in the previous sections, these polynomials are very small (<span class="math">g_{i}</span> is the sum of univariate polynomials and <span class="math">R_{i}</span> has 2 variables with variable degree 2), the zkVPD protocols become very simple. The complexity of KeyGen, Commit, Open, Verify and proof size are all <span class="math">O(s_{i})</span> for <span class="math">g_{i}</span> and are all <span class="math">O(1)</span> for <span class="math">R_{i}</span>. We omit the full protocols due to space limit.</p>

    <p class="text-gray-300">For the zkVPD used for the input layer, we design a customized protocol based on the zkVPD protocol in [52]. Recall that at the end of the GKR protocol, <span class="math">\\mathcal{V}</span> receives two evaluations of the polynomial <span class="math">\\hat{V}_d(z) = \\hat{V}_d(z) + Z_d(z)\\sum_{w\\in \\{0,1\\}}R_d(z_1,w)</span> at <span class="math">z = u^{(d)}</span> and <span class="math">z = v^{(d)}</span>. In our zero knowledge proof protocol, which will be presented in Section 4.4, <span class="math">\\mathcal{P}</span> commits to <span class="math">\\hat{V}_d(z)</span> using the zkVPD at the beginning, and opens it to the two points selected by <span class="math">\\mathcal{V}</span>.</p>

    <p class="text-gray-300">The protocol in [52] works for any polynomial with <span class="math">\\ell</span> variables and any variable degree, and is particularly efficient for multilinear polynomials. We modify the protocol for our zero-knowledge proof scheme and preserve the efficiency. Note that though <span class="math">\\hat{V}_d(z)</span> is a low degree extension of the input, it can be decomposed to the sum of <span class="math">\\hat{V}_d(z)</span>, a multilinear polynomial, and <span class="math">Z_{d}(z)\\sum_{w\\in \\{0,1\\}}R_{d}(z_{1},w)</span>. Moreover, <span class="math">Z_{d}(u^{(d)})</span> and <span class="math">Z_{d}(v^{(d)})</span> can be computed directly by <span class="math">\\mathcal{V}</span>. Therefore, in our construction, <span class="math">\\mathcal{P}</span> commits to <span class="math">\\hat{V}_d(z)</span> and <span class="math">\\sum_{w\\in \\{0,1\\}}R_d(z_1,w)</span> separately, and later opens the sum together given <span class="math">Z_{d}(u^{(d)})</span> and <span class="math">Z_{d}(v^{(d)})</span>, which is naturally supported because of the homomorphic property of the commitment. Another optimization is that unlike other layers of the circuit, <span class="math">R_{d}(z_{1},w)</span> itself is not opened at two points (<span class="math">\\mathcal{V}</span> does not receive <span class="math">R_{d}(u^{(d)},c^{(d)})</span> and <span class="math">R_{d}(v^{(d)},c^{(d)})</span> in Construction 2). Therefore, it suffices to set <span class="math">\\hat{V}_d(z) = \\hat{V}_d(z) + Z_d(z)R_d(z_1)</span>, where <span class="math">R_{d}</span> is a univariate linear polynomial. The full protocol is presented in Construction 3.</p>

    <p class="text-gray-300"><strong>Theorem 5.</strong> Construction 3 is a zero-knowledge verifiable polynomial delegation scheme as defined by Definition 4, under Assumption 1 and 2.</p>

    <p class="text-gray-300">The proof of completeness, soundness and zero knowledge is similar to that of the zkVPD protocol in [52]. We only add an extra univariate linear polynomial <span class="math">R(x_{1})</span>, which does not affect the proof. We omit the proof due to space limit.</p>

    <p class="text-gray-300">In Appendix B, we describe new algorithms to commit and open multilinear extensions directly in linear time. With the new algorithms, KeyGen, Commit and Open takes <span class="math">O(2^{\\ell})</span> field operations and multiplications in the base group of the bilinear map, Verify takes <span class="math">O(\\ell)</span> time and the proof size is <span class="math">O(\\ell)</span>.</p>

    <p class="text-gray-300">5From the reduced matrix, we can see that setting <span class="math">a_2 = a_3 = a_4 = 0</span> does not affect the rank of the matrix, which simplifies the masking polynomial <span class="math">R</span> in practice.</p>

    <p class="text-gray-300">6If one is willing to perform a check like this, we can simplify the masking polynomial <span class="math">R</span> to be multilinear. The reduced matrix will be the first 4 columns of the matrix showed above, and it has full rank if <span class="math">c \\neq 2^{-1}</span>.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Construction 3.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a prime-order finite field. Let <span class="math">\\dot{V}(x):\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span> be an <span class="math">\\ell</span>-variate polynomial such that <span class="math">\\dot{V}(x)=\\tilde{V}(x)+Z(x)R(x_{1})</span>, where <span class="math">\\tilde{V}(x)</span> is a multilinear polynomial, <span class="math">Z(x)=\\prod_{i=1}^{\\ell}x_{i}(1-x_{i})</span> and <span class="math">R(x_{1})=a_{0}+a_{1}x_{1}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{pp},\\mathsf{vp})\\leftarrow\\mathsf{KeyGen}(1^{\\lambda},\\ell)</span>: Select <span class="math">\\alpha,t_{1},t_{2},\\cdots,t_{l},t_{\\ell+1}\\in\\mathbb{F}</span> uniformly at random, run <span class="math">\\mathsf{bp}\\leftarrow\\mathsf{BilGen}(1^{\\lambda})</span> and compute <span class="math">\\mathsf{pp}=(\\mathsf{bp},g^{\\alpha},g^{t_{\\ell+1}},g^{\\alpha t_{\\ell+1}},\\{g^{\\prod_{i\\in W}t_{i}},g^{\\alpha\\prod_{i\\in W}t_{i}}\\}_{W\\in\\mathcal{W}_{\\ell}})</span>, where <span class="math">\\mathcal{W}_{\\ell}</span> is the set of all subsets of <span class="math">\\{1,\\ldots,\\ell\\}</span>. Set <span class="math">\\mathsf{vp}=(\\mathsf{bp},g^{t_{1}},\\ldots,g^{t_{\\ell+1}},g^{\\alpha})</span>.</li>

      <li><span class="math">\\mathsf{com}\\leftarrow\\mathsf{Commit}(\\dot{V},r_{V},r_{R},\\mathsf{pp})</span>: Compute <span class="math">c_{1}=g^{\\tilde{V}(t_{1},t_{2},\\cdots,t_{\\ell})+r_{V}t_{\\ell+1}}</span>, <span class="math">c_{2}=g^{\\alpha(\\tilde{V}(t_{1},t_{2},\\cdots,t_{\\ell})+r_{V}t_{\\ell+1})}</span>, <span class="math">c_{3}=g^{R(t_{1})+r_{R}t_{\\ell+1}}</span> and <span class="math">c_{4}=g^{\\alpha(R(t_{1})+r_{R}t_{\\ell+1})}</span> output the commitment <span class="math">\\mathsf{com}=(c_{1},c_{2},c_{3},c_{4})</span>.</li>

      <li><span class="math">\\{\\mathsf{accept},\\mathsf{reject}\\}\\leftarrow\\mathsf{CheckComm}(\\mathsf{com},\\mathsf{vp})</span>: Output <span class="math">\\mathsf{accept}</span> if <span class="math">e(c_{1},g^{\\alpha})=e(c_{2},g)</span> and <span class="math">e(c_{3},g^{\\alpha})=e(c_{4},g)</span>. Otherwise, output <span class="math">\\mathsf{reject}</span>.</li>

      <li><span class="math">(y,\\pi)\\leftarrow\\mathsf{Open}(\\dot{V},r_{V},r_{R},u,\\mathsf{pp})</span>: Choose <span class="math">r_{1},\\ldots,r_{\\ell}\\in\\mathbb{F}</span> at random, and compute polynomials <span class="math">q_{i}</span> such that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\tilde{V}(x)+r_{V}x_{\\ell+1}+Z(u)(R(x_{1})+r_{R}x_{\\ell+1})-(\\tilde{V}(u)+Z(u)R(u_{1}))=</span> <span class="math">\\sum_{i=1}^{\\ell}(x_{i}-u_{i})(q_{i}(x_{i},\\ldots,x_{\\ell})+r_{i}x_{\\ell+1})+x_{\\ell+1}(r_{V}+r_{R}Z(u)-\\sum_{i=1}^{\\ell}r_{i}(x_{i}-u_{i})).</span></p>

    <p class="text-gray-300">Set <span class="math">\\pi=(\\{g^{q_{i}(t_{i}\\ldots,t_{\\ell})+r_{i}t_{\\ell+1}},g^{\\alpha(q_{i}(t_{i}\\ldots,t_{\\ell})+r_{i}t_{\\ell+1})}\\}_{i\\in[1,\\ell]},\\qquad g^{r_{V}+r_{R}Z(u)-\\sum_{i=1}^{\\ell}r_{i}(t_{i}-u_{i})}</span>, <span class="math">g^{\\alpha(r_{V}+r_{R}Z(u)-\\sum_{i=1}^{\\ell}r_{i}(t_{i}-u_{i}))})</span> and <span class="math">y=\\tilde{V}(u)+Z(u)R(u_{1})</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\{\\mathsf{accept},\\mathsf{reject}\\}\\leftarrow\\mathsf{Verify}(\\mathsf{com},u,y,\\pi,\\mathsf{vp})</span>: Parse <span class="math">\\pi</span> as <span class="math">(\\pi_{i},\\pi_{\\alpha i})</span> for <span class="math">i\\in[1,\\ell+1]</span>. Check <span class="math">e(\\pi_{i},g^{\\alpha})=e(\\pi_{\\alpha i},g)</span> for <span class="math">i\\in[1,\\ell+1]</span>. Check <span class="math">e(c_{1}c_{3}^{Z(u)}/g^{y},g)=\\prod_{i=1}^{\\ell}e(\\pi_{i},g^{t_{i}-u_{i}})\\cdot e(g^{\\pi_{\\ell+1}},g^{t_{\\ell+1}})</span>. Output <span class="math">\\mathsf{accept}</span> if all the checks pass, otherwise, output <span class="math">\\mathsf{reject}</span>.</li>

    </ul>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">4.4 Putting Everything Together</h3>

    <p class="text-gray-300">In this section, we present our zero knowledge argument scheme. At a high level, similar to <em>[51, 52, 53]</em>, <span class="math">\\mathcal{V}</span> can use the GKR protocol to verify the correct evaluation of a circuit <span class="math">C</span> on input <span class="math">x</span> and a witness <span class="math">w</span>, given an oracle access to the evaluation of a polynomial defined by <span class="math">x,w</span> on a random point. We instantiate the oracle using the zkVPD protocol. Formally, we present the construction in Construction 4, which combines our zero knowledge GKR and zkVPD protocols. Similar to the protocols in <em>[51, 52]</em>, Step 6 and 7 are to check that <span class="math">\\mathcal{P}</span> indeed uses <span class="math">x</span> as the input to the circuit.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Theorem 6.</h6>

    <p class="text-gray-300">For an input size <span class="math">n</span> and a finite field <span class="math">\\mathbb{F}</span>, Construction 4 is a zero knowledge argument for the relation</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{R}=\\{(C,x;w):C\\in\\mathcal{C}_{\\mathbb{F}}\\wedge</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq n\\wedge C(x;w)=1\\},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">as defined in Definition 2, under Assumption 1 and 2. Moreover, for every <span class="math">(C,x;w)\\in\\mathcal{R}</span>, the running time of <span class="math">\\mathcal{P}</span> is $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> field operations and </span>O(n)<span class="math"> multiplications in the base group of the bilinear map. The running time of </span>\\mathcal{V}<span class="math"> is </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d\\cdot\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> if </span>C<span class="math"> is log-space uniform with </span>d<span class="math"> layers. </span>\\mathcal{P}<span class="math"> and </span>\\mathcal{V}<span class="math"> interact </span>O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> rounds and the total communication (proof size) is </span>O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. In case </span>d<span class="math"> is </span>\\mathsf{polylog}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, the protocol is a succinct argument.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof Sketch. The correctness and the soundness follow from those of the two building blocks, zero knowledge GKR and zkVPD, by Theorem 4 and 5.</p>

    <p class="text-gray-300">To prove zero knowledge, consider a simulator <span class="math">\\mathcal{S}</span> that calls the simulator <span class="math">\\mathcal{S}_{GKR}</span> of zero knowledge GKR given in Section 4.2 as a subroutine, which simulates the partial view up to the input layer. At the input layer, the major challenge is that <span class="math">\\mathcal{S}</span> committed to (a randomly chosen) <span class="math">\\dot{V}_{d}^{*}</span> at the beginning of the protocol, before</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Construction 4.</h6>

    <p class="text-gray-300">Let <span class="math">\\lambda</span> be the security parameter, <span class="math">\\mathbb{F}</span> be a prime field, <span class="math">n</span> be an upper bound on input size, and <span class="math">S</span> be an upper bound on circuit size. We use <span class="math">\\mathsf{VPD}_{1},\\mathsf{VPD}_{2},\\mathsf{VPD}_{3}</span> to denote the zkVPD protocols for input layer, masking polynomials <span class="math">g_{i}</span> and <span class="math">R_{i}</span> described in Construction 2.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(1^{\\lambda},n,S)</span>: run <span class="math">(\\mathsf{pp}_{1},\\mathsf{vp}_{1})\\leftarrow\\mathsf{VPD}_{1}.\\mathsf{KeyGen}(1^{\\lambda},\\log n)</span>, <span class="math">(\\mathsf{pp}_{2},\\mathsf{vp}_{2})\\leftarrow\\mathsf{VPD}_{2}.\\mathsf{KeyGen}(1^{\\lambda},\\log S)</span>, <span class="math">(\\mathsf{pp}_{3},\\mathsf{vp}_{3})\\leftarrow\\mathsf{VPD}_{3}.\\mathsf{KeyGen}(1^{\\lambda})</span>. Output <span class="math">\\mathsf{pk}=(\\mathsf{pp}_{1},\\mathsf{pp}_{2},\\mathsf{pp}_{3})</span> and <span class="math">\\mathsf{vk}=(\\mathsf{vp}_{1},\\mathsf{vp}_{2},\\mathsf{vp}_{3})</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\langle\\mathcal{P}(\\mathsf{pk},w),\\mathcal{V}(\\mathsf{vk})\\rangle(x)</span>: Let <span class="math">C</span> be a layered arithmetic circuit over <span class="math">\\mathbb{F}</span> with <span class="math">d</span> layers, input <span class="math">x</span> and witness <span class="math">w</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq n<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq S<span class="math"> and </span>C(x;w)=1<span class="math">. Without loss of generality, assume </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{m}-1<span class="math"> for some </span>m\\in\\mathbb{N}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> selects a random bivariate polynomial <span class="math">R_{d}</span> with variable degree 2 and commits to the input of <span class="math">C</span> by sending <span class="math">\\mathsf{com}_{d}\\leftarrow\\mathsf{VPD}_{1}.\\mathsf{Commit}(\\hat{V}_{d},r_{V},r_{R},\\mathsf{pp}_{1})</span> to <span class="math">\\mathcal{V}</span>, where <span class="math">\\hat{V}_{d}</span> is the multilinear extension of array <span class="math">(x;w)</span> and <span class="math">\\hat{V}_{d}=\\tilde{V}_{d}+R_{d}</span></li>

      <li><span class="math">\\mathcal{V}</span> runs <span class="math">\\mathsf{VPD}_{1}.\\mathsf{CheckComm}(\\mathsf{com}_{d},\\mathsf{vp}_{1})</span>. If it outputs reject, <span class="math">\\mathcal{V}</span> aborts and outputs reject.</li>

      <li><span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> execute Step 1-5 of the zero knowledge GKR protocol in Construction 2, with the zkVPDs instantiated with <span class="math">\\mathsf{VPD}_{2}</span> and <span class="math">\\mathsf{VPD}_{3}</span>. If Construction 2 rejects, <span class="math">\\mathcal{V}</span> outputs reject and aborts. Otherwise, by the end of this step, <span class="math">\\mathcal{V}</span> receives two claims of <span class="math">\\hat{V}_{d}</span> at <span class="math">u^{(d)}</span> and <span class="math">v^{(d)}</span>.</li>

      <li><span class="math">\\mathcal{P}</span> runs <span class="math">(y_{1},\\pi_{1})\\leftarrow\\mathsf{VPD}_{1}.\\mathsf{Open}(\\hat{V},r_{V},r_{R},u^{(d)},\\mathsf{pp}_{1})</span>, <span class="math">(y_{2},\\pi_{2})\\leftarrow\\mathsf{VPD}_{1}.\\mathsf{Open}(\\hat{V},r_{V},r_{R},v^{(d)},\\mathsf{pp}_{1})</span> and sends <span class="math">y_{1},\\pi_{1},y_{2},\\pi_{2}</span> to <span class="math">\\mathcal{V}</span>.</li>

      <li><span class="math">\\mathcal{V}</span> runs <span class="math">\\mathsf{Verify}(\\mathsf{com}_{d},u^{(d)},y_{1},\\pi_{1},\\mathsf{vp}_{1})</span> and <span class="math">\\mathsf{Verify}(\\mathsf{com}_{d},v^{(d)},y_{2},\\pi_{2},\\mathsf{vp}_{1})</span> and output reject if either check fails. Otherwise, <span class="math">\\mathcal{V}</span> checks <span class="math">\\hat{V}_{d}(u^{(d)})=y_{1}</span> and <span class="math">\\hat{V}_{d}(v^{(d)})=y_{2}</span>, and rejects if either fails.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6. <span class="math">\\mathcal{V}</span> computes the multilinear extension of input <span class="math">x</span> at a random point $r_{x}\\in\\mathbb{F}^{\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and sends </span>r_{x}<span class="math"> to </span>\\mathcal{P}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">knowing the points <span class="math">u^{(d)},v^{(d)}</span> to evaluate on. If <span class="math">\\mathcal{S}</span> opens the commitment honestly, with high probability the evaluations are not consistent with the last message of the GKR (sumcheck in layer <span class="math">d-1</span>) and a malicious <span class="math">\\mathcal{V}^{*}</span> can distinguish the ideal world from the real world. In our proof, we resolve this issue by using the simulator <span class="math">\\mathcal{S}_{VPD}</span> of our zkVPD protocol. Given the trapdoor <span class="math">\\mathsf{trap}</span> used in <span class="math">\\mathsf{KeyGen}</span>, <span class="math">\\mathcal{S}_{VPD}</span> is able to open the commitment to any value in zero knowledge, and in particular it opens to those messages that are consistent with the GKR protocol in our scheme, which completes the construction of <span class="math">\\mathcal{S}</span>.</p>

    <p class="text-gray-300">The complexity of our zero knowledge argument scheme follows from our new GKR protocol with linear prover time, and the complexity of the zkVPD protocol for the input layer analyzed in Section 4.3. The masking polynomials <span class="math">g_{i},R_{i}</span> and their commitments and openings introduce no asymptotic overhead and are efficient in practice.</p>

    <p class="text-gray-300">Removing interaction. Our construction can be made non-interactive in the random oracle model using Fiat—Shamir heuristic <em>[28]</em>. Though GKR protocol is not constant round, recent results <em>[14, 22]</em> show that applying Fiat-Shamir only incurs a polynomial soundness loss in the number of rounds in GKR. In our implementation, the GKR protocol is on a 254-bit prime field matching the bilinear group used in the zkVPD. The non-interactive version of our system provides a security level of 100+ bits.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">5 Implementation and Evaluation</p>

    <p class="text-gray-300">Software. We fully implement Libra, our new zero knowledge proof system in C++. There are around 3000 lines of code for the zkGKR protocol, 1000 lines for the zkVPD protocol and 700 lines for circuit generators. Our system provides an interface to take a generic layered arithmetic circuit and turn it into a zero knowledge proof. We implement a new class for large integers named u512, and use it together with the GMP <em>[2]</em> library for large numbers and field arithmetic. We use the ate-pairing <em>[1]</em> library on a 254-bit elliptic curve for the bilinear map used in zkVPD. We plan to open-source our system.</p>

    <p class="text-gray-300">Hardware. We run all of the experiments on Amazon EC2 c5.9xlarge instances with 70GB of RAM and Intel Xeon platinum 8124m CPU with 3GHz virtual core. Our current implementation is not parallelized and we only use a single CPU core in the experiments. We report the average running time of 10 executions.</p>

    <p class="text-gray-300">More gate types with no overhead. We first present a concrete optimization we developed during the implementation to support various types of gates with no extra overhead. In our protocol in Section 3 and 4, we only consider addition and multiplication gates, as they are enough to represent all arithmetic circuits. However, in practice, the size of the circuit can be reduced significantly if we introduce other types of gate. The GKR protocol still works with these new gates, but they incur an overhead on the prover time for a circuit of the same size. Therefore, in prior work such as <em>[48, 54]</em>, this is considered as a trade-off.</p>

    <p class="text-gray-300">Our protocol supports any gate with fan-in <span class="math">\\leq 2</span> and degree <span class="math">\\leq 2</span> with no overhead on the prover. Recall that in the GKR protocol, the values in layer <span class="math">i</span> is represented as a sumcheck of values in layer <span class="math">i+1</span> and the wiring predicates, as shown in Equation 2. With a set of gate types <span class="math">\\mathcal{T}</span>, we can write the polynomial in the sum as</p>

    <p class="text-gray-300"><span class="math">\\sum_{j\\in\\mathcal{T}}\\tilde{gate}_{i}^{(j)}(g,x,y)G_{i}^{(j)}(\\tilde{V}_{i+1}(x),\\tilde{V}_{i+1}(x)),</span></p>

    <p class="text-gray-300">where <span class="math">G_{i}^{(j)})</span> is the computation of gate type <span class="math">j</span> (e.g., for addition gates, <span class="math">G_{i}^{(j)}(\\tilde{V}_{i+1}(x),\\tilde{V}_{i+1}(x))=\\tilde{V}_{i+1}(x)+\\tilde{V}_{i+1}(x))</span>. As the gates have fan-in <span class="math">\\leq 2</span> and degree <span class="math">\\leq 2</span>, <span class="math">G_{i}^{(j)}</span> has up to 2 variables and total degree at most 2 for all <span class="math">j</span>. Therefore, each <span class="math">G_{i}^{(j)}</span> can be expressed explicitly as <span class="math">a_{0}+a_{1}\\tilde{V}_{i+1}(x)+a_{2}\\tilde{V}_{i+1}(y)+a_{3}\\tilde{V}_{i+1}(x)\\tilde{V}_{i+1}(y)+a_{4}\\tilde{V}_{i+1}(x)^{2}+a_{5}\\tilde{V}_{i+1}(y)^{2}</span>, at most 6 nonzero monomials. The prover can then combine all the wiring predicates <span class="math">\\tilde{gate}_{i}^{(j)}(g,x,y)</span> for the same monomial through a summation. With this approach, when generating the proof in Algorithm 4 and 5, the prover only allocates one array for each monomial, and initializes all 6 arrays with one scan through all the gates in Init_PhaseOne and Init_PhaseTwo. In this way, the prover time remains the same regardless of the number of gate types.</p>

    <p class="text-gray-300">In our experiments, useful types of gates include subtraction, relay, multiply by constant, <span class="math">x(1-x)</span> for binary check, NOT,AND,OR,XOR, etc.</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">5.1 Improvements on GKR protocols</h3>

    <p class="text-gray-300">In this section, we compare the performace of our new GKR protocol with linear prover time with all variants of GKR in the literature on different circuits.</p>

    <p class="text-gray-300">Methodology and benchmarks. For fair comparisons, we re-implement all of these variants in C++ with the same libraries. The variants include: (1) <span class="math">O(C)</span> for regular circuits, proposed in <em>[45]</em>, where the two inputs of a gate can be described by two mapping functions with constant size in constant time. See <em>[45]</em> for the formal definition of regular circuits. (2) <span class="math">O(C+C^{\\prime}\\log C^{\\prime})</span> for data-parallel circuits with a small copy of size <span class="math">C^{\\prime}</span>, proposed in <em>[49]</em>. (3) <span class="math">O(C\\log C^{\\prime})</span> for circuits with non-connected different copies of size <span class="math">C^{\\prime}</span>, proposed in <em>[54]</em>. (4) <span class="math">O(C\\log C)</span> for arbitrary circuits, proposed in <em>[25]</em>.</p>

    <p class="text-gray-300">We compare our GKR protocol to these variants on the benchmarks below:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Matrix multiplication: <span class="math">\\mathcal{P}</span> proves to <span class="math">\\mathcal{V}</span> that it knows two matrices whose product equals a public matrix.</li>

    </ul>

    <p class="text-gray-300">The representation of this function with an arithmetic circuit is highly regular. We evaluate on different</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Matrix multiplication</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Matrix size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4x4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16x16</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">64x64</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">256x256</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">[45]</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0003s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.006s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.390s</td>

            <td class="px-3 py-2 border-b border-gray-700">29.0s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Ours</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0004s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.014s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.788s</td>

            <td class="px-3 py-2 border-b border-gray-700">50.0s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Image scaling</td>

            <td class="px-3 py-2 border-b border-gray-700">#pixels</td>

            <td class="px-3 py-2 border-b border-gray-700">112x112</td>

            <td class="px-3 py-2 border-b border-gray-700">176x176</td>

            <td class="px-3 py-2 border-b border-gray-700">560x560</td>

            <td class="px-3 py-2 border-b border-gray-700">1072x1072</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">[49]</td>

            <td class="px-3 py-2 border-b border-gray-700">0.445s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.779s</td>

            <td class="px-3 py-2 border-b border-gray-700">7.54s</td>

            <td class="px-3 py-2 border-b border-gray-700">29.2s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Ours</td>

            <td class="px-3 py-2 border-b border-gray-700">0.337s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.25s</td>

            <td class="px-3 py-2 border-b border-gray-700">19.8s</td>

            <td class="px-3 py-2 border-b border-gray-700">79.2s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Image scaling with different parameters</td>

            <td class="px-3 py-2 border-b border-gray-700">#pixels</td>

            <td class="px-3 py-2 border-b border-gray-700">112x112</td>

            <td class="px-3 py-2 border-b border-gray-700">176x176</td>

            <td class="px-3 py-2 border-b border-gray-700">560x560</td>

            <td class="px-3 py-2 border-b border-gray-700">1072x1072</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">[53]</td>

            <td class="px-3 py-2 border-b border-gray-700">5.45s</td>

            <td class="px-3 py-2 border-b border-gray-700">21.8s</td>

            <td class="px-3 py-2 border-b border-gray-700">348s</td>

            <td class="px-3 py-2 border-b border-gray-700">1441s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Ours</td>

            <td class="px-3 py-2 border-b border-gray-700">0.329s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.22s</td>

            <td class="px-3 py-2 border-b border-gray-700">19.3s</td>

            <td class="px-3 py-2 border-b border-gray-700">77.2s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Random circuit</td>

            <td class="px-3 py-2 border-b border-gray-700">#gates per layer</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">212</td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">[25]</td>

            <td class="px-3 py-2 border-b border-gray-700">0.008s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.179s</td>

            <td class="px-3 py-2 border-b border-gray-700">3.79s</td>

            <td class="px-3 py-2 border-b border-gray-700">83.1s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Ours</td>

            <td class="px-3 py-2 border-b border-gray-700">0.002s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.039s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.635s</td>

            <td class="px-3 py-2 border-b border-gray-700">10.8s</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Prover time of our linear GKR and previous GKR variants.</p>

    <p class="text-gray-300">dimensions from  <span class="math">4 \\times 4</span>  to  <span class="math">256 \\times 256</span>  and the elements in the matrices are 32-bit integers.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Image scaling: It computes a low-resolution image by scaling from a high-resolution image. We use the classic Lanczos re-sampling [46] method. It computes each pixel of the output as the convolution of the input with a sliding window and a kernel function defined as:  <span class="math">k(x) = \\mathrm{sinc}(x) / \\mathrm{sinc}(ax)</span> , if  <span class="math">-a &amp;lt; x &amp;lt; a</span> ;  <span class="math">k(x) = 0</span> , otherwise, where  <span class="math">a</span>  is the scaling parameter and  <span class="math">\\mathrm{sinc}(x) = \\sin(x) / x</span> . This function is data parallel, where each sub-circuit computes the same function to generate one pixel of the output image. We evaluate by fixing the window size as  <span class="math">16 \\times 16</span>  and increase the image size from  <span class="math">112 \\times 112</span>  to  <span class="math">1072 \\times 1072</span> . The pixels are 8-bit integers for greyscale images.</li>

      <li>Image scaling of different parameters: It is the same computation as above with different scaling parameters in the kernel function for different pixels. The circuit of this function consists of different sub-copies. We evaluate it with the same image sizes as above.</li>

      <li>Random circuit: It is randomly generated layered circuit. We randomly sample the type of each gate, input value and the wiring patterns. We fix the depth as 3 and increase the number of gates per layer from  <span class="math">2^{8}</span>  to  <span class="math">2^{20}</span> .</li>

    </ul>

    <p class="text-gray-300">To be consistent with the next section, all the protocols are executed on a 254-bit prime field. This does not affect the comparison at all, as all the protocols are in the same field. In Table 2, we report the prover time of the protocols. The proof size and the verification time of all the variants are similar.</p>

    <p class="text-gray-300">Results. As shown in Table 2, the performance of our GKR protocol is comparable to those special protocols for structured circuits, and much better than the state-of-the-art on generic circuits. For example, for matrix multiplication, our protocol is slower by  <span class="math">1.3 - 2.4 \\times</span> , because the protocol in [45] writes the wiring of matrix multiplication explicitly and does not need to compute  <span class="math">a\\bar{d}d</span>  and  <span class="math">m\\bar{u}t</span> . For image scaling, our protocol is slower by  <span class="math">2.5 - 4 \\times</span> . This gap would become even smaller when the size of each sub-copy is larger. Here we use a small  <span class="math">16 \\times 16</span>  block, while the number of copies is 49-4489.</p>

    <p class="text-gray-300">For image scaling with different parameters and generic random circuits, our protocol has a speedup of  <span class="math">4 - 8 \\times</span> , and the speedup will increase with the scale of the circuits, as indicated by the complexity.</p>

    <p class="text-gray-300">Besides the speedup on complicated circuits, a significant advantage of our new GKR protocol is on the prover interface of the system. In prior work such as [49, 54], as the protocols are particularly efficient for structured circuits, the circuits must be represented as small copies and the numbers of each copy. Even worse, the structure is explored per layer of the circuit, making the numbers of each copy potentially different in different layers. (E.g., 6 gates may be considered 3 copies with 2 gates and 2 copies with 3 gates in two different layers for efficiency purposes.) This constraint makes the interface of these systems hard to use and generalize. Our result gives a unified solution for arbitrary circuits, and it is the main reason that our prover can take the description of any layered arithmetic circuit potentially generated by other tools like Verilog.</p>

    <p class="text-gray-300">5.2 Comparing to Other ZKP Schemes</p>

    <p class="text-gray-300">In this section, we show the performance of Libra as a whole and compare it with several state-of-the-art zero knowledge proof systems.</p>

    <p class="text-gray-300">Methodology. We compare with the following systems: libSNARK <em>[15]</em>, Ligero <em>[7]</em>, libSTARK <em>[10]</em>, Hyrax <em>[51]</em>, Bulletproofs <em>[18]</em> and Aurora <em>[13]</em>. See Section 1 for more explanations of these systems and their asymptotic.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>libSNARK: We use jsnark <em>[4]</em> to write the circuits (rank one constraint system (R1CS)), which compiles them to zero knowledge proofs using the libSNARK backend <em>[6]</em>.</li>

      <li>Ligero: As the system is not open-source, we use the same number reported in <em>[7]</em> on computing hashes.</li>

      <li>libSTARK: After communications with the authors of <em>[10]</em>, we obtain numbers for proving the same number of hashes in the 3rd benchmark below from the authors. The experiments are executed on a server with 512GB of DDR3 RAM (1.6GHz) and 16 cores (2 threads per core) at speed of 3.2GHz.</li>

      <li>Hyrax: We use the open-source implementation of the system at <em>[3]</em>.</li>

      <li>Bulletproofs: We use the system re-implemented by <em>[51]</em> at <em>[3]</em> for the first two benchmarks. We obtain numbers for proving the same number of hashes in the 3rd benchmark through communications with the authors of <em>[18]</em>.</li>

      <li>Aurora: As a recently accepted paper, the system is not available and we extrapolate its performance using the numbers reported in the paper <em>[13]</em> for circuits with <span class="math">2^{10}-2^{20}</span> R1CS constrains.</li>

    </ul>

    <p class="text-gray-300">Benchmarks. We evaluate the systems on three benchmarks: matrix multiplication, image scaling and Merkle Tree <em>[42]</em>, which are used in <em>[51]</em>. Matrix multiplication and image scaling are the same as explained in Section 5.1. In the third benchmark, <span class="math">\\mathcal{P}</span> proves to <span class="math">\\mathcal{V}</span> that it knows the value of the leaves of a Merkle tree <em>[42]</em> that computes to a public root value <em>[17]</em>. We use SHA-256 for the hash function. We implement it with a flat circuit where each sub-computation is one instance of the hash function. The consistency of the input and output of corresponding hashes are then checked by the circuit. There are <span class="math">2M-1</span> SHA256 invocations for a Merkle tree with <span class="math">M</span> leaves. We increase the number of leaves from 16 to 256. We use the SHA-256 implemented by jsnark <em>[4]</em> in R1CS format to run libSNARK and estimate Aurora, and we use the SHA-256 arithmetic circuit implemented by Hyrax to run Hyrax, Bulletproofs and Libra. We only show the performance of Ligero and libSTARK on the third benchmark.</p>

    <p class="text-gray-300">We report the prover time, proof size and verification time in Figure 1.</p>

    <p class="text-gray-300">Prover time. As shown in Figure 1(a)(b)(c), the prover in Libra is the fastest among all systems in all three benchmarks we tested. Ligero is one of the best existing ZKP systems on prover time as it is purely based on symmetric key operations. Comparing to Ligero, the prover time of Libra is <span class="math">1.15\\times</span> faster on a Merkle tree with 2 leaves and <span class="math">2\\times</span> faster with 256 leaves. Comparing to other systems, Libra improves the prover time by <span class="math">3.4-8.9\\times</span> vs. Hyrax, <span class="math">7.1-16.1\\times</span> vs. Aurora, <span class="math">10.1-12.4\\times</span> vs. libSTARK and <span class="math">13-33\\times</span> vs. Bulletproof.</p>

    <p class="text-gray-300">Libra is also faster than libSNARK on general circuits by <span class="math">5-10\\times</span>, as shown in Figure 1(a) and 1(b). The performance of Libra is comparable to libSNARK on Merkle trees in Figure 1(c). This is because (1) most values in the circuit of SHA256 are binary, which is friendly to the prover of libSNARK as the time of exponentiation is proportional to the bit-length of the values; (2) The R1CS of SHA256 is highly optimized by jsnark <em>[4]</em> and real world products like Zcash <em>[11]</em>. There are only 26,000 constrains in one hash. In the arithmetic circuit used by Libra, there are 60,000 gates with 38,000 of them being multiplication gates. Even so, Libra is still as fast as libSNARK on a Merkle tree with 2 leaves and <span class="math">2\\times</span> faster with 256 leaves. We plan to further optimize the implementation of SHA256 as an arithmetic circuit in the future.</p>

    <p class="text-gray-300">The gap between Libra and other systems will become bigger as the size of the circuit grows, as the prover time in these systems (other than Bulletproof) scales quasi-linearly with the circuit size. The evaluations justify that the prover time in Libra is both optimal asymptotically, and efficient in practice.</p>

    <p class="text-gray-300">Verification time. Figure 1(d)(e)(f) show the verification time. Our verifier is much slower than libSNARK and libSTARK, which runs in 1.8ms and 28-44ms respectively in all the benchmarks.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> (a)  <span class="math">\\mathcal{P}</span>  time: MatMul.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (b)  <span class="math">\\mathcal{P}</span>  time: 16x Lanczos</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> (c)  <span class="math">\\mathcal{P}</span>  time: Merkle tree</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> (d)  <span class="math">\\mathcal{V}</span>  time: MatMul.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> (e)  <span class="math">\\mathcal{V}</span>  time: 16x Lanczos</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> (f)  <span class="math">\\mathcal{V}</span>  time: Merkle tree</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> (g) Proof size: MatMul.</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> (h) Proof size: 16x Lanczos</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> (i) Proof size: Merkle tree</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> Figure 1: Comparisons of prover time, proof size and verification time between Libra and existing zero knowledge proof systems.</p>

    <p class="text-gray-300">Other than these two systems, the verification time of Libra is faster, as it grows sub-linearly with the circuit size. In particular, our verification time ranges from  <span class="math">0.08 - 1.15\\mathrm{s}</span>  in the benchmarks we consider. In Figure 1(f), the verification time of Libra is  <span class="math">8\\times</span>  slower than Aurora when  <span class="math">M = 2</span> , and  <span class="math">15\\times</span>  faster when  <span class="math">M = 256</span> . Libra is  <span class="math">2.5\\times</span>  slower than Ligero with  <span class="math">M = 2</span>  and  <span class="math">4\\times</span>  faster with  <span class="math">M = 256</span> . Comparing to Hyrax and Bulletproof, our verification is  <span class="math">1.2 - 9\\times</span>  and  <span class="math">3 - 100\\times</span>  faster respectively. Again, the gap increases with the scale of the circuits as our verification is succinct.</p>

    <p class="text-gray-300">Proof size. We report the proof size in Figure 1(g)(h)(i). Our proof size is much bigger than libSNARK, which is 128 bytes for all circuits, and Bulletproof, which ranges in  <span class="math">1.5 - 2\\mathrm{KBs}</span> . The proof size in Libra is in the range of 30-60KBs, except for the matrix multiplications where it reduces to  <span class="math">5 - 9\\mathrm{KBs}</span> . This is better than Aurora, Hyrax and libSTARK, which also have poly-logarithmic proof size to the circuit. Finally, the proof size in Ligero is  <span class="math">O(\\sqrt{C})</span>  and grows to several megabytes in practice.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Setup time.</h4>

    <p class="text-gray-300">Among all the systems, only Libra and libSNARK require trusted setup. Thanks to the optimization described in the beginning of this section, it only takes 202s to generate the public parameters in our largest instance with <span class="math">n=2^{24}</span>. Libra only needs to perform this setup once and it can be used for all benchmarks and all circuits with no more inputs. libSNARK requires a per-circuit setup. For example, it takes 1027s for the Merkle tree with 256 leaves, and takes 210s for <span class="math">64\\times 64</span> matrix multiplications.</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">5.3 Discussions</h3>

    <p class="text-gray-300">In this section, we discuss some potential improvements for Libra.</p>

    <p class="text-gray-300">Improving verification time. As shown in the experiments above, the verification time in Libra is already fast in practice compared to other systems, yet it can be further improved by 1-2 orders of magnitude.</p>

    <p class="text-gray-300">Within the verification of Libra, most of the time (more than 95% in the evaluations above) is spent on our zkVPD protocols using bilinear pairings. In our current protocol, we use the pairing-based zkVPD both for the input layer and for the masking polynomials <span class="math">g_{i},R_{i}</span> in each intermediate layer. Although the masking polynomials are small, the verification of our zkVPD still requires <span class="math">O(s_{i})</span> pairings per layer for <span class="math">g_{i}</span>, which is asymptotically the same as the input layer. For example, for the SHA256 circuit with 12 layers, the zkVPD verification of each <span class="math">g_{i}</span> is around 46ms, <span class="math">\\frac{1}{16}</span> of the total verification time.</p>

    <p class="text-gray-300">However, there are many zkVPD candidates for these masking polynomials. Recall that the size of <span class="math">g_{i}</span> is only <span class="math">O(s_{i})</span>, logarithmic on the size of the circuit. We could use any zkVPD with up to linear commitment size, prover time, proof size and verification time while still maintaining the asymptotic complexity of Libra. The only property we need is zero knowledge. Therefore, we can replace our pairing-based zkVPD with any of the zero knowledge proof systems we compare with as a black-box. Ligero and Aurora are of particular interest as their verification requires no cryptographic operations. If we use the black-box of these two systems for the zkVPD of <span class="math">g_{i},R_{i}</span>, the prover time and proof size would be affected minimally, and the verification time would be improved by almost <span class="math">d</span> times, as only the zkVPD of the input layer requires pairings after the change. This is a 1-2 orders-of-magnitude improvement depending on the depth of the circuit. In addition, it also removes the trusted setup in the zkVPD for the masking polynomials. We plan to integrate this approach into our system when the implementations of Ligero and Aurora become available.</p>

    <p class="text-gray-300">Removing trusted setup. After the change above, the only place that requires trusted setup is the zkVPD for the input layer. However, replacing our pairing-based zkVPD with other systems without trusted setup may affect the succinctness of our verification time on structured circuits. For example, using Ligero, Bulletproof and Aurora as a black-box would increase the verification time to <span class="math">O(n)</span>, and using Hyrax would increase the proof size and verification time to <span class="math">O(\\sqrt{n})</span>. Using libSTARK may keep the same complexity, as polynomial evaluation is a special function with short description, but the prover time and memory usage is high in STARK as shown in the experiments. Designing an efficient zkVPD protocol with logarithmic proof size and verification time without trusted setup is left as an interesting future work and we believe this paper serves as an important step towards the goal of efficient succinct zero knowledge proof without trusted setup.</p>

    <h2 id="sec-39" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">This material is in part based upon work supported by DARPA under Grant No. N66001-15-C-4066 and Center for Long-Term Cybersecurity (CLTC). Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of DARPA or CLTC. Charalampos Papamanthou’s work was supported by NSF grants #1652259 and #1514261 and by a NIST grant.</p>

    <h2 id="sec-40" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[2] The GNU multiple precision arithmetic library. https://gmplib.org/</li>

      <li>[3] Hyrax reference implementation. https://github.com/hyraxZK/hyraxZK</li>

      <li>[4] jsnark. https://github.com/akosba/jsnark</li>

      <li>[5] Libra implementation. https://github.com/sunblaze-ucb/Libra</li>

      <li>[6] libsnark. https://github.com/scipr-lab/libsnark</li>

      <li>[7] Ames, S., Hazay, C., Ishai, Y., Venkitasubramaniam, M.: Ligero: Lightweight sublinear arguments without a trusted setup. In: Proceedings of the ACM SIGSAC Conference on Computer and Communications Security (2017)</li>

      <li>[8] Baum, C., Bootle, J., Cerulli, A., Del Pino, R., Groth, J., Lyubashevsky, V.: Sub-linear lattice-based zero-knowledge arguments for arithmetic circuits. In: Annual International Cryptology Conference. pp. 669–699. Springer (2018)</li>

      <li>[9] Bayer, S., Groth, J.: Efficient zero-knowledge argument for correctness of a shuffle. In: Annual International Conference on the Theory and Applications of Cryptographic Techniques. pp. 263–280. Springer (2012)</li>

      <li>[10] Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint, 2018</li>

      <li>[11] Ben-Sasson, E., Chiesa, A., Garman, C., Green, M., Miers, I., Tromer, E., Virza, M.: Zerocash: Decentralized anonymous payments from bitcoin. In: Proceedings of the Symposium on Security and Privacy SP, 2014 (2014)</li>

      <li>[12] Ben-Sasson, E., Chiesa, A., Genkin, D., Tromer, E., Virza, M.: SNARKs for C: Verifying program executions succinctly and in zero knowledge. In: CRYPTO 2013</li>

      <li>[13] Ben-Sasson, E., Chiesa, A., Riabzev, M., Spooner, N., Virza, M., Ward, N.P.: Aurora: Transparent Succinct Arguments for R1CS. Cryptology ePrint, 2018</li>

      <li>[14] Ben-Sasson, E., Chiesa, A., Spooner, N.: Interactive oracle proofs. In: Theory of Cryptography Conference. pp. 31–60. Springer (2016)</li>

      <li>[15] Ben-Sasson, E., Chiesa, A., Tromer, E., Virza, M.: Succinct Non-Interactive Zero Knowledge for a von Neumann Architecture. In: Proceedings of the USENIX Security Symposium, 2014</li>

      <li>[16] Ben-Sasson, E., Chiesa, A., Tromer, E., Virza, M.: Scalable zero knowledge via cycles of elliptic curves. In: CRYPTO 2014, pp. 276–294 (2014)</li>

      <li>[17] Blum, M., Evans, W., Gemmell, P., Kannan, S., Naor, M.: Checking the correctness of memories. Algorithmica 12(2-3), 225–244 (1994)</li>

      <li>[18] Bünz, B., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., Maxwell, G.: Bulletproofs: Short proofs for confidential transactions and more. In: Proceedings of the Symposium on Security and Privacy (SP), 2018. vol. 00, pp. 319–338</li>

      <li>[19] Bootle, J., Cerulli, A., Chaidos, P., Groth, J., Petit, C.: Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In: International Conference on the Theory and Applications of Cryptographic Techniques (2016)</li>

      <li>[20] Bootle, J., Cerulli, A., Ghadafi, E., Groth, J., Hajiabadi, M., Jakobsen, S.K.: Linear-time zero-knowledge proofs for arithmetic circuit satisfiability. In: International Conference on the Theory and Application of Cryptology and Information Security. pp. 336–365. Springer (2017)</li>

      <li>[21] Braun, B., Feldman, A.J., Ren, Z., Setty, S.T.V., Blumberg, A.J., Walfish, M.: Verifying computations with state. In: ACM SIGOPS 24th Symposium on Operating Systems Principles, SOSP, 2013</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[22] Canetti, R., Chen, Y., Holmgren, J., Lombardi, A., Rothblum, G.N., Rothblum, R.D.: Fiat-shamir from simpler assumptions. Tech. rep., IACR Cryptology ePrint Archive, 2018: 1004 (2018)</li>

      <li>[23] Chase, M., Derler, D., Goldfeder, S., Orlandi, C., Ramacher, S., Rechberger, C., Slamanig, D., Zaverucha, G.: Post-quantum zero-knowledge and signatures from symmetric-key primitives. In: Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. pp. 1825–1842. ACM (2017)</li>

      <li>[24] Chiesa, A., Forbes, M.A., Spooner, N.: A Zero Knowledge Sumcheck and its Applications. CoRR abs/1704.02086 (2017), http://arxiv.org/abs/1704.02086</li>

      <li>[25] Cormode, G., Mitzenmacher, M., Thaler, J.: Practical Verified Computation with Streaming Interactive Proofs. In: Proceedings of the 3rd Innovations in Theoretical Computer Science Conference. ITCS ’12</li>

      <li>[26] Costello, C., Fournet, C., Howell, J., Kohlweiss, M., Kreuter, B., Naehrig, M., Parno, B., Zahur, S.: Geppetto: Versatile verifiable computation. In: S&P 2015</li>

      <li>[27] Cramer, R., Damgård, I.: Zero-knowledge proofs for finite field arithmetic, or: Can zero-knowledge be for free? In: Annual International Cryptology Conference, 1998</li>

      <li>[28] Fiat, A., Shamir, A.: How to prove yourself: Practical solutions to identification and signature problems. In: Conference on the Theory and Application of Cryptographic Techniques. pp. 186–194. Springer (1986)</li>

      <li>[29] Fiore, D., Fournet, C., Ghosh, E., Kohlweiss, M., Ohrimenko, O., Parno, B.: Hash first, argue later: Adaptive verifiable computations on outsourced data. In: Proceedings of the ACM SIGSAC Conference on Computer and Communications Security (2016)</li>

      <li>[30] Gennaro, R., Gentry, C., Parno, B., Raykova, M.: Quadratic span programs and succinct NIZKs without PCPs. In: EUROCRYPT 2013. pp. 626–645 (2013)</li>

      <li>[31] Giacomelli, I., Madsen, J., Orlandi, C.: Zkboo: Faster zero-knowledge for boolean circuits. In: USENIX Security Symposium. pp. 1069–1083 (2016)</li>

      <li>[32] Goldwasser, S., Kalai, Y.T., Rothblum, G.N.: Delegating Computation: Interactive Proofs for Muggles. J. ACM 62(4), 27:1–27:64 (Sep 2015)</li>

      <li>[33] Goldwasser, S., Micali, S., Rackoff, C.: The knowledge complexity of interactive proof systems. SIAM Journal on computing 18(1), 186–208 (1989)</li>

      <li>[34] Groth, J.: Linear algebra with sub-linear zero-knowledge arguments. In: Advances in Cryptology-CRYPTO 2009, pp. 192–208. Springer (2009)</li>

      <li>[35] Groth, J.: Short pairing-based non-interactive zero-knowledge arguments. In: International Conference on the Theory and Application of Cryptology and Information Security. pp. 321–340. Springer (2010)</li>

      <li>[36] Ishai, Y., Kushilevitz, E., Ostrovsky, R.: Efficient arguments without short pcps. In: 22nd Annual IEEE Conference on Computational Complexity (CCC 2007)</li>

      <li>[37] Ishai, Y., Kushilevitz, E., Ostrovsky, R., Sahai, A.: Zero-knowledge from secure multiparty computation. In: Proceedings of the annual ACM symposium on Theory of computing. pp. 21–30. ACM (2007)</li>

      <li>[38] Kilian, J.: A note on efficient zero-knowledge proofs and arguments (extended abstract). In: Proceedings of the ACM Symposium on Theory of Computing (1992)</li>

      <li>[39] Kosba, A., Miller, A., Shi, E., Wen, Z., Papamanthou, C.: Hawk: The blockchain model of cryptography and privacy-preserving smart contracts. In: Proceedings of Symposium on security and privacy (SP), 2016</li>

      <li>[40] Lipmaa, H.: Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In: Theory of Cryptography Conference (2012)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[41] Lund, C., Fortnow, L., Karloff, H., Nisan, N.: Algebraic Methods for Interactive Proof Systems. J. ACM 39(4), 859–868 (Oct 1992)</li>

      <li>[42] Merkle, R.C.: A digital signature based on a conventional encryption function. In: Conference on the theory and application of cryptographic techniques (1987)</li>

      <li>[43] Micali, S.: Computationally sound proofs. SIAM J. Comput. (2000)</li>

      <li>[44] Parno, B., Howell, J., Gentry, C., Raykova, M.: Pinocchio: Nearly practical verifiable computation. In: S&P 2013. pp. 238–252 (2013)</li>

      <li>[45] Thaler, J.: Time-Optimal Interactive Proofs for Circuit Evaluation. In: Canetti, R., Garay, J.A. (eds.) Advances in Cryptology – CRYPTO 2013 (2013)</li>

      <li>[46] Turkowski, K.: Filters for common resampling tasks. In: Graphics gems. pp. 147–165. Academic Press Professional, Inc. (1990)</li>

      <li>[47] Vu, V., Setty, S., Blumberg, A.J., Walfish, M.: A Hybrid Architecture for Interactive Verifiable Computation. In: Proceedings of the 2013 IEEE Symposium on Security and Privacy. SP ’13 (2013)</li>

      <li>[48] Wahby, R.S., Howald, M., Garg, S., Shelat, A., Walfish, M.: Verifiable asics. In: Security and Privacy (SP), 2016 IEEE Symposium on. pp. 759–778. IEEE (2016)</li>

      <li>[49] Wahby, R.S., Ji, Y., Blumberg, A.J., Shelat, A., Thaler, J., Walfish, M., Wies, T.: Full accounting for verifiable outsourcing. In: Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. ACM (2017)</li>

      <li>[50] Wahby, R.S., Setty, S.T., Ren, Z., Blumberg, A.J., Walfish, M.: Efficient ram and control flow in verifiable outsourced computation. In: NDSS (2015)</li>

      <li>[51] Wahby, R.S., Tzialla, I., Shelat, A., Thaler, J., Walfish, M.: Doubly-efficient zkSNARKs without trusted setup. In: 2018 IEEE Symposium on Security and Privacy (SP). pp. 926–943. IEEE (2018)</li>

      <li>[52] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: A Zero-Knowledge version of vSQL. Cryptology ePrint, 2017</li>

      <li>[53] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: vSQL: Verifying arbitrary SQL queries over dynamic outsourced databases. In: Security and Privacy (SP), 2017 IEEE Symposium on. pp. 863–880. IEEE (2017)</li>

      <li>[54] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: vRAM: Faster verifiable RAM with program-independent preprocessing. In: Proceeding of IEEE Symposium on Security and Privacy (S&P) (2018)</li>

    </ul>

    <p class="text-gray-300">A Condensing to One Point in Linear Time</p>

    <p class="text-gray-300">In this section, we present an algorithm to reduce two claims about <span class="math">\\tilde{V}_{i+1}</span> to one in linear time. Recall that as described in Section 2.3, in the <span class="math">i</span>-th layer, after the sumcheck, the verifier receives two claims <span class="math">\\tilde{V}(u),\\tilde{V}(v)</span>. (Again we omit the superscript and subscript of <span class="math">i</span> for the ease of interpretation.) She then defines a line <span class="math">\\gamma(x):\\mathbb{F}\\to\\mathbb{F}^{s}</span> such that <span class="math">\\gamma(0)=u,\\gamma(1)=v</span> and the prover needs to provide <span class="math">\\tilde{V}(\\gamma(x))</span>, a degree <span class="math">s</span> univariate polynomial, to <span class="math">\\mathcal{V}</span>. If the prover computes it naively, which was done in all prior papers, it incurs <span class="math">O(s2^{s})</span> time, as it is equivalent to evaluating <span class="math">\\tilde{V}()</span> at <span class="math">s+1</span> points.</p>

    <p class="text-gray-300">Algorithm 7 Compute <span class="math">\\tilde{V}(\\gamma(x))=\\sum_{y\\in\\{0,1\\}^{s}}I(\\gamma(x),y)\\tilde{V}(y)</span> 1: Initialize a binary tree <span class="math">T</span> with <span class="math">s</span> levels. We use <span class="math">T_{j}[b]</span> to denote the <span class="math">b</span>-th node at level <span class="math">j</span>. 2: for <span class="math">b\\in\\{0,1\\}^{s}</span> do 3: <span class="math">T_{s}[b]=\\tilde{V}(b)</span>. 4: Multiply <span class="math">T_{s}[b]</span> with <span class="math">b_{s}(c_{s}x+d_{s})+(1-b_{s})(1-c_{s}x-d_{s})</span>. 5: for <span class="math">j=s-1,\\ldots,1</span> do 6: for <span class="math">b\\in\\{0,1\\}^{j}</span> do 7: <span class="math">T_{j}[b]=T_{j+1}[b,0]+T_{j+1}[b,1]</span>. 8: <span class="math">T_{j}[b]=T_{j}[b]\\cdot(b_{j}(c_{j}x+d_{j})+(1-b_{j})(1-c_{j}x-d_{j}))</span>. 9: Output <span class="math">T_{1}[0]</span>.</p>

    <p class="text-gray-300">In our new algorithm, we write <span class="math">\\tilde{V}(\\gamma(x))=\\sum_{y\\in\\{0,1\\}^{s}}I(\\gamma(x),y)\\tilde{V}(y)</span>, where <span class="math">I(a,b)</span> is an identity polynomial <span class="math">I(a,b)=0</span> iff <span class="math">a=b</span>. This holds by inspection of both sides on the Boolean hypercube. We then evaluate the right side in linear time with a binary tree structure. The key observation is that the identity polynomial can be written as <span class="math">I(a,b)=\\prod_{j=1}^{s}(a_{j}b_{j}+(1-a_{j})(1-b_{j}))</span>, and we can process one variable <span class="math">(a_{j},b_{j})</span> at a time and multiply them together to get the final result.</p>

    <p class="text-gray-300">We construct a binary tree with <span class="math">2^{s}</span> leaves and initialize each leaf <span class="math">b\\in\\{0,1\\}^{s}</span> with <span class="math">\\tilde{V}(b)</span>. As <span class="math">\\gamma(x)</span> is a linear polynomial, we write it as <span class="math">\\gamma(x)=[c_{1},\\ldots,c_{s}]^{T}x+[d_{1},\\ldots,d_{s}]^{T}</span>. At the leaf level, we only consider the last variable of <span class="math">I(\\gamma(x),y)</span>. For each leaf <span class="math">b\\in\\{0,1\\}^{s}</span>, we multiply the value with <span class="math">b_{s}(c_{s}x+d_{s})+(1-b_{s})(1-c_{s}x-d_{s})</span>, the result of which is a linear polynomial. For a node <span class="math">b\\in\\{0,1\\}^{j}</span> in the intermediate level <span class="math">j</span>, we add the polynomials from its two children, and multiply it with <span class="math">b_{j}(c_{j}x+d_{j})+(1-b_{j})(1-c_{j}x-d_{j})</span>, the part in <span class="math">I</span> that corresponds to the <span class="math">j</span>-th variable. In this way, each node in the <span class="math">j</span>-th level stores a degree <span class="math">j</span> polynomial. Eventually, the root is the polynomial on the right side of degree <span class="math">s</span>, which equals to <span class="math">\\tilde{V}(\\gamma(x))</span>. The algorithm is given in Algorithm 7.</p>

    <p class="text-gray-300">To see the complexity of Algorithm 7, both the storage and the polynomial multiplication at level <span class="math">j</span> is <span class="math">O(s-j+1)</span> in each node. So the total time is <span class="math">O(\\sum_{j=1}^{s}2^{j}(s-j+1))=O(2^{s})</span>, which is linear to the number of gates in the layer.</p>

    <p class="text-gray-300">An alternative way to interpret this result is to add an additional layer for each layer of the circuit in GKR relaying the values. That is,</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(g)=\\sum_{x\\in\\{0,1\\}^{s_{i}}}I(g,x)\\tilde{V}_{i+1}(x),</span></p>

    <p class="text-gray-300">where <span class="math">\\tilde{V}_{i}=\\tilde{V}_{i+1}</span>. Then when using the random linear combination approach, the sumcheck is executed on</p>

    <p class="text-gray-300"><span class="math">\\alpha\\tilde{V}_{i}(u)+\\beta\\tilde{V}_{i}(v)=\\sum_{x\\in\\{0,1\\}^{s_{i}}}(\\alpha I(u,x)+\\beta I(v,x))\\tilde{V}_{i+1}(x).</span></p>

    <p class="text-gray-300">Algorithm 8 Committing and opening the multilinear extension of vector  <span class="math">\\mathbf{V}</span>  of size  <span class="math">2^{\\ell}</span> . 1: procedure pp  <span class="math">\\leftarrow</span>  KeyGen( <span class="math">\\ell, 1^{\\lambda}</span> ) 2: Select  <span class="math">\\alpha, t_1, t_2, \\ldots, t_\\ell \\in \\mathbb{F}</span>  randomly and run bp  <span class="math">\\leftarrow</span>  BilGen( <span class="math">1^{\\lambda}</span> ). 3: for  <span class="math">k = 1, \\ldots, \\ell</span>  do 4: for all  <span class="math">b \\in \\{0, 1\\}^k</span>  do 5: Compute  <span class="math">g\\prod_{i=1}^{k} \\chi_{b_i}(t_i), g^{\\alpha} \\prod_{i=1}^{k} \\chi_{b_i}(t_i)</span> 6:  <span class="math">\\mathsf{pp}_k = (g\\prod_{i=1}^{k} \\chi_{b_i}(t_i), g^{\\alpha} \\prod_{i=1}^{k} \\chi_{b_i}(t_i))</span>  for all  <span class="math">b \\in \\{0, 1\\}^k</span> . 7: Output pp = (pp1, ..., ppL). 8: procedure com  <span class="math">\\leftarrow</span>  Commit(pp, V) 9: Compute com = ( <span class="math">\\prod_{b \\in \\{0, 1\\}^\\ell} (g\\prod_{i=1}^{\\ell} \\chi_{b_i}(t_i))^{\\mathbf{V}[b]}</span> ,  <span class="math">\\prod_{b \\in \\{0, 1\\}^\\ell} (g^{\\alpha} \\prod_{i=1}^{\\ell} \\chi_{b_i}(t_i))^{\\mathbf{V}[b]}</span> ). 10: procedure (y, π)  <span class="math">\\leftarrow</span>  Open(V, u, pp) 11: Set  <span class="math">\\mathbf{R}_\\ell = \\mathbf{V}</span> 12: for  <span class="math">k = \\ell, \\ldots, 1</span>  do 13: Initialize two arrays  <span class="math">\\mathbf{Q}_k</span>  and  <span class="math">\\mathbf{R}_{k-1}</span>  of size  <span class="math">2^{k-1}</span> 14: for  <span class="math">b \\in \\{0, 1\\}^{k-1}</span>  do 15:  <span class="math">\\mathbf{Q}_k[b] = \\mathbf{R}_k[b, 1] - \\mathbf{R}_k[b, 0]</span> 16:  <span class="math">\\mathbf{R}_{k-1}[b] = \\mathbf{R}_k[b, 0] \\cdot (1 - u_k) + \\mathbf{R}_k[b, 1] \\cdot u_k</span> 17: Compute  <span class="math">\\pi_k = (\\prod_{b \\in \\{0, 1\\}^k} (g\\prod_{i=1}^{k} \\chi_{b_i}(t_i))^{\\mathbf{Q}_k[b]}</span> ,  <span class="math">\\prod_{b \\in \\{0, 1\\}^k} (g^{\\alpha} \\prod_{i=1}^{k} \\chi_{b_i}(t_i))^{\\mathbf{Q}_k[b]})</span> 18: Output  <span class="math">\\pi = (\\pi_1, \\ldots, \\pi_\\ell)</span> .</p>

    <p class="text-gray-300">At the end of the sumcheck, the verifier receives a single claim on  <span class="math">\\tilde{V}_{i + 1} = \\tilde{V}_i</span> . The sumcheck can obviously run in linear time, and the relay layers do not change the result of the circuit. This approach is actually the same as the condensing to one point in linear time above conceptually.</p>

    <p class="text-gray-300">Using the algorithms proposed in [54], given a multilinear polynomial, Commit and Open of our zkVPD protocol in Construction 3 take linear time. However, in our new zero knowledge proof protocol in 4, the prover commits to the multilinear extension of the input and the witness, and later opens to the evaluation of a random point. Converting an MLE to the corresponding multilinear polynomial in the form of coefficients takes quasi-linear field operations (the algorithm is analogous to fast Fourier transform). To achieve linear prover time for our ZKP protocol, we propose new algorithms to commit and open directly on MLE.</p>

    <p class="text-gray-300">Recall from Section 2.3 that an array  <span class="math">\\mathbf{V}</span>  of size  <span class="math">2^{\\ell}</span>  can be viewed as a function  <span class="math">V:\\{0,1\\}^{\\ell}\\to \\mathbb{F}</span>  such that  <span class="math">V(b) = \\mathbf{V}[b]</span> , and its MLE  <span class="math">\\tilde{V}</span>  can be expressed as</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde {V} (x _ {1}, x _ {2}, \\dots , x _ {\\ell}) = \\sum_ {b \\in \\{0, 1 \\} ^ {\\ell}} (\\prod_ {i = 1} ^ {\\ell} \\chi_ {b _ {i}} (x _ {i})) \\cdot V (b),</span></div>

    <p class="text-gray-300">where  <span class="math">\\chi_{b_i}(x_i) = (1 - b_i)(1 - x_i) + b_ix_i</span> . That is,  <span class="math">\\chi_{b_i}(x_i) = 1 - x_i</span>  if  <span class="math">b_{i} = 0</span>  and  <span class="math">\\chi_{b_i}(x_i) = x_i</span>  if  <span class="math">b_{i} = 1</span> . Therefore, to commit to an MLE, instead of generating pp as all the monomials of multilinear polynomials on the exponent, we compute the products of  <span class="math">\\chi_{b_i}</span>  on the exponent for all possible  <span class="math">b\\in \\{0,1\\} ^k</span>  for  <span class="math">k\\leq \\ell</span> . The new public parameters can either be computed from scratch in KeyGen, or be derived from the original pp in linear time. With the new public parameters, the commitment of an MLE can be computed in linear time simply by multiplying each public parameter with the corresponding element in the array.</p>

    <p class="text-gray-300">In addition, to open the polynomial to the evaluation of a point, the proofs can also be computed in linear time through a dynamic programming algorithm. We present the algorithms in Algorithm 8. For</p>

    <p class="text-gray-300">simplicity, we focus on the version without zero knowledge and only present KeyGen, Commit, Open that are modified. The rest of the algorithms remain the same, and it is straight forward to extend the scheme to a zkVPD using the same approach in Construction 3. In particular, in every iteration of Open, the prover divides the current polynomial by <span class="math">(x_{k}-u_{k})</span>. Because of the structure of MLE, all the elements with indices with least-significant-bit (LSB) <span class="math">0</span> are multiplied by <span class="math">1-x_{k}</span>, and with LSB <span class="math">1</span> are multiplied by <span class="math">x_{k}</span>. Moreover, two elements <span class="math">v_{0},v_{1}</span> with indices with the same prefix other than LSB are multiplied by the same polynomial, which is a term in the MLE with one less variable. Therefore, their contribution to the quotient polynomial is <span class="math">v_{1}-v_{0}</span>, and to the remainder polynomial is <span class="math">v_{0}(1-u_{k})+v_{1}u_{k}</span>. They are computed in Step 15 and 16 in Algorithm 8. Note that the quotient polynomial and the remainder polynomial are also MLEs of <span class="math">\\mathbf{Q}_{k}</span> and <span class="math">\\mathbf{R}_{k-1}</span>. Therefore, we can repeat the algorithm in the next iteration on <span class="math">\\mathbf{R}_{k-1}</span> recursively, and generate the proof <span class="math">\\pi_{k}</span> using the public parameter <span class="math">\\mathsf{pp}_{k}</span> and <span class="math">\\mathbf{Q}_{k}</span> in linear time to the size of the array in each iteration. As the size of the array is shrinking by half in each iteration, the total complexity of Open is also linear.</p>`;
---

<BaseLayout title="Libra: Succinct Zero-Knowledge Proofs with Optimal Prover Co... (2019/317)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/317
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
